[
    {
        "prompt": "### Task Description:\nYou are an experienced software engineer skilled in API usage analysis. Your task is to analyze the following C/C++ code snippet and summarize the core API usage patterns for 'TIFFReadDirectory', focusing on:\n- API functionality\n- Typical usage\n- Key parameters\n- Return values\n- Error handling\n- Best practices\nProvide a concise and structured response.\n\n### Provided Code Snippet:\n```c\nstatic int DLL_CALLCONV\nPageCount(FreeImageIO *io, fi_handle handle, void *data) {\n\tif(data) {\n\t\tfi_TIFFIO *fio = (fi_TIFFIO*)data;\n\t\tTIFF *tif = (TIFF *)fio->tif;\n\t\tint nr_ifd = 0;\n\n\t\tdo {\n\t\t\tnr_ifd++;\n\t\t} while (TIFFReadDirectory(tif));\n\t\t\t\t\n\t\treturn nr_ifd;\n\t}\n\n\treturn 0;\n}\n```\n",
        "response": "### Core API Usage Summary for `TIFFReadDirectory`\n\n#### **API Functionality**  \n`TIFFReadDirectory` advances to the next Image File Directory (IFD) in a TIFF file. Each IFD typically represents a page/image in a multi-page TIFF. Used to traverse all pages in the file.\n\n#### **Typical Usage**  \n- Called in a loop to count or process all pages in a TIFF file.  \n- Example from code:  \n  ```c\n  do { \n    nr_ifd++; \n  } while (TIFFReadDirectory(tif)); // Loop until no more directories\n  ```\n\n#### **Key Parameters**  \n- `TIFF *tif`: Pointer to the open TIFF file handle (critical for context).\n\n#### **Return Values**  \n- **Non-zero (1)**: Successfully advanced to the next directory.  \n- **Zero (0)**: No more directories or an error occurred (requires further checks to distinguish).\n\n#### **Error Handling**  \n- **Limitation in Provided Code**: Does not differentiate between end-of-directories and errors.  \n- **Best Practice**: After the loop, verify if the end was reached cleanly using `TIFFLastDirectory(tif)` (returns 1 if the last directory was processed successfully, 0 otherwise).  \n  Example fix:  \n  ```c\n  int is_last = TIFFLastDirectory(tif);\n  if (!is_last) { /* Handle error */ }\n  ```\n\n#### **Best Practices**  \n1. **Error Differentiation**: Use `TIFFLastDirectory` post-loop to confirm termination was due to end-of-file, not an error.  \n2. **State Management**: Ensure the TIFF handle (`tif`) is properly opened/initialized before calling `TIFFReadDirectory`.  \n3. **Multi-threading**: TIFF handles are not thread-safe; synchronize access if used concurrently.  \n4. **Resource Cleanup**: Close the TIFF handle with `TIFFClose(tif)` after processing.  \n\n#### **Code Snippet Analysis**  \n- The provided code counts directories but does not handle errors. Adding `TIFFLastDirectory` checks would improve robustness.  \n- Assumes `TIFFReadDirectory` failures are only due to end-of-file, which might not always hold true."
    },
    {
        "prompt": "### Task Description:\nYou are an experienced software engineer skilled in API usage analysis. Your task is to analyze the following C/C++ code snippet and summarize the core API usage patterns for 'TIFFReadDirectory', focusing on:\n- API functionality\n- Typical usage\n- Key parameters\n- Return values\n- Error handling\n- Best practices\nProvide a concise and structured response.\n\n### Provided Code Snippet:\n```c\nvoid LavaVu::readVolumeTIFF(const FilePath& fn)\n{\n#ifdef HAVE_LIBTIFF\n  TIFF* tif = TIFFOpen(fn.full.c_str(), \"r\");\n  if (tif)\n  {\n    unsigned int width, height;\n    size_t npixels;\n    int channels = 4;\n    GLubyte* imageData;\n    int count = 0;\n    TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n    TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n    npixels = width * height;\n    imageData = (GLubyte*)_TIFFmalloc(npixels * channels * sizeof(GLubyte));\n    if (imageData)\n    {\n      json volss = session.global(\"volsubsample\");\n      int d = TIFFNumberOfDirectories(tif);\n      int ds = volss[2];\n      if (d > 1) std::cout << \"TIFF contains \" << d << \" pages, sub-sampling z \" << ds << std::endl;\n      do\n      {\n        if (TIFFReadRGBAImage(tif, width, height, (uint32_t*)imageData, 0))\n        {\n          //Subsample\n          if (count % ds != 0) {count++; continue;}\n          readVolumeSlice(fn.base, imageData, width, height, channels, true);\n        }\n        count++;\n      }\n      while (TIFFReadDirectory(tif));\n      _TIFFfree(imageData);\n    }\n    TIFFClose(tif);\n  }\n#else\n  abort_program(\"Require libTIFF to load TIFF images\\n\");\n#endif\n}\n```\n",
        "response": "### Core API Usage Summary for `TIFFReadDirectory`:\n\n#### **API Functionality**  \n`TIFFReadDirectory` advances to the next directory (page) in a multi-page TIFF file. It enables iterative processing of all images/directories within the file.\n\n---\n\n#### **Typical Usage**  \nUsed in a loop to process multi-page TIFFs:  \n```c\ndo {\n  // Process current directory (e.g., TIFFReadRGBAImage)\n} while (TIFFReadDirectory(tif)); // Advance to next directory\n```\nThe loop starts with the first directory (already opened via `TIFFOpen`) and iterates until no more directories exist.\n\n---\n\n#### **Key Parameters**  \n- `TIFF* tif`: A handle to the opened TIFF file.  \n*(No additional parameters required for basic usage.)*\n\n---\n\n#### **Return Values**  \n- **`1` (true)**: Successfully advanced to the next directory.  \n- **`0` (false)**: No more directories or an error occurred.  \n\n---\n\n#### **Error Handling**  \n- **Implicit Handling in Code**: The loop exits on `0`, treating both end-of-file and errors identically.  \n- **Limitation**: Errors (e.g., corrupt directories) are not explicitly checked. Best practice would use `TIFFGetError` or `TIFFGetField` for detailed error diagnostics.  \n\n---\n\n#### **Best Practices**  \n1. **Loop Structure**: Use a `do-while` loop to ensure the first directory is processed before advancing.  \n2. **Resource Management**: Pair with `TIFFClose` and `_TIFFfree` to avoid leaks.  \n3. **Error Checking**: Add explicit error checks (e.g., `TIFFGetError`) to distinguish between normal termination and failures.  \n4. **Validation**: Verify consistency between `TIFFNumberOfDirectories` and actual directory reads.  \n5. **Multi-threading**: Avoid concurrent access to the same `TIFF*` handle.  \n\n---\n\n**Code Example Notes**:  \n- The provided code uses `TIFFReadDirectory` to process volumetric TIFF slices with optional subsampling.  \n- Missing explicit error checks for `TIFFReadDirectory` could mask issues like corrupted intermediate directories."
    },
    {
        "prompt": "### Task Description:\nYou are an experienced software engineer skilled in API usage analysis. Your task is to analyze the following C/C++ code snippet and summarize the core API usage patterns for 'TIFFReadDirectory', focusing on:\n- API functionality\n- Typical usage\n- Key parameters\n- Return values\n- Error handling\n- Best practices\nProvide a concise and structured response.\n\n### Provided Code Snippet:\n```c\nEerIO::EerIO(const string & fname, IOMode rw, Decoder &dec)\n:\tImageIO(fname, rw), decoder(dec)\n{\n\tTIFFSetWarningHandler(TIFFOutputWarning);\n\n\ttiff_file = TIFFOpen(filename.c_str(), \"r\");\n\n\tauto acquisition_metadata = read_acquisition_metadata(tiff_file);\n\tacquisition_data_dict = parse_acquisition_data(acquisition_metadata);\n\n\tfor( ; TIFFReadDirectory(tiff_file); )\n\t\tnum_frames = TIFFCurrentDirectory(tiff_file) + 1;\n\n}\n```\n",
        "response": "### Core API Usage Analysis: `TIFFReadDirectory`\n\n#### **API Functionality**\n- **Purpose**: Reads the next directory (image frame) in a TIFF file, advancing the internal file pointer to the next directory.\n- **Scope**: Part of the LibTIFF library for handling multi-image TIFF files.\n\n#### **Typical Usage**\n- **Looping Through Directories**: Used in loops to iterate over all directories (frames) in a TIFF file, as seen in:\n  ```c\n  for( ; TIFFReadDirectory(tiff_file); )\n    num_frames = TIFFCurrentDirectory(tiff_file) + 1;\n  ```\n- **Frame Counting**: Determines the total number of frames by incrementing `TIFFCurrentDirectory` until no more directories exist.\n\n#### **Key Parameters**\n- **`TIFF *tif`**: A pointer to an open TIFF file handle (e.g., `tiff_file` in the snippet).\n\n#### **Return Values**\n- **`1`**: Success (next directory read).\n- **`0`**: No more directories (loop termination).\n- **`-1`**: Error during directory read (not explicitly handled in the snippet).\n\n#### **Error Handling**\n- **Weakness in Snippet**: The code treats all non-zero returns as success, potentially ignoring errors (e.g., `-1`). This could lead to incorrect frame counts or silent failures.\n- **Best Practice**: Explicitly check for errors:\n  ```c\n  int ret;\n  while ((ret = TIFFReadDirectory(tiff_file)) == 1) { ... }\n  if (ret == -1) { /* Handle error */ }\n  ```\n\n#### **Best Practices**\n1. **Error Checking**: Always validate return values to distinguish between EOF (`0`) and errors (`-1`).\n2. **Rewind After Enumeration**: Use `TIFFSetDirectory(tiff_file, 0)` to reset to the first directory after counting frames, ensuring subsequent operations start from the beginning.\n3. **Combine with `TIFFCurrentDirectory`**: Track the current directory index (0-based) for accurate frame counting.\n4. **Robust Logging**: Integrate with `TIFFSetWarningHandler`/`TIFFSetErrorHandler` to capture warnings/errors (as done with `TIFFOutputWarning` in the snippet).\n\n#### **Code Snippet Insights**\n- The loop counts frames by incrementing `num_frames` until `TIFFReadDirectory` returns `0`.\n- **Weakness**: Errors (`-1`) are treated as end-of-file, potentially undercounting frames or missing errors."
    },
    {
        "prompt": "### Task Description:\nYou are an experienced software engineer skilled in API usage analysis. Your task is to analyze the following C/C++ code snippet and summarize the core API usage patterns for 'TIFFReadDirectory', focusing on:\n- API functionality\n- Typical usage\n- Key parameters\n- Return values\n- Error handling\n- Best practices\nProvide a concise and structured response.\n\n### Provided Code Snippet:\n```c\nbool tImageTIFF::Load(const tString& tiffFile)\n{\n\tClear();\n\n\tif (tSystem::tGetFileType(tiffFile) != tSystem::tFileType::TIFF)\n\t\treturn false;\n\n\tif (!tFileExists(tiffFile))\n\t\treturn false;\n\n\tTIFF* tiff = TIFFOpen(tiffFile.Chr(), \"rb\");\n\tif (!tiff)\n\t\treturn false;\n\n\t// Create all frames.\n\ttPixelFormat srcFormat = tPixelFormat::R8G8B8A8;\n\tdo\n\t{\n\t\tint width = 0; int height = 0;\n\t\tTIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, &width);\n\t\tTIFFGetField(tiff, TIFFTAG_IMAGELENGTH, &height);\n\t\tif ((width <= 0) || (height <= 0))\n\t\t\tbreak;\n\n\t\tint numPixels = width*height;\n\t\tint durationMilliSeconds = ReadSoftwarePageDuration(tiff);\n\n\t\tuint32* pixels = (uint32*)_TIFFmalloc(numPixels * sizeof(uint32));\n\t\tint successCode = TIFFReadRGBAImage(tiff, width, height, pixels, 0);\n\t\tif (!successCode)\n\t\t{\n\t\t\t_TIFFfree(pixels);\n\t\t\tbreak;\n\t\t}\n\n\t\ttFrame* frame = new tFrame;\n\t\tframe->Width = width;\n\t\tframe->Height = height;\n\t\tframe->Pixels = new tPixel4b[width*height];\n\t\tframe->PixelFormatSrc = srcFormat;\n\n\t\t// If duration not set we use a default of 1 second.\n\t\tframe->Duration = (durationMilliSeconds >= 0) ? float(durationMilliSeconds)/1000.0f : 1.0f;\n\n\t\tfor (int p = 0; p < width*height; p++)\n\t\t\tframe->Pixels[p] = pixels[p];\n\n\t\t_TIFFfree(pixels);\n\t\tFrames.Append(frame);\n\t} while (TIFFReadDirectory(tiff));\n\n\tTIFFClose(tiff);\n\tif (Frames.GetNumItems() == 0)\n\t\treturn false;\n\n\tPixelFormatSrc = srcFormat;\n\tPixelFormat = tPixelFormat::R8G8B8A8;\n\n\t// TIFF files are assumed to be in sRGB.\n\tColourProfileSrc = tColourProfile::sRGB;\n\tColourProfile = tColourProfile::sRGB;\n\n\treturn true;\n}\n```\n",
        "response": "### Core API Usage Patterns for `TIFFReadDirectory`\n\n#### **API Functionality**  \n`TIFFReadDirectory` advances to the next directory (image frame) in a multi-page TIFF file. It enables processing of multi-frame TIFFs by iterating through each stored image directory.\n\n---\n\n#### **Typical Usage**  \n- Used in a **loop** (`do-while` in the snippet) to read all frames in a TIFF file.  \n- Called **after processing the current directory** to move to the next one.  \n- First directory is read by `TIFFOpen`; subsequent directories are handled by `TIFFReadDirectory`.\n\n---\n\n#### **Key Parameters**  \n- **`TIFF* tiff`**: Pointer to the opened TIFF file handle (initialized via `TIFFOpen`).\n\n---\n\n#### **Return Values**  \n- **`1` (true)**: Successfully advanced to the next directory.  \n- **`0` (false)**: No more directories (end of file) or an error occurred.\n\n---\n\n#### **Error Handling**  \n- The code treats a `0` return as the end of directories, but **does not distinguish between errors and natural termination**.  \n- Best practice: Use `TIFFGetErrorHandler` to log errors or validate directory integrity (e.g., via `TIFFCheckDirectory`).  \n- The snippet implicitly checks for failure by exiting the loop and verifying if frames were loaded (`Frames.GetNumItems() == 0`).\n\n---\n\n#### **Best Practices**  \n1. **Loop Structure**: Use `do-while` to process at least one directory (ensuring compatibility with single-frame TIFFs).  \n2. **Resource Management**: Free allocated memory (e.g., `_TIFFfree`) even if intermediate directory reads fail.  \n3. **Validation**: Check directory metadata (e.g., `TIFFTAG_IMAGEWIDTH`, `TIFFTAG_IMAGELENGTH`) in each iteration.  \n4. **Error Detection**: Integrate error handlers to differentiate between end-of-file and read failures.  \n5. **Multi-frame Support**: Handle varying pixel formats/dimensions across directories (not done in the snippet, which assumes uniformity).\n\n---\n\n### Summary  \n`TIFFReadDirectory` is critical for multi-frame TIFF processing. Its usage in loops requires careful error handling and validation to ensure robustness, especially when dealing with heterogeneous directories."
    },
    {
        "prompt": "### Task Description:\nYou are an experienced software engineer skilled in API usage analysis. Your task is to analyze the following C/C++ code snippet and summarize the core API usage patterns for 'TIFFReadDirectory', focusing on:\n- API functionality\n- Typical usage\n- Key parameters\n- Return values\n- Error handling\n- Best practices\nProvide a concise and structured response.\n\n### Provided Code Snippet:\n```c\nvoid TiffIO::init()\n{\n\tENTERFUNC;\n\n\tif (initialized) {\n\t\treturn;\n\t}\n\n\tinitialized = true;\n\n\tbool is_new_file = false;\n\n\tFILE * tmp_in = sfopen(filename, rw_mode, & is_new_file, true);\n\n\tif (! tmp_in) {\n\t\tthrow ImageReadException(filename, \"open TIFF\");\n\t}\n\n\tif (! is_new_file) {\n\t\tchar buf[64];\n\n\t\tif (fread(buf, sizeof(buf), 1, tmp_in) != 1) {\n\t\t\tthrow ImageReadException(filename, \"first block\");\n\t\t}\n\n\t\tif (!is_valid(&buf)) {\n\t\t\tthrow ImageReadException(filename, \"invalid TIFF\");\n\t\t}\n\n        is_big_endian = (buf[0] == TIFF_BIG_ENDIAN);\n\t}\n\n\tfclose(tmp_in);\n\ttmp_in = 0;\n\n\tTIFFSetWarningHandler(0);\n\n\tif (rw_mode == ImageIO::READ_ONLY) {\n\t\ttiff_file = TIFFOpen(filename.c_str(), \"r\");\n\n\t\tif (! tiff_file) {\n\t\t\tthrow ImageReadException(filename, \"open TIFF\");\n\t\t}\n\n\t\tTIFFGetField(tiff_file, TIFFTAG_BITSPERSAMPLE, &bitspersample);\n\n\t\tif (bitspersample != CHAR_BIT &&\n\t\t\tbitspersample != (CHAR_BIT * sizeof(short)) &&\n\t\t\tbitspersample != (CHAR_BIT * sizeof(float)) ) {\n\n\t\t\tchar desc[256];\n\t\t\tsprintf(desc, \"invalid %d bits. only %d-bit and %d-bit TIFF are supported\",\n\t\t\t\t\tbitspersample, CHAR_BIT, (int)(CHAR_BIT * sizeof(short)));\n\t\t\tthrow ImageReadException(filename, desc);\n\t\t}\n\t}\n\telse {\n\t\ttiff_file = TIFFOpen(filename.c_str(), \"w\");\n\n\t\tif (! tiff_file) {\n\t\t\tthrow ImageReadException(filename, \"open TIFF\");\n\t\t}\n\t}\n\n\tif (tiff_file) {\n\t\tnimg = 0;\n\n\t\tdo {\n\t\t\tnimg++;\n\t\t} while (TIFFReadDirectory(tiff_file));\n\t}\n\n\tEXITFUNC;\n}\n```\n",
        "response": "### Core API Usage Summary for `TIFFReadDirectory`\n\n#### **API Functionality**  \n`TIFFReadDirectory` iterates through a multi-directory TIFF file, advancing to the next directory (image) in the sequence. It is used to process multi-image TIFF files.\n\n---\n\n#### **Typical Usage**  \n- **Looping through directories**:  \n  ```c\n  do {\n    nimg++;\n  } while (TIFFReadDirectory(tiff_file));\n  ```  \n  Used in a `do-while` loop to count all images (`nimg`) by advancing through directories until exhaustion.\n\n---\n\n#### **Key Parameters**  \n- **`TIFF* tiff_file`**: A handle to an open TIFF file (initialized via `TIFFOpen`).  \n  Example: `TIFFReadDirectory(tiff_file)`.\n\n---\n\n#### **Return Values**  \n- **`1` (true)**: Successfully advanced to the next directory.  \n- **`0` (false)**: No more directories or an error occurred.  \n\n---\n\n#### **Error Handling**  \n- **No explicit error checks**: The provided code assumes `0` implies end-of-directories, not errors.  \n- **Risk**: Errors (e.g., corrupt directory) may terminate the loop prematurely without logging.  \n- **Best Practice**: Post-loop validation using `TIFFGetLastError` to distinguish between normal termination and errors.  \n\n---\n\n#### **Best Practices**  \n1. **Error Differentiation**:  \n   After the loop, verify termination reason:  \n   ```c\n   if (TIFFGetLastError() != 0) { /* Handle error */ }\n   ```  \n2. **Directory Reset**:  \n   Use `TIFFSetDirectory(tiff_file, 0)` to reset to the first directory after counting.  \n3. **Validate Open Mode**: Ensure the file is opened in `READ_ONLY` mode (`\"r\"`) for directory traversal.  \n4. **Avoid Silent Failures**: Log warnings/errors if `TIFFReadDirectory` fails unexpectedly.  \n\n---\n\n### Summary  \n`TIFFReadDirectory` enables traversal of TIFF directories, but robust implementations should:  \n- Handle errors explicitly.  \n- Validate file state and mode.  \n- Reset directory pointers if further processing is needed."
    },
    {
        "prompt": "### Task Description:\nYou are an experienced software engineer skilled in API usage analysis. Your task is to analyze the following C/C++ code snippet and summarize the core API usage patterns for 'TIFFReadDirectory', focusing on:\n- API functionality\n- Typical usage\n- Key parameters\n- Return values\n- Error handling\n- Best practices\nProvide a concise and structured response.\n\n### Provided Code Snippet:\n```c\nvoid Compute(OpKernelContext* context) override {\n    const Tensor* input_tensor;\n    OP_REQUIRES_OK(context, context->input(\"input\", &input_tensor));\n\n    std::istringstream input_stream(input_tensor->scalar<tstring>()(),\n                                    std::ios_base::in | std::ios_base::binary);\n\n    std::unique_ptr<TIFF, void (*)(TIFF*)> tiff(\n        XTIFFStreamOpen(\"memory\", &input_stream), [](TIFF* p) {\n          if (p != nullptr) {\n            XTIFFClose(p);\n          }\n        });\n    OP_REQUIRES(context, (tiff.get() != nullptr),\n                errors::InvalidArgument(\"unable to open TIFF from memory\"));\n\n    std::vector<TensorShape> shape;\n    std::vector<DataType> dtype;\n    do {\n      unsigned int height, width;\n      TIFFGetField(tiff.get(), TIFFTAG_IMAGELENGTH, &height);\n      TIFFGetField(tiff.get(), TIFFTAG_IMAGEWIDTH, &width);\n\n      unsigned short channels;\n      TIFFGetField(tiff.get(), TIFFTAG_SAMPLESPERPIXEL, &channels);\n\n      shape.push_back(\n          TensorShape({static_cast<int64>(height), static_cast<int64>(width),\n                       static_cast<int64>(channels)}));\n\n      unsigned short format, bits;\n      if (!TIFFGetField(tiff.get(), TIFFTAG_SAMPLEFORMAT, &format)) {\n        // If format is not defined, then we assume format is SAMPLEFORMAT_UINT\n        format = SAMPLEFORMAT_UINT;\n      }\n      TIFFGetField(tiff.get(), TIFFTAG_BITSPERSAMPLE, &bits);\n      DataType pixel_dtype;\n      switch (format) {\n        case SAMPLEFORMAT_UINT:\n          switch (bits) {\n            case 8:\n              pixel_dtype = DT_UINT8;\n              break;\n            case 16:\n              pixel_dtype = DT_UINT16;\n              break;\n            default:\n              OP_REQUIRES(context, false,\n                          errors::InvalidArgument(\"unsupported bits \", bits,\n                                                  \" for uint\"));\n          }\n          break;\n        case SAMPLEFORMAT_INT:\n          switch (bits) {\n            default:\n              OP_REQUIRES(context, false,\n                          errors::InvalidArgument(\"unsupported bits \", bits,\n                                                  \" for int\"));\n          }\n          break;\n        case SAMPLEFORMAT_IEEEFP:\n          switch (bits) {\n            case 16:\n              pixel_dtype = DT_HALF;\n              break;\n            default:\n              OP_REQUIRES(context, false,\n                          errors::InvalidArgument(\"unsupported bits \", bits,\n                                                  \" for fp\"));\n          }\n          break;\n        default:\n          OP_REQUIRES(context, false,\n                      errors::InvalidArgument(\"unsupported format \", format));\n      }\n      dtype.push_back(pixel_dtype);\n\n      // GeoTIFF specifi information\n      // std::unique_ptr<GTIF, void(*)(GTIF*)> gtif(GTIFNew(tiff.get()),\n      // [](GTIF* p) { if (p != nullptr) { GTIFFree(p); } });\n      // OP_REQUIRES(context, (gtif.get() != nullptr),\n      // errors::InvalidArgument(\"unable to read GeoTIFF information\"));\n      // GTIFPrint(gtif,0,0);\n    } while (TIFFReadDirectory(tiff.get()));\n\n    Tensor* shape_tensor = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(\n                       0, TensorShape({static_cast<int64>(shape.size()), 3}),\n                       &shape_tensor));\n    for (size_t i = 0; i < shape.size(); i++) {\n      shape_tensor->flat<int64>()(i * 3) = shape[i].dim_size(0);\n      shape_tensor->flat<int64>()(i * 3 + 1) = shape[i].dim_size(1);\n      shape_tensor->flat<int64>()(i * 3 + 2) = shape[i].dim_size(2);\n    }\n    Tensor* dtype_tensor = nullptr;\n    OP_REQUIRES_OK(\n        context,\n        context->allocate_output(\n            1, TensorShape({static_cast<int64>(dtype.size())}), &dtype_tensor));\n    for (size_t i = 0; i < dtype.size(); i++) {\n      dtype_tensor->flat<int64>()(i) = dtype[i];\n    }\n  }\n```\n",
        "response": "### Core API Usage Patterns for `TIFFReadDirectory`\n\n#### **API Functionality**  \n`TIFFReadDirectory` is part of the libtiff library and advances the TIFF file handle to the next directory (image/page) in a multi-page TIFF file. It enables sequential traversal of embedded images in a TIFF file.\n\n---\n\n#### **Typical Usage**  \nUsed in a loop to process multi-page TIFF files:  \n```c\ndo {\n  // Process current directory (e.g., read tags like width, height)\n} while (TIFFReadDirectory(tiff_handle));\n```\n\n---\n\n#### **Key Parameters**  \n- **`tiff_handle`** (`TIFF*`): Pointer to an open TIFF file object (initialized via `XTIFFOpen` or similar).\n\n---\n\n#### **Return Values**  \n- **`1`**: Successfully advanced to the next directory.\n- **`0`**: No more directories to read or an error occurred (end-of-file or corruption).\n\n---\n\n#### **Error Handling**  \n- The provided code **does not explicitly check for errors** when `TIFFReadDirectory` returns `0`. This risks silently ignoring corrupted files.  \n- **Best Practice**: Use `TIFFGetError` to distinguish between end-of-file and actual errors after a `0` return:  \n  ```c\n  if (TIFFReadDirectory(tiff_handle) == 0) {\n    if (!TIFFAtEnd(tiff_handle)) { // Check if error occurred\n      OP_REQUIRES(context, false, errors::Internal(\"TIFFReadDirectory failed\"));\n    }\n  }\n  ```\n\n---\n\n#### **Best Practices**  \n1. **Multi-Page Support**: Always use `TIFFReadDirectory` in a loop to handle multi-page TIFFs.  \n2. **Error Checking**: Explicitly validate if `0` indicates end-of-file or an error.  \n3. **Resource Management**: Use RAII wrappers (e.g., `std::unique_ptr` with a custom deleter, as in the code) to ensure `XTIFFClose` is called.  \n4. **Tag Validation**: Check critical tags (e.g., `TIFFTAG_IMAGEWIDTH`, `TIFFTAG_SAMPLESPERPIXEL`) for validity during directory traversal.  \n\n---\n\n### Summary  \n`TIFFReadDirectory` is critical for processing multi-page TIFF files. The code demonstrates its typical loop-based usage but lacks explicit error differentiation. Proper error handling and resource cleanup (via RAII) are essential for robustness."
    },
    {
        "prompt": "### Task Description:\nYou are an experienced software engineer skilled in API usage analysis. Your task is to analyze the following C/C++ code snippet and summarize the core API usage patterns for 'TIFFReadDirectory', focusing on:\n- API functionality\n- Typical usage\n- Key parameters\n- Return values\n- Error handling\n- Best practices\nProvide a concise and structured response.\n\n### Provided Code Snippet:\n```c\nint imageIO::readTiff(){\n  TIFF * image;\n  uint width, height, depth, planesize;\n  uint offset = 0;\n  int unit;\n\n  // Open the TIFF image\n  image = TIFFOpen(filename.c_str(), \"r\");\n\n  // Find the width and height of the image\n  TIFFGetField(image, TIFFTAG_IMAGEWIDTH, &width);\n  TIFFGetField(image, TIFFTAG_IMAGELENGTH, &height);\n  depth = getTiffCount();\n\n  img.height = height;\n  img.width  = width;\n  img.depth  = depth;\n  img.image_stack = (uchar *) malloc (height * width * depth * sizeof(uchar));\n\n  if (img.image_stack == NULL){\n    cerr << \"Error, could not allocate enough memory for image stack.\\n\";\n    return 0;\n  }\n\n  TIFFGetField(image, TIFFTAG_RESOLUTIONUNIT, &unit);\n  TIFFGetField(image, TIFFTAG_XRESOLUTION, &img.xy_dist);\n\n  if (unit == RESUNIT_CENTIMETER){\n    /*\n     * divide by 10,000 to convert from centimeters to microns\n     * take inverse to get microns/pixel\n     */\n    img.xy_dist = (1 / (img.xy_dist / 10000));\n  }else if (unit == RESUNIT_INCH){\n    // divide by 24,500 to convert from inches to microns \n    img.xy_dist = (1 / (img.xy_dist / 25400));\n  }\n  \n  planesize = height * width;\n\n  if (image != NULL) {\n\n    uint bufsize= TIFFStripSize(image);\n    uchar * buf = (uchar *) _TIFFmalloc(bufsize);\n    uint s, ns  = TIFFNumberOfStrips(image);\n    uint *bytecounts;\n\n    do {\n      \n      TIFFGetField(image, TIFFTAG_STRIPBYTECOUNTS, &bytecounts);\n      for (s = 0; s < ns; s++) {\n\t\n\t// check to see if we need to resize the buffer\n\tif (bytecounts[s] != (uint)bufsize){\n\t  buf = (uchar *)_TIFFrealloc(buf, bytecounts[s]);\n\t  if (!buf){\n\t    return 0;\n\t  }\n\t  bufsize = bytecounts[s];\n\t}\n\t\n\t// try to read the strip\n\tif (TIFFReadRawStrip(image, s, buf, bytecounts[s]) < 0){\n\t  // if we encounter an error, free the buffer and return\n\t  _TIFFfree(buf);\n\t  return 0;\n\t}else{\n\t  memcpy(&img.image_stack[offset], buf, (bufsize * sizeof(uchar)));\n\t  offset += bufsize;\n\t}\n      }\n      \n    } while (TIFFReadDirectory(image));\n    _TIFFfree(buf);\n  }\n\n  /*\n    // DEBUG\n    tstrip_t strip;\n    uint32* bc;\n    \n    TIFFGetField(image, TIFFTAG_STRIPBYTECOUNTS, &bc);\n\n      \n    int cnt = 0;\n\n\n    do {\n      cout << \"strip byte counts: \" << bc[cnt++] << endl;\n\n      // Read the image into the memory buffer\n      if(TIFFReadRGBAStrip(image, 0, raster) == 0){\n\tfprintf(stderr, \"Could not read image\\n\");\n\treturn 0;\n      }\n\n      for (i = 0; i < planesize; ++i){\n\timg.image_stack[offset + i] = ((uchar) TIFFGetR(raster[i]));\n      }\n      offset += planesize;\n\n      cout << \"raster[\" << offset - 1 << \"] = \" << TIFFGetR(raster[offset - 1]) << endl;      \n      printf(\"img[%i] = %i\\n\", offset - 1, img.image_stack[offset - 1]);\n\n    } while (TIFFReadDirectory(image));\n\n    free(raster);\n    (void) TIFFClose(image);\n  }\n  */\n  return 1;\n}\n```\n",
        "response": "### Core API Usage Patterns for `TIFFReadDirectory`\n\n#### **API Functionality**\n- **Purpose**: Advances to the next directory (image) in a multi-page TIFF file. Enables sequential processing of multiple images/pages within a single TIFF file.\n- **Behavior**: Part of the libtiff library; used to iterate through directories (pages) in a TIFF file.\n\n#### **Typical Usage**\n- **Loop Structure**: Wrapped in a `do { ... } while (TIFFReadDirectory(image))` loop to process all directories.\n- **Workflow**:\n  1. Read initial directory (first image) after opening the file.\n  2. Use `TIFFReadDirectory` to advance to subsequent directories until no more exist.\n\n#### **Key Parameters**\n- **Input**: `TIFF*` handle (`image` in the code), representing the opened TIFF file.\n\n#### **Return Values**\n- **1**: Success (next directory read).\n- **0**: No more directories (end of file).\n- **-1**: Error (e.g., corrupted directory).\n\n#### **Error Handling**\n- **Code Limitation**: The provided snippet does not explicitly check for errors (e.g., return value `-1`). The loop exits on `0` (end) but ignores errors, risking silent failures.\n- **Best Practice**: Explicitly handle return values:\n  ```c\n  int ret;\n  do {\n    // Process directory\n    ret = TIFFReadDirectory(image);\n    if (ret < 0) {\n      // Handle error (e.g., log, cleanup, return failure)\n      break;\n    }\n  } while (ret > 0);\n  ```\n\n#### **Best Practices**\n1. **Explicit Error Checking**:\n   - Always check for `-1` to detect errors during directory iteration.\n2. **Per-Directory Tag Reinitialization**:\n   - Re-read tags (e.g., `TIFFTAG_IMAGEWIDTH`, `TIFFTAG_IMAGELENGTH`) **after each `TIFFReadDirectory` call**, as directories may have differing properties.\n3. **Resource Management**:\n   - Close the TIFF handle with `TIFFClose(image)` after processing to avoid leaks (missing in the provided code).\n   - Ensure memory buffers (e.g., `img.image_stack`) are resized/reallocated if directories have varying dimensions.\n4. **Multi-Directory Compatibility**:\n   - Avoid assuming all directories share the same metadata (e.g., resolution, dimensions). The provided code reads tags once, which is unsafe for multi-page TIFFs with varying properties.\n\n#### **Code-Specific Observations**\n- **Resource Leak**: `TIFFClose(image)` is missing in the active code, causing a file handle leak.\n- **Multi-Directory Assumption**: The code reads tags (e.g., `width`, `height`) only once, making it unsuitable for TIFFs with variable-sized directories."
    },
    {
        "prompt": "### Task Description:\nYou are an experienced software engineer skilled in API usage analysis. Your task is to analyze the following C/C++ code snippet and summarize the core API usage patterns for 'TIFFReadDirectory', focusing on:\n- API functionality\n- Typical usage\n- Key parameters\n- Return values\n- Error handling\n- Best practices\nProvide a concise and structured response.\n\n### Provided Code Snippet:\n```c\nerr_info *Desk::test_compare_with_tiff (QString &fname)\n   {\n   max_info *max;\n   cpoint size, true_size;\n   int bpp, pagenum;\n   byte *im;\n   TIFF *tif;\n\tunsigned imagelength;\n\tbyte *buf, *ptr;\n\tunsigned row;\n\tint stride, im_size, tif_size;\n   int config, nstrips;\n   int imageWidth, imageLength, tileWidth, tileLength;\n\n   CALL (max_open (fname.latin1 (), &max));\n\n   QString ext;\n   QString newname = removeExtension (fname, ext);\n\n   newname += \".tif\";\n\n   printf (\"name=%s\\n\", newname.latin1 ());\n\n   tif = TIFFOpen (newname.latin1 (), \"r\");\n\n   // compare each page\n   for (pagenum = 0; pagenum < max_get_pagecount (max); pagenum++)\n      {\n      printf (\"page %d / %d: \", pagenum, max_get_pagecount (max));\n\n\t   if (pagenum && !TIFFReadDirectory(tif))\n\t      {\n\t      printf (\"ran out of pages\\n\");\n\t      exit (1);\n\t      }   err_info *test_decomp_comp (QString &fname);\n\n\n//      printf (\"\\nTIFF\\n\");\n    \tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &imagelength);\n      TIFFGetField(tif, TIFFTAG_PLANARCONFIG, &config);\n   \tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n\t   TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &imageLength);\n//   \tTIFFGetField(tif, TIFFTAG_TILEWIDTH, &tileWidth);\n//   \tTIFFGetField(tif, TIFFTAG_TILELENGTH, &tileLength);\n\n      tileWidth = tileLength = 0;\n\n      nstrips = TIFFNumberOfStrips(tif);\n//      printf (\"strips=%d, image=%dx%d, tile=%dx%d: %d\\n\", nstrips, imageWidth, imageLength,\n//            tileWidth, tileLength, TIFFNumberOfTiles(tif));\n\n    \tstride = ((TIFFScanlineSize(tif) + 3) & ~3);;\n//      stride = imageWidth / 8;\n    \ttif_size = stride * imagelength;\n     \tbuf = (byte *)malloc (tif_size);\n     \tprintf (\"   stride=%d, \", stride);\n   \tfor (row = 0, ptr = buf; row < imagelength; row++, ptr += stride)\n\t      if (TIFFReadScanline(tif, ptr, row) != 1)\n\t         {\n\t         printf (\"\\nreadscanline error\\n\");\n\t         break;\n\t         }\n      CALL (max_get_image (max, pagenum, &size, &true_size, &bpp, &im, &im_size));\n\n   \tfor (row = 0, ptr = buf; row < imagelength; row++, ptr += stride)\n   \t   if (0 != memcmp (ptr, im + (ptr - buf), stride))\n   \t      {\n   \t      printf (\"\\n- error line %d\\n\", row);\n   \t      dump (\"tif\", ptr, stride, im + (ptr - buf));\n   \t      dump (\"max\", im + (ptr - buf), stride, ptr);\n   \t      }\n\n\t   free (buf);\n\t   printf (\"    lines=%d/%d, %d %d\\n\", imagelength, row, im_size, tif_size);\n\t   }\n   TIFFClose (tif);\n   max_close (max);\n\n   return NULL;\n   }\n```\n",
        "response": "### Core API Usage Patterns for `TIFFReadDirectory`\n\n#### **API Functionality**  \n`TIFFReadDirectory` is used to navigate to the next directory (image) in a multi-page TIFF file. It enables sequential access to individual pages/images within the TIFF.\n\n---\n\n#### **Typical Usage**  \n- Called in a loop to iterate over multiple pages in a TIFF file.  \n- The first directory is loaded automatically when opening the file (`TIFFOpen`). Subsequent directories require explicit calls to `TIFFReadDirectory`.  \n- Example from code:  \n  ```c\n  for (pagenum = 0; pagenum < max_get_pagecount(max); pagenum++) {\n    if (pagenum && !TIFFReadDirectory(tif)) { /* Handle no more pages */ }\n  }\n  ```\n\n---\n\n#### **Key Parameters**  \n- `TIFF *tif`: A handle to the opened TIFF file (from `TIFFOpen`).\n\n---\n\n#### **Return Values**  \n- **`1`**: Success (next directory read).  \n- **`0`**: No more directories (end of file).  \n- **`-1`**: Error (e.g., corrupted file).  \n\n---\n\n#### **Error Handling**  \n- The code checks for `0` (no more pages) and exits, but **does not handle `-1`** (errors).  \n- Best practice: Check for `-1` and handle errors explicitly:  \n  ```c\n  int ret = TIFFReadDirectory(tif);\n  if (ret == -1) { /* Handle I/O or format errors */ }\n  else if (ret == 0) { /* No more pages */ }\n  ```\n\n---\n\n#### **Best Practices**  \n1. **Check All Return Values**: Handle both `0` (no more pages) and `-1` (errors).  \n2. **Re-Read Tags After Navigation**: After moving to a new directory, re-read metadata (e.g., `TIFFTAG_IMAGELENGTH`, `TIFFTAG_IMAGEWIDTH`) as they may differ per page.  \n3. **Avoid Silent Failures**: Log errors instead of exiting abruptly.  \n4. **Close Resources Gracefully**: Use `TIFFClose` to ensure cleanup.  \n\n---\n\n#### **Code Snippet Observations**  \n- The code assumes the first directory is valid and skips explicit checks for subsequent directories.  \n- Missing error handling for `-1` could lead to undetected corruption or invalid reads.  \n- Metadata (e.g., `TIFFTAG_IMAGELENGTH`) is re-fetched after navigation, which is correct.  \n\n---\n\n### Summary  \n`TIFFReadDirectory` is critical for multi-page TIFF processing. Always validate its return value, handle errors, and refresh per-directory metadata to ensure robust parsing."
    },
    {
        "prompt": "### Task Description:\nYou are an experienced software engineer skilled in API usage analysis. Your task is to analyze the following C/C++ code snippet and summarize the core API usage patterns for 'TIFFReadDirectory', focusing on:\n- API functionality\n- Typical usage\n- Key parameters\n- Return values\n- Error handling\n- Best practices\nProvide a concise and structured response.\n\n### Provided Code Snippet:\n```c\nJNIEXPORT jboolean JNICALL LCTIFFWriter_METHOD(append)\n    ( JNIEnv *env, jobject jLCTIFFWriter, jbyteArray jFileNameUtf8 )\n{\n    TIFF *const destTIFF = getNativePtr( env, jLCTIFFWriter );\n    TIFFSetField( destTIFF, TIFFTAG_PAGENUMBER, 0, 2 );\n    int result = TIFFWriteDirectory( destTIFF );\n    if ( !result )\n        return JNI_FALSE;\n    jbyteArray_to_c const cFileName( env, jFileNameUtf8 );\n    TIFF *const srcTIFF = LC_TIFFOpen( cFileName, \"r\" );\n    if ( !srcTIFF )\n        return JNI_FALSE;\n    if ( isLightZoneLayeredTIFF( srcTIFF ) )\n        TIFFReadDirectory( srcTIFF );\n    result = tiffcp( srcTIFF, destTIFF );\n    TIFFSetField( destTIFF, TIFFTAG_PAGENUMBER, 1, 2 );\n    TIFFClose( srcTIFF );\n    return result ? JNI_TRUE : JNI_FALSE;\n}\n```\n",
        "response": "### Core API Usage Summary for `TIFFReadDirectory`\n\n#### **API Functionality**  \n`TIFFReadDirectory` advances the internal pointer of a TIFF file to the next directory (image/page), making it the current directory. Used to navigate multi-page or multi-image TIFF files.\n\n---\n\n#### **Typical Usage**  \n- **Multi-directory processing**: Read subsequent directories in loops or conditionally (e.g., skipping headers).  \n- **Conditional navigation**: In the provided code, it skips a directory in LightZone TIFF files (likely to bypass metadata layers).  \n\n---\n\n#### **Key Parameters**  \n| Parameter | Type     | Description                          |  \n|-----------|----------|--------------------------------------|  \n| `tif`     | `TIFF*`  | Handle to an open TIFF file (read mode). |  \n\n---\n\n#### **Return Values**  \n- **`1`**: Success (next directory read).  \n- **`0`**: Failure (no more directories or invalid state).  \n\n---\n\n#### **Error Handling**  \n- **In the code**: No explicit error checking (risk of silent failures).  \n- **Best practice**: Always validate the return value:  \n  ```c\n  if (TIFFReadDirectory(tif) != 1) {\n      // Handle error (e.g., log, close file, return failure)\n  }\n  ```  \n\n---\n\n#### **Best Practices**  \n1. **Check return values**: Ensure directory navigation succeeds before proceeding.  \n2. **Combine with `TIFFSetDirectory`**: For precise control over directory indices.  \n3. **Validate file mode**: Ensure the TIFF is opened in read (`\"r\"`) mode.  \n4. **Loop safely**: Use in `while (TIFFReadDirectory(tif))` loops for batch processing.  \n5. **Context awareness**: Understand file structure (e.g., LightZone layers) to skip/process directories appropriately.  \n\n---\n\n#### **Code-Specific Notes**  \n- **LightZone workaround**: Skips a directory after verifying `isLightZoneLayeredTIFF`, likely to access the actual image data.  \n- **Risk**: Missing error checks for `TIFFReadDirectory` could lead to invalid `tiffcp` operations if the directory read fails."
    },
    {
        "prompt": "### Task Description:\nYou are an experienced software engineer skilled in API usage analysis. Your task is to analyze the following C/C++ code snippet and summarize the core API usage patterns for 'TIFFReadDirectory', focusing on:\n- API functionality\n- Typical usage\n- Key parameters\n- Return values\n- Error handling\n- Best practices\nProvide a concise and structured response.\n\n### Provided Code Snippet:\n```c\nint imageIO::getTiffCount(){\n  int cnt = 0;\n  TIFF * image;\n\n  image = TIFFOpen(filename.c_str(), \"r\");\n\n  if (image != NULL) {\n    do {\n      ++cnt;\n    }while (TIFFReadDirectory(image));\n  }else{\n    cnt = -1;\n  }\n  \n  (void) TIFFClose(image);\n\n  return cnt;\n}\n```\n",
        "response": "### Core API Usage Analysis: `TIFFReadDirectory`\n\n#### **API Functionality**\n- **Purpose**: Advances the TIFF file handle to the next directory (image/page) in the TIFF file.\n- **Behavior**: Enables sequential iteration over all directories in the TIFF file. Returns `1` on success (next directory exists) and `0` on failure or end of directories.\n\n#### **Typical Usage**\n- **Looping Mechanism**: Used in a `do-while` loop to count directories. The loop increments a counter first, then checks for the next directory via `TIFFReadDirectory`.\n- **Initialization**: Requires a valid `TIFF*` handle opened with `TIFFOpen`.\n\n#### **Key Parameters**\n- **Input**: A single `TIFF*` handle (`image` in the code), representing the opened TIFF file.\n\n#### **Return Values**\n- **Success**: Returns `1` when the next directory is successfully read.\n- **Failure/End**: Returns `0` if no more directories exist **or** an error occurs during reading.\n\n#### **Error Handling**\n- **Gaps in Provided Code**:\n  - Fails to distinguish between **end-of-directories** and **true errors** (e.g., corrupt file). A return value of `0` could indicate either case, leading to potentially incorrect counts.\n  - No explicit error logging or recovery for directory read failures.\n- **Critical Issue**: `TIFFClose(image)` is called even if `image` is `NULL` (when `TIFFOpen` fails), risking undefined behavior (e.g., segmentation fault).\n\n#### **Best Practices**\n1. **Null Check Before Close**:\n   ```c\n   if (image != NULL) TIFFClose(image);\n   ```\n2. **Error Differentiation**:\n   - Use `TIFFGetErrorHandler` or similar mechanisms to check if `TIFFReadDirectory` failed due to an error (not just end-of-file).\n3. **Resource Safety**:\n   - Ensure `TIFFClose` is only called on valid handles.\n   - Consider returning a distinct error code (e.g., `-2`) if directory read errors occur mid-loop.\n4. **Defensive Initialization**:\n   - Initialize `cnt = -1` on `TIFFOpen` failure (as done) to signal file access issues.\n\n#### **Structured Summary**\n```plaintext\nAPI Functionality: Iterate through TIFF directories.\nTypical Usage:   do { ++cnt; } while (TIFFReadDirectory(handle));\nKey Parameters: TIFF* handle (opened TIFF file).\nReturn Values:   1 (next dir exists), 0 (end/error).\nError Handling:  Missing distinction between errors and EOF; risky NULL closure.\nBest Practices: Validate handle before close, add error checks, handle partial failures.\n``` \n\n#### **Code Fix Example**\n```c\nint imageIO::getTiffCount() {\n  TIFF* image = TIFFOpen(filename.c_str(), \"r\");\n  if (!image) return -1; // Fail on open error\n\n  int cnt = 0;\n  do {\n    cnt++;\n  } while (TIFFReadDirectory(image));\n\n  // Check if loop exited due to error (not EOF)\n  if (cnt > 0 && !TIFFCurrentDirectoryOffset(image)) {\n    cnt = -2; // Signal read error\n  }\n\n  TIFFClose(image);\n  return cnt;\n}\n```"
    },
    {
        "prompt": "### Task Description:\nYou are an experienced software engineer skilled in API usage analysis. Your task is to analyze the following C/C++ code snippet and summarize the core API usage patterns for 'TIFFReadDirectory', focusing on:\n- API functionality\n- Typical usage\n- Key parameters\n- Return values\n- Error handling\n- Best practices\nProvide a concise and structured response.\n\n### Provided Code Snippet:\n```c\nuint32_t TIFFCountDirectories(TIFF* tif) {\n    TIFFSetDirectory(tif,0);\n    uint32_t n_images =0;\n    do ++n_images; while (TIFFReadDirectory(tif));\n    TIFFSetDirectory(tif,0);\n    return n_images;\n}\n```\n",
        "response": "### Core API Usage Summary for `TIFFReadDirectory`\n\n#### **API Functionality**\n- Advances the TIFF file's directory pointer to the next directory and reads its contents.\n- Used to sequentially traverse all directories (e.g., images) in a TIFF file.\n\n#### **Typical Usage**\n- Called iteratively in a loop (e.g., `do-while`) to count or process all directories in the file.\n- Example:\n  ```c\n  do { ... } while (TIFFReadDirectory(tif));\n  ```\n\n#### **Key Parameters**\n- `TIFF* tif`: A handle to the open TIFF file. Must be initialized before use.\n\n#### **Return Values**\n- **`1`**: Successfully read the next directory.\n- **`0`**: No more directories to read **or an error occurred** (e.g., corrupt file).\n\n#### **Error Handling**\n- The provided code **does not distinguish between errors and end-of-directories**. A return value of `0` could indicate either case.\n- **Best Practice**: After the loop, use error-checking APIs (e.g., `TIFFGetError`) to verify if an error occurred:\n  ```c\n  if (TIFFGetError(tif) != TIFF_ERROR_NONE) {\n    // Handle error\n  }\n  ```\n\n#### **Best Practices**\n1. **Reset State After Iteration**: Use `TIFFSetDirectory(tif, 0)` to reset to the first directory after traversal (as shown in the snippet).\n2. **Explicit Error Checking**: Always check for errors after loop termination to avoid misinterpreting failures as normal termination.\n3. **Validate TIFF Handle**: Ensure the `TIFF*` handle is valid and the file is opened in a compatible mode (e.g., read mode).\n4. **Avoid Assumptions**: Do not assume `0` always means \"end of directories\"; handle potential errors explicitly."
    },
    {
        "prompt": "### Task Description:\nYou are an experienced software engineer skilled in API usage analysis. Your task is to analyze the following C/C++ code snippet and summarize the core API usage patterns for 'TIFFReadDirectory', focusing on:\n- API functionality\n- Typical usage\n- Key parameters\n- Return values\n- Error handling\n- Best practices\nProvide a concise and structured response.\n\n### Provided Code Snippet:\n```c\nchar *readTiff3DFile2Buffer ( void *fhandler, unsigned char *img, unsigned int img_width, unsigned int img_height, unsigned int first, unsigned int last, \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   int b_swap, int downsamplingFactor, int starti, int endi, int startj, int endj ) {\r\n\tuint32 rps;\r\n    uint16 spp, bpp, orientation, photo, comp, planar_config;\r\n    int check, StripsPerImage,LastStripSize;\r\n\tuint32 XSIZE;\r\n\tuint32 YSIZE;\r\n\r\n    TIFF *input = (TIFF *) fhandler;\r\n\r\n\tcheck=TIFFGetField(input, TIFFTAG_BITSPERSAMPLE, &bpp); \r\n\tif (!check)\r\n\t{\r\n\t\treturn ((char *) \"Undefined bits per sample.\");\r\n\t}\r\n\r\n\tcheck=TIFFGetField(input, TIFFTAG_SAMPLESPERPIXEL, &spp);\r\n\tif (!check)\r\n\t{\r\n\t\tspp = 1;\r\n\t\t//return ((char *) \"Undefined samples per pixel.\");\r\n\t}\r\n\r\n\tcheck=TIFFGetField(input, TIFFTAG_PHOTOMETRIC, &photo);\r\n\tif (!check)\r\n\t{\r\n\t\treturn ((char *) \"Cannot determine photometric interpretation.\");\r\n\t}\r\n\r\n\tcheck=TIFFGetField(input, TIFFTAG_COMPRESSION, &comp);\r\n\tif (!check)\r\n\t{\r\n\t\treturn ((char *) \"Cannot determine compression technique.\");\r\n\t}\r\n\r\n\tcheck=TIFFGetField(input, TIFFTAG_PLANARCONFIG, &planar_config);\r\n\tif (!check)\r\n\t{\r\n\t\treturn ((char *) \"Cannot determine planar configuration.\");\r\n\t}\r\n\r\n\tstarti = (starti == -1) ? 0 : starti;\r\n\tendi   = (endi == -1) ? img_height-1 : endi;\r\n\tstartj = (startj == -1) ? 0 : startj;\r\n\tendj   = (endj == -1) ? img_width-1 : endj;\r\n\r\n\tcheck=TIFFIsTiled(input);\r\n\tif (check) // file is internally tiled\r\n\t{\r\n\t\tuint32 tilewidth;\r\n\t\tuint32 tilelength;\r\n\t\tuint32 tiledepth;\r\n\t\ttsize_t tilenum;\r\n\t\ttsize_t tilesize;\r\n\t\ttsize_t tilenum_width;\r\n\t\ttsize_t tilenum_length;\r\n\t\tttile_t tile;\r\n\t\ttdata_t data;\r\n\t\tunsigned char *psrc; // pointer in the tile buffer to the top left pixel of the current block to be copied\r\n\t\tunsigned char *pdst; // pointer in the image buffer to the top left pixel of the current block to be filled\r\n\t\tuint32 stride_src;\r\n\t\tuint32 stride_dst;\r\n\t\tint i; // row index in the slice of the top left pixel of the current block to be filled\r\n\t\tint j; // column index in the slice of the top left pixel of the current block to be filled \r\n\t\tuint32 width; // width of the current block to be filled (in pixels)\r\n\t\tuint32 len; // length of the current block to be filled (in pixels)\r\n\t\tint page;\r\n\r\n\t\t// checks\r\n\t\tif ( TIFFGetField(input, TIFFTAG_TILEDEPTH, &tiledepth) )\r\n\t\t\treturn ((char *) \"Tiling among slices (z direction) not supported.\");\r\n\t\tif ( spp > 1 )\r\n\t\t\tif ( TIFFGetField(input, TIFFTAG_PLANARCONFIG, &planar_config) )\r\n\t\t\t\tif ( planar_config > 1 )\r\n\t\t\t\t\treturn ((char *) \"Non-interleaved multiple channels not supported with tiling.\");\r\n\r\n\t\t// tiling is in x,y only\r\n\t\tTIFFGetField(input, TIFFTAG_TILEWIDTH, &tilewidth);\r\n\t\tTIFFGetField(input, TIFFTAG_TILELENGTH, &tilelength);\r\n\t\ttilenum = TIFFNumberOfTiles(input);\r\n\t\ttilesize = TIFFTileSize(input);\r\n\t\ttilenum_width  = (img_width % tilewidth) ? (img_width / tilewidth) + 1 : img_width / tilewidth;\r\n\t\ttilenum_length = (img_height % tilelength) ? (img_height / tilelength) + 1 : img_height / tilelength;\r\n\r\n\t\tdata = new unsigned char[tilesize];\r\n\t\tstride_src = tilewidth * spp; // width of tile (in bytes)\r\n\t\tstride_dst = (endj - startj + 1) * spp; // width of subregion (in bytes)\r\n\r\n\t\tpage = 0;\r\n\t\tdo {\r\n\r\n\t\t\tpsrc = ((unsigned char *)data) + ((starti % tilelength)*tilewidth + (startj % tilewidth)) * spp; // in the first tile skip (starti % tilelength) rows plus (startj % tilewidth) pixels\r\n\t\t\tpdst = img; // the buffer has the size of the subregion\r\n\t\t\tlen = tilelength - (starti % tilelength); // rows to be copied for the first row of tiles \r\n\t\t\ttile = TIFFComputeTile(input,startj,starti,0,0); // index of the first tile to be copied in the current row of tiles\r\n\t\t\tfor ( i=starti; i<=endi; ) {\r\n\t\t\t\twidth = tilewidth - (startj%tilewidth); // width of the first block to be copied/filled\r\n\t\t\t\tfor ( j=startj; j<=endj; ) {\r\n\t\t\t\t\tTIFFReadEncodedTile(input,tile,data,(tsize_t) -1); // read tile into tile buffer\r\n\t\t\t\t\tcopydata (psrc,stride_src,pdst,stride_dst,(width * spp),len); // copy the block \r\n\t\t\t\t\tj += width;\r\n\t\t\t\t\ttile++; // index of the next tile in the same row of tiles\r\n\t\t\t\t\tpsrc = ((unsigned char *)data) + ((i % tilelength)*tilewidth) * spp; // the block in the next tile begins just after (i % tilelength) rows\r\n\t\t\t\t\tpdst += width * spp; // the block in the image buffer move forward of width pixels\r\n\t\t\t\t\twidth = (((tile%tilenum_width) + 1) * tilewidth <= (endj+1)) ? tilewidth : ((endj+1)%tilewidth); // if the next tile in the row is all within the subregion, width is tilewidth otherwise it is shorter\r\n\t\t\t\t}\r\n\t\t\t\ti += len;\r\n\t\t\t\ttile = TIFFComputeTile(input,startj,i,0,0); // index of the first tile to be copied in the current row of tiles\r\n\t\t\t\tpsrc = ((unsigned char *)data) + ((i % tilelength)*tilewidth + (startj % tilewidth)) * spp; // in the first tile of the next row of tiles skip (i % tilelength) rows plus (startj % tilewidth) pixels\r\n\t\t\t\tpdst = img + ((i-starti) * stride_dst); // the block in the image buffer begin after (i-starti) rows\r\n\t\t\t\tlen = (((tile/tilenum_width) + 1) * tilelength <= (endi+1)) ? tilelength : ((endi+1)%tilelength); // if the next row of tiles is all within the subregion, len is tilelength otherwise it is shorter\r\n\t\t\t}\r\n\r\n\t\t\tpage++;\r\n\t\r\n\t\t}while ( page < static_cast<int>(last-first+1) && TIFFReadDirectory(input));\r\n\r\n\t\treturn (char *) 0;\r\n\t}\r\n\r\n\t// 2018-08-22. Giulio. @CHANGED if TIFFTAG_ROWSPERSTRIP is missing it is assumed that all rows are packed into only one strip\r\n\tif ( !TIFFGetField(input, TIFFTAG_ROWSPERSTRIP, &rps) )\r\n\t\trps = img_height;\t\r\n// \tcheck=TIFFGetField(input, TIFFTAG_ROWSPERSTRIP, &rps);\r\n// \tif (!check)\r\n// \t{\r\n// \t\treturn ((char *) \"Undefined rows per strip.\");\r\n// \t}\r\n\r\n    \r\n\t//check=TIFFGetField(input, TIFFTAG_ORIENTATION, &orientation); \r\n\t//if (!check)\r\n\t//{\r\n\t//\treturn ((char *) \"Image orientation undefined.\");\r\n\t//}\t\r\n    \r\n\tStripsPerImage =  (img_height + rps - 1) / rps;\r\n\tLastStripSize = img_height % rps;\r\n\tif (LastStripSize==0)\r\n\t\tLastStripSize=rps;\r\n\r\n\tunsigned char *buf = img;\r\n\tint page=0;\r\n\r\n\tif ( downsamplingFactor == 1 ) { // read without downsampling\r\n\r\n\t\tif ( starti < 0 || endi >= img_height || startj < 0 || endj >= img_width || starti >= endi || startj >= endj )\r\n\t\t{\r\n\t\t\treturn ((char *) \"Wrong substack indices.\");\r\n\t\t}\r\n\r\n\t\tif ( starti == 0 && endi == (img_height-1) && startj == 0 && endj == (img_width-1) ) { // read whole images from files \r\n\r\n\t\t\tcheck=TIFFSetDirectory(input, first);\r\n\t\t\tif (!check)\r\n\t\t\t{\r\n\t\t\t\treturn ((char *) \"Cannot open the requested first strip.\");\r\n\t\t\t}\r\n\r\n\t\t\tdo{\r\n\r\n\t\t\t\tfor (int i=0; i < StripsPerImage-1; i++){\r\n\t\t\t\t\tif (comp==1) {\r\n\t\t\t\t\t\tTIFFReadRawStrip(input, i, buf, spp * rps * img_width * (bpp/8));\r\n\t\t\t\t\t\tbuf = buf + spp * rps * img_width * (bpp/8);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse{\r\n\t\t\t\t\t\tTIFFReadEncodedStrip(input, i, buf, spp * rps * img_width * (bpp/8));\r\n\t\t\t\t\t\tbuf = buf + spp * rps * img_width * (bpp/8);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (comp==1) {\r\n\t\t\t\t\tTIFFReadRawStrip(input, StripsPerImage-1, buf, spp * LastStripSize * img_width * (bpp/8));\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\tTIFFReadEncodedStrip(input, StripsPerImage-1, buf, spp * LastStripSize * img_width * (bpp/8));\r\n\t\t\t\t}\r\n\t\t\t\tbuf = buf + spp * LastStripSize * img_width * (bpp/8);\r\n\r\n\t\t\t\tpage++;\r\n\t\r\n\t\t\t}while ( page < static_cast<int>(last-first+1) && TIFFReadDirectory(input));//while (TIFFReadDirectory(input));\r\n\r\n\t\t}\r\n\t\telse { // read only a subregion of images from files\r\n\r\n\t\t\tcheck=TIFFGetField(input, TIFFTAG_IMAGEWIDTH, &XSIZE);\r\n\t\t\tif (!check)\r\n\t\t\t{\r\n\t\t\t\treturn ((char *) \"Image width of undefined.\");\r\n\t\t\t}\t\t    \r\n\t\t\tcheck=TIFFGetField(input, TIFFTAG_IMAGELENGTH, &YSIZE);\r\n\t\t\tif (!check)\r\n\t\t\t{\r\n\t\t\t\treturn ((char *) \"Image length of undefined.\");\r\n\t\t\t}\r\n\r\n\t\t\tunsigned char *rowbuf = new unsigned char[spp * rps * XSIZE * (bpp/8)];\r\n\t\t\tunsigned char *bufptr;\r\n\r\n\t\t\tdo{\r\n\t\t\t\tcheck=TIFFSetDirectory(input, first + page);\r\n\t\t\t\tif (!check)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn ((char *) \"Cannot open next requested strip.\");\r\n\t\t\t\t}\r\n\r\n\t\t\t\tint stripIndex = (starti / rps) - 1; // the strip preceeding the first one\r\n\t\t\t\tfor (int i=starti; i <= endi; i++) {\r\n\t\t\t\t\tif ( floor((double)i / rps) > stripIndex ) { // read a new strip\r\n\t\t\t\t\t\tstripIndex = (int)floor((double)i / rps);\r\n\t\t\t\t\t\tif (comp==1) {\r\n\t\t\t\t\t\t\tTIFFReadRawStrip(input, stripIndex, rowbuf, spp * ((stripIndex < StripsPerImage) ? rps :LastStripSize) * XSIZE * (bpp/8));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse{\r\n\t\t\t\t\t\t\tTIFFReadEncodedStrip(input, stripIndex, rowbuf, spp * ((stripIndex < StripsPerImage) ? rps :LastStripSize) * XSIZE * (bpp/8));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbufptr = rowbuf + (i % rps) * (spp * XSIZE * (bpp/8));\r\n\t\t\t\t\tif ( bpp == 8 )\r\n\t\t\t\t\t\tfor (int j=0, j1=startj; j<=(endj-startj); j++, j1++) {\r\n\t\t\t\t\t\t\tfor (int c=0; c<spp; c++) {\r\n\t\t\t\t\t\t\t\tbuf[j * spp + c] = bufptr[j1 * spp + c];\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tfor (int j=0 , j1=startj; j<=(endj-startj); j++, j1++) {\r\n\t\t\t\t\t\t\tfor (int c=0; c<spp; c++) {\r\n\t\t\t\t\t\t\t\t((uint16 *)buf)[j * spp + c] = ((uint16 *)bufptr)[j1 * spp + c];\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\tbuf = buf + spp * (endj-startj+1) * (bpp/8);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tpage++;\r\n\r\n\t\t\t}while ( page < static_cast<int>(last-first+1) );\r\n\r\n\t\t\tdelete []rowbuf;\r\n\r\n\t\t}\r\n\r\n\t\t// input file is assumed to be already open and it is provided as an handler; the file should be closed by caller\r\n\t\t//TIFFClose(input); \r\n\r\n\t\t// 2021. Giulio. The following code seems useless since the condition should be always false\r\n// \t\tif ( page < static_cast<int>(last-first+1) ){\r\n// \t\t\treturn ((char *) \"Cannot read all the pages.\");\r\n// \t\t}\r\n\t}\r\n\telse { // read with downsampling\r\n\r\n\t\t// preliminary checks\r\n\t\tif ( starti != 0 || endi != (img_height-1) || startj != 0 || endj != (img_width-1) ) { // a subregion has been requested \r\n\t\t\treturn ((char *) \"Subregion extraction not supported with downsampling.\");\r\n\t\t}\t\t    \r\n\t\tcheck=TIFFGetField(input, TIFFTAG_IMAGEWIDTH, &XSIZE);\r\n\t\tif (!check)\r\n\t\t{\r\n\t\t\treturn ((char *) \"Image width of undefined.\");\r\n\t\t}\t\t    \r\n\t\tcheck=TIFFGetField(input, TIFFTAG_IMAGELENGTH, &YSIZE);\r\n\t\tif (!check)\r\n\t\t{\r\n\t\t\treturn ((char *) \"Image length of undefined.\");\r\n\t\t}\r\n\r\n\t\tif ( (int)ceil((double)XSIZE/downsamplingFactor) < img_width ) \r\n\t\t{\r\n\t\t\treturn ((char *) \"Requested image width too large.\");\r\n\t\t}\r\n\t\tif ( (int)ceil((double)YSIZE/downsamplingFactor) < img_height ) \r\n\t\t{\r\n\t\t\treturn ((char *) \"Requested image height too large.\");\r\n\t\t}\r\n\r\n\t\tunsigned char *rowbuf = new unsigned char[spp * rps * XSIZE * (bpp/8)];\r\n\t\tunsigned char *bufptr;\r\n\r\n\t\tdo{\r\n\t\t\tcheck=TIFFSetDirectory(input, ((first + page) * downsamplingFactor));\r\n\t\t\tif (!check)\r\n\t\t\t{\r\n\t\t\t\treturn ((char *) \"Cannot open next requested strip.\");\r\n\t\t\t}\r\n\r\n\t\t\tint stripIndex = -1; // the strip preceeding the first one\r\n\t\t\tfor (int i=0; i < img_height; i++) {\r\n\t\t\t\tif ( floor(i * downsamplingFactor / (double)rps) > stripIndex ) { // read a new strip\r\n\t\t\t\t\tstripIndex = (int)floor(i * downsamplingFactor / (double)rps);\r\n\t\t\t\t\tif (comp==1) {\r\n\t\t\t\t\t\tTIFFReadRawStrip(input, stripIndex, rowbuf, spp * ((stripIndex < StripsPerImage) ? rps :LastStripSize) * XSIZE * (bpp/8));\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse{\r\n\t\t\t\t\t\tTIFFReadEncodedStrip(input, stripIndex, rowbuf, spp * ((stripIndex < StripsPerImage) ? rps :LastStripSize) * XSIZE * (bpp/8));\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbufptr = rowbuf + ((i * downsamplingFactor) % rps) * (spp * XSIZE * (bpp/8));\r\n\t\t\t\tif ( bpp == 8 )\r\n\t\t\t\t\tfor (int j=0; j<img_width; j++) {\r\n\t\t\t\t\t\tfor (int c=0; c<spp; c++) {\r\n\t\t\t\t\t\t\tbuf[j * spp + c] = bufptr[j * spp * downsamplingFactor + c];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t\tfor (int j=0; j<img_width; j++) {\r\n\t\t\t\t\t\tfor (int c=0; c<spp; c++) {\r\n\t\t\t\t\t\t\t((uint16 *)buf)[j * spp + c] = ((uint16 *)bufptr)[j * spp * downsamplingFactor + c];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\tbuf = buf + spp * img_width * (bpp/8);\r\n\t\t\t}\r\n\r\n\t\t\tpage++;\r\n\r\n\t\t}while ( page < static_cast<int>(last-first+1) );\r\n\r\n\t\tdelete []rowbuf;\r\n\t}\r\n    \r\n\t// swap the data bytes if necessary \t\r\n\tif (b_swap)\r\n\t{\r\n\t\tint i;\r\n\t\tsize_t total = img_width * img_height * spp * (last-first+1);\r\n\t\tif (bpp/8 == 2)\r\n\t\t{\r\n\t\t\tfor (i=0;i<total; i++)\r\n\t\t\t{\r\n                iim::swap2bytes((void *)(img+2*i));\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (bpp/8 == 4)\r\n\t\t{\r\n\t\t\tfor (i=0;i<total; i++)\r\n\t\t\t{\r\n                iim::swap4bytes((void *)(img+4*i));\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn (char *) 0;\r\n}\n```\n",
        "response": "### Core API Usage Patterns for `TIFFReadDirectory`\n\n#### **API Functionality**\n- **Purpose**: Advances the TIFF file handle to the next directory (image) in a multi-page TIFF file.\n- **Role**: Enables sequential traversal of multiple images/directories within a TIFF file.\n\n#### **Typical Usage**\n- Used in a loop to iterate through directories after an initial directory is set (e.g., `TIFFSetDirectory` in non-tiled case).\n- Example from code:\n  ```c\n  do {\n      // Process current directory (e.g., read tiles/strips)\n      page++;\n  } while (page < (last-first+1) && TIFFReadDirectory(input));\n  ```\n\n#### **Key Parameters**\n- **Input**: `TIFF* input` (handle to an open TIFF file).\n- No additional parameters; relies on the internal state of the TIFF handle.\n\n#### **Return Values**\n- **Success**: Returns `1` (true) if the next directory is successfully read.\n- **Failure**: Returns `0` (false) if no more directories exist or an error occurs.\n\n#### **Error Handling**\n- **Loop Termination**: The loop stops if `TIFFReadDirectory` returns `0`, but the code does not explicitly check for premature termination (e.g., failing to read all `last-first+1` pages).\n- **Missing Error Logging**: No error messages are generated if `TIFFReadDirectory` fails mid-loop, potentially leading to silent failures.\n\n#### **Best Practices**\n1. **Initial Directory Setup**:\n   - Explicitly set the starting directory with `TIFFSetDirectory` before looping (done in the non-tiled case but omitted in the tiled case).\n2. **Tag Re-Reading**:\n   - Re-fetch tags (e.g., `TIFFTAG_BITSPERSAMPLE`) after moving to a new directory, as TIFF directories may have different configurations (not done in the provided code).\n3. **Post-Loop Validation**:\n   - After the loop, verify if all required pages were read (commented-out in the code but critical for robustness).\n4. **Error Propagation**:\n   - Return explicit error messages if `TIFFReadDirectory` fails before reading all expected pages.\n\n#### **Code Issues Identified**\n- **Inconsistent Initialization**: The tiled case assumes the initial directory is correctly set externally, while the non-tiled case uses `TIFFSetDirectory`.\n- **Missing Error Checks**: No validation after the loop to ensure `page == last-first+1`, risking incomplete reads.\n- **Tag Persistence**: Tags like `bpp` or `spp` are read once initially, which may fail if directories have varying configurations.\n\n---\n\n### Summary\n`TIFFReadDirectory` is used to iterate through TIFF directories, but the code lacks robust error handling and consistency in directory initialization. Best practices include explicit setup, tag re-fetching, and post-loop validation to ensure reliability."
    },
    {
        "prompt": "### Task Description:\nYou are an experienced software engineer skilled in API usage analysis. Your task is to analyze the following C/C++ code snippet and summarize the core API usage patterns for 'TIFFReadDirectory', focusing on:\n- API functionality\n- Typical usage\n- Key parameters\n- Return values\n- Error handling\n- Best practices\nProvide a concise and structured response.\n\n### Provided Code Snippet:\n```c\nvoid \r\n\tiomanager::tiff3D::readMetadata(\r\n\tstd::string img_path,\t\t// (INPUT)\timage filepath\r\n\tint & img_width,\t\t\t// (OUTPUT) image width  (in pixels)\r\n\tint & img_height,\t\t\t// (OUTPUT) image height (in pixels)\r\n\tint & img_depth,\t\t\t// (OUTPUT) image depth (in pixels)\r\n\tint & img_bytes_x_chan,\t// (OUTPUT) number of bytes per channel\r\n\tint & img_chans,\t\t\t// (OUTPUT) number of channels\r\n\tconst std::string & params)\t// (INPUT)\tadditional parameters <param1=val, param2=val, ...> \r\nthrow (iom::exception)\r\n{\r\n\t/**/iom::debug(iom::LEV3, iom::strprintf(\"img_path = %s, img_width = %d, img_height = %d, img_depth = %d, img_bytes_x_chan = %d, img_chans = %d, params = \\\"%s\\\"\",\r\n\t\timg_path.c_str(), img_width, img_height, img_depth,\timg_bytes_x_chan, img_chans, params.c_str()).c_str(), __iom__current__function__);\r\n\r\n\t//disable warning and error handlers to avoid messages on unrecognized tags\r\n\tTIFFSetWarningHandler(0);\r\n\tTIFFSetErrorHandler(0);\r\n\r\n\tTIFF* input=TIFFOpen(img_path.c_str(),\"r\");\r\n\tif (!input)\r\n\t\tthrow iom::exception(iom::strprintf(\"unable to open image \\\"%s\\\". Possible unsupported format or it isn't an image.\\nSupported format is 3DTIFF\", img_path.c_str()), __iom__current__function__);\r\n\r\n\tif (!TIFFGetField(input, TIFFTAG_IMAGEWIDTH, &img_width))\r\n\t\tthrow iom::exception(iom::strprintf(\"unable to determine 'TIFFTAG_IMAGEWIDTH' from image \\\"%s\\\". \", img_path.c_str()), __iom__current__function__);\r\n\r\n\tif (!TIFFGetField(input, TIFFTAG_IMAGELENGTH, &img_height))\r\n\t\tthrow iom::exception(iom::strprintf(\"unable to determine 'TIFFTAG_IMAGELENGTH' from image \\\"%s\\\". \", img_path.c_str()), __iom__current__function__);\r\n\r\n\tif (!TIFFGetField(input, TIFFTAG_BITSPERSAMPLE, &img_bytes_x_chan))\r\n\t\tthrow iom::exception(iom::strprintf(\"unable to determine 'TIFFTAG_BITSPERSAMPLE' from image \\\"%s\\\". \", img_path.c_str()), __iom__current__function__);\r\n\timg_bytes_x_chan /= 8;\r\n\r\n\tif (!TIFFGetField(input, TIFFTAG_SAMPLESPERPIXEL, &img_chans)) \r\n\t\timg_chans = 1;\r\n\t\t//throw iom::exception(iom::strprintf(\"unable to determine 'TIFFTAG_SAMPLESPERPIXEL' from image \\\"%s\\\". \", img_path.c_str()), __iom__current__function__);\r\n\r\n\t// Onofri\r\n\tuint16 cpage;  // Current page. We do not actually need it.\r\n\tuint16 npages; // Number of pages. \r\n\tint PNcheck=TIFFGetField(input, TIFFTAG_PAGENUMBER, &cpage, &npages);\r\n\tif (!PNcheck || npages==0) { // the tag has not been read correctly\r\n\t\t//iom::warning(iom::strprintf(\"unable to determine 'TIFFTAG_PAGENUMBER' from image file \\\"%s\\\". \", img_path.c_str()).c_str(),__iom__current__function__);\r\n\t\timg_depth = 0;\r\n\t\tdo {\r\n\t\t\timg_depth++;\r\n\t\t} while (TIFFReadDirectory(input));\r\n\t}\r\n\telse\r\n\t\timg_depth = npages;\r\n\r\n\tTIFFClose(input);\r\n}\n```\n",
        "response": "### Core API Usage Patterns for `TIFFReadDirectory`\n\n#### **API Functionality**  \n`TIFFReadDirectory` is a LibTIFF function used to advance to and read the next directory (image/page) in a multi-page TIFF file. It enables traversal of the TIFF directory structure to process multi-layered or volumetric data.\n\n---\n\n#### **Typical Usage**  \nUsed to iterate through TIFF directories when metadata like `TIFFTAG_PAGENUMBER` is unavailable. In the code, it counts the total number of pages (depth) in a 3D TIFF:\n```c\ndo {\n    img_depth++;\n} while (TIFFReadDirectory(input));  // Loop until no more directories\n```\n\n---\n\n#### **Key Parameters**  \n- **Input**: `TIFF*` handle (`input` in the code), representing an open TIFF file.\n\n---\n\n#### **Return Values**  \n- **1 (Success)**: A new directory was read.  \n- **0 (Failure/End)**: No more directories exist or an error occurred.  \n\n---\n\n#### **Error Handling**  \n- **Weakness**: The code assumes `0` always indicates the end of directories, ignoring potential read errors.  \n- **Risk**: Silent failures may cause incorrect depth values if directory parsing fails mid-iteration.  \n- **Mitigation**: Check LibTIFF error handling mechanisms or re-enable error handlers for diagnostics.\n\n---\n\n#### **Best Practices**  \n1. **Prefer Metadata Tags**: Use `TIFFTAG_PAGENUMBER` when available (more efficient than directory traversal).  \n2. **Error Checking**: Add post-iteration validation (e.g., `TIFFGetError` or custom logging) to distinguish errors from legitimate end-of-file.  \n3. **State Management**: Reset directory state with `TIFFSetDirectory` after iteration if further processing is needed.  \n4. **Handler Control**: Avoid disabling warnings/errors unless absolutely necessary, as they aid in debugging.  \n\n---\n\n### Summary  \n`TIFFReadDirectory` enables directory traversal in multi-page TIFFs. While efficient for metadata-free depth counting, robust implementations should validate return values and handle errors explicitly. The provided code prioritizes simplicity over safety, assuming directory iteration failures only indicate end-of-file."
    },
    {
        "prompt": "### Task Description:\nYou are an experienced software engineer skilled in API usage analysis. Your task is to analyze the following C/C++ code snippet and summarize the core API usage patterns for 'TIFFReadDirectory', focusing on:\n- API functionality\n- Typical usage\n- Key parameters\n- Return values\n- Error handling\n- Best practices\nProvide a concise and structured response.\n\n### Provided Code Snippet:\n```c\nbool TiffDecoder::nextPage()\n{\n    // Prepare the next page, if any.\n    return !m_tif.empty() &&\n           TIFFReadDirectory(static_cast<TIFF*>(m_tif.get())) &&\n           readHeader();\n}\n```\n",
        "response": "### Core API Usage Analysis: `TIFFReadDirectory`\n\n#### **API Functionality**\n`TIFFReadDirectory` is a LibTIFF function used to advance to and read the next directory (image) in a multi-page TIFF file. It prepares the internal state for accessing subsequent image data and metadata.\n\n---\n\n#### **Typical Usage**\n- Called iteratively to process multi-page TIFF files (e.g., in loops or `nextPage`-style methods).\n- Often paired with `TIFFOpen`, `TIFFGetField`, and image data extraction APIs.\n- Example workflow:\n  ```c\n  TIFF* tif = TIFFOpen(\"file.tif\", \"r\");\n  do {\n    // Process current directory (e.g., read tags, decode pixels)\n  } while (TIFFReadDirectory(tif));\n  TIFFClose(tif);\n  ```\n\n---\n\n#### **Key Parameters**\n| Parameter    | Type      | Description                                      |\n|--------------|-----------|--------------------------------------------------|\n| `tif`        | `TIFF*`   | Handle to an open TIFF file, obtained via `TIFFOpen`. |\n\n---\n\n#### **Return Values**\n- **`1`**: Successfully read the next directory.\n- **`0`**: No more directories to read (end of file).\n- **`-1`**: **Error** (e.g., corrupt file, I/O failure).\n\n---\n\n#### **Error Handling in the Provided Code**\n- **Flawed Implementation**: The code treats **any non-zero return value** (including `-1`) as success due to the boolean cast (`TIFFReadDirectory(...) && readHeader()`).  \n  - This is incorrect, as `-1` indicates an error, not a valid directory.  \n- **Best Practice**: Explicitly check for a return value of `1` to distinguish success from errors:\n  ```c\n  int status = TIFFReadDirectory(tif);\n  if (status == 1) { /* Success */ }\n  else if (status == 0) { /* End of directories */ }\n  else { /* Handle error */ }\n  ```\n\n---\n\n#### **Best Practices**\n1. **Explicit Return Value Checks**: Validate `TIFFReadDirectory` returns `1` for success. Avoid implicit boolean casts.\n2. **Error Logging**: Use LibTIFF’s error handlers (e.g., `TIFFSetErrorHandler`) to capture diagnostics.\n3. **State Validity**: Ensure the `TIFF*` handle is valid and properly initialized before calling.\n4. **Multi-Page Loops**: Reset internal state (e.g., pixel buffers) between directory reads.\n5. **Resource Cleanup**: Close handles with `TIFFClose` and manage memory ownership (e.g., via RAII wrappers like `m_tif` in the snippet).\n\n---\n\n#### **Critical Note on the Provided Code**\nThe current implementation **incorrectly proceeds on errors** (treats `-1` as success). To fix:\n```c\nbool TiffDecoder::nextPage() {\n  if (m_tif.empty()) return false;\n  int status = TIFFReadDirectory(static_cast<TIFF*>(m_tif.get()));\n  if (status != 1) return false; // Handle 0 (EOF) and -1 (error)\n  return readHeader();\n}\n```"
    },
    {
        "prompt": "### Task Description:\nYou are an experienced software engineer skilled in API usage analysis. Your task is to analyze the following C/C++ code snippet and summarize the core API usage patterns for 'TIFFReadDirectory', focusing on:\n- API functionality\n- Typical usage\n- Key parameters\n- Return values\n- Error handling\n- Best practices\nProvide a concise and structured response.\n\n### Provided Code Snippet:\n```c\nvoid \r\n\tiomanager::tiff2D::readMetadata(\r\n\tstd::string img_path,\t\t\t// (INPUT)  image filepath\r\n\tint & img_width,\t\t\t\t// (OUTPUT) image width  (in pixels)\r\n\tint & img_height,\t\t\t\t// (OUTPUT) image height (in pixels)\r\n\tint & img_bytes_x_chan,\t\t\t// (OUTPUT) number of bytes per channel\r\n\tint & img_chans,\t\t\t\t// (OUTPUT) number of channels\r\n\tconst std::string & params)\t\t// (INPUT)  additional parameters <param1=val, param2=val, ...> \r\nthrow (iom::exception)\r\n{\r\n\t/**/iom::debug(iom::LEV3, iom::strprintf(\"img_path = \\\"%s\\\", params = \\\"%s\\\"\",img_path.c_str(), params.c_str()).c_str(), __iom__current__function__);\r\n\r\n\tuint16 bpp;\r\n\tuint16 spp;\r\n\r\n\t//disable warning and error handlers to avoid messages on unrecognized tags\r\n\tTIFFSetWarningHandler(0);\r\n\tTIFFSetErrorHandler(0);\r\n\r\n\tTIFF* input=TIFFOpen(img_path.c_str(),\"r\");\r\n\tif (!input)\r\n\t\tthrow iom::exception(iom::strprintf(\"unable to open image \\\"%s\\\". Possible unsupported format or it isn't an image.\\nSupported format is 2DTIFF\", img_path.c_str()), __iom__current__function__);\r\n\r\n\tif (!TIFFGetField(input, TIFFTAG_IMAGEWIDTH, &img_width))\r\n\t\tthrow iom::exception(iom::strprintf(\"unable to determine 'TIFFTAG_IMAGEWIDTH' from image \\\"%s\\\". \", img_path.c_str()), __iom__current__function__);\r\n\r\n\tif (!TIFFGetField(input, TIFFTAG_IMAGELENGTH, &img_height))\r\n\t\tthrow iom::exception(iom::strprintf(\"unable to determine 'TIFFTAG_IMAGELENGTH' from image \\\"%s\\\". \", img_path.c_str()), __iom__current__function__);\r\n\r\n\tif (!TIFFGetField(input, TIFFTAG_BITSPERSAMPLE, &bpp))\r\n\t\tthrow iom::exception(iom::strprintf(\"unable to determine 'TIFFTAG_BITSPERSAMPLE' from image \\\"%s\\\". \", img_path.c_str()), __iom__current__function__);\r\n\timg_bytes_x_chan = bpp/8;\r\n\r\n\tif (!TIFFGetField(input, TIFFTAG_SAMPLESPERPIXEL, &spp)) \r\n\t\tspp = 1;\r\n\t\t//throw iom::exception(iom::strprintf(\"unable to determine 'TIFFTAG_SAMPLESPERPIXEL' from image \\\"%s\\\". \", img_path.c_str()), __iom__current__function__);\r\n\timg_chans = spp;\r\n\r\n\t// Onofri\r\n\tint img_depth;\t\t\t// image depth (in pixels)\r\n\tuint16 cpage;  // Current page. We do not actually need it.\r\n\tuint16 npages; // Number of pages. \r\n\tint PNcheck=TIFFGetField(input, TIFFTAG_PAGENUMBER, &cpage, &npages);\r\n\tif (!PNcheck || npages==0) { // the tag has not been read correctly\r\n\t\t//iom::warning(iom::strprintf(\"unable to determine 'TIFFTAG_PAGENUMBER' from image file \\\"%s\\\". \", img_path.c_str()).c_str(),__iom__current__function__);\r\n\t\timg_depth = 0;\r\n\t\tdo {\r\n\t\t\timg_depth++;\r\n\t\t} while (TIFFReadDirectory(input));\r\n\t}\r\n\telse\r\n\t\timg_depth = npages;\r\n\r\n\tTIFFClose(input);\r\n\t\r\n\t// check the exception after closing the file\r\n\tif ( img_depth > 1 ) \r\n\t\tthrow iom::exception(iom::strprintf(\"image \\\"%s\\\" has more than one page.\\nSupported format is 2DTIFF\", img_path.c_str()), __iom__current__function__);\r\n}\n```\n",
        "response": "### Core API Usage Patterns for `TIFFReadDirectory`\n\n#### **API Functionality**  \n`TIFFReadDirectory` advances to the next directory (page) in a TIFF file, enabling traversal of multi-page TIFF structures. It is part of the libtiff library for reading TIFF metadata and content.\n\n---\n\n#### **Typical Usage**  \nUsed in a loop to count the number of directories (pages) when `TIFFTAG_PAGENUMBER` is unavailable or unreliable. Example:  \n```c\ndo {\n    img_depth++;\n} while (TIFFReadDirectory(input));  // Loop until no more directories\n```\n\n---\n\n#### **Key Parameters**  \n- **`TIFF* tif`**: Pointer to an open TIFF file handle (e.g., `input` in the code).  \n\n---\n\n#### **Return Values**  \n- **`1`**: Successfully advanced to the next directory.  \n- **`0`**: No more directories to read.  \n- **`-1`**: Error during directory read (not handled in the provided code).  \n\n---\n\n#### **Error Handling**  \n- **Unhandled Errors**: The code assumes non-zero returns indicate valid directories, but `-1` (error) could cause infinite loops.  \n- **Mitigation**: Check for `-1` and terminate early:  \n  ```c\n  int ret;\n  while ((ret = TIFFReadDirectory(input)) == 1) { ... }\n  if (ret == -1) { /* handle error */ }\n  ```\n\n---\n\n#### **Best Practices**  \n1. **Prefer `TIFFTAG_PAGENUMBER`**: Use built-in tags for page counts when available.  \n2. **Handle All Return Values**: Explicitly check for `-1` to avoid infinite loops on read errors.  \n3. **Reset Directory Index**: If further operations on the first directory are needed, reset with `TIFFSetDirectory(input, 0)`.  \n4. **Re-enable Error Handlers**: Restore libtiff’s default error/warning handlers after custom logic.  \n\n---\n\n#### **Code-Specific Notes**  \n- The loop counts directories to enforce a 2D TIFF requirement (`img_depth > 1` throws an error).  \n- Error suppression via `TIFFSetErrorHandler(0)` may hide critical issues; use judiciously."
    },
    {
        "prompt": "### Task Description:\nYou are an experienced software engineer skilled in API usage analysis. Your task is to analyze the following C/C++ code snippet and summarize the core API usage patterns for 'TIFFReadDirectory', focusing on:\n- API functionality\n- Typical usage\n- Key parameters\n- Return values\n- Error handling\n- Best practices\nProvide a concise and structured response.\n\n### Provided Code Snippet:\n```c\nint NativeDecoder::getDyrectoryCount()\n{\n    int dircount = 0;\n    do {\n        dircount++;\n    } while (TIFFReadDirectory(image));\n    return dircount;\n}\n```\n",
        "response": "### API Usage Summary for `TIFFReadDirectory`\n\n#### **API Functionality**\n- Advances the internal pointer to the next directory (IFD) in a TIFF file.\n- Used to iterate through multiple images/pages in a multi-directory TIFF.\n\n#### **Typical Usage**\n- Called in a loop to count or process all directories.\n- **Example**: The provided code uses a `do-while` loop to increment a counter until `TIFFReadDirectory` fails.\n\n#### **Key Parameters**\n- `TIFF* image`: A handle to an open TIFF file (passed as the sole parameter).\n\n#### **Return Values**\n- **1**: Successfully read the next directory.\n- **0**: No more directories or an error occurred (e.g., file corruption).\n\n#### **Error Handling**\n- **Critical Issue in Provided Code**: Treats `0` (error or end-of-file) as a loop exit but does not distinguish between errors and legitimate end-of-directories. This can lead to undercounting if an error occurs mid-read.\n- **Best Practice**: After `TIFFReadDirectory` returns `0`, check `TIFFGetLastError()` to differentiate between errors and end-of-file.\n\n#### **Best Practices**\n1. **Explicit Error Checking**:\n   ```c\n   int status;\n   do {\n       dircount++;\n       status = TIFFReadDirectory(image);\n   } while (status == 1); // Only continue on explicit success\n   if (status == -1) { // Handle errors via TIFFGetLastError()\n       log_error(\"Failed to read directory: %s\", TIFFGetLastError());\n   }\n   ```\n2. **Reset Directory State**: After counting, rewind to the first directory with `TIFFSetDirectory(image, 0)` if further processing is needed.\n3. **Avoid Assumptions**: Do not assume `TIFFReadDirectory` initializes the first directory; ensure the TIFF handle is properly opened and initialized before looping."
    },
    {
        "prompt": "### Task Description:\nYou are an experienced software engineer skilled in API usage analysis. Your task is to analyze the following C/C++ code snippet and summarize the core API usage patterns for 'TIFFReadDirectory', focusing on:\n- API functionality\n- Typical usage\n- Key parameters\n- Return values\n- Error handling\n- Best practices\nProvide a concise and structured response.\n\n### Provided Code Snippet:\n```c\nbool Import_3DTiff_Workspace::sizeOfDomain() {\n    uint32 bitsPerSample = 0;\n    uint16 rgb_check;\n\n    TIFF* input_Image;\n    TIFFSetWarningHandler(nullptr);\n    if((input_Image = TIFFOpen(fileName.c_str(), \"r\")) == nullptr){\n        X=-1;\n        return false;\n    }\n\n\n    if(input_Image) {\n        TIFFGetField(input_Image, TIFFTAG_IMAGEWIDTH, &X);\n        TIFFGetField(input_Image, TIFFTAG_IMAGELENGTH, &Y);\n        TIFFGetField(input_Image, TIFFTAG_BITSPERSAMPLE, &bitsPerSample);\n        TIFFGetField(input_Image, TIFFTAG_SAMPLESPERPIXEL, &rgb_check);\n    }\n\n    if(rgb_check == 3){\n        std::cout << \"Image must be grayscale, input is RGB.\" << std::endl;\n        X=-1;\n        return false;\n    }\n\n    if(bitsPerSample!=8){\n        if(bitsPerSample == 16 || bitsPerSample == 32){\n            std::cout << \"Image must be 8-bit\" << std::endl;\n            X=-1;\n            return false;\n        }\n        else {\n            bitsPerSample = 8;\n        }\n    }\n\n    int page=0;\n    while(true){\n        TIFFSetDirectory(input_Image, page);\n        page++;\n        if(!TIFFReadDirectory(input_Image)) {\n            break;\n        }\n    }\n    Z=page;\n\n    xMin = 0;\n    yMin = 0;\n    zMin = 0;\n    xMax = X-1;\n    yMax = Y-1;\n    zMax = Z-1;\n\n    TIFFClose(input_Image);\n\n    return true;\n}\n```\n",
        "response": "### Core API Usage Patterns for `TIFFReadDirectory`\n\n#### **API Functionality**\n- **Purpose**: Advances to and reads the next directory (page) in a multi-directory TIFF file, making it the current directory for subsequent operations.\n- **Library**: Part of the LibTIFF library for reading/writing TIFF files.\n\n#### **Typical Usage**\n- Iterating through all directories in a TIFF file to process multi-page images (e.g., stacks, volumes).\n- **Example**:  \n  ```c\n  int page_count = 0;\n  do {\n      // Process current directory\n      page_count++;\n  } while (TIFFReadDirectory(tif));\n  ```\n\n#### **Key Parameters**\n- **`TIFF* tif`**: A handle to an open TIFF file (obtained via `TIFFOpen`).\n\n#### **Return Values**\n- **`1`**: Successfully advanced to the next directory.\n- **`0`**: No more directories exist, or an error occurred (e.g., corrupt file).\n\n#### **Error Handling**\n- **Check Return Value**: A return value of `0` signals termination of the directory loop. However, it does not distinguish between end-of-file and actual errors.\n- **Best Practice**: Use `TIFFGetErrorHandler` to log or handle specific errors if critical.\n\n#### **Best Practices**\n1. **Avoid Redundant Calls**: Use `TIFFReadDirectory` directly in a loop instead of combining it with `TIFFSetDirectory` (as seen in the code snippet), unless explicit directory indexing is required.\n2. **Error Differentiation**: After loop termination, check if the end of directories was reached (expected) or an error occurred (unexpected) using LibTIFF error handlers.\n3. **Resource Management**: Always close the TIFF handle with `TIFFClose` after processing.\n\n---\n\n### Code Snippet Analysis\n- **Directory Counting Logic**: The code iterates through directories using `TIFFReadDirectory` but redundantly calls `TIFFSetDirectory` in each loop iteration. A simpler approach would be:\n  ```c\n  Z = 0;\n  while (TIFFReadDirectory(input_Image)) Z++;\n  ```\n- **Error Handling**: The code treats all `TIFFReadDirectory` failures as end-of-file, which may mask actual errors. No error messages are logged for debugging."
    },
    {
        "prompt": "### Task Description:\nYou are an experienced software engineer skilled in API usage analysis. Your task is to analyze the following C/C++ code snippet and summarize the core API usage patterns for 'TIFFReadDirectory', focusing on:\n- API functionality\n- Typical usage\n- Key parameters\n- Return values\n- Error handling\n- Best practices\nProvide a concise and structured response.\n\n### Provided Code Snippet:\n```c\nCPLErr GTiffDataset::CleanOverviews()\n\n{\n    CPLAssert( bBase );\n\n    ScanDirectories();\n\n    FlushDirectory();\n    *ppoActiveDSRef = nullptr;\n\n/* -------------------------------------------------------------------- */\n/*      Cleanup overviews objects, and get offsets to all overview      */\n/*      directories.                                                    */\n/* -------------------------------------------------------------------- */\n    std::vector<toff_t> anOvDirOffsets;\n\n    for( int i = 0; i < nOverviewCount; ++i )\n    {\n        anOvDirOffsets.push_back( papoOverviewDS[i]->nDirOffset );\n        delete papoOverviewDS[i];\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Loop through all the directories, translating the offsets       */\n/*      into indexes we can use with TIFFUnlinkDirectory().             */\n/* -------------------------------------------------------------------- */\n    std::vector<uint16> anOvDirIndexes;\n    int iThisOffset = 1;\n\n    TIFFSetDirectory( hTIFF, 0 );\n\n    while( true )\n    {\n        for( int i = 0; i < nOverviewCount; ++i )\n        {\n            if( anOvDirOffsets[i] == TIFFCurrentDirOffset( hTIFF ) )\n            {\n                CPLDebug( \"GTiff\", \"%d -> %d\",\n                          static_cast<int>(anOvDirOffsets[i]), iThisOffset );\n                anOvDirIndexes.push_back( static_cast<uint16>(iThisOffset) );\n            }\n        }\n\n        if( TIFFLastDirectory( hTIFF ) )\n            break;\n\n        TIFFReadDirectory( hTIFF );\n        ++iThisOffset;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Actually unlink the target directories.  Note that we do        */\n/*      this from last to first so as to avoid renumbering any of       */\n/*      the earlier directories we need to remove.                      */\n/* -------------------------------------------------------------------- */\n    while( !anOvDirIndexes.empty() )\n    {\n        TIFFUnlinkDirectory( hTIFF, anOvDirIndexes.back() );\n        anOvDirIndexes.pop_back();\n    }\n\n    CPLFree( papoOverviewDS );\n\n    nOverviewCount = 0;\n    papoOverviewDS = nullptr;\n\n    if( !SetDirectory() )\n        return CE_Failure;\n\n    return CE_None;\n}\n```\n",
        "response": "### Core API Usage Summary for `TIFFReadDirectory`\n\n#### **API Functionality**  \n`TIFFReadDirectory` advances the TIFF file's internal pointer to the next directory (IFD - Image File Directory). It is used to sequentially traverse directories in a TIFF file.\n\n#### **Typical Usage**  \nUsed in loops to iterate over all directories in a TIFF file. Commonly paired with `TIFFLastDirectory` to check for the end of the directory list.\n\n#### **Key Parameters**  \n- **`hTIFF` (TIFF*)**: A handle to the open TIFF file, initialized with `TIFFOpen` or similar.\n\n#### **Return Values**  \n- **`1` (success)**: Next directory was successfully read.\n- **`0` (failure)**: Error occurred (e.g., corrupted file, invalid handle).\n\n#### **Error Handling**  \n- **In the provided code**: Errors are **not handled** – the loop relies on `TIFFLastDirectory` to terminate, risking infinite loops or missed directories if `TIFFReadDirectory` fails.  \n- **Best practice**: Always check the return value. Example fix:  \n  ```c\n  if (!TIFFReadDirectory(hTIFF)) {\n      CPLError(CE_Failure, ...); // Log error\n      break; // Exit loop on failure\n  }\n  ```\n\n#### **Best Practices**  \n1. **Validate the TIFF handle**: Ensure `hTIFF` is valid before calling.  \n2. **Check return values**: Handle failures explicitly to avoid undefined behavior.  \n3. **Combine with `TIFFSetDirectory`**: Reset directory index (e.g., `TIFFSetDirectory(hTIFF, 0)`) before iteration.  \n4. **Avoid infinite loops**: Use `TIFFLastDirectory` with error-checking for robustness.  \n5. **Contextualize directories**: Track offsets/indexes (as in `anOvDirOffsets`) to map logical positions.  \n\n#### **Code-Specific Insight**  \nThe code uses `TIFFReadDirectory` to locate overview directories for unlinking. The lack of error-checking here is a critical oversight; a failure in `TIFFReadDirectory` could leave the TIFF handle in an invalid state, causing resource leaks or incorrect cleanup."
    },
    {
        "prompt": "### Task Description:\nYou are an experienced software engineer skilled in API usage analysis. Your task is to analyze the following C/C++ code snippet and summarize the core API usage patterns for 'TIFFReadDirectory', focusing on:\n- API functionality\n- Typical usage\n- Key parameters\n- Return values\n- Error handling\n- Best practices\nProvide a concise and structured response.\n\n### Provided Code Snippet:\n```c\nuint TiffPyramidReader::findLevel(const QSize& imageSize)\n{\n    TIFFSetDirectory(_impl->tif.get(), 0);\n\n    uint level = 0;\n    while (getImageSize() > imageSize && TIFFReadDirectory(_impl->tif.get()))\n        ++level;\n\n    return level;\n}\n```\n",
        "response": "### Core API Usage Patterns for `TIFFReadDirectory`\n\n#### **API Functionality**\n- **Purpose**: Reads the next directory (image) in a multi-directory TIFF file, advancing the internal pointer to the next image (e.g., lower pyramid level in a pyramidal TIFF).\n- **Behavior**: Parses metadata for the next directory, making it the active directory for subsequent operations.\n\n#### **Typical Usage**\n- Used in loops to iterate through directories sequentially.\n- Example:\n  ```c\n  TIFFSetDirectory(tif, 0); // Start at first directory\n  while (TIFFReadDirectory(tif)) {\n    // Process next directory\n  }\n  ```\n\n#### **Key Parameters**\n- **`TIFF* tif`**: A handle to the opened TIFF file.  \n  In the provided code: `_impl->tif.get()` retrieves the handle (likely via a smart pointer).\n\n#### **Return Values**\n- **`1`**: Success (next directory exists and is read).\n- **`0`**: Failure (no more directories or read error).\n\n#### **Error Handling**\n- **Limitation in Code**: The snippet does not distinguish between *end-of-directories* and *errors*.  \n  - If `TIFFReadDirectory` fails due to corruption, the loop exits prematurely, potentially returning an incorrect `level`.\n- **Best Practice**: After failure, use `TIFFGetError` or `TIFFLastError` to check for actual errors.\n\n#### **Best Practices**\n1. **Validate Directory Order**: Ensure directories are ordered by decreasing resolution (critical for pyramid workflows).\n2. **Explicit Error Checking**: After `TIFFReadDirectory` returns `0`, check for errors to avoid silent failures.\n3. **Reset State**: Use `TIFFSetDirectory(tif, 0)` before iteration to guarantee traversal starts at the first directory.\n4. **Bounds Safety**: Ensure the loop does not exceed the available directories (e.g., guard against invalid `level` values).\n\n#### **Code-Specific Analysis**\n- The loop iterates through directories starting at index 0, incrementing `level` for each valid subsequent directory, until the current image size ≤ target size or directories are exhausted.\n- **Assumption**: Directories are ordered from highest to lowest resolution. A violation of this order would cause incorrect level selection."
    },
    {
        "prompt": "### Task Description:\nYou are an experienced software engineer skilled in API usage analysis. Your task is to analyze the following C/C++ code snippet and summarize the core API usage patterns for 'TIFFReadDirectory', focusing on:\n- API functionality\n- Typical usage\n- Key parameters\n- Return values\n- Error handling\n- Best practices\nProvide a concise and structured response.\n\n### Provided Code Snippet:\n```c\nvoid GTiffDataset::ScanDirectories()\n\n{\n/* -------------------------------------------------------------------- */\n/*      We only scan once.  We do not scan for non-base datasets.       */\n/* -------------------------------------------------------------------- */\n    if( !bScanDeferred )\n        return;\n\n    bScanDeferred = false;\n\n    if( !bBase )\n        return;\n\n    if( TIFFLastDirectory( hTIFF ) )\n        return;\n\n    CPLDebug( \"GTiff\", \"ScanDirectories()\" );\n\n/* ==================================================================== */\n/*      Scan all directories.                                           */\n/* ==================================================================== */\n    CPLStringList aosSubdatasets;\n    int iDirIndex = 0;\n\n    FlushDirectory();\n    while( !TIFFLastDirectory( hTIFF )\n           && (iDirIndex == 0 || TIFFReadDirectory( hTIFF ) != 0) )\n    {\n        // Only libtiff 4.0.4 can handle between 32768 and 65535 directories.\n#if !defined(SUPPORTS_MORE_THAN_32768_DIRECTORIES)\n        if( iDirIndex == 32768 )\n            break;\n#endif\n        toff_t nThisDir = TIFFCurrentDirOffset(hTIFF);\n        uint32 nSubType = 0;\n\n        *ppoActiveDSRef = nullptr; // Our directory no longer matches this ds.\n\n        ++iDirIndex;\n\n        if( !TIFFGetField(hTIFF, TIFFTAG_SUBFILETYPE, &nSubType) )\n            nSubType = 0;\n\n        /* Embedded overview of the main image */\n        if( (nSubType & FILETYPE_REDUCEDIMAGE) != 0 &&\n            (nSubType & FILETYPE_MASK) == 0 &&\n            iDirIndex != 1 &&\n            nOverviewCount < 30 /* to avoid DoS */ )\n        {\n            GTiffDataset *poODS = new GTiffDataset();\n            poODS->osFilename = osFilename;\n            if( poODS->OpenOffset( hTIFF, ppoActiveDSRef, nThisDir, false,\n                                   eAccess ) != CE_None\n                || poODS->GetRasterCount() != GetRasterCount() )\n            {\n                delete poODS;\n            }\n            else\n            {\n                CPLDebug( \"GTiff\", \"Opened %dx%d overview.\",\n                          poODS->GetRasterXSize(), poODS->GetRasterYSize());\n                ++nOverviewCount;\n                papoOverviewDS = static_cast<GTiffDataset **>(\n                    CPLRealloc(papoOverviewDS,\n                               nOverviewCount * (sizeof(void*))) );\n                papoOverviewDS[nOverviewCount-1] = poODS;\n                poODS->poBaseDS = this;\n                poODS->bIsOverview_ = true;\n            }\n        }\n        // Embedded mask of the main image.\n        else if( (nSubType & FILETYPE_MASK) != 0 &&\n                 (nSubType & FILETYPE_REDUCEDIMAGE) == 0 &&\n                 iDirIndex != 1 &&\n                 poMaskDS == nullptr )\n        {\n            poMaskDS = new GTiffDataset();\n            poMaskDS->osFilename = osFilename;\n\n            // The TIFF6 specification - page 37 - only allows 1\n            // SamplesPerPixel and 1 BitsPerSample Here we support either 1 or\n            // 8 bit per sample and we support either 1 sample per pixel or as\n            // many samples as in the main image We don't check the value of\n            // the PhotometricInterpretation tag, which should be set to\n            // \"Transparency mask\" (4) according to the specification (page\n            // 36).  However, the TIFF6 specification allows image masks to\n            // have a higher resolution than the main image, what we don't\n            // support here.\n\n            if( poMaskDS->OpenOffset( hTIFF, ppoActiveDSRef, nThisDir,\n                                      false, eAccess ) != CE_None\n                || poMaskDS->GetRasterCount() == 0\n                || !(poMaskDS->GetRasterCount() == 1\n                     || poMaskDS->GetRasterCount() == GetRasterCount())\n                || poMaskDS->GetRasterXSize() != GetRasterXSize()\n                || poMaskDS->GetRasterYSize() != GetRasterYSize()\n                || poMaskDS->GetRasterBand(1)->GetRasterDataType() != GDT_Byte)\n            {\n                delete poMaskDS;\n                poMaskDS = nullptr;\n            }\n            else\n            {\n                CPLDebug( \"GTiff\", \"Opened band mask.\");\n                poMaskDS->poBaseDS = this;\n\n                poMaskDS->bPromoteTo8Bits =\n                    CPLTestBool(\n                        CPLGetConfigOption( \"GDAL_TIFF_INTERNAL_MASK_TO_8BIT\",\n                                            \"YES\" ) );\n            }\n        }\n\n        // Embedded mask of an overview.  The TIFF6 specification allows the\n        // combination of the FILETYPE_xxxx masks.\n        else if( (nSubType & FILETYPE_REDUCEDIMAGE) != 0 &&\n                 (nSubType & FILETYPE_MASK) != 0 &&\n                 iDirIndex != 1 )\n        {\n            GTiffDataset* poDS = new GTiffDataset();\n            poDS->osFilename = osFilename;\n            if( poDS->OpenOffset( hTIFF, ppoActiveDSRef, nThisDir, FALSE,\n                                  eAccess ) != CE_None\n                || poDS->GetRasterCount() == 0\n                || poDS->GetRasterBand(1)->GetRasterDataType() != GDT_Byte)\n            {\n                delete poDS;\n            }\n            else\n            {\n                int i = 0;  // Used after for.\n                for( ; i < nOverviewCount; ++i )\n                {\n                    if( cpl::down_cast<GTiffDataset *>(GDALDataset::FromHandle(\n                           papoOverviewDS[i]))->poMaskDS == nullptr &&\n                        poDS->GetRasterXSize() ==\n                        papoOverviewDS[i]->GetRasterXSize() &&\n                        poDS->GetRasterYSize() ==\n                        papoOverviewDS[i]->GetRasterYSize() &&\n                        (poDS->GetRasterCount() == 1 ||\n                         poDS->GetRasterCount() == GetRasterCount()))\n                    {\n                        CPLDebug(\n                            \"GTiff\", \"Opened band mask for %dx%d overview.\",\n                            poDS->GetRasterXSize(), poDS->GetRasterYSize());\n                        cpl::down_cast<GTiffDataset*>(GDALDataset::FromHandle(\n                            papoOverviewDS[i]))->\n                            poMaskDS = poDS;\n                        poDS->bPromoteTo8Bits =\n                            CPLTestBool(\n                                CPLGetConfigOption(\n                                    \"GDAL_TIFF_INTERNAL_MASK_TO_8BIT\",\n                                    \"YES\" ) );\n                        poDS->poBaseDS = this;\n                        break;\n                    }\n                }\n                if( i == nOverviewCount )\n                {\n                    delete poDS;\n                }\n            }\n        }\n        else if( nSubType == 0 || nSubType == FILETYPE_PAGE )\n        {\n            uint32 nXSize = 0;\n            uint32 nYSize = 0;\n\n            TIFFGetField( hTIFF, TIFFTAG_IMAGEWIDTH, &nXSize );\n            TIFFGetField( hTIFF, TIFFTAG_IMAGELENGTH, &nYSize );\n\n            if( nXSize > INT_MAX || nYSize > INT_MAX )\n            {\n                CPLDebug(\"GTiff\",\n                         \"Skipping directory with too large image: %u x %u\",\n                         nXSize, nYSize);\n            }\n            else\n            {\n                uint16 nSPP = 0;\n                if( !TIFFGetField(hTIFF, TIFFTAG_SAMPLESPERPIXEL, &nSPP ) )\n                    nSPP = 1;\n\n                CPLString osName, osDesc;\n                osName.Printf( \"SUBDATASET_%d_NAME=GTIFF_DIR:%d:%s\",\n                            iDirIndex, iDirIndex, osFilename.c_str() );\n                osDesc.Printf( \"SUBDATASET_%d_DESC=Page %d (%dP x %dL x %dB)\",\n                            iDirIndex, iDirIndex,\n                            static_cast<int>(nXSize),\n                            static_cast<int>(nYSize),\n                            nSPP );\n\n                aosSubdatasets.AddString(osName);\n                aosSubdatasets.AddString(osDesc);\n            }\n        }\n\n        // Make sure we are stepping from the expected directory regardless\n        // of churn done processing the above.\n        if( TIFFCurrentDirOffset(hTIFF) != nThisDir )\n            TIFFSetSubDirectory( hTIFF, nThisDir );\n        *ppoActiveDSRef = nullptr;\n    }\n\n    // Nasty hack. Probably something that should be fixed in libtiff\n    // In case the last directory cycles to the first directory, we have\n    // TIFFCurrentDirOffset(hTIFF) == nDirOffset, but the TIFFReadDirectory()\n    // hasn't done its job, so SetDirectory() would be confused and think it\n    // has nothing to do. To avoid that reset to a fake offset before calling\n    // SetDirectory()\n    // This can also occur if the last directory cycles to the IFD of the\n    // mask dataset and we activate this mask dataset.\n    // So always completely reset\n    TIFFSetSubDirectory( hTIFF, 0 );\n    *ppoActiveDSRef = nullptr;\n    CPL_IGNORE_RET_VAL( SetDirectory() );\n\n    // If we have a mask for the main image, loop over the overviews, and if\n    // they have a mask, let's set this mask as an overview of the main mask.\n    if( poMaskDS != nullptr )\n    {\n        for( int i = 0; i < nOverviewCount; ++i )\n        {\n            if( cpl::down_cast<GTiffDataset *>(GDALDataset::FromHandle(\n                   papoOverviewDS[i]))->poMaskDS != nullptr)\n            {\n                ++poMaskDS->nOverviewCount;\n                poMaskDS->papoOverviewDS = static_cast<GTiffDataset **>(\n                    CPLRealloc(poMaskDS->papoOverviewDS,\n                               poMaskDS->nOverviewCount * (sizeof(void*))) );\n                poMaskDS->papoOverviewDS[poMaskDS->nOverviewCount-1] =\n                    cpl::down_cast<GTiffDataset*>(GDALDataset::FromHandle(\n                        papoOverviewDS[i]))->poMaskDS;\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Only keep track of subdatasets if we have more than one         */\n/*      subdataset (pair).                                              */\n/* -------------------------------------------------------------------- */\n    if( aosSubdatasets.size() > 2 )\n    {\n        oGTiffMDMD.SetMetadata( aosSubdatasets.List(), \"SUBDATASETS\" );\n    }\n}\n```\n",
        "response": "### Core API Usage Patterns for `TIFFReadDirectory`\n\n#### **API Functionality**\n- **Purpose**: Reads the next directory (image or metadata structure) in a TIFF file, advancing the internal file pointer. Enables traversal of multi-directory TIFF files (e.g., multi-page images, overviews, masks).\n\n#### **Typical Usage**\n- **Iterating Directories**: Used in a loop to sequentially process all directories in a TIFF file. Example:\n  ```c\n  while (!TIFFLastDirectory(hTIFF) && TIFFReadDirectory(hTIFF) != 0) {\n      // Process directory...\n  }\n  ```\n\n#### **Key Parameters**\n- **`hTIFF`** (`TIFF*`): A handle to the open TIFF file, managed by libtiff. Represents the current file context.\n\n#### **Return Values**\n- **Success**: Returns `1` if the next directory is successfully read.\n- **Failure/End**: Returns `0` if no more directories exist or an error occurs (e.g., corrupt file).\n\n#### **Error Handling**\n- **Implicit Termination**: The loop exits if `TIFFReadDirectory` returns `0`, stopping further processing. No explicit error logging is shown, but libtiff may internally report errors (e.g., via `TIFFError`).\n- **State Management**: After the loop, `TIFFSetSubDirectory` resets the directory offset to ensure consistent state.\n\n#### **Best Practices**\n1. **Directory Limits**: Use compile-time guards (e.g., `SUPPORTS_MORE_THAN_32768_DIRECTORIES`) to handle older libtiff versions with directory count limitations.\n2. **Offset Tracking**: Use `TIFFCurrentDirOffset` to track directory positions and validate/reset state with `TIFFSetSubDirectory` if needed.\n3. **Loop Safeguards**: Include conditions to avoid infinite loops (e.g., `TIFFLastDirectory` checks, directory index limits).\n4. **Resource Management**: Ensure proper cleanup (e.g., closing datasets, freeing memory) if directory parsing fails mid-loop.\n5. **Subdataset Filtering**: Filter directories based on tags (e.g., `TIFFTAG_SUBFILETYPE`) to handle specific structures (overviews, masks).\n\n---\n\n### Summary\n`TIFFReadDirectory` is critical for iterating through multi-directory TIFF files. Proper usage involves checking return values, managing directory offsets, and enforcing safeguards to handle edge cases (e.g., large file support, invalid directories). The provided code demonstrates robust traversal while handling embedded overviews, masks, and subdatasets."
    },
    {
        "prompt": "### Task Description:\nYou are an experienced software engineer skilled in API usage analysis. Your task is to analyze the following C/C++ code snippet and summarize the core API usage patterns for 'TIFFReadDirectory', focusing on:\n- API functionality\n- Typical usage\n- Key parameters\n- Return values\n- Error handling\n- Best practices\nProvide a concise and structured response.\n\n### Provided Code Snippet:\n```c\nbool getInfo(TIFF* tif, Vec3c& dimensions, ImageDataType& dataType, size_t& pixelSizeBytes, uint64_t& rawDataOffset, string& reason)\n\t\t\t{\n\t\t\t\t// Read information from all .tif directories and make sure that all of them match.\n\n\t\t\t\tcoord_t imageJDepth;\n\t\t\t\tuint64_t imageJOffset;\n\t\t\t\tif (!getCurrentDirectoryInfo(tif, dimensions, dataType, pixelSizeBytes, imageJDepth, imageJOffset, reason))\n\t\t\t\t\treturn false;\n\n\t\t\t\tcoord_t dirCount = 1;\n\n\t\t\t\tif (TIFFLastDirectory(tif) == 0)\n\t\t\t\t{\n\t\t\t\t\tdo\n\t\t\t\t\t{\n\t\t\t\t\t\tif (TIFFReadDirectory(tif) != 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treason = \"Unable to read TIFF directory. The file is invalid.\";\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (dimensions.z > 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treason = \"TIFF file contains 3D slices.\";\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tVec3c currDims;\n\t\t\t\t\t\tImageDataType currDT;\n\t\t\t\t\t\tsize_t currPixelSizeBytes;\n\t\t\t\t\t\tcoord_t dummy1;\n\t\t\t\t\t\tuint64_t dummy2;\n\t\t\t\t\t\tif (!getCurrentDirectoryInfo(tif, currDims, currDT, currPixelSizeBytes, dummy1, dummy2, reason))\n\t\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t\tif (currDims != dimensions || currDims.z > 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdimensions = Vec3c(0, 0, 0);\n\t\t\t\t\t\t\treason = \"TIFF file contains slices of different dimensions.\";\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (currDT != dataType)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treason = \"TIFF file contains data of unsupported pixel data type.\";\n\t\t\t\t\t\t\tdataType = ImageDataType::Unknown;\n\t\t\t\t\t\t\tcurrPixelSizeBytes = 0;\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (currPixelSizeBytes != pixelSizeBytes)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treason = \"TIFF file contains slices of multiple pixel data types.\";\n\t\t\t\t\t\t\tpixelSizeBytes = 0;\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdirCount++;\n\n\t\t\t\t\t} while (TIFFLastDirectory(tif) == 0);\n\t\t\t\t}\n\n\t\t\t\tTIFFSetDirectory(tif, 0);\n\n\t\t\t\tif (imageJDepth > dirCount)\n\t\t\t\t{\n\t\t\t\t\t// This is an ImageJ fake tiff.\n\t\t\t\t\tdimensions.z = imageJDepth;\n\t\t\t\t\trawDataOffset = imageJOffset;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// This is a normal tiff where each slice is in separate tiff directory.\n\t\t\t\t\tdimensions.z = dirCount;\n\t\t\t\t\trawDataOffset = 0;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n```\n",
        "response": "### Core API Usage Patterns for `TIFFReadDirectory`\n\n#### **API Functionality**  \n`TIFFReadDirectory` advances the TIFF file pointer to the next directory (image slice) in a multi-directory TIFF file. It is used to iterate through all directories to validate consistency in multi-slice TIFF files.\n\n---\n\n#### **Typical Usage**  \n- Called in a loop (`do-while` in the snippet) to process all directories.  \n- Paired with `TIFFLastDirectory` to check if the current directory is the last one.  \n- Validates slice uniformity (dimensions, data type, pixel size) across directories.  \n\n---\n\n#### **Key Parameters**  \n- `TIFF* tif`: Pointer to the open TIFF file handle.  \n\n---\n\n#### **Return Values**  \n- **`1`**: Successfully read the next directory.  \n- **`0` or negative value**: Failure to read (invalid file or corrupted directory).  \n\n---\n\n#### **Error Handling**  \n- **Explicit check**: Return value `!= 1` triggers an error with a descriptive `reason` string.  \n- **Termination**: Returns `false` immediately on failure to prevent invalid state propagation.  \n\n---\n\n#### **Best Practices**  \n1. **Loop Safely**: Use `TIFFLastDirectory` to control iteration boundaries.  \n2. **Reset State**: After processing, reset to the first directory with `TIFFSetDirectory(tif, 0)`.  \n3. **Consistency Checks**: Validate uniformity of metadata (dimensions, data type) across directories.  \n4. **Robust Error Messaging**: Provide specific failure reasons (e.g., \"slices of different dimensions\").  \n5. **Handle Multi-Directories**: Account for ImageJ-specific TIFF quirks (e.g., fake 3D depth vs. normal multi-directory files).  \n\n--- \n\n### Summary  \n`TIFFReadDirectory` enables traversal of TIFF directories for validation. The code ensures all slices are consistent, handles errors gracefully, and addresses edge cases like ImageJ-formatted files."
    },
    {
        "prompt": "### Task Description:\nYou are an experienced software engineer skilled in API usage analysis. Your task is to analyze the following C/C++ code snippet and summarize the core API usage patterns for 'TIFFReadDirectory', focusing on:\n- API functionality\n- Typical usage\n- Key parameters\n- Return values\n- Error handling\n- Best practices\nProvide a concise and structured response.\n\n### Provided Code Snippet:\n```c\nstd::unique_ptr<GTiffGrid> GTiffDataset::nextGrid() {\n    if (!m_hasNextGrid)\n        return nullptr;\n    if (m_nextDirOffset) {\n        TIFFSetSubDirectory(m_hTIFF, m_nextDirOffset);\n    }\n\n    uint32 width = 0;\n    uint32 height = 0;\n    TIFFGetField(m_hTIFF, TIFFTAG_IMAGEWIDTH, &width);\n    TIFFGetField(m_hTIFF, TIFFTAG_IMAGELENGTH, &height);\n    if (width == 0 || height == 0 || width > INT_MAX || height > INT_MAX) {\n        pj_log(m_ctx, PJ_LOG_ERROR, \"Invalid image size\");\n        return nullptr;\n    }\n\n    uint16 samplesPerPixel = 0;\n    if (!TIFFGetField(m_hTIFF, TIFFTAG_SAMPLESPERPIXEL, &samplesPerPixel)) {\n        pj_log(m_ctx, PJ_LOG_ERROR, \"Missing SamplesPerPixel tag\");\n        return nullptr;\n    }\n    if (samplesPerPixel == 0) {\n        pj_log(m_ctx, PJ_LOG_ERROR, \"Invalid SamplesPerPixel value\");\n        return nullptr;\n    }\n\n    uint16 bitsPerSample = 0;\n    if (!TIFFGetField(m_hTIFF, TIFFTAG_BITSPERSAMPLE, &bitsPerSample)) {\n        pj_log(m_ctx, PJ_LOG_ERROR, \"Missing BitsPerSample tag\");\n        return nullptr;\n    }\n\n    uint16 planarConfig = 0;\n    if (!TIFFGetField(m_hTIFF, TIFFTAG_PLANARCONFIG, &planarConfig)) {\n        pj_log(m_ctx, PJ_LOG_ERROR, \"Missing PlanarConfig tag\");\n        return nullptr;\n    }\n\n    uint16 sampleFormat = 0;\n    if (!TIFFGetField(m_hTIFF, TIFFTAG_SAMPLEFORMAT, &sampleFormat)) {\n        pj_log(m_ctx, PJ_LOG_ERROR, \"Missing SampleFormat tag\");\n        return nullptr;\n    }\n\n    TIFFDataType dt;\n    if (sampleFormat == SAMPLEFORMAT_INT && bitsPerSample == 16)\n        dt = TIFFDataType::Int16;\n    else if (sampleFormat == SAMPLEFORMAT_UINT && bitsPerSample == 16)\n        dt = TIFFDataType::UInt16;\n    else if (sampleFormat == SAMPLEFORMAT_INT && bitsPerSample == 32)\n        dt = TIFFDataType::Int32;\n    else if (sampleFormat == SAMPLEFORMAT_UINT && bitsPerSample == 32)\n        dt = TIFFDataType::UInt32;\n    else if (sampleFormat == SAMPLEFORMAT_IEEEFP && bitsPerSample == 32)\n        dt = TIFFDataType::Float32;\n    else if (sampleFormat == SAMPLEFORMAT_IEEEFP && bitsPerSample == 64)\n        dt = TIFFDataType::Float64;\n    else {\n        pj_log(\n            m_ctx, PJ_LOG_ERROR,\n            \"Unsupported combination of SampleFormat and BitsPerSample values\");\n        return nullptr;\n    }\n\n    uint16 photometric = PHOTOMETRIC_MINISBLACK;\n    if (!TIFFGetField(m_hTIFF, TIFFTAG_PHOTOMETRIC, &photometric))\n        photometric = PHOTOMETRIC_MINISBLACK;\n    if (photometric != PHOTOMETRIC_MINISBLACK) {\n        pj_log(m_ctx, PJ_LOG_ERROR, \"Unsupported Photometric value\");\n        return nullptr;\n    }\n\n    uint16 compression = COMPRESSION_NONE;\n    if (!TIFFGetField(m_hTIFF, TIFFTAG_COMPRESSION, &compression))\n        compression = COMPRESSION_NONE;\n\n    if (compression != COMPRESSION_NONE &&\n        !TIFFIsCODECConfigured(compression)) {\n        pj_log(m_ctx, PJ_LOG_ERROR,\n               \"Cannot open TIFF file due to missing codec.\");\n        return nullptr;\n    }\n    // We really don't want to try dealing with old-JPEG images\n    if (compression == COMPRESSION_OJPEG) {\n        pj_log(m_ctx, PJ_LOG_ERROR, \"Unsupported compression method.\");\n        return nullptr;\n    }\n\n    const auto blockSize = TIFFIsTiled(m_hTIFF) ? TIFFTileSize64(m_hTIFF)\n                                                : TIFFStripSize64(m_hTIFF);\n    if (blockSize == 0 || blockSize > 64 * 1024 * 2014) {\n        pj_log(m_ctx, PJ_LOG_ERROR, \"Unsupported block size.\");\n        return nullptr;\n    }\n\n    unsigned short count = 0;\n    unsigned short *geokeys = nullptr;\n    bool pixelIsArea = false;\n\n    ExtentAndRes extent;\n    extent.isGeographic = true;\n\n    if (!TIFFGetField(m_hTIFF, TIFFTAG_GEOKEYDIRECTORY, &count, &geokeys)) {\n        pj_log(m_ctx, PJ_LOG_DEBUG_MINOR, \"No GeoKeys tag\");\n    } else {\n        if (count < 4 || (count % 4) != 0) {\n            pj_log(m_ctx, PJ_LOG_ERROR,\n                   \"Wrong number of values in GeoKeys tag\");\n            return nullptr;\n        }\n\n        if (geokeys[0] != 1) {\n            pj_log(m_ctx, PJ_LOG_ERROR, \"Unsupported GeoTIFF major version\");\n            return nullptr;\n        }\n        // We only know that we support GeoTIFF 1.0 and 1.1 at that time\n        if (geokeys[1] != 1 || geokeys[2] > 1) {\n            pj_log(m_ctx, PJ_LOG_DEBUG_MINOR,\n                   \"GeoTIFF %d.%d possibly not handled\", geokeys[1],\n                   geokeys[2]);\n        }\n\n        for (unsigned int i = 4; i + 3 < count; i += 4) {\n            constexpr unsigned short GTModelTypeGeoKey = 1024;\n            constexpr unsigned short ModelTypeProjected = 1;\n            constexpr unsigned short ModelTypeGeographic = 2;\n\n            constexpr unsigned short GTRasterTypeGeoKey = 1025;\n            constexpr unsigned short RasterPixelIsArea = 1;\n            // constexpr unsigned short RasterPixelIsPoint = 2;\n\n            if (geokeys[i] == GTModelTypeGeoKey) {\n                if (geokeys[i + 3] == ModelTypeProjected) {\n                    extent.isGeographic = false;\n                } else if (geokeys[i + 3] != ModelTypeGeographic) {\n                    pj_log(m_ctx, PJ_LOG_ERROR,\n                           \"Only GTModelTypeGeoKey = \"\n                           \"ModelTypeGeographic or ModelTypeProjected are \"\n                           \"supported\");\n                    return nullptr;\n                }\n            } else if (geokeys[i] == GTRasterTypeGeoKey) {\n                if (geokeys[i + 3] == RasterPixelIsArea) {\n                    pixelIsArea = true;\n                }\n            }\n        }\n    }\n\n    double hRes = 0;\n    double vRes = 0;\n    double west = 0;\n    double north = 0;\n\n    double *matrix = nullptr;\n    if (TIFFGetField(m_hTIFF, TIFFTAG_GEOTRANSMATRIX, &count, &matrix) &&\n        count == 16) {\n        // If using GDAL to produce a bottom-up georeferencing, it will produce\n        // a GeoTransformationMatrix, since negative values in GeoPixelScale\n        // have historically been implementation bugs.\n        if (matrix[1] != 0 || matrix[4] != 0) {\n            pj_log(m_ctx, PJ_LOG_ERROR, \"Rotational terms not supported in \"\n                                        \"GeoTransformationMatrix tag\");\n            return nullptr;\n        }\n\n        west = matrix[3];\n        hRes = matrix[0];\n        north = matrix[7];\n        vRes = -matrix[5]; // negation to simulate GeoPixelScale convention\n    } else {\n        double *geopixelscale = nullptr;\n        if (TIFFGetField(m_hTIFF, TIFFTAG_GEOPIXELSCALE, &count,\n                         &geopixelscale) != 1) {\n            pj_log(m_ctx, PJ_LOG_ERROR, \"No GeoPixelScale tag\");\n            return nullptr;\n        }\n        if (count != 3) {\n            pj_log(m_ctx, PJ_LOG_ERROR,\n                   \"Wrong number of values in GeoPixelScale tag\");\n            return nullptr;\n        }\n        hRes = geopixelscale[0];\n        vRes = geopixelscale[1];\n\n        double *geotiepoints = nullptr;\n        if (TIFFGetField(m_hTIFF, TIFFTAG_GEOTIEPOINTS, &count,\n                         &geotiepoints) != 1) {\n            pj_log(m_ctx, PJ_LOG_ERROR, \"No GeoTiePoints tag\");\n            return nullptr;\n        }\n        if (count != 6) {\n            pj_log(m_ctx, PJ_LOG_ERROR,\n                   \"Wrong number of values in GeoTiePoints tag\");\n            return nullptr;\n        }\n\n        west = geotiepoints[3] - geotiepoints[0] * hRes;\n        north = geotiepoints[4] + geotiepoints[1] * vRes;\n    }\n\n    if (pixelIsArea) {\n        west += 0.5 * hRes;\n        north -= 0.5 * vRes;\n    }\n\n    const double mulFactor = extent.isGeographic ? DEG_TO_RAD : 1;\n    extent.west = west * mulFactor;\n    extent.north = north * mulFactor;\n    extent.resX = hRes * mulFactor;\n    extent.resY = fabs(vRes) * mulFactor;\n    extent.east = (west + hRes * (width - 1)) * mulFactor;\n    extent.south = (north - vRes * (height - 1)) * mulFactor;\n\n    if (vRes < 0) {\n        std::swap(extent.north, extent.south);\n    }\n\n    if (!((!extent.isGeographic ||\n           (fabs(extent.west) <= 4 * M_PI && fabs(extent.east) <= 4 * M_PI &&\n            fabs(extent.north) <= M_PI + 1e-5 &&\n            fabs(extent.south) <= M_PI + 1e-5)) &&\n          extent.west < extent.east && extent.south < extent.north &&\n          extent.resX > 1e-10 && extent.resY > 1e-10)) {\n        pj_log(m_ctx, PJ_LOG_ERROR, \"Inconsistent georeferencing for %s\",\n               m_filename.c_str());\n        return nullptr;\n    }\n\n    auto ret = std::unique_ptr<GTiffGrid>(new GTiffGrid(\n        m_ctx, m_hTIFF, m_cache, m_fp.get(), m_ifdIdx, m_filename, width,\n        height, extent, dt, samplesPerPixel, planarConfig, vRes < 0));\n    m_ifdIdx++;\n    m_hasNextGrid = TIFFReadDirectory(m_hTIFF) != 0;\n    m_nextDirOffset = TIFFCurrentDirOffset(m_hTIFF);\n    return ret;\n}\n```\n",
        "response": "### Core API Usage Summary for `TIFFReadDirectory`:\n\n1. **API Functionality**:  \n   `TIFFReadDirectory` advances the TIFF file handle to the next directory (image) in a multi-image TIFF file. It is used to iterate through sub-images or grids stored in the file.\n\n2. **Typical Usage**:  \n   Called in a loop to process successive directories (e.g., grids in a GeoTIFF). Example flow:\n   ```c++\n   while (TIFFReadDirectory(tiffHandle)) {\n       // Process the next directory\n   }\n   ```\n   In the provided code, it checks for remaining directories after initializing a grid.\n\n3. **Key Parameters**:  \n   - `TIFF* tif`: A handle to the opened TIFF file (`m_hTIFF` in the code).\n\n4. **Return Values**:  \n   - **Non-zero (1)**: Successfully read the next directory.\n   - **Zero (0)**: No more directories or an error occurred.\n\n5. **Error Handling**:  \n   - The code checks `TIFFReadDirectory`’s return value to update `m_hasNextGrid`, terminating iteration on failure/end.\n   - **Limitation**: Errors (e.g., corrupt directories) are treated as \"no more data\" without explicit error logging. Best practice would use `TIFFGetLastError()` to distinguish between EOF and genuine errors.\n\n6. **Best Practices**:  \n   - **Iterate Safely**: Use `TIFFReadDirectory` in a loop to handle multi-directory files.\n   - **Offset Management**: Use `TIFFCurrentDirOffset` to track directory positions (as done with `m_nextDirOffset`).\n   - **Error Differentiation**: Check `TIFFGetLastError()` to log specific errors (missing in the provided code).\n   - **State Validation**: Ensure the TIFF handle is valid and properly initialized before iteration.\n\n### Code-Specific Observations:\n- The code uses `TIFFReadDirectory` to drive iteration through grids, updating `m_hasNextGrid` and `m_nextDirOffset`.\n- Relies on `TIFFSetSubDirectory` to jump to specific offsets when resuming from `m_nextDirOffset`.\n- Lacks explicit error logging for `TIFFReadDirectory` failures, which could hide issues like file corruption."
    },
    {
        "prompt": "### Task Description:\nYou are an experienced software engineer skilled in API usage analysis. Your task is to analyze the following C/C++ code snippet and summarize the core API usage patterns for 'TIFFReadDirectory', focusing on:\n- API functionality\n- Typical usage\n- Key parameters\n- Return values\n- Error handling\n- Best practices\nProvide a concise and structured response.\n\n### Provided Code Snippet:\n```c\nGDALDataset *GTiffDataset::OpenDir( GDALOpenInfo * poOpenInfo )\n\n{\n    bool bAllowRGBAInterface = true;\n    const char* pszFilename = poOpenInfo->pszFilename;\n    if( STARTS_WITH_CI(pszFilename, \"GTIFF_RAW:\") )\n    {\n        bAllowRGBAInterface = false;\n        pszFilename += strlen(\"GTIFF_RAW:\");\n    }\n\n    if( !STARTS_WITH_CI(pszFilename, \"GTIFF_DIR:\") ||\n        pszFilename[strlen(\"GTIFF_DIR:\")] == '\\0' )\n    {\n        return nullptr;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Split out filename, and dir#/offset.                            */\n/* -------------------------------------------------------------------- */\n    pszFilename += strlen(\"GTIFF_DIR:\");\n    bool bAbsolute = false;\n\n    if( STARTS_WITH_CI(pszFilename, \"off:\") )\n    {\n        bAbsolute = true;\n        pszFilename += 4;\n    }\n\n    toff_t nOffset = atol(pszFilename);\n    pszFilename += 1;\n\n    while( *pszFilename != '\\0' && pszFilename[-1] != ':' )\n        ++pszFilename;\n\n    if( *pszFilename == '\\0' || nOffset == 0 )\n    {\n        ReportError(pszFilename, CE_Failure, CPLE_OpenFailed,\n            \"Unable to extract offset or filename, should take the form:\\n\"\n            \"GTIFF_DIR:<dir>:filename or GTIFF_DIR:off:<dir_offset>:filename\" );\n        return nullptr;\n    }\n\n    if( poOpenInfo->eAccess == GA_Update )\n    {\n        ReportError(\n            pszFilename, CE_Warning, CPLE_AppDefined,\n            \"Opening a specific TIFF directory is not supported in \"\n            \"update mode. Switching to read-only\" );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Try opening the dataset.                                        */\n/* -------------------------------------------------------------------- */\n    if( !GTiffOneTimeInit() )\n        return nullptr;\n\n    const char* pszFlag = poOpenInfo->eAccess == GA_Update ? \"r+D\" : \"rDO\";\n    VSILFILE* l_fpL = VSIFOpenL(pszFilename, pszFlag);\n    if( l_fpL == nullptr )\n        return nullptr;\n    TIFF *l_hTIFF = VSI_TIFFOpen( pszFilename, pszFlag, l_fpL );\n    if( l_hTIFF == nullptr )\n    {\n        CPL_IGNORE_RET_VAL(VSIFCloseL(l_fpL));\n        return nullptr;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If a directory was requested by index, advance to it now.       */\n/* -------------------------------------------------------------------- */\n    if( !bAbsolute )\n    {\n        const toff_t nOffsetRequested = nOffset;\n        while( nOffset > 1 )\n        {\n            if( TIFFReadDirectory( l_hTIFF ) == 0 )\n            {\n                XTIFFClose( l_hTIFF );\n                ReportError(\n                    pszFilename, CE_Failure, CPLE_OpenFailed,\n                    \"Requested directory %lu not found.\",\n                    static_cast<long unsigned int>(nOffsetRequested));\n                CPL_IGNORE_RET_VAL(VSIFCloseL(l_fpL));\n                return nullptr;\n            }\n            nOffset--;\n        }\n\n        nOffset = TIFFCurrentDirOffset( l_hTIFF );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Create a corresponding GDALDataset.                             */\n/* -------------------------------------------------------------------- */\n    GTiffDataset *poDS = new GTiffDataset();\n    poDS->SetDescription( poOpenInfo->pszFilename );\n    poDS->m_pszFilename = CPLStrdup(pszFilename);\n    poDS->m_fpL = l_fpL;\n    poDS->m_hTIFF = l_hTIFF;\n    poDS->m_bSingleIFDOpened = true;\n\n    if( !EQUAL(pszFilename,poOpenInfo->pszFilename)\n        && !STARTS_WITH_CI(poOpenInfo->pszFilename, \"GTIFF_RAW:\") )\n    {\n        poDS->SetPhysicalFilename( pszFilename );\n        poDS->SetSubdatasetName( poOpenInfo->pszFilename );\n    }\n\n    if( poOpenInfo->AreSiblingFilesLoaded() )\n        poDS->oOvManager.TransferSiblingFiles(\n            poOpenInfo->StealSiblingFiles() );\n\n    if( poDS->OpenOffset( l_hTIFF,\n                          nOffset, poOpenInfo->eAccess,\n                          bAllowRGBAInterface, true ) != CE_None )\n    {\n        delete poDS;\n        return nullptr;\n    }\n\n    return poDS;\n}\n```\n",
        "response": "### Core API Usage Patterns for `TIFFReadDirectory`\n\n#### **API Functionality**\n- **Purpose**: `TIFFReadDirectory` is used to read the next directory (subfile/image) in a TIFF file. It enables navigation between multiple directories within a TIFF file, which is essential for accessing non-default or sequential image data.\n\n#### **Typical Usage**\n- **Sequential Directory Access**: Used in a loop to advance to a specific directory index (e.g., to access the `n`-th directory by iterating `n-1` times from the first directory).\n- **Handling Multi-Directory Files**: Critical for workflows requiring access to specific subfiles without prior knowledge of their offsets.\n\n#### **Key Parameters**\n- **`TIFF *tif`**: A handle to an open TIFF file. This is the only parameter for `TIFFReadDirectory`.\n\n#### **Return Values**\n- **Success**: Returns `1` if the next directory is successfully read.\n- **Failure**: Returns `0` if no more directories exist or an error occurs.\n\n#### **Error Handling**\n- **Explicit Checks**: Return values are checked immediately after invocation. A failure triggers cleanup (e.g., closing the TIFF handle) and error reporting.\n- **Contextual Feedback**: Errors include details like the requested directory index (e.g., `ReportError` with `CE_Failure` and `CPLE_OpenFailed` in the provided code).\n\n#### **Best Practices**\n1. **Loop Safeguards**: Use loop counters to avoid infinite loops when advancing to a target directory (e.g., `while (nOffset > 1)`).\n2. **State Validation**: After directory navigation, confirm the current directory offset with `TIFFCurrentDirOffset` for accuracy.\n3. **Resource Cleanup**: Ensure the TIFF handle (`l_hTIFF`) and associated file pointers (`l_fpL`) are closed on failure to prevent leaks.\n4. **Read-Only Preference**: Avoid using `TIFFReadDirectory` in write modes (`GA_Update`), as directory navigation in update mode is often unsupported (see code warning).\n5. **Error Granularity**: Provide specific error messages (e.g., directory index not found) to aid debugging.\n\n---\n\n### **Summary in Code Context**\nThe provided code uses `TIFFReadDirectory` to iterate through TIFF directories until reaching a user-specified index (`nOffset`). Key steps include:\n1. **Loop Execution**: Decrement `nOffset` while calling `TIFFReadDirectory` until the target directory is reached.\n2. **Failure Handling**: If `TIFFReadDirectory` returns `0`, the TIFF handle is closed, and an error is reported.\n3. **Offset Validation**: After iteration, `TIFFCurrentDirOffset` retrieves the final directory offset for further operations."
    },
    {
        "prompt": "### Task Description:\nYou are an experienced software engineer skilled in API usage analysis. Your task is to analyze the following C/C++ code snippet and summarize the core API usage patterns for 'TIFFReadDirectory', focusing on:\n- API functionality\n- Typical usage\n- Key parameters\n- Return values\n- Error handling\n- Best practices\nProvide a concise and structured response.\n\n### Provided Code Snippet:\n```c\nCPLErr GTiffDataset::CleanOverviews()\n\n{\n    CPLAssert( !m_poBaseDS );\n\n    ScanDirectories();\n\n    FlushDirectory();\n\n/* -------------------------------------------------------------------- */\n/*      Cleanup overviews objects, and get offsets to all overview      */\n/*      directories.                                                    */\n/* -------------------------------------------------------------------- */\n    std::vector<toff_t> anOvDirOffsets;\n\n    for( int i = 0; i < m_nOverviewCount; ++i )\n    {\n        anOvDirOffsets.push_back( m_papoOverviewDS[i]->m_nDirOffset );\n        delete m_papoOverviewDS[i];\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Loop through all the directories, translating the offsets       */\n/*      into indexes we can use with TIFFUnlinkDirectory().             */\n/* -------------------------------------------------------------------- */\n    std::vector<uint16> anOvDirIndexes;\n    int iThisOffset = 1;\n\n    TIFFSetDirectory( m_hTIFF, 0 );\n\n    while( true )\n    {\n        for( int i = 0; i < m_nOverviewCount; ++i )\n        {\n            if( anOvDirOffsets[i] == TIFFCurrentDirOffset( m_hTIFF ) )\n            {\n                CPLDebug( \"GTiff\", \"%d -> %d\",\n                          static_cast<int>(anOvDirOffsets[i]), iThisOffset );\n                anOvDirIndexes.push_back( static_cast<uint16>(iThisOffset) );\n            }\n        }\n\n        if( TIFFLastDirectory( m_hTIFF ) )\n            break;\n\n        TIFFReadDirectory( m_hTIFF );\n        ++iThisOffset;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Actually unlink the target directories.  Note that we do        */\n/*      this from last to first so as to avoid renumbering any of       */\n/*      the earlier directories we need to remove.                      */\n/* -------------------------------------------------------------------- */\n    while( !anOvDirIndexes.empty() )\n    {\n        TIFFUnlinkDirectory( m_hTIFF, anOvDirIndexes.back() );\n        anOvDirIndexes.pop_back();\n    }\n\n    CPLFree( m_papoOverviewDS );\n\n    m_nOverviewCount = 0;\n    m_papoOverviewDS = nullptr;\n\n    if( !SetDirectory() )\n        return CE_Failure;\n\n    return CE_None;\n}\n```\n",
        "response": "### Core API Usage Patterns for `TIFFReadDirectory`\n\n**1. API Functionality**  \n`TIFFReadDirectory` is a function from the libtiff library used to read the next directory (image) in a TIFF file and make it the current directory. It enables sequential traversal of multiple directories within a TIFF file.\n\n**2. Typical Usage**  \nUsed in a loop to iterate through all directories in a TIFF file, typically after initializing with `TIFFSetDirectory`. Example flow:\n```c\nTIFFSetDirectory(hTIFF, 0);  // Start at first directory\nwhile (!TIFFLastDirectory(hTIFF)) {\n  // Process current directory\n  TIFFReadDirectory(hTIFF);   // Advance to next directory\n}\n```\n\n**3. Key Parameters**  \n- `TIFF* hTIFF`: Handle to an open TIFF file. The only parameter required.\n\n**4. Return Values**  \n- Returns `1` on successfully advancing to the next directory.\n- Returns `0` on failure (end of directories or read error).\n\n**5. Error Handling**  \n- **Critical Gap in Provided Code**: No explicit error checking for `TIFFReadDirectory` return value. Risk of infinite loops if read errors occur without reaching `TIFFLastDirectory`.\n- **Recommended Fix**:\n  ```c\n  if (!TIFFReadDirectory(m_hTIFF)) {\n    if (!TIFFLastDirectory(m_hTIFF)) {\n      CPLError(...); // Handle read error\n      break;\n    }\n  }\n  ```\n\n**6. Best Practices**  \n1. Always check `TIFFReadDirectory` return value to detect read errors.\n2. Use `TIFFSetDirectory` to reset to a known directory before iteration.\n3. Prefer directory indexes over offsets when unlinking to avoid renumbering issues.\n4. Process directories in reverse order when deleting (as done in the code) to maintain index validity.\n\n**Code-Specific Insight**  \nThe implementation uses `TIFFReadDirectory` to:\n1. Traverse all directories after the first (`TIFFSetDirectory(m_hTIFF, 0)`).\n2. Identify overview directories via offset matching.\n3. Collect directory indexes for later unlinking.  \n*Missing error handling could lead to undetected failures in directory traversal.*"
    },
    {
        "prompt": "### Task Description:\nYou are an experienced software engineer skilled in API usage analysis. Your task is to analyze the following C/C++ code snippet and summarize the core API usage patterns for 'TIFFReadDirectory', focusing on:\n- API functionality\n- Typical usage\n- Key parameters\n- Return values\n- Error handling\n- Best practices\nProvide a concise and structured response.\n\n### Provided Code Snippet:\n```c\nvoid GTiffDataset::ScanDirectories()\n\n{\n/* -------------------------------------------------------------------- */\n/*      We only scan once.  We do not scan for non-base datasets.       */\n/* -------------------------------------------------------------------- */\n    if( !m_bScanDeferred )\n        return;\n\n    m_bScanDeferred = false;\n\n    if( m_poBaseDS )\n        return;\n\n    Crystalize();\n\n    CPLDebug( \"GTiff\", \"ScanDirectories()\" );\n\n/* ==================================================================== */\n/*      Scan all directories.                                           */\n/* ==================================================================== */\n    CPLStringList aosSubdatasets;\n    int iDirIndex = 0;\n\n    FlushDirectory();\n\n    do\n    {\n        // Only libtiff 4.0.4 can handle between 32768 and 65535 directories.\n#if !defined(SUPPORTS_MORE_THAN_32768_DIRECTORIES)\n        if( iDirIndex == 32768 )\n            break;\n#endif\n        toff_t nTopDir = TIFFCurrentDirOffset(m_hTIFF);\n        uint32 nSubType = 0;\n\n        ++iDirIndex;\n\n        toff_t *tmpSubIFDOffsets = nullptr;\n        toff_t *subIFDOffsets = nullptr;\n        uint16 nSubIFDs = 0;\n        if (TIFFGetField(m_hTIFF, TIFFTAG_SUBIFD, &nSubIFDs, &tmpSubIFDOffsets) && iDirIndex == 1)\n        {\n            subIFDOffsets = static_cast<toff_t *>(CPLMalloc(nSubIFDs * sizeof(toff_t)));\n            for (uint16 iSubIFD = 0; iSubIFD < nSubIFDs; iSubIFD++)\n            {\n                subIFDOffsets[iSubIFD] = tmpSubIFDOffsets[iSubIFD];\n            }\n        }\n\n        //early break for backwards compatibility: if the first directory read is also the last, and there are no subIFDs, no use continuing\n        if( iDirIndex==1 && nSubIFDs==0 && TIFFLastDirectory( m_hTIFF )) {\n            CPLFree(subIFDOffsets);\n            break;\n        }\n\n\n        for( uint16 iSubIFD = 0; iSubIFD<=nSubIFDs; iSubIFD++ ) {\n            toff_t nThisDir = nTopDir;\n            if ( iSubIFD > 0 && iDirIndex > 1 ) //don't read subIFDs if we are not in the original directory\n                break;\n            if ( iSubIFD > 0 ) {\n                // make static analyzer happy. subIFDOffsets cannot be null if iSubIFD>0\n                assert(subIFDOffsets != nullptr); \n                nThisDir = subIFDOffsets[iSubIFD-1];\n                //CPLDebug(\"GTiff\", \"Opened subIFD %d/%d at offset %llu.\", iSubIFD, nSubIFDs, nThisDir);\n                if (!TIFFSetSubDirectory(m_hTIFF,nThisDir))\n                    break;\n            }\n\n\n            if( !TIFFGetField(m_hTIFF, TIFFTAG_SUBFILETYPE, &nSubType) )\n                nSubType = 0;\n\n            /* Embedded overview of the main image */\n            if( (nSubType & FILETYPE_REDUCEDIMAGE) != 0 &&\n                (nSubType & FILETYPE_MASK) == 0 &&\n                ((nSubIFDs==0 && iDirIndex != 1) || iSubIFD>0) &&\n                m_nOverviewCount < 30 /* to avoid DoS */ )\n            {\n                GTiffDataset *poODS = new GTiffDataset();\n                poODS->ShareLockWithParentDataset(this);\n                poODS->SetStructuralMDFromParent(this);\n                poODS->m_pszFilename = CPLStrdup(m_pszFilename);\n                if( poODS->OpenOffset( VSI_TIFFOpenChild(m_hTIFF), nThisDir,\n                                    eAccess ) != CE_None\n                    || poODS->GetRasterCount() != GetRasterCount() )\n                {\n                    delete poODS;\n                }\n                else\n                {\n                    CPLDebug( \"GTiff\", \"Opened %dx%d overview.\",\n                            poODS->GetRasterXSize(), poODS->GetRasterYSize());\n                    ++m_nOverviewCount;\n                    m_papoOverviewDS = static_cast<GTiffDataset **>(\n                        CPLRealloc(m_papoOverviewDS,\n                                m_nOverviewCount * (sizeof(void*))) );\n                    m_papoOverviewDS[m_nOverviewCount-1] = poODS;\n                    poODS->m_poBaseDS = this;\n                    poODS->m_bIsOverview = true;\n                }\n            }\n            // Embedded mask of the main image.\n            else if( (nSubType & FILETYPE_MASK) != 0 &&\n                    (nSubType & FILETYPE_REDUCEDIMAGE) == 0 &&\n                    ((nSubIFDs==0 && iDirIndex != 1) || iSubIFD>0) &&\n                    m_poMaskDS == nullptr )\n            {\n                m_poMaskDS = new GTiffDataset();\n                m_poMaskDS->ShareLockWithParentDataset(this);\n                m_poMaskDS->SetStructuralMDFromParent(this);\n                m_poMaskDS->m_pszFilename = CPLStrdup(m_pszFilename);\n\n                // The TIFF6 specification - page 37 - only allows 1\n                // SamplesPerPixel and 1 BitsPerSample Here we support either 1 or\n                // 8 bit per sample and we support either 1 sample per pixel or as\n                // many samples as in the main image We don't check the value of\n                // the PhotometricInterpretation tag, which should be set to\n                // \"Transparency mask\" (4) according to the specification (page\n                // 36).  However, the TIFF6 specification allows image masks to\n                // have a higher resolution than the main image, what we don't\n                // support here.\n\n                if( m_poMaskDS->OpenOffset( VSI_TIFFOpenChild(m_hTIFF), nThisDir,\n                                        eAccess ) != CE_None\n                    || m_poMaskDS->GetRasterCount() == 0\n                    || !(m_poMaskDS->GetRasterCount() == 1\n                        || m_poMaskDS->GetRasterCount() == GetRasterCount())\n                    || m_poMaskDS->GetRasterXSize() != GetRasterXSize()\n                    || m_poMaskDS->GetRasterYSize() != GetRasterYSize()\n                    || m_poMaskDS->GetRasterBand(1)->GetRasterDataType() != GDT_Byte)\n                {\n                    delete m_poMaskDS;\n                    m_poMaskDS = nullptr;\n                }\n                else\n                {\n                    CPLDebug( \"GTiff\", \"Opened band mask.\");\n                    m_poMaskDS->m_poBaseDS = this;\n                    m_poMaskDS->m_poImageryDS = this;\n\n                    m_poMaskDS->m_bPromoteTo8Bits =\n                        CPLTestBool(\n                            CPLGetConfigOption( \"GDAL_TIFF_INTERNAL_MASK_TO_8BIT\",\n                                                \"YES\" ) );\n                }\n            }\n\n            // Embedded mask of an overview.  The TIFF6 specification allows the\n            // combination of the FILETYPE_xxxx masks.\n            else if( (nSubType & FILETYPE_REDUCEDIMAGE) != 0 &&\n                    (nSubType & FILETYPE_MASK) != 0 &&\n                    ((nSubIFDs==0 && iDirIndex != 1) || iSubIFD>0))\n            {\n                GTiffDataset* poDS = new GTiffDataset();\n                poDS->ShareLockWithParentDataset(this);\n                poDS->SetStructuralMDFromParent(this);\n                poDS->m_pszFilename = CPLStrdup(m_pszFilename);\n                if( poDS->OpenOffset( VSI_TIFFOpenChild(m_hTIFF), nThisDir,\n                                    eAccess ) != CE_None\n                    || poDS->GetRasterCount() == 0\n                    || poDS->GetRasterBand(1)->GetRasterDataType() != GDT_Byte)\n                {\n                    delete poDS;\n                }\n                else\n                {\n                    int i = 0;  // Used after for.\n                    for( ; i < m_nOverviewCount; ++i )\n                    {\n                        auto poOvrDS = cpl::down_cast<GTiffDataset*>(\n                                GDALDataset::FromHandle(m_papoOverviewDS[i]));\n                        if( poOvrDS->m_poMaskDS == nullptr &&\n                            poDS->GetRasterXSize() ==\n                            m_papoOverviewDS[i]->GetRasterXSize() &&\n                            poDS->GetRasterYSize() ==\n                            m_papoOverviewDS[i]->GetRasterYSize() &&\n                            (poDS->GetRasterCount() == 1 ||\n                            poDS->GetRasterCount() == GetRasterCount()))\n                        {\n                            CPLDebug(\n                                \"GTiff\", \"Opened band mask for %dx%d overview.\",\n                                poDS->GetRasterXSize(), poDS->GetRasterYSize());\n                            poDS->m_poImageryDS = poOvrDS;\n                            poOvrDS->m_poMaskDS = poDS;\n                            poDS->m_bPromoteTo8Bits =\n                                CPLTestBool(\n                                    CPLGetConfigOption(\n                                        \"GDAL_TIFF_INTERNAL_MASK_TO_8BIT\",\n                                        \"YES\" ) );\n                            poDS->m_poBaseDS = this;\n                            break;\n                        }\n                    }\n                    if( i == m_nOverviewCount )\n                    {\n                        delete poDS;\n                    }\n                }\n            }\n            else if( !m_bSingleIFDOpened && (nSubType == 0 || nSubType == FILETYPE_PAGE) )\n            {\n                uint32 nXSize = 0;\n                uint32 nYSize = 0;\n\n                TIFFGetField( m_hTIFF, TIFFTAG_IMAGEWIDTH, &nXSize );\n                TIFFGetField( m_hTIFF, TIFFTAG_IMAGELENGTH, &nYSize );\n\n                // For Geodetic TIFF grids (GTG)\n                // (https://proj.org/specifications/geodetictiffgrids.html)\n                // extract the grid_name to put it in the description\n                std::string osFriendlyName;\n                char* pszText = nullptr;\n                if( TIFFGetField( m_hTIFF, TIFFTAG_GDAL_METADATA, &pszText ) &&\n                    strstr(pszText, \"grid_name\") != nullptr )\n                {\n                    CPLXMLNode *psRoot = CPLParseXMLString( pszText );\n                    CPLXMLNode *psItem = nullptr;\n\n                    if( psRoot != nullptr && psRoot->eType == CXT_Element\n                        && EQUAL(psRoot->pszValue,\"GDALMetadata\") )\n                        psItem = psRoot->psChild;\n\n                    for( ; psItem != nullptr; psItem = psItem->psNext )\n                    {\n\n                        if( psItem->eType != CXT_Element\n                            || !EQUAL(psItem->pszValue,\"Item\") )\n                            continue;\n\n                        const char *pszKey = CPLGetXMLValue( psItem, \"name\", nullptr );\n                        const char *pszValue = CPLGetXMLValue( psItem, nullptr, nullptr );\n                        int nBand =\n                            atoi(CPLGetXMLValue( psItem, \"sample\", \"-1\" ));\n                        if( pszKey && pszValue && nBand <= 0 &&\n                            EQUAL(pszKey, \"grid_name\") )\n                        {\n                            osFriendlyName = \": \";\n                            osFriendlyName += pszValue;\n                            break;\n                        }\n                    }\n\n                    CPLDestroyXMLNode(psRoot);\n                }\n\n                if( nXSize > INT_MAX || nYSize > INT_MAX )\n                {\n                    CPLDebug(\"GTiff\",\n                            \"Skipping directory with too large image: %u x %u\",\n                            nXSize, nYSize);\n                }\n                else\n                {\n                    uint16 nSPP = 0;\n                    if( !TIFFGetField(m_hTIFF, TIFFTAG_SAMPLESPERPIXEL, &nSPP ) )\n                        nSPP = 1;\n\n                    CPLString osName, osDesc;\n                    osName.Printf( \"SUBDATASET_%d_NAME=GTIFF_DIR:%d:%s\",\n                                iDirIndex, iDirIndex, m_pszFilename );\n                    osDesc.Printf( \"SUBDATASET_%d_DESC=Page %d (%dP x %dL x %dB)\",\n                                iDirIndex, iDirIndex,\n                                static_cast<int>(nXSize),\n                                static_cast<int>(nYSize),\n                                nSPP );\n                    osDesc += osFriendlyName;\n\n                    aosSubdatasets.AddString(osName);\n                    aosSubdatasets.AddString(osDesc);\n                }\n            }\n        }\n        CPLFree(subIFDOffsets);\n\n        // Make sure we are stepping from the expected directory regardless\n        // of churn done processing the above.\n        if( TIFFCurrentDirOffset(m_hTIFF) != nTopDir )\n            TIFFSetSubDirectory( m_hTIFF, nTopDir );\n    } while( !m_bSingleIFDOpened && !TIFFLastDirectory( m_hTIFF ) && TIFFReadDirectory( m_hTIFF ) != 0 );\n\n\n    ReloadDirectory();\n\n    // If we have a mask for the main image, loop over the overviews, and if\n    // they have a mask, let's set this mask as an overview of the main mask.\n    if( m_poMaskDS != nullptr )\n    {\n        for( int i = 0; i < m_nOverviewCount; ++i )\n        {\n            if( cpl::down_cast<GTiffDataset *>(GDALDataset::FromHandle(\n                   m_papoOverviewDS[i]))->m_poMaskDS != nullptr)\n            {\n                ++m_poMaskDS->m_nOverviewCount;\n                m_poMaskDS->m_papoOverviewDS = static_cast<GTiffDataset **>(\n                    CPLRealloc(m_poMaskDS->m_papoOverviewDS,\n                               m_poMaskDS->m_nOverviewCount * (sizeof(void*))) );\n                m_poMaskDS->m_papoOverviewDS[m_poMaskDS->m_nOverviewCount-1] =\n                    cpl::down_cast<GTiffDataset*>(GDALDataset::FromHandle(\n                        m_papoOverviewDS[i]))->m_poMaskDS;\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Only keep track of subdatasets if we have more than one         */\n/*      subdataset (pair).                                              */\n/* -------------------------------------------------------------------- */\n    if( aosSubdatasets.size() > 2 )\n    {\n        m_oGTiffMDMD.SetMetadata( aosSubdatasets.List(), \"SUBDATASETS\" );\n    }\n}\n```\n",
        "response": "### Core API Usage Patterns for `TIFFReadDirectory`\n\n#### **API Functionality**\n- **Purpose**: `TIFFReadDirectory` reads the next TIFF Image File Directory (IFD) and makes it the current directory. It is used to traverse multi-directory TIFF files (e.g., multi-page documents, overviews, masks).\n\n#### **Typical Usage**\n- **Iterating Directories**: Called in a loop to scan all directories in a TIFF file:\n  ```c\n  do {\n      // Process directory...\n  } while (TIFFReadDirectory(m_hTIFF));\n  ```\n- **Subdirectory Handling**: Navigates to subdirectories (e.g., SubIFDs) using `TIFFSetSubDirectory` before processing.\n\n#### **Key Parameters**\n- **Input**: `TIFF*` handle (`m_hTIFF` in the code), representing the open TIFF file.\n\n#### **Return Values**\n- **Success**: Returns `1` when the next directory is successfully read.\n- **Failure/End**: Returns `0` if no more directories exist or an error occurs.\n\n#### **Error Handling**\n- **Implicit Termination**: The loop exits on failure, but no explicit error logging is performed in the snippet.\n- **Libtiff Errors**: Errors (e.g., corrupt directories) are typically handled via libtiff’s internal error reporting mechanism.\n\n#### **Best Practices**\n1. **Loop Safeguards**: Limit directory scans to avoid infinite loops (e.g., `SUPPORTS_MORE_THAN_32768_DIRECTORIES` check).\n2. **Directory Navigation**: Use `TIFFCurrentDirOffset` and `TIFFSetSubDirectory` to reset positions after subdirectory processing.\n3. **Resource Management**: Free allocated resources (e.g., `CPLFree(subIFDOffsets)`) after processing each directory.\n4. **Validation**: Check directory validity (e.g., image dimensions, data types) before using metadata or raster data.\n\n---\n\n### Structured Summary\n```markdown\n- **Functionality**: Reads the next TIFF directory for traversal.\n- **Usage**: Loop through directories/subdirectories; handle overviews, masks, and subdatasets.\n- **Parameters**: `TIFF*` handle to the opened file.\n- **Returns**: `1` (success), `0` (end of directories/error).\n- **Error Handling**: Loop termination on failure; no explicit logging here (relies on libtiff internals).\n- **Best Practices**:\n  - Use directory offset tracking to avoid state corruption.\n  - Validate directory contents (e.g., size, type).\n  - Limit iterations to prevent DoS/overflows.\n  - Cleanup resources post-processing.\n```"
    },
    {
        "prompt": "### Task Description:\nYou are an experienced software engineer skilled in API usage analysis. Your task is to analyze the following C/C++ code snippet and summarize the core API usage patterns for 'TIFFReadDirectory', focusing on:\n- API functionality\n- Typical usage\n- Key parameters\n- Return values\n- Error handling\n- Best practices\nProvide a concise and structured response.\n\n### Provided Code Snippet:\n```c\nbool TiffDecoder::nextPage()\n{\n    // Prepare the next page, if any.\n    return m_tif &&\n           TIFFReadDirectory(static_cast<TIFF*>(m_tif)) &&\n           readHeader();\n}\n```\n",
        "response": "### Core API Usage Patterns for `TIFFReadDirectory`\n\n**1. API Functionality**  \n`TIFFReadDirectory` advances to the next directory (image/page) in a multi-page TIFF file. It is part of the libtiff library for reading TIFF data.\n\n**2. Typical Usage**  \nUsed in loops to iterate through multi-page TIFF files:\n```c++\nwhile (TIFFReadDirectory(tif)) {\n  // Process current page\n}\n```\n\n**3. Key Parameters**  \n- `TIFF* tif`: A handle to an open TIFF file (cast from `m_tif` in the code snippet).\n\n**4. Return Values**  \n- `1` (success): Next directory was read.\n- `0` (failure): No more directories or an error occurred.\n\n**5. Error Handling**  \n- **Implicit Check**: The code checks for a non-zero return to determine success.\n- **Limitation**: Return value `0` could mean either end-of-file or an error. To distinguish, use `TIFFGetLastErrorCode` or `TIFFGetLastError` for error details (not shown in the snippet).\n\n**6. Best Practices**  \n- **Validation**: Ensure the `TIFF*` handle is valid before calling (e.g., `m_tif != nullptr` in the snippet).\n- **Post-Call Actions**: After success, read metadata (e.g., `readHeader()` in the snippet) to update internal state.\n- **Error Diagnostics**: Use libtiff error APIs (e.g., `TIFFGetLastError`) to log or handle errors explicitly.\n- **Lifecycle Management**: Properly initialize/close the `TIFF*` handle to avoid leaks."
    },
    {
        "prompt": "### Task Description:\nYou are an experienced software engineer skilled in API usage analysis. Your task is to analyze the following C/C++ code snippet and summarize the core API usage patterns for 'TIFFReadDirectory', focusing on:\n- API functionality\n- Typical usage\n- Key parameters\n- Return values\n- Error handling\n- Best practices\nProvide a concise and structured response.\n\n### Provided Code Snippet:\n```c\nint wxTIFFHandler::GetImageCount( wxInputStream& stream )\n{\n    TIFF *tif = TIFFwxOpen( stream, \"image\", \"r\" );\n\n    if (!tif)\n        return 0;\n\n    int dircount = 0;  // according to the libtiff docs, dircount should be set to 1 here???\n    do {\n        dircount++;\n    } while (TIFFReadDirectory(tif));\n\n    TIFFClose( tif );\n\n    return dircount;\n}\n```\n",
        "response": "### Core API Usage Patterns for `TIFFReadDirectory`\n\n#### **API Functionality**\n- **Purpose**: Reads the next directory (image) in a TIFF file. Enables iteration through multiple images stored in a single file.\n- **Behavior**: Moves the internal pointer to the next directory. The first directory is read automatically when the file is opened.\n\n#### **Typical Usage**\n- Used in a loop to count or process all directories (images) in a TIFF file.\n- Example:\n  ```c\n  do {\n      dircount++;\n  } while (TIFFReadDirectory(tif));\n  ```\n\n#### **Key Parameters**\n- `TIFF *tif`: A handle to the opened TIFF file (from `TIFFOpen` or similar).\n\n#### **Return Values**\n- **1 (Success)**: Next directory was read successfully.\n- **0 (Failure)**: No more directories exist, or an error occurred (e.g., corrupt file).\n\n#### **Error Handling**\n- **Limitation in Example**: The provided code assumes `0` always indicates \"no more directories,\" but errors (e.g., invalid TIFF structure) also return `0`.\n- **Best Practice**: After the loop, check for errors using `TIFFGetLastError` to distinguish between end-of-file and actual errors:\n  ```c\n  if (TIFFGetLastError()) {\n      // Handle error (e.g., log, return an error code).\n  }\n  ```\n\n#### **Best Practices**\n1. **Error Checking**: Always validate if `TIFFReadDirectory` failures are due to errors or legitimate end-of-file.\n2. **Initial Count Handling**: The first directory is counted when the file is opened; the loop increments for subsequent directories.\n3. **Resource Management**: Ensure `TIFFClose` is called to release resources, even on errors (implemented correctly in the example).\n4. **Mode Validation**: Open the TIFF file in read mode (`\"r\"`) for directory iteration.\n\n#### **Code Snippet Analysis**\n- Correctly counts directories but lacks error differentiation.\n- Suggestion: Add post-loop error checks to improve robustness."
    },
    {
        "prompt": "### Task Description:\nYou are an experienced software engineer skilled in API usage analysis. Your task is to analyze the following C/C++ code snippet and summarize the core API usage patterns for 'TIFFReadDirectory', focusing on:\n- API functionality\n- Typical usage\n- Key parameters\n- Return values\n- Error handling\n- Best practices\nProvide a concise and structured response.\n\n### Provided Code Snippet:\n```c\nCPLErr GTiffDataset::CleanOverviews()\n\n{\n    CPLAssert( bBase );\n\n    FlushDirectory();\n    *ppoActiveDSRef = NULL;\n\n/* -------------------------------------------------------------------- */\n/*      Cleanup overviews objects, and get offsets to all overview      */\n/*      directories.                                                    */\n/* -------------------------------------------------------------------- */\n    std::vector<toff_t>  anOvDirOffsets;\n    int i;\n\n    for( i = 0; i < nOverviewCount; i++ )\n    {\n        anOvDirOffsets.push_back( papoOverviewDS[i]->nDirOffset );\n        delete papoOverviewDS[i];\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Loop through all the directories, translating the offsets       */\n/*      into indexes we can use with TIFFUnlinkDirectory().             */\n/* -------------------------------------------------------------------- */\n    std::vector<uint16> anOvDirIndexes;\n    int iThisOffset = 1;\n\n    TIFFSetDirectory( hTIFF, 0 );\n    \n    for( ; TRUE; ) \n    {\n        for( i = 0; i < nOverviewCount; i++ )\n        {\n            if( anOvDirOffsets[i] == TIFFCurrentDirOffset( hTIFF ) )\n            {\n                CPLDebug( \"GTiff\", \"%d -> %d\", \n                          (int) anOvDirOffsets[i], iThisOffset );\n                anOvDirIndexes.push_back( iThisOffset );\n            }\n        }\n        \n        if( TIFFLastDirectory( hTIFF ) )\n            break;\n\n        TIFFReadDirectory( hTIFF );\n        iThisOffset++;\n    } \n\n/* -------------------------------------------------------------------- */\n/*      Actually unlink the target directories.  Note that we do        */\n/*      this from last to first so as to avoid renumbering any of       */\n/*      the earlier directories we need to remove.                      */\n/* -------------------------------------------------------------------- */\n    while( !anOvDirIndexes.empty() )\n    {\n        TIFFUnlinkDirectory( hTIFF, anOvDirIndexes.back() );\n        anOvDirIndexes.pop_back();\n    }\n\n    CPLFree( papoOverviewDS );\n\n    nOverviewCount = 0;\n    papoOverviewDS = NULL;\n\n    if (!SetDirectory())\n        return CE_Failure;\n\n    return CE_None;\n}\n```\n",
        "response": "### Core API Usage Patterns for `TIFFReadDirectory`\n\n#### **API Functionality**\n- **Purpose**: Reads the next TIFF directory (IFD) in the file and makes it the current directory.\n- **Context**: Used to traverse directories sequentially in a TIFF file, typically to locate and manage overview (subfile) directories.\n\n#### **Typical Usage**\n- **Loop Through Directories**: Iterate over all directories in a TIFF file using `TIFFReadDirectory` until `TIFFLastDirectory` indicates the end.\n- **Example**:\n  ```c\n  TIFFSetDirectory(hTIFF, 0);  // Start at the first directory\n  while (!TIFFLastDirectory(hTIFF)) {\n      TIFFReadDirectory(hTIFF);  // Advance to the next directory\n  }\n  ```\n\n#### **Key Parameters**\n- **`hTIFF` (TIFF*)**: Handle to the open TIFF file. Critical for maintaining state during directory traversal.\n\n#### **Return Values**\n- **Success**: Returns `1` when the next directory is successfully read.\n- **Failure**: Returns `0` if no more directories exist or an error occurs.\n\n#### **Error Handling**\n- **No Explicit Checks in Snippet**: The provided code does not check `TIFFReadDirectory`'s return value, risking infinite loops if an error occurs mid-traversal.\n- **Best Practice**: Always validate the return value:\n  ```c\n  if (!TIFFReadDirectory(hTIFF)) {\n      // Handle error (e.g., break loop, log issue)\n  }\n  ```\n\n#### **Best Practices**\n1. **Combine with `TIFFLastDirectory`**: Use `TIFFLastDirectory` to terminate traversal safely.\n2. **Check Return Values**: Ensure robustness by validating `TIFFReadDirectory` results.\n3. **State Management**: Use `TIFFSetDirectory` to reset to a known directory index (e.g., `0`) before traversal.\n4. **Avoid Assumptions**: Do not assume sequential directory offsets; track directory positions explicitly (as done with `iThisOffset`).\n\n#### **Code-Specific Insights**\n- **Directory Indexing**: The code tracks directory offsets (`anOvDirOffsets`) and translates them to indexes for unlinking.\n- **Unlinking Order**: Directories are unlinked in reverse order (last to first) to prevent renumbering issues during deletion."
    },
    {
        "prompt": "### Task Description:\nYou are an experienced software engineer skilled in API usage analysis. Your task is to analyze the following C/C++ code snippet and summarize the core API usage patterns for 'TIFFReadDirectory', focusing on:\n- API functionality\n- Typical usage\n- Key parameters\n- Return values\n- Error handling\n- Best practices\nProvide a concise and structured response.\n\n### Provided Code Snippet:\n```c\nJNIEXPORT jboolean JNICALL LCTIFFWriter_METHOD(append)\n    ( JNIEnv *env, jobject jLCTIFFWriter, jstring jFileName )\n{\n    TIFF *const destTIFF = getNativePtr( env, jLCTIFFWriter );\n    TIFFSetField( destTIFF, TIFFTAG_PAGENUMBER, 0, 2 );\n    int result = TIFFWriteDirectory( destTIFF );\n    if ( !result )\n        return JNI_FALSE;\n    jstring_to_c const cFileName( env, jFileName );\n    TIFF *const srcTIFF = LC_TIFFOpen( cFileName, \"r\" );\n    if ( !srcTIFF )\n        return JNI_FALSE;\n    if ( isLightZoneLayeredTIFF( srcTIFF ) )\n        TIFFReadDirectory( srcTIFF );\n    result = tiffcp( srcTIFF, destTIFF );\n    TIFFSetField( destTIFF, TIFFTAG_PAGENUMBER, 1, 2 );\n    TIFFClose( srcTIFF );\n    return result ? JNI_TRUE : JNI_FALSE;\n}\n```\n",
        "response": "### Core API Usage Patterns for `TIFFReadDirectory`\n\n#### **API Functionality**  \n`TIFFReadDirectory` is part of the LibTIFF library and advances the TIFF file handle to the next directory (image) in a multi-directory TIFF file. Directories represent individual pages or sub-images within a TIFF.\n\n---\n\n#### **Typical Usage**  \nUsed to iterate through multi-page TIFFs. In the provided code, it skips the first directory of a LightZone-layered TIFF, likely to bypass metadata and access the actual image data in subsequent directories.\n\n---\n\n#### **Key Parameters**  \n- `TIFF *`: A pointer to the TIFF file handle (e.g., `srcTIFF` in the snippet).  \n  The function reads the next directory from this handle.\n\n---\n\n#### **Return Values**  \n- **1 (Success):** Next directory read.  \n- **0 (Failure):** No more directories or an error occurred (e.g., corrupt file).  \n\n---\n\n#### **Error Handling**  \n- **Not Handled in the Snippet:** The code does not check `TIFFReadDirectory`'s return value, risking silent failures (e.g., invalid directory access in `tiffcp`).  \n- **Recommended:** Add error checks and propagate failures (e.g., log, close handles, return error status).\n\n---\n\n#### **Best Practices**  \n1. **Validate Return Values:** Always check if `TIFFReadDirectory` succeeds.  \n2. **Combine with `TIFFSetDirectory`:** For precise directory navigation.  \n3. **Loop Structure:** Use in a loop (e.g., `while (TIFFReadDirectory(tif))`) to process all directories.  \n4. **Context Awareness:** Understand the TIFF structure (e.g., LightZone layers) to avoid skipping critical directories.  \n\n---\n\n### Code-Specific Note  \nThe snippet assumes LightZone TIFFs place metadata in the first directory. While functional, the lack of error checking for `TIFFReadDirectory` could lead to undefined behavior if the directory read fails."
    },
    {
        "prompt": "### Task Description:\nYou are an experienced software engineer skilled in API usage analysis. Your task is to analyze the following C/C++ code snippet and summarize the core API usage patterns for 'TIFFReadDirectory', focusing on:\n- API functionality\n- Typical usage\n- Key parameters\n- Return values\n- Error handling\n- Best practices\nProvide a concise and structured response.\n\n### Provided Code Snippet:\n```c\nKisImportExportErrorCode\nKisTIFFImport::convert(KisDocument *document,\n                       QIODevice * /*io*/,\n                       KisPropertiesConfigurationSP /*configuration*/)\n{\n    dbgFile << \"Start decoding TIFF File\";\n\n    if (!KisImportExportAdditionalChecks::doesFileExist(filename())) {\n        return ImportExportCodes::FileNotExist;\n    }\n    if (!KisImportExportAdditionalChecks::isFileReadable(filename())) {\n        return ImportExportCodes::NoAccessToRead;\n    }\n\n    QFile file(filename());\n    if (!file.open(QFile::ReadOnly)) {\n        return KisImportExportErrorCode(KisImportExportErrorCannotRead(file.error()));\n    }\n\n    // Open the TIFF file\n    const QByteArray encodedFilename = QFile::encodeName(filename());\n\n    // https://gitlab.com/libtiff/libtiff/-/issues/173\n#ifdef Q_OS_WIN\n    const intptr_t handle = _get_osfhandle(file.handle());\n#else\n    const int handle = file.handle();\n#endif\n\n    std::unique_ptr<TIFF, decltype(&TIFFCleanup)> image(TIFFFdOpen(handle, encodedFilename.data(), \"r\"), &TIFFCleanup);\n\n    if (!image) {\n        dbgFile << \"Could not open the file, either it does not exist, either \"\n                   \"it is not a TIFF :\"\n                << filename();\n        return (ImportExportCodes::FileFormatIncorrect);\n    }\n    dbgFile << \"Reading first image descriptor\";\n    KisImportExportErrorCode result = readTIFFDirectory(document, image.get());\n    if (!result.isOk()) {\n        return result;\n    }\n\n    if (!m_photoshopBlockParsed) {\n        // Photoshop images only have one IFD plus the layer blob\n        // Ward off inconsistencies by blocking future attempts to parse them\n        m_photoshopBlockParsed = true;\n        while (TIFFReadDirectory(image.get())) {\n            result = readTIFFDirectory(document, image.get());\n            if (!result.isOk()) {\n                return result;\n            }\n        }\n    }\n    // Freeing memory\n    image.reset();\n    file.close();\n\n    {\n        // HACK!! Externally parse the Exif metadata\n        // libtiff has no way to access the fields wholesale\n        try {\n            KisExiv2IODevice::ptr_type basicIoDevice(new KisExiv2IODevice(filename()));\n\n#if EXIV2_TEST_VERSION(0,28,0)\n            const std::unique_ptr<Exiv2::Image> readImg = Exiv2::ImageFactory::open(std::move(basicIoDevice));\n#else\n            const std::unique_ptr<Exiv2::Image> readImg(Exiv2::ImageFactory::open(basicIoDevice).release());\n#endif\n\n            readImg->readMetadata();\n\n            const KisMetaData::IOBackend *io =\n                KisMetadataBackendRegistry::instance()->value(\"exif\");\n\n            // All IFDs are paint layer children of root\n            KisNodeSP node = m_image->rootLayer()->firstChild();\n\n            QBuffer ioDevice;\n\n            {\n                // Synthesize the Exif blob\n                Exiv2::ExifData tempData;\n                Exiv2::Blob tempBlob;\n\n                // NOTE: do not use std::copy_if, auto_ptrs beware\n                for (const Exiv2::Exifdatum &i : readImg->exifData()) {\n                    const uint16_t tag = i.tag();\n\n                    if (tag == Exif::Image::ImageWidth\n                        || tag == Exif::Image::ImageLength\n                        || tag == Exif::Image::BitsPerSample\n                        || tag == Exif::Image::Compression\n                        || tag == Exif::Image::PhotometricInterpretation\n                        || tag == Exif::Image::Orientation\n                        || tag == Exif::Image::SamplesPerPixel\n                        || tag == Exif::Image::PlanarConfiguration\n                        || tag == Exif::Image::YCbCrSubSampling\n                        || tag == Exif::Image::YCbCrPositioning\n                        || tag == Exif::Image::XResolution\n                        || tag == Exif::Image::YResolution\n                        || tag == Exif::Image::ResolutionUnit\n                        || tag == Exif::Image::TransferFunction\n                        || tag == Exif::Image::WhitePoint\n                        || tag == Exif::Image::PrimaryChromaticities\n                        || tag == Exif::Image::YCbCrCoefficients\n                        || tag == Exif::Image::ReferenceBlackWhite\n                        || tag == Exif::Image::InterColorProfile) {\n                        dbgMetaData << \"Ignoring TIFF-specific\"\n                                    << i.key().c_str();\n                        continue;\n                    }\n\n                    tempData.add(i);\n                }\n\n                // Encode into temporary blob\n                Exiv2::ExifParser::encode(tempBlob,\n                                          Exiv2::littleEndian,\n                                          tempData);\n\n                // Reencode into Qt land\n                ioDevice.setData(reinterpret_cast<char *>(tempBlob.data()),\n                                 static_cast<int>(tempBlob.size()));\n            }\n\n            // Get layer\n            KisLayer *layer = qobject_cast<KisLayer *>(node.data());\n            KIS_ASSERT_RECOVER(layer)\n            {\n                errFile << \"Attempted to import metadata on an empty document\";\n                return ImportExportCodes::InternalError;\n            }\n\n            // Inject the data as any other IOBackend\n            io->loadFrom(layer->metaData(), &ioDevice);\n#if EXIV2_TEST_VERSION(0,28,0)\n        } catch (Exiv2::Error &e) {\n            errFile << \"Failed metadata import:\" << Exiv2::Error(e.code()).what();\n#else\n        } catch (Exiv2::AnyError &e) {\n            errFile << \"Failed metadata import:\" << e.code() << e.what();\n#endif\n        }\n    }\n\n    document->setCurrentImage(m_image);\n\n    m_image = nullptr;\n    m_photoshopBlockParsed = false;\n\n    return ImportExportCodes::OK;\n}\n```\n",
        "response": "### Core API Usage Patterns for `TIFFReadDirectory`\n\n#### **API Functionality**\n- **Purpose**: Advances the TIFF file handle to the next directory (Image File Directory, IFD) and makes it the current directory.\n- **Behavior**: Used to iterate through multiple directories (e.g., multi-page TIFFs or layered Photoshop files).\n\n#### **Typical Usage**\n- **Loop through directories**:\n  ```cpp\n  while (TIFFReadDirectory(image.get())) {\n    // Process each directory (e.g., read layers or metadata)\n    result = readTIFFDirectory(document, image.get());\n  }\n  ```\n\n#### **Key Parameters**\n- **`TIFF* tif`**: Pointer to the TIFF file handle (opened via `TIFFFdOpen`/`TIFFOpen`).\n\n#### **Return Values**\n- **`1`**: Successfully advanced to the next directory.\n- **`0`**: No more directories to read (end of file).\n- **`-1`**: Error during directory traversal (e.g., corrupt file).\n\n#### **Error Handling**\n- **Weakness in Provided Code**: Fails to explicitly check for `-1` (error return), risking silent failures.\n- **Best Practice**: Add explicit error checks:\n  ```cpp\n  int dirStatus;\n  while ((dirStatus = TIFFReadDirectory(image.get())) == 1) {\n    // Process directory\n  }\n  if (dirStatus == -1) {\n    // Handle error (e.g., log, cleanup, return error code)\n  }\n  ```\n\n#### **Best Practices**\n1. **Validate Return Values**: Check for `-1` to detect errors during iteration.\n2. **Combine with Robust Parsing**: Ensure downstream functions (e.g., `readTIFFDirectory`) handle directory-specific errors.\n3. **Resource Management**: Use RAII (e.g., `std::unique_ptr` with `TIFFCleanup`) to prevent leaks.\n4. **Metadata Handling**: Separate TIFF-specific metadata from generic Exif data during processing.\n5. **Platform Compatibility**: Use OS-agnostic file handles (e.g., `TIFFFdOpen` with `_get_osfhandle` on Windows)."
    },
    {
        "prompt": "### Task Description:\nYou are an experienced software engineer skilled in API usage analysis. Your task is to analyze the following C/C++ code snippet and summarize the core API usage patterns for 'TIFFReadDirectory', focusing on:\n- API functionality\n- Typical usage\n- Key parameters\n- Return values\n- Error handling\n- Best practices\nProvide a concise and structured response.\n\n### Provided Code Snippet:\n```c\nGDALDataset *GTiffDataset::OpenDir( GDALOpenInfo * poOpenInfo )\n\n{\n    int bAllowRGBAInterface = TRUE;\n    const char* pszFilename = poOpenInfo->pszFilename;\n    if( EQUALN(pszFilename,\"GTIFF_RAW:\", strlen(\"GTIFF_RAW:\")) )\n    {\n        bAllowRGBAInterface = FALSE;\n        pszFilename += strlen(\"GTIFF_RAW:\");\n    }\n\n    if( !EQUALN(pszFilename,\"GTIFF_DIR:\",strlen(\"GTIFF_DIR:\")) )\n        return NULL;\n    \n/* -------------------------------------------------------------------- */\n/*      Split out filename, and dir#/offset.                            */\n/* -------------------------------------------------------------------- */\n    pszFilename += strlen(\"GTIFF_DIR:\");\n    int        bAbsolute = FALSE;\n    toff_t     nOffset;\n    \n    if( EQUALN(pszFilename,\"off:\",4) )\n    {\n        bAbsolute = TRUE;\n        pszFilename += 4;\n    }\n\n    nOffset = atol(pszFilename);\n    pszFilename += 1;\n\n    while( *pszFilename != '\\0' && pszFilename[-1] != ':' )\n        pszFilename++;\n\n    if( *pszFilename == '\\0' || nOffset == 0 )\n    {\n        CPLError( CE_Failure, CPLE_OpenFailed,\n                  \"Unable to extract offset or filename, should take the form\\n\"\n                  \"GTIFF_DIR:<dir>:filename or GTIFF_DIR:off:<dir_offset>:filename\" );\n        return NULL;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Try opening the dataset.                                        */\n/* -------------------------------------------------------------------- */\n    TIFF\t*hTIFF;\n\n    GTiffOneTimeInit();\n\n    hTIFF = VSI_TIFFOpen( pszFilename, \"r\" );\n    if( hTIFF == NULL )\n        return( NULL );\n\n/* -------------------------------------------------------------------- */\n/*      If a directory was requested by index, advance to it now.       */\n/* -------------------------------------------------------------------- */\n    if( !bAbsolute )\n    {\n        while( nOffset > 1 )\n        {\n            if( TIFFReadDirectory( hTIFF ) == 0 )\n            {\n                XTIFFClose( hTIFF );\n                CPLError( CE_Failure, CPLE_OpenFailed, \n                          \"Requested directory %lu not found.\", (long unsigned int)nOffset );\n                return NULL;\n            }\n            nOffset--;\n        }\n\n        nOffset = TIFFCurrentDirOffset( hTIFF );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Create a corresponding GDALDataset.                             */\n/* -------------------------------------------------------------------- */\n    GTiffDataset \t*poDS;\n\n    poDS = new GTiffDataset();\n    poDS->SetDescription( poOpenInfo->pszFilename );\n    poDS->osFilename = poOpenInfo->pszFilename;\n    poDS->poActiveDS = poDS;\n\n    if( !EQUAL(pszFilename,poOpenInfo->pszFilename) \n        && !EQUALN(poOpenInfo->pszFilename,\"GTIFF_RAW:\",10) )\n    {\n        poDS->SetPhysicalFilename( pszFilename );\n        poDS->SetSubdatasetName( poOpenInfo->pszFilename );\n        poDS->osFilename = pszFilename;\n    }\n\n    if (poOpenInfo->eAccess == GA_Update)\n    {\n        CPLError( CE_Warning, CPLE_AppDefined,\n                  \"Opening a specific TIFF directory is not supported in update mode. Switching to read-only\" );\n    }\n\n    if( poDS->OpenOffset( hTIFF, &(poDS->poActiveDS),\n                          nOffset, FALSE, GA_ReadOnly, bAllowRGBAInterface ) != CE_None )\n    {\n        delete poDS;\n        return NULL;\n    }\n    else\n    {\n        poDS->bCloseTIFFHandle = TRUE;\n        return poDS;\n    }\n}\n```\n",
        "response": "### Core API Usage Patterns for `TIFFReadDirectory`\n\n#### **API Functionality**\n- **Purpose**: Reads the next TIFF directory (subfile) from an open TIFF file and makes it the current directory.\n- **Operation**: Incrementally navigates through TIFF directories in sequential order. Used to access multi-directory (multi-page) TIFF files.\n\n#### **Typical Usage**\n- **Directory Navigation**: Called in a loop to advance to a specific directory index (e.g., `while(nOffset > 1) { TIFFReadDirectory(...); nOffset--; }`).\n- **Multi-Directory Files**: Enables access to subdatasets or pages in TIFF files with multiple directories.\n\n#### **Key Parameters**\n- **`TIFF *tif`**: The TIFF file handle (e.g., `hTIFF` in the code), opened via `TIFFOpen` or `VSI_TIFFOpen`.\n\n#### **Return Values**\n- **Success**: Returns `1` when the next directory is successfully read.\n- **Failure**: Returns `0` if no more directories exist or an error occurs (e.g., invalid directory structure).\n\n#### **Error Handling**\n- **Explicit Checks**: Return value is checked after each call (e.g., `if(TIFFReadDirectory(...) == 0)`).\n- **Resource Cleanup**: On failure, the TIFF handle is closed (`XTIFFClose`), and an error is logged via `CPLError`.\n- **Error Messaging**: Provides context-specific failure details (e.g., \"Requested directory %lu not found\").\n\n#### **Best Practices**\n1. **Loop Safely**: Use in loops with decrementing counters to target specific directories (non-absolute mode).\n2. **Validate Returns**: Always check the return value to avoid silent failures.\n3. **Cleanup Resources**: Ensure TIFF handles are closed if navigation fails.\n4. **Absolute vs. Relative**: Prefer absolute offsets (`TIFFCurrentDirOffset`) for direct access when possible, avoiding sequential reads.\n5. **State Awareness**: After successful navigation, confirm the current directory offset with `TIFFCurrentDirOffset`.\n\n### Summary in Code Context\nThe provided code uses `TIFFReadDirectory` to iterate through TIFF directories until reaching a user-specified index. It handles errors by closing the TIFF handle and reporting failures, ensuring robust navigation in multi-directory TIFF files."
    },
    {
        "prompt": "### Task Description:\nYou are an experienced software engineer skilled in API usage analysis. Your task is to analyze the following C/C++ code snippet and summarize the core API usage patterns for 'TIFFReadDirectory', focusing on:\n- API functionality\n- Typical usage\n- Key parameters\n- Return values\n- Error handling\n- Best practices\nProvide a concise and structured response.\n\n### Provided Code Snippet:\n```c\nCPLErr GTiffDataset::OpenOffset( TIFF *hTIFFIn, \n                                 GTiffDataset **ppoActiveDSRef,\n                                 toff_t nDirOffsetIn, \n\t\t\t\t int bBaseIn, GDALAccess eAccess,\n                                 int bAllowRGBAInterface)\n\n{\n    uint32\tnXSize, nYSize;\n    int\t\tbTreatAsBitmap = FALSE;\n    int         bTreatAsOdd = FALSE;\n\n    this->eAccess = eAccess;\n\n    hTIFF = hTIFFIn;\n    this->ppoActiveDSRef = ppoActiveDSRef;\n\n    nDirOffset = nDirOffsetIn;\n\n    if (!SetDirectory( nDirOffsetIn ))\n        return CE_Failure;\n\n    bBase = bBaseIn;\n\n    this->eAccess = eAccess;\n\n/* -------------------------------------------------------------------- */\n/*      Capture some information from the file that is of interest.     */\n/* -------------------------------------------------------------------- */\n    TIFFGetField( hTIFF, TIFFTAG_IMAGEWIDTH, &nXSize );\n    TIFFGetField( hTIFF, TIFFTAG_IMAGELENGTH, &nYSize );\n    nRasterXSize = nXSize;\n    nRasterYSize = nYSize;\n\n    if( !TIFFGetField(hTIFF, TIFFTAG_SAMPLESPERPIXEL, &nSamplesPerPixel ) )\n        nBands = 1;\n    else\n        nBands = nSamplesPerPixel;\n    \n    if( !TIFFGetField(hTIFF, TIFFTAG_BITSPERSAMPLE, &(nBitsPerSample)) )\n        nBitsPerSample = 1;\n    \n    if( !TIFFGetField( hTIFF, TIFFTAG_PLANARCONFIG, &(nPlanarConfig) ) )\n        nPlanarConfig = PLANARCONFIG_CONTIG;\n    \n    if( !TIFFGetField( hTIFF, TIFFTAG_PHOTOMETRIC, &(nPhotometric) ) )\n        nPhotometric = PHOTOMETRIC_MINISBLACK;\n    \n    if( !TIFFGetField( hTIFF, TIFFTAG_SAMPLEFORMAT, &(nSampleFormat) ) )\n        nSampleFormat = SAMPLEFORMAT_UINT;\n    \n    if( !TIFFGetField( hTIFF, TIFFTAG_COMPRESSION, &(nCompression) ) )\n        nCompression = COMPRESSION_NONE;\n    \n#if defined(TIFFLIB_VERSION) && TIFFLIB_VERSION > 20031007 /* 3.6.0 */\n    if (nCompression != COMPRESSION_NONE &&\n        !TIFFIsCODECConfigured(nCompression))\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                  \"Cannot open TIFF file due to missing codec.\" );\n        return CE_Failure;\n    }\n#endif\n\n/* -------------------------------------------------------------------- */\n/*      YCbCr JPEG compressed images should be translated on the fly    */\n/*      to RGB by libtiff/libjpeg unless specifically requested         */\n/*      otherwise.                                                      */\n/* -------------------------------------------------------------------- */\n    if( nCompression == COMPRESSION_JPEG \n        && nPhotometric == PHOTOMETRIC_YCBCR \n        && CSLTestBoolean( CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\",\n                                              \"YES\") ) )\n    {\n        int nColorMode;\n\n        SetMetadataItem( \"SOURCE_COLOR_SPACE\", \"YCbCr\", \"IMAGE_STRUCTURE\" );\n        if ( !TIFFGetField( hTIFF, TIFFTAG_JPEGCOLORMODE, &nColorMode ) ||\n              nColorMode != JPEGCOLORMODE_RGB )\n            TIFFSetField(hTIFF, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Get strip/tile layout.                                          */\n/* -------------------------------------------------------------------- */\n    if( TIFFIsTiled(hTIFF) )\n    {\n        TIFFGetField( hTIFF, TIFFTAG_TILEWIDTH, &(nBlockXSize) );\n        TIFFGetField( hTIFF, TIFFTAG_TILELENGTH, &(nBlockYSize) );\n    }\n    else\n    {\n        if( !TIFFGetField( hTIFF, TIFFTAG_ROWSPERSTRIP,\n                           &(nRowsPerStrip) ) )\n        {\n            CPLError( CE_Warning, CPLE_AppDefined, \n                      \"RowsPerStrip not defined ... assuming all one strip.\" );\n            nRowsPerStrip = nYSize; /* dummy value */\n        }\n\n        nBlockXSize = nRasterXSize;\n        nBlockYSize = MIN(nRowsPerStrip,nYSize);\n    }\n        \n    nBlocksPerBand =\n        ((nYSize + nBlockYSize - 1) / nBlockYSize)\n        * ((nXSize + nBlockXSize  - 1) / nBlockXSize);\n\n/* -------------------------------------------------------------------- */\n/*      Should we handle this using the GTiffBitmapBand?                */\n/* -------------------------------------------------------------------- */\n    if( nBitsPerSample == 1 && nBands == 1 )\n    {\n        bTreatAsBitmap = TRUE;\n\n        // Lets treat large \"one row\" bitmaps using the scanline api.\n        if( !TIFFIsTiled(hTIFF) \n            && nBlockYSize == nYSize \n            && nYSize > 2000 \n            && bAllowRGBAInterface )\n            bTreatAsSplitBitmap = TRUE;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Should we treat this via the RGBA interface?                    */\n/* -------------------------------------------------------------------- */\n    if( bAllowRGBAInterface &&\n        !bTreatAsBitmap && !(nBitsPerSample > 8) \n        && (nPhotometric == PHOTOMETRIC_CIELAB ||\n            nPhotometric == PHOTOMETRIC_LOGL ||\n            nPhotometric == PHOTOMETRIC_LOGLUV ||\n            nPhotometric == PHOTOMETRIC_SEPARATED ||\n            ( nPhotometric == PHOTOMETRIC_YCBCR \n              && nCompression != COMPRESSION_JPEG )) )\n    {\n        char\tszMessage[1024];\n\n        if( TIFFRGBAImageOK( hTIFF, szMessage ) == 1 )\n        {\n            const char* pszSourceColorSpace = NULL;\n            switch (nPhotometric)\n            {\n                case PHOTOMETRIC_CIELAB:\n                    pszSourceColorSpace = \"CIELAB\";\n                    break;\n                case PHOTOMETRIC_LOGL:\n                    pszSourceColorSpace = \"LOGL\";\n                    break;\n                case PHOTOMETRIC_LOGLUV:\n                    pszSourceColorSpace = \"LOGLUV\";\n                    break;\n                case PHOTOMETRIC_SEPARATED:\n                    pszSourceColorSpace = \"CMYK\";\n                    break;\n                case PHOTOMETRIC_YCBCR:\n                    pszSourceColorSpace = \"YCbCr\";\n                    break;\n            }\n            if (pszSourceColorSpace)\n                SetMetadataItem( \"SOURCE_COLOR_SPACE\", pszSourceColorSpace, \"IMAGE_STRUCTURE\" );\n            bTreatAsRGBA = TRUE;\n            nBands = 4;\n        }\n        else\n        {\n            CPLDebug( \"GTiff\", \"TIFFRGBAImageOK says:\\n%s\", szMessage );\n        }\n    }\n    \n/* -------------------------------------------------------------------- */\n/*      Should we treat this via the split interface?                   */\n/* -------------------------------------------------------------------- */\n    if( !TIFFIsTiled(hTIFF) \n        && nBitsPerSample == 8\n        && nBlockYSize == nYSize \n        && nYSize > 2000\n        && !bTreatAsRGBA \n        && CSLTestBoolean(CPLGetConfigOption(\"GDAL_ENABLE_TIFF_SPLIT\", \"YES\")))\n    {\n        /* libtiff 3.9.2 (20091104) and older, libtiff 4.0.0beta5 (also 20091104) */\n        /* and older will crash when trying to open a all-in-one-strip */\n        /* YCbCr JPEG compressed TIFF (see #3259). BUG_3259_FIXED is defined */\n        /* in internal libtiff tif_config.h until a 4.0.0beta6 is released */\n#if (TIFFLIB_VERSION <= 20091104 && !defined(BIGTIFF_SUPPORT)) || \\\n    (TIFFLIB_VERSION <= 20091104 && defined(BIGTIFF_SUPPORT) && !defined(BUG_3259_FIXED))\n        if (nPhotometric == PHOTOMETRIC_YCBCR  &&\n            nCompression == COMPRESSION_JPEG)\n        {\n            CPLDebug(\"GTiff\", \"Avoid using split band to open all-in-one-strip \"\n                              \"YCbCr JPEG compressed TIFF because of older libtiff\");\n        }\n        else\n#endif\n            bTreatAsSplit = TRUE;\n    }\n    \n/* -------------------------------------------------------------------- */\n/*      Should we treat this via the odd bits interface?                */\n/* -------------------------------------------------------------------- */\n    if ( nSampleFormat == SAMPLEFORMAT_IEEEFP )\n    {\n        if ( nBitsPerSample == 16 || nBitsPerSample == 24 )\n            bTreatAsOdd = TRUE;\n    }\n    else if ( !bTreatAsRGBA && !bTreatAsBitmap\n              && nBitsPerSample != 8\n              && nBitsPerSample != 16\n              && nBitsPerSample != 32\n              && nBitsPerSample != 64 \n              && nBitsPerSample != 128 )\n        bTreatAsOdd = TRUE;\n\n    int bMinIsWhite = nPhotometric == PHOTOMETRIC_MINISWHITE;\n\n/* -------------------------------------------------------------------- */\n/*      Capture the color table if there is one.                        */\n/* -------------------------------------------------------------------- */\n    unsigned short\t*panRed, *panGreen, *panBlue;\n\n    if( bTreatAsRGBA \n        || TIFFGetField( hTIFF, TIFFTAG_COLORMAP, \n                         &panRed, &panGreen, &panBlue) == 0 )\n    {\n\t// Build inverted palette if we have inverted photometric.\n\t// Pixel values remains unchanged.  Avoid doing this for *deep*\n        // data types (per #1882)\n\tif( nBitsPerSample <= 16 && nPhotometric == PHOTOMETRIC_MINISWHITE )\n\t{\n\t    GDALColorEntry  oEntry;\n\t    int\t\t    iColor, nColorCount;\n\t    \n\t    poColorTable = new GDALColorTable();\n\t    nColorCount = 1 << nBitsPerSample;\n\n\t    for ( iColor = 0; iColor < nColorCount; iColor++ )\n\t    {\n\t\toEntry.c1 = oEntry.c2 = oEntry.c3 = (short) \n                    ((255 * (nColorCount - 1 - iColor)) / (nColorCount-1));\n\t\toEntry.c4 = 255;\n\t\tpoColorTable->SetColorEntry( iColor, &oEntry );\n\t    }\n\n\t    nPhotometric = PHOTOMETRIC_PALETTE;\n\t}\n\telse\n\t    poColorTable = NULL;\n    }\n    else\n    {\n        int\tnColorCount, nMaxColor = 0;\n        GDALColorEntry oEntry;\n\n        poColorTable = new GDALColorTable();\n\n        nColorCount = 1 << nBitsPerSample;\n\n        for( int iColor = nColorCount - 1; iColor >= 0; iColor-- )\n        {\n            oEntry.c1 = panRed[iColor] / 256;\n            oEntry.c2 = panGreen[iColor] / 256;\n            oEntry.c3 = panBlue[iColor] / 256;\n            oEntry.c4 = 255;\n\n            poColorTable->SetColorEntry( iColor, &oEntry );\n\n            nMaxColor = MAX(nMaxColor,panRed[iColor]);\n            nMaxColor = MAX(nMaxColor,panGreen[iColor]);\n            nMaxColor = MAX(nMaxColor,panBlue[iColor]);\n        }\n\n        // Bug 1384 - Some TIFF files are generated with color map entry\n        // values in range 0-255 instead of 0-65535 - try to handle these\n        // gracefully.\n        if( nMaxColor > 0 && nMaxColor < 256 )\n        {\n            CPLDebug( \"GTiff\", \"TIFF ColorTable seems to be improperly scaled, fixing up.\" );\n            \n            for( int iColor = nColorCount - 1; iColor >= 0; iColor-- )\n            {\n                oEntry.c1 = panRed[iColor];\n                oEntry.c2 = panGreen[iColor];\n                oEntry.c3 = panBlue[iColor];\n                oEntry.c4 = 255;\n                \n                poColorTable->SetColorEntry( iColor, &oEntry );\n            }\n        }\n    }\n    \n/* -------------------------------------------------------------------- */\n/*      Create band information objects.                                */\n/* -------------------------------------------------------------------- */\n    for( int iBand = 0; iBand < nBands; iBand++ )\n    {\n        if( bTreatAsRGBA )\n            SetBand( iBand+1, new GTiffRGBABand( this, iBand+1 ) );\n        else if( bTreatAsSplitBitmap )\n            SetBand( iBand+1, new GTiffSplitBitmapBand( this, iBand+1 ) );\n        else if( bTreatAsSplit )\n            SetBand( iBand+1, new GTiffSplitBand( this, iBand+1 ) );\n        else if( bTreatAsBitmap )\n            SetBand( iBand+1, new GTiffBitmapBand( this, iBand+1 ) );\n        else if( bTreatAsOdd )\n            SetBand( iBand+1, new GTiffOddBitsBand( this, iBand+1 ) );\n        else\n            SetBand( iBand+1, new GTiffRasterBand( this, iBand+1 ) );\n    }\n\n    if( GetRasterBand(1)->GetRasterDataType() == GDT_Unknown )\n    {\n        CPLError( CE_Failure, CPLE_NotSupported,\n                  \"Unsupported TIFF configuration.\" );\n        return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Get the transform or gcps from the GeoTIFF file.                */\n/* -------------------------------------------------------------------- */\n    if( bBaseIn )\n    {\n        char    *pszTabWKT = NULL;\n        double\t*padfTiePoints, *padfScale, *padfMatrix;\n        uint16\tnCount;\n\n        adfGeoTransform[0] = 0.0;\n        adfGeoTransform[1] = 1.0;\n        adfGeoTransform[2] = 0.0;\n        adfGeoTransform[3] = 0.0;\n        adfGeoTransform[4] = 0.0;\n        adfGeoTransform[5] = 1.0;\n    \n        if( TIFFGetField(hTIFF,TIFFTAG_GEOPIXELSCALE,&nCount,&padfScale )\n            && nCount >= 2 \n            && padfScale[0] != 0.0 && padfScale[1] != 0.0 )\n        {\n            adfGeoTransform[1] = padfScale[0];\n            adfGeoTransform[5] = - ABS(padfScale[1]);\n\n            if( TIFFGetField(hTIFF,TIFFTAG_GEOTIEPOINTS,&nCount,&padfTiePoints )\n                && nCount >= 6 )\n            {\n                adfGeoTransform[0] =\n                    padfTiePoints[3] - padfTiePoints[0] * adfGeoTransform[1];\n                adfGeoTransform[3] =\n                    padfTiePoints[4] - padfTiePoints[1] * adfGeoTransform[5];\n\n                bGeoTransformValid = TRUE;\n            }\n        }\n\n        else if( TIFFGetField(hTIFF,TIFFTAG_GEOTRANSMATRIX,&nCount,&padfMatrix ) \n                 && nCount == 16 )\n        {\n            adfGeoTransform[0] = padfMatrix[3];\n            adfGeoTransform[1] = padfMatrix[0];\n            adfGeoTransform[2] = padfMatrix[1];\n            adfGeoTransform[3] = padfMatrix[7];\n            adfGeoTransform[4] = padfMatrix[4];\n            adfGeoTransform[5] = padfMatrix[5];\n            bGeoTransformValid = TRUE;\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Otherwise try looking for a .tfw, .tifw or .wld file.           */\n/* -------------------------------------------------------------------- */\n        else\n        {\n            bGeoTransformValid = \n                GDALReadWorldFile( osFilename, NULL, adfGeoTransform );\n\n            if( !bGeoTransformValid )\n            {\n                bGeoTransformValid = \n                    GDALReadWorldFile( osFilename, \"wld\", adfGeoTransform );\n            }\n\n            if( !bGeoTransformValid )\n            {\n                int bTabFileOK = \n                    GDALReadTabFile( osFilename, adfGeoTransform, \n                                     &pszTabWKT, &nGCPCount, &pasGCPList );\n\n                if( bTabFileOK && nGCPCount == 0 )\n                    bGeoTransformValid = TRUE;\n            }\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Check for GCPs.  Note, we will allow there to be GCPs and a     */\n/*      transform in some circumstances.                                */\n/* -------------------------------------------------------------------- */\n        if( TIFFGetField(hTIFF,TIFFTAG_GEOTIEPOINTS,&nCount,&padfTiePoints )\n            && !bGeoTransformValid )\n        {\n            nGCPCount = nCount / 6;\n            pasGCPList = (GDAL_GCP *) CPLCalloc(sizeof(GDAL_GCP),nGCPCount);\n        \n            for( int iGCP = 0; iGCP < nGCPCount; iGCP++ )\n            {\n                char\tszID[32];\n\n                sprintf( szID, \"%d\", iGCP+1 );\n                pasGCPList[iGCP].pszId = CPLStrdup( szID );\n                pasGCPList[iGCP].pszInfo = CPLStrdup(\"\");\n                pasGCPList[iGCP].dfGCPPixel = padfTiePoints[iGCP*6+0];\n                pasGCPList[iGCP].dfGCPLine = padfTiePoints[iGCP*6+1];\n                pasGCPList[iGCP].dfGCPX = padfTiePoints[iGCP*6+3];\n                pasGCPList[iGCP].dfGCPY = padfTiePoints[iGCP*6+4];\n                pasGCPList[iGCP].dfGCPZ = padfTiePoints[iGCP*6+5];\n            }\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Did we find a tab file?  If so we will use it's coordinate      */\n/*      system and give it precidence.                                  */\n/* -------------------------------------------------------------------- */\n        if( pszTabWKT != NULL \n            && (pszProjection == NULL || pszProjection[0] == '\\0') )\n        {\n            CPLFree( pszProjection );\n            pszProjection = pszTabWKT;\n            pszTabWKT = NULL;\n            bLookedForProjection = TRUE;\n        }\n        \n        CPLFree( pszTabWKT );\n        bGeoTIFFInfoChanged = FALSE;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Capture some other potentially interesting information.         */\n/* -------------------------------------------------------------------- */\n    char\t*pszText, szWorkMDI[200];\n    float   fResolution;\n    uint16  nShort;\n\n    if( TIFFGetField( hTIFF, TIFFTAG_DOCUMENTNAME, &pszText ) )\n        SetMetadataItem( \"TIFFTAG_DOCUMENTNAME\",  pszText );\n\n    if( TIFFGetField( hTIFF, TIFFTAG_IMAGEDESCRIPTION, &pszText ) )\n        SetMetadataItem( \"TIFFTAG_IMAGEDESCRIPTION\", pszText );\n\n    if( TIFFGetField( hTIFF, TIFFTAG_SOFTWARE, &pszText ) )\n        SetMetadataItem( \"TIFFTAG_SOFTWARE\", pszText );\n\n    if( TIFFGetField( hTIFF, TIFFTAG_DATETIME, &pszText ) )\n        SetMetadataItem( \"TIFFTAG_DATETIME\", pszText );\n\n    if( TIFFGetField( hTIFF, TIFFTAG_ARTIST, &pszText ) )\n        SetMetadataItem( \"TIFFTAG_ARTIST\", pszText );\n\n    if( TIFFGetField( hTIFF, TIFFTAG_HOSTCOMPUTER, &pszText ) )\n        SetMetadataItem( \"TIFFTAG_HOSTCOMPUTER\", pszText );\n\n    if( TIFFGetField( hTIFF, TIFFTAG_COPYRIGHT, &pszText ) )\n        SetMetadataItem( \"TIFFTAG_COPYRIGHT\", pszText );\n\n    if( TIFFGetField( hTIFF, TIFFTAG_XRESOLUTION, &fResolution ) )\n    {\n        sprintf( szWorkMDI, \"%.8g\", fResolution );\n        SetMetadataItem( \"TIFFTAG_XRESOLUTION\", szWorkMDI );\n    }\n\n    if( TIFFGetField( hTIFF, TIFFTAG_YRESOLUTION, &fResolution ) )\n    {\n        sprintf( szWorkMDI, \"%.8g\", fResolution );\n        SetMetadataItem( \"TIFFTAG_YRESOLUTION\", szWorkMDI );\n    }\n\n    if( TIFFGetField( hTIFF, TIFFTAG_MINSAMPLEVALUE, &nShort ) )\n    {\n        sprintf( szWorkMDI, \"%d\", nShort );\n        SetMetadataItem( \"TIFFTAG_MINSAMPLEVALUE\", szWorkMDI );\n    }\n\n    if( TIFFGetField( hTIFF, TIFFTAG_MAXSAMPLEVALUE, &nShort ) )\n    {\n        sprintf( szWorkMDI, \"%d\", nShort );\n        SetMetadataItem( \"TIFFTAG_MAXSAMPLEVALUE\", szWorkMDI );\n    }\n\n    if( TIFFGetField( hTIFF, TIFFTAG_RESOLUTIONUNIT, &nShort ) )\n    {\n        if( nShort == RESUNIT_NONE )\n            sprintf( szWorkMDI, \"%d (unitless)\", nShort );\n        else if( nShort == RESUNIT_INCH )\n            sprintf( szWorkMDI, \"%d (pixels/inch)\", nShort );\n        else if( nShort == RESUNIT_CENTIMETER )\n            sprintf( szWorkMDI, \"%d (pixels/cm)\", nShort );\n        else\n            sprintf( szWorkMDI, \"%d\", nShort );\n        SetMetadataItem( \"TIFFTAG_RESOLUTIONUNIT\", szWorkMDI );\n    }\n\n    if( nCompression == COMPRESSION_NONE )\n        /* no compression tag */;\n    else if( nCompression == COMPRESSION_CCITTRLE )\n        SetMetadataItem( \"COMPRESSION\", \"CCITTRLE\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_CCITTFAX3 )\n        SetMetadataItem( \"COMPRESSION\", \"CCITTFAX3\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_CCITTFAX4 )\n        SetMetadataItem( \"COMPRESSION\", \"CCITTFAX4\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_LZW )\n        SetMetadataItem( \"COMPRESSION\", \"LZW\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_OJPEG )\n        SetMetadataItem( \"COMPRESSION\", \"OJPEG\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_JPEG )\n    {  \n        if ( nPhotometric == PHOTOMETRIC_YCBCR )\n            SetMetadataItem( \"COMPRESSION\", \"YCbCr JPEG\", \"IMAGE_STRUCTURE\" );\n        else\n            SetMetadataItem( \"COMPRESSION\", \"JPEG\", \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_NEXT )\n        SetMetadataItem( \"COMPRESSION\", \"NEXT\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_CCITTRLEW )\n        SetMetadataItem( \"COMPRESSION\", \"CCITTRLEW\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_PACKBITS )\n        SetMetadataItem( \"COMPRESSION\", \"PACKBITS\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_THUNDERSCAN )\n        SetMetadataItem( \"COMPRESSION\", \"THUNDERSCAN\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_PIXARFILM )\n        SetMetadataItem( \"COMPRESSION\", \"PIXARFILM\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_PIXARLOG )\n        SetMetadataItem( \"COMPRESSION\", \"PIXARLOG\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_DEFLATE )\n        SetMetadataItem( \"COMPRESSION\", \"DEFLATE\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_ADOBE_DEFLATE )\n        SetMetadataItem( \"COMPRESSION\", \"DEFLATE\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_DCS )\n        SetMetadataItem( \"COMPRESSION\", \"DCS\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_JBIG )\n        SetMetadataItem( \"COMPRESSION\", \"JBIG\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_SGILOG )\n        SetMetadataItem( \"COMPRESSION\", \"SGILOG\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_SGILOG24 )\n        SetMetadataItem( \"COMPRESSION\", \"SGILOG24\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_JP2000 )\n        SetMetadataItem( \"COMPRESSION\", \"JP2000\", \"IMAGE_STRUCTURE\" );\n    else\n    {\n        CPLString oComp;\n        SetMetadataItem( \"COMPRESSION\", \n                         (const char *) oComp.Printf( \"%d\", nCompression));\n    }\n\n    if( nPlanarConfig == PLANARCONFIG_CONTIG && nBands != 1 )\n        SetMetadataItem( \"INTERLEAVE\", \"PIXEL\", \"IMAGE_STRUCTURE\" );\n    else\n        SetMetadataItem( \"INTERLEAVE\", \"BAND\", \"IMAGE_STRUCTURE\" );\n\n    if(  (GetRasterBand(1)->GetRasterDataType() == GDT_Byte   && nBitsPerSample != 8 ) ||\n         (GetRasterBand(1)->GetRasterDataType() == GDT_UInt16 && nBitsPerSample != 16) ||\n         (GetRasterBand(1)->GetRasterDataType() == GDT_UInt32 && nBitsPerSample != 32) )\n    {\n        for (int i = 0; i < nBands; ++i)\n            GetRasterBand(i+1)->SetMetadataItem( \"NBITS\", \n                                                 CPLString().Printf( \"%d\", (int)nBitsPerSample ),\n                                                 \"IMAGE_STRUCTURE\" );\n    }\n        \n    if( bMinIsWhite )\n        SetMetadataItem( \"MINISWHITE\", \"YES\", \"IMAGE_STRUCTURE\" );\n\n    if( TIFFGetField( hTIFF, TIFFTAG_GDAL_METADATA, &pszText ) )\n    {\n        CPLXMLNode *psRoot = CPLParseXMLString( pszText );\n        CPLXMLNode *psItem = NULL;\n\n        if( psRoot != NULL && psRoot->eType == CXT_Element\n            && EQUAL(psRoot->pszValue,\"GDALMetadata\") )\n            psItem = psRoot->psChild;\n\n        for( ; psItem != NULL; psItem = psItem->psNext )\n        {\n            const char *pszKey, *pszValue, *pszRole, *pszDomain; \n            char *pszUnescapedValue;\n            int nBand, bIsXML = FALSE;\n\n            if( psItem->eType != CXT_Element\n                || !EQUAL(psItem->pszValue,\"Item\") )\n                continue;\n\n            pszKey = CPLGetXMLValue( psItem, \"name\", NULL );\n            pszValue = CPLGetXMLValue( psItem, NULL, NULL );\n            nBand = atoi(CPLGetXMLValue( psItem, \"sample\", \"-1\" )) + 1;\n            pszRole = CPLGetXMLValue( psItem, \"role\", \"\" );\n            pszDomain = CPLGetXMLValue( psItem, \"domain\", \"\" );\n                \n            if( pszKey == NULL || pszValue == NULL )\n                continue;\n\n            if( EQUALN(pszDomain,\"xml:\",4) )\n                bIsXML = TRUE;\n\n            pszUnescapedValue = CPLUnescapeString( pszValue, NULL, \n                                                   CPLES_XML );\n            if( nBand == 0 )\n            {\n                if( bIsXML )\n                {\n                    char *apszMD[2] = { pszUnescapedValue, NULL };\n                    SetMetadata( apszMD, pszDomain );\n                }\n                else\n                    SetMetadataItem( pszKey, pszUnescapedValue, pszDomain );\n            }\n            else\n            {\n                GDALRasterBand *poBand = GetRasterBand(nBand);\n                if( poBand != NULL )\n                {\n                    if( EQUAL(pszRole,\"scale\") )\n                        poBand->SetScale( atof(pszUnescapedValue) );\n                    else if( EQUAL(pszRole,\"offset\") )\n                        poBand->SetOffset( atof(pszUnescapedValue) );\n                    else if( EQUAL(pszRole,\"unittype\") )\n                        poBand->SetUnitType( pszUnescapedValue );\n                    else\n                    {\n                        if( bIsXML )\n                        {\n                            char *apszMD[2] = { pszUnescapedValue, NULL };\n                            poBand->SetMetadata( apszMD, pszDomain );\n                        }\n                        else\n                            poBand->SetMetadataItem(pszKey,pszUnescapedValue,\n                                                    pszDomain );\n                    }\n                }\n            }\n            CPLFree( pszUnescapedValue );\n        }\n\n        CPLDestroyXMLNode( psRoot );\n    }\n\n    bMetadataChanged = FALSE;\n\n/* -------------------------------------------------------------------- */\n/*      Check for RPC metadata in an RPB file.                          */\n/* -------------------------------------------------------------------- */\n    if( bBaseIn )\n    {\n        char **papszRPCMD = GDALLoadRPBFile( osFilename, NULL );\n        \n        if( papszRPCMD != NULL )\n        {\n            oGTiffMDMD.SetMetadata( papszRPCMD, \"RPC\" );\n            CSLDestroy( papszRPCMD );\n            bMetadataChanged = FALSE;\n        }\n        else\n            ReadRPCTag();\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Check for RPC metadata in an RPB file.                          */\n/* -------------------------------------------------------------------- */\n    if( bBaseIn )\n    {\n        char **papszIMDMD = GDALLoadIMDFile( osFilename, NULL );\n\n        if( papszIMDMD != NULL )\n        {\n            oGTiffMDMD.SetMetadata( papszIMDMD, \"IMD\" );\n            CSLDestroy( papszIMDMD );\n            bMetadataChanged = FALSE;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Check for NODATA                                                */\n/* -------------------------------------------------------------------- */\n    if( TIFFGetField( hTIFF, TIFFTAG_GDAL_NODATA, &pszText ) )\n    {\n        bNoDataSet = TRUE;\n        dfNoDataValue = atof( pszText );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If this is a \"base\" raster, we should scan for any              */\n/*      associated overviews, internal mask bands and subdatasets.      */\n/* -------------------------------------------------------------------- */\n    if( bBase )\n    {\n        char **papszSubdatasets = NULL;\n        int  iDirIndex = 0;\n\n        FlushDirectory();  \n        while( !TIFFLastDirectory( hTIFF ) \n               && (iDirIndex == 0 || TIFFReadDirectory( hTIFF ) != 0) )\n        {\n            toff_t\tnThisDir = TIFFCurrentDirOffset(hTIFF);\n            uint32\tnSubType = 0;\n\n            *ppoActiveDSRef = NULL; // our directory no longer matches this ds\n            \n            iDirIndex++;\n\n            if( !TIFFGetField(hTIFF, TIFFTAG_SUBFILETYPE, &nSubType) )\n                nSubType = 0;\n\n            /* Embedded overview of the main image */\n            if ((nSubType & FILETYPE_REDUCEDIMAGE) != 0 &&\n                (nSubType & FILETYPE_MASK) == 0 &&\n                iDirIndex != 1 )\n            {\n                GTiffDataset\t*poODS;\n                \n                poODS = new GTiffDataset();\n                if( poODS->OpenOffset( hTIFF, ppoActiveDSRef, nThisDir, FALSE, \n                                       eAccess ) != CE_None \n                    || poODS->GetRasterCount() != GetRasterCount() )\n                {\n                    delete poODS;\n                }\n                else\n                {\n                    CPLDebug( \"GTiff\", \"Opened %dx%d overview.\\n\", \n                              poODS->GetRasterXSize(), poODS->GetRasterYSize());\n                    nOverviewCount++;\n                    papoOverviewDS = (GTiffDataset **)\n                        CPLRealloc(papoOverviewDS, \n                                   nOverviewCount * (sizeof(void*)));\n                    papoOverviewDS[nOverviewCount-1] = poODS;\n                    poODS->poBaseDS = this;\n                }\n            }\n            \n            /* Embedded mask of the main image */\n            else if ((nSubType & FILETYPE_MASK) != 0 &&\n                     (nSubType & FILETYPE_REDUCEDIMAGE) == 0 &&\n                     poMaskDS == NULL )\n            {\n                poMaskDS = new GTiffDataset();\n                \n                /* The TIFF6 specification - page 37 - only allows 1 SamplesPerPixel and 1 BitsPerSample\n                   Here we support either 1 or 8 bit per sample\n                   and we support either 1 sample per pixel or as many samples as in the main image\n                   We don't check the value of the PhotometricInterpretation tag, which should be\n                   set to \"Transparency mask\" (4) according to the specification (page 36)\n                   ... But the TIFF6 specification allows image masks to have a higher resolution than\n                   the main image, what we don't support here\n                */\n\n                if( poMaskDS->OpenOffset( hTIFF, ppoActiveDSRef, nThisDir, \n                                          FALSE, eAccess ) != CE_None \n                    || poMaskDS->GetRasterCount() == 0\n                    || !(poMaskDS->GetRasterCount() == 1 || poMaskDS->GetRasterCount() == GetRasterCount())\n                    || poMaskDS->GetRasterXSize() != GetRasterXSize()\n                    || poMaskDS->GetRasterYSize() != GetRasterYSize()\n                    || poMaskDS->GetRasterBand(1)->GetRasterDataType() != GDT_Byte)\n                {\n                    delete poMaskDS;\n                    poMaskDS = NULL;\n                }\n                else\n                {\n                    CPLDebug( \"GTiff\", \"Opened band mask.\\n\");\n                    poMaskDS->poBaseDS = this;\n                }\n            }\n            \n            /* Embedded mask of an overview */\n            /* The TIFF6 specification allows the combination of the FILETYPE_xxxx masks */\n            else if (nSubType & (FILETYPE_REDUCEDIMAGE | FILETYPE_MASK))\n            {\n                GTiffDataset* poDS = new GTiffDataset();\n                if( poDS->OpenOffset( hTIFF, ppoActiveDSRef, nThisDir, FALSE, \n                                      eAccess ) != CE_None\n                    || poDS->GetRasterCount() == 0\n                    || poDS->GetRasterBand(1)->GetRasterDataType() != GDT_Byte)\n                {\n                    delete poDS;\n                }\n                else\n                {\n                    int i;\n                    for(i=0;i<nOverviewCount;i++)\n                    {\n                        if (((GTiffDataset*)papoOverviewDS[i])->poMaskDS == NULL &&\n                            poDS->GetRasterXSize() == papoOverviewDS[i]->GetRasterXSize() &&\n                            poDS->GetRasterYSize() == papoOverviewDS[i]->GetRasterYSize() &&\n                            (poDS->GetRasterCount() == 1 || poDS->GetRasterCount() == GetRasterCount()))\n                        {\n                            CPLDebug( \"GTiff\", \"Opened band mask for %dx%d overview.\\n\",\n                                      poDS->GetRasterXSize(), poDS->GetRasterYSize());\n                            ((GTiffDataset*)papoOverviewDS[i])->poMaskDS = poDS;\n                            poDS->poBaseDS = this;\n                            break;\n                        }\n                    }\n                    if (i == nOverviewCount)\n                    {\n                        delete poDS;\n                    }\n                }\n            }\n            else if( nSubType == 0 ) {\n                CPLString osName, osDesc;\n                uint32\tnXSize, nYSize;\n                uint16  nSPP;\n\n                TIFFGetField( hTIFF, TIFFTAG_IMAGEWIDTH, &nXSize );\n                TIFFGetField( hTIFF, TIFFTAG_IMAGELENGTH, &nYSize );\n                if( !TIFFGetField(hTIFF, TIFFTAG_SAMPLESPERPIXEL, &nSPP ) )\n                    nSPP = 1;\n\n                osName.Printf( \"SUBDATASET_%d_NAME=GTIFF_DIR:%d:%s\", \n                               iDirIndex, iDirIndex, osFilename.c_str() );\n                osDesc.Printf( \"SUBDATASET_%d_DESC=Page %d (%dP x %dL x %dB)\", \n                               iDirIndex, iDirIndex, \n                               (int)nXSize, (int)nYSize, nSPP );\n\n                papszSubdatasets = \n                    CSLAddString( papszSubdatasets, osName );\n                papszSubdatasets = \n                    CSLAddString( papszSubdatasets, osDesc );\n            }\n\n            // Make sure we are stepping from the expected directory regardless\n            // of churn done processing the above.\n            if( TIFFCurrentDirOffset(hTIFF) != nThisDir )\n                TIFFSetSubDirectory( hTIFF, nThisDir );\n            *ppoActiveDSRef = NULL;\n        }\n\n        /* If we have a mask for the main image, loop over the overviews, and if they */\n        /* have a mask, let's set this mask as an overview of the main mask... */\n        if (poMaskDS != NULL)\n        {\n            int i;\n            for(i=0;i<nOverviewCount;i++)\n            {\n                if (((GTiffDataset*)papoOverviewDS[i])->poMaskDS != NULL)\n                {\n                    poMaskDS->nOverviewCount++;\n                    poMaskDS->papoOverviewDS = (GTiffDataset **)\n                        CPLRealloc(poMaskDS->papoOverviewDS, \n                                poMaskDS->nOverviewCount * (sizeof(void*)));\n                    poMaskDS->papoOverviewDS[poMaskDS->nOverviewCount-1] =\n                            ((GTiffDataset*)papoOverviewDS[i])->poMaskDS;\n                }\n            }\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Only keep track of subdatasets if we have more than one         */\n/*      subdataset (pair).                                              */\n/* -------------------------------------------------------------------- */\n        if( CSLCount(papszSubdatasets) > 2 )\n        {\n            oGTiffMDMD.SetMetadata( papszSubdatasets, \"SUBDATASETS\" );\n        }\n        CSLDestroy( papszSubdatasets );\n    }\n\n    return( CE_None );\n}\n```\n",
        "response": "### Core API Usage Patterns for `TIFFReadDirectory`\n\n#### **API Functionality**\n- **Purpose**: Reads the next TIFF Image File Directory (IFD) in a TIFF file. Used to iterate through multiple directories (e.g., overviews, masks, subdatasets).\n- **Role in Code**: Scans subsequent directories to identify embedded overviews, mask bands, and subdatasets after processing the primary image.\n\n#### **Typical Usage**\n- **Looping Through Directories**:\n  ```c\n  while (!TIFFLastDirectory(hTIFF) && (iDirIndex == 0 || TIFFReadDirectory(hTIFF) != 0)) {\n      // Process directory (e.g., check for overviews/masks)\n      iDirIndex++;\n  }\n  ```\n  - Used in a loop to traverse all directories in the TIFF file.\n  - Checks for end-of-file with `TIFFLastDirectory` and reads the next directory with `TIFFReadDirectory`.\n\n#### **Key Parameters**\n- **Input**: `TIFF* hTIFF`  \n  A handle to the opened TIFF file. The code passes the main TIFF handle (`hTIFFIn`) to read subsequent directories.\n\n#### **Return Values**\n- **Success**: Returns `1` (non-zero) when a directory is successfully read.\n- **Failure**: Returns `0` if no more directories exist or an error occurs.  \n  In the code, failure terminates the loop (no explicit error logging).\n\n#### **Error Handling**\n- **Implicit Termination**: The loop exits if `TIFFReadDirectory` returns `0`, treating it as \"no more directories\" without distinguishing between errors and end-of-file.\n- **Limitation**: Potential errors (e.g., corrupt directories) are not explicitly reported, leading to silent failures.\n\n#### **Best Practices**\n1. **Explicit Error Checking**:  \n   After failure, use `TIFFGetLastError()` to log errors instead of assuming end-of-file.\n   ```c\n   if (TIFFReadDirectory(hTIFF) == 0 && !TIFFLastDirectory(hTIFF)) {\n       CPLError(CE_Failure, CPLE_AppDefined, \"TIFFReadDirectory error: %s\", TIFFGetLastError());\n   }\n   ```\n2. **Directory Offset Management**:  \n   Use `TIFFSetSubDirectory(hTIFF, nThisDir)` to reset to known offsets if intermediate processing alters the directory position.\n3. **Handling Subdirectories**:  \n   Validate subdirectories (e.g., check dimensions, compatibility) before treating them as overviews/masks.\n4. **Resource Cleanup**:  \n   Ensure `TIFFClose` is called on all opened TIFF handles to avoid leaks.\n\n---\n\n### Summary\n`TIFFReadDirectory` is critical for iterating through TIFF directories to identify ancillary data (overviews, masks). While the code uses it to scan subdirectories, error handling is minimal. Best practices involve explicit error logging, validating subdirectory content, and robust offset management."
    }
]