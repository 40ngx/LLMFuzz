{
    "TIFFCIELabToXYZ": {
        "source_code": "void TIFFCIELabToXYZ(TIFFCIELabToRGB *cielab, uint32_t l, int32_t a, int32_t b,\n                     float *X, float *Y, float *Z)\n{\n    TIFFCIELab16ToXYZ(cielab, l * 257, a * 256, b * 256, X, Y, Z);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_color.c",
        "metrics": {
            "nloc": 5,
            "cyclomatic_complexity": 1,
            "token_count": 52,
            "parameter_count": 7
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 50,
            "store_count": 25
        }
    },
    "TIFFXYZToRGB": {
        "source_code": "void TIFFXYZToRGB(TIFFCIELabToRGB *cielab, float X, float Y, float Z,\n                  uint32_t *r, uint32_t *g, uint32_t *b)\n{\n    size_t i;\n    float Yr, Yg, Yb;\n    float *matrix = &cielab->display.d_mat[0][0];\n\n    /* Multiply through the matrix to get luminosity values. */\n    Yr = matrix[0] * X + matrix[1] * Y + matrix[2] * Z;\n    Yg = matrix[3] * X + matrix[4] * Y + matrix[5] * Z;\n    Yb = matrix[6] * X + matrix[7] * Y + matrix[8] * Z;\n\n    /* Clip input */\n    Yr = TIFFmax(Yr, cielab->display.d_Y0R);\n    Yg = TIFFmax(Yg, cielab->display.d_Y0G);\n    Yb = TIFFmax(Yb, cielab->display.d_Y0B);\n\n    /* Avoid overflow in case of wrong input values */\n    Yr = TIFFmin(Yr, cielab->display.d_YCR);\n    Yg = TIFFmin(Yg, cielab->display.d_YCG);\n    Yb = TIFFmin(Yb, cielab->display.d_YCB);\n\n    /* Turn luminosity to colour value. */\n    i = (size_t)((Yr - cielab->display.d_Y0R) / cielab->rstep);\n    i = TIFFmin((size_t)cielab->range, i);\n    *r = RINT(cielab->Yr2r[i]);\n\n    i = (size_t)((Yg - cielab->display.d_Y0G) / cielab->gstep);\n    i = TIFFmin((size_t)cielab->range, i);\n    *g = RINT(cielab->Yg2g[i]);\n\n    i = (size_t)((Yb - cielab->display.d_Y0B) / cielab->bstep);\n    i = TIFFmin((size_t)cielab->range, i);\n    *b = RINT(cielab->Yb2b[i]);\n\n    /* Clip output. */\n    *r = TIFFmin(*r, cielab->display.d_Vrwr);\n    *g = TIFFmin(*g, cielab->display.d_Vrwg);\n    *b = TIFFmin(*b, cielab->display.d_Vrwb);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_color.c",
        "metrics": {
            "nloc": 28,
            "cyclomatic_complexity": 1,
            "token_count": 392,
            "parameter_count": 7
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 154,
            "store_count": 29
        }
    },
    "TIFFCIELabToRGBInit": {
        "source_code": "int TIFFCIELabToRGBInit(TIFFCIELabToRGB *cielab, const TIFFDisplay *display,\n                        float *refWhite)\n{\n    size_t i;\n    double dfGamma;\n\n    cielab->range = CIELABTORGB_TABLE_RANGE;\n\n    _TIFFmemcpy(&cielab->display, display, sizeof(TIFFDisplay));\n\n    /* Red */\n    dfGamma = 1.0 / cielab->display.d_gammaR;\n    cielab->rstep =\n        (cielab->display.d_YCR - cielab->display.d_Y0R) / cielab->range;\n    for (i = 0; i <= (size_t)cielab->range; i++)\n    {\n        cielab->Yr2r[i] = cielab->display.d_Vrwr *\n                          ((float)pow((double)i / cielab->range, dfGamma));\n    }\n\n    /* Green */\n    dfGamma = 1.0 / cielab->display.d_gammaG;\n    cielab->gstep =\n        (cielab->display.d_YCR - cielab->display.d_Y0R) / cielab->range;\n    for (i = 0; i <= (size_t)cielab->range; i++)\n    {\n        cielab->Yg2g[i] = cielab->display.d_Vrwg *\n                          ((float)pow((double)i / cielab->range, dfGamma));\n    }\n\n    /* Blue */\n    dfGamma = 1.0 / cielab->display.d_gammaB;\n    cielab->bstep =\n        (cielab->display.d_YCR - cielab->display.d_Y0R) / cielab->range;\n    for (i = 0; i <= (size_t)cielab->range; i++)\n    {\n        cielab->Yb2b[i] = cielab->display.d_Vrwb *\n                          ((float)pow((double)i / cielab->range, dfGamma));\n    }\n\n    /* Init reference white point */\n    cielab->X0 = refWhite[0];\n    cielab->Y0 = refWhite[1];\n    cielab->Z0 = refWhite[2];\n\n    return 0;\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_color.c",
        "metrics": {
            "nloc": 36,
            "cyclomatic_complexity": 4,
            "token_count": 326,
            "parameter_count": 3
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 78,
            "store_count": 25
        }
    },
    "TIFFYCbCrtoRGB": {
        "source_code": "void TIFFYCbCrtoRGB(TIFFYCbCrToRGB *ycbcr, uint32_t Y, int32_t Cb, int32_t Cr,\n                    uint32_t *r, uint32_t *g, uint32_t *b)\n{\n    int32_t i;\n\n    /* XXX: Only 8-bit YCbCr input supported for now */\n    Y = HICLAMP(Y, 255);\n    Cb = CLAMP(Cb, 0, 255);\n    Cr = CLAMP(Cr, 0, 255);\n\n    i = ycbcr->Y_tab[Y] + ycbcr->Cr_r_tab[Cr];\n    *r = CLAMP(i, 0, 255);\n    i = ycbcr->Y_tab[Y] +\n        (int)((ycbcr->Cb_g_tab[Cb] + ycbcr->Cr_g_tab[Cr]) >> SHIFT);\n    *g = CLAMP(i, 0, 255);\n    i = ycbcr->Y_tab[Y] + ycbcr->Cb_b_tab[Cb];\n    *b = CLAMP(i, 0, 255);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_color.c",
        "metrics": {
            "nloc": 15,
            "cyclomatic_complexity": 1,
            "token_count": 164,
            "parameter_count": 7
        },
        "cve_info": [
            {
                "CVE_ID": "CVE-2010-2595",
                "Description": "The TIFFYCbCrtoRGB function in LibTIFF 3.9.0 and 3.9.2, as used in ImageMagick, does not properly handle invalid ReferenceBlackWhite values, which allows remote attackers to cause a denial of service (application crash) via a crafted TIFF image that triggers an array index error, related to \"downsampled OJPEG input.\""
            }
        ],
        "cve_count": 1,
        "instruction": {
            "load_count": 48,
            "store_count": 16
        }
    },
    "TIFFYCbCrToRGBInit": {
        "source_code": "int TIFFYCbCrToRGBInit(TIFFYCbCrToRGB *ycbcr, float *luma, float *refBlackWhite)\n{\n    TIFFRGBValue *clamptab;\n    int i;\n\n#define LumaRed luma[0]\n#define LumaGreen luma[1]\n#define LumaBlue luma[2]\n\n    clamptab =\n        (TIFFRGBValue *)((uint8_t *)ycbcr +\n                         TIFFroundup_32(sizeof(TIFFYCbCrToRGB), sizeof(long)));\n    _TIFFmemset(clamptab, 0, 256); /* v < 0 => 0 */\n    ycbcr->clamptab = (clamptab += 256);\n    for (i = 0; i < 256; i++)\n        clamptab[i] = (TIFFRGBValue)i;\n    _TIFFmemset(clamptab + 256, 255, 2 * 256); /* v > 255 => 255 */\n    ycbcr->Cr_r_tab = (int *)(clamptab + 3 * 256);\n    ycbcr->Cb_b_tab = ycbcr->Cr_r_tab + 256;\n    ycbcr->Cr_g_tab = (int32_t *)(ycbcr->Cb_b_tab + 256);\n    ycbcr->Cb_g_tab = ycbcr->Cr_g_tab + 256;\n    ycbcr->Y_tab = ycbcr->Cb_g_tab + 256;\n\n    {\n        float f1 = 2 - 2 * LumaRed;\n        int32_t D1 = FIX(CLAMP(f1, 0.0F, 2.0F));\n        float f2 = LumaRed * f1 / LumaGreen;\n        int32_t D2 = -FIX(CLAMP(f2, 0.0F, 2.0F));\n        float f3 = 2 - 2 * LumaBlue;\n        int32_t D3 = FIX(CLAMP(f3, 0.0F, 2.0F));\n        float f4 = LumaBlue * f3 / LumaGreen;\n        int32_t D4 = -FIX(CLAMP(f4, 0.0F, 2.0F));\n        int x;\n\n#undef LumaBlue\n#undef LumaGreen\n#undef LumaRed\n\n        /*\n         * i is the actual input pixel value in the range 0..255\n         * Cb and Cr values are in the range -128..127 (actually\n         * they are in a range defined by the ReferenceBlackWhite\n         * tag) so there is some range shifting to do here when\n         * constructing tables indexed by the raw pixel data.\n         */\n        for (i = 0, x = -128; i < 256; i++, x++)\n        {\n            int32_t Cr = (int32_t)CLAMPw(Code2V(x, refBlackWhite[4] - 128.0F,\n                                                refBlackWhite[5] - 128.0F, 127),\n                                         -128.0F * 32, 128.0F * 32);\n            int32_t Cb = (int32_t)CLAMPw(Code2V(x, refBlackWhite[2] - 128.0F,\n                                                refBlackWhite[3] - 128.0F, 127),\n                                         -128.0F * 32, 128.0F * 32);\n\n            ycbcr->Cr_r_tab[i] = (int32_t)((D1 * Cr + ONE_HALF) >> SHIFT);\n            ycbcr->Cb_b_tab[i] = (int32_t)((D3 * Cb + ONE_HALF) >> SHIFT);\n            ycbcr->Cr_g_tab[i] = D2 * Cr;\n            ycbcr->Cb_g_tab[i] = D4 * Cb + ONE_HALF;\n            ycbcr->Y_tab[i] = (int32_t)CLAMPw(\n                Code2V(x + 128, refBlackWhite[0], refBlackWhite[1], 255),\n                -128.0F * 32, 128.0F * 32);\n        }\n    }\n\n    return 0;\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_color.c",
        "metrics": {
            "nloc": 46,
            "cyclomatic_complexity": 3,
            "token_count": 503,
            "parameter_count": 3
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 139,
            "store_count": 57
        }
    },
    "TIFFComputeStrip": {
        "source_code": "uint32_t TIFFComputeStrip(TIFF *tif, uint32_t row, uint16_t sample)\n{\n    static const char module[] = \"TIFFComputeStrip\";\n    TIFFDirectory *td = &tif->tif_dir;\n    uint32_t strip;\n\n    if (td->td_rowsperstrip == 0)\n    {\n        TIFFErrorExtR(tif, module, \"Cannot compute strip: RowsPerStrip is zero\");\n        return 0;\n    }\n    strip = row / td->td_rowsperstrip;\n    if (td->td_planarconfig == PLANARCONFIG_SEPARATE)\n    {\n        if (sample >= td->td_samplesperpixel)\n        {\n            TIFFErrorExtR(tif, module, \"%lu: Sample out of range, max %lu\",\n                          (unsigned long)sample,\n                          (unsigned long)td->td_samplesperpixel);\n            return (0);\n        }\n        strip += (uint32_t)sample * td->td_stripsperimage;\n    }\n    return (strip);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_strip.c",
        "metrics": {
            "nloc": 24,
            "cyclomatic_complexity": 4,
            "token_count": 129,
            "parameter_count": 3
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 22,
            "store_count": 9
        }
    },
    "TIFFNumberOfStrips": {
        "source_code": "uint32_t TIFFNumberOfStrips(TIFF *tif)\n{\n    TIFFDirectory *td = &tif->tif_dir;\n    uint32_t nstrips;\n\n    if (td->td_rowsperstrip == 0)\n    {\n        TIFFWarningExtR(tif, \"TIFFNumberOfStrips\", \"RowsPerStrip is zero\");\n        return 0;\n    }\n    nstrips = (td->td_rowsperstrip == (uint32_t)-1\n                   ? 1\n                   : TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip));\n    if (td->td_planarconfig == PLANARCONFIG_SEPARATE)\n        nstrips =\n            _TIFFMultiply32(tif, nstrips, (uint32_t)td->td_samplesperpixel,\n                            \"TIFFNumberOfStrips\");\n    return (nstrips);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_strip.c",
        "metrics": {
            "nloc": 18,
            "cyclomatic_complexity": 4,
            "token_count": 100,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 55,
            "store_count": 16
        }
    },
    "TIFFVStripSize64": {
        "source_code": "uint64_t TIFFVStripSize64(TIFF *tif, uint32_t nrows)\n{\n    static const char module[] = \"TIFFVStripSize64\";\n    TIFFDirectory *td = &tif->tif_dir;\n    if (nrows == (uint32_t)(-1))\n        nrows = td->td_imagelength;\n    if ((td->td_planarconfig == PLANARCONFIG_CONTIG) &&\n        (td->td_photometric == PHOTOMETRIC_YCBCR) && (!isUpSampled(tif)))\n    {\n        /*\n         * Packed YCbCr data contain one Cb+Cr for every\n         * HorizontalSampling*VerticalSampling Y values.\n         * Must also roundup width and height when calculating\n         * since images that are not a multiple of the\n         * horizontal/vertical subsampling area include\n         * YCbCr data for the extended image.\n         */\n        uint16_t ycbcrsubsampling[2];\n        uint16_t samplingblock_samples;\n        uint32_t samplingblocks_hor;\n        uint32_t samplingblocks_ver;\n        uint64_t samplingrow_samples;\n        uint64_t samplingrow_size;\n        if (td->td_samplesperpixel != 3)\n        {\n            TIFFErrorExtR(tif, module, \"Invalid td_samplesperpixel value\");\n            return 0;\n        }\n        TIFFGetFieldDefaulted(tif, TIFFTAG_YCBCRSUBSAMPLING,\n                              ycbcrsubsampling + 0, ycbcrsubsampling + 1);\n        if ((ycbcrsubsampling[0] != 1 && ycbcrsubsampling[0] != 2 &&\n             ycbcrsubsampling[0] != 4) ||\n            (ycbcrsubsampling[1] != 1 && ycbcrsubsampling[1] != 2 &&\n             ycbcrsubsampling[1] != 4) ||\n            (ycbcrsubsampling[0] == 0 || ycbcrsubsampling[1] == 0))\n        {\n            TIFFErrorExtR(tif, module, \"Invalid YCbCr subsampling (%dx%d)\",\n                          ycbcrsubsampling[0], ycbcrsubsampling[1]);\n            return 0;\n        }\n        samplingblock_samples = ycbcrsubsampling[0] * ycbcrsubsampling[1] + 2;\n        samplingblocks_hor =\n            TIFFhowmany_32(td->td_imagewidth, ycbcrsubsampling[0]);\n        samplingblocks_ver = TIFFhowmany_32(nrows, ycbcrsubsampling[1]);\n        samplingrow_samples = _TIFFMultiply64(tif, samplingblocks_hor,\n                                              samplingblock_samples, module);\n        samplingrow_size = TIFFhowmany8_64(_TIFFMultiply64(\n            tif, samplingrow_samples, td->td_bitspersample, module));\n        return (\n            _TIFFMultiply64(tif, samplingrow_size, samplingblocks_ver, module));\n    }\n    else\n        return (_TIFFMultiply64(tif, nrows, TIFFScanlineSize64(tif), module));\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_strip.c",
        "metrics": {
            "nloc": 46,
            "cyclomatic_complexity": 14,
            "token_count": 324,
            "parameter_count": 2
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 177,
            "store_count": 67
        }
    },
    "TIFFVStripSize": {
        "source_code": "tmsize_t TIFFVStripSize(TIFF *tif, uint32_t nrows)\n{\n    static const char module[] = \"TIFFVStripSize\";\n    uint64_t m;\n    m = TIFFVStripSize64(tif, nrows);\n    return _TIFFCastUInt64ToSSize(tif, m, module);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_strip.c",
        "metrics": {
            "nloc": 7,
            "cyclomatic_complexity": 1,
            "token_count": 42,
            "parameter_count": 2
        },
        "cve_info": [
            {
                "CVE_ID": "CVE-2010-2597",
                "Description": "The TIFFVStripSize function in tif_strip.c in LibTIFF 3.9.0 and 3.9.2 makes incorrect calls to the TIFFGetField function, which allows remote attackers to cause a denial of service (application crash) via a crafted TIFF image, related to \"downsampled OJPEG input\" and possibly related to a compiler optimization that triggers a divide-by-zero error."
            }
        ],
        "cve_count": 1,
        "instruction": {
            "load_count": 188,
            "store_count": 75
        }
    },
    "TIFFRawStripSize64": {
        "source_code": "uint64_t TIFFRawStripSize64(TIFF *tif, uint32_t strip)\n{\n    static const char module[] = \"TIFFRawStripSize64\";\n    uint64_t bytecount = TIFFGetStrileByteCount(tif, strip);\n\n    if (bytecount == 0)\n    {\n        TIFFErrorExtR(tif, module,\n                      \"%\" PRIu64 \": Invalid strip byte count, strip %lu\",\n                      (uint64_t)bytecount, (unsigned long)strip);\n        bytecount = (uint64_t)-1;\n    }\n\n    return bytecount;\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_strip.c",
        "metrics": {
            "nloc": 13,
            "cyclomatic_complexity": 2,
            "token_count": 71,
            "parameter_count": 2
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 7,
            "store_count": 4
        }
    },
    "TIFFRawStripSize": {
        "source_code": "tmsize_t TIFFRawStripSize(TIFF *tif, uint32_t strip)\n{\n    static const char module[] = \"TIFFRawStripSize\";\n    uint64_t m;\n    tmsize_t n;\n    m = TIFFRawStripSize64(tif, strip);\n    if (m == (uint64_t)(-1))\n        n = (tmsize_t)(-1);\n    else\n    {\n        n = (tmsize_t)m;\n        if ((uint64_t)n != m)\n        {\n            TIFFErrorExtR(tif, module, \"Integer overflow\");\n            n = 0;\n        }\n    }\n    return (n);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_strip.c",
        "metrics": {
            "nloc": 19,
            "cyclomatic_complexity": 3,
            "token_count": 96,
            "parameter_count": 2
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 15,
            "store_count": 10
        }
    },
    "TIFFStripSize64": {
        "source_code": "uint64_t TIFFStripSize64(TIFF *tif)\n{\n    TIFFDirectory *td = &tif->tif_dir;\n    uint32_t rps = td->td_rowsperstrip;\n    if (rps > td->td_imagelength)\n        rps = td->td_imagelength;\n    return (TIFFVStripSize64(tif, rps));\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_strip.c",
        "metrics": {
            "nloc": 8,
            "cyclomatic_complexity": 2,
            "token_count": 48,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 187,
            "store_count": 71
        }
    },
    "TIFFStripSize": {
        "source_code": "tmsize_t TIFFStripSize(TIFF *tif)\n{\n    static const char module[] = \"TIFFStripSize\";\n    uint64_t m;\n    m = TIFFStripSize64(tif);\n    return _TIFFCastUInt64ToSSize(tif, m, module);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_strip.c",
        "metrics": {
            "nloc": 7,
            "cyclomatic_complexity": 1,
            "token_count": 37,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 197,
            "store_count": 78
        }
    },
    "TIFFDefaultStripSize": {
        "source_code": "uint32_t TIFFDefaultStripSize(TIFF *tif, uint32_t request)\n{\n    return (*tif->tif_defstripsize)(tif, request);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_strip.c",
        "metrics": {
            "nloc": 4,
            "cyclomatic_complexity": 1,
            "token_count": 24,
            "parameter_count": 2
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 4,
            "store_count": 2
        }
    },
    "TIFFScanlineSize64": {
        "source_code": "uint64_t TIFFScanlineSize64(TIFF *tif)\n{\n    static const char module[] = \"TIFFScanlineSize64\";\n    TIFFDirectory *td = &tif->tif_dir;\n    uint64_t scanline_size;\n    if (td->td_planarconfig == PLANARCONFIG_CONTIG)\n    {\n        if ((td->td_photometric == PHOTOMETRIC_YCBCR) &&\n            (td->td_samplesperpixel == 3) && (!isUpSampled(tif)))\n        {\n            uint16_t ycbcrsubsampling[2];\n            uint16_t samplingblock_samples;\n            uint32_t samplingblocks_hor;\n            uint64_t samplingrow_samples;\n            uint64_t samplingrow_size;\n            if (td->td_samplesperpixel != 3)\n            {\n                TIFFErrorExtR(tif, module, \"Invalid td_samplesperpixel value\");\n                return 0;\n            }\n            TIFFGetFieldDefaulted(tif, TIFFTAG_YCBCRSUBSAMPLING,\n                                  ycbcrsubsampling + 0, ycbcrsubsampling + 1);\n            if (((ycbcrsubsampling[0] != 1) && (ycbcrsubsampling[0] != 2) &&\n                 (ycbcrsubsampling[0] != 4)) ||\n                ((ycbcrsubsampling[1] != 1) && (ycbcrsubsampling[1] != 2) &&\n                 (ycbcrsubsampling[1] != 4)) ||\n                ((ycbcrsubsampling[0] == 0) || (ycbcrsubsampling[1] == 0)))\n            {\n                TIFFErrorExtR(tif, module, \"Invalid YCbCr subsampling\");\n                return 0;\n            }\n            samplingblock_samples =\n                ycbcrsubsampling[0] * ycbcrsubsampling[1] + 2;\n            samplingblocks_hor =\n                TIFFhowmany_32(td->td_imagewidth, ycbcrsubsampling[0]);\n            samplingrow_samples = _TIFFMultiply64(\n                tif, samplingblocks_hor, samplingblock_samples, module);\n            samplingrow_size =\n                TIFFhowmany_64(_TIFFMultiply64(tif, samplingrow_samples,\n                                               td->td_bitspersample, module),\n                               8);\n            scanline_size = (samplingrow_size / ycbcrsubsampling[1]);\n        }\n        else\n        {\n            uint64_t scanline_samples;\n            uint32_t scanline_width = td->td_imagewidth;\n\n#if 0\n            // Tries to fix https://gitlab.com/libtiff/libtiff/-/merge_requests/564\n            // but causes regression when decoding legit files with tiffcp -c none\n            // Cf https://gitlab.com/libtiff/libtiff/-/merge_requests/644\n            if (td->td_photometric == PHOTOMETRIC_YCBCR)\n            {\n                uint16_t subsampling_hor;\n                uint16_t ignored;\n                TIFFGetFieldDefaulted(tif, TIFFTAG_YCBCRSUBSAMPLING,\n                                      &subsampling_hor, &ignored);\n                if (subsampling_hor > 1) // roundup width for YCbCr\n                    scanline_width =\n                        TIFFroundup_32(scanline_width, subsampling_hor);\n            }\n#endif\n\n            scanline_samples = _TIFFMultiply64(tif, scanline_width,\n                                               td->td_samplesperpixel, module);\n            scanline_size =\n                TIFFhowmany_64(_TIFFMultiply64(tif, scanline_samples,\n                                               td->td_bitspersample, module),\n                               8);\n        }\n    }\n    else\n    {\n        scanline_size =\n            TIFFhowmany_64(_TIFFMultiply64(tif, td->td_imagewidth,\n                                           td->td_bitspersample, module),\n                           8);\n    }\n    if (scanline_size == 0)\n    {\n        TIFFErrorExtR(tif, module, \"Computed scanline size is zero\");\n        return 0;\n    }\n    return (scanline_size);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_strip.c",
        "metrics": {
            "nloc": 79,
            "cyclomatic_complexity": 18,
            "token_count": 430,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 107,
            "store_count": 48
        }
    },
    "TIFFScanlineSize": {
        "source_code": "tmsize_t TIFFScanlineSize(TIFF *tif)\n{\n    static const char module[] = \"TIFFScanlineSize\";\n    uint64_t m;\n    m = TIFFScanlineSize64(tif);\n    return _TIFFCastUInt64ToSSize(tif, m, module);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_strip.c",
        "metrics": {
            "nloc": 7,
            "cyclomatic_complexity": 1,
            "token_count": 37,
            "parameter_count": 1
        },
        "cve_info": [
            {
                "CVE_ID": "CVE-2012-4564",
                "Description": "ppm2tiff does not check the return value of the TIFFScanlineSize function, which allows remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via a crafted PPM image that triggers an integer overflow, a zero-memory allocation, and a heap-based buffer overflow."
            }
        ],
        "cve_count": 1,
        "instruction": {
            "load_count": 117,
            "store_count": 55
        }
    },
    "TIFFRasterScanlineSize64": {
        "source_code": "uint64_t TIFFRasterScanlineSize64(TIFF *tif)\n{\n    static const char module[] = \"TIFFRasterScanlineSize64\";\n    TIFFDirectory *td = &tif->tif_dir;\n    uint64_t scanline;\n\n    scanline =\n        _TIFFMultiply64(tif, td->td_bitspersample, td->td_imagewidth, module);\n    if (td->td_planarconfig == PLANARCONFIG_CONTIG)\n    {\n        scanline =\n            _TIFFMultiply64(tif, scanline, td->td_samplesperpixel, module);\n        return (TIFFhowmany8_64(scanline));\n    }\n    else\n        return (_TIFFMultiply64(tif, TIFFhowmany8_64(scanline),\n                                td->td_samplesperpixel, module));\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_strip.c",
        "metrics": {
            "nloc": 17,
            "cyclomatic_complexity": 2,
            "token_count": 99,
            "parameter_count": 1
        },
        "cve_info": [
            {
                "CVE_ID": "CVE-2023-52355",
                "Description": "An out-of-memory flaw was found in libtiff that could be triggered by passing a crafted tiff file to the TIFFRasterScanlineSize64() API. This flaw allows a remote attacker to cause a denial of service via a crafted input with a size smaller than 379 KB."
            }
        ],
        "cve_count": 1,
        "instruction": {
            "load_count": 49,
            "store_count": 24
        }
    },
    "TIFFRasterScanlineSize": {
        "source_code": "tmsize_t TIFFRasterScanlineSize(TIFF *tif)\n{\n    static const char module[] = \"TIFFRasterScanlineSize\";\n    uint64_t m;\n    m = TIFFRasterScanlineSize64(tif);\n    return _TIFFCastUInt64ToSSize(tif, m, module);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_strip.c",
        "metrics": {
            "nloc": 7,
            "cyclomatic_complexity": 1,
            "token_count": 37,
            "parameter_count": 1
        },
        "cve_info": [
            {
                "CVE_ID": "CVE-2023-52355",
                "Description": "An out-of-memory flaw was found in libtiff that could be triggered by passing a crafted tiff file to the TIFFRasterScanlineSize64() API. This flaw allows a remote attacker to cause a denial of service via a crafted input with a size smaller than 379 KB."
            }
        ],
        "cve_count": 1,
        "instruction": {
            "load_count": 59,
            "store_count": 31
        }
    },
    "TIFFComputeTile": {
        "source_code": "uint32_t TIFFComputeTile(TIFF *tif, uint32_t x, uint32_t y, uint32_t z,\n                         uint16_t s)\n{\n    TIFFDirectory *td = &tif->tif_dir;\n    uint32_t dx = td->td_tilewidth;\n    uint32_t dy = td->td_tilelength;\n    uint32_t dz = td->td_tiledepth;\n    uint32_t tile = 1;\n\n    if (td->td_imagedepth == 1)\n        z = 0;\n    if (dx == (uint32_t)-1)\n        dx = td->td_imagewidth;\n    if (dy == (uint32_t)-1)\n        dy = td->td_imagelength;\n    if (dz == (uint32_t)-1)\n        dz = td->td_imagedepth;\n    if (dx != 0 && dy != 0 && dz != 0)\n    {\n        uint32_t xpt = TIFFhowmany_32(td->td_imagewidth, dx);\n        uint32_t ypt = TIFFhowmany_32(td->td_imagelength, dy);\n        uint32_t zpt = TIFFhowmany_32(td->td_imagedepth, dz);\n\n        if (td->td_planarconfig == PLANARCONFIG_SEPARATE)\n            tile = (xpt * ypt * zpt) * s + (xpt * ypt) * (z / dz) +\n                   xpt * (y / dy) + x / dx;\n        else\n            tile = (xpt * ypt) * (z / dz) + xpt * (y / dy) + x / dx;\n    }\n    return (tile);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_tile.c",
        "metrics": {
            "nloc": 29,
            "cyclomatic_complexity": 9,
            "token_count": 243,
            "parameter_count": 5
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 67,
            "store_count": 19
        }
    },
    "TIFFCheckTile": {
        "source_code": "int TIFFCheckTile(TIFF *tif, uint32_t x, uint32_t y, uint32_t z, uint16_t s)\n{\n    TIFFDirectory *td = &tif->tif_dir;\n\n    if (x >= td->td_imagewidth)\n    {\n        TIFFErrorExtR(tif, tif->tif_name, \"%lu: Col out of range, max %lu\",\n                      (unsigned long)x, (unsigned long)(td->td_imagewidth - 1));\n        return (0);\n    }\n    if (y >= td->td_imagelength)\n    {\n        TIFFErrorExtR(tif, tif->tif_name, \"%lu: Row out of range, max %lu\",\n                      (unsigned long)y,\n                      (unsigned long)(td->td_imagelength - 1));\n        return (0);\n    }\n    if (z >= td->td_imagedepth)\n    {\n        TIFFErrorExtR(tif, tif->tif_name, \"%lu: Depth out of range, max %lu\",\n                      (unsigned long)z, (unsigned long)(td->td_imagedepth - 1));\n        return (0);\n    }\n    if (td->td_planarconfig == PLANARCONFIG_SEPARATE &&\n        s >= td->td_samplesperpixel)\n    {\n        TIFFErrorExtR(tif, tif->tif_name, \"%lu: Sample out of range, max %lu\",\n                      (unsigned long)s,\n                      (unsigned long)(td->td_samplesperpixel - 1));\n        return (0);\n    }\n    return (1);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_tile.c",
        "metrics": {
            "nloc": 32,
            "cyclomatic_complexity": 6,
            "token_count": 216,
            "parameter_count": 5
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 40,
            "store_count": 11
        }
    },
    "TIFFNumberOfTiles": {
        "source_code": "uint32_t TIFFNumberOfTiles(TIFF *tif)\n{\n    TIFFDirectory *td = &tif->tif_dir;\n    uint32_t dx = td->td_tilewidth;\n    uint32_t dy = td->td_tilelength;\n    uint32_t dz = td->td_tiledepth;\n    uint32_t ntiles;\n\n    if (dx == (uint32_t)-1)\n        dx = td->td_imagewidth;\n    if (dy == (uint32_t)-1)\n        dy = td->td_imagelength;\n    if (dz == (uint32_t)-1)\n        dz = td->td_imagedepth;\n    ntiles =\n        (dx == 0 || dy == 0 || dz == 0)\n            ? 0\n            : _TIFFMultiply32(\n                  tif,\n                  _TIFFMultiply32(tif, TIFFhowmany_32(td->td_imagewidth, dx),\n                                  TIFFhowmany_32(td->td_imagelength, dy),\n                                  \"TIFFNumberOfTiles\"),\n                  TIFFhowmany_32(td->td_imagedepth, dz), \"TIFFNumberOfTiles\");\n    if (td->td_planarconfig == PLANARCONFIG_SEPARATE)\n        ntiles = _TIFFMultiply32(tif, ntiles, td->td_samplesperpixel,\n                                 \"TIFFNumberOfTiles\");\n    return (ntiles);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_tile.c",
        "metrics": {
            "nloc": 27,
            "cyclomatic_complexity": 8,
            "token_count": 176,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 76,
            "store_count": 28
        }
    },
    "TIFFTileRowSize64": {
        "source_code": "uint64_t TIFFTileRowSize64(TIFF *tif)\n{\n    static const char module[] = \"TIFFTileRowSize64\";\n    TIFFDirectory *td = &tif->tif_dir;\n    uint64_t rowsize;\n    uint64_t tilerowsize;\n\n    if (td->td_tilelength == 0)\n    {\n        TIFFErrorExtR(tif, module, \"Tile length is zero\");\n        return 0;\n    }\n    if (td->td_tilewidth == 0)\n    {\n        TIFFErrorExtR(tif, module, \"Tile width is zero\");\n        return (0);\n    }\n    rowsize = _TIFFMultiply64(tif, td->td_bitspersample, td->td_tilewidth,\n                              \"TIFFTileRowSize\");\n    if (td->td_planarconfig == PLANARCONFIG_CONTIG)\n    {\n        if (td->td_samplesperpixel == 0)\n        {\n            TIFFErrorExtR(tif, module, \"Samples per pixel is zero\");\n            return 0;\n        }\n        rowsize = _TIFFMultiply64(tif, rowsize, td->td_samplesperpixel,\n                                  \"TIFFTileRowSize\");\n    }\n    tilerowsize = TIFFhowmany8_64(rowsize);\n    if (tilerowsize == 0)\n    {\n        TIFFErrorExtR(tif, module, \"Computed tile row size is zero\");\n        return 0;\n    }\n    return (tilerowsize);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_tile.c",
        "metrics": {
            "nloc": 36,
            "cyclomatic_complexity": 6,
            "token_count": 174,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 46,
            "store_count": 22
        }
    },
    "TIFFTileRowSize": {
        "source_code": "tmsize_t TIFFTileRowSize(TIFF *tif)\n{\n    static const char module[] = \"TIFFTileRowSize\";\n    uint64_t m;\n    m = TIFFTileRowSize64(tif);\n    return _TIFFCastUInt64ToSSize(tif, m, module);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_tile.c",
        "metrics": {
            "nloc": 7,
            "cyclomatic_complexity": 1,
            "token_count": 37,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 56,
            "store_count": 29
        }
    },
    "TIFFVTileSize64": {
        "source_code": "uint64_t TIFFVTileSize64(TIFF *tif, uint32_t nrows)\n{\n    static const char module[] = \"TIFFVTileSize64\";\n    TIFFDirectory *td = &tif->tif_dir;\n    if (td->td_tilelength == 0 || td->td_tilewidth == 0 ||\n        td->td_tiledepth == 0)\n        return (0);\n    if ((td->td_planarconfig == PLANARCONFIG_CONTIG) &&\n        (td->td_photometric == PHOTOMETRIC_YCBCR) &&\n        (td->td_samplesperpixel == 3) && (!isUpSampled(tif)))\n    {\n        /*\n         * Packed YCbCr data contain one Cb+Cr for every\n         * HorizontalSampling*VerticalSampling Y values.\n         * Must also roundup width and height when calculating\n         * since images that are not a multiple of the\n         * horizontal/vertical subsampling area include\n         * YCbCr data for the extended image.\n         */\n        uint16_t ycbcrsubsampling[2];\n        uint16_t samplingblock_samples;\n        uint32_t samplingblocks_hor;\n        uint32_t samplingblocks_ver;\n        uint64_t samplingrow_samples;\n        uint64_t samplingrow_size;\n        TIFFGetFieldDefaulted(tif, TIFFTAG_YCBCRSUBSAMPLING,\n                              ycbcrsubsampling + 0, ycbcrsubsampling + 1);\n        if ((ycbcrsubsampling[0] != 1 && ycbcrsubsampling[0] != 2 &&\n             ycbcrsubsampling[0] != 4) ||\n            (ycbcrsubsampling[1] != 1 && ycbcrsubsampling[1] != 2 &&\n             ycbcrsubsampling[1] != 4))\n        {\n            TIFFErrorExtR(tif, module, \"Invalid YCbCr subsampling (%dx%d)\",\n                          ycbcrsubsampling[0], ycbcrsubsampling[1]);\n            return 0;\n        }\n        samplingblock_samples = ycbcrsubsampling[0] * ycbcrsubsampling[1] + 2;\n        samplingblocks_hor =\n            TIFFhowmany_32(td->td_tilewidth, ycbcrsubsampling[0]);\n        samplingblocks_ver = TIFFhowmany_32(nrows, ycbcrsubsampling[1]);\n        samplingrow_samples = _TIFFMultiply64(tif, samplingblocks_hor,\n                                              samplingblock_samples, module);\n        samplingrow_size = TIFFhowmany8_64(_TIFFMultiply64(\n            tif, samplingrow_samples, td->td_bitspersample, module));\n        return (\n            _TIFFMultiply64(tif, samplingrow_size, samplingblocks_ver, module));\n    }\n    else\n        return (_TIFFMultiply64(tif, nrows, TIFFTileRowSize64(tif), module));\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_tile.c",
        "metrics": {
            "nloc": 42,
            "cyclomatic_complexity": 14,
            "token_count": 301,
            "parameter_count": 2
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 164,
            "store_count": 73
        }
    },
    "TIFFVTileSize": {
        "source_code": "tmsize_t TIFFVTileSize(TIFF *tif, uint32_t nrows)\n{\n    static const char module[] = \"TIFFVTileSize\";\n    uint64_t m;\n    m = TIFFVTileSize64(tif, nrows);\n    return _TIFFCastUInt64ToSSize(tif, m, module);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_tile.c",
        "metrics": {
            "nloc": 7,
            "cyclomatic_complexity": 1,
            "token_count": 42,
            "parameter_count": 2
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 175,
            "store_count": 81
        }
    },
    "TIFFTileSize64": {
        "source_code": "uint64_t TIFFTileSize64(TIFF *tif)\n{\n    return (TIFFVTileSize64(tif, tif->tif_dir.td_tilelength));\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_tile.c",
        "metrics": {
            "nloc": 4,
            "cyclomatic_complexity": 1,
            "token_count": 22,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 167,
            "store_count": 74
        }
    },
    "TIFFTileSize": {
        "source_code": "tmsize_t TIFFTileSize(TIFF *tif)\n{\n    static const char module[] = \"TIFFTileSize\";\n    uint64_t m;\n    m = TIFFTileSize64(tif);\n    return _TIFFCastUInt64ToSSize(tif, m, module);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_tile.c",
        "metrics": {
            "nloc": 7,
            "cyclomatic_complexity": 1,
            "token_count": 37,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 177,
            "store_count": 81
        }
    },
    "TIFFDefaultTileSize": {
        "source_code": "void TIFFDefaultTileSize(TIFF *tif, uint32_t *tw, uint32_t *th)\n{\n    (*tif->tif_deftilesize)(tif, tw, th);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_tile.c",
        "metrics": {
            "nloc": 4,
            "cyclomatic_complexity": 1,
            "token_count": 30,
            "parameter_count": 3
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 5,
            "store_count": 3
        }
    },
    "TIFFCleanup": {
        "source_code": "void TIFFCleanup(TIFF *tif)\n{\n    /*\n     * Flush buffered data and directory (if dirty).\n     */\n    if (tif->tif_mode != O_RDONLY)\n        TIFFFlush(tif);\n    (*tif->tif_cleanup)(tif);\n    TIFFFreeDirectory(tif);\n\n    _TIFFCleanupIFDOffsetAndNumberMaps(tif);\n\n    /*\n     * Clean up client info links.\n     */\n    while (tif->tif_clientinfo)\n    {\n        TIFFClientInfoLink *psLink = tif->tif_clientinfo;\n\n        tif->tif_clientinfo = psLink->next;\n        _TIFFfreeExt(tif, psLink->name);\n        _TIFFfreeExt(tif, psLink);\n    }\n\n    if (tif->tif_rawdata && (tif->tif_flags & TIFF_MYBUFFER))\n        _TIFFfreeExt(tif, tif->tif_rawdata);\n    if (isMapped(tif))\n        TIFFUnmapFileContents(tif, tif->tif_base, (toff_t)tif->tif_size);\n\n    /*\n     * Clean up custom fields.\n     */\n    if (tif->tif_fields && tif->tif_nfields > 0)\n    {\n        uint32_t i;\n\n        for (i = 0; i < tif->tif_nfields; i++)\n        {\n            TIFFField *fld = tif->tif_fields[i];\n            if (fld->field_name != NULL)\n            {\n                if (fld->field_bit == FIELD_CUSTOM &&\n                    /* caution: tif_fields[i] must not be the beginning of a\n                     * fields-array. Otherwise the following tags are also freed\n                     * with the first free().\n                     */\n                    TIFFFieldIsAnonymous(fld))\n                {\n                    _TIFFfreeExt(tif, fld->field_name);\n                    _TIFFfreeExt(tif, fld);\n                }\n            }\n        }\n\n        _TIFFfreeExt(tif, tif->tif_fields);\n    }\n\n    if (tif->tif_nfieldscompat > 0)\n    {\n        uint32_t i;\n\n        for (i = 0; i < tif->tif_nfieldscompat; i++)\n        {\n            if (tif->tif_fieldscompat[i].allocated_size)\n                _TIFFfreeExt(tif, tif->tif_fieldscompat[i].fields);\n        }\n        _TIFFfreeExt(tif, tif->tif_fieldscompat);\n    }\n\n    if (tif->tif_cur_cumulated_mem_alloc != 0)\n    {\n        TIFFErrorExtR(tif, \"TIFFCleanup\",\n                      \"tif_cur_cumulated_mem_alloc = %\" PRIu64 \" whereas it \"\n                      \"should be 0\",\n                      (uint64_t)tif->tif_cur_cumulated_mem_alloc);\n    }\n\n    _TIFFfreeExt(NULL, tif);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_close.c",
        "metrics": {
            "nloc": 55,
            "cyclomatic_complexity": 16,
            "token_count": 322,
            "parameter_count": 1
        },
        "cve_info": [
            {
                "CVE_ID": "CVE-2017-9935",
                "Description": "In LibTIFF 4.0.8, there is a heap-based buffer overflow in the t2p_write_pdf function in tools/tiff2pdf.c. This heap overflow could lead to different damages. For example, a crafted TIFF document can lead to an out-of-bounds read in TIFFCleanup, an invalid free in TIFFClose or t2p_free, memory corruption in t2p_readwrite_pdf_image, or a double free in t2p_free. Given these possibilities, it probably could cause arbitrary code execution."
            }
        ],
        "cve_count": 1,
        "instruction": {
            "load_count": 98,
            "store_count": 12
        }
    },
    "TIFFClose": {
        "source_code": "void TIFFClose(TIFF *tif)\n{\n    if (tif != NULL)\n    {\n        TIFFCloseProc closeproc = tif->tif_closeproc;\n        thandle_t fd = tif->tif_clientdata;\n\n        TIFFCleanup(tif);\n        (void)(*closeproc)(fd);\n    }\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_close.c",
        "metrics": {
            "nloc": 10,
            "cyclomatic_complexity": 2,
            "token_count": 46,
            "parameter_count": 1
        },
        "cve_info": [
            {
                "CVE_ID": "CVE-2017-9935",
                "Description": "In LibTIFF 4.0.8, there is a heap-based buffer overflow in the t2p_write_pdf function in tools/tiff2pdf.c. This heap overflow could lead to different damages. For example, a crafted TIFF document can lead to an out-of-bounds read in TIFFCleanup, an invalid free in TIFFClose or t2p_free, memory corruption in t2p_readwrite_pdf_image, or a double free in t2p_free. Given these possibilities, it probably could cause arbitrary code execution."
            },
            {
                "CVE_ID": "CVE-2022-2521",
                "Description": "It was found in libtiff 4.4.0rc1 that there is an invalid pointer free operation in TIFFClose() at tif_close.c:131 called by tiffcrop.c:2522 that can cause a program crash and denial of service while processing crafted input."
            },
            {
                "CVE_ID": "CVE-2023-3316",
                "Description": "A NULL pointer dereference in TIFFClose() is caused by a failure to open an output file (non-existent path or a path that requires permissions like /dev/null) while specifying zones."
            }
        ],
        "cve_count": 3,
        "instruction": {
            "load_count": 106,
            "store_count": 15
        }
    },
    "TIFFSwabShort": {
        "source_code": "void TIFFSwabShort(uint16_t *wp)\n{\n    register unsigned char *cp = (unsigned char *)wp;\n    unsigned char t;\n    assert(sizeof(uint16_t) == 2);\n    t = cp[1];\n    cp[1] = cp[0];\n    cp[0] = t;\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_swab.c",
        "metrics": {
            "nloc": 9,
            "cyclomatic_complexity": 1,
            "token_count": 59,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 8,
            "store_count": 5
        }
    },
    "TIFFSwabLong": {
        "source_code": "void TIFFSwabLong(uint32_t *lp)\n{\n    register unsigned char *cp = (unsigned char *)lp;\n    unsigned char t;\n    assert(sizeof(uint32_t) == 4);\n    t = cp[3];\n    cp[3] = cp[0];\n    cp[0] = t;\n    t = cp[2];\n    cp[2] = cp[1];\n    cp[1] = t;\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_swab.c",
        "metrics": {
            "nloc": 12,
            "cyclomatic_complexity": 1,
            "token_count": 83,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 15,
            "store_count": 8
        }
    },
    "TIFFSwabLong8": {
        "source_code": "void TIFFSwabLong8(uint64_t *lp)\n{\n    register unsigned char *cp = (unsigned char *)lp;\n    unsigned char t;\n    assert(sizeof(uint64_t) == 8);\n    t = cp[7];\n    cp[7] = cp[0];\n    cp[0] = t;\n    t = cp[6];\n    cp[6] = cp[1];\n    cp[1] = t;\n    t = cp[5];\n    cp[5] = cp[2];\n    cp[2] = t;\n    t = cp[4];\n    cp[4] = cp[3];\n    cp[3] = t;\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_swab.c",
        "metrics": {
            "nloc": 18,
            "cyclomatic_complexity": 1,
            "token_count": 131,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 29,
            "store_count": 14
        }
    },
    "TIFFSwabArrayOfShort": {
        "source_code": "void TIFFSwabArrayOfShort(register uint16_t *wp, tmsize_t n)\n{\n    register unsigned char *cp;\n    register unsigned char t;\n    assert(sizeof(uint16_t) == 2);\n    /* XXX unroll loop some */\n    while (n-- > 0)\n    {\n        cp = (unsigned char *)wp;\n        t = cp[1];\n        cp[1] = cp[0];\n        cp[0] = t;\n        wp++;\n    }\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_swab.c",
        "metrics": {
            "nloc": 14,
            "cyclomatic_complexity": 2,
            "token_count": 78,
            "parameter_count": 2
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 10,
            "store_count": 8
        }
    },
    "TIFFSwabArrayOfTriples": {
        "source_code": "void TIFFSwabArrayOfTriples(register uint8_t *tp, tmsize_t n)\n{\n    unsigned char *cp;\n    unsigned char t;\n\n    /* XXX unroll loop some */\n    while (n-- > 0)\n    {\n        cp = (unsigned char *)tp;\n        t = cp[2];\n        cp[2] = cp[0];\n        cp[0] = t;\n        tp += 3;\n    }\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_swab.c",
        "metrics": {
            "nloc": 13,
            "cyclomatic_complexity": 2,
            "token_count": 67,
            "parameter_count": 2
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 10,
            "store_count": 8
        }
    },
    "TIFFSwabArrayOfLong": {
        "source_code": "void TIFFSwabArrayOfLong(register uint32_t *lp, tmsize_t n)\n{\n    register unsigned char *cp;\n    register unsigned char t;\n    assert(sizeof(uint32_t) == 4);\n    /* XXX unroll loop some */\n    while (n-- > 0)\n    {\n        cp = (unsigned char *)lp;\n        t = cp[3];\n        cp[3] = cp[0];\n        cp[0] = t;\n        t = cp[2];\n        cp[2] = cp[1];\n        cp[1] = t;\n        lp++;\n    }\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_swab.c",
        "metrics": {
            "nloc": 17,
            "cyclomatic_complexity": 2,
            "token_count": 102,
            "parameter_count": 2
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 17,
            "store_count": 11
        }
    },
    "TIFFSwabArrayOfLong8": {
        "source_code": "void TIFFSwabArrayOfLong8(register uint64_t *lp, tmsize_t n)\n{\n    register unsigned char *cp;\n    register unsigned char t;\n    assert(sizeof(uint64_t) == 8);\n    /* XXX unroll loop some */\n    while (n-- > 0)\n    {\n        cp = (unsigned char *)lp;\n        t = cp[7];\n        cp[7] = cp[0];\n        cp[0] = t;\n        t = cp[6];\n        cp[6] = cp[1];\n        cp[1] = t;\n        t = cp[5];\n        cp[5] = cp[2];\n        cp[2] = t;\n        t = cp[4];\n        cp[4] = cp[3];\n        cp[3] = t;\n        lp++;\n    }\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_swab.c",
        "metrics": {
            "nloc": 23,
            "cyclomatic_complexity": 2,
            "token_count": 150,
            "parameter_count": 2
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 31,
            "store_count": 17
        }
    },
    "TIFFSwabFloat": {
        "source_code": "void TIFFSwabFloat(float *fp)\n{\n    register unsigned char *cp = (unsigned char *)fp;\n    unsigned char t;\n    assert(sizeof(float) == 4);\n    t = cp[3];\n    cp[3] = cp[0];\n    cp[0] = t;\n    t = cp[2];\n    cp[2] = cp[1];\n    cp[1] = t;\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_swab.c",
        "metrics": {
            "nloc": 12,
            "cyclomatic_complexity": 1,
            "token_count": 83,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 15,
            "store_count": 8
        }
    },
    "TIFFSwabArrayOfFloat": {
        "source_code": "void TIFFSwabArrayOfFloat(register float *fp, tmsize_t n)\n{\n    register unsigned char *cp;\n    register unsigned char t;\n    assert(sizeof(float) == 4);\n    /* XXX unroll loop some */\n    while (n-- > 0)\n    {\n        cp = (unsigned char *)fp;\n        t = cp[3];\n        cp[3] = cp[0];\n        cp[0] = t;\n        t = cp[2];\n        cp[2] = cp[1];\n        cp[1] = t;\n        fp++;\n    }\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_swab.c",
        "metrics": {
            "nloc": 17,
            "cyclomatic_complexity": 2,
            "token_count": 102,
            "parameter_count": 2
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 17,
            "store_count": 11
        }
    },
    "TIFFSwabDouble": {
        "source_code": "void TIFFSwabDouble(double *dp)\n{\n    register unsigned char *cp = (unsigned char *)dp;\n    unsigned char t;\n    assert(sizeof(double) == 8);\n    t = cp[7];\n    cp[7] = cp[0];\n    cp[0] = t;\n    t = cp[6];\n    cp[6] = cp[1];\n    cp[1] = t;\n    t = cp[5];\n    cp[5] = cp[2];\n    cp[2] = t;\n    t = cp[4];\n    cp[4] = cp[3];\n    cp[3] = t;\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_swab.c",
        "metrics": {
            "nloc": 18,
            "cyclomatic_complexity": 1,
            "token_count": 131,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 29,
            "store_count": 14
        }
    },
    "TIFFSwabArrayOfDouble": {
        "source_code": "void TIFFSwabArrayOfDouble(double *dp, tmsize_t n)\n{\n    register unsigned char *cp;\n    register unsigned char t;\n    assert(sizeof(double) == 8);\n    /* XXX unroll loop some */\n    while (n-- > 0)\n    {\n        cp = (unsigned char *)dp;\n        t = cp[7];\n        cp[7] = cp[0];\n        cp[0] = t;\n        t = cp[6];\n        cp[6] = cp[1];\n        cp[1] = t;\n        t = cp[5];\n        cp[5] = cp[2];\n        cp[2] = t;\n        t = cp[4];\n        cp[4] = cp[3];\n        cp[3] = t;\n        dp++;\n    }\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_swab.c",
        "metrics": {
            "nloc": 23,
            "cyclomatic_complexity": 2,
            "token_count": 149,
            "parameter_count": 2
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 31,
            "store_count": 17
        }
    },
    "TIFFGetBitRevTable": {
        "source_code": "const unsigned char *TIFFGetBitRevTable(int reversed)\n{\n    return (reversed ? TIFFBitRevTable : TIFFNoBitRevTable);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_swab.c",
        "metrics": {
            "nloc": 4,
            "cyclomatic_complexity": 2,
            "token_count": 16,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 1,
            "store_count": 1
        }
    },
    "TIFFReverseBits": {
        "source_code": "void TIFFReverseBits(uint8_t *cp, tmsize_t n)\n{\n    for (; n > 8; n -= 8)\n    {\n        cp[0] = TIFFBitRevTable[cp[0]];\n        cp[1] = TIFFBitRevTable[cp[1]];\n        cp[2] = TIFFBitRevTable[cp[2]];\n        cp[3] = TIFFBitRevTable[cp[3]];\n        cp[4] = TIFFBitRevTable[cp[4]];\n        cp[5] = TIFFBitRevTable[cp[5]];\n        cp[6] = TIFFBitRevTable[cp[6]];\n        cp[7] = TIFFBitRevTable[cp[7]];\n        cp += 8;\n    }\n    while (n-- > 0)\n    {\n        *cp = TIFFBitRevTable[*cp];\n        cp++;\n    }\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_swab.c",
        "metrics": {
            "nloc": 20,
            "cyclomatic_complexity": 3,
            "token_count": 153,
            "parameter_count": 2
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 41,
            "store_count": 15
        }
    },
    "TIFFGetVersion": {
        "source_code": "const char *TIFFGetVersion(void) { return (TIFFVersion); }\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_version.c",
        "metrics": {
            "nloc": 1,
            "cyclomatic_complexity": 1,
            "token_count": 11,
            "parameter_count": 0
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 0,
            "store_count": 0
        }
    },
    "_TIFFMultiply32": {
        "source_code": "uint32_t _TIFFMultiply32(TIFF *tif, uint32_t first, uint32_t second,\n                         const char *where)\n{\n    if (second && first > UINT32_MAX / second)\n    {\n        TIFFErrorExtR(tif, where, \"Integer overflow in %s\", where);\n        return 0;\n    }\n\n    return first * second;\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_aux.c",
        "metrics": {
            "nloc": 10,
            "cyclomatic_complexity": 3,
            "token_count": 50,
            "parameter_count": 4
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 9,
            "store_count": 6
        }
    },
    "_TIFFMultiply64": {
        "source_code": "uint64_t _TIFFMultiply64(TIFF *tif, uint64_t first, uint64_t second,\n                         const char *where)\n{\n    if (second && first > UINT64_MAX / second)\n    {\n        TIFFErrorExtR(tif, where, \"Integer overflow in %s\", where);\n        return 0;\n    }\n\n    return first * second;\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_aux.c",
        "metrics": {
            "nloc": 10,
            "cyclomatic_complexity": 3,
            "token_count": 50,
            "parameter_count": 4
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 9,
            "store_count": 6
        }
    },
    "_TIFFCheckRealloc": {
        "source_code": "void *_TIFFCheckRealloc(TIFF *tif, void *buffer, tmsize_t nmemb,\n                        tmsize_t elem_size, const char *what)\n{\n    void *cp = NULL;\n    tmsize_t count = _TIFFMultiplySSize(tif, nmemb, elem_size, NULL);\n    /*\n     * Check for integer overflow.\n     */\n    if (count != 0)\n    {\n        cp = _TIFFreallocExt(tif, buffer, count);\n    }\n\n    if (cp == NULL)\n    {\n        TIFFErrorExtR(tif, tif->tif_name,\n                      \"Failed to allocate memory for %s \"\n                      \"(%\" TIFF_SSIZE_FORMAT \" elements of %\" TIFF_SSIZE_FORMAT\n                      \" bytes each)\",\n                      what, nmemb, elem_size);\n    }\n\n    return cp;\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_aux.c",
        "metrics": {
            "nloc": 19,
            "cyclomatic_complexity": 3,
            "token_count": 95,
            "parameter_count": 5
        },
        "cve_info": [
            {
                "CVE_ID": "CVE-2019-14973",
                "Description": "_TIFFCheckMalloc and _TIFFCheckRealloc in tif_aux.c in LibTIFF through 4.0.10 mishandle Integer Overflow checks because they rely on compiler behavior that is undefined by the applicable C standards. This can, for example, lead to an application crash."
            }
        ],
        "cve_count": 1,
        "instruction": {
            "load_count": 32,
            "store_count": 15
        }
    },
    "_TIFFCheckMalloc": {
        "source_code": "void *_TIFFCheckMalloc(TIFF *tif, tmsize_t nmemb, tmsize_t elem_size,\n                       const char *what)\n{\n    return _TIFFCheckRealloc(tif, NULL, nmemb, elem_size, what);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_aux.c",
        "metrics": {
            "nloc": 5,
            "cyclomatic_complexity": 1,
            "token_count": 33,
            "parameter_count": 4
        },
        "cve_info": [
            {
                "CVE_ID": "CVE-2017-11613",
                "Description": "In LibTIFF 4.0.8, there is a denial of service vulnerability in the TIFFOpen function. A crafted input will lead to a denial of service attack. During the TIFFOpen process, td_imagelength is not checked. The value of td_imagelength can be directly controlled by an input file. In the ChopUpSingleUncompressedStrip function, the _TIFFCheckMalloc function is called based on td_imagelength. If we set the value of td_imagelength close to the amount of system memory, it will hang the system or trigger the OOM killer."
            },
            {
                "CVE_ID": "CVE-2019-14973",
                "Description": "_TIFFCheckMalloc and _TIFFCheckRealloc in tif_aux.c in LibTIFF through 4.0.10 mishandle Integer Overflow checks because they rely on compiler behavior that is undefined by the applicable C standards. This can, for example, lead to an application crash."
            }
        ],
        "cve_count": 2,
        "instruction": {
            "load_count": 36,
            "store_count": 19
        }
    },
    "TIFFVGetFieldDefaulted": {
        "source_code": "int TIFFVGetFieldDefaulted(TIFF *tif, uint32_t tag, va_list ap)\n{\n    TIFFDirectory *td = &tif->tif_dir;\n\n    if (TIFFVGetField(tif, tag, ap))\n        return (1);\n    switch (tag)\n    {\n        case TIFFTAG_SUBFILETYPE:\n            *va_arg(ap, uint32_t *) = td->td_subfiletype;\n            return (1);\n        case TIFFTAG_BITSPERSAMPLE:\n            *va_arg(ap, uint16_t *) = td->td_bitspersample;\n            return (1);\n        case TIFFTAG_THRESHHOLDING:\n            *va_arg(ap, uint16_t *) = td->td_threshholding;\n            return (1);\n        case TIFFTAG_FILLORDER:\n            *va_arg(ap, uint16_t *) = td->td_fillorder;\n            return (1);\n        case TIFFTAG_ORIENTATION:\n            *va_arg(ap, uint16_t *) = td->td_orientation;\n            return (1);\n        case TIFFTAG_SAMPLESPERPIXEL:\n            *va_arg(ap, uint16_t *) = td->td_samplesperpixel;\n            return (1);\n        case TIFFTAG_ROWSPERSTRIP:\n            *va_arg(ap, uint32_t *) = td->td_rowsperstrip;\n            return (1);\n        case TIFFTAG_MINSAMPLEVALUE:\n            *va_arg(ap, uint16_t *) = td->td_minsamplevalue;\n            return (1);\n        case TIFFTAG_MAXSAMPLEVALUE:\n        {\n            uint16_t maxsamplevalue;\n            /* td_bitspersample=1 is always set in TIFFDefaultDirectory().\n             * Therefore, td_maxsamplevalue has to be re-calculated in\n             * TIFFGetFieldDefaulted(). */\n            if (td->td_bitspersample > 0)\n            {\n                /* This shift operation into a uint16_t limits the value to\n                 * 65535 even if td_bitspersamle is > 16 */\n                if (td->td_bitspersample <= 16)\n                {\n                    maxsamplevalue = (1 << td->td_bitspersample) -\n                                     1; /* 2**(BitsPerSample) - 1 */\n                }\n                else\n                {\n                    maxsamplevalue = 65535;\n                }\n            }\n            else\n            {\n                maxsamplevalue = 0;\n            }\n            *va_arg(ap, uint16_t *) = maxsamplevalue;\n            return (1);\n        }\n        case TIFFTAG_PLANARCONFIG:\n            *va_arg(ap, uint16_t *) = td->td_planarconfig;\n            return (1);\n        case TIFFTAG_RESOLUTIONUNIT:\n            *va_arg(ap, uint16_t *) = td->td_resolutionunit;\n            return (1);\n        case TIFFTAG_PREDICTOR:\n        {\n            TIFFPredictorState *sp = (TIFFPredictorState *)tif->tif_data;\n            if (sp == NULL)\n            {\n                TIFFErrorExtR(\n                    tif, tif->tif_name,\n                    \"Cannot get \\\"Predictor\\\" tag as plugin is not configured\");\n                *va_arg(ap, uint16_t *) = 0;\n                return 0;\n            }\n            *va_arg(ap, uint16_t *) = (uint16_t)sp->predictor;\n            return 1;\n        }\n        case TIFFTAG_DOTRANGE:\n            *va_arg(ap, uint16_t *) = 0;\n            *va_arg(ap, uint16_t *) = (1 << td->td_bitspersample) - 1;\n            return (1);\n        case TIFFTAG_INKSET:\n            *va_arg(ap, uint16_t *) = INKSET_CMYK;\n            return 1;\n        case TIFFTAG_NUMBEROFINKS:\n            *va_arg(ap, uint16_t *) = 4;\n            return (1);\n        case TIFFTAG_EXTRASAMPLES:\n            *va_arg(ap, uint16_t *) = td->td_extrasamples;\n            *va_arg(ap, const uint16_t **) = td->td_sampleinfo;\n            return (1);\n        case TIFFTAG_MATTEING:\n            *va_arg(ap, uint16_t *) =\n                (td->td_extrasamples == 1 &&\n                 td->td_sampleinfo[0] == EXTRASAMPLE_ASSOCALPHA);\n            return (1);\n        case TIFFTAG_TILEDEPTH:\n            *va_arg(ap, uint32_t *) = td->td_tiledepth;\n            return (1);\n        case TIFFTAG_DATATYPE:\n            *va_arg(ap, uint16_t *) = td->td_sampleformat - 1;\n            return (1);\n        case TIFFTAG_SAMPLEFORMAT:\n            *va_arg(ap, uint16_t *) = td->td_sampleformat;\n            return (1);\n        case TIFFTAG_IMAGEDEPTH:\n            *va_arg(ap, uint32_t *) = td->td_imagedepth;\n            return (1);\n        case TIFFTAG_YCBCRCOEFFICIENTS:\n        {\n            /* defaults are from CCIR Recommendation 601-1 */\n            static const float ycbcrcoeffs[] = {0.299f, 0.587f, 0.114f};\n            *va_arg(ap, const float **) = ycbcrcoeffs;\n            return 1;\n        }\n        case TIFFTAG_YCBCRSUBSAMPLING:\n            *va_arg(ap, uint16_t *) = td->td_ycbcrsubsampling[0];\n            *va_arg(ap, uint16_t *) = td->td_ycbcrsubsampling[1];\n            return (1);\n        case TIFFTAG_YCBCRPOSITIONING:\n            *va_arg(ap, uint16_t *) = td->td_ycbcrpositioning;\n            return (1);\n        case TIFFTAG_WHITEPOINT:\n        {\n            /* TIFF 6.0 specification tells that it is no default\n               value for the WhitePoint, but AdobePhotoshop TIFF\n               Technical Note tells that it should be CIE D50. */\n            static const float whitepoint[] = {\n                D50_X0 / (D50_X0 + D50_Y0 + D50_Z0),\n                D50_Y0 / (D50_X0 + D50_Y0 + D50_Z0)};\n            *va_arg(ap, const float **) = whitepoint;\n            return 1;\n        }\n        case TIFFTAG_TRANSFERFUNCTION:\n            if (!td->td_transferfunction[0] &&\n                !TIFFDefaultTransferFunction(tif, td))\n            {\n                TIFFErrorExtR(tif, tif->tif_name,\n                              \"No space for \\\"TransferFunction\\\" tag\");\n                return (0);\n            }\n            *va_arg(ap, const uint16_t **) = td->td_transferfunction[0];\n            if (td->td_samplesperpixel - td->td_extrasamples > 1)\n            {\n                *va_arg(ap, const uint16_t **) = td->td_transferfunction[1];\n                *va_arg(ap, const uint16_t **) = td->td_transferfunction[2];\n            }\n            return (1);\n        case TIFFTAG_REFERENCEBLACKWHITE:\n            if (!td->td_refblackwhite && !TIFFDefaultRefBlackWhite(tif, td))\n                return (0);\n            *va_arg(ap, const float **) = td->td_refblackwhite;\n            return (1);\n    }\n    return 0;\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_aux.c",
        "metrics": {
            "nloc": 148,
            "cyclomatic_complexity": 38,
            "token_count": 927,
            "parameter_count": 3
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 366,
            "store_count": 181
        }
    },
    "TIFFGetFieldDefaulted": {
        "source_code": "int TIFFGetFieldDefaulted(TIFF *tif, uint32_t tag, ...)\n{\n    int ok;\n    va_list ap;\n\n    va_start(ap, tag);\n    ok = TIFFVGetFieldDefaulted(tif, tag, ap);\n    va_end(ap);\n    return (ok);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_aux.c",
        "metrics": {
            "nloc": 9,
            "cyclomatic_complexity": 1,
            "token_count": 47,
            "parameter_count": 2
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 369,
            "store_count": 184
        }
    },
    "_TIFFClampDoubleToUInt32": {
        "source_code": "uint32_t _TIFFClampDoubleToUInt32(double val)\n{\n    if (val < 0)\n        return 0;\n    if (val > 0xFFFFFFFFU || val != val)\n        return 0xFFFFFFFFU;\n    return (uint32_t)val;\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_aux.c",
        "metrics": {
            "nloc": 8,
            "cyclomatic_complexity": 4,
            "token_count": 35,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 6,
            "store_count": 4
        }
    },
    "TIFFFdOpen": {
        "source_code": "TIFF *TIFFFdOpen(int fd, const char *name, const char *mode)\n{\n    return TIFFFdOpenExt(fd, name, mode, NULL);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_unix.c",
        "metrics": {
            "nloc": 4,
            "cyclomatic_complexity": 1,
            "token_count": 29,
            "parameter_count": 3
        },
        "cve_info": [
            {
                "CVE_ID": "CVE-2019-6128",
                "Description": "The TIFFFdOpen function in tif_unix.c in LibTIFF 4.0.10 has a memory leak, as demonstrated by pal2rgb."
            }
        ],
        "cve_count": 1,
        "instruction": {
            "load_count": 12,
            "store_count": 10
        }
    },
    "TIFFFdOpenExt": {
        "source_code": "TIFF *TIFFFdOpenExt(int fd, const char *name, const char *mode,\n                    TIFFOpenOptions *opts)\n{\n    TIFF *tif;\n\n    fd_as_handle_union_t fdh;\n    fdh.fd = fd;\n    tif = TIFFClientOpenExt(name, mode, fdh.h, _tiffReadProc, _tiffWriteProc,\n                            _tiffSeekProc, _tiffCloseProc, _tiffSizeProc,\n                            _tiffMapProc, _tiffUnmapProc, opts);\n    if (tif)\n        tif->tif_fd = fd;\n    return (tif);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_unix.c",
        "metrics": {
            "nloc": 13,
            "cyclomatic_complexity": 2,
            "token_count": 78,
            "parameter_count": 4
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 9,
            "store_count": 7
        }
    },
    "TIFFOpen": {
        "source_code": "TIFF *TIFFOpen(const char *name, const char *mode)\n{\n    return TIFFOpenExt(name, mode, NULL);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_unix.c",
        "metrics": {
            "nloc": 4,
            "cyclomatic_complexity": 1,
            "token_count": 24,
            "parameter_count": 2
        },
        "cve_info": [
            {
                "CVE_ID": "CVE-2017-11613",
                "Description": "In LibTIFF 4.0.8, there is a denial of service vulnerability in the TIFFOpen function. A crafted input will lead to a denial of service attack. During the TIFFOpen process, td_imagelength is not checked. The value of td_imagelength can be directly controlled by an input file. In the ChopUpSingleUncompressedStrip function, the _TIFFCheckMalloc function is called based on td_imagelength. If we set the value of td_imagelength close to the amount of system memory, it will hang the system or trigger the OOM killer."
            },
            {
                "CVE_ID": "CVE-2023-6277",
                "Description": "An out-of-memory flaw was found in libtiff. Passing a crafted tiff file to TIFFOpen() API may allow a remote attacker to cause a denial of service via a craft input with size smaller than 379 KB."
            }
        ],
        "cve_count": 2,
        "instruction": {
            "load_count": 23,
            "store_count": 11
        }
    },
    "TIFFOpenExt": {
        "source_code": "TIFF *TIFFOpenExt(const char *name, const char *mode, TIFFOpenOptions *opts)\n{\n    static const char module[] = \"TIFFOpen\";\n    int m, fd;\n    TIFF *tif;\n\n    m = _TIFFgetMode(opts, NULL, mode, module);\n    if (m == -1)\n        return ((TIFF *)0);\n\n/* for cygwin and mingw */\n#ifdef O_BINARY\n    m |= O_BINARY;\n#endif\n\n    fd = open(name, m, 0666);\n    if (fd < 0)\n    {\n        if (errno > 0 && strerror(errno) != NULL)\n        {\n            _TIFFErrorEarly(opts, NULL, module, \"%s: %s\", name,\n                            strerror(errno));\n        }\n        else\n        {\n            _TIFFErrorEarly(opts, NULL, module, \"%s: Cannot open\", name);\n        }\n        return ((TIFF *)0);\n    }\n\n    tif = TIFFFdOpenExt((int)fd, name, mode, opts);\n    if (!tif)\n        close(fd);\n    return tif;\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_unix.c",
        "metrics": {
            "nloc": 28,
            "cyclomatic_complexity": 7,
            "token_count": 175,
            "parameter_count": 3
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 30,
            "store_count": 16
        }
    },
    "_TIFFmalloc": {
        "source_code": "void *_TIFFmalloc(tmsize_t s)\n{\n    if (s == 0)\n        return ((void *)NULL);\n\n    return (malloc((size_t)s));\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_unix.c",
        "metrics": {
            "nloc": 6,
            "cyclomatic_complexity": 2,
            "token_count": 33,
            "parameter_count": 1
        },
        "cve_info": [
            {
                "CVE_ID": "CVE-2017-9815",
                "Description": "In LibTIFF 4.0.7, the TIFFReadDirEntryLong8Array function in libtiff/tif_dirread.c mishandles a malloc operation, which allows attackers to cause a denial of service (memory leak within the function _TIFFmalloc in tif_unix.c) via a crafted file."
            },
            {
                "CVE_ID": "CVE-2014-8130",
                "Description": "The _TIFFmalloc function in tif_unix.c in LibTIFF 4.0.3 does not reject a zero size, which allows remote attackers to cause a denial of service (divide-by-zero error and application crash) via a crafted TIFF image that is mishandled by the TIFFWriteScanline function in tif_write.c, as demonstrated by tiffdither."
            }
        ],
        "cve_count": 2,
        "instruction": {
            "load_count": 3,
            "store_count": 3
        }
    },
    "_TIFFfree": {
        "source_code": "void _TIFFfree(void *p) { free(p); }\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_unix.c",
        "metrics": {
            "nloc": 1,
            "cyclomatic_complexity": 1,
            "token_count": 13,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 1,
            "store_count": 1
        }
    },
    "_TIFFrealloc": {
        "source_code": "void *_TIFFrealloc(void *p, tmsize_t s) { return (realloc(p, (size_t)s)); }\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_unix.c",
        "metrics": {
            "nloc": 1,
            "cyclomatic_complexity": 1,
            "token_count": 24,
            "parameter_count": 2
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 2,
            "store_count": 2
        }
    },
    "_TIFFmemset": {
        "source_code": "void _TIFFmemset(void *p, int v, tmsize_t c) { memset(p, v, (size_t)c); }\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_unix.c",
        "metrics": {
            "nloc": 1,
            "cyclomatic_complexity": 1,
            "token_count": 26,
            "parameter_count": 3
        },
        "cve_info": [
            {
                "CVE_ID": "CVE-2022-3626",
                "Description": "LibTIFF 4.4.0 has an out-of-bounds write in _TIFFmemset in libtiff/tif_unix.c:340 when called from processCropSelections, tools/tiffcrop.c:7619, allowing attackers to cause a denial-of-service via a crafted tiff file. For users that compile libtiff from sources, the fix is available with commit 236b7191."
            }
        ],
        "cve_count": 1,
        "instruction": {
            "load_count": 3,
            "store_count": 3
        }
    },
    "_TIFFmemcpy": {
        "source_code": "void _TIFFmemcpy(void *d, const void *s, tmsize_t c)\n{\n    memcpy(d, s, (size_t)c);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_unix.c",
        "metrics": {
            "nloc": 4,
            "cyclomatic_complexity": 1,
            "token_count": 28,
            "parameter_count": 3
        },
        "cve_info": [
            {
                "CVE_ID": "CVE-2020-19144",
                "Description": "Buffer Overflow in LibTiff v4.0.10 allows attackers to cause a denial of service via the 'in _TIFFmemcpy' funtion in the component 'tif_unix.c'."
            },
            {
                "CVE_ID": "CVE-2022-22844",
                "Description": "LibTIFF 4.3.0 has an out-of-bounds read in _TIFFmemcpy in tif_unix.c in certain situations involving a custom tag and 0x0200 as the second word of the DE field."
            },
            {
                "CVE_ID": "CVE-2022-3597",
                "Description": "LibTIFF 4.4.0 has an out-of-bounds write in _TIFFmemcpy in libtiff/tif_unix.c:346 when called from extractImageSection, tools/tiffcrop.c:6826, allowing attackers to cause a denial-of-service via a crafted tiff file. For users that compile libtiff from sources, the fix is available with commit 236b7191."
            },
            {
                "CVE_ID": "CVE-2022-3627",
                "Description": "LibTIFF 4.4.0 has an out-of-bounds write in _TIFFmemcpy in libtiff/tif_unix.c:346 when called from extractImageSection, tools/tiffcrop.c:6860, allowing attackers to cause a denial-of-service via a crafted tiff file. For users that compile libtiff from sources, the fix is available with commit 236b7191."
            },
            {
                "CVE_ID": "CVE-2020-18768",
                "Description": "There exists one heap buffer overflow in _TIFFmemcpy in tif_unix.c in libtiff 4.0.10, which allows an attacker to cause a denial-of-service through a crafted tiff file."
            }
        ],
        "cve_count": 5,
        "instruction": {
            "load_count": 3,
            "store_count": 3
        }
    },
    "_TIFFmemcmp": {
        "source_code": "int _TIFFmemcmp(const void *p1, const void *p2, tmsize_t c)\n{\n    return (memcmp(p1, p2, (size_t)c));\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_unix.c",
        "metrics": {
            "nloc": 4,
            "cyclomatic_complexity": 1,
            "token_count": 32,
            "parameter_count": 3
        },
        "cve_info": [
            {
                "CVE_ID": "CVE-2018-17000",
                "Description": "A NULL pointer dereference in the function _TIFFmemcmp at tif_unix.c (called from TIFFWriteDirectoryTagTransferfunction) in LibTIFF 4.0.9 allows an attacker to cause a denial-of-service through a crafted tiff file. This vulnerability can be triggered by the executable tiffcp."
            }
        ],
        "cve_count": 1,
        "instruction": {
            "load_count": 3,
            "store_count": 3
        }
    },
    "TIFFFlush": {
        "source_code": "int TIFFFlush(TIFF *tif)\n{\n    if (tif->tif_mode == O_RDONLY)\n        return 1;\n\n    if (!TIFFFlushData(tif))\n        return (0);\n\n    /* In update (r+) mode we try to detect the case where\n       only the strip/tile map has been altered, and we try to\n       rewrite only that portion of the directory without\n       making any other changes */\n\n    if ((tif->tif_flags & TIFF_DIRTYSTRIP) &&\n        !(tif->tif_flags & TIFF_DIRTYDIRECT) && tif->tif_mode == O_RDWR)\n    {\n        if (TIFFForceStrileArrayWriting(tif))\n            return 1;\n    }\n\n    if ((tif->tif_flags & (TIFF_DIRTYDIRECT | TIFF_DIRTYSTRIP)) &&\n        !TIFFRewriteDirectory(tif))\n        return (0);\n\n    return (1);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_flush.c",
        "metrics": {
            "nloc": 17,
            "cyclomatic_complexity": 9,
            "token_count": 99,
            "parameter_count": 1
        },
        "cve_info": [
            {
                "CVE_ID": "CVE-2016-9534",
                "Description": "tif_write.c in libtiff 4.0.6 has an issue in the error code path of TIFFFlushData1() that didn't reset the tif_rawcc and tif_rawcp members. Reported as MSVR 35095, aka \"TIFFFlushData1 heap-buffer-overflow.\""
            }
        ],
        "cve_count": 1,
        "instruction": {
            "load_count": 77,
            "store_count": 23
        }
    },
    "TIFFForceStrileArrayWriting": {
        "source_code": "int TIFFForceStrileArrayWriting(TIFF *tif)\n{\n    static const char module[] = \"TIFFForceStrileArrayWriting\";\n    const int isTiled = TIFFIsTiled(tif);\n\n    if (tif->tif_mode == O_RDONLY)\n    {\n        TIFFErrorExtR(tif, tif->tif_name, \"File opened in read-only mode\");\n        return 0;\n    }\n    if (tif->tif_diroff == 0)\n    {\n        TIFFErrorExtR(tif, module, \"Directory has not yet been written\");\n        return 0;\n    }\n    if ((tif->tif_flags & TIFF_DIRTYDIRECT) != 0)\n    {\n        TIFFErrorExtR(tif, module,\n                      \"Directory has changes other than the strile arrays. \"\n                      \"TIFFRewriteDirectory() should be called instead\");\n        return 0;\n    }\n\n    if (!(tif->tif_flags & TIFF_DIRTYSTRIP))\n    {\n        if (!(tif->tif_dir.td_stripoffset_entry.tdir_tag != 0 &&\n              tif->tif_dir.td_stripoffset_entry.tdir_count == 0 &&\n              tif->tif_dir.td_stripoffset_entry.tdir_type == 0 &&\n              tif->tif_dir.td_stripoffset_entry.tdir_offset.toff_long8 == 0 &&\n              tif->tif_dir.td_stripbytecount_entry.tdir_tag != 0 &&\n              tif->tif_dir.td_stripbytecount_entry.tdir_count == 0 &&\n              tif->tif_dir.td_stripbytecount_entry.tdir_type == 0 &&\n              tif->tif_dir.td_stripbytecount_entry.tdir_offset.toff_long8 == 0))\n        {\n            TIFFErrorExtR(tif, module,\n                          \"Function not called together with \"\n                          \"TIFFDeferStrileArrayWriting()\");\n            return 0;\n        }\n\n        if (tif->tif_dir.td_stripoffset_p == NULL && !TIFFSetupStrips(tif))\n            return 0;\n    }\n\n    if (_TIFFRewriteField(tif,\n                          isTiled ? TIFFTAG_TILEOFFSETS : TIFFTAG_STRIPOFFSETS,\n                          TIFF_LONG8, tif->tif_dir.td_nstrips,\n                          tif->tif_dir.td_stripoffset_p) &&\n        _TIFFRewriteField(\n            tif, isTiled ? TIFFTAG_TILEBYTECOUNTS : TIFFTAG_STRIPBYTECOUNTS,\n            TIFF_LONG8, tif->tif_dir.td_nstrips,\n            tif->tif_dir.td_stripbytecount_p))\n    {\n        tif->tif_flags &= ~TIFF_DIRTYSTRIP;\n        tif->tif_flags &= ~TIFF_BEENWRITING;\n        return 1;\n    }\n\n    return 0;\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_flush.c",
        "metrics": {
            "nloc": 55,
            "cyclomatic_complexity": 19,
            "token_count": 307,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 691,
            "store_count": 175
        }
    },
    "TIFFFlushData": {
        "source_code": "int TIFFFlushData(TIFF *tif)\n{\n    if ((tif->tif_flags & TIFF_BEENWRITING) == 0)\n        return (1);\n    if (tif->tif_flags & TIFF_POSTENCODE)\n    {\n        tif->tif_flags &= ~TIFF_POSTENCODE;\n        if (!(*tif->tif_postencode)(tif))\n            return (0);\n    }\n    return (TIFFFlushData1(tif));\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_flush.c",
        "metrics": {
            "nloc": 12,
            "cyclomatic_complexity": 4,
            "token_count": 67,
            "parameter_count": 1
        },
        "cve_info": [
            {
                "CVE_ID": "CVE-2016-9534",
                "Description": "tif_write.c in libtiff 4.0.6 has an issue in the error code path of TIFFFlushData1() that didn't reset the tif_rawcc and tif_rawcp members. Reported as MSVR 35095, aka \"TIFFFlushData1 heap-buffer-overflow.\""
            }
        ],
        "cve_count": 1,
        "instruction": {
            "load_count": 11,
            "store_count": 5
        }
    },
    "TIFFOpenOptionsAlloc": {
        "source_code": "TIFFOpenOptions *TIFFOpenOptionsAlloc()\n{\n    TIFFOpenOptions *opts =\n        (TIFFOpenOptions *)_TIFFcalloc(1, sizeof(TIFFOpenOptions));\n    return opts;\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_open.c",
        "metrics": {
            "nloc": 6,
            "cyclomatic_complexity": 1,
            "token_count": 26,
            "parameter_count": 0
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 6,
            "store_count": 5
        }
    },
    "TIFFOpenOptionsFree": {
        "source_code": "void TIFFOpenOptionsFree(TIFFOpenOptions *opts) { _TIFFfree(opts); }\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_open.c",
        "metrics": {
            "nloc": 1,
            "cyclomatic_complexity": 1,
            "token_count": 13,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 2,
            "store_count": 2
        }
    },
    "TIFFOpenOptionsSetMaxSingleMemAlloc": {
        "source_code": "void TIFFOpenOptionsSetMaxSingleMemAlloc(TIFFOpenOptions *opts,\n                                         tmsize_t max_single_mem_alloc)\n{\n    opts->max_single_mem_alloc = max_single_mem_alloc;\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_open.c",
        "metrics": {
            "nloc": 5,
            "cyclomatic_complexity": 1,
            "token_count": 17,
            "parameter_count": 2
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 2,
            "store_count": 3
        }
    },
    "TIFFOpenOptionsSetMaxCumulatedMemAlloc": {
        "source_code": "void TIFFOpenOptionsSetMaxCumulatedMemAlloc(TIFFOpenOptions *opts,\n                                            tmsize_t max_cumulated_mem_alloc)\n{\n    opts->max_cumulated_mem_alloc = max_cumulated_mem_alloc;\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_open.c",
        "metrics": {
            "nloc": 5,
            "cyclomatic_complexity": 1,
            "token_count": 17,
            "parameter_count": 2
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 2,
            "store_count": 3
        }
    },
    "TIFFOpenOptionsSetWarnAboutUnknownTags": {
        "source_code": "void TIFFOpenOptionsSetWarnAboutUnknownTags(TIFFOpenOptions *opts,\n                                            int warn_about_unknown_tags)\n{\n    opts->warn_about_unknown_tags = warn_about_unknown_tags;\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_open.c",
        "metrics": {
            "nloc": 5,
            "cyclomatic_complexity": 1,
            "token_count": 17,
            "parameter_count": 2
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 2,
            "store_count": 3
        }
    },
    "TIFFOpenOptionsSetErrorHandlerExtR": {
        "source_code": "void TIFFOpenOptionsSetErrorHandlerExtR(TIFFOpenOptions *opts,\n                                        TIFFErrorHandlerExtR handler,\n                                        void *errorhandler_user_data)\n{\n    opts->errorhandler = handler;\n    opts->errorhandler_user_data = errorhandler_user_data;\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_open.c",
        "metrics": {
            "nloc": 7,
            "cyclomatic_complexity": 1,
            "token_count": 27,
            "parameter_count": 3
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 4,
            "store_count": 5
        }
    },
    "TIFFOpenOptionsSetWarningHandlerExtR": {
        "source_code": "void TIFFOpenOptionsSetWarningHandlerExtR(TIFFOpenOptions *opts,\n                                          TIFFErrorHandlerExtR handler,\n                                          void *warnhandler_user_data)\n{\n    opts->warnhandler = handler;\n    opts->warnhandler_user_data = warnhandler_user_data;\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_open.c",
        "metrics": {
            "nloc": 7,
            "cyclomatic_complexity": 1,
            "token_count": 27,
            "parameter_count": 3
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 4,
            "store_count": 5
        }
    },
    "TIFFClientOpen": {
        "source_code": "TIFF *TIFFClientOpen(const char *name, const char *mode, thandle_t clientdata,\n                     TIFFReadWriteProc readproc, TIFFReadWriteProc writeproc,\n                     TIFFSeekProc seekproc, TIFFCloseProc closeproc,\n                     TIFFSizeProc sizeproc, TIFFMapFileProc mapproc,\n                     TIFFUnmapFileProc unmapproc)\n{\n    return TIFFClientOpenExt(name, mode, clientdata, readproc, writeproc,\n                             seekproc, closeproc, sizeproc, mapproc, unmapproc,\n                             NULL);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_open.c",
        "metrics": {
            "nloc": 10,
            "cyclomatic_complexity": 1,
            "token_count": 64,
            "parameter_count": 10
        },
        "cve_info": [
            {
                "CVE_ID": "CVE-2018-10801",
                "Description": "TIFFClientOpen in tif_unix.c in LibTIFF 3.8.2 has memory leaks, as demonstrated by bmp2tiff."
            }
        ],
        "cve_count": 1,
        "instruction": {
            "load_count": 312,
            "store_count": 98
        }
    },
    "TIFFClientOpenExt": {
        "source_code": "TIFF *TIFFClientOpenExt(const char *name, const char *mode,\n                        thandle_t clientdata, TIFFReadWriteProc readproc,\n                        TIFFReadWriteProc writeproc, TIFFSeekProc seekproc,\n                        TIFFCloseProc closeproc, TIFFSizeProc sizeproc,\n                        TIFFMapFileProc mapproc, TIFFUnmapFileProc unmapproc,\n                        TIFFOpenOptions *opts)\n{\n    static const char module[] = \"TIFFClientOpenExt\";\n    TIFF *tif;\n    int m;\n    const char *cp;\n\n    /* The following are configuration checks. They should be redundant, but\n     * should not compile to any actual code in an optimised release build\n     * anyway. If any of them fail, (makefile-based or other) configuration is\n     * not correct */\n    assert(sizeof(uint8_t) == 1);\n    assert(sizeof(int8_t) == 1);\n    assert(sizeof(uint16_t) == 2);\n    assert(sizeof(int16_t) == 2);\n    assert(sizeof(uint32_t) == 4);\n    assert(sizeof(int32_t) == 4);\n    assert(sizeof(uint64_t) == 8);\n    assert(sizeof(int64_t) == 8);\n    {\n        union\n        {\n            uint8_t a8[2];\n            uint16_t a16;\n        } n;\n        n.a8[0] = 1;\n        n.a8[1] = 0;\n        (void)n;\n#ifdef WORDS_BIGENDIAN\n        assert(n.a16 == 256);\n#else\n        assert(n.a16 == 1);\n#endif\n    }\n\n    m = _TIFFgetMode(opts, clientdata, mode, module);\n    if (m == -1)\n        goto bad2;\n    tmsize_t size_to_alloc = (tmsize_t)(sizeof(TIFF) + strlen(name) + 1);\n    if (opts && opts->max_single_mem_alloc > 0 &&\n        size_to_alloc > opts->max_single_mem_alloc)\n    {\n        _TIFFErrorEarly(opts, clientdata, module,\n                        \"%s: Memory allocation of %\" PRIu64\n                        \" bytes is beyond the %\" PRIu64\n                        \" byte limit defined in open options\",\n                        name, (uint64_t)size_to_alloc,\n                        (uint64_t)opts->max_single_mem_alloc);\n        goto bad2;\n    }\n    if (opts && opts->max_cumulated_mem_alloc > 0 &&\n        size_to_alloc > opts->max_cumulated_mem_alloc)\n    {\n        _TIFFErrorEarly(opts, clientdata, module,\n                        \"%s: Memory allocation of %\" PRIu64\n                        \" bytes is beyond the %\" PRIu64\n                        \" cumulated byte limit defined in open options\",\n                        name, (uint64_t)size_to_alloc,\n                        (uint64_t)opts->max_cumulated_mem_alloc);\n        goto bad2;\n    }\n    tif = (TIFF *)_TIFFmallocExt(NULL, size_to_alloc);\n    if (tif == NULL)\n    {\n        _TIFFErrorEarly(opts, clientdata, module,\n                        \"%s: Out of memory (TIFF structure)\", name);\n        goto bad2;\n    }\n    _TIFFmemset(tif, 0, sizeof(*tif));\n    tif->tif_name = (char *)tif + sizeof(TIFF);\n    strcpy(tif->tif_name, name);\n    tif->tif_mode = m & ~(O_CREAT | O_TRUNC);\n    tif->tif_curdir = TIFF_NON_EXISTENT_DIR_NUMBER; /* non-existent directory */\n    tif->tif_curdircount = TIFF_NON_EXISTENT_DIR_NUMBER;\n    tif->tif_curoff = 0;\n    tif->tif_curstrip = (uint32_t)-1; /* invalid strip */\n    tif->tif_row = (uint32_t)-1;      /* read/write pre-increment */\n    tif->tif_clientdata = clientdata;\n    tif->tif_readproc = readproc;\n    tif->tif_writeproc = writeproc;\n    tif->tif_seekproc = seekproc;\n    tif->tif_closeproc = closeproc;\n    tif->tif_sizeproc = sizeproc;\n    tif->tif_mapproc = mapproc ? mapproc : _tiffDummyMapProc;\n    tif->tif_unmapproc = unmapproc ? unmapproc : _tiffDummyUnmapProc;\n    if (opts)\n    {\n        tif->tif_errorhandler = opts->errorhandler;\n        tif->tif_errorhandler_user_data = opts->errorhandler_user_data;\n        tif->tif_warnhandler = opts->warnhandler;\n        tif->tif_warnhandler_user_data = opts->warnhandler_user_data;\n        tif->tif_max_single_mem_alloc = opts->max_single_mem_alloc;\n        tif->tif_max_cumulated_mem_alloc = opts->max_cumulated_mem_alloc;\n        tif->tif_warn_about_unknown_tags = opts->warn_about_unknown_tags;\n    }\n\n    if (!readproc || !writeproc || !seekproc || !closeproc || !sizeproc)\n    {\n        TIFFErrorExtR(tif, module,\n                      \"One of the client procedures is NULL pointer.\");\n        _TIFFfreeExt(NULL, tif);\n        goto bad2;\n    }\n\n    _TIFFSetDefaultCompressionState(tif); /* setup default state */\n    /*\n     * Default is to return data MSB2LSB and enable the\n     * use of memory-mapped files and strip chopping when\n     * a file is opened read-only.\n     */\n    tif->tif_flags = FILLORDER_MSB2LSB;\n    if (m == O_RDONLY)\n        tif->tif_flags |= TIFF_MAPPED;\n\n#ifdef STRIPCHOP_DEFAULT\n    if (m == O_RDONLY || m == O_RDWR)\n        tif->tif_flags |= STRIPCHOP_DEFAULT;\n#endif\n\n    /*\n     * Process library-specific flags in the open mode string.\n     * The following flags may be used to control intrinsic library\n     * behavior that may or may not be desirable (usually for\n     * compatibility with some application that claims to support\n     * TIFF but only supports some brain dead idea of what the\n     * vendor thinks TIFF is):\n     *\n     * 'l' use little-endian byte order for creating a file\n     * 'b' use big-endian byte order for creating a file\n     * 'L' read/write information using LSB2MSB bit order\n     * 'B' read/write information using MSB2LSB bit order\n     * 'H' read/write information using host bit order\n     * 'M' enable use of memory-mapped files when supported\n     * 'm' disable use of memory-mapped files\n     * 'C' enable strip chopping support when reading\n     * 'c' disable strip chopping support\n     * 'h' read TIFF header only, do not load the first IFD\n     * '4' ClassicTIFF for creating a file (default)\n     * '8' BigTIFF for creating a file\n     * 'D' enable use of deferred strip/tile offset/bytecount array loading.\n     * 'O' on-demand loading of values instead of whole array loading (implies\n     * D)\n     *\n     * The use of the 'l' and 'b' flags is strongly discouraged.\n     * These flags are provided solely because numerous vendors,\n     * typically on the PC, do not correctly support TIFF; they\n     * only support the Intel little-endian byte order.  This\n     * support is not configured by default because it supports\n     * the violation of the TIFF spec that says that readers *MUST*\n     * support both byte orders.  It is strongly recommended that\n     * you not use this feature except to deal with busted apps\n     * that write invalid TIFF.  And even in those cases you should\n     * bang on the vendors to fix their software.\n     *\n     * The 'L', 'B', and 'H' flags are intended for applications\n     * that can optimize operations on data by using a particular\n     * bit order.  By default the library returns data in MSB2LSB\n     * bit order for compatibility with older versions of this\n     * library.  Returning data in the bit order of the native CPU\n     * makes the most sense but also requires applications to check\n     * the value of the FillOrder tag; something they probably do\n     * not do right now.\n     *\n     * The 'M' and 'm' flags are provided because some virtual memory\n     * systems exhibit poor behavior when large images are mapped.\n     * These options permit clients to control the use of memory-mapped\n     * files on a per-file basis.\n     *\n     * The 'C' and 'c' flags are provided because the library support\n     * for chopping up large strips into multiple smaller strips is not\n     * application-transparent and as such can cause problems.  The 'c'\n     * option permits applications that only want to look at the tags,\n     * for example, to get the unadulterated TIFF tag information.\n     */\n    for (cp = mode; *cp; cp++)\n        switch (*cp)\n        {\n            case 'b':\n#ifndef WORDS_BIGENDIAN\n                if (m & O_CREAT)\n                    tif->tif_flags |= TIFF_SWAB;\n#endif\n                break;\n            case 'l':\n#ifdef WORDS_BIGENDIAN\n                if ((m & O_CREAT))\n                    tif->tif_flags |= TIFF_SWAB;\n#endif\n                break;\n            case 'B':\n                tif->tif_flags =\n                    (tif->tif_flags & ~TIFF_FILLORDER) | FILLORDER_MSB2LSB;\n                break;\n            case 'L':\n                tif->tif_flags =\n                    (tif->tif_flags & ~TIFF_FILLORDER) | FILLORDER_LSB2MSB;\n                break;\n            case 'H':\n                TIFFWarningExtR(tif, name,\n                                \"H(ost) mode is deprecated. Since \"\n                                \"libtiff 4.5.1, it is an alias of 'B' / \"\n                                \"FILLORDER_MSB2LSB.\");\n                tif->tif_flags =\n                    (tif->tif_flags & ~TIFF_FILLORDER) | FILLORDER_MSB2LSB;\n                break;\n            case 'M':\n                if (m == O_RDONLY)\n                    tif->tif_flags |= TIFF_MAPPED;\n                break;\n            case 'm':\n                if (m == O_RDONLY)\n                    tif->tif_flags &= ~TIFF_MAPPED;\n                break;\n            case 'C':\n                if (m == O_RDONLY)\n                    tif->tif_flags |= TIFF_STRIPCHOP;\n                break;\n            case 'c':\n                if (m == O_RDONLY)\n                    tif->tif_flags &= ~TIFF_STRIPCHOP;\n                break;\n            case 'h':\n                tif->tif_flags |= TIFF_HEADERONLY;\n                break;\n            case '8':\n                if (m & O_CREAT)\n                    tif->tif_flags |= TIFF_BIGTIFF;\n                break;\n            case 'D':\n                tif->tif_flags |= TIFF_DEFERSTRILELOAD;\n                break;\n            case 'O':\n                if (m == O_RDONLY)\n                    tif->tif_flags |=\n                        (TIFF_LAZYSTRILELOAD | TIFF_DEFERSTRILELOAD);\n                break;\n        }\n\n#ifdef DEFER_STRILE_LOAD\n    /* Compatibility with old DEFER_STRILE_LOAD compilation flag */\n    /* Probably unneeded, since to the best of my knowledge (E. Rouault) */\n    /* GDAL was the only user of this, and will now use the new 'D' flag */\n    tif->tif_flags |= TIFF_DEFERSTRILELOAD;\n#endif\n\n    /*\n     * Read in TIFF header.\n     */\n    if ((m & O_TRUNC) ||\n        !ReadOK(tif, &tif->tif_header, sizeof(TIFFHeaderClassic)))\n    {\n        if (tif->tif_mode == O_RDONLY)\n        {\n            TIFFErrorExtR(tif, name, \"Cannot read TIFF header\");\n            goto bad;\n        }\n        /*\n         * Setup header and write.\n         */\n#ifdef WORDS_BIGENDIAN\n        tif->tif_header.common.tiff_magic =\n            (tif->tif_flags & TIFF_SWAB) ? TIFF_LITTLEENDIAN : TIFF_BIGENDIAN;\n#else\n        tif->tif_header.common.tiff_magic =\n            (tif->tif_flags & TIFF_SWAB) ? TIFF_BIGENDIAN : TIFF_LITTLEENDIAN;\n#endif\n        TIFFHeaderUnion tif_header_swapped;\n        if (!(tif->tif_flags & TIFF_BIGTIFF))\n        {\n            tif->tif_header.common.tiff_version = TIFF_VERSION_CLASSIC;\n            tif->tif_header.classic.tiff_diroff = 0;\n            tif->tif_header_size = sizeof(TIFFHeaderClassic);\n            /* Swapped copy for writing */\n            _TIFFmemcpy(&tif_header_swapped, &tif->tif_header,\n                        sizeof(TIFFHeaderUnion));\n            if (tif->tif_flags & TIFF_SWAB)\n                TIFFSwabShort(&tif_header_swapped.common.tiff_version);\n        }\n        else\n        {\n            tif->tif_header.common.tiff_version = TIFF_VERSION_BIG;\n            tif->tif_header.big.tiff_offsetsize = 8;\n            tif->tif_header.big.tiff_unused = 0;\n            tif->tif_header.big.tiff_diroff = 0;\n            tif->tif_header_size = sizeof(TIFFHeaderBig);\n            /* Swapped copy for writing */\n            _TIFFmemcpy(&tif_header_swapped, &tif->tif_header,\n                        sizeof(TIFFHeaderUnion));\n            if (tif->tif_flags & TIFF_SWAB)\n            {\n                TIFFSwabShort(&tif_header_swapped.common.tiff_version);\n                TIFFSwabShort(&tif_header_swapped.big.tiff_offsetsize);\n            }\n        }\n        /*\n         * The doc for \"fopen\" for some STD_C_LIBs says that if you\n         * open a file for modify (\"+\"), then you must fseek (or\n         * fflush?) between any freads and fwrites.  This is not\n         * necessary on most systems, but has been shown to be needed\n         * on Solaris.\n         */\n        TIFFSeekFile(tif, 0, SEEK_SET);\n        if (!WriteOK(tif, &tif_header_swapped,\n                     (tmsize_t)(tif->tif_header_size)))\n        {\n            TIFFErrorExtR(tif, name, \"Error writing TIFF header\");\n            goto bad;\n        }\n        /*\n         * Setup default directory.\n         */\n        if (!TIFFDefaultDirectory(tif))\n            goto bad;\n        tif->tif_diroff = 0;\n        tif->tif_lastdiroff = 0;\n        tif->tif_setdirectory_force_absolute = FALSE;\n        /* tif_curdircount = 0 means 'empty file opened for writing, but no IFD\n         * written yet' */\n        tif->tif_curdircount = 0;\n        return (tif);\n    }\n\n    /*\n     * Setup the byte order handling according to the opened file for reading.\n     */\n    if (tif->tif_header.common.tiff_magic != TIFF_BIGENDIAN &&\n        tif->tif_header.common.tiff_magic != TIFF_LITTLEENDIAN\n#if MDI_SUPPORT\n        &&\n#if HOST_BIGENDIAN\n        tif->tif_header.common.tiff_magic != MDI_BIGENDIAN\n#else\n        tif->tif_header.common.tiff_magic != MDI_LITTLEENDIAN\n#endif\n    )\n    {\n        TIFFErrorExtR(tif, name,\n                      \"Not a TIFF or MDI file, bad magic number %\" PRIu16\n                      \" (0x%\" PRIx16 \")\",\n#else\n    )\n    {\n        TIFFErrorExtR(tif, name,\n                      \"Not a TIFF file, bad magic number %\" PRIu16\n                      \" (0x%\" PRIx16 \")\",\n#endif\n                      tif->tif_header.common.tiff_magic,\n                      tif->tif_header.common.tiff_magic);\n        goto bad;\n    }\n    if (tif->tif_header.common.tiff_magic == TIFF_BIGENDIAN)\n    {\n#ifndef WORDS_BIGENDIAN\n        tif->tif_flags |= TIFF_SWAB;\n#endif\n    }\n    else\n    {\n#ifdef WORDS_BIGENDIAN\n        tif->tif_flags |= TIFF_SWAB;\n#endif\n    }\n    if (tif->tif_flags & TIFF_SWAB)\n        TIFFSwabShort(&tif->tif_header.common.tiff_version);\n    if ((tif->tif_header.common.tiff_version != TIFF_VERSION_CLASSIC) &&\n        (tif->tif_header.common.tiff_version != TIFF_VERSION_BIG))\n    {\n        TIFFErrorExtR(tif, name,\n                      \"Not a TIFF file, bad version number %\" PRIu16\n                      \" (0x%\" PRIx16 \")\",\n                      tif->tif_header.common.tiff_version,\n                      tif->tif_header.common.tiff_version);\n        goto bad;\n    }\n    if (tif->tif_header.common.tiff_version == TIFF_VERSION_CLASSIC)\n    {\n        if (tif->tif_flags & TIFF_SWAB)\n            TIFFSwabLong(&tif->tif_header.classic.tiff_diroff);\n        tif->tif_header_size = sizeof(TIFFHeaderClassic);\n    }\n    else\n    {\n        if (!ReadOK(tif,\n                    ((uint8_t *)(&tif->tif_header) + sizeof(TIFFHeaderClassic)),\n                    (sizeof(TIFFHeaderBig) - sizeof(TIFFHeaderClassic))))\n        {\n            TIFFErrorExtR(tif, name, \"Cannot read TIFF header\");\n            goto bad;\n        }\n        if (tif->tif_flags & TIFF_SWAB)\n        {\n            TIFFSwabShort(&tif->tif_header.big.tiff_offsetsize);\n            TIFFSwabLong8(&tif->tif_header.big.tiff_diroff);\n        }\n        if (tif->tif_header.big.tiff_offsetsize != 8)\n        {\n            TIFFErrorExtR(tif, name,\n                          \"Not a TIFF file, bad BigTIFF offsetsize %\" PRIu16\n                          \" (0x%\" PRIx16 \")\",\n                          tif->tif_header.big.tiff_offsetsize,\n                          tif->tif_header.big.tiff_offsetsize);\n            goto bad;\n        }\n        if (tif->tif_header.big.tiff_unused != 0)\n        {\n            TIFFErrorExtR(tif, name,\n                          \"Not a TIFF file, bad BigTIFF unused %\" PRIu16\n                          \" (0x%\" PRIx16 \")\",\n                          tif->tif_header.big.tiff_unused,\n                          tif->tif_header.big.tiff_unused);\n            goto bad;\n        }\n        tif->tif_header_size = sizeof(TIFFHeaderBig);\n        tif->tif_flags |= TIFF_BIGTIFF;\n    }\n    tif->tif_flags |= TIFF_MYBUFFER;\n    tif->tif_rawcp = tif->tif_rawdata = 0;\n    tif->tif_rawdatasize = 0;\n    tif->tif_rawdataoff = 0;\n    tif->tif_rawdataloaded = 0;\n\n    switch (mode[0])\n    {\n        case 'r':\n            if (!(tif->tif_flags & TIFF_BIGTIFF))\n                tif->tif_nextdiroff = tif->tif_header.classic.tiff_diroff;\n            else\n                tif->tif_nextdiroff = tif->tif_header.big.tiff_diroff;\n            /*\n             * Try to use a memory-mapped file if the client\n             * has not explicitly suppressed usage with the\n             * 'm' flag in the open mode (see above).\n             */\n            if (tif->tif_flags & TIFF_MAPPED)\n            {\n                toff_t n;\n                if (TIFFMapFileContents(tif, (void **)(&tif->tif_base), &n))\n                {\n                    tif->tif_size = (tmsize_t)n;\n                    assert((toff_t)tif->tif_size == n);\n                }\n                else\n                    tif->tif_flags &= ~TIFF_MAPPED;\n            }\n            /*\n             * Sometimes we do not want to read the first directory (for\n             * example, it may be broken) and want to proceed to other\n             * directories. I this case we use the TIFF_HEADERONLY flag to open\n             * file and return immediately after reading TIFF header.\n             * However, the pointer to TIFFSetField() and TIFFGetField()\n             * (i.e. tif->tif_tagmethods.vsetfield and\n             * tif->tif_tagmethods.vgetfield) need to be initialized, which is\n             * done in TIFFDefaultDirectory().\n             */\n            if (tif->tif_flags & TIFF_HEADERONLY)\n            {\n                if (!TIFFDefaultDirectory(tif))\n                    goto bad;\n                return (tif);\n            }\n\n            /*\n             * Setup initial directory.\n             */\n            if (TIFFReadDirectory(tif))\n            {\n                return (tif);\n            }\n            break;\n        case 'a':\n            /*\n             * New directories are automatically append\n             * to the end of the directory chain when they\n             * are written out (see TIFFWriteDirectory).\n             */\n            if (!TIFFDefaultDirectory(tif))\n                goto bad;\n            return (tif);\n    }\nbad:\n    tif->tif_mode = O_RDONLY; /* XXX avoid flush */\n    TIFFCleanup(tif);\nbad2:\n    return ((TIFF *)0);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_open.c",
        "metrics": {
            "nloc": 0,
            "cyclomatic_complexity": 0,
            "token_count": 0,
            "parameter_count": 0
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 468,
            "store_count": 180
        }
    },
    "TIFFFileName": {
        "source_code": "const char *TIFFFileName(TIFF *tif) { return (tif->tif_name); }\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_open.c",
        "metrics": {
            "nloc": 1,
            "cyclomatic_complexity": 1,
            "token_count": 15,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 2,
            "store_count": 1
        }
    },
    "TIFFSetFileName": {
        "source_code": "const char *TIFFSetFileName(TIFF *tif, const char *name)\n{\n    const char *old_name = tif->tif_name;\n    tif->tif_name = (char *)name;\n    return (old_name);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_open.c",
        "metrics": {
            "nloc": 6,
            "cyclomatic_complexity": 1,
            "token_count": 37,
            "parameter_count": 2
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 5,
            "store_count": 4
        }
    },
    "TIFFFileno": {
        "source_code": "int TIFFFileno(TIFF *tif) { return (tif->tif_fd); }\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_open.c",
        "metrics": {
            "nloc": 1,
            "cyclomatic_complexity": 1,
            "token_count": 15,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 2,
            "store_count": 1
        }
    },
    "TIFFSetFileno": {
        "source_code": "int TIFFSetFileno(TIFF *tif, int fd)\n{\n    int old_fd = tif->tif_fd;\n    tif->tif_fd = fd;\n    return old_fd;\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_open.c",
        "metrics": {
            "nloc": 6,
            "cyclomatic_complexity": 1,
            "token_count": 27,
            "parameter_count": 2
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 5,
            "store_count": 4
        }
    },
    "TIFFClientdata": {
        "source_code": "thandle_t TIFFClientdata(TIFF *tif) { return (tif->tif_clientdata); }\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_open.c",
        "metrics": {
            "nloc": 1,
            "cyclomatic_complexity": 1,
            "token_count": 15,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 2,
            "store_count": 1
        }
    },
    "TIFFSetClientdata": {
        "source_code": "thandle_t TIFFSetClientdata(TIFF *tif, thandle_t newvalue)\n{\n    thandle_t m = tif->tif_clientdata;\n    tif->tif_clientdata = newvalue;\n    return m;\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_open.c",
        "metrics": {
            "nloc": 6,
            "cyclomatic_complexity": 1,
            "token_count": 27,
            "parameter_count": 2
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 5,
            "store_count": 4
        }
    },
    "TIFFGetMode": {
        "source_code": "int TIFFGetMode(TIFF *tif) { return (tif->tif_mode); }\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_open.c",
        "metrics": {
            "nloc": 1,
            "cyclomatic_complexity": 1,
            "token_count": 15,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 2,
            "store_count": 1
        }
    },
    "TIFFSetMode": {
        "source_code": "int TIFFSetMode(TIFF *tif, int mode)\n{\n    int old_mode = tif->tif_mode;\n    tif->tif_mode = mode;\n    return (old_mode);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_open.c",
        "metrics": {
            "nloc": 6,
            "cyclomatic_complexity": 1,
            "token_count": 29,
            "parameter_count": 2
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 5,
            "store_count": 4
        }
    },
    "TIFFIsTiled": {
        "source_code": "int TIFFIsTiled(TIFF *tif) { return (isTiled(tif)); }\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_open.c",
        "metrics": {
            "nloc": 1,
            "cyclomatic_complexity": 1,
            "token_count": 16,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 2,
            "store_count": 1
        }
    },
    "TIFFCurrentRow": {
        "source_code": "uint32_t TIFFCurrentRow(TIFF *tif) { return (tif->tif_row); }\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_open.c",
        "metrics": {
            "nloc": 1,
            "cyclomatic_complexity": 1,
            "token_count": 15,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 2,
            "store_count": 1
        }
    },
    "TIFFCurrentDirectory": {
        "source_code": "tdir_t TIFFCurrentDirectory(TIFF *tif) { return (tif->tif_curdir); }\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_open.c",
        "metrics": {
            "nloc": 1,
            "cyclomatic_complexity": 1,
            "token_count": 15,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 2,
            "store_count": 1
        }
    },
    "TIFFCurrentStrip": {
        "source_code": "uint32_t TIFFCurrentStrip(TIFF *tif) { return (tif->tif_curstrip); }\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_open.c",
        "metrics": {
            "nloc": 1,
            "cyclomatic_complexity": 1,
            "token_count": 15,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 2,
            "store_count": 1
        }
    },
    "TIFFCurrentTile": {
        "source_code": "uint32_t TIFFCurrentTile(TIFF *tif) { return (tif->tif_curtile); }\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_open.c",
        "metrics": {
            "nloc": 1,
            "cyclomatic_complexity": 1,
            "token_count": 15,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 2,
            "store_count": 1
        }
    },
    "TIFFIsByteSwapped": {
        "source_code": "int TIFFIsByteSwapped(TIFF *tif) { return ((tif->tif_flags & TIFF_SWAB) != 0); }\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_open.c",
        "metrics": {
            "nloc": 1,
            "cyclomatic_complexity": 1,
            "token_count": 21,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 2,
            "store_count": 1
        }
    },
    "TIFFIsUpSampled": {
        "source_code": "int TIFFIsUpSampled(TIFF *tif) { return (isUpSampled(tif)); }\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_open.c",
        "metrics": {
            "nloc": 1,
            "cyclomatic_complexity": 1,
            "token_count": 16,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 2,
            "store_count": 1
        }
    },
    "TIFFIsMSB2LSB": {
        "source_code": "int TIFFIsMSB2LSB(TIFF *tif) { return (isFillOrder(tif, FILLORDER_MSB2LSB)); }\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_open.c",
        "metrics": {
            "nloc": 1,
            "cyclomatic_complexity": 1,
            "token_count": 18,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 2,
            "store_count": 1
        }
    },
    "TIFFIsBigEndian": {
        "source_code": "int TIFFIsBigEndian(TIFF *tif)\n{\n    return (tif->tif_header.common.tiff_magic == TIFF_BIGENDIAN);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_open.c",
        "metrics": {
            "nloc": 4,
            "cyclomatic_complexity": 1,
            "token_count": 21,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 2,
            "store_count": 1
        }
    },
    "TIFFIsBigTIFF": {
        "source_code": "int TIFFIsBigTIFF(TIFF *tif) { return ((tif->tif_flags & TIFF_BIGTIFF) != 0); }\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_open.c",
        "metrics": {
            "nloc": 1,
            "cyclomatic_complexity": 1,
            "token_count": 21,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 2,
            "store_count": 1
        }
    },
    "TIFFGetReadProc": {
        "source_code": "TIFFReadWriteProc TIFFGetReadProc(TIFF *tif) { return (tif->tif_readproc); }\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_open.c",
        "metrics": {
            "nloc": 1,
            "cyclomatic_complexity": 1,
            "token_count": 15,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 2,
            "store_count": 1
        }
    },
    "TIFFGetWriteProc": {
        "source_code": "TIFFReadWriteProc TIFFGetWriteProc(TIFF *tif) { return (tif->tif_writeproc); }\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_open.c",
        "metrics": {
            "nloc": 1,
            "cyclomatic_complexity": 1,
            "token_count": 15,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 2,
            "store_count": 1
        }
    },
    "TIFFGetSeekProc": {
        "source_code": "TIFFSeekProc TIFFGetSeekProc(TIFF *tif) { return (tif->tif_seekproc); }\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_open.c",
        "metrics": {
            "nloc": 1,
            "cyclomatic_complexity": 1,
            "token_count": 15,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 2,
            "store_count": 1
        }
    },
    "TIFFGetCloseProc": {
        "source_code": "TIFFCloseProc TIFFGetCloseProc(TIFF *tif) { return (tif->tif_closeproc); }\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_open.c",
        "metrics": {
            "nloc": 1,
            "cyclomatic_complexity": 1,
            "token_count": 15,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 2,
            "store_count": 1
        }
    },
    "TIFFGetSizeProc": {
        "source_code": "TIFFSizeProc TIFFGetSizeProc(TIFF *tif) { return (tif->tif_sizeproc); }\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_open.c",
        "metrics": {
            "nloc": 1,
            "cyclomatic_complexity": 1,
            "token_count": 15,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 2,
            "store_count": 1
        }
    },
    "TIFFGetMapFileProc": {
        "source_code": "TIFFMapFileProc TIFFGetMapFileProc(TIFF *tif) { return (tif->tif_mapproc); }\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_open.c",
        "metrics": {
            "nloc": 1,
            "cyclomatic_complexity": 1,
            "token_count": 15,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 2,
            "store_count": 1
        }
    },
    "TIFFGetUnmapFileProc": {
        "source_code": "TIFFUnmapFileProc TIFFGetUnmapFileProc(TIFF *tif)\n{\n    return (tif->tif_unmapproc);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_open.c",
        "metrics": {
            "nloc": 4,
            "cyclomatic_complexity": 1,
            "token_count": 15,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 2,
            "store_count": 1
        }
    },
    "TIFFSetWarningHandler": {
        "source_code": "TIFFErrorHandler TIFFSetWarningHandler(TIFFErrorHandler handler)\n{\n    TIFFErrorHandler prev = _TIFFwarningHandler;\n    _TIFFwarningHandler = handler;\n    return (prev);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_warning.c",
        "metrics": {
            "nloc": 6,
            "cyclomatic_complexity": 1,
            "token_count": 21,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 3,
            "store_count": 3
        }
    },
    "TIFFSetWarningHandlerExt": {
        "source_code": "TIFFErrorHandlerExt TIFFSetWarningHandlerExt(TIFFErrorHandlerExt handler)\n{\n    TIFFErrorHandlerExt prev = _TIFFwarningHandlerExt;\n    _TIFFwarningHandlerExt = handler;\n    return (prev);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_warning.c",
        "metrics": {
            "nloc": 6,
            "cyclomatic_complexity": 1,
            "token_count": 21,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 3,
            "store_count": 3
        }
    },
    "TIFFWarning": {
        "source_code": "void TIFFWarning(const char *module, const char *fmt, ...)\n{\n    va_list ap;\n    if (_TIFFwarningHandler)\n    {\n        va_start(ap, fmt);\n        (*_TIFFwarningHandler)(module, fmt, ap);\n        va_end(ap);\n    }\n    if (_TIFFwarningHandlerExt)\n    {\n        va_start(ap, fmt);\n        (*_TIFFwarningHandlerExt)(0, module, fmt, ap);\n        va_end(ap);\n    }\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_warning.c",
        "metrics": {
            "nloc": 16,
            "cyclomatic_complexity": 3,
            "token_count": 81,
            "parameter_count": 2
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 8,
            "store_count": 2
        }
    },
    "TIFFWarningExt": {
        "source_code": "void TIFFWarningExt(thandle_t fd, const char *module, const char *fmt, ...)\n{\n    va_list ap;\n    if (_TIFFwarningHandler)\n    {\n        va_start(ap, fmt);\n        (*_TIFFwarningHandler)(module, fmt, ap);\n        va_end(ap);\n    }\n    if (_TIFFwarningHandlerExt)\n    {\n        va_start(ap, fmt);\n        (*_TIFFwarningHandlerExt)(fd, module, fmt, ap);\n        va_end(ap);\n    }\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_warning.c",
        "metrics": {
            "nloc": 16,
            "cyclomatic_complexity": 3,
            "token_count": 84,
            "parameter_count": 3
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 9,
            "store_count": 3
        }
    },
    "TIFFWarningExtR": {
        "source_code": "void TIFFWarningExtR(TIFF *tif, const char *module, const char *fmt, ...)\n{\n    va_list ap;\n    if (tif && tif->tif_warnhandler)\n    {\n        va_start(ap, fmt);\n        int stop = (*tif->tif_warnhandler)(tif, tif->tif_warnhandler_user_data,\n                                           module, fmt, ap);\n        va_end(ap);\n        if (stop)\n            return;\n    }\n    if (_TIFFwarningHandler)\n    {\n        va_start(ap, fmt);\n        (*_TIFFwarningHandler)(module, fmt, ap);\n        va_end(ap);\n    }\n    if (_TIFFwarningHandlerExt)\n    {\n        va_start(ap, fmt);\n        (*_TIFFwarningHandlerExt)(tif ? tif->tif_clientdata : 0, module, fmt,\n                                  ap);\n        va_end(ap);\n    }\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_warning.c",
        "metrics": {
            "nloc": 26,
            "cyclomatic_complexity": 7,
            "token_count": 142,
            "parameter_count": 3
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 22,
            "store_count": 4
        }
    },
    "TIFFRGBAImageOK": {
        "source_code": "int TIFFRGBAImageOK(TIFF *tif, char emsg[EMSG_BUF_SIZE])\n{\n    TIFFDirectory *td = &tif->tif_dir;\n    uint16_t photometric;\n    int colorchannels;\n\n    if (!tif->tif_decodestatus)\n    {\n        snprintf(emsg, EMSG_BUF_SIZE,\n                 \"Sorry, requested compression method is not configured\");\n        return (0);\n    }\n    switch (td->td_bitspersample)\n    {\n        case 1:\n        case 2:\n        case 4:\n        case 8:\n        case 16:\n            break;\n        default:\n            snprintf(emsg, EMSG_BUF_SIZE,\n                     \"Sorry, can not handle images with %\" PRIu16\n                     \"-bit samples\",\n                     td->td_bitspersample);\n            return (0);\n    }\n    if (td->td_sampleformat == SAMPLEFORMAT_IEEEFP)\n    {\n        snprintf(\n            emsg, EMSG_BUF_SIZE,\n            \"Sorry, can not handle images with IEEE floating-point samples\");\n        return (0);\n    }\n    colorchannels = td->td_samplesperpixel - td->td_extrasamples;\n    if (!TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric))\n    {\n        switch (colorchannels)\n        {\n            case 1:\n                photometric = PHOTOMETRIC_MINISBLACK;\n                break;\n            case 3:\n                photometric = PHOTOMETRIC_RGB;\n                break;\n            default:\n                snprintf(emsg, EMSG_BUF_SIZE, \"Missing needed %s tag\",\n                         photoTag);\n                return (0);\n        }\n    }\n    switch (photometric)\n    {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        case PHOTOMETRIC_PALETTE:\n            if (td->td_planarconfig == PLANARCONFIG_CONTIG &&\n                td->td_samplesperpixel != 1 && td->td_bitspersample < 8)\n            {\n                snprintf(\n                    emsg, EMSG_BUF_SIZE,\n                    \"Sorry, can not handle contiguous data with %s=%\" PRIu16\n                    \", \"\n                    \"and %s=%\" PRIu16 \" and Bits/Sample=%\" PRIu16 \"\",\n                    photoTag, photometric, \"Samples/pixel\",\n                    td->td_samplesperpixel, td->td_bitspersample);\n                return (0);\n            }\n            /*\n             * We should likely validate that any extra samples are either\n             * to be ignored, or are alpha, and if alpha we should try to use\n             * them.  But for now we won't bother with this.\n             */\n            break;\n        case PHOTOMETRIC_YCBCR:\n            /*\n             * TODO: if at all meaningful and useful, make more complete\n             * support check here, or better still, refactor to let supporting\n             * code decide whether there is support and what meaningful\n             * error to return\n             */\n            break;\n        case PHOTOMETRIC_RGB:\n            if (colorchannels < 3)\n            {\n                snprintf(emsg, EMSG_BUF_SIZE,\n                         \"Sorry, can not handle RGB image with %s=%d\",\n                         \"Color channels\", colorchannels);\n                return (0);\n            }\n            break;\n        case PHOTOMETRIC_SEPARATED:\n        {\n            uint16_t inkset;\n            TIFFGetFieldDefaulted(tif, TIFFTAG_INKSET, &inkset);\n            if (inkset != INKSET_CMYK)\n            {\n                snprintf(emsg, EMSG_BUF_SIZE,\n                         \"Sorry, can not handle separated image with %s=%d\",\n                         \"InkSet\", inkset);\n                return 0;\n            }\n            if (td->td_samplesperpixel < 4)\n            {\n                snprintf(\n                    emsg, EMSG_BUF_SIZE,\n                    \"Sorry, can not handle separated image with %s=%\" PRIu16,\n                    \"Samples/pixel\", td->td_samplesperpixel);\n                return 0;\n            }\n            break;\n        }\n        case PHOTOMETRIC_LOGL:\n            if (td->td_compression != COMPRESSION_SGILOG)\n            {\n                snprintf(emsg, EMSG_BUF_SIZE,\n                         \"Sorry, LogL data must have %s=%d\", \"Compression\",\n                         COMPRESSION_SGILOG);\n                return (0);\n            }\n            break;\n        case PHOTOMETRIC_LOGLUV:\n            if (td->td_compression != COMPRESSION_SGILOG &&\n                td->td_compression != COMPRESSION_SGILOG24)\n            {\n                snprintf(emsg, EMSG_BUF_SIZE,\n                         \"Sorry, LogLuv data must have %s=%d or %d\",\n                         \"Compression\", COMPRESSION_SGILOG,\n                         COMPRESSION_SGILOG24);\n                return (0);\n            }\n            if (td->td_planarconfig != PLANARCONFIG_CONTIG)\n            {\n                snprintf(emsg, EMSG_BUF_SIZE,\n                         \"Sorry, can not handle LogLuv images with %s=%\" PRIu16,\n                         \"Planarconfiguration\", td->td_planarconfig);\n                return (0);\n            }\n            if (td->td_samplesperpixel != 3 || colorchannels != 3)\n            {\n                snprintf(emsg, EMSG_BUF_SIZE,\n                         \"Sorry, can not handle image with %s=%\" PRIu16\n                         \", %s=%d\",\n                         \"Samples/pixel\", td->td_samplesperpixel,\n                         \"colorchannels\", colorchannels);\n                return 0;\n            }\n            break;\n        case PHOTOMETRIC_CIELAB:\n            if (td->td_samplesperpixel != 3 || colorchannels != 3 ||\n                (td->td_bitspersample != 8 && td->td_bitspersample != 16))\n            {\n                snprintf(emsg, EMSG_BUF_SIZE,\n                         \"Sorry, can not handle image with %s=%\" PRIu16\n                         \", %s=%d and %s=%\" PRIu16,\n                         \"Samples/pixel\", td->td_samplesperpixel,\n                         \"colorchannels\", colorchannels, \"Bits/sample\",\n                         td->td_bitspersample);\n                return 0;\n            }\n            break;\n        default:\n            snprintf(emsg, EMSG_BUF_SIZE,\n                     \"Sorry, can not handle image with %s=%\" PRIu16, photoTag,\n                     photometric);\n            return (0);\n    }\n    return (1);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_getimage.c",
        "metrics": {
            "nloc": 157,
            "cyclomatic_complexity": 36,
            "token_count": 606,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 452,
            "store_count": 208
        }
    },
    "TIFFRGBAImageEnd": {
        "source_code": "void TIFFRGBAImageEnd(TIFFRGBAImage *img)\n{\n    if (img->Map)\n    {\n        _TIFFfreeExt(img->tif, img->Map);\n        img->Map = NULL;\n    }\n    if (img->BWmap)\n    {\n        _TIFFfreeExt(img->tif, img->BWmap);\n        img->BWmap = NULL;\n    }\n    if (img->PALmap)\n    {\n        _TIFFfreeExt(img->tif, img->PALmap);\n        img->PALmap = NULL;\n    }\n    if (img->ycbcr)\n    {\n        _TIFFfreeExt(img->tif, img->ycbcr);\n        img->ycbcr = NULL;\n    }\n    if (img->cielab)\n    {\n        _TIFFfreeExt(img->tif, img->cielab);\n        img->cielab = NULL;\n    }\n    if (img->UaToAa)\n    {\n        _TIFFfreeExt(img->tif, img->UaToAa);\n        img->UaToAa = NULL;\n    }\n    if (img->Bitdepth16To8)\n    {\n        _TIFFfreeExt(img->tif, img->Bitdepth16To8);\n        img->Bitdepth16To8 = NULL;\n    }\n\n    if (img->redcmap)\n    {\n        _TIFFfreeExt(img->tif, img->redcmap);\n        _TIFFfreeExt(img->tif, img->greencmap);\n        _TIFFfreeExt(img->tif, img->bluecmap);\n        img->redcmap = img->greencmap = img->bluecmap = NULL;\n    }\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_getimage.c",
        "metrics": {
            "nloc": 45,
            "cyclomatic_complexity": 9,
            "token_count": 238,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 66,
            "store_count": 11
        }
    },
    "TIFFRGBAImageBegin": {
        "source_code": "int TIFFRGBAImageBegin(TIFFRGBAImage *img, TIFF *tif, int stop,\n                       char emsg[EMSG_BUF_SIZE])\n{\n    uint16_t *sampleinfo;\n    uint16_t extrasamples;\n    uint16_t planarconfig;\n    uint16_t compress;\n    int colorchannels;\n    uint16_t *red_orig, *green_orig, *blue_orig;\n    int n_color;\n\n    if (!TIFFRGBAImageOK(tif, emsg))\n        return 0;\n\n    /* Initialize to normal values */\n    img->row_offset = 0;\n    img->col_offset = 0;\n    img->redcmap = NULL;\n    img->greencmap = NULL;\n    img->bluecmap = NULL;\n    img->Map = NULL;\n    img->BWmap = NULL;\n    img->PALmap = NULL;\n    img->ycbcr = NULL;\n    img->cielab = NULL;\n    img->UaToAa = NULL;\n    img->Bitdepth16To8 = NULL;\n    img->req_orientation = ORIENTATION_BOTLEFT; /* It is the default */\n\n    img->tif = tif;\n    img->stoponerr = stop;\n    TIFFGetFieldDefaulted(tif, TIFFTAG_BITSPERSAMPLE, &img->bitspersample);\n    switch (img->bitspersample)\n    {\n        case 1:\n        case 2:\n        case 4:\n        case 8:\n        case 16:\n            break;\n        default:\n            snprintf(emsg, EMSG_BUF_SIZE,\n                     \"Sorry, can not handle images with %\" PRIu16\n                     \"-bit samples\",\n                     img->bitspersample);\n            goto fail_return;\n    }\n    img->alpha = 0;\n    TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLESPERPIXEL, &img->samplesperpixel);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_EXTRASAMPLES, &extrasamples,\n                          &sampleinfo);\n    if (extrasamples >= 1)\n    {\n        switch (sampleinfo[0])\n        {\n            case EXTRASAMPLE_UNSPECIFIED: /* Workaround for some images without\n                                           */\n                if (img->samplesperpixel >\n                    3) /* correct info about alpha channel */\n                    img->alpha = EXTRASAMPLE_ASSOCALPHA;\n                break;\n            case EXTRASAMPLE_ASSOCALPHA: /* data is pre-multiplied */\n            case EXTRASAMPLE_UNASSALPHA: /* data is not pre-multiplied */\n                img->alpha = sampleinfo[0];\n                break;\n        }\n    }\n\n#ifdef DEFAULT_EXTRASAMPLE_AS_ALPHA\n    if (!TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &img->photometric))\n        img->photometric = PHOTOMETRIC_MINISWHITE;\n\n    if (extrasamples == 0 && img->samplesperpixel == 4 &&\n        img->photometric == PHOTOMETRIC_RGB)\n    {\n        img->alpha = EXTRASAMPLE_ASSOCALPHA;\n        extrasamples = 1;\n    }\n#endif\n\n    colorchannels = img->samplesperpixel - extrasamples;\n    TIFFGetFieldDefaulted(tif, TIFFTAG_COMPRESSION, &compress);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_PLANARCONFIG, &planarconfig);\n    if (!TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &img->photometric))\n    {\n        switch (colorchannels)\n        {\n            case 1:\n                if (isCCITTCompression(tif))\n                    img->photometric = PHOTOMETRIC_MINISWHITE;\n                else\n                    img->photometric = PHOTOMETRIC_MINISBLACK;\n                break;\n            case 3:\n                img->photometric = PHOTOMETRIC_RGB;\n                break;\n            default:\n                snprintf(emsg, EMSG_BUF_SIZE, \"Missing needed %s tag\",\n                         photoTag);\n                goto fail_return;\n        }\n    }\n    switch (img->photometric)\n    {\n        case PHOTOMETRIC_PALETTE:\n            if (!TIFFGetField(tif, TIFFTAG_COLORMAP, &red_orig, &green_orig,\n                              &blue_orig))\n            {\n                snprintf(emsg, EMSG_BUF_SIZE,\n                         \"Missing required \\\"Colormap\\\" tag\");\n                goto fail_return;\n            }\n\n            /* copy the colormaps so we can modify them */\n            n_color = (1U << img->bitspersample);\n            img->redcmap =\n                (uint16_t *)_TIFFmallocExt(tif, sizeof(uint16_t) * n_color);\n            img->greencmap =\n                (uint16_t *)_TIFFmallocExt(tif, sizeof(uint16_t) * n_color);\n            img->bluecmap =\n                (uint16_t *)_TIFFmallocExt(tif, sizeof(uint16_t) * n_color);\n            if (!img->redcmap || !img->greencmap || !img->bluecmap)\n            {\n                snprintf(emsg, EMSG_BUF_SIZE,\n                         \"Out of memory for colormap copy\");\n                goto fail_return;\n            }\n\n            _TIFFmemcpy(img->redcmap, red_orig, n_color * 2);\n            _TIFFmemcpy(img->greencmap, green_orig, n_color * 2);\n            _TIFFmemcpy(img->bluecmap, blue_orig, n_color * 2);\n\n            /* fall through... */\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n            if (planarconfig == PLANARCONFIG_CONTIG &&\n                img->samplesperpixel != 1 && img->bitspersample < 8)\n            {\n                snprintf(\n                    emsg, EMSG_BUF_SIZE,\n                    \"Sorry, can not handle contiguous data with %s=%\" PRIu16\n                    \", \"\n                    \"and %s=%\" PRIu16 \" and Bits/Sample=%\" PRIu16,\n                    photoTag, img->photometric, \"Samples/pixel\",\n                    img->samplesperpixel, img->bitspersample);\n                goto fail_return;\n            }\n            break;\n        case PHOTOMETRIC_YCBCR:\n            /* It would probably be nice to have a reality check here. */\n            if (planarconfig == PLANARCONFIG_CONTIG)\n                /* can rely on libjpeg to convert to RGB */\n                /* XXX should restore current state on exit */\n                switch (compress)\n                {\n                    case COMPRESSION_JPEG:\n                        /*\n                         * TODO: when complete tests verify complete\n                         * desubsampling and YCbCr handling, remove use of\n                         * TIFFTAG_JPEGCOLORMODE in favor of tif_getimage.c\n                         * native handling\n                         */\n                        TIFFSetField(tif, TIFFTAG_JPEGCOLORMODE,\n                                     JPEGCOLORMODE_RGB);\n                        img->photometric = PHOTOMETRIC_RGB;\n                        break;\n                    default:\n                        /* do nothing */;\n                        break;\n                }\n            /*\n             * TODO: if at all meaningful and useful, make more complete\n             * support check here, or better still, refactor to let supporting\n             * code decide whether there is support and what meaningful\n             * error to return\n             */\n            break;\n        case PHOTOMETRIC_RGB:\n            if (colorchannels < 3)\n            {\n                snprintf(emsg, EMSG_BUF_SIZE,\n                         \"Sorry, can not handle RGB image with %s=%d\",\n                         \"Color channels\", colorchannels);\n                goto fail_return;\n            }\n            break;\n        case PHOTOMETRIC_SEPARATED:\n        {\n            uint16_t inkset;\n            TIFFGetFieldDefaulted(tif, TIFFTAG_INKSET, &inkset);\n            if (inkset != INKSET_CMYK)\n            {\n                snprintf(\n                    emsg, EMSG_BUF_SIZE,\n                    \"Sorry, can not handle separated image with %s=%\" PRIu16,\n                    \"InkSet\", inkset);\n                goto fail_return;\n            }\n            if (img->samplesperpixel < 4)\n            {\n                snprintf(\n                    emsg, EMSG_BUF_SIZE,\n                    \"Sorry, can not handle separated image with %s=%\" PRIu16,\n                    \"Samples/pixel\", img->samplesperpixel);\n                goto fail_return;\n            }\n        }\n        break;\n        case PHOTOMETRIC_LOGL:\n            if (compress != COMPRESSION_SGILOG)\n            {\n                snprintf(emsg, EMSG_BUF_SIZE,\n                         \"Sorry, LogL data must have %s=%d\", \"Compression\",\n                         COMPRESSION_SGILOG);\n                goto fail_return;\n            }\n            TIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_8BIT);\n            img->photometric = PHOTOMETRIC_MINISBLACK; /* little white lie */\n            img->bitspersample = 8;\n            break;\n        case PHOTOMETRIC_LOGLUV:\n            if (compress != COMPRESSION_SGILOG &&\n                compress != COMPRESSION_SGILOG24)\n            {\n                snprintf(emsg, EMSG_BUF_SIZE,\n                         \"Sorry, LogLuv data must have %s=%d or %d\",\n                         \"Compression\", COMPRESSION_SGILOG,\n                         COMPRESSION_SGILOG24);\n                goto fail_return;\n            }\n            if (planarconfig != PLANARCONFIG_CONTIG)\n            {\n                snprintf(emsg, EMSG_BUF_SIZE,\n                         \"Sorry, can not handle LogLuv images with %s=%\" PRIu16,\n                         \"Planarconfiguration\", planarconfig);\n                return (0);\n            }\n            TIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_8BIT);\n            img->photometric = PHOTOMETRIC_RGB; /* little white lie */\n            img->bitspersample = 8;\n            break;\n        case PHOTOMETRIC_CIELAB:\n            break;\n        default:\n            snprintf(emsg, EMSG_BUF_SIZE,\n                     \"Sorry, can not handle image with %s=%\" PRIu16, photoTag,\n                     img->photometric);\n            goto fail_return;\n    }\n    TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &img->width);\n    TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &img->height);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ORIENTATION, &img->orientation);\n    img->isContig =\n        !(planarconfig == PLANARCONFIG_SEPARATE && img->samplesperpixel > 1);\n    if (img->isContig)\n    {\n        if (!PickContigCase(img))\n        {\n            snprintf(emsg, EMSG_BUF_SIZE, \"Sorry, can not handle image\");\n            goto fail_return;\n        }\n    }\n    else\n    {\n        if (!PickSeparateCase(img))\n        {\n            snprintf(emsg, EMSG_BUF_SIZE, \"Sorry, can not handle image\");\n            goto fail_return;\n        }\n    }\n    return 1;\n\nfail_return:\n    TIFFRGBAImageEnd(img);\n    return 0;\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_getimage.c",
        "metrics": {
            "nloc": 245,
            "cyclomatic_complexity": 50,
            "token_count": 1120,
            "parameter_count": 3
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 3441,
            "store_count": 1625
        }
    },
    "TIFFRGBAImageGet": {
        "source_code": "int TIFFRGBAImageGet(TIFFRGBAImage *img, uint32_t *raster, uint32_t w,\n                     uint32_t h)\n{\n    if (img->get == NULL)\n    {\n        TIFFErrorExtR(img->tif, TIFFFileName(img->tif),\n                      \"No \\\"get\\\" routine setup\");\n        return (0);\n    }\n    if (img->put.any == NULL)\n    {\n        TIFFErrorExtR(\n            img->tif, TIFFFileName(img->tif),\n            \"No \\\"put\\\" routine setupl; probably can not handle image format\");\n        return (0);\n    }\n    return (*img->get)(img, raster, w, h);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_getimage.c",
        "metrics": {
            "nloc": 18,
            "cyclomatic_complexity": 3,
            "token_count": 99,
            "parameter_count": 4
        },
        "cve_info": [
            {
                "CVE_ID": "CVE-2010-2483",
                "Description": "The TIFFRGBAImageGet function in LibTIFF 3.9.0 allows remote attackers to cause a denial of service (out-of-bounds read and application crash) via a TIFF file with an invalid combination of SamplesPerPixel and Photometric values."
            },
            {
                "CVE_ID": "CVE-2017-5849",
                "Description": "tiffttopnm in netpbm 10.47.63 does not properly use the libtiff TIFFRGBAImageGet function, which allows remote attackers to cause a denial of service (out-of-bounds read and write) via a crafted tiff image file, related to transposing width and height values."
            }
        ],
        "cve_count": 2,
        "instruction": {
            "load_count": 19,
            "store_count": 7
        }
    },
    "TIFFReadRGBAImageOriented": {
        "source_code": "int TIFFReadRGBAImageOriented(TIFF *tif, uint32_t rwidth, uint32_t rheight,\n                              uint32_t *raster, int orientation, int stop)\n{\n    char emsg[EMSG_BUF_SIZE] = \"\";\n    TIFFRGBAImage img;\n    int ok;\n\n    if (TIFFRGBAImageBegin(&img, tif, stop, emsg))\n    {\n        img.req_orientation = (uint16_t)orientation;\n        /* XXX verify rwidth and rheight against width and height */\n        ok = TIFFRGBAImageGet(&img, raster + (rheight - img.height) * rwidth,\n                              rwidth, img.height);\n        TIFFRGBAImageEnd(&img);\n    }\n    else\n    {\n        TIFFErrorExtR(tif, TIFFFileName(tif), \"%s\", emsg);\n        ok = 0;\n    }\n    return (ok);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_getimage.c",
        "metrics": {
            "nloc": 20,
            "cyclomatic_complexity": 2,
            "token_count": 121,
            "parameter_count": 6
        },
        "cve_info": [
            {
                "CVE_ID": "CVE-2019-11459",
                "Description": "The tiff_document_render() and tiff_document_get_thumbnail() functions in the TIFF document backend in GNOME Evince through 3.32.0 did not handle errors from TIFFReadRGBAImageOriented(), leading to uninitialized memory use when processing certain TIFF image files."
            }
        ],
        "cve_count": 1,
        "instruction": {
            "load_count": 3538,
            "store_count": 1652
        }
    },
    "TIFFReadRGBAImage": {
        "source_code": "int TIFFReadRGBAImage(TIFF *tif, uint32_t rwidth, uint32_t rheight,\n                      uint32_t *raster, int stop)\n{\n    return TIFFReadRGBAImageOriented(tif, rwidth, rheight, raster,\n                                     ORIENTATION_BOTLEFT, stop);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_getimage.c",
        "metrics": {
            "nloc": 6,
            "cyclomatic_complexity": 1,
            "token_count": 37,
            "parameter_count": 5
        },
        "cve_info": [
            {
                "CVE_ID": "CVE-2019-11459",
                "Description": "The tiff_document_render() and tiff_document_get_thumbnail() functions in the TIFF document backend in GNOME Evince through 3.32.0 did not handle errors from TIFFReadRGBAImageOriented(), leading to uninitialized memory use when processing certain TIFF image files."
            }
        ],
        "cve_count": 1,
        "instruction": {
            "load_count": 3543,
            "store_count": 1657
        }
    },
    "TIFFReadRGBAStrip": {
        "source_code": "int TIFFReadRGBAStrip(TIFF *tif, uint32_t row, uint32_t *raster)\n\n{\n    return TIFFReadRGBAStripExt(tif, row, raster, 0);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_getimage.c",
        "metrics": {
            "nloc": 4,
            "cyclomatic_complexity": 1,
            "token_count": 27,
            "parameter_count": 3
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 34,
            "store_count": 18
        }
    },
    "TIFFReadRGBAStripExt": {
        "source_code": "int TIFFReadRGBAStripExt(TIFF *tif, uint32_t row, uint32_t *raster,\n                         int stop_on_error)\n\n{\n    char emsg[EMSG_BUF_SIZE] = \"\";\n    TIFFRGBAImage img;\n    int ok;\n    uint32_t rowsperstrip, rows_to_read;\n\n    if (TIFFIsTiled(tif))\n    {\n        TIFFErrorExtR(tif, TIFFFileName(tif),\n                      \"Can't use TIFFReadRGBAStrip() with tiled file.\");\n        return (0);\n    }\n\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n\n    if (rowsperstrip == 0)\n    {\n        TIFFErrorExtR(tif, TIFFFileName(tif), \"rowsperstrip is zero\");\n        return (0);\n    }\n\n    if ((row % rowsperstrip) != 0)\n    {\n        TIFFErrorExtR(\n            tif, TIFFFileName(tif),\n            \"Row passed to TIFFReadRGBAStrip() must be first in a strip.\");\n        return (0);\n    }\n\n    if (TIFFRGBAImageBegin(&img, tif, stop_on_error, emsg))\n    {\n        if (row >= img.height)\n        {\n            TIFFErrorExtR(tif, TIFFFileName(tif),\n                          \"Invalid row passed to TIFFReadRGBAStrip().\");\n            TIFFRGBAImageEnd(&img);\n            return (0);\n        }\n\n        img.row_offset = row;\n        img.col_offset = 0;\n\n        if (row + rowsperstrip > img.height)\n            rows_to_read = img.height - row;\n        else\n            rows_to_read = rowsperstrip;\n\n        ok = TIFFRGBAImageGet(&img, raster, img.width, rows_to_read);\n\n        TIFFRGBAImageEnd(&img);\n    }\n    else\n    {\n        TIFFErrorExtR(tif, TIFFFileName(tif), \"%s\", emsg);\n        ok = 0;\n    }\n\n    return (ok);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_getimage.c",
        "metrics": {
            "nloc": 51,
            "cyclomatic_complexity": 7,
            "token_count": 259,
            "parameter_count": 4
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 3992,
            "store_count": 1853
        }
    },
    "TIFFReadRGBATile": {
        "source_code": "int TIFFReadRGBATile(TIFF *tif, uint32_t col, uint32_t row, uint32_t *raster)\n\n{\n    return TIFFReadRGBATileExt(tif, col, row, raster, 0);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_getimage.c",
        "metrics": {
            "nloc": 4,
            "cyclomatic_complexity": 1,
            "token_count": 32,
            "parameter_count": 4
        },
        "cve_info": [
            {
                "CVE_ID": "CVE-2021-25291",
                "Description": "An issue was discovered in Pillow before 8.1.1. In TiffDecode.c, there is an out-of-bounds read in TiffreadRGBATile via invalid tile boundaries."
            },
            {
                "CVE_ID": "CVE-2022-3970",
                "Description": "A vulnerability was found in LibTIFF. It has been classified as critical. This affects the function TIFFReadRGBATileExt of the file libtiff/tif_getimage.c. The manipulation leads to integer overflow. It is possible to initiate the attack remotely. The exploit has been disclosed to the public and may be used. The name of the patch is 227500897dfb07fb7d27f7aa570050e62617e3be. It is recommended to apply a patch to fix this issue. The identifier VDB-213549 was assigned to this vulnerability."
            },
            {
                "CVE_ID": "CVE-2023-52356",
                "Description": "A segment fault (SEGV) flaw was found in libtiff that could be triggered by passing a crafted tiff file to the TIFFReadRGBATileExt() API. This flaw allows a remote attacker to cause a heap-buffer overflow, leading to a denial of service."
            }
        ],
        "cve_count": 3,
        "instruction": {
            "load_count": 81,
            "store_count": 27
        }
    },
    "TIFFReadRGBATileExt": {
        "source_code": "int TIFFReadRGBATileExt(TIFF *tif, uint32_t col, uint32_t row, uint32_t *raster,\n                        int stop_on_error)\n{\n    char emsg[EMSG_BUF_SIZE] = \"\";\n    TIFFRGBAImage img;\n    int ok;\n    uint32_t tile_xsize, tile_ysize;\n    uint32_t read_xsize, read_ysize;\n    uint32_t i_row;\n\n    /*\n     * Verify that our request is legal - on a tile file, and on a\n     * tile boundary.\n     */\n\n    if (!TIFFIsTiled(tif))\n    {\n        TIFFErrorExtR(tif, TIFFFileName(tif),\n                      \"Can't use TIFFReadRGBATile() with striped file.\");\n        return (0);\n    }\n\n    TIFFGetFieldDefaulted(tif, TIFFTAG_TILEWIDTH, &tile_xsize);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_TILELENGTH, &tile_ysize);\n    if (tile_xsize == 0 || tile_ysize == 0)\n    {\n        TIFFErrorExtR(tif, TIFFFileName(tif),\n                      \"tile_xsize or tile_ysize is zero\");\n        return (0);\n    }\n\n    if ((col % tile_xsize) != 0 || (row % tile_ysize) != 0)\n    {\n        TIFFErrorExtR(tif, TIFFFileName(tif),\n                      \"Row/col passed to TIFFReadRGBATile() must be top\"\n                      \"left corner of a tile.\");\n        return (0);\n    }\n\n    /*\n     * Setup the RGBA reader.\n     */\n\n    if (!TIFFRGBAImageBegin(&img, tif, stop_on_error, emsg))\n    {\n        TIFFErrorExtR(tif, TIFFFileName(tif), \"%s\", emsg);\n        return (0);\n    }\n\n    if (col >= img.width || row >= img.height)\n    {\n        TIFFErrorExtR(tif, TIFFFileName(tif),\n                      \"Invalid row/col passed to TIFFReadRGBATile().\");\n        TIFFRGBAImageEnd(&img);\n        return (0);\n    }\n\n    /*\n     * The TIFFRGBAImageGet() function doesn't allow us to get off the\n     * edge of the image, even to fill an otherwise valid tile.  So we\n     * figure out how much we can read, and fix up the tile buffer to\n     * a full tile configuration afterwards.\n     */\n\n    if (row + tile_ysize > img.height)\n        read_ysize = img.height - row;\n    else\n        read_ysize = tile_ysize;\n\n    if (col + tile_xsize > img.width)\n        read_xsize = img.width - col;\n    else\n        read_xsize = tile_xsize;\n\n    /*\n     * Read the chunk of imagery.\n     */\n\n    img.row_offset = row;\n    img.col_offset = col;\n\n    ok = TIFFRGBAImageGet(&img, raster, read_xsize, read_ysize);\n\n    TIFFRGBAImageEnd(&img);\n\n    /*\n     * If our read was incomplete we will need to fix up the tile by\n     * shifting the data around as if a full tile of data is being returned.\n     *\n     * This is all the more complicated because the image is organized in\n     * bottom to top format.\n     */\n\n    if (read_xsize == tile_xsize && read_ysize == tile_ysize)\n        return (ok);\n\n    for (i_row = 0; i_row < read_ysize; i_row++)\n    {\n        memmove(raster + (size_t)(tile_ysize - i_row - 1) * tile_xsize,\n                raster + (size_t)(read_ysize - i_row - 1) * read_xsize,\n                read_xsize * sizeof(uint32_t));\n        _TIFFmemset(raster + (size_t)(tile_ysize - i_row - 1) * tile_xsize +\n                        read_xsize,\n                    0, sizeof(uint32_t) * (tile_xsize - read_xsize));\n    }\n\n    for (i_row = read_ysize; i_row < tile_ysize; i_row++)\n    {\n        _TIFFmemset(raster + (size_t)(tile_ysize - i_row - 1) * tile_xsize, 0,\n                    sizeof(uint32_t) * tile_xsize);\n    }\n\n    return (ok);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_getimage.c",
        "metrics": {
            "nloc": 72,
            "cyclomatic_complexity": 15,
            "token_count": 465,
            "parameter_count": 5
        },
        "cve_info": [
            {
                "CVE_ID": "CVE-2022-3970",
                "Description": "A vulnerability was found in LibTIFF. It has been classified as critical. This affects the function TIFFReadRGBATileExt of the file libtiff/tif_getimage.c. The manipulation leads to integer overflow. It is possible to initiate the attack remotely. The exploit has been disclosed to the public and may be used. The name of the patch is 227500897dfb07fb7d27f7aa570050e62617e3be. It is recommended to apply a patch to fix this issue. The identifier VDB-213549 was assigned to this vulnerability."
            },
            {
                "CVE_ID": "CVE-2023-52356",
                "Description": "A segment fault (SEGV) flaw was found in libtiff that could be triggered by passing a crafted tiff file to the TIFFReadRGBATileExt() API. This flaw allows a remote attacker to cause a heap-buffer overflow, leading to a denial of service."
            }
        ],
        "cve_count": 2,
        "instruction": {
            "load_count": 4413,
            "store_count": 2051
        }
    },
    "TIFFReadDirectory": {
        "source_code": "int TIFFReadDirectory(TIFF *tif)\n{\n    static const char module[] = \"TIFFReadDirectory\";\n    TIFFDirEntry *dir;\n    uint16_t dircount;\n    TIFFDirEntry *dp;\n    uint16_t di;\n    const TIFFField *fip;\n    uint32_t fii = FAILED_FII;\n    toff_t nextdiroff;\n    int bitspersample_read = FALSE;\n    int color_channels;\n\n    if (tif->tif_nextdiroff == 0)\n    {\n        /* In this special case, tif_diroff needs also to be set to 0.\n         * This is behind the last IFD, thus no checking or reading necessary.\n         */\n        tif->tif_diroff = tif->tif_nextdiroff;\n        return 0;\n    }\n\n    nextdiroff = tif->tif_nextdiroff;\n    /* tif_curdir++ and tif_nextdiroff should only be updated after SUCCESSFUL\n     * reading of the directory. Otherwise, invalid IFD offsets could corrupt\n     * the IFD list. */\n    if (!_TIFFCheckDirNumberAndOffset(tif,\n                                      tif->tif_curdir ==\n                                              TIFF_NON_EXISTENT_DIR_NUMBER\n                                          ? 0\n                                          : tif->tif_curdir + 1,\n                                      nextdiroff))\n    {\n        return 0; /* bad offset (IFD looping or more than TIFF_MAX_DIR_COUNT\n                     IFDs) */\n    }\n    dircount = TIFFFetchDirectory(tif, nextdiroff, &dir, &tif->tif_nextdiroff);\n    if (!dircount)\n    {\n        TIFFErrorExtR(tif, module,\n                      \"Failed to read directory at offset %\" PRIu64,\n                      nextdiroff);\n        return 0;\n    }\n    /* Set global values after a valid directory has been fetched.\n     * tif_diroff is already set to nextdiroff in TIFFFetchDirectory() in the\n     * beginning. */\n    if (tif->tif_curdir == TIFF_NON_EXISTENT_DIR_NUMBER)\n        tif->tif_curdir = 0;\n    else\n        tif->tif_curdir++;\n\n    TIFFReadDirectoryCheckOrder(tif, dir, dircount);\n\n    /*\n     * Mark duplicates of any tag to be ignored (bugzilla 1994)\n     * to avoid certain pathological problems.\n     */\n    {\n        TIFFDirEntry *ma;\n        uint16_t mb;\n        for (ma = dir, mb = 0; mb < dircount; ma++, mb++)\n        {\n            TIFFDirEntry *na;\n            uint16_t nb;\n            for (na = ma + 1, nb = mb + 1; nb < dircount; na++, nb++)\n            {\n                if (ma->tdir_tag == na->tdir_tag)\n                {\n                    na->tdir_ignore = TRUE;\n                }\n            }\n        }\n    }\n\n    tif->tif_flags &= ~TIFF_BEENWRITING; /* reset before new dir */\n    tif->tif_flags &= ~TIFF_BUF4WRITE;   /* reset before new dir */\n    tif->tif_flags &= ~TIFF_CHOPPEDUPARRAYS;\n\n    /* free any old stuff and reinit */\n    (*tif->tif_cleanup)(tif); /* cleanup any previous compression state */\n    TIFFFreeDirectory(tif);\n    TIFFDefaultDirectory(tif);\n\n    /* After setup a fresh directory indicate that now active IFD is also\n     * present on file, even if its entries could not be read successfully\n     * below.  */\n    tif->tif_dir.td_iswrittentofile = TRUE;\n\n    /* Allocate arrays for offset values outside IFD entry for IFD data size\n     * checking. Note: Counter are reset within TIFFFreeDirectory(). */\n    tif->tif_dir.td_dirdatasize_offsets =\n        (TIFFEntryOffsetAndLength *)_TIFFmallocExt(\n            tif, dircount * sizeof(TIFFEntryOffsetAndLength));\n    if (tif->tif_dir.td_dirdatasize_offsets == NULL)\n    {\n        TIFFErrorExtR(\n            tif, module,\n            \"Failed to allocate memory for counting IFD data size at reading\");\n        goto bad;\n    }\n    /*\n     * Electronic Arts writes gray-scale TIFF files\n     * without a PlanarConfiguration directory entry.\n     * Thus we setup a default value here, even though\n     * the TIFF spec says there is no default value.\n     * After PlanarConfiguration is preset in TIFFDefaultDirectory()\n     * the following setting is not needed, but does not harm either.\n     */\n    TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    /*\n     * Setup default value and then make a pass over\n     * the fields to check type and tag information,\n     * and to extract info required to size data\n     * structures.  A second pass is made afterwards\n     * to read in everything not taken in the first pass.\n     * But we must process the Compression tag first\n     * in order to merge in codec-private tag definitions (otherwise\n     * we may get complaints about unknown tags).  However, the\n     * Compression tag may be dependent on the SamplesPerPixel\n     * tag value because older TIFF specs permitted Compression\n     * to be written as a SamplesPerPixel-count tag entry.\n     * Thus if we don't first figure out the correct SamplesPerPixel\n     * tag value then we may end up ignoring the Compression tag\n     * value because it has an incorrect count value (if the\n     * true value of SamplesPerPixel is not 1).\n     */\n    dp =\n        TIFFReadDirectoryFindEntry(tif, dir, dircount, TIFFTAG_SAMPLESPERPIXEL);\n    if (dp)\n    {\n        if (!TIFFFetchNormalTag(tif, dp, 0))\n            goto bad;\n        dp->tdir_ignore = TRUE;\n    }\n    dp = TIFFReadDirectoryFindEntry(tif, dir, dircount, TIFFTAG_COMPRESSION);\n    if (dp)\n    {\n        /*\n         * The 5.0 spec says the Compression tag has one value, while\n         * earlier specs say it has one value per sample.  Because of\n         * this, we accept the tag if one value is supplied with either\n         * count.\n         */\n        uint16_t value;\n        enum TIFFReadDirEntryErr err;\n        err = TIFFReadDirEntryShort(tif, dp, &value);\n        if (err == TIFFReadDirEntryErrCount)\n            err = TIFFReadDirEntryPersampleShort(tif, dp, &value);\n        if (err != TIFFReadDirEntryErrOk)\n        {\n            TIFFReadDirEntryOutputErr(tif, err, module, \"Compression\", 0);\n            goto bad;\n        }\n        if (!TIFFSetField(tif, TIFFTAG_COMPRESSION, value))\n            goto bad;\n        dp->tdir_ignore = TRUE;\n    }\n    else\n    {\n        if (!TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_NONE))\n            goto bad;\n    }\n    /*\n     * First real pass over the directory.\n     */\n    for (di = 0, dp = dir; di < dircount; di++, dp++)\n    {\n        if (!dp->tdir_ignore)\n        {\n            TIFFReadDirectoryFindFieldInfo(tif, dp->tdir_tag, &fii);\n            if (fii == FAILED_FII)\n            {\n                if (tif->tif_warn_about_unknown_tags)\n                {\n                    TIFFWarningExtR(tif, module,\n                                    \"Unknown field with tag %\" PRIu16\n                                    \" (0x%\" PRIx16 \") encountered\",\n                                    dp->tdir_tag, dp->tdir_tag);\n                }\n                /* the following knowingly leaks the\n                   anonymous field structure */\n                const TIFFField *fld = _TIFFCreateAnonField(\n                    tif, dp->tdir_tag, (TIFFDataType)dp->tdir_type);\n                if (fld == NULL || !_TIFFMergeFields(tif, fld, 1))\n                {\n                    TIFFWarningExtR(\n                        tif, module,\n                        \"Registering anonymous field with tag %\" PRIu16\n                        \" (0x%\" PRIx16 \") failed\",\n                        dp->tdir_tag, dp->tdir_tag);\n                    dp->tdir_ignore = TRUE;\n                }\n                else\n                {\n                    TIFFReadDirectoryFindFieldInfo(tif, dp->tdir_tag, &fii);\n                    assert(fii != FAILED_FII);\n                }\n            }\n        }\n        if (!dp->tdir_ignore)\n        {\n            fip = tif->tif_fields[fii];\n            if (fip->field_bit == FIELD_IGNORE)\n                dp->tdir_ignore = TRUE;\n            else\n            {\n                switch (dp->tdir_tag)\n                {\n                    case TIFFTAG_STRIPOFFSETS:\n                    case TIFFTAG_STRIPBYTECOUNTS:\n                    case TIFFTAG_TILEOFFSETS:\n                    case TIFFTAG_TILEBYTECOUNTS:\n                        TIFFSetFieldBit(tif, fip->field_bit);\n                        break;\n                    case TIFFTAG_IMAGEWIDTH:\n                    case TIFFTAG_IMAGELENGTH:\n                    case TIFFTAG_IMAGEDEPTH:\n                    case TIFFTAG_TILELENGTH:\n                    case TIFFTAG_TILEWIDTH:\n                    case TIFFTAG_TILEDEPTH:\n                    case TIFFTAG_PLANARCONFIG:\n                    case TIFFTAG_ROWSPERSTRIP:\n                    case TIFFTAG_EXTRASAMPLES:\n                        if (!TIFFFetchNormalTag(tif, dp, 0))\n                            goto bad;\n                        dp->tdir_ignore = TRUE;\n                        break;\n                    default:\n                        if (!_TIFFCheckFieldIsValidForCodec(tif, dp->tdir_tag))\n                            dp->tdir_ignore = TRUE;\n                        break;\n                }\n            }\n        }\n    }\n    /*\n     * XXX: OJPEG hack.\n     * If a) compression is OJPEG, b) planarconfig tag says it's separate,\n     * c) strip offsets/bytecounts tag are both present and\n     * d) both contain exactly one value, then we consistently find\n     * that the buggy implementation of the buggy compression scheme\n     * matches contig planarconfig best. So we 'fix-up' the tag here\n     */\n    if ((tif->tif_dir.td_compression == COMPRESSION_OJPEG) &&\n        (tif->tif_dir.td_planarconfig == PLANARCONFIG_SEPARATE))\n    {\n        if (!_TIFFFillStriles(tif))\n            goto bad;\n        dp = TIFFReadDirectoryFindEntry(tif, dir, dircount,\n                                        TIFFTAG_STRIPOFFSETS);\n        if ((dp != 0) && (dp->tdir_count == 1))\n        {\n            dp = TIFFReadDirectoryFindEntry(tif, dir, dircount,\n                                            TIFFTAG_STRIPBYTECOUNTS);\n            if ((dp != 0) && (dp->tdir_count == 1))\n            {\n                tif->tif_dir.td_planarconfig = PLANARCONFIG_CONTIG;\n                TIFFWarningExtR(tif, module,\n                                \"Planarconfig tag value assumed incorrect, \"\n                                \"assuming data is contig instead of chunky\");\n            }\n        }\n    }\n    /*\n     * Allocate directory structure and setup defaults.\n     */\n    if (!TIFFFieldSet(tif, FIELD_IMAGEDIMENSIONS))\n    {\n        MissingRequired(tif, \"ImageLength\");\n        goto bad;\n    }\n\n    /*\n     * Second pass: extract other information.\n     */\n    for (di = 0, dp = dir; di < dircount; di++, dp++)\n    {\n        if (!dp->tdir_ignore)\n        {\n            switch (dp->tdir_tag)\n            {\n                case TIFFTAG_MINSAMPLEVALUE:\n                case TIFFTAG_MAXSAMPLEVALUE:\n                case TIFFTAG_BITSPERSAMPLE:\n                case TIFFTAG_DATATYPE:\n                case TIFFTAG_SAMPLEFORMAT:\n                    /*\n                     * The MinSampleValue, MaxSampleValue, BitsPerSample\n                     * DataType and SampleFormat tags are supposed to be\n                     * written as one value/sample, but some vendors\n                     * incorrectly write one value only -- so we accept\n                     * that as well (yuck). Other vendors write correct\n                     * value for NumberOfSamples, but incorrect one for\n                     * BitsPerSample and friends, and we will read this\n                     * too.\n                     */\n                    {\n                        uint16_t value;\n                        enum TIFFReadDirEntryErr err;\n                        err = TIFFReadDirEntryShort(tif, dp, &value);\n                        if (!EvaluateIFDdatasizeReading(tif, dp))\n                            goto bad;\n                        if (err == TIFFReadDirEntryErrCount)\n                            err =\n                                TIFFReadDirEntryPersampleShort(tif, dp, &value);\n                        if (err != TIFFReadDirEntryErrOk)\n                        {\n                            fip = TIFFFieldWithTag(tif, dp->tdir_tag);\n                            TIFFReadDirEntryOutputErr(\n                                tif, err, module,\n                                fip ? fip->field_name : \"unknown tagname\", 0);\n                            goto bad;\n                        }\n                        if (!TIFFSetField(tif, dp->tdir_tag, value))\n                            goto bad;\n                        if (dp->tdir_tag == TIFFTAG_BITSPERSAMPLE)\n                            bitspersample_read = TRUE;\n                    }\n                    break;\n                case TIFFTAG_SMINSAMPLEVALUE:\n                case TIFFTAG_SMAXSAMPLEVALUE:\n                {\n\n                    double *data = NULL;\n                    enum TIFFReadDirEntryErr err;\n                    uint32_t saved_flags;\n                    int m;\n                    if (dp->tdir_count !=\n                        (uint64_t)tif->tif_dir.td_samplesperpixel)\n                        err = TIFFReadDirEntryErrCount;\n                    else\n                        err = TIFFReadDirEntryDoubleArray(tif, dp, &data);\n                    if (!EvaluateIFDdatasizeReading(tif, dp))\n                        goto bad;\n                    if (err != TIFFReadDirEntryErrOk)\n                    {\n                        fip = TIFFFieldWithTag(tif, dp->tdir_tag);\n                        TIFFReadDirEntryOutputErr(\n                            tif, err, module,\n                            fip ? fip->field_name : \"unknown tagname\", 0);\n                        goto bad;\n                    }\n                    saved_flags = tif->tif_flags;\n                    tif->tif_flags |= TIFF_PERSAMPLE;\n                    m = TIFFSetField(tif, dp->tdir_tag, data);\n                    tif->tif_flags = saved_flags;\n                    _TIFFfreeExt(tif, data);\n                    if (!m)\n                        goto bad;\n                }\n                break;\n                case TIFFTAG_STRIPOFFSETS:\n                case TIFFTAG_TILEOFFSETS:\n                {\n                    switch (dp->tdir_type)\n                    {\n                        case TIFF_SHORT:\n                        case TIFF_LONG:\n                        case TIFF_LONG8:\n                            break;\n                        default:\n                            /* Warn except if directory typically created with\n                             * TIFFDeferStrileArrayWriting() */\n                            if (!(tif->tif_mode == O_RDWR &&\n                                  dp->tdir_count == 0 && dp->tdir_type == 0 &&\n                                  dp->tdir_offset.toff_long8 == 0))\n                            {\n                                fip = TIFFFieldWithTag(tif, dp->tdir_tag);\n                                TIFFWarningExtR(\n                                    tif, module, \"Invalid data type for tag %s\",\n                                    fip ? fip->field_name : \"unknown tagname\");\n                            }\n                            break;\n                    }\n                    _TIFFmemcpy(&(tif->tif_dir.td_stripoffset_entry), dp,\n                                sizeof(TIFFDirEntry));\n                    if (!EvaluateIFDdatasizeReading(tif, dp))\n                        goto bad;\n                }\n                break;\n                case TIFFTAG_STRIPBYTECOUNTS:\n                case TIFFTAG_TILEBYTECOUNTS:\n                {\n                    switch (dp->tdir_type)\n                    {\n                        case TIFF_SHORT:\n                        case TIFF_LONG:\n                        case TIFF_LONG8:\n                            break;\n                        default:\n                            /* Warn except if directory typically created with\n                             * TIFFDeferStrileArrayWriting() */\n                            if (!(tif->tif_mode == O_RDWR &&\n                                  dp->tdir_count == 0 && dp->tdir_type == 0 &&\n                                  dp->tdir_offset.toff_long8 == 0))\n                            {\n                                fip = TIFFFieldWithTag(tif, dp->tdir_tag);\n                                TIFFWarningExtR(\n                                    tif, module, \"Invalid data type for tag %s\",\n                                    fip ? fip->field_name : \"unknown tagname\");\n                            }\n                            break;\n                    }\n                    _TIFFmemcpy(&(tif->tif_dir.td_stripbytecount_entry), dp,\n                                sizeof(TIFFDirEntry));\n                    if (!EvaluateIFDdatasizeReading(tif, dp))\n                        goto bad;\n                }\n                break;\n                case TIFFTAG_COLORMAP:\n                case TIFFTAG_TRANSFERFUNCTION:\n                {\n                    enum TIFFReadDirEntryErr err;\n                    uint32_t countpersample;\n                    uint32_t countrequired;\n                    uint32_t incrementpersample;\n                    uint16_t *value = NULL;\n                    /* It would be dangerous to instantiate those tag values */\n                    /* since if td_bitspersample has not yet been read (due to\n                     */\n                    /* unordered tags), it could be read afterwards with a */\n                    /* values greater than the default one (1), which may cause\n                     */\n                    /* crashes in user code */\n                    if (!bitspersample_read)\n                    {\n                        fip = TIFFFieldWithTag(tif, dp->tdir_tag);\n                        TIFFWarningExtR(\n                            tif, module,\n                            \"Ignoring %s since BitsPerSample tag not found\",\n                            fip ? fip->field_name : \"unknown tagname\");\n                        continue;\n                    }\n                    /* ColorMap or TransferFunction for high bit */\n                    /* depths do not make much sense and could be */\n                    /* used as a denial of service vector */\n                    if (tif->tif_dir.td_bitspersample > 24)\n                    {\n                        fip = TIFFFieldWithTag(tif, dp->tdir_tag);\n                        TIFFWarningExtR(\n                            tif, module,\n                            \"Ignoring %s because BitsPerSample=%\" PRIu16 \">24\",\n                            fip ? fip->field_name : \"unknown tagname\",\n                            tif->tif_dir.td_bitspersample);\n                        continue;\n                    }\n                    countpersample = (1U << tif->tif_dir.td_bitspersample);\n                    if ((dp->tdir_tag == TIFFTAG_TRANSFERFUNCTION) &&\n                        (dp->tdir_count == (uint64_t)countpersample))\n                    {\n                        countrequired = countpersample;\n                        incrementpersample = 0;\n                    }\n                    else\n                    {\n                        countrequired = 3 * countpersample;\n                        incrementpersample = countpersample;\n                    }\n                    if (dp->tdir_count != (uint64_t)countrequired)\n                        err = TIFFReadDirEntryErrCount;\n                    else\n                        err = TIFFReadDirEntryShortArray(tif, dp, &value);\n                    if (!EvaluateIFDdatasizeReading(tif, dp))\n                        goto bad;\n                    if (err != TIFFReadDirEntryErrOk)\n                    {\n                        fip = TIFFFieldWithTag(tif, dp->tdir_tag);\n                        TIFFReadDirEntryOutputErr(\n                            tif, err, module,\n                            fip ? fip->field_name : \"unknown tagname\", 1);\n                    }\n                    else\n                    {\n                        TIFFSetField(tif, dp->tdir_tag, value,\n                                     value + incrementpersample,\n                                     value + 2 * incrementpersample);\n                        _TIFFfreeExt(tif, value);\n                    }\n                }\n                break;\n                    /* BEGIN REV 4.0 COMPATIBILITY */\n                case TIFFTAG_OSUBFILETYPE:\n                {\n                    uint16_t valueo;\n                    uint32_t value;\n                    if (TIFFReadDirEntryShort(tif, dp, &valueo) ==\n                        TIFFReadDirEntryErrOk)\n                    {\n                        switch (valueo)\n                        {\n                            case OFILETYPE_REDUCEDIMAGE:\n                                value = FILETYPE_REDUCEDIMAGE;\n                                break;\n                            case OFILETYPE_PAGE:\n                                value = FILETYPE_PAGE;\n                                break;\n                            default:\n                                value = 0;\n                                break;\n                        }\n                        if (value != 0)\n                            TIFFSetField(tif, TIFFTAG_SUBFILETYPE, value);\n                    }\n                }\n                break;\n                /* END REV 4.0 COMPATIBILITY */\n#if 0\n                case TIFFTAG_EP_BATTERYLEVEL:\n                    /* TIFFTAG_EP_BATTERYLEVEL can be RATIONAL or ASCII.\n                     * LibTiff defines it as ASCII and converts RATIONAL to an\n                     * ASCII string. */\n                    switch (dp->tdir_type)\n                    {\n                        case TIFF_RATIONAL:\n                        {\n                            /* Read rational and convert to ASCII*/\n                            enum TIFFReadDirEntryErr err;\n                            TIFFRational_t rValue;\n                            err = TIFFReadDirEntryCheckedRationalDirect(\n                                tif, dp, &rValue);\n                            if (err != TIFFReadDirEntryErrOk)\n                            {\n                                fip = TIFFFieldWithTag(tif, dp->tdir_tag);\n                                TIFFReadDirEntryOutputErr(\n                                    tif, err, module,\n                                    fip ? fip->field_name : \"unknown tagname\",\n                                    1);\n                            }\n                            else\n                            {\n                                char szAux[32];\n                                snprintf(szAux, sizeof(szAux) - 1, \"%d/%d\",\n                                         rValue.uNum, rValue.uDenom);\n                                TIFFSetField(tif, dp->tdir_tag, szAux);\n                            }\n                        }\n                        break;\n                        case TIFF_ASCII:\n                            (void)TIFFFetchNormalTag(tif, dp, TRUE);\n                            break;\n                        default:\n                            fip = TIFFFieldWithTag(tif, dp->tdir_tag);\n                            TIFFWarningExtR(tif, module,\n                                            \"Invalid data type for tag %s. \"\n                                            \"ASCII or RATIONAL expected\",\n                                            fip ? fip->field_name\n                                                : \"unknown tagname\");\n                            break;\n                    }\n                    break;\n#endif\n                default:\n                    (void)TIFFFetchNormalTag(tif, dp, TRUE);\n                    break;\n            } /* -- switch (dp->tdir_tag) -- */\n        }     /* -- if (!dp->tdir_ignore) */\n    }         /* -- for-loop -- */\n\n    /* Evaluate final IFD data size. */\n    CalcFinalIFDdatasizeReading(tif, dircount);\n\n    /*\n     * OJPEG hack:\n     * - If a) compression is OJPEG, and b) photometric tag is missing,\n     * then we consistently find that photometric should be YCbCr\n     * - If a) compression is OJPEG, and b) photometric tag says it's RGB,\n     * then we consistently find that the buggy implementation of the\n     * buggy compression scheme matches photometric YCbCr instead.\n     * - If a) compression is OJPEG, and b) bitspersample tag is missing,\n     * then we consistently find bitspersample should be 8.\n     * - If a) compression is OJPEG, b) samplesperpixel tag is missing,\n     * and c) photometric is RGB or YCbCr, then we consistently find\n     * samplesperpixel should be 3\n     * - If a) compression is OJPEG, b) samplesperpixel tag is missing,\n     * and c) photometric is MINISWHITE or MINISBLACK, then we consistently\n     * find samplesperpixel should be 3\n     */\n    if (tif->tif_dir.td_compression == COMPRESSION_OJPEG)\n    {\n        if (!TIFFFieldSet(tif, FIELD_PHOTOMETRIC))\n        {\n            TIFFWarningExtR(\n                tif, module,\n                \"Photometric tag is missing, assuming data is YCbCr\");\n            if (!TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR))\n                goto bad;\n        }\n        else if (tif->tif_dir.td_photometric == PHOTOMETRIC_RGB)\n        {\n            tif->tif_dir.td_photometric = PHOTOMETRIC_YCBCR;\n            TIFFWarningExtR(tif, module,\n                            \"Photometric tag value assumed incorrect, \"\n                            \"assuming data is YCbCr instead of RGB\");\n        }\n        if (!TIFFFieldSet(tif, FIELD_BITSPERSAMPLE))\n        {\n            TIFFWarningExtR(\n                tif, module,\n                \"BitsPerSample tag is missing, assuming 8 bits per sample\");\n            if (!TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8))\n                goto bad;\n        }\n        if (!TIFFFieldSet(tif, FIELD_SAMPLESPERPIXEL))\n        {\n            if (tif->tif_dir.td_photometric == PHOTOMETRIC_RGB)\n            {\n                TIFFWarningExtR(tif, module,\n                                \"SamplesPerPixel tag is missing, \"\n                                \"assuming correct SamplesPerPixel value is 3\");\n                if (!TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 3))\n                    goto bad;\n            }\n            if (tif->tif_dir.td_photometric == PHOTOMETRIC_YCBCR)\n            {\n                TIFFWarningExtR(tif, module,\n                                \"SamplesPerPixel tag is missing, \"\n                                \"applying correct SamplesPerPixel value of 3\");\n                if (!TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 3))\n                    goto bad;\n            }\n            else if ((tif->tif_dir.td_photometric == PHOTOMETRIC_MINISWHITE) ||\n                     (tif->tif_dir.td_photometric == PHOTOMETRIC_MINISBLACK))\n            {\n                /*\n                 * SamplesPerPixel tag is missing, but is not required\n                 * by spec.  Assume correct SamplesPerPixel value of 1.\n                 */\n                if (!TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 1))\n                    goto bad;\n            }\n        }\n    }\n\n    /*\n     * Setup appropriate structures (by strip or by tile)\n     * We do that only after the above OJPEG hack which alters SamplesPerPixel\n     * and thus influences the number of strips in the separate planarconfig.\n     */\n    if (!TIFFFieldSet(tif, FIELD_TILEDIMENSIONS))\n    {\n        tif->tif_dir.td_nstrips = TIFFNumberOfStrips(tif);\n        tif->tif_dir.td_tilewidth = tif->tif_dir.td_imagewidth;\n        tif->tif_dir.td_tilelength = tif->tif_dir.td_rowsperstrip;\n        tif->tif_dir.td_tiledepth = tif->tif_dir.td_imagedepth;\n        tif->tif_flags &= ~TIFF_ISTILED;\n    }\n    else\n    {\n        tif->tif_dir.td_nstrips = TIFFNumberOfTiles(tif);\n        tif->tif_flags |= TIFF_ISTILED;\n    }\n    if (!tif->tif_dir.td_nstrips)\n    {\n        TIFFErrorExtR(tif, module, \"Cannot handle zero number of %s\",\n                      isTiled(tif) ? \"tiles\" : \"strips\");\n        goto bad;\n    }\n    tif->tif_dir.td_stripsperimage = tif->tif_dir.td_nstrips;\n    if (tif->tif_dir.td_planarconfig == PLANARCONFIG_SEPARATE)\n        tif->tif_dir.td_stripsperimage /= tif->tif_dir.td_samplesperpixel;\n    if (!TIFFFieldSet(tif, FIELD_STRIPOFFSETS))\n    {\n#ifdef OJPEG_SUPPORT\n        if ((tif->tif_dir.td_compression == COMPRESSION_OJPEG) &&\n            (isTiled(tif) == 0) && (tif->tif_dir.td_nstrips == 1))\n        {\n            /*\n             * XXX: OJPEG hack.\n             * If a) compression is OJPEG, b) it's not a tiled TIFF,\n             * and c) the number of strips is 1,\n             * then we tolerate the absence of stripoffsets tag,\n             * because, presumably, all required data is in the\n             * JpegInterchangeFormat stream.\n             */\n            TIFFSetFieldBit(tif, FIELD_STRIPOFFSETS);\n        }\n        else\n#endif\n        {\n            MissingRequired(tif, isTiled(tif) ? \"TileOffsets\" : \"StripOffsets\");\n            goto bad;\n        }\n    }\n\n    if (tif->tif_mode == O_RDWR &&\n        tif->tif_dir.td_stripoffset_entry.tdir_tag != 0 &&\n        tif->tif_dir.td_stripoffset_entry.tdir_count == 0 &&\n        tif->tif_dir.td_stripoffset_entry.tdir_type == 0 &&\n        tif->tif_dir.td_stripoffset_entry.tdir_offset.toff_long8 == 0 &&\n        tif->tif_dir.td_stripbytecount_entry.tdir_tag != 0 &&\n        tif->tif_dir.td_stripbytecount_entry.tdir_count == 0 &&\n        tif->tif_dir.td_stripbytecount_entry.tdir_type == 0 &&\n        tif->tif_dir.td_stripbytecount_entry.tdir_offset.toff_long8 == 0)\n    {\n        /* Directory typically created with TIFFDeferStrileArrayWriting() */\n        TIFFSetupStrips(tif);\n    }\n    else if (!(tif->tif_flags & TIFF_DEFERSTRILELOAD))\n    {\n        if (tif->tif_dir.td_stripoffset_entry.tdir_tag != 0)\n        {\n            if (!TIFFFetchStripThing(tif, &(tif->tif_dir.td_stripoffset_entry),\n                                     tif->tif_dir.td_nstrips,\n                                     &tif->tif_dir.td_stripoffset_p))\n            {\n                goto bad;\n            }\n        }\n        if (tif->tif_dir.td_stripbytecount_entry.tdir_tag != 0)\n        {\n            if (!TIFFFetchStripThing(\n                    tif, &(tif->tif_dir.td_stripbytecount_entry),\n                    tif->tif_dir.td_nstrips, &tif->tif_dir.td_stripbytecount_p))\n            {\n                goto bad;\n            }\n        }\n    }\n\n    /*\n     * Make sure all non-color channels are extrasamples.\n     * If it's not the case, define them as such.\n     */\n    color_channels = _TIFFGetMaxColorChannels(tif->tif_dir.td_photometric);\n    if (color_channels &&\n        tif->tif_dir.td_samplesperpixel - tif->tif_dir.td_extrasamples >\n            color_channels)\n    {\n        uint16_t old_extrasamples;\n        uint16_t *new_sampleinfo;\n\n        TIFFWarningExtR(\n            tif, module,\n            \"Sum of Photometric type-related \"\n            \"color channels and ExtraSamples doesn't match SamplesPerPixel. \"\n            \"Defining non-color channels as ExtraSamples.\");\n\n        old_extrasamples = tif->tif_dir.td_extrasamples;\n        tif->tif_dir.td_extrasamples =\n            (uint16_t)(tif->tif_dir.td_samplesperpixel - color_channels);\n\n        // sampleinfo should contain information relative to these new extra\n        // samples\n        new_sampleinfo = (uint16_t *)_TIFFcallocExt(\n            tif, tif->tif_dir.td_extrasamples, sizeof(uint16_t));\n        if (!new_sampleinfo)\n        {\n            TIFFErrorExtR(tif, module,\n                          \"Failed to allocate memory for \"\n                          \"temporary new sampleinfo array \"\n                          \"(%\" PRIu16 \" 16 bit elements)\",\n                          tif->tif_dir.td_extrasamples);\n            goto bad;\n        }\n\n        if (old_extrasamples > 0)\n            memcpy(new_sampleinfo, tif->tif_dir.td_sampleinfo,\n                   old_extrasamples * sizeof(uint16_t));\n        _TIFFsetShortArrayExt(tif, &tif->tif_dir.td_sampleinfo, new_sampleinfo,\n                              tif->tif_dir.td_extrasamples);\n        _TIFFfreeExt(tif, new_sampleinfo);\n    }\n\n    /*\n     * Verify Palette image has a Colormap.\n     */\n    if (tif->tif_dir.td_photometric == PHOTOMETRIC_PALETTE &&\n        !TIFFFieldSet(tif, FIELD_COLORMAP))\n    {\n        if (tif->tif_dir.td_bitspersample >= 8 &&\n            tif->tif_dir.td_samplesperpixel == 3)\n            tif->tif_dir.td_photometric = PHOTOMETRIC_RGB;\n        else if (tif->tif_dir.td_bitspersample >= 8)\n            tif->tif_dir.td_photometric = PHOTOMETRIC_MINISBLACK;\n        else\n        {\n            MissingRequired(tif, \"Colormap\");\n            goto bad;\n        }\n    }\n    /*\n     * OJPEG hack:\n     * We do no further messing with strip/tile offsets/bytecounts in OJPEG\n     * TIFFs\n     */\n    if (tif->tif_dir.td_compression != COMPRESSION_OJPEG)\n    {\n        /*\n         * Attempt to deal with a missing StripByteCounts tag.\n         */\n        if (!TIFFFieldSet(tif, FIELD_STRIPBYTECOUNTS))\n        {\n            /*\n             * Some manufacturers violate the spec by not giving\n             * the size of the strips.  In this case, assume there\n             * is one uncompressed strip of data.\n             */\n            if ((tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG &&\n                 tif->tif_dir.td_nstrips > 1) ||\n                (tif->tif_dir.td_planarconfig == PLANARCONFIG_SEPARATE &&\n                 tif->tif_dir.td_nstrips !=\n                     (uint32_t)tif->tif_dir.td_samplesperpixel))\n            {\n                MissingRequired(tif, \"StripByteCounts\");\n                goto bad;\n            }\n            TIFFWarningExtR(\n                tif, module,\n                \"TIFF directory is missing required \"\n                \"\\\"StripByteCounts\\\" field, calculating from imagelength\");\n            if (EstimateStripByteCounts(tif, dir, dircount) < 0)\n                goto bad;\n        }\n        else if (tif->tif_dir.td_nstrips == 1 &&\n                 !(tif->tif_flags & TIFF_ISTILED) && ByteCountLooksBad(tif))\n        {\n            /*\n             * XXX: Plexus (and others) sometimes give a value of\n             * zero for a tag when they don't know what the\n             * correct value is!  Try and handle the simple case\n             * of estimating the size of a one strip image.\n             */\n            TIFFWarningExtR(tif, module,\n                            \"Bogus \\\"StripByteCounts\\\" field, ignoring and \"\n                            \"calculating from imagelength\");\n            if (EstimateStripByteCounts(tif, dir, dircount) < 0)\n                goto bad;\n        }\n        else if (!(tif->tif_flags & TIFF_DEFERSTRILELOAD) &&\n                 tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG &&\n                 tif->tif_dir.td_nstrips > 2 &&\n                 tif->tif_dir.td_compression == COMPRESSION_NONE &&\n                 TIFFGetStrileByteCount(tif, 0) !=\n                     TIFFGetStrileByteCount(tif, 1) &&\n                 TIFFGetStrileByteCount(tif, 0) != 0 &&\n                 TIFFGetStrileByteCount(tif, 1) != 0)\n        {\n            /*\n             * XXX: Some vendors fill StripByteCount array with\n             * absolutely wrong values (it can be equal to\n             * StripOffset array, for example). Catch this case\n             * here.\n             *\n             * We avoid this check if deferring strile loading\n             * as it would always force us to load the strip/tile\n             * information.\n             */\n            TIFFWarningExtR(tif, module,\n                            \"Wrong \\\"StripByteCounts\\\" field, ignoring and \"\n                            \"calculating from imagelength\");\n            if (EstimateStripByteCounts(tif, dir, dircount) < 0)\n                goto bad;\n        }\n    }\n    if (dir)\n    {\n        _TIFFfreeExt(tif, dir);\n        dir = NULL;\n    }\n    if (!TIFFFieldSet(tif, FIELD_MAXSAMPLEVALUE))\n    {\n        if (tif->tif_dir.td_bitspersample >= 16)\n            tif->tif_dir.td_maxsamplevalue = 0xFFFF;\n        else\n            tif->tif_dir.td_maxsamplevalue =\n                (uint16_t)((1L << tif->tif_dir.td_bitspersample) - 1);\n    }\n\n#ifdef STRIPBYTECOUNTSORTED_UNUSED\n    /*\n     * XXX: We can optimize checking for the strip bounds using the sorted\n     * bytecounts array. See also comments for TIFFAppendToStrip()\n     * function in tif_write.c.\n     */\n    if (!(tif->tif_flags & TIFF_DEFERSTRILELOAD) && tif->tif_dir.td_nstrips > 1)\n    {\n        uint32_t strip;\n\n        tif->tif_dir.td_stripbytecountsorted = 1;\n        for (strip = 1; strip < tif->tif_dir.td_nstrips; strip++)\n        {\n            if (TIFFGetStrileOffset(tif, strip - 1) >\n                TIFFGetStrileOffset(tif, strip))\n            {\n                tif->tif_dir.td_stripbytecountsorted = 0;\n                break;\n            }\n        }\n    }\n#endif\n\n    /*\n     * An opportunity for compression mode dependent tag fixup\n     */\n    (*tif->tif_fixuptags)(tif);\n\n    /*\n     * Some manufacturers make life difficult by writing\n     * large amounts of uncompressed data as a single strip.\n     * This is contrary to the recommendations of the spec.\n     * The following makes an attempt at breaking such images\n     * into strips closer to the recommended 8k bytes.  A\n     * side effect, however, is that the RowsPerStrip tag\n     * value may be changed.\n     */\n    if ((tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG) &&\n        (tif->tif_dir.td_nstrips == 1) &&\n        (tif->tif_dir.td_compression == COMPRESSION_NONE) &&\n        ((tif->tif_flags & (TIFF_STRIPCHOP | TIFF_ISTILED)) == TIFF_STRIPCHOP))\n    {\n        ChopUpSingleUncompressedStrip(tif);\n    }\n\n    /* There are also uncompressed striped files with strips larger than */\n    /* 2 GB, which make them unfriendly with a lot of code. If possible, */\n    /* try to expose smaller \"virtual\" strips. */\n    if (tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG &&\n        tif->tif_dir.td_compression == COMPRESSION_NONE &&\n        (tif->tif_flags & (TIFF_STRIPCHOP | TIFF_ISTILED)) == TIFF_STRIPCHOP &&\n        TIFFStripSize64(tif) > 0x7FFFFFFFUL)\n    {\n        TryChopUpUncompressedBigTiff(tif);\n    }\n\n    /*\n     * Clear the dirty directory flag.\n     */\n    tif->tif_flags &= ~TIFF_DIRTYDIRECT;\n    tif->tif_flags &= ~TIFF_DIRTYSTRIP;\n\n    /*\n     * Reinitialize i/o since we are starting on a new directory.\n     */\n    tif->tif_row = (uint32_t)-1;\n    tif->tif_curstrip = (uint32_t)-1;\n    tif->tif_col = (uint32_t)-1;\n    tif->tif_curtile = (uint32_t)-1;\n    tif->tif_tilesize = (tmsize_t)-1;\n\n    tif->tif_scanlinesize = TIFFScanlineSize(tif);\n    if (!tif->tif_scanlinesize)\n    {\n        TIFFErrorExtR(tif, module, \"Cannot handle zero scanline size\");\n        return (0);\n    }\n\n    if (isTiled(tif))\n    {\n        tif->tif_tilesize = TIFFTileSize(tif);\n        if (!tif->tif_tilesize)\n        {\n            TIFFErrorExtR(tif, module, \"Cannot handle zero tile size\");\n            return (0);\n        }\n    }\n    else\n    {\n        if (!TIFFStripSize(tif))\n        {\n            TIFFErrorExtR(tif, module, \"Cannot handle zero strip size\");\n            return (0);\n        }\n    }\n    return (1);\nbad:\n    if (dir)\n        _TIFFfreeExt(tif, dir);\n    return (0);\n} /*-- TIFFReadDirectory() --*/\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_dirread.c",
        "metrics": {
            "nloc": 736,
            "cyclomatic_complexity": 201,
            "token_count": 3737,
            "parameter_count": 1
        },
        "cve_info": [
            {
                "CVE_ID": "CVE-2010-2630",
                "Description": "The TIFFReadDirectory function in LibTIFF 3.9.0 does not properly validate the data types of codec-specific tags that have an out-of-order position in a TIFF file, which allows remote attackers to cause a denial of service (application crash) via a crafted file, a different vulnerability than CVE-2010-2481."
            },
            {
                "CVE_ID": "CVE-2012-2088",
                "Description": "Integer signedness error in the TIFFReadDirectory function in tif_dirread.c in libtiff 3.9.4 and earlier allows remote attackers to cause a denial of service (application crash) and possibly execute arbitrary code via a negative tile depth in a tiff image, which triggers an improper conversion between signed and unsigned types, leading to a heap-based buffer overflow."
            },
            {
                "CVE_ID": "CVE-2019-12213",
                "Description": "When FreeImage 3.18.0 reads a special TIFF file, the TIFFReadDirectory function in PluginTIFF.cpp always returns 1, leading to stack exhaustion."
            },
            {
                "CVE_ID": "CVE-2022-0562",
                "Description": "Null source pointer passed as an argument to memcpy() function within TIFFReadDirectory() in tif_dirread.c in libtiff versions from 4.0 to 4.3.0 could lead to Denial of Service via crafted TIFF file. For users that compile libtiff from sources, a fix is available with commit 561599c."
            },
            {
                "CVE_ID": "CVE-2022-40090",
                "Description": "An issue was discovered in function TIFFReadDirectory libtiff before 4.4.0 allows attackers to cause a denial of service via crafted TIFF file."
            }
        ],
        "cve_count": 5,
        "instruction": {
            "load_count": 6398,
            "store_count": 1644
        }
    },
    "TIFFReadCustomDirectory": {
        "source_code": "int TIFFReadCustomDirectory(TIFF *tif, toff_t diroff,\n                            const TIFFFieldArray *infoarray)\n{\n    static const char module[] = \"TIFFReadCustomDirectory\";\n    TIFFDirEntry *dir;\n    uint16_t dircount;\n    TIFFDirEntry *dp;\n    uint16_t di;\n    const TIFFField *fip;\n    uint32_t fii;\n\n    dircount = TIFFFetchDirectory(tif, diroff, &dir, NULL);\n    if (!dircount)\n    {\n        TIFFErrorExtR(tif, module,\n                      \"Failed to read custom directory at offset %\" PRIu64,\n                      diroff);\n        return 0;\n    }\n    TIFFReadDirectoryCheckOrder(tif, dir, dircount);\n\n    /*\n     * Mark duplicates of any tag to be ignored (bugzilla 1994)\n     * to avoid certain pathological problems.\n     */\n    {\n        TIFFDirEntry *ma;\n        uint16_t mb;\n        for (ma = dir, mb = 0; mb < dircount; ma++, mb++)\n        {\n            TIFFDirEntry *na;\n            uint16_t nb;\n            for (na = ma + 1, nb = mb + 1; nb < dircount; na++, nb++)\n            {\n                if (ma->tdir_tag == na->tdir_tag)\n                {\n                    na->tdir_ignore = TRUE;\n                }\n            }\n        }\n    }\n\n    /* Free any old stuff and reinit. */\n    (*tif->tif_cleanup)(tif); /* cleanup any previous compression state */\n    TIFFFreeDirectory(tif);\n    /* Even if custom directories do not need the default settings of a standard\n     * IFD, the pointer to the TIFFSetField() and TIFFGetField() (i.e.\n     * tif->tif_tagmethods.vsetfield and tif->tif_tagmethods.vgetfield) need to\n     * be initialized, which is done in TIFFDefaultDirectory().\n     * After that, the field array for the custom tags needs to be setup again.\n     */\n    TIFFDefaultDirectory(tif);\n    _TIFFSetupFields(tif, infoarray);\n\n    /* Allocate arrays for offset values outside IFD entry for IFD data size\n     * checking. Note: Counter are reset within TIFFFreeDirectory(). */\n    tif->tif_dir.td_dirdatasize_offsets =\n        (TIFFEntryOffsetAndLength *)_TIFFmallocExt(\n            tif, dircount * sizeof(TIFFEntryOffsetAndLength));\n    if (tif->tif_dir.td_dirdatasize_offsets == NULL)\n    {\n        TIFFErrorExtR(\n            tif, module,\n            \"Failed to allocate memory for counting IFD data size at reading\");\n        if (dir)\n            _TIFFfreeExt(tif, dir);\n        return 0;\n    }\n\n    for (di = 0, dp = dir; di < dircount; di++, dp++)\n    {\n        TIFFReadDirectoryFindFieldInfo(tif, dp->tdir_tag, &fii);\n        if (fii == FAILED_FII)\n        {\n            if (tif->tif_warn_about_unknown_tags)\n            {\n                TIFFWarningExtR(tif, module,\n                                \"Unknown field with tag %\" PRIu16 \" (0x%\" PRIx16\n                                \") encountered\",\n                                dp->tdir_tag, dp->tdir_tag);\n            }\n            const TIFFField *fld = _TIFFCreateAnonField(\n                tif, dp->tdir_tag, (TIFFDataType)dp->tdir_type);\n            if (fld == NULL || !_TIFFMergeFields(tif, fld, 1))\n            {\n                if (tif->tif_warn_about_unknown_tags)\n                {\n                    TIFFWarningExtR(\n                        tif, module,\n                        \"Registering anonymous field with tag %\" PRIu16\n                        \" (0x%\" PRIx16 \") failed\",\n                        dp->tdir_tag, dp->tdir_tag);\n                }\n                dp->tdir_ignore = TRUE;\n            }\n            else\n            {\n                TIFFReadDirectoryFindFieldInfo(tif, dp->tdir_tag, &fii);\n                assert(fii != FAILED_FII);\n            }\n        }\n        if (!dp->tdir_ignore)\n        {\n            fip = tif->tif_fields[fii];\n            if (fip->field_bit == FIELD_IGNORE)\n                dp->tdir_ignore = TRUE;\n            else\n            {\n                /* check data type */\n                while ((fip->field_type != TIFF_ANY) &&\n                       (fip->field_type != dp->tdir_type))\n                {\n                    fii++;\n                    if ((fii == tif->tif_nfields) ||\n                        (tif->tif_fields[fii]->field_tag !=\n                         (uint32_t)dp->tdir_tag))\n                    {\n                        fii = 0xFFFF;\n                        break;\n                    }\n                    fip = tif->tif_fields[fii];\n                }\n                if (fii == 0xFFFF)\n                {\n                    TIFFWarningExtR(tif, module,\n                                    \"Wrong data type %\" PRIu16\n                                    \" for \\\"%s\\\"; tag ignored\",\n                                    dp->tdir_type, fip->field_name);\n                    dp->tdir_ignore = TRUE;\n                }\n                else\n                {\n                    /* check count if known in advance */\n                    if ((fip->field_readcount != TIFF_VARIABLE) &&\n                        (fip->field_readcount != TIFF_VARIABLE2))\n                    {\n                        uint32_t expected;\n                        if (fip->field_readcount == TIFF_SPP)\n                            expected =\n                                (uint32_t)tif->tif_dir.td_samplesperpixel;\n                        else\n                            expected = (uint32_t)fip->field_readcount;\n                        if (!CheckDirCount(tif, dp, expected))\n                            dp->tdir_ignore = TRUE;\n                    }\n                }\n            }\n            if (!dp->tdir_ignore)\n            {\n                switch (dp->tdir_tag)\n                {\n                    case EXIFTAG_SUBJECTDISTANCE:\n                        if (!TIFFFieldIsAnonymous(fip))\n                        {\n                            /* should only be called on a Exif directory */\n                            /* when exifFields[] is active */\n                            (void)TIFFFetchSubjectDistance(tif, dp);\n                        }\n                        else\n                        {\n                            (void)TIFFFetchNormalTag(tif, dp, TRUE);\n                        }\n                        break;\n                    default:\n                        (void)TIFFFetchNormalTag(tif, dp, TRUE);\n                        break;\n                }\n            } /*-- if (!dp->tdir_ignore) */\n        }\n    }\n    /* Evaluate final IFD data size. */\n    CalcFinalIFDdatasizeReading(tif, dircount);\n\n    /* To be able to return from SubIFD or custom-IFD to main-IFD */\n    tif->tif_setdirectory_force_absolute = TRUE;\n    if (dir)\n        _TIFFfreeExt(tif, dir);\n    return 1;\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_dirread.c",
        "metrics": {
            "nloc": 154,
            "cyclomatic_complexity": 28,
            "token_count": 736,
            "parameter_count": 3
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 16849,
            "store_count": 7322
        }
    },
    "TIFFReadEXIFDirectory": {
        "source_code": "int TIFFReadEXIFDirectory(TIFF *tif, toff_t diroff)\n{\n    return TIFFReadCustomDirectory(tif, diroff, _TIFFGetExifFields());\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_dirread.c",
        "metrics": {
            "nloc": 4,
            "cyclomatic_complexity": 1,
            "token_count": 23,
            "parameter_count": 2
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 16851,
            "store_count": 7324
        }
    },
    "TIFFReadGPSDirectory": {
        "source_code": "int TIFFReadGPSDirectory(TIFF *tif, toff_t diroff)\n{\n    return TIFFReadCustomDirectory(tif, diroff, _TIFFGetGpsFields());\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_dirread.c",
        "metrics": {
            "nloc": 4,
            "cyclomatic_complexity": 1,
            "token_count": 23,
            "parameter_count": 2
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 16851,
            "store_count": 7324
        }
    },
    "TIFFGetStrileOffset": {
        "source_code": "uint64_t TIFFGetStrileOffset(TIFF *tif, uint32_t strile)\n{\n    return TIFFGetStrileOffsetWithErr(tif, strile, NULL);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_dirread.c",
        "metrics": {
            "nloc": 4,
            "cyclomatic_complexity": 1,
            "token_count": 21,
            "parameter_count": 2
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 8,
            "store_count": 6
        }
    },
    "TIFFGetStrileOffsetWithErr": {
        "source_code": "uint64_t TIFFGetStrileOffsetWithErr(TIFF *tif, uint32_t strile, int *pbErr)\n{\n    TIFFDirectory *td = &tif->tif_dir;\n    return _TIFFGetStrileOffsetOrByteCountValue(tif, strile,\n                                                &(td->td_stripoffset_entry),\n                                                &(td->td_stripoffset_p), pbErr);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_dirread.c",
        "metrics": {
            "nloc": 7,
            "cyclomatic_complexity": 1,
            "token_count": 48,
            "parameter_count": 3
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 38,
            "store_count": 17
        }
    },
    "TIFFGetStrileByteCount": {
        "source_code": "uint64_t TIFFGetStrileByteCount(TIFF *tif, uint32_t strile)\n{\n    return TIFFGetStrileByteCountWithErr(tif, strile, NULL);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_dirread.c",
        "metrics": {
            "nloc": 4,
            "cyclomatic_complexity": 1,
            "token_count": 21,
            "parameter_count": 2
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 8,
            "store_count": 6
        }
    },
    "TIFFGetStrileByteCountWithErr": {
        "source_code": "uint64_t TIFFGetStrileByteCountWithErr(TIFF *tif, uint32_t strile, int *pbErr)\n{\n    TIFFDirectory *td = &tif->tif_dir;\n    return _TIFFGetStrileOffsetOrByteCountValue(\n        tif, strile, &(td->td_stripbytecount_entry), &(td->td_stripbytecount_p),\n        pbErr);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_dirread.c",
        "metrics": {
            "nloc": 7,
            "cyclomatic_complexity": 1,
            "token_count": 48,
            "parameter_count": 3
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 171,
            "store_count": 59
        }
    },
    "TIFFSetField": {
        "source_code": "int TIFFSetField(TIFF *tif, uint32_t tag, ...)\n{\n    va_list ap;\n    int status;\n\n    va_start(ap, tag);\n    status = TIFFVSetField(tif, tag, ap);\n    va_end(ap);\n    return (status);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_dir.c",
        "metrics": {
            "nloc": 9,
            "cyclomatic_complexity": 1,
            "token_count": 47,
            "parameter_count": 2
        },
        "cve_info": [
            {
                "CVE_ID": "CVE-2017-14528",
                "Description": "The TIFFSetProfiles function in coders/tiff.c in ImageMagick 7.0.6 has incorrect expectations about whether LibTIFF TIFFGetField return values imply that data validation has occurred, which allows remote attackers to cause a denial of service (use-after-free after an invalid call to TIFFSetField, and application crash) via a crafted file."
            }
        ],
        "cve_count": 1,
        "instruction": {
            "load_count": 10,
            "store_count": 6
        }
    },
    "TIFFUnsetField": {
        "source_code": "int TIFFUnsetField(TIFF *tif, uint32_t tag)\n{\n    const TIFFField *fip = TIFFFieldWithTag(tif, tag);\n    TIFFDirectory *td = &tif->tif_dir;\n\n    if (!fip)\n        return 0;\n\n    if (fip->field_bit != FIELD_CUSTOM)\n        TIFFClrFieldBit(tif, fip->field_bit);\n    else\n    {\n        TIFFTagValue *tv = NULL;\n        int i;\n\n        for (i = 0; i < td->td_customValueCount; i++)\n        {\n\n            tv = td->td_customValues + i;\n            if (tv->info->field_tag == tag)\n                break;\n        }\n\n        if (i < td->td_customValueCount)\n        {\n            _TIFFfreeExt(tif, tv->value);\n            for (; i < td->td_customValueCount - 1; i++)\n            {\n                td->td_customValues[i] = td->td_customValues[i + 1];\n            }\n            td->td_customValueCount--;\n        }\n    }\n\n    tif->tif_flags |= TIFF_DIRTYDIRECT;\n\n    return (1);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_dir.c",
        "metrics": {
            "nloc": 31,
            "cyclomatic_complexity": 7,
            "token_count": 173,
            "parameter_count": 2
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 50,
            "store_count": 17
        }
    },
    "TIFFVSetField": {
        "source_code": "int TIFFVSetField(TIFF *tif, uint32_t tag, va_list ap)\n{\n    return OkToChangeTag(tif, tag)\n               ? (*tif->tif_tagmethods.vsetfield)(tif, tag, ap)\n               : 0;\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_dir.c",
        "metrics": {
            "nloc": 6,
            "cyclomatic_complexity": 2,
            "token_count": 40,
            "parameter_count": 3
        },
        "cve_info": [
            {
                "CVE_ID": "CVE-2006-0405",
                "Description": "The TIFFFetchShortPair function in tif_dirread.c in libtiff 3.8.0 allows remote attackers to cause a denial of service (application crash) via a crafted TIFF image that triggers a NULL pointer dereference, possibly due to changes in type declarations and/or the TIFFVSetField function."
            }
        ],
        "cve_count": 1,
        "instruction": {
            "load_count": 26,
            "store_count": 9
        }
    },
    "TIFFGetField": {
        "source_code": "int TIFFGetField(TIFF *tif, uint32_t tag, ...)\n{\n    int status;\n    va_list ap;\n\n    va_start(ap, tag);\n    status = TIFFVGetField(tif, tag, ap);\n    va_end(ap);\n    return (status);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_dir.c",
        "metrics": {
            "nloc": 9,
            "cyclomatic_complexity": 1,
            "token_count": 47,
            "parameter_count": 2
        },
        "cve_info": [
            {
                "CVE_ID": "CVE-2010-2597",
                "Description": "The TIFFVStripSize function in tif_strip.c in LibTIFF 3.9.0 and 3.9.2 makes incorrect calls to the TIFFGetField function, which allows remote attackers to cause a denial of service (application crash) via a crafted TIFF image, related to \"downsampled OJPEG input\" and possibly related to a compiler optimization that triggers a divide-by-zero error."
            },
            {
                "CVE_ID": "CVE-2016-7449",
                "Description": "The TIFFGetField function in coders/tiff.c in GraphicsMagick 1.3.24 allows remote attackers to cause a denial of service (out-of-bounds heap read) via a file containing an \"unterminated\" string."
            },
            {
                "CVE_ID": "CVE-2017-14528",
                "Description": "The TIFFSetProfiles function in coders/tiff.c in ImageMagick 7.0.6 has incorrect expectations about whether LibTIFF TIFFGetField return values imply that data validation has occurred, which allows remote attackers to cause a denial of service (use-after-free after an invalid call to TIFFSetField, and application crash) via a crafted file."
            }
        ],
        "cve_count": 3,
        "instruction": {
            "load_count": 18,
            "store_count": 7
        }
    },
    "TIFFVGetField": {
        "source_code": "int TIFFVGetField(TIFF *tif, uint32_t tag, va_list ap)\n{\n    const TIFFField *fip = TIFFFindField(tif, tag, TIFF_ANY);\n    return (fip && (isPseudoTag(tag) || TIFFFieldSet(tif, fip->field_bit))\n                ? (*tif->tif_tagmethods.vgetfield)(tif, tag, ap)\n                : 0);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_dir.c",
        "metrics": {
            "nloc": 7,
            "cyclomatic_complexity": 4,
            "token_count": 67,
            "parameter_count": 3
        },
        "cve_info": [
            {
                "CVE_ID": "CVE-2010-2443",
                "Description": "The OJPEGReadBufferFill function in tif_ojpeg.c in LibTIFF before 3.9.3 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via an OJPEG image with undefined strip offsets, related to the TIFFVGetField function."
            }
        ],
        "cve_count": 1,
        "instruction": {
            "load_count": 41,
            "store_count": 15
        }
    },
    "TIFFFreeDirectory": {
        "source_code": "void TIFFFreeDirectory(TIFF *tif)\n{\n    TIFFDirectory *td = &tif->tif_dir;\n    int i;\n\n    _TIFFmemset(td->td_fieldsset, 0, sizeof(td->td_fieldsset));\n    CleanupField(td_sminsamplevalue);\n    CleanupField(td_smaxsamplevalue);\n    CleanupField(td_colormap[0]);\n    CleanupField(td_colormap[1]);\n    CleanupField(td_colormap[2]);\n    CleanupField(td_sampleinfo);\n    CleanupField(td_subifd);\n    CleanupField(td_inknames);\n    CleanupField(td_refblackwhite);\n    CleanupField(td_transferfunction[0]);\n    CleanupField(td_transferfunction[1]);\n    CleanupField(td_transferfunction[2]);\n    CleanupField(td_stripoffset_p);\n    CleanupField(td_stripbytecount_p);\n    td->td_stripoffsetbyteallocsize = 0;\n    TIFFClrFieldBit(tif, FIELD_YCBCRSUBSAMPLING);\n    TIFFClrFieldBit(tif, FIELD_YCBCRPOSITIONING);\n\n    /* Cleanup custom tag values */\n    for (i = 0; i < td->td_customValueCount; i++)\n    {\n        if (td->td_customValues[i].value)\n            _TIFFfreeExt(tif, td->td_customValues[i].value);\n    }\n\n    td->td_customValueCount = 0;\n    CleanupField(td_customValues);\n\n    _TIFFmemset(&(td->td_stripoffset_entry), 0, sizeof(TIFFDirEntry));\n    _TIFFmemset(&(td->td_stripbytecount_entry), 0, sizeof(TIFFDirEntry));\n\n    /* Reset some internal parameters for IFD data size checking. */\n    tif->tif_dir.td_dirdatasize_read = 0;\n    tif->tif_dir.td_dirdatasize_write = 0;\n    if (tif->tif_dir.td_dirdatasize_offsets != NULL)\n    {\n        _TIFFfreeExt(tif, tif->tif_dir.td_dirdatasize_offsets);\n        tif->tif_dir.td_dirdatasize_offsets = NULL;\n        tif->tif_dir.td_dirdatasize_Noffsets = 0;\n    }\n    tif->tif_dir.td_iswrittentofile = FALSE;\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_dir.c",
        "metrics": {
            "nloc": 41,
            "cyclomatic_complexity": 4,
            "token_count": 294,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 132,
            "store_count": 37
        }
    },
    "TIFFSetTagExtender": {
        "source_code": "TIFFExtendProc TIFFSetTagExtender(TIFFExtendProc extender)\n{\n    TIFFExtendProc prev = _TIFFextender;\n    _TIFFextender = extender;\n    return (prev);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_dir.c",
        "metrics": {
            "nloc": 6,
            "cyclomatic_complexity": 1,
            "token_count": 21,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 3,
            "store_count": 3
        }
    },
    "TIFFCreateDirectory": {
        "source_code": "int TIFFCreateDirectory(TIFF *tif)\n{\n    /* Free previously allocated memory and setup default values. */\n    TIFFFreeDirectory(tif);\n    TIFFDefaultDirectory(tif);\n    tif->tif_diroff = 0;\n    tif->tif_nextdiroff = 0;\n    tif->tif_curoff = 0;\n    tif->tif_row = (uint32_t)-1;\n    tif->tif_curstrip = (uint32_t)-1;\n    tif->tif_dir.td_iswrittentofile = FALSE;\n\n    return 0;\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_dir.c",
        "metrics": {
            "nloc": 12,
            "cyclomatic_complexity": 1,
            "token_count": 67,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 199,
            "store_count": 80
        }
    },
    "TIFFCreateCustomDirectory": {
        "source_code": "int TIFFCreateCustomDirectory(TIFF *tif, const TIFFFieldArray *infoarray)\n{\n    /* Free previously allocated memory and setup default values. */\n    TIFFFreeDirectory(tif);\n    TIFFDefaultDirectory(tif);\n\n    /*\n     * Reset the field definitions to match the application provided list.\n     * Hopefully TIFFDefaultDirectory() won't have done anything irreversible\n     * based on it's assumption this is an image directory.\n     */\n    _TIFFSetupFields(tif, infoarray);\n\n    tif->tif_diroff = 0;\n    tif->tif_nextdiroff = 0;\n    tif->tif_curoff = 0;\n    tif->tif_row = (uint32_t)-1;\n    tif->tif_curstrip = (uint32_t)-1;\n    /* invalidate directory index */\n    tif->tif_curdir = TIFF_NON_EXISTENT_DIR_NUMBER;\n    /* invalidate IFD loop lists */\n    _TIFFCleanupIFDOffsetAndNumberMaps(tif);\n    /* To be able to return from SubIFD or custom-IFD to main-IFD */\n    tif->tif_setdirectory_force_absolute = TRUE;\n\n    return 0;\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_dir.c",
        "metrics": {
            "nloc": 15,
            "cyclomatic_complexity": 1,
            "token_count": 88,
            "parameter_count": 2
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 282,
            "store_count": 105
        }
    },
    "TIFFCreateEXIFDirectory": {
        "source_code": "int TIFFCreateEXIFDirectory(TIFF *tif)\n{\n    const TIFFFieldArray *exifFieldArray;\n    exifFieldArray = _TIFFGetExifFields();\n    return TIFFCreateCustomDirectory(tif, exifFieldArray);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_dir.c",
        "metrics": {
            "nloc": 6,
            "cyclomatic_complexity": 1,
            "token_count": 27,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 284,
            "store_count": 107
        }
    },
    "TIFFCreateGPSDirectory": {
        "source_code": "int TIFFCreateGPSDirectory(TIFF *tif)\n{\n    const TIFFFieldArray *gpsFieldArray;\n    gpsFieldArray = _TIFFGetGpsFields();\n    return TIFFCreateCustomDirectory(tif, gpsFieldArray);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_dir.c",
        "metrics": {
            "nloc": 6,
            "cyclomatic_complexity": 1,
            "token_count": 27,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 284,
            "store_count": 107
        }
    },
    "TIFFNumberOfDirectories": {
        "source_code": "tdir_t TIFFNumberOfDirectories(TIFF *tif)\n{\n    uint64_t nextdiroff;\n    tdir_t nextdirnum;\n    tdir_t n;\n    if (!(tif->tif_flags & TIFF_BIGTIFF))\n        nextdiroff = tif->tif_header.classic.tiff_diroff;\n    else\n        nextdiroff = tif->tif_header.big.tiff_diroff;\n    nextdirnum = 0;\n    n = 0;\n    while (nextdiroff != 0 &&\n           TIFFAdvanceDirectory(tif, &nextdiroff, NULL, &nextdirnum))\n    {\n        ++n;\n    }\n    /* Update number of main-IFDs in file. */\n    tif->tif_curdircount = n;\n    return (n);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_dir.c",
        "metrics": {
            "nloc": 19,
            "cyclomatic_complexity": 4,
            "token_count": 92,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 214,
            "store_count": 48
        }
    },
    "TIFFSetDirectory": {
        "source_code": "int TIFFSetDirectory(TIFF *tif, tdir_t dirn)\n{\n    uint64_t nextdiroff;\n    tdir_t nextdirnum = 0;\n    tdir_t n;\n\n    if (tif->tif_setdirectory_force_absolute)\n    {\n        /* tif_setdirectory_force_absolute=1 will force parsing the main IFD\n         * chain from the beginning, thus IFD directory list needs to be cleared\n         * from possible SubIFD offsets.\n         */\n        _TIFFCleanupIFDOffsetAndNumberMaps(tif); /* invalidate IFD loop lists */\n    }\n\n    /* Even faster path, if offset is available within IFD loop hash list. */\n    if (!tif->tif_setdirectory_force_absolute &&\n        _TIFFGetOffsetFromDirNumber(tif, dirn, &nextdiroff))\n    {\n        /* Set parameters for following TIFFReadDirectory() below. */\n        tif->tif_nextdiroff = nextdiroff;\n        tif->tif_curdir = dirn;\n        /* Reset to relative stepping */\n        tif->tif_setdirectory_force_absolute = FALSE;\n    }\n    else\n    {\n\n        /* Fast path when we just advance relative to the current directory:\n         * start at the current dir offset and continue to seek from there.\n         * Check special cases when relative is not allowed:\n         * - jump back from SubIFD or custom directory\n         * - right after TIFFWriteDirectory() jump back to that directory\n         *   using TIFFSetDirectory() */\n        const int relative = (dirn >= tif->tif_curdir) &&\n                             (tif->tif_diroff != 0) &&\n                             !tif->tif_setdirectory_force_absolute;\n\n        if (relative)\n        {\n            nextdiroff = tif->tif_diroff;\n            dirn -= tif->tif_curdir;\n            nextdirnum = tif->tif_curdir;\n        }\n        else if (!(tif->tif_flags & TIFF_BIGTIFF))\n            nextdiroff = tif->tif_header.classic.tiff_diroff;\n        else\n            nextdiroff = tif->tif_header.big.tiff_diroff;\n\n        /* Reset to relative stepping */\n        tif->tif_setdirectory_force_absolute = FALSE;\n\n        for (n = dirn; n > 0 && nextdiroff != 0; n--)\n            if (!TIFFAdvanceDirectory(tif, &nextdiroff, NULL, &nextdirnum))\n                return (0);\n        /* If the n-th directory could not be reached (does not exist),\n         * return here without touching anything further. */\n        if (nextdiroff == 0 || n > 0)\n            return (0);\n\n        tif->tif_nextdiroff = nextdiroff;\n\n        /* Set curdir to the actual directory index. */\n        if (relative)\n            tif->tif_curdir += dirn - n;\n        else\n            tif->tif_curdir = dirn - n;\n    }\n\n    /* The -1 decrement is because TIFFReadDirectory will increment\n     * tif_curdir after successfully reading the directory. */\n    if (tif->tif_curdir == 0)\n        tif->tif_curdir = TIFF_NON_EXISTENT_DIR_NUMBER;\n    else\n        tif->tif_curdir--;\n\n    tdir_t curdir = tif->tif_curdir;\n\n    int retval = TIFFReadDirectory(tif);\n\n    if (!retval && tif->tif_curdir == curdir)\n    {\n        /* If tif_curdir has not be incremented, TIFFFetchDirectory() in\n         * TIFFReadDirectory() has failed and tif_curdir shall be set\n         * specifically. */\n        tif->tif_curdir = TIFF_NON_EXISTENT_DIR_NUMBER;\n    }\n    return (retval);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_dir.c",
        "metrics": {
            "nloc": 55,
            "cyclomatic_complexity": 17,
            "token_count": 302,
            "parameter_count": 2
        },
        "cve_info": [
            {
                "CVE_ID": "CVE-2018-5784",
                "Description": "In LibTIFF 4.0.9, there is an uncontrolled resource consumption in the TIFFSetDirectory function of tif_dir.c. Remote attackers could leverage this vulnerability to cause a denial of service via a crafted tif file. This occurs because the declared number of directory entries is not validated against the actual number of directory entries."
            }
        ],
        "cve_count": 1,
        "instruction": {
            "load_count": 478,
            "store_count": 169
        }
    },
    "TIFFSetSubDirectory": {
        "source_code": "int TIFFSetSubDirectory(TIFF *tif, uint64_t diroff)\n{\n    /* Match nextdiroff and curdir for consistent IFD-loop checking.\n     * Only with TIFFSetSubDirectory() the IFD list can be corrupted with\n     * invalid offsets within the main IFD tree. In the case of several subIFDs\n     * of a main image, there are two possibilities that are not even mutually\n     * exclusive. a.) The subIFD tag contains an array with all offsets of the\n     * subIFDs. b.) The SubIFDs are concatenated with their NextIFD parameters.\n     * (refer to\n     * https://www.awaresystems.be/imaging/tiff/specification/TIFFPM6.pdf.)\n     */\n    int retval;\n    uint32_t curdir = 0;\n    int8_t probablySubIFD = 0;\n    if (diroff == 0)\n    {\n        /* Special case to set tif_diroff=0, which is done in\n         * TIFFReadDirectory() below to indicate that the currently read IFD is\n         * treated as a new, fresh IFD. */\n        tif->tif_curdir = TIFF_NON_EXISTENT_DIR_NUMBER;\n        tif->tif_dir.td_iswrittentofile = FALSE;\n    }\n    else\n    {\n        if (!_TIFFGetDirNumberFromOffset(tif, diroff, &curdir))\n        {\n            /* Non-existing offsets might point to a SubIFD or invalid IFD.*/\n            probablySubIFD = 1;\n        }\n        /* -1 because TIFFReadDirectory() will increment tif_curdir. */\n        if (curdir >= 1)\n            tif->tif_curdir = curdir - 1;\n        else\n            tif->tif_curdir = TIFF_NON_EXISTENT_DIR_NUMBER;\n    }\n    curdir = tif->tif_curdir;\n\n    tif->tif_nextdiroff = diroff;\n    retval = TIFFReadDirectory(tif);\n\n    /* tif_curdir is incremented in TIFFReadDirectory(), but if it has not been\n     * incremented, TIFFFetchDirectory() has failed there and tif_curdir shall\n     * be set specifically. */\n    if (!retval && diroff != 0 && tif->tif_curdir == curdir)\n    {\n        tif->tif_curdir = TIFF_NON_EXISTENT_DIR_NUMBER;\n    }\n\n    if (probablySubIFD)\n    {\n        if (retval)\n        {\n            /* Reset IFD list to start new one for SubIFD chain and also start\n             * SubIFD chain with tif_curdir=0 for IFD loop checking. */\n            /* invalidate IFD loop lists */\n            _TIFFCleanupIFDOffsetAndNumberMaps(tif);\n            tif->tif_curdir = 0; /* first directory of new chain */\n            /* add this offset to new IFD list */\n            retval = _TIFFCheckDirNumberAndOffset(tif, tif->tif_curdir, diroff);\n        }\n        /* To be able to return from SubIFD or custom-IFD to main-IFD */\n        tif->tif_setdirectory_force_absolute = TRUE;\n    }\n\n    return (retval);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_dir.c",
        "metrics": {
            "nloc": 40,
            "cyclomatic_complexity": 9,
            "token_count": 178,
            "parameter_count": 2
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 30,
            "store_count": 16
        }
    },
    "TIFFCurrentDirOffset": {
        "source_code": "uint64_t TIFFCurrentDirOffset(TIFF *tif) { return (tif->tif_diroff); }\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_dir.c",
        "metrics": {
            "nloc": 1,
            "cyclomatic_complexity": 1,
            "token_count": 15,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 2,
            "store_count": 1
        }
    },
    "TIFFLastDirectory": {
        "source_code": "int TIFFLastDirectory(TIFF *tif) { return (tif->tif_nextdiroff == 0); }\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_dir.c",
        "metrics": {
            "nloc": 1,
            "cyclomatic_complexity": 1,
            "token_count": 17,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 2,
            "store_count": 1
        }
    },
    "TIFFUnlinkDirectory": {
        "source_code": "int TIFFUnlinkDirectory(TIFF *tif, tdir_t dirn)\n{\n    static const char module[] = \"TIFFUnlinkDirectory\";\n    uint64_t nextdir;\n    tdir_t nextdirnum;\n    uint64_t off;\n    tdir_t n;\n\n    if (tif->tif_mode == O_RDONLY)\n    {\n        TIFFErrorExtR(tif, module,\n                      \"Can not unlink directory in read-only file\");\n        return (0);\n    }\n    if (dirn == 0)\n    {\n        TIFFErrorExtR(tif, module,\n                      \"For TIFFUnlinkDirectory() first directory starts with \"\n                      \"number 1 and not 0\");\n        return (0);\n    }\n    /*\n     * Go to the directory before the one we want\n     * to unlink and nab the offset of the link\n     * field we'll need to patch.\n     */\n    if (!(tif->tif_flags & TIFF_BIGTIFF))\n    {\n        nextdir = tif->tif_header.classic.tiff_diroff;\n        off = 4;\n    }\n    else\n    {\n        nextdir = tif->tif_header.big.tiff_diroff;\n        off = 8;\n    }\n    nextdirnum = 0; /* First directory is dirn=0 */\n\n    for (n = dirn - 1; n > 0; n--)\n    {\n        if (nextdir == 0)\n        {\n            TIFFErrorExtR(tif, module, \"Directory %u does not exist\", dirn);\n            return (0);\n        }\n        if (!TIFFAdvanceDirectory(tif, &nextdir, &off, &nextdirnum))\n            return (0);\n    }\n    /*\n     * Advance to the directory to be unlinked and fetch\n     * the offset of the directory that follows.\n     */\n    if (!TIFFAdvanceDirectory(tif, &nextdir, NULL, &nextdirnum))\n        return (0);\n    /*\n     * Go back and patch the link field of the preceding\n     * directory to point to the offset of the directory\n     * that follows.\n     */\n    (void)TIFFSeekFile(tif, off, SEEK_SET);\n    if (!(tif->tif_flags & TIFF_BIGTIFF))\n    {\n        uint32_t nextdir32;\n        nextdir32 = (uint32_t)nextdir;\n        assert((uint64_t)nextdir32 == nextdir);\n        if (tif->tif_flags & TIFF_SWAB)\n            TIFFSwabLong(&nextdir32);\n        if (!WriteOK(tif, &nextdir32, sizeof(uint32_t)))\n        {\n            TIFFErrorExtR(tif, module, \"Error writing directory link\");\n            return (0);\n        }\n    }\n    else\n    {\n        /* Need local swap because nextdir has to be used unswapped below. */\n        uint64_t nextdir64 = nextdir;\n        if (tif->tif_flags & TIFF_SWAB)\n            TIFFSwabLong8(&nextdir64);\n        if (!WriteOK(tif, &nextdir64, sizeof(uint64_t)))\n        {\n            TIFFErrorExtR(tif, module, \"Error writing directory link\");\n            return (0);\n        }\n    }\n\n    /* For dirn=1 (first directory) also update the libtiff internal\n     * base offset variables. */\n    if (dirn == 1)\n    {\n        if (!(tif->tif_flags & TIFF_BIGTIFF))\n            tif->tif_header.classic.tiff_diroff = (uint32_t)nextdir;\n        else\n            tif->tif_header.big.tiff_diroff = nextdir;\n    }\n\n    /*\n     * Leave directory state setup safely.  We don't have\n     * facilities for doing inserting and removing directories,\n     * so it's safest to just invalidate everything.  This\n     * means that the caller can only append to the directory\n     * chain.\n     */\n    (*tif->tif_cleanup)(tif);\n    if ((tif->tif_flags & TIFF_MYBUFFER) && tif->tif_rawdata)\n    {\n        _TIFFfreeExt(tif, tif->tif_rawdata);\n        tif->tif_rawdata = NULL;\n        tif->tif_rawcc = 0;\n        tif->tif_rawdataoff = 0;\n        tif->tif_rawdataloaded = 0;\n    }\n    tif->tif_flags &= ~(TIFF_BEENWRITING | TIFF_BUFFERSETUP | TIFF_POSTENCODE |\n                        TIFF_BUF4WRITE);\n    TIFFFreeDirectory(tif);\n    TIFFDefaultDirectory(tif);\n    tif->tif_diroff = 0;     /* force link on next write */\n    tif->tif_nextdiroff = 0; /* next write must be at end */\n    tif->tif_lastdiroff = 0; /* will be updated on next link */\n    tif->tif_curoff = 0;\n    tif->tif_row = (uint32_t)-1;\n    tif->tif_curstrip = (uint32_t)-1;\n    tif->tif_curdir = TIFF_NON_EXISTENT_DIR_NUMBER;\n    if (tif->tif_curdircount > 0)\n        tif->tif_curdircount--;\n    else\n        tif->tif_curdircount = TIFF_NON_EXISTENT_DIR_NUMBER;\n    _TIFFCleanupIFDOffsetAndNumberMaps(tif); /* invalidate IFD loop lists */\n    return (1);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_dir.c",
        "metrics": {
            "nloc": 102,
            "cyclomatic_complexity": 18,
            "token_count": 562,
            "parameter_count": 2
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 1188,
            "store_count": 432
        }
    },
    "TIFFGetTagListCount": {
        "source_code": "int TIFFGetTagListCount(TIFF *tif)\n\n{\n    TIFFDirectory *td = &tif->tif_dir;\n\n    return td->td_customValueCount;\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_extension.c",
        "metrics": {
            "nloc": 5,
            "cyclomatic_complexity": 1,
            "token_count": 22,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 3,
            "store_count": 2
        }
    },
    "TIFFGetTagListEntry": {
        "source_code": "uint32_t TIFFGetTagListEntry(TIFF *tif, int tag_index)\n\n{\n    TIFFDirectory *td = &tif->tif_dir;\n\n    if (tag_index < 0 || tag_index >= td->td_customValueCount)\n        return (uint32_t)(-1);\n    else\n        return td->td_customValues[tag_index].info->field_tag;\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_extension.c",
        "metrics": {
            "nloc": 8,
            "cyclomatic_complexity": 3,
            "token_count": 54,
            "parameter_count": 2
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 11,
            "store_count": 5
        }
    },
    "TIFFAccessTagMethods": {
        "source_code": "TIFFTagMethods *TIFFAccessTagMethods(TIFF *tif)\n\n{\n    return &(tif->tif_tagmethods);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_extension.c",
        "metrics": {
            "nloc": 4,
            "cyclomatic_complexity": 1,
            "token_count": 16,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 1,
            "store_count": 1
        }
    },
    "TIFFGetClientInfo": {
        "source_code": "void *TIFFGetClientInfo(TIFF *tif, const char *name)\n\n{\n    TIFFClientInfoLink *psLink = tif->tif_clientinfo;\n\n    while (psLink != NULL && strcmp(psLink->name, name) != 0)\n        psLink = psLink->next;\n\n    if (psLink != NULL)\n        return psLink->data;\n    else\n        return NULL;\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_extension.c",
        "metrics": {
            "nloc": 10,
            "cyclomatic_complexity": 4,
            "token_count": 59,
            "parameter_count": 2
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 12,
            "store_count": 6
        }
    },
    "TIFFSetClientInfo": {
        "source_code": "void TIFFSetClientInfo(TIFF *tif, void *data, const char *name)\n\n{\n    TIFFClientInfoLink *psLink = tif->tif_clientinfo;\n\n    /*\n    ** Do we have an existing link with this name?  If so, just\n    ** set it.\n    */\n    while (psLink != NULL && strcmp(psLink->name, name) != 0)\n        psLink = psLink->next;\n\n    if (psLink != NULL)\n    {\n        psLink->data = data;\n        return;\n    }\n\n    /*\n    ** Create a new link.\n    */\n\n    psLink =\n        (TIFFClientInfoLink *)_TIFFmallocExt(tif, sizeof(TIFFClientInfoLink));\n    assert(psLink != NULL);\n    psLink->next = tif->tif_clientinfo;\n    psLink->name = (char *)_TIFFmallocExt(tif, (tmsize_t)(strlen(name) + 1));\n    assert(psLink->name != NULL);\n    strcpy(psLink->name, name);\n    psLink->data = data;\n\n    tif->tif_clientinfo = psLink;\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_extension.c",
        "metrics": {
            "nloc": 20,
            "cyclomatic_complexity": 4,
            "token_count": 150,
            "parameter_count": 3
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 28,
            "store_count": 11
        }
    },
    "TIFFSetCompressionScheme": {
        "source_code": "int TIFFSetCompressionScheme(TIFF *tif, int scheme)\n{\n    const TIFFCodec *c = TIFFFindCODEC((uint16_t)scheme);\n\n    _TIFFSetDefaultCompressionState(tif);\n    /*\n     * Don't treat an unknown compression scheme as an error.\n     * This permits applications to open files with data that\n     * the library does not have builtin support for, but which\n     * may still be meaningful.\n     */\n    return (c ? (*c->init)(tif, scheme) : 1);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_compress.c",
        "metrics": {
            "nloc": 6,
            "cyclomatic_complexity": 2,
            "token_count": 48,
            "parameter_count": 2
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 46,
            "store_count": 32
        }
    },
    "TIFFFindCODEC": {
        "source_code": "const TIFFCodec *TIFFFindCODEC(uint16_t scheme)\n{\n    const TIFFCodec *c;\n    codec_t *cd;\n\n    for (cd = registeredCODECS; cd; cd = cd->next)\n        if (cd->info->scheme == scheme)\n            return ((const TIFFCodec *)cd->info);\n    for (c = _TIFFBuiltinCODECS; c->name; c++)\n        if (c->scheme == scheme)\n            return (c);\n    return ((const TIFFCodec *)0);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_compress.c",
        "metrics": {
            "nloc": 12,
            "cyclomatic_complexity": 5,
            "token_count": 88,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 18,
            "store_count": 8
        }
    },
    "TIFFRegisterCODEC": {
        "source_code": "TIFFCodec *TIFFRegisterCODEC(uint16_t scheme, const char *name,\n                             TIFFInitMethod init)\n{\n    codec_t *cd = (codec_t *)_TIFFmallocExt(\n        NULL,\n        (tmsize_t)(sizeof(codec_t) + sizeof(TIFFCodec) + strlen(name) + 1));\n\n    if (cd != NULL)\n    {\n        cd->info = (TIFFCodec *)((uint8_t *)cd + sizeof(codec_t));\n        cd->info->name = (char *)((uint8_t *)cd->info + sizeof(TIFFCodec));\n        strcpy(cd->info->name, name);\n        cd->info->scheme = scheme;\n        cd->info->init = init;\n        cd->next = registeredCODECS;\n        registeredCODECS = cd;\n    }\n    else\n    {\n        TIFFErrorExt(0, \"TIFFRegisterCODEC\",\n                     \"No space to register compression scheme %s\", name);\n        return NULL;\n    }\n    return (cd->info);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_compress.c",
        "metrics": {
            "nloc": 24,
            "cyclomatic_complexity": 2,
            "token_count": 165,
            "parameter_count": 3
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 34,
            "store_count": 15
        }
    },
    "TIFFUnRegisterCODEC": {
        "source_code": "void TIFFUnRegisterCODEC(TIFFCodec *c)\n{\n    codec_t *cd;\n    codec_t **pcd;\n\n    for (pcd = &registeredCODECS; (cd = *pcd) != NULL; pcd = &cd->next)\n        if (cd->info == c)\n        {\n            *pcd = cd->next;\n            _TIFFfreeExt(NULL, cd);\n            return;\n        }\n    TIFFErrorExt(0, \"TIFFUnRegisterCODEC\",\n                 \"Cannot remove compression scheme %s; not registered\",\n                 c->name);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_compress.c",
        "metrics": {
            "nloc": 15,
            "cyclomatic_complexity": 3,
            "token_count": 78,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 21,
            "store_count": 8
        }
    },
    "TIFFGetConfiguredCODECs": {
        "source_code": "TIFFCodec *TIFFGetConfiguredCODECs()\n{\n    int i = 1;\n    codec_t *cd;\n    const TIFFCodec *c;\n    TIFFCodec *codecs = NULL;\n    TIFFCodec *new_codecs;\n\n    for (cd = registeredCODECS; cd; cd = cd->next)\n    {\n        new_codecs =\n            (TIFFCodec *)_TIFFreallocExt(NULL, codecs, i * sizeof(TIFFCodec));\n        if (!new_codecs)\n        {\n            _TIFFfreeExt(NULL, codecs);\n            return NULL;\n        }\n        codecs = new_codecs;\n        _TIFFmemcpy(codecs + i - 1, cd->info, sizeof(TIFFCodec));\n        i++;\n    }\n    for (c = _TIFFBuiltinCODECS; c->name; c++)\n    {\n        if (TIFFIsCODECConfigured(c->scheme))\n        {\n            new_codecs = (TIFFCodec *)_TIFFreallocExt(NULL, codecs,\n                                                      i * sizeof(TIFFCodec));\n            if (!new_codecs)\n            {\n                _TIFFfreeExt(NULL, codecs);\n                return NULL;\n            }\n            codecs = new_codecs;\n            _TIFFmemcpy(codecs + i - 1, (const void *)c, sizeof(TIFFCodec));\n            i++;\n        }\n    }\n\n    new_codecs =\n        (TIFFCodec *)_TIFFreallocExt(NULL, codecs, i * sizeof(TIFFCodec));\n    if (!new_codecs)\n    {\n        _TIFFfreeExt(NULL, codecs);\n        return NULL;\n    }\n    codecs = new_codecs;\n    _TIFFmemset(codecs + i - 1, 0, sizeof(TIFFCodec));\n\n    return codecs;\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_compress.c",
        "metrics": {
            "nloc": 47,
            "cyclomatic_complexity": 7,
            "token_count": 258,
            "parameter_count": 0
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 53,
            "store_count": 33
        }
    },
    "TIFFWriteScanline": {
        "source_code": "int TIFFWriteScanline(TIFF *tif, void *buf, uint32_t row, uint16_t sample)\n{\n    static const char module[] = \"TIFFWriteScanline\";\n    register TIFFDirectory *td;\n    int status, imagegrew = 0;\n    uint32_t strip;\n\n    if (!WRITECHECKSTRIPS(tif, module))\n        return (-1);\n    /*\n     * Handle delayed allocation of data buffer.  This\n     * permits it to be sized more intelligently (using\n     * directory information).\n     */\n    if (!BUFFERCHECK(tif))\n        return (-1);\n    tif->tif_flags |= TIFF_BUF4WRITE; /* not strictly sure this is right*/\n\n    td = &tif->tif_dir;\n    /*\n     * Extend image length if needed\n     * (but only for PlanarConfig=1).\n     */\n    if (row >= td->td_imagelength)\n    { /* extend image */\n        if (td->td_planarconfig == PLANARCONFIG_SEPARATE)\n        {\n            TIFFErrorExtR(\n                tif, module,\n                \"Can not change \\\"ImageLength\\\" when using separate planes\");\n            return (-1);\n        }\n        td->td_imagelength = row + 1;\n        imagegrew = 1;\n    }\n    /*\n     * Calculate strip and check for crossings.\n     */\n    if (td->td_planarconfig == PLANARCONFIG_SEPARATE)\n    {\n        if (sample >= td->td_samplesperpixel)\n        {\n            TIFFErrorExtR(tif, module, \"%lu: Sample out of range, max %lu\",\n                          (unsigned long)sample,\n                          (unsigned long)td->td_samplesperpixel);\n            return (-1);\n        }\n        strip = sample * td->td_stripsperimage + row / td->td_rowsperstrip;\n    }\n    else\n        strip = row / td->td_rowsperstrip;\n    /*\n     * Check strip array to make sure there's space. We don't support\n     * dynamically growing files that have data organized in separate\n     * bitplanes because it's too painful.  In that case we require that\n     * the imagelength be set properly before the first write (so that the\n     * strips array will be fully allocated above).\n     */\n    if (strip >= td->td_nstrips && !TIFFGrowStrips(tif, 1, module))\n        return (-1);\n    if (strip != tif->tif_curstrip)\n    {\n        /*\n         * Changing strips -- flush any data present.\n         */\n        if (!TIFFFlushData(tif))\n            return (-1);\n        tif->tif_curstrip = strip;\n        /*\n         * Watch out for a growing image.  The value of strips/image\n         * will initially be 1 (since it can't be deduced until the\n         * imagelength is known).\n         */\n        if (strip >= td->td_stripsperimage && imagegrew)\n            td->td_stripsperimage =\n                TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);\n        if (td->td_stripsperimage == 0)\n        {\n            TIFFErrorExtR(tif, module, \"Zero strips per image\");\n            return (-1);\n        }\n        tif->tif_row = (strip % td->td_stripsperimage) * td->td_rowsperstrip;\n        if ((tif->tif_flags & TIFF_CODERSETUP) == 0)\n        {\n            if (!(*tif->tif_setupencode)(tif))\n                return (-1);\n            tif->tif_flags |= TIFF_CODERSETUP;\n        }\n\n        tif->tif_rawcc = 0;\n        tif->tif_rawcp = tif->tif_rawdata;\n\n        /* this informs TIFFAppendToStrip() we have changed strip */\n        tif->tif_curoff = 0;\n\n        if (!(*tif->tif_preencode)(tif, sample))\n            return (-1);\n        tif->tif_flags |= TIFF_POSTENCODE;\n    }\n    /*\n     * Ensure the write is either sequential or at the\n     * beginning of a strip (or that we can randomly\n     * access the data -- i.e. no encoding).\n     */\n    if (row != tif->tif_row)\n    {\n        if (row < tif->tif_row)\n        {\n            /*\n             * Moving backwards within the same strip:\n             * backup to the start and then decode\n             * forward (below).\n             */\n            tif->tif_row =\n                (strip % td->td_stripsperimage) * td->td_rowsperstrip;\n            tif->tif_rawcp = tif->tif_rawdata;\n        }\n        /*\n         * Seek forward to the desired row.\n         */\n        if (!(*tif->tif_seek)(tif, row - tif->tif_row))\n            return (-1);\n        tif->tif_row = row;\n    }\n\n    /* swab if needed - note that source buffer will be altered */\n    tif->tif_postdecode(tif, (uint8_t *)buf, tif->tif_scanlinesize);\n\n    status = (*tif->tif_encoderow)(tif, (uint8_t *)buf, tif->tif_scanlinesize,\n                                   sample);\n\n    /* we are now poised at the beginning of the next row */\n    tif->tif_row = row + 1;\n    return (status);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_write.c",
        "metrics": {
            "nloc": 84,
            "cyclomatic_complexity": 20,
            "token_count": 539,
            "parameter_count": 4
        },
        "cve_info": [
            {
                "CVE_ID": "CVE-2014-8130",
                "Description": "The _TIFFmalloc function in tif_unix.c in LibTIFF 4.0.3 does not reject a zero size, which allows remote attackers to cause a denial of service (divide-by-zero error and application crash) via a crafted TIFF image that is mishandled by the TIFFWriteScanline function in tif_write.c, as demonstrated by tiffdither."
            },
            {
                "CVE_ID": "CVE-2018-10779",
                "Description": "TIFFWriteScanline in tif_write.c in LibTIFF 3.8.2 has a heap-based buffer over-read, as demonstrated by bmp2tiff."
            }
        ],
        "cve_count": 2,
        "instruction": {
            "load_count": 272,
            "store_count": 82
        }
    },
    "TIFFWriteEncodedStrip": {
        "source_code": "tmsize_t TIFFWriteEncodedStrip(TIFF *tif, uint32_t strip, void *data,\n                               tmsize_t cc)\n{\n    static const char module[] = \"TIFFWriteEncodedStrip\";\n    TIFFDirectory *td = &tif->tif_dir;\n    uint16_t sample;\n\n    if (!WRITECHECKSTRIPS(tif, module))\n        return ((tmsize_t)-1);\n    /*\n     * Check strip array to make sure there's space.\n     * We don't support dynamically growing files that\n     * have data organized in separate bitplanes because\n     * it's too painful.  In that case we require that\n     * the imagelength be set properly before the first\n     * write (so that the strips array will be fully\n     * allocated above).\n     */\n    if (strip >= td->td_nstrips)\n    {\n        if (td->td_planarconfig == PLANARCONFIG_SEPARATE)\n        {\n            TIFFErrorExtR(\n                tif, module,\n                \"Can not grow image by strips when using separate planes\");\n            return ((tmsize_t)-1);\n        }\n        if (!TIFFGrowStrips(tif, 1, module))\n            return ((tmsize_t)-1);\n        td->td_stripsperimage =\n            TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);\n    }\n    /*\n     * Handle delayed allocation of data buffer.  This\n     * permits it to be sized according to the directory\n     * info.\n     */\n    if (!BUFFERCHECK(tif))\n        return ((tmsize_t)-1);\n\n    tif->tif_flags |= TIFF_BUF4WRITE;\n\n    tif->tif_curstrip = strip;\n\n    /* this informs TIFFAppendToStrip() we have changed or reset strip */\n    tif->tif_curoff = 0;\n\n    if (!_TIFFReserveLargeEnoughWriteBuffer(tif, strip))\n    {\n        return ((tmsize_t)(-1));\n    }\n\n    tif->tif_rawcc = 0;\n    tif->tif_rawcp = tif->tif_rawdata;\n\n    if (td->td_stripsperimage == 0)\n    {\n        TIFFErrorExtR(tif, module, \"Zero strips per image\");\n        return ((tmsize_t)-1);\n    }\n\n    tif->tif_row = (strip % td->td_stripsperimage) * td->td_rowsperstrip;\n    if ((tif->tif_flags & TIFF_CODERSETUP) == 0)\n    {\n        if (!(*tif->tif_setupencode)(tif))\n            return ((tmsize_t)-1);\n        tif->tif_flags |= TIFF_CODERSETUP;\n    }\n\n    tif->tif_flags &= ~TIFF_POSTENCODE;\n\n    /* shortcut to avoid an extra memcpy() */\n    if (td->td_compression == COMPRESSION_NONE)\n    {\n        /* swab if needed - note that source buffer will be altered */\n        tif->tif_postdecode(tif, (uint8_t *)data, cc);\n\n        if (!isFillOrder(tif, td->td_fillorder) &&\n            (tif->tif_flags & TIFF_NOBITREV) == 0)\n            TIFFReverseBits((uint8_t *)data, cc);\n\n        if (cc > 0 && !TIFFAppendToStrip(tif, strip, (uint8_t *)data, cc))\n            return ((tmsize_t)-1);\n        return (cc);\n    }\n\n    sample = (uint16_t)(strip / td->td_stripsperimage);\n    if (!(*tif->tif_preencode)(tif, sample))\n        return ((tmsize_t)-1);\n\n    /* swab if needed - note that source buffer will be altered */\n    tif->tif_postdecode(tif, (uint8_t *)data, cc);\n\n    if (!(*tif->tif_encodestrip)(tif, (uint8_t *)data, cc, sample))\n        return ((tmsize_t)-1);\n    if (!(*tif->tif_postencode)(tif))\n        return ((tmsize_t)-1);\n    if (!isFillOrder(tif, td->td_fillorder) &&\n        (tif->tif_flags & TIFF_NOBITREV) == 0)\n        TIFFReverseBits(tif->tif_rawdata, tif->tif_rawcc);\n    if (tif->tif_rawcc > 0 &&\n        !TIFFAppendToStrip(tif, strip, tif->tif_rawdata, tif->tif_rawcc))\n        return ((tmsize_t)-1);\n    tif->tif_rawcc = 0;\n    tif->tif_rawcp = tif->tif_rawdata;\n    return (cc);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_write.c",
        "metrics": {
            "nloc": 74,
            "cyclomatic_complexity": 22,
            "token_count": 581,
            "parameter_count": 4
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 1309,
            "store_count": 435
        }
    },
    "TIFFWriteRawStrip": {
        "source_code": "tmsize_t TIFFWriteRawStrip(TIFF *tif, uint32_t strip, void *data, tmsize_t cc)\n{\n    static const char module[] = \"TIFFWriteRawStrip\";\n    TIFFDirectory *td = &tif->tif_dir;\n\n    if (!WRITECHECKSTRIPS(tif, module))\n        return ((tmsize_t)-1);\n    /*\n     * Check strip array to make sure there's space.\n     * We don't support dynamically growing files that\n     * have data organized in separate bitplanes because\n     * it's too painful.  In that case we require that\n     * the imagelength be set properly before the first\n     * write (so that the strips array will be fully\n     * allocated above).\n     */\n    if (strip >= td->td_nstrips)\n    {\n        if (td->td_planarconfig == PLANARCONFIG_SEPARATE)\n        {\n            TIFFErrorExtR(\n                tif, module,\n                \"Can not grow image by strips when using separate planes\");\n            return ((tmsize_t)-1);\n        }\n        /*\n         * Watch out for a growing image.  The value of\n         * strips/image will initially be 1 (since it\n         * can't be deduced until the imagelength is known).\n         */\n        if (strip >= td->td_stripsperimage)\n            td->td_stripsperimage =\n                TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);\n        if (!TIFFGrowStrips(tif, 1, module))\n            return ((tmsize_t)-1);\n    }\n\n    if (tif->tif_curstrip != strip)\n    {\n        tif->tif_curstrip = strip;\n\n        /* this informs TIFFAppendToStrip() we have changed or reset strip */\n        tif->tif_curoff = 0;\n    }\n\n    if (td->td_stripsperimage == 0)\n    {\n        TIFFErrorExtR(tif, module, \"Zero strips per image\");\n        return ((tmsize_t)-1);\n    }\n    tif->tif_row = (strip % td->td_stripsperimage) * td->td_rowsperstrip;\n    return (TIFFAppendToStrip(tif, strip, (uint8_t *)data, cc) ? cc\n                                                               : (tmsize_t)-1);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_write.c",
        "metrics": {
            "nloc": 35,
            "cyclomatic_complexity": 9,
            "token_count": 229,
            "parameter_count": 4
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 728,
            "store_count": 247
        }
    },
    "TIFFWriteTile": {
        "source_code": "tmsize_t TIFFWriteTile(TIFF *tif, void *buf, uint32_t x, uint32_t y, uint32_t z,\n                       uint16_t s)\n{\n    if (!TIFFCheckTile(tif, x, y, z, s))\n        return ((tmsize_t)(-1));\n    /*\n     * NB: A tile size of -1 is used instead of tif_tilesize knowing\n     *     that TIFFWriteEncodedTile will clamp this to the tile size.\n     *     This is done because the tile size may not be defined until\n     *     after the output buffer is setup in TIFFWriteBufferSetup.\n     */\n    return (TIFFWriteEncodedTile(tif, TIFFComputeTile(tif, x, y, z, s), buf,\n                                 (tmsize_t)(-1)));\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_write.c",
        "metrics": {
            "nloc": 8,
            "cyclomatic_complexity": 2,
            "token_count": 82,
            "parameter_count": 6
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 262,
            "store_count": 72
        }
    },
    "TIFFWriteEncodedTile": {
        "source_code": "tmsize_t TIFFWriteEncodedTile(TIFF *tif, uint32_t tile, void *data, tmsize_t cc)\n{\n    static const char module[] = \"TIFFWriteEncodedTile\";\n    TIFFDirectory *td;\n    uint16_t sample;\n    uint32_t howmany32;\n\n    if (!WRITECHECKTILES(tif, module))\n        return ((tmsize_t)(-1));\n    td = &tif->tif_dir;\n    if (tile >= td->td_nstrips)\n    {\n        TIFFErrorExtR(tif, module, \"Tile %lu out of range, max %lu\",\n                      (unsigned long)tile, (unsigned long)td->td_nstrips);\n        return ((tmsize_t)(-1));\n    }\n    /*\n     * Handle delayed allocation of data buffer.  This\n     * permits it to be sized more intelligently (using\n     * directory information).\n     */\n    if (!BUFFERCHECK(tif))\n        return ((tmsize_t)(-1));\n\n    tif->tif_flags |= TIFF_BUF4WRITE;\n\n    tif->tif_curtile = tile;\n\n    /* this informs TIFFAppendToStrip() we have changed or reset tile */\n    tif->tif_curoff = 0;\n\n    if (!_TIFFReserveLargeEnoughWriteBuffer(tif, tile))\n    {\n        return ((tmsize_t)(-1));\n    }\n\n    tif->tif_rawcc = 0;\n    tif->tif_rawcp = tif->tif_rawdata;\n\n    /*\n     * Compute tiles per row & per column to compute\n     * current row and column\n     */\n    howmany32 = TIFFhowmany_32(td->td_imagelength, td->td_tilelength);\n    if (howmany32 == 0)\n    {\n        TIFFErrorExtR(tif, module, \"Zero tiles\");\n        return ((tmsize_t)(-1));\n    }\n    tif->tif_row = (tile % howmany32) * td->td_tilelength;\n    howmany32 = TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth);\n    if (howmany32 == 0)\n    {\n        TIFFErrorExtR(tif, module, \"Zero tiles\");\n        return ((tmsize_t)(-1));\n    }\n    tif->tif_col = (tile % howmany32) * td->td_tilewidth;\n\n    if ((tif->tif_flags & TIFF_CODERSETUP) == 0)\n    {\n        if (!(*tif->tif_setupencode)(tif))\n            return ((tmsize_t)(-1));\n        tif->tif_flags |= TIFF_CODERSETUP;\n    }\n    tif->tif_flags &= ~TIFF_POSTENCODE;\n\n    /*\n     * Clamp write amount to the tile size.  This is mostly\n     * done so that callers can pass in some large number\n     * (e.g. -1) and have the tile size used instead.\n     */\n    if (cc < 1 || cc > tif->tif_tilesize)\n        cc = tif->tif_tilesize;\n\n    /* shortcut to avoid an extra memcpy() */\n    if (td->td_compression == COMPRESSION_NONE)\n    {\n        /* swab if needed - note that source buffer will be altered */\n        tif->tif_postdecode(tif, (uint8_t *)data, cc);\n\n        if (!isFillOrder(tif, td->td_fillorder) &&\n            (tif->tif_flags & TIFF_NOBITREV) == 0)\n            TIFFReverseBits((uint8_t *)data, cc);\n\n        if (cc > 0 && !TIFFAppendToStrip(tif, tile, (uint8_t *)data, cc))\n            return ((tmsize_t)-1);\n        return (cc);\n    }\n\n    sample = (uint16_t)(tile / td->td_stripsperimage);\n    if (!(*tif->tif_preencode)(tif, sample))\n        return ((tmsize_t)(-1));\n    /* swab if needed - note that source buffer will be altered */\n    tif->tif_postdecode(tif, (uint8_t *)data, cc);\n\n    if (!(*tif->tif_encodetile)(tif, (uint8_t *)data, cc, sample))\n        return ((tmsize_t)-1);\n    if (!(*tif->tif_postencode)(tif))\n        return ((tmsize_t)(-1));\n    if (!isFillOrder(tif, td->td_fillorder) &&\n        (tif->tif_flags & TIFF_NOBITREV) == 0)\n        TIFFReverseBits((uint8_t *)tif->tif_rawdata, tif->tif_rawcc);\n    if (tif->tif_rawcc > 0 &&\n        !TIFFAppendToStrip(tif, tile, tif->tif_rawdata, tif->tif_rawcc))\n        return ((tmsize_t)(-1));\n    tif->tif_rawcc = 0;\n    tif->tif_rawcp = tif->tif_rawdata;\n    return (cc);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_write.c",
        "metrics": {
            "nloc": 77,
            "cyclomatic_complexity": 23,
            "token_count": 656,
            "parameter_count": 4
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 1557,
            "store_count": 528
        }
    },
    "TIFFWriteRawTile": {
        "source_code": "tmsize_t TIFFWriteRawTile(TIFF *tif, uint32_t tile, void *data, tmsize_t cc)\n{\n    static const char module[] = \"TIFFWriteRawTile\";\n\n    if (!WRITECHECKTILES(tif, module))\n        return ((tmsize_t)(-1));\n    if (tile >= tif->tif_dir.td_nstrips)\n    {\n        TIFFErrorExtR(tif, module, \"Tile %lu out of range, max %lu\",\n                      (unsigned long)tile,\n                      (unsigned long)tif->tif_dir.td_nstrips);\n        return ((tmsize_t)(-1));\n    }\n    return (TIFFAppendToStrip(tif, tile, (uint8_t *)data, cc) ? cc\n                                                              : (tmsize_t)(-1));\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_write.c",
        "metrics": {
            "nloc": 15,
            "cyclomatic_complexity": 4,
            "token_count": 124,
            "parameter_count": 4
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 646,
            "store_count": 221
        }
    },
    "TIFFSetupStrips": {
        "source_code": "int TIFFSetupStrips(TIFF *tif)\n{\n    TIFFDirectory *td = &tif->tif_dir;\n\n    if (isTiled(tif))\n        td->td_stripsperimage = isUnspecified(tif, FIELD_TILEDIMENSIONS)\n                                    ? td->td_samplesperpixel\n                                    : TIFFNumberOfTiles(tif);\n    else\n        td->td_stripsperimage = isUnspecified(tif, FIELD_ROWSPERSTRIP)\n                                    ? td->td_samplesperpixel\n                                    : TIFFNumberOfStrips(tif);\n    td->td_nstrips = td->td_stripsperimage;\n    /* TIFFWriteDirectoryTagData has a limitation to 0x80000000U bytes */\n    if (td->td_nstrips >=\n        0x80000000U / ((tif->tif_flags & TIFF_BIGTIFF) ? 0x8U : 0x4U))\n    {\n        TIFFErrorExtR(tif, \"TIFFSetupStrips\",\n                      \"Too large Strip/Tile Offsets/ByteCounts arrays\");\n        return 0;\n    }\n    if (td->td_planarconfig == PLANARCONFIG_SEPARATE)\n        td->td_stripsperimage /= td->td_samplesperpixel;\n\n    if (td->td_stripoffset_p != NULL)\n        _TIFFfreeExt(tif, td->td_stripoffset_p);\n    td->td_stripoffset_p = (uint64_t *)_TIFFCheckMalloc(\n        tif, td->td_nstrips, sizeof(uint64_t), \"for \\\"StripOffsets\\\" array\");\n    if (td->td_stripbytecount_p != NULL)\n        _TIFFfreeExt(tif, td->td_stripbytecount_p);\n    td->td_stripbytecount_p = (uint64_t *)_TIFFCheckMalloc(\n        tif, td->td_nstrips, sizeof(uint64_t), \"for \\\"StripByteCounts\\\" array\");\n    if (td->td_stripoffset_p == NULL || td->td_stripbytecount_p == NULL)\n        return (0);\n    /*\n     * Place data at the end-of-file\n     * (by setting offsets to zero).\n     */\n    _TIFFmemset(td->td_stripoffset_p, 0, td->td_nstrips * sizeof(uint64_t));\n    _TIFFmemset(td->td_stripbytecount_p, 0, td->td_nstrips * sizeof(uint64_t));\n    TIFFSetFieldBit(tif, FIELD_STRIPOFFSETS);\n    TIFFSetFieldBit(tif, FIELD_STRIPBYTECOUNTS);\n    return (1);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_write.c",
        "metrics": {
            "nloc": 37,
            "cyclomatic_complexity": 11,
            "token_count": 282,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 277,
            "store_count": 101
        }
    },
    "TIFFWriteCheck": {
        "source_code": "int TIFFWriteCheck(TIFF *tif, int tiles, const char *module)\n{\n    if (tif->tif_mode == O_RDONLY)\n    {\n        TIFFErrorExtR(tif, module, \"File not open for writing\");\n        return (0);\n    }\n    if (tiles ^ isTiled(tif))\n    {\n        TIFFErrorExtR(tif, module,\n                      tiles ? \"Can not write tiles to a striped image\"\n                            : \"Can not write scanlines to a tiled image\");\n        return (0);\n    }\n\n    _TIFFFillStriles(tif);\n\n    /*\n     * On the first write verify all the required information\n     * has been setup and initialize any data structures that\n     * had to wait until directory information was set.\n     * Note that a lot of our work is assumed to remain valid\n     * because we disallow any of the important parameters\n     * from changing after we start writing (i.e. once\n     * TIFF_BEENWRITING is set, TIFFSetField will only allow\n     * the image's length to be changed).\n     */\n    if (!TIFFFieldSet(tif, FIELD_IMAGEDIMENSIONS))\n    {\n        TIFFErrorExtR(tif, module,\n                      \"Must set \\\"ImageWidth\\\" before writing data\");\n        return (0);\n    }\n    if (tif->tif_dir.td_stripoffset_p == NULL && !TIFFSetupStrips(tif))\n    {\n        tif->tif_dir.td_nstrips = 0;\n        TIFFErrorExtR(tif, module, \"No space for %s arrays\",\n                      isTiled(tif) ? \"tile\" : \"strip\");\n        return (0);\n    }\n    if (isTiled(tif))\n    {\n        tif->tif_tilesize = TIFFTileSize(tif);\n        if (tif->tif_tilesize == 0)\n            return (0);\n    }\n    else\n        tif->tif_tilesize = (tmsize_t)(-1);\n    tif->tif_scanlinesize = TIFFScanlineSize(tif);\n    if (tif->tif_scanlinesize == 0)\n        return (0);\n    tif->tif_flags |= TIFF_BEENWRITING;\n\n    if (tif->tif_dir.td_stripoffset_entry.tdir_tag != 0 &&\n        tif->tif_dir.td_stripoffset_entry.tdir_count == 0 &&\n        tif->tif_dir.td_stripoffset_entry.tdir_type == 0 &&\n        tif->tif_dir.td_stripoffset_entry.tdir_offset.toff_long8 == 0 &&\n        tif->tif_dir.td_stripbytecount_entry.tdir_tag != 0 &&\n        tif->tif_dir.td_stripbytecount_entry.tdir_count == 0 &&\n        tif->tif_dir.td_stripbytecount_entry.tdir_type == 0 &&\n        tif->tif_dir.td_stripbytecount_entry.tdir_offset.toff_long8 == 0 &&\n        !(tif->tif_flags & TIFF_DIRTYDIRECT))\n    {\n        TIFFForceStrileArrayWriting(tif);\n    }\n\n    return (1);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_write.c",
        "metrics": {
            "nloc": 54,
            "cyclomatic_complexity": 20,
            "token_count": 328,
            "parameter_count": 3
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 418,
            "store_count": 164
        }
    },
    "TIFFWriteBufferSetup": {
        "source_code": "int TIFFWriteBufferSetup(TIFF *tif, void *bp, tmsize_t size)\n{\n    static const char module[] = \"TIFFWriteBufferSetup\";\n\n    if (tif->tif_rawdata)\n    {\n        if (tif->tif_flags & TIFF_MYBUFFER)\n        {\n            _TIFFfreeExt(tif, tif->tif_rawdata);\n            tif->tif_flags &= ~TIFF_MYBUFFER;\n        }\n        tif->tif_rawdata = NULL;\n    }\n    if (size == (tmsize_t)(-1))\n    {\n        size = (isTiled(tif) ? tif->tif_tilesize : TIFFStripSize(tif));\n\n        /* Adds 10% margin for cases where compression would expand a bit */\n        if (size < TIFF_TMSIZE_T_MAX - size / 10)\n            size += size / 10;\n        /*\n         * Make raw data buffer at least 8K\n         */\n        if (size < 8 * 1024)\n            size = 8 * 1024;\n        bp = NULL; /* NB: force malloc */\n    }\n    if (bp == NULL)\n    {\n        bp = _TIFFmallocExt(tif, size);\n        if (bp == NULL)\n        {\n            TIFFErrorExtR(tif, module, \"No space for output buffer\");\n            return (0);\n        }\n        tif->tif_flags |= TIFF_MYBUFFER;\n    }\n    else\n        tif->tif_flags &= ~TIFF_MYBUFFER;\n    tif->tif_rawdata = (uint8_t *)bp;\n    tif->tif_rawdatasize = size;\n    tif->tif_rawcc = 0;\n    tif->tif_rawcp = tif->tif_rawdata;\n    tif->tif_flags |= TIFF_BUFFERSETUP;\n    return (1);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_write.c",
        "metrics": {
            "nloc": 40,
            "cyclomatic_complexity": 9,
            "token_count": 222,
            "parameter_count": 3
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 238,
            "store_count": 97
        }
    },
    "TIFFSetWriteOffset": {
        "source_code": "void TIFFSetWriteOffset(TIFF *tif, toff_t off)\n{\n    tif->tif_curoff = off;\n    tif->tif_lastvalidoff = 0;\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_write.c",
        "metrics": {
            "nloc": 5,
            "cyclomatic_complexity": 1,
            "token_count": 23,
            "parameter_count": 2
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 3,
            "store_count": 4
        }
    },
    "_TIFFGetExifFields": {
        "source_code": "const TIFFFieldArray *_TIFFGetExifFields(void) { return (&exifFieldArray); }\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_dirinfo.c",
        "metrics": {
            "nloc": 1,
            "cyclomatic_complexity": 1,
            "token_count": 12,
            "parameter_count": 0
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 0,
            "store_count": 0
        }
    },
    "_TIFFGetGpsFields": {
        "source_code": "const TIFFFieldArray *_TIFFGetGpsFields(void) { return (&gpsFieldArray); }\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_dirinfo.c",
        "metrics": {
            "nloc": 1,
            "cyclomatic_complexity": 1,
            "token_count": 12,
            "parameter_count": 0
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 0,
            "store_count": 0
        }
    },
    "TIFFDataWidth": {
        "source_code": "int TIFFDataWidth(TIFFDataType type)\n{\n    switch (type)\n    {\n        case 0: /* nothing */\n        case TIFF_BYTE:\n        case TIFF_ASCII:\n        case TIFF_SBYTE:\n        case TIFF_UNDEFINED:\n            return 1;\n        case TIFF_SHORT:\n        case TIFF_SSHORT:\n            return 2;\n        case TIFF_LONG:\n        case TIFF_SLONG:\n        case TIFF_FLOAT:\n        case TIFF_IFD:\n            return 4;\n        case TIFF_RATIONAL:\n        case TIFF_SRATIONAL:\n        case TIFF_DOUBLE:\n        case TIFF_LONG8:\n        case TIFF_SLONG8:\n        case TIFF_IFD8:\n            return 8;\n        default:\n            return 0; /* will return 0 for unknown types */\n    }\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_dirinfo.c",
        "metrics": {
            "nloc": 29,
            "cyclomatic_complexity": 18,
            "token_count": 81,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 2,
            "store_count": 6
        }
    },
    "TIFFFieldSetGetSize": {
        "source_code": "int TIFFFieldSetGetSize(const TIFFField *fip)\n{\n    /*\n     * TIFFSetField() and TIFFGetField() must provide the parameter accordingly\n     * to the definition of \"set_get_field_type\" of the tag definition in\n     * dir_info.c. This function returns the data size for that purpose.\n     *\n     * Furthermore, this data size is also used for the internal storage,\n     * even for TIFF_RATIONAL values for FIELD_CUSTOM, which are stored\n     * internally as 4-byte float, but some of them should be stored internally\n     * as 8-byte double, depending on the \"set_get_field_type\" _FLOAT_ or\n     * _DOUBLE_.\n     */\n    if (fip == NULL)\n        return 0;\n\n    switch (fip->set_get_field_type)\n    {\n        case TIFF_SETGET_UNDEFINED:\n        case TIFF_SETGET_ASCII:\n        case TIFF_SETGET_C0_ASCII:\n        case TIFF_SETGET_C16_ASCII:\n        case TIFF_SETGET_C32_ASCII:\n        case TIFF_SETGET_OTHER:\n            return 1;\n        case TIFF_SETGET_UINT8:\n        case TIFF_SETGET_SINT8:\n        case TIFF_SETGET_C0_UINT8:\n        case TIFF_SETGET_C0_SINT8:\n        case TIFF_SETGET_C16_UINT8:\n        case TIFF_SETGET_C16_SINT8:\n        case TIFF_SETGET_C32_UINT8:\n        case TIFF_SETGET_C32_SINT8:\n            return 1;\n        case TIFF_SETGET_UINT16:\n        case TIFF_SETGET_SINT16:\n        case TIFF_SETGET_C0_UINT16:\n        case TIFF_SETGET_C0_SINT16:\n        case TIFF_SETGET_C16_UINT16:\n        case TIFF_SETGET_C16_SINT16:\n        case TIFF_SETGET_C32_UINT16:\n        case TIFF_SETGET_C32_SINT16:\n            return 2;\n        case TIFF_SETGET_INT:\n        case TIFF_SETGET_UINT32:\n        case TIFF_SETGET_SINT32:\n        case TIFF_SETGET_FLOAT:\n        case TIFF_SETGET_UINT16_PAIR:\n        case TIFF_SETGET_C0_UINT32:\n        case TIFF_SETGET_C0_SINT32:\n        case TIFF_SETGET_C0_FLOAT:\n        case TIFF_SETGET_C16_UINT32:\n        case TIFF_SETGET_C16_SINT32:\n        case TIFF_SETGET_C16_FLOAT:\n        case TIFF_SETGET_C32_UINT32:\n        case TIFF_SETGET_C32_SINT32:\n        case TIFF_SETGET_C32_FLOAT:\n            return 4;\n        case TIFF_SETGET_UINT64:\n        case TIFF_SETGET_SINT64:\n        case TIFF_SETGET_DOUBLE:\n        case TIFF_SETGET_IFD8:\n        case TIFF_SETGET_C0_UINT64:\n        case TIFF_SETGET_C0_SINT64:\n        case TIFF_SETGET_C0_DOUBLE:\n        case TIFF_SETGET_C0_IFD8:\n        case TIFF_SETGET_C16_UINT64:\n        case TIFF_SETGET_C16_SINT64:\n        case TIFF_SETGET_C16_DOUBLE:\n        case TIFF_SETGET_C16_IFD8:\n        case TIFF_SETGET_C32_UINT64:\n        case TIFF_SETGET_C32_SINT64:\n        case TIFF_SETGET_C32_DOUBLE:\n        case TIFF_SETGET_C32_IFD8:\n            return 8;\n        default:\n            return 0;\n    }\n} /*-- TIFFFieldSetGetSize() --- */\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_dirinfo.c",
        "metrics": {
            "nloc": 67,
            "cyclomatic_complexity": 54,
            "token_count": 202,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 4,
            "store_count": 8
        }
    },
    "TIFFFieldSetGetCountSize": {
        "source_code": "int TIFFFieldSetGetCountSize(const TIFFField *fip)\n{\n    if (fip == NULL)\n        return 0;\n\n    switch (fip->set_get_field_type)\n    {\n        case TIFF_SETGET_C16_ASCII:\n        case TIFF_SETGET_C16_UINT8:\n        case TIFF_SETGET_C16_SINT8:\n        case TIFF_SETGET_C16_UINT16:\n        case TIFF_SETGET_C16_SINT16:\n        case TIFF_SETGET_C16_UINT32:\n        case TIFF_SETGET_C16_SINT32:\n        case TIFF_SETGET_C16_FLOAT:\n        case TIFF_SETGET_C16_UINT64:\n        case TIFF_SETGET_C16_SINT64:\n        case TIFF_SETGET_C16_DOUBLE:\n        case TIFF_SETGET_C16_IFD8:\n            return 2;\n        case TIFF_SETGET_C32_ASCII:\n        case TIFF_SETGET_C32_UINT8:\n        case TIFF_SETGET_C32_SINT8:\n        case TIFF_SETGET_C32_UINT16:\n        case TIFF_SETGET_C32_SINT16:\n        case TIFF_SETGET_C32_UINT32:\n        case TIFF_SETGET_C32_SINT32:\n        case TIFF_SETGET_C32_FLOAT:\n        case TIFF_SETGET_C32_UINT64:\n        case TIFF_SETGET_C32_SINT64:\n        case TIFF_SETGET_C32_DOUBLE:\n        case TIFF_SETGET_C32_IFD8:\n            return 4;\n        default:\n            return 0;\n    }\n} /*-- TIFFFieldSetGetCountSize() --- */\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_dirinfo.c",
        "metrics": {
            "nloc": 36,
            "cyclomatic_complexity": 26,
            "token_count": 109,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 4,
            "store_count": 5
        }
    },
    "TIFFFindField": {
        "source_code": "const TIFFField *TIFFFindField(TIFF *tif, uint32_t tag, TIFFDataType dt)\n{\n    TIFFField key = {0, 0, 0, TIFF_NOTYPE, 0, 0, 0, 0, 0, NULL, NULL};\n    TIFFField *pkey = &key;\n    const TIFFField **ret;\n    if (tif->tif_foundfield && tif->tif_foundfield->field_tag == tag &&\n        (dt == TIFF_ANY || dt == tif->tif_foundfield->field_type))\n        return tif->tif_foundfield;\n\n    /* If we are invoked with no field information, then just return. */\n    if (!tif->tif_fields)\n        return NULL;\n\n    /* NB: use sorted search (e.g. binary search) */\n\n    key.field_tag = tag;\n    key.field_type = dt;\n\n    ret = (const TIFFField **)bsearch(&pkey, tif->tif_fields, tif->tif_nfields,\n                                      sizeof(TIFFField *), tagCompare);\n    return tif->tif_foundfield = (ret ? *ret : NULL);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_dirinfo.c",
        "metrics": {
            "nloc": 16,
            "cyclomatic_complexity": 7,
            "token_count": 151,
            "parameter_count": 3
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 26,
            "store_count": 11
        }
    },
    "TIFFFieldWithTag": {
        "source_code": "const TIFFField *TIFFFieldWithTag(TIFF *tif, uint32_t tag)\n{\n    const TIFFField *fip = TIFFFindField(tif, tag, TIFF_ANY);\n    if (!fip)\n    {\n        TIFFWarningExtR(tif, \"TIFFFieldWithTag\", \"Warning, unknown tag 0x%x\",\n                        (unsigned int)tag);\n    }\n    return (fip);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_dirinfo.c",
        "metrics": {
            "nloc": 10,
            "cyclomatic_complexity": 2,
            "token_count": 52,
            "parameter_count": 2
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 54,
            "store_count": 18
        }
    },
    "TIFFFieldWithName": {
        "source_code": "const TIFFField *TIFFFieldWithName(TIFF *tif, const char *field_name)\n{\n    const TIFFField *fip = _TIFFFindFieldByName(tif, field_name, TIFF_ANY);\n    if (!fip)\n    {\n        TIFFWarningExtR(tif, \"TIFFFieldWithName\", \"Warning, unknown tag %s\",\n                        field_name);\n    }\n    return (fip);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_dirinfo.c",
        "metrics": {
            "nloc": 10,
            "cyclomatic_complexity": 2,
            "token_count": 50,
            "parameter_count": 2
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 53,
            "store_count": 18
        }
    },
    "TIFFFieldTag": {
        "source_code": "uint32_t TIFFFieldTag(const TIFFField *fip) { return fip->field_tag; }\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_dirinfo.c",
        "metrics": {
            "nloc": 1,
            "cyclomatic_complexity": 1,
            "token_count": 14,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 2,
            "store_count": 1
        }
    },
    "TIFFFieldName": {
        "source_code": "const char *TIFFFieldName(const TIFFField *fip) { return fip->field_name; }\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_dirinfo.c",
        "metrics": {
            "nloc": 1,
            "cyclomatic_complexity": 1,
            "token_count": 14,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 2,
            "store_count": 1
        }
    },
    "TIFFFieldDataType": {
        "source_code": "TIFFDataType TIFFFieldDataType(const TIFFField *fip) { return fip->field_type; }\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_dirinfo.c",
        "metrics": {
            "nloc": 1,
            "cyclomatic_complexity": 1,
            "token_count": 14,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 2,
            "store_count": 1
        }
    },
    "TIFFFieldPassCount": {
        "source_code": "int TIFFFieldPassCount(const TIFFField *fip) { return fip->field_passcount; }\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_dirinfo.c",
        "metrics": {
            "nloc": 1,
            "cyclomatic_complexity": 1,
            "token_count": 14,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 2,
            "store_count": 1
        }
    },
    "TIFFFieldReadCount": {
        "source_code": "int TIFFFieldReadCount(const TIFFField *fip) { return fip->field_readcount; }\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_dirinfo.c",
        "metrics": {
            "nloc": 1,
            "cyclomatic_complexity": 1,
            "token_count": 14,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 2,
            "store_count": 1
        }
    },
    "TIFFFieldWriteCount": {
        "source_code": "int TIFFFieldWriteCount(const TIFFField *fip) { return fip->field_writecount; }\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_dirinfo.c",
        "metrics": {
            "nloc": 1,
            "cyclomatic_complexity": 1,
            "token_count": 14,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 2,
            "store_count": 1
        }
    },
    "TIFFFieldIsAnonymous": {
        "source_code": "int TIFFFieldIsAnonymous(const TIFFField *fip) { return fip->field_anonymous; }\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_dirinfo.c",
        "metrics": {
            "nloc": 1,
            "cyclomatic_complexity": 1,
            "token_count": 14,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 2,
            "store_count": 1
        }
    },
    "TIFFMergeFieldInfo": {
        "source_code": "int TIFFMergeFieldInfo(TIFF *tif, const TIFFFieldInfo info[], uint32_t n)\n{\n    static const char module[] = \"TIFFMergeFieldInfo\";\n    static const char reason[] = \"for fields array\";\n    TIFFField *tp;\n    size_t nfields;\n    uint32_t i;\n\n    if (tif->tif_nfieldscompat > 0)\n    {\n        tif->tif_fieldscompat = (TIFFFieldArray *)_TIFFCheckRealloc(\n            tif, tif->tif_fieldscompat, tif->tif_nfieldscompat + 1,\n            sizeof(TIFFFieldArray), reason);\n    }\n    else\n    {\n        tif->tif_fieldscompat = (TIFFFieldArray *)_TIFFCheckMalloc(\n            tif, 1, sizeof(TIFFFieldArray), reason);\n    }\n    if (!tif->tif_fieldscompat)\n    {\n        TIFFErrorExtR(tif, module, \"Failed to allocate fields array\");\n        return -1;\n    }\n    nfields = tif->tif_nfieldscompat++;\n\n    tif->tif_fieldscompat[nfields].type = tfiatOther;\n    tif->tif_fieldscompat[nfields].allocated_size = n;\n    tif->tif_fieldscompat[nfields].count = n;\n    tif->tif_fieldscompat[nfields].fields =\n        (TIFFField *)_TIFFCheckMalloc(tif, n, sizeof(TIFFField), reason);\n    if (!tif->tif_fieldscompat[nfields].fields)\n    {\n        TIFFErrorExtR(tif, module, \"Failed to allocate fields array\");\n        return -1;\n    }\n\n    tp = tif->tif_fieldscompat[nfields].fields;\n    for (i = 0; i < n; i++)\n    {\n        tp->field_tag = info[i].field_tag;\n        if (info[i].field_readcount < TIFF_VARIABLE2 ||\n            info[i].field_writecount < TIFF_VARIABLE2)\n        {\n            /* The fields (field_readcount) and (field_writecount) may use the\n             * values TIFF_VARIABLE (-1), TIFF_SPP (-2), TIFF_VARIABLE2 (-3). */\n            TIFFErrorExtR(\n                tif, module,\n                \"The value of field_readcount %d and field_writecount %d \"\n                \"must be greater than or equal to -3.\",\n                info[i].field_readcount, info[i].field_writecount);\n            return -1;\n        }\n        if ((info[i].field_readcount == 0 || info[i].field_writecount == 0) &&\n            info[i].field_bit != FIELD_IGNORE)\n        {\n            /* The fields (field_readcount) and (field_writecount) may only\n            be zero for pseudo_tags or ignored tags. */\n            TIFFErrorExtR(\n                tif, module,\n                \"The value of field_readcount %d and field_writecount %d \"\n                \"may only be zero for field_bit = 0 (i.e. ignored tags).\",\n                info[i].field_readcount, info[i].field_writecount);\n            return -1;\n        }\n        tp->field_readcount = info[i].field_readcount;\n        tp->field_writecount = info[i].field_writecount;\n        tp->field_type = info[i].field_type;\n        tp->field_anonymous = 0;\n        tp->set_get_field_type =\n            _TIFFSetGetType(info[i].field_type, info[i].field_writecount,\n                            info[i].field_passcount);\n        tp->field_bit = info[i].field_bit;\n        tp->field_oktochange = info[i].field_oktochange;\n        tp->field_passcount = info[i].field_passcount;\n        /* Define an empty static string to be passed as field_name where a NULL\n         * pointer is passed in. Otherwise, this will lead to buffer overflow\n         * furtheron. */\n        if (info[i].field_name == NULL)\n        {\n            static const char *string_static_empty = \"\";\n            tp->field_name = (char *)string_static_empty;\n        }\n        else\n        {\n            tp->field_name = info[i].field_name;\n        }\n        tp->field_subfields = NULL;\n        tp++;\n    }\n\n    if (!_TIFFMergeFields(tif, tif->tif_fieldscompat[nfields].fields, n))\n    {\n        TIFFErrorExtR(tif, module, \"Setting up field info failed\");\n        return -1;\n    }\n\n    return 0;\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_dirinfo.c",
        "metrics": {
            "nloc": 87,
            "cyclomatic_complexity": 12,
            "token_count": 565,
            "parameter_count": 2
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 384,
            "store_count": 201
        }
    },
    "TIFFSetErrorHandler": {
        "source_code": "TIFFErrorHandler TIFFSetErrorHandler(TIFFErrorHandler handler)\n{\n    TIFFErrorHandler prev = _TIFFerrorHandler;\n    _TIFFerrorHandler = handler;\n    return (prev);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_error.c",
        "metrics": {
            "nloc": 6,
            "cyclomatic_complexity": 1,
            "token_count": 21,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 3,
            "store_count": 3
        }
    },
    "TIFFSetErrorHandlerExt": {
        "source_code": "TIFFErrorHandlerExt TIFFSetErrorHandlerExt(TIFFErrorHandlerExt handler)\n{\n    TIFFErrorHandlerExt prev = _TIFFerrorHandlerExt;\n    _TIFFerrorHandlerExt = handler;\n    return (prev);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_error.c",
        "metrics": {
            "nloc": 6,
            "cyclomatic_complexity": 1,
            "token_count": 21,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 3,
            "store_count": 3
        }
    },
    "TIFFError": {
        "source_code": "void TIFFError(const char *module, const char *fmt, ...)\n{\n    va_list ap;\n    if (_TIFFerrorHandler)\n    {\n        va_start(ap, fmt);\n        (*_TIFFerrorHandler)(module, fmt, ap);\n        va_end(ap);\n    }\n    if (_TIFFerrorHandlerExt)\n    {\n        va_start(ap, fmt);\n        (*_TIFFerrorHandlerExt)(0, module, fmt, ap);\n        va_end(ap);\n    }\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_error.c",
        "metrics": {
            "nloc": 16,
            "cyclomatic_complexity": 3,
            "token_count": 81,
            "parameter_count": 2
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 8,
            "store_count": 2
        }
    },
    "TIFFErrorExt": {
        "source_code": "void TIFFErrorExt(thandle_t fd, const char *module, const char *fmt, ...)\n{\n    va_list ap;\n    if (_TIFFerrorHandler)\n    {\n        va_start(ap, fmt);\n        (*_TIFFerrorHandler)(module, fmt, ap);\n        va_end(ap);\n    }\n    if (_TIFFerrorHandlerExt)\n    {\n        va_start(ap, fmt);\n        (*_TIFFerrorHandlerExt)(fd, module, fmt, ap);\n        va_end(ap);\n    }\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_error.c",
        "metrics": {
            "nloc": 16,
            "cyclomatic_complexity": 3,
            "token_count": 84,
            "parameter_count": 3
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 9,
            "store_count": 3
        }
    },
    "TIFFErrorExtR": {
        "source_code": "void TIFFErrorExtR(TIFF *tif, const char *module, const char *fmt, ...)\n{\n    va_list ap;\n    if (tif && tif->tif_errorhandler)\n    {\n        va_start(ap, fmt);\n        int stop = (*tif->tif_errorhandler)(\n            tif, tif->tif_errorhandler_user_data, module, fmt, ap);\n        va_end(ap);\n        if (stop)\n            return;\n    }\n    if (_TIFFerrorHandler)\n    {\n        va_start(ap, fmt);\n        (*_TIFFerrorHandler)(module, fmt, ap);\n        va_end(ap);\n    }\n    if (_TIFFerrorHandlerExt)\n    {\n        va_start(ap, fmt);\n        (*_TIFFerrorHandlerExt)(tif ? tif->tif_clientdata : NULL, module, fmt,\n                                ap);\n        va_end(ap);\n    }\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_error.c",
        "metrics": {
            "nloc": 26,
            "cyclomatic_complexity": 7,
            "token_count": 142,
            "parameter_count": 3
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 22,
            "store_count": 4
        }
    },
    "TIFFWriteDirectory": {
        "source_code": "int TIFFWriteDirectory(TIFF *tif)\n{\n    return TIFFWriteDirectorySec(tif, TRUE, TRUE, NULL);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_dirwrite.c",
        "metrics": {
            "nloc": 4,
            "cyclomatic_complexity": 1,
            "token_count": 20,
            "parameter_count": 1
        },
        "cve_info": [
            {
                "CVE_ID": "CVE-2016-3658",
                "Description": "The TIFFWriteDirectoryTagLongLong8Array function in tif_dirwrite.c in the tiffset tool in LibTIFF 4.0.6 and earlier allows remote attackers to cause a denial of service (out-of-bounds read) via vectors involving the ma variable."
            },
            {
                "CVE_ID": "CVE-2016-10371",
                "Description": "The TIFFWriteDirectoryTagCheckedRational function in tif_dirwrite.c in LibTIFF 4.0.6 allows remote attackers to cause a denial of service (assertion failure and application exit) via a crafted TIFF file."
            },
            {
                "CVE_ID": "CVE-2014-8127",
                "Description": "LibTIFF 4.0.3 allows remote attackers to cause a denial of service (out-of-bounds read and crash) via a crafted TIFF image to the (1) checkInkNamesString function in tif_dir.c in the thumbnail tool, (2) compresscontig function in tiff2bw.c in the tiff2bw tool, (3) putcontig8bitCIELab function in tif_getimage.c in the tiff2rgba tool, LZWPreDecode function in tif_lzw.c in the (4) tiff2ps or (5) tiffdither tool, (6) NeXTDecode function in tif_next.c in the tiffmedian tool, or (7) TIFFWriteDirectoryTagLongLong8Array function in tif_dirwrite.c in the tiffset tool."
            },
            {
                "CVE_ID": "CVE-2017-10688",
                "Description": "In LibTIFF 4.0.8, there is a assertion abort in the TIFFWriteDirectoryTagCheckedLong8Array function in tif_dirwrite.c. A crafted input will lead to a remote denial of service attack."
            },
            {
                "CVE_ID": "CVE-2017-13726",
                "Description": "There is a reachable assertion abort in the function TIFFWriteDirectorySec() in LibTIFF 4.0.8, related to tif_dirwrite.c and a SubIFD tag. A crafted input will lead to a remote denial of service attack."
            }
        ],
        "cve_count": 5,
        "instruction": {
            "load_count": 815,
            "store_count": 90
        }
    },
    "TIFFDeferStrileArrayWriting": {
        "source_code": "int TIFFDeferStrileArrayWriting(TIFF *tif)\n{\n    static const char module[] = \"TIFFDeferStrileArrayWriting\";\n    if (tif->tif_mode == O_RDONLY)\n    {\n        TIFFErrorExtR(tif, tif->tif_name, \"File opened in read-only mode\");\n        return 0;\n    }\n    if (tif->tif_diroff != 0)\n    {\n        TIFFErrorExtR(tif, module, \"Directory has already been written\");\n        return 0;\n    }\n\n    tif->tif_dir.td_deferstrilearraywriting = TRUE;\n    return 1;\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_dirwrite.c",
        "metrics": {
            "nloc": 16,
            "cyclomatic_complexity": 3,
            "token_count": 74,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 10,
            "store_count": 5
        }
    },
    "TIFFCheckpointDirectory": {
        "source_code": "int TIFFCheckpointDirectory(TIFF *tif)\n{\n    int rc;\n    /* Setup the strips arrays, if they haven't already been. */\n    if (tif->tif_dir.td_stripoffset_p == NULL)\n        (void)TIFFSetupStrips(tif);\n    rc = TIFFWriteDirectorySec(tif, TRUE, FALSE, NULL);\n    (void)TIFFSetWriteOffset(tif, TIFFSeekFile(tif, 0, SEEK_END));\n    return rc;\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_dirwrite.c",
        "metrics": {
            "nloc": 9,
            "cyclomatic_complexity": 2,
            "token_count": 62,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 2786,
            "store_count": 1005
        }
    },
    "TIFFWriteCustomDirectory": {
        "source_code": "int TIFFWriteCustomDirectory(TIFF *tif, uint64_t *pdiroff)\n{\n    return TIFFWriteDirectorySec(tif, FALSE, FALSE, pdiroff);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_dirwrite.c",
        "metrics": {
            "nloc": 4,
            "cyclomatic_complexity": 1,
            "token_count": 24,
            "parameter_count": 2
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 2778,
            "store_count": 1005
        }
    },
    "TIFFRewriteDirectory": {
        "source_code": "int TIFFRewriteDirectory(TIFF *tif)\n{\n    return TIFFRewriteDirectorySec(tif, TRUE, TRUE, NULL);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_dirwrite.c",
        "metrics": {
            "nloc": 4,
            "cyclomatic_complexity": 1,
            "token_count": 20,
            "parameter_count": 1
        },
        "cve_info": [
            {
                "CVE_ID": "CVE-2019-15141",
                "Description": "WriteTIFFImage in coders/tiff.c in ImageMagick 7.0.8-43 Q16 allows attackers to cause a denial-of-service (application crash resulting from a heap-based buffer over-read) via a crafted TIFF image file, related to TIFFRewriteDirectory, TIFFWriteDirectory, TIFFWriteDirectorySec, and TIFFWriteDirectoryTagColormap in tif_dirwrite.c of LibTIFF. NOTE: this occurs because of an incomplete fix for CVE-2019-11597."
            }
        ],
        "cve_count": 1,
        "instruction": {
            "load_count": 3855,
            "store_count": 1189
        }
    },
    "_TIFFRewriteField": {
        "source_code": "int _TIFFRewriteField(TIFF *tif, uint16_t tag, TIFFDataType in_datatype,\n                      tmsize_t count, void *data)\n{\n    static const char module[] = \"TIFFResetField\";\n    /* const TIFFField* fip = NULL; */\n    uint16_t dircount;\n    tmsize_t dirsize;\n    uint8_t direntry_raw[20];\n    uint16_t entry_tag = 0;\n    uint16_t entry_type = 0;\n    uint64_t entry_count = 0;\n    uint64_t entry_offset = 0;\n    int value_in_entry = 0;\n    uint64_t read_offset;\n    uint8_t *buf_to_write = NULL;\n    TIFFDataType datatype;\n\n    /* -------------------------------------------------------------------- */\n    /*      Find field definition.                                          */\n    /* -------------------------------------------------------------------- */\n    /*fip =*/TIFFFindField(tif, tag, TIFF_ANY);\n\n    /* -------------------------------------------------------------------- */\n    /*      Do some checking this is a straight forward case.               */\n    /* -------------------------------------------------------------------- */\n    if (isMapped(tif))\n    {\n        TIFFErrorExtR(tif, module,\n                      \"Memory mapped files not currently supported for \"\n                      \"this operation.\");\n        return 0;\n    }\n\n    if (tif->tif_diroff == 0)\n    {\n        TIFFErrorExtR(\n            tif, module,\n            \"Attempt to reset field on directory not already on disk.\");\n        return 0;\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Read the directory entry count.                                 */\n    /* -------------------------------------------------------------------- */\n    if (!SeekOK(tif, tif->tif_diroff))\n    {\n        TIFFErrorExtR(tif, module, \"%s: Seek error accessing TIFF directory\",\n                      tif->tif_name);\n        return 0;\n    }\n\n    read_offset = tif->tif_diroff;\n\n    if (!(tif->tif_flags & TIFF_BIGTIFF))\n    {\n        if (!ReadOK(tif, &dircount, sizeof(uint16_t)))\n        {\n            TIFFErrorExtR(tif, module, \"%s: Can not read TIFF directory count\",\n                          tif->tif_name);\n            return 0;\n        }\n        if (tif->tif_flags & TIFF_SWAB)\n            TIFFSwabShort(&dircount);\n        dirsize = 12;\n        read_offset += 2;\n    }\n    else\n    {\n        uint64_t dircount64;\n        if (!ReadOK(tif, &dircount64, sizeof(uint64_t)))\n        {\n            TIFFErrorExtR(tif, module, \"%s: Can not read TIFF directory count\",\n                          tif->tif_name);\n            return 0;\n        }\n        if (tif->tif_flags & TIFF_SWAB)\n            TIFFSwabLong8(&dircount64);\n        dircount = (uint16_t)dircount64;\n        dirsize = 20;\n        read_offset += 8;\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Read through directory to find target tag.                      */\n    /* -------------------------------------------------------------------- */\n    while (dircount > 0)\n    {\n        if (!ReadOK(tif, direntry_raw, dirsize))\n        {\n            TIFFErrorExtR(tif, module, \"%s: Can not read TIFF directory entry.\",\n                          tif->tif_name);\n            return 0;\n        }\n\n        memcpy(&entry_tag, direntry_raw + 0, sizeof(uint16_t));\n        if (tif->tif_flags & TIFF_SWAB)\n            TIFFSwabShort(&entry_tag);\n\n        if (entry_tag == tag)\n            break;\n\n        read_offset += dirsize;\n    }\n\n    if (entry_tag != tag)\n    {\n        TIFFErrorExtR(tif, module, \"%s: Could not find tag %\" PRIu16 \".\",\n                      tif->tif_name, tag);\n        return 0;\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Extract the type, count and offset for this entry.              */\n    /* -------------------------------------------------------------------- */\n    memcpy(&entry_type, direntry_raw + 2, sizeof(uint16_t));\n    if (tif->tif_flags & TIFF_SWAB)\n        TIFFSwabShort(&entry_type);\n\n    if (!(tif->tif_flags & TIFF_BIGTIFF))\n    {\n        uint32_t value;\n\n        memcpy(&value, direntry_raw + 4, sizeof(uint32_t));\n        if (tif->tif_flags & TIFF_SWAB)\n            TIFFSwabLong(&value);\n        entry_count = value;\n\n        memcpy(&value, direntry_raw + 8, sizeof(uint32_t));\n        if (tif->tif_flags & TIFF_SWAB)\n            TIFFSwabLong(&value);\n        entry_offset = value;\n    }\n    else\n    {\n        memcpy(&entry_count, direntry_raw + 4, sizeof(uint64_t));\n        if (tif->tif_flags & TIFF_SWAB)\n            TIFFSwabLong8(&entry_count);\n\n        memcpy(&entry_offset, direntry_raw + 12, sizeof(uint64_t));\n        if (tif->tif_flags & TIFF_SWAB)\n            TIFFSwabLong8(&entry_offset);\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      When a dummy tag was written due to TIFFDeferStrileArrayWriting() */\n    /* -------------------------------------------------------------------- */\n    if (entry_offset == 0 && entry_count == 0 && entry_type == 0)\n    {\n        if (tag == TIFFTAG_TILEOFFSETS || tag == TIFFTAG_STRIPOFFSETS)\n        {\n            entry_type =\n                (tif->tif_flags & TIFF_BIGTIFF) ? TIFF_LONG8 : TIFF_LONG;\n        }\n        else\n        {\n            int write_aslong8 = 1;\n            if (count > 1 && tag == TIFFTAG_STRIPBYTECOUNTS)\n            {\n                write_aslong8 = WriteAsLong8(tif, TIFFStripSize64(tif));\n            }\n            else if (count > 1 && tag == TIFFTAG_TILEBYTECOUNTS)\n            {\n                write_aslong8 = WriteAsLong8(tif, TIFFTileSize64(tif));\n            }\n            if (write_aslong8)\n            {\n                entry_type = TIFF_LONG8;\n            }\n            else\n            {\n                int write_aslong4 = 1;\n                if (count > 1 && tag == TIFFTAG_STRIPBYTECOUNTS)\n                {\n                    write_aslong4 = WriteAsLong4(tif, TIFFStripSize64(tif));\n                }\n                else if (count > 1 && tag == TIFFTAG_TILEBYTECOUNTS)\n                {\n                    write_aslong4 = WriteAsLong4(tif, TIFFTileSize64(tif));\n                }\n                if (write_aslong4)\n                {\n                    entry_type = TIFF_LONG;\n                }\n                else\n                {\n                    entry_type = TIFF_SHORT;\n                }\n            }\n        }\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      What data type do we want to write this as?                     */\n    /* -------------------------------------------------------------------- */\n    if (TIFFDataWidth(in_datatype) == 8 && !(tif->tif_flags & TIFF_BIGTIFF))\n    {\n        if (in_datatype == TIFF_LONG8)\n            datatype = entry_type == TIFF_SHORT ? TIFF_SHORT : TIFF_LONG;\n        else if (in_datatype == TIFF_SLONG8)\n            datatype = TIFF_SLONG;\n        else if (in_datatype == TIFF_IFD8)\n            datatype = TIFF_IFD;\n        else\n            datatype = in_datatype;\n    }\n    else\n    {\n        if (in_datatype == TIFF_LONG8 &&\n            (entry_type == TIFF_SHORT || entry_type == TIFF_LONG ||\n             entry_type == TIFF_LONG8))\n            datatype = entry_type;\n        else if (in_datatype == TIFF_SLONG8 &&\n                 (entry_type == TIFF_SLONG || entry_type == TIFF_SLONG8))\n            datatype = entry_type;\n        else if (in_datatype == TIFF_IFD8 &&\n                 (entry_type == TIFF_IFD || entry_type == TIFF_IFD8))\n            datatype = entry_type;\n        else\n            datatype = in_datatype;\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Prepare buffer of actual data to write.  This includes          */\n    /*      swabbing as needed.                                             */\n    /* -------------------------------------------------------------------- */\n    buf_to_write = (uint8_t *)_TIFFCheckMalloc(\n        tif, count, TIFFDataWidth(datatype), \"for field buffer.\");\n    if (!buf_to_write)\n        return 0;\n\n    if (datatype == in_datatype)\n        memcpy(buf_to_write, data, count * TIFFDataWidth(datatype));\n    else if (datatype == TIFF_SLONG && in_datatype == TIFF_SLONG8)\n    {\n        tmsize_t i;\n\n        for (i = 0; i < count; i++)\n        {\n            ((int32_t *)buf_to_write)[i] = (int32_t)((int64_t *)data)[i];\n            if ((int64_t)((int32_t *)buf_to_write)[i] != ((int64_t *)data)[i])\n            {\n                _TIFFfreeExt(tif, buf_to_write);\n                TIFFErrorExtR(tif, module,\n                              \"Value exceeds 32bit range of output type.\");\n                return 0;\n            }\n        }\n    }\n    else if ((datatype == TIFF_LONG && in_datatype == TIFF_LONG8) ||\n             (datatype == TIFF_IFD && in_datatype == TIFF_IFD8))\n    {\n        tmsize_t i;\n\n        for (i = 0; i < count; i++)\n        {\n            ((uint32_t *)buf_to_write)[i] = (uint32_t)((uint64_t *)data)[i];\n            if ((uint64_t)((uint32_t *)buf_to_write)[i] !=\n                ((uint64_t *)data)[i])\n            {\n                _TIFFfreeExt(tif, buf_to_write);\n                TIFFErrorExtR(tif, module,\n                              \"Value exceeds 32bit range of output type.\");\n                return 0;\n            }\n        }\n    }\n    else if (datatype == TIFF_SHORT && in_datatype == TIFF_LONG8)\n    {\n        tmsize_t i;\n\n        for (i = 0; i < count; i++)\n        {\n            ((uint16_t *)buf_to_write)[i] = (uint16_t)((uint64_t *)data)[i];\n            if ((uint64_t)((uint16_t *)buf_to_write)[i] !=\n                ((uint64_t *)data)[i])\n            {\n                _TIFFfreeExt(tif, buf_to_write);\n                TIFFErrorExtR(tif, module,\n                              \"Value exceeds 16bit range of output type.\");\n                return 0;\n            }\n        }\n    }\n    else\n    {\n        TIFFErrorExtR(tif, module, \"Unhandled type conversion.\");\n        return 0;\n    }\n\n    if (TIFFDataWidth(datatype) > 1 && (tif->tif_flags & TIFF_SWAB))\n    {\n        if (TIFFDataWidth(datatype) == 2)\n            TIFFSwabArrayOfShort((uint16_t *)buf_to_write, count);\n        else if (TIFFDataWidth(datatype) == 4)\n            TIFFSwabArrayOfLong((uint32_t *)buf_to_write, count);\n        else if (TIFFDataWidth(datatype) == 8)\n            TIFFSwabArrayOfLong8((uint64_t *)buf_to_write, count);\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Is this a value that fits into the directory entry?             */\n    /* -------------------------------------------------------------------- */\n    if (!(tif->tif_flags & TIFF_BIGTIFF))\n    {\n        if (TIFFDataWidth(datatype) * count <= 4)\n        {\n            entry_offset = read_offset + 8;\n            value_in_entry = 1;\n        }\n    }\n    else\n    {\n        if (TIFFDataWidth(datatype) * count <= 8)\n        {\n            entry_offset = read_offset + 12;\n            value_in_entry = 1;\n        }\n    }\n\n    if ((tag == TIFFTAG_TILEOFFSETS || tag == TIFFTAG_STRIPOFFSETS) &&\n        tif->tif_dir.td_stripoffset_entry.tdir_count == 0 &&\n        tif->tif_dir.td_stripoffset_entry.tdir_type == 0 &&\n        tif->tif_dir.td_stripoffset_entry.tdir_offset.toff_long8 == 0)\n    {\n        tif->tif_dir.td_stripoffset_entry.tdir_type = datatype;\n        tif->tif_dir.td_stripoffset_entry.tdir_count = count;\n    }\n    else if ((tag == TIFFTAG_TILEBYTECOUNTS ||\n              tag == TIFFTAG_STRIPBYTECOUNTS) &&\n             tif->tif_dir.td_stripbytecount_entry.tdir_count == 0 &&\n             tif->tif_dir.td_stripbytecount_entry.tdir_type == 0 &&\n             tif->tif_dir.td_stripbytecount_entry.tdir_offset.toff_long8 == 0)\n    {\n        tif->tif_dir.td_stripbytecount_entry.tdir_type = datatype;\n        tif->tif_dir.td_stripbytecount_entry.tdir_count = count;\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      If the tag type, and count match, then we just write it out     */\n    /*      over the old values without altering the directory entry at     */\n    /*      all.                                                            */\n    /* -------------------------------------------------------------------- */\n    if (entry_count == (uint64_t)count && entry_type == (uint16_t)datatype)\n    {\n        if (!SeekOK(tif, entry_offset))\n        {\n            _TIFFfreeExt(tif, buf_to_write);\n            TIFFErrorExtR(tif, module,\n                          \"%s: Seek error accessing TIFF directory\",\n                          tif->tif_name);\n            return 0;\n        }\n        if (!WriteOK(tif, buf_to_write, count * TIFFDataWidth(datatype)))\n        {\n            _TIFFfreeExt(tif, buf_to_write);\n            TIFFErrorExtR(tif, module, \"Error writing directory link\");\n            return (0);\n        }\n\n        _TIFFfreeExt(tif, buf_to_write);\n        return 1;\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Otherwise, we write the new tag data at the end of the file.    */\n    /* -------------------------------------------------------------------- */\n    if (!value_in_entry)\n    {\n        entry_offset = TIFFSeekFile(tif, 0, SEEK_END);\n\n        if (!WriteOK(tif, buf_to_write, count * TIFFDataWidth(datatype)))\n        {\n            _TIFFfreeExt(tif, buf_to_write);\n            TIFFErrorExtR(tif, module, \"Error writing directory link\");\n            return (0);\n        }\n    }\n    else\n    {\n        if (count * TIFFDataWidth(datatype) == 4)\n        {\n            uint32_t value;\n            memcpy(&value, buf_to_write, count * TIFFDataWidth(datatype));\n            entry_offset = value;\n        }\n        else\n        {\n            memcpy(&entry_offset, buf_to_write,\n                   count * TIFFDataWidth(datatype));\n        }\n    }\n\n    _TIFFfreeExt(tif, buf_to_write);\n    buf_to_write = 0;\n\n    /* -------------------------------------------------------------------- */\n    /*      Adjust the directory entry.                                     */\n    /* -------------------------------------------------------------------- */\n    entry_type = datatype;\n    entry_count = (uint64_t)count;\n    memcpy(direntry_raw + 2, &entry_type, sizeof(uint16_t));\n    if (tif->tif_flags & TIFF_SWAB)\n        TIFFSwabShort((uint16_t *)(direntry_raw + 2));\n\n    if (!(tif->tif_flags & TIFF_BIGTIFF))\n    {\n        uint32_t value;\n\n        value = (uint32_t)entry_count;\n        memcpy(direntry_raw + 4, &value, sizeof(uint32_t));\n        if (tif->tif_flags & TIFF_SWAB)\n            TIFFSwabLong((uint32_t *)(direntry_raw + 4));\n\n        value = (uint32_t)entry_offset;\n        memcpy(direntry_raw + 8, &value, sizeof(uint32_t));\n        if (tif->tif_flags & TIFF_SWAB)\n            TIFFSwabLong((uint32_t *)(direntry_raw + 8));\n    }\n    else\n    {\n        memcpy(direntry_raw + 4, &entry_count, sizeof(uint64_t));\n        if (tif->tif_flags & TIFF_SWAB)\n            TIFFSwabLong8((uint64_t *)(direntry_raw + 4));\n\n        memcpy(direntry_raw + 12, &entry_offset, sizeof(uint64_t));\n        if (tif->tif_flags & TIFF_SWAB)\n            TIFFSwabLong8((uint64_t *)(direntry_raw + 12));\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Write the directory entry out to disk.                          */\n    /* -------------------------------------------------------------------- */\n    if (!SeekOK(tif, read_offset))\n    {\n        TIFFErrorExtR(tif, module, \"%s: Seek error accessing TIFF directory\",\n                      tif->tif_name);\n        return 0;\n    }\n\n    if (!WriteOK(tif, direntry_raw, dirsize))\n    {\n        TIFFErrorExtR(tif, module, \"%s: Can not write TIFF directory entry.\",\n                      tif->tif_name);\n        return 0;\n    }\n\n    return 1;\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_dirwrite.c",
        "metrics": {
            "nloc": 366,
            "cyclomatic_complexity": 101,
            "token_count": 2081,
            "parameter_count": 5
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 723,
            "store_count": 372
        }
    },
    "TIFFReadScanline": {
        "source_code": "int TIFFReadScanline(TIFF *tif, void *buf, uint32_t row, uint16_t sample)\n{\n    int e;\n\n    if (!TIFFCheckRead(tif, 0))\n        return (-1);\n    if ((e = TIFFSeek(tif, row, sample)) != 0)\n    {\n        /*\n         * Decompress desired row into user buffer.\n         */\n        e = (*tif->tif_decoderow)(tif, (uint8_t *)buf, tif->tif_scanlinesize,\n                                  sample);\n\n        /* we are now poised at the beginning of the next row */\n        tif->tif_row = row + 1;\n\n        if (e)\n            (*tif->tif_postdecode)(tif, (uint8_t *)buf, tif->tif_scanlinesize);\n    }\n    else\n    {\n        /* See TIFFReadEncodedStrip comment regarding TIFFTAG_FAXFILLFUNC. */\n        if (buf)\n            memset(buf, 0, (size_t)tif->tif_scanlinesize);\n    }\n    return (e > 0 ? 1 : -1);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_read.c",
        "metrics": {
            "nloc": 20,
            "cyclomatic_complexity": 6,
            "token_count": 145,
            "parameter_count": 4
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 126,
            "store_count": 34
        }
    },
    "TIFFReadEncodedStrip": {
        "source_code": "tmsize_t TIFFReadEncodedStrip(TIFF *tif, uint32_t strip, void *buf,\n                              tmsize_t size)\n{\n    static const char module[] = \"TIFFReadEncodedStrip\";\n    TIFFDirectory *td = &tif->tif_dir;\n    tmsize_t stripsize;\n    uint16_t plane;\n\n    stripsize = TIFFReadEncodedStripGetStripSize(tif, strip, &plane);\n    if (stripsize == ((tmsize_t)(-1)))\n        return ((tmsize_t)(-1));\n\n    /* shortcut to avoid an extra memcpy() */\n    if (td->td_compression == COMPRESSION_NONE && size != (tmsize_t)(-1) &&\n        size >= stripsize && !isMapped(tif) &&\n        ((tif->tif_flags & TIFF_NOREADRAW) == 0))\n    {\n        if (TIFFReadRawStrip1(tif, strip, buf, stripsize, module) != stripsize)\n            return ((tmsize_t)(-1));\n\n        if (!isFillOrder(tif, td->td_fillorder) &&\n            (tif->tif_flags & TIFF_NOBITREV) == 0)\n            TIFFReverseBits(buf, stripsize);\n\n        (*tif->tif_postdecode)(tif, buf, stripsize);\n        return (stripsize);\n    }\n\n    if ((size != (tmsize_t)(-1)) && (size < stripsize))\n        stripsize = size;\n    if (!TIFFFillStrip(tif, strip))\n    {\n        /* The output buf may be NULL, in particular if TIFFTAG_FAXFILLFUNC\n           is being used. Thus, memset must be conditional on buf not NULL. */\n        if (buf)\n            memset(buf, 0, (size_t)stripsize);\n        return ((tmsize_t)(-1));\n    }\n    if ((*tif->tif_decodestrip)(tif, buf, stripsize, plane) <= 0)\n        return ((tmsize_t)(-1));\n    (*tif->tif_postdecode)(tif, buf, stripsize);\n    return (stripsize);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_read.c",
        "metrics": {
            "nloc": 35,
            "cyclomatic_complexity": 15,
            "token_count": 310,
            "parameter_count": 4
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 732,
            "store_count": 251
        }
    },
    "TIFFReadRawStrip": {
        "source_code": "tmsize_t TIFFReadRawStrip(TIFF *tif, uint32_t strip, void *buf, tmsize_t size)\n{\n    static const char module[] = \"TIFFReadRawStrip\";\n    TIFFDirectory *td = &tif->tif_dir;\n    uint64_t bytecount64;\n    tmsize_t bytecountm;\n\n    if (!TIFFCheckRead(tif, 0))\n        return ((tmsize_t)(-1));\n    if (strip >= td->td_nstrips)\n    {\n        TIFFErrorExtR(tif, module,\n                      \"%\" PRIu32 \": Strip out of range, max %\" PRIu32, strip,\n                      td->td_nstrips);\n        return ((tmsize_t)(-1));\n    }\n    if (tif->tif_flags & TIFF_NOREADRAW)\n    {\n        TIFFErrorExtR(tif, module,\n                      \"Compression scheme does not support access to raw \"\n                      \"uncompressed data\");\n        return ((tmsize_t)(-1));\n    }\n    bytecount64 = TIFFGetStrileByteCount(tif, strip);\n    if (size != (tmsize_t)(-1) && (uint64_t)size <= bytecount64)\n        bytecountm = size;\n    else\n        bytecountm = _TIFFCastUInt64ToSSize(tif, bytecount64, module);\n    if (bytecountm == 0)\n    {\n        return ((tmsize_t)(-1));\n    }\n    return (TIFFReadRawStrip1(tif, strip, buf, bytecountm, module));\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_read.c",
        "metrics": {
            "nloc": 33,
            "cyclomatic_complexity": 7,
            "token_count": 212,
            "parameter_count": 4
        },
        "cve_info": [
            {
                "CVE_ID": "CVE-2016-6223",
                "Description": "The TIFFReadRawStrip1 and TIFFReadRawTile1 functions in tif_read.c in libtiff before 4.0.7 allows remote attackers to cause a denial of service (crash) or possibly obtain sensitive information via a negative index in a file-content buffer."
            }
        ],
        "cve_count": 1,
        "instruction": {
            "load_count": 115,
            "store_count": 45
        }
    },
    "TIFFReadTile": {
        "source_code": "tmsize_t TIFFReadTile(TIFF *tif, void *buf, uint32_t x, uint32_t y, uint32_t z,\n                      uint16_t s)\n{\n    if (!TIFFCheckRead(tif, 1) || !TIFFCheckTile(tif, x, y, z, s))\n        return ((tmsize_t)(-1));\n    return (TIFFReadEncodedTile(tif, TIFFComputeTile(tif, x, y, z, s), buf,\n                                (tmsize_t)(-1)));\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_read.c",
        "metrics": {
            "nloc": 8,
            "cyclomatic_complexity": 3,
            "token_count": 90,
            "parameter_count": 6
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 198,
            "store_count": 58
        }
    },
    "TIFFReadEncodedTile": {
        "source_code": "tmsize_t TIFFReadEncodedTile(TIFF *tif, uint32_t tile, void *buf, tmsize_t size)\n{\n    static const char module[] = \"TIFFReadEncodedTile\";\n    TIFFDirectory *td = &tif->tif_dir;\n    tmsize_t tilesize = tif->tif_tilesize;\n\n    if (!TIFFCheckRead(tif, 1))\n        return ((tmsize_t)(-1));\n    if (tile >= td->td_nstrips)\n    {\n        TIFFErrorExtR(tif, module,\n                      \"%\" PRIu32 \": Tile out of range, max %\" PRIu32, tile,\n                      td->td_nstrips);\n        return ((tmsize_t)(-1));\n    }\n\n    /* shortcut to avoid an extra memcpy() */\n    if (td->td_compression == COMPRESSION_NONE && size != (tmsize_t)(-1) &&\n        size >= tilesize && !isMapped(tif) &&\n        ((tif->tif_flags & TIFF_NOREADRAW) == 0))\n    {\n        if (TIFFReadRawTile1(tif, tile, buf, tilesize, module) != tilesize)\n            return ((tmsize_t)(-1));\n\n        if (!isFillOrder(tif, td->td_fillorder) &&\n            (tif->tif_flags & TIFF_NOBITREV) == 0)\n            TIFFReverseBits(buf, tilesize);\n\n        (*tif->tif_postdecode)(tif, buf, tilesize);\n        return (tilesize);\n    }\n\n    if (size == (tmsize_t)(-1))\n        size = tilesize;\n    else if (size > tilesize)\n        size = tilesize;\n    if (!TIFFFillTile(tif, tile))\n    {\n        /* See TIFFReadEncodedStrip comment regarding TIFFTAG_FAXFILLFUNC. */\n        if (buf)\n            memset(buf, 0, (size_t)size);\n        return ((tmsize_t)(-1));\n    }\n    else if ((*tif->tif_decodetile)(tif, (uint8_t *)buf, size,\n                                    (uint16_t)(tile / td->td_stripsperimage)))\n    {\n        (*tif->tif_postdecode)(tif, (uint8_t *)buf, size);\n        return (size);\n    }\n    else\n        return ((tmsize_t)(-1));\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_read.c",
        "metrics": {
            "nloc": 45,
            "cyclomatic_complexity": 16,
            "token_count": 356,
            "parameter_count": 4
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 303,
            "store_count": 82
        }
    },
    "TIFFReadRawTile": {
        "source_code": "tmsize_t TIFFReadRawTile(TIFF *tif, uint32_t tile, void *buf, tmsize_t size)\n{\n    static const char module[] = \"TIFFReadRawTile\";\n    TIFFDirectory *td = &tif->tif_dir;\n    uint64_t bytecount64;\n    tmsize_t bytecountm;\n\n    if (!TIFFCheckRead(tif, 1))\n        return ((tmsize_t)(-1));\n    if (tile >= td->td_nstrips)\n    {\n        TIFFErrorExtR(tif, module,\n                      \"%\" PRIu32 \": Tile out of range, max %\" PRIu32, tile,\n                      td->td_nstrips);\n        return ((tmsize_t)(-1));\n    }\n    if (tif->tif_flags & TIFF_NOREADRAW)\n    {\n        TIFFErrorExtR(tif, module,\n                      \"Compression scheme does not support access to raw \"\n                      \"uncompressed data\");\n        return ((tmsize_t)(-1));\n    }\n    bytecount64 = TIFFGetStrileByteCount(tif, tile);\n    if (size != (tmsize_t)(-1) && (uint64_t)size <= bytecount64)\n        bytecountm = size;\n    else\n        bytecountm = _TIFFCastUInt64ToSSize(tif, bytecount64, module);\n    if (bytecountm == 0)\n    {\n        return ((tmsize_t)(-1));\n    }\n    return (TIFFReadRawTile1(tif, tile, buf, bytecountm, module));\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_read.c",
        "metrics": {
            "nloc": 33,
            "cyclomatic_complexity": 7,
            "token_count": 212,
            "parameter_count": 4
        },
        "cve_info": [
            {
                "CVE_ID": "CVE-2016-6223",
                "Description": "The TIFFReadRawStrip1 and TIFFReadRawTile1 functions in tif_read.c in libtiff before 4.0.7 allows remote attackers to cause a denial of service (crash) or possibly obtain sensitive information via a negative index in a file-content buffer."
            }
        ],
        "cve_count": 1,
        "instruction": {
            "load_count": 124,
            "store_count": 43
        }
    },
    "TIFFReadBufferSetup": {
        "source_code": "int TIFFReadBufferSetup(TIFF *tif, void *bp, tmsize_t size)\n{\n    static const char module[] = \"TIFFReadBufferSetup\";\n\n    assert((tif->tif_flags & TIFF_NOREADRAW) == 0);\n    tif->tif_flags &= ~TIFF_BUFFERMMAP;\n\n    if (tif->tif_rawdata)\n    {\n        if (tif->tif_flags & TIFF_MYBUFFER)\n            _TIFFfreeExt(tif, tif->tif_rawdata);\n        tif->tif_rawdata = NULL;\n        tif->tif_rawdatasize = 0;\n    }\n    if (bp)\n    {\n        tif->tif_rawdatasize = size;\n        tif->tif_rawdata = (uint8_t *)bp;\n        tif->tif_flags &= ~TIFF_MYBUFFER;\n    }\n    else\n    {\n        tif->tif_rawdatasize = (tmsize_t)TIFFroundup_64((uint64_t)size, 1024);\n        if (tif->tif_rawdatasize == 0)\n        {\n            TIFFErrorExtR(tif, module, \"Invalid buffer size\");\n            return (0);\n        }\n        /* Initialize to zero to avoid uninitialized buffers in case of */\n        /* short reads (http://bugzilla.maptools.org/show_bug.cgi?id=2651) */\n        tif->tif_rawdata =\n            (uint8_t *)_TIFFcallocExt(tif, 1, tif->tif_rawdatasize);\n        tif->tif_flags |= TIFF_MYBUFFER;\n    }\n    if (tif->tif_rawdata == NULL)\n    {\n        TIFFErrorExtR(tif, module,\n                      \"No space for data buffer at scanline %\" PRIu32,\n                      tif->tif_row);\n        tif->tif_rawdatasize = 0;\n        return (0);\n    }\n    return (1);\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_read.c",
        "metrics": {
            "nloc": 40,
            "cyclomatic_complexity": 6,
            "token_count": 217,
            "parameter_count": 3
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 38,
            "store_count": 16
        }
    },
    "TIFFReadFromUserBuffer": {
        "source_code": "int TIFFReadFromUserBuffer(TIFF *tif, uint32_t strile, void *inbuf,\n                           tmsize_t insize, void *outbuf, tmsize_t outsize)\n{\n    static const char module[] = \"TIFFReadFromUserBuffer\";\n    TIFFDirectory *td = &tif->tif_dir;\n    int ret = 1;\n    uint32_t old_tif_flags = tif->tif_flags;\n    tmsize_t old_rawdatasize = tif->tif_rawdatasize;\n    void *old_rawdata = tif->tif_rawdata;\n\n    if (tif->tif_mode == O_WRONLY)\n    {\n        TIFFErrorExtR(tif, tif->tif_name, \"File not open for reading\");\n        return 0;\n    }\n    if (tif->tif_flags & TIFF_NOREADRAW)\n    {\n        TIFFErrorExtR(tif, module,\n                      \"Compression scheme does not support access to raw \"\n                      \"uncompressed data\");\n        return 0;\n    }\n\n    tif->tif_flags &= ~TIFF_MYBUFFER;\n    tif->tif_flags |= TIFF_BUFFERMMAP;\n    tif->tif_rawdatasize = insize;\n    tif->tif_rawdata = inbuf;\n    tif->tif_rawdataoff = 0;\n    tif->tif_rawdataloaded = insize;\n\n    if (!isFillOrder(tif, td->td_fillorder) &&\n        (tif->tif_flags & TIFF_NOBITREV) == 0)\n    {\n        TIFFReverseBits(inbuf, insize);\n    }\n\n    if (TIFFIsTiled(tif))\n    {\n        if (!TIFFStartTile(tif, strile))\n        {\n            ret = 0;\n            /* See related TIFFReadEncodedStrip comment. */\n            if (outbuf)\n                memset(outbuf, 0, (size_t)outsize);\n        }\n        else if (!(*tif->tif_decodetile)(\n                     tif, (uint8_t *)outbuf, outsize,\n                     (uint16_t)(strile / td->td_stripsperimage)))\n        {\n            ret = 0;\n        }\n    }\n    else\n    {\n        uint32_t rowsperstrip = td->td_rowsperstrip;\n        uint32_t stripsperplane;\n        if (rowsperstrip > td->td_imagelength)\n            rowsperstrip = td->td_imagelength;\n        if (rowsperstrip == 0)\n        {\n            TIFFErrorExtR(tif, module, \"rowsperstrip is zero\");\n            ret = 0;\n        }\n        else\n        {\n            stripsperplane =\n                TIFFhowmany_32_maxuint_compat(td->td_imagelength, rowsperstrip);\n            if (!TIFFStartStrip(tif, strile))\n            {\n                ret = 0;\n                /* See related TIFFReadEncodedStrip comment. */\n                if (outbuf)\n                    memset(outbuf, 0, (size_t)outsize);\n            }\n            else if (!(*tif->tif_decodestrip)(\n                         tif, (uint8_t *)outbuf, outsize,\n                         (uint16_t)(strile / stripsperplane)))\n            {\n                ret = 0;\n            }\n        }\n    }\n    if (ret)\n    {\n        (*tif->tif_postdecode)(tif, (uint8_t *)outbuf, outsize);\n    }\n\n    if (!isFillOrder(tif, td->td_fillorder) &&\n        (tif->tif_flags & TIFF_NOBITREV) == 0)\n    {\n        TIFFReverseBits(inbuf, insize);\n    }\n\n    tif->tif_flags = (old_tif_flags & (TIFF_MYBUFFER | TIFF_BUFFERMMAP)) |\n                     (tif->tif_flags & ~(TIFF_MYBUFFER | TIFF_BUFFERMMAP));\n    tif->tif_rawdatasize = old_rawdatasize;\n    tif->tif_rawdata = old_rawdata;\n    tif->tif_rawdataoff = 0;\n    tif->tif_rawdataloaded = 0;\n\n    return ret;\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_read.c",
        "metrics": {
            "nloc": 93,
            "cyclomatic_complexity": 17,
            "token_count": 503,
            "parameter_count": 6
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 295,
            "store_count": 99
        }
    },
    "TIFFIsCODECConfigured": {
        "source_code": "int TIFFIsCODECConfigured(uint16_t scheme)\n{\n    const TIFFCodec *codec = TIFFFindCODEC(scheme);\n\n    if (codec == NULL)\n    {\n        return 0;\n    }\n    if (codec->init == NULL)\n    {\n        return 0;\n    }\n    if (codec->init != NotConfigured)\n    {\n        return 1;\n    }\n    return 0;\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_codec.c",
        "metrics": {
            "nloc": 17,
            "cyclomatic_complexity": 4,
            "token_count": 57,
            "parameter_count": 1
        },
        "cve_info": [],
        "cve_count": 0,
        "instruction": {
            "load_count": 7,
            "store_count": 6
        }
    },
    "TIFFPrintDirectory": {
        "source_code": "void TIFFPrintDirectory(TIFF *tif, FILE *fd, long flags)\n{\n    TIFFDirectory *td = &tif->tif_dir;\n    char *sep;\n    long l, n;\n\n    fprintf(fd, \"TIFF Directory at offset 0x%\" PRIx64 \" (%\" PRIu64 \")\\n\",\n            tif->tif_diroff, tif->tif_diroff);\n    if (TIFFFieldSet(tif, FIELD_SUBFILETYPE))\n    {\n        fprintf(fd, \"  Subfile Type:\");\n        sep = \" \";\n        if (td->td_subfiletype & FILETYPE_REDUCEDIMAGE)\n        {\n            fprintf(fd, \"%sreduced-resolution image\", sep);\n            sep = \"/\";\n        }\n        if (td->td_subfiletype & FILETYPE_PAGE)\n        {\n            fprintf(fd, \"%smulti-page document\", sep);\n            sep = \"/\";\n        }\n        if (td->td_subfiletype & FILETYPE_MASK)\n            fprintf(fd, \"%stransparency mask\", sep);\n        fprintf(fd, \" (%\" PRIu32 \" = 0x%\" PRIx32 \")\\n\", td->td_subfiletype,\n                td->td_subfiletype);\n    }\n    if (TIFFFieldSet(tif, FIELD_IMAGEDIMENSIONS))\n    {\n        fprintf(fd, \"  Image Width: %\" PRIu32 \" Image Length: %\" PRIu32,\n                td->td_imagewidth, td->td_imagelength);\n        if (TIFFFieldSet(tif, FIELD_IMAGEDEPTH))\n            fprintf(fd, \" Image Depth: %\" PRIu32, td->td_imagedepth);\n        fprintf(fd, \"\\n\");\n    }\n    if (TIFFFieldSet(tif, FIELD_TILEDIMENSIONS))\n    {\n        fprintf(fd, \"  Tile Width: %\" PRIu32 \" Tile Length: %\" PRIu32,\n                td->td_tilewidth, td->td_tilelength);\n        if (TIFFFieldSet(tif, FIELD_TILEDEPTH))\n            fprintf(fd, \" Tile Depth: %\" PRIu32, td->td_tiledepth);\n        fprintf(fd, \"\\n\");\n    }\n    if (TIFFFieldSet(tif, FIELD_RESOLUTION))\n    {\n        fprintf(fd, \"  Resolution: %g, %g\", td->td_xresolution,\n                td->td_yresolution);\n        if (TIFFFieldSet(tif, FIELD_RESOLUTIONUNIT))\n        {\n            switch (td->td_resolutionunit)\n            {\n                case RESUNIT_NONE:\n                    fprintf(fd, \" (unitless)\");\n                    break;\n                case RESUNIT_INCH:\n                    fprintf(fd, \" pixels/inch\");\n                    break;\n                case RESUNIT_CENTIMETER:\n                    fprintf(fd, \" pixels/cm\");\n                    break;\n                default:\n                    fprintf(fd, \" (unit %\" PRIu16 \" = 0x%\" PRIx16 \")\",\n                            td->td_resolutionunit, td->td_resolutionunit);\n                    break;\n            }\n        }\n        fprintf(fd, \"\\n\");\n    }\n    if (TIFFFieldSet(tif, FIELD_POSITION))\n        fprintf(fd, \"  Position: %g, %g\\n\", td->td_xposition, td->td_yposition);\n    if (TIFFFieldSet(tif, FIELD_BITSPERSAMPLE))\n        fprintf(fd, \"  Bits/Sample: %\" PRIu16 \"\\n\", td->td_bitspersample);\n    if (TIFFFieldSet(tif, FIELD_SAMPLEFORMAT))\n    {\n        fprintf(fd, \"  Sample Format: \");\n        switch (td->td_sampleformat)\n        {\n            case SAMPLEFORMAT_VOID:\n                fprintf(fd, \"void\\n\");\n                break;\n            case SAMPLEFORMAT_INT:\n                fprintf(fd, \"signed integer\\n\");\n                break;\n            case SAMPLEFORMAT_UINT:\n                fprintf(fd, \"unsigned integer\\n\");\n                break;\n            case SAMPLEFORMAT_IEEEFP:\n                fprintf(fd, \"IEEE floating point\\n\");\n                break;\n            case SAMPLEFORMAT_COMPLEXINT:\n                fprintf(fd, \"complex signed integer\\n\");\n                break;\n            case SAMPLEFORMAT_COMPLEXIEEEFP:\n                fprintf(fd, \"complex IEEE floating point\\n\");\n                break;\n            default:\n                fprintf(fd, \"%\" PRIu16 \" (0x%\" PRIx16 \")\\n\",\n                        td->td_sampleformat, td->td_sampleformat);\n                break;\n        }\n    }\n    if (TIFFFieldSet(tif, FIELD_COMPRESSION))\n    {\n        const TIFFCodec *c = TIFFFindCODEC(td->td_compression);\n        fprintf(fd, \"  Compression Scheme: \");\n        if (c)\n            fprintf(fd, \"%s\\n\", c->name);\n        else\n            fprintf(fd, \"%\" PRIu16 \" (0x%\" PRIx16 \")\\n\", td->td_compression,\n                    td->td_compression);\n    }\n    if (TIFFFieldSet(tif, FIELD_PHOTOMETRIC))\n    {\n        fprintf(fd, \"  Photometric Interpretation: \");\n        if (td->td_photometric < NPHOTONAMES)\n            fprintf(fd, \"%s\\n\", photoNames[td->td_photometric]);\n        else\n        {\n            switch (td->td_photometric)\n            {\n                case PHOTOMETRIC_LOGL:\n                    fprintf(fd, \"CIE Log2(L)\\n\");\n                    break;\n                case PHOTOMETRIC_LOGLUV:\n                    fprintf(fd, \"CIE Log2(L) (u',v')\\n\");\n                    break;\n                default:\n                    fprintf(fd, \"%\" PRIu16 \" (0x%\" PRIx16 \")\\n\",\n                            td->td_photometric, td->td_photometric);\n                    break;\n            }\n        }\n    }\n    if (TIFFFieldSet(tif, FIELD_EXTRASAMPLES) && td->td_extrasamples)\n    {\n        uint16_t i;\n        fprintf(fd, \"  Extra Samples: %\" PRIu16 \"<\", td->td_extrasamples);\n        sep = \"\";\n        for (i = 0; i < td->td_extrasamples; i++)\n        {\n            switch (td->td_sampleinfo[i])\n            {\n                case EXTRASAMPLE_UNSPECIFIED:\n                    fprintf(fd, \"%sunspecified\", sep);\n                    break;\n                case EXTRASAMPLE_ASSOCALPHA:\n                    fprintf(fd, \"%sassoc-alpha\", sep);\n                    break;\n                case EXTRASAMPLE_UNASSALPHA:\n                    fprintf(fd, \"%sunassoc-alpha\", sep);\n                    break;\n                default:\n                    fprintf(fd, \"%s%\" PRIu16 \" (0x%\" PRIx16 \")\", sep,\n                            td->td_sampleinfo[i], td->td_sampleinfo[i]);\n                    break;\n            }\n            sep = \", \";\n        }\n        fprintf(fd, \">\\n\");\n    }\n    if (TIFFFieldSet(tif, FIELD_INKNAMES))\n    {\n        char *cp;\n        uint16_t i;\n        fprintf(fd, \"  Ink Names: \");\n        i = td->td_samplesperpixel;\n        sep = \"\";\n        for (cp = td->td_inknames;\n             i > 0 && cp < td->td_inknames + td->td_inknameslen;\n             cp = strchr(cp, '\\0') + 1, i--)\n        {\n            size_t max_chars = td->td_inknameslen - (cp - td->td_inknames);\n            fputs(sep, fd);\n            _TIFFprintAsciiBounded(fd, cp, max_chars);\n            sep = \", \";\n        }\n        fputs(\"\\n\", fd);\n    }\n    if (TIFFFieldSet(tif, FIELD_NUMBEROFINKS))\n    {\n        fprintf(fd, \"  NumberOfInks: %d\\n\", td->td_numberofinks);\n    }\n    if (TIFFFieldSet(tif, FIELD_THRESHHOLDING))\n    {\n        fprintf(fd, \"  Thresholding: \");\n        switch (td->td_threshholding)\n        {\n            case THRESHHOLD_BILEVEL:\n                fprintf(fd, \"bilevel art scan\\n\");\n                break;\n            case THRESHHOLD_HALFTONE:\n                fprintf(fd, \"halftone or dithered scan\\n\");\n                break;\n            case THRESHHOLD_ERRORDIFFUSE:\n                fprintf(fd, \"error diffused\\n\");\n                break;\n            default:\n                fprintf(fd, \"%\" PRIu16 \" (0x%\" PRIx16 \")\\n\",\n                        td->td_threshholding, td->td_threshholding);\n                break;\n        }\n    }\n    if (TIFFFieldSet(tif, FIELD_FILLORDER))\n    {\n        fprintf(fd, \"  FillOrder: \");\n        switch (td->td_fillorder)\n        {\n            case FILLORDER_MSB2LSB:\n                fprintf(fd, \"msb-to-lsb\\n\");\n                break;\n            case FILLORDER_LSB2MSB:\n                fprintf(fd, \"lsb-to-msb\\n\");\n                break;\n            default:\n                fprintf(fd, \"%\" PRIu16 \" (0x%\" PRIx16 \")\\n\", td->td_fillorder,\n                        td->td_fillorder);\n                break;\n        }\n    }\n    if (TIFFFieldSet(tif, FIELD_YCBCRSUBSAMPLING))\n    {\n        fprintf(fd, \"  YCbCr Subsampling: %\" PRIu16 \", %\" PRIu16 \"\\n\",\n                td->td_ycbcrsubsampling[0], td->td_ycbcrsubsampling[1]);\n    }\n    if (TIFFFieldSet(tif, FIELD_YCBCRPOSITIONING))\n    {\n        fprintf(fd, \"  YCbCr Positioning: \");\n        switch (td->td_ycbcrpositioning)\n        {\n            case YCBCRPOSITION_CENTERED:\n                fprintf(fd, \"centered\\n\");\n                break;\n            case YCBCRPOSITION_COSITED:\n                fprintf(fd, \"cosited\\n\");\n                break;\n            default:\n                fprintf(fd, \"%\" PRIu16 \" (0x%\" PRIx16 \")\\n\",\n                        td->td_ycbcrpositioning, td->td_ycbcrpositioning);\n                break;\n        }\n    }\n    if (TIFFFieldSet(tif, FIELD_HALFTONEHINTS))\n        fprintf(fd, \"  Halftone Hints: light %\" PRIu16 \" dark %\" PRIu16 \"\\n\",\n                td->td_halftonehints[0], td->td_halftonehints[1]);\n    if (TIFFFieldSet(tif, FIELD_ORIENTATION))\n    {\n        fprintf(fd, \"  Orientation: \");\n        if (td->td_orientation < NORIENTNAMES)\n            fprintf(fd, \"%s\\n\", orientNames[td->td_orientation]);\n        else\n            fprintf(fd, \"%\" PRIu16 \" (0x%\" PRIx16 \")\\n\", td->td_orientation,\n                    td->td_orientation);\n    }\n    if (TIFFFieldSet(tif, FIELD_SAMPLESPERPIXEL))\n        fprintf(fd, \"  Samples/Pixel: %\" PRIx16 \"\\n\", td->td_samplesperpixel);\n    if (TIFFFieldSet(tif, FIELD_ROWSPERSTRIP))\n    {\n        fprintf(fd, \"  Rows/Strip: \");\n        if (td->td_rowsperstrip == (uint32_t)-1)\n            fprintf(fd, \"(infinite)\\n\");\n        else\n            fprintf(fd, \"%\" PRIu32 \"\\n\", td->td_rowsperstrip);\n    }\n    if (TIFFFieldSet(tif, FIELD_MINSAMPLEVALUE))\n        fprintf(fd, \"  Min Sample Value: %\" PRIu16 \"\\n\", td->td_minsamplevalue);\n    if (TIFFFieldSet(tif, FIELD_MAXSAMPLEVALUE))\n        fprintf(fd, \"  Max Sample Value: %\" PRIu16 \"\\n\", td->td_maxsamplevalue);\n    if (TIFFFieldSet(tif, FIELD_SMINSAMPLEVALUE))\n    {\n        int i;\n        int count =\n            (tif->tif_flags & TIFF_PERSAMPLE) ? td->td_samplesperpixel : 1;\n        fprintf(fd, \"  SMin Sample Value:\");\n        for (i = 0; i < count; ++i)\n            fprintf(fd, \" %g\", td->td_sminsamplevalue[i]);\n        fprintf(fd, \"\\n\");\n    }\n    if (TIFFFieldSet(tif, FIELD_SMAXSAMPLEVALUE))\n    {\n        int i;\n        int count =\n            (tif->tif_flags & TIFF_PERSAMPLE) ? td->td_samplesperpixel : 1;\n        fprintf(fd, \"  SMax Sample Value:\");\n        for (i = 0; i < count; ++i)\n            fprintf(fd, \" %g\", td->td_smaxsamplevalue[i]);\n        fprintf(fd, \"\\n\");\n    }\n    if (TIFFFieldSet(tif, FIELD_PLANARCONFIG))\n    {\n        fprintf(fd, \"  Planar Configuration: \");\n        switch (td->td_planarconfig)\n        {\n            case PLANARCONFIG_CONTIG:\n                fprintf(fd, \"single image plane\\n\");\n                break;\n            case PLANARCONFIG_SEPARATE:\n                fprintf(fd, \"separate image planes\\n\");\n                break;\n            default:\n                fprintf(fd, \"%\" PRIu16 \" (0x%\" PRIx16 \")\\n\",\n                        td->td_planarconfig, td->td_planarconfig);\n                break;\n        }\n    }\n    if (TIFFFieldSet(tif, FIELD_PAGENUMBER))\n        fprintf(fd, \"  Page Number: %\" PRIu16 \"-%\" PRIu16 \"\\n\",\n                td->td_pagenumber[0], td->td_pagenumber[1]);\n    if (TIFFFieldSet(tif, FIELD_COLORMAP))\n    {\n        fprintf(fd, \"  Color Map: \");\n        if (flags & TIFFPRINT_COLORMAP)\n        {\n            fprintf(fd, \"\\n\");\n            n = 1L << td->td_bitspersample;\n            for (l = 0; l < n; l++)\n                fprintf(fd, \"   %5ld: %5\" PRIu16 \" %5\" PRIu16 \" %5\" PRIu16 \"\\n\",\n                        l, td->td_colormap[0][l], td->td_colormap[1][l],\n                        td->td_colormap[2][l]);\n        }\n        else\n            fprintf(fd, \"(present)\\n\");\n    }\n    if (TIFFFieldSet(tif, FIELD_REFBLACKWHITE))\n    {\n        int i;\n        fprintf(fd, \"  Reference Black/White:\\n\");\n        for (i = 0; i < 3; i++)\n            fprintf(fd, \"    %2d: %5g %5g\\n\", i,\n                    td->td_refblackwhite[2 * i + 0],\n                    td->td_refblackwhite[2 * i + 1]);\n    }\n    if (TIFFFieldSet(tif, FIELD_TRANSFERFUNCTION))\n    {\n        fprintf(fd, \"  Transfer Function: \");\n        if (flags & TIFFPRINT_CURVES)\n        {\n            fprintf(fd, \"\\n\");\n            n = 1L << td->td_bitspersample;\n            for (l = 0; l < n; l++)\n            {\n                uint16_t i;\n                fprintf(fd, \"    %2ld: %5\" PRIu16, l,\n                        td->td_transferfunction[0][l]);\n                for (i = 1;\n                     i < td->td_samplesperpixel - td->td_extrasamples && i < 3;\n                     i++)\n                    fprintf(fd, \" %5\" PRIu16, td->td_transferfunction[i][l]);\n                fputc('\\n', fd);\n            }\n        }\n        else\n            fprintf(fd, \"(present)\\n\");\n    }\n    if (TIFFFieldSet(tif, FIELD_SUBIFD) && (td->td_subifd))\n    {\n        uint16_t i;\n        fprintf(fd, \"  SubIFD Offsets:\");\n        for (i = 0; i < td->td_nsubifd; i++)\n            fprintf(fd, \" %5\" PRIu64, td->td_subifd[i]);\n        fputc('\\n', fd);\n    }\n\n    /*\n    ** Custom tag support.\n    */\n    {\n        int i;\n        short count;\n\n        count = (short)TIFFGetTagListCount(tif);\n        for (i = 0; i < count; i++)\n        {\n            uint32_t tag = TIFFGetTagListEntry(tif, i);\n            const TIFFField *fip;\n            uint32_t value_count;\n            int mem_alloc = 0;\n            void *raw_data = NULL;\n            uint16_t dotrange[2]; /* must be kept in that scope and not moved in\n                                     the below TIFFTAG_DOTRANGE specific case */\n\n            fip = TIFFFieldWithTag(tif, tag);\n            if (fip == NULL)\n                continue;\n\n            if (fip->field_passcount)\n            {\n                if (fip->field_readcount == TIFF_VARIABLE2)\n                {\n                    if (TIFFGetField(tif, tag, &value_count, &raw_data) != 1)\n                        continue;\n                }\n                else if (fip->field_readcount == TIFF_VARIABLE)\n                {\n                    uint16_t small_value_count;\n                    if (TIFFGetField(tif, tag, &small_value_count, &raw_data) !=\n                        1)\n                        continue;\n                    value_count = small_value_count;\n                }\n                else\n                {\n                    assert(fip->field_readcount == TIFF_VARIABLE ||\n                           fip->field_readcount == TIFF_VARIABLE2);\n                    continue;\n                }\n            }\n            else\n            {\n                if (fip->field_readcount == TIFF_VARIABLE ||\n                    fip->field_readcount == TIFF_VARIABLE2)\n                    value_count = 1;\n                else if (fip->field_readcount == TIFF_SPP)\n                    value_count = td->td_samplesperpixel;\n                else\n                    value_count = fip->field_readcount;\n                if (fip->field_tag == TIFFTAG_DOTRANGE &&\n                    strcmp(fip->field_name, \"DotRange\") == 0)\n                {\n                    /* TODO: This is an evil exception and should not have been\n                       handled this way ... likely best if we move it into\n                       the directory structure with an explicit field in\n                       libtiff 4.1 and assign it a FIELD_ value */\n                    raw_data = dotrange;\n                    TIFFGetField(tif, tag, dotrange + 0, dotrange + 1);\n                }\n                else if (fip->field_type == TIFF_ASCII ||\n                         fip->field_readcount == TIFF_VARIABLE ||\n                         fip->field_readcount == TIFF_VARIABLE2 ||\n                         fip->field_readcount == TIFF_SPP || value_count > 1)\n                {\n                    if (TIFFGetField(tif, tag, &raw_data) != 1)\n                        continue;\n                }\n                else\n                {\n                    /*--: Rational2Double: For Rationals evaluate\n                     * \"set_get_field_type\" to determine internal storage size.\n                     */\n                    int tv_size = TIFFFieldSetGetSize(fip);\n                    raw_data = _TIFFmallocExt(tif, tv_size * value_count);\n                    mem_alloc = 1;\n                    if (TIFFGetField(tif, tag, raw_data) != 1)\n                    {\n                        _TIFFfreeExt(tif, raw_data);\n                        continue;\n                    }\n                }\n            }\n\n            /*\n             * Catch the tags which needs to be specially handled\n             * and pretty print them. If tag not handled in\n             * _TIFFPrettyPrintField() fall down and print it as\n             * any other tag.\n             */\n            if (raw_data != NULL &&\n                !_TIFFPrettyPrintField(tif, fip, fd, tag, value_count,\n                                       raw_data))\n                _TIFFPrintField(fd, fip, value_count, raw_data);\n\n            if (mem_alloc)\n                _TIFFfreeExt(tif, raw_data);\n        }\n    }\n\n    if (tif->tif_tagmethods.printdir)\n        (*tif->tif_tagmethods.printdir)(tif, fd, flags);\n\n    if ((flags & TIFFPRINT_STRIPS) && TIFFFieldSet(tif, FIELD_STRIPOFFSETS))\n    {\n        uint32_t s;\n\n        fprintf(fd, \"  %\" PRIu32 \" %s:\\n\", td->td_nstrips,\n                isTiled(tif) ? \"Tiles\" : \"Strips\");\n        for (s = 0; s < td->td_nstrips; s++)\n            fprintf(fd, \"    %3\" PRIu32 \": [%8\" PRIu64 \", %8\" PRIu64 \"]\\n\", s,\n                    TIFFGetStrileOffset(tif, s),\n                    TIFFGetStrileByteCount(tif, s));\n    }\n}\n",
        "file_path": "/home/sjx/LlmFuzz/docker_shared/source_code/libtiff/libtiff/tif_print.c",
        "metrics": {
            "nloc": 453,
            "cyclomatic_complexity": 109,
            "token_count": 2612,
            "parameter_count": 3
        },
        "cve_info": [
            {
                "CVE_ID": "CVE-2017-18013",
                "Description": "In LibTIFF 4.0.9, there is a Null-Pointer Dereference in the tif_print.c TIFFPrintDirectory function, as demonstrated by a tiffinfo crash."
            },
            {
                "CVE_ID": "CVE-2018-7456",
                "Description": "A NULL Pointer Dereference occurs in the function TIFFPrintDirectory in tif_print.c in LibTIFF 3.9.3, 3.9.4, 3.9.5, 3.9.6, 3.9.7, 4.0.0alpha4, 4.0.0alpha5, 4.0.0alpha6, 4.0.0beta7, 4.0.0, 4.0.1, 4.0.2, 4.0.3, 4.0.4, 4.0.4beta, 4.0.5, 4.0.6, 4.0.7, 4.0.8 and 4.0.9 when using the tiffinfo tool to print crafted TIFF information, a different vulnerability than CVE-2017-18013. (This affects an earlier part of the TIFFPrintDirectory function that was not addressed by the CVE-2017-18013 patch.)"
            }
        ],
        "cve_count": 2,
        "instruction": {
            "load_count": 721,
            "store_count": 103
        }
    }
}