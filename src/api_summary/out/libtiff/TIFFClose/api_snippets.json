[
    "bool Image::initWithTiffData(const unsigned char * data, ssize_t dataLen)\n{\n#if CC_USE_WIC\n    return decodeWithWIC(data, dataLen);\n#elif CC_USE_TIFF\n    bool ret = false;\n    do\n    {\n        // set the read call back function\n        tImageSource imageSource;\n        imageSource.data    = data;\n        imageSource.size    = dataLen;\n        imageSource.offset  = 0;\n\n        TIFF* tif = TIFFClientOpen(\"file.tif\", \"r\", (thandle_t)&imageSource,\n            tiffReadProc, tiffWriteProc,\n            tiffSeekProc, tiffCloseProc, tiffSizeProc,\n            tiffMapProc,\n            tiffUnmapProc);\n\n        CC_BREAK_IF(nullptr == tif);\n\n        uint32 w = 0, h = 0;\n        uint16 bitsPerSample = 0, samplePerPixel = 0, planarConfig = 0;\n        size_t npixels = 0;\n\n        TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w);\n        TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\n        TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bitsPerSample);\n        TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &samplePerPixel);\n        TIFFGetField(tif, TIFFTAG_PLANARCONFIG, &planarConfig);\n\n        npixels = w * h;\n\n        _renderFormat = Image::PixelFormat::RGBA8888;\n        _width = w;\n        _height = h;\n\n        _dataLen = npixels * sizeof (uint32);\n        _data = static_cast<unsigned char*>(malloc(_dataLen * sizeof(unsigned char)));\n\n        uint32* raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n        if (raster != nullptr)\n        {\n           if (TIFFReadRGBAImageOriented(tif, w, h, raster, ORIENTATION_TOPLEFT, 0))\n           {\n                /* the raster data is pre-multiplied by the alpha component\n                   after invoking TIFFReadRGBAImageOriented*/\n                _hasPremultipliedAlpha = true;\n\n               memcpy(_data, raster, npixels*sizeof (uint32));\n           }\n\n          _TIFFfree(raster);\n        }\n\n\n        TIFFClose(tif);\n\n        ret = true;\n    } while (0);\n    return ret;\n#else\n    CCLOG(\"tiff is not enabled, please enable it in ccConfig.h\");\n    return false;\n#endif //CC_USE_TIFF\n}",
    "CxImageTIF::~CxImageTIF()\n{\n\tif (m_tif2) TIFFClose(m_tif2);\n}",
    "void CxImageTIF::TIFFCloseEx(TIFF* tif)\n{\n\tif (tif) TIFFClose(tif);\n}",
    "bool Image::initWithTiffData(const unsigned char * data, ssize_t dataLen)\n{\n    bool bRet = false;\n    do \n    {\n        // set the read call back function\n        tImageSource imageSource;\n        imageSource.data    = data;\n        imageSource.size    = dataLen;\n        imageSource.offset  = 0;\n\n        TIFF* tif = TIFFClientOpen(\"file.tif\", \"r\", (thandle_t)&imageSource, \n            tiffReadProc, tiffWriteProc,\n            tiffSeekProc, tiffCloseProc, tiffSizeProc,\n            tiffMapProc,\n            tiffUnmapProc);\n\n        CC_BREAK_IF(nullptr == tif);\n\n        uint32 w = 0, h = 0;\n        uint16 bitsPerSample = 0, samplePerPixel = 0, planarConfig = 0;\n        size_t npixels = 0;\n        \n        TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w);\n        TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\n        TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bitsPerSample);\n        TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &samplePerPixel);\n        TIFFGetField(tif, TIFFTAG_PLANARCONFIG, &planarConfig);\n\n        npixels = w * h;\n        \n        _renderFormat = Texture2D::PixelFormat::RGBA8888;\n        _width = w;\n        _height = h;\n\n        _dataLen = npixels * sizeof (uint32);\n        _data = static_cast<unsigned char*>(malloc(_dataLen * sizeof(unsigned char)));\n\n        uint32* raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n        if (raster != nullptr) \n        {\n           if (TIFFReadRGBAImageOriented(tif, w, h, raster, ORIENTATION_TOPLEFT, 0))\n           {\n                /* the raster data is pre-multiplied by the alpha component \n                   after invoking TIFFReadRGBAImageOriented*/\n                _preMulti = true;\n\n               memcpy(_data, raster, npixels*sizeof (uint32));\n           }\n\n          _TIFFfree(raster);\n        }\n        \n\n        TIFFClose(tif);\n\n        bRet = true;\n    } while (0);\n    return bRet;\n}",
    "void operator()(TIFF* tiff) const {\n            TIFFClose(tiff);\n        }",
    "static void cv_tiffCloseHandle(void* handle)\n{\n    TIFFClose((TIFF*)handle);\n}",
    "bool QTiffHandler::read(QImage *image)\n{\n    if (!canRead())\n        return false;\n\n    TIFF *const tiff = TIFFClientOpen(\"foo\",\n                                      \"r\",\n                                      this,\n                                      qtiffReadProc,\n                                      qtiffWriteProc,\n                                      qtiffSeekProc,\n                                      qtiffCloseProc,\n                                      qtiffSizeProc,\n                                      qtiffMapProc,\n                                      qtiffUnmapProc);\n\n    if (!tiff) {\n        return false;\n    }\n    uint32 width;\n    uint32 height;\n    uint16 photometric;\n    if (!TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, &width)\n        || !TIFFGetField(tiff, TIFFTAG_IMAGELENGTH, &height)\n        || !TIFFGetField(tiff, TIFFTAG_PHOTOMETRIC, &photometric)) {\n        TIFFClose(tiff);\n        return false;\n    }\n\n    // BitsPerSample defaults to 1 according to the TIFF spec.\n    uint16 bitPerSample;\n    if (!TIFFGetField(tiff, TIFFTAG_BITSPERSAMPLE, &bitPerSample))\n        bitPerSample = 1;\n    uint16 samplesPerPixel; // they may be e.g. grayscale with 2 samples per pixel\n    if (!TIFFGetField(tiff, TIFFTAG_SAMPLESPERPIXEL, &samplesPerPixel))\n        samplesPerPixel = 1;\n\n    bool grayscale = photometric == PHOTOMETRIC_MINISBLACK || photometric == PHOTOMETRIC_MINISWHITE;\n    if (grayscale && bitPerSample == 1 && samplesPerPixel == 1) {\n        if (image->size() != QSize(width, height) || image->format() != QImage::Format_Mono)\n            *image = QImage(width, height, QImage::Format_Mono);\n        QVector<QRgb> colortable(2);\n        if (photometric == PHOTOMETRIC_MINISBLACK) {\n            colortable[0] = 0xff000000;\n            colortable[1] = 0xffffffff;\n        } else {\n            colortable[0] = 0xffffffff;\n            colortable[1] = 0xff000000;\n        }\n        image->setColorTable(colortable);\n\n        if (!image->isNull()) {\n            for (uint32 y=0; y<height; ++y) {\n                if (TIFFReadScanline(tiff, image->scanLine(y), y, 0) < 0) {\n                    TIFFClose(tiff);\n                    return false;\n                }\n            }\n        }\n    } else {\n        if ((grayscale || photometric == PHOTOMETRIC_PALETTE) && bitPerSample == 8 && samplesPerPixel == 1) {\n            if (image->size() != QSize(width, height) || image->format() != QImage::Format_Indexed8)\n                *image = QImage(width, height, QImage::Format_Indexed8);\n            if (!image->isNull()) {\n                const uint16 tableSize = 256;\n                QVector<QRgb> qtColorTable(tableSize);\n                if (grayscale) {\n                    for (int i = 0; i<tableSize; ++i) {\n                        const int c = (photometric == PHOTOMETRIC_MINISBLACK) ? i : (255 - i);\n                        qtColorTable[i] = qRgb(c, c, c);\n                    }\n                } else {\n                    // create the color table\n                    uint16 *redTable = 0;\n                    uint16 *greenTable = 0;\n                    uint16 *blueTable = 0;\n                    if (!TIFFGetField(tiff, TIFFTAG_COLORMAP, &redTable, &greenTable, &blueTable)) {\n                        TIFFClose(tiff);\n                        return false;\n                    }\n                    if (!redTable || !greenTable || !blueTable) {\n                        TIFFClose(tiff);\n                        return false;\n                    }\n\n                    for (int i = 0; i<tableSize ;++i) {\n                        const int red = redTable[i] / 257;\n                        const int green = greenTable[i] / 257;\n                        const int blue = blueTable[i] / 257;\n                        qtColorTable[i] = qRgb(red, green, blue);\n                    }\n                }\n\n                image->setColorTable(qtColorTable);\n                for (uint32 y=0; y<height; ++y) {\n                    if (TIFFReadScanline(tiff, image->scanLine(y), y, 0) < 0) {\n                        TIFFClose(tiff);\n                        return false;\n                    }\n                }\n\n                // free redTable, greenTable and greenTable done by libtiff\n            }\n        } else {\n            if (image->size() != QSize(width, height) || image->format() != QImage::Format_ARGB32)\n                *image = QImage(width, height, QImage::Format_ARGB32);\n            if (!image->isNull()) {\n                const int stopOnError = 1;\n                if (TIFFReadRGBAImageOriented(tiff, width, height, reinterpret_cast<uint32 *>(image->bits()), ORIENTATION_TOPLEFT, stopOnError)) {\n                    for (uint32 y=0; y<height; ++y)\n                        convert32BitOrder(image->scanLine(y), width);\n                } else {\n                    TIFFClose(tiff);\n                    return false;\n                }\n            }\n        }\n    }\n\n    if (image->isNull()) {\n        TIFFClose(tiff);\n        return false;\n    }\n\n    float resX = 0;\n    float resY = 0;\n    uint16 resUnit;\n    if (!TIFFGetField(tiff, TIFFTAG_RESOLUTIONUNIT, &resUnit))\n        resUnit = RESUNIT_INCH;\n\n    if (TIFFGetField(tiff, TIFFTAG_XRESOLUTION, &resX)\n        && TIFFGetField(tiff, TIFFTAG_YRESOLUTION, &resY)) {\n        switch(resUnit) {\n        case RESUNIT_CENTIMETER:\n            image->setDotsPerMeterX(qRound(resX * 100));\n            image->setDotsPerMeterY(qRound(resY * 100));\n            break;\n        case RESUNIT_INCH:\n            image->setDotsPerMeterX(qRound(resX * (100 / 2.54)));\n            image->setDotsPerMeterY(qRound(resY * (100 / 2.54)));\n            break;\n        default:\n            // do nothing as defaults have already\n            // been set within the QImage class\n            break;\n        }\n    }\n\n    // rotate the image if the orientation is defined in the file\n    uint16 orientationTag;\n    if (TIFFGetField(tiff, TIFFTAG_ORIENTATION, &orientationTag)) {\n        if (image->format() == QImage::Format_ARGB32) {\n            // TIFFReadRGBAImageOriented() flip the image but does not rotate them\n            switch (orientationTag) {\n            case 5:\n                rotate_right_mirror_horizontal(image);\n                break;\n            case 6:\n                rotate_right_mirror_vertical(image);\n                break;\n            case 7:\n                rotate_right_mirror_horizontal(image);\n                break;\n            case 8:\n                rotate_right_mirror_vertical(image);\n                break;\n            }\n        } else {\n            switch (orientationTag) {\n            case 1: // default orientation\n                break;\n            case 2: // mirror horizontal\n                *image = image->mirrored(true, false);\n                break;\n            case 3: // mirror both\n                *image = image->mirrored(true, true);\n                break;\n            case 4: // mirror vertical\n                *image = image->mirrored(false, true);\n                break;\n            case 5: // rotate right mirror horizontal\n                {\n                    QMatrix transformation;\n                    transformation.rotate(90);\n                    *image = image->transformed(transformation);\n                    *image = image->mirrored(true, false);\n                    break;\n                }\n            case 6: // rotate right\n                {\n                    QMatrix transformation;\n                    transformation.rotate(90);\n                    *image = image->transformed(transformation);\n                    break;\n                }\n            case 7: // rotate right, mirror vertical\n                {\n                    QMatrix transformation;\n                    transformation.rotate(90);\n                    *image = image->transformed(transformation);\n                    *image = image->mirrored(false, true);\n                    break;\n                }\n            case 8: // rotate left\n                {\n                    QMatrix transformation;\n                    transformation.rotate(270);\n                    *image = image->transformed(transformation);\n                    break;\n                }\n            }\n        }\n    }\n\n\n    TIFFClose(tiff);\n    return true;\n}",
    "bool QTiffHandler::write(const QImage &image)\n{\n    if (!device()->isWritable())\n        return false;\n\n    TIFF *const tiff = TIFFClientOpen(\"foo\",\n                                      \"w\",\n                                      this,\n                                      qtiffReadProc,\n                                      qtiffWriteProc,\n                                      qtiffSeekProc,\n                                      qtiffCloseProc,\n                                      qtiffSizeProc,\n                                      qtiffMapProc,\n                                      qtiffUnmapProc);\n    if (!tiff)\n        return false;\n\n    const int width = image.width();\n    const int height = image.height();\n\n    if (!TIFFSetField(tiff, TIFFTAG_IMAGEWIDTH, width)\n        || !TIFFSetField(tiff, TIFFTAG_IMAGELENGTH, height)\n        || !TIFFSetField(tiff, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG)) {\n        TIFFClose(tiff);\n        return false;\n    }\n\n    // set the resolution\n    bool  resolutionSet = false;\n    const int dotPerMeterX = image.dotsPerMeterX();\n    const int dotPerMeterY = image.dotsPerMeterY();\n    if ((dotPerMeterX % 100) == 0\n        && (dotPerMeterY % 100) == 0) {\n        resolutionSet = TIFFSetField(tiff, TIFFTAG_RESOLUTIONUNIT, RESUNIT_CENTIMETER)\n                        && TIFFSetField(tiff, TIFFTAG_XRESOLUTION, dotPerMeterX/100.0)\n                        && TIFFSetField(tiff, TIFFTAG_YRESOLUTION, dotPerMeterY/100.0);\n    } else {\n        resolutionSet = TIFFSetField(tiff, TIFFTAG_RESOLUTIONUNIT, RESUNIT_INCH)\n                        && TIFFSetField(tiff, TIFFTAG_XRESOLUTION, static_cast<float>(image.logicalDpiX()))\n                        && TIFFSetField(tiff, TIFFTAG_YRESOLUTION, static_cast<float>(image.logicalDpiY()));\n    }\n    if (!resolutionSet) {\n        TIFFClose(tiff);\n        return false;\n    }\n\n    // configure image depth\n    const QImage::Format format = image.format();\n    if (format == QImage::Format_Mono || format == QImage::Format_MonoLSB) {\n        uint16 photometric = PHOTOMETRIC_MINISBLACK;\n        if (image.colorTable().at(0) == 0xffffffff)\n            photometric = PHOTOMETRIC_MINISWHITE;\n        if (!TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, photometric)\n            || !TIFFSetField(tiff, TIFFTAG_COMPRESSION, compression == NoCompression ? COMPRESSION_NONE : COMPRESSION_CCITTRLE)\n            || !TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 1)) {\n            TIFFClose(tiff);\n            return false;\n        }\n\n        // try to do the conversion in chunks no greater than 16 MB\n        int chunks = (width * height / (1024 * 1024 * 16)) + 1;\n        int chunkHeight = qMax(height / chunks, 1);\n\n        int y = 0;\n        while (y < height) {\n            QImage chunk = image.copy(0, y, width, qMin(chunkHeight, height - y)).convertToFormat(QImage::Format_Mono);\n\n            int chunkStart = y;\n            int chunkEnd = y + chunk.height();\n            while (y < chunkEnd) {\n                if (TIFFWriteScanline(tiff, reinterpret_cast<uint32 *>(chunk.scanLine(y - chunkStart)), y) != 1) {\n                    TIFFClose(tiff);\n                    return false;\n                }\n                ++y;\n            }\n        }\n        TIFFClose(tiff);\n    } else if (format == QImage::Format_Indexed8) {\n        const QVector<QRgb> colorTable = image.colorTable();\n        bool isGrayscale = checkGrayscale(colorTable);\n        if (isGrayscale) {\n            uint16 photometric = PHOTOMETRIC_MINISBLACK;\n            if (image.colorTable().at(0) == 0xffffffff)\n                photometric = PHOTOMETRIC_MINISWHITE;\n            if (!TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, photometric)\n                    || !TIFFSetField(tiff, TIFFTAG_COMPRESSION, compression == NoCompression ? COMPRESSION_NONE : COMPRESSION_PACKBITS)\n                    || !TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 8)) {\n                TIFFClose(tiff);\n                return false;\n            }\n        } else {\n            if (!TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_PALETTE)\n                    || !TIFFSetField(tiff, TIFFTAG_COMPRESSION, compression == NoCompression ? COMPRESSION_NONE : COMPRESSION_PACKBITS)\n                    || !TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 8)) {\n                TIFFClose(tiff);\n                return false;\n            }\n            //// write the color table\n            // allocate the color tables\n            uint16 *redTable = static_cast<uint16 *>(qMalloc(256 * sizeof(uint16)));\n            uint16 *greenTable = static_cast<uint16 *>(qMalloc(256 * sizeof(uint16)));\n            uint16 *blueTable = static_cast<uint16 *>(qMalloc(256 * sizeof(uint16)));\n            if (!redTable || !greenTable || !blueTable) {\n                qFree(redTable);\n                qFree(greenTable);\n                qFree(blueTable);\n                TIFFClose(tiff);\n                return false;\n            }\n\n            // set the color table\n            const int tableSize = colorTable.size();\n            Q_ASSERT(tableSize <= 256);\n            for (int i = 0; i<tableSize; ++i) {\n                const QRgb color = colorTable.at(i);\n                redTable[i] = qRed(color) * 257;\n                greenTable[i] = qGreen(color) * 257;\n                blueTable[i] = qBlue(color) * 257;\n            }\n\n            const bool setColorTableSuccess = TIFFSetField(tiff, TIFFTAG_COLORMAP, redTable, greenTable, blueTable);\n\n            qFree(redTable);\n            qFree(greenTable);\n            qFree(blueTable);\n\n            if (!setColorTableSuccess) {\n                TIFFClose(tiff);\n                return false;\n            }\n        }\n\n        //// write the data\n        // try to do the conversion in chunks no greater than 16 MB\n        int chunks = (width * height/ (1024 * 1024 * 16)) + 1;\n        int chunkHeight = qMax(height / chunks, 1);\n\n        int y = 0;\n        while (y < height) {\n            QImage chunk = image.copy(0, y, width, qMin(chunkHeight, height - y));\n\n            int chunkStart = y;\n            int chunkEnd = y + chunk.height();\n            while (y < chunkEnd) {\n                if (TIFFWriteScanline(tiff, reinterpret_cast<uint32 *>(chunk.scanLine(y - chunkStart)), y) != 1) {\n                    TIFFClose(tiff);\n                    return false;\n                }\n                ++y;\n            }\n        }\n        TIFFClose(tiff);\n\n    } else {\n        if (!TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB)\n            || !TIFFSetField(tiff, TIFFTAG_COMPRESSION, compression == NoCompression ? COMPRESSION_NONE : COMPRESSION_LZW)\n            || !TIFFSetField(tiff, TIFFTAG_SAMPLESPERPIXEL, 4)\n            || !TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 8)) {\n            TIFFClose(tiff);\n            return false;\n        }\n        // try to do the ARGB32 conversion in chunks no greater than 16 MB\n        int chunks = (width * height * 4 / (1024 * 1024 * 16)) + 1;\n        int chunkHeight = qMax(height / chunks, 1);\n\n        int y = 0;\n        while (y < height) {\n            QImage chunk = image.copy(0, y, width, qMin(chunkHeight, height - y)).convertToFormat(QImage::Format_ARGB32);\n\n            int chunkStart = y;\n            int chunkEnd = y + chunk.height();\n            while (y < chunkEnd) {\n                if (QSysInfo::ByteOrder == QSysInfo::LittleEndian)\n                    convert32BitOrder(chunk.scanLine(y - chunkStart), width);\n                else\n                    convert32BitOrderBigEndian(chunk.scanLine(y - chunkStart), width);\n\n                if (TIFFWriteScanline(tiff, reinterpret_cast<uint32 *>(chunk.scanLine(y - chunkStart)), y) != 1) {\n                    TIFFClose(tiff);\n                    return false;\n                }\n                ++y;\n            }\n        }\n        TIFFClose(tiff);\n    }\n\n    return true;\n}",
    "QVariant QTiffHandler::option(ImageOption option) const\n{\n    if (option == Size && canRead()) {\n        QSize imageSize;\n        qint64 pos = device()->pos();\n        TIFF *tiff = TIFFClientOpen(\"foo\",\n                                    \"r\",\n                                    const_cast<QTiffHandler*>(this),\n                                    qtiffReadProc,\n                                    qtiffWriteProc,\n                                    qtiffSeekProc,\n                                    qtiffCloseProc,\n                                    qtiffSizeProc,\n                                    qtiffMapProc,\n                                    qtiffUnmapProc);\n\n        if (tiff) {\n            uint32 width = 0;\n            uint32 height = 0;\n            TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, &width);\n            TIFFGetField(tiff, TIFFTAG_IMAGELENGTH, &height);\n            imageSize = QSize(width, height);\n            TIFFClose(tiff);\n        }\n        device()->seek(pos);\n        if (imageSize.isValid())\n            return imageSize;\n    } else if (option == CompressionRatio) {\n        return compression;\n    } else if (option == ImageFormat) {\n        return QImage::Format_ARGB32;\n    }\n    return QVariant();\n}",
    "EerIO::~EerIO()\n{\n\tTIFFClose(tiff_file);\n}",
    "TiffIO::~TiffIO()\n{\n\tif (tiff_file) {\n\t\tTIFFClose(tiff_file);\n\t\ttiff_file = 0;\n\t}\n}",
    "~TiffLoader() {\n    TIFFClose(tiff);\n  }",
    "void TIFFImageIO::loadHeader(const char *name, long &width, long &height, int &depth) const\n{\n  TIFF *tif=TIFFOpen(name, \"r\");\n\n  if (tif == 0)\n  {\n    throw gutil::IOException(\"Can only load TIFF image (\"+std::string(name)+\")\");\n  }\n\n  uint32_t w, h;\n  uint16_t d;\n\n  TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w);\n  TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\n  TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &d);\n\n  width=w;\n  height=h;\n  depth=d;\n\n  TIFFClose(tif);\n}",
    "~TiffImage()\n    {\n      TIFFClose(tif);\n    }",
    "void saveInternal(const Image<T> &image, const char *name)\n{\n  TIFF* tif=TIFFOpen(name, \"w\");\n\n  if (!tif)\n  {\n    throw gutil::IOException(\"Cannot store image: \"+std::string(name));\n  }\n\n  TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, static_cast<uint32_t>(image.getWidth()));\n  TIFFSetField(tif, TIFFTAG_IMAGELENGTH, static_cast<uint32_t>(image.getHeight()));\n  TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, static_cast<uint16_t>(image.getDepth()));\n  TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8*sizeof(T));\n\n  if (std::is_floating_point<T>::value)\n  {\n    TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);\n  }\n  else\n  {\n    TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT);\n  }\n\n  int strip=static_cast<int>(8192/(image.getWidth()*image.getDepth()*sizeof(T)));\n  strip=std::max(1, strip);\n  strip=std::min(static_cast<int>(image.getHeight()), strip);\n\n  TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, TIFFDefaultStripSize(tif, static_cast<uint32_t>(strip)));\n\n  TIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n  TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\n  if (image.getDepth() == 3 || image.getDepth() == 4)\n  {\n    TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n  }\n  else\n  {\n    TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n  }\n\n  if (image.getDepth() == 1)\n  {\n    for (long k=0; k<image.getHeight(); k++)\n    {\n      if (TIFFWriteScanline(tif, image.getPtr(0, k, 0), static_cast<uint32_t>(k), 0) < 0)\n      {\n        TIFFClose(tif);\n        throw gutil::IOException(\"Cannot write image data: \"+std::string(name));\n      }\n    }\n  }\n  else\n  {\n    std::vector<T> line(image.getWidth()*image.getDepth());\n\n    for (long k=0; k<image.getHeight(); k++)\n    {\n      T *p=line.data();\n      for (long i=0; i<image.getWidth(); i++)\n      {\n        for (int d=0; d<image.getDepth(); d++)\n        {\n          *p++=image.get(i, k, d);\n        }\n      }\n\n      if (TIFFWriteScanline(tif, line.data(), static_cast<uint32_t>(k), 0) < 0)\n      {\n        TIFFClose(tif);\n        throw gutil::IOException(\"Cannot write image data: \"+std::string(name));\n      }\n    }\n  }\n\n  TIFFClose(tif);\n}",
    "void LavaVu::readVolumeTIFF(const FilePath& fn)\n{\n#ifdef HAVE_LIBTIFF\n  TIFF* tif = TIFFOpen(fn.full.c_str(), \"r\");\n  if (tif)\n  {\n    unsigned int width, height;\n    size_t npixels;\n    int channels = 4;\n    GLubyte* imageData;\n    int count = 0;\n    TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n    TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n    npixels = width * height;\n    imageData = (GLubyte*)_TIFFmalloc(npixels * channels * sizeof(GLubyte));\n    if (imageData)\n    {\n      json volss = session.global(\"volsubsample\");\n      int d = TIFFNumberOfDirectories(tif);\n      int ds = volss[2];\n      if (d > 1) std::cout << \"TIFF contains \" << d << \" pages, sub-sampling z \" << ds << std::endl;\n      do\n      {\n        if (TIFFReadRGBAImage(tif, width, height, (uint32_t*)imageData, 0))\n        {\n          //Subsample\n          if (count % ds != 0) {count++; continue;}\n          readVolumeSlice(fn.base, imageData, width, height, channels, true);\n        }\n        count++;\n      }\n      while (TIFFReadDirectory(tif));\n      _TIFFfree(imageData);\n    }\n    TIFFClose(tif);\n  }\n#else\n  abort_program(\"Require libTIFF to load TIFF images\\n\");\n#endif\n}",
    "void ImageLoader::loadTIFF()\r\n{\r\n  newSource();\r\n#ifdef HAVE_LIBTIFF\r\n  TIFF* tif = TIFFOpen(fn.full.c_str(), \"r\");\r\n  if (tif)\r\n  {\r\n    TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &source->width);\r\n    TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &source->height);\r\n    TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &source->channels);\r\n    //source->channels = 4;\r\n    source->allocate();   // Reserve Memory\r\n    if (source->pixels)\r\n    {\r\n      if (TIFFReadRGBAImage(tif, source->width, source->height, (uint32_t*)source->pixels, 0))\r\n      {\r\n        //Succeeded\r\n      }\r\n      else\r\n        clear();\r\n    }\r\n    TIFFClose(tif);\r\n  }\r\n#else\r\n  abort_program(\"[Load Texture] Require libTIFF to load TIFF images\\n\");\r\n#endif\r\n}",
    "bool TiffWriter::close()\n{\n    // Close the file\n\n    TIFFClose(priv->f);\n\n    return true;\n}",
    "void dng_save(std::vector<libcamera::Span<uint8_t>> const &mem, StreamInfo const &info, ControlList const &metadata,\n\t\t\t  std::string const &filename, std::string const &cam_model, StillOptions const *options)\n{\n\t// Check the Bayer format and unpack it to u16.\n\n\tauto it = bayer_formats.find(info.pixel_format);\n\tif (it == bayer_formats.end())\n\t\tthrow std::runtime_error(\"unsupported Bayer format\");\n\tBayerFormat const &bayer_format = it->second;\n\tLOG(1, \"Bayer format is \" << bayer_format.name);\n\n\t// Decompression will require a buffer that's 8 pixels aligned.\n\tunsigned int buf_stride_pixels = info.width;\n\tunsigned int buf_stride_pixels_padded = (buf_stride_pixels + 7) & ~7;\n\tstd::vector<uint16_t> buf(buf_stride_pixels_padded * info.height);\n\tif (bayer_format.compressed)\n\t{\n\t\tuncompress(mem[0].data(), info, &buf[0]);\n\t\tbuf_stride_pixels = buf_stride_pixels_padded;\n\t}\n\telse if (bayer_format.packed)\n\t{\n\t\tswitch (bayer_format.bits)\n\t\t{\n\t\tcase 10:\n\t\t\tunpack_10bit(mem[0].data(), info, &buf[0]);\n\t\t\tbreak;\n\t\tcase 12:\n\t\t\tunpack_12bit(mem[0].data(), info, &buf[0]);\n\t\t\tbreak;\n\t\t}\n\t}\n\telse\n\t\tunpack_16bit(mem[0].data(), info, &buf[0]);\n\n\t// We need to fish out some metadata values for the DNG.\n\tfloat black = 4096 * (1 << bayer_format.bits) / 65536.0;\n\tfloat black_levels[] = { black, black, black, black };\n\tauto bl = metadata.get(controls::SensorBlackLevels);\n\tif (bl)\n\t{\n\t\t// levels is in the order R, Gr, Gb, B. Re-order it for the actual bayer order.\n\t\tfor (int i = 0; i < 4; i++)\n\t\t{\n\t\t\tint j = bayer_format.order[i];\n\t\t\tj = j == 0 ? 0 : (j == 2 ? 3 : 1 + !!bayer_format.order[i ^ 1]);\n\t\t\tblack_levels[j] = (*bl)[i] * (1 << bayer_format.bits) / 65536.0;\n\t\t}\n\t}\n\telse\n\t\tLOG_ERROR(\"WARNING: no black level found, using default\");\n\n\tauto exp = metadata.get(controls::ExposureTime);\n\tfloat exp_time = 10000;\n\tif (exp)\n\t\texp_time = *exp;\n\telse\n\t\tLOG_ERROR(\"WARNING: default to exposure time of \" << exp_time << \"us\");\n\texp_time /= 1e6;\n\n\tauto ag = metadata.get(controls::AnalogueGain);\n\tuint16_t iso = 100;\n\tif (ag)\n\t\tiso = *ag * 100.0;\n\telse\n\t\tLOG_ERROR(\"WARNING: default to ISO value of \" << iso);\n\n\tfloat NEUTRAL[] = { 1, 1, 1 };\n\tMatrix WB_GAINS(1, 1, 1);\n\tauto cg = metadata.get(controls::ColourGains);\n\tif (cg)\n\t{\n\t\tNEUTRAL[0] = 1.0 / (*cg)[0];\n\t\tNEUTRAL[2] = 1.0 / (*cg)[1];\n\t\tWB_GAINS = Matrix((*cg)[0], 1, (*cg)[1]);\n\t}\n\n\t// Use a slightly plausible default CCM in case the metadata doesn't have one (it should!).\n\tMatrix CCM(1.90255, -0.77478, -0.12777,\n\t\t\t   -0.31338, 1.88197, -0.56858,\n\t\t\t   -0.06001, -0.61785, 1.67786);\n\tauto ccm = metadata.get(controls::ColourCorrectionMatrix);\n\tif (ccm)\n\t{\n\t\tCCM = Matrix((*ccm)[0], (*ccm)[1], (*ccm)[2], (*ccm)[3], (*ccm)[4], (*ccm)[5], (*ccm)[6], (*ccm)[7], (*ccm)[8]);\n\t}\n\telse\n\t\tLOG_ERROR(\"WARNING: no CCM metadata found\");\n\n\t// This maxtrix from http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n\tMatrix RGB2XYZ(0.4124564, 0.3575761, 0.1804375,\n\t\t\t\t   0.2126729, 0.7151522, 0.0721750,\n\t\t\t\t   0.0193339, 0.1191920, 0.9503041);\n\tMatrix CAM_XYZ = (RGB2XYZ * CCM * WB_GAINS).Inv();\n\n\tLOG(2, \"Black levels \" << black_levels[0] << \" \" << black_levels[1] << \" \" << black_levels[2] << \" \"\n\t\t\t\t\t\t   << black_levels[3] << \", exposure time \" << exp_time * 1e6 << \"us, ISO \" << iso);\n\tLOG(2, \"Neutral \" << NEUTRAL[0] << \" \" << NEUTRAL[1] << \" \" << NEUTRAL[2]);\n\tLOG(2, \"Cam_XYZ: \");\n\tLOG(2, CAM_XYZ.m[0] << \" \" << CAM_XYZ.m[1] << \" \" << CAM_XYZ.m[2]);\n\tLOG(2, CAM_XYZ.m[3] << \" \" << CAM_XYZ.m[4] << \" \" << CAM_XYZ.m[5]);\n\tLOG(2, CAM_XYZ.m[6] << \" \" << CAM_XYZ.m[7] << \" \" << CAM_XYZ.m[8]);\n\n\t// Finally write the DNG.\n\n\tTIFF *tif = nullptr;\n\n\ttry\n\t{\n\t\tconst short cfa_repeat_pattern_dim[] = { 2, 2 };\n\t\tuint32_t white = (1 << bayer_format.bits) - 1;\n\t\ttoff_t offset_subifd = 0, offset_exififd = 0;\n\t\tstd::string unique_model = std::string(MAKE_STRING \" \") + cam_model;\n\n\t\ttif = TIFFOpen(filename.c_str(), \"w\");\n\t\tif (!tif)\n\t\t\tthrow std::runtime_error(\"could not open file \" + filename);\n\n\t\t// This is just the thumbnail, but put it first to help software that only\n\t\t// reads the first IFD.\n\t\tTIFFSetField(tif, TIFFTAG_SUBFILETYPE, 1);\n\t\tTIFFSetField(tif, TIFFTAG_IMAGEWIDTH, info.width >> 4);\n\t\tTIFFSetField(tif, TIFFTAG_IMAGELENGTH, info.height >> 4);\n\t\tTIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8);\n\t\tTIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n\t\tTIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n\t\tTIFFSetField(tif, TIFFTAG_MAKE, MAKE_STRING);\n\t\tTIFFSetField(tif, TIFFTAG_MODEL, cam_model.c_str());\n\t\tTIFFSetField(tif, TIFFTAG_DNGVERSION, \"\\001\\001\\000\\000\");\n\t\tTIFFSetField(tif, TIFFTAG_DNGBACKWARDVERSION, \"\\001\\000\\000\\000\");\n\t\tTIFFSetField(tif, TIFFTAG_UNIQUECAMERAMODEL, unique_model.c_str());\n\t\tTIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n\t\tTIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 3);\n\t\tTIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\t\tTIFFSetField(tif, TIFFTAG_SOFTWARE, \"rpicam-still\");\n\t\tTIFFSetField(tif, TIFFTAG_COLORMATRIX1, 9, CAM_XYZ.m);\n\t\tTIFFSetField(tif, TIFFTAG_ASSHOTNEUTRAL, 3, NEUTRAL);\n\t\tTIFFSetField(tif, TIFFTAG_CALIBRATIONILLUMINANT1, 21);\n\t\tTIFFSetField(tif, TIFFTAG_SUBIFD, 1, &offset_subifd);\n\t\tTIFFSetField(tif, TIFFTAG_EXIFIFD, offset_exififd);\n\n\t\t// Make a small greyscale thumbnail, just to give some clue what's in here.\n\t\tstd::vector<uint8_t> thumb_buf((info.width >> 4) * 3);\n\n\t\tfor (unsigned int y = 0; y < (info.height >> 4); y++)\n\t\t{\n\t\t\tfor (unsigned int x = 0; x < (info.width >> 4); x++)\n\t\t\t{\n\t\t\t\tunsigned int off = (y * buf_stride_pixels + x) << 4;\n\t\t\t\tuint32_t grey =\n\t\t\t\t\tbuf[off] + buf[off + 1] + buf[off + buf_stride_pixels] + buf[off + buf_stride_pixels + 1];\n\t\t\t\tgrey = (grey << 14) >> bayer_format.bits;\n\t\t\t\tgrey = sqrt((double)grey); // simple \"gamma correction\"\n\t\t\t\tthumb_buf[3 * x] = thumb_buf[3 * x + 1] = thumb_buf[3 * x + 2] = grey;\n\t\t\t}\n\t\t\tif (TIFFWriteScanline(tif, &thumb_buf[0], y, 0) != 1)\n\t\t\t\tthrow std::runtime_error(\"error writing DNG thumbnail data\");\n\t\t}\n\n\t\tTIFFWriteDirectory(tif);\n\n\t\t// The main image (actually tends to show up as \"sub-image 1\").\n\t\tTIFFSetField(tif, TIFFTAG_SUBFILETYPE, 0);\n\t\tTIFFSetField(tif, TIFFTAG_IMAGEWIDTH, info.width);\n\t\tTIFFSetField(tif, TIFFTAG_IMAGELENGTH, info.height);\n\t\tTIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 16);\n\t\tTIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_CFA);\n\t\tTIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 1);\n\t\tTIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\t\tTIFFSetField(tif, TIFFTAG_CFAREPEATPATTERNDIM, cfa_repeat_pattern_dim);\n#if TIFFLIB_VERSION >= 20201219 // version 4.2.0 or later\n\t\tTIFFSetField(tif, TIFFTAG_CFAPATTERN, 4, bayer_format.order);\n#else\n\t\tTIFFSetField(tif, TIFFTAG_CFAPATTERN, bayer_format.order);\n#endif\n\t\tTIFFSetField(tif, TIFFTAG_WHITELEVEL, 1, &white);\n\t\tconst uint16_t black_level_repeat_dim[] = { 2, 2 };\n\t\tTIFFSetField(tif, TIFFTAG_BLACKLEVELREPEATDIM, &black_level_repeat_dim);\n\t\tTIFFSetField(tif, TIFFTAG_BLACKLEVEL, 4, &black_levels);\n\n\t\tfor (unsigned int y = 0; y < info.height; y++)\n\t\t{\n\t\t\tif (TIFFWriteScanline(tif, &buf[buf_stride_pixels * y], y, 0) != 1)\n\t\t\t\tthrow std::runtime_error(\"error writing DNG image data\");\n\t\t}\n\n\t\t// We have to checkpoint before the directory offset is valid.\n\t\tTIFFCheckpointDirectory(tif);\n\t\toffset_subifd = TIFFCurrentDirOffset(tif);\n\t\tTIFFWriteDirectory(tif);\n\n\t\t// Create a separate IFD just for the EXIF tags. Why we couldn't simply have\n\t\t// DNG tags for these, which would have made life so much easier, I have no idea.\n\t\tTIFFCreateEXIFDirectory(tif);\n\n\t\ttime_t t;\n\t\ttime(&t);\n\t\tstruct tm *time_info = localtime(&t);\n\t\tchar time_str[32];\n\t\tstrftime(time_str, 32, \"%Y:%m:%d %H:%M:%S\", time_info);\n\t\tTIFFSetField(tif, EXIFTAG_DATETIMEORIGINAL, time_str);\n\n\t\tTIFFSetField(tif, EXIFTAG_ISOSPEEDRATINGS, 1, &iso);\n\t\tTIFFSetField(tif, EXIFTAG_EXPOSURETIME, exp_time);\n\n\t\tauto lp = metadata.get(libcamera::controls::LensPosition);\n\t\tif (lp)\n\t\t{\n\t\t\tdouble dist = (*lp > 0.0) ? (1.0 / *lp) : std::numeric_limits<double>::infinity();\n\t\t\tTIFFSetField(tif, EXIFTAG_SUBJECTDISTANCE, dist);\n\t\t}\n\n\t\tTIFFCheckpointDirectory(tif);\n\t\toffset_exififd = TIFFCurrentDirOffset(tif);\n\t\tTIFFWriteDirectory(tif);\n\n\t\t// Now got back to the initial IFD and correct the offsets to its sub-thingies\n\t\tTIFFSetDirectory(tif, 0);\n\t\tTIFFSetField(tif, TIFFTAG_SUBIFD, 1, &offset_subifd);\n\t\tTIFFSetField(tif, TIFFTAG_EXIFIFD, offset_exififd);\n\t\tTIFFWriteDirectory(tif);\n\n\t\t// For reasons unknown, the last sub-IFD that we make seems to reappear at the\n\t\t// end of the file as IDF1, and some tools (exiftool for example) are prone to\n\t\t// complain about it. As far as I can see the code above is doing the correct\n\t\t// things, and I can't find any references to this problem anywhere. So frankly\n\t\t// I have no idea what is happening - please let us know if you do. Anyway,\n\t\t// this bodge appears to make the problem go away...\n\t\tTIFFUnlinkDirectory(tif, 2);\n\n\t\tTIFFClose(tif);\n\t}\n\tcatch (std::exception const &e)\n\t{\n\t\tif (tif)\n\t\t\tTIFFClose(tif);\n\t\tthrow;\n\t}\n}",
    "JNIEXPORT jboolean JNICALL LCTIFFWriter_METHOD(append)\n    ( JNIEnv *env, jobject jLCTIFFWriter, jbyteArray jFileNameUtf8 )\n{\n    TIFF *const destTIFF = getNativePtr( env, jLCTIFFWriter );\n    TIFFSetField( destTIFF, TIFFTAG_PAGENUMBER, 0, 2 );\n    int result = TIFFWriteDirectory( destTIFF );\n    if ( !result )\n        return JNI_FALSE;\n    jbyteArray_to_c const cFileName( env, jFileNameUtf8 );\n    TIFF *const srcTIFF = LC_TIFFOpen( cFileName, \"r\" );\n    if ( !srcTIFF )\n        return JNI_FALSE;\n    if ( isLightZoneLayeredTIFF( srcTIFF ) )\n        TIFFReadDirectory( srcTIFF );\n    result = tiffcp( srcTIFF, destTIFF );\n    TIFFSetField( destTIFF, TIFFTAG_PAGENUMBER, 1, 2 );\n    TIFFClose( srcTIFF );\n    return result ? JNI_TRUE : JNI_FALSE;\n}",
    "JNIEXPORT void JNICALL LCTIFFCommon_METHOD(TIFFClose)\n    ( JNIEnv *env, jobject jLCTIFFCommon )\n{\n    if ( TIFF *const tiff = getNativePtr( env, jLCTIFFCommon ) ) {\n        TIFFClose( tiff );\n        LC_setNativePtr( env, jLCTIFFCommon, 0 );\n    }\n}",
    "EStatusCode TIFFImageHandler::WriteImageBufferToStream(PDFStream* inPDFStream,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tuint32_t inImageWidth,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tuint32_t inImageLength,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tunsigned char* inBuffer,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tImageSizeProc inBufferSizeFunction)\n{\n\tEStatusCode status = PDFHummus::eSuccess;\n\tdo\n\t{\n\t\tmT2p->pdfStream = NULL;\n\n\t\t/* hopefully here is good enough, and that dummy is good. \n\t\t\tbasically the only allowed action is to write */\n\t\tTIFF* output = TIFFClientOpen(\"dummy.txt\", \"w\", (thandle_t)mT2p,\n\t\t\t\t\tt2p_readproc, t2p_writeproc, t2p_seekproc, \n\t\t\t\t\tt2p_closeproc, t2p_sizeproc, \n\t\t\t\t\tt2p_mapproc, t2p_unmapproc );\n\n\t\tTIFFSetField(output, TIFFTAG_PHOTOMETRIC, mT2p->tiff_photometric);\n\t\tTIFFSetField(output, TIFFTAG_BITSPERSAMPLE, mT2p->tiff_bitspersample);\n\t\tTIFFSetField(output, TIFFTAG_SAMPLESPERPIXEL, mT2p->tiff_samplesperpixel);\n\t\tTIFFSetField(output, TIFFTAG_IMAGEWIDTH, inImageWidth);\n\t\tTIFFSetField(output, TIFFTAG_IMAGELENGTH, inImageLength);\n\t\tTIFFSetField(output, TIFFTAG_ROWSPERSTRIP, inImageLength); // equal to image length in both usages...\n\t\tTIFFSetField(output, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\t\tTIFFSetField(output, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);\n\n\t\tswitch(mT2p->pdf_compression)\n\t\t{\n\t\tcase T2P_COMPRESS_NONE:\n\t\t\tTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n\t\t\tbreak;\n\t\tcase T2P_COMPRESS_G4:\n\t\t\tTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_CCITTFAX4);\n\t\t\tbreak;\n\t\tcase T2P_COMPRESS_ZIP:\n\t\t\tTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);\n\t\t\tif(mT2p->pdf_defaultcompressionquality%100 != 0)\n\t\t\t{\n\t\t\t\tTIFFSetField(output, \n\t\t\t\t\tTIFFTAG_PREDICTOR, \n\t\t\t\t\tmT2p->pdf_defaultcompressionquality % 100);\n\t\t\t}\n\t\t\tif(mT2p->pdf_defaultcompressionquality/100 != 0)\n\t\t\t{\n\t\t\t\tTIFFSetField(output, \n\t\t\t\t\tTIFFTAG_ZIPQUALITY, \n\t\t\t\t\t(mT2p->pdf_defaultcompressionquality / 100));\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tmT2p->pdfStream = inPDFStream;\n\t\tmT2p->output = output; // dirty trick so i can use the inBufferSizeFunction function by getting info from output (sometimes)\n\n\t\ttsize_t bufferoffset = TIFFWriteEncodedStrip(output, (tstrip_t)0,inBuffer,inBufferSizeFunction(mT2p)); \n\n\t\tmT2p->output = NULL;\n\t\tmT2p->pdfStream = NULL;\n\t\tif (output != NULL)\n\t\t\tTIFFClose(output);\n\n\t\tif (bufferoffset == (tsize_t)-1) \n\t\t{\n\t\t\tTRACE_LOG1(\"Error writing encoded strip to output PDF %s\",mT2p->inputFilePath.c_str());\n\t\t\tstatus = PDFHummus::eFailure;\n\t\t\tbreak;\n\t\t}\t\t\n\t}while(false);\n\n\treturn status;\n}",
    "PDFFormXObject* TIFFImageHandler::CreateFormXObjectFromTIFFStream(\tIByteReaderWithPosition* inTIFFStream,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tObjectIDType inFormXObjectID,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tconst TIFFUsageParameters& inTIFFUsageParameters)\n{\n\n\tPDFFormXObject* imageFormXObject = NULL;\n\tTIFF* input = NULL;\n\n\tdo\n\t{\n\t\tTIFFSetErrorHandler(ReportError);\n\t\tTIFFSetWarningHandler(ReportWarning);\n\n\t\tif(!mObjectsContext || !mContainerDocumentContext)\n\t\t{\n\t\t\tTRACE_LOG(\"TIFFImageHandler::CreateFormXObjectFromTIFFFile. Unexpected Error, mObjectsContext or mContainerDocumentContext not initialized\");\n\t\t\tbreak;\n\t\t}\n\n\t\tStreamWithPos streamInfo;\n\t\tstreamInfo.mStream = inTIFFStream;\n\t\tstreamInfo.mOriginalPosition = inTIFFStream->GetCurrentPosition();\n\t\t\n\t\tinput = TIFFClientOpen(\"Stream\",\"r\",(thandle_t)&streamInfo,STATIC_streamRead,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSTATIC_streamWrite,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSTATIC_streamSeek,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSTATIC_streamClose,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSTATIC_tiffSize,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSTATIC_tiffMap,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSTATIC_tiffUnmap);\n\t\tif(!input)\n\t\t{\n\t\t\tTRACE_LOG(\"TIFFImageHandler::CreateFormXObjectFromTIFFFile. cannot open stream for reading\");\n\t\t\tbreak;\n\t\t}\n\n\n\t\tInitializeConversionState();\n\t\tmT2p->input = input;\n\t\tmT2p->inputFilePath = \"\";\n\t\tmT2p->pdf_page = inTIFFUsageParameters.PageIndex;\n\t\tmUserParameters = inTIFFUsageParameters;\n\n\t\timageFormXObject = ConvertTiff2PDF(inFormXObjectID);\n\n\t}while(false);\n\n\tDestroyConversionState();\n\tif(input != NULL)\n\t\tTIFFClose(input);\n\n\treturn imageFormXObject;\n}",
    "TIFFImageHandler::TiffImageInfo TIFFImageHandler::ReadImageInfo(IByteReaderWithPosition* inTIFFStream,unsigned long inImageIndex)\n{\n\tTIFF* input = NULL;\n    TiffImageInfo imageInfo;\n\t\n\timageInfo.dimensions.first = -1;\n\timageInfo.dimensions.second = -1;\n\timageInfo.colorComponents = 0;\n    EStatusCode status;\n    \n\tdo\n\t{\n\t\tTIFFSetErrorHandler(ReportError);\n\t\tTIFFSetWarningHandler(ReportWarning);\n        \n\t\tStreamWithPos streamInfo;\n\t\tstreamInfo.mStream = inTIFFStream;\n\t\tstreamInfo.mOriginalPosition = inTIFFStream->GetCurrentPosition();\n\t\t\n\t\tinput = TIFFClientOpen(\"Stream\",\"r\",(thandle_t)&streamInfo,STATIC_streamRead,\n                               STATIC_streamWrite,\n                               STATIC_streamSeek,\n                               STATIC_streamClose,\n                               STATIC_tiffSize,\n                               STATIC_tiffMap,\n                               STATIC_tiffUnmap);\n\t\tif(!input)\n\t\t{\n\t\t\tTRACE_LOG(\"TIFFImageHandler::ReadImageDimensions. cannot open stream for reading\");\n\t\t\tbreak;\n\t\t}\n        \n        \n\t\tInitializeConversionState();\n\t\tmT2p->input = input;\n\t\tmT2p->inputFilePath = \"\";\n\t\tmT2p->pdf_page = (tdir_t)inImageIndex;\n        \n        \n        status = ReadTopLevelTiffInformation();\n        if(status != PDFHummus::eSuccess)\n            break;\n            \n        if(mT2p->pdf_page >= mT2p->tiff_pagecount)\n        {\n            TRACE_LOG3(\n                           \"TIFFImageHandler::ReadImageDimensions, Requested tiff page %u where the tiff only has %u pages. Tiff file name - %s\",\n                           mT2p->pdf_page,\n                           mT2p->tiff_pagecount,\n                           mT2p->inputFilePath.c_str());\n            status = PDFHummus::eFailure;\n            break;\n        }\n        \n        status = ReadTIFFPageInformation();\n        if(status != PDFHummus::eSuccess)\n            break;\n        imageInfo.dimensions.first = mT2p->pdf_mediabox.x2 - mT2p->pdf_mediabox.x1;\n        imageInfo.dimensions.second = mT2p->pdf_mediabox.y2 - mT2p->pdf_mediabox.y1;\n\t\timageInfo.colorComponents = mT2p->tiff_samplesperpixel;\n\t\t      \n\t}while(false);\n    \n\tDestroyConversionState();\n\tif(input != NULL)\n\t\tTIFFClose(input);\n    \n    return imageInfo;\n}",
    "unsigned long TIFFImageHandler::ReadImagePageCount(IByteReaderWithPosition* inTIFFStream)\n{\n\tTIFF* input = NULL;\n\tunsigned long result = 0;\n\tEStatusCode status;\n\n\tdo\n\t{\n\t\tTIFFSetErrorHandler(ReportError);\n\t\tTIFFSetWarningHandler(ReportWarning);\n\n\t\tStreamWithPos streamInfo;\n\t\tstreamInfo.mStream = inTIFFStream;\n\t\tstreamInfo.mOriginalPosition = inTIFFStream->GetCurrentPosition();\n\n\t\tinput = TIFFClientOpen(\"Stream\", \"r\", (thandle_t)&streamInfo, STATIC_streamRead,\n\t\t\tSTATIC_streamWrite,\n\t\t\tSTATIC_streamSeek,\n\t\t\tSTATIC_streamClose,\n\t\t\tSTATIC_tiffSize,\n\t\t\tSTATIC_tiffMap,\n\t\t\tSTATIC_tiffUnmap);\n\t\tif (!input)\n\t\t{\n\t\t\tTRACE_LOG(\"TIFFImageHandler::ReadImagePageCount. cannot open stream for reading\");\n\t\t\tbreak;\n\t\t}\n\n\n\t\tInitializeConversionState();\n\t\tmT2p->input = input;\n\t\tmT2p->inputFilePath = \"\";\n\n\t\tstatus = ReadTopLevelTiffInformation();\n\t\tif (status != PDFHummus::eSuccess)\n\t\t\tbreak;\n\n\t\tresult = mT2p->tiff_pagecount;\n\t} while (false);\n\n\tDestroyConversionState();\n\tif (input != NULL)\n\t\tTIFFClose(input);\n\n\treturn result;\n}",
    "ImageHeaders\nload_tiff_file_headers (std::string const& filename)\n{\n    ImageHeaders headers;\n    TIFFSetWarningHandler(nullptr);\n    TIFFSetErrorHandler(tiff_error_handler);\n\n    TIFF* tif = TIFFOpen(filename.c_str(), \"r\");\n    if (tif == nullptr)\n        throw util::FileException(filename, \"TIFF file format not recognized\");\n\n    try\n    {\n        uint32_t width, height;\n        uint16_t channels, bits, sampleFormat;\n        TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n        TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n        TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &channels);\n        TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bits);\n        TIFFGetField(tif, TIFFTAG_SAMPLEFORMAT, &sampleFormat);\n\n        headers.width = width;\n        headers.height = height;\n        headers.channels = channels;\n        headers.type = IMAGE_TYPE_UNKNOWN;\n\n        if (bits == 8) {\n            switch(sampleFormat) {\n                case SAMPLEFORMAT_UINT:\n                    headers.type = IMAGE_TYPE_UINT8;\n                    break;\n                case SAMPLEFORMAT_INT:\n                    headers.type = IMAGE_TYPE_SINT8;\n                    break;\n                case SAMPLEFORMAT_IEEEFP:\n                    headers.type = IMAGE_TYPE_FLOAT;\n                    break;\n                default:\n                    break;\n            }\n        } else if (bits == 16) {\n            switch(sampleFormat) {\n                case SAMPLEFORMAT_UINT:\n                    headers.type = IMAGE_TYPE_UINT16;\n                    break;\n                case SAMPLEFORMAT_INT:\n                    headers.type = IMAGE_TYPE_SINT16;\n                    break;\n                case SAMPLEFORMAT_IEEEFP:\n                    headers.type = IMAGE_TYPE_FLOAT;\n                    break;\n                default:\n                    break;\n            }\n        } else if (bits == 32) {\n            switch(sampleFormat) {\n                case SAMPLEFORMAT_UINT:\n                    headers.type = IMAGE_TYPE_UINT32;\n                    break;\n                case SAMPLEFORMAT_INT:\n                    headers.type = IMAGE_TYPE_SINT32;\n                    break;\n                case SAMPLEFORMAT_IEEEFP:\n                    headers.type = IMAGE_TYPE_FLOAT;\n                    break;\n                default:\n                    break;\n            }\n        } else if (bits == 64) {\n            switch(sampleFormat) {\n                case SAMPLEFORMAT_UINT:\n                    headers.type = IMAGE_TYPE_UINT64;\n                    break;\n                case SAMPLEFORMAT_INT:\n                    headers.type = IMAGE_TYPE_SINT64;\n                    break;\n                case SAMPLEFORMAT_IEEEFP:\n                    headers.type = IMAGE_TYPE_FLOAT;\n                    break;\n                default:\n                    break;\n            }\n        }\n\n        if (headers.type == IMAGE_TYPE_UNKNOWN){\n            throw util::Exception(\"TIFF file has unsupported bits and/or sample format.\");\n        }\n\n        TIFFClose(tif);\n        return headers;\n    }\n    catch (std::exception& e)\n    {\n        TIFFClose(tif);\n        throw;\n    }\n}",
    "ByteImage::Ptr\nload_tiff_file (std::string const& filename)\n{\n    TIFFSetWarningHandler(nullptr);\n    TIFFSetErrorHandler(tiff_error_handler);\n\n    TIFF* tif = TIFFOpen(filename.c_str(), \"r\");\n    if (!tif)\n        throw util::Exception(\"TIFF file format not recognized\");\n\n    try\n    {\n        /* Read width and height from TIFF and create MVE image. */\n        uint32_t width, height;\n        uint16_t channels, bits;\n        TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n        TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n        TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &channels);\n        TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bits);\n        if (bits != 8)\n            throw util::Exception(\"Expected 8 bit TIFF file\");\n        ByteImage::Ptr image = ByteImage::create(width, height, channels);\n\n        /* Scanline based TIFF reading. */\n        uint32_t rowstride = TIFFScanlineSize(tif);\n        ByteImage::ImageData& data = image->get_data();\n        for (uint32_t row = 0; row < height; row++)\n        {\n            tdata_t row_pointer = &data[row * rowstride];\n            TIFFReadScanline(tif, row_pointer, row);\n        }\n\n        TIFFClose(tif);\n        return image;\n    }\n    catch (std::exception& e)\n    {\n        TIFFClose(tif);\n        throw;\n    }\n}",
    "void\nsave_tiff_file (ByteImage::ConstPtr image, std::string const& filename)\n{\n    if (image == nullptr)\n        throw std::invalid_argument(\"Null image given\");\n\n    TIFF* tif = TIFFOpen(filename.c_str(), \"w\");\n    if (!tif)\n        throw util::FileException(filename, \"Unknown TIFF file error\");\n\n    uint32_t width = image->width();\n    uint32_t height = image->height();\n    uint32_t channels = image->channels();\n    TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, width);\n    TIFFSetField(tif, TIFFTAG_IMAGELENGTH, height);\n    TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, channels);\n    TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8);\n    TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);\n    TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n\n    tdata_t buffer = const_cast<uint8_t*>(image->get_data_pointer());\n    int64_t ret = TIFFWriteEncodedStrip(tif, 0, buffer,\n        image->get_value_amount());\n\n    TIFFClose(tif);\n\n    if (ret < 0)\n        throw util::Exception(\"Error writing TIFF image\");\n}",
    "RawImage::Ptr\nload_tiff_16_file (std::string const& filename)\n{\n    if (sizeof(uint16_t) != 2)\n        throw util::Exception(\"Need 16bit data type for TIFF image.\");\n\n    TIFFSetWarningHandler(nullptr);\n    TIFFSetErrorHandler(tiff_error_handler);\n\n    TIFF* tif = TIFFOpen(filename.c_str(), \"r\");\n    if (!tif)\n        throw util::Exception(\"TIFF file format not recognized\");\n\n    try\n    {\n        /* Read width and height from TIFF and create MVE image. */\n        uint32_t width, height;\n        uint16_t channels, bits;\n        TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n        TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n        TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &channels);\n        TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bits);\n        if (bits != 16)\n            throw util::Exception(\"TIFF file bits per sample don't match\");\n\n        RawImage::Ptr image = Image<uint16_t>::create(width, height, channels);\n\n        /* Scanline based TIFF reading. */\n        uint32_t rowstride = TIFFScanlineSize(tif) / sizeof(uint16_t);\n        Image<uint16_t>::ImageData& data = image->get_data();\n        for (uint32_t row = 0; row < height; row++)\n        {\n            tdata_t row_pointer = &data[row * rowstride];\n            TIFFReadScanline(tif, row_pointer, row);\n        }\n\n        TIFFClose(tif);\n        return image;\n    }\n    catch (std::exception& e)\n    {\n        TIFFClose(tif);\n        throw;\n    }\n}",
    "void\nsave_tiff_16_file (RawImage::ConstPtr image, std::string const& filename)\n{\n    if (image == nullptr)\n        throw std::invalid_argument(\"Null image given\");\n\n    TIFF* tif = TIFFOpen(filename.c_str(), \"w\");\n    if (!tif)\n        throw util::FileException(filename, \"Unknown TIFF file error\");\n\n    uint32_t width = image->width();\n    uint32_t height = image->height();\n    uint32_t channels = image->channels();\n    TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, width);\n    TIFFSetField(tif, TIFFTAG_IMAGELENGTH, height);\n    TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, channels);\n    TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8 * sizeof(uint16_t));\n    TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);\n    TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n\n    tdata_t buffer = const_cast<uint16_t*>(image->get_data_pointer());\n    int64_t ret = TIFFWriteEncodedStrip(tif, 0, buffer,\n        image->get_value_amount() * sizeof(uint16_t));\n\n    TIFFClose(tif);\n\n    if (ret < 0)\n        throw util::Exception(\"Error writing TIFF image\");\n}",
    "FloatImage::Ptr\nload_tiff_float_file (std::string const& filename)\n{\n    if (sizeof(float) != 4)\n        throw util::Exception(\"Need 32bit data type for TIFF image.\");\n\n    TIFFSetWarningHandler(nullptr);\n    TIFFSetErrorHandler(tiff_error_handler);\n\n    TIFF* tif = TIFFOpen(filename.c_str(), \"r\");\n    if (!tif)\n        throw util::Exception(\"TIFF file format not recognized\");\n\n    try\n    {\n        /* Read width and height from TIFF and create MVE image. */\n        uint32_t width, height;\n        uint16_t channels, bits;\n        TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n        TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n        TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &channels);\n        TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bits);\n        if (bits != 32)\n            throw util::Exception(\"TIFF file bits per sample don't match\");\n\n        FloatImage::Ptr image = Image<float>::create(width, height, channels);\n\n        /* Scanline based TIFF reading. */\n        uint32_t rowstride = TIFFScanlineSize(tif) / sizeof(float);\n        Image<float>::ImageData& data = image->get_data();\n        for (uint32_t row = 0; row < height; row++)\n        {\n            tdata_t row_pointer = &data[row * rowstride];\n            TIFFReadScanline(tif, row_pointer, row);\n        }\n\n        TIFFClose(tif);\n        return image;\n    }\n    catch (std::exception& e)\n    {\n        TIFFClose(tif);\n        throw;\n    }\n}",
    "void\nsave_tiff_float_file (FloatImage::ConstPtr image, std::string const& filename)\n{\n    if (image == nullptr)\n        throw std::invalid_argument(\"Null image given\");\n\n    TIFF* tif = TIFFOpen(filename.c_str(), \"w\");\n    if (!tif)\n        throw util::FileException(filename, \"Unknown TIFF file error\");\n\n    uint32_t width = image->width();\n    uint32_t height = image->height();\n    uint32_t channels = image->channels();\n    TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, width);\n    TIFFSetField(tif, TIFFTAG_IMAGELENGTH, height);\n    TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, channels);\n    TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8 * sizeof(float));\n    TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);\n    TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n    TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);\n\n    tdata_t buffer = const_cast<float*>(image->get_data_pointer());\n    int64_t ret = TIFFWriteEncodedStrip(tif, 0, buffer,\n        image->get_value_amount() * sizeof(float));\n\n    TIFFClose(tif);\n\n    if (ret < 0)\n        throw util::Exception(\"Error writing TIFF image\");\n}",
    "MAGICS_NO_EXPORT void CairoDriver::write_tiff() const {\n    int compression = 1;\n\n    unsigned char* data = cairo_image_surface_get_data(surface_);\n    int width           = cairo_image_surface_get_width(surface_);\n    int height          = cairo_image_surface_get_height(surface_);\n    const int stride    = cairo_image_surface_get_stride(surface_);\n\n    TIFF* tif = TIFFOpen(fileName_.c_str(), \"w\");\n    if (!tif) {\n        if (MagicsGlobal::strict()) {\n            throw CannotOpenFile(fileName_);\n        }\n        MagLog::warning() << \"CairoDriver: Unable to open TIFF file \" << fileName_ << std::endl;\n        return;\n    }\n\n    GTIF* gtif = GTIFNew(tif);\n    if (!gtif) {\n        if (MagicsGlobal::strict()) {\n            throw CannotOpenFile(fileName_);\n        }\n        MagLog::warning() << \"CairoDriver: Unable to open GeoTIFF file \" << fileName_ << std::endl;\n        return;\n    }\n\n    TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, width);\n    TIFFSetField(tif, TIFFTAG_IMAGELENGTH, height);\n    TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 4);\n    TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8);\n    TIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n    TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n    TIFFSetField(tif, TIFFTAG_SOFTWARE, \"Magics\");\n\n    GTIFKeySet(gtif, GTModelTypeGeoKey, TYPE_SHORT, 1, ModelGeographic);\n    GTIFKeySet(gtif, GTRasterTypeGeoKey, TYPE_SHORT, 1, RasterPixelIsArea);\n    GTIFKeySet(gtif, GTCitationGeoKey, TYPE_ASCII, 0, \"MagicsPlot\");\n    GTIFKeySet(gtif, GeographicTypeGeoKey, TYPE_SHORT, 1, KvUserDefined);\n    GTIFKeySet(gtif, GeogCitationGeoKey, TYPE_ASCII, 0, \"Everest Ellipsoid Used.\");\n    GTIFKeySet(gtif, GeogAngularUnitsGeoKey, TYPE_SHORT, 1, Angular_Degree);\n    GTIFKeySet(gtif, GeogLinearUnitsGeoKey, TYPE_SHORT, 1, Linear_Meter);\n    GTIFKeySet(gtif, GeogGeodeticDatumGeoKey, TYPE_SHORT, 1, KvUserDefined);\n    GTIFKeySet(gtif, GeogEllipsoidGeoKey, TYPE_SHORT, 1, Ellipse_WGS_84);\n    GTIFKeySet(gtif, GeogSemiMajorAxisGeoKey, TYPE_DOUBLE, 1, (double)6377298.556);\n    GTIFKeySet(gtif, GeogInvFlatteningGeoKey, TYPE_DOUBLE, 1, (double)300.8017);\n\n    if (compression > 1) {\n        if (compression > 10)\n            compression = 10;\n        TIFFSetField(tif, TIFFTAG_COMPRESSION, compression);\n    }\n\n    // DPI\n    TIFFSetField(tif, TIFFTAG_RESOLUTIONUNIT, RESUNIT_INCH);\n    TIFFSetField(tif, TIFFTAG_XRESOLUTION, (float)90.);\n    TIFFSetField(tif, TIFFTAG_YRESOLUTION, (float)90.);\n\n    unsigned char* buf;\n    if (TIFFScanlineSize(tif))\n        buf = (unsigned char*)_TIFFmalloc(4 * width);\n    else\n        buf = (unsigned char*)_TIFFmalloc(TIFFScanlineSize(tif));\n\n    unsigned char* pscanline;\n    for (unsigned int i = 0; i < height; i++) {\n        pscanline = buf;\n        for (unsigned int j = 0; j < stride; j++) {\n            *pscanline++ = data[i * stride + j++];\n            *pscanline++ = data[i * stride + j++];\n            *pscanline++ = data[i * stride + j++];\n            *pscanline++ = data[i * stride + j];\n        }\n        TIFFWriteScanline(tif, buf, i, 0);\n    }\n    TIFFClose(tif);\n    _TIFFfree(buf);\n    return;\n}",
    "int image::read_tiff(const std::string &filename) {\n  TIFF *tiff_handle;\n  size_t bytes_per_line;\n  uint16_t planar_configuration;\n  if ((tiff_handle = TIFFOpen(filename.c_str(), \"r\")) == nullptr) {\n    printf(\"ERROR: File %s is not found.\\n\", filename.c_str());\n    return EXIT_FAILURE;\n  }\n\n  uint32_t tiff_width  = 0;\n  uint32_t tiff_height = 0;\n  TIFFGetField(tiff_handle, TIFFTAG_IMAGEWIDTH, &tiff_width);\n  TIFFGetField(tiff_handle, TIFFTAG_IMAGELENGTH, &tiff_height);\n\n  uint16_t tiff_bits_per_sample   = 0;\n  uint16_t tiff_samples_per_pixel = 0;\n  TIFFGetField(tiff_handle, TIFFTAG_BITSPERSAMPLE, &tiff_bits_per_sample);\n  TIFFGetField(tiff_handle, TIFFTAG_SAMPLESPERPIXEL, &tiff_samples_per_pixel);\n  // some TIFs have tiff_samples_per_pixel=0 when it is a single channel\n  // image - set to 1\n  tiff_samples_per_pixel = (tiff_samples_per_pixel < 1) ? 1 : tiff_samples_per_pixel;\n\n  uint16_t tiff_planar_configuration = 0;\n  uint16_t tiff_photometric          = 0;\n  TIFFGetField(tiff_handle, TIFFTAG_PLANARCONFIG, &tiff_planar_configuration);\n  TIFFGetField(tiff_handle, TIFFTAG_PHOTOMETRIC, &tiff_photometric);\n\n  planar_configuration = tiff_planar_configuration;\n\n  uint16_t tiff_compression    = 0;\n  uint32_t tiff_rows_per_strip = 0;\n  TIFFGetField(tiff_handle, TIFFTAG_COMPRESSION, &tiff_compression);\n  TIFFGetField(tiff_handle, TIFFTAG_ROWSPERSTRIP, &tiff_rows_per_strip);\n\n  if (tiff_planar_configuration == PLANARCONFIG_SEPARATE) {\n    bytes_per_line = tiff_samples_per_pixel * TIFFScanlineSize64(tiff_handle);\n  } else {\n    bytes_per_line = TIFFScanlineSize64(tiff_handle);\n  }\n  // Error on known incompatilbe input formats\n  if (tiff_bits_per_sample != 8 && tiff_bits_per_sample != 16) {\n    printf(\n        \"ERROR: TIFF IO is currently limited to file limited\"\n        \" to files with TIFFTAG_BITSPERSAMPLE=8 and TIFFTAG_BITSPERSAMPLE=16 \\n\"\n        \"input file = %s has TIFFTAG_BITSPERSAMPLE=%d\\n\",\n        filename.c_str(), tiff_bits_per_sample);\n    TIFFClose(tiff_handle);\n    return EXIT_FAILURE;\n  }\n  if (TIFFIsTiled(tiff_handle)) {\n    printf(\n        \"ERROR: TIFF IO is currently limited to TIF files\"\n        \"without tiles. \\nInput file %s has been detected as tiled\\n\",\n        filename.c_str());\n    TIFFClose(tiff_handle);\n    return EXIT_FAILURE;\n  }\n  if (PHOTOMETRIC_RGB != tiff_photometric && PHOTOMETRIC_MINISBLACK != tiff_photometric) {\n    printf(\n        \"ERROR: TIFF IO is currently limited to \"\n        \"TIFFTAG_PHOTOMETRIC=PHOTOMETRIC_MINISBLACK=%d and \"\n        \"PHOTOMETRIC_RGB=%d. \\nInput file %s has been detected \"\n        \"TIFFTAG_PHOTOMETRIC=%d\\n\",\n        PHOTOMETRIC_MINISBLACK, PHOTOMETRIC_RGB, filename.c_str(), tiff_photometric);\n    TIFFClose(tiff_handle);\n    return EXIT_FAILURE;\n  }\n  this->num_components    = tiff_samples_per_pixel;\n  uint16_t num_iterations = this->num_components;\n  // setting bit-depth for components\n  this->width  = tiff_width;\n  this->height = tiff_height;\n  for (int i = 0; i < num_iterations; ++i) {\n    this->component_width.push_back(width);\n    this->component_height.push_back(height);\n    this->bits_per_pixel.push_back(static_cast<uint8_t>(tiff_bits_per_sample));\n    this->is_signed.push_back(false);\n  }\n\n  const uint32_t byte_per_sample = (tiff_bits_per_sample + 8U - 1U) / 8U;\n  const uint32_t component_gap   = num_iterations * byte_per_sample;\n  // const uint32_t line_width = component_gap * tiff_width;\n  std::unique_ptr<uint8_t[]> line_buf = MAKE_UNIQUE<uint8_t[]>(bytes_per_line);\n\n  // allocate memory once\n  if (this->buf == nullptr) {\n    this->buf = MAKE_UNIQUE<std::unique_ptr<int32_t[]>[]>(this->num_components);\n  }\n  for (size_t i = 0; i < this->num_components; ++i) {\n    this->buf[i] =\n        MAKE_UNIQUE<int32_t[]>(static_cast<size_t>(this->component_width[i]) * this->component_height[i]);\n  }\n\n  if (PLANARCONFIG_SEPARATE == planar_configuration) {\n    // PLANAR read\n  } else if (PLANARCONFIG_CONTIG == planar_configuration) {\n    // NORMAL read\n    for (uint32_t i = 0; i < tiff_height; ++i) {\n      if (TIFFReadScanline(tiff_handle, line_buf.get(), i) < 0) {\n        printf(\"ERROR: not enough samples in the given pnm file.\\n\");\n        TIFFClose(tiff_handle);\n        return EXIT_FAILURE;\n      }\n\n      for (size_t c = 0; c < num_iterations; ++c) {\n        uint8_t *src;\n        int32_t *dst;\n        src = &line_buf[c * byte_per_sample];\n        dst = &this->buf[c][static_cast<size_t>(i) * tiff_width];\n\n        switch (byte_per_sample) {\n          case 1:\n            for (size_t j = 0; j < tiff_width; ++j) {\n              *dst = *src;\n              dst++;\n              src += component_gap;\n            }\n            break;\n          case 2:\n            for (size_t j = 0; j < tiff_width; ++j) {\n              // suppose little-endian\n              *dst = src[0] | (src[1] << 8);\n              // *dst >>= 16 - tiff_bits_per_sample; // for future use\n              dst++;\n              src += component_gap;\n            }\n            break;\n          default:\n            printf(\"ERROR: bit-depth over 16 is not supported.\\n\");\n            TIFFClose(tiff_handle);\n            return EXIT_FAILURE;\n            break;\n        }\n      }\n    }\n  }\n  return EXIT_SUCCESS;\n}",
    "void ImLoadImageToMat(const char* path, ImMat& mat, bool gray)\n{\n    auto file_suffix = ImGuiHelper::path_filename_suffix(path);\n    if (file_suffix.compare(\".tiff\") == 0 || file_suffix.compare(\".TIFF\") == 0)\n    {\n#if IMGUI_TIFF\n        TIFF* tif = TIFFOpen(path, \"r\");\n        if (tif)\n        {\n            uint32_t w, h, c, imagelength;\n            uint16_t depth, config;\n            TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w);\n            TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\n            TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &c);\n            TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &depth);\n            TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &imagelength);\n            TIFFGetField(tif, TIFFTAG_PLANARCONFIG, &config);\n            mat.create_type(w, h, c, depth == 8 ? IM_DT_INT8 : depth == 16 ? IM_DT_INT16 : IM_DT_FLOAT32);\n            if (config == PLANARCONFIG_CONTIG)\n            {\n                mat.elempack = c;\n                for (int row = 0; row < imagelength; row++)\n                {\n                    void* mat_row = (unsigned char*)mat.data + (size_t)mat.w * row * mat.elemsize * mat.elempack;\n                    TIFFReadScanline(tif, mat_row, row);\n                }\n            }\n            else if (config == PLANARCONFIG_SEPARATE)\n            {\n                // TODO::Dicky\n            }\n            TIFFClose(tif);\n        }\n#endif\n        return;\n    }\n\n    int width = 0, height = 0, component = 0;\n    if (auto data = stbi_load(path, &width, &height, &component, gray ? 1 : 4))\n    {\n        ImMat tmp;\n        tmp.create_type(width, height, gray ? 1 : 4, data, IM_DT_INT8);\n        tmp.elempack = gray ? 1 : 4;\n        mat = tmp.clone();\n        stbi_image_free(data);\n    }\n    else if (auto data = stbi_load_16(path, &width, &height, &component, gray ? 1 : 4))\n    {\n        ImMat tmp;\n        tmp.create_type(width, height, gray ? 1 : 4, data, IM_DT_INT16);\n        tmp.elempack = gray ? 1 : 4;\n        mat = tmp.clone();\n        stbi_image_free(data);\n    }\n}",
    "bool ImMatToFile(const ImMat& mat, std::string path)\n{\n    int ret = -1;\n    if (mat.empty())\n    {\n        return false;\n    }\n    auto file_suffix = ImGuiHelper::path_filename_suffix(path);\n    if (!file_suffix.empty())\n    {\n        if (file_suffix.compare(\".png\") == 0 || file_suffix.compare(\".PNG\") == 0)\n            stbi_write_png(path.c_str(), mat.w, mat.h, mat.c, mat.data, mat.w * mat.c);\n        else if (file_suffix.compare(\".jpg\") == 0 || file_suffix.compare(\".JPG\") == 0 ||\n                file_suffix.compare(\".jpeg\") == 0 || file_suffix.compare(\".JPEG\") == 0)\n            stbi_write_jpg(path.c_str(), mat.w, mat.h, mat.c, mat.data, mat.w * mat.c);\n        else if (file_suffix.compare(\".bmp\") == 0 || file_suffix.compare(\".BMP\") == 0)\n            stbi_write_bmp(path.c_str(), mat.w, mat.h, mat.c, mat.data);\n        else if (file_suffix.compare(\".tga\") == 0 || file_suffix.compare(\".TGA\") == 0)\n            stbi_write_tga(path.c_str(), mat.w, mat.h, mat.c, mat.data);\n#if IMGUI_TIFF\n        else if (file_suffix.compare(\".tiff\") == 0 || file_suffix.compare(\".TIFF\") == 0)\n        {\n            // TODO::Dicky\n            TIFF* tif = TIFFOpen(path.c_str(), \"w\");\n            if (tif)\n            {\n                const char* copyright_str = \"CodeWin\"; \n                const char* app_str = \"CodeWin\"; \n                TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, mat.w);\n                TIFFSetField(tif, TIFFTAG_IMAGELENGTH, mat.h);\n                TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, mat.c);\n                TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, mat.h);\n                TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, mat.depth);\n                if (mat.c == 1)\n                    TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n                else\n                    TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n                //TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);\n                TIFFSetField(tif, TIFFTAG_RESOLUTIONUNIT, RESUNIT_INCH);\n                TIFFSetField(tif, TIFFTAG_XRESOLUTION, 72.0);\n                TIFFSetField(tif, TIFFTAG_YRESOLUTION, 72.0);\n                TIFFSetField(tif, TIFFTAG_COPYRIGHT, copyright_str);\n                TIFFSetField(tif, TIFFTAG_SOFTWARE, app_str);\n                TIFFSetField(tif, TIFFTAG_PLANARCONFIG, mat.elempack > 1 ? PLANARCONFIG_CONTIG : PLANARCONFIG_SEPARATE);\n                if (mat.type == IM_DT_FLOAT32)\n                    TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);\n                else if (mat.type == IM_DT_INT16 || mat.type == IM_DT_INT32)\n                    TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT);\n                if (mat.elempack > 1)\n                {\n                    for (int row = 0; row < mat.h; row++)\n                    {\n                        void* mat_row = (unsigned char*)mat.data + (size_t)mat.w * row * mat.elemsize * mat.elempack;\n                        TIFFWriteScanline(tif, mat_row, row, 0);\n                    } \n                }\n                else\n                {\n                    for (int c = 0; c < mat.c; c++)\n                    {\n                        auto channel = mat.channel(c);\n                        for (int row = 0; row < channel.h; row++)\n                        {\n                            void* channel_row = (unsigned char*)channel.data + (size_t)channel.w * row * channel.elemsize;\n                            TIFFWriteScanline(tif, channel_row, row, c);\n                        }\n                    }\n                }\n\n                TIFFClose(tif);\n            }\n        }\n#endif\n    }\n    else\n    {\n        path += \".png\";\n        stbi_write_png(path.c_str(), mat.w, mat.h, mat.c, mat.data, mat.w * mat.c);\n    }\n    return true;\n}",
    "void WriteTIFF(const char *name, float *rgba, int XRes, int YRes, bool hasAlpha) \n{\n    // Open 8-bit TIFF file for writing\n    TIFF *tiff = TIFFOpen(name, \"w\");\n    if (!tiff) {\n\tfprintf(stderr, \"Unable to open TIFF %s for writing\", name);\n\treturn;\n    }\n\n    int nChannels = hasAlpha ? 4 : 3;\n    TIFFSetField(tiff, TIFFTAG_SAMPLESPERPIXEL, nChannels);\n    if (hasAlpha) {\n\tshort int extra[] = { EXTRASAMPLE_ASSOCALPHA };\n\tTIFFSetField(tiff, TIFFTAG_EXTRASAMPLES, (short)1, extra);\n    }\n    // Write image resolution information\n    TIFFSetField(tiff, TIFFTAG_IMAGEWIDTH, XRes);\n    TIFFSetField(tiff, TIFFTAG_IMAGELENGTH, YRes);\n    TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 8);\n    TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n    // Set Generic TIFF Fields\n    TIFFSetField(tiff, TIFFTAG_ROWSPERSTRIP, 1);\n    TIFFSetField(tiff, TIFFTAG_XRESOLUTION, 1.f);\n    TIFFSetField(tiff, TIFFTAG_YRESOLUTION, 1.f);\n    TIFFSetField(tiff, TIFFTAG_RESOLUTIONUNIT, (short)1);\n    TIFFSetField(tiff, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n    TIFFSetField(tiff, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    TIFFSetField(tiff, TIFFTAG_ORIENTATION, (int)ORIENTATION_TOPLEFT);\n    // Write 8-bit scanlines\n    unsigned char *buf = new unsigned char[nChannels * XRes];\n    for (int y = 0; y < YRes; ++y) {\n\tunsigned char *bufp = buf;\n\tfor (int x = 0; x < XRes; ++x) {\n\t    // Pack 8-bit pixels samples into buf\n\t    for (int s = 0; s < nChannels; ++s)\n\t\t*bufp++ = (unsigned char)*rgba++;\n\t}\n\tTIFFWriteScanline(tiff, buf, y, 1);\n    }\n    // Close 8-bit TIFF file\n    delete[] buf;\n    TIFFClose(tiff);\n}",
    "static bool ReadTIFF(const char *name, float *&rgba, int &xRes, int &yRes,\n\t\t     bool &hasAlpha)\n{\n    // Try to open TIFF file\n    TIFF *tiff = TIFFOpen(name, \"r\");\n    if (!tiff) {\n\tfprintf(stderr, \"Unable to open TIFF %s\", name);\n\treturn false;\n    }\n    // Get basic information from TIFF header\n    short int nSamples;\n    int xSize, ySize;\n    TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, &xSize);\n    TIFFGetField(tiff, TIFFTAG_IMAGELENGTH, &ySize);\n    TIFFGetField(tiff, TIFFTAG_SAMPLESPERPIXEL, &nSamples);\n    if (nSamples != 3 && nSamples != 4) {\n\tfprintf(stderr, \"Sorry, only handle 3 and 4 sample TIFFs...\\n\");\n\treturn false;\n    }\n    hasAlpha = (nSamples == 4);\n    xRes = xSize;\n    yRes = ySize;\n\n    // Make sure this is a TIFF we can read\n    short int bitsPerSample, sampleFormat = SAMPLEFORMAT_UINT;\n    if (!TIFFGetField(tiff, TIFFTAG_BITSPERSAMPLE, &bitsPerSample)) {\n\tfprintf(stderr, \"TIFFRead: bits per sample not set in TIFF\");\n\tTIFFClose(tiff);\n\treturn false;\n    }\n\n    if (!TIFFGetField(tiff, TIFFTAG_SAMPLEFORMAT, &sampleFormat)) {\n\tif (bitsPerSample == 32)\n\t    sampleFormat = SAMPLEFORMAT_IEEEFP;\n\telse\n\t    sampleFormat = SAMPLEFORMAT_UINT;\n    }\n\t\n    if (bitsPerSample == 32) {\n\tif (sampleFormat != SAMPLEFORMAT_IEEEFP) {\n\t    fprintf(stderr, \"TIFFRead: 32 bit TIFF not stored in floating point format\");\n\t    TIFFClose(tiff);\n\t    return false;\n\t}\n    }\n    else {\n\tif (bitsPerSample != 8 && bitsPerSample != 32) {\n\t    fprintf(stderr, \"TIFFRead: only 8 and 32 bits per sample supported\");\n\t    TIFFClose(tiff);\n\t    return false;\n\t}\n\tif (sampleFormat != SAMPLEFORMAT_UINT) {\n\t    fprintf(stderr, \"TIFFRead: 8 bit TIFFs must be stored as unsigned ints\");\n\t    TIFFClose(tiff);\n\t    return false;\n\t}\n    }\n\n    int bytesPerSample = bitsPerSample / 8;\n    if (nSamples * xRes * bytesPerSample != TIFFScanlineSize(tiff)) {\n\tfprintf(stderr, \"TIFFRead: RGB not interleaved in TIFF %s\", name);\n\tTIFFClose(tiff);\n\treturn false;\n    }\n\n    // Allocate space for [[pixels]] and buffers\n    rgba = new float[nSamples * xRes * yRes];\n    float *p = rgba;\n    unsigned char *ubuf = NULL;\n    if (bitsPerSample == 8) ubuf = new unsigned char[nSamples * xRes];\n\n    for (int y = 0; y < yRes; ++y) {\n\tif (ubuf) {\n\t    // Read 8-bit TIFF scanline\n\t    if (TIFFReadScanline(tiff, ubuf, y, 1) == -1) {\n\t\tTIFFClose(tiff);\n\t\treturn false;\n\t    }\n\t    for (int x = 0; x < nSamples*xRes; ++x)\n\t\t*p++ = ubuf[x] * INV_255;\n\t}\n\telse {\n\t    // Read floating point TIFF scanline\n\t    if (TIFFReadScanline(tiff, p, y, 1) == -1) {\n\t\tTIFFClose(tiff);\n\t\treturn false;\n\t    }\n\t    p += nSamples * xRes;\n\t}\n    }\n\n    delete[] ubuf;\n    TIFFClose(tiff);\n    return rgba;\n}",
    "void SAVE_TIFF_libtiff(const std::string& filename, const TDATA* data, size_t width, size_t height, bool little_endian=true) {\r\n#ifdef TINYTIFF_TEST_LIBTIFF\r\n    TIFF* tifvideo;\r\n    if (little_endian) {\r\n        tifvideo=TIFFOpen(filename.c_str(), \"wl\");\r\n    } else {\r\n        tifvideo=TIFFOpen(filename.c_str(), \"wb\");\r\n    }\r\n    if (tifvideo) {\r\n        TIFFWrite<TDATA>(tifvideo, data, width, height);\r\n        TIFFWriteDirectory(tifvideo);\r\n        TIFFClose(tifvideo);\r\n    }\r\n#endif\r\n}",
    "bool libtiffTestRead(const char* filename, const T* writteneven, const T* writtenodd, uint32_t width, uint32_t height, uint16_t samples=1, uint32_t frames_expected=0, TinyTIFFSampleLayout inputOrg=TinyTIFF_Chunky, std::string* description_out=nullptr)  {\r\n    bool ok=true;\r\n#ifdef TINYTIFF_TEST_LIBTIFF\r\n    TIFF* tif = TIFFOpen(filename, \"r\");\r\n    T* data=(T*)malloc(width*height*sizeof(T));\r\n    if (tif) {\r\n        uint32_t frame=0;\r\n        do {\r\n            uint32_t nx,ny;\r\n            uint16_t ns,bs;\r\n            TIFFGetField(tif,TIFFTAG_IMAGEWIDTH,&nx);\r\n            TIFFGetField(tif,TIFFTAG_IMAGELENGTH,&ny);\r\n            TIFFGetField(tif,TIFFTAG_SAMPLESPERPIXEL,&ns);\r\n            TIFFGetField(tif,TIFFTAG_BITSPERSAMPLE,&bs);\r\n            char* val=NULL;\r\n            TIFFGetField(tif,TIFFTAG_IMAGEDESCRIPTION,&val);\r\n            if (val) {\r\n                std::cout<<\"    ImageDescription(\"<<strlen(val)<<\"):\\n\"<<val<<\"\\n\";\r\n                if (description_out) *description_out=val;\r\n            } else {\r\n                if (description_out) description_out->clear();\r\n            }\r\n            TIFFPrintDirectory(tif, stdout);\r\n            if (nx==width && ny==height && ns==samples && bs==sizeof(T)*8) {\r\n                size_t errcnt=0;\r\n                size_t pixcnt=0;\r\n                for (uint16_t samp=0; samp<samples; samp++) {\r\n                    if (TIFFReadFrame(tif, data, samp)) {\r\n                        ok=true;\r\n                        const T* written=writteneven;\r\n                        if (writtenodd && frame%2==1) written=writtenodd;\r\n                        if (inputOrg==TinyTIFF_Chunky) {\r\n                            for (uint32_t i=0; i<width*height; i++) {\r\n                                if (data[i]!=written[i*samples+samp]) {\r\n                                    ok=false;\r\n                                    errcnt++;\r\n                                    if (errcnt<50) std::cout<<\" -- READ-ERROR: pixel-value differs in frame \"<<frame<<\" for pixel (\"<<i%width<<\",\"<<i/width<<\"): file: \"<<static_cast<typename atleast_int<T>::TPrint>(data[i])<<\" expected: \"<<static_cast<typename atleast_int<T>::TPrint>(written[i*samples+samp])<<\"\\n\";\r\n                                    if (errcnt==50) std::cout<<\" -- READ-ERROR: ...\\n\";\r\n                                } else {\r\n                                    pixcnt++;\r\n                                }\r\n                            }\r\n                        } else {\r\n                            for (uint32_t i=0; i<width*height; i++) {\r\n                                if (data[i]!=written[i+samp*width*height]) {\r\n                                    ok=false;\r\n                                    errcnt++;\r\n                                    if (errcnt<50) std::cout<<\" -- READ-ERROR: pixel-value differs in frame \"<<frame<<\" for pixel (\"<<i%width<<\",\"<<i/width<<\"): file: \"<<static_cast<typename atleast_int<T>::TPrint>(data[i])<<\" expected: \"<<static_cast<typename atleast_int<T>::TPrint>(written[i+samp*width*height])<<\"\\n\";\r\n                                    if (errcnt==50) std::cout<<\" -- READ-ERROR: ...\\n\";\r\n                                } else {\r\n                                    pixcnt++;\r\n                                }\r\n                            }\r\n                        }\r\n                        if (!ok) {\r\n                            std::cout<<\" -- TEST READ WITH LIBTIFF: READ WRONG DATA for \"<<errcnt<<\" pixels in frame \"<<frame<<\"!!!\\n\";\r\n                        }\r\n                    } else {\r\n                        std::cout<<\" -- TEST READ WITH LIBTIFF: COULD NOT READ FRAME \"<<frame<<\"!\\n\";\r\n                        ok=false;\r\n                    }\r\n                }\r\n                if (ok) {\r\n                    std::cout<<\" -- TEST READ WITH LIBTIFF: SUCCESS FOR FRAME \"<<frame<<\"! All \"<<pixcnt<<\" pixels&samples as expected!\\n\";\r\n                }\r\n            } else {\r\n                std::cout<<\" -- TEST READ WITH LIBTIFF: FRAME SIZE OF FRAME \"<<frame<<\" DOES NOT MATCH (width: file:\"<<nx<<\"/expected:\"<<width<<\",   height: file:\"<<ny<<\"/expected:\"<<height<<\",   samples: file:\"<<ns<<\"/expected:\"<<samples<<\",   bitspersample: file:\"<<bs<<\"/expected:\"<<(sizeof(T)*8)<<\")!\\n\";\r\n                ok=false;\r\n            }\r\n            frame++;\r\n        } while (ok && TIFFReadDirectory(tif));\r\n        if (frames_expected>0 && frames_expected!=frame) {\r\n            std::cout<<\" -- ERROR IN TEST READ WITH LIBTIFF: number of frames (\"<<frame<<\")does not match expected number of frames (\"<<frames_expected<<\")\\n\";\r\n            ok=false;\r\n        }\r\n        TIFFClose(tif);\r\n    } else {\r\n        std::cout<<\" -- TEST READ WITH LIBTIFF: COULD NOT OPEN FILE!\\n\";\r\n        ok=false;\r\n    }\r\n    free(data);\r\n#endif\r\n    return ok;\r\n}",
    "void performLibTIFFWriteTest(const std::string& name, const char* filename, const T* imagedata, size_t WIDTH, size_t HEIGHT, size_t SAMPLES, size_t FRAMES, std::vector<TestResult>& test_results, const float SPEEDTEST_REMOVESLOWEST_PERCENT = 0.1) {\n#ifdef TINYTIFF_TEST_LIBTIFF\n    const size_t bits=sizeof(T)*8;\n    std::string desc=std::to_string(WIDTH)+\"x\"+std::to_string(HEIGHT)+\"pix/\"+std::to_string(bits)+\"bit/\"+std::to_string(SAMPLES)+\"ch/\"+std::to_string(FRAMES)+\"frames\";\n    test_results.emplace_back();\n    test_results.back().name=name+\" [\"+desc+\", \"+std::string(filename)+\"]\";\n    test_results.back().success=true;\n    std::cout<<\"\\n\\n*****************************************************************************\\n\";\n    std::cout<<\"* \"<<test_results.back().name<<\"\\n\";\n    HighResTimer timer, timer1;\n    timer.start();\n    TIFF* tifvideo=TIFFOpen(filename, \"w\");\n    if (tifvideo) {\n        std::vector<double> runtimes;\n        runtimes.reserve(FRAMES);\n        for (size_t f=0; f<FRAMES; f++) {\n            timer1.start();\n            TIFFWrite<T>(tifvideo, imagedata, WIDTH, HEIGHT);\n            TIFFWriteDirectory(tifvideo);\n            runtimes.push_back(timer1.get_time());\n        }\n        TIFFClose(tifvideo);\n        test_results.back().duration_ms=timer.get_time()/1e3;\n        test_results.back().success=true;\n        test_results.back().numImages=FRAMES;\n        reportRuntimes(name, runtimes, SPEEDTEST_REMOVESLOWEST_PERCENT, &test_results);\n    } else {\n        std::cout<<\"ERROR: could not open '\"<<filename<<\"' for writing!\\n\";\n        test_results.back().success=false;\n    }\n    if (test_results.back().success) {\n        std::cout<<\"* ==> SUCCESSFUL,   duration=\"<<test_results.back().duration_ms<<\"ms\\n\";\n    } else {\n        std::cout<<\"* ==> FAILED\\n\";\n    }\n#endif\n}",
    "__declspec(dllexport) void ReadEERCombinedFrame(const char* path, int firstFrameInclusive, int lastFrameExclusive, int eer_upsampling, float* h_result)\n{\n\tif (eer_upsampling < 1 || eer_upsampling > 3)\n\t\tthrow(\"EERRenderer::read: eer_upsampling must be 1, 2 or 3.\");\n\t\n\t// First of all, check the file size\n\tFILE* fh = fopen(path, \"r\");\n\tif (fh == NULL)\n\t\tthrow std::runtime_error(\"Failed to open file\");\n\n\tfseek(fh, 0, SEEK_END);\n\tlong long file_size = ftell(fh);\n\tfseek(fh, 0, SEEK_SET);\n\tfclose(fh);\n\n\tint nframes = 0;\n\tbool is_7bit = false;\n\t\n\t// Try reading as TIFF; this handle is kept open\n\tTIFF* ftiff = TIFFOpen(path, \"r\");\n\n\tif (ftiff == NULL)\n\t{\n\t\tthrow std::runtime_error(\"Legacy mode not implemented\");\n\t}\n\telse\n\t{\n\t\t// Check width & size\n\t\tint width, height;\n\t\tuint16_t compression = 0;\n\t\tTIFFGetField(ftiff, TIFFTAG_IMAGEWIDTH, &width);\n\t\tTIFFGetField(ftiff, TIFFTAG_IMAGELENGTH, &height);\n\t\tTIFFGetField(ftiff, TIFFTAG_COMPRESSION, &compression);\n\n\t\t// TIA can write an EER file whose first page is a sum and compressoin == 1.\n\t\t// This is not supported (yet). EPU never writes such movies.\n\t\tif (compression == TIFF_COMPRESSION_EER8bit)\n\t\t\tis_7bit = false;\n\t\telse if (compression == TIFF_COMPRESSION_EER7bit)\n\t\t\tis_7bit = true;\n\t\telse\n\t\t\tthrow std::runtime_error(\"Unknown compression scheme for EER\");\n\n\t\tif (width != EER_IMAGE_WIDTH || height != EER_IMAGE_HEIGHT)\n\t\t\tthrow std::runtime_error(\"Currently we support only 4096x4096 pixel EER movies.\");\n\n\t\t// Find the number of frames\n\t\tnframes = TIFFNumberOfDirectories(ftiff);\n\t}\n\t\n\tstd::vector<long long> frame_starts, frame_sizes;\n\tunsigned char* buf;\n\n\t{\n\t\tframe_starts.resize(nframes, 0);\n\t\tframe_sizes.resize(nframes, 0);\n\t\tbuf = (unsigned char*)malloc(file_size); // This is big enough\n\t\tif (buf == NULL)\n\t\t\tthrow std::runtime_error(\"Failed to allocate buffer\");\n\t\tlong long pos = 0;\n\n\t\t// Read everything\n\t\tfor (int frame = firstFrameInclusive; frame < lastFrameExclusive; frame++)\n\t\t{\n\t\t\tTIFFSetDirectory(ftiff, frame);\n\t\t\tconst int nstrips = TIFFNumberOfStrips(ftiff);\n\t\t\tframe_starts[frame] = pos;\n\n\t\t\tfor (int strip = 0; strip < nstrips; strip++)\n\t\t\t{\n\t\t\t\tconst int strip_size = TIFFRawStripSize(ftiff, strip);\n\t\t\t\tif (pos + strip_size >= file_size)\n\t\t\t\t\tthrow std::runtime_error(\"EER: buffer overflow when reading raw strips.\");\n\n\t\t\t\tTIFFReadRawStrip(ftiff, strip, buf + pos, strip_size);\n\t\t\t\tpos += strip_size;\n\t\t\t\tframe_sizes[frame] += strip_size;\n\t\t\t}\n\t\t}\n\n\t\tTIFFClose(ftiff);\n\t}\n\n\t{\n\t\tlong long total_n_electron = 0;\n\n\t\tlong long supersize = 4096 << (eer_upsampling - 1);\n\n\t\tstd::vector<unsigned int> positions;\n\t\tstd::vector<unsigned char> symbols;\n\t\tmemset(h_result, 0, supersize * supersize * sizeof(float));\n\n\t\tfor (int iframe = firstFrameInclusive; iframe < lastFrameExclusive; iframe++)\n\t\t{\n\t\t\tlong long pos = frame_starts[iframe];\n\t\t\tunsigned int n_pix = 0, n_electron = 0;\n\t\t\tconst int max_electrons = frame_sizes[iframe] * 2; // at 4 bits per electron (very permissive bound!)\n\t\t\tif (positions.size() < max_electrons)\n\t\t\t{\n\t\t\t\tpositions.resize(max_electrons);\n\t\t\t\tsymbols.resize(max_electrons);\n\t\t\t}\n\n\t\t\tif (is_7bit)\n\t\t\t{\n\t\t\t\tunsigned int bit_pos = 0; // 4 K * 4 K * 11 bit << 2 ** 32\n\t\t\t\tunsigned char p, s;\n\n\t\t\t\twhile (true)\n\t\t\t\t{\n\t\t\t\t\t// Fetch 32 bits and unpack up to 2 chunks of 7 + 4 bits.\n\t\t\t\t\t// This is faster than unpack 7 and 4 bits sequentially.\n\t\t\t\t\t// Since the size of buf is larger than the actual size by the TIFF header size,\n\t\t\t\t\t// it is always safe to read ahead.\n\n\t\t\t\t\tlong long first_byte = pos + (bit_pos >> 3);\n\t\t\t\t\tconst unsigned int bit_offset_in_first_byte = bit_pos & 7; // 7 = 00000111 (same as % 8)\n\t\t\t\t\tconst unsigned int chunk = (*(unsigned int*)(buf + first_byte)) >> bit_offset_in_first_byte;\n\n\t\t\t\t\tp = (unsigned char)(chunk & 127); // 127 = 01111111\n\t\t\t\t\tbit_pos += 7; // TODO: we can remove this for further speed.\n\t\t\t\t\tn_pix += p;\n\t\t\t\t\tif (n_pix == EER_IMAGE_PIXELS) break;\n\t\t\t\t\tif (p == 127) continue; // this should be rare.\n\n\t\t\t\t\ts = (unsigned char)((chunk >> 7) & 15) ^ 0x0A; // 15 = 00001111; See below for 0x0A\n\t\t\t\t\tbit_pos += 4;\n\t\t\t\t\tpositions[n_electron] = n_pix;\n\t\t\t\t\tsymbols[n_electron] = s;\n\t\t\t\t\tn_electron++;\n\t\t\t\t\tn_pix++;\n\n\t\t\t\t\tp = (unsigned char)((chunk >> 11) & 127); // 127 = 01111111\n\t\t\t\t\tbit_pos += 7;\n\t\t\t\t\tn_pix += p;\n\t\t\t\t\tif (n_pix == EER_IMAGE_PIXELS) break;\n\t\t\t\t\tif (p == 127) continue;\n\n\t\t\t\t\ts = (unsigned char)((chunk >> 18) & 15) ^ 0x0A; // 15 = 00001111; See below for 0x0A\n\t\t\t\t\tbit_pos += 4;\n\t\t\t\t\tpositions[n_electron] = n_pix;\n\t\t\t\t\tsymbols[n_electron] = s;\n\t\t\t\t\tn_electron++;\n\t\t\t\t\tn_pix++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// unpack every two symbols = 12 bit * 2 = 24 bit = 3 byte\n\t\t\t\t// high <- |bbbbBBBB|BBBBaaaa|AAAAAAAA| -> low\n\t\t\t\t// With SIMD intrinsics at the SSSE3 level, we can unpack 10 symbols (120 bits) simultaneously.\n\t\t\t\tunsigned char p1, p2, s1, s2;\n\n\t\t\t\tconst long long pos_limit = frame_starts[iframe] + frame_sizes[iframe];\n\t\t\t\t// Because there is a footer, it is safe to go beyond the limit by two bytes.\n\t\t\t\twhile (pos < pos_limit)\n\t\t\t\t{\n\t\t\t\t\t// symbol is bit tricky. 0000YyXx; Y and X must be flipped.\n\t\t\t\t\tp1 = buf[pos];\n\t\t\t\t\ts1 = (buf[pos + 1] & 0x0F) ^ 0x0A; // 0x0F = 00001111, 0x0A = 00001010\n\n\t\t\t\t\tp2 = (buf[pos + 1] >> 4) | (buf[pos + 2] << 4);\n\t\t\t\t\ts2 = (buf[pos + 2] >> 4) ^ 0x0A;\n\n\t\t\t\t\t// Note the order. Add p before checking the size and placing a new electron.\n\t\t\t\t\tn_pix += p1;\n\t\t\t\t\tif (n_pix == EER_IMAGE_PIXELS) break;\n\t\t\t\t\tif (p1 < 255)\n\t\t\t\t\t{\n\t\t\t\t\t\tpositions[n_electron] = n_pix;\n\t\t\t\t\t\tsymbols[n_electron] = s1;\n\t\t\t\t\t\tn_electron++;\n\t\t\t\t\t\tn_pix++;\n\t\t\t\t\t}\n\n\t\t\t\t\tn_pix += p2;\n\t\t\t\t\tif (n_pix == EER_IMAGE_PIXELS) break;\n\t\t\t\t\tif (p2 < 255)\n\t\t\t\t\t{\n\t\t\t\t\t\tpositions[n_electron] = n_pix;\n\t\t\t\t\t\tsymbols[n_electron] = s2;\n\t\t\t\t\t\tn_electron++;\n\t\t\t\t\t\tn_pix++;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tpos += 3;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (n_pix != EER_IMAGE_PIXELS)\n\t\t\t\tthrow std::runtime_error(\"Number of pixels is not right.\");\n\n\t\t\tif (eer_upsampling == 3)\n\t\t\t\trender16K(h_result, positions, symbols, n_electron);\n\t\t\telse if (eer_upsampling == 2)\n\t\t\t\trender8K(h_result, positions, symbols, n_electron);\n\t\t\telse if (eer_upsampling == 1)\n\t\t\t\trender4K(h_result, positions, symbols, n_electron);\n\t\t\telse\n\t\t\t\tthrow std::runtime_error(\"Invalid EER upsamle\");\n\n\t\t\ttotal_n_electron += n_electron;\n\t\t}\n\n\t\tfree(buf);\n\t}\n}",
    "__declspec(dllexport) void ReadTIFF(const char* path, int layer, bool flipy, float* h_result)\n{\n\tTIFF* ftiff = TIFFOpen(path, \"r\");\n\t\n\t// libtiff's types\n\tuint32 width, length;\n\n\tif (TIFFGetField(ftiff, TIFFTAG_IMAGEWIDTH, &width) != 1 ||\n\t\tTIFFGetField(ftiff, TIFFTAG_IMAGELENGTH, &length) != 1)\n\t{\n\t\tthrow std::runtime_error(\"The input TIFF file does not have the width or height field.\");\n\t}\n\n\tint3 dims = make_int3(width, length, TIFFNumberOfDirectories(ftiff));\n\n\tif (layer >= dims.z)\n\t\tthrow std::runtime_error(\"Requested layer exceeds the stack size.\");\n\n\tif (layer >= 0)\n\t\tdims.z = 1;\n\n\tuint16 sampleFormat, bitsPerSample;\n\tTIFFGetFieldDefaulted(ftiff, TIFFTAG_BITSPERSAMPLE, &bitsPerSample);\n\tTIFFGetFieldDefaulted(ftiff, TIFFTAG_SAMPLEFORMAT, &sampleFormat);\n\n\tTIFFSetDirectory(ftiff, 0);\n\t\n\trelion::DataType datatype;\n\n\tif (bitsPerSample == 8 && sampleFormat == 1) {\n\t\tdatatype = relion::UChar;\n\t}\n\telse if (bitsPerSample == 16 && sampleFormat == 1) {\n\t\tdatatype = relion::UShort;\n\t}\n\telse if (bitsPerSample == 16 && sampleFormat == 2) {\n\t\tdatatype = relion::Short;\n\t}\n\telse if (bitsPerSample == 32 && sampleFormat == 3) {\n\t\tdatatype = relion::Float;\n\t}\n\telse {\n\t\tthrow std::runtime_error(\"Unsupported TIFF format\");\n\t}\n\n\tfloat* h_tempstrip = (float*)malloc(dims.x * sizeof(float));\n\n\t//dims.z = 20;\n\n\tfor (int z = 0; z < dims.z; z++) \n\t{\n\t\tTIFFSetDirectory(ftiff, layer < 0 ? z : layer);\n\n\t\tfloat* h_resultlayer = h_result + Elements2(dims) * z;\n\t\t\n\t\ttsize_t stripSize = TIFFStripSize(ftiff);\n\t\ttstrip_t numberOfStrips = TIFFNumberOfStrips(ftiff);\n\t\ttdata_t buf = _TIFFmalloc(stripSize);\n\t\n\t\tsize_t haveread_n = 0;\n\n\t\tfor (tstrip_t strip = 0; strip < numberOfStrips; strip++) \n\t\t{\n\t\t\ttsize_t actually_read = TIFFReadEncodedStrip(ftiff, strip, buf, stripSize);\n\t\t\ttsize_t actually_read_n = actually_read * 8 / bitsPerSample;\n\n\t\t\ttsize_t actually_read_n_8 = actually_read_n / 8 * 8;\n\n\t\t\tif (datatype == relion::UChar)\n\t\t\t{\n\t\t\t\tfor (tsize_t i = 0; i < actually_read_n_8; i += 8)\n\t\t\t\t{\n\t\t\t\t\th_resultlayer[haveread_n + i] = (float)((uchar*)buf)[i];\n\t\t\t\t\th_resultlayer[haveread_n + i + 1] = (float)((uchar*)buf)[i + 1];\n\t\t\t\t\th_resultlayer[haveread_n + i + 2] = (float)((uchar*)buf)[i + 2];\n\t\t\t\t\th_resultlayer[haveread_n + i + 3] = (float)((uchar*)buf)[i + 3];\n\t\t\t\t\th_resultlayer[haveread_n + i + 4] = (float)((uchar*)buf)[i + 4];\n\t\t\t\t\th_resultlayer[haveread_n + i + 5] = (float)((uchar*)buf)[i + 5];\n\t\t\t\t\th_resultlayer[haveread_n + i + 6] = (float)((uchar*)buf)[i + 6];\n\t\t\t\t\th_resultlayer[haveread_n + i + 7] = (float)((uchar*)buf)[i + 7];\n\t\t\t\t}\n\t\t\t\tfor (tsize_t i = actually_read_n_8; i < actually_read_n; i++)\n\t\t\t\t\th_resultlayer[haveread_n + i] = (float)((uchar*)buf)[i];\n\t\t\t}\n\t\t\telse if (datatype == relion::UShort)\n\t\t\t\tfor (tsize_t i = 0; i < actually_read_n; i++)\n\t\t\t\t\th_resultlayer[haveread_n + i] = (float)((ushort*)buf)[i];\n\t\t\telse if (datatype == relion::Short)\n\t\t\t\tfor (tsize_t i = 0; i < actually_read_n; i++)\n\t\t\t\t\th_resultlayer[haveread_n + i] = (float)((short*)buf)[i];\n\t\t\telse if (datatype == relion::Float)\n\t\t\t\tmemcpy(h_resultlayer + haveread_n, buf, actually_read);\n\t\t\t\n\t\t\thaveread_n += actually_read_n;\n\t\t}\n\n\t\t_TIFFfree(buf);\n\n\t\t// Flip the Y axis if requested\n\n\t\tif (flipy)\n\t\t{\n\t\t\tfor (tsize_t y1 = 0; y1 < dims.y / 2; y1++)\n\t\t\t{\n\t\t\t\ttsize_t y2 = dims.y - 1 - y1;\n\n\t\t\t\tmemcpy(h_tempstrip, h_resultlayer + y1 * dims.x, dims.x * sizeof(float));\n\n\t\t\t\tmemcpy(h_resultlayer + y1 * dims.x, h_resultlayer + y2 * dims.x, dims.x * sizeof(float));\n\n\t\t\t\tmemcpy(h_resultlayer + y2 * dims.x, h_tempstrip, dims.x * sizeof(float));\n\t\t\t}\n\t\t}\n\t}\n\n\tfree(h_tempstrip);\n\n\tTIFFClose(ftiff);\n}",
    "bool Import_3DTiff_Workspace::sizeOfDomain() {\n    uint32 bitsPerSample = 0;\n    uint16 rgb_check;\n\n    TIFF* input_Image;\n    TIFFSetWarningHandler(nullptr);\n    if((input_Image = TIFFOpen(fileName.c_str(), \"r\")) == nullptr){\n        X=-1;\n        return false;\n    }\n\n\n    if(input_Image) {\n        TIFFGetField(input_Image, TIFFTAG_IMAGEWIDTH, &X);\n        TIFFGetField(input_Image, TIFFTAG_IMAGELENGTH, &Y);\n        TIFFGetField(input_Image, TIFFTAG_BITSPERSAMPLE, &bitsPerSample);\n        TIFFGetField(input_Image, TIFFTAG_SAMPLESPERPIXEL, &rgb_check);\n    }\n\n    if(rgb_check == 3){\n        std::cout << \"Image must be grayscale, input is RGB.\" << std::endl;\n        X=-1;\n        return false;\n    }\n\n    if(bitsPerSample!=8){\n        if(bitsPerSample == 16 || bitsPerSample == 32){\n            std::cout << \"Image must be 8-bit\" << std::endl;\n            X=-1;\n            return false;\n        }\n        else {\n            bitsPerSample = 8;\n        }\n    }\n\n    int page=0;\n    while(true){\n        TIFFSetDirectory(input_Image, page);\n        page++;\n        if(!TIFFReadDirectory(input_Image)) {\n            break;\n        }\n    }\n    Z=page;\n\n    xMin = 0;\n    yMin = 0;\n    zMin = 0;\n    xMax = X-1;\n    yMax = Y-1;\n    zMax = Z-1;\n\n    TIFFClose(input_Image);\n\n    return true;\n}",
    "bool Import_3DTiff_Workspace::importHelper() {\n\n    long localX = xMax - xMin + 1;\n    long localY = yMax - yMin + 1;\n    long localZ = zMax - zMin + 1;\n\n    work->matrix.resize(localX, localY, localZ);\n\n        omp_set_num_threads(numThreads);\n#pragma omp parallel for\n        for (int page = (int) zMin; page <= (int) zMax; page++) {\n            TIFF *temp_Image = TIFFOpen(fileName.c_str(), \"r\");\n            TIFFSetDirectory(temp_Image, page);\n\n            std::vector<uint8_t> svec(X);\n            for (int row = yMin; row <= yMax; row++) {\n                TIFFReadScanline(temp_Image, &svec[0], row, 0);\n                for (int i = xMin; i <= xMax; i++) {\n                    work->matrix(i - xMin, row - yMin, page - zMin) = svec[i];\n                }\n            }\n            TIFFClose(temp_Image);\n        }\n\n    return true;\n}",
    "int R2Image::\nReadTIFF(const char *filename)\n{\n#ifdef RN_USE_TIFF\n  // Open file\n  TIFF* tif = TIFFOpen(filename, \"r\");\n  if (!tif) {\n    fprintf(stderr, \"Unable to open TIFF file %s\\n\", filename);\n    return 0;\n  }\n\n  // Get image dimensions\n  uint32 w, h;\n  TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w);\n  TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\n  size_t npixels = w * h;\n\n  // Allocate buffer for data\n  uint32* raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n  if (!raster) {\n    fprintf(stderr, \"Unable to allocate data for TIFF file %s\\n\", filename);\n    return 0;\n  }\n\n  // Read data into buffer\n  if (!TIFFReadRGBAImage(tif, w, h, raster, 0)) {\n    fprintf(stderr, \"Unable to read TIFF file %s\\n\", filename);\n    return 0;\n  }\n\n  // Initialize R2Image data\n  width = w;\n  height = h;\n  ncomponents = 3;\n  rowsize = ncomponents * width;\n  if ((rowsize % 4) != 0) rowsize = (rowsize / 4 + 1) * 4;\n  int nbytes = rowsize * height;\n  pixels = new unsigned char [nbytes];\n  if (!pixels) {\n    fprintf(stderr, \"Unable to allocate memory for TIFF file %s\", filename);\n    return 0;\n  }\n\n  // Fill R2Image pixel data \n  uint32 *rasterp = raster;\n  for (int j = 0; j < height; j++) {\n    unsigned char *p = &pixels[j*rowsize];\n    for (int i = 0; i < width; i++) {\n      uint32 pixel = *(rasterp++);\n      *(p++) = pixel & 0xFF;\n      *(p++) = (pixel >> 8) & 0xFF;\n      *(p++) = (pixel >> 16) & 0xFF;\n    }\n  }\n\n  // Free data\n  _TIFFfree(raster);\n\n  // Close file\n  TIFFClose(tif);\n\n  // Return success\n  return 1;\n#else\n  RNFail(\"TIFF not supported\");\n  return 0;\n#endif\n}",
    "int R2Image::\nWriteTIFF(const char *filename) const\n{\n#ifdef RN_USE_TIFF\n  // Open TIFF file\n  TIFF *out = TIFFOpen(filename, \"w\");\n  if (!out) {\n    fprintf(stderr, \"Unable to open TIFF file %s\\n\", filename);\n    return 0;\n  }\n\n  // Set TIFF parameters\n  TIFFSetField(out, TIFFTAG_IMAGEWIDTH, width);\n  TIFFSetField(out, TIFFTAG_IMAGELENGTH, height);\n  TIFFSetField(out, TIFFTAG_ORIENTATION, ORIENTATION_BOTLEFT);\n  TIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, 3);\n  TIFFSetField(out, TIFFTAG_BITSPERSAMPLE, 8);\n  TIFFSetField(out, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n  TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n  TIFFSetField(out, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n  TIFFSetField(out, TIFFTAG_ROWSPERSTRIP, 1);\n\n  // Allocate data for scan lines\n  int scanline_size = TIFFScanlineSize(out);\n  unsigned char *buf = (unsigned char *)_TIFFmalloc(scanline_size);\n  if (!buf) {\n    fprintf(stderr, \"Unable to allocate memory for TIFF scan lines\\n\");\n    return 0;\n  }\n\n  // Write scan lines to TIFF file\n  for (int row = 0; row < height; row++) {\n    const unsigned char *p = Pixels(row);\n    if (TIFFWriteScanline(out, (tdata_t) p, height - row - 1, 0) < 0) {\n      fprintf(stderr, \"Unable to write scanline to TIFF image %s\\n\", filename);\n      return 0;\n    }\n  }\n\n  // Free data for scan lines\n  _TIFFfree(buf);\n\n  // Close TIFF file\n  TIFFClose(out);\n\n  // Return success\n  return 1;\n#else\n  RNFail(\"TIFF not supported\");\n  return 0;\n#endif\n}",
    "static Status libtiff_process(TiffDecHandle handle, const TiffDecInput* in, TiffDecOutput* out) {\n    tiff_dec_libtiff_t* state = (tiff_dec_libtiff_t*)handle;\n\n    state->data->msg.clear();\n\n    TiffStream stream;\n    stream.data = (char*)in->buffer;\n    stream.pos = 0;\n    stream.size = in->size;\n\n    TIFF* inTiff = TIFFClientOpen(\"Memory\", \"r\", (thandle_t)&stream, tiff_Read, tiff_Write, tiff_Seek, tiff_Close,\n                                  tiff_Size, tiff_Map, tiff_Unmap);\n\n    uint32 width = 0;\n    uint32 height = 0;\n    uint16 bitsPerSample = 0;\n    uint16 nsamples = 0;\n    uint16 photometric = 0;\n    uint16 subsampling[2] = {0, 0};\n\n    TIFFGetField(inTiff, TIFFTAG_IMAGEWIDTH, &width);\n    TIFFGetField(inTiff, TIFFTAG_IMAGELENGTH, &height);\n    TIFFGetField(inTiff, TIFFTAG_BITSPERSAMPLE, &bitsPerSample);\n    TIFFGetField(inTiff, TIFFTAG_SAMPLESPERPIXEL, &nsamples);\n    TIFFGetField(inTiff, TIFFTAG_PHOTOMETRIC, &photometric);\n\n    if (bitsPerSample != 16) {\n        state->data->msg = \"Unsupported bit-depth: \" + std::to_string(bitsPerSample);\n        TIFFClose(inTiff);\n        return STATUS_ERROR;\n    }\n\n    TiffFormat format;\n    if (PHOTOMETRIC_RGB == photometric) {\n        format = TIFF_FORMAT_RGB48LE;\n    }\n    else if (PHOTOMETRIC_YCBCR == photometric) {\n        TIFFGetField(inTiff, TIFFTAG_YCBCRSUBSAMPLING, &subsampling[0], &subsampling[1]);\n        if (1 == subsampling[0] && 1 == subsampling[1]) {\n            format = TIFF_FORMAT_YUV444P16LE;\n        }\n        else {\n            state->data->msg =\n                \"Unsupported subsampling: \" + std::to_string(subsampling[0]) + \",\" + std::to_string(subsampling[1]);\n            TIFFClose(inTiff);\n            return STATUS_ERROR;\n        }\n    }\n    else {\n        state->data->msg = \"Unsupported photometric interpretation: \" + std::to_string(photometric);\n        TIFFClose(inTiff);\n        return STATUS_ERROR;\n    }\n    const int maxPlaneNum = 4;\n    uint64_t buffer_size = width * height * maxPlaneNum;\n    if (!state->data->outputBuffer)\n        state->data->outputBuffer = new uint16_t[buffer_size];\n    if (!state->data->lineBuffer)\n        state->data->lineBuffer = new uint16_t[buffer_size];\n\n    uint64_t pixNum = width * height;\n    memset(state->data->outputBuffer, 0, buffer_size);\n    uint16* plane[maxPlaneNum];\n    for (int i = 0; i < maxPlaneNum; i++) {\n        plane[i] = &state->data->outputBuffer[i * pixNum];\n    }\n\n    out->buffer[0] = (void*)plane[0];\n    out->buffer[1] = (void*)plane[1];\n    out->buffer[2] = (void*)plane[2];\n\n    uint16_t* line = state->data->lineBuffer;\n    for (uint32 row = 0; row < height; row++) {\n        if (!TIFFReadScanline(inTiff, line, row)) {\n            state->data->msg = \"TIFFReadScanline failed\";\n            TIFFClose(inTiff);\n            return STATUS_ERROR;\n        }\n\n        for (uint32 i = 0; i < width; i++) {\n            for (uint32 s = 0; s < nsamples; s++) {\n                *(plane[s]++) = line[(i*nsamples)+s];\n            }\n        }\n    }\n\n    out->width = width;\n    out->height = height;\n    out->format = format;\n\n    TIFFClose(inTiff);\n    return STATUS_OK;\n}",
    "int ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}",
    "PVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(&img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(&img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(&img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(&img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}",
    "TiffStream::~TiffStream()\n{\n    if(m_tif != NULL) TIFFClose(m_tif);\n}",
    "unsigned char *\nsimage_tiff_load(std::istream& fin,\n                 int& width_ret,\n                 int& height_ret,\n                 int& numComponents_ret,\n                 uint16& bitspersample)\n{\n    TIFF *in;\n    uint16 dataType;\n    uint16 samplesperpixel;\n    uint16 photometric;\n    uint32 w, h;\n    uint16 config;\n    uint16* red;\n    uint16* green;\n    uint16* blue;\n    unsigned char *inbuf = NULL;\n    tsize_t rowsize;\n    uint32 row;\n    int format;\n    unsigned char *buffer;\n    int width;\n    int height;\n    unsigned char *currPtr;\n\n    TIFFSetErrorHandler(tiff_error);\n    TIFFSetWarningHandler(tiff_warn);\n\n    in = TIFFClientOpen(\"inputstream\", \"r\", (thandle_t)&fin,\n            libtiffStreamReadProc, //Custom read function\n            libtiffStreamWriteProc, //Custom write function\n            libtiffStreamSeekProc, //Custom seek function\n            libtiffStreamCloseProc, //Custom close function\n            libtiffStreamSizeProc, //Custom size function\n            libtiffStreamMapProc, //Custom map function\n            libtiffStreamUnmapProc); //Custom unmap function\n\n    if (in == NULL)\n    {\n        tifferror = ERR_OPEN;\n        return NULL;\n    }\n    if (TIFFGetField(in, TIFFTAG_PHOTOMETRIC, &photometric) == 1)\n    {\n        if (photometric != PHOTOMETRIC_RGB && photometric != PHOTOMETRIC_PALETTE &&\n            photometric != PHOTOMETRIC_MINISWHITE &&\n            photometric != PHOTOMETRIC_MINISBLACK)\n        {\n            OSG_NOTICE << \"Photometric type \"<<photometric<<\" not handled; can only handle Grayscale, RGB and Palette images\" << std::endl;\n            TIFFClose(in);\n            tifferror = ERR_UNSUPPORTED;\n            return NULL;\n        }\n    }\n    else\n    {\n        tifferror = ERR_READ;\n        TIFFClose(in);\n        return NULL;\n    }\n\n    if (TIFFGetField(in, TIFFTAG_SAMPLESPERPIXEL, &samplesperpixel) == 1)\n    {\n        if (samplesperpixel != 1 &&\n            samplesperpixel != 2 &&\n            samplesperpixel != 3 &&\n            samplesperpixel != 4)\n        {\n            OSG_DEBUG << \"Bad samples/pixel\" << std::endl;\n            tifferror = ERR_UNSUPPORTED;\n            TIFFClose(in);\n            return NULL;\n        }\n    }\n    else\n    {\n        tifferror = ERR_READ;\n        TIFFClose(in);\n        return NULL;\n    }\n\n    if (TIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bitspersample) == 1)\n    {\n         if (bitspersample != 8 && bitspersample != 16 && bitspersample != 32)\n        {\n            OSG_NOTICE << \"can only handle 8, 16 and 32 bit samples\" << std::endl;\n            TIFFClose(in);\n            tifferror = ERR_UNSUPPORTED;\n            return NULL;\n        }\n    }\n    else\n    {\n        tifferror = ERR_READ;\n        TIFFClose(in);\n        return NULL;\n    }\n\n    if (TIFFGetField(in, TIFFTAG_IMAGEWIDTH, &w) != 1 ||\n        TIFFGetField(in, TIFFTAG_IMAGELENGTH, &h) != 1 ||\n        TIFFGetField(in, TIFFTAG_PLANARCONFIG, &config) != 1)\n    {\n        TIFFClose(in);\n        tifferror = ERR_READ;\n        return NULL;\n    }\n\n\n    TIFFGetField(in, TIFFTAG_DATATYPE, &dataType);\n    OSG_INFO<<\"TIFFTAG_DATATYPE=\"<<dataType<<std::endl;\n\n\n    /*\n    if (photometric == PHOTOMETRIC_MINISWHITE ||\n        photometric == PHOTOMETRIC_MINISBLACK)\n        format = 1;\n    else\n        format = 3;\n    */\n    // if it has a palette, data returned is 3 byte rgb\n    // so set format to 3.\n    if (photometric == PHOTOMETRIC_PALETTE)\n        format = 3;\n    else\n        format = samplesperpixel * bitspersample / 8;\n\n\n    int bytespersample = bitspersample / 8;\n    int bytesperpixel = bytespersample * samplesperpixel;\n\n    OSG_INFO<<\"format=\"<<format<<std::endl;\n    OSG_INFO<<\"bytespersample=\"<<bytespersample<<std::endl;\n    OSG_INFO<<\"bytesperpixel=\"<<bytesperpixel<<std::endl;\n\n    buffer = new unsigned char [w*h*format];\n\n    if (!buffer)\n    {\n        tifferror = ERR_MEM;\n        TIFFClose(in);\n        return NULL;\n    }\n\n    // initialize memory\n    for(unsigned char* ptr=buffer;ptr<buffer+w*h*format;++ptr) *ptr = 0;\n\n    width = w;\n    height = h;\n\n    currPtr = buffer + (h-1)*w*format;\n\n    tifferror = ERR_NO_ERROR;\n\n    switch (pack(photometric, config))\n    {\n        case pack(PHOTOMETRIC_MINISWHITE, PLANARCONFIG_CONTIG):\n        case pack(PHOTOMETRIC_MINISBLACK, PLANARCONFIG_CONTIG):\n        case pack(PHOTOMETRIC_MINISWHITE, PLANARCONFIG_SEPARATE):\n        case pack(PHOTOMETRIC_MINISBLACK, PLANARCONFIG_SEPARATE):\n            inbuf = new unsigned char [TIFFScanlineSize(in)];\n            for (row = 0; row < h; row++)\n            {\n                if (TIFFReadScanline(in, inbuf, row, 0) < 0)\n                {\n                    tifferror = ERR_READ;\n                    break;\n                }\n                invert_row(currPtr, inbuf, samplesperpixel*w, photometric == PHOTOMETRIC_MINISWHITE, bitspersample);\n                currPtr -= format*w;\n            }\n            break;\n\n        case pack(PHOTOMETRIC_PALETTE, PLANARCONFIG_CONTIG):\n        case pack(PHOTOMETRIC_PALETTE, PLANARCONFIG_SEPARATE):\n\n            if (TIFFGetField(in, TIFFTAG_COLORMAP, &red, &green, &blue) != 1)\n            {\n                tifferror = ERR_READ;\n                break;\n            }\n\n            /* */\n            /* Convert 16-bit colormap to 8-bit (unless it looks */\n            /* like an old-style 8-bit colormap). */\n            /* */\n            if (!tifferror && bitspersample!=32 && checkcmap(1<<bitspersample, red, green, blue) == 16)\n            {\n                int i;\n                for (i = (1<<bitspersample)-1; i >= 0; i--)\n                {\n                    red[i] = CVT(red[i]);\n                    green[i] = CVT(green[i]);\n                    blue[i] = CVT(blue[i]);\n                }\n            }\n\n            inbuf = new unsigned char [TIFFScanlineSize(in)];\n            for (row = 0; row < h; row++)\n            {\n                if (TIFFReadScanline(in, inbuf, row, 0) < 0)\n                {\n                    tifferror = ERR_READ;\n                    break;\n                }\n                remap_row(currPtr, inbuf, w, red, green, blue);\n                currPtr -= format*w;\n            }\n            break;\n\n        case pack(PHOTOMETRIC_RGB, PLANARCONFIG_CONTIG):\n            inbuf = new unsigned char [TIFFScanlineSize(in)];\n            for (row = 0; row < h; row++)\n            {\n                if (TIFFReadScanline(in, inbuf, row, 0) < 0)\n                {\n                    tifferror = ERR_READ;\n                    break;\n                }\n                memcpy(currPtr, inbuf, format*w);\n                currPtr -= format*w;\n            }\n            break;\n\n        case pack(PHOTOMETRIC_RGB, PLANARCONFIG_SEPARATE):\n            rowsize = TIFFScanlineSize(in);\n            inbuf = new unsigned char [format*rowsize];\n            for (row = 0; !tifferror && row < h; row++)\n            {\n                int s;\n                for (s = 0; s < format; s++)\n                {\n                    if (TIFFReadScanline(in, (tdata_t)(inbuf+s*rowsize), (uint32)row, (tsample_t)s) < 0)\n                    {\n                        tifferror = ERR_READ; break;\n                    }\n                }\n                if (!tifferror)\n                {\n                    if (format==3) interleave_row(currPtr, inbuf, inbuf+rowsize, inbuf+2*rowsize, w, format, bitspersample);\n                    else if (format==4) interleave_row(currPtr, inbuf, inbuf+rowsize, inbuf+2*rowsize, inbuf+3*rowsize, w, format, bitspersample);\n                    currPtr -= format*w;\n                }\n            }\n            break;\n        default:\n            tifferror = ERR_UNSUPPORTED;\n            break;\n    }\n\n    if (inbuf) delete [] inbuf;\n    TIFFClose(in);\n\n    if (tifferror)\n    {\n        if (buffer) delete [] buffer;\n        return NULL;\n    }\n    width_ret = width;\n    height_ret = height;\n    if (photometric == PHOTOMETRIC_PALETTE)\n        numComponents_ret = format;\n    else\n        numComponents_ret = samplesperpixel;\n\n    return buffer;\n}",
    "WriteResult::WriteStatus writeTIFStream(std::ostream& fout, const osg::Image& img, const osgDB::ReaderWriter::Options* options) const\n        {\n            int compressionType = COMPRESSION_PACKBITS;\n            if (options) {\n                std::istringstream iss(options->getOptionString());\n                std::string opt;\n                while (iss >> opt) {\n                    opt = osgDB::convertToLowerCase(opt);\n\n                    std::size_t eqInd = opt.find(\"=\");\n                    if (opt.substr(0, eqInd) == \"tiff_compression\") {\n                        std::string compressTypeOpt;\n                        compressTypeOpt = opt.substr(eqInd + 1);\n                        compressTypeOpt = osgDB::convertToLowerCase(compressTypeOpt);\n                        if (compressTypeOpt == \"packbits\") {\n                            compressionType = COMPRESSION_PACKBITS;\n                        }\n                        else if (compressTypeOpt == \"lzw\") {\n                            compressionType = COMPRESSION_LZW;\n                        }\n                        else if (compressTypeOpt == \"jpeg\") {\n                            compressionType = COMPRESSION_JPEG;\n                        }\n                        else if (compressTypeOpt == \"none\") {\n                            compressionType = COMPRESSION_NONE;\n                        }\n                    }\n                }\n            }\n\n\n            //Code is based from the following article on CodeProject.com\n            //http://www.codeproject.com/bitmap/BitmapsToTiffs.asp\n\n            TIFF *image;\n            int samplesPerPixel;\n            int bitsPerSample;\n            uint16 photometric;\n\n            image = TIFFClientOpen(\"outputstream\", \"w\", (thandle_t)&fout,\n                                    libtiffOStreamReadProc, //Custom read function\n                                    libtiffOStreamWriteProc, //Custom write function\n                                    libtiffOStreamSeekProc, //Custom seek function\n                                    libtiffStreamCloseProc, //Custom close function\n                                    libtiffOStreamSizeProc, //Custom size function\n                                    libtiffStreamMapProc, //Custom map function\n                                    libtiffStreamUnmapProc); //Custom unmap function\n\n            if(image == NULL)\n            {\n                return WriteResult::ERROR_IN_WRITING_FILE;\n            }\n\n            switch(img.getPixelFormat()) {\n                case GL_DEPTH_COMPONENT:\n                case GL_LUMINANCE:\n                case GL_ALPHA:\n                case GL_RED:\n                    photometric = PHOTOMETRIC_MINISBLACK;\n                    samplesPerPixel = 1;\n                    break;\n                case GL_LUMINANCE_ALPHA:\n                case GL_RG:\n                    photometric = PHOTOMETRIC_MINISBLACK;\n                    samplesPerPixel = 2;\n                    break;\n                case GL_RGB:\n                    photometric = PHOTOMETRIC_RGB;\n                    samplesPerPixel = 3;\n                    break;\n                case GL_RGBA:\n                    photometric = PHOTOMETRIC_RGB;\n                    samplesPerPixel = 4;\n                    break;\n                default:\n                    return WriteResult::ERROR_IN_WRITING_FILE;\n                    break;\n            }\n\n            uint32 rowsperstrip = 0;\n\n            switch(img.getDataType()){\n                case GL_FLOAT:\n                    TIFFSetField(image, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);\n                    rowsperstrip = 1;\n                    bitsPerSample = 32;\n                    break;\n                case GL_SHORT:\n                    TIFFSetField(image, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_INT);\n                    bitsPerSample = 16;\n                    break;\n                case GL_UNSIGNED_SHORT:\n                    TIFFSetField(image, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT);\n                    bitsPerSample = 16;\n                    break;\n                default:\n                    bitsPerSample = 8;\n                    break;\n            }\n\n            TIFFSetField(image, TIFFTAG_IMAGEWIDTH,img.s());\n            TIFFSetField(image, TIFFTAG_IMAGELENGTH,img.t());\n            TIFFSetField(image, TIFFTAG_BITSPERSAMPLE,bitsPerSample);\n            TIFFSetField(image, TIFFTAG_SAMPLESPERPIXEL,samplesPerPixel);\n            TIFFSetField(image, TIFFTAG_PHOTOMETRIC, photometric);\n            TIFFSetField(image, TIFFTAG_COMPRESSION, compressionType);\n            TIFFSetField(image, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);\n            TIFFSetField(image, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\n            if (rowsperstrip==0) rowsperstrip = TIFFDefaultStripSize(image, 0);\n            TIFFSetField(image, TIFFTAG_ROWSPERSTRIP, rowsperstrip);\n\n            // Write the information to the file\n            for(int i = 0; i < img.t(); ++i) {\n                TIFFWriteScanline(image,(tdata_t)img.data(0,img.t()-i-1),i,0);\n            }\n\n            // Close the file\n            TIFFClose(image);\n\n            return WriteResult::FILE_SAVED;\n        }",
    "static void\nread_tiff(CCImage &rimg, ByteStream *bs, cjb2opts &opts)\n{\n  TIFF *tiff = TIFFClientOpen(\"libtiff\", \"rm\", (thandle_t)bs,\n                              readproc, writeproc, seekproc,\n                              closeproc, sizeproc, \n                              mapproc, unmapproc );\n  if (! tiff)\n    G_THROW(\"Tiff image is corrupted (cannot open)\");\n  // bitonal\n  uint16 bps = 0, spp = 0;\n  TIFFGetFieldDefaulted(tiff, TIFFTAG_BITSPERSAMPLE, &bps);\n  TIFFGetFieldDefaulted(tiff, TIFFTAG_SAMPLESPERPIXEL, &spp);\n  if (bps != 1 || spp != 1)\n    G_THROW(\"Tiff image is not bitonal\");\n  // photometric\n  uint16 photo = PHOTOMETRIC_MINISWHITE;\n  TIFFGetFieldDefaulted(tiff, TIFFTAG_PHOTOMETRIC, &photo);\n  // image size\n  uint32 w, h;\n  if (!TIFFGetFieldDefaulted(tiff, TIFFTAG_IMAGEWIDTH, &w) ||\n      !TIFFGetFieldDefaulted(tiff, TIFFTAG_IMAGELENGTH, &h) )\n    G_THROW(\"Tiff image size is not defined\");\n  // resolution\n  float xres, yres;\n  if (TIFFGetFieldDefaulted(tiff, TIFFTAG_XRESOLUTION, &xres) &&\n      TIFFGetFieldDefaulted(tiff, TIFFTAG_YRESOLUTION, &yres) ) \n    {\n      if (xres != yres)\n        DjVuPrintErrorUTF8( \"cjb2: X- and Y-resolution do not match\\n\");\n      if (! opts.forcedpi)\n        opts.dpi = (int) (xres + yres) / 2;\n    }\n  // init rimg\n  rimg.init(w, h, opts.dpi);\n  // allocate scanline\n  tsize_t scanlinesize = TIFFScanlineSize(tiff);\n  scanlinesize = MAX(scanlinesize,1);\n  unsigned char *scanline = 0;\n  GPBuffer<unsigned char> gscanline(scanline, scanlinesize);\n  // iterate on rows\n  for (int y=0; y<(int)h; y++)\n    {\n      int yy = h - y - 1;\n      if (TIFFReadScanline(tiff, (tdata_t)scanline, y) < 0)\n        G_THROW(\"Tiff file is corrupted (TIFFReadScanline)\");\n      if (photo != PHOTOMETRIC_MINISWHITE)\n        for (int i=0; i<(int)scanlinesize; i++)\n          scanline[i] ^= 0xff;\n      int lastx=0, off=0;\n      unsigned char mask=0, c=0, b=0;\n      for (int x=0; x<(int)w; x++)\n        {\n          if (! mask) \n            {\n              b = scanline[off++];\n              while (b==c && x+8<(int)w )\n                {\n                  x = x + 8;  // speedup\n                  b = scanline[off++];\n                }\n              mask = 0x80;\n            }\n          if ( (b ^ c) & mask ) \n            {\n              c ^= 0xff;\n              if (c)\n                lastx = x;\n              else\n                rimg.add_single_run(yy, lastx, x-1);\n            }\n          mask >>= 1;\n        }\n      if (c)\n        rimg.add_single_run(yy, lastx, w-1);\n    }\n  // close\n  TIFFClose(tiff);\n}",
    "void\nclosefile(int pageno)\n{\n  /* Do not close when generating a single file */\n  if (pageno > 0 && ! flag_eachpage)\n    return;\n\n  /* Compute filename */\n  const char *filename = outputfilename;\n  if (flag_eachpage && pageno > 0)\n    {\n      sprintf(pagefilename, filename, pageno);\n      filename = pagefilename;\n    }\n\n  /* Close temporary tiff and generate pdf */\n#if HAVE_TIFF2PDF\n  if (tiff && tempfilename)\n    {\n      const char *args[3];\n      if (! TIFFFlush(tiff))\n        die(i18n(\"Error while flushing TIFF file.\"));\n      if (flag_verbose)\n        fprintf(stderr,i18n(\"Converting temporary TIFF to PDF.\\n\"));\n#ifndef _WIN32\n      if (tiffd >= 0)\n        {\n          int fd = dup(tiffd);\n          TIFFClose(tiff);\n          close(tiffd);\n          tiffd = fd;\n          lseek(tiffd, 0, SEEK_SET);\n          if (! (tiff = TIFFFdOpen(tiffd, tempfilename, \"r\")))\n            die(i18n(\"Cannot reopen temporary TIFF file '%s'.\"), tempfilename);\n        }\n      else\n#endif\n        {\n          TIFFClose(tiff);\n          if (!(tiff = TIFFOpen(tempfilename, \"r\")))\n            die(i18n(\"Cannot reopen temporary TIFF file '%s'.\"), tempfilename);\n        }\n      // Convert\n      if (! (fout = fopen(filename, \"wb\")))\n        die(i18n(\"Cannot open output file '%s'.\"), filename);\n      args[0] = programname;\n      args[1] = \"-o\";\n      args[2] = filename;\n      if (tiff2pdf(tiff, fout, 3, args) != EXIT_SUCCESS)\n        die(i18n(\"Error occurred while creating PDF file.\"));\n      TIFFClose(tiff);\n      tiff = 0;\n#ifndef _WIN32\n      close(tiffd);\n      tiffd = -1;\n#endif\n      remove(tempfilename);\n      free(tempfilename);\n      tempfilename = 0;\n    }\n#endif\n  /* Close tiff */\n#if HAVE_TIFF\n  if (tiff)\n    {\n      if (! TIFFFlush(tiff))\n        die(i18n(\"Error while flushing tiff file.\"));\n      TIFFClose(tiff);\n      tiff = 0;\n    }\n#endif\n  /* Close fout */\n  if (fout)\n    {\n      if (fflush(fout) < 0)\n        die(i18n(\"Error while flushing output file: %s\"), strerror(errno));\n      fclose(fout);\n      fout = 0;\n    }\n}",
    "int R2Image::\nWriteTIFFFile(const char *filename) const\n{\n#ifdef RN_USE_TIFF\n  // Open TIFF file\n  TIFF *out = TIFFOpen(filename, \"w\");\n  if (!out) {\n    RNFail(\"Unable to open TIFF file %s\\n\", filename);\n    return 0;\n  }\n\n  // Set TIFF parameters\n  TIFFSetField(out, TIFFTAG_IMAGEWIDTH, width);\n  TIFFSetField(out, TIFFTAG_IMAGELENGTH, height);\n  TIFFSetField(out, TIFFTAG_ORIENTATION, ORIENTATION_BOTLEFT);\n  TIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, 3);\n  TIFFSetField(out, TIFFTAG_BITSPERSAMPLE, 8);\n  TIFFSetField(out, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n  TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n  TIFFSetField(out, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n  TIFFSetField(out, TIFFTAG_ROWSPERSTRIP, 1);\n\n  // Allocate data for scan lines\n  int scanline_size = TIFFScanlineSize(out);\n  unsigned char *buf = (unsigned char *)_TIFFmalloc(scanline_size);\n  if (!buf) {\n    RNFail(\"Unable to allocate memory for TIFF scan lines\\n\");\n    return 0;\n  }\n\n  // Write scan lines to TIFF file\n  for (int row = 0; row < height; row++) {\n    const unsigned char *p = Pixels(row);\n    if (TIFFWriteScanline(out, (tdata_t) p, height - row - 1, 0) < 0) {\n      RNFail(\"Unable to write scanline to TIFF image %s\\n\", filename);\n      return 0;\n    }\n  }\n\n  // Free data for scan lines\n  _TIFFfree(buf);\n\n  // Close TIFF file\n  TIFFClose(out);\n\n  // Return success\n  return 1;\n#else\n  RNFail(\"TIFF not supported\");\n  return 0;\n#endif\n}",
    "INGR_VirtualFile CPL_STDCALL INGR_CreateVirtualFile( const char *pszFilename,\n                                                     INGR_Format eFormat,\n                                                     int nXSize,\n                                                     int nYSize,\n                                                     int nTileSize,\n                                                     int nQuality,\n                                                     GByte *pabyBuffer,\n                                                     int nBufferSize,\n                                                     int nBand )\n{\n    INGR_VirtualFile hVirtual = {nullptr, nullptr, nullptr};\n\n    hVirtual.pszFileName = CPLSPrintf( \"/vsimem/%s.virtual\",\n        CPLGetBasename( pszFilename ) );\n\n    int nJPGComponents = 1;\n\n    switch( eFormat )\n    {\n    case JPEGRGB:\n        nJPGComponents = 3;\n        CPL_FALLTHROUGH\n    case JPEGGRAY:\n        {\n            GByte *pabyHeader = (GByte*) CPLCalloc( 1, 2048 );\n            int nHeaderSize   = JPGHLP_HeaderMaker( pabyHeader,\n                                                    nTileSize,\n                                                    nTileSize,\n                                                    nJPGComponents,\n                                                    0,\n                                                    nQuality );\n            VSILFILE *fp = VSIFOpenL( hVirtual.pszFileName, \"w+\" );\n            VSIFWriteL( pabyHeader, 1, nHeaderSize, fp );\n            VSIFWriteL( pabyBuffer, 1, nBufferSize, fp );\n            VSIFCloseL( fp );\n            CPLFree( pabyHeader );\n            break;\n        }\n    case CCITTGroup4:\n        {\n            REVERSEBITSBUFFER( pabyBuffer, nBufferSize );\n            VSILFILE *fpL = VSIFOpenL( hVirtual.pszFileName, \"w+\" );\n            TIFF *hTIFF = VSI_TIFFOpen( hVirtual.pszFileName, \"w+\", fpL );\n            if( hTIFF == nullptr ) /* shouldn't happen */\n                return hVirtual;\n            TIFFSetField( hTIFF, TIFFTAG_IMAGEWIDTH,      nXSize );\n            TIFFSetField( hTIFF, TIFFTAG_IMAGELENGTH,     nYSize );\n            TIFFSetField( hTIFF, TIFFTAG_BITSPERSAMPLE,   1 );\n            TIFFSetField( hTIFF, TIFFTAG_SAMPLEFORMAT,    SAMPLEFORMAT_UINT );\n            TIFFSetField( hTIFF, TIFFTAG_PLANARCONFIG,    PLANARCONFIG_CONTIG );\n            TIFFSetField( hTIFF, TIFFTAG_FILLORDER,       FILLORDER_MSB2LSB );\n            TIFFSetField( hTIFF, TIFFTAG_ROWSPERSTRIP,    -1 );\n            TIFFSetField( hTIFF, TIFFTAG_SAMPLESPERPIXEL, 1 );\n            TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC,     PHOTOMETRIC_MINISWHITE );\n            TIFFSetField( hTIFF, TIFFTAG_COMPRESSION,     COMPRESSION_CCITTFAX4 );\n            TIFFWriteRawStrip( hTIFF, 0, pabyBuffer, nBufferSize );\n            TIFFWriteDirectory( hTIFF );\n            TIFFClose( hTIFF );\n            VSIFCloseL(fpL);\n            break;\n        }\n    default:\n        return hVirtual;\n    }",
    "int NITFUncompressBILEVEL( NITFImage *psImage,\n                           GByte *pabyInputData, int nInputBytes,\n                           GByte *pabyOutputImage )\n\n{\n/* -------------------------------------------------------------------- */\n/*      Write memory TIFF with the bilevel data.                        */\n/* -------------------------------------------------------------------- */\n    const int nOutputBytes= (psImage->nBlockWidth * psImage->nBlockHeight + 7)/8;\n\n    CPLString osFilename;\n\n    osFilename.Printf( \"/vsimem/nitf-wrk-%ld.tif\", (long) CPLGetPID() );\n\n    VSILFILE* fpL = VSIFOpenL(osFilename, \"w+\");\n    if( fpL == nullptr )\n        return FALSE;\n    TIFF *hTIFF = VSI_TIFFOpen( osFilename, \"w+\", fpL );\n    if (hTIFF == nullptr)\n    {\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fpL));\n        return FALSE;\n    }\n\n    TIFFSetField( hTIFF, TIFFTAG_IMAGEWIDTH,    psImage->nBlockWidth );\n    TIFFSetField( hTIFF, TIFFTAG_IMAGELENGTH,   psImage->nBlockHeight );\n    TIFFSetField( hTIFF, TIFFTAG_BITSPERSAMPLE, 1 );\n    TIFFSetField( hTIFF, TIFFTAG_SAMPLEFORMAT,  SAMPLEFORMAT_UINT );\n    TIFFSetField( hTIFF, TIFFTAG_PLANARCONFIG,  PLANARCONFIG_CONTIG );\n    TIFFSetField( hTIFF, TIFFTAG_FILLORDER,     FILLORDER_MSB2LSB );\n\n    TIFFSetField( hTIFF, TIFFTAG_ROWSPERSTRIP,  psImage->nBlockHeight );\n    TIFFSetField( hTIFF, TIFFTAG_SAMPLESPERPIXEL, 1 );\n    TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK );\n    TIFFSetField( hTIFF, TIFFTAG_COMPRESSION, COMPRESSION_CCITTFAX3 );\n\n    if( psImage->szCOMRAT[0] == '2' )\n        TIFFSetField( hTIFF, TIFFTAG_GROUP3OPTIONS, GROUP3OPT_2DENCODING );\n\n    TIFFWriteRawStrip( hTIFF, 0, pabyInputData, nInputBytes );\n    TIFFWriteDirectory( hTIFF );\n\n    TIFFClose( hTIFF );\n\n/* -------------------------------------------------------------------- */\n/*      Now open and read it back.                                      */\n/* -------------------------------------------------------------------- */\n    bool bResult = true;\n\n    hTIFF = VSI_TIFFOpen( osFilename, \"r\", fpL );\n    if (hTIFF == nullptr)\n    {\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fpL));\n        return FALSE;\n    }\n\n    if( TIFFReadEncodedStrip( hTIFF, 0, pabyOutputImage, nOutputBytes ) == -1 )\n    {\n        memset( pabyOutputImage, 0, nOutputBytes );\n        bResult = false;\n    }\n\n    TIFFClose( hTIFF );\n    CPL_IGNORE_RET_VAL(VSIFCloseL(fpL));\n\n    VSIUnlink( osFilename );\n\n    return bResult;\n}",
    "void SavePointCloudToTiff(float *src_pc, INT32 width, INT32 height, char *fileName)\n{\n\tINT32  x, y, pos_src, pos_dst, y_offset, z_offset;\n\tTIFF   *imageTiff = NULL;\n\tfloat  *point_cloud = (float*)malloc(width * height * 3 * sizeof(float));\n\tint    bitSize = 32;\n\tfloat  *ptrPageImage;\n\n\t// re-arrange point cloud data\n\ty_offset = width * height;\n\tz_offset = y_offset * 2;\n#pragma omp parallel for firstprivate(x, pos_src, pos_dst)\n\tfor (y = 0; y < height; y++) {\n\t\tpos_src = y * width * 3;\n\t\tpos_dst = y * width;\n\t\tfor (x = 0; x < width; x++) {\n\t\t\tif (src_pc[pos_src+2] < 1e+6f) {\n\t\t\t\tpoint_cloud[pos_dst         ] = src_pc[pos_src  ];\n\t\t\t\tpoint_cloud[pos_dst+y_offset] = src_pc[pos_src+1];\n\t\t\t\tpoint_cloud[pos_dst+z_offset] = src_pc[pos_src+2];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpoint_cloud[pos_dst         ] = NAN;\n\t\t\t\tpoint_cloud[pos_dst+y_offset] = NAN;\n\t\t\t\tpoint_cloud[pos_dst+z_offset] = NAN;\n\t\t\t}\n\t\t\tpos_src += 3;\n\t\t\tpos_dst++;\n\t\t}\n\t}\n\n\timageTiff = TIFFOpen(fileName, \"w\");\n\tif (imageTiff == NULL)   return;\n\tfor (int page = 0; page < 3; page++) {\n\t\tptrPageImage = point_cloud + (width * height) * page;\n\n\t\tTIFFSetField(imageTiff, TIFFTAG_IMAGEWIDTH, width);\n\t\tTIFFSetField(imageTiff, TIFFTAG_IMAGELENGTH, height);\n\t\tTIFFSetField(imageTiff, TIFFTAG_BITSPERSAMPLE, bitSize);\n\t\tTIFFSetField(imageTiff, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);\n\t\tTIFFSetField(imageTiff, TIFFTAG_SAMPLESPERPIXEL, 1);\n\t\tTIFFSetField(imageTiff, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n\t\tTIFFSetField(imageTiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n\t\tTIFFSetField(imageTiff, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);\n\t\tTIFFSetField(imageTiff, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\t\tTIFFSetField(imageTiff, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n\t\tTIFFSetField(imageTiff, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE);\n\t\tTIFFSetField(imageTiff, TIFFTAG_PAGENUMBER, page, 3);\n\n\t\tsize_t stride = width;\n\t\tfor (int i = 0; i < height; i++) {\n\t\t\tTIFFWriteScanline(imageTiff, ptrPageImage + i * stride, i, 0);\n\t\t}\n\t\tTIFFWriteDirectory(imageTiff);\n\n\t}\n\tTIFFClose(imageTiff);\n\tif (point_cloud != NULL) free(point_cloud);\n}",
    "void Image::readTiff(\n  const char* p_name,\n  const size_t i_border) {\n\n  //! Open the tiff file\n  TIFF *tif = TIFFOpen(p_name, \"r\");\n\n  //! Check that the file has been open\n  if (!tif) {\n    cout << \"Unable to read TIFF file \" << p_name << \". Abort.\" << endl;\n    exit(EXIT_FAILURE);\n  }\n\n  //! Initialization\n  uint32 w = 0, h = 0;\n  uint16 spp = 0, bps = 0, fmt = 0;\n\n  //! Get the metadata\n  TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w);\n  TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\n  TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &spp);\n  TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bps);\n  TIFFGetField(tif, TIFFTAG_SAMPLEFORMAT, &fmt);\n\n  //! Check the metadata\n  if (spp != 1 || bps != (uint16) sizeof(float) * 8 ||\n      fmt != SAMPLEFORMAT_IEEEFP) {\n    cout << \"readTiff: metadata non-conform. Abort.\" << endl;\n    exit(EXIT_FAILURE);\n  }\n\n  //! Allocate the image\n  new (this) Image(w, h, 1, i_border);\n\n  //! Read the values\n  for (size_t i = 0; i < m_height; i++) {\n    float* oI = this->getPtr(0, i);\n    if (TIFFReadScanline(tif, oI, i, 0) < 0) {\n      cout << \"readTiff: error reading row \" << i << endl;\n      exit(EXIT_FAILURE);\n    }\n  }\n\n  //! Close the file\n  TIFFClose(tif);\n}",
    "void Image::writeTiff(\n  const std::string &p_name,\n  const bool p_quad) const {\n\n  //! Open the file\n  TIFF *tif = TIFFOpen(p_name.c_str(), \"w\");\n\n  //! Check that the file has been created\n  if (!tif) {\n    cout << \"Unable to write TIFF file \" << p_name << endl;\n    exit(EXIT_FAILURE);\n  }\n\n  //! For convenience\n  const size_t h = m_height * (p_quad ? 2 : 1);\n  const size_t w = m_width  * (p_quad ? 2 : 1);\n  uint32 rowsperstrip;\n  float* line = (float*) memalloc(16, (p_quad ? w : m_width) * sizeof(float));\n\n  //! Header of the tiff file\n  TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, (uint32) w);\n  TIFFSetField(tif, TIFFTAG_IMAGELENGTH, (uint32) h);\n  TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_SEPARATE);\n  TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, (uint16) m_channels);\n  TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, (uint16) sizeof(float) * 8);\n  TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);\n  rowsperstrip = TIFFDefaultStripSize(tif, (uint32) h);\n  TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, rowsperstrip);\n  TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n  TIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n\n  //! Write the file data\n  for (size_t c = 0, ok = 1; ok && c < m_channels; c++) {\n    for (size_t i = 0; ok && i < h; i++) {\n      const float* iI = this->getPtr(c, p_quad ? i / 2 : i);\n\n      //! Copy the line\n      if (p_quad) {\n        for (size_t j = 0; j < m_width; j++) {\n          line[2 * j + 0] = line[2 * j + 1] = iI[j];\n        }\n      }\n      else {\n        for (size_t j = 0; j < m_width; j++) {\n          line[j] = iI[j];\n        }\n      }\n\n      //! Write the line\n      if (TIFFWriteScanline(tif, line, (uint32) i, (tsample_t) c) < 0) {\n        cout << \"WriteTIFF: error writing row \" << i << endl;\n        ok = 0;\n      }\n    }\n  }\n\n  //! Release memory\n  memfree(line);\n\n  //! Close the file\n  TIFFClose(tif);\n}",
    "int ReadTiff(const char * filename,\n  std::vector<unsigned char> * ptr,\n  int * w,\n  int * h,\n  int * depth)\n{\n  TIFF* tiff = TIFFOpen(filename, \"r\");\n  if (!tiff) {\n    std::cerr << \"Error: Couldn't open \" << filename << \" fopen returned 0\";\n    return 0;\n  }\n  uint16 bps, spp;\n\n  TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, w);\n  TIFFGetField(tiff, TIFFTAG_IMAGELENGTH, h);\n  TIFFGetField(tiff, TIFFTAG_BITSPERSAMPLE, &bps);\n  TIFFGetField(tiff, TIFFTAG_SAMPLESPERPIXEL, &spp);\n  *depth = bps * spp / 8;\n\n  ptr->resize((*h)*(*w)*(*depth));\n\n  if (*depth==4) {\n    if (ptr != nullptr) {\n      if (!TIFFReadRGBAImageOriented(tiff, *w, *h, (uint32*)&((*ptr)[0]), ORIENTATION_TOPLEFT, 0)) {\n        TIFFClose(tiff);\n        return 0;\n      }\n    }\n  } else {\n    for (size_t i=0; i<TIFFNumberOfStrips(tiff); ++i) {\n      if (TIFFReadEncodedStrip(tiff, i, ((uint8*)&((*ptr)[0]))+i*TIFFStripSize(tiff),(tsize_t)-1) ==\n        std::numeric_limits<tsize_t>::max()) {\n        TIFFClose(tiff);\n        return 0;\n      }\n    }\n  }\n  TIFFClose(tiff);\n  return 1;\n}",
    "int WriteTiff(const char * filename,\n  const std::vector<unsigned char> & ptr,\n  int w,\n  int h,\n  int depth)\n{\n  TIFF* tiff = TIFFOpen(filename, \"w\");\n  if (!tiff) {\n    std::cerr << \"Error: Couldn't open \" << filename << \" fopen returned 0\";\n    return 0;\n  }\n  TIFFSetField(tiff, TIFFTAG_IMAGEWIDTH, w);\n  TIFFSetField(tiff, TIFFTAG_IMAGELENGTH, h);\n  TIFFSetField(tiff, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n  TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n  TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 8);\n  TIFFSetField(tiff, TIFFTAG_SAMPLESPERPIXEL, depth);\n  TIFFSetField(tiff, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n  TIFFSetField(tiff, TIFFTAG_COMPRESSION,COMPRESSION_NONE);\n  TIFFSetField(tiff, TIFFTAG_ROWSPERSTRIP, 16);\n  for (uint32 y=0; y < static_cast<uint32>(h); ++y) {\n    if (TIFFWriteScanline(tiff,(tdata_t)(((uint8*)(&ptr[0]))+depth*w*y),y)<0) {\n      TIFFClose(tiff);\n      return 0;\n    }\n  }\n  TIFFClose(tiff);\n  return 1;\n}",
    "bool Read_TIFF_ImageHeader(const char * filename, ImageHeader * imgheader)\n{\n  bool bStatus = false;\n\n  TIFF* tiff = TIFFOpen(filename, \"r\");\n  if (!tiff) {\n    return false;\n  }\n\n  if (imgheader)\n  {\n    TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, &imgheader->width);\n    TIFFGetField(tiff, TIFFTAG_IMAGELENGTH, &imgheader->height);\n    bStatus = true;\n  }\n\n  TIFFClose(tiff);\n  return bStatus;\n}",
    "~TiffHandle() {\n    if (m_handle) {\n      TIFFClose(m_handle);\n    }\n  }",
    "void AIPlug::processRaster(QDataStream &ts)\r\n{\r\n\tdouble m1, m2, m3, m4, m5, m6, x1, y1, x2, y2, dummy;\r\n\tint w, h, type, alpha, bin, bits;\r\n\tQString tmp = \"\";\r\n\tQString cumulated = \"\";\r\n\twhile (!ts.atEnd())\r\n\t{\r\n\t\ttmp = readLineFromDataStream(ts);\r\n\t\tif (tmp.startsWith(\"%\"))\r\n\t\t\tbreak;\r\n\t\ttmp.remove(\"[\");\r\n\t\ttmp.remove(\"]\");\r\n\t\tif (!tmp.isEmpty())\r\n\t\t\tcumulated += \" \" + tmp;\r\n\t}\r\n\tQString Cdata = \"\";\r\n\tQStringList da;\r\n\tgetCommands(cumulated, da);\r\n\tCdata = da.last();\r\n\tScTextStream gVals(&Cdata, QIODevice::ReadOnly);\r\n\tgVals >> m1 >> m2 >> m3 >> m4 >> m5 >> m6 >> x1 >> y1 >> x2 >> y2 >> w >> h >> bits >> type >> alpha >> dummy >> bin;\r\n//\tqDebug() << QString(\"Matrix: %1 %2 %3 %4 %5 %6\").arg(m1).arg(m2).arg(m3).arg(m4).arg(m5).arg(m6);\r\n//\tqDebug() << QString(\"Bounds: %1 %2 %3 %4\").arg(x1).arg(y1).arg(x2).arg(y2);\r\n//\tqDebug() << QString(\"Size: %1 %2\").arg(w).arg(h);\r\n//\tqDebug() << QString(\"Bits: %1\").arg(bits);\r\n//\tqDebug() << QString(\"Typ: %1\").arg(type);\r\n//\tqDebug() << QString(\"Alpha-Channels: %1\").arg(alpha);\r\n//\tqDebug() << QString(\"Encoding: %1\").arg(bin);\r\n\tuint dataSize = w * h * (type + alpha);\r\n\tuint alphaData = w * h * type;\r\n//\tbool cmyk = false;\r\n//\tif (type == 4)\r\n//\t\tcmyk = true;\r\n\tif (tmp.startsWith(\"%%BeginData\"))\r\n\t{\r\n\t\tScTextStream gVals2(&tmp, QIODevice::ReadOnly);\r\n\t\ttmp = readLineFromDataStream(ts);\r\n\t}\r\n\tQByteArray psdata;\r\n\tpsdata.resize(dataSize);\r\n\tRawImage m_image;\r\n\tif (type == 4)\r\n\t{\r\n\t\tif (alpha > 0)\r\n\t\t\tm_image.create(w, 1, 5);\r\n\t\telse\r\n\t\t\tm_image.create(w, 1, 4);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tif (alpha > 0)\r\n\t\t\tm_image.create(w, 1, 4);\r\n\t\telse\r\n\t\t\tm_image.create(w, 1, 3);\r\n\t}\r\n\tbool first = false;\r\n\tif (bin == 0) // 0 = ASCII encoded data\r\n\t{\r\n\t\tuint dataPointer = 0;\r\n\t\twhile (!ts.atEnd())\r\n\t\t{\r\n\t\t\tif (first)\r\n\t\t\t\ttmp = readLineFromDataStream(ts);\r\n\t\t\tfirst = true;\r\n\t\t\tif (tmp.startsWith(\"%AI5_EndRaster\"))\r\n\t\t\t\tbreak;\r\n\t\t\tfor (int a = 1; a < tmp.length(); a += 2)\r\n\t\t\t{\r\n\t\t\t\tbool ok;\r\n\t\t\t\tushort data = tmp.midRef(a, 2).toUShort(&ok, 16);\r\n\t\t\t\tpsdata[dataPointer++] = data;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tpsdata.resize(dataSize);\r\n\t\tts.readRawData(psdata.data(), dataSize);\r\n\t}\r\n\tQTransform imgMatrix = QTransform(m1, m2, m3, m4, m5, m6);\r\n\tQPointF pos = QPointF(imgMatrix.dx(), imgMatrix.dy());\r\n\tpos += QPointF(m_Doc->currentPage()->xOffset(), -m_Doc->currentPage()->yOffset());\r\n\tpos += QPointF(baseX, -baseY);\r\n\tint z = m_Doc->itemAdd(PageItem::ImageFrame, PageItem::Unspecified, pos.x() - docX, docHeight - (pos.y() - docY), 10, 10, 0, CurrColorFill, CurrColorStroke);\r\n\tPageItem* ite = m_Doc->Items->at(z);\r\n\tite->setWidthHeight(fabs(w * m1), fabs(h * m4));\r\n\tdouble rotation = getRotationFromMatrix(imgMatrix, 0.0);\r\n\tite->setRotation(rotation * 180 / M_PI);\r\n\tite->SetRectFrame();\r\n\tm_Doc->setRedrawBounding(ite);\r\n\tite->Clip = flattenPath(ite->PoLine, ite->Segments);\r\n\tite->setTextFlowMode(PageItem::TextFlowDisabled);\r\n\tite->setFillShade(CurrFillShade);\r\n\tite->setLineShade(CurrStrokeShade);\r\n\tite->setFillEvenOdd(fillRule);\r\n\tite->setFillTransparency(1.0 - Opacity);\r\n\tite->setLineTransparency(1.0 - Opacity);\r\n\tite->setFillBlendmode(blendMode);\r\n\tite->setLineBlendmode(blendMode);\r\n\tite->setLineEnd(CapStyle);\r\n\tite->setLineJoin(JoinStyle);\r\n\tuchar *p;\r\n\tuint yCount = 0;\r\n\tquint16 eTag = EXTRASAMPLE_UNASSALPHA;\r\n\tQTemporaryFile *tempFile = new QTemporaryFile(QDir::tempPath() + \"/scribus_temp_ai_XXXXXX.tif\");\r\n\ttempFile->setAutoRemove(false);\r\n\ttempFile->open();\r\n\tQString imgName = getLongPathName(tempFile->fileName());\r\n\ttempFile->close();\r\n\tite->isInlineImage = true;\r\n\tite->isTempFile = true;\r\n\tdelete tempFile;\r\n\tTIFF* tif = TIFFOpen(imgName.toLocal8Bit().data(), \"w\");\r\n\tif (tif)\r\n\t{\r\n\t\tTIFFSetField(tif, TIFFTAG_IMAGEWIDTH, w);\r\n\t\tTIFFSetField(tif, TIFFTAG_IMAGELENGTH, h);\r\n\t\tTIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8);\r\n\t\tTIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, m_image.channels());\r\n\t\tif (alpha == 1)\r\n\t\t\tTIFFSetField(tif, TIFFTAG_EXTRASAMPLES, 1, &eTag);\r\n\t\tTIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\r\n\t\tif (type == 4)\r\n\t\t\tTIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_SEPARATED);\r\n\t\telse\r\n\t\t\tTIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\r\n\t\tTIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_LZW);\r\n\t\tfor (int y = 0; y < h; ++y)\r\n\t\t{\r\n\t\t\tp = m_image.scanLine( 0 );\r\n\t\t\tfor (int xh = 0; xh < m_image.width(); ++xh )\r\n\t\t\t{\r\n\t\t\t\tp[0] = psdata[yCount++];\r\n\t\t\t\tif (type > 1)\r\n\t\t\t\t{\r\n\t\t\t\t\tp[1] = psdata[yCount++];\r\n\t\t\t\t\tp[2] = psdata[yCount++];\r\n\t\t\t\t\tif (type == 4)\r\n\t\t\t\t\t\tp[3] = psdata[yCount++];\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tp[1] = p[0];\r\n\t\t\t\t\tp[2] = p[0];\r\n\t\t\t\t}\r\n\t\t\t\tif (alpha == 1)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (type == 4)\r\n\t\t\t\t\t\tp[4] = psdata[alphaData++];\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tp[3] = psdata[alphaData++];\r\n\t\t\t\t}\r\n\t\t\t\tp += m_image.channels();\r\n\t\t\t}\r\n\t\t\tTIFFWriteScanline(tif, m_image.scanLine(0), y);\r\n\t\t}\r\n\t\tTIFFClose(tif);\r\n\t}\r\n\tm_Doc->loadPict(imgName, ite);\r\n\tif (ite->imageIsAvailable)\r\n\t\tite->setImageXYScale(ite->width() / ite->pixm.width(), ite->height() / ite->pixm.height());\r\n\tif (importerFlags & LoadSavePlugin::lfCreateDoc)\r\n\t\tite->setLocked(itemLocked);\r\n\tif (patternMode)\r\n\t\tPatternElements.append(ite);\r\n\telse\r\n\t\tElements.append(ite);\r\n\tif (groupStack.count() != 0)\r\n\t\tgroupStack.top().append(ite);\r\n}",
    "void SlaOutputDev::drawImage(GfxState *state, Object *ref, Stream *str, int width, int height, GfxImageColorMap *colorMap, GBool interpolate, POPPLER_CONST_082 int* maskColors, GBool inlineImg)\r\n{\r\n\tImageStream * imgStr = new ImageStream(str, width, colorMap->getNumPixelComps(), colorMap->getBits());\r\n//\tqDebug() << \"Image Components\" << colorMap->getNumPixelComps() << \"Mask\" << maskColors;\r\n\timgStr->reset();\r\n\tQImage* image = nullptr;\r\n\tif (maskColors)\r\n\t{\r\n\t\timage = new QImage(width, height, QImage::Format_ARGB32);\r\n\t\tfor (int y = 0; y < height; y++)\r\n\t\t{\r\n\t\t\tQRgb *s = (QRgb*)(image->scanLine(y));\r\n\t\t\tGuchar *pix = imgStr->getLine();\r\n\t\t\tfor (int x = 0; x < width; x++)\r\n\t\t\t{\r\n\t\t\t\tGfxRGB rgb;\r\n\t\t\t\tcolorMap->getRGB(pix, &rgb);\r\n\t\t\t\tint Rc = qRound(colToDbl(rgb.r) * 255);\r\n\t\t\t\tint Gc = qRound(colToDbl(rgb.g) * 255);\r\n\t\t\t\tint Bc = qRound(colToDbl(rgb.b) * 255);\r\n\t\t\t\t*s = qRgba(Rc, Gc, Bc, 255);\r\n\t\t\t\tfor (int i = 0; i < colorMap->getNumPixelComps(); ++i)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (pix[i] < maskColors[2*i] * 255 || pix[i] > maskColors[2*i+1] * 255)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t*s = *s | 0xff000000;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\ts++;\r\n\t\t\t\tpix += colorMap->getNumPixelComps();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\timage = new QImage(width, height, QImage::Format_ARGB32);\r\n\t\tfor (int y = 0; y < height; y++)\r\n\t\t{\r\n\t\t\tQRgb *s = (QRgb*)(image->scanLine(y));\r\n\t\t\tGuchar *pix = imgStr->getLine();\r\n\t\t\tfor (int x = 0; x < width; x++)\r\n\t\t\t{\r\n\t\t\t\tif (colorMap->getNumPixelComps() == 4)\r\n\t\t\t\t{\r\n\t\t\t\t\tGfxCMYK cmyk;\r\n\t\t\t\t\tcolorMap->getCMYK(pix, &cmyk);\r\n\t\t\t\t\tint Cc = qRound(colToDbl(cmyk.c) * 255);\r\n\t\t\t\t\tint Mc = qRound(colToDbl(cmyk.m) * 255);\r\n\t\t\t\t\tint Yc = qRound(colToDbl(cmyk.y) * 255);\r\n\t\t\t\t\tint Kc = qRound(colToDbl(cmyk.k) * 255);\r\n\t\t\t\t\t*s = qRgba(Yc, Mc, Cc, Kc);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tGfxRGB rgb;\r\n\t\t\t\t\tcolorMap->getRGB(pix, &rgb);\r\n\t\t\t\t\tint Rc = qRound(colToDbl(rgb.r) * 255);\r\n\t\t\t\t\tint Gc = qRound(colToDbl(rgb.g) * 255);\r\n\t\t\t\t\tint Bc = qRound(colToDbl(rgb.b) * 255);\r\n\t\t\t\t\t*s = qRgba(Rc, Gc, Bc, 255);\r\n\t\t\t\t}\r\n\t\t\t\ts++;\r\n\t\t\t\tpix += colorMap->getNumPixelComps();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (image == nullptr || image->isNull())\r\n\t{\r\n\t\tdelete imgStr;\r\n\t\tdelete image;\r\n\t\treturn;\r\n\t}\r\n\tconst double *ctm = state->getCTM();\r\n\tdouble xCoor = m_doc->currentPage()->xOffset();\r\n\tdouble yCoor = m_doc->currentPage()->yOffset();\r\n\tQRectF crect = QRectF(0, 0, width, height);\r\n\tm_ctm = QTransform(ctm[0] / width, ctm[1] / width, -ctm[2] / height, -ctm[3] / height, ctm[2] + ctm[4], ctm[3] + ctm[5]);\r\n\tQLineF cline = QLineF(0, 0, width, 0);\r\n\tQLineF tline = m_ctm.map(cline);\r\n\tQRectF trect = m_ctm.mapRect(crect);\r\n\tdouble sx = m_ctm.m11();\r\n\tdouble sy = m_ctm.m22();\r\n\tQImage img = image->copy();\r\n\tQTransform mm = QTransform(ctm[0] / width, ctm[1] / width, -ctm[2] / height, -ctm[3] / height, 0, 0);\r\n\tint z = m_doc->itemAdd(PageItem::ImageFrame, PageItem::Rectangle, xCoor + trect.x(), yCoor + trect.y(), trect.width(), trect.height(), 0, CommonStrings::None, CommonStrings::None);\r\n\tPageItem* ite = m_doc->Items->at(z);\r\n\tite->ClipEdited = true;\r\n\tite->FrameType = 3;\r\n\tm_doc->setRedrawBounding(ite);\r\n\tite->Clip = flattenPath(ite->PoLine, ite->Segments);\r\n\tite->setTextFlowMode(PageItem::TextFlowDisabled);\r\n\tite->setFillShade(100);\r\n\tite->setLineShade(100);\r\n\tite->setFillEvenOdd(false);\r\n\tite->setFillTransparency(1.0 - state->getFillOpacity());\r\n\tite->setFillBlendmode(getBlendMode(state));\r\n\tm_doc->adjustItemSize(ite);\r\n\tif ((mm.type() == QTransform::TxShear) || (mm.type() == QTransform::TxRotate))\r\n\t{\r\n\t\tite->setImageRotation(-tline.angle());\r\n\t\t/*QTransform rotMat;\r\n\t\trotMat.rotate(tline.angle());\r\n\t\tQTransform imgMat = m_ctm * rotMat.inverted();\r\n\t\tdouble scaleX = sqrt(imgMat.m11() * imgMat.m11() + imgMat.m12() * imgMat.m12());\r\n\t\tdouble scaleY = sqrt(imgMat.m21() * imgMat.m21() + imgMat.m22() * imgMat.m22());\r\n\t\timgMat.scale(1.0 / scaleX, 1.0 / scaleY);\r\n\t\tif (!imgMat.isIdentity())\r\n\t\t\timg = img.transformed(imgMat);*/\r\n\t}\r\n\telse\r\n\t{\r\n\t\tif ((sx < 0) || (sy < 0))\r\n\t\t{\r\n\t\t\tif (sx < 0)\r\n\t\t\t\tite->setImageFlippedH(true);\r\n\t\t\tif (sy < 0)\r\n\t\t\t\tite->setImageFlippedV(true);\r\n\t\t}\r\n\t}\r\n\tif (colorMap->getNumPixelComps() == 4)\r\n\t{\r\n\t\tQTemporaryFile *tempFile = new QTemporaryFile(QDir::tempPath() + \"/scribus_temp_pdf_XXXXXX.tif\");\r\n\t\ttempFile->setAutoRemove(false);\r\n\t\tif (tempFile->open())\r\n\t\t{\r\n\t\t\tQString fileName = getLongPathName(tempFile->fileName());\r\n\t\t\tif (!fileName.isEmpty())\r\n\t\t\t{\r\n\t\t\t\ttempFile->close();\r\n\t\t\t\tite->isInlineImage = true;\r\n\t\t\t\tite->isTempFile = true;\r\n\t\t\t\tite->AspectRatio = false;\r\n\t\t\t\tite->ScaleType   = false;\r\n\t\t\t\tTIFF* tif = TIFFOpen(fileName.toLocal8Bit().data(), \"w\");\r\n\t\t\t\tif (tif)\r\n\t\t\t\t{\r\n\t\t\t\t\tTIFFSetField(tif, TIFFTAG_IMAGEWIDTH, img.width());\r\n\t\t\t\t\tTIFFSetField(tif, TIFFTAG_IMAGELENGTH, img.height());\r\n\t\t\t\t\tTIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8);\r\n\t\t\t\t\tTIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 4);\r\n\t\t\t\t\tTIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\r\n\t\t\t\t\tTIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_SEPARATED);\r\n\t\t\t\t\tTIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_LZW);\r\n\t\t\t\t\tfor (int y = 0; y < img.height(); ++y)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tTIFFWriteScanline(tif, img.scanLine(y), y);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tTIFFClose(tif);\r\n\t\t\t\t\tm_doc->loadPict(fileName, ite);\r\n\t\t\t\t}\r\n\t\t\t\tm_Elements->append(ite);\r\n\t\t\t\tif (m_groupStack.count() != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tm_groupStack.top().Items.append(ite);\r\n\t\t\t\t\tapplyMask(ite);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\tm_doc->Items->removeAll(ite);\r\n\t\t}\r\n\t\tdelete tempFile;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tQTemporaryFile *tempFile = new QTemporaryFile(QDir::tempPath() + \"/scribus_temp_pdf_XXXXXX.png\");\r\n\t\ttempFile->setAutoRemove(false);\r\n\t\tif (tempFile->open())\r\n\t\t{\r\n\t\t\tQString fileName = getLongPathName(tempFile->fileName());\r\n\t\t\tif (!fileName.isEmpty())\r\n\t\t\t{\r\n\t\t\t\ttempFile->close();\r\n\t\t\t\tite->isInlineImage = true;\r\n\t\t\t\tite->isTempFile = true;\r\n\t\t\t\tite->AspectRatio = false;\r\n\t\t\t\tite->ScaleType   = false;\r\n\t\t\t\timg.save(fileName, \"PNG\");\r\n\t\t\t\tm_doc->loadPict(fileName, ite);\r\n\t\t\t\tm_Elements->append(ite);\r\n\t\t\t\tif (m_groupStack.count() != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tm_groupStack.top().Items.append(ite);\r\n\t\t\t\t\tapplyMask(ite);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\tm_doc->Items->removeAll(ite);\r\n\t\t}\r\n\t\tdelete tempFile;\r\n\t}\r\n\tif ((checkClip()) && (inPattern == 0))\r\n\t{\r\n\t\tFPointArray out = m_currentClipPath.copy();\r\n\t\tout.translate(m_doc->currentPage()->xOffset(), m_doc->currentPage()->yOffset());\r\n\t\tout.translate(-ite->xPos(), -ite->yPos());\r\n\t\tite->PoLine = out.copy();\r\n\t\tite->ClipEdited = true;\r\n\t\tite->FrameType = 3;\r\n\t\tFPoint wh = getMaxClipF(&ite->PoLine);\r\n\t\tite->setWidthHeight(wh.x(), wh.y());\r\n\t\tite->setTextFlowMode(PageItem::TextFlowDisabled);\r\n\t\tite->ScaleType   = true;\r\n\t\tm_doc->adjustItemSize(ite);\r\n\t\tite->OldB2 = ite->width();\r\n\t\tite->OldH2 = ite->height();\r\n\t\tite->updateClip();\r\n\t}\r\n\tdelete imgStr;\r\n\tdelete image;\r\n}",
    "void ScImgDataLoader_TIFF::loadEmbeddedProfile(const QString& fn, int /*page*/)\n{\n\tScColorMgmtEngine engine(ScCore->defaultEngine);\n\tm_embeddedProfile.resize(0);\n\tm_profileComponents = 0;\n\tif (!QFile::exists(fn))\n\t\treturn;\n\tTIFFSetTagExtender(TagExtender);\n\tTIFF* tif = TIFFOpen(fn.toLocal8Bit(), \"r\");\n\tif (!tif)\n\t\treturn;\n\n\tuint32 EmbedLen = 0;\n\tvoid*  EmbedBuffer;\n\tif (TIFFGetField(tif, TIFFTAG_ICCPROFILE, &EmbedLen, &EmbedBuffer))\n\t{\n\t\tQByteArray profArray((const char*) EmbedBuffer, EmbedLen);\n\t\tScColorProfile tiffProf = engine.openProfileFromMem(profArray);\n\t\tif (tiffProf)\n\t\t{\n\t\t\tif (tiffProf.colorSpace() == ColorSpace_Rgb)\n\t\t\t\tm_profileComponents = 3;\n\t\t\tif (tiffProf.colorSpace() == ColorSpace_Cmyk)\n\t\t\t\tm_profileComponents = 4;\n\t\t\tif (tiffProf.colorSpace() == ColorSpace_Gray)\n\t\t\t\tm_profileComponents = 1;\n\t\t\tm_embeddedProfile = profArray;\n\t\t}\n\t}\n\tTIFFClose(tif);\n}",
    "int ScImgDataLoader_TIFF::getLayers(const QString& fn, int /*page*/)\n{\n\tint layerNum = 1;\n\tint test;\n\tstruct PSDLayer lay;\n\tTIFFSetTagExtender(TagExtender);\n\tTIFF* tif = TIFFOpen(fn.toLocal8Bit(), \"r\");\n\tif (!tif)\n\t\treturn layerNum;\n\n\tdo\n\t{\n\t\tchar *layerName = nullptr;\n\t\tTIFFGetField(tif, TIFFTAG_PAGENAME, &layerName);\n\t\tQString name = QString(layerName);\n\t\tif (name.isEmpty())\n\t\t\tlay.layerName = QString(\"Layer #%1\").arg(layerNum);\n\t\telse\n\t\t\tlay.layerName = name;\n\t\tlay.blend = \"norm\";\n\t\tlay.opacity = 255;\n\t\tlay.flags = 0;\n\t\tm_imageInfoRecord.layerInfo.append(lay);\n\t\tm_imageInfoRecord.valid = true;\n\t\tlayerNum++;\n\t\ttest = TIFFReadDirectory(tif);\n\t}\n\twhile (test == 1);\n\tTIFFClose(tif);\n\n\treturn layerNum;\n}",
    "bool ScImgDataLoader_TIFF::testAlphaChannelAvailability(const QString& fn, int /*page*/, bool& hasAlpha)\n{\n\tint  test;\n\n\tQByteArray byteOrder(2, ' ');\n\tQFile fo(fn);\n\tif (fo.open(QIODevice::ReadOnly))\n\t{\n\t\tfo.read(byteOrder.data(), 1);\n\t\tfo.close();\n\t}\n\n\tTIFFSetTagExtender(TagExtender);\n\tTIFF* tif = TIFFOpen(fn.toLocal8Bit(), \"r\");\n\tif (!tif)\n\t\treturn false;\n\n\tuint16 extrasamples, *extratypes;\n\thasAlpha = false;\n\tdo\n\t{\n\t\tif (TIFFGetField (tif, TIFFTAG_EXTRASAMPLES, &extrasamples, &extratypes) == 1)\n\t\t{\n\t\t\tfor (int i = 0; i < extrasamples; ++i)\n\t\t\t{\n\t\t\t\tif (extratypes[i] != EXTRASAMPLE_UNSPECIFIED)\n\t\t\t\t{\n\t\t\t\t\thasAlpha = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttest = TIFFReadDirectory(tif);\n\t}\n\twhile (test == 1);\n\n\tif (hasAlpha)\n\t{\n\t\tTIFFClose(tif);\n\t\treturn true;\n\t}\n\n\tunsigned int PhotoshopLen2 = 0;\n\tunsigned char* PhotoshopBuffer2;\n\tint gotField = TIFFGetField(tif, 37724, &PhotoshopLen2, &PhotoshopBuffer2);\n\tif (gotField && (PhotoshopLen2 > 40))\n\t{\n\t\tm_imageInfoRecord.layerInfo.clear();\n\t\tQByteArray arrayPhot = QByteArray::fromRawData((const char*)PhotoshopBuffer2, PhotoshopLen2);\n\t\tQDataStream s(&arrayPhot, QIODevice::ReadOnly);\n\t\tif (byteOrder[0] == 'M')\n\t\t\ts.setByteOrder(QDataStream::BigEndian);\n\t\telse\n\t\t\ts.setByteOrder(QDataStream::LittleEndian);\n\n\t\tQList<PSDLayer> layerInfo;\n\t\tif (loadLayerInfo(s, layerInfo))\n\t\t{\n\t\t\tfor (int layer = 0; layer < layerInfo.count(); ++layer)\n\t\t\t{\n\t\t\t\tconst PSDLayer& psdLayer = layerInfo.at(layer);\n\t\t\t\tuint channel_num = psdLayer.channelLen.count();\n\t\t\t\tfor (uint channel = 0; channel < channel_num; ++channel)\n\t\t\t\t{\n\t\t\t\t\tif (psdLayer.channelType[channel] == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\thasAlpha = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (hasAlpha) break;\n\t\t\t}\n\t\t}\n\t}\n\n\tTIFFClose(tif);\n\treturn true;\n}",
    "bool ScImgDataLoader_TIFF::getImageData(TIFF* tif, RawImage *image, uint widtht, uint heightt, uint size, uint16 photometric, uint16 bitspersample, uint16 samplesperpixel, bool &bilevel, bool &isCMYK)\n{\n\tuint32 *bits = nullptr;\n\tif (photometric == PHOTOMETRIC_SEPARATED)\n\t{\n\t\tif (samplesperpixel > 5)\n\t\t{\n\t\t\tif (!getImageData_RGBA(tif, image, widtht, heightt, size, bitspersample, samplesperpixel))\n\t\t\t\treturn false;\n\t\t\tif (bitspersample == 1)\n\t\t\t\tbilevel = true;\n\t\t\tisCMYK = false;\n\t\t\tm_pixelFormat = Format_RGBA_8;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (TIFFIsTiled(tif))\n\t\t\t{\n\t\t\t\tuint32 columns, rows;\n\t\t\t\tuint32 *tile_buf;\n\t\t\t\tuint32 xt, yt;\n\t\t\t\tTIFFGetField(tif, TIFFTAG_TILEWIDTH,  &columns);\n\t\t\t\tTIFFGetField(tif, TIFFTAG_TILELENGTH, &rows);\n\t\t\t\ttile_buf = (uint32*) _TIFFmalloc(columns*rows*sizeof(uint32));\n\t\t\t\tif (tile_buf == nullptr)\n\t\t\t\t{\n\t\t\t\t\tTIFFClose(tif);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tuint32 tileW = columns, tileH = rows;\n\t\t\t\tfor (yt = 0; yt < (uint32) image->height(); yt += rows)\n\t\t\t\t{\n\t\t\t\t\tif (yt > (uint) image->height())\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif (image->height()-yt < rows)\n\t\t\t\t\t\ttileH = image->height()-yt;\n\t\t\t\t\ttileW = columns;\n\t\t\t\t\tuint32 yi;\n\t\t\t\t\tint chans = image->channels();\n\t\t\t\t\tfor (xt = 0; xt < (uint) image->width(); xt += columns)\n\t\t\t\t\t{\n\t\t\t\t\t\tTIFFReadTile(tif, tile_buf, xt, yt, 0, 0);\n\t\t\t\t\t\tfor (yi = 0; yi < tileH; yi++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t_TIFFmemcpy(image->scanLine(yt+(tileH-1-yi))+xt, tile_buf+tileW*yi, tileW*chans);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_TIFFfree(tile_buf);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttsize_t bytesperrow = TIFFScanlineSize(tif);\n\t\t\t\tbits = (uint32 *) _TIFFmalloc(bytesperrow);\n\t\t\t\tint chans = image->channels();\n\t\t\t\tif (bits)\n\t\t\t\t{\n\t\t\t\t\tfor (unsigned int y = 0; y < heightt; y++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (TIFFReadScanline(tif, bits, y, 0))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/* The code below allows loading of CMYK TIFFs generated by ImageMagick, \n\t\t\t\t\t\t\t   currently commented out because its an ugly hack atm\n\t\t\t\t\t\t\t   When converting 8-bit PNGs with an alpha channel to CMYK Tiff, ImageMagick\n\t\t\t\t\t\t\t   creates a 16-bit CMYK Tiff !?!??\n\t\t\t\t\t\t\tif (bitspersample > 8)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tuchar *ptrT = image->scanLine(y);\n\t\t\t\t\t\t\t\tuchar *ptrS = (uchar*)bits;\n\t\t\t\t\t\t\t\tfor (unsigned int x = 0; x < widtht; x++)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tptrT[0] = ptrS[1];\n\t\t\t\t\t\t\t\t\tptrT[1] = ptrS[3];\n\t\t\t\t\t\t\t\t\tptrT[2] = ptrS[5];\n\t\t\t\t\t\t\t\t\tptrT[3] = ptrS[7];\n\t\t\t\t\t\t\t\t\tif (samplesperpixel > 4)\n\t\t\t\t\t\t\t\t\t\tptrT[4] = ptrS[9];\n\t\t\t\t\t\t\t\t\tptrT += chans;\n\t\t\t\t\t\t\t\t\tptrS += chans * 2;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse */\n\t\t\t\t\t\t\t\tmemcpy(image->scanLine(y), bits, chans * widtht);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t_TIFFfree(bits);\n\t\t\t\t}\n\t\t\t}\n\t\t\tisCMYK = true;\n\t\t\tm_pixelFormat = (image->channels() == 5) ? Format_CMYKA_8 : Format_CMYK_8;\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (!getImageData_RGBA(tif, image, widtht, heightt, size, bitspersample, samplesperpixel))\n\t\t\treturn false;\n\t\tif (bitspersample == 1)\n\t\t\tbilevel = true;\n\t\tm_pixelFormat = Format_RGBA_8;\n\t}\n\treturn true;\n}",
    "bool ScImgDataLoader_TIFF::loadPicture(const QString& fn, int page, int res, bool thumbnail)\n{\n\tScColorMgmtEngine engine(ScCore->defaultEngine);\n\tbool bilevel = false;\n\tbool failedPS = false;\n\tbool foundPS = false;\n\tshort resolutionunit = RESUNIT_INCH; // Default unit is inch\n\tfloat xres = 72.0, yres = 72.0;\n\tif (!QFile::exists(fn))\n\t\treturn false;\n\tQByteArray byteOrder(2, ' ');\n\tQFile fo(fn);\n\tif (fo.open(QIODevice::ReadOnly))\n\t{\n\t\tfo.read(byteOrder.data(), 1);\n\t\tfo.close();\n\t}\n\tsrand(314159265);\n\tfor (int i = 0; i < 4096; i++)\n\t\tm_random_table[i] = rand();\n\tfor (int i = 0; i < 4096; i++)\n\t{\n\t\tint tmp;\n\t\tint swap = i + rand() % (4096 - i);\n\t\ttmp = m_random_table[i];\n\t\tm_random_table[i] = m_random_table[swap];\n\t\tm_random_table[swap] = tmp;\n\t}\n\n\tinitialize();\n\n\tint test;\n\tbool valid = m_imageInfoRecord.isRequest;\n\tQMap<int, ImageLoadRequest> req = m_imageInfoRecord.RequestProps;\n\tm_imageInfoRecord.RequestProps = req;\n\tm_imageInfoRecord.isRequest = valid;\n\tm_imageInfoRecord.type = ImageTypeTIF;\n\tgetLayers(fn, page);\n\n\tTIFFSetTagExtender(TagExtender);\n\tTIFF* tif = TIFFOpen(fn.toLocal8Bit(), \"r\");\n\tif (!tif)\n\t\treturn false;\n\n\tbool isCMYK = false;\n\tunsigned int widtht, heightt, size;\n\tchar *description=nullptr, *copyright=nullptr, *datetime=nullptr, *artist=nullptr, *scannerMake=nullptr, *scannerModel=nullptr;\n\tuint16 bitspersample, fillorder, planar;\n\n\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &widtht);\n\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &heightt);\n\tTIFFGetField(tif, TIFFTAG_XRESOLUTION, &xres);\n\tTIFFGetField(tif, TIFFTAG_YRESOLUTION, &yres);\n\tTIFFGetField(tif, TIFFTAG_RESOLUTIONUNIT , &resolutionunit);\n\tsize = widtht * heightt;\n\tTIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &m_photometric);\n\tTIFFGetField(tif, TIFFTAG_PLANARCONFIG, &planar);\n\tTIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bitspersample);\n\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &m_samplesperpixel);\n\tTIFFGetField(tif, TIFFTAG_FILLORDER, &fillorder);\n\n\tTIFFGetField(tif, TIFFTAG_MAKE, &scannerMake);\n\tTIFFGetField(tif, TIFFTAG_MODEL, &scannerModel);\n\tTIFFGetField(tif, TIFFTAG_IMAGEDESCRIPTION, &description);\n\tTIFFGetField(tif, TIFFTAG_COPYRIGHT, &copyright);\n\tTIFFGetField(tif, TIFFTAG_DATETIME, &datetime);\n\tTIFFGetField(tif, TIFFTAG_ARTIST, &artist);\n\tm_imageInfoRecord.exifInfo.cameraName = QString(scannerModel);\n\tm_imageInfoRecord.exifInfo.cameraVendor = QString(scannerMake);\n\tm_imageInfoRecord.exifInfo.comment = QString(description);\n\tm_imageInfoRecord.exifInfo.userComment = QString(copyright);\n\tm_imageInfoRecord.exifInfo.width = widtht;\n\tm_imageInfoRecord.exifInfo.height = heightt;\n\tm_imageInfoRecord.exifInfo.dateTime = QString(datetime);\n\tm_imageInfoRecord.exifInfo.artist = QString(artist);\n\tm_imageInfoRecord.exifInfo.thumbnail = QImage();\n\tm_imageInfoRecord.exifDataValid = true;\n\tuint32 EmbedLen = 0;\n\tvoid*  EmbedBuffer;\n\tif (TIFFGetField(tif, TIFFTAG_ICCPROFILE, &EmbedLen, &EmbedBuffer))\n\t{\n\t\tQByteArray profArray((const char*) EmbedBuffer, EmbedLen);\n\t\tScColorProfile tiffProf = engine.openProfileFromMem(profArray);\n\t\tm_embeddedProfile = profArray;\n\t\tm_imageInfoRecord.profileName = tiffProf.productDescription();\n\t\tm_imageInfoRecord.isEmbedded = true;\n\t}\n\telse\n\t{\n\t\tm_imageInfoRecord.isEmbedded = false;\n\t\tm_imageInfoRecord.profileName = \"\";\n\t}\n\tunsigned int PhotoshopLen = 0;\n\tunsigned char* PhotoshopBuffer;\n\tif (TIFFGetField(tif, TIFFTAG_PHOTOSHOP, &PhotoshopLen, &PhotoshopBuffer) )\n\t{\n\t\tif (PhotoshopLen != 0)\n\t\t{\n\t\t\tQByteArray arrayPhot = QByteArray((const char*)PhotoshopBuffer,PhotoshopLen);\n\t\t\tQDataStream strPhot(&arrayPhot,QIODevice::ReadOnly);\n\t\t\tstrPhot.setByteOrder( QDataStream::BigEndian );\n\t\t\tPSDHeader fakeHeader;\n\t\t\tfakeHeader.width = widtht;\n\t\t\tfakeHeader.height = heightt;\n\t\t\tparseRessourceData(strPhot, fakeHeader, PhotoshopLen);\n\t\t\tm_imageInfoRecord.exifInfo.width = widtht;\n\t\t\tm_imageInfoRecord.exifInfo.height = heightt;\n\t\t\tif (!m_imageInfoRecord.valid)\n\t\t\t\tm_imageInfoRecord.valid = (m_imageInfoRecord.PDSpathData.size())>0;\n\t\t\tif (thumbnail)\n\t\t\t{\n\t\t\t\tif (m_photometric == PHOTOMETRIC_SEPARATED)\n\t\t\t\t{\n\t\t\t\t\tisCMYK = true;\n\t\t\t\t\tm_imageInfoRecord.colorspace = ColorSpaceCMYK;\n\t\t\t\t}\n\t\t\t\telse if (m_samplesperpixel == 1)\n\t\t\t\t{\n\t\t\t\t\tm_imageInfoRecord.colorspace = ColorSpaceGray;\n\t\t\t\t\tisCMYK = false;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tm_imageInfoRecord.colorspace = ColorSpaceRGB;\n\t\t\t\tif (bitspersample == 1)\n\t\t\t\t\tbilevel = true;\n\t\t\t\tif (!m_imageInfoRecord.exifInfo.thumbnail.isNull())\n\t\t\t\t{\n\t\t\t\t\tif (isCMYK)\n\t\t\t\t\t{\n\t\t\t\t\t\tr_image.create(m_imageInfoRecord.exifInfo.thumbnail.width(), m_imageInfoRecord.exifInfo.thumbnail.height(), 5);\n\t\t\t\t\t\tm_pixelFormat = Format_CMYKA_8;;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tr_image.create(m_imageInfoRecord.exifInfo.thumbnail.width(), m_imageInfoRecord.exifInfo.thumbnail.height(), 4);\n\t\t\t\t\t\tm_pixelFormat = (m_imageInfoRecord.colorspace == ColorSpaceCMYK) ? Format_CMYK_8 : Format_RGBA_8;\n\t\t\t\t\t}\n\t\t\t\t\tr_image.fill(0);\n\t\t\t\t\tQRgb *s;\n\t\t\t\t\tuchar *d;\n\t\t\t\t\tunsigned char cc, cm, cy, ck;\n\t\t\t\t\tfor (int yit=0; yit < m_imageInfoRecord.exifInfo.thumbnail.height(); ++yit)\n\t\t\t\t\t{\n\t\t\t\t\t\ts = (QRgb*)(m_imageInfoRecord.exifInfo.thumbnail.scanLine( yit ));\n\t\t\t\t\t\td = r_image.scanLine( yit );\n\t\t\t\t\t\tfor (int xit=0; xit < m_imageInfoRecord.exifInfo.thumbnail.width(); ++xit)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (isCMYK)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcc = 255 - qRed(*s);\n\t\t\t\t\t\t\t\tcm = 255 - qGreen(*s);\n\t\t\t\t\t\t\t\tcy = 255 - qBlue(*s);\n\t\t\t\t\t\t\t\tck = qMin(qMin(cc, cm), cy);\n\t\t\t\t\t\t\t\td[0] = cc-ck;\n\t\t\t\t\t\t\t\td[1] = cm-ck;\n\t\t\t\t\t\t\t\td[2] = cy-ck;\n\t\t\t\t\t\t\t\td[3] = ck;\n\t\t\t\t\t\t\t\td[4] = 255;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\td[0] = qRed(*s);\n\t\t\t\t\t\t\t\td[1] = qGreen(*s);\n\t\t\t\t\t\t\t\td[2] = qBlue(*s);\n\t\t\t\t\t\t\t\td[3] = 255;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ts++;\n\t\t\t\t\t\t\td += r_image.channels();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tTIFFClose(tif);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tunsigned int PhotoshopLen2 = 0;\n\tunsigned char* PhotoshopBuffer2;\n\tint gotField = TIFFGetField(tif, 37724, &PhotoshopLen2, &PhotoshopBuffer2);\n\tif (gotField && (PhotoshopLen2 > 40))\n\t{\n\t\tm_imageInfoRecord.layerInfo.clear();\n\t\tQByteArray arrayPhot = QByteArray::fromRawData((const char*)PhotoshopBuffer2, PhotoshopLen2);\n\t\tQDataStream s(&arrayPhot,QIODevice::ReadOnly);\n\t\tif (byteOrder[0] == 'M')\n\t\t\ts.setByteOrder( QDataStream::BigEndian );\n\t\telse\n\t\t\ts.setByteOrder( QDataStream::LittleEndian );\n\n\t\tfailedPS = !loadLayerInfo(s, m_imageInfoRecord.layerInfo); \n\t\tif (!failedPS)\n\t\t{\n\t\t\tint chans = 4;\n\t\t\tint numChannels = m_imageInfoRecord.layerInfo.last().channelType.count();\n\t\t\tint numLayers = m_imageInfoRecord.layerInfo.count();\n\t\t\tPSDHeader fakeHeader;\n\t\t\tfakeHeader.width = widtht;\n\t\t\tfakeHeader.height = heightt;\n\t\t\tfakeHeader.channel_count = numChannels;\n\t\t\tfakeHeader.depth = 8;\n\t\t\tif (m_photometric == PHOTOMETRIC_SEPARATED)\n\t\t\t{\n\t\t\t\tisCMYK = true;\n\t\t\t\tfakeHeader.color_mode = CM_CMYK;\n\t\t\t\tchans = 5;\n\t\t\t}\n\t\t\telse if (m_samplesperpixel == 1)\n\t\t\t{\n\t\t\t\tfakeHeader.color_mode = CM_GRAYSCALE;\n\t\t\t\tisCMYK = false;\n\t\t\t\tchans = 4;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfakeHeader.color_mode = CM_RGB;\n\t\t\t\tisCMYK = false;\n\t\t\t\tchans = 4;\n\t\t\t}\n\t\t\tif (!r_image.create(widtht, heightt, chans))\n\t\t\t\treturn false;\n\t\t\tr_image.fill(0);\n\t\t\tbool firstLayer = true;\n\t\t\tfor (int layer = 0; layer < numLayers; layer++)\n\t\t\t{\n\t\t\t\tloadLayerChannels( s, fakeHeader, m_imageInfoRecord.layerInfo, layer, &firstLayer );\n\t\t\t}\n\t\t\tarrayPhot.clear();\n\t\t\tTIFFClose(tif);\n\t\t\tfoundPS = true;\n\t\t\tif (m_imageInfoRecord.layerInfo.count() == 1)\n\t\t\t\tm_imageInfoRecord.layerInfo.clear();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tarrayPhot.clear();\n\t\t\tgetLayers(fn, page);\n\t\t}\n\t}\n\n\tif (xres <= 1.0 || yres <= 1.0)\n\t{\n\t\txres = yres = 72.0;\n\t\tQFileInfo qfi(fn);\n\t\tm_message = QObject::tr(\"%1 may be corrupted : missing resolution tags\").arg(qfi.fileName());\n\t\tm_msgType = warningMsg;\n\t}\n\tif ((!foundPS) || (failedPS))\n\t{\n\t\tint chans = 4;\n\t\tif (m_photometric == PHOTOMETRIC_SEPARATED)\n\t\t{\n\t\t\tif (m_samplesperpixel > 5) \n\t\t\t\tchans = 4;\n\t\t\telse\n\t\t\t\tchans = m_samplesperpixel;\n\t\t}\n\t\telse\n\t\t\tchans = 4;\n\t\tif (!r_image.create(widtht, heightt, chans))\n\t\t{\n\t\t\tTIFFClose(tif);\n\t\t\treturn false;\n\t\t}\n\t\tr_image.fill(0);\n\t\tint layerNum = 0;\n\t\tdo\n\t\t{\n\t\t\tRawImage tmpImg;\n\t\t\tif (!tmpImg.create(widtht, heightt, chans))\n\t\t\t{\n\t\t\t\tTIFFClose(tif);\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\ttmpImg.fill(0);\n\t\t\tif (!getImageData(tif, &tmpImg, widtht, heightt, size, m_photometric, bitspersample, m_samplesperpixel, bilevel, isCMYK))\n\t\t\t{\n\t\t\t\tTIFFClose(tif);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbool visible = true;\n\t\t\tbool useMask = true;\n\t\t\tif ((m_imageInfoRecord.isRequest) && (m_imageInfoRecord.RequestProps.contains(layerNum)))\n\t\t\t\tvisible = m_imageInfoRecord.RequestProps[layerNum].visible;\n\t\t\tQString layBlend(\"norm\");\n\t\t\tif ((m_imageInfoRecord.isRequest) && (m_imageInfoRecord.RequestProps.contains(layerNum)))\n\t\t\t\tlayBlend = m_imageInfoRecord.RequestProps[layerNum].blend;\n\t\t\tif ((m_imageInfoRecord.isRequest) && (m_imageInfoRecord.RequestProps.contains(layerNum)))\n\t\t\t\tuseMask = m_imageInfoRecord.RequestProps[layerNum].useMask;\n\t\t\tint layOpa = 255;\n\t\t\tif ((m_imageInfoRecord.isRequest) && (m_imageInfoRecord.RequestProps.contains(layerNum)))\n\t\t\t\tlayOpa = m_imageInfoRecord.RequestProps[layerNum].opacity;\n\t\t\tif (visible)\n\t\t\t{\n\t\t\t\tif ((layerNum == 0) && (layBlend != \"diss\"))\n\t\t\t\t\tr_image = tmpImg;\n\t\t\t\telse\n\t\t\t\t\tblendOntoTarget(&tmpImg, layOpa, layBlend, isCMYK, useMask);\n\t\t\t}\n\t\t\t//JG Copy should not be necessary as QImage is implicitly shared in Qt4\n\t\t\tQImage imt; //QImage imt = tmpImg.copy();\n\t\t\tdouble sx = tmpImg.width() / 40.0;\n\t\t\tdouble sy = tmpImg.height() / 40.0;\n\t\t\timt = tmpImg.convertToQImage(chans > 4);\n\t\t\timt = sy < sx ?\timt.scaled(qRound(imt.width() / sx), qRound(imt.height() / sx), Qt::IgnoreAspectRatio, Qt::SmoothTransformation) :\n\t\t\t\t\t\t\t\t\t\timt.scaled(qRound(imt.width() / sy), qRound(imt.height() / sy), Qt::IgnoreAspectRatio, Qt::SmoothTransformation);\n\t\t\tm_imageInfoRecord.layerInfo[layerNum].thumb = imt.copy();\n\t\t\tif (chans > 4)\n\t\t\t{\n\t\t\t\tQImage imt2 = imt.createAlphaMask();\n\t\t\t\timt2.invertPixels();\n\t\t\t\tm_imageInfoRecord.layerInfo[layerNum].thumb_mask = imt2.copy();\n\t\t\t}\n\t\t\telse\n\t\t\t\tm_imageInfoRecord.layerInfo[layerNum].thumb_mask = QImage();\n\t\t\tlayerNum++;\n\n\t\t\tif ((m_imageInfoRecord.layerInfo.count() == 1) && (chans < 5))\n\t\t\t\tm_imageInfoRecord.layerInfo.clear();\n\t\t\ttest = TIFFReadDirectory(tif);\n\n\t\t\t// #10415 : check that image size for the current directory is the same as the main one\n\t\t\t// Some progs use tiff directory to store previews, we do not handle such case\n\t\t\t// and may perform reads in non allocated blocks if we continue\n\t\t\twhile (test == 1)\n\t\t\t{\n\t\t\t\tunsigned int dirWidth(0), dirHeight(0);\n\t\t\t\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &dirWidth);\n\t\t\t\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &dirHeight);\n\t\t\t\tif (dirWidth == widtht && dirHeight == heightt)\n\t\t\t\t\tbreak;\n\t\t\t\ttest = TIFFReadDirectory(tif);\n\t\t\t\tlayerNum++;\n\t\t\t}\n\t\t}\n\t\twhile (test == 1);\n\t\tTIFFClose(tif);\n\t}\n\tif (resolutionunit == RESUNIT_INCH)\n\t{\n\t\tm_image.setDotsPerMeterX ((int) (xres / 0.0254));\n\t\tm_image.setDotsPerMeterY ((int) (yres / 0.0254));\n\t\tm_imageInfoRecord.xres = qRound(xres);\n\t\tm_imageInfoRecord.yres = qRound(yres);\n\t}\n\telse if (resolutionunit == RESUNIT_CENTIMETER)\n\t{\n\t\tm_image.setDotsPerMeterX ((int) (xres * 100.0));\n\t\tm_image.setDotsPerMeterY ((int) (yres * 100.0));\n\t\tm_imageInfoRecord.xres = qRound(xres*2.54);\n\t\tm_imageInfoRecord.yres = qRound(yres*2.54);\n\t}\n\tif (isCMYK)\n\t{\n\t\tm_imageInfoRecord.colorspace = ColorSpaceCMYK;\n\t\tm_pixelFormat = (r_image.channels() == 5) ? Format_CMYKA_8 : Format_CMYK_8;\n\t}\n\telse if (m_samplesperpixel == 1)\n\t{\n\t\t// Do not set m_pixelFormat here as the real pixel format is most probably different than gray\n\t\tif (bitspersample == 1)\n\t\t\tm_imageInfoRecord.colorspace = ColorSpaceMonochrome;\n\t\telse\n\t\t\tm_imageInfoRecord.colorspace = ColorSpaceGray;\n\t}\n\telse\n\t{\n\t\tm_imageInfoRecord.colorspace = ColorSpaceRGB;\n\t\tm_pixelFormat = Format_RGBA_8;\n\t}\n\tm_imageInfoRecord.BBoxX = 0;\n\tm_imageInfoRecord.BBoxH = r_image.height();\n\tif ((m_imageInfoRecord.layerInfo.isEmpty()) && (m_imageInfoRecord.PDSpathData.isEmpty()))\n\t\tm_imageInfoRecord.valid = false;\n\telse\n\t\tm_imageInfoRecord.valid = true;\n\treturn true;\n}",
    "FloatImage * nv::ImageIO::loadFloatTIFF(const char * fileName, Stream & s)\n{\n\tnvCheck(!s.isError());\n\t\n\tTIFF * tif = TIFFOpen(fileName, \"r\");\n\t//TIFF * tif = TIFFClientOpen(fileName, \"r\", &s, tiffReadWriteProc, tiffReadWriteProc, tiffSeekProc, tiffCloseProc, tiffSizeProc, tiffMapFileProc, tiffUnmapFileProc);\n\t\n\tif (!tif)\n\t{\n\t\tnvDebug(\"Can't open '%s' for reading\\n\", fileName);\n\t\treturn NULL;\n\t}\n\t\n\t::uint16 spp, bpp, format;\n\t::uint32 width, height;\n\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n\tTIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bpp);\n\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &spp);\n\tTIFFGetField(tif, TIFFTAG_SAMPLEFORMAT, &format);\n\t\n\tif (bpp != 8 && bpp != 16 && bpp != 32) {\n\t\tnvDebug(\"Can't load '%s', only 1 sample per pixel supported\\n\", fileName);\n\t\tTIFFClose(tif);\n\t\treturn NULL;\n\t}\n\t\n\tAutoPtr<FloatImage> fimage(new FloatImage());\n\tfimage->allocate(spp, width, height);\n\t\n\tint linesize = TIFFScanlineSize(tif);\n\ttdata_t buf = (::uint8 *)nv::mem::malloc(linesize);\n\t\n\tfor (uint y = 0; y < height; y++) \n\t{\n\t\tTIFFReadScanline(tif, buf, y, 0);\n\n\t\tfor (uint c=0; c<spp; c++ ) \n\t\t{\n\t\t\tfloat * dst = fimage->scanline(y, c);\n\n\t\t\tfor(uint x = 0; x < width; x++) \n\t\t\t{\n\t\t\t\tif (bpp == 8)\n\t\t\t\t{\n\t\t\t\t\tdst[x] = float(((::uint8 *)buf)[x*spp+c]) / float(0xFF);\n\t\t\t\t}\n\t\t\t\telse if (bpp == 16)\n\t\t\t\t{\n\t\t\t\t\tdst[x] = float(((::uint16 *)buf)[x*spp+c]) / float(0xFFFF);\n\t\t\t\t}\n\t\t\t\telse if (bpp == 32)\n\t\t\t\t{\n\t\t\t\t\tif (format==SAMPLEFORMAT_IEEEFP)\n\t\t\t\t\t{\n\t\t\t\t\t\tdst[x] = float(((float *)buf)[x*spp+c]);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tdst[x] = float(((::uint32 *)buf)[x*spp+c] >> 8) / float(0xFFFFFF);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\n\tnv::mem::free(buf);\n\t\n\tTIFFClose(tif);\n\t\n\treturn fimage.release();\n}",
    "bool nv::ImageIO::saveFloatTIFF(const char * fileName, const FloatImage * fimage, uint base_component, uint num_components)\n{\n\tnvCheck(fileName != NULL);\n\tnvCheck(fimage != NULL);\n\tnvCheck(base_component + num_components <= fimage->componentNum());\n\t\n\tconst int iW = fimage->width();\n\tconst int iH = fimage->height();\n\tconst int iC = num_components;\n\n\tTIFF * image = TIFFOpen(fileName, \"w\");\n\n\t// Open the TIFF file\n\tif (image == NULL)\n\t{\n\t\tnvDebug(\"Could not open '%s' for writing\\n\", fileName);\n\t\treturn false;\n\t}\n\n\tTIFFSetField(image, TIFFTAG_IMAGEWIDTH,  iW);\n\tTIFFSetField(image, TIFFTAG_IMAGELENGTH, iH);\n\tTIFFSetField(image, TIFFTAG_SAMPLESPERPIXEL, iC);\n\tTIFFSetField(image, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);\n\tTIFFSetField(image, TIFFTAG_BITSPERSAMPLE, 32);\n\t\n\tuint32 rowsperstrip = TIFFDefaultStripSize(image, (uint32)-1); \n\n\tTIFFSetField(image, TIFFTAG_ROWSPERSTRIP, rowsperstrip);\n\tTIFFSetField(image, TIFFTAG_COMPRESSION, COMPRESSION_PACKBITS);\n\tif (num_components == 3)\n\t{\n\t\t// Set this so that it can be visualized with pfstools.\n\t\tTIFFSetField(image, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n\t}\n\tTIFFSetField(image, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n\tTIFFSetField(image, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\n\tfloat * scanline = new float[iW * iC];\n\tfor (int y = 0; y < iH; y++)\n\t{\n\t\tfor (int c = 0; c < iC; c++) \n\t\t{\n\t\t\tconst float * src = fimage->scanline(y, base_component + c);\n\t\t\tfor (int x = 0; x < iW; x++) scanline[x * iC + c] = src[x];\n\t\t}\n\t\tif (TIFFWriteScanline(image, scanline, y, 0)==-1)\n\t\t{\n\t\t\tnvDebug(\"Error writing scanline %d\\n\", y);\n\t\t\treturn false;\n\t\t}\n\t}\n\tdelete [] scanline;\n\n\t// Close the file\n\tTIFFClose(image);\n\treturn true;\n}",
    "void TiffDecoder::close()\n{\n    if( m_tif )\n    {\n        TIFF* tif = (TIFF*)m_tif;\n        TIFFClose( tif );\n        m_tif = 0;\n    }\n}",
    "bool TiffEncoder::writeLibTiff( const std::vector<Mat>& img_vec, const std::vector<int>& params)\n{\n    // do NOT put \"wb\" as the mode, because the b means \"big endian\" mode, not \"binary\" mode.\n    // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n    TIFF* pTiffHandle;\n\n    TiffEncoderBufHelper buf_helper(m_buf);\n    if ( m_buf )\n    {\n        pTiffHandle = buf_helper.open();\n    }\n    else\n    {\n        pTiffHandle = TIFFOpen(m_filename.c_str(), \"w\");\n    }\n    if (!pTiffHandle)\n    {\n        return false;\n    }\n\n    //Settings that matter to all images\n    // defaults for now, maybe base them on params in the future\n    int compression = COMPRESSION_LZW;\n    int predictor = PREDICTOR_HORIZONTAL;\n    int resUnit = -1, dpiX = -1, dpiY = -1;\n\n    readParam(params, TIFFTAG_COMPRESSION, compression);\n    readParam(params, TIFFTAG_PREDICTOR, predictor);\n    readParam(params, IMWRITE_TIFF_RESUNIT, resUnit);\n    readParam(params, IMWRITE_TIFF_XDPI, dpiX);\n    readParam(params, IMWRITE_TIFF_YDPI, dpiY);\n\n    //Iterate through each image in the vector and write them out as Tiff directories\n    for (size_t page = 0; page < img_vec.size(); page++)\n    {\n        const Mat& img = img_vec[page];\n        int channels = img.channels();\n        int width = img.cols, height = img.rows;\n        int depth = img.depth();\n\n        int bitsPerChannel = -1;\n        switch (depth)\n        {\n            case CV_8U:\n            {\n                bitsPerChannel = 8;\n                break;\n            }\n            case CV_16U:\n            {\n                bitsPerChannel = 16;\n                break;\n            }\n            default:\n            {\n                TIFFClose(pTiffHandle);\n                return false;\n            }\n        }\n\n        const int bitsPerByte = 8;\n        size_t fileStep = (width * channels * bitsPerChannel) / bitsPerByte;\n\n        int rowsPerStrip = (int)((1 << 13) / fileStep);\n        readParam(params, TIFFTAG_ROWSPERSTRIP, rowsPerStrip);\n\n        if (rowsPerStrip < 1)\n            rowsPerStrip = 1;\n\n        if (rowsPerStrip > height)\n            rowsPerStrip = height;\n\n        int   colorspace = channels > 1 ? PHOTOMETRIC_RGB : PHOTOMETRIC_MINISBLACK;\n\n        if (!TIFFSetField(pTiffHandle, TIFFTAG_IMAGEWIDTH, width)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_IMAGELENGTH, height)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_BITSPERSAMPLE, bitsPerChannel)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_COMPRESSION, compression)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_PHOTOMETRIC, colorspace)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_SAMPLESPERPIXEL, channels)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_ROWSPERSTRIP, rowsPerStrip)\n            || (img_vec.size() > 1 && (\n               !TIFFSetField(pTiffHandle, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_PAGENUMBER, page, img_vec.size() )))\n            )\n        {\n            TIFFClose(pTiffHandle);\n            return false;\n        }\n\n        if (compression != COMPRESSION_NONE && !TIFFSetField(pTiffHandle, TIFFTAG_PREDICTOR, predictor))\n        {\n            TIFFClose(pTiffHandle);\n            return false;\n        }\n\n        if (((resUnit >= RESUNIT_NONE && resUnit <= RESUNIT_CENTIMETER) && !TIFFSetField(pTiffHandle, TIFFTAG_RESOLUTIONUNIT, resUnit))\n            || (dpiX >= 0 && !TIFFSetField(pTiffHandle, TIFFTAG_XRESOLUTION, (float)dpiX))\n            || (dpiY >= 0 && !TIFFSetField(pTiffHandle, TIFFTAG_YRESOLUTION, (float)dpiY))\n            )\n        {\n            TIFFClose(pTiffHandle);\n            return false;\n        }\n\n\n        // row buffer, because TIFFWriteScanline modifies the original data!\n        size_t scanlineSize = TIFFScanlineSize(pTiffHandle);\n        AutoBuffer<uchar> _buffer(scanlineSize + 32);\n        uchar* buffer = _buffer.data();\n        if (!buffer)\n        {\n            TIFFClose(pTiffHandle);\n            return false;\n        }\n\n        for (int y = 0; y < height; ++y)\n        {\n            switch (channels)\n            {\n                case 1:\n                {\n                    memcpy(buffer, img.ptr(y), scanlineSize);\n                    break;\n                }\n\n                case 3:\n                {\n                    if (depth == CV_8U)\n                        icvCvt_BGR2RGB_8u_C3R( img.ptr(y), 0, buffer, 0, Size(width, 1));\n                    else\n                        icvCvt_BGR2RGB_16u_C3R( img.ptr<ushort>(y), 0, (ushort*)buffer, 0, Size(width, 1));\n                    break;\n                }\n\n                case 4:\n                {\n                    if (depth == CV_8U)\n                        icvCvt_BGRA2RGBA_8u_C4R( img.ptr(y), 0, buffer, 0, Size(width, 1));\n                    else\n                        icvCvt_BGRA2RGBA_16u_C4R( img.ptr<ushort>(y), 0, (ushort*)buffer, 0, Size(width, 1));\n                    break;\n                }\n\n                default:\n                {\n                    TIFFClose(pTiffHandle);\n                    return false;\n                }\n            }\n\n            int writeResult = TIFFWriteScanline(pTiffHandle, buffer, y, 0);\n            if (writeResult != 1)\n            {\n                TIFFClose(pTiffHandle);\n                return false;\n            }\n        }\n\n        TIFFWriteDirectory(pTiffHandle);\n\n    }\n\n    TIFFClose(pTiffHandle);\n    return true;\n}",
    "bool TiffEncoder::write_32FC3(const Mat& _img)\n{\n    Mat img;\n    cvtColor(_img, img, COLOR_BGR2XYZ);\n\n    TIFF* tif;\n\n    TiffEncoderBufHelper buf_helper(m_buf);\n    if ( m_buf )\n    {\n        tif = buf_helper.open();\n    }\n    else\n    {\n        tif = TIFFOpen(m_filename.c_str(), \"w\");\n    }\n\n    if (!tif)\n    {\n        return false;\n    }\n    TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, img.cols);\n    TIFFSetField(tif, TIFFTAG_IMAGELENGTH, img.rows);\n    TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 3);\n    TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_SGILOG);\n    TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_LOGLUV);\n    TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    TIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_FLOAT);\n    TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, 1);\n    int strip_size = 3 * img.cols;\n    float *ptr = const_cast<float*>(img.ptr<float>());\n    for (int i = 0; i < img.rows; i++, ptr += strip_size)\n    {\n        TIFFWriteEncodedStrip(tif, i, ptr, strip_size * sizeof(float));\n    }\n    TIFFClose(tif);\n    return true;\n}",
    "bool TiffEncoder::write_32FC1(const Mat& _img)\n{\n\n    TIFF* tif;\n\n    TiffEncoderBufHelper buf_helper(m_buf);\n    if ( m_buf )\n    {\n        tif = buf_helper.open();\n    }\n    else\n    {\n        tif = TIFFOpen(m_filename.c_str(), \"w\");\n    }\n\n    if (!tif)\n    {\n        return false;\n    }\n\n    TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, _img.cols);\n    TIFFSetField(tif, TIFFTAG_IMAGELENGTH, _img.rows);\n    TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 1);\n    TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 32);\n    TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n    TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);\n    TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n    for (uint32 row = 0; row < (uint32)_img.rows; row++)\n    {\n        if (TIFFWriteScanline(tif, (tdata_t)_img.ptr<float>(row), row, 1) != 1)\n        {\n            TIFFClose(tif);\n            return false;\n        }\n    }\n    TIFFWriteDirectory(tif);\n    TIFFClose(tif);\n\n    return true;\n}",
    "Image load(string filename) {\n        TIFF *tiff = TIFFOpen(filename.c_str(), \"r\");\n\n        assert(tiff, \"Could not open file %s\\n\", filename.c_str());\n\n        // Get basic information from TIFF header\n        int w;\n        assert(TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, &w), \n               \"Width not set in TIFF\\n\");\n        int h;\n        assert(TIFFGetField(tiff, TIFFTAG_IMAGELENGTH, &h), \n               \"Height not set in tiff\\n\");\n        unsigned short c;\n        assert(TIFFGetField(tiff, TIFFTAG_SAMPLESPERPIXEL, &c),\n               \"Number of channels not set in tiff\\n\");\n\n        unsigned short bitsPerSample;\n        assert(TIFFGetField(tiff, TIFFTAG_BITSPERSAMPLE, &bitsPerSample),\n               \"Bits per sample not set in TIFF\\n\");\n\n        unsigned short sampleFormat;\n        if (!TIFFGetField(tiff, TIFFTAG_SAMPLEFORMAT, &sampleFormat)) {\n            //printf(\"WARNING: couldn't find sample format in tiff, assuming %i bit unsigned integers\\n\", bitsPerSample);\n            sampleFormat = SAMPLEFORMAT_UINT;\n        }\n\n        Image im(w, h, 1, c);\n        int bytesPerSample = bitsPerSample / 8;\n\n        assert(im.channels * im.width * bytesPerSample == TIFFScanlineSize(tiff), \n               \"Unsupported scanline format in TIFF file, might be stored in tiles or strips.\\n\");\n\n        if (bytesPerSample == 1 && sampleFormat == SAMPLEFORMAT_UINT) {        \n            readTiff<unsigned char>(im, tiff, 0x000000ff);\n        } else if (bytesPerSample == 1 && sampleFormat == SAMPLEFORMAT_INT) {\n            readTiff<char>(im, tiff, 0x000000ff);\n        } else if (bytesPerSample == 2 && sampleFormat == SAMPLEFORMAT_UINT) {\n            readTiff<unsigned short>(im, tiff, 0x0000ffff);\n        } else if (bytesPerSample == 2 && sampleFormat == SAMPLEFORMAT_INT) {\n            readTiff<short>(im, tiff, 0x0000ffff);\n        #ifndef NO_OPENEXR\n        } else if (bytesPerSample == 2 && sampleFormat == SAMPLEFORMAT_IEEEFP) {\n            readTiff<half>(im, tiff, 1);\n        #endif\n        } else if (bytesPerSample == 4 && sampleFormat == SAMPLEFORMAT_UINT) {\n            readTiff<unsigned int>(im, tiff, 0xffffffff);\n        } else if (bytesPerSample == 4 && sampleFormat == SAMPLEFORMAT_INT) {\n            readTiff<int>(im, tiff, 0xffffffff);\n        } else if (bytesPerSample == 4 && sampleFormat == SAMPLEFORMAT_IEEEFP) {\n            readTiff<float>(im, tiff, 1);\n        } else if (bytesPerSample == 8 && sampleFormat == SAMPLEFORMAT_IEEEFP) {\n            readTiff<double>(im, tiff, 1);\n        } else if (sampleFormat == SAMPLEFORMAT_UINT || sampleFormat == SAMPLEFORMAT_INT) {\n            panic(\"%i bytes per sample for integers unsupported\\n\", bytesPerSample);\n        } else if (sampleFormat == SAMPLEFORMAT_IEEEFP) {\n            panic(\"%i bytes per sample for floats unsupported\\n\", bytesPerSample);\n        } else {\n            panic(\"Sample format unsupported (not int, unsigned int, or float)\\n\");\n        }\n\n        TIFFClose(tiff);\n\n        return im;\n    }",
    "void save(Window im, string filename, string type) {\n        // Open 16-bit TIFF file for writing\n        TIFF *tiff = TIFFOpen(filename.c_str(), \"w\");\n        assert(tiff, \"Could not open file %s\\n\", filename.c_str());\n\n        if (type == \"\") {\n            type = \"uint16\";\n            printf(\"WARNING: type not specified, assuming 16 bit unsigned int\\n\");\n        }\n\n        assert(im.frames == 1, \"Can only save single frame tiffs\\n\");\n        \n        TIFFSetField(tiff, TIFFTAG_SAMPLESPERPIXEL, im.channels);\n        TIFFSetField(tiff, TIFFTAG_IMAGEWIDTH, im.width);\n        TIFFSetField(tiff, TIFFTAG_IMAGELENGTH, im.height);\n\n        if (im.channels == 1) TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK); // grayscale, black is 0\n        else if (im.channels == 3) TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n        else {\n            printf(\"WARNING: Image is neither 1 channel nor 3 channels, so cannot set a valid photometric interpretation.\\n\");\n        }\n        TIFFSetField(tiff, TIFFTAG_ROWSPERSTRIP, 1L);\n        TIFFSetField(tiff, TIFFTAG_XRESOLUTION, 1.0);\n        TIFFSetField(tiff, TIFFTAG_YRESOLUTION, 1.0);\n        TIFFSetField(tiff, TIFFTAG_RESOLUTIONUNIT, 1);\n        TIFFSetField(tiff, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n        TIFFSetField(tiff, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n        TIFFSetField(tiff, TIFFTAG_ORIENTATION, (int)ORIENTATION_TOPLEFT);\n\n        if (type == \"int8\" || type == \"char\") {\n            TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 8);\n            TIFFSetField(tiff, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_INT);\n            writeTiff<char>(im, tiff, 0x000000ff);\n        } else if (type == \"uint8\" || type == \"unsigned char\") {\n            TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 8);\n            TIFFSetField(tiff, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT);\n            writeTiff<unsigned char>(im, tiff, 0x000000ff);\n        } else if (type == \"int16\" || type == \"short\") {\n            TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 16);\n            TIFFSetField(tiff, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_INT);\n            writeTiff<short>(im, tiff, 0x0000ffff);\n        } else if (type == \"uint16\" || type == \"unsigned short\") {\n            TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 16);\n            TIFFSetField(tiff, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT);\n            writeTiff<unsigned short>(im, tiff, 0x0000ffff);\n        #ifndef NO_OPENEXR\n        } else if (type == \"float16\" || type == \"half\") {\n            TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 16);\n            TIFFSetField(tiff, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);\n            writeTiff<half>(im, tiff, 1);\n        #endif\n        } else if (type == \"int32\" || type == \"int\") {\n            TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 32);\n            TIFFSetField(tiff, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_INT);\n            writeTiff<int>(im, tiff, 0xffffffff);\n        } else if (type == \"uint32\" || type == \"unsigned int\") {\n            TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 32);\n            TIFFSetField(tiff, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT);\n            writeTiff<unsigned int>(im, tiff, 0xffffffff);\n        } else if (type == \"float32\" || type == \"float\") {\n            TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 32);\n            TIFFSetField(tiff, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);\n            writeTiff<float>(im, tiff, 1);\n        } else if (type == \"float64\" || type == \"double\") {\n            TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 64);\n            TIFFSetField(tiff, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);\n            writeTiff<double>(im, tiff, 1);\n        } else {\n            panic(\"Unknown type %s\\n\", type.c_str());\n        }\n\n        // Close 16-bit TIFF file\n        TIFFClose(tiff);        \n    }",
    "int ReadTiff(const char * filename,\n  vector<unsigned char> * ptr,\n  int * w,\n  int * h,\n  int * depth)\n{\n  TIFF* tiff = TIFFOpen(filename, \"r\");\n  if (!tiff) {\n    std::cerr << \"Error: Couldn't open \" << filename << \" fopen returned 0\";\n    return 0;\n  }\n  uint16 bps, spp;\n\n  TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, w);\n  TIFFGetField(tiff, TIFFTAG_IMAGELENGTH, h);\n  TIFFGetField(tiff, TIFFTAG_BITSPERSAMPLE, &bps);\n  TIFFGetField(tiff, TIFFTAG_SAMPLESPERPIXEL, &spp);\n  *depth = bps * spp / 8;\n\n  ptr->resize((*h)*(*w)*(*depth));\n\n  if (*depth==4) {\n    if (ptr != NULL) {\n      if (!TIFFReadRGBAImageOriented(tiff, *w, *h, (uint32*)&((*ptr)[0]), ORIENTATION_TOPLEFT, 0)) {\n        TIFFClose(tiff);\n        return 0;\n      }\n    }\n  } else {\n    for (size_t i=0; i<TIFFNumberOfStrips(tiff); ++i) {\n      if (TIFFReadEncodedStrip(tiff, i, ((uint8*)&((*ptr)[0]))+i*TIFFStripSize(tiff),(tsize_t)-1) ==\n        std::numeric_limits<tsize_t>::max()) {\n        TIFFClose(tiff);\n        return 0;\n      }\n    }\n  }\n  TIFFClose(tiff);\n  return 1;\n}",
    "int WriteTiff(const char * filename,\n  const vector<unsigned char> & ptr,\n  int w,\n  int h,\n  int depth)\n{\n  TIFF* tiff = TIFFOpen(filename, \"w\");\n  if (!tiff) {\n    std::cerr << \"Error: Couldn't open \" << filename << \" fopen returned 0\";\n    return 0;\n  }\n  TIFFSetField(tiff, TIFFTAG_IMAGEWIDTH, w);\n  TIFFSetField(tiff, TIFFTAG_IMAGELENGTH, h);\n  TIFFSetField(tiff, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n  TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n  TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 8);\n  TIFFSetField(tiff, TIFFTAG_SAMPLESPERPIXEL, depth);\n  TIFFSetField(tiff, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n  TIFFSetField(tiff, TIFFTAG_COMPRESSION,COMPRESSION_NONE);\n  TIFFSetField(tiff, TIFFTAG_ROWSPERSTRIP, 16);\n  for (uint32 y=0; y < h ; ++y) {\n    if (TIFFWriteScanline(tiff,(tdata_t)(((uint8*)(&ptr[0]))+depth*w*y),y)<0) {\n      TIFFClose(tiff);\n      return 0;\n    }\n  }\n  TIFFClose(tiff);\n  return 1;\n}",
    "void screenCapture(int zoom)\n    {\n        ptr<FrameBuffer> fb = FrameBuffer::getDefault();\n\n        vec4<GLint> vp = fb->getViewport();\n        int w = vp.z;\n        int h = vp.w;\n        char *buf = new char[w * h * 3];\n        char *ibuf = new char[w * h * 3];\n\n        char name[256];\n        char stime[256];\n        Timer::getDateTimeString(stime, 256);\n        sprintf(name, \"image.%s.tiff\", stime);\n\n        TIFF* f = TIFFOpen(name, \"wb\");\n        TIFFSetField(f, TIFFTAG_IMAGEWIDTH, w * zoom);\n        TIFFSetField(f, TIFFTAG_IMAGELENGTH, h * zoom);\n        if (zoom > 1) {\n            TIFFSetField(f, TIFFTAG_TILEWIDTH, w);\n            TIFFSetField(f, TIFFTAG_TILELENGTH, h);\n        }\n        TIFFSetField(f, TIFFTAG_SAMPLESPERPIXEL, 3);\n        TIFFSetField(f, TIFFTAG_BITSPERSAMPLE, 8);\n        TIFFSetField(f, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);\n        TIFFSetField(f, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n        TIFFSetField(f, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n        TIFFSetField(f, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n\n        if (zoom == 1) {\n            fb->readPixels(0, 0, w, h, RGB, UNSIGNED_BYTE, Buffer::Parameters(), CPUBuffer(buf));\n            for (int l = 0; l < h; ++l) {\n                memcpy(ibuf + 3 * (h - 1 - l) * w, buf + 3 * l * w, 3 * w);\n            }\n            TIFFWriteEncodedStrip(f, 0, ibuf, w * h * 3);\n        } else {\n            for (int j = 0; j < zoom; ++j) {\n                float bottom = -1.0f + j * 2.0f / zoom;\n                float top = -1.0f + (j + 1) * 2.0f / zoom;\n                for (int i = 0; i < zoom; ++i) {\n                    float left = -1.0f + i * 2.0f / zoom;\n                    float right = -1.0f + (i + 1) * 2.0f / zoom;\n                    getViewController()->setProjection(0.0f, 0.0f, vec4f(left, right, bottom, top));\n                    fb->clear(true, false, true);\n                    scene->update(t, 0.0);\n                    scene->draw();\n\n                    fb->readPixels(0, 0, w, h, RGB, UNSIGNED_BYTE, Buffer::Parameters(), CPUBuffer(buf));\n                    for (int l = 0; l < h; ++l) {\n                        memcpy(ibuf + 3 * (h - 1 - l) * w, buf + 3 * l * w, 3 * w);\n                    }\n                    TIFFWriteTile(f, ibuf, i * w, (zoom - 1 - j) * h, 0, 0);\n\n                    GlfwWindow::redisplay(0.0, 0.0);\n                }\n            }\n        }\n\n        TIFFClose(f);\n        delete[] buf;\n        delete[] ibuf;\n    }",
    "void ResidualProducer::readTile(int level, int tx, int ty,\n        unsigned char* compressedData, unsigned char *uncompressedData,\n        float *tile, float *result)\n{\n    int tilesize = getTileSize(level) + 5;\n\n    if ((int) name.size() == 0) {\n        if (tile != NULL) {\n            for (int j = 0; j < tilesize; ++j) {\n                for (int i = 0; i < tilesize; ++i) {\n                    result[i + j * (tileSize + 5)] = tile[i + j * (tileSize + 5)];\n                }\n            }\n        } else {\n            for (int j = 0; j < tilesize; ++j) {\n                for (int i = 0; i < tilesize; ++i) {\n                    result[i + j * (tileSize + 5)] = 0.f;\n                }\n            }\n        }\n    } else {\n        int tileid = getTileId(level, tx, ty);\n        int fsize = offsets[2 * tileid + 1] - offsets[2 * tileid];\n        assert(fsize < (tileSize + 5) * (tileSize + 5) * 2);\n\n#ifdef SINGLE_FILE\n        pthread_mutex_lock((pthread_mutex_t*) mutex);\n        fseek64(tileFile, header + offsets[2 * tileid], SEEK_SET);\n        fread(compressedData, fsize, 1, tileFile);\n        pthread_mutex_unlock((pthread_mutex_t*) mutex);\n#else\n        FILE *file;\n        fopen(&file, name.c_str(), \"rb\");\n        fseek64(file, header + offsets[2 * tileid], SEEK_SET);\n        fread(compressedData, fsize, 1, file);\n        fclose(file);\n#endif\n        /*ifstream fs(name.c_str(), ios::binary);\n        fs.seekg(header + offsets[2 * tileid], ios::beg);\n        fs.read((char*) compressedData, fsize);\n        fs.close();*/\n\n        // TODO compare perfs FILE vs ifstream vs mmap\n\n        mfs_file fd;\n        mfs_open(compressedData, fsize, (char *)\"r\", &fd);\n        TIFF* tf = TIFFClientOpen(\"name\", \"r\", &fd,\n            (TIFFReadWriteProc) mfs_read, (TIFFReadWriteProc) mfs_write, (TIFFSeekProc) mfs_lseek,\n            (TIFFCloseProc) mfs_close, (TIFFSizeProc) mfs_size, (TIFFMapFileProc) mfs_map,\n            (TIFFUnmapFileProc) mfs_unmap);\n        TIFFReadEncodedStrip(tf, 0, uncompressedData, (tsize_t) -1);\n        TIFFClose(tf);\n\n        if (tile != NULL) {\n            for (int j = 0; j < tilesize; ++j) {\n                for (int i = 0; i < tilesize; ++i) {\n                    int off = 2 * (i + j * tilesize);\n                    int toff = i + j * (tileSize + 5);\n                    short z = short(uncompressedData[off + 1]) << 8 | short(uncompressedData[off]);\n                    result[toff] = tile[toff] + z * scale;\n                }\n            }\n        } else {\n            for (int j = 0; j < tilesize; ++j) {\n                for (int i = 0; i < tilesize; ++i) {\n                    int off = 2 * (i + j * tilesize);\n                    short z = short(uncompressedData[off + 1]) << 8 | short(uncompressedData[off]);\n                    result[i + j * (tileSize + 5)] = z * scale;\n                }\n            }\n        }\n    }\n}",
    "bool OrthoCPUProducer::doCreateTile(int level, int tx, int ty, TileStorage::Slot *data)\n{\n    if (Logger::DEBUG_LOGGER != NULL) {\n        ostringstream oss;\n        oss << \"CPU tile \" << getId() << \" \" << level << \" \" << tx << \" \" << ty;\n        Logger::DEBUG_LOGGER->log(\"ORTHO\", oss.str());\n    }\n\n    CPUTileStorage<unsigned char>::CPUSlot *cpuData = dynamic_cast<CPUTileStorage<unsigned char>::CPUSlot*>(data);\n    assert(cpuData != NULL);\n\n    int tileid = getTileId(level, tx, ty);\n\n    if ((int) name.size() == 0) {\n        for (int i = 0; i < cpuData->size; i++) {\n            cpuData->data[i] = 0;\n        }\n    } else {\n        assert(dynamic_cast<CPUTileStorage<unsigned char>*>(cpuData->getOwner())->getChannels() == channels);\n        assert(cpuData->getOwner()->getTileSize() == tileSize + 2*border);\n        assert(level <= maxLevel);\n\n        unsigned char *compressedData = (unsigned char*) pthread_getspecific(*((pthread_key_t*) key));\n        if (compressedData == NULL) {\n            compressedData = new unsigned char[MAX_TILE_SIZE * MAX_TILE_SIZE * 4 * 2];\n            pthread_setspecific(*((pthread_key_t*) key), compressedData);\n        }\n\n        int fsize = (int) (offsets[2 * tileid + 1] - offsets[2 * tileid]);\n        assert(fsize < (tileSize + 2*border) * (tileSize + 2*border) * channels * 2);\n\n        if (dxt) {\n    #ifdef SINGLE_FILE\n            pthread_mutex_lock((pthread_mutex_t*) mutex);\n            fseek64(tileFile, header + offsets[2 * tileid], SEEK_SET);\n            fread(cpuData->data, fsize, 1, tileFile);\n            pthread_mutex_unlock((pthread_mutex_t*) mutex);\n    #else\n            FILE *file;\n            fopen(&file, name.c_str(), \"rb\");\n            fseek64(file, header + offsets[2 * tileid], SEEK_SET);\n            fread(cpuData->data, fsize, 1, file);\n            fclose(file);\n            /*ifstream fs(name.c_str(), ios::binary);\n            fs.seekg(header + offsets[2 * tileid], ios::beg);\n            fs.read((char*) cpuData->data, fsize);\n            fs.close();*/\n    #endif\n            cpuData->size = fsize;\n        } else {\n            unsigned char* srcData = compressedData;\n    #ifdef SINGLE_FILE\n            pthread_mutex_lock((pthread_mutex_t*) mutex);\n            fseek64(tileFile, header + offsets[2 * tileid], SEEK_SET);\n            fread(compressedData, fsize, 1, tileFile);\n            pthread_mutex_unlock((pthread_mutex_t*) mutex);\n    #else\n            FILE *file;\n            fopen(&file, name.c_str(), \"rb\");\n            fseek64(file, header + offsets[2 * tileid], SEEK_SET);\n            fread(compressedData, fsize, 1, file);\n            fclose(file);\n            /*ifstream fs(name.c_str(), ios::binary);\n            fs.seekg(header + offsets[2 * tileid], ios::beg);\n            fs.read((char*) src, fsize);\n            fs.close();*/\n    #endif\n\n            mfs_file fd;\n            mfs_open(srcData, fsize, (char *)\"r\", &fd);\n            TIFF* tf = TIFFClientOpen(\"name\", \"r\", &fd,\n                (TIFFReadWriteProc) mfs_read, (TIFFReadWriteProc) mfs_write, (TIFFSeekProc) mfs_lseek,\n                (TIFFCloseProc) mfs_close, (TIFFSizeProc) mfs_size, (TIFFMapFileProc) mfs_map,\n                (TIFFUnmapFileProc) mfs_unmap);\n            TIFFReadEncodedStrip(tf, 0, cpuData->data, (tsize_t) -1);\n            TIFFClose(tf);\n        }\n    }\n\n    return true;\n}",
    "unsigned char* ColorMipmap::readTile(int tx, int ty)\n{\n    char buf[256];\n    unsigned char *data = new unsigned char[(tileSize + 2*border) * (tileSize + 2*border) * channels];\n    int nTiles = 1 << currentLevel;\n    int nTilesPerFile = min(nTiles, 16);\n    int dx = tx / nTilesPerFile;\n    int dy = ty / nTilesPerFile;\n    tx = tx % nTilesPerFile;\n    ty = ty % nTilesPerFile;\n    sprintf(buf, \"%s/%.2d-%.4d-%.4d.tiff\", cache.c_str(), currentLevel, dx, dy);\n    TIFF* f = TIFFOpen(buf, \"rb\");\n    TIFFSetDirectory(f, tx + ty * nTilesPerFile);\n    TIFFReadEncodedStrip(f, 0, data, (tsize_t) -1);\n    TIFFClose(f);\n    return data;\n}",
    "void ColorMipmap::buildBaseLevelTiles()\n{\n    char buf[256];\n    int nTiles = baseLevelSize / tileSize;\n    int nTilesPerFile = min(nTiles, 16);\n\n    printf(\"Build mipmap level %d...\\n\", maxLevel);\n\n    for (int dy = 0; dy < nTiles / nTilesPerFile; ++dy) {\n\t\tfor (int dx = 0; dx < nTiles / nTilesPerFile; ++dx) {\n\t   \t    sprintf(buf, \"%s/%.2d-%.4d-%.4d.tiff\", cache.c_str(), maxLevel, dx, dy);\n\t   \t    if (flog(buf)) {\n                TIFF* f = TIFFOpen(buf, \"wb\");\n                for (int ny = 0; ny < nTilesPerFile; ++ny) {\n                    for (int nx = 0; nx < nTilesPerFile; ++nx) {\n                        int tx = nx + dx * nTilesPerFile;\n                        int ty = ny + dy * nTilesPerFile;\n                        buildBaseLevelTile(tx, ty, f);\n                    }\n                }\n                TIFFClose(f);\n\t   \t    }\n\t\t}\n\t}\n}",
    "void ColorMipmap::buildMipmapLevel(int level)\n{\n    char buf[256];\n    int nTiles = 1 << level;\n    int nTilesPerFile = min(nTiles, 16);\n\n    printf(\"Build mipmap level %d...\\n\", level);\n\n    currentLevel = level + 1;\n    reset(tileSize << currentLevel, tileSize << currentLevel, tileSize);\n\n    for (int dy = 0; dy < nTiles / nTilesPerFile; ++dy) {\n        for (int dx = 0; dx < nTiles / nTilesPerFile; ++dx) {\n            sprintf(buf, \"%s/%.2d-%.4d-%.4d.tiff\", cache.c_str(), level, dx, dy);\n            if (flog(buf)) {\n                TIFF* f = TIFFOpen(buf, \"wb\");\n                for (int ny = 0; ny < nTilesPerFile; ++ny) {\n                    for (int nx = 0; nx < nTilesPerFile; ++nx) {\n                        int tx = nx + dx * nTilesPerFile;\n                        int ty = ny + dy * nTilesPerFile;\n\n                        int off = 0;\n                        for (int j = -border; j < tileSize + border; ++j) {\n                            for (int i = -border; i < tileSize + border; ++i) {\n                                int ix = 2 * (tx * tileSize + i);\n                                int iy = 2 * (ty * tileSize + j);\n\n                                vec4f c1 = getTileColor(ix, iy);\n                                vec4f c2 = getTileColor(ix+1, iy);\n                                vec4f c3 = getTileColor(ix, iy+1);\n                                vec4f c4 = getTileColor(ix+1, iy+1);\n\n                                tile[off++] = int(roundf(l2r((r2l(c1.x)+r2l(c2.x)+r2l(c3.x)+r2l(c4.x))/4.0)));\n                                if (channels > 1) {\n                                    tile[off++] = int(roundf(l2r((r2l(c1.y)+r2l(c2.y)+r2l(c3.y)+r2l(c4.y))/4.0)));\n                                }\n                                if (channels > 2) {\n                                    tile[off++] = int(roundf(l2r((r2l(c1.z)+r2l(c2.z)+r2l(c3.z)+r2l(c4.z))/4.0)));\n                                }\n                                if (channels > 3) {\n                                    float w1 = max(2.0 * c1.w - 255.0, 0.0);\n                                    float n1 = max(255.0 - 2.0 * c1.w, 0.0);\n                                    float w2 = max(2.0 * c2.w - 255.0, 0.0);\n                                    float n2 = max(255.0 - 2.0 * c2.w, 0.0);\n                                    float w3 = max(2.0 * c3.w - 255.0, 0.0);\n                                    float n3 = max(255.0 - 2.0 * c3.w, 0.0);\n                                    float w4 = max(2.0 * c4.w - 255.0, 0.0);\n                                    float n4 = max(255.0 - 2.0 * c4.w, 0.0);\n                                    int w = int(roundf((w1 + w2 + w3 + w4) / 4));\n                                    int n = int(roundf((n1 + n2 + n3 + n4) / 4));\n                                    tile[off++] = 127 + w / 2 - n / 2;\n                                }\n                            }\n                        }\n\n                        TIFFSetField(f, TIFFTAG_IMAGEWIDTH, tileSize + 2*border);\n                        TIFFSetField(f, TIFFTAG_IMAGELENGTH, tileSize + 2*border);\n                        TIFFSetField(f, TIFFTAG_SAMPLESPERPIXEL, channels);\n                        TIFFSetField(f, TIFFTAG_BITSPERSAMPLE, 8);\n                        TIFFSetField(f, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);\n                        TIFFSetField(f, TIFFTAG_ORIENTATION, ORIENTATION_BOTLEFT);\n                        TIFFSetField(f, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n                        if (channels == 1) {\n                            TIFFSetField(f, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n                        } else {\n                            TIFFSetField(f, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n                        }\n                        TIFFWriteEncodedStrip(f, 0, tile, (tileSize + 2*border) * (tileSize + 2*border) * channels);\n                        TIFFWriteDirectory(f);\n                    }\n                }\n                TIFFClose(f);\n            }\n        }\n    }\n}",
    "void ColorMipmap::produceRawTile(int level, int tx, int ty)\n{\n    int nTiles = 1 << level;\n    int nTilesPerFile = min(nTiles, 16);\n    int dx = tx / nTilesPerFile;\n    int dy = ty / nTilesPerFile;\n    int x = tx % nTilesPerFile;\n    int y = ty % nTilesPerFile;\n    char buf[256];\n    sprintf(buf, \"%s/%.2d-%.4d-%.4d.tiff\", cache.c_str(), level, dx, dy);\n    TIFF* tf = TIFFOpen(buf, \"rb\");\n    TIFFSetDirectory(tf, x + y * nTilesPerFile);\n    TIFFReadEncodedStrip(tf, 0, tile, (tsize_t) -1);\n    TIFFClose(tf);\n}",
    "void ColorMipmap::produceTile(int level, int tx, int ty, long long *offset, long long *offsets, FILE *f)\n{\n    produceTile(level, tx, ty);\n\n    int tileid = tx + ty * (1 << level) + ((1 << (2 * level)) - 1) / 3;\n\n    bool isConstant;\n    int constantValue;\n    if (channels == 1) {\n        isConstant = true;\n        for (int i = 1; i < (tileSize + 2*border) * (tileSize + 2*border); ++i) {\n            if (tile[i] != tile[i - 1]) {\n                isConstant = false;\n                break;\n            }\n        }\n        constantValue = tile[0];\n    } else if (channels == 2) {\n        isConstant = true;\n        for (int i = 1; i < (tileSize + 2*border) * (tileSize + 2*border); ++i) {\n            if (tile[2*i] != tile[2*(i - 1)] || tile[2*i+1] != tile[2*(i - 1)+1]) {\n                isConstant = false;\n                break;\n            }\n        }\n        constantValue = (tile[0] << 8) | tile[1];\n    } else if (channels == 4) {\n        isConstant = true;\n        int *pixels = (int*) tile;\n        for (int i = 1; i < (tileSize + 2*border) * (tileSize + 2*border); ++i) {\n            if (pixels[i] != pixels[i - 1]) {\n                isConstant = false;\n                break;\n            }\n        }\n        constantValue = pixels[0];\n    } else {\n        isConstant = false;\n    }\n\n    map<int, int>::iterator it;\n    if (isConstant) {\n        it = constantTileIds.find(constantValue);\n    }\n    if (isConstant && it != constantTileIds.end()) {\n        int constantId = it->second;\n        offsets[2 * tileid] = offsets[2 * constantId];\n        offsets[2 * tileid + 1] = offsets[2 * constantId + 1];\n    } else {\n        int size;\n        if (dxt) {\n            if (channels == 4) {\n                CompressImageDXT5(tile, dxtTile, tileSize + 2*border, tileSize + 2*border, size);\n                fwrite(dxtTile, size, 1, f);\n            } else {\n                for (int i = 0; i < (tileSize + 2*border) * (tileSize + 2*border); ++i) {\n                    rgbaTile[4*i] = tile[i*channels];\n                    rgbaTile[4*i+1] = tile[i*channels+min(1, channels-1)];\n                    rgbaTile[4*i+2] = tile[i*channels+min(2, channels-1)];\n                    rgbaTile[4*i+3] = 255;\n                }\n                CompressImageDXT1(rgbaTile, dxtTile, tileSize + 2*border, tileSize + 2*border, size);\n                fwrite(dxtTile, size, 1, f);\n            }\n        } else {\n            mfs_file fd;\n            mfs_open(NULL, 0, (char*)\"w\", &fd);\n            TIFF* tf = TIFFClientOpen(\"\", (char*)\"w\", &fd,\n                (TIFFReadWriteProc) mfs_read, (TIFFReadWriteProc) mfs_write, (TIFFSeekProc) mfs_lseek,\n                (TIFFCloseProc) mfs_close, (TIFFSizeProc) mfs_size, (TIFFMapFileProc) mfs_map,\n                (TIFFUnmapFileProc) mfs_unmap);\n            TIFFSetField(tf, TIFFTAG_IMAGEWIDTH, tileSize + 2*border);\n            TIFFSetField(tf, TIFFTAG_IMAGELENGTH, tileSize + 2*border);\n            if (jpg && (tx > 0 && ty > 0 && tx < (1 << level) - 1 && ty < (1 << level) - 1)) {\n                TIFFSetField(tf, TIFFTAG_COMPRESSION, COMPRESSION_JPEG);\n                TIFFSetField(tf, TIFFTAG_JPEGQUALITY, jpg_quality);\n            } else {\n                TIFFSetField(tf, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);\n            }\n            TIFFSetField(tf, TIFFTAG_ORIENTATION, ORIENTATION_BOTLEFT);\n            TIFFSetField(tf, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n            if (channels == 1) {\n                TIFFSetField(tf, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n            } else {\n                TIFFSetField(tf, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n            }\n            TIFFSetField(tf, TIFFTAG_SAMPLESPERPIXEL, channels);\n            TIFFSetField(tf, TIFFTAG_BITSPERSAMPLE, 8);\n            TIFFWriteEncodedStrip(tf, 0, tile, (tileSize + 2*border) * (tileSize + 2*border) * channels);\n            TIFFClose(tf);\n\n            fwrite(fd.buf, fd.buf_size, 1, f);\n            free(fd.buf);\n            size = fd.buf_size;\n        }\n        offsets[2 * tileid] = *offset;\n        *offset += size;\n        offsets[2 * tileid + 1] = *offset;\n    }\n\n    if (isConstant && it == constantTileIds.end()) {\n        constantTileIds[constantValue] = tileid;\n    }\n}",
    "void ColorMipmap::readInputTile(int level, int tx, int ty)\n{\n    int tileid = tx + ty * (1 << level) + ((1 << (2 * level)) - 1) / 3;\n\n    int fsize = (int) (ioffsets[2 * tileid + 1] - ioffsets[2 * tileid]);\n    assert(fsize < tileSize * tileSize * 8);\n\n    fseek64(in, iheader + ioffsets[2 * tileid], SEEK_SET);\n    fread(compressedInputTile, fsize, 1, in);\n\n    mfs_file fd;\n    mfs_open(compressedInputTile, fsize, (char *)\"r\", &fd);\n    TIFF* tf = TIFFClientOpen(\"name\", \"r\", &fd,\n        (TIFFReadWriteProc) mfs_read, (TIFFReadWriteProc) mfs_write, (TIFFSeekProc) mfs_lseek,\n        (TIFFCloseProc) mfs_close, (TIFFSizeProc) mfs_size, (TIFFMapFileProc) mfs_map,\n        (TIFFUnmapFileProc) mfs_unmap);\n    TIFFReadEncodedStrip(tf, 0, inputTile, (tsize_t) -1);\n    TIFFClose(tf);\n}",
    "void ColorMipmap::convertTile(int level, int tx, int ty, unsigned char *parent, long long *offset, long long *offsets, FILE *f)\n{\n    convertTile(level, tx, ty, parent);\n\n    int tileid = tx + ty * (1 << level) + ((1 << (2 * level)) - 1) / 3;\n\n    bool isConstant;\n    int constantValue;\n    if (channels == 1) {\n        isConstant = true;\n        for (int i = 1; i < tileWidth * tileWidth; ++i) {\n            if (tile[i] != tile[i - 1]) {\n                isConstant = false;\n                break;\n            }\n        }\n        constantValue = tile[0];\n    } else if (channels == 2) {\n        isConstant = true;\n        for (int i = 1; i < tileWidth * tileWidth; ++i) {\n            if (tile[2*i] != tile[2*(i - 1)] || tile[2*i+1] != tile[2*(i - 1)+1]) {\n                isConstant = false;\n                break;\n            }\n        }\n        constantValue = (tile[0] << 8) | tile[1];\n    } else if (channels == 3) {\n        isConstant = true;\n        for (int i = 1; i < tileWidth * tileWidth; ++i) {\n            if (tile[3*i] != tile[3*(i - 1)] || tile[3*i+1] != tile[3*(i - 1)+1] || tile[3*i+2] != tile[3*(i - 1)+2]) {\n                isConstant = false;\n                break;\n            }\n        }\n        constantValue = (tile[0] << 16) | (tile[1] << 8) | tile[2];\n    } else {\n        isConstant = true;\n        int *pixels = (int*) tile;\n        for (int i = 1; i < tileWidth * tileWidth; ++i) {\n            if (pixels[i] != pixels[i - 1]) {\n                isConstant = false;\n                break;\n            }\n        }\n        constantValue = pixels[0];\n    }\n\n    map<int, int>::iterator it;\n    if (isConstant) {\n        it = constantTileIds.find(constantValue);\n    }\n    if (isConstant && it != constantTileIds.end()) {\n        int constantId = it->second;\n        offsets[2 * tileid] = offsets[2 * constantId];\n        offsets[2 * tileid + 1] = offsets[2 * constantId + 1];\n    } else {\n        int size;\n\n        mfs_file fd;\n        mfs_open(NULL, 0, (char*)\"w\", &fd);\n        TIFF* tf = TIFFClientOpen(\"\", \"w\", &fd,\n            (TIFFReadWriteProc) mfs_read, (TIFFReadWriteProc) mfs_write, (TIFFSeekProc) mfs_lseek,\n            (TIFFCloseProc) mfs_close, (TIFFSizeProc) mfs_size, (TIFFMapFileProc) mfs_map,\n            (TIFFUnmapFileProc) mfs_unmap);\n        TIFFSetField(tf, TIFFTAG_IMAGEWIDTH, tileWidth);\n        TIFFSetField(tf, TIFFTAG_IMAGELENGTH, tileWidth);\n        if (oJpg) {\n            TIFFSetField(tf, TIFFTAG_COMPRESSION, COMPRESSION_JPEG);\n            TIFFSetField(tf, TIFFTAG_JPEGQUALITY, oJpg_quality);\n        } else {\n            TIFFSetField(tf, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);\n        }\n        TIFFSetField(tf, TIFFTAG_ORIENTATION, ORIENTATION_BOTLEFT);\n        TIFFSetField(tf, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n        if (channels == 1) {\n            TIFFSetField(tf, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n        } else {\n            TIFFSetField(tf, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n        }\n        TIFFSetField(tf, TIFFTAG_SAMPLESPERPIXEL, channels);\n        TIFFSetField(tf, TIFFTAG_BITSPERSAMPLE, 8);\n        TIFFWriteEncodedStrip(tf, 0, tile, tileWidth * tileWidth * channels);\n        TIFFClose(tf);\n\n        if (oJpg) {\n            // uncompress back into 'tile'\n            mfs_open(fd.buf, fd.buf_size, (char *) \"r\", &fd);\n            tf = TIFFClientOpen(\"name\", \"r\", &fd,\n                (TIFFReadWriteProc) mfs_read, (TIFFReadWriteProc) mfs_write, (TIFFSeekProc) mfs_lseek,\n                (TIFFCloseProc) mfs_close, (TIFFSizeProc) mfs_size, (TIFFMapFileProc) mfs_map,\n                (TIFFUnmapFileProc) mfs_unmap);\n            TIFFReadEncodedStrip(tf, 0, tile, (tsize_t) -1);\n            TIFFClose(tf);\n        }\n\n        fwrite(fd.buf, fd.buf_size, 1, f);\n        free(fd.buf);\n        size = fd.buf_size;\n\n        offsets[2 * tileid] = *offset;\n        *offset += size;\n        offsets[2 * tileid + 1] = *offset;\n    }\n\n    if (isConstant && it == constantTileIds.end()) {\n        constantTileIds[constantValue] = tileid;\n    }\n\n    // recomputes inputTile with uncompressed quantified residuals (lossy process)\n    if (level == 0) {\n        for (int i = 0; i < tileWidth * tileWidth * channels; ++i) {\n            inputTile[i] = tile[i];\n        }\n    } else {\n        int masks[4][4] = {\n            { 1, 3, 3, 9 },\n            { 3, 1, 9, 3 },\n            { 3, 9, 1, 3 },\n            { 9, 3, 3, 1 }\n        };\n        int rx = (tx % 2) * tileSize / 2;\n        int ry = (ty % 2) * tileSize / 2;\n        for (int y = 0; y < tileWidth; ++y) {\n            int py = (y + 1) / 2 + ry;\n            for (int x = 0; x < tileWidth; ++x) {\n                int px = (x + 1) / 2 + rx;\n                int *m = masks[(x % 2) + 2 * (y % 2)];\n                for (int c = 0; c < channels; ++c) {\n                    int p0 = parent[(px + py * tileWidth) * channels + c];\n                    int p1 = parent[(px + 1 + py * tileWidth) * channels + c];\n                    int p2 = parent[(px + (py + 1) * tileWidth) * channels + c];\n                    int p3 = parent[(px + 1 + (py + 1) * tileWidth) * channels + c];\n                    int off = (x + y * tileWidth) * channels + c;\n                    int r = (tile[off] - 128) * RESIDUAL_STEPS;\n                    int v = (m[0] * p0 + m[1] * p1 + m[2] * p2 + m[3] * p3) / 16 + r;\n                    inputTile[off] = max(0, min(255, v));\n                }\n            }\n        }\n    }\n}",
    "void redisplay(double t, double dt)\n    {\n        printf(\"COMPUTING VIEWS...\\n\");\n        ptr<FrameBuffer> fb = FrameBuffer::getDefault();\n        fb->setPolygonMode(FILL, FILL);\n        fb->setMultisample(true);\n        fb->setSampleAlpha(true, true);\n        fb->setViewport(vec4<GLint>(0, 0, w, w));\n        fb->setDepthTest(true, LESS);\n\n        int total = 2 * (n * n + n) + 1;\n        unsigned char *buf = new unsigned char[w * w * total * 4];\n        int current = 0;\n\n        const float zmax = 1;\n        const float zmin = -1;\n\n        FILE *f;\n        char name[256];\n        sprintf(name, \"%s/views.xml\", output);\n        fopen(&f, name, \"w\");\n\n        for (int i = -n; i <= n; ++i) {\n            for (int j = -n + abs(i); j <= n - abs(i); ++j) {\n\n                printf(\"VIEW %d of %d\\n\", current, total);\n\n                float x = (i + j) / float(n);\n                float y = (j - i) / float(n);\n                float angle = 90.0 - std::max(fabs(x),fabs(y)) * 90.0;\n                float alpha = x == 0.0 && y == 0.0 ? 0.0 : atan2(y, x) / M_PI * 180.0;\n\n                mat4f cameraToWorld = mat4f::rotatex(90) * mat4f::rotatex(-angle);\n                mat4f worldToCamera = cameraToWorld.inverse();\n\n                box3f b;\n                b = b.enlarge((worldToCamera * vec4f(-1.0, -1.0, zmin, 1.0)).xyz());\n                b = b.enlarge((worldToCamera * vec4f(+1.0, -1.0, zmin, 1.0)).xyz());\n                b = b.enlarge((worldToCamera * vec4f(-1.0, +1.0, zmin, 1.0)).xyz());\n                b = b.enlarge((worldToCamera * vec4f(+1.0, +1.0, zmin, 1.0)).xyz());\n                b = b.enlarge((worldToCamera * vec4f(-1.0, -1.0, zmax, 1.0)).xyz());\n                b = b.enlarge((worldToCamera * vec4f(+1.0, -1.0, zmax, 1.0)).xyz());\n                b = b.enlarge((worldToCamera * vec4f(-1.0, +1.0, zmax, 1.0)).xyz());\n                b = b.enlarge((worldToCamera * vec4f(+1.0, +1.0, zmax, 1.0)).xyz());\n                mat4f c2s = mat4f::orthoProjection(b.xmax, b.xmin, b.ymax, b.ymin, -2.0 * b.zmax, -2.0 * b.zmin);\n                mat4f w2s = c2s * worldToCamera * mat4f::rotatez(-90.0 - alpha);\n                vec3f dir = ((mat4f::rotatez(90.0 + alpha) * cameraToWorld) * vec4f(0.0, 0.0, 1.0, 0.0)).xyz();\n\n                p->getUniformMatrix4f(\"worldToScreen\")->setMatrix(w2s);\n                p->getUniform3f(\"dir\")->set(dir);\n\n                fb->clear(true, false, true);\n\n                fb->setColorMask(true, false, true, true);\n                vector<TreeMesh>::iterator k = tree.begin();\n                while (k != tree.end()) {\n                    p->getUniformSampler(\"colorSampler\")->set(k->texture);\n                    fb->draw(p, *(k->mesh));\n                    k++;\n                }\n\n                fb->setColorMask(false, true, false, false);\n                fb->setDepthTest(true, GREATER);\n                fb->setClearDepth(0.0);\n                fb->clear(false, false, true);\n                k = tree.begin();\n                while (k != tree.end()) {\n                    p->getUniformSampler(\"colorSampler\")->set(k->texture);\n                    fb->draw(p, *(k->mesh));\n                    k++;\n                }\n\n                fb->setClearDepth(1.0);\n                fb->setDepthTest(true, LESS);\n                fb->setColorMask(true, true, true, true);\n\n                int view = i * (1 - abs(i)) + j + 2 * n * i + n * (n + 1);\n                assert(view == current);\n                current++;\n                fprintf(f, \"    <uniformMatrix3f name=\\\"views[%d]\\\" value=\\\"%f,%f,%f,%f,%f,%f,%f,%f,%f\\\"/>\\n\",\n                       view,\n                       w2s[0][0], w2s[0][1], w2s[0][2],\n                       w2s[1][0], w2s[1][1], w2s[1][2],\n                       w2s[2][0], w2s[2][1], w2s[2][2]);\n\n                fb->readPixels(0, 0, w, w, RGBA, UNSIGNED_BYTE, Buffer::Parameters(), CPUBuffer(buf + view * w * w * 4));\n                clearBorder(buf + view * w * w *4);\n            }\n        }\n        fclose(f);\n\n        sprintf(name, \"%s/treeViews.tiff\", output);\n        TIFF* out = TIFFOpen(name, \"wb\");\n        TIFFSetField(out, TIFFTAG_IMAGEWIDTH, w);\n        TIFFSetField(out, TIFFTAG_IMAGELENGTH, w * total);\n        TIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, 4);\n        TIFFSetField(out, TIFFTAG_BITSPERSAMPLE, 8);\n        TIFFSetField(out, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);\n        TIFFSetField(out, TIFFTAG_ORIENTATION, ORIENTATION_BOTLEFT);\n        TIFFSetField(out, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n        TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n        TIFFWriteEncodedStrip(out, 0, buf, w * w * total * 4);\n        TIFFClose(out);\n        delete[] buf;\n\n        printf(\"VIEWS DONE.\\n\");\n        ::exit(0);\n    }",
    "void preprocessMultisample(const char *output)\n{\n    computeCombinations();\n    int w = 9;\n    int h = 70;\n    unsigned char *buf = new unsigned char[w*h];\n    for (int i = 0; i < w; ++i) {\n        for (int j = 0; j < h; ++j) {\n            int v = getCombination(8, i, j);\n            buf[i + j * w] = v;\n        }\n    }\n\n    TIFF* out = TIFFOpen(output, \"wb\");\n    TIFFSetField(out, TIFFTAG_IMAGEWIDTH, w);\n    TIFFSetField(out, TIFFTAG_IMAGELENGTH, h);\n    TIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, 1);\n    TIFFSetField(out, TIFFTAG_BITSPERSAMPLE, 8);\n    TIFFSetField(out, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);\n    TIFFSetField(out, TIFFTAG_ORIENTATION, ORIENTATION_BOTLEFT);\n    TIFFSetField(out, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n    TIFFWriteEncodedStrip(out, 0, buf, w * h);\n    TIFFClose(out);\n}",
    "unsigned char* HeightMipmap::readTile(int tx, int ty)\n{\n    char buf[256];\n    unsigned char *data = new unsigned char[(tileSize + 5) * (tileSize + 5) * 2];\n    int nTiles = max(1, (baseLevelSize / tileSize) >> (maxLevel - currentLevel));\n    int nTilesPerFile = min(nTiles, 16);\n    int dx = tx / nTilesPerFile;\n    int dy = ty / nTilesPerFile;\n    tx = tx % nTilesPerFile;\n    ty = ty % nTilesPerFile;\n    sprintf(buf, \"%s/%.2d-%.4d-%.4d.tiff\", cache.c_str(), currentLevel, dx, dy);\n    TIFF* f = TIFFOpen(buf, \"rb\");\n    TIFFSetDirectory(f, tx + ty * nTilesPerFile);\n    TIFFReadEncodedStrip(f, 0, data, (tsize_t) -1);\n    TIFFClose(f);\n    return data;\n}",
    "void HeightMipmap::buildMipmapLevel(int level)\n{\n    char buf[256];\n    int nTiles = max(1, (baseLevelSize / tileSize) >> (maxLevel - level));\n    int nTilesPerFile = min(nTiles, 16);\n\n    printf(\"Build mipmap level %d...\\n\", level);\n\n    currentLevel = level + 1;\n    reset(baseLevelSize >> (maxLevel - currentLevel), baseLevelSize >> (maxLevel - currentLevel), min(topLevelSize << currentLevel, tileSize));\n\n    for (int dy = 0; dy < nTiles / nTilesPerFile; ++dy) {\n        for (int dx = 0; dx < nTiles / nTilesPerFile; ++dx) {\n            sprintf(buf, \"%s/%.2d-%.4d-%.4d.tiff\", cache.c_str(), level, dx, dy);\n            if (flog(buf)) {\n                TIFF* f = TIFFOpen(buf, \"wb\");\n                for (int ny = 0; ny < nTilesPerFile; ++ny) {\n                    for (int nx = 0; nx < nTilesPerFile; ++nx) {\n                        int tx = nx + dx * nTilesPerFile;\n                        int ty = ny + dy * nTilesPerFile;\n\n                        int off = 0;\n                        int currentTileSize = min(topLevelSize << level, tileSize);\n                        for (int j = -2; j <= currentTileSize + 2; ++j) {\n                            for (int i = -2; i <= currentTileSize + 2; ++i) {\n                                int ix = 2 * (tx * currentTileSize + i);\n                                int iy = 2 * (ty * currentTileSize + j);\n                                /*float h1 = getTileHeight(ix, iy);\n                                float h2 = getTileHeight(ix+1, iy);\n                                float h3 = getTileHeight(ix, iy+1);\n                                float h4 = getTileHeight(ix+1, iy+1);\n                                short sh = (short) ((h1 + h2 + h3 + h4) / 4);*/\n                                short sh = (short) (getTileHeight(ix, iy));\n                                tile[off++] = sh & 0xFF;\n                                tile[off++] = sh >> 8;\n                            }\n                        }\n\n                        TIFFSetField(f, TIFFTAG_IMAGEWIDTH, currentTileSize + 5);\n                        TIFFSetField(f, TIFFTAG_IMAGELENGTH, currentTileSize + 5);\n                        TIFFSetField(f, TIFFTAG_SAMPLESPERPIXEL, 1);\n                        TIFFSetField(f, TIFFTAG_BITSPERSAMPLE, 16);\n                        TIFFSetField(f, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);\n                        TIFFSetField(f, TIFFTAG_ORIENTATION, ORIENTATION_BOTLEFT);\n                        TIFFSetField(f, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n                        TIFFSetField(f, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n                        TIFFWriteEncodedStrip(f, 0, tile, (currentTileSize + 5) * (currentTileSize + 5) * 2);\n                        TIFFWriteDirectory(f);\n                    }\n                }\n                TIFFClose(f);\n            }\n        }\n    }\n}",
    "void HeightMipmap::buildResiduals(int level)\n{\n    int nTiles = max(1, (baseLevelSize / this->tileSize) >> (maxLevel - level));\n    int nTilesPerFile = min(nTiles, 16);\n    int tileSize = min(topLevelSize << level, this->tileSize);\n\n    printf(\"Build residuals level %d...\\n\", level);\n\n    currentLevel = level;\n    reset(baseLevelSize >> (maxLevel - currentLevel), baseLevelSize >> (maxLevel - currentLevel), min(topLevelSize << currentLevel, this->tileSize));\n\n    float *parentTile = new float[(this->tileSize + 5) * (this->tileSize + 5)];\n    float *currentTile = new float[(this->tileSize + 5) * (this->tileSize + 5)];\n    float *residualTile = new float[(this->tileSize + 5) * (this->tileSize + 5)];\n    unsigned char *encodedResidual = new unsigned char[(this->tileSize + 5) * (this->tileSize + 5) * 2];\n\n    float maxRR = 0.0;\n    float maxEE = 0.0;\n    for (int dy = 0; dy < nTiles / nTilesPerFile; ++dy) {\n        for (int dx = 0; dx < nTiles / nTilesPerFile; ++dx) {\n            char buf[256];\n            sprintf(buf, \"%s/residual-%.2d-%.4d-%.4d.tiff\", cache.c_str(), level, dx, dy);\n\n            if (flog(buf)) {\n                TIFF* f = TIFFOpen(buf, \"wb\");\n                for (int ny = 0; ny < nTilesPerFile; ++ny) {\n                    for (int nx = 0; nx < nTilesPerFile; ++nx) {\n                        int tx = nx + dx * nTilesPerFile;\n                        int ty = ny + dy * nTilesPerFile;\n                        float maxR, meanR, maxErr;\n\n                        getApproxTile(level - 1, tx / 2, ty / 2, parentTile);\n                        getTile(level, tx, ty, currentTile);\n                        computeResidual(parentTile, currentTile, level, tx, ty, residualTile, maxR, meanR);\n                        encodeResidual(level, residualTile, encodedResidual);\n                        computeApproxTile(parentTile, residualTile, level, tx, ty, currentTile, maxErr);\n                        if (level < maxLevel) {\n                            saveApproxTile(level, tx, ty, currentTile);\n                        }\n\n                        TIFFSetField(f, TIFFTAG_IMAGEWIDTH, tileSize + 5);\n                        TIFFSetField(f, TIFFTAG_IMAGELENGTH, tileSize + 5);\n                        TIFFSetField(f, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);\n                        TIFFSetField(f, TIFFTAG_ORIENTATION, ORIENTATION_BOTLEFT);\n                        TIFFSetField(f, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n                        TIFFSetField(f, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n                        /*TIFFSetField(f, TIFFTAG_SAMPLESPERPIXEL, 1);\n                        TIFFSetField(f, TIFFTAG_BITSPERSAMPLE, 16);*/\n                        TIFFSetField(f, TIFFTAG_SAMPLESPERPIXEL, 2);\n                        TIFFSetField(f, TIFFTAG_BITSPERSAMPLE, 8);\n                        TIFFWriteEncodedStrip(f, 0, encodedResidual, (tileSize + 5) * (tileSize + 5) * 2);\n                        TIFFWriteDirectory(f);\n\n                        maxRR = max(maxR, maxRR);\n                        maxEE = max(maxErr, maxEE);\n                    }\n                }\n\n                TIFFClose(f);\n                printf(\"%f max residual, %f max err\\n\", maxRR, maxEE);\n            }\n        }\n    }\n\n    delete[] parentTile;\n    delete[] currentTile;\n    delete[] residualTile;\n    delete[] encodedResidual;\n}",
    "void HeightMipmap::produceTile(int level, int tx, int ty, unsigned int *offset, unsigned int *offsets, FILE *f)\n{\n    int nTiles = max(1, (baseLevelSize / this->tileSize) >> (maxLevel - level));\n    int nTilesPerFile = min(nTiles, 16);\n    int tileSize = min(topLevelSize << level, this->tileSize);\n\n    if (level == 0) {\n        currentLevel = 0;\n        reset(tileSize, tileSize, tileSize);\n\n        for (int j = 0; j <= tileSize + 4; ++j) {\n            for (int i = 0; i <= tileSize + 4; ++i) {\n                int off = i + j * (tileSize + 5);\n                short z = short(roundf(getTileHeight(i - 2, j - 2) / scale));\n                off = i + j * (tileSize + 5);\n                tile[2 * off] = z & 0xFF;\n                tile[2 * off + 1] = z >> 8;\n            }\n        }\n    } else {\n        int dx = tx / nTilesPerFile;\n        int dy = ty / nTilesPerFile;\n        int x = tx % nTilesPerFile;\n        int y = ty % nTilesPerFile;\n        char buf[256];\n        sprintf(buf, \"%s/residual-%.2d-%.4d-%.4d.tiff\", cache.c_str(), level, dx, dy);\n        TIFF* f = TIFFOpen(buf, \"rb\");\n        TIFFSetDirectory(f, x + y * nTilesPerFile);\n        TIFFReadEncodedStrip(f, 0, tile, (tsize_t) -1);\n        TIFFClose(f);\n    }\n\n    int tileid;\n\tif (level < minLevel) {\n\t    tileid = level;\n\t} else {\n        int l = max(level - minLevel, 0);\n\t    tileid = minLevel + tx + ty * (1 << l) + ((1 << (2 * l)) - 1) / 3;\n\t}\n\n    bool isConstant = true;\n    for (int i = 0; i < (tileSize + 5) * (tileSize + 5) * 2; ++i) {\n        if (tile[i] != 0) {\n            isConstant = false;\n            break;\n        }\n    }\n\n    if (isConstant && constantTile != -1) {\n        offsets[2 * tileid] = offsets[2 * constantTile];\n        offsets[2 * tileid + 1] = offsets[2 * constantTile + 1];\n    } else {\n        mfs_file fd;\n        mfs_open(NULL, 0, (char*)\"w\", &fd);\n        TIFF* tf = TIFFClientOpen(\"\", \"w\", &fd,\n            (TIFFReadWriteProc) mfs_read, (TIFFReadWriteProc) mfs_write, (TIFFSeekProc) mfs_lseek,\n            (TIFFCloseProc) mfs_close, (TIFFSizeProc) mfs_size, (TIFFMapFileProc) mfs_map,\n            (TIFFUnmapFileProc) mfs_unmap);\n        TIFFSetField(tf, TIFFTAG_IMAGEWIDTH, tileSize + 5);\n        TIFFSetField(tf, TIFFTAG_IMAGELENGTH, tileSize + 5);\n        TIFFSetField(tf, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);\n        TIFFSetField(tf, TIFFTAG_ORIENTATION, ORIENTATION_BOTLEFT);\n        TIFFSetField(tf, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n        TIFFSetField(tf, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n        /*TIFFSetField(tf, TIFFTAG_SAMPLESPERPIXEL, 1);\n        TIFFSetField(tf, TIFFTAG_BITSPERSAMPLE, 16);*/\n        TIFFSetField(tf, TIFFTAG_SAMPLESPERPIXEL, 2);\n        TIFFSetField(tf, TIFFTAG_BITSPERSAMPLE, 8);\n        TIFFWriteEncodedStrip(tf, 0, tile, (tileSize + 5) * (tileSize + 5) * 2);\n        TIFFClose(tf);\n\n        fwrite(fd.buf, fd.buf_size, 1, f);\n        free(fd.buf);\n\n        offsets[2 * tileid] = *offset;\n        *offset += fd.buf_size;\n        offsets[2 * tileid + 1] = *offset;\n    }\n\n    if (isConstant && constantTile == -1) {\n        constantTile = tileid;\n    }\n}",
    "float* DemTileCache::readTile(int level, int tx, int ty)\n{\n    int tileid = getTileId(level, tx, ty);\n    int tilesize = getTileSize(level) + 5;\n\n    if (level > maxLevel) {\n        float *result = new float[(tileSize + 5) * (tileSize + 5)];\n        for (int j = 0; j < tilesize; ++j) {\n            for (int i = 0; i < tilesize; ++i) {\n                result[i + j * (tileSize + 5)] = 0.0f;\n            }\n        }\n        return result;\n    }\n\n    int fsize = offsets[2 * tileid + 1] - offsets[2 * tileid];\n    assert(fsize < (tileSize + 5) * (tileSize + 5) * 2);\n\n    fseek64(tileFile, header + offsets[2 * tileid], SEEK_SET);\n    fread(compressedData, fsize, 1, tileFile);\n\n    mfs_file fd;\n    mfs_open(compressedData, fsize, (char*)\"r\", &fd);\n    TIFF* tf = TIFFClientOpen(\"name\", \"r\", &fd,\n        (TIFFReadWriteProc) mfs_read, (TIFFReadWriteProc) mfs_write, (TIFFSeekProc) mfs_lseek,\n        (TIFFCloseProc) mfs_close, (TIFFSizeProc) mfs_size, (TIFFMapFileProc) mfs_map,\n        (TIFFUnmapFileProc) mfs_unmap);\n    TIFFReadEncodedStrip(tf, 0, uncompressedData, (tsize_t) -1);\n    TIFFClose(tf);\n\n    float *result = new float[(tileSize + 5) * (tileSize + 5)];\n    for (int j = 0; j < tilesize; ++j) {\n        for (int i = 0; i < tilesize; ++i) {\n            int off = 2 * (i + j * tilesize);\n            short z = short(uncompressedData[off + 1]) << 8 | short(uncompressedData[off]);\n            result[i + j * (tileSize + 5)] = z * scale;\n        }\n    }\n\n    return result;\n}",
    "virtual unsigned char* readTile(int tx, int ty)\n    {\n        if (currentLevel == maxLevel) {\n            char buf[256];\n            unsigned char *data = new unsigned char[(tileSize + 2*border) * (tileSize + 2*border) * channels];\n            sprintf(buf, \"%s/%.4d-%.4d.tiff\", cache.c_str(), tx, ty);\n            TIFF* f = TIFFOpen(buf, \"rb\");\n            TIFFReadEncodedStrip(f, 0, data, (tsize_t) -1);\n            TIFFClose(f);\n            return data;\n        } else {\n            return ColorMipmap::readTile(tx, ty);\n        }\n    }",
    "virtual void produceTile(int level, int tx, int ty)\n    {\n        if (level == maxLevel) {\n            char buf[256];\n            sprintf(buf, \"%s/%.4d-%.4d.tiff\", cache.c_str(), tx, ty);\n            TIFF* tf = TIFFOpen(buf, \"rb\");\n            TIFFReadEncodedStrip(tf, 0, tile, (tsize_t) -1);\n            TIFFClose(tf);\n        } else {\n            ColorMipmap::produceTile(level, tx, ty);\n        }\n    }",
    "virtual void buildMipmapLevel(int level)\n    {\n        char buf[256];\n        int nTiles = 1 << level;\n        int nTilesPerFile = min(nTiles, 16);\n\n        printf(\"Build mipmap level %d...\\n\", level);\n\n        currentLevel = level + 1;\n        reset(tileSize << currentLevel, tileSize << currentLevel, tileSize);\n\n        for (int dy = 0; dy < nTiles / nTilesPerFile; ++dy) {\n            for (int dx = 0; dx < nTiles / nTilesPerFile; ++dx) {\n                sprintf(buf, \"%s/%.2d-%.4d-%.4d.tiff\", cache.c_str(), level, dx, dy);\n                if (flog(buf)) {\n                    TIFF* f = TIFFOpen(buf, \"wb\");\n                    for (int ny = 0; ny < nTilesPerFile; ++ny) {\n                        for (int nx = 0; nx < nTilesPerFile; ++nx) {\n                            int tx = nx + dx * nTilesPerFile;\n                            int ty = ny + dy * nTilesPerFile;\n\n                            vec3d pc = vec3d((tx + 0.5) / (1 << level) * (2.0 * R) - R, (ty + 0.5) / (1 << level) * (2.0 * R) - R, R);\n                            vec3d uz = pc.normalize();\n                            vec3d ux = vec3d::UNIT_Y.crossProduct(uz).normalize();\n                            vec3d uy = uz.crossProduct(ux);\n                            mat3d worldToTangentFrame = mat3d(\n                                ux.x, ux.y, ux.z,\n                                uy.x, uy.y, uy.z,\n                                uz.x, uz.y, uz.z);\n\n                            mat3d childToParentFrame[4][4];\n                            for (int j = -1; j < 3; ++j) {\n                                for (int i = -1; i < 3; ++i) {\n                                    pc = vec3d((2*tx+i + 0.5) / (2 << level) * (2.0 * R) - R, (2*ty+j + 0.5) / (2 << level) * (2.0 * R) - R, R);\n                                    uz = pc.normalize();\n                                    ux = vec3d::UNIT_Y.crossProduct(uz).normalize();\n                                    uy = uz.crossProduct(ux);\n                                    childToParentFrame[i+1][j+1] = worldToTangentFrame * mat3d(\n                                        ux.x, uy.x, uz.x,\n                                        ux.y, uy.y, uz.y,\n                                        ux.z, uy.z, uz.z);\n                                }\n                            }\n\n                            int off = 0;\n                            for (int j = -border; j < tileSize + border; ++j) {\n                                for (int i = -border; i < tileSize + border; ++i) {\n                                    int ix = 2 * (tx * tileSize + i);\n                                    int iy = 2 * (ty * tileSize + j);\n\n                                    vec4f c1 = getTileColor(ix, iy);\n                                    vec4f c2 = getTileColor(ix+1, iy);\n                                    vec4f c3 = getTileColor(ix, iy+1);\n                                    vec4f c4 = getTileColor(ix+1, iy+1);\n\n                                    float a1 = pow(c1.x / 255, 0.25f);\n                                    float a2 = pow(c2.x / 255, 0.25f);\n                                    float a3 = pow(c3.x / 255, 0.25f);\n                                    float a4 = pow(c4.x / 255, 0.25f);\n                                    float a = (a1 + a2 + a3 + a4) / 4.0;\n                                    //float a = max(a1, max(a2, max(a3, a4)));\n                                    //float a = ((a1 + a2 + a3 + a4) / 4.0 + max(a1, max(a2, max(a3, a4)))) / 2.0;\n                                    tile[off++] = int(roundf(pow(a, 4.0f) * 255));\n\n                                    #define X(x) tan(x * (2.9 / 255.0) - 1.45) / 8.0\n                                    vec3d n1 = vec3d(X(c1.y), X(c1.z), 0.0);\n                                    vec3d n2 = vec3d(X(c2.y), X(c2.z), 0.0);\n                                    vec3d n3 = vec3d(X(c3.y), X(c3.z), 0.0);\n                                    vec3d n4 = vec3d(X(c4.y), X(c4.z), 0.0);\n                                    n1.z = sqrt(1.0 - n1.squaredLength());\n                                    n2.z = sqrt(1.0 - n2.squaredLength());\n                                    n3.z = sqrt(1.0 - n3.squaredLength());\n                                    n4.z = sqrt(1.0 - n4.squaredLength());\n\n                                    int ui = (i + tileSize / 2) / (tileSize / 2);\n                                    int uj = (j + tileSize / 2) / (tileSize / 2);\n                                    vec3d n = childToParentFrame[ui][uj] * n1;\n                                    n += childToParentFrame[ui][uj] * n2;\n                                    n += childToParentFrame[ui][uj] * n3;\n                                    n += childToParentFrame[ui][uj] * n4;\n                                    n = n.normalize();\n\n                                    tile[off++] = int((atan(8.0*n.x)/2.9 + 0.5) * 255);\n                                    tile[off++] = int((atan(8.0*n.y)/2.9 + 0.5) * 255);\n                                }\n                            }\n\n                            TIFFSetField(f, TIFFTAG_IMAGEWIDTH, tileSize + 2*border);\n                            TIFFSetField(f, TIFFTAG_IMAGELENGTH, tileSize + 2*border);\n                            TIFFSetField(f, TIFFTAG_SAMPLESPERPIXEL, channels);\n                            TIFFSetField(f, TIFFTAG_BITSPERSAMPLE, 8);\n                            TIFFSetField(f, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);\n                            TIFFSetField(f, TIFFTAG_ORIENTATION, ORIENTATION_BOTLEFT);\n                            TIFFSetField(f, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n                            if (channels == 1) {\n                                TIFFSetField(f, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n                            } else {\n                                TIFFSetField(f, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n                            }\n                            TIFFWriteEncodedStrip(f, 0, tile, (tileSize + 2*border) * (tileSize + 2*border) * channels);\n                            TIFFWriteDirectory(f);\n                        }\n                    }\n                    TIFFClose(f);\n                }\n            }\n        }\n    }",
    "void ApertureMipmap::build(const string &temp)\n{\n    int tileSize = z->faces[0]->r->tileSize;\n    int blevel = buildLevel - z->faces[0]->r->minLevel;\n    assert(buildLevel == z->level);\n\n    char buf[256];\n    unsigned char *tile = new unsigned char[(tileSize + 4) * (tileSize + 4) * 3];\n\n    int n = 1 << blevel;\n\n    for (int ty = 0; ty < n; ++ty) {\n        for (int tx = 0; tx < n; ++tx) {\n\t   \t    sprintf(buf, \"%s/%.4d-%.4d.tiff\", temp.c_str(), tx, ty);\n\t   \t    if (flog(buf)) {\n                vec3d pc = vec3d((tx + 0.5) / (1 << blevel) * (2.0 * R) - R, (ty + 0.5) / (1 << blevel) * (2.0 * R) - R, R);\n                vec3d uz = pc.normalize();\n                vec3d ux = vec3d::UNIT_Y.crossProduct(uz).normalize();\n                vec3d uy = uz.crossProduct(ux);\n                mat3d worldToTangentFrame = mat3d(\n                    ux.x, ux.y, ux.z,\n                    uy.x, uy.y, uy.z,\n                    uz.x, uz.y, uz.z);\n\n                double x0 = (tx + 0.5 - 1.0 / tileSize) / (1 << blevel) * (2.0 * R) - R;\n                double x1 = (tx + 0.5 + 1.0 / tileSize) / (1 << blevel) * (2.0 * R) - R;\n                double y0 = (ty + 0.5 - 1.0 / tileSize) / (1 << blevel) * (2.0 * R) - R;\n                double y1 = (ty + 0.5 + 1.0 / tileSize) / (1 << blevel) * (2.0 * R) - R;\n\n                vec3d dir[8];\n                float phi[8], cphi[8], sphi[8];\n                float len[8];\n                dir[0] = vec3d(x1, pc.y, R).normalize(R) - uz * R;\n                dir[1] = vec3d(x1, y1, R).normalize(R) - uz * R;\n                dir[2] = vec3d(pc.x, y1, R).normalize(R) - uz * R;\n                dir[3] = vec3d(x0, y1, R).normalize(R) - uz * R;\n                dir[4] = vec3d(x0, pc.y, R).normalize(R) - uz * R;\n                dir[5] = vec3d(x0, y0, R).normalize(R) - uz * R;\n                dir[6] = vec3d(pc.x, y0, R).normalize(R) - uz * R;\n                dir[7] = vec3d(x1, y0, R).normalize(R) - uz * R;\n                for (int i = 0; i < 8; ++i) {\n                    dir[i] = worldToTangentFrame * dir[i];\n                    phi[i] = atan2(dir[i].y, dir[i].x);\n                    cphi[i] = cos(phi[i]);\n                    sphi[i] = sin(phi[i]);\n                    len[i] = dir[i].length();\n                }\n\n                TIFF* f = TIFFOpen(buf, \"wb\");\n                for (int y = -2; y < tileSize + 2; ++y) {\n                    for (int x = -2; x < tileSize + 2; ++x) {\n\n                        float slopes[8] = { 0, 0, 0, 0, 0, 0, 0, 0 };\n                        double sx, sy, sz;\n                        proj(tx * tileSize + x + 0.5, ty * tileSize + y + 0.5, z->m, sx, sy, sz);\n                        float z0 = z->getHeight(sx, sy, sz);\n                        compute(buildLevel, tx * tileSize + x, ty * tileSize + y, 0.5, 0.5, z0, len, 1, slopes);\n\n                        vec3f n(0, 0, 0);\n                        //int v = (int) floor(max(0.0, (ambient(phi, cphi, sphi, slopes, n) * 2.0 - 1.0)) * 255);\n                        int v = (int) floor(pow(ambient(phi, cphi, sphi, slopes, n), 4.0f) * 255);\n\n                        n = n.normalize();\n                        //n.x = (n.x + 0.5) * 255;\n                        //n.y = (n.y + 0.5) * 255;\n                        n.x = (atan(8.0*n.x)/2.9 + 0.5) * 255;\n                        n.y = (atan(8.0*n.y)/2.9 + 0.5) * 255;\n\n                        tile[(x+2 + (y+2) * (tileSize + 4)) * 3] = v;\n                        tile[(x+2 + (y+2) * (tileSize + 4)) * 3 + 1] = max(0, min(255, int(n.x)));\n                        tile[(x+2 + (y+2) * (tileSize + 4)) * 3 + 2] = max(0, min(255, int(n.y)));\n                    }\n                }\n                TIFFSetField(f, TIFFTAG_IMAGEWIDTH, tileSize + 4);\n                TIFFSetField(f, TIFFTAG_IMAGELENGTH, tileSize + 4);\n                TIFFSetField(f, TIFFTAG_SAMPLESPERPIXEL, 3);\n                TIFFSetField(f, TIFFTAG_BITSPERSAMPLE, 8);\n                TIFFSetField(f, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);\n                TIFFSetField(f, TIFFTAG_ORIENTATION, ORIENTATION_BOTLEFT);\n                TIFFSetField(f, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n                TIFFSetField(f, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n                TIFFWriteEncodedStrip(f, 0, tile, (tileSize + 4) * (tileSize + 4) * 3);\n                TIFFClose(f);\n\t   \t    }\n        }\n    }\n\n    delete[] tile;\n}",
    "int WriteTiff(GLubyte *image, const char *filename, const char *description, int x, int y, int width, int height, int compression, int super)\n{\n\tTIFF *file;\n\tGLubyte *p;\n\tint i;\n\n\tfile = TIFFOpen(filename, \"w\");\n\tif (file == NULL) \n\t{\n\t\treturn 1;\n\t}\n\t\t\n\tTIFFSetField(file, TIFFTAG_IMAGEWIDTH, (uint32) width);\n\tTIFFSetField(file, TIFFTAG_IMAGELENGTH, (uint32) height);\n\tTIFFSetField(file, TIFFTAG_BITSPERSAMPLE, 8);\n\tTIFFSetField(file, TIFFTAG_COMPRESSION, compression);\n\tTIFFSetField(file, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n\tTIFFSetField(file, TIFFTAG_SAMPLESPERPIXEL, 3);\n\tTIFFSetField(file, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\tTIFFSetField(file, TIFFTAG_ROWSPERSTRIP, 1);\n\tTIFFSetField(file, TIFFTAG_IMAGEDESCRIPTION, description);\n\tp = image;\n\tfor (i = height - 1; i >= 0; i--) \n\t{\n\t\tif (TIFFWriteScanline(file, p, i, 0) < 0) \n\t\t{\n\t\t\tfree(image);\n\t\t\tTIFFClose(file);\n\t\t\treturn 1;\n\t\t}\n\t\tp += width * sizeof(GLubyte) * 3;\n\t}\n\tTIFFClose(file);\n\tfree(image);\n\treturn 0;\n}",
    "void\nsaveTiff(const sensor_msgs::Image& image, const std::string& file)\n{\n    using\tnamespace sensor_msgs;\n\n    TIFF* const\ttiff = TIFFOpen(file.c_str(), \"w\");\n    if (!tiff)\n\tthrow std::runtime_error(\"saveTiff(): cannot open file[\"\n\t\t\t\t + file + ']');\n\n    const auto\tbitsPerSample\t= image_encodings::bitDepth(image.encoding);\n    const auto\tsamplesPerPixel = image_encodings::numChannels(image.encoding);\n    const auto\tphotometric\t= (image_encodings::isColor(image.encoding) ?\n\t\t\t\t   PHOTOMETRIC_RGB : PHOTOMETRIC_MINISBLACK);\n    \n    TIFFSetField(tiff, TIFFTAG_IMAGEWIDTH,\timage.width);\n    TIFFSetField(tiff, TIFFTAG_IMAGELENGTH,\timage.height);\n    TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE,\tbitsPerSample);\n    TIFFSetField(tiff, TIFFTAG_SAMPLESPERPIXEL,\tsamplesPerPixel);\n    TIFFSetField(tiff, TIFFTAG_ROWSPERSTRIP,\t1);\n    TIFFSetField(tiff, TIFFTAG_COMPRESSION,\tCOMPRESSION_NONE);\n    TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC,\tphotometric);\n    TIFFSetField(tiff, TIFFTAG_FILLORDER,\tFILLORDER_MSB2LSB);\n    TIFFSetField(tiff, TIFFTAG_PLANARCONFIG,\tPLANARCONFIG_CONTIG);\n    TIFFSetField(tiff, TIFFTAG_ORIENTATION,\tORIENTATION_TOPLEFT);\n    TIFFSetField(tiff, TIFFTAG_XRESOLUTION,\t72.0);\n    TIFFSetField(tiff, TIFFTAG_YRESOLUTION,\t72.0);\n    TIFFSetField(tiff, TIFFTAG_RESOLUTIONUNIT,\tRESUNIT_INCH);\n\n    for (int n = 0, offset = 0; n < image.height; ++n)\n    {\n\tTIFFWriteEncodedStrip(tiff, n, image.data.data() + offset, image.step);\n\toffset += image.step;\n    }\n\n    TIFFClose(tiff);\n}",
    "sensor_msgs::ImagePtr\nloadTiff(const std::string& file)\n{\n    using\tnamespace sensor_msgs;\n\n    TIFF* const\ttiff = TIFFOpen(file.c_str(), \"r\");\n    if (!tiff)\n\tthrow std::runtime_error(\"loadTiff(): cannot open file[\" + file + ']');\n\n    uint32\twidth, height;\n    uint16\tbitsPerSample, samplesPerPixel, photometric;\n\n    if (!TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH,\t     &width)\t\t||\n\t!TIFFGetField(tiff, TIFFTAG_IMAGELENGTH,     &height)\t\t||\n\t!TIFFGetField(tiff, TIFFTAG_BITSPERSAMPLE,   &bitsPerSample)\t||\n\t!TIFFGetField(tiff, TIFFTAG_SAMPLESPERPIXEL, &samplesPerPixel)\t||\n\t!TIFFGetField(tiff, TIFFTAG_PHOTOMETRIC,     &photometric))\n    {\n\tthrow std::runtime_error(\"loadTiff(): cannot get necessary fields\");\n    }\n\n    sensor_msgs::ImagePtr\timage(new sensor_msgs::Image());\n    image->width  = width;\n    image->height = height;\n\n    switch (photometric)\n    {\n      case PHOTOMETRIC_MINISBLACK:\n\tswitch(bitsPerSample)\n\t{\n\t  case 8:\n\t    image->encoding = image_encodings::MONO8;\n\t    break;\n\t  case 16:\n\t    image->encoding = image_encodings::MONO16;\n\t    break;\n\t  case 32:\n\t    switch (samplesPerPixel)\n\t    {\n\t      case 1:\n\t\timage->encoding = image_encodings::TYPE_32FC1;\n\t\tbreak;\n\t      case 2:\n\t\timage->encoding = image_encodings::TYPE_32FC2;\n\t\tbreak;\n\t      case 3:\n\t\timage->encoding = image_encodings::TYPE_32FC3;\n\t\tbreak;\n\t      case 4:\n\t\timage->encoding = image_encodings::TYPE_32FC4;\n\t\tbreak;\n\t      default:\n\t\tthrow std::runtime_error(\"loadTiff(): unsupported #samples per pixel[\"\n\t\t\t\t\t + std::to_string(samplesPerPixel)\n\t\t\t\t\t + \"] under #bits per sample[\"\n\t\t\t\t\t + std::to_string(bitsPerSample)\n\t\t\t\t\t + ']');\n\t    }\n\t    break;\n\t  case 64:\n\t    switch (samplesPerPixel)\n\t    {\n\t      case 1:\n\t\timage->encoding = image_encodings::TYPE_64FC1;\n\t\tbreak;\n\t      case 2:\n\t\timage->encoding = image_encodings::TYPE_64FC2;\n\t\tbreak;\n\t      case 3:\n\t\timage->encoding = image_encodings::TYPE_64FC3;\n\t\tbreak;\n\t      case 4:\n\t\timage->encoding = image_encodings::TYPE_64FC4;\n\t\tbreak;\n\t      default:\n\t\tthrow std::runtime_error(\"loadTiff(): unsupported #samples per pixel[\"\n\t\t\t\t\t + std::to_string(samplesPerPixel)\n\t\t\t\t\t + \"] under #bits per sample[\"\n\t\t\t\t\t + std::to_string(bitsPerSample)\n\t\t\t\t\t + ']');\n\t    }\n\t    break;\n\t  default:\n\t    throw std::runtime_error(\"loadTiff(): unsupported #bits per sample[\"\n\t\t\t\t     + std::to_string(bitsPerSample) + ']');\n\t}\n\tbreak;\n\n      case PHOTOMETRIC_RGB:\n\tswitch(bitsPerSample)\n\t{\n\t  case 8:\n\t    image->encoding = image_encodings::RGB8;\n\t    break;\n\t  case 16:\n\t    image->encoding = image_encodings::RGB16;\n\t    break;\n\t  default:\n\t    throw std::runtime_error(\"loadTiff(): unsupported #bits per sample[\"\n\t\t\t\t     + std::to_string(bitsPerSample) + ']');\n\t}\n\tbreak;\n\n      default:\n\tthrow std::runtime_error(\"loadTiff(): unsupported photometic[\"\n\t\t\t\t + std::to_string(photometric) + ']');\n    }\n\n    image->step\t\t= image->width * bitsPerSample * samplesPerPixel / 8;\n    image->is_bigendian = false;\n    image->data.resize(image->height * image->step);\n\n    const auto\tnBytesPerStrip = TIFFStripSize(tiff);\n    const auto\tnStrips        = TIFFNumberOfStrips(tiff);\n\n    for (int n = 0, offset = 0; n < nStrips; ++n)\n    {\n\tconst auto nBytes = TIFFReadEncodedStrip(tiff, n,\n\t\t\t\t\t\t image->data.data() + offset,\n\t\t\t\t\t\t nBytesPerStrip);\n\tif (nBytes < 0)\n\t    throw std::runtime_error(\"loadTiff(): failed to read strip\");\n\n\toffset += nBytes;\n    }\n\n    TIFFClose(tiff);\n\n    return image;\n}",
    "FXbool fxloadTIF(FXStream& store,FXColor*& data,FXint& width,FXint& height,FXushort& codec){\n  tiff_store_handle s_handle;\n  FXuval size,s;\n\n  // Null out\n  data=nullptr;\n  width=0;\n  height=0;\n\n  // Set error/warning handlers\n  TIFFSetErrorHandler(nullptr);\n  TIFFSetWarningHandler(nullptr);\n\n  // Initialize\n  s_handle.store=&store;\n  s_handle.begin=store.position();\n  s_handle.end=store.position();\n\n  FXTRACE((100,\"fxloadTIF\\n\"));\n\n  // Open image\n  TIFF* image=TIFFClientOpen(\"tiff\",\"rm\",(thandle_t)&s_handle,tif_read_store,tif_write_store,tif_seek_store,tif_close_store,tif_size_store,nullptr,nullptr);\n  if(image){\n\n    // Get sizes\n    TIFFGetField(image,TIFFTAG_IMAGEWIDTH,&width);\n    TIFFGetField(image,TIFFTAG_IMAGELENGTH,&height);\n    TIFFGetField(image,TIFFTAG_COMPRESSION,&codec);\n\n    FXTRACE((100,\"fxloadTIF: width=%d height=%d codec=%d\\n\",width,height,codec));\n\n    // Make room for data\n    size=width*height;\n    if(allocElms(data,size)){\n      if(TIFFReadRGBAImageOriented(image,width,height,data,ORIENTATION_TOPLEFT,0)){\n        for(s=0; s<size; s++){\n          data[s]=((data[s]&0xff)<<16)|((data[s]&0xff0000)>>16)|(data[s]&0xff00)|(data[s]&0xff000000);\n          }\n        TIFFClose(image);\n        return true;\n        }\n      freeElms(data);\n      }\n    TIFFClose(image);\n    }\n  return false;\n  }",
    "FXbool fxloadTIF__(FXStream& store,FXColor*& data,FXint& width,FXint& height,FXushort& codec){\n  tiff_store_handle s_handle;\n  FXbool result=false;\n  TIFF* image;\n\n  // Null out\n  data=nullptr;\n  width=0;\n  height=0;\n  codec=0;\n\n  // Set error/warning handlers\n  TIFFSetErrorHandler(nullptr);\n  TIFFSetWarningHandler(nullptr);\n\n  // Initialize\n  s_handle.store=&store;\n  s_handle.begin=store.position();\n  s_handle.end=store.position();\n\n  FXTRACE((100,\"fxloadGEOTIF\\n\"));\n\n  // Open image\n  if((image=TIFFClientOpen(\"tiff\",\"rm\",(thandle_t)&s_handle,tif_read_store,tif_write_store,tif_seek_store,tif_close_store,tif_size_store,nullptr,nullptr))!=nullptr){\n    FXushort samples=0;\n    FXushort samplebits=0;\n    FXushort format=0;\n    FXuint   scanlinesize;\n    FXuchar *scanline;\n\n    // Get size\n    TIFFGetField(image,TIFFTAG_IMAGEWIDTH,&width);\n    TIFFGetField(image,TIFFTAG_IMAGELENGTH,&height);\n    TIFFGetField(image,TIFFTAG_SAMPLESPERPIXEL,&samples);\n    TIFFGetField(image,TIFFTAG_BITSPERSAMPLE,&samplebits);\n    TIFFGetField(image,TIFFTAG_SAMPLEFORMAT,&format);\n\n    // We try to remember the codec for later when we save the image back out...\n    TIFFGetField(image,TIFFTAG_COMPRESSION,&codec);\n\n    // Get line size (bytes)\n    scanlinesize=TIFFScanlineSize(image);\n\n    // Show image configuration\n    FXTRACE((100,\"width=%d height=%d codec=%u samples=%u samplebits=%u format=%u scanlinesize=%u\\n\",width,height,codec,samples,samplebits,format,scanlinesize));\n\n    // Supported formats\n    if((format==SAMPLEFORMAT_UINT || format==SAMPLEFORMAT_INT || format==SAMPLEFORMAT_IEEEFP) && (samples==1 || samples==3)){\n\n      // Allocate scanline buffer\n      if(callocElms(scanline,scanlinesize)){\n\n        // Make room for data\n        if(callocElms(data,width*height)){\n\n/*\n\n    FXuint nPlanarConfig=0;\n    FXuint nCompressFlag=0;\n    FXuint nPhotometric=0;\n\n\n\n\n    TIFFGetField(image,TIFFTAG_PLANARCONFIG,&nPlanarConfig);\n    TIFFGetField(image,TIFFTAG_COMPRESSION,&nCompressFlag);\n    TIFFGetField(image,TIFFTAG_PHOTOMETRIC,&nPhotometric);\n\n    FXTRACE((100,\"nPlanarConfig=%u\\n\",nPlanarConfig));\n    FXTRACE((100,\"nCompressFlag=%u\\n\",nCompressFlag));\n    FXTRACE((100,\"nPhotometric=%u\\n\",nPhotometric));\n\n    switch(nSampleFormat){\n      case SAMPLEFORMAT_UINT:\n        break;\n      case SAMPLEFORMAT_INT:\n        break;\n      case SAMPLEFORMAT_IEEEFP:\n        break;\n      case SAMPLEFORMAT_VOID:\n        break;\n      case SAMPLEFORMAT_COMPLEXINT:\n        break;\n      case SAMPLEFORMAT_COMPLEXIEEEFP:\n        break;\n      default:\n        break;\n      }\n*/\n\n          // Read lines\n          for(FXint y=0; y<height; ++y){\n            TIFFReadScanline(image,scanline,y,0);\n\n            if(samples==3){\n              if(samplebits==8){\n                for(FXint x=0; x<width; ++x){\n                  ((FXuchar*)&data[y*width+x])[0]=scanline[3*x+2];        // Blue\n                  ((FXuchar*)&data[y*width+x])[1]=scanline[3*x+1];        // Green\n                  ((FXuchar*)&data[y*width+x])[2]=scanline[3*x+0];        // Red\n                  ((FXuchar*)&data[y*width+x])[3]=255;                    // Alpha\n                  }\n                }\n              else if(samplebits==16){\n                for(FXint x=0; x<width; ++x){\n                  ((FXuchar*)&data[y*width+x])[0]=((FXushort*)scanline)[3*x+2]/257;\n                  ((FXuchar*)&data[y*width+x])[1]=((FXushort*)scanline)[3*x+1]/257;\n                  ((FXuchar*)&data[y*width+x])[2]=((FXushort*)scanline)[3*x+0]/257;\n                  ((FXuchar*)&data[y*width+x])[3]=255;\n                  }\n                }\n              }\n            else{\n              if(samplebits==8){\n                for(FXint x=0; x<width; ++x){\n                  ((FXuchar*)&data[y*width+x])[0]=scanline[x];          // Blue\n                  ((FXuchar*)&data[y*width+x])[1]=scanline[x];          // Green\n                  ((FXuchar*)&data[y*width+x])[2]=scanline[x];          // Red\n                  ((FXuchar*)&data[y*width+x])[3]=255;                  // Alpha\n                  }\n                }\n              else if(samplebits==16){\n                for(FXint x=0; x<width; ++x){\n                  ((FXuchar*)&data[y*width+x])[0]=((FXushort*)scanline)[x]/257;\n                  ((FXuchar*)&data[y*width+x])[1]=((FXushort*)scanline)[x]/257;\n                  ((FXuchar*)&data[y*width+x])[2]=((FXushort*)scanline)[x]/257;\n                  ((FXuchar*)&data[y*width+x])[3]=255;\n                  }\n                }\n              }\n            }\n\n          // Got as far as this if success\n          result=true;\n          }\n        }\n      freeElms(scanline);\n      }\n    TIFFClose(image);\n    }\n  return result;\n  }",
    "FXbool fxsaveTIF(FXStream& store,const FXColor* data,FXint width,FXint height,FXushort codec){\n  FXbool result=false;\n\n  // Must make sense\n  if(data && 0<width && 0<height){\n\n    // Correct for unsupported codecs\n    const TIFFCodec* coder=TIFFFindCODEC(codec);\n    if(coder==nullptr) codec=COMPRESSION_PACKBITS;\n\n    // Due to the infamous UNISYS patent, we can read LZW TIFF's but not\n    // write them back as that would require the LZW compression algorithm!\n    if(codec==COMPRESSION_LZW) codec=COMPRESSION_PACKBITS;\n\n    FXTRACE((100,\"fxsaveTIF: codec=%d\\n\",codec));\n\n    // Set error/warning handlers\n    TIFFSetErrorHandler(nullptr);\n    TIFFSetWarningHandler(nullptr);\n\n    // Initialize\n    tiff_store_handle s_handle;\n    s_handle.store=&store;\n    s_handle.begin=store.position();\n    s_handle.end=store.position();\n\n    // Open image\n    TIFF* image=TIFFClientOpen(\"tiff\",\"w\",(thandle_t)&s_handle,tif_dummy_read_store,tif_write_store,tif_seek_store,tif_close_store,tif_size_store,nullptr,nullptr);\n    if(image){\n      FXColor *buffer=nullptr;\n\n      // Size of a strip is 16kb\n      FXint rows_per_strip=16*1024/width;\n      if(rows_per_strip<1) rows_per_strip=1;\n\n      // Set fields\n      TIFFSetField(image,TIFFTAG_IMAGEWIDTH,width);\n      TIFFSetField(image,TIFFTAG_IMAGELENGTH,height);\n      TIFFSetField(image,TIFFTAG_COMPRESSION,codec);\n      TIFFSetField(image,TIFFTAG_ORIENTATION,ORIENTATION_TOPLEFT);\n      TIFFSetField(image,TIFFTAG_ROWSPERSTRIP,rows_per_strip);\n      TIFFSetField(image,TIFFTAG_BITSPERSAMPLE,8);\n      TIFFSetField(image,TIFFTAG_SAMPLESPERPIXEL,4);\n      TIFFSetField(image,TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG);\n      TIFFSetField(image,TIFFTAG_PHOTOMETRIC,PHOTOMETRIC_RGB);\n\n      // Allocate scanline buffer\n      if(allocElms(buffer,width)){\n\n        // Dump each line\n        for(FXint y=0; y<height; data+=width,y++){\n\n          // Convert byte order\n          for(FXint x=0; x<width; x++){\n            buffer[x]=FXREDVAL(data[x]) | FXGREENVAL(data[x])<<8 | FXBLUEVAL(data[x])<<16 | FXALPHAVAL(data[x])<<24;\n            }\n\n          // Write scanline\n          if(TIFFWriteScanline(image,buffer,y,1)!=1) goto x;\n          }\n\n        // All done\n        result=true;\n\n        // Delete scanline buffer\nx:      freeElms(buffer);\n        }\n\n      // Close image\n      TIFFClose(image);\n      }\n    }\n  return result;\n  }",
    "bool  TiffEncoder::writeLibTiff( const Mat& img, const vector<int>& params)\n{\n    int channels = img.channels();\n    int width = img.cols, height = img.rows;\n    int depth = img.depth();\n\n    int bitsPerChannel = -1;\n    switch (depth)\n    {\n        case CV_8U:\n        {\n            bitsPerChannel = 8;\n            break;\n        }\n        case CV_16U:\n        {\n            bitsPerChannel = 16;\n            break;\n        }\n        default:\n        {\n            return false;\n        }\n    }\n\n    const int bitsPerByte = 8;\n    size_t fileStep = (width * channels * bitsPerChannel) / bitsPerByte;\n\n    int rowsPerStrip = (int)((1 << 13)/fileStep);\n    readParam(params, TIFFTAG_ROWSPERSTRIP, rowsPerStrip);\n\n    if( rowsPerStrip < 1 )\n        rowsPerStrip = 1;\n\n    if( rowsPerStrip > height )\n        rowsPerStrip = height;\n\n\n    // do NOT put \"wb\" as the mode, because the b means \"big endian\" mode, not \"binary\" mode.\n    // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n    TIFF* pTiffHandle = TIFFOpen(m_filename.c_str(), \"w\");\n    if (!pTiffHandle)\n    {\n        return false;\n    }\n\n    // defaults for now, maybe base them on params in the future\n    int   compression  = COMPRESSION_LZW;\n    int   predictor    = PREDICTOR_HORIZONTAL;\n\n    readParam(params, TIFFTAG_COMPRESSION, compression);\n    readParam(params, TIFFTAG_PREDICTOR, predictor);\n\n    int   colorspace = channels > 1 ? PHOTOMETRIC_RGB : PHOTOMETRIC_MINISBLACK;\n\n    if ( !TIFFSetField(pTiffHandle, TIFFTAG_IMAGEWIDTH, width)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_IMAGELENGTH, height)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_BITSPERSAMPLE, bitsPerChannel)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_COMPRESSION, compression)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_PHOTOMETRIC, colorspace)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_SAMPLESPERPIXEL, channels)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_ROWSPERSTRIP, rowsPerStrip)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_PREDICTOR, predictor)\n       )\n    {\n        TIFFClose(pTiffHandle);\n        return false;\n    }\n\n    // row buffer, because TIFFWriteScanline modifies the original data!\n    size_t scanlineSize = TIFFScanlineSize(pTiffHandle);\n    AutoBuffer<uchar> _buffer(scanlineSize+32);\n    uchar* buffer = _buffer;\n    if (!buffer)\n    {\n        TIFFClose(pTiffHandle);\n        return false;\n    }\n\n    for (int y = 0; y < height; ++y)\n    {\n        switch(channels)\n        {\n            case 1:\n            {\n                memcpy(buffer, img.data + img.step * y, scanlineSize);\n                break;\n            }\n\n            case 3:\n            {\n                if (depth == CV_8U)\n                    icvCvt_BGR2RGB_8u_C3R( img.data + img.step*y, 0, buffer, 0, cvSize(width,1) );\n                else\n                    icvCvt_BGR2RGB_16u_C3R( (const ushort*)(img.data + img.step*y), 0, (ushort*)buffer, 0, cvSize(width,1) );\n                break;\n            }\n\n            case 4:\n            {\n                if (depth == CV_8U)\n                    icvCvt_BGRA2RGBA_8u_C4R( img.data + img.step*y, 0, buffer, 0, cvSize(width,1) );\n                else\n                    icvCvt_BGRA2RGBA_16u_C4R( (const ushort*)(img.data + img.step*y), 0, (ushort*)buffer, 0, cvSize(width,1) );\n                break;\n            }\n\n            default:\n            {\n                TIFFClose(pTiffHandle);\n                return false;\n            }\n        }\n\n        int writeResult = TIFFWriteScanline(pTiffHandle, buffer, y, 0);\n        if (writeResult != 1)\n        {\n            TIFFClose(pTiffHandle);\n            return false;\n        }\n    }\n\n    TIFFClose(pTiffHandle);\n    return true;\n}",
    "~ScopedTiffReader()\n  {\n    if (m_tiff) {\n      TIFFClose(m_tiff);\n    }\n  }",
    "int ImageMatrix::LoadTIFF(char *filename) {\n\tunsigned int h,w,x=0,y=0;\n\tunsigned short int spp=0,bps=0;\n\tTIFF *tif = NULL;\n\tunsigned char *buf8;\n\tunsigned short *buf16;\n\tRGBcolor rgb = {0,0,0};\n\tImageMatrix R_matrix, G_matrix, B_matrix;\n\tMoments2 R_stats, G_stats, B_stats;\n\n\tTIFFSetWarningHandler(NULL);\n\tif( (tif = TIFFOpen(filename, \"r\")) ) {\n\t\tsource = filename;\n\n\t\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w);\n\t\twidth = w;\n\t\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\n\t\theight = h;\n\t\tTIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bps);\n\t\tbits=bps;\n\t\tif ( ! (bits == 8 || bits == 16) ) return (0); // only 8 and 16-bit images supported.\n\t\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &spp);\n\t\tif (!spp) spp=1;  /* assume one sample per pixel if nothing is specified */\n\t\t// regardless of how the image comes in, the stored mode is HSV\n\t\tif (spp == 3) {\n\t\t\tColorMode = cmHSV;\n\t\t\t// If the bits are > 8, we do the read into doubles so that later\n\t\t\t// we can scale the image to its actual signal range.\n\t\t\tif (bits > 8) {\n\t\t\t\tR_matrix.ColorMode = cmGRAY;\n\t\t\t\tR_matrix.allocate (width, height);\n\t\t\t\tG_matrix.ColorMode = cmGRAY;\n\t\t\t\tG_matrix.allocate (width, height);\n\t\t\t\tB_matrix.ColorMode = cmGRAY;\n\t\t\t\tB_matrix.allocate (width, height);\n\t\t\t}\n\t\t} else {\n\t\t\tColorMode = cmGRAY;\n\t\t}\n\t\tif ( TIFFNumberOfDirectories(tif) > 1) return(0);   /* get the number of slices (Zs) */\n\n\t\t/* allocate the data */\n\t\tallocate (width, height);\n\t\twriteablePixels pix_plane = WriteablePixels();\n\t\twriteableColors clr_plane = WriteableColors();\n\n\t\t/* read TIFF header and determine image size */\n\t\tbuf8 = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(tif)*spp);\n\t\tbuf16 = (unsigned short *)_TIFFmalloc( (tsize_t)sizeof(unsigned short)*TIFFScanlineSize(tif)*spp );\n\t\tfor (y = 0; y < height; y++) {\n\t\t\tint col;\n\t\t\tif (bits==8) TIFFReadScanline(tif, buf8, y);\n\t\t\telse TIFFReadScanline(tif, buf16, y);\n\t\t\tx=0;col=0;\n\t\t\twhile (x<width) {\n\t\t\t\tunsigned char byte_data;\n\t\t\t\tunsigned short short_data;\n\t\t\t\tdouble val=0;\n\t\t\t\tint sample_index;\n\t\t\t\tfor (sample_index=0;sample_index<spp;sample_index++) {\n\t\t\t\t\tbyte_data=buf8[col+sample_index];\n\t\t\t\t\tshort_data=buf16[col+sample_index];\n\t\t\t\t\tif (bits==8) val=(double)byte_data;\n\t\t\t\t\telse val=(double)(short_data);\n\t\t\t\t\tif (spp==3 && bits > 8) {  /* RGB image */\n\t\t\t\t\t\tif (sample_index==0) R_matrix.WriteablePixels()(y,x) = R_stats.add (val);\n\t\t\t\t\t\tif (sample_index==1) G_matrix.WriteablePixels()(y,x) = G_stats.add (val);\n\t\t\t\t\t\tif (sample_index==2) B_matrix.WriteablePixels()(y,x) = B_stats.add (val);\n\t\t\t\t\t} else if (spp == 3) {\n\t\t\t\t\t\tif (sample_index==0) rgb.r = (unsigned char)(R_stats.add (val));\n\t\t\t\t\t\tif (sample_index==1) rgb.g = (unsigned char)(G_stats.add (val));\n\t\t\t\t\t\tif (sample_index==2) rgb.b = (unsigned char)(B_stats.add (val));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (spp == 3 && bits == 8) {\n\t\t\t\t\tpix_plane (y, x) = stats.add (RGB2GRAY (rgb));\n\t\t\t\t\tclr_plane (y, x) = RGB2HSV(rgb);\n\t\t\t\t} else if (spp == 1) {\n\t\t\t\t\tpix_plane (y, x) = stats.add (val);\n\t\t\t\t}\n\t\t\t\tx++;\n\t\t\t\tcol+=spp;\n\t\t\t}\n\t\t}\n\t\t// Do the conversion to unsigned chars based on the input signal range\n\t\t// i.e. scale global RGB min-max to 0-255\n\t\tif (spp == 3 && bits > 8) {\n\t\t\t//size_t a, num = width*height;\n\t\t\tdouble RGB_min=0, RGB_max=0, RGB_scale=0;\n\t\t\tR_matrix.finish();\n\t\t\tG_matrix.finish();\n\t\t\tB_matrix.finish();\n\t\t\t// Get the min and max for all 3 channels\n\t\t\tif (R_stats.min() <= G_stats.min() && R_stats.min() <= B_stats.min()) RGB_min = R_stats.min();\n\t\t\telse if (G_stats.min() <= R_stats.min() && G_stats.min() <= B_stats.min()) RGB_min = G_stats.min();\n\t\t\telse if (B_stats.min() <= R_stats.min() && B_stats.min() <= G_stats.min()) RGB_min = B_stats.min();\n\t\t\tif (R_stats.max() >= G_stats.max() && R_stats.max() >= B_stats.max()) RGB_max = R_stats.max();\n\t\t\telse if (G_stats.max() >= R_stats.max() && G_stats.max() >= B_stats.max()) RGB_max = G_stats.max();\n\t\t\telse if (B_stats.max() >= R_stats.max() && B_stats.max() >= G_stats.max()) RGB_max = B_stats.max();\n\t\t\t// Scale the clrData to the global min / max.\n\t\t\tRGB_scale = (255.0/(RGB_max-RGB_min));\n\t\t\tfor (y = 0; y < height; y++) {\n\t\t\t\tfor (x = 0; x < width; x++) {\n\t\t\t\t\trgb.r = (unsigned char)( (R_matrix.ReadablePixels()(y,x) - RGB_min) * RGB_scale);\n\t\t\t\t\trgb.g = (unsigned char)( (G_matrix.ReadablePixels()(y,x) - RGB_min) * RGB_scale);\n\t\t\t\t\trgb.b = (unsigned char)( (B_matrix.ReadablePixels()(y,x) - RGB_min) * RGB_scale);\n\t\t\t\t\tpix_plane (y, x) = stats.add (RGB2GRAY (rgb));\n\t\t\t\t\tclr_plane (y, x) = RGB2HSV(rgb);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_TIFFfree(buf8);\n\t\t_TIFFfree(buf16);\n\t\tTIFFClose(tif);\n\n\t} else return(0);\n\n\treturn(1);\n}",
    "int ImageMatrix::SaveTiff(char *filename) {\n\treadOnlyPixels pix_plane = ReadablePixels();\n\n\tunsigned int x,y;\n\tTIFF* tif = TIFFOpen(filename, \"w\");\n\tif (!tif) return(0);\n\tunsigned short *BufImage16 = new unsigned short[width*height];\n\tif (!BufImage16) {\n\t\tTIFFClose(tif);\n\t\treturn (0);\n\t}\n\tunsigned char *BufImage8 = new unsigned char[width*height];\n\tif (!BufImage8) {\n\t\tTIFFClose(tif);\n\t\tdelete[] BufImage16;\n\t\treturn (0);\n\t}\n\n\n\tfor (y = 0; y < height; y++)\n\t\tfor (x = 0; x < width ; x++) {\n\t\t\tif (bits==16) BufImage16[x + (y * width)] = (unsigned short) ( pix_plane (y,x) );\n\t\t\telse BufImage8[x + (y * width)] = (unsigned char) ( pix_plane (y,x) );\n\t\t}\n\n\tTIFFSetField(tif,TIFFTAG_IMAGEWIDTH, width);\n\tTIFFSetField(tif,TIFFTAG_IMAGELENGTH, height);\n\tTIFFSetField(tif, TIFFTAG_PLANARCONFIG,1);\n\tTIFFSetField(tif, TIFFTAG_PHOTOMETRIC, 1);\n\tTIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, bits);\n\tTIFFSetField(tif, TIFFTAG_COMPRESSION, 1);\n\tTIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 1);\n\n\tfor (y = 0; y < height; y ++) {\n\t\tif (bits==16) TIFFWriteScanline (tif, &(BufImage16[y*width]), y,0 );\n\t\telse TIFFWriteScanline (tif, &(BufImage8[y*width]), y,0 );\n\t}\n\n\tTIFFClose(tif);\n\tdelete[] BufImage16;\n\tdelete[] BufImage8;\n\treturn(1);\n}",
    "int main(int argc, char **argv)\n{\n  if (argc < 2) {\n    std::cout << \"Needs input.tif\\n\";\n    return EXIT_FAILURE;\n  }\n\n  TIFF* tif = TIFFOpen(argv[1], \"r\");\n  if (tif) {\n    tdata_t buf;\n    tstrip_t strip;\n\n    // TODO: count is N(SamplesPerPixel)\n    uint16_t sampleformat;\n    if (!TIFFGetField(tif, TIFFTAG_SAMPLEFORMAT, &sampleformat)) {\n      sampleformat = 1;\n    }\n\n    uint16_t bitspersample;\n    if (!TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bitspersample)) {\n      std::cout << \"TIFFTAG_BITSPERSAMPLE not found\\n\";\n      return -1;\n    }\n\n    std::cout << \"bitspersample = \" << bitspersample << \"\\n\";\n    std::cout << \"sampleformat = \" << sampleformat << \"\\n\";\n\n    std::cout << \"strip size: \" << TIFFStripSize(tif) << \"\\n\";\n\n    buf = _TIFFmalloc(TIFFStripSize(tif));\n  \tfor (strip = 0; strip < TIFFNumberOfStrips(tif); strip++) {\n\t\t  TIFFReadEncodedStrip(tif, strip, buf, (tsize_t) -1);\n      if (sampleformat == 3) { // IEEEFP\n        assert(bitspersample == 32); // TODO: 64bit float\n        const float *pixels = reinterpret_cast<const float *>(buf);\n        const size_t num_pixels = TIFFStripSize(tif) / sizeof(float);\n        for (size_t i = 0; i < num_pixels; i++) {\n          std::cout << \"val[\" << i << \"] = \" << pixels[i] << \"\\n\";\n        }\n      } else if (sampleformat == 1) { // uint\n        if (bitspersample == 16) {\n          const uint16_t *pixels = reinterpret_cast<const uint16_t *>(buf);\n          const size_t num_pixels = TIFFStripSize(tif) / sizeof(uint16_t);\n          for (size_t i = 0; i < num_pixels; i++) {\n            std::cout << \"val[\" << i << \"] = \" << pixels[i] << \"\\n\";\n          }\n        }\n      }\n    }\n\t  _TIFFfree(buf);\n\t  TIFFClose(tif);\n  }\n\n  return EXIT_SUCCESS;\n}",
    "int ReadTiff(const char * filename,\n  std::vector<unsigned char> * ptr,\n  int * w,\n  int * h,\n  int * depth)\n{\n  TIFF* tiff = TIFFOpen(filename, \"r\");\n  if (!tiff) {\n    OPENMVG_LOG_ERROR << \"Couldn't open \" << filename << \" fopen returned 0\";\n    return 0;\n  }\n  uint16 bps, spp;\n\n  TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, w);\n  TIFFGetField(tiff, TIFFTAG_IMAGELENGTH, h);\n  TIFFGetField(tiff, TIFFTAG_BITSPERSAMPLE, &bps);\n  TIFFGetField(tiff, TIFFTAG_SAMPLESPERPIXEL, &spp);\n  *depth = bps * spp / 8;\n\n  ptr->resize((*h)*(*w)*(*depth));\n\n  if (*depth==4) {\n    if (ptr != nullptr) {\n      if (!TIFFReadRGBAImageOriented(tiff, *w, *h, (uint32*)&((*ptr)[0]), ORIENTATION_TOPLEFT, 0)) {\n        TIFFClose(tiff);\n        return 0;\n      }\n    }\n  } else {\n    for (size_t i=0; i<TIFFNumberOfStrips(tiff); ++i) {\n      if (TIFFReadEncodedStrip(tiff, i, ((uint8*)&((*ptr)[0]))+i*TIFFStripSize(tiff),(tsize_t)-1) ==\n        std::numeric_limits<tsize_t>::max()) {\n        TIFFClose(tiff);\n        return 0;\n      }\n    }\n  }\n  TIFFClose(tiff);\n  return 1;\n}",
    "int WriteTiff(const char * filename,\n  const std::vector<unsigned char> & ptr,\n  int w,\n  int h,\n  int depth)\n{\n  TIFF* tiff = TIFFOpen(filename, \"w\");\n  if (!tiff) {\n    OPENMVG_LOG_ERROR << \"Couldn't open \" << filename << \" fopen returned 0\";\n    return 0;\n  }\n  TIFFSetField(tiff, TIFFTAG_IMAGEWIDTH, w);\n  TIFFSetField(tiff, TIFFTAG_IMAGELENGTH, h);\n  TIFFSetField(tiff, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n  TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n  TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 8);\n  TIFFSetField(tiff, TIFFTAG_SAMPLESPERPIXEL, depth);\n  TIFFSetField(tiff, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n  TIFFSetField(tiff, TIFFTAG_COMPRESSION,COMPRESSION_NONE);\n  TIFFSetField(tiff, TIFFTAG_ROWSPERSTRIP, 16);\n  for (uint32 y=0; y < static_cast<uint32>(h); ++y) {\n    if (TIFFWriteScanline(tiff,(tdata_t)(((uint8*)(&ptr[0]))+depth*w*y),y)<0) {\n      TIFFClose(tiff);\n      return 0;\n    }\n  }\n  TIFFClose(tiff);\n  return 1;\n}",
    "bool Read_TIFF_ImageHeader(const char * filename, ImageHeader * imgheader)\n{\n  bool bStatus = false;\n\n  TIFF* tiff = TIFFOpen(filename, \"r\");\n  if (!tiff) {\n    OPENMVG_LOG_ERROR << \"Cannot open TIFF image: \" << filename << \".\";\n    return false;\n  }\n\n  if (imgheader)\n  {\n    TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, &imgheader->width);\n    TIFFGetField(tiff, TIFFTAG_IMAGELENGTH, &imgheader->height);\n    bStatus = true;\n  }\n\n  TIFFClose(tiff);\n  return bStatus;\n}",
    "il::image_type_ptr tiff_null_image( TIFF* tif )\r\n\t{\r\n\t\tTIFFClose( tif );\r\n\t\treturn il::image_type_ptr( );\r\n\t}",
    "il::image_type_ptr load_tiff( const pl::string& uri )\r\n\t{\r\n\t\tTIFF* tif = TIFFOpen( uri.c_str( ), \"r\" );\r\n\t\tif( tif == NULL )\r\n\t\t\treturn il::image_type_ptr( );\r\n\r\n\t\tint width, height, depth;\r\n\r\n\t\tTIFFGetFieldDefaulted( tif, TIFFTAG_IMAGEWIDTH,  &width );\r\n\t\tTIFFGetFieldDefaulted( tif, TIFFTAG_IMAGELENGTH, &height );\r\n\t\tif( !TIFFGetFieldDefaulted( tif, TIFFTAG_IMAGEDEPTH, &depth ) ) depth = 1;\r\n\r\n\t\tunsigned short config;\r\n\t\tTIFFGetFieldDefaulted( tif, TIFFTAG_PLANARCONFIG, &config );\r\n\r\n\t\tif( config != PLANARCONFIG_CONTIG )\r\n\t\t\treturn tiff_null_image( tif );\r\n\r\n\t\tunsigned short photo, compression;\r\n\t\tunsigned short sample_format, orientation;\r\n\t\tTIFFGetFieldDefaulted( tif, TIFFTAG_PHOTOMETRIC, &photo );\r\n\t\tTIFFGetFieldDefaulted( tif, TIFFTAG_SAMPLEFORMAT, &sample_format );\r\n\t\tTIFFGetFieldDefaulted( tif, TIFFTAG_COMPRESSION, &compression );\r\n\t\tTIFFGetFieldDefaulted( tif, TIFFTAG_ORIENTATION, &orientation );\r\n\r\n\t\tbool is_float = false;\r\n\t\tswitch( photo )\r\n\t\t{\r\n\t\t\tcase PHOTOMETRIC_RGB:\r\n\t\t\t\tif( sample_format == SAMPLEFORMAT_IEEEFP )\r\n\t\t\t\t\tis_float = true;\r\n\t\t\t\tbreak;\r\n\t\t\t\t\r\n\t\t\tdefault:\r\n\t\t\t\treturn tiff_null_image( tif );\r\n\t\t}\r\n\t\t\r\n\t\tunsigned short bpp, components;\r\n\t\tTIFFGetFieldDefaulted( tif, TIFFTAG_BITSPERSAMPLE,   &bpp );\r\n\t\tTIFFGetFieldDefaulted( tif, TIFFTAG_SAMPLESPERPIXEL, &components );\r\n\r\n\t\til::image_type_ptr im = tiff_image_type_to_image_type( bpp, components, width, height, is_float );\r\n\t\tif( !im )\r\n\t\t\treturn il::image_type_ptr( );\r\n\r\n\t\til::image_type::pointer data = im->data( );\r\n\t\tint bytes_per_pixel = components * bpp / 8;\r\n\r\n\t\tif( TIFFIsTiled( tif ) )\r\n\t\t{\r\n\t\t\tint tile_width, tile_height, tile_depth;\r\n\r\n\t\t\tTIFFGetField( tif, TIFFTAG_TILEWIDTH,  &tile_width );\r\n\t\t\tTIFFGetField( tif, TIFFTAG_TILELENGTH, &tile_height );\r\n\r\n\t\t\tif( !TIFFGetField( tif, TIFFTAG_TILEDEPTH,  &tile_depth ) )\r\n\t\t\t\ttile_depth = 1;\r\n\r\n\t\t\tstd::vector<unsigned char> buf( TIFFTileSize( tif ) );\r\n\t\t\tfor( int k = 0; k < depth; k += tile_depth )\r\n\t\t\t{\r\n\t\t\t\tfor( int j = 0; j < height; j += tile_height )\r\n\t\t\t\t{\r\n\t\t\t\t\tfor( int i = 0; i < width; i += tile_width )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tTIFFReadTile( tif, &buf[ 0 ], i, j, k, 0 );\r\n\r\n\t\t\t\t\t\tfor( int l = 0; l < tile_depth; ++l )\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tfor( int m = 0; m < tile_height; ++m )\r\n\t\t\t\t\t\t\t\tmemcpy( data + ( ( ( k + l ) * height + j + m ) * width + i ) * bytes_per_pixel, \r\n\t\t\t\t\t\t\t\t\t\t&buf[ 0 ] + ( l * tile_height + m ) * tile_width * bytes_per_pixel, tile_width * bytes_per_pixel );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tsize_t pitch = im->pitch( );\r\n\t\t\tif( is_float )\r\n\t\t\t\tpitch *= sizeof( float );\r\n\r\n\t\t\tunsigned int rows, strip_size;\r\n\t\t\tTIFFGetField( tif, TIFFTAG_ROWSPERSTRIP, &rows );\r\n\t\t\tstrip_size = TIFFStripSize( tif );\r\n\t\t\t\r\n\t\t\ttypedef std::vector<unsigned char> buffer_t;\r\n\t\t\tbuffer_t buf( strip_size );\r\n\t\t\t\r\n\t\t\tint linesize = strip_size / rows;\r\n\t\t\t\r\n\t\t\ttstrip_t nstrips = TIFFNumberOfStrips( tif );\r\n\t\t\tfor( tstrip_t i = 0; i < nstrips; ++i )\r\n\t\t\t{\r\n\t\t\t\tTIFFReadEncodedStrip( tif, i, &buf[ 0 ], strip_size );\r\n\t\t\t\t\r\n\t\t\t\tbuffer_t::pointer buf_data = &buf[ 0 ];\r\n\t\t\t\t\r\n\t\t\t\tfor( unsigned int j = 0; j < rows; ++j )\r\n\t\t\t\t{\r\n\t\t\t\t\tmemcpy( data, buf_data, linesize );\r\n\r\n\t\t\t\t\tbuf_data += linesize;\r\n\t\t\t\t\tdata += pitch;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tTIFFClose( tif );\r\n\r\n\t\treturn im;\r\n\t}",
    "ILboolean iLoadTiffInternal()\n{\n\tTIFF\t *tif;\n\tuint16\t photometric, planarconfig, orientation;\n\tuint16\t samplesperpixel, bitspersample, *sampleinfo, extrasamples;\n\tuint32\t w, h, d, linesize, tilewidth, tilelength;\n\tILubyte  *pImageData;\n\tILuint\t i, ProfileLen, DirCount = 0;\n\tvoid\t *Buffer;\n\tILimage  *Image, *TempImage;\n\tILushort si;\n        ILfloat  x_position, x_resolution, y_position, y_resolution;\n\t//TIFFRGBAImage img;\n\t//char emsg[1024];\n\n\t// to avoid high order bits garbage when used as shorts\n\tw = h = d = linesize = tilewidth = tilelength = 0;\n\n\tif (iCurImage == NULL) {\n\t\tilSetError(IL_ILLEGAL_OPERATION);\n\t\treturn IL_FALSE;\n\t}\n\n\tTIFFSetWarningHandler (NULL);\n\tTIFFSetErrorHandler   (NULL);\n\n\t//for debugging only\n\t//TIFFSetWarningHandler(warningHandler);\n\t//TIFFSetErrorHandler(errorHandler);\n\n\ttif = iTIFFOpen((char*)\"r\");\n\tif (tif == NULL) {\n\t\tilSetError(IL_COULD_NOT_OPEN_FILE);\n\t\treturn IL_FALSE;\n\t}\n\n\tdo {\n\t\tDirCount++;\n\t} while (TIFFReadDirectory(tif));\n\n\t/*\n\t if (!ilTexImage(1, 1, 1, 1, IL_RGBA, IL_UNSIGNED_BYTE, NULL)) {\n\t\t TIFFClose(tif);\n\t\t return IL_FALSE;\n\t}\n\tImage = iCurImage;\n\tfor (i = 1; i < DirCount; i++) {\n\t\t Image->Next = ilNewImage(1, 1, 1, 1, 1);\n\t\tif (Image->Next == NULL) {\n\t\t\tTIFFClose(tif);\n\t\t\treturn IL_FALSE;\n\t\t}\n\t\tImage = Image->Next;\n\t}\n\tiCurImage->NumNext = DirCount - 1;\n\t*/\n\tImage = NULL;\n\tfor (i = 0; i < DirCount; i++) {\n\t\tTIFFSetDirectory(tif, (tdir_t)i);\n\t\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH,  &w);\n\t\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\n\n\t\tTIFFGetFieldDefaulted(tif, TIFFTAG_IMAGEDEPTH,\t\t&d); //TODO: d is ignored...\n\t\tTIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLESPERPIXEL, &samplesperpixel);\n\t\tTIFFGetFieldDefaulted(tif, TIFFTAG_BITSPERSAMPLE,\t&bitspersample);\n\t\tTIFFGetFieldDefaulted(tif, TIFFTAG_EXTRASAMPLES,\t&extrasamples, &sampleinfo);\n\t\tTIFFGetFieldDefaulted(tif, TIFFTAG_ORIENTATION, \t&orientation);\n\n\t\tlinesize = (uint32)TIFFScanlineSize(tif);\n\t\t\n\t\t//added 2003-08-31\n\t\t//1 bpp tiffs are not neccessarily greyscale, they can\n\t\t//have a palette (photometric == 3)...get this information\n\t\tTIFFGetFieldDefaulted(tif, TIFFTAG_PHOTOMETRIC,  &photometric);\n\t\tTIFFGetFieldDefaulted(tif, TIFFTAG_PLANARCONFIG, &planarconfig);\n\n\t\t//special-case code for frequent data cases that may be read more\n\t\t//efficiently than with the TIFFReadRGBAImage() interface.\n\t\t\n\t\t//added 2004-05-12\n\t\t//Get tile sizes and use TIFFReadRGBAImage() for tiled images for now\n\t\ttilewidth = w; tilelength = h;\n\t\tTIFFGetFieldDefaulted(tif, TIFFTAG_TILEWIDTH,  &tilewidth);\n\t\tTIFFGetFieldDefaulted(tif, TIFFTAG_TILELENGTH, &tilelength);\n\n\n\t\tif (extrasamples == 0\n\t\t\t&& samplesperpixel == 1  //luminance or palette\n\t\t\t&& (bitspersample == 8 || bitspersample == 1 || bitspersample == 16)\n\t\t\t&& (photometric == PHOTOMETRIC_MINISWHITE\n\t\t\t\t|| photometric == PHOTOMETRIC_MINISBLACK\n\t\t\t\t|| photometric == PHOTOMETRIC_PALETTE)\n\t\t\t&& (orientation == ORIENTATION_TOPLEFT || orientation == ORIENTATION_BOTLEFT)\n\t\t\t&& tilewidth == w && tilelength == h\n\t\t\t) {\n\t\t\tILubyte* strip;\n\t\t\ttsize_t stripsize;\n\t\t\tILuint y;\n\t\t\tuint32 rowsperstrip, j, linesread;\n\n\t\t\t//TODO: 1 bit/pixel images should not be stored as 8 bits...\n\t\t\t//(-> add new format)\n\t\t\tif (!Image) {\n\t\t\t\tint type = IL_UNSIGNED_BYTE;\n\t\t\t\tif (bitspersample == 16) type = IL_UNSIGNED_SHORT;\n\t\t\t\tif (!ilTexImage(w, h, 1, 1, IL_LUMINANCE, type, NULL)) {\n\t\t\t\t\tTIFFClose(tif);\n\t\t\t\t\treturn IL_FALSE;\n\t\t\t\t}\n\t\t\t\tImage = iCurImage;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tImage->Next = ilNewImage(w, h, 1, 1, 1);\n\t\t\t\tif (Image->Next == NULL) {\n\t\t\t\t\tTIFFClose(tif);\n\t\t\t\t\treturn IL_FALSE;\n\t\t\t\t}\n\t\t\t\tImage = Image->Next;\n\t\t\t}\n\n\t\t\tif (photometric == PHOTOMETRIC_PALETTE) { //read palette\n\t\t\t\tuint16 *red, *green, *blue;\n\t\t\t\t//ILboolean is16bitpalette = IL_FALSE;\n\t\t\t\tILubyte *entry;\n\t\t\t\tuint32 count = 1 << bitspersample, j;\n\t\t\n\t\t\t\tTIFFGetField(tif, TIFFTAG_COLORMAP, &red, &green, &blue);\n\n\t\t\t\tImage->Format = IL_COLOUR_INDEX;\n\t\t\t\tImage->Pal.PalSize = (count)*3;\n\t\t\t\tImage->Pal.PalType = IL_PAL_RGB24;\n\t\t\t\tImage->Pal.Palette = (ILubyte*)ialloc(Image->Pal.PalSize);\n\t\t\t\tentry = Image->Pal.Palette;\n\t\t\t\tfor (j = 0; j < count; ++j) {\n\t\t\t\t\tentry[0] = (ILubyte)(red[j] >> 8);\n\t\t\t\t\tentry[1] = (ILubyte)(green[j] >> 8);\n\t\t\t\t\tentry[2] = (ILubyte)(blue[j] >> 8);\n\n\t\t\t\t\tentry += 3;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tTIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n\t\t\tstripsize = TIFFStripSize(tif);\n\n\t\t\tstrip = (ILubyte*)ialloc(stripsize);\n\n\t\t\tif (bitspersample == 8 || bitspersample == 16) {\n\t\t\t\tILubyte *dat = Image->Data;\n\t\t\t\tfor (y = 0; y < h; y += rowsperstrip) {\n\t\t\t\t\t//the last strip may contain less data if the image\n\t\t\t\t\t//height is not evenly divisible by rowsperstrip\n\t\t\t\t\tif (y + rowsperstrip > h) {\n\t\t\t\t\t\tstripsize = linesize*(h - y);\n\t\t\t\t\t\tlinesread = h - y;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tlinesread = rowsperstrip;\n\n\t\t\t\t\tif (TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, y, 0), strip, stripsize) == -1) {\n\t\t\t\t\t\tilSetError(IL_LIB_TIFF_ERROR);\n\t\t\t\t\t\tifree(strip);\n\t\t\t\t\t\tTIFFClose(tif);\n\t\t\t\t\t\treturn IL_FALSE;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (photometric == PHOTOMETRIC_MINISWHITE) { //invert channel\n\t\t\t\t\t\tuint32 k, t2;\n\t\t\t\t\t\tfor (j = 0; j < linesread; ++j) {\n\t\t\t\t\t\t\tt2 = j*linesize;\n\t\t\t\t\t\t\t//this works for 16bit images as well: the two bytes\n\t\t\t\t\t\t\t//making up a pixel can be inverted independently\n\t\t\t\t\t\t\tfor (k = 0; k < Image->Bps; ++k)\n\t\t\t\t\t\t\t\tdat[k] = ~strip[t2 + k];\n\t\t\t\t\t\t\tdat += w;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tfor(j = 0; j < linesread; ++j)\n\t\t\t\t\t\t\tmemcpy(&Image->Data[(y + j)*Image->Bps], &strip[j*linesize], Image->Bps);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (bitspersample == 1) {\n\t\t\t\t//TODO: add a native format to devil, so we don't have to\n\t\t\t\t//unpack the values here\n\t\t\t\tILubyte mask, curr, *dat = Image->Data;\n\t\t\t\tuint32 k, sx, t2;\n\t\t\t\tfor (y = 0; y < h; y += rowsperstrip) {\n\t\t\t\t\t//the last strip may contain less data if the image\n\t\t\t\t\t//height is not evenly divisible by rowsperstrip\n\t\t\t\t\tif (y + rowsperstrip > h) {\n\t\t\t\t\t\tstripsize = linesize*(h - y);\n\t\t\t\t\t\tlinesread = h - y;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tlinesread = rowsperstrip;\n\n\t\t\t\t\tif (TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, y, 0), strip, stripsize) == -1) {\n\t\t\t\t\t\tilSetError(IL_LIB_TIFF_ERROR);\n\t\t\t\t\t\tifree(strip);\n\t\t\t\t\t\tTIFFClose(tif);\n\t\t\t\t\t\treturn IL_FALSE;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (j = 0; j < linesread; ++j) {\n\t\t\t\t\t\tk = 0;\n\t\t\t\t\t\tsx = 0;\n\t\t\t\t\t\tt2 = j*linesize;\n\t\t\t\t\t\twhile (k < w) {\n\t\t\t\t\t\t\tcurr = strip[t2 + sx];\n\t\t\t\t\t\t\tif (photometric == PHOTOMETRIC_MINISWHITE)\n\t\t\t\t\t\t\t\tcurr = ~curr;\n\t\t\t\t\t\t\tfor (mask = 0x80; mask != 0 && k < w; mask >>= 1){\n\t\t\t\t\t\t\t\tif((curr & mask) != 0)\n\t\t\t\t\t\t\t\t\tdat[k] = 255;\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tdat[k] = 0;\n\t\t\t\t\t\t\t\t++k;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t++sx;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdat += w;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tifree(strip);\n\n\t\t\tif(orientation == ORIENTATION_TOPLEFT)\n\t\t\t\tImage->Origin = IL_ORIGIN_UPPER_LEFT;\n\t\t\telse if(orientation == ORIENTATION_BOTLEFT)\n\t\t\t\tImage->Origin = IL_ORIGIN_LOWER_LEFT;\n\t\t}\n\t\t//for 16bit rgb images:\n\t\telse if (extrasamples == 0\n\t\t\t&& samplesperpixel == 3\n\t\t\t&& (bitspersample == 8 || bitspersample == 16)\n\t\t\t&& photometric == PHOTOMETRIC_RGB\n\t\t\t&& planarconfig == 1\n\t\t\t&& (orientation == ORIENTATION_TOPLEFT || orientation == ORIENTATION_BOTLEFT)\n\t\t\t&& tilewidth == w && tilelength == h\n\t\t\t) {\n\t\t\tILubyte *strip, *dat;\n\t\t\ttsize_t stripsize;\n\t\t\tILuint y;\n\t\t\tuint32 rowsperstrip, j, linesread;\n\n\t\t\tif (!Image) {\n\t\t\t\tint type = IL_UNSIGNED_BYTE;\n\t\t\t\tif (bitspersample == 16) type = IL_UNSIGNED_SHORT;\n\t\t\t\tif(!ilTexImage(w, h, 1, 3, IL_RGB, type, NULL)) {\n\t\t\t\t\tTIFFClose(tif);\n\t\t\t\t\treturn IL_FALSE;\n\t\t\t\t}\n\t\t\t\tImage = iCurImage;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tImage->Next = ilNewImage(w, h, 1, 1, 1);\n\t\t\t\tif(Image->Next == NULL) {\n\t\t\t\t\tTIFFClose(tif);\n\t\t\t\t\treturn IL_FALSE;\n\t\t\t\t}\n\t\t\t\tImage = Image->Next;\n\t\t\t}\n\n\t\t\tTIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n\t\t\tstripsize = TIFFStripSize(tif);\n\n\t\t\tstrip = (ILubyte*)ialloc(stripsize);\n\n\t\t\tdat = Image->Data;\n\t\t\tfor (y = 0; y < h; y += rowsperstrip) {\n\t\t\t\t//the last strip may contain less data if the image\n\t\t\t\t//height is not evenly divisible by rowsperstrip\n\t\t\t\tif (y + rowsperstrip > h) {\n\t\t\t\t\tstripsize = linesize*(h - y);\n\t\t\t\t\tlinesread = h - y;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tlinesread = rowsperstrip;\n\n\t\t\t\tif (TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, y, 0), strip, stripsize) == -1) {\n\t\t\t\t\tilSetError(IL_LIB_TIFF_ERROR);\n\t\t\t\t\tifree(strip);\n\t\t\t\t\tTIFFClose(tif);\n\t\t\t\t\treturn IL_FALSE;\n\t\t\t\t}\n\n\t\t\t\tfor(j = 0; j < linesread; ++j)\n\t\t\t\t\t\tmemcpy(&Image->Data[(y + j)*Image->Bps], &strip[j*linesize], Image->Bps);\n\t\t\t}\n\n\t\t\tifree(strip);\n\t\t\t\n\t\t\tif(orientation == ORIENTATION_TOPLEFT)\n\t\t\t\tImage->Origin = IL_ORIGIN_UPPER_LEFT;\n\t\t\telse if(orientation == ORIENTATION_BOTLEFT)\n\t\t\t\tImage->Origin = IL_ORIGIN_LOWER_LEFT;\n\t\t}/*\n\t\telse if (extrasamples == 0 && samplesperpixel == 3  //rgb\n\t\t\t\t\t&& (bitspersample == 8 || bitspersample == 1 || bitspersample == 16)\n\t\t\t\t\t&& photometric == PHOTOMETRIC_RGB\n\t\t\t\t\t&& (planarconfig == PLANARCONFIG_CONTIG || planarcon\n\t\t\t\t\t\t&& (orientation == ORIENTATION_TOPLEFT || orientation == ORIENTATION_BOTLEFT)\n\t\t\t\t\t) {\n\t\t}\n\t\t\t\t*/\n\t\telse {\n\t\t\t\t//not direclty supported format\n\t\t\tif(!Image) {\n\t\t\t\tif(!ilTexImage(w, h, 1, 4, IL_RGBA, IL_UNSIGNED_BYTE, NULL)) {\n\t\t\t\t\tTIFFClose(tif);\n\t\t\t\t\treturn IL_FALSE;\n\t\t\t\t}\n\t\t\t\tImage = iCurImage;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tImage->Next = ilNewImage(w, h, 1, 4, 1);\n\t\t\t\tif(Image->Next == NULL) {\n\t\t\t\t\tTIFFClose(tif);\n\t\t\t\t\treturn IL_FALSE;\n\t\t\t\t}\n\t\t\t\tImage = Image->Next;\n\t\t\t}\n\n\t\t\tif (samplesperpixel == 4) {\n\t\t\t\tTIFFGetFieldDefaulted(tif, TIFFTAG_EXTRASAMPLES, &extrasamples, &sampleinfo);\n\t\t\t\tif (!sampleinfo || sampleinfo[0] == EXTRASAMPLE_UNSPECIFIED) {\n\t\t\t\t\tsi = EXTRASAMPLE_ASSOCALPHA;\n\t\t\t\t\tTIFFSetField(tif, TIFFTAG_EXTRASAMPLES, 1, &si);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\t if (!ilResizeImage(Image, Image->Width, Image->Height, 1, 4, 1)) {\n\t\t\t\t TIFFClose(tif);\n\t\t\t\t return IL_FALSE;\n\t\t\t }\n\t\t\t */\n\t\t\tImage->Format = IL_RGBA;\n\t\t\tImage->Type = IL_UNSIGNED_BYTE;\n\t\n\t\t\t// Siigron: added u_long cast to shut up compiler warning\n\t\t\t//2003-08-31: changed flag from 1 (exit on error) to 0 (keep decoding)\n\t\t\t//this lets me view text.tif, but can give crashes with unsupported\n\t\t\t//tiffs...\n\t\t\t//2003-09-04: keep flag 1 for official version for now\n\t\t\tif (!TIFFReadRGBAImage(tif, Image->Width, Image->Height, (uint32*)Image->Data, 0)) {\n\t\t\t\tTIFFClose(tif);\n\t\t\t\tilSetError(IL_LIB_TIFF_ERROR);\n\t\t\t\treturn IL_FALSE;\n\t\t\t}\n\t\t\tImage->Origin = IL_ORIGIN_LOWER_LEFT;  // eiu...dunno if this is right\n\n#ifdef __BIG_ENDIAN__ //TIFFReadRGBAImage reads abgr on big endian, convert to rgba\n\t\t\tEndianSwapData(Image);\n#endif\n\n\t\t\t/*\n\t\t\t The following switch() should not be needed,\n\t\t\t because we take care of the special cases that needed\n\t\t\t these conversions. But since not all special cases\n\t\t\t are handled right now, keep it :)\n\t\t\t */\n\t\t\t//TODO: put switch into the loop??\n\t\t\tTempImage = iCurImage;\n\t\t\tiCurImage = Image; //ilConvertImage() converts iCurImage\n\t\t\tswitch (samplesperpixel)\n\t\t\t{\n\t\t\t\tcase 1:\n\t\t\t\t\t//added 2003-08-31 to keep palettized tiffs colored\n\t\t\t\t\tif(photometric != 3)\n\t\t\t\t\t\tilConvertImage(IL_LUMINANCE, IL_UNSIGNED_BYTE);\n\t\t\t\t\telse //strip alpha as tiff supports no alpha palettes\n\t\t\t\t\t\tilConvertImage(IL_RGB, IL_UNSIGNED_BYTE);\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase 3:\n\t\t\t\t\t//TODO: why the ifdef??\n#ifdef __LITTLE_ENDIAN__\n\t\t\t\t\tilConvertImage(IL_RGB, IL_UNSIGNED_BYTE);\n#endif\t\t\t\n\t\t\t\t\tbreak; \n\t\t\t\t\t\n\t\t\t\tcase 4:\n\t\t\t\t\tpImageData = Image->Data;\n\t\t\t\t\t//removed on 2003-08-26...why was this here? libtiff should and does\n\t\t\t\t\t//take care of these things???\n\t\t\t\t\t/*\t\t\t\n\t\t\t\t\t//invert alpha\n#ifdef __LITTLE_ENDIAN__\n\t\t\t\t\tpImageData += 3;\n#endif\t\t\t\n\t\t\t\t\tfor (i = Image->Width * Image->Height; i > 0; i--) {\n\t\t\t\t\t\t*pImageData ^= 255;\n\t\t\t\t\t\tpImageData += 4;\n\t\t\t\t\t}\n\t\t\t\t\t*/\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tiCurImage = TempImage;\n\t\t\t\n\t\t} //else not directly supported format\n\n\t\tif (TIFFGetField(tif, TIFFTAG_ICCPROFILE, &ProfileLen, &Buffer)) {\n\t\t\tif (Image->Profile && Image->ProfileSize)\n\t\t\t\tifree(Image->Profile);\n\t\t\tImage->Profile = (ILubyte*)ialloc(ProfileLen);\n\t\t\tif (Image->Profile == NULL) {\n\t\t\t\tTIFFClose(tif);\n\t\t\t\treturn IL_FALSE;\n\t\t\t}\n\n\t\t\tmemcpy(Image->Profile, Buffer, ProfileLen);\n\t\t\tImage->ProfileSize = ProfileLen;\n\n\t\t\t//removed on 2003-08-24 as explained in bug 579574 on sourceforge\n\t\t\t//_TIFFfree(Buffer);\n\t\t}\n\n                // dangelo: read offset from tiff tags.\n                //If nothing is stored in these tags, then this must be an \"uncropped\" TIFF \n                //file, in which case, the \"full size\" width/height is the same as the \n                //\"cropped\" width and height\n                //\n                // the full size is currently not supported by DevIL\n                //if (TIFFGetField(tif, TIFFTAG_PIXAR_IMAGEFULLWIDTH, &(c->full_width)) ==\n                //        0)\n                //    (c->full_width = c->cropped_width);\n                //if (TIFFGetField(tif, TIFFTAG_PIXAR_IMAGEFULLLENGTH, &(c->full_height)) ==\n                //        0)\n                //    (c->full_height = c->cropped_height);\n\n                if (TIFFGetField(tif, TIFFTAG_XPOSITION, &x_position) == 0)\n                    x_position = 0;\n                if (TIFFGetField(tif, TIFFTAG_XRESOLUTION, &x_resolution) == 0)\n                    x_resolution = 0;\n                if (TIFFGetField(tif, TIFFTAG_YPOSITION, &y_position) == 0)\n                    y_position = 0;\n                if (TIFFGetField(tif, TIFFTAG_YRESOLUTION, &y_resolution) == 0)\n                    y_resolution = 0;\n\n                //offset in pixels of \"cropped\" image from top left corner of \n                //full image (rounded to nearest integer)\n                Image->OffX = (uint32) ((x_position * x_resolution) + 0.49);\n                Image->OffY = (uint32) ((y_position * y_resolution) + 0.49);\n                \n\n\t\t/*\n\t\t Image = Image->Next;\n\t\t if (Image == NULL)  // Should never happen except when we reach the end, but check anyway.\n\t\t break;\n\t\t */ \n\t} //for tiff directories\n\n\tTIFFClose(tif);\n\n\treturn ilFixImage();\n}",
    "ILboolean iSaveTiffInternal(/*ILconst_string Filename*/)\n{\n\tILenum\tFormat;\n\tILenum\tCompression;\n\tILuint\tixLine;\n\tTIFF\t*File;\n\tchar\tDescription[512];\n\tILimage *TempImage;\n\tconst char\t*str;\n\tILboolean SwapColors;\n\tILubyte *OldData;\n\n\tif(iCurImage == NULL) {\n\t\tilSetError(IL_ILLEGAL_OPERATION);\n\t\treturn IL_FALSE;\n\t}\n\n#if 1\n\tTIFFSetWarningHandler (NULL);\n\tTIFFSetErrorHandler   (NULL);\n#else\n\t//for debugging only\n\tTIFFSetWarningHandler(warningHandler);\n\tTIFFSetErrorHandler(errorHandler);\n#endif\n\tif (iGetHint(IL_COMPRESSION_HINT) == IL_USE_COMPRESSION)\n\t\tCompression = COMPRESSION_LZW;\n\telse\n\t\tCompression = COMPRESSION_NONE;\n\n\tif (iCurImage->Format == IL_COLOUR_INDEX) {\n\t\tif (ilGetBppPal(iCurImage->Pal.PalType) == 4)  // Preserve the alpha.\n\t\t\tTempImage = iConvertImage(iCurImage, IL_RGBA, IL_UNSIGNED_BYTE);\n\t\telse\n\t\t\tTempImage = iConvertImage(iCurImage, IL_RGB, IL_UNSIGNED_BYTE);\n\t\t\n\t\tif (TempImage == NULL) {\n\t\t\treturn IL_FALSE;\n\t\t}\n\t}\n\telse {\n\t\tTempImage = iCurImage;\n\t}\n\n\t/*#ifndef _UNICODE\n\t\tFile = TIFFOpen(Filename, \"w\");\n\t#else\n\t\tFile = TIFFOpenW(Filename, \"w\");\n\t#endif*/\n\n\t// Control writing functions ourself.\n\tFile = iTIFFOpen((char*)\"w\");\n\tif (File == NULL) {\n\t\tilSetError(IL_COULD_NOT_OPEN_FILE);\n\t\treturn IL_FALSE;\n\t}\n\n#ifdef _UNICODE\n\tsprintf(Description, \"Tiff generated by %Ls\", ilGetString(IL_VERSION_NUM));\n#else// _UNICODE\n\tsprintf(Description, \"Tiff generated by %s\", ilGetString(IL_VERSION_NUM));\n#endif// _UNICODE\n\n\tTIFFSetField(File, TIFFTAG_IMAGEWIDTH, TempImage->Width);\n\tTIFFSetField(File, TIFFTAG_IMAGELENGTH, TempImage->Height);\n\tTIFFSetField(File, TIFFTAG_COMPRESSION, Compression);\n\tTIFFSetField(File, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n\tTIFFSetField(File, TIFFTAG_BITSPERSAMPLE, TempImage->Bpc << 3);\n\tTIFFSetField(File, TIFFTAG_SAMPLESPERPIXEL, TempImage->Bpp);\n\tif (TempImage->Bpp == 4) //TODO: LUMINANCE, LUMINANCE_ALPHA\n\t\tTIFFSetField(File, TIFFTAG_MATTEING, 1);\n\tTIFFSetField(File, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\tTIFFSetField(File, TIFFTAG_ROWSPERSTRIP, 1);\n\tTIFFSetField(File, TIFFTAG_SOFTWARE, ilGetString(IL_VERSION_NUM));  //@TODO: Will probably not work properly under Windows if Unicode\n\t/*TIFFSetField(File, TIFFTAG_DOCUMENTNAME,\n\t\tiGetString(IL_TIF_DOCUMENTNAME_STRING) ?\n\t\tiGetString(IL_TIF_DOCUMENTNAME_STRING) : FileName);\n*/\n\tstr = iGetString(IL_TIF_DOCUMENTNAME_STRING);\n\tif (str) {\n\t\tTIFFSetField(File, TIFFTAG_DOCUMENTNAME, str);\n\t\tifree(str);\n\t}\n\n\n\tstr = iGetString(IL_TIF_AUTHNAME_STRING);\n\tif (iGetString(IL_TIF_AUTHNAME_STRING)) {\n\t\tTIFFSetField(File, TIFFTAG_ARTIST, str);\n\t\tifree(str);\n\t}\n\n\tstr = iGetString(IL_TIF_HOSTCOMPUTER_STRING);\n\tif (str) {\n\t\tTIFFSetField(File, TIFFTAG_HOSTCOMPUTER, str);\n\t\tifree(str);\n\t}\n\n\tstr = iGetString(IL_TIF_HOSTCOMPUTER_STRING);\n\tif (str) {\n\t\tTIFFSetField(File, TIFFTAG_IMAGEDESCRIPTION, str);\n\t\tifree(str);\n\t}\n\n\t// Set the date and time string.\n\tTIFFSetField(File, TIFFTAG_DATETIME, iMakeString());\n\n\t// 24/4/2003\n\t// Orientation flag is not always supported (Photoshop, ...), orient the image data \n\t// and set it always to normal view\n\tTIFFSetField(File, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n\tif (TempImage->Origin != IL_ORIGIN_UPPER_LEFT) {\n\t\tILubyte* Data = iGetFlipped(TempImage);\n\t\tOldData = TempImage->Data;\n\t\tTempImage->Data = Data;\n\t}\n\telse\n\t\tOldData = TempImage->Data;\n\n\t/*\n\t TIFFSetField(File, TIFFTAG_ORIENTATION,\n\t\t\t\t  TempImage->Origin == IL_ORIGIN_UPPER_LEFT ? ORIENTATION_TOPLEFT : ORIENTATION_BOTLEFT);\n\t */\n\n\tFormat = TempImage->Format;\n\tSwapColors = (Format == IL_BGR || Format == IL_BGRA);\n\tif (SwapColors)\n \t\tilSwapColours();\n\n\tfor (ixLine = 0; ixLine < TempImage->Height; ++ixLine) {\n\t\tif (TIFFWriteScanline(File, TempImage->Data + ixLine * TempImage->Bps, ixLine, 0) < 0) {\n\t\t\tTIFFClose(File);\n\t\t\tilSetError(IL_LIB_TIFF_ERROR);\n\t\t\tif (SwapColors)\n\t\t\t\tilSwapColours();\n\t\t\tif (TempImage->Data != OldData) {\n\t\t\t\tifree( TempImage->Data );\n\t\t\t\tTempImage->Data = OldData;\n\t\t\t}\n\t\t\tif (TempImage != iCurImage)\n\t\t\t\tilCloseImage(TempImage);\n\t\t\treturn IL_FALSE;\n\t\t}\n\t}\n\n\tif (SwapColors)\n \t\tilSwapColours();\n\n\tif (TempImage->Data != OldData) {\n\t\tifree(TempImage->Data);\n\t\tTempImage->Data = OldData;\n\t}\n\n\tif (TempImage != iCurImage)\n\t\tilCloseImage(TempImage);\n\n\tTIFFClose(File);\n\n\treturn IL_TRUE;\n}",
    "ByteImage::Ptr\nload_tiff_file (std::string const& filename)\n{\n    TIFFSetWarningHandler(nullptr);\n    TIFFSetErrorHandler(tiff_error_handler);\n\n    TIFF* tif = TIFFOpen(filename.c_str(), \"r\");\n    if (!tif)\n        throw util::Exception(\"TIFF file format not recognized\");\n\n    try\n    {\n        /* Read width and height from TIFF and create MVE image. */\n        uint32 width, height;\n        uint16 channels, bits;\n        TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n        TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n        TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &channels);\n        TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bits);\n        if (bits != 8)\n            throw util::Exception(\"Expected 8 bit TIFF file\");\n        ByteImage::Ptr image = ByteImage::create(width, height, channels);\n\n        /* Scanline based TIFF reading. */\n        uint32 rowstride = TIFFScanlineSize(tif);\n        ByteImage::ImageData& data = image->get_data();\n        for (uint32 row = 0; row < height; row++)\n        {\n            tdata_t row_pointer = &data[row * rowstride];\n            TIFFReadScanline(tif, row_pointer, row);\n        }\n\n        TIFFClose(tif);\n        return image;\n    }\n    catch (std::exception& e)\n    {\n        TIFFClose(tif);\n        throw;\n    }\n}",
    "RawImage::Ptr\nload_tiff_16_file (std::string const& filename)\n{\n    if (sizeof(uint16_t) != 2)\n        throw util::Exception(\"Need 16bit data type for TIFF image.\");\n\n    TIFFSetWarningHandler(nullptr);\n    TIFFSetErrorHandler(tiff_error_handler);\n\n    TIFF* tif = TIFFOpen(filename.c_str(), \"r\");\n    if (!tif)\n        throw util::Exception(\"TIFF file format not recognized\");\n\n    try\n    {\n        /* Read width and height from TIFF and create MVE image. */\n        uint32 width, height;\n        uint16 channels, bits;\n        TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n        TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n        TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &channels);\n        TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bits);\n        if (bits != 16)\n            throw util::Exception(\"TIFF file bits per sample don't match\");\n\n        RawImage::Ptr image = Image<uint16_t>::create(width, height, channels);\n\n        /* Scanline based TIFF reading. */\n        uint32 rowstride = TIFFScanlineSize(tif) / sizeof(uint16_t);\n        Image<uint16_t>::ImageData& data = image->get_data();\n        for (uint32 row = 0; row < height; row++)\n        {\n            tdata_t row_pointer = &data[row * rowstride];\n            TIFFReadScanline(tif, row_pointer, row);\n        }\n\n        TIFFClose(tif);\n        return image;\n    }\n    catch (std::exception& e)\n    {\n        TIFFClose(tif);\n        throw;\n    }\n}",
    "static FloatImage * loadFloatTIFF(const char * fileName, Stream & s)\n{\n    nvCheck(!s.isError());\n\n    TIFF * tif = TIFFOpen(fileName, \"r\");\n    //TIFF * tif = TIFFClientOpen(fileName, \"r\", &s, tiffReadWriteProc, tiffReadWriteProc, tiffSeekProc, tiffCloseProc, tiffSizeProc, tiffMapFileProc, tiffUnmapFileProc);\n\n    if (!tif)\n    {\n        nvDebug(\"Can't open '%s' for reading\\n\", fileName);\n        return NULL;\n    }\n\n    ::uint16 spp, bpp, format;\n    ::uint32 width, height;\n    TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n    TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n    TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bpp);\n    TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &spp);\n    TIFFGetField(tif, TIFFTAG_SAMPLEFORMAT, &format);\n\n    if (bpp != 8 && bpp != 16 && bpp != 32) {\n        nvDebug(\"Can't load '%s', only 1 sample per pixel supported\\n\", fileName);\n        TIFFClose(tif);\n        return NULL;\n    }\n\n    AutoPtr<FloatImage> fimage(new FloatImage());\n    fimage->allocate(spp, width, height);\n\n    int linesize = TIFFScanlineSize(tif);\n    tdata_t buf = malloc<uint8>(linesize);\n\n    for (uint y = 0; y < height; y++)\n    {\n        TIFFReadScanline(tif, buf, y, 0);\n\n\tfor (uint c=0; c<spp; c++ )\n\t{\n\t    float * dst = fimage->scanline(y, c);\n\n\t    for(uint x = 0; x < width; x++)\n\t    {\n\t\tif (bpp == 8)\n\t\t{\n\t\t\tdst[x] = float(((::uint8 *)buf)[x*spp+c]) / float(0xFF);\n\t\t}\n\t\telse if (bpp == 16)\n\t\t{\n\t\t\tdst[x] = float(((::uint16 *)buf)[x*spp+c]) / float(0xFFFF);\n\t\t}\n\t\telse if (bpp == 32)\n\t\t{\n\t\t    if (format==SAMPLEFORMAT_IEEEFP)\n\t\t    {\n\t\t\tdst[x] = float(((float *)buf)[x*spp+c]);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tdst[x] = float(((::uint32 *)buf)[x*spp+c] >> 8) / float(0xFFFFFF);\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n\n    free(buf);\n\n    TIFFClose(tif);\n\n    return fimage.release();\n}",
    "int Tiff16SourcePlugin::understands(QSettings *cfg, const QString& filename) const {\n  Q_UNUSED(cfg)\n\n  quint16 spp, bpp, is_tiled;\n\n  if (filename.toLower().endsWith(\".tiff\") ||\n      filename.toLower().endsWith(\".tif\")) {\n\n    TIFF *tif=TIFFOpen(filename.toAscii(), \"r\");\n\n    if (tif) {\n      TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bpp);\n      TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &spp);\n      is_tiled = TIFFIsTiled(tif);\n\n      TIFFClose(tif);\n\n\n      if ((bpp == 16) && (spp = 1) && (is_tiled == 0)) {\n          return 91;\n      }\n    }\n  }\n  return 0;\n}",
    "TiffLoader::~TiffLoader()\n{\n    if( m_tiff ) TIFFClose( m_tiff );\n}",
    "JNIEXPORT jboolean JNICALL LCTIFFWriter_METHOD(append)\n    ( JNIEnv *env, jobject jLCTIFFWriter, jstring jFileName )\n{\n    TIFF *const destTIFF = getNativePtr( env, jLCTIFFWriter );\n    TIFFSetField( destTIFF, TIFFTAG_PAGENUMBER, 0, 2 );\n    int result = TIFFWriteDirectory( destTIFF );\n    if ( !result )\n        return JNI_FALSE;\n    jstring_to_c const cFileName( env, jFileName );\n    TIFF *const srcTIFF = LC_TIFFOpen( cFileName, \"r\" );\n    if ( !srcTIFF )\n        return JNI_FALSE;\n    if ( isLightZoneLayeredTIFF( srcTIFF ) )\n        TIFFReadDirectory( srcTIFF );\n    result = tiffcp( srcTIFF, destTIFF );\n    TIFFSetField( destTIFF, TIFFTAG_PAGENUMBER, 1, 2 );\n    TIFFClose( srcTIFF );\n    return result ? JNI_TRUE : JNI_FALSE;\n}",
    "heif_error loadTIFF(const char* filename, InputImage *input_image) {\n  TIFFSetWarningHandler(suppress_warnings);\n\n  std::unique_ptr<TIFF, void(*)(TIFF*)> tifPtr(TIFFOpen(filename, \"r\"), [](TIFF* tif) { TIFFClose(tif); });\n  if (!tifPtr) {\n    struct heif_error err = {\n      .code = heif_error_Invalid_input,\n      .subcode = heif_suberror_Unspecified,\n      .message = \"Cannot open TIFF ile\"};\n    return err;\n  }\n\n  TIFF* tif = tifPtr.get();\n  if (TIFFIsTiled(tif)) {\n    struct heif_error err = {\n      .code = heif_error_Unsupported_feature,\n      .subcode = heif_suberror_Unspecified,\n      .message = \"Tiled TIFF images are not supported yet\"};\n    return err;\n  }\n\n  uint16_t shortv, samplesPerPixel, bps, config, format;\n  if (TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &shortv) && shortv == PHOTOMETRIC_PALETTE) {\n    struct heif_error err = {\n      .code = heif_error_Unsupported_feature,\n      .subcode = heif_suberror_Unspecified,\n      .message = \"Palette TIFF images are not supported yet\"};\n    return err;\n  }\n\n  TIFFGetField(tif, TIFFTAG_PLANARCONFIG, &config);\n  TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &samplesPerPixel);\n  if (samplesPerPixel != 1 && samplesPerPixel != 3 && samplesPerPixel != 4) {\n    struct heif_error err = {\n      .code = heif_error_Invalid_input,\n      .subcode = heif_suberror_Unspecified,\n      .message = \"Only 1, 3 and 4 samples per pixel are supported.\"};\n    return err;\n  }\n\n  TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bps);\n  if (bps != 8) {    \n    struct heif_error err = {\n      .code = heif_error_Invalid_input,\n      .subcode = heif_suberror_Unspecified,\n      .message = \"Only 8 bits per sample are supported.\"};\n    return err;\n  }\n\n  if (TIFFGetField(tif, TIFFTAG_SAMPLEFORMAT, &format) && format != SAMPLEFORMAT_UINT) {\n    struct heif_error err = {\n      .code = heif_error_Invalid_input,\n      .subcode = heif_suberror_Unspecified,\n      .message = \"Only UINT sample format is supported.\"};\n    return err;\n  }\n\n  struct heif_error err;\n  struct heif_image* image = nullptr;\n\n  switch (config) {\n    case PLANARCONFIG_CONTIG:\n      err = readPixelInterleave(tif, samplesPerPixel, &image);\n      break;\n    case PLANARCONFIG_SEPARATE:\n      err = readBandInterleave(tif, samplesPerPixel, &image);\n      break;\n    default:\n      struct heif_error err = {\n        .code = heif_error_Invalid_input,\n        .subcode = heif_suberror_Unspecified,\n        .message = \"Unsupported planar configuration\"};\n      return err;\n  }\n  if (err.code != heif_error_Ok) {\n    return err;\n  }\n\n  input_image->image = std::shared_ptr<heif_image>(image,\n                                          [](heif_image* img) { heif_image_release(img); });\n\n  // Unfortunately libtiff doesn't provide a way to read a raw dictionary.\n  // Therefore we manually parse the EXIF data, extract the tags and encode\n  // them for use in the HEIF image.\n  std::unique_ptr<ExifTags> tags = ExifTags::Parse(tif);\n  if (tags) {\n    tags->Encode(&(input_image->exif));\n  }\n  return heif_error_ok;\n}",
    "bool TiffEncoder::Encode(const struct heif_image_handle *handle,\n                         const struct heif_image *image, const std::string &filename)\n{\n    TIFF *tif = TIFFOpen(filename.c_str(), \"w\");\n\n    // For now we write interleaved\n    int width = heif_image_get_width(image, heif_channel_interleaved);\n    int height = heif_image_get_height(image, heif_channel_interleaved);\n    bool hasAlpha = ((heif_image_get_chroma_format(image) == heif_chroma_interleaved_RGBA) ||\n                     (heif_image_get_chroma_format(image) == heif_chroma_interleaved_RRGGBBAA_BE));\n    int input_bpp = heif_image_get_bits_per_pixel_range(image, heif_channel_interleaved);\n\n    TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, width);\n    TIFFSetField(tif, TIFFTAG_IMAGELENGTH, height);\n    TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, input_bpp);\n    TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, hasAlpha ? 4 : 3);\n    if (hasAlpha)\n    {\n        // TODO: is alpha premultiplied?\n        uint16_t extra_samples[1] = {EXTRASAMPLE_UNASSALPHA};\n        TIFFSetField(tif, TIFFTAG_EXTRASAMPLES, 1, &extra_samples);\n    }\n    TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, 1);\n    TIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n    TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n    TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT);\n    TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n\n    int stride_rgb;\n    const uint8_t *row_rgb = heif_image_get_plane_readonly(image,\n                                                           heif_channel_interleaved, &stride_rgb);\n\n    for (int i = 0; i < height; i++)\n    {\n        // memcpy(scan_line, &buffer[i * width], width * sizeof(uint32));\n        TIFFWriteScanline(tif, (void *)(&(row_rgb[i * stride_rgb])), i, 0);\n    }\n    TIFFClose(tif);\n    return true;\n}",
    "bool tiffToQImage( const char * data, int size, QImage & image )\n{\n  QByteArray arr = QByteArray::fromRawData( data, size );\n  QBuffer buf;\n  buf.setData( arr );\n  buf.open( QIODevice::ReadOnly );\n\n  TIFF *const tiff = TIFFClientOpen( \"foo\",\n                                     \"r\",\n                                     &buf,\n                                     tiffReadProc,\n                                     tiffWriteProc,\n                                     tiffSeekProc,\n                                     tiffCloseProc,\n                                     tiffSizeProc,\n                                     tiffMapProc,\n                                     tiffUnmapProc );\n  if( !tiff )\n    return false;\n\n  Uint32 width, height;\n  if( !TIFFGetField( tiff, TIFFTAG_IMAGEWIDTH, &width )\n      || !TIFFGetField( tiff, TIFFTAG_IMAGELENGTH, &height ) )\n  {\n    TIFFClose( tiff );\n    return false;\n  }\n\n  Uint16 bitPerSample;\n  if( !TIFFGetField( tiff, TIFFTAG_BITSPERSAMPLE, &bitPerSample ) )\n    bitPerSample = 1;\n\n  Uint16 samplesPerPixel; // they may be e.g. grayscale with 2 samples per pixel\n  if( !TIFFGetField( tiff, TIFFTAG_SAMPLESPERPIXEL, &samplesPerPixel ) )\n    samplesPerPixel = 1;\n\n  if( bitPerSample == 1 && samplesPerPixel == 1 )\n  {\n    QImage tiffImage( width, height, QImage::Format_Mono );\n\n    QVector<QRgb> colortable( 2 );\n    colortable[0] = 0xffffffff;\n    colortable[1] = 0xff000000;\n    tiffImage.setColorTable( colortable );\n\n    for ( Uint32 y = 0; y < height; ++y )\n    {\n      if( TIFFReadScanline( tiff, tiffImage.scanLine( y ), y, 0 ) < 0 )\n      {\n        TIFFClose( tiff );\n        return false;\n      }\n    }\n\n    image = tiffImage;\n    TIFFClose( tiff );\n    return true;\n  }\n\n  TIFFClose( tiff );\n  return false;\n}",
    "bool Image::initWithTiffData(const unsigned char * data, ssize_t dataLen)\n{\n#if CC_USE_TIFF\n    bool ret = false;\n    do \n    {\n        // set the read call back function\n        tImageSource imageSource;\n        imageSource.data    = data;\n        imageSource.size    = dataLen;\n        imageSource.offset  = 0;\n\n        TIFF* tif = TIFFClientOpen(\"file.tif\", \"r\", (thandle_t)&imageSource, \n            tiffReadProc, tiffWriteProc,\n            tiffSeekProc, tiffCloseProc, tiffSizeProc,\n            tiffMapProc,\n            tiffUnmapProc);\n\n        CC_BREAK_IF(nullptr == tif);\n\n        uint32 w = 0, h = 0;\n        uint16 bitsPerSample = 0, samplePerPixel = 0, planarConfig = 0;\n        size_t npixels = 0;\n        \n        TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w);\n        TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\n        TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bitsPerSample);\n        TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &samplePerPixel);\n        TIFFGetField(tif, TIFFTAG_PLANARCONFIG, &planarConfig);\n\n        npixels = w * h;\n        \n        _renderFormat = Texture2D::PixelFormat::RGBA8888;\n        _width = w;\n        _height = h;\n\n        _dataLen = npixels * sizeof (uint32);\n        _data = static_cast<unsigned char*>(malloc(_dataLen * sizeof(unsigned char)));\n\n        uint32* raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n        if (raster != nullptr) \n        {\n           if (TIFFReadRGBAImageOriented(tif, w, h, raster, ORIENTATION_TOPLEFT, 0))\n           {\n                /* the raster data is pre-multiplied by the alpha component \n                   after invoking TIFFReadRGBAImageOriented*/\n                _hasPremultipliedAlpha = true;\n\n               memcpy(_data, raster, npixels*sizeof (uint32));\n           }\n\n          _TIFFfree(raster);\n        }\n        \n\n        TIFFClose(tif);\n\n        ret = true;\n    } while (0);\n    return ret;\n#else\n    CCLOG(\"tiff is not enabled, please enalbe it in ccConfig.h\");\n    return false;\n#endif\n}",
    "bool CxImageTIF::Decode(CxFile * hFile)\r\n{\r\n\t//Comment this line if you need more information on errors\r\n\t// TIFFSetErrorHandler(NULL);\t//<Patrick Hoffmann>\r\n\r\n\t//Open file and fill the TIFF structure\r\n\t// m_tif = TIFFOpen(imageFileName,\"rb\");\r\n\tTIFF* m_tif = _TIFFOpenEx(hFile, \"rb\");\r\n\r\n\tuint32 height=0;\r\n\tuint32 width=0;\r\n\tuint16 bitspersample=1;\r\n\tuint16 samplesperpixel=1;\r\n\tuint32 rowsperstrip=(DWORD)-1;\r\n\tuint16 photometric=0;\r\n\tuint16 compression=1;\r\n\tuint16 orientation=ORIENTATION_TOPLEFT; //<vho>\r\n\tuint16 res_unit; //<Trifon>\r\n\tuint32 x, y;\r\n\tfloat resolution, offset;\r\n\tBOOL isRGB;\r\n\tBYTE *bits;\t\t//pointer to source data\r\n\tBYTE *bits2;\t//pointer to destination data\r\n\r\n  try{\r\n\t//check if it's a tiff file\r\n\tif (!m_tif)\r\n\t\tthrow \"Error encountered while opening TIFF file\";\r\n\r\n\t// <Robert Abram> - 12/2002 : get NumFrames directly, instead of looping\r\n\t// info.nNumFrames=0;\r\n\t// while(TIFFSetDirectory(m_tif,(uint16)info.nNumFrames)) info.nNumFrames++;\r\n\tinfo.nNumFrames = TIFFNumberOfDirectories(m_tif);\r\n\r\n\tif (!TIFFSetDirectory(m_tif, (uint16)info.nFrame))\r\n\t\tthrow \"Error: page not present in TIFF file\";\t\t\t\r\n\r\n\t//get image info\r\n\tTIFFGetField(m_tif, TIFFTAG_IMAGEWIDTH, &width);\r\n\tTIFFGetField(m_tif, TIFFTAG_IMAGELENGTH, &height);\r\n\tTIFFGetField(m_tif, TIFFTAG_SAMPLESPERPIXEL, &samplesperpixel);\r\n\tTIFFGetField(m_tif, TIFFTAG_BITSPERSAMPLE, &bitspersample);\r\n\tTIFFGetField(m_tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);   \r\n\tTIFFGetField(m_tif, TIFFTAG_PHOTOMETRIC, &photometric);\r\n\tTIFFGetField(m_tif, TIFFTAG_ORIENTATION, &orientation);\r\n\r\n\tif (info.nEscape == -1) {\r\n\t\t// Return output dimensions only\r\n\t\thead.biWidth = width;\r\n\t\thead.biHeight = height;\r\n\t\tthrow \"output dimensions returned\";\r\n\t}\r\n\r\n\tTIFFGetFieldDefaulted(m_tif, TIFFTAG_RESOLUTIONUNIT, &res_unit);\r\n\tif (TIFFGetField(m_tif, TIFFTAG_XRESOLUTION, &resolution))\r\n\t{\r\n\t\tif (res_unit == RESUNIT_CENTIMETER) resolution = (float)(resolution*2.54f + 0.5f);\r\n\t\tSetXDPI((long)resolution);\r\n\t}\r\n\tif (TIFFGetField(m_tif, TIFFTAG_YRESOLUTION, &resolution))\r\n\t{\r\n\t\tif (res_unit == RESUNIT_CENTIMETER) resolution = (float)(resolution*2.54f + 0.5f);\r\n\t\tSetYDPI((long)resolution);\r\n\t}\r\n\r\n\tif (TIFFGetField(m_tif, TIFFTAG_XPOSITION, &offset))\tinfo.xOffset = (long)offset;\r\n\tif (TIFFGetField(m_tif, TIFFTAG_YPOSITION, &offset))\tinfo.yOffset = (long)offset;\r\n\r\n\thead.biClrUsed=0;\r\n\tinfo.nBkgndIndex =-1;\r\n\r\n\tif (rowsperstrip>height){\r\n\t\trowsperstrip=height;\r\n\t\tTIFFSetField(m_tif, TIFFTAG_ROWSPERSTRIP, rowsperstrip);\r\n\t}\r\n\r\n\tisRGB = (bitspersample >= 8) &&\r\n\t\t(photometric == PHOTOMETRIC_RGB) ||\r\n\t\t(photometric == PHOTOMETRIC_YCBCR) ||\r\n\t\t(photometric == PHOTOMETRIC_SEPARATED) ||\r\n\t\t(photometric == PHOTOMETRIC_LOGL) ||\r\n\t\t(photometric == PHOTOMETRIC_LOGLUV);\r\n\r\n\tif (isRGB){\r\n\t\thead.biBitCount=24;\r\n\t}else{\r\n\t\tif ((photometric==PHOTOMETRIC_MINISBLACK)||(photometric==PHOTOMETRIC_MINISWHITE)){\r\n\t\t\tif\t(bitspersample == 1){\r\n\t\t\t\thead.biBitCount=1;\t\t//B&W image\r\n\t\t\t\thead.biClrUsed =2;\r\n\t\t\t} else if (bitspersample == 4) {\r\n\t\t\t\thead.biBitCount=4;\t\t//16 colors gray scale\r\n\t\t\t\thead.biClrUsed =16;\r\n\t\t\t} else {\r\n\t\t\t\thead.biBitCount=8;\t\t//gray scale\r\n\t\t\t\thead.biClrUsed =256;\r\n\t\t\t}\r\n\t\t} else if (bitspersample == 4) {\r\n\t\t\thead.biBitCount=4;\t\t\t// 16 colors\r\n\t\t\thead.biClrUsed=16;\r\n\t\t} else {\r\n\t\t\thead.biBitCount=8;\t\t\t//256 colors\r\n\t\t\thead.biClrUsed=256;\r\n\t\t}\r\n\t}\r\n\r\n\tif (info.nEscape) throw \"Cancelled\"; // <vho> - cancel decoding\r\n\r\n\tCreate(width,height,head.biBitCount,CXIMAGE_FORMAT_TIF);\t//image creation\r\n\tif (!pDib) throw \"CxImageTIF can't create image\";\r\n\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\tif (samplesperpixel==4) AlphaCreate();\t//add alpha support for 32bpp tiffs\r\n\tif (samplesperpixel==2 && bitspersample==8) AlphaCreate();\t//add alpha support for 8bpp + alpha\r\n#endif //CXIMAGE_SUPPORT_ALPHA\r\n\r\n\tTIFFGetField(m_tif, TIFFTAG_COMPRESSION, &compression);\r\n\tSetCodecOption(compression); // <DPR> save original compression type\r\n\r\n\tif (isRGB) {\r\n\t\t// Read the whole image into one big RGBA buffer using\r\n\t\t// the traditional TIFFReadRGBAImage() API that we trust.\r\n\t\tuint32* raster;\t\t// retrieve RGBA image\r\n\t\tuint32 *row;\r\n\r\n\t\traster = (uint32*)_TIFFmalloc(width * height * sizeof (uint32));\r\n\t\tif (raster == NULL) throw \"No space for raster buffer\";\r\n\t\t\t\r\n\t\t// Read the image in one chunk into an RGBA array\r\n\t\tif(!TIFFReadRGBAImage(m_tif, width, height, raster, 1)) {\r\n\t\t\t\t_TIFFfree(raster);\r\n\t\t\t\tthrow \"Corrupted TIFF file!\";\r\n\t\t}\r\n\r\n\t\t// read the raster lines and save them in the DIB\r\n\t\t// with RGB mode, we have to change the order of the 3 samples RGB\r\n\t\trow = &raster[0];\r\n\t\tbits2 = info.pImage;\r\n\t\tfor (y = 0; y < height; y++) {\r\n\r\n\t\t\tif (info.nEscape){ // <vho> - cancel decoding\r\n\t\t\t\t_TIFFfree(raster);\r\n\t\t\t\tthrow \"Cancelled\";\r\n\t\t\t}\r\n\r\n\t\t\tbits = bits2;\r\n\t\t\tfor (x = 0; x < width; x++) {\r\n\t\t\t\t*bits++ = (BYTE)TIFFGetB(row[x]);\r\n\t\t\t\t*bits++ = (BYTE)TIFFGetG(row[x]);\r\n\t\t\t\t*bits++ = (BYTE)TIFFGetR(row[x]);\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\t\t\t\tif (samplesperpixel==4) AlphaSet(x,y,(BYTE)TIFFGetA(row[x]));\r\n#endif //CXIMAGE_SUPPORT_ALPHA\r\n\t\t\t}\r\n\t\t\trow += width;\r\n\t\t\tbits2 += info.dwEffWidth;\r\n\t\t}\r\n\t\t_TIFFfree(raster);\r\n\t} else {\r\n\t\tRGBQUAD *pal;\r\n\t\tpal=(RGBQUAD*)calloc(256,sizeof(RGBQUAD));\r\n\t\tif (pal==NULL) throw \"Unable to allocate TIFF palette\";\r\n\r\n\t\t// set up the colormap based on photometric\t\r\n\t\tswitch(photometric) {\r\n\t\t\tcase PHOTOMETRIC_MINISBLACK:\t// bitmap and greyscale image types\r\n\t\t\tcase PHOTOMETRIC_MINISWHITE:\r\n\t\t\t\tif (bitspersample == 1) {\t// Monochrome image\r\n\t\t\t\t\tif (photometric == PHOTOMETRIC_MINISBLACK) {\r\n\t\t\t\t\t\tpal[1].rgbRed = pal[1].rgbGreen = pal[1].rgbBlue = 255;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tpal[0].rgbRed = pal[0].rgbGreen = pal[0].rgbBlue = 255;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\t\t// need to build the scale for greyscale images\r\n\t\t\t\t\tif (photometric == PHOTOMETRIC_MINISBLACK) {\r\n\t\t\t\t\t\tfor (DWORD i=0; i<head.biClrUsed; i++){\r\n\t\t\t\t\t\t\tpal[i].rgbRed = pal[i].rgbGreen = pal[i].rgbBlue = (BYTE)(i*(255/(head.biClrUsed-1)));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tfor (DWORD i=0; i<head.biClrUsed; i++){\r\n\t\t\t\t\t\t\tpal[i].rgbRed = pal[i].rgbGreen = pal[i].rgbBlue = (BYTE)(255-i*(255/(head.biClrUsed-1)));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase PHOTOMETRIC_PALETTE:\t// color map indexed\r\n\t\t\t\tuint16 *red;\r\n\t\t\t\tuint16 *green;\r\n\t\t\t\tuint16 *blue;\r\n\t\t\t\tTIFFGetField(m_tif, TIFFTAG_COLORMAP, &red, &green, &blue); \r\n\r\n\t\t\t\t// Is the palette 16 or 8 bits ?\r\n\t\t\t\tBOOL Palette16Bits = FALSE;\r\n\t\t\t\tint n=1<<bitspersample;\r\n\t\t\t\twhile (n-- > 0) {\r\n\t\t\t\t\tif (red[n] >= 256 || green[n] >= 256 || blue[n] >= 256) {\r\n\t\t\t\t\t\tPalette16Bits=TRUE;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// load the palette in the DIB\r\n\t\t\t\tfor (int i = (1 << bitspersample) - 1; i >= 0; i--) {\r\n\t\t\t\t\tif (Palette16Bits) {\r\n\t\t\t\t\t\tpal[i].rgbRed =(BYTE) CVT(red[i]);\r\n\t\t\t\t\t\tpal[i].rgbGreen = (BYTE) CVT(green[i]);\r\n\t\t\t\t\t\tpal[i].rgbBlue = (BYTE) CVT(blue[i]);           \r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tpal[i].rgbRed = (BYTE) red[i];\r\n\t\t\t\t\t\tpal[i].rgbGreen = (BYTE) green[i];\r\n\t\t\t\t\t\tpal[i].rgbBlue = (BYTE) blue[i];        \r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t\tSetPalette(pal,head.biClrUsed);\t//palette assign\r\n\t\tfree(pal);\r\n\r\n\t\t// read the tiff lines and save them in the DIB\r\n\t\tuint32 nrow;\r\n\t\tuint32 ys;\r\n\t\tint line = CalculateLine(width, bitspersample * samplesperpixel);\r\n\t\tlong bitsize= TIFFStripSize(m_tif);\r\n\t\t//verify bitsize: could be wrong if StripByteCounts is missing.\r\n\t\tif (bitsize>(long)(head.biSizeImage*samplesperpixel)) bitsize=head.biSizeImage*samplesperpixel;\r\n\r\n\t\tint tiled_image = TIFFIsTiled(m_tif);\r\n\t\tuint32 tw, tl;\r\n\t\tBYTE* tilebuf;\r\n\t\tif (tiled_image){\r\n\t\t\tTIFFGetField(m_tif, TIFFTAG_TILEWIDTH, &tw);\r\n\t\t\tTIFFGetField(m_tif, TIFFTAG_TILELENGTH, &tl);\r\n\t\t\trowsperstrip = tl;\r\n\t\t\tbitsize = TIFFTileSize(m_tif) * (int)(1+width/tw);\r\n\t\t\ttilebuf = (BYTE*)malloc(TIFFTileSize(m_tif));\r\n\t\t}\r\n\t\t\r\n\t\tbits = (BYTE*)malloc(bitsize);\r\n\t\tif (bits==NULL){\r\n\t\t\tthrow \"CxImageTIF can't allocate memory\";\r\n\t\t}\r\n\r\n\t\tfor (ys = 0; ys < height; ys += rowsperstrip) {\r\n\r\n\t\t\tif (info.nEscape){ // <vho> - cancel decoding\r\n\t\t\t\tfree(bits);\r\n\t\t\t\tthrow \"Cancelled\";\r\n\t\t\t}\r\n\r\n\t\t\tnrow = (ys + rowsperstrip > height ? height - ys : rowsperstrip);\r\n\r\n\t\t\tif (tiled_image){\r\n\t\t\t\tuint32 imagew = TIFFScanlineSize(m_tif);\r\n\t\t\t\tuint32 tilew  = TIFFTileRowSize(m_tif);\r\n\t\t\t\tint iskew = imagew - tilew;\r\n\t\t\t\tuint8* bufp = (uint8*) bits;\r\n\r\n\t\t\t\tuint32 colb = 0;\r\n\t\t\t\tfor (uint32 col = 0; col < width; col += tw) {\r\n\t\t\t\t\tif (TIFFReadTile(m_tif, tilebuf, col, ys, 0, 0) < 0){\r\n\t\t\t\t\t\tfree(tilebuf);\r\n\t\t\t\t\t\tfree(bits);\r\n\t\t\t\t\t\tthrow \"Corrupted tiled TIFF file!\";\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (colb + tw > imagew) {\r\n\t\t\t\t\t\tuint32 owidth = imagew - colb;\r\n\t\t\t\t\t\tuint32 oskew = tilew - owidth;\r\n\t\t\t\t\t\tTileToStrip(bufp + colb, tilebuf, nrow, owidth, oskew + iskew, oskew );\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tTileToStrip(bufp + colb, tilebuf, nrow, tilew, iskew, 0);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcolb += tilew;\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\t\t\t\tif (TIFFReadEncodedStrip(m_tif, TIFFComputeStrip(m_tif, ys, 0), bits, nrow * line) == -1) {\r\n\t\t\t\t\tfree(bits);\r\n\t\t\t\t\tthrow \"Corrupted TIFF file!\";\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tfor (y = 0; y < nrow; y++) {\r\n\t\t\t\tlong offset=(nrow-y-1)*line;\r\n\t\t\t\tif (bitspersample==16) for (DWORD xi=0;xi<width;xi++) bits[xi+offset]=bits[xi*2+offset+1];\r\n\t\t\t\tif (samplesperpixel==1) { //simple 8bpp image\r\n\t\t\t\t\tmemcpy(info.pImage+info.dwEffWidth*(height-ys-nrow+y),bits+offset,info.dwEffWidth);\r\n\t\t\t\t} else if (samplesperpixel==2) { //8bpp image with alpha layer\r\n\t\t\t\t\tint xi=0;\r\n\t\t\t\t\tint ii=0;\r\n\t\t\t\t\tint yi=height-ys-nrow+y;\r\n\t\t\t\t\twhile (ii<line){\r\n\t\t\t\t\t\tSetPixelIndex(xi,yi,bits[ii+offset]);\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\t\t\t\t\t\tAlphaSet(xi,yi,bits[ii+offset+1]);\r\n#endif //CXIMAGE_SUPPORT_ALPHA\r\n\t\t\t\t\t\tii+=2;\r\n\t\t\t\t\t\txi++;\r\n\t\t\t\t\t\tif (xi>=(int)width){\r\n\t\t\t\t\t\t\tyi--;\r\n\t\t\t\t\t\t\txi=0;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else { //photometric==PHOTOMETRIC_CIELAB\r\n\t\t\t\t\tif (head.biBitCount!=24){ //fix image\r\n\t\t\t\t\t\tCreate(width,height,24,CXIMAGE_FORMAT_TIF);\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\t\t\t\t\t\tif (samplesperpixel==4) AlphaCreate();\r\n#endif //CXIMAGE_SUPPORT_ALPHA\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tint xi=0;\r\n\t\t\t\t\tint ii=0;\r\n\t\t\t\t\tint yi=height-ys-nrow+y;\r\n\t\t\t\t\tRGBQUAD c;\r\n\t\t\t\t\tint l,a,b,bitsoffset;\r\n\t\t\t\t\tdouble p,cx,cy,cz,cr,cg,cb;\r\n\t\t\t\t\twhile (ii<line){\r\n\t\t\t\t\t\tbitsoffset = ii*samplesperpixel+offset;\r\n\t\t\t\t\t\tl=bits[bitsoffset];\r\n\t\t\t\t\t\ta=bits[bitsoffset+1];\r\n\t\t\t\t\t\tb=bits[bitsoffset+2];\r\n\t\t\t\t\t\tif (a>127) a-=256;\r\n\t\t\t\t\t\tif (b>127) b-=256;\r\n\t\t\t\t\t\t// lab to xyz\r\n\t\t\t\t\t\tp = (l/2.55 + 16) / 116.0;\r\n\t\t\t\t\t\tcx = pow( p + a * 0.002, 3);\r\n\t\t\t\t\t\tcy = pow( p, 3);\r\n\t\t\t\t\t\tcz = pow( p - b * 0.005, 3);\r\n\t\t\t\t\t\t// white point\r\n\t\t\t\t\t\tcx*=0.95047;\r\n\t\t\t\t\t\t//cy*=1.000;\r\n\t\t\t\t\t\tcz*=1.0883;\r\n\t\t\t\t\t\t// xyz to rgb\r\n\t\t\t\t\t\tcr =  3.240479 * cx - 1.537150 * cy - 0.498535 * cz;\r\n\t\t\t\t\t\tcg = -0.969256 * cx + 1.875992 * cy + 0.041556 * cz;\r\n\t\t\t\t\t\tcb =  0.055648 * cx - 0.204043 * cy + 1.057311 * cz;\r\n\r\n\t\t\t\t\t\tif ( cr > 0.00304 ) cr = 1.055 * pow(cr,0.41667) - 0.055;\r\n\t\t\t\t\t\t\telse            cr = 12.92 * cr;\r\n\t\t\t\t\t\tif ( cg > 0.00304 ) cg = 1.055 * pow(cg,0.41667) - 0.055;\r\n\t\t\t\t\t\t\telse            cg = 12.92 * cg;\r\n\t\t\t\t\t\tif ( cb > 0.00304 ) cb = 1.055 * pow(cb,0.41667) - 0.055;\r\n\t\t\t\t\t\t\telse            cb = 12.92 * cb;\r\n\r\n\t\t\t\t\t\tc.rgbRed  =(BYTE)max(0,min(255,(int)(cr*255)));\r\n\t\t\t\t\t\tc.rgbGreen=(BYTE)max(0,min(255,(int)(cg*255)));\r\n\t\t\t\t\t\tc.rgbBlue =(BYTE)max(0,min(255,(int)(cb*255)));\r\n\r\n\t\t\t\t\t\tSetPixelColor(xi,yi,c);\r\n#if CXIMAGE_SUPPORT_ALPHA\r\n\t\t\t\t\t\tif (samplesperpixel==4) AlphaSet(xi,yi,bits[bitsoffset+3]);\r\n#endif //CXIMAGE_SUPPORT_ALPHA\r\n\t\t\t\t\t\tii++;\r\n\t\t\t\t\t\txi++;\r\n\t\t\t\t\t\tif (xi>=(int)width){\r\n\t\t\t\t\t\t\tyi--;\r\n\t\t\t\t\t\t\txi=0;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tfree(bits);\r\n\t\tif (tiled_image) free(tilebuf);\r\n\r\n\t\tswitch(orientation){\r\n\t\tcase ORIENTATION_TOPRIGHT: /* row 0 top, col 0 rhs */\r\n\t\t\tMirror();\r\n\t\t\tbreak;\r\n\t\tcase ORIENTATION_BOTRIGHT: /* row 0 bottom, col 0 rhs */\r\n\t\t\tFlip();\r\n\t\t\tMirror();\r\n\t\t\tbreak;\r\n\t\tcase ORIENTATION_BOTLEFT: /* row 0 bottom, col 0 lhs */\r\n\t\t\tFlip();\r\n\t\t\tbreak;\r\n\t\tcase ORIENTATION_LEFTTOP: /* row 0 lhs, col 0 top */\r\n\t\t\tRotateRight();\r\n\t\t\tMirror();\r\n\t\t\tbreak;\r\n\t\tcase ORIENTATION_RIGHTTOP: /* row 0 rhs, col 0 top */\r\n\t\t\tRotateLeft();\r\n\t\t\tbreak;\r\n\t\tcase ORIENTATION_RIGHTBOT: /* row 0 rhs, col 0 bottom */\r\n\t\t\tRotateLeft();\r\n\t\t\tMirror();\r\n\t\t\tbreak;\r\n\t\tcase ORIENTATION_LEFTBOT: /* row 0 lhs, col 0 bottom */\r\n\t\t\tRotateRight();\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t}\r\n  } catch (char *message) {\r\n\t  strncpy(info.szLastError,message,255);\r\n\t  if (m_tif) TIFFClose(m_tif);\r\n\t  if (info.nEscape==-1) return true;\r\n\t  return false;\r\n  }\r\n\tTIFFClose(m_tif);\r\n\treturn true;\r\n}",
    "bool CxImageTIF::Encode(CxFile * hFile, bool bAppend)\r\n{\r\n  try{\r\n\tif (hFile==NULL) throw CXIMAGE_ERR_NOFILE;\r\n\tif (pDib==NULL) throw CXIMAGE_ERR_NOIMAGE;\r\n\r\n\t// <RJ> replaced \"w+b\" with \"a\", to append an image directly on an existing file\r\n\tif (m_tif2==NULL) m_tif2=_TIFFOpenEx(hFile, \"a\");\r\n\tif (m_tif2==NULL) throw \"initialization fail\";\r\n\r\n\tif (bAppend || m_pages) m_multipage=true;\r\n\tm_pages++;\r\n\r\n\tif (!EncodeBody(m_tif2,m_multipage,m_pages,m_pages)) throw \"Error saving TIFF file\";\r\n\tif (bAppend) {\r\n\t\tif (!TIFFWriteDirectory(m_tif2)) throw \"Error saving TIFF directory\";\r\n\t}\r\n  } catch (char *message) {\r\n\t  strncpy(info.szLastError,message,255);\r\n\t  if (m_tif2){\r\n\t\t  TIFFClose(m_tif2);\r\n\t\t  m_tif2=NULL;\r\n\t\t  m_multipage=false;\r\n\t\t  m_pages=0;\r\n\t  }\r\n\t  return false;\r\n  }\r\n\tif (!bAppend){\r\n\t\tTIFFClose(m_tif2);\r\n\t\tm_tif2=NULL;\r\n\t\tm_multipage=false;\r\n\t\tm_pages=0;\r\n\t}\r\n\treturn true;\r\n}",
    "bool wxTIFFHandler::LoadFile( wxImage *image, wxInputStream& stream, bool verbose, int index )\n{\n    if (index == -1)\n        index = 0;\n\n    image->Destroy();\n\n    TIFF *tif = TIFFwxOpen( stream, \"image\", \"r\" );\n\n    if (!tif)\n    {\n        if (verbose)\n        {\n            wxLogError( _(\"TIFF: Error loading image.\") );\n        }\n\n        return false;\n    }\n\n    if (!TIFFSetDirectory( tif, (tdir_t)index ))\n    {\n        if (verbose)\n        {\n            wxLogError( _(\"Invalid TIFF image index.\") );\n        }\n\n        TIFFClose( tif );\n\n        return false;\n    }\n\n    uint32 w, h;\n    uint32 *raster;\n\n    TIFFGetField( tif, TIFFTAG_IMAGEWIDTH, &w );\n    TIFFGetField( tif, TIFFTAG_IMAGELENGTH, &h );\n\n    uint16 samplesPerPixel = 0;\n    (void) TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLESPERPIXEL, &samplesPerPixel);\n\n    uint16 bitsPerSample = 0;\n    (void) TIFFGetFieldDefaulted(tif, TIFFTAG_BITSPERSAMPLE, &bitsPerSample);\n\n    uint16 extraSamples;\n    uint16* samplesInfo;\n    TIFFGetFieldDefaulted(tif, TIFFTAG_EXTRASAMPLES,\n                          &extraSamples, &samplesInfo);\n\n    uint16 photometric;\n    if (!TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric))\n    {\n        photometric = PHOTOMETRIC_MINISWHITE;\n    }\n    const bool hasAlpha = (extraSamples >= 1\n        && ((samplesInfo[0] == EXTRASAMPLE_UNSPECIFIED)\n            || samplesInfo[0] == EXTRASAMPLE_ASSOCALPHA\n            || samplesInfo[0] == EXTRASAMPLE_UNASSALPHA))\n        || (extraSamples == 0 && samplesPerPixel == 4\n            && photometric == PHOTOMETRIC_RGB);\n\n    // guard against integer overflow during multiplication which could result\n    // in allocating a too small buffer and then overflowing it\n    const double bytesNeeded = (double)w * (double)h * sizeof(uint32);\n    if ( bytesNeeded >= wxUINT32_MAX )\n    {\n        if ( verbose )\n        {\n            wxLogError( _(\"TIFF: Image size is abnormally big.\") );\n        }\n\n        TIFFClose(tif);\n\n        return false;\n    }\n\n    raster = (uint32*) _TIFFmalloc( (uint32)bytesNeeded );\n\n    if (!raster)\n    {\n        if (verbose)\n        {\n            wxLogError( _(\"TIFF: Couldn't allocate memory.\") );\n        }\n\n        TIFFClose( tif );\n\n        return false;\n    }\n\n    image->Create( (int)w, (int)h );\n    if (!image->IsOk())\n    {\n        if (verbose)\n        {\n            wxLogError( _(\"TIFF: Couldn't allocate memory.\") );\n        }\n\n        _TIFFfree( raster );\n        TIFFClose( tif );\n\n        return false;\n    }\n\n    if ( hasAlpha )\n        image->SetAlpha();\n\n    uint16 planarConfig = PLANARCONFIG_CONTIG;\n    (void) TIFFGetField(tif, TIFFTAG_PLANARCONFIG, &planarConfig);\n\n    bool ok = true;\n    char msg[1024] = \"\";\n    if\n    (\n        (planarConfig == PLANARCONFIG_CONTIG && samplesPerPixel == 2\n            && extraSamples == 1)\n        &&\n        (\n            ( !TIFFRGBAImageOK(tif, msg) )\n            || (bitsPerSample == 8)\n        )\n    )\n    {\n        const bool isGreyScale = (bitsPerSample == 8);\n        unsigned char *buf = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(tif));\n        uint32 pos = 0;\n        const bool minIsWhite = (photometric == PHOTOMETRIC_MINISWHITE);\n        const int minValue =  minIsWhite ? 255 : 0;\n        const int maxValue = 255 - minValue;\n\n        /*\n        Decode to ABGR format as that is what the code, that converts to\n        wxImage, later on expects (normally TIFFReadRGBAImageOriented is\n        used to decode which uses an ABGR layout).\n        */\n        for (uint32 y = 0; y < h; ++y)\n        {\n            if (TIFFReadScanline(tif, buf, y, 0) != 1)\n            {\n                ok = false;\n                break;\n            }\n\n            if (isGreyScale)\n            {\n                for (uint32 x = 0; x < w; ++x)\n                {\n                    uint8 val = minIsWhite ? 255 - buf[x*2] : buf[x*2];\n                    uint8 alpha = minIsWhite ? 255 - buf[x*2+1] : buf[x*2+1];\n                    raster[pos] = val + (val << 8) + (val << 16)\n                        + (alpha << 24);\n                    pos++;\n                }\n            }\n            else\n            {\n                for (uint32 x = 0; x < w; ++x)\n                {\n                    int mask = buf[x*2/8] << ((x*2)%8);\n\n                    uint8 val = mask & 128 ? maxValue : minValue;\n                    raster[pos] = val + (val << 8) + (val << 16)\n                        + ((mask & 64 ? maxValue : minValue) << 24);\n                    pos++;\n                }\n            }\n        }\n\n        _TIFFfree(buf);\n    }\n    else\n    {\n        ok = TIFFReadRGBAImageOriented( tif, w, h, raster,\n            ORIENTATION_TOPLEFT, 0 ) != 0;\n    }\n\n\n    if (!ok)\n    {\n        if (verbose)\n        {\n            wxLogError( _(\"TIFF: Error reading image.\") );\n        }\n\n        _TIFFfree( raster );\n        image->Destroy();\n        TIFFClose( tif );\n\n        return false;\n    }\n\n    unsigned char *ptr = image->GetData();\n\n    unsigned char *alpha = image->GetAlpha();\n\n    uint32 pos = 0;\n\n    for (uint32 i = 0; i < h; i++)\n    {\n        for (uint32 j = 0; j < w; j++)\n        {\n            *(ptr++) = (unsigned char)TIFFGetR(raster[pos]);\n            *(ptr++) = (unsigned char)TIFFGetG(raster[pos]);\n            *(ptr++) = (unsigned char)TIFFGetB(raster[pos]);\n            if ( hasAlpha )\n                *(alpha++) = (unsigned char)TIFFGetA(raster[pos]);\n\n            pos++;\n        }\n    }\n\n\n    image->SetOption(wxIMAGE_OPTION_TIFF_PHOTOMETRIC, photometric);\n\n    uint16 compression;\n    /*\n    Copy some baseline TIFF tags which helps when re-saving a TIFF\n    to be similar to the original image.\n    */\n    if (samplesPerPixel)\n    {\n        image->SetOption(wxIMAGE_OPTION_TIFF_SAMPLESPERPIXEL, samplesPerPixel);\n    }\n\n    if (bitsPerSample)\n    {\n        image->SetOption(wxIMAGE_OPTION_TIFF_BITSPERSAMPLE, bitsPerSample);\n    }\n\n    if ( TIFFGetFieldDefaulted(tif, TIFFTAG_COMPRESSION, &compression) )\n    {\n        image->SetOption(wxIMAGE_OPTION_TIFF_COMPRESSION, compression);\n    }\n\n    // Set the resolution unit.\n    wxImageResolution resUnit = wxIMAGE_RESOLUTION_NONE;\n    uint16 tiffRes;\n    if ( TIFFGetFieldDefaulted(tif, TIFFTAG_RESOLUTIONUNIT, &tiffRes) )\n    {\n        switch (tiffRes)\n        {\n            default:\n                wxLogWarning(_(\"Unknown TIFF resolution unit %d ignored\"),\n                    tiffRes);\n                wxFALLTHROUGH;\n\n            case RESUNIT_NONE:\n                resUnit = wxIMAGE_RESOLUTION_NONE;\n                break;\n\n            case RESUNIT_INCH:\n                resUnit = wxIMAGE_RESOLUTION_INCHES;\n                break;\n\n            case RESUNIT_CENTIMETER:\n                resUnit = wxIMAGE_RESOLUTION_CM;\n                break;\n        }\n    }\n\n    image->SetOption(wxIMAGE_OPTION_RESOLUTIONUNIT, resUnit);\n\n    /*\n    Set the image resolution if it's available. Resolution tag is not\n    dependent on RESOLUTIONUNIT != RESUNIT_NONE (according to TIFF spec).\n    */\n    float resX, resY;\n\n    if ( TIFFGetField(tif, TIFFTAG_XRESOLUTION, &resX) )\n    {\n        /*\n        Use a string value to not lose precision.\n        rounding to int as cm and then converting to inch may\n        result in whole integer rounding error, eg. 201 instead of 200 dpi.\n        If an app wants an int, GetOptionInt will convert and round down.\n        */\n        image->SetOption(wxIMAGE_OPTION_RESOLUTIONX,\n            wxString::FromCDouble((double) resX));\n    }\n\n    if ( TIFFGetField(tif, TIFFTAG_YRESOLUTION, &resY) )\n    {\n        image->SetOption(wxIMAGE_OPTION_RESOLUTIONY,\n            wxString::FromCDouble((double) resY));\n    }\n\n    _TIFFfree( raster );\n\n    TIFFClose( tif );\n\n    return true;\n}",
    "int wxTIFFHandler::DoGetImageCount( wxInputStream& stream )\n{\n    TIFF *tif = TIFFwxOpen( stream, \"image\", \"r\" );\n\n    if (!tif)\n        return 0;\n\n    int dircount = 0;  // according to the libtiff docs, dircount should be set to 1 here???\n    do {\n        dircount++;\n    } while (TIFFReadDirectory(tif));\n\n    TIFFClose( tif );\n\n    // NOTE: this function modifies the current stream position but it's ok\n    //       (see wxImageHandler::GetImageCount)\n\n    return dircount;\n}",
    "bool wxTIFFHandler::SaveFile( wxImage *image, wxOutputStream& stream, bool verbose )\n{\n    TIFF *tif = TIFFwxOpen( stream, \"image\", \"w\" );\n\n    if (!tif)\n    {\n        if (verbose)\n        {\n            wxLogError( _(\"TIFF: Error saving image.\") );\n        }\n\n        return false;\n    }\n\n    const int imageWidth = image->GetWidth();\n    TIFFSetField(tif, TIFFTAG_IMAGEWIDTH,  (uint32) imageWidth);\n    TIFFSetField(tif, TIFFTAG_IMAGELENGTH, (uint32)image->GetHeight());\n    TIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n    TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\n    // save the image resolution if we have it\n    int xres, yres;\n    const wxImageResolution res = GetResolutionFromOptions(*image, &xres, &yres);\n    uint16 tiffRes;\n    switch ( res )\n    {\n        default:\n            wxFAIL_MSG( wxT(\"unknown image resolution units\") );\n            wxFALLTHROUGH;\n\n        case wxIMAGE_RESOLUTION_NONE:\n            tiffRes = RESUNIT_NONE;\n            break;\n\n        case wxIMAGE_RESOLUTION_INCHES:\n            tiffRes = RESUNIT_INCH;\n            break;\n\n        case wxIMAGE_RESOLUTION_CM:\n            tiffRes = RESUNIT_CENTIMETER;\n            break;\n    }\n\n    if ( tiffRes != RESUNIT_NONE )\n    {\n        TIFFSetField(tif, TIFFTAG_RESOLUTIONUNIT, tiffRes);\n        TIFFSetField(tif, TIFFTAG_XRESOLUTION, (float)xres);\n        TIFFSetField(tif, TIFFTAG_YRESOLUTION, (float)yres);\n    }\n\n\n    int spp = image->GetOptionInt(wxIMAGE_OPTION_TIFF_SAMPLESPERPIXEL);\n    if ( !spp )\n        spp = 3;\n\n    int bps = image->GetOptionInt(wxIMAGE_OPTION_TIFF_BITSPERSAMPLE);\n    if ( !bps )\n    {\n        bps = 8;\n    }\n    else if (bps == 1)\n    {\n        // One bit per sample combined with 3 samples per pixel is\n        // not allowed and crashes libtiff.\n        spp = 1;\n    }\n\n    int photometric = PHOTOMETRIC_RGB;\n\n    if ( image->HasOption(wxIMAGE_OPTION_TIFF_PHOTOMETRIC) )\n    {\n        photometric = image->GetOptionInt(wxIMAGE_OPTION_TIFF_PHOTOMETRIC);\n        if (photometric == PHOTOMETRIC_MINISWHITE\n            || photometric == PHOTOMETRIC_MINISBLACK)\n        {\n            // either b/w or greyscale\n            spp = 1;\n        }\n    }\n    else if (spp <= 2)\n    {\n        photometric = PHOTOMETRIC_MINISWHITE;\n    }\n\n    const bool hasAlpha = image->HasAlpha();\n\n    int compression = image->GetOptionInt(wxIMAGE_OPTION_TIFF_COMPRESSION);\n    if ( !compression || (compression == COMPRESSION_JPEG && hasAlpha) )\n    {\n        // We can't use COMPRESSION_LZW because current version of libtiff\n        // doesn't implement it (\"no longer implemented due to Unisys patent\n        // enforcement\") and other compression methods are lossy so we\n        // shouldn't use them by default -- and the only remaining one is none.\n        // Also JPEG compression for alpha images is not a good idea (viewers\n        // not opening the image properly).\n        compression = COMPRESSION_NONE;\n    }\n\n    if\n    (\n        (photometric == PHOTOMETRIC_RGB && spp == 4)\n        || (photometric <= PHOTOMETRIC_MINISBLACK && spp == 2)\n    )\n    {\n        // Compensate for user passing a SamplesPerPixel that includes\n        // the alpha channel.\n        spp--;\n    }\n\n\n    int extraSamples = hasAlpha ? 1 : 0;\n\n    TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, spp + extraSamples);\n    TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, bps);\n    TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, photometric);\n    TIFFSetField(tif, TIFFTAG_COMPRESSION, compression);\n\n    if (extraSamples)\n    {\n        uint16 extra[] = { EXTRASAMPLE_UNSPECIFIED };\n        TIFFSetField(tif, TIFFTAG_EXTRASAMPLES, (long) 1, &extra);\n    }\n\n    // scanlinesize is determined by spp+extraSamples and bps\n    const tsize_t linebytes =\n        (tsize_t)((imageWidth * (spp + extraSamples) * bps + 7) / 8);\n\n    unsigned char *buf;\n\n    const bool isColouredImage = (spp > 1)\n        && (photometric != PHOTOMETRIC_MINISWHITE)\n        && (photometric != PHOTOMETRIC_MINISBLACK);\n\n\n    if (TIFFScanlineSize(tif) > linebytes || !isColouredImage || hasAlpha)\n    {\n        buf = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(tif));\n        if (!buf)\n        {\n            if (verbose)\n            {\n                wxLogError( _(\"TIFF: Couldn't allocate memory.\") );\n            }\n\n            TIFFClose( tif );\n\n            return false;\n        }\n    }\n    else\n    {\n        buf = NULL;\n    }\n\n    TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP,TIFFDefaultStripSize(tif, (uint32) -1));\n\n    const int bitsPerPixel = (spp + extraSamples) * bps;\n    const int bytesPerPixel = (bitsPerPixel + 7) / 8;\n    const int pixelsPerByte = 8 / bitsPerPixel;\n    int remainingPixelCount = 0;\n\n    if (pixelsPerByte)\n    {\n        // How many pixels to write in the last byte column?\n        remainingPixelCount = imageWidth % pixelsPerByte;\n        if (!remainingPixelCount) remainingPixelCount = pixelsPerByte;\n    }\n\n    const bool minIsWhite = (photometric == PHOTOMETRIC_MINISWHITE);\n    unsigned char *ptr = image->GetData();\n    for ( int row = 0; row < image->GetHeight(); row++ )\n    {\n        if ( buf )\n        {\n            if (isColouredImage)\n            {\n                // colour image\n                if (hasAlpha)\n                {\n                    for ( int column = 0; column < imageWidth; column++ )\n                    {\n                        buf[column*4    ] = ptr[column*3    ];\n                        buf[column*4 + 1] = ptr[column*3 + 1];\n                        buf[column*4 + 2] = ptr[column*3 + 2];\n                        buf[column*4 + 3] = image->GetAlpha(column, row);\n                    }\n                }\n                else\n                {\n                    memcpy(buf, ptr, imageWidth * 3);\n                }\n            }\n            else if (spp * bps == 8) // greyscale image\n            {\n                for ( int column = 0; column < imageWidth; column++ )\n                {\n                    uint8 value = ptr[column*3 + 1];\n                    if (minIsWhite)\n                    {\n                        value = 255 - value;\n                    }\n\n                    buf[column * bytesPerPixel] = value;\n\n                    if (hasAlpha)\n                    {\n                        value = image->GetAlpha(column, row);\n                        buf[column*bytesPerPixel+1]\n                            = minIsWhite ? 255 - value : value;\n                    }\n                }\n            }\n            else // black and white image\n            {\n                for ( int column = 0; column < linebytes; column++ )\n                {\n                    uint8 reverse = 0;\n                    int pixelsPerByteCount = (column + 1 != linebytes)\n                        ? pixelsPerByte\n                        : remainingPixelCount;\n                    for ( int bp = 0; bp < pixelsPerByteCount; bp++ )\n                    {\n                        if ( (ptr[column * 3 * pixelsPerByte + bp*3 + 1] <=127)\n                            == minIsWhite )\n                        {\n                            // check only green as this is sufficient\n                            reverse |= (uint8) (128 >> (bp * bitsPerPixel));\n                        }\n\n                        if (hasAlpha\n                            && (image->GetAlpha(column * pixelsPerByte + bp,\n                                    row) <= 127) == minIsWhite)\n                        {\n                            reverse |= (uint8) (64 >> (bp * bitsPerPixel));\n                        }\n                    }\n\n                    buf[column] = reverse;\n                }\n            }\n        }\n\n        if ( TIFFWriteScanline(tif, buf ? buf : ptr, (uint32)row, 0) < 0 )\n        {\n            if (verbose)\n            {\n                wxLogError( _(\"TIFF: Error writing image.\") );\n            }\n\n            TIFFClose( tif );\n            if (buf)\n                _TIFFfree(buf);\n\n            return false;\n        }\n\n        ptr += imageWidth * 3;\n    }\n\n    (void) TIFFClose(tif);\n\n    if (buf)\n        _TIFFfree(buf);\n\n    return true;\n}",
    "GTiffDataset::~GTiffDataset() {\n    if (m_hTIFF)\n        TIFFClose(m_hTIFF);\n}",
    "err_info *Desk::test_compare_with_tiff (QString &fname)\n   {\n   max_info *max;\n   cpoint size, true_size;\n   int bpp, pagenum;\n   byte *im;\n   TIFF *tif;\n\tunsigned imagelength;\n\tbyte *buf, *ptr;\n\tunsigned row;\n\tint stride, im_size, tif_size;\n   int config, nstrips;\n   int imageWidth, imageLength, tileWidth, tileLength;\n\n   CALL (max_open (fname.latin1 (), &max));\n\n   QString ext;\n   QString newname = removeExtension (fname, ext);\n\n   newname += \".tif\";\n\n   printf (\"name=%s\\n\", newname.latin1 ());\n\n   tif = TIFFOpen (newname.latin1 (), \"r\");\n\n   // compare each page\n   for (pagenum = 0; pagenum < max_get_pagecount (max); pagenum++)\n      {\n      printf (\"page %d / %d: \", pagenum, max_get_pagecount (max));\n\n\t   if (pagenum && !TIFFReadDirectory(tif))\n\t      {\n\t      printf (\"ran out of pages\\n\");\n\t      exit (1);\n\t      }   err_info *test_decomp_comp (QString &fname);\n\n\n//      printf (\"\\nTIFF\\n\");\n    \tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &imagelength);\n      TIFFGetField(tif, TIFFTAG_PLANARCONFIG, &config);\n   \tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n\t   TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &imageLength);\n//   \tTIFFGetField(tif, TIFFTAG_TILEWIDTH, &tileWidth);\n//   \tTIFFGetField(tif, TIFFTAG_TILELENGTH, &tileLength);\n\n      tileWidth = tileLength = 0;\n\n      nstrips = TIFFNumberOfStrips(tif);\n//      printf (\"strips=%d, image=%dx%d, tile=%dx%d: %d\\n\", nstrips, imageWidth, imageLength,\n//            tileWidth, tileLength, TIFFNumberOfTiles(tif));\n\n    \tstride = ((TIFFScanlineSize(tif) + 3) & ~3);;\n//      stride = imageWidth / 8;\n    \ttif_size = stride * imagelength;\n     \tbuf = (byte *)malloc (tif_size);\n     \tprintf (\"   stride=%d, \", stride);\n   \tfor (row = 0, ptr = buf; row < imagelength; row++, ptr += stride)\n\t      if (TIFFReadScanline(tif, ptr, row) != 1)\n\t         {\n\t         printf (\"\\nreadscanline error\\n\");\n\t         break;\n\t         }\n      CALL (max_get_image (max, pagenum, &size, &true_size, &bpp, &im, &im_size));\n\n   \tfor (row = 0, ptr = buf; row < imagelength; row++, ptr += stride)\n   \t   if (0 != memcmp (ptr, im + (ptr - buf), stride))\n   \t      {\n   \t      printf (\"\\n- error line %d\\n\", row);\n   \t      dump (\"tif\", ptr, stride, im + (ptr - buf));\n   \t      dump (\"max\", im + (ptr - buf), stride, ptr);\n   \t      }\n\n\t   free (buf);\n\t   printf (\"    lines=%d/%d, %d %d\\n\", imagelength, row, im_size, tif_size);\n\t   }\n   TIFFClose (tif);\n   max_close (max);\n\n   return NULL;\n   }",
    "void writeTiff(QImageIO* iio)\n{\n  QImage image;\n  TIFF* tiffile;\n  QRgb rgb;\n  char *data;\n  int y;\n  int channels;\n  int quality;\n  int compression;\n  int width;\n  int bytes;\n  int depth;\n  bool color;\n  bool has_alpha;\n  Q_UINT16  extra_samples[1];\n  QString params;\n  float x_res,y_res;\n  //PACKBITS is supported for all formats and lossless; use it as default, if the user\n  //didn't request a specific format.\n  compression = COMPRESSION_PACKBITS;\n  if(iio->parameters())\n  {\n    params = iio->parameters();\n    if(params.contains(\"COMPRESSION_NONE\"))\n      compression = COMPRESSION_NONE;\n    else if(params.contains(\"COMPRESSION_CCITTRLE\")) //Huffman\n      compression = COMPRESSION_CCITTRLE;\n    else if(params.contains(\"COMPRESSION_CCITTFAX3\")) //group3 fax\n      compression = COMPRESSION_CCITTFAX3;\n    else if(params.contains(\"COMPRESSION_CCITTFAX4\")) //group4 fax\n      compression = COMPRESSION_CCITTFAX4;\n    else if(params.contains(\"COMPRESSION_PACKBITS\"))  //packed bits\n      compression = COMPRESSION_PACKBITS;\n    else\n    {\n      bool ok;\n      int i = params.toInt(&ok);\n      if(ok)\n      {\n        if(i>=0 && i<=100)\n        {\n          compression = COMPRESSION_JPEG;\n          quality = i;\n        }\n      }\n    }\n  }\n  image = iio->image();\n  width = image.width();\n  depth = image.depth();\n  has_alpha = image.hasAlphaBuffer();\n  if(depth == 32) depth = 8;\n  if(depth == 8)\n  {\n    if((compression ==  COMPRESSION_CCITTRLE) ||\n       (compression ==  COMPRESSION_CCITTFAX3) ||\n       (compression ==  COMPRESSION_CCITTFAX4))\n    {\n      iio->setStatus(1);//compression type unsupported for this format\n      return;\n    }\n  }\n  else if(depth == 1)\n  {\n    if(compression ==  COMPRESSION_JPEG)\n    {\n      iio->setStatus(1);//compression type unsupported for this format\n      return;\n    }\n  }\n\n  if(image.depth()>1 && !image.allGray())\n  {\n    channels = 3;\n    if(has_alpha)\n      channels += 1;\n    color = true;\n  }\n  else\n  {\n    channels = 1;\n    color = false;\n  }\n\n  //For non-lineart images, bytes per channel is always one\n  bytes = 1;\n\n  if((image.depth() == 1) && (image.numColors() == 2))\n  {\n\t  if(qGray(image.color(0)) > qGray(image.color(1)))\n    {\n\t    // 0=dark/black, 1=light/white - invert\n\t    image.detach();\n\t    for(int y=0; y<image.height(); y++ )\n      {\n\t\t    uchar *p = image.scanLine(y);\n\t\t    uchar *end = p + image.bytesPerLine();\n\t\t    while ( p < end )\n\t\t      *p++ ^= 0xff;\n\t    }\n\t  }\n  }\n\n  tiffile = TIFFOpen(QFile::encodeName(iio->fileName()), \"w\");\nqDebug(\"TIFF: try to open %s\",iio->fileName().latin1());\n  if(!tiffile)\n  {\n    iio->setStatus(1);\n    return ;\n  }\n\n  TIFFSetField(tiffile, TIFFTAG_IMAGEWIDTH, image.width());\n  TIFFSetField(tiffile, TIFFTAG_IMAGELENGTH, image.height());\n  TIFFSetField(tiffile, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n  TIFFSetField(tiffile, TIFFTAG_BITSPERSAMPLE, channels);\n  TIFFSetField(tiffile, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n  TIFFSetField(tiffile, TIFFTAG_COMPRESSION, compression);\n  TIFFSetField(tiffile, TIFFTAG_SOFTWARE, \"QuiteInsane\");\n\n  if((image.dotsPerMeterX() > 0) && (image.dotsPerMeterY() > 0))\n  {\n    TIFFSetField(tiffile, TIFFTAG_RESOLUTIONUNIT, RESUNIT_INCH);\n    x_res = float(image.dotsPerMeterX())/(100.0/2.54);\n    y_res = float(image.dotsPerMeterY())/(100.0/2.54);\n    TIFFSetField(tiffile, TIFFTAG_XRESOLUTION,x_res);\n    TIFFSetField(tiffile, TIFFTAG_YRESOLUTION,y_res);\n  }\n\n  if(compression == COMPRESSION_JPEG)\n  {\n    TIFFSetField(tiffile, TIFFTAG_JPEGQUALITY, quality);\n    TIFFSetField(tiffile, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RAW);\n  }\n\n  if(color)\n  {\n    TIFFSetField(tiffile, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n    TIFFSetField(tiffile, TIFFTAG_BITSPERSAMPLE,8);\n    if(has_alpha)\n      TIFFSetField(tiffile, TIFFTAG_SAMPLESPERPIXEL,4);\n    else\n      TIFFSetField(tiffile, TIFFTAG_SAMPLESPERPIXEL,3);\n  }\n  else\n  {\n    if(depth == 1) //lineart\n    {\n      TIFFSetField(tiffile, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISWHITE);\n      TIFFSetField(tiffile, TIFFTAG_BITSPERSAMPLE,1);\n      TIFFSetField(tiffile, TIFFTAG_SAMPLESPERPIXEL,1);\n    }\n    else // grayscale\n    {\n      TIFFSetField(tiffile, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n      TIFFSetField(tiffile, TIFFTAG_BITSPERSAMPLE,8);\n      TIFFSetField(tiffile, TIFFTAG_SAMPLESPERPIXEL,1);\n    }\n  }\n\n  if(has_alpha)\n  {\n    extra_samples [0] = EXTRASAMPLE_ASSOCALPHA;\n    TIFFSetField (tiffile, TIFFTAG_EXTRASAMPLES, 1, extra_samples);\n  }\n  TIFFSetField(tiffile,TIFFTAG_ROWSPERSTRIP,TIFFDefaultStripSize(tiffile,0));\n\n  if(image.depth() > 1)\n    data = new char[image.width() * channels * bytes];\n  else\n    data = new char[(image.width()+7)/8];\n\n  if(data)\n  {\n    for(y = 0; y < image.height(); y++)\n    {\n      if(image.depth() > 1)\n      {\n        for(int i=0;i<image.width();i++)\n        {\n          rgb = image.pixel(i,y);\n          if(channels == 3)\n          {\n            data[i*3] = qRed(rgb);\n            data[i*3+1] = qGreen(rgb);\n            data[i*3+2] = qBlue(rgb);\n          }\n          else if(channels == 4)//alpha\n          {\n            int alpha = qAlpha(rgb);\n            data[i*4] = Q_UINT8(qRed(rgb)*alpha/255);\n            data[i*4+1] = Q_UINT8(qGreen(rgb)*alpha/255);\n            data[i*4+2] = Q_UINT8(qBlue(rgb)*alpha/255);\n            data[i*4+3] = Q_UINT8(alpha);\n          }\n          else\n          {\n            data[i] = qGray(rgb);\n          }\n        }\n        if(TIFFWriteScanline(tiffile,data, y, 0) == -1) //error\n        {\n          TIFFClose(tiffile);\n          delete [] data;\n          iio->setStatus(1);\n          return;\n        }\n      }\n      else\n      {\n        if(TIFFWriteScanline(tiffile,(char*)image.scanLine(y), y, 0) == -1) //error\n        {\n          TIFFClose(tiffile);\n          delete [] data;\n          iio->setStatus(1);\n          return;\n        }\n      }\n    }\n    iio->setStatus(0);\n    delete [] data;\n  }\n  else\n  {\n    //could not allocate data\n    iio->setStatus(1);\n  }\n  TIFFClose(tiffile);\n}",
    "void readTiff(QImageIO* iio)\n{\n  QImage image;\n  int depth;\n  int i;\n  float x_resolution, y_resolution;\n  int y;\n  TIFF *tiff;\n  Q_UINT16 extra;\n  Q_UINT16* extra_types;\n  Q_UINT16 compress_tag;\n  Q_UINT32 height,width;\n  Q_UINT16 bits_per_sample;\n  Q_UINT16 interlace;\n  Q_UINT16 max_sample_value;\n  Q_UINT16 min_sample_value;\n  Q_UINT16 photometric;\n  Q_UINT16 samples_per_pixel;\n  Q_UINT16 units;\n  bool color;\n  bool has_alpha = false;\n  bool min_is_white = false;\n  tiff=TIFFOpen(QFile::encodeName(iio->fileName()),\"r\");\n  if(tiff == (TIFF *) 0L)\n  {\n    iio->setStatus(1);\n    return;\n  }\n  TIFFGetField(tiff,TIFFTAG_IMAGEWIDTH,&width);\n  TIFFGetField(tiff,TIFFTAG_IMAGELENGTH,&height);\n  TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,&bits_per_sample);\n  TIFFGetFieldDefaulted(tiff,TIFFTAG_PHOTOMETRIC,&photometric);\n  TIFFGetField(tiff,TIFFTAG_SAMPLESPERPIXEL,&samples_per_pixel);\n  TIFFGetField(tiff,TIFFTAG_EXTRASAMPLES,&extra,&extra_types);\n  TIFFGetFieldDefaulted(tiff,TIFFTAG_PLANARCONFIG,&interlace);\n\n  if(extra>0 && (extra_types[0] == EXTRASAMPLE_ASSOCALPHA))\n  {\n    has_alpha = true;\n  }\n  //The formats we can read. If the tiff has been written by QuiteInsane,\n  //then we can read it this way. For other formats, we fall back to\n  //RGBA - at least for the moment.\n  if((!TIFFIsTiled(tiff)) &&\n     (interlace == PLANARCONFIG_CONTIG) &&\n     ((bits_per_sample == 1)   ||\n      (bits_per_sample == 8)   ||\n      (bits_per_sample == 16)) &&\n     ((photometric == PHOTOMETRIC_MINISWHITE) ||\n      (photometric == PHOTOMETRIC_MINISBLACK) ||\n      (photometric == PHOTOMETRIC_RGB)        ||\n      (photometric == PHOTOMETRIC_PALETTE)))\n  {\n    if((bits_per_sample == 8) || (bits_per_sample == 16))\n    {\n      if(photometric == PHOTOMETRIC_RGB)\n      {\n        color = true;\n        depth = 32;\n        if(!image.create(width,height,depth))\n        {\n          iio->setStatus(1);\n          return;\n        }\n        image.setAlphaBuffer(has_alpha);\n      }\n      else\n      {\n        depth = 8;\n        if(!image.create(width,height,depth))\n        {\n          iio->setStatus(1);\n          return;\n        }\n        image.setNumColors(256);\n        image.setAlphaBuffer(has_alpha);\n        if(photometric == PHOTOMETRIC_PALETTE)\n        {\n          color = true;\n          Q_UINT16* blue_colormap;\n          Q_UINT16* green_colormap;\n          Q_UINT16* red_colormap;\n\n          TIFFGetField(tiff,TIFFTAG_COLORMAP,&red_colormap,&green_colormap,\n                       &blue_colormap);\n          for(i=0; i < 256; i++)\n          {\n            image.setColor(i,qRgb(red_colormap[i]/257,\n                                  green_colormap[i]/257,\n                                  blue_colormap[i]/257));\n\n          }\n        }\n        else if(photometric == PHOTOMETRIC_MINISWHITE)\n        {\n          color = false; //grayscale\n          min_is_white = true;\n        }\n        else\n        {\n          color = false;\n        }\n      }\n    }\n    else if(bits_per_sample == 1) //lineart, B&W\n    {\n      depth = 1;\n      if(!image.create(width,height,depth,2,QImage::BigEndian))\n      {\n        iio->setStatus(1);\n        return;\n      }\n    }\n    if(depth == 1)\n    {\n      image.setColor(0,qRgb(255,255,255));\n      image.setColor(1,qRgb(0,0,0));\n    }\n    TIFFGetFieldDefaulted(tiff,TIFFTAG_RESOLUTIONUNIT,&units);\n    TIFFGetFieldDefaulted(tiff,TIFFTAG_XRESOLUTION,&x_resolution);\n    TIFFGetFieldDefaulted(tiff,TIFFTAG_YRESOLUTION,&y_resolution);\n    if(units == 1)\n    {\n      image.setDotsPerMeterX(0);\n      image.setDotsPerMeterY(0);\n    }\n    else if(units == 2)\n    {\n      image.setDotsPerMeterX(int(x_resolution*100.0/2.54));\n      image.setDotsPerMeterY(int(y_resolution*100.0/2.54));\n    }\n    else if(units == 3)\n    {\n      image.setDotsPerMeterX(int(x_resolution*100.0));\n      image.setDotsPerMeterY(int(y_resolution*100.0));\n    }\n    TIFFGetFieldDefaulted(tiff,TIFFTAG_COMPRESSION,&compress_tag);\n    TIFFGetFieldDefaulted(tiff,TIFFTAG_MINSAMPLEVALUE,&min_sample_value);\n    TIFFGetFieldDefaulted(tiff,TIFFTAG_MAXSAMPLEVALUE,&max_sample_value);\n    TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLESPERPIXEL,&samples_per_pixel);\n\n    Q_UINT8* line;\n    line = 0;\n    if(depth == 32)\n    {\n      if(bits_per_sample == 16)\n      {\n        if(has_alpha)\n          line = new Q_UINT8 [width*8];\n        else\n          line = new Q_UINT8 [width*6];\n      }\n      else\n      {\n        if(has_alpha)\n          line = new Q_UINT8 [width*4];\n        else\n          line = new Q_UINT8 [width*3];\n      }\n    }\n    if(depth == 8)\n    {\n      if(bits_per_sample == 16)\n        line = new Q_UINT8 [width*2];\n      else\n        line = new Q_UINT8 [width];\n    }\n    if(depth == 1)\n      line = new Q_UINT8 [TIFFScanlineSize(tiff)];\n\n    if(line)\n    {\n      for(y=0; y < (int) image.height(); y++)\n      {\n        if(TIFFReadScanline(tiff,(unsigned char*)line,y,0) == -1)\n        {\n          delete [] line;\n          TIFFClose(tiff);\n          iio->setStatus(1);\n          return;\n        }\n        if(depth == 32)\n        {\n          Q_UINT16* line16;\n          line16 = (Q_UINT16*) line;\n          int Qt::red,Qt::green,Qt::blue,alpha;\n          for(i=0;i<image.width();i++)\n          {\n            if(bits_per_sample == 16)\n            {\n              if(has_alpha)\n              {\n                Qt::red = int(line16[i*4])/257;\n                Qt::green = int(line16[i*4+1])/257;\n                Qt::blue = int(line16[i*4+2])/257;\n                alpha = int(line16[i*4+3]/257);\n                if(alpha > 0)\n                {\n                  Qt::red = (Qt::red*255)/alpha;\n                  Qt::green = (Qt::green*255)/alpha;\n                  Qt::blue = (Qt::blue*255)/alpha;\n                }\n                image.setPixel(i,y,qRgba(Qt::red,Qt::green,Qt::blue,alpha));\n              }\n              else\n                image.setPixel(i,y,qRgb(int(line16[i*3]),\n                                        int(line16[i*3+1]),\n                                        int(line16[i*3+2])));\n            }\n            else\n            {\n              if(has_alpha)\n              {\n                Qt::red = int(line[i*4]);\n                Qt::green = int(line[i*4+1]);\n                Qt::blue = int(line[i*4+2]);\n                alpha = int(line[i*4+3]);\n                if(alpha > 0)\n                {\n                  Qt::red = (Qt::red*255)/alpha;\n                  Qt::green = (Qt::green*255)/alpha;\n                  Qt::blue = (Qt::blue*255)/alpha;\n                }\n                image.setPixel(i,y,qRgba(Qt::red,Qt::green,Qt::blue,alpha));\n              }\n              else\n                image.setPixel(i,y,qRgb(int(line[i*3]),\n                                        int(line[i*3+1]),\n                                        int(line[i*3+2])));\n            }\n          }\n        }\n        if(depth == 8)\n        {\n          if(bits_per_sample == 16)\n          {\n            Q_UINT16* line16;\n            line16 = (Q_UINT16*) line;\n            for(i=0;i<image.width();i++)\n            {\n              int Qt::gray = line16[i]/257;\n              if(color)\n              {\n                image.setPixel(i,y,Qt::gray);\n              }\n              else\n              {\n                if(min_is_white)\n                {\n                  Qt::gray = 255 - Qt::gray;\n                  image.setPixel(i,y,Qt::gray);\n                  image.setColor(Qt::gray,qRgb(Qt::gray,Qt::gray,Qt::gray));\n                }\n                else\n                {\n                  image.setPixel(i,y,Qt::gray);\n                  image.setColor(Qt::gray,qRgb(Qt::gray,Qt::gray,Qt::gray));\n                }\n              }\n            }\n          }\n          else if(bits_per_sample == 8)\n          {\n            for(i=0;i<image.width();i++)\n            {\n              if(color)\n              {\n                image.setPixel(i,y,line[i]);\n              }\n              else\n              {\n                image.setPixel(i,y,line[i]);\n                if(min_is_white)\n                {\n                  image.setPixel(i,y,line[i]);\n                  image.setColor(line[i],qRgb(int(line[i]^0xff),\n                                              int(line[i]^0xff),\n                                              int(line[i]^0xff)));\n                }\n                else\n                {\n                  image.setPixel(i,y,line[i]);\n                  image.setColor(line[i],qRgb(int(line[i]),\n                                              int(line[i]),\n                                              int(line[i])));\n                }\n              }\n            }\n          }\n        }\n        if(depth == 1)\n        {\n          memcpy(image.scanLine(y),line,TIFFScanlineSize(tiff));\n        }\n      }\n      delete [] line;\n      TIFFClose(tiff);\n    }\n    else //error\n    {\n      TIFFClose(tiff);\n      iio->setStatus(1);\n      return;\n    }\n  }\n//otherwise, try to read an RGBA image\n  else\n  {\n    unsigned int i;\n    unsigned int i2;\n    unsigned char* idat;\n    uint32 w, h;\n    size_t npixels;\n    uint32* raster;\n    TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, &w);\n    TIFFGetField(tiff, TIFFTAG_IMAGELENGTH, &h);\n    npixels = w * h;\n    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n    if(raster)\n    {\n      if(TIFFReadRGBAImage(tiff, w, h, raster, 0))\n      {\n        if(!image.create(w,h,32))\n        {\n          iio->setStatus(1);\n          _TIFFfree(raster);\n          return;\n        }\n        image.setAlphaBuffer(true);\n        //we finaly can transfer the data to our image\n        idat = (unsigned char*)raster;\n        for(i=0;i<h;i++)\n        {\n          for(i2=0;i2<w;i2++)\n          {\n            image.setPixel(i2,i,qRgba((int)*(idat),\n                                      (int)*(idat+1),\n                                      (int)*(idat+2),\n                                      (int)*(idat+3)));\n            idat += 4;\n          }\n        }\n      }\n      _TIFFfree(raster);\n      image = image.mirror(false,true);\n    }\n    else //couldn't allocate raster\n    {\n      TIFFClose(tiff);\n      iio->setStatus(1);\n      return;\n    }\n    TIFFClose(tiff);\n  }\n  iio->setImage(image);\n  iio->setStatus(0);\n}",
    "void TIFFImage::cleanup() {\r\n  _tileSizesPerLevel.clear();\r\n  if (_tiff) {\r\n    TIFFClose(_tiff);\r\n    _tiff = NULL;\r\n  }\r\n  if (_jp2000) {\r\n    delete _jp2000;\r\n    _jp2000 = NULL;\r\n  }\r\n}",
    "int AperioSVSWriter::finishImage() {\r\n  if (getDataType() == DataType::UInt32) {\r\n    writePyramidToDisk<unsigned int>();\r\n    writeThumbnail<unsigned int>();\r\n    incorporatePyramid<unsigned int>();\r\n    writeThumbnail<unsigned int>();\r\n  }\r\n  else if (getDataType() == DataType::UInt16) {\r\n    writePyramidToDisk<unsigned short>();\r\n    writeThumbnail<unsigned short>();\r\n    incorporatePyramid<unsigned short>();\r\n    writeThumbnail<unsigned short>();\r\n  }\r\n  else if (getDataType() == DataType::UChar) {\r\n    writePyramidToDisk<unsigned char>();\r\n    writeThumbnail<unsigned char>();\r\n    incorporatePyramid<unsigned char>();\r\n    writeThumbnail<unsigned char>();\r\n  }\r\n  else {\r\n    writePyramidToDisk<float>();\r\n    writeThumbnail<float>();\r\n    incorporatePyramid<float>();\r\n    writeThumbnail<float>();\r\n  }\r\n  for (std::vector<std::string>::const_iterator it = _levelFiles.begin(); it != _levelFiles.end(); ++it) {\r\n    for (int i = 0; i < 5; ++i) {\r\n      if (remove(it->c_str()) == 0) {\r\n        break;\r\n      }\r\n    }\r\n  }\r\n  TIFFClose(_tiff);\r\n  _tiff = NULL;\r\n  _levelFiles.clear();\r\n  _fileName = \"\";\r\n  _pos = 0;\r\n  return 0;\r\n}",
    "void AperioSVSWriter::writeThumbnail() {\r\n  unsigned long w = 0, h = 0, nrsamples = 0;\r\n  TIFF* lowestResTiff = TIFFOpen(_levelFiles[_levelFiles.size()-1].c_str(), \"r\");\r\n  TIFFGetField(lowestResTiff, TIFFTAG_IMAGEWIDTH, &w);\r\n  TIFFGetField(lowestResTiff, TIFFTAG_IMAGELENGTH, &h);\r\n  TIFFGetField(lowestResTiff, TIFFTAG_SAMPLESPERPIXEL, &nrsamples);\r\n\r\n  setBaseTags(_tiff);\r\n  TIFFSetField(_tiff, TIFFTAG_COMPRESSION, COMPRESSION_JPEG);\r\n  TIFFSetField(_tiff, TIFFTAG_JPEGQUALITY, 70);\r\n  TIFFSetField(_tiff, TIFFTAG_ROWSPERSTRIP, 16);\r\n  TIFFSetField(_tiff, TIFFTAG_IMAGEWIDTH, w);\r\n  TIFFSetField(_tiff, TIFFTAG_IMAGELENGTH, h);\r\n  TIFFSetField(_tiff, TIFFTAG_RESOLUTIONUNIT, RESUNIT_CENTIMETER);\r\n  TIFFSetField(_tiff, TIFFTAG_SUBFILETYPE, FILETYPE_REDUCEDIMAGE);\r\n\r\n  unsigned int npixels = w * h * nrsamples;\r\n  T* raster = (T*)_TIFFmalloc(npixels * sizeof(T));\r\n  unsigned int nrTiles = TIFFNumberOfTiles(lowestResTiff);\r\n  unsigned int tileW = 0, tileH = 0;\r\n  TIFFGetField(lowestResTiff, TIFFTAG_TILEWIDTH, &tileW);\r\n  TIFFGetField(lowestResTiff, TIFFTAG_TILELENGTH, &tileH);\r\n  T* tile = (T*)_TIFFmalloc(tileW * tileH * nrsamples * sizeof(T));\r\n  JPEG2000Codec cod;\r\n  for (unsigned int tileY = 0; tileY < h; tileY += tileH) {\r\n    for (unsigned int tileX = 0; tileX < w; tileX += tileW) {\r\n      if (getCompression() == Compression::JPEG2000) {\r\n        unsigned int no = TIFFComputeTile(lowestResTiff, tileX, tileY, 0, 0);\r\n        unsigned int rawSize = TIFFReadRawTile(lowestResTiff, no, tile, tileW*tileH*nrsamples*sizeof(T));\r\n        cod.decode((unsigned char*)tile, rawSize, tileW*tileH*nrsamples*sizeof(T));\r\n      }\r\n      else {\r\n        TIFFReadTile(lowestResTiff, tile, tileX, tileY, 0, 0);\r\n      }\r\n      for (unsigned int y = 0; y < tileH; ++y){\r\n        for (unsigned int x = 0; x < tileW; ++x){\r\n          if ((tileX + x) < w && (tileY + y) < h) {\r\n            for (unsigned int s = 0; s < nrsamples; ++s) {\r\n              (*(raster + (tileY + y) * w * nrsamples + (tileX + x) * nrsamples + s)) = (*(tile + y * tileW * nrsamples + x * nrsamples + s));\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  _TIFFfree(tile);\r\n  tile = NULL;\r\n  if (raster != NULL) {\r\n    unsigned int nrOfStrips = TIFFNumberOfStrips(_tiff);\r\n    for (unsigned int i = 0; i < nrOfStrips; ++i) {\r\n      T* strip = (T*)_TIFFmalloc(16 * w * nrsamples * sizeof(T));\r\n      unsigned int startOfStrip = i * 16 * w * nrsamples;\r\n      unsigned int endOfStrip = (i + 1) * 16 * w * nrsamples;\r\n      if (endOfStrip>npixels) {\r\n        endOfStrip = npixels;\r\n      }\r\n      for (unsigned int j = startOfStrip, k = 0; j < endOfStrip; ++j, ++k) {\r\n        T val = *(raster + j);\r\n        *(strip + k) = val;\r\n      }\r\n      TIFFWriteEncodedStrip(_tiff, i, strip, 16 * w * nrsamples * sizeof(T));\r\n      _TIFFfree(strip);\r\n    }\r\n    _TIFFfree(raster);\r\n  }\r\n\r\n  TIFFClose(lowestResTiff);\r\n  lowestResTiff = NULL;\r\n  if (TIFFNumberOfDirectories(_tiff) > 1) {\r\n    TIFFSetField(_tiff, TIFFTAG_IMAGEDESCRIPTION, \"Aperio Image macro\");\r\n  }\r\n  TIFFWriteDirectory(_tiff);\r\n}",
    "MultiResolutionImageWriter::~MultiResolutionImageWriter() {\r\n\tif (_tiff) {\r\n\t\tTIFFClose(_tiff);\r\n\t\t_tiff = NULL;\r\n\t}\r\n\tif (_jpeg2000Codec) {\r\n\t\tdelete _jpeg2000Codec;\r\n\t\t_jpeg2000Codec = NULL;\r\n\t}\r\n}",
    "int MultiResolutionImageWriter::finishImage() {\t\r\n\tif (TIFFIsTiled(_tiff) == 0) {\r\n\t\tstd::cout << \"No valid tiles have been written to the base image, cannot finish image.\" << std::endl;\r\n\t\treturn -1;\r\n\t}\r\n\tif (_min_vals != NULL && _max_vals != NULL) {\r\n\t\tTIFFSetField(_tiff, TIFFTAG_PERSAMPLE, PERSAMPLE_MULTI);\r\n\t\tTIFFSetField(_tiff, TIFFTAG_SMINSAMPLEVALUE, &_min_vals[0]);\r\n\t\tTIFFSetField(_tiff, TIFFTAG_SMAXSAMPLEVALUE, &_max_vals[0]);\r\n\t\t/* Reset to default behavior, if needed. */\r\n\t\tTIFFSetField(_tiff, TIFFTAG_PERSAMPLE, PERSAMPLE_MERGED);\r\n\t\tdelete[] _min_vals;\r\n\t\tdelete[] _max_vals;\r\n\t\t_min_vals = NULL;\r\n\t\t_max_vals = NULL;\r\n\t}\r\n\tauto startPyramidTime = std::chrono::steady_clock::now();\r\n\tif (getDataType() == DataType::UInt32) {\r\n\t\tif (writePyramidToDisk<unsigned int>() < 0) {\r\n\t\t\tstd::cout << \"Writing pyramid to disk failed, TIFF file is still valid for further analysis.\" << std::endl;\r\n\t\t\treturn -1;\r\n\t\t}\r\n\t\tincorporatePyramid<unsigned int>();\r\n\t}\r\n\telse if (getDataType() == DataType::UInt16) {\r\n\tif (writePyramidToDisk<unsigned short>() < 0) {\r\n\t\tstd::cout << \"Writing pyramid to disk failed, TIFF file is still valid for further analysis.\" << std::endl;\r\n\t\treturn -1;\r\n\t}\t\tincorporatePyramid<unsigned short>();\r\n\t}\r\n\telse if (getDataType() == DataType::UChar) {\r\n\t\tif (writePyramidToDisk<unsigned char>() < 0) {\r\n\t\t\tstd::cout << \"Writing pyramid to disk failed, TIFF file is still valid for further analysis.\" << std::endl;\r\n\t\t\treturn -1;\r\n\t\t}\r\n\t\tincorporatePyramid<unsigned char>();\r\n\t}\r\n\telse {\r\n\t\tif (writePyramidToDisk<float>() < 0) {\r\n\t\t\tstd::cout << \"Writing pyramid to disk failed, TIFF file is still valid for further analysis.\" << std::endl;\r\n\t\t\treturn -1;\r\n\t\t}\r\n\t\tincorporatePyramid<float>();\r\n\t}\r\n\tauto endPyramidTime = std::chrono::steady_clock::now();\r\n\t_totalPyramidTime += std::chrono::duration<double, milli>(endPyramidTime - startPyramidTime).count();\r\n\tfor (std::vector<std::string>::const_iterator it = _levelFiles.begin(); it != _levelFiles.end(); ++it) {\r\n\t\tfor (int i = 0; i < 5; ++i) {\r\n\t\t\tif (remove(it->c_str()) == 0) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tTIFFClose(_tiff);\r\n\t_tiff = NULL;\r\n\t_levelFiles.clear();\r\n\t_fileName = \"\";\r\n\t_pos = 0;\r\n\tstd::cout << \"Total time was \" << _totalReadingTime + _totalBaseWritingTime + _totalPyramidTime + _jpeg2kCompressionTime << std::endl;\r\n\tstd::cout << \"Total reading time was \" << _totalReadingTime << std::endl;\r\n\tstd::cout << \"Total base writing time was \" << _totalBaseWritingTime << std::endl;\r\n\tstd::cout << \"Total pyramid downsampling time was \" << _totalDownsamplingtime << std::endl;\r\n\tstd::cout << \"Total pyramid writing time was \" << _totalPyramidTime << std::endl;\r\n\tstd::cout << \"Total time determining min/max was \" << _totalMinMaxTime << std::endl;\r\n\tif (_codec == pathology::Compression::JPEG2000) {\r\n\t\tstd::cout << \"Total JPEG2000 encoding time was \" << _jpeg2kCompressionTime << std::endl;\r\n\t}\r\n\treturn 0;\r\n}",
    "int MultiResolutionImageWriter::writePyramidToDisk() {\r\n\r\n\t//! First get the overall image width and height;\r\n\tunsigned long w = 0, h = 0, nrsamples = 0, nrbits = 0;\r\n\t// TIFF idiosyncracy, when setting resolution tags one uses doubles,\r\n\t// getting them requires floats\r\n\tfloat spacingX = 0, spacingY = 0;\r\n\tstd::vector<double> spacing;\r\n\tTIFFGetField(_tiff, TIFFTAG_IMAGEWIDTH, &w);\r\n\tTIFFGetField(_tiff, TIFFTAG_IMAGELENGTH, &h);\r\n\tTIFFGetField(_tiff, TIFFTAG_SAMPLESPERPIXEL, &nrsamples);\r\n\tTIFFGetField(_tiff, TIFFTAG_BITSPERSAMPLE, &nrbits);\r\n\tif (TIFFGetField(_tiff, TIFFTAG_XRESOLUTION, &spacingX) == 1) {\r\n\t\tif (TIFFGetField(_tiff, TIFFTAG_YRESOLUTION, &spacingY) == 1) {\r\n\t\t\tspacing.push_back(1. / (spacingX / (10000.)));\r\n\t\t\tspacing.push_back(1. / (spacingY / (10000.)));\r\n\t\t}\r\n\t}\r\n\t// Determine the amount of pyramid levels\r\n\tunsigned int pyramidlevels = 1;\r\n\tunsigned int lowestwidth = w;\r\n\tif (_maxPyramidLevels < 0) {\r\n\t\twhile (lowestwidth > 1024) {\r\n\t\t\tlowestwidth /= _downsamplePerLevel;\r\n\t\t\tpyramidlevels += 1;\r\n\t\t}\r\n\t\tif (abs(1024. - lowestwidth) > abs(1024. - lowestwidth * 2)) {\r\n\t\t\tlowestwidth *= _downsamplePerLevel;\r\n\t\t\tpyramidlevels -= 1;\r\n\t\t}\r\n\t}\r\n\telse {\r\n\t\tpyramidlevels = _maxPyramidLevels;\r\n\t\tlowestwidth /= pow(_downsamplePerLevel, pyramidlevels);\r\n\t}\r\n\t// Setup the image directory for the thumbnail\r\n\tunsigned int lowestheight = (unsigned int)(h / pow(_downsamplePerLevel, (double)pyramidlevels));\r\n\r\n\t// Write temporary image to store previous level (LibTiff does not allow to go back and forth between\r\n\t// empty directories\r\n#ifdef WIN32\r\n\tsize_t found = _fileName.find_last_of(\"/\\\\\");\r\n#else \r\n\tsize_t found = _fileName.find_last_of(\"/\");\r\n#endif\r\n\tstring tmpPth = _fileName.substr(0, found + 1);\r\n\tstring fileName = _fileName.substr(found + 1);\r\n\tsize_t dotLoc = fileName.find_last_of(\".\");\r\n\tstring baseName = fileName.substr(0, dotLoc);\r\n\tfor (unsigned int level = 1; level <= pyramidlevels; ++level) {\r\n\t\tif (_monitor) {\r\n\t\t\t_monitor->setProgress((_monitor->maximumProgress() / 2.) + (static_cast<float>(level) / static_cast<float>(pyramidlevels))* (_monitor->maximumProgress() / 4.));\r\n\t\t}\r\n\t\tTIFF* prevLevelTiff = _tiff;\r\n\t\tif (level != 1) {\r\n\t\t\tstd::stringstream ssm;\r\n\t\t\tssm << tmpPth << \"temp\" << baseName << \"Level\" << level - 1 << \".tif\";\r\n\t\t\tprevLevelTiff = TIFFOpen(ssm.str().c_str(), \"r\");\r\n\t\t}\r\n\t\tstd::stringstream ssm;\r\n\t\tssm << tmpPth << \"temp\" << baseName << \"Level\" << level << \".tif\";\r\n\t\tTIFF* levelTiff = TIFFOpen(ssm.str().c_str(), \"w8\");\r\n\t\t_levelFiles.push_back(ssm.str());\r\n\t\tunsigned int levelw = (unsigned int)(w / pow(_downsamplePerLevel, (double)level));\r\n\t\tunsigned int levelh = (unsigned int)(h / pow(_downsamplePerLevel, (double)level));\r\n\t\tunsigned int prevLevelw = (unsigned int)(w / pow(_downsamplePerLevel, (double)level - 1));\r\n\t\tunsigned int prevLevelh = (unsigned int)(h / pow(_downsamplePerLevel, (double)level - 1));\r\n\t\tsetTempPyramidTags(levelTiff, levelw, levelh);\r\n\t\tunsigned int nrTilesX = (unsigned int)ceil(float(levelw) / _tileSize);\r\n\t\tunsigned int nrTilesY = (unsigned int)ceil(float(levelh) / _tileSize);\r\n\t\tunsigned int levelTiles = nrTilesX * nrTilesY;\r\n\t\tunsigned int npixels = _tileSize * _tileSize * nrsamples;\r\n\t\tint rowOrg = -_downsamplePerLevel, colOrg = 0;\r\n\t\tfor (unsigned int i = 0; i < levelTiles; ++i) {\r\n\t\t\tif (i % nrTilesX == 0) {\r\n\t\t\t\trowOrg += _downsamplePerLevel;\r\n\t\t\t\tcolOrg = 0;\r\n\t\t\t}\r\n\t\t\tunsigned int xpos = _tileSize * colOrg;\r\n\t\t\tunsigned int ypos = _tileSize * rowOrg;\r\n\t\t\tint inpTilesForOutpTile = _downsamplePerLevel * _downsamplePerLevel;\r\n\t\t\tstd::vector<T*> tiles;\r\n\t\t\tstd::vector<bool> tiles_valid;\r\n\t\t\tfor (int inTileNr = 0; inTileNr < inpTilesForOutpTile; ++inTileNr) {\r\n\t\t\t\ttiles.push_back((T*)_TIFFmalloc(npixels * sizeof(T)));\r\n\t\t\t\ttiles_valid.push_back(false);\r\n\t\t\t}\r\n\t\t\tT* outTile = (T*)_TIFFmalloc(npixels * sizeof(T));\r\n\t\t\tunsigned int size = npixels * sizeof(T);\r\n\t\t\tif (level == 1 && (getCompression() == Compression::JPEG2000)) {\r\n\t\t\t\tfor (int inRow = 0; inRow < _downsamplePerLevel; inRow++) {\r\n\t\t\t\t\tfor (int inCol = 0; inCol < _downsamplePerLevel; inCol++) {\r\n\t\t\t\t\t\tif (xpos + inCol * _tileSize >= prevLevelw || ypos + inRow * _tileSize >= prevLevelh) {\r\n\t\t\t\t\t\t\tstd::fill_n(tiles[inRow * _downsamplePerLevel + inCol], npixels, static_cast<T>(0));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tint tileNr = TIFFComputeTile(prevLevelTiff, xpos + inCol * _tileSize, ypos + inRow * _tileSize, 0, 0);\r\n\t\t\t\t\t\t\tunsigned int outTileSize = _tileSize * _tileSize * nrsamples * (nrbits / 8);\r\n\t\t\t\t\t\t\tint rawSize = TIFFReadRawTile(prevLevelTiff, tileNr, tiles[inRow * _downsamplePerLevel + inCol], outTileSize);\r\n\t\t\t\t\t\t\tif (rawSize > 0) {\r\n\t\t\t\t\t\t\t\ttiles_valid[inRow * _downsamplePerLevel + inCol] = true;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\tstd::fill_n(tiles[inRow * _downsamplePerLevel + inCol], npixels, static_cast<T>(0));\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tfor (int inRow = 0; inRow < _downsamplePerLevel; inRow++) {\r\n\t\t\t\t\tfor (int inCol = 0; inCol < _downsamplePerLevel; inCol++) {\r\n\t\t\t\t\t\tif (xpos + inCol * _tileSize >= prevLevelw || ypos + inRow * _tileSize >= prevLevelh) {\r\n\t\t\t\t\t\t\tstd::fill_n(tiles[inRow * _downsamplePerLevel + inCol], npixels, static_cast<T>(0));\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tif (TIFFReadTile(prevLevelTiff, tiles[inRow * _downsamplePerLevel + inCol], xpos + inCol * _tileSize, ypos + inRow * _tileSize, 0, 0) < 0) {\r\n\t\t\t\t\t\t\t\tstd::fill_n(tiles[inRow * _downsamplePerLevel + inCol], npixels, static_cast<T>(0));\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\ttiles_valid[inRow * _downsamplePerLevel + inCol] = true;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (std::any_of(tiles_valid.begin(), tiles_valid.end(), [](bool v) { return v; })) {\r\n\t\t\t\tstd::vector<T*> dsTiles;\r\n\t\t\t\tfor (auto tile : tiles) {\r\n\t\t\t\t\tdsTiles.push_back(downscaleTile(tile, _tileSize, nrsamples));\r\n\t\t\t\t}\r\n\t\t\t\tunsigned int dsSize = _tileSize / _downsamplePerLevel;\r\n\t\t\t\tfor (unsigned int y = 0; y < _tileSize; ++y) {\r\n\t\t\t\t\tfor (unsigned int x = 0; x < _tileSize; ++x) {\r\n\t\t\t\t\t\tfor (unsigned int s = 0; s < nrsamples; ++s) {\r\n\t\t\t\t\t\t\tunsigned int outIndex = nrsamples * (y * _tileSize + x) + s;\r\n\t\t\t\t\t\t\tunsigned int colTile = std::floor(x / dsSize);\r\n\t\t\t\t\t\t\tunsigned int rowTile = std::floor(y / dsSize);\r\n\t\t\t\t\t\t\tunsigned int inIndex = y * dsSize * nrsamples + x * nrsamples + s;\r\n\t\t\t\t\t\t\tT* usedTile = dsTiles[rowTile * _downsamplePerLevel + colTile];\r\n\t\t\t\t\t\t\tinIndex = ((y - rowTile * dsSize) * dsSize * nrsamples) + ((x - colTile * dsSize) * nrsamples) + s;\r\n\t\t\t\t\t\t\tT val = *(usedTile + inIndex);\r\n\t\t\t\t\t\t\t*(outTile + outIndex) = val;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tTIFFWriteEncodedTile(levelTiff, i, outTile, npixels * sizeof(T));\r\n\t\t\t\tfor (auto tile : dsTiles) {\r\n\t\t\t\t\t_TIFFfree(tile);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfor (auto tile : tiles) {\r\n\t\t\t\t_TIFFfree(tile);\r\n\t\t\t}\r\n\t\t\t_TIFFfree(outTile);\r\n\t\t\tcolOrg += _downsamplePerLevel;\r\n\t\t}\r\n\t\tif (level != 1) {\r\n\t\t\tTIFFClose(prevLevelTiff);\r\n\t\t}\r\n\t\tTIFFSetField(_tiff, TIFFTAG_RESOLUTIONUNIT, RESUNIT_CENTIMETER);\r\n\t\tif (!spacing.empty()) {\r\n\t\t\tspacing[0] *= _downsamplePerLevel;\r\n\t\t\tspacing[1] *= _downsamplePerLevel;\r\n\t\t\tdouble pixPerCmX = (1. / spacing[0]) * 10000;\r\n\t\t\tdouble pixPerCmY = (1. / spacing[1]) * 10000;\r\n\t\t\tTIFFSetField(levelTiff, TIFFTAG_XRESOLUTION, pixPerCmX);\r\n\t\t\tTIFFSetField(levelTiff, TIFFTAG_YRESOLUTION, pixPerCmY);\r\n\t\t}\r\n\t\tTIFFClose(levelTiff);\r\n\t}\r\n\t//! Write base directory to disk\r\n\tTIFFWriteDirectory(_tiff);\r\n\treturn 0;\r\n}",
    "int MultiResolutionImageWriter::incorporatePyramid() {\r\n\tunsigned long nrsamples = 0;\r\n\r\n\t//// Now add all the pyramid levels\r\n\tfor (vector<string>::const_iterator it = _levelFiles.begin(); it != _levelFiles.end(); ++it) {\r\n\t\tif (_monitor) {\r\n\t\t\t_monitor->setProgress(3 * (_monitor->maximumProgress() / 4.) + ((static_cast<float>(it - _levelFiles.begin()) + 1.0) / static_cast<float>(_levelFiles.size()))* (_monitor->maximumProgress() / 4.));\r\n\t\t}\r\n\t\tTIFF* level = TIFFOpen(it->c_str(), \"rm\");\r\n\r\n\t\tfloat spacingX = 0, spacingY = 0;\r\n\t\tstd::vector<double> spacing;\r\n\t\tif (TIFFGetField(level, TIFFTAG_XRESOLUTION, &spacingX) == 1) {\r\n\t\t\tif (TIFFGetField(level, TIFFTAG_YRESOLUTION, &spacingY) == 1) {\r\n\t\t\t\tspacing.push_back(1. / (spacingX / (10000.)));\r\n\t\t\t\tspacing.push_back(1. / (spacingY / (10000.)));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tunsigned int levelw, levelh;\r\n\t\tTIFFGetField(level, TIFFTAG_IMAGEWIDTH, &levelw);\r\n\t\tTIFFGetField(level, TIFFTAG_IMAGELENGTH, &levelh);\r\n\t\tsetPyramidTags(_tiff, levelw, levelh);\r\n\t\tTIFFSetField(_tiff, TIFFTAG_SUBFILETYPE, FILETYPE_REDUCEDIMAGE);\r\n\t\tTIFFGetField(level, TIFFTAG_SAMPLESPERPIXEL, &nrsamples);\r\n\t\twritePyramidLevel<T>(level, levelw, levelh, nrsamples);\r\n\r\n\t\tsetSpacing(spacing);\r\n\t\tTIFFWriteDirectory(_tiff);\r\n\t\tTIFFClose(level);\r\n\t}\r\n\treturn 0;\r\n}",
    "void safeTiffClose(TIFF* tif)\n{\n\tif(tif)\n\t\tTIFFClose(tif);\n}",
    "void save_tiff( const char *filename,\n\t\t\t\tTqFloat *raster,\n\t\t\t\tTqInt width,\n\t\t\t\tTqInt length,\n\t\t\t\tTqInt samples,\n\t\t\t\tconst char* description)\n{\n\t/* save to a tiff file */\n\tTqInt i;\n\tTqUchar *pdata = (TqUchar *) raster;\n\tTIFF* ptex = TIFFOpen( filename, \"w\" );\n\tstatic TqChar datetime[20];\n\tstruct tm  *ct;\n\tTqInt    year;\n\tTqInt linewidth;\n\n\ttime_t long_time;\n\n\ttime( &long_time );           /* Get time as long integer. */\n\tct = localtime( &long_time ); /* Convert to local time. */\n\n\n\tyear=1900 + ct->tm_year;\n\tstd::sprintf(datetime, \"%04d:%02d:%02d %02d:%02d:%02d\",\n\t        year, ct->tm_mon + 1, ct->tm_mday,\n\t        ct->tm_hour, ct->tm_min, ct->tm_sec);\n\n\n\tTIFFCreateDirectory( ptex );\n\n\n\tTIFFSetField( ptex, TIFFTAG_SOFTWARE, description );\n\tTIFFSetField( ptex, TIFFTAG_IMAGEWIDTH, width );\n\tTIFFSetField( ptex, TIFFTAG_IMAGELENGTH, length );\n\tTIFFSetField( ptex, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG );\n\tTIFFSetField( ptex, TIFFTAG_BITSPERSAMPLE, 32 );\n\tTIFFSetField( ptex, TIFFTAG_SAMPLESPERPIXEL, samples );\n\tTIFFSetField( ptex, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT );\n\tTIFFSetField( ptex, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP );\n\tTIFFSetField( ptex, TIFFTAG_COMPRESSION, COMPRESSION_PACKBITS );\n\tTIFFSetField( ptex, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB );\n\tTIFFSetField( ptex, TIFFTAG_ROWSPERSTRIP, 1 );\n\tTIFFSetField( ptex, TIFFTAG_DATETIME, datetime);\n\n\tlinewidth = width * samples;\n\tlinewidth *= sizeof(TqFloat);\n\tfor ( i = 0; i < length; i++ )\n\t{\n\t\tTIFFWriteScanline( ptex, pdata, i, 0 );\n\t\tpdata += linewidth;\n\t}\n\tTIFFClose( ptex );\n}",
    "void SaveAsShadowMap(const std::string& filename, SqDisplayInstance* image, char *mydescription)\n{\n\tTqChar version[ 80 ];\n\tTqUint twidth = 32;\n\tTqUint tlength = 32;\n\n\tstruct tm *ct;\n\tint year;\n\n\ttime_t long_time;\n\n\ttime( &long_time );           /* Get time as long integer. */\n\tct = localtime( &long_time ); /* Convert to local time. */\n\n\n\tyear=1900 + ct->tm_year;\n\tsprintf(datetime, \"%04d:%02d:%02d %02d:%02d:%02d\", year, ct->tm_mon + 1,\n\t        ct->tm_mday, ct->tm_hour, ct->tm_min, ct->tm_sec);\n\n\n\tconst char* mode = (image->m_append)? \"a\" : \"w\";\n\n\t// Save the shadowmap to a binary file.\n\tif ( filename.compare( \"\" ) != 0 )\n\t{\n\t\tTIFF * pshadow = TIFFOpen( filename.c_str(), mode );\n\t\tif( pshadow != NULL )\n\t\t{\n\t\t\t// Set common tags\n\t\t\tTIFFCreateDirectory( pshadow );\n\n\t\t\tsprintf( version, \"Aqsis %s (%s %s)\", AQSIS_VERSION_STR, __DATE__, __TIME__);\n\n\t\t\tTIFFSetField( pshadow, TIFFTAG_SOFTWARE, ( char* ) version );\n\t\t\tTIFFSetField( pshadow, TIFFTAG_PIXAR_MATRIX_WORLDTOCAMERA, image->m_matWorldToCamera );\n\t\t\tTIFFSetField( pshadow, TIFFTAG_PIXAR_MATRIX_WORLDTOSCREEN, image->m_matWorldToScreen );\n\t\t\tTIFFSetField( pshadow, TIFFTAG_PIXAR_TEXTUREFORMAT, SHADOWMAP_HEADER );\n\t\t\tTIFFSetField( pshadow, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK );\n\n\t\t\tif (!image->m_hostname.empty())\n\t\t\t\tTIFFSetField( pshadow, TIFFTAG_HOSTCOMPUTER, image->m_hostname.c_str() );\n\t\t\tTIFFSetField( pshadow, TIFFTAG_IMAGEDESCRIPTION, mydescription);\n\t\t\t// Write the floating point image to the directory.\n\t\t\tTIFFSetField( pshadow, TIFFTAG_IMAGEWIDTH, image->m_width );\n\t\t\tTIFFSetField( pshadow, TIFFTAG_IMAGELENGTH, image->m_height );\n\t\t\tTIFFSetField( pshadow, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG );\n\t\t\tTIFFSetField( pshadow, TIFFTAG_BITSPERSAMPLE, 32 );\n\t\t\tTIFFSetField( pshadow, TIFFTAG_SAMPLESPERPIXEL, image->m_iFormatCount );\n\t\t\tTIFFSetField( pshadow, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT );\n\t\t\tTIFFSetField( pshadow, TIFFTAG_TILEWIDTH, twidth );\n\t\t\tTIFFSetField( pshadow, TIFFTAG_TILELENGTH, tlength );\n\t\t\tTIFFSetField( pshadow, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP );\n\t\t\tTIFFSetField( pshadow, TIFFTAG_COMPRESSION, image->m_compression );\n\t\t\tTIFFSetField( pshadow, TIFFTAG_DATETIME, datetime);\n\n\t\t\tTqDouble minz = FLT_MAX;\n\t\t\tTqFloat* ptdata = reinterpret_cast<TqFloat*>(image->m_data) ;\n\t\t\tfor (TqInt y = 0; y < image->m_height; y++)\n\t\t\t\tfor (TqInt x = 0; x < image->m_width; x++)\n\t\t\t\t{\n\t\t\t\t\tTqDouble value = (TqDouble) ptdata[y*image->m_width + x];\n\t\t\t\t\tif (value < minz) minz = value;\t\n\t\t\t\t}\n\t\t\tTIFFSetField( pshadow, TIFFTAG_SMINSAMPLEVALUE, minz );\n\n\t\t\tTqUint tsize = twidth * tlength;\n\t\t\tTqUint tperrow = ( image->m_width + twidth - 1 ) / twidth;\n\t\t\tTqFloat* ptile = static_cast<TqFloat*>( _TIFFmalloc( tsize * sizeof( TqFloat ) ) );\n\n\n\t\t\tif ( ptile != NULL )\n\t\t\t{\n\t\t\t\tTqUint ctiles = tperrow * ( ( image->m_width + tlength - 1 ) / tlength );\n\t\t\t\tTqUint itile;\n\t\t\t\tfor ( itile = 0; itile < ctiles; itile++ )\n\t\t\t\t{\n\t\t\t\t\tTqUint x = ( itile % tperrow ) * twidth;\n\t\t\t\t\tTqUint y = ( itile / tperrow ) * tlength;\n\t\t\t\t\tptdata = reinterpret_cast<TqFloat*>(image->m_data) + ( ( y * image->m_width ) + x ) * image->m_iFormatCount;\n\t\t\t\t\t// Clear the tile to black.\n\t\t\t\t\tmemset( ptile, 0, tsize * sizeof( TqFloat ) );\n\t\t\t\t\tfor ( TqUlong i = 0; i < tlength; i++ )\n\t\t\t\t\t{\n\t\t\t\t\t\tfor ( TqUlong j = 0; j < twidth; j++ )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif ( ( x + j ) < (TqUlong) image->m_width && ( y + i ) < (TqUlong) image->m_height )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tTqInt ii;\n\t\t\t\t\t\t\t\tfor ( ii = 0; ii < image->m_iFormatCount; ii++ ) \n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tTqFloat value = ptdata[ ( ( j * image->m_iFormatCount ) + ii ) ];\n\t\t\t\t\t\t\t\t\tptile[ ( i * twidth * image->m_iFormatCount ) + ( ( ( j * image->m_iFormatCount ) + ii ) ) ] = value;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tptdata += ( image->m_width * image->m_iFormatCount );\n\t\t\t\t\t}\n\t\t\t\t\tTIFFWriteTile( pshadow, ptile, x, y, 0, 0 );\n\t\t\t\t}\n\t\t\t\tTIFFWriteDirectory( pshadow );\n\n\t\t\t}\n\n\n\t\t\tTIFFClose( pshadow );\n\t\t}\n\t}\n}",
    "void WriteTIFF(const std::string& filename, SqDisplayInstance* image)\n{\n\tuint16 photometric = PHOTOMETRIC_RGB;\n\tuint16 config = PLANARCONFIG_CONTIG;\n\tstruct tm *ct;\n\tchar mydescription[80];\n\tint year;\n\n\ttime_t long_time;\n\n\ttime( &long_time );           /* Get time as long integer. */\n\tct = localtime( &long_time ); /* Convert to local time. */\n\n\n\tyear=1900 + ct->tm_year;\n\tsprintf(datetime, \"%04d:%02d:%02d %02d:%02d:%02d\", year, ct->tm_mon + 1,\n\t        ct->tm_mday, ct->tm_hour, ct->tm_min, ct->tm_sec);\n\n\tif (description.empty())\n\t{\n\t\tdouble nSecs = difftime(long_time, start);\n\t\tsprintf(mydescription,\"Aqsis Renderer, %d secs rendertime\", static_cast<TqInt>(nSecs));\n\t\tstart = long_time;\n\t}\n\telse\n\t{\n\t\tstrcpy(mydescription, description.c_str());\n\t}\n\n\n\t// Set common tags\n\t// If in \"shadowmap\" mode, write as a shadowmap.\n\tif( image->m_imageType == Type_Shadowmap )\n\t{\n\t\tSaveAsShadowMap(filename, image, mydescription);\n\t\treturn;\n\t}\n\telse if( image->m_imageType == Type_ZFile )\n\t{\n\t\tstd::ofstream ofile( filename.c_str(), std::ios::out | std::ios::binary );\n\t\tif ( ofile.is_open() )\n\t\t{\n\t\t\t// Save a file type and version marker\n\t\t\tofile << ZFILE_HEADER;\n\n\t\t\t// Save the xres and yres.\n\t\t\tofile.write( reinterpret_cast<char* >( &image->m_width ), sizeof( image->m_width ) );\n\t\t\tofile.write( reinterpret_cast<char* >( &image->m_height ), sizeof( image->m_height ) );\n\n\t\t\t// Save the transformation matrices.\n\t\t\tofile.write( reinterpret_cast<char*>( image->m_matWorldToCamera[ 0 ] ), sizeof( image->m_matWorldToCamera[ 0 ][ 0 ] ) * 4 );\n\t\t\tofile.write( reinterpret_cast<char*>( image->m_matWorldToCamera[ 1 ] ), sizeof( image->m_matWorldToCamera[ 0 ][ 0 ] ) * 4 );\n\t\t\tofile.write( reinterpret_cast<char*>( image->m_matWorldToCamera[ 2 ] ), sizeof( image->m_matWorldToCamera[ 0 ][ 0 ] ) * 4 );\n\t\t\tofile.write( reinterpret_cast<char*>( image->m_matWorldToCamera[ 3 ] ), sizeof( image->m_matWorldToCamera[ 0 ][ 0 ] ) * 4 );\n\n\t\t\tofile.write( reinterpret_cast<char*>( image->m_matWorldToScreen[ 0 ] ), sizeof( image->m_matWorldToScreen[ 0 ][ 0 ] ) * 4 );\n\t\t\tofile.write( reinterpret_cast<char*>( image->m_matWorldToScreen[ 1 ] ), sizeof( image->m_matWorldToScreen[ 0 ][ 0 ] ) * 4 );\n\t\t\tofile.write( reinterpret_cast<char*>( image->m_matWorldToScreen[ 2 ] ), sizeof( image->m_matWorldToScreen[ 0 ][ 0 ] ) * 4 );\n\t\t\tofile.write( reinterpret_cast<char*>( image->m_matWorldToScreen[ 3 ] ), sizeof( image->m_matWorldToScreen[ 0 ][ 0 ] ) * 4 );\n\n\t\t\t// Now output the depth values\n\t\t\tofile.write( reinterpret_cast<char*>( image->m_data ), sizeof( TqFloat ) * ( image->m_width * image->m_height ) );\n\t\t\tofile.close();\n\t\t}\n\t\treturn;\n\t}\n\n\tTIFF* pOut = TIFFOpen( filename.c_str(), \"w\" );\n\n\tif ( pOut )\n\t{\n\t\t// Write the image to a tiff file.\n\t\tchar version[ 80 ];\n\n\t\tshort ExtraSamplesTypes[ 1 ] = {EXTRASAMPLE_ASSOCALPHA};\n\n\t\tsprintf( version, \"Aqsis %s (%s %s)\", AQSIS_VERSION_STR, __DATE__, __TIME__);\n\t\tbool use_logluv = false;\n\n\t\tTIFFSetField( pOut, TIFFTAG_SOFTWARE, ( char* ) version );\n\t\tTIFFSetField( pOut, TIFFTAG_IMAGEWIDTH, ( uint32 ) image->m_width );\n\t\tTIFFSetField( pOut, TIFFTAG_IMAGELENGTH, ( uint32 ) image->m_height );\n\t\tTIFFSetField( pOut, TIFFTAG_RESOLUTIONUNIT, RESUNIT_NONE );\n\t\tTIFFSetField( pOut, TIFFTAG_XRESOLUTION, (float) 1.0 );\n\t\tTIFFSetField( pOut, TIFFTAG_YRESOLUTION, (float) 1.0 );\n\t\tTIFFSetField( pOut, TIFFTAG_BITSPERSAMPLE, (short) 8 );\n\t\tTIFFSetField( pOut, TIFFTAG_PIXAR_MATRIX_WORLDTOCAMERA, image->m_matWorldToCamera );\n\t\tTIFFSetField( pOut, TIFFTAG_PIXAR_MATRIX_WORLDTOSCREEN, image->m_matWorldToScreen );\n\t\tTIFFSetField( pOut, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT );\n\t\tTIFFSetField( pOut, TIFFTAG_SAMPLESPERPIXEL, image->m_iFormatCount );\n\t\tTIFFSetField( pOut, TIFFTAG_DATETIME, datetime);\n\t\tif (!image->m_hostname.empty())\n\t\t\tTIFFSetField( pOut, TIFFTAG_HOSTCOMPUTER, image->m_hostname.c_str() );\n\t\tTIFFSetField( pOut, TIFFTAG_IMAGEDESCRIPTION, mydescription);\n\n\t\t// Set the position tages in case we aer dealing with a cropped image.\n\t\tTIFFSetField( pOut, TIFFTAG_XPOSITION, ( float ) image->m_origin[0] );\n\t\tTIFFSetField( pOut, TIFFTAG_YPOSITION, ( float ) image->m_origin[1] );\n\t\tTIFFSetField( pOut, TIFFTAG_PIXAR_IMAGEFULLWIDTH, (uint32) image->m_OriginalSize[0] );\n\t\tTIFFSetField( pOut, TIFFTAG_PIXAR_IMAGEFULLLENGTH, (uint32) image->m_OriginalSize[1] );\n\n\t\t// Write out an 8 bits per pixel integer image.\n\t\tif ( image->m_format == PkDspyUnsigned8 )\n\t\t{\n\t\t\tTIFFSetField( pOut, TIFFTAG_BITSPERSAMPLE, 8 );\n\t\t\tTIFFSetField( pOut, TIFFTAG_PLANARCONFIG, config );\n\t\t\tTIFFSetField( pOut, TIFFTAG_COMPRESSION, image->m_compression );\n\t\t\tif ( image->m_compression == COMPRESSION_JPEG )\n\t\t\t\tTIFFSetField( pOut, TIFFTAG_JPEGQUALITY, image->m_quality );\n\t\t\tTIFFSetField( pOut, TIFFTAG_PHOTOMETRIC, photometric );\n\t\t\tTIFFSetField( pOut, TIFFTAG_ROWSPERSTRIP, TIFFDefaultStripSize( pOut, 0 ) );\n\n\t\t\tif ( image->m_iFormatCount == 4 )\n\t\t\t\tTIFFSetField( pOut, TIFFTAG_EXTRASAMPLES, 1, ExtraSamplesTypes );\n\n\t\t\tTqInt row;\n\t\t\tfor ( row = 0; row < image->m_height; row++ )\n\t\t\t{\n\t\t\t\tif ( TIFFWriteScanline( pOut, reinterpret_cast<void*>(reinterpret_cast<char*>(image->m_data) + ( row * image->m_lineLength ))\n\t\t\t\t                        , row, 0 ) < 0 )\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tTIFFClose( pOut );\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Write out a floating point image.\n\t\t\tTIFFSetField( pOut, TIFFTAG_STONITS, ( double ) 1.0 );\n\n\t\t\t//\t\t\tif(/* user wants logluv compression*/)\n\t\t\t//\t\t\t{\n\t\t\t//\t\t\t\tif(/* user wants to save the alpha channel */)\n\t\t\t//\t\t\t\t{\n\t\t\t//\t\t\t\t\twarn(\"SGI LogLuv encoding does not allow an alpha channel\"\n\t\t\t//\t\t\t\t\t\t\t\" - using uncompressed IEEEFP instead\");\n\t\t\t//\t\t\t\t}\n\t\t\t//\t\t\t\telse\n\t\t\t//\t\t\t\t{\n\t\t\t//\t\t\t\t\tuse_logluv = true;\n\t\t\t//\t\t\t\t}\n\t\t\t//\n\t\t\t//\t\t\t\tif(/* user wants LZW compression*/)\n\t\t\t//\t\t\t\t{\n\t\t\t//\t\t\t\t\twarn(\"LZW compression is not available with SGI LogLuv encoding\\n\");\n\t\t\t//\t\t\t\t}\n\t\t\t//\t\t\t}\n\n\t\t\tif ( use_logluv )\n\t\t\t{\n\t\t\t\t/* use SGI LogLuv compression */\n\t\t\t\tTIFFSetField( pOut, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT );\n\t\t\t\tTIFFSetField( pOut, TIFFTAG_BITSPERSAMPLE, 16 );\n\t\t\t\tTIFFSetField( pOut, TIFFTAG_COMPRESSION, COMPRESSION_SGILOG );\n\t\t\t\tTIFFSetField( pOut, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_LOGLUV );\n\t\t\t\tTIFFSetField( pOut, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_FLOAT );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* use uncompressed IEEEFP pixels */\n\t\t\t\tTIFFSetField( pOut, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP );\n\t\t\t\tTIFFSetField( pOut, TIFFTAG_BITSPERSAMPLE, 32 );\n\t\t\t\tTIFFSetField( pOut, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB );\n\t\t\t\tTIFFSetField( pOut, TIFFTAG_COMPRESSION, image->m_compression );\n\t\t\t}\n\t\t\tif (image->m_format == PkDspyUnsigned16)\n\t\t\t{\n\t\t\t\tTIFFSetField( pOut, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT );\n\t\t\t\tTIFFSetField( pOut, TIFFTAG_BITSPERSAMPLE, 16 );\n\t\t\t}\n\n\t\t\tTIFFSetField( pOut, TIFFTAG_SAMPLESPERPIXEL, image->m_iFormatCount );\n\n\t\t\tif ( image->m_iFormatCount == 4 )\n\t\t\t\tTIFFSetField( pOut, TIFFTAG_EXTRASAMPLES, 1, ExtraSamplesTypes );\n\t\t\tTIFFSetField( pOut, TIFFTAG_PLANARCONFIG, config );\n\n\t\t\tTqInt row = 0;\n\t\t\tfor ( row = 0; row < image->m_height; row++ )\n\t\t\t{\n\t\t\t\tif ( TIFFWriteScanline( pOut, reinterpret_cast<void*>(reinterpret_cast<TqUchar*>(image->m_data) + ( row * image->m_lineLength )), row, 0 )\n\t\t\t\t        < 0 )\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tTIFFClose( pOut );\n\t\t}\n\t}\n}",
    "void writeStripTiff(const char* fileName)\n{\n\tuint32 height = 4;\n\tuint32 width = 6;\n\tuint32 rowsPerStrip = height/2;\n\tuint16 samplesPerPixel = 3;\n\tuint16 bitsPerSample = 8;\n\n\tconst unsigned char red[] = {0xFF, 0, 0};\n\tconst unsigned char blue[] = {0, 0, 0xFF};\n\n\t//TIFF* outFile = TIFFStreamOpen(\"stream\", &outStream);\n\tTIFF* outFile = TIFFOpen(fileName, \"w\");\n\n\tsetTiffFields(outFile, width, height, samplesPerPixel, bitsPerSample);\n\tTIFFSetField(outFile, TIFFTAG_ROWSPERSTRIP, rowsPerStrip);\n\tTIFFSetField(outFile, TIFFTAG_IMAGEDESCRIPTION, \"Strip-allocated tiff for unit tests\");\n\n\ttsize_t bufSize = TIFFStripSize(outFile);\n\tunsigned char* buf = reinterpret_cast<unsigned char*>(_TIFFmalloc(bufSize));\n\n\t// first directory is a red strip and a blue strip.\n\tsetBufToColor(buf, bufSize/samplesPerPixel, red, samplesPerPixel);\n\tTIFFWriteEncodedStrip(outFile, 0, buf, bufSize);\n\tsetBufToColor(buf, bufSize/samplesPerPixel, blue, samplesPerPixel);\n\tTIFFWriteEncodedStrip(outFile, 1, buf, bufSize);\n\n\tTIFFWriteDirectory(outFile);\n\n\tsetTiffFields(outFile, width, height, samplesPerPixel, bitsPerSample);\n\tTIFFSetField(outFile, TIFFTAG_ROWSPERSTRIP, rowsPerStrip);\n\n\t// second directory is a white strip and a black strip\n\t_TIFFmemset(buf, 0xFF, bufSize);\n\tTIFFWriteEncodedStrip(outFile, 0, buf, bufSize);\n\t_TIFFmemset(buf, 0x00, bufSize);\n\tTIFFWriteEncodedStrip(outFile, 1, buf, bufSize);\n\n\tTIFFClose(outFile);\n\t_TIFFfree(buf);\n\t//TIFFSetField(outFile, TIFFTAG_TILEWIDTH, tileWidth);\n\t//TIFFSetField(outFile, TIFFTAG_TILELENGTH, tileHeight);\n}",
    "void writeTiledTiff(const char* fileName)\n{\n\tuint32 height = 5;\n\tuint32 width = 4;\n\tuint16 samplesPerPixel = 3;\n\tuint16 bitsPerSample = 8;\n\tuint32 tileWidth = 16;\n\tuint32 tileHeight = 16;\n\n\t//TIFF* outFile = TIFFStreamOpen(\"stream\", &outStream);\n\tTIFF* outFile = TIFFOpen(fileName, \"w\");\n\n\tsetTiffFields(outFile, width, height, samplesPerPixel, bitsPerSample);\n\tTIFFSetField(outFile, TIFFTAG_TILEWIDTH, tileWidth);\n\tTIFFSetField(outFile, TIFFTAG_TILELENGTH, tileHeight);\n\n\ttsize_t bufSize = TIFFTileSize(outFile);\n\tchar* buf = reinterpret_cast<char*>(_TIFFmalloc(bufSize));\n\t_TIFFmemset(buf, 0x00, bufSize);\n\n\t// first directory\n\tTIFFWriteEncodedTile(outFile, 0, buf, bufSize);\n\tTIFFWriteDirectory(outFile);\n\n\t// rest of the directories\n\twhile(width > 1 || height > 1)\n\t{\n\t\twidth = std::max<uint32>((width+1)/2, 1);\n\t\theight = std::max<uint32>((height+1)/2, 1);\n\t\tsetTiffFields(outFile, width, height, samplesPerPixel, bitsPerSample);\n\t\tTIFFSetField(outFile, TIFFTAG_TILEWIDTH, tileWidth);\n\t\tTIFFSetField(outFile, TIFFTAG_TILELENGTH, tileHeight);\n\n\t\tTIFFWriteEncodedTile(outFile, 0, buf, bufSize);\n\t\tTIFFWriteDirectory(outFile);\n\t}\n\n\tTIFFClose(outFile);\n\t_TIFFfree(buf);\n}",
    "virtual bool close()\n        {\n            if(!m_tif)\n                return false;\n            TIFFClose(m_tif);\n            m_tif = 0;\n            return true;\n        }",
    "void CqShadowMapOld::SaveShadowMapOld( const CqString& strShadowName, bool append )\n{\n\tconst char* mode = (append)? \"a\" : \"w\";\n\n\t// Save the shadowmap to a binary file.\n\tif ( m_strName.compare( \"\" ) != 0 )\n\t{\n\t\tif ( ! m_apFlat.empty() )\n\t\t{\n\t\t\tTIFF * pshadow = TIFFOpen( strShadowName.c_str(), mode );\n\t\t\tTIFFCreateDirectory( pshadow );\n\n\t\t\t// Write the transform matrices.\n\t\t\tTqFloat\tmatWToC[ 16 ];\n\t\t\tTqFloat\tmatWToS[ 16 ];\n\t\t\tTqInt r, c;\n\t\t\tfor ( r = 0; r < 4; r++ )\n\t\t\t{\n\t\t\t\tfor ( c = 0; c < 4; c++ )\n\t\t\t\t{\n\t\t\t\t\tmatWToC[ ( r * 4 ) + c ] = matWorldToCamera()[ r ][ c ];\n\t\t\t\t\tmatWToS[ ( r * 4 ) + c ] = matWorldToScreen()[ r ][ c ];\n\t\t\t\t}\n\t\t\t}\n\t\t\tTIFFSetField( pshadow, TIFFTAG_PIXAR_MATRIX_WORLDTOCAMERA, matWToC );\n\t\t\tTIFFSetField( pshadow, TIFFTAG_PIXAR_MATRIX_WORLDTOSCREEN, matWToS );\n\t\t\tTIFFSetField( pshadow, TIFFTAG_PIXAR_TEXTUREFORMAT, SHADOWMAP_HEADER );\n\t\t\tTIFFSetField( pshadow, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK );\n\n\t\t\t// Write the floating point image to the directory.\n\t\t\tTqDouble minz = RI_FLOATMAX;\n\t\t\tTqFloat *depths = reinterpret_cast<TqFloat*>( m_apFlat.front() ->pVoidBufferData() );\n\t\t\tfor (TqUint y =0; y < YRes(); y++)\n\t\t\t\tfor (TqUint x = 0; x < XRes(); x++)\n\t\t\t\t\tminz = min(minz, (TqDouble)depths[y*XRes() + x]);\n\t\t\tTIFFSetField( pshadow, TIFFTAG_SMINSAMPLEVALUE, minz );\n\t\t\tWriteTileImage( pshadow, depths, XRes(), YRes(), 32, 32, 1, m_Compression, m_Quality );\n\t\t\tTIFFClose( pshadow );\n\t\t}\n\t}\n}",
    "void CqTextureMapOld::Close()\n{\n\n\tif ( m_pImage != 0 )\n\t\tTIFFClose( m_pImage );\n\tm_pImage = 0;\n\n}",
    "int main()\n{\n    const int width = 1000;\n    const int maxIter = 2000;\n\n    const int superSamp = 3;\n\n    double scale = 0.01;\n    Transform trans;\n    trans.dx = scale/superSamp * 2.0/width;\n    trans.x0 =  -0.79 + scale * -1.0;\n    trans.dy = -scale/superSamp * 2.0/width;\n    trans.y0 =  0.15 + scale * 1.0;\n\n    const int filterWidth = 3;\n    std::vector<float> filter;\n    cacheFilter(filter, filterWidth, superSamp);\n\n    TIFF* tif = TIFFOpen(\"mandel.tif\", \"w\");\n\n//    renderImageSimple(tif, width, superSamp, &filter[0], filterWidth,\n//                      trans, maxIter);\n//    renderImageTiled(tif, width, superSamp, &filter[0], filterWidth,\n//                     trans, maxIter);\n//    renderImageParallelOmp(tif, width, superSamp, &filter[0], filterWidth,\n//                           trans, maxIter);\n    renderImageParallel(tif, width, superSamp, &filter[0], filterWidth,\n                        trans, maxIter);\n\n    TIFFClose(tif);\n\n    return 0;\n}",
    "bool tImageTIFF::Load(const tString& tiffFile)\n{\n\tClear();\n\n\tif (tSystem::tGetFileType(tiffFile) != tSystem::tFileType::TIFF)\n\t\treturn false;\n\n\tif (!tFileExists(tiffFile))\n\t\treturn false;\n\n\tTIFF* tiff = TIFFOpen(tiffFile.Chr(), \"rb\");\n\tif (!tiff)\n\t\treturn false;\n\n\t// Create all frames.\n\ttPixelFormat srcFormat = tPixelFormat::R8G8B8A8;\n\tdo\n\t{\n\t\tint width = 0; int height = 0;\n\t\tTIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, &width);\n\t\tTIFFGetField(tiff, TIFFTAG_IMAGELENGTH, &height);\n\t\tif ((width <= 0) || (height <= 0))\n\t\t\tbreak;\n\n\t\tint numPixels = width*height;\n\t\tint durationMilliSeconds = ReadSoftwarePageDuration(tiff);\n\n\t\tuint32* pixels = (uint32*)_TIFFmalloc(numPixels * sizeof(uint32));\n\t\tint successCode = TIFFReadRGBAImage(tiff, width, height, pixels, 0);\n\t\tif (!successCode)\n\t\t{\n\t\t\t_TIFFfree(pixels);\n\t\t\tbreak;\n\t\t}\n\n\t\ttFrame* frame = new tFrame;\n\t\tframe->Width = width;\n\t\tframe->Height = height;\n\t\tframe->Pixels = new tPixel4b[width*height];\n\t\tframe->PixelFormatSrc = srcFormat;\n\n\t\t// If duration not set we use a default of 1 second.\n\t\tframe->Duration = (durationMilliSeconds >= 0) ? float(durationMilliSeconds)/1000.0f : 1.0f;\n\n\t\tfor (int p = 0; p < width*height; p++)\n\t\t\tframe->Pixels[p] = pixels[p];\n\n\t\t_TIFFfree(pixels);\n\t\tFrames.Append(frame);\n\t} while (TIFFReadDirectory(tiff));\n\n\tTIFFClose(tiff);\n\tif (Frames.GetNumItems() == 0)\n\t\treturn false;\n\n\tPixelFormatSrc = srcFormat;\n\tPixelFormat = tPixelFormat::R8G8B8A8;\n\n\t// TIFF files are assumed to be in sRGB.\n\tColourProfileSrc = tColourProfile::sRGB;\n\tColourProfile = tColourProfile::sRGB;\n\n\treturn true;\n}",
    "bool tImageTIFF::Save(const tString& tiffFile, const SaveParams& params) const\n{\n\tif (!IsValid() || (params.Format == tFormat::Invalid))\n\t\treturn false;\n\n\tif (tSystem::tGetFileType(tiffFile) != tSystem::tFileType::TIFF)\n\t\treturn false;\n\n\tTIFF* tiff = TIFFOpen(tiffFile.Chr(), \"wb\");\n\tif (!tiff)\n\t\treturn false;\n\n\tint rowSize = 0;\n\tuint8* rowBuf = nullptr;\n\tfor (tFrame* frame = Frames.First(); frame; frame = frame->Next())\n\t{\n\t\t// Writes image from last loop and starts a new directory.\n\t\tif (frame != Frames.First())\n\t\t\tTIFFWriteDirectory(tiff);\n\n\t\tbool isOpaque = frame->IsOpaque();\n\t\tint bytesPerPixel = 0;\n\t\tswitch (params.Format)\n\t\t{\n\t\t\tcase tFormat::Auto:\t\tbytesPerPixel = isOpaque ? 3 : 4;\tbreak;\n\t\t\tcase tFormat::BPP24:\tbytesPerPixel = 3;\t\t\t\t\tbreak;\n\t\t\tcase tFormat::BPP32:\tbytesPerPixel = 4;\t\t\t\t\tbreak;\n\t\t}\n\t\ttAssert(bytesPerPixel);\n\n\t\tint w = frame->Width;\n\t\tint h = frame->Height;\n\n\t\tTIFFSetField(tiff, TIFFTAG_IMAGEWIDTH, w);\n\t\tTIFFSetField(tiff, TIFFTAG_IMAGELENGTH, h);\n\t\tTIFFSetField(tiff, TIFFTAG_SAMPLESPERPIXEL, bytesPerPixel);\n\t\tTIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 8);\n\t\tTIFFSetField(tiff, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n\t\tTIFFSetField(tiff, TIFFTAG_COMPRESSION, params.UseZLibCompression ? COMPRESSION_DEFLATE : COMPRESSION_NONE);\n\t\tTIFFSetField(tiff, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\t\tTIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n\t\tif (bytesPerPixel == 4)\n\t\t{\n\t\t\t// Unassociated alpha means the extra channel is not a premultiplied alpha channel.\n\t\t\tuint16 extraSampleTypes[] = { EXTRASAMPLE_UNASSALPHA };\n\t\t\tTIFFSetField(tiff, TIFFTAG_EXTRASAMPLES, tNumElements(extraSampleTypes), extraSampleTypes);\n\t\t}\n\n\t\tint pageDurMilliSec = (params.OverrideFrameDuration >= 0) ? params.OverrideFrameDuration : int(frame->Duration*1000.0f);\n\t\tWriteSoftwarePageDuration(tiff, pageDurMilliSec);\n\n\t\tint rowSizeNeeded = TIFFScanlineSize(tiff);\n\t\ttAssert(rowSizeNeeded == (w*bytesPerPixel));\n\n\t\t// Let's not reallocate the line buffer every frame. Often all frames will be the same size.\n\t\tif (rowSize != rowSizeNeeded)\n\t\t{\n\t\t\tif (rowBuf)\n\t\t\t\t_TIFFfree(rowBuf);\n\t\t\trowBuf = (uint8*)_TIFFmalloc(rowSizeNeeded);\n\t\t\trowSize = rowSizeNeeded;\n\t\t}\n\n\t\tTIFFSetField(tiff, TIFFTAG_ROWSPERSTRIP, TIFFDefaultStripSize(tiff, w*bytesPerPixel));\n\t\tfor (int r = 0; r < h; r++)\n\t\t{\n\t\t\tfor (int x = 0; x < w; x++)\n\t\t\t{\n\t\t\t\tint idx = (h-r-1)*w + x;\n\t\t\t\trowBuf[x*bytesPerPixel + 0] = frame->Pixels[idx].R;\n\t\t\t\trowBuf[x*bytesPerPixel + 1] = frame->Pixels[idx].G;\n\t\t\t\trowBuf[x*bytesPerPixel + 2] = frame->Pixels[idx].B;\n\t\t\t\tif (bytesPerPixel == 4)\n\t\t\t\t\trowBuf[x*bytesPerPixel + 3] = frame->Pixels[idx].A;\n\t\t\t}\n\n\t\t\tint errCode = TIFFWriteScanline(tiff, rowBuf, r, 0);\n\t\t\tif (errCode < 0)\n\t\t\t\tcontinue;\n\t\t}\n    }\n\n\tif (rowBuf)\n\t\t_TIFFfree(rowBuf);\n\tTIFFClose(tiff);\n\n\treturn true;\n}",
    "TiffExporter::~TiffExporter() {\n    if (m_image) {\n      TIFFClose(m_image);\n      m_image = NULL;\n    }\n\n    delete [] m_raster;\n    m_raster = NULL;\n  }",
    "BEGIN_POV_NAMESPACE\n\n/*****************************************************************************\n*\n* FUNCTION      : Read_Tiff_Image\n*\n* ARGUMENTS     : IMAGE *Image; char *name;\n*\n* MODIFIED ARGS : Image\n*\n* RETURN VALUE  : none\n*\n* AUTHOR        : Alexander Enzmann\n*\n* DESCRIPTION\n*\n*   Reads a TIFF image into an RGB image buffer\n*\n* CHANGES\n*\n* New - 6/2000\n*\n******************************************************************************/\n\nvoid Read_Tiff_Image(IMAGE *Image, char *name)\n{\n\tunsigned int width, height;\n\tchar *filename = Locate_Filename(name, POV_File_Image_TIFF, 1);\n\t\n    long LineSize;\n    uint16 BitsPerSample, PhotometricInterpretation;\n\tuint16 SamplePerPixel, Orientation;\n\tuint32 RowsPerStrip;\n    int row, nrow, i, j, l;\n    TIFF* tif;\n\tint result = 0;\n\t\n\tif (filename == NULL)\n\t\tError(\"Cannot read TIFF image.\");\n\t\n\t// Rather than have libTIFF complain about tags it doesn't understand,\n\t// we just suppress all the warnings.\n\tTIFFSetWarningHandler(SuppressTIFFWarnings);\n\tTIFFSetErrorHandler(SuppressTIFFWarnings);\n\t\n\t// Open and do initial processing\n\ttif = TIFFClientOpen(filename, \"r\", Tiff_Open(filename),\n\t                     Tiff_Read, Tiff_Write, Tiff_Seek, Tiff_Close,\n\t                     Tiff_Size, Tiff_Map, Tiff_Unmap);\n\tif (!tif)\n\t\treturn;\n\t\n\t// Get basic information about the image\n\tint ExtraSamples, ExtraSampleInfo;\n\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);  \n\tTIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n\tTIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);   \n\tTIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\n\tTIFFGetField(tif, TIFFTAG_ORIENTATION, &Orientation);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_EXTRASAMPLES, &ExtraSamples, &ExtraSampleInfo);\n\t\n\tImage->iwidth = width;\n\tImage->iheight = height;\n\tImage->width = (DBL)width;\n\tImage->height = (DBL)height;\n\t\n    LineSize = TIFFScanlineSize(tif);\n\tassert(SamplePerPixel == (int)(LineSize / width));\n    // SamplePerPixel = (int)(LineSize / width);\n\t\n#if 0\n\t// For now we are ignoring the orientation of the image...\n\tswitch (Orientation)\n\t{\n\t\tcase ORIENTATION_TOPLEFT:\n\t\t\tbreak;\n\t\tcase ORIENTATION_TOPRIGHT:\n\t\t\tbreak;\n\t\tcase ORIENTATION_BOTRIGHT:\n\t\t\tbreak;\n\t\tcase ORIENTATION_BOTLEFT:\n\t\t\tbreak;\n\t\tcase ORIENTATION_LEFTTOP:\n\t\t\tbreak;\n\t\tcase ORIENTATION_RIGHTTOP:\n\t\t\tbreak;\n\t\tcase ORIENTATION_RIGHTBOT:\n\t\t\tbreak;\n\t\tcase ORIENTATION_LEFTBOT:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n#endif\n\t\n\t//PhotometricInterpretation = 2 image is RGB\n\t//PhotometricInterpretation = 3 image have a color palette              \n\tif (PhotometricInterpretation == PHOTOMETRIC_PALETTE)\n\t{\n\t\tuint16 *red, *green, *blue;\n\t\tint16 i;\n\t\tint Palette16Bits;\n\t\tIMAGE_COLOUR *cmap;\n\n\t\t//load the palette\n\t\tImage->data.rgb8_lines = NULL;\n\t\tint cmap_len = (1 << BitsPerSample);\n\t\tImage->Colour_Map_Size = cmap_len;\n\n\t\tcmap = (IMAGE_COLOUR *)POV_MALLOC(cmap_len*sizeof(IMAGE_COLOUR), \"TIFF image color map\");\n\t\tImage->Colour_Map = cmap;\n\n\t\tTIFFGetField(tif, TIFFTAG_COLORMAP, &red, &green, &blue); \n\n\t\t// Is the palette 16 or 8 bits ?\n\t\tif (checkcmap(cmap_len, red, green, blue) == 16) \n\t\t\tPalette16Bits = true;\n\t\telse\n\t\t\tPalette16Bits = false;\n\n\t\t// Read the palette\n\t\tfor (i=0,j=0;i<cmap_len;i++)\n\t\t{\n\t\t\tif (Palette16Bits)\n\t\t\t{\n\t\t\t\tcmap[i].Red   = CVT(red[i]);\n\t\t\t\tcmap[i].Green = CVT(green[i]);\n\t\t\t\tcmap[i].Blue  = CVT(blue[i]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcmap[i].Red   = red[i];\n\t\t\t\tcmap[i].Green = green[i];\n\t\t\t\tcmap[i].Blue  = blue[i];\n\t\t\t}\n\t\t\t// I may be mistaken, but it appears that alpha/opacity information doesn't\n\t\t\t// appear in a Paletted Tiff image.  Well - if it does, it's not as easy to\n\t\t\t// get at as RGB.\n\t\t\tcmap[i].Filter   = 0;\n\t\t\tcmap[i].Transmit = 0;\n\t\t}\n\n\t\tImage->data.map_lines = (unsigned char **)POV_MALLOC(height * sizeof(unsigned char *), \"TIFF image\");\n\t\tunsigned char *buf = (unsigned char *)POV_MALLOC(sizeof(unsigned char) * TIFFStripSize(tif), \"TIFF row\");\n\n\t\t//read the tiff lines and save them in the image\n\t\t//with RGB mode, we have to change the order of the 3 samples RGB <=> BGR\n\t\tfor (row=0;row<height;row+=RowsPerStrip)\n\t\t{     \n\t\t\tnrow = (row + (int)RowsPerStrip > height ? height - row : RowsPerStrip);\n\t\t\tTIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, row, 0), buf, nrow * LineSize);\n\t\t\tfor (l=0;l<nrow;l++)\n\t\t\t{\n\t\t\t\tImage->data.map_lines[row+l] = (unsigned char *)POV_MALLOC(width, \"TIFF Image line\");\n\t\t\t\tPOV_MEMCPY(Image->data.map_lines[row+l], &buf[l*LineSize], (int)width); \n\t\t\t}\n\t\t}\n\n\t\tPOV_FREE(buf);\n\t}\n\telse\n\t{\n\t\t// Allocate the row buffers for the image\n\t\tImage->Colour_Map_Size = 0;\n\t\tImage->Colour_Map = NULL;\n\t\tImage->data.rgb8_lines = (IMAGE8_LINE *)POV_MALLOC(height * sizeof(IMAGE8_LINE), \"TIFF image\");\n\t\tuint32 *buf = (uint32 *)POV_MALLOC(sizeof(uint32) * width * height, \"TIIF image data\");\n\n\t\tTIFFReadRGBAImage(tif, width, height, buf, 0);\n\t\tuint32 abgr, *tbuf = buf;\n\t\tfor (i=height-1;i>=0;i--)\n\t\t{\n\t\t\tImage->data.rgb8_lines[i].blue   = (unsigned char *)POV_MALLOC(width, \"TIFF Image line\");\n\t\t\tImage->data.rgb8_lines[i].green  = (unsigned char *)POV_MALLOC(width, \"TIFF Image line\");\n\t\t\tImage->data.rgb8_lines[i].red    = (unsigned char *)POV_MALLOC(width, \"TIFF Image line\");\n\t\t\tImage->data.rgb8_lines[i].transm = (unsigned char *)POV_MALLOC(width, \"TIFF Image line\");\n\t\t\tfor (j=0,l=0;j<width;j++)\n\t\t\t{\n\t\t\t\tabgr = *tbuf++;\n\t\t\t\tImage->data.rgb8_lines[i].blue[j]   = (unsigned char)TIFFGetB(abgr);\n\t\t\t\tImage->data.rgb8_lines[i].green[j]  = (unsigned char)TIFFGetG(abgr);\n\t\t\t\tImage->data.rgb8_lines[i].red[j]    = (unsigned char)TIFFGetR(abgr);\n\t\t\t\tImage->data.rgb8_lines[i].transm[j] = 255 - (unsigned char)TIFFGetA(abgr);\n\t\t\t}\n\t\t}\n        POV_FREE(buf);\n\t}\n\t\n\tTIFFClose(tif);\n}",
    "bool height_tif::load(ll_t lat, ll_t lon)\n{\n\tauto lat_dec = lat_start(lat);\n\tauto lon_dec = lon_start(lon);\n\n#if USE_TIFF\n\n\t// COMPLETELY WRONG!!!\n\n\t//DUMP(lat_dec, lon_dec);\n\tif (ok(lat, lon)) {\n\t\treturn true;\n\t}\n\tconst auto lock = std::unique_lock(mutex);\n\n\tif (lat >= 90 || lat <= -90 || lon >= 180 || lon <= -180)\n\t\treturn false;\n\n\t//DUMP(lat_dec, lon_dec);\n\tif (ok(lat, lon)) {\n\t\treturn true;\n\t}\n\n\tif (lat_loading == lat_dec && lon_loading == lon_dec) {\n\t\t//DUMP(lat_dec, lon_dec);\n\t\treturn false;\n\t}\n\tDUMP((long long)this, lat_dec, lon_dec, lat_loading, lon_loading, lat_loaded,\n\t\t\tlon_loaded);\n\tTimeTaker timer(\"hgt load\");\n\n\tlat_loading = lat_dec;\n\tlon_loading = lon_dec;\n\n\t//if (srtmTile.empty())\n\t{\n\t\tconst auto zipname = gen_zip_name_15(lat_dec, lon_dec);\n\t\t//zipname = \"15-J\";\n\t\t//zipname = \"15-O\";\n\t\tconst auto zipfile = zipname + \".zip\";\n\t\tconst auto zipfull = folder + \"/\" + zipname;\n\t\tconst auto tifname = folder + \"/\" + zipname + \".tif\";\n\t\tDUMP(zipname, zipfile, tifname);\n\t\tif (!std::filesystem::exists(tifname)) {\n\t\t\tmulti_http_to_file(zipfile,\n\t\t\t\t\t{\"http://cdn.freeminer.org/earth/\" + zipfile,\n\t\t\t\t\t\t\t\"http://www.viewfinderpanoramas.org/DEM/TIF15/\" + zipfile},\n\t\t\t\t\tzipfull);\n\t\t}\n\n\t\tif (!std::filesystem::exists(tifname) && std::filesystem::exists(zipfull) &&\n\t\t\t\tstd::filesystem::file_size(zipfull)) {\n\t\t\tconst auto cmd = \"unzip \" + zipfull + \" -d \" + folder;\n\t\t\texec_to_string(cmd); // TODO just exec\n\t\t}\n\n\t\tif (std::filesystem::exists(tifname)) {\n\t\t\tif (auto tif = TIFFOpen(tifname.c_str(), \"r\"); tif) {\n\t\t\t\tuint32_t w = 0, h = 0;\n\n\t\t\t\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w);\n\t\t\t\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\n\t\t\t\tsize_t npixels = w * h;\n\t\t\t\tif (!npixels)\n\t\t\t\t\treturn false;\n\n\t\t\t\tif (auto raster = (uint32_t *)_TIFFmalloc(npixels * sizeof(uint32_t));\n\t\t\t\t\t\traster) {\n\t\t\t\t\tif (TIFFReadRGBAImage(tif, w, h, raster, 0)) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\tDUMP(raster[0]);\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tuint8_t *bytes = (uint8_t *)&raster[0];\n\t\t\t\t\t\t\tDUMP(bytes[0], bytes[2], bytes[3], bytes[4]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t*/\n\t\t\t\t\t\theights.resize(npixels);\n\n\t\t\t\t\t\tfor (size_t i = 0; i < npixels; ++i) {\n\t\t\t\t\t\t\tuint8_t *bytes = (uint8_t *)&raster[i];\n\n\t\t\t\t\t\t\tconst auto gray =\n\t\t\t\t\t\t\t\t\tfloor(((bytes[0] * 0.299) + (bytes[1] * 0.587) +\n\t\t\t\t\t\t\t\t\t\t\t(bytes[3] * 0.144) + 0.5)) -\n\t\t\t\t\t\t\t\t\t37; // Wrong?\n\t\t\t\t\t\t\tif (!(i % 100000))\n\t\t\t\t\t\t\t\tDUMP(i, raster[i], bytes[0], bytes[2], bytes[3], bytes[4],\n\t\t\t\t\t\t\t\t\t\tgray);\n\t\t\t\t\t\t\theights[i] = gray;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlat_loaded = lat_dec;\n\t\t\t\t\t\tlon_loaded = lon_dec;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tDUMP(\"read fail\");\n\t\t\t\t\t}\n\t\t\t\t\t_TIFFfree(raster);\n\t\t\t\t} else {\n\t\t\t\t\tDUMP(\"malloc fail\");\n\t\t\t\t}\n\t\t\t\tTIFFClose(tif);\n\n\t\t\t\t//DUMP(w, h, npixels);\n\n\t\t\t\tif (lat_loaded == lat_dec && lon_loaded == lon_dec) {\n\t\t\t\t\tseconds_per_px_y = seconds_per_px_x = 15;\n\t\t\t\t\tside_length_x = w;\n\t\t\t\t\tside_length_y = h;\n\t\t\t\t\tDUMP(\"tif ok\", seconds_per_px_x, side_length_x, side_length_y);\n\n\t\t\t\t\tlat_loaded = lat_dec;\n\t\t\t\t\tlon_loaded = lon_dec;\n\n\t\t\t\t\tpixel_per_deg_x = (ll_t)side_length_x / tile_deg_x;\n\t\t\t\t\tpixel_per_deg_y = (ll_t)side_length_y / tile_deg_y;\n\n\t\t\t\t\tDUMP(\"loadok\", (long long)this, heights.size(), lat_loaded,\n\t\t\t\t\t\t\tlon_loaded, zipname, tifname, seconds_per_px_x,\n\t\t\t\t\t\t\tget(lat_dec, lon_dec));\n\t\t\t\t\tDUMP(\"ppd\", pixel_per_deg_x, pixel_per_deg_y);\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n#endif\n\n\t//lat_loaded = lat_dec;\n\t//lon_loaded = lon_dec;\n\t// DUMP(\"loadok\", (long)this, heights.size(), lat_loaded, lon_loaded, filesize, zipname, filename, seconds_per_px, get(lat_dec, lon_dec));\n\treturn false;\n}",
    "bool height_gebco_tif::load(ll_t lat, ll_t lon)\n{\n\tconst auto lat_dec = lat90_start(lat);\n\tconst auto lon_dec = lon90_start(lon);\n#if TEST\n\tstatic int once = 0;\n\tif (!once++)\n\t\tfor (const auto &t : std::vector<std::tuple<int, int, std::string>>{\n\t\t\t\t\t {0, 0, \"n90.0_s0.0_w0.0_e90.0\"}, {1, 1, \"n90.0_s0.0_w0.0_e90.0\"},\n\t\t\t\t\t {-1, 1, \"n0.0_s-90.0_w0.0_e90.0\"}, {1, -1, \"n90.0_s0.0_w-90.0_e0.0\"},\n\t\t\t\t\t {-1, -1, \"n0.0_s-90.0_w-90.0_e0.0\"},\n\t\t\t\t\t {1, 100, \"n90.0_s0.0_w90.0_e180.0\"},\n\t\t\t\t\t {-1, -100, \"n0.0_s-90.0_w-180.0_e-90.0\"}, {-300, 0, \"\"},\n\t\t\t\t\t {0, 300, \"\"}}) {\n\t\t\tconst auto fn = folder + \"/\" + \"gebco_2023_sub_ice_\" +\n\t\t\t\t\t\t\tfile_name(get<0>(t), get<1>(t)) + \".tif\";\n\t\t\tDUMP(\"testname\", get<0>(t), get<1>(t), file_name(get<0>(t), get<1>(t)),\n\t\t\t\t\tget<2>(t), std::filesystem::exists(fn));\n\t\t\tif (!get<2>(t).empty() && get<2>(t) != file_name(get<0>(t), get<1>(t))) {\n\t\t\t\tDUMP(\"testfail\");\n\t\t\t\t//exit(1);\n\t\t\t}\n\t\t}\n#endif\n\n#if USE_TIFF\n\n\t//DUMP(lat_dec, lon_dec);\n\tif (ok(lat, lon)) {\n\t\treturn true;\n\t}\n\tconst auto lock = std::unique_lock(mutex);\n\t//DUMP(lat_dec, lon_dec);\n\tif (ok(lat, lon)) {\n\t\treturn true;\n\t}\n\tif (lat_loading == lat_dec && lon_loading == lon_dec) {\n\t\t//DUMP(lat_dec, lon_dec);\n\t\treturn false;\n\t}\n\t//DUMP(\"loadstart\", (long long)this, lat, lon, lat_dec, lon_dec, lat_loading, lon_loading, lat_loaded, lon_loaded, floor(lat / 90.0 + 1) * 90);\n\tTimeTaker timer(\"tiff load\");\n\n\tlat_loading = lat_dec;\n\tlon_loading = lon_dec;\n\n\t{\n\t\tconst auto name = file_name(lat, lon);\n\t\tauto tifname = folder + \"/\" + \"gebco_2023_sub_ice_\" + name + \".tif\";\n\t\t//DUMP(name, tifname);\n\t\tif (0) // too big zips\n\t\t{\n\t\t\tstd::string zipfile = \"gebco_2023_sub_ice_topo_geotiff.zip\";\n\t\t\tstd::string zipfull = folder + \"/\" + zipfile;\n\t\t\tif (!std::filesystem::exists(tifname)) {\n\t\t\t\tif (multi_http_to_file(zipfile,\n\t\t\t\t\t\t\t{\"https://www.bodc.ac.uk/data/open_download/gebco/gebco_2023_sub_ice_topo/geotiff/\"},\n\t\t\t\t\t\t\tzipfull)) {\n\t\t\t\t\texec_to_string(\n\t\t\t\t\t\t\t\"unzip \" + zipfull + \" -d \" + folder); // TODO just exec\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!std::filesystem::exists(tifname) && !std::filesystem::exists(zipfull)) {\n\t\t\t\tzipfile = \"gebco_2023_geotiff.zip\";\n\t\t\t\tzipfull = folder + \"/\" + zipfile;\n\t\t\t\ttifname = folder + \"/\" + \"gebco_2023_\" + name + \".tif\";\n\t\t\t\tif (multi_http_to_file(zipfile,\n\t\t\t\t\t\t\t{\"https://www.bodc.ac.uk/data/open_download/gebco/gebco_2023_tid/geotiff/\"},\n\t\t\t\t\t\t\tzipfull)) {\n\t\t\t\t\texec_to_string(\n\t\t\t\t\t\t\t\"unzip \" + zipfull + \" -d \" + folder); // TODO just exec\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tstd::cerr\n\t\t\t\t\t<< \"Want \" << tifname << \" from \"\n\t\t\t\t\t<< \"https://www.bodc.ac.uk/data/open_download/gebco/gebco_2023_sub_ice_topo/geotiff/\"\n\t\t\t\t\t<< \" or \"\n\t\t\t\t\t<< \"https://www.bodc.ac.uk/data/open_download/gebco/gebco_2023_tid/geotiff/\"\n\t\t\t\t\t<< \" in \" << porting::path_cache + DIR_DELIM + \"earth\" << \"\\n\";\n\t\t}\n\n\t\t//DUMP(tifname, std::filesystem::exists(tifname));\n\n\t\tif (!std::filesystem::exists(tifname)) {\n\t\t\ttifname = folder + \"/\" + \"gebco_2023_\" + name + \".tif\";\n\t\t}\n\t\t//DUMP(\"loadtifname\", tifname, std::filesystem::exists(tifname));\n\t\tif (std::filesystem::exists(tifname)) {\n\t\t\tDUMP(\"open tif\", tifname, std::filesystem::file_size(tifname));\n\t\t\tif (const auto tif = TIFFOpen(tifname.c_str(), \"r\"); tif) {\n\t\t\t\tuint32_t w = 0;\n\t\t\t\tuint32_t h = 0;\n\t\t\t\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w);\n\t\t\t\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\n\t\t\t\tif (!w || !h) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tconst size_t npixels = (w + 1) * (h + 1);\n\t\t\t\t//DUMP(\"tiff size\", w, h, npixels);\n\t\t\t\theights.resize(npixels);\n\n\t\t\t\t//w = TIFFScanlineSize(tif) >> 1;\n\t\t\t\tconst tdata_t buf = _TIFFmalloc(TIFFScanlineSize(tif));\n\t\t\t\tfor (uint32_t row = 0; row < h; ++row) {\n\t\t\t\t\tTIFFReadScanline(tif, buf, row, 0);\n\n#if HGT_DEBUG\n\t\t\t\t\tif (!(row % 10000))\n\t\t\t\t\t\tDUMP(row, TIFFNumberOfStrips(tif), TIFFStripSize(tif),\n\t\t\t\t\t\t\t\t((uint8_t *)buf)[0], ((uint8_t *)buf)[2],\n\t\t\t\t\t\t\t\t((uint8_t *)buf)[3], ((uint8_t *)buf)[4]);\n#endif\n\n\t\t\t\t\tint16_t height;\n\t\t\t\t\tfor (uint32_t i = 0; i < w; ++i) {\n\t\t\t\t\t\theight = (((uint8_t *)buf)[i << 1]) |\n\t\t\t\t\t\t\t\t (((uint8_t *)buf)[(i << 1) + 1] << 8);\n\t\t\t\t\t\tif (height == -32768 || height == 31727) {\n\t\t\t\t\t\t\theight = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst auto dest = i + row * (w + 1);\n#if HGT_DEBUG\n\t\t\t\t\t\tif (!(i % 10000) && !(row % 10000))\n\t\t\t\t\t\t\tDUMP(\"fill\", i, w, h, row, dest, height, //height2,\n\t\t\t\t\t\t\t\t\t((uint8_t *)buf)[(i << 1)],\n\t\t\t\t\t\t\t\t\t((uint8_t *)buf)[(i << 1) + 1],\n\t\t\t\t\t\t\t\t\t((uint8_t *)buf)[(i << 1) + 2],\n\t\t\t\t\t\t\t\t\t((uint8_t *)buf)[(i << 1) + 3]);\n#endif\n\n\t\t\t\t\t\theights[dest] = height;\n\t\t\t\t\t}\n\t\t\t\t\tconst auto dest = w + row * (w + 1);\n\t\t\t\t\theights[dest] = height; // hack for  interpolation x+1 get\n\t\t\t\t\t\t\t\t\t\t\t//DUMP(\"xhck\", w, dest, height);\n\t\t\t\t}\n\n\t\t\t\t// hack for interpolation y+1 get\n\t\t\t\tfor (uint32_t i = 0; i <= w; ++i) {\n\t\t\t\t\tconst auto src = i + (h - 1) * (w + 1);\n\t\t\t\t\tconst auto dest = i + h * (w + 1);\n\t\t\t\t\t//DUMP(\"yhck\", i, src, dest, heights[src]);\n\t\t\t\t\theights[dest] = heights[src];\n\t\t\t\t}\n\n\t\t\t\t_TIFFfree(buf);\n\t\t\t\tTIFFClose(tif);\n\n\t\t\t\tlat_loaded = lat_dec;\n\t\t\t\tlon_loaded = lon_dec;\n\n\t\t\t\tside_length_x = w;\n\t\t\t\tside_length_y = h;\n\n\t\t\t\tseconds_per_px_x =\n\t\t\t\t\t\ttile_deg_x * 3600 / ((float)side_length_x - side_length_x_extra);\n\t\t\t\tseconds_per_px_y = tile_deg_y * 3600 / ((float)side_length_y);\n\n\t\t\t\tpixel_per_deg_x = (ll_t)side_length_x / tile_deg_x;\n\t\t\t\tpixel_per_deg_y = (ll_t)side_length_y / tile_deg_y;\n\n#if HGT_DEBUG\n\t\t\t\tDUMP(\"tif ok\", seconds_per_px_x, side_length_x, side_length_y,\n\t\t\t\t\t\tseconds_per_px_x, seconds_per_px_y);\n\t\t\t\tDUMP(\"loadok\", (long)this, heights.size(), lat_loaded, lon_loaded,\n\t\t\t\t\t\ttifname, seconds_per_px_x, get(lat_dec, lon_dec));\n\t\t\t\tDUMP(\"testread\", read(0, 0), read(0, side_length_x - 1),\n\t\t\t\t\t\tread(side_length_y - 1, side_length_x - 1),\n\t\t\t\t\t\tread(side_length_y - 1, 0));\n#endif\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n#endif\n\n\t// DUMP(\"load not ok\", (long long)this, heights.size(), lat_loaded, lon_loaded, seconds_per_px_x, get(lat_dec, lon_dec));\n\treturn false;\n}",
    "int slTerrain::loadGeoTIFF( char *file ) {\n#if HAVE_LIBTIFF\n\tTIFF* tif;\n\tfloat *row;\n\tint height, width, x, y;\n\tunsigned short depth, samples;\n\n\tif ( !( tif = TIFFOpen( file, \"r\" ) ) )\n\t\treturn -1;\n\n\tTIFFGetField( tif, TIFFTAG_IMAGEWIDTH, &width );\n\n\tTIFFGetField( tif, TIFFTAG_IMAGELENGTH, &height );\n\n\tTIFFGetField( tif, TIFFTAG_BITSPERSAMPLE, &depth );\n\n\tTIFFGetField( tif, TIFFTAG_SAMPLESPERPIXEL, &samples );\n\n\tprintf( \"Loading GeoTIFF data (%d x %d) x %d x %d\\n\", height, width, depth, samples );\n\n\tif ( height < width ) resize( height );\n\telse resize( width );\n\n\trow = new float[width];\n\n\tif ( width > _side ) width = _side;\n\n\tif ( height > _side ) height = _side;\n\n\tfor ( y = 0; y < height; y++ ) {\n\t\tTIFFReadScanline( tif, row, y, 0 );\n\n\t\tfor ( x = 0; x < width; x++ ) {\n\t\t\t_matrix[x][y] = 3 * row[x * samples];\n\n\t\t\tif ( _matrix[x][y] < 90 ) _matrix[x][y] = 10;\n\t\t}\n\t}\n\n\tdelete row;\n\n\tinitialize();\n\n\tTIFFClose( tif );\n\n\t_roam->computeVariance();\n#endif\n\treturn 0;\n}",
    "int imageIO::getTiffCount(){\n  int cnt = 0;\n  TIFF * image;\n\n  image = TIFFOpen(filename.c_str(), \"r\");\n\n  if (image != NULL) {\n    do {\n      ++cnt;\n    }while (TIFFReadDirectory(image));\n  }else{\n    cnt = -1;\n  }\n  \n  (void) TIFFClose(image);\n\n  return cnt;\n}",
    "void imageIO::writeImage(const float * steady_state, uint max_visits, pixel center) {\n  //const uint Z_AREA = 1;\n  const double block_size = (2 * AREA + 1) * (2 * AREA + 1);// * (Z_AREA * Z_AREA + 1);\n\n  uint i, j;\n  float block_mean = 0.0;\n  float min_val    = 1.0 / max_visits;\n\n  // Do thresholding\n  if (OPT_THRESHOLD){\n\n    // find the block of pixels aroung the center that we will use for thresholding\n    for (i = (center.x - AREA); i <= (center.x + AREA); ++i) {\n      for (j = (center.y - AREA); j <= (center.y + AREA); ++j) {\n\t//for (k = (center.z - Z_AREA); k <= (center.z + Z_AREA); ++k) {\n\t  pixel cur = {i, j, center.z};\n\t  block_mean += steady_state[OFFSET(img, cur)];\n\t  //}\n      }      \n    }\n    \n    block_mean /= block_size;\n\n    if (fout.is_open()){\n      fout << \"Cell body size        : \" << block_size << endl \n\t   << \"Mean cell body value  : \" << block_mean << endl\n\t   << \"Min threshold         : \" << min_val << endl << endl;\n    }\n      \n    if (OPT_DEBUG > 0){\n      cout << \"Cell body size      : \" << block_size << endl \n\t   << \"Mean cell body value: \" << block_mean << endl\n\t   << \"Min threshold       : \" << min_val << endl;\n    }\n\n    block_mean -= min_val;\n  }else{\n    block_mean = 1.0;\n    min_val    = 0.0;\n  }\n\n  /*\n   * ************** WRITE MULTI-PLANAR TIFF FILE **************\n   */ \n  string outfile = OPT_IMAGEOUT + \"stack.tif\";\n  TIFF * image;\n  uint rowsperstrip, page;\n  double norm;\n  char page_number[20], z_depth[40];\n\n  uchar * row = (uchar *) malloc(img.width * sizeof(uchar));\n  \n  // Open the TIFF file\n  if((image = TIFFOpen(outfile.c_str(), \"w\")) == NULL){\n    cerr << \"Could not open \" << outfile << \" for writing\\n\";\n  }\n  \n  // Loop through each plane of the image\n  for (page = 0; page < img.depth; ++page){\n      TIFFSetField(image, TIFFTAG_IMAGEWIDTH, img.width);\n      TIFFSetField(image, TIFFTAG_IMAGELENGTH, img.height);\n      TIFFSetField(image, TIFFTAG_IMAGEDEPTH, img.depth);      \n      TIFFSetField(image, TIFFTAG_BITSPERSAMPLE, 8);\n      TIFFSetField(image, TIFFTAG_SAMPLESPERPIXEL, 1);\n      \n      rowsperstrip = TIFFDefaultStripSize(image, -1);\n      \n      TIFFSetField(image, TIFFTAG_ROWSPERSTRIP, rowsperstrip);\n      TIFFSetField(image, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n      TIFFSetField(image, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n      \n      TIFFSetField(image, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);\n      TIFFSetField(image, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\n      // set the resolution, we multiply by 10,000 to convert from\n      // microns (10^-6) to centimerters (10^-2)\n      TIFFSetField(image, TIFFTAG_RESOLUTIONUNIT, RESUNIT_CENTIMETER);\n      sprintf(z_depth, \"z_resolution: %f\", (img.z_dist * 10000));\n      TIFFSetField(image, TIFFTAG_XRESOLUTION, (img.xy_dist * 10000));\n      TIFFSetField(image, TIFFTAG_YRESOLUTION, (img.xy_dist * 10000));\n      // not sure where else to put the z_resolution data????\n      TIFFSetField(image, TIFFTAG_ARTIST, z_depth);\n\n      sprintf(page_number, \"Page %d\", page + 1);\n      TIFFSetField(image, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE);\n      TIFFSetField(image, TIFFTAG_PAGENUMBER, page + 1, page + 1);\n      TIFFSetField(image, TIFFTAG_PAGENAME, page_number);\n   \n\n      for (i = 0; i < img.height; ++i){\n\t\n\t// compute pixel values\n\tfor (j = 0; j < img.width; ++j) {\n\t  norm = (fabs(steady_state[(page * img.height * img.width) + \n\t\t\t\t    (img.width * i) + j] - min_val) / block_mean);\n\t  row[j] = (uchar)(min(1.0, norm) * 255);\n\t}\n\t\n\t// write a single row of the image\n\tif (TIFFWriteScanline(image, row, i, 0) == -1){ \n\t  printf(\"Error!!\\n\");\n\t}\n      }\n\n      // write one plane of the image\n      if (img.depth > 1){\n\tTIFFWriteDirectory(image);\n      }\n  }\n  \n  free(row);\n  TIFFClose(image);\n}",
    "RGBImage readTIFFImage(const char* imageName,IO::File& source)\n\t{\n\t/* Check if the source file is seekable: */\n\tIO::SeekableFilePtr seekableSource(&source);\n\tif(seekableSource==0)\n\t\t{\n\t\t/* Create a seekable filter for the source file: */\n\t\tseekableSource=new IO::SeekableFilter(&source);\n\t\t}\n\t\n\t/* Set the TIFF error handler: */\n\tTIFFSetErrorHandler(tiffErrorFunction);\n\tTIFFSetWarningHandler(tiffWarningFunction);\n\t\n\tTIFF* tiff=0;\n\tRGBImage result;\n\tuint32* rgbaBuffer=0;\n\ttry\n\t\t{\n\t\t/* Pretend to open the TIFF file and register the hook functions: */\n\t\ttiff=TIFFClientOpen(imageName,\"rm\",seekableSource.getPointer(),tiffReadFunction,tiffWriteFunction,tiffSeekFunction,tiffCloseFunction,tiffSizeFunction,tiffMapFileFunction,tiffUnmapFileFunction);\n\t\tif(tiff==0)\n\t\t\tthrow std::runtime_error(\"Error while opening image\");\n\t\t\n\t\t/* Get the image size: */\n\t\tuint32 width,height;\n\t\tTIFFGetField(tiff,TIFFTAG_IMAGEWIDTH,&width);\n\t\tTIFFGetField(tiff,TIFFTAG_IMAGELENGTH,&height);\n\t\t\n\t\t/* Create the result image: */\n\t\tresult=RGBImage(width,height);\n\t\t\n\t\t/* Allocate a temporary RGBA buffer: */\n\t\trgbaBuffer=new uint32[height*width];\n\t\t\n\t\t/* Read the TIFF image into the temporary buffer: */\n\t\tif(!TIFFReadRGBAImage(tiff,width,height,rgbaBuffer))\n\t\t\tthrow std::runtime_error(\"Error while reading image\");\n\t\t\n\t\t/* Copy the RGB image data into the result image: */\n\t\tuint32* sPtr=rgbaBuffer;\n\t\tRGBImage::Color* dPtr=result.modifyPixels();\n\t\tfor(uint32 y=0;y<height;++y)\n\t\t\tfor(uint32 x=0;x<width;++x,++sPtr,++dPtr)\n\t\t\t\t{\n\t\t\t\t(*dPtr)[0]=RGBImage::Scalar(TIFFGetR(*sPtr));\n\t\t\t\t(*dPtr)[1]=RGBImage::Scalar(TIFFGetG(*sPtr));\n\t\t\t\t(*dPtr)[2]=RGBImage::Scalar(TIFFGetB(*sPtr));\n\t\t\t\t}\n\t\t}\n\tcatch(std::runtime_error err)\n\t\t{\n\t\t/* Clean up: */\n\t\tdelete[] rgbaBuffer;\n\t\tif(tiff!=0)\n\t\t\tTIFFClose(tiff);\n\t\t\n\t\t/* Wrap and re-throw the exception: */\n\t\tMisc::throwStdErr(\"Images::readTIFFImage: Caught exception \\\"%s\\\" while reading image \\\"%s\\\"\",err.what(),imageName);\n\t\t}\n\t\n\t/* Clean up and return the result image: */\n\tdelete[] rgbaBuffer;\n\tif(tiff!=0)\n\t\tTIFFClose(tiff);\n\treturn result;\n\t}",
    "RGBAImage readTransparentTIFFImage(const char* imageName,IO::File& source)\n\t{\n\t/* Check if the source file is seekable: */\n\tIO::SeekableFilePtr seekableSource(&source);\n\tif(seekableSource==0)\n\t\t{\n\t\t/* Create a seekable filter for the source file: */\n\t\tseekableSource=new IO::SeekableFilter(&source);\n\t\t}\n\t\n\t/* Set the TIFF error handler: */\n\tTIFFSetErrorHandler(tiffErrorFunction);\n\t\n\tTIFF* tiff=0;\n\tRGBAImage result;\n\tuint32* rgbaBuffer=0;\n\ttry\n\t\t{\n\t\t/* Pretend to open the TIFF file and register the hook functions: */\n\t\ttiff=TIFFClientOpen(imageName,\"rm\",seekableSource.getPointer(),tiffReadFunction,tiffWriteFunction,tiffSeekFunction,tiffCloseFunction,tiffSizeFunction,tiffMapFileFunction,tiffUnmapFileFunction);\n\t\tif(tiff==0)\n\t\t\tthrow std::runtime_error(\"Error while opening image\");\n\t\t\n\t\t/* Get the image size: */\n\t\tuint32 width,height;\n\t\tTIFFGetField(tiff,TIFFTAG_IMAGEWIDTH,&width);\n\t\tTIFFGetField(tiff,TIFFTAG_IMAGELENGTH,&height);\n\t\t\n\t\t/* Create the result image: */\n\t\tresult=RGBAImage(width,height);\n\t\t\n\t\t/* Allocate a temporary RGBA buffer: */\n\t\trgbaBuffer=new uint32[height*width];\n\t\t\n\t\t/* Read the TIFF image into the temporary buffer: */\n\t\tif(!TIFFReadRGBAImage(tiff,width,height,rgbaBuffer))\n\t\t\tthrow std::runtime_error(\"Error while reading image\");\n\t\t\n\t\t/* Copy the RGBA image data into the result image: */\n\t\tuint32* sPtr=rgbaBuffer;\n\t\tRGBAImage::Color* dPtr=result.modifyPixels();\n\t\tfor(uint32 y=0;y<height;++y)\n\t\t\tfor(uint32 x=0;x<width;++x,++sPtr,++dPtr)\n\t\t\t\t{\n\t\t\t\t(*dPtr)[0]=RGBImage::Scalar(TIFFGetR(*sPtr));\n\t\t\t\t(*dPtr)[1]=RGBImage::Scalar(TIFFGetG(*sPtr));\n\t\t\t\t(*dPtr)[2]=RGBImage::Scalar(TIFFGetB(*sPtr));\n\t\t\t\t(*dPtr)[3]=RGBAImage::Scalar(TIFFGetA(*sPtr));\n\t\t\t\t}\n\t\t}\n\tcatch(std::runtime_error err)\n\t\t{\n\t\t/* Clean up: */\n\t\tdelete[] rgbaBuffer;\n\t\tif(tiff!=0)\n\t\t\tTIFFClose(tiff);\n\t\t\n\t\t/* Wrap and re-throw the exception: */\n\t\tMisc::throwStdErr(\"Images::readTransparentTIFFImage: Caught exception \\\"%s\\\" while reading image \\\"%s\\\"\",err.what(),imageName);\n\t\t}\n\t\n\t/* Clean up and return the result image: */\n\tdelete[] rgbaBuffer;\n\tif(tiff!=0)\n\t\tTIFFClose(tiff);\n\treturn result;\n\t}",
    "void writeTiffFile(unsigned int width,unsigned int height,const unsigned char* image,const char* imageFileName)\n\t{\n\t/* Set the TIFF error handler: */\n\tTIFFSetErrorHandler(tiffErrorFunction);\n\tTIFFSetWarningHandler(tiffWarningFunction);\n\t\n\tTIFF* tiff=0;\n\ttry\n\t\t{\n\t\t/* Open the TIFF file: */\n\t\ttiff=TIFFOpen(imageFileName,\"w\");\n\t\tif(tiff==0)\n\t\t\tthrow std::runtime_error(\"Error while opening image file\");\n\t\t\n\t\t/* Write the TIFF image layout tags: */\n\t\tTIFFSetField(tiff,TIFFTAG_IMAGEWIDTH,width);\n\t\tTIFFSetField(tiff,TIFFTAG_IMAGELENGTH,height);\n\t\tTIFFSetField(tiff,TIFFTAG_BITSPERSAMPLE,8);\n\t\tTIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,3);\n\t\tTIFFSetField(tiff,TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG);\n\t\tTIFFSetField(tiff,TIFFTAG_COMPRESSION,COMPRESSION_NONE);\n\t\tTIFFSetField(tiff,TIFFTAG_PHOTOMETRIC,PHOTOMETRIC_RGB);\n\t\tTIFFSetField(tiff,TIFFTAG_ROWSPERSTRIP,TIFFDefaultStripSize(tiff,width*3));\n\t\t\n\t\t/* Write the image data to the TIFF file one scan line at a time, top-to-bottom: */\n\t\tfor(unsigned int row=height;row>0;--row)\n\t\t\tif(TIFFWriteScanline(tiff,reinterpret_cast<tdata_t>(const_cast<unsigned char*>(image+(row-1)*width*3)),height-row)<0)\n\t\t\t\tthrow std::runtime_error(\"Error while writing image\");\n\t\t\n\t\t/* Close the TIFF file: */\n\t\tTIFFClose(tiff);\n\t\t}\n\tcatch(std::runtime_error err)\n\t\t{\n\t\t/* Clean up: */\n\t\tif(tiff!=0)\n\t\t\tTIFFClose(tiff);\n\t\t\n\t\t/* Wrap and re-throw the exception: */\n\t\tMisc::throwStdErr(\"Images::writeTiffFile: Caught exception \\\"%s\\\" while writing image \\\"%s\\\"\",err.what(),imageFileName);\n\t\t}\n\t}",
    "bool TiffEncoder::writeLibTiff( const std::vector<Mat>& img_vec, const std::vector<int>& params)\n{\n    // do NOT put \"wb\" as the mode, because the b means \"big endian\" mode, not \"binary\" mode.\n    // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n    TIFF* pTiffHandle;\n\n    TiffEncoderBufHelper buf_helper(m_buf);\n    if ( m_buf )\n    {\n        pTiffHandle = buf_helper.open();\n    }\n    else\n    {\n        pTiffHandle = TIFFOpen(m_filename.c_str(), \"w\");\n    }\n    if (!pTiffHandle)\n    {\n        return false;\n    }\n\n    //Settings that matter to all images\n    // defaults for now, maybe base them on params in the future\n    int compression = COMPRESSION_LZW;\n    int predictor = PREDICTOR_HORIZONTAL;\n\n    readParam(params, TIFFTAG_COMPRESSION, compression);\n    readParam(params, TIFFTAG_PREDICTOR, predictor);\n\n    //Iterate through each image in the vector and write them out as Tiff directories\n    for (size_t page = 0; page < img_vec.size(); page++)\n    {\n        const Mat& img = img_vec[page];\n        int channels = img.channels();\n        int width = img.cols, height = img.rows;\n        int depth = img.depth();\n\n        int bitsPerChannel = -1;\n        switch (depth)\n        {\n            case CV_8U:\n            {\n                bitsPerChannel = 8;\n                break;\n            }\n            case CV_16U:\n            {\n                bitsPerChannel = 16;\n                break;\n            }\n            default:\n            {\n                TIFFClose(pTiffHandle);\n                return false;\n            }\n        }\n\n        const int bitsPerByte = 8;\n        size_t fileStep = (width * channels * bitsPerChannel) / bitsPerByte;\n\n        int rowsPerStrip = (int)((1 << 13) / fileStep);\n        readParam(params, TIFFTAG_ROWSPERSTRIP, rowsPerStrip);\n\n        if (rowsPerStrip < 1)\n            rowsPerStrip = 1;\n\n        if (rowsPerStrip > height)\n            rowsPerStrip = height;\n\n        int   colorspace = channels > 1 ? PHOTOMETRIC_RGB : PHOTOMETRIC_MINISBLACK;\n\n        if (!TIFFSetField(pTiffHandle, TIFFTAG_IMAGEWIDTH, width)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_IMAGELENGTH, height)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_BITSPERSAMPLE, bitsPerChannel)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_COMPRESSION, compression)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_PHOTOMETRIC, colorspace)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_SAMPLESPERPIXEL, channels)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_ROWSPERSTRIP, rowsPerStrip)\n            || (img_vec.size() > 1 && (\n               !TIFFSetField(pTiffHandle, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_PAGENUMBER, page, img_vec.size() )))\n            )\n        {\n            TIFFClose(pTiffHandle);\n            return false;\n        }\n\n        if (compression != COMPRESSION_NONE && !TIFFSetField(pTiffHandle, TIFFTAG_PREDICTOR, predictor))\n        {\n            TIFFClose(pTiffHandle);\n            return false;\n        }\n\n        // row buffer, because TIFFWriteScanline modifies the original data!\n        size_t scanlineSize = TIFFScanlineSize(pTiffHandle);\n        AutoBuffer<uchar> _buffer(scanlineSize + 32);\n        uchar* buffer = _buffer;\n        if (!buffer)\n        {\n            TIFFClose(pTiffHandle);\n            return false;\n        }\n\n        for (int y = 0; y < height; ++y)\n        {\n            switch (channels)\n            {\n                case 1:\n                {\n                    memcpy(buffer, img.ptr(y), scanlineSize);\n                    break;\n                }\n\n                case 3:\n                {\n                    if (depth == CV_8U)\n                        icvCvt_BGR2RGB_8u_C3R( img.ptr(y), 0, buffer, 0, cvSize(width, 1));\n                    else\n                        icvCvt_BGR2RGB_16u_C3R( img.ptr<ushort>(y), 0, (ushort*)buffer, 0, cvSize(width, 1));\n                    break;\n                }\n\n                case 4:\n                {\n                    if (depth == CV_8U)\n                        icvCvt_BGRA2RGBA_8u_C4R( img.ptr(y), 0, buffer, 0, cvSize(width, 1));\n                    else\n                        icvCvt_BGRA2RGBA_16u_C4R( img.ptr<ushort>(y), 0, (ushort*)buffer, 0, cvSize(width, 1));\n                    break;\n                }\n\n                default:\n                {\n                    TIFFClose(pTiffHandle);\n                    return false;\n                }\n            }\n\n            int writeResult = TIFFWriteScanline(pTiffHandle, buffer, y, 0);\n            if (writeResult != 1)\n            {\n                TIFFClose(pTiffHandle);\n                return false;\n            }\n        }\n\n        TIFFWriteDirectory(pTiffHandle);\n\n    }\n\n    TIFFClose(pTiffHandle);\n    return true;\n}",
    "void TiffWriter::writeFrame(const std::string& filename, const char* data) {\n  TIFF* tif = TIFFOpen(filename.c_str(), \"w\");\n  if (!tif) {\n    Logger::get(Logger::Error) << \"Cannot open file '\" << filename << \"' for writing.\" << std::endl;\n    return;\n  }\n  TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, getWidth());\n  TIFFSetField(tif, TIFFTAG_IMAGELENGTH, getHeight());\n  TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8);\n  TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 4);\n  TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, getHeight());\n\n  TIFFSetField(tif, TIFFTAG_COMPRESSION, compression);\n  TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);  // RGBA??\n  TIFFSetField(tif, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);\n  TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\n  TIFFSetField(tif, TIFFTAG_XRESOLUTION, 150.0);\n  TIFFSetField(tif, TIFFTAG_YRESOLUTION, 150.0);\n  TIFFSetField(tif, TIFFTAG_RESOLUTIONUNIT, RESUNIT_CENTIMETER);\n\n  // Write the information to the file\n  TIFFWriteEncodedStrip(tif, 0, (tdata_t)data, (tsize_t)(getWidth() * getHeight() * 4));\n  TIFFClose(tif);\n}",
    "TIFFFormat::~TIFFFormat()\n{\n   if(tif_)\n      TIFFClose(tif_);\n}",
    "bool TIFFFormat::encodeFinish(void)\n{\n   if(encodeState & IMAGE_FORMAT_ENCODED_PIXELS)\n   {\n      assert(!tif_);\n      return true;\n   }\n   if(tif_)\n      TIFFClose(tif_);\n   tif_ = nullptr;\n   encodeState |= IMAGE_FORMAT_ENCODED_PIXELS;\n\n   return true;\n}",
    "grk_image* TIFFFormat::decode(const std::string& filename, grk_cparameters* parameters)\n{\n   bool found_assocalpha = false;\n   size_t alpha_count = 0;\n   chroma_subsample_x = 1;\n   chroma_subsample_y = 1;\n   GRK_COLOR_SPACE color_space = GRK_CLRSPC_UNKNOWN;\n   grk_image_comp cmptparm[grk::maxNumPackComponents];\n   grk_image* image = nullptr;\n   uint16_t tiBps = 0, tiPhoto = 0, tiSf = SAMPLEFORMAT_UINT, tiSpp = 0, tiPC = 0;\n   bool hasTiSf = false;\n   short tiResUnit = 0;\n   float tiXRes = 0, tiYRes = 0;\n   uint32_t tiWidth = 0, tiHeight = 0;\n   bool is_cinema = GRK_IS_CINEMA(parameters->rsiz);\n   bool success = false;\n   bool isCIE = false;\n   uint16_t compress;\n   float *luma = nullptr, *refBlackWhite = nullptr;\n   uint16_t *red_orig = nullptr, *green_orig = nullptr, *blue_orig = nullptr;\n\n   tif_ = TIFFOpen(filename.c_str(), \"r\");\n   if(!tif_)\n   {\n      spdlog::error(\"TIFFFormat::decode: Failed to open {} for reading\", filename);\n      return 0;\n   }\n\n   if(TIFFIsTiled(tif_))\n   {\n      spdlog::error(\"TIFFFormat::decode: tiled TIFF images not supported\");\n      return 0;\n   }\n\n   TIFFGetField(tif_, TIFFTAG_COMPRESSION, &compress);\n   TIFFGetFieldDefaulted(tif_, TIFFTAG_IMAGEWIDTH, &tiWidth);\n   TIFFGetFieldDefaulted(tif_, TIFFTAG_IMAGELENGTH, &tiHeight);\n   TIFFGetFieldDefaulted(tif_, TIFFTAG_BITSPERSAMPLE, &tiBps);\n   TIFFGetFieldDefaulted(tif_, TIFFTAG_SAMPLESPERPIXEL, &tiSpp);\n   TIFFGetFieldDefaulted(tif_, TIFFTAG_PHOTOMETRIC, &tiPhoto);\n   TIFFGetFieldDefaulted(tif_, TIFFTAG_PLANARCONFIG, &tiPC);\n   hasTiSf = TIFFGetFieldDefaulted(tif_, TIFFTAG_SAMPLEFORMAT, &tiSf) == 1;\n\n   TIFFGetFieldDefaulted(tif_, TIFFTAG_REFERENCEBLACKWHITE, &refBlackWhite);\n\n   uint32_t w = tiWidth;\n   uint32_t h = tiHeight;\n   uint16_t numcomps = 0;\n   uint32_t icclen = 0;\n   uint8_t* iccbuf = nullptr;\n   uint8_t* iptc_buf = nullptr;\n   uint32_t iptc_len = 0;\n   uint8_t* xmp_buf = nullptr;\n   uint32_t xmp_len = 0;\n   uint16_t* sampleinfo = nullptr;\n   uint16_t extrasamples = 0;\n   bool hasXRes = false, hasYRes = false, hasResUnit = false;\n   bool isSigned = (tiSf == SAMPLEFORMAT_INT);\n   bool needSignedPixelReader = isSigned && (tiBps == 8 || tiBps == 16);\n\n   // 1. sanity checks\n\n   // check for supported photometric interpretation\n   if(tiPhoto != PHOTOMETRIC_MINISBLACK && tiPhoto != PHOTOMETRIC_MINISWHITE &&\n      tiPhoto != PHOTOMETRIC_RGB && tiPhoto != PHOTOMETRIC_ICCLAB &&\n      tiPhoto != PHOTOMETRIC_CIELAB && tiPhoto != PHOTOMETRIC_YCBCR &&\n      tiPhoto != PHOTOMETRIC_SEPARATED && tiPhoto != PHOTOMETRIC_PALETTE)\n   {\n      spdlog::error(\"TIFFFormat::decode: Unsupported color format {}.\\n\"\n                    \"Only RGB(A), GRAY(A), CIELAB, YCC, CMYK and PALETTE have been implemented.\",\n                    getColourFormatString(tiPhoto));\n      goto cleanup;\n   }\n   // check for rec601\n   if(tiPhoto == PHOTOMETRIC_YCBCR)\n   {\n      TIFFGetFieldDefaulted(tif_, TIFFTAG_YCBCRCOEFFICIENTS, &luma);\n      for(size_t i = 0; i < 3; ++i)\n      {\n         if((uint32_t)(luma[i] * 1000.0f + 0.5f) != rec_601_luma[i])\n         {\n            spdlog::error(\n                \"TIFFFormat::decode: YCbCr image with unsupported non Rec. 601 colour space;\");\n            spdlog::error(\"YCbCrCoefficients: {},{},{}\", luma[0], luma[1], luma[2]);\n            spdlog::error(\"Please convert to sRGB before compressing.\");\n            goto cleanup;\n         }\n      }\n   }\n   // check sample format\n   if(hasTiSf && tiSf != SAMPLEFORMAT_UINT && tiSf != SAMPLEFORMAT_INT)\n   {\n      spdlog::error(\"TIFFFormat::decode: Unsupported sample format: {}.\",\n                    getSampleFormatString(tiSf));\n      goto cleanup;\n   }\n   if(tiSpp == 0)\n   {\n      spdlog::error(\"TIFFFormat::decode: Samples per pixel must be non-zero\");\n      goto cleanup;\n   }\n   if(tiBps > 16U || tiBps == 0)\n   {\n      spdlog::error(\"TIFFFormat::decode: Unsupported precision {}. Maximum 16 Bits supported.\",\n                    tiBps);\n      goto cleanup;\n   }\n   if(tiWidth == 0 || tiHeight == 0)\n   {\n      spdlog::error(\"TIFFFormat::decode: Width({}) and height({}) must both \"\n                    \"be non-zero\",\n                    tiWidth, tiHeight);\n      goto cleanup;\n   }\n   TIFFGetFieldDefaulted(tif_, TIFFTAG_EXTRASAMPLES, &extrasamples, &sampleinfo);\n\n   // 2. initialize image components and signed/unsigned\n   memset(&cmptparm[0], 0, grk::maxNumPackComponents * sizeof(grk_image_comp));\n   if((tiPhoto == PHOTOMETRIC_RGB) && (is_cinema) && (tiBps != 12U))\n   {\n      spdlog::warn(\"TIFFFormat::decode: Input image bitdepth is {} bits.\", tiBps);\n      spdlog::warn(\"TIF conversion has automatically rescaled to 12-bits\");\n      spdlog::warn(\"to comply with cinema profiles.\\n\");\n   }\n   else\n   {\n      is_cinema = 0U;\n   }\n   numcomps = extrasamples;\n   switch(tiPhoto)\n   {\n      case PHOTOMETRIC_PALETTE:\n         if(isSigned)\n         {\n            spdlog::error(\"TIFFFormat::decode: Signed palette image not supported\");\n            goto cleanup;\n         }\n         color_space = GRK_CLRSPC_SRGB;\n         numcomps++;\n         break;\n      case PHOTOMETRIC_MINISBLACK:\n      case PHOTOMETRIC_MINISWHITE:\n         color_space = GRK_CLRSPC_GRAY;\n         numcomps++;\n         break;\n      case PHOTOMETRIC_RGB:\n         color_space = GRK_CLRSPC_SRGB;\n         numcomps = (uint16_t)(numcomps + 3);\n         break;\n      case PHOTOMETRIC_CIELAB:\n      case PHOTOMETRIC_ICCLAB:\n         isCIE = true;\n         color_space = GRK_CLRSPC_DEFAULT_CIE;\n         numcomps = (uint16_t)(numcomps + 3);\n         break;\n      case PHOTOMETRIC_YCBCR:\n         // jpeg library is needed to convert from YCbCr to RGB\n         if(compress == COMPRESSION_OJPEG || compress == COMPRESSION_JPEG)\n         {\n            spdlog::error(\"TIFFFormat::decode: YCbCr image with JPEG compression\"\n                          \" is not supported\");\n            goto cleanup;\n         }\n         else if(compress == COMPRESSION_PACKBITS)\n         {\n            spdlog::error(\"TIFFFormat::decode: YCbCr image with PACKBITS compression\"\n                          \" is not supported\");\n            goto cleanup;\n         }\n         color_space = GRK_CLRSPC_SYCC;\n         numcomps = (uint16_t)(numcomps + 3);\n         TIFFGetFieldDefaulted(tif_, TIFFTAG_YCBCRSUBSAMPLING, &chroma_subsample_x,\n                               &chroma_subsample_y);\n         if(chroma_subsample_x == 0 || chroma_subsample_y == 0)\n         {\n            spdlog::error(\"TIFFFormat::decode: chroma subsampling factors must be positive.\");\n            goto cleanup;\n         }\n         if(chroma_subsample_x > 255 || chroma_subsample_y > 255)\n         {\n            spdlog::error(\n                \"TIFFFormat::decode: chroma subsampling factors must each be less than 256.\");\n            goto cleanup;\n         }\n         if(chroma_subsample_x != 1 || chroma_subsample_y != 1)\n         {\n            if(isSigned)\n            {\n               spdlog::error(\"TIFFFormat::decode: chroma subsampling {},{} with signed data \"\n                             \"is not supported\",\n                             chroma_subsample_x, chroma_subsample_y);\n               goto cleanup;\n            }\n            if(numcomps != 3)\n            {\n               spdlog::error(\"TIFFFormat::decode: chroma subsampling {},{} with alpha \"\n                             \"channel(s) not supported\",\n                             chroma_subsample_x, chroma_subsample_y);\n               goto cleanup;\n            }\n         }\n         break;\n      case PHOTOMETRIC_SEPARATED:\n         color_space = GRK_CLRSPC_CMYK;\n         numcomps = (uint16_t)(numcomps + 4);\n         break;\n      default:\n         spdlog::error(\"TIFFFormat::decode: Unsupported colour space {}.\", tiPhoto);\n         goto cleanup;\n         break;\n   }\n   if(tiPhoto == PHOTOMETRIC_CIELAB)\n   {\n      if(hasTiSf && (tiSf != SAMPLEFORMAT_INT))\n         spdlog::warn(\"TIFFFormat::decode: Input image is in CIE colour space\"\n                      \" but sample format is unsigned int. Forcing to signed int\");\n      isSigned = true;\n   }\n   else if(tiPhoto == PHOTOMETRIC_ICCLAB)\n   {\n      if(hasTiSf && (tiSf != SAMPLEFORMAT_UINT))\n         spdlog::warn(\"TIFFFormat::decode: Input image is in ICC CIE colour\"\n                      \" space but sample format is signed int. Forcing to unsigned int\");\n      isSigned = false;\n   }\n\n   if(isSigned)\n   {\n      if(tiPhoto == PHOTOMETRIC_MINISWHITE)\n         spdlog::error(\"TIFFFormat::decode: signed image with \"\n                       \"MINISWHITE format is not fully supported\");\n      if(tiBps != 4 && tiBps != 8 && tiBps != 10 && tiBps != 12 && tiBps != 16)\n      {\n         spdlog::error(\"TIFFFormat::decode: signed image with bit\"\n                       \" depth {} is not supported\",\n                       tiBps);\n         goto cleanup;\n      }\n   }\n   if(numcomps > grk::maxNumPackComponents)\n   {\n      spdlog::error(\"TIFFFormat::decode: number of components \"\n                    \"{} must be <= %u\",\n                    numcomps, grk::maxNumPackComponents);\n      goto cleanup;\n   }\n\n   // 4. create image\n   for(uint32_t j = 0; j < numcomps; j++)\n   {\n      auto img_comp = cmptparm + j;\n      img_comp->prec = (uint8_t)tiBps;\n      bool chroma = (j == 1 || j == 2);\n      img_comp->dx = chroma ? (uint8_t)chroma_subsample_x : 1;\n      img_comp->dy = chroma ? (uint8_t)chroma_subsample_y : 1;\n      img_comp->w = grk::ceildiv<uint32_t>(w, img_comp->dx);\n      img_comp->h = grk::ceildiv<uint32_t>(h, img_comp->dy);\n   }\n   image = grk_image_new(numcomps, &cmptparm[0], color_space, true);\n   if(!image)\n      goto cleanup;\n\n   /* set image offset and reference grid */\n   image->x0 = parameters->image_offset_x0;\n   image->x1 = image->x0 + (w - 1) * 1 + 1;\n   if(image->x1 <= image->x0)\n   {\n      spdlog::error(\"TIFFFormat::decode: Bad value for image->x1({}) vs. \"\n                    \"image->x0({}).\",\n                    image->x1, image->x0);\n      goto cleanup;\n   }\n   image->y0 = parameters->image_offset_y0;\n   image->y1 = image->y0 + (h - 1) * 1 + 1;\n   if(image->y1 <= image->y0)\n   {\n      spdlog::error(\"TIFFFormat::decode: Bad value for image->y1({}) vs. \"\n                    \"image->y0({}).\",\n                    image->y1, image->y0);\n      goto cleanup;\n   }\n   if(tiPhoto == PHOTOMETRIC_PALETTE)\n   {\n      if(!TIFFGetField(tif_, TIFFTAG_COLORMAP, &red_orig, &green_orig, &blue_orig))\n      {\n         spdlog::error(\"TIFFFormat::decode: Missing required \\\"Colormap\\\" tag\");\n         goto cleanup;\n      }\n      uint16_t palette_num_entries = (uint16_t)(1U << tiBps);\n      uint8_t num_channels = 3U;\n      create_meta(image);\n      allocPalette(&image->meta->color, num_channels, (uint16_t)palette_num_entries);\n      auto cmap = new _grk_component_mapping_comp[num_channels];\n      for(uint8_t i = 0; i < num_channels; ++i)\n      {\n         cmap[i].component = 0;\n         cmap[i].mapping_type = 1;\n         cmap[i].palette_column = i;\n         image->meta->color.palette->channel_prec[i] = 16;\n         image->meta->color.palette->channel_sign[i] = false;\n      }\n      image->meta->color.palette->component_mapping = cmap;\n      auto lut_ptr = image->meta->color.palette->lut;\n      for(uint16_t i = 0; i < palette_num_entries; i++)\n      {\n         *lut_ptr++ = red_orig[i];\n         *lut_ptr++ = green_orig[i];\n         *lut_ptr++ = blue_orig[i];\n      }\n   }\n   for(uint32_t j = 0; j < numcomps; j++)\n   {\n      // handle non-colour channel\n      uint16_t numColourChannels = (uint16_t)(numcomps - extrasamples);\n      auto comp = image->comps + j;\n\n      if(extrasamples > 0 && j >= numColourChannels)\n      {\n         comp->type = GRK_CHANNEL_TYPE_UNSPECIFIED;\n         comp->association = GRK_CHANNEL_ASSOC_UNASSOCIATED;\n         auto alphaType = sampleinfo[j - numColourChannels];\n         if(alphaType == EXTRASAMPLE_ASSOCALPHA)\n         {\n            if(found_assocalpha)\n               spdlog::warn(\"TIFFFormat::decode: Found more than one associated alpha channel\");\n            alpha_count++;\n            comp->type = GRK_CHANNEL_TYPE_PREMULTIPLIED_OPACITY;\n            found_assocalpha = true;\n         }\n         else if(alphaType == EXTRASAMPLE_UNASSALPHA)\n         {\n            alpha_count++;\n            comp->type = GRK_CHANNEL_TYPE_OPACITY;\n         }\n         else\n         {\n            // some older mono or RGB images may have alpha channel\n            // stored as EXTRASAMPLE_UNSPECIFIED\n            if((color_space == GRK_CLRSPC_GRAY && numcomps == 2) ||\n               (color_space == GRK_CLRSPC_SRGB && numcomps == 4))\n            {\n               alpha_count++;\n               comp->type = GRK_CHANNEL_TYPE_OPACITY;\n            }\n         }\n      }\n      if(comp->type == GRK_CHANNEL_TYPE_OPACITY ||\n         comp->type == GRK_CHANNEL_TYPE_PREMULTIPLIED_OPACITY)\n      {\n         switch(alpha_count)\n         {\n            case 1:\n               comp->association = GRK_CHANNEL_ASSOC_WHOLE_IMAGE;\n               break;\n            case 2:\n               comp->association = GRK_CHANNEL_ASSOC_UNASSOCIATED;\n               break;\n            default:\n               comp->type = GRK_CHANNEL_TYPE_UNSPECIFIED;\n               comp->association = GRK_CHANNEL_ASSOC_UNASSOCIATED;\n               break;\n         }\n      }\n      comp->sgnd = isSigned;\n   }\n\n   if(needSignedPixelReader && isFinalOutputSubsampled(image))\n   {\n      spdlog::error(\"TIFF: subsampling not supported for signed 8 and 16 bit images\");\n      goto cleanup;\n   }\n\n   // 5. extract capture resolution\n   hasXRes = TIFFGetFieldDefaulted(tif_, TIFFTAG_XRESOLUTION, &tiXRes) == 1;\n   hasYRes = TIFFGetFieldDefaulted(tif_, TIFFTAG_YRESOLUTION, &tiYRes) == 1;\n   hasResUnit = TIFFGetFieldDefaulted(tif_, TIFFTAG_RESOLUTIONUNIT, &tiResUnit) == 1;\n   if(hasXRes && hasYRes && hasResUnit && tiResUnit != RESUNIT_NONE)\n   {\n      set_resolution(parameters->capture_resolution_from_file, tiXRes, tiYRes, tiResUnit);\n      parameters->write_capture_resolution_from_file = true;\n   }\n   // 6. extract embedded ICC profile (with sanity check on binary size of profile)\n   // note: we ignore ICC profile for CIE images as JPEG 2000 can't signal both\n   // CIE and ICC\n   if(!isCIE)\n   {\n      if((TIFFGetFieldDefaulted(tif_, TIFFTAG_ICCPROFILE, &icclen, &iccbuf) == 1) && icclen > 0 &&\n         icclen < grk::maxICCProfileBufferLen)\n         copy_icc(image, iccbuf, icclen);\n   }\n   // 7. extract IPTC meta-data\n   if(TIFFGetFieldDefaulted(tif_, TIFFTAG_RICHTIFFIPTC, &iptc_len, &iptc_buf) == 1)\n   {\n      if(TIFFIsByteSwapped(tif_))\n         TIFFSwabArrayOfLong((uint32_t*)iptc_buf, iptc_len);\n      // since TIFFTAG_RICHTIFFIPTC is of type TIFF_LONG, we must multiply\n      // by 4 to get the length in bytes\n      create_meta(image);\n      image->meta->iptc_len = iptc_len * 4;\n      image->meta->iptc_buf = new uint8_t[iptc_len];\n      memcpy(image->meta->iptc_buf, iptc_buf, iptc_len);\n   }\n   // 8. extract XML meta-data\n   if(TIFFGetFieldDefaulted(tif_, TIFFTAG_XMLPACKET, &xmp_len, &xmp_buf) == 1)\n   {\n      create_meta(image);\n      image->meta->xmp_len = xmp_len;\n      image->meta->xmp_buf = new uint8_t[xmp_len];\n      memcpy(image->meta->xmp_buf, xmp_buf, xmp_len);\n   }\n   // 9. read pixel data\n   if(needSignedPixelReader)\n   {\n      if(tiBps == 8)\n         success = readTiffPixelsSigned<int8_t>(tif_, image->comps, numcomps, tiSpp, tiPC);\n      else\n         success = readTiffPixelsSigned<int16_t>(tif_, image->comps, numcomps, tiSpp, tiPC);\n   }\n   else\n   {\n      success = readTiffPixels(tif_, image->comps, numcomps, tiSpp, tiPC, tiPhoto,\n                               chroma_subsample_x, chroma_subsample_y);\n   }\ncleanup:\n   if(tif_)\n      TIFFClose(tif_);\n   tif_ = nullptr;\n   if(success)\n   {\n      if(is_cinema)\n      {\n         for(uint32_t j = 0; j < numcomps; ++j)\n            scaleComponent(image->comps + j, 12);\n      }\n      return image;\n   }\n   if(image)\n      grk_object_unref(&image->obj);\n\n   return nullptr;\n}",
    "int ChkTIFF(LPCTSTR lpszPath)\n{\n    int rtn = 0;\n\n    TIFFErrorHandler eh;\n    TIFFErrorHandler wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF *tif = TIFFOpen(lpszPath, \"r\");\n    if (tif)\n    {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}",
    "PVOID ReadTIFF(LPCTSTR lpszPath)\n{\n    void *pDIB = 0;\n    TIFFErrorHandler wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath))\n    {\n        TIFF *tif = TIFFOpen(lpszPath, \"r\");\n        if (tif)\n        {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg))\n            {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(&img.tif, tif, -1, emsg))\n                {\n                    size_t npixels;\n                    uint32_t *raster;\n\n                    DibInstallHack(&img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster =\n                        (uint32_t *)_TIFFmalloc(npixels * sizeof(uint32_t));\n                    if (raster != NULL)\n                    {\n                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width,\n                                             img.tif.height))\n                        {\n                            pDIB = TIFFRGBA2DIB(&img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(&img.tif);\n            }\n            else\n            {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg);\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}",
    "TiffStream::~TiffStream()\n{\n    if (m_tif != NULL)\n        TIFFClose(m_tif);\n}",
    "int ImageIO::getTIFFSampleFormat (const Glib::ustring &fname, IIOSampleFormat &sFormat, IIOSampleArrangement &sArrangement)\n{\n#ifdef _WIN32\n    wchar_t *wfilename = (wchar_t*)g_utf8_to_utf16 (fname.c_str(), -1, NULL, NULL, NULL);\n    TIFF* in = TIFFOpenW (wfilename, \"r\");\n    g_free (wfilename);\n#else\n    TIFF* in = TIFFOpen(fname.c_str(), \"r\");\n#endif\n\n    if (in == nullptr) {\n        return IMIO_CANNOTREADFILE;\n    }\n\n    std::uint16_t bitspersample = 0, samplesperpixel = 0, sampleformat = 0;\n    int hasTag = TIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bitspersample);\n    hasTag &= TIFFGetField(in, TIFFTAG_SAMPLESPERPIXEL, &samplesperpixel);\n\n    if (!hasTag) {\n        // These are needed\n        TIFFClose(in);\n        sFormat = IIOSF_UNKNOWN;\n        return IMIO_VARIANTNOTSUPPORTED;\n    }\n\n    if (!TIFFGetField(in, TIFFTAG_SAMPLEFORMAT, &sampleformat)) {\n        /*\n         * WARNING: This is a dirty hack!\n         * We assume that files which doesn't contain the TIFFTAG_SAMPLEFORMAT tag\n         * (which is the case with uncompressed TIFFs produced by RT!) are RGB files,\n         * but that may be not true.   --- Hombre\n         */\n        sampleformat = SAMPLEFORMAT_UINT;\n    } else if (sampleformat == SAMPLEFORMAT_VOID) {\n        // according to https://www.awaresystems.be/imaging/tiff/tifftags/sampleformat.html\n        // we assume SAMPLEFORMAT_UINT if SAMPLEFORMAT_VOID is set\n        sampleformat = SAMPLEFORMAT_UINT;\n    }\n\n    std::uint16_t config;\n    TIFFGetField(in, TIFFTAG_PLANARCONFIG, &config);\n\n    if (config == PLANARCONFIG_CONTIG) {\n        sArrangement = IIOSA_CHUNKY;\n    } else {\n        sFormat = IIOSF_UNKNOWN;\n        sArrangement = IIOSA_UNKNOWN;\n        TIFFClose(in);\n        return IMIO_VARIANTNOTSUPPORTED;\n    }\n\n    std::uint16_t photometric;\n\n    if (!TIFFGetField(in, TIFFTAG_PHOTOMETRIC, &photometric)) {\n        TIFFClose(in);\n        return IMIO_VARIANTNOTSUPPORTED;\n    }\n\n    std::uint16_t compression;\n\n    if (photometric == PHOTOMETRIC_LOGLUV)\n        if (!TIFFGetField(in, TIFFTAG_COMPRESSION, &compression)) {\n            compression = COMPRESSION_NONE;\n        }\n\n    TIFFClose(in);\n\n    if (photometric == PHOTOMETRIC_RGB || photometric == PHOTOMETRIC_MINISBLACK) {\n        if ((samplesperpixel == 1 || samplesperpixel == 3 || samplesperpixel == 4) && sampleformat == SAMPLEFORMAT_UINT) {\n            if (bitspersample == 8) {\n                sFormat = IIOSF_UNSIGNED_CHAR;\n                return IMIO_SUCCESS;\n            }\n\n            if (bitspersample == 16) {\n                sFormat = IIOSF_UNSIGNED_SHORT;\n                return IMIO_SUCCESS;\n            }\n        } else if ((samplesperpixel == 3 || samplesperpixel == 4) && sampleformat == SAMPLEFORMAT_IEEEFP) {\n            if (bitspersample==16) {\n                sFormat = IIOSF_FLOAT16;\n                return IMIO_SUCCESS;\n            }\n            if (bitspersample == 24) {\n                sFormat = IIOSF_FLOAT24;\n                return IMIO_SUCCESS;\n            }\n            if (bitspersample == 32) {\n                sFormat = IIOSF_FLOAT32;\n                return IMIO_SUCCESS;\n            }\n        }\n    } else if ((samplesperpixel == 3 || samplesperpixel == 4) && photometric == PHOTOMETRIC_LOGLUV) {\n        if (compression == COMPRESSION_SGILOG24) {\n            sFormat = IIOSF_LOGLUV24;\n            return IMIO_SUCCESS;\n        } else if (compression == COMPRESSION_SGILOG) {\n            sFormat = IIOSF_LOGLUV32;\n            return IMIO_SUCCESS;\n        }\n    }\n\n    return IMIO_VARIANTNOTSUPPORTED;\n}",
    "int ImageIO::loadTIFF (const Glib::ustring &fname)\n{\n\n    static MyMutex thumbMutex;\n    MyMutex::MyLock lock(thumbMutex);\n\n    if(!options.serializeTiffRead) {\n        lock.release();\n    }\n\n#ifdef _WIN32\n    wchar_t *wfilename = (wchar_t*)g_utf8_to_utf16 (fname.c_str(), -1, NULL, NULL, NULL);\n    TIFF* in = TIFFOpenW (wfilename, \"r\");\n    g_free (wfilename);\n#else\n    TIFF* in = TIFFOpen(fname.c_str(), \"r\");\n#endif\n\n    if (in == nullptr) {\n        return IMIO_CANNOTREADFILE;\n    }\n\n    if (pl) {\n        pl->setProgressStr (\"PROGRESSBAR_LOADTIFF\");\n        pl->setProgress (0.0);\n    }\n\n    int width, height;\n    TIFFGetField(in, TIFFTAG_IMAGEWIDTH, &width);\n    TIFFGetField(in, TIFFTAG_IMAGELENGTH, &height);\n\n    std::uint16_t bitspersample, samplesperpixel;\n    int hasTag = TIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bitspersample);\n    hasTag &= TIFFGetField(in, TIFFTAG_SAMPLESPERPIXEL, &samplesperpixel);\n\n    if (!hasTag) {\n        // These are needed\n        TIFFClose(in);\n        fprintf(stderr, \"Error 1 loading %s\\n\", fname.c_str());\n        fflush(stderr);\n        return IMIO_VARIANTNOTSUPPORTED;\n    }\n\n    std::uint16_t config;\n    TIFFGetField(in, TIFFTAG_PLANARCONFIG, &config);\n\n    if (config != PLANARCONFIG_CONTIG) {\n        TIFFClose(in);\n        fprintf(stderr, \"Error 2 loading %s\\n\", fname.c_str());\n        fflush(stderr);\n        return IMIO_VARIANTNOTSUPPORTED;\n    }\n\n    if (sampleFormat & (IIOSF_LOGLUV24 | IIOSF_LOGLUV32)) {\n        TIFFSetField(in, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_FLOAT);\n    }\n\n    /*\n     * We could use the min/max values set in TIFFTAG_SMINSAMPLEVALUE and\n     * TIFFTAG_SMAXSAMPLEVALUE, but for now, we normalize the image to the\n     * effective minimum and maximum values\n     */\n    if (settings->verbose) {\n        printf(\"Information of \\\"%s\\\":\\n\", fname.c_str());\n        std::uint16_t tiffDefaultScale, tiffBaselineExposure, tiffLinearResponseLimit;\n        if (TIFFGetField(in, TIFFTAG_DEFAULTSCALE, &tiffDefaultScale)) {\n            printf(\"   DefaultScale: %d\\n\", tiffDefaultScale);\n        }\n        else\n            printf(\"   No DefaultScale value!\\n\");\n        if (TIFFGetField(in, TIFFTAG_BASELINEEXPOSURE, &tiffBaselineExposure)) {\n            printf(\"   BaselineExposure: %d\\n\", tiffBaselineExposure);\n        }\n        else\n            printf(\"   No BaselineExposure value!\\n\");\n        if (TIFFGetField(in, TIFFTAG_LINEARRESPONSELIMIT, &tiffLinearResponseLimit)) {\n            printf(\"   LinearResponseLimit: %d\\n\", tiffLinearResponseLimit);\n        }\n        else\n            printf(\"   No LinearResponseLimit value!\\n\");\n\n        std::uint16_t tiffMinValue, tiffMaxValue;\n        if (TIFFGetField(in, TIFFTAG_SMINSAMPLEVALUE, &tiffMinValue)) {\n            printf(\"   MinValue: %d\\n\", tiffMinValue);\n        }\n        else\n            printf(\"   No minimum value!\\n\");\n        if (TIFFGetField(in, TIFFTAG_SMAXSAMPLEVALUE, &tiffMaxValue)) {\n            printf(\"   MaxValue: %d\\n\\n\", tiffMaxValue);\n        }\n        else\n            printf(\"   No maximum value!\\n\\n\");\n        printf(\"   Those values are not taken into account, the image data are normalized to a [0;1] range\\n\\n\");\n    }\n\n    char* profdata;\n    deleteLoadedProfileData();\n\n    if (TIFFGetField(in, TIFFTAG_ICCPROFILE, &loadedProfileLength, &profdata)) {\n        embProfile = cmsOpenProfileFromMem (profdata, loadedProfileLength);\n        loadedProfileData = new char [loadedProfileLength];\n        memcpy (loadedProfileData, profdata, loadedProfileLength);\n    } else {\n        embProfile = nullptr;\n    }\n\n    allocate (width, height);\n\n    std::unique_ptr<unsigned char[]> linebuffer(new unsigned char[TIFFScanlineSize(in) * (samplesperpixel == 1 ? 3 : 1)]);\n\n    for (int row = 0; row < height; row++) {\n        if (TIFFReadScanline(in, linebuffer.get(), row, 0) < 0) {\n            TIFFClose(in);\n            fprintf(stderr, \"Error 3 loading %s\\n\", fname.c_str());\n            fflush(stderr);\n            return IMIO_READERROR;\n        }\n\n        if (samplesperpixel > 3) {\n            for (int i = 0; i < width; i++) {\n                memmove(linebuffer.get() + i * 3 * bitspersample / 8, linebuffer.get() + i * samplesperpixel * bitspersample / 8, 3 * bitspersample / 8);\n            }\n        }\n        else if (samplesperpixel == 1) {\n            const size_t bytes = bitspersample / 8;\n            for (int i = width - 1; i >= 0; --i) {\n                const unsigned char* const src = linebuffer.get() + i * bytes;\n                unsigned char* const dest = linebuffer.get() + i * 3 * bytes;\n                memcpy(dest + 2 * bytes, src, bytes);\n                memcpy(dest + 1 * bytes, src, bytes);\n                memcpy(dest + 0 * bytes, src, bytes);\n            }\n        }\n\n        setScanline (row, linebuffer.get(), bitspersample);\n\n        if (pl && !(row % 100)) {\n            pl->setProgress ((double)(row + 1) / height);\n        }\n    }\n\n    TIFFClose(in);\n\n    if (pl) {\n        pl->setProgressStr (\"PROGRESSBAR_READY\");\n        pl->setProgress (1.0);\n    }\n\n    return IMIO_SUCCESS;\n}",
    "int ImageIO::saveTIFF (\n    const Glib::ustring &fname,\n    int bps,\n    bool isFloat,\n    bool uncompressed,\n    bool big\n) const\n{\n    if (getWidth() < 1 || getHeight() < 1) {\n        return IMIO_HEADERERROR;\n    }\n\n    bool writeOk = true;\n    int width = getWidth ();\n    int height = getHeight ();\n\n    if (bps < 0) {\n        bps = getBPS ();\n    }\n\n    int lineWidth = width * 3 * (bps / 8);\n    std::vector<unsigned char> linebuffer(lineWidth);\n\n    std::string mode = \"w\";\n\n    if (big) {\n        mode += '8';\n    }\n\n#ifdef _WIN32\n    FILE *file = g_fopen_withBinaryAndLock (fname);\n    int fileno = _fileno(file);\n    int osfileno = _get_osfhandle(fileno);\n    TIFF* out = TIFFFdOpen (osfileno, fname.c_str(), mode.c_str());\n#else\n    TIFF* out = TIFFOpen(fname.c_str(), mode.c_str());\n    // int fileno = TIFFFileno (out);\n#endif\n\n    if (!out) {\n        return IMIO_CANNOTWRITEFILE;\n    }\n\n    if (pl) {\n        pl->setProgressStr (\"PROGRESSBAR_SAVETIFF\");\n        pl->setProgress (0.0);\n    }\n\n    bool needsReverse = false;\n\n    TIFFSetField (out, TIFFTAG_SOFTWARE, \"RawTherapee \" RTVERSION);\n    TIFFSetField (out, TIFFTAG_IMAGEWIDTH, width);\n    TIFFSetField (out, TIFFTAG_IMAGELENGTH, height);\n    TIFFSetField (out, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n    TIFFSetField (out, TIFFTAG_SAMPLESPERPIXEL, 3);\n    TIFFSetField (out, TIFFTAG_ROWSPERSTRIP, height);\n    TIFFSetField (out, TIFFTAG_BITSPERSAMPLE, bps);\n    TIFFSetField (out, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    TIFFSetField (out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n    TIFFSetField (out, TIFFTAG_COMPRESSION, uncompressed ? COMPRESSION_NONE : COMPRESSION_ADOBE_DEFLATE);\n    TIFFSetField (out, TIFFTAG_SAMPLEFORMAT, (bps == 16 || bps == 32) && isFloat ? SAMPLEFORMAT_IEEEFP : SAMPLEFORMAT_UINT);\n\n    // somehow Exiv2 (tested with 0.27.3) doesn't seem to be able to update\n    // XResolution and YResolution, so we do it ourselves here....\n    constexpr float default_resolution = 300.f;\n    float x_res = default_resolution;\n    float y_res = default_resolution;\n    int res_unit = RESUNIT_INCH;\n    if (!metadataInfo.filename().empty()) {\n        auto exif = metadataInfo.getOutputExifData();\n        auto it = exif.findKey(Exiv2::ExifKey(\"Exif.Image.XResolution\"));\n        if (it != exif.end()) {\n            x_res = it->toFloat();\n        }\n        it = exif.findKey(Exiv2::ExifKey(\"Exif.Image.YResolution\"));\n        if (it != exif.end()) {\n            y_res = it->toFloat();\n        }\n        it = exif.findKey(Exiv2::ExifKey(\"Exif.Image.ResolutionUnit\"));\n        if (it != exif.end()) {\n            res_unit = to_long(it);\n        }\n    }\n    TIFFSetField(out, TIFFTAG_XRESOLUTION, x_res);\n    TIFFSetField(out, TIFFTAG_YRESOLUTION, y_res);\n    TIFFSetField(out, TIFFTAG_RESOLUTIONUNIT, res_unit);\n\n    if (!uncompressed) {\n        TIFFSetField (out, TIFFTAG_PREDICTOR, (bps == 16 || bps == 32) && isFloat ? PREDICTOR_FLOATINGPOINT : PREDICTOR_HORIZONTAL);\n    }\n    if (!profileData.empty()) {\n        TIFFSetField (out, TIFFTAG_ICCPROFILE, profileData.size(), profileData.data());\n    }\n\n    for (int row = 0; row < height; row++) {\n        getScanline (row, linebuffer.data(), bps, isFloat);\n\n        if (bps == 16) {\n            if(needsReverse && !uncompressed && isFloat) {\n                for(int i = 0; i < lineWidth; i += 2) {\n                    std::swap(linebuffer[i], linebuffer[i + 1]);\n                }\n            }\n        } else if (bps == 32) {\n            if(needsReverse && !uncompressed) {\n                for(int i = 0; i < lineWidth; i += 4) {\n                    std::swap(linebuffer[i], linebuffer[i + 3]);\n                    std::swap(linebuffer[i + 1], linebuffer[i + 2]);\n                }\n            }\n        }\n\n        if (TIFFWriteScanline (out, linebuffer.data(), row, 0) < 0) {\n            TIFFClose (out);\n            return IMIO_CANNOTWRITEFILE;\n        }\n\n        if (pl && !(row % 100)) {\n            pl->setProgress ((double)(row + 1) / height);\n        }\n    }\n\n    if (TIFFFlush(out) != 1) {\n        writeOk = false;\n    }\n\n    TIFFClose (out);\n#ifdef _WIN32\n    fclose (file);\n#endif\n\n    if (!saveMetadata(fname)) {\n        writeOk = false;\n    }\n\n    if (pl) {\n        pl->setProgressStr (\"PROGRESSBAR_READY\");\n        pl->setProgress (1.0);\n    }\n\n    if(writeOk) {\n        return IMIO_SUCCESS;\n    } else {\n        g_remove (fname.c_str());\n        return IMIO_CANNOTWRITEFILE;\n    }\n}",
    "ref<Image> vl::loadTIFF(VirtualFile* file)\r\n{\r\n  file->open(OM_ReadOnly);\r\n  ref<Image> img = new Image;\r\n\r\n  TIFFSetErrorHandler(tiff_error);\r\n  TIFFSetWarningHandler(tiff_warning);\r\n\r\n  TIFF* tif = TIFFClientOpen(\"tiffread\", \"r\", reinterpret_cast<thandle_t>(file),\r\n                tiff_io_read_func,\r\n                tiff_io_write_func,\r\n                tiff_io_seek_func,\r\n                tiff_io_close_func,\r\n                tiff_io_size_func,\r\n                tiff_io_map_func,\r\n                tiff_io_unmap_func);\r\n\r\n  if (tif)\r\n  {\r\n    uint32 w, h;\r\n    size_t npixels;\r\n    uint32* raster;\r\n\r\n    TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w);\r\n    TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\r\n    npixels = w * h;\r\n    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\r\n    if (raster != NULL)\r\n    {\r\n      if (TIFFReadRGBAImage(tif, w, h, raster, 0))\r\n      {\r\n        img->allocate2D(w,h,1,vl::IF_RGBA,vl::IT_UNSIGNED_BYTE);\r\n        memcpy(img->pixels(), raster, img->requiredMemory());\r\n      }\r\n      _TIFFfree(raster);\r\n    }\r\n    uint16 orientation = ORIENTATION_TOPLEFT; // default\r\n    TIFFGetField(tif, TIFFTAG_ORIENTATION, &orientation);\r\n    if (orientation == ORIENTATION_LEFTBOT )\r\n      img->flipVertically();\r\n    TIFFClose(tif);\r\n  }\r\n\r\n  file->close();\r\n  return img;\r\n}",
    "int TMOImage::OpenTIFF_8_32()\n{\n\tTIFF *pFile; // TIFF file pointer\n\tTIFFSetErrorHandler(0);\n\n\t// otevreni vstupniho souboru TIFF\n\tif ((pFile = TIFFOpen(pName, \"r\")) == NULL)\n\t{\n\t\tstrcat(pName, \".tif\");\n\t\tif ((pFile = TIFFOpen(pName, \"r\")) == NULL)\n\t\t{\n\t\t\tstrcat(pName, \"f\");\n\t\t\tif ((pFile = TIFFOpen(pName, \"r\")) == NULL)\n\t\t\t{\n\t\t\t\tdelete[] pName;\n\t\t\t\tpName = 0;\n\t\t\t\tthrow TMO_EFILE;\n\t\t\t}\n\t\t}\n\t}\n\tReadHeader(pFile);\n\tReadData(pFile);\n\tTIFFClose(pFile);\n\treturn 0;\n}",
    "int TMOImage::WriteData(TIFF *pFile, bool HDR)\n{\n\tConvert(TMO_RGB, false);\n\n\tint x, y, offset;\n\tdouble pixel[3];\n\n\tfloat *scanline = NULL;\t\t\t // 32b HDR\n\tunsigned char *scanlineb = NULL; // 8b LDR\n\n\tif (HDR)\n\t{ // write 32b floats\n\t\tscanline = new float[3 * iWidth];\n\t\tfor (y = 0; y < iHeight; y++)\n\t\t{\n\t\t\tif (y % 10 == 0)\n\t\t\t\tif (ProgressBar(y, iHeight) == 1)\n\t\t\t\t\tthrow TMO_EPROGRESS_BAR;\n\t\t\toffset = y * iWidth;\n\t\t\tfor (x = iWidth; x--;)\n\t\t\t{\n\t\t\t\tif (iFormat < 256)\n\t\t\t\t{\n\t\t\t\t\tpixel[0] = GetOffset(offset + x)[0];\n\t\t\t\t\tpixel[1] = GetOffset(offset + x)[1];\n\t\t\t\t\tpixel[2] = GetOffset(offset + x)[2];\n\t\t\t\t\tscanline[3 * x] = pixel[0];\n\t\t\t\t\tscanline[3 * x + 1] = pixel[1];\n\t\t\t\t\tscanline[3 * x + 2] = pixel[2];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpixel[0] = GetOffset(offset + x)[0];\n\t\t\t\t\tif (pixel[0] < 0.0)\n\t\t\t\t\t\tpixel[0] = 0.0;\n\t\t\t\t\tif (pixel[0] > 1.0)\n\t\t\t\t\t\tpixel[0] = 1.0;\n\t\t\t\t\tscanline[3 * x] =\n\t\t\t\t\t\tscanline[3 * x + 1] =\n\t\t\t\t\t\t\tscanline[3 * x + 2] = (unsigned char)(255 * pixel[0]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (TIFFWriteScanline(pFile, scanline, y, 0) < 0)\n\t\t\t\tthrow TMO_EFILE;\n\t\t}\n\t}\n\telse\n\t{\n\t\tscanlineb = new unsigned char[3 * iWidth];\n\t\tfor (y = 0; y < iHeight; y++)\n\t\t{\n\t\t\tif (y % 10 == 0)\n\t\t\t\tif (ProgressBar(y, iHeight) == 1)\n\t\t\t\t\tthrow TMO_EPROGRESS_BAR;\n\t\t\toffset = y * iWidth;\n\t\t\tfor (x = iWidth; x--;)\n\t\t\t{\n\t\t\t\tif (iFormat < 256)\n\t\t\t\t{\n\t\t\t\t\tpixel[0] = GetOffset(offset + x)[0];\n\t\t\t\t\tpixel[1] = GetOffset(offset + x)[1];\n\t\t\t\t\tpixel[2] = GetOffset(offset + x)[2];\n\t\t\t\t\tif (pixel[0] < 0.0)\n\t\t\t\t\t\tpixel[0] = 0.0;\n\t\t\t\t\tif (pixel[1] < 0.0)\n\t\t\t\t\t\tpixel[1] = 0.0;\n\t\t\t\t\tif (pixel[2] < 0.0)\n\t\t\t\t\t\tpixel[2] = 0.0;\n\t\t\t\t\tif (pixel[0] > 1.0)\n\t\t\t\t\t\tpixel[0] = 1.0;\n\t\t\t\t\tif (pixel[1] > 1.0)\n\t\t\t\t\t\tpixel[1] = 1.0;\n\t\t\t\t\tif (pixel[2] > 1.0)\n\t\t\t\t\t\tpixel[2] = 1.0;\n\t\t\t\t\tscanlineb[3 * x] = (unsigned char)(255 * pixel[0]);\n\t\t\t\t\tscanlineb[3 * x + 1] = (unsigned char)(255 * pixel[1]);\n\t\t\t\t\tscanlineb[3 * x + 2] = (unsigned char)(255 * pixel[2]);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpixel[0] = GetOffset(offset + x)[0];\n\t\t\t\t\tif (pixel[0] < 0.0)\n\t\t\t\t\t\tpixel[0] = 0.0;\n\t\t\t\t\tif (pixel[0] > 1.0)\n\t\t\t\t\t\tpixel[0] = 1.0;\n\t\t\t\t\tscanlineb[3 * x] =\n\t\t\t\t\t\tscanlineb[3 * x + 1] =\n\t\t\t\t\t\t\tscanlineb[3 * x + 2] = (unsigned char)(255 * pixel[0]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (TIFFWriteScanline(pFile, scanlineb, y, 0) < 0)\n\t\t\t\tthrow TMO_EFILE_WRITE;\n\t\t}\n\t}\n\tif (y % 10 == 0)\n\t\tif (ProgressBar(y, iHeight) == 1)\n\t\t\tthrow TMO_EPROGRESS_BAR;\n\tif (pFile)\n\t\tTIFFClose(pFile);\n\tpFile = 0;\n\tif (scanline)\n\t\tdelete[] scanline;\n\tif (scanlineb)\n\t\tdelete[] scanlineb;\n\treturn 0;\n}",
    "void DEM_ImageCoregistration_hillshade(TransParam *return_param, char* _filename, ARGINFO args, char *_save_filepath, int gcp_opt)\n{\n    ProInfo *proinfo = (ProInfo*)malloc(sizeof(ProInfo));\n    \n    proinfo->number_of_images = args.number_of_images;\n    proinfo->pyramid_level = args.pyramid_level;\n    sprintf(proinfo->save_filepath,\"%s\",args.Outputpath);\n    if(args.GCP_spacing > 0)\n        proinfo->GCP_spacing = args.GCP_spacing;\n    else\n        proinfo->GCP_spacing = -9;\n    \n    time_t total_ST = 0, total_ET = 0;\n    double total_gap;\n    //FILE *time_fid;\n    \n    total_ST = time(0);\n    int py_kernel_size = 3;\n    \n    bool check_start = true;\n    if(args.check_txt_input == 0)\n    {\n        check_start = OpenProject(_filename,proinfo,args);\n    }\n    else if(args.check_txt_input == 1)\n    {\n        FILE *fid_read = fopen(args.DEM_input_file,\"r\");\n        \n        args.number_of_images = 0;\n        while( (fscanf(fid_read,\"%s\\n\",args.Image[args.number_of_images])) != EOF )\n        {\n            printf(\"input DEM %s\\n\",args.Image[args.number_of_images]);\n            sprintf(proinfo->Imagefilename[args.number_of_images],\"%s\",args.Image[args.number_of_images]);\n            args.number_of_images++;\n        }\n        fclose(fid_read);\n        proinfo->number_of_images = args.number_of_images;\n        printf(\"image num %d\\n\",args.number_of_images);\n    }\n    \n    if(check_start)\n    {\n        if(Maketmpfolders(proinfo))\n        {\n            int py_level = proinfo->pyramid_level;\n            TransParam param;\n            SetTranParam_fromGeoTiff(&param,proinfo->Imagefilename[0]);\n            \n            char ref_dem_name[500];\n            sprintf(ref_dem_name,\"%s\",args.Image[0]);\n            printf(\"dem name = %s\\n\",ref_dem_name);\n            \n            double ref_minX,ref_maxY,ref_dx,ref_dy;\n            CSize ref_dem_size = ReadGeotiff_info_dxy(ref_dem_name,&ref_minX,&ref_maxY,&ref_dx,&ref_dy);\n            \n            long cols[2] = {0, ref_dem_size.width};\n            long rows[2] = {0, ref_dem_size.height};\n            \n            //dem image = ref\n            float type(0);\n            float *DEM = Readtiff_T(ref_dem_name,&ref_dem_size,cols,rows,&ref_dem_size,type);\n            \n            char *reffilename  = SetOutpathName(args.Image[0]);\n            char *ref_no_ext = remove_ext(reffilename);\n            int char_size = strlen(ref_no_ext);\n            char *ref_fchar = (char*)malloc(sizeof(char)*(char_size-2));\n            for(int c = 0 ; c < char_size - 3 ; c++)\n                ref_fchar[c] = ref_no_ext[c];\n      \n            ref_fchar[char_size-3] = '\\0';\n            char DEM_name_refoutfile[500];\n            sprintf(DEM_name_refoutfile,\"%sdem.tif\",ref_fchar);\n            free(ref_no_ext);\n            free(ref_fchar);\n            free(reffilename);\n            \n            ref_no_ext = remove_ext(args.Image[0]);\n            char_size = strlen(ref_no_ext);\n            ref_fchar = (char*)malloc(sizeof(char)*(char_size-2));\n            for(int c = 0 ; c < char_size - 3 ; c++)\n                ref_fchar[c] = ref_no_ext[c];\n            \n            ref_fchar[char_size-3] = '\\0';\n            char ref_hill_inputname[500];\n            sprintf(ref_hill_inputname,\"%sdem_hillshade.tif\",ref_fchar);\n            printf(\"ref hill name %s\\n\",ref_hill_inputname);\n            free(ref_no_ext);\n            free(ref_fchar);\n            \n            //create hillshadeimage\n            unsigned char *ref_hill = NULL;\n            FILE *checktif = fopen(ref_hill_inputname,\"r\");\n            if(checktif)\n            {\n                TIFF *refhilltif  = TIFFOpen(ref_hill_inputname,\"r\");\n                uint8 type(0);\n                ref_hill = Readtiff_T(ref_hill_inputname, &ref_dem_size, cols, rows, &ref_dem_size, type);\n                TIFFClose(refhilltif);\n                fclose(checktif);\n                printf(\"loading existing hillshade image %s\\n\",ref_hill_inputname);\n            }\n            else\n                ref_hill = CreateHillshade(DEM,ref_dem_size,ref_dx);\n   \n            //create pyramidimage\n            CSize *data_size_ref = (CSize*)malloc(sizeof(CSize)*(py_level+1));\n            SetPySizes(data_size_ref, ref_dem_size, py_level);\n            \n            unsigned char **SubImages_ref = (unsigned char**)malloc(sizeof(unsigned char*)*(py_level+1));\n            \n            for(int level = 0 ; level <= py_level ; level++)\n            {\n                CSize data_size;\n                long int data_length;\n                \n                if(level == 0)\n                {\n                    data_size = data_size_ref[level];\n                    \n                    data_length = (long int)data_size.height*(long int)data_size.width;\n                    SubImages_ref[level] = (unsigned char*)malloc(sizeof(unsigned char)*data_length);\n                    memcpy(SubImages_ref[level],ref_hill,sizeof(unsigned char)*(long)data_length);\n                 }\n                else\n                {\n                    data_size = data_size_ref[level-1];\n                    \n                    data_length = (long int)data_size.height*(long int)data_size.width;\n                    SubImages_ref[level]= CreateImagePyramid(SubImages_ref[level-1],data_size,py_kernel_size,(double)1.6);\n                }\n            }\n            free(ref_hill);\n            \n            double ImageBoundary_ref[4] = {0.0};\n            ImageBoundary_ref[0] = ref_minX;\n            ImageBoundary_ref[1] = ref_maxY - ref_dy*ref_dem_size.height;\n            ImageBoundary_ref[2] = ref_minX + ref_dx*ref_dem_size.width;\n            ImageBoundary_ref[3] = ref_maxY;\n            \n            char out_file[500];\n            sprintf(out_file,\"%s/DEM_coreg_result.txt\",args.Outputpath);\n            FILE* fid_out         = fopen(out_file,\"w\");\n            fprintf(fid_out,\"ref DEM name\\t%s\\n\",DEM_name_refoutfile);\n            fprintf(fid_out,\"DEM name\\t\\t\\t\\t\\t\\t\\tTx[meter]\\tTy[meter]\\tTz(average)\\tTz(median)\\tTx_std[meter]\\tTy_std[meter]\\tTz_std(average)\\tTz_std(median)\\tControls_rho\\tMean_all(avg)\\tMedian_all(avg)\\tdz_std(avg)\\tMean_all(med)\\tMedian_all(med)\\tdz_std(med)\\tNumberOfCPs\\tprocessing time\\n\");\n            \n            double Grid_space = ref_dx*15.0;\n            if(proinfo->GCP_spacing > 0)\n                Grid_space = proinfo->GCP_spacing;\n            printf(\"Grid space %f\\n\", Grid_space);\n            for(int ti = 1; ti < proinfo->number_of_images ; ti++)\n            {\n                time_t total_ST_iter = 0, total_ET_iter = 0;\n                total_ST_iter = time(0);\n                \n                char tar_dem_name[500];\n                sprintf(tar_dem_name,\"%s\",args.Image[ti]);\n                printf(\"dem name = %s\\n\",tar_dem_name);\n                \n                double tar_minX,tar_maxY,tar_dx,tar_dy;\n                CSize tar_dem_size = ReadGeotiff_info_dxy(tar_dem_name,&tar_minX,&tar_maxY,&tar_dx,&tar_dy);\n                \n                cols[0] = 0;\n                cols[1] = tar_dem_size.width;\n                \n                rows[0] = 0;\n                rows[1] = tar_dem_size.height;\n                \n                //dem image\n                float type(0);\n                float *DEM_tar= Readtiff_T(tar_dem_name,&tar_dem_size,cols,rows,&tar_dem_size,type);\n                \n                char *reffilename  = SetOutpathName(args.Image[ti]);\n                char *ref_no_ext = remove_ext(reffilename);\n                int char_size = strlen(ref_no_ext);\n                char *ref_fchar = (char*)malloc(sizeof(char)*(char_size-2));\n                for(int c = 0 ; c < char_size - 3 ; c++)\n                    ref_fchar[c] = ref_no_ext[c];\n        \n                ref_fchar[char_size-3] = '\\0';\n                char DEM_name_outfile[500];\n                sprintf(DEM_name_outfile,\"%sdem\",ref_fchar);\n                free(ref_no_ext);\n                free(ref_fchar);\n                free(reffilename);\n                \n                ref_no_ext = remove_ext(args.Image[ti]);\n                char_size = strlen(ref_no_ext);\n                ref_fchar = (char*)malloc(sizeof(char)*(char_size-2));\n                for(int c = 0 ; c < char_size - 3 ; c++)\n                    ref_fchar[c] = ref_no_ext[c];\n         \n                ref_fchar[char_size-3] = '\\0';\n                char tar_hill_inputfile[500];\n                sprintf(tar_hill_inputfile,\"%sdem_hillshade.tif\",ref_fchar);\n                printf(\"tar hill name %s\\n\",tar_hill_inputfile);\n                free(ref_no_ext);\n                free(ref_fchar);\n                \n                char co_dems_name[500];\n                char copoly_dems_name[500];\n                char co_dems_name_diff[500];\n                char copoly_dems_name_diff[500];\n                char ref_hill_name[500];\n                char tar_hill_name[500];\n                \n                sprintf(co_dems_name,\"%s/%s_coreg_avg.tif\",args.Outputpath,DEM_name_outfile);\n                sprintf(copoly_dems_name,\"%s/%s_coreg_med.tif\",args.Outputpath,DEM_name_outfile);\n                sprintf(co_dems_name_diff,\"%s/%s_coreg_avg_diff.tif\",args.Outputpath,DEM_name_outfile);\n                sprintf(copoly_dems_name_diff,\"%s/%s_coreg_med_diff.tif\",args.Outputpath,DEM_name_outfile);\n                \n                sprintf(ref_hill_name,\"%s/%s_ref_hill.tif\",args.Outputpath,DEM_name_outfile);\n                sprintf(tar_hill_name,\"%s/%s_tar_hill.tif\",args.Outputpath,DEM_name_outfile);\n                \n                //create hillshadeimage\n                unsigned char *tar_hill = NULL;\n                FILE *checktif_tar = fopen(tar_hill_inputfile,\"r\");\n                if(checktif)\n                {\n                    TIFF *tarhilltif = NULL;\n                    tarhilltif  = TIFFOpen(tar_hill_inputfile,\"r\");\n                    uint8 type(0);\n                    tar_hill = Readtiff_T(tar_hill_inputfile, &tar_dem_size, cols, rows, &tar_dem_size, type);\n                    TIFFClose(tarhilltif);\n                    fclose(checktif_tar);\n                    printf(\"loading existing hillshade image %s\\n\",tar_hill_inputfile);\n                }\n                else\n                    tar_hill = CreateHillshade(DEM_tar,tar_dem_size,tar_dx);\n                \n                //create pyramidimage\n                CSize *data_size_tar = (CSize*)malloc(sizeof(CSize)*(py_level+1));\n                SetPySizes(data_size_tar, tar_dem_size, py_level);\n                \n                unsigned char **SubImages_tar = (unsigned char**)malloc(sizeof(unsigned char*)*(py_level+1));\n                \n                for(int level = 0 ; level <= py_level ; level++)\n                {\n                    CSize data_size;\n                    long int data_length;\n                    \n                    if(level == 0)\n                    {\n                        data_size = data_size_tar[level];\n                        \n                        data_length = (long int)data_size.height*(long int)data_size.width;\n                        SubImages_tar[level] = (unsigned char*)malloc(sizeof(unsigned char)*data_length);\n                        memcpy(SubImages_tar[level],tar_hill,sizeof(unsigned char)*(long)data_length);\n                    }\n                    else\n                    {\n                        data_size = data_size_tar[level-1];\n                        \n                        data_length = (long int)data_size.height*(long int)data_size.width;\n                        SubImages_tar[level]= CreateImagePyramid(SubImages_tar[level-1],data_size,py_kernel_size,(double)1.6);\n                    }\n                }\n                free(tar_hill);\n                \n                double ImageBoundary_tar[4] = {0.0};\n                double Boundary[4] = {0.0};\n                //double GridSize_width, GridSize_height;\n                \n                Boundary[0] = ImageBoundary_ref[0];\n                Boundary[1] = ImageBoundary_ref[1];\n                Boundary[2] = ImageBoundary_ref[2];\n                Boundary[3] = ImageBoundary_ref[3];\n                \n                ImageBoundary_tar[0] = tar_minX;\n                ImageBoundary_tar[1] = tar_maxY - tar_dy*tar_dem_size.height;\n                ImageBoundary_tar[2] = tar_minX + tar_dx*tar_dem_size.width;\n                ImageBoundary_tar[3] = tar_maxY;\n                \n                if(Boundary[0] < ImageBoundary_tar[0])\n                    Boundary[0] = ImageBoundary_tar[0];\n                else\n                    Boundary[0] = Boundary[0];\n                \n                if(Boundary[1] < ImageBoundary_tar[1])\n                    Boundary[1] = ImageBoundary_tar[1];\n                else\n                    Boundary[1] = Boundary[1];\n                \n                if(Boundary[2] > ImageBoundary_tar[2])\n                    Boundary[2] = ImageBoundary_tar[2];\n                else\n                    Boundary[2] = Boundary[2];\n                \n                if(Boundary[3] > ImageBoundary_tar[3])\n                    Boundary[3] = ImageBoundary_tar[3];\n                else\n                    Boundary[3] = Boundary[3];\n                \n                if(args.check_boundary)\n                {\n                    if(Boundary[0] < args.Min_X)\n                        Boundary[0] = args.Min_X;\n                    if(Boundary[1] < args.Min_Y)\n                        Boundary[1] = args.Min_Y;\n                    if(Boundary[2] > args.Max_X)\n                        Boundary[2] = args.Max_X;\n                    if(Boundary[3] > args.Max_Y)\n                        Boundary[3] = args.Max_Y;\n                    \n                    Boundary[0] = args.Min_X;\n                    Boundary[1] = args.Min_Y;\n                    Boundary[2] = args.Max_X;\n                    Boundary[3] = args.Max_Y;\n                }\n                \n                // GridSize_width = Boundary[2] - Boundary[0];\n                // GridSize_height = Boundary[3] - Boundary[1];\n                \n                //int iter_counts;\n                \n                D2DPOINT adjust_std;\n                vector<D2DPOINT> MPs_2D;\n                vector<D2DPOINT> MPs_2D_mat;\n                double avg_roh;\n                double ImageAdjust_coreg[2] = {0};\n                \n                for(int level = py_level ; level >= 0 ; level --)\n                {\n                    int iter_counts;\n                    D2DPOINT grid_dxy_ref(ref_dx, ref_dy);\n                    D2DPOINT grid_dxy_tar(tar_dx, tar_dy);\n                    \n                    vector<D2DPOINT> MPs;\n                    \n                    CoregParam_Image(proinfo, ti, level, ImageAdjust_coreg, 15, SubImages_ref[level], data_size_ref[level], SubImages_tar[level],  data_size_tar[level], ImageBoundary_ref, ImageBoundary_tar, grid_dxy_ref, grid_dxy_tar, Grid_space, Boundary, &avg_roh, &iter_counts, &adjust_std, MPs_2D_mat, MPs_2D, MPs);\n                    \n                    printf(\"%d\\t\\t%4.2f\\t\\t%4.2f\\t\\t%4.2f\\t\\t%4.2f\\t\\t%zu\\t%4.2f\\t%d\\t%4.2f\\t%4.2f\\n\",level,ImageAdjust_coreg[0], ImageAdjust_coreg[1],-ImageAdjust_coreg[0]*tar_dy, ImageAdjust_coreg[1]*tar_dx,MPs_2D.size(),avg_roh,iter_counts,adjust_std.m_X,adjust_std.m_Y);\n                    free(SubImages_tar[level]);\n                }\n                free(SubImages_tar);\n                free(data_size_tar);\n        \n                int RA_iter_counts = MPs_2D.size();\n                if(RA_iter_counts > 10)\n                {\n                    // time_t total_ST_a = 0, total_ET_a = 0;\n                    // total_ST_a = time(0);\n                    \n                    const double Coreg_param[2] = {- ImageAdjust_coreg[0]*tar_dy, ImageAdjust_coreg[1]*tar_dx};\n                    const double W_th = 80;\n                    \n                    int diff_count = 0;\n                    double dH_th = 30;\n                    double SD_z = 0;\n                    double SD_z_med = 0;\n                    double MED_z = 0;\n                    double average = 0;\n                    \n                    bool check_stop = false;\n                    int while_iter = 0;\n                    double pre_std = 10000.0;\n                    double change_std_ratio = 1000;\n                    \n                    total_ST = time(0);\n                    bool check_cps = false;\n                    while(!check_stop && while_iter < 50 && !check_cps)\n                    {\n                        double sum_diff = 0;\n                        D3DPOINT *save_pts = (D3DPOINT*)calloc(sizeof(D3DPOINT),RA_iter_counts);\n                        diff_count = 0;\n#pragma omp parallel for reduction(+:sum_diff,diff_count) schedule(guided)\n                        for(long int gcp_index = 0 ; gcp_index < RA_iter_counts ; gcp_index ++)\n                        {\n                            D2DPOINT gcp_coord,ref_img,tar_img;\n                            gcp_coord.m_X = MPs_2D[gcp_index].m_X;\n                            gcp_coord.m_Y = MPs_2D[gcp_index].m_Y;\n                            \n                            ref_img.m_X = (gcp_coord.m_X - ref_minX)/ref_dx;\n                            ref_img.m_Y = (ref_maxY - gcp_coord.m_Y)/ref_dx;\n                            \n                            tar_img.m_X = ( (gcp_coord.m_X + Coreg_param[1]) - tar_minX )/tar_dx;\n                            tar_img.m_Y = ( tar_maxY - (gcp_coord.m_Y + Coreg_param[0]) )/tar_dx;\n                            \n                            bool check_b = true;\n                            if(args.check_boundary)\n                            {\n                                if(gcp_coord.m_X >= args.Min_X && gcp_coord.m_X <= args.Max_X && gcp_coord.m_Y >= args.Min_Y && gcp_coord.m_Y <= args.Max_Y)\n                                    check_b = true;\n                                else\n                                    check_b = false;\n                            }\n                            \n                            if(ref_img.m_X - 2 >= 0 && ref_img.m_X + 2 < ref_dem_size.width && ref_img.m_Y - 2 >= 0 && ref_img.m_Y + 2 < ref_dem_size.height &&\n                               tar_img.m_X - 2 >= 0 && tar_img.m_X + 2 < tar_dem_size.width && tar_img.m_Y - 2 >= 0 && tar_img.m_Y + 2 < tar_dem_size.height && check_b)\n                            {\n                                long ref_index = (long)(ref_img.m_Y)*(long)ref_dem_size.width + (long)(ref_img.m_X);\n                                long tar_index = (long)(tar_img.m_Y)*(long)tar_dem_size.width + (long)(tar_img.m_X);\n                                \n                                if(DEM[ref_index] > -100 && DEM[ref_index] < 10000 && DEM_tar[tar_index] > -100 && DEM_tar[tar_index] < 10000)\n                                {\n                                    vector<double> ref_patch_vecs, tar_patch_vecs;\n                                    vector<long> kc_pos, kr_pos;\n                                    int kernel_count = 0;\n                                    for(long kr = -2 ; kr <= 2 ; kr++ )\n                                    {\n                                        for(long kc = -2 ; kc <= 2 ; kc++ )\n                                        {\n                                            long k_refindex = (long)(ref_img.m_Y + kr)*(long)ref_dem_size.width + (long)(ref_img.m_X + kc);\n                                            long k_tarindex = (long)(tar_img.m_Y + kr)*(long)tar_dem_size.width + (long)(tar_img.m_X + kc);\n                                            \n                                            if(DEM[k_refindex] > -100 && DEM[k_refindex] < 10000 && DEM_tar[k_tarindex] > -100 && DEM_tar[k_tarindex] < 10000)\n                                            {\n                                                ref_patch_vecs.push_back(DEM[k_refindex]);\n                                                tar_patch_vecs.push_back(DEM_tar[k_tarindex]);\n                                                kc_pos.push_back(kc);\n                                                kr_pos.push_back(kr);\n                                            }\n                                        }\n                                    }\n                                    \n                                    kernel_count = ref_patch_vecs.size();\n                                    \n                                    GMA_double *A_matrix = GMA_double_create(kernel_count, 3);\n                                    GMA_double *L_matrix = GMA_double_create(kernel_count, 1);\n                                    GMA_double *AT_matrix = GMA_double_create(3,kernel_count);\n                                    GMA_double *ATA_matrix = GMA_double_create(3,3);\n                                    \n                                    GMA_double *ATAI_matrix = GMA_double_create(3,3);\n                                    GMA_double *ATL_matrix = GMA_double_create(3,1);\n                                    \n                                    GMA_double *X_matrix = GMA_double_create(3,1);\n                                    GMA_double *AX_matrix = GMA_double_create(kernel_count,1);\n                                    GMA_double *V_matrix = GMA_double_create(kernel_count,1);\n                                    \n                                    GMA_double *tA_matrix = GMA_double_create(kernel_count, 3);\n                                    GMA_double *tL_matrix = GMA_double_create(kernel_count, 1);\n                                    GMA_double *tAT_matrix = GMA_double_create(3,kernel_count);\n                                    GMA_double *tATA_matrix = GMA_double_create(3,3);\n                                    \n                                    GMA_double *tATAI_matrix = GMA_double_create(3,3);\n                                    GMA_double *tATL_matrix = GMA_double_create(3,1);\n                                    \n                                    GMA_double *tX_matrix = GMA_double_create(3,1);\n                                    GMA_double *tAX_matrix = GMA_double_create(kernel_count,1);\n                                    GMA_double *tV_matrix = GMA_double_create(kernel_count,1);\n                                    \n                                    for(long k_index = 0 ; k_index < kernel_count ; k_index++)\n                                    {\n                                        A_matrix->val[k_index][0] = kc_pos[k_index]*ref_dx;\n                                        A_matrix->val[k_index][1] = kr_pos[k_index]*ref_dx;\n                                        A_matrix->val[k_index][2] = 1.0;\n                                        \n                                        L_matrix->val[k_index][0] = ref_patch_vecs[k_index];\n                                        \n                                        tA_matrix->val[k_index][0] = kc_pos[k_index]*tar_dx;\n                                        tA_matrix->val[k_index][1] = kr_pos[k_index]*tar_dx;\n                                        tA_matrix->val[k_index][2] = 1.0;\n                                        tL_matrix->val[k_index][0] = tar_patch_vecs[k_index];\n                                    }\n                                    \n                                    //DEM height correlation\n                                    double k_ncc = Correlate(ref_patch_vecs, tar_patch_vecs, kernel_count);\n                                    if (k_ncc != -99)\n                                        k_ncc = (k_ncc + 1)/2.0;\n                                    else\n                                        k_ncc = 0.0;\n                                    \n                                    GMA_double_Tran(A_matrix,AT_matrix);\n                                    GMA_double_mul(AT_matrix,A_matrix,ATA_matrix);\n                                    GMA_double_inv(ATA_matrix,ATAI_matrix);\n                                    GMA_double_mul(AT_matrix,L_matrix,ATL_matrix);\n                                    GMA_double_mul(ATAI_matrix,ATL_matrix,X_matrix);\n                                    GMA_double_mul(A_matrix,X_matrix,AX_matrix);\n                                    GMA_double_sub(AX_matrix,L_matrix,V_matrix);\n                                    \n                                    GMA_double_Tran(tA_matrix,tAT_matrix);\n                                    GMA_double_mul(tAT_matrix,tA_matrix,tATA_matrix);\n                                    GMA_double_inv(tATA_matrix,tATAI_matrix);\n                                    GMA_double_mul(tAT_matrix,tL_matrix,tATL_matrix);\n                                    GMA_double_mul(tATAI_matrix,tATL_matrix,tX_matrix);\n                                    GMA_double_mul(tA_matrix,tX_matrix,tAX_matrix);\n                                    GMA_double_sub(tAX_matrix,tL_matrix,tV_matrix);\n                                    \n                                    ref_patch_vecs.clear();\n                                    tar_patch_vecs.clear();\n                                    kc_pos.clear();\n                                    kr_pos.clear();\n                                    \n                                    D3DPOINT ref_normal(X_matrix->val[0][0], X_matrix->val[1][0], 1.0, 0);\n                                    D3DPOINT tar_normal(tX_matrix->val[0][0], tX_matrix->val[1][0], 1.0, 0);\n                                    D3DPOINT scale(1,1,1,0);\n                                    double ref_angle, ref_aspect, tar_angle, tar_aspect;\n                                    \n                                    SlopeAspect(ref_normal, scale, &ref_angle, &ref_aspect);\n                                    SlopeAspect(tar_normal, scale, &tar_angle, &tar_aspect);\n                                    \n                                    double SS = 1 - fabs(ref_angle - tar_angle)/90.0;\n                                    double SA = 1 - fabs(ref_aspect - tar_aspect)/360.0;\n                                    \n                                    double W = 40*k_ncc + 40*SS + 20*SA;\n                                    \n                                    if(W > W_th && (DEM[ref_index] - DEM_tar[tar_index]) < dH_th + average && (DEM[ref_index] - DEM_tar[tar_index]) > - dH_th + average)\n                                    {\n                                        long t_col_int   = (long)(tar_img.m_X + 0.01);\n                                        long t_row_int   = (long)(tar_img.m_Y + 0.01);\n                                        \n                                        double dcol        = tar_img.m_X - t_col_int;\n                                        double drow        = tar_img.m_Y - t_row_int;\n                                        \n                                        long index1,index2,index3, index4;\n                                        double value1, value2, value3, value4, value;\n                                        \n                                        index1  = (t_col_int   ) + (t_row_int   )*(long)tar_dem_size.width;\n                                        index2  = (t_col_int +1) + (t_row_int   )*(long)tar_dem_size.width;\n                                        index3  = (t_col_int   ) + (t_row_int +1)*(long)tar_dem_size.width;\n                                        index4  = (t_col_int +1) + (t_row_int +1)*(long)tar_dem_size.width;\n                                        \n                                        value1      = DEM_tar[index1];\n                                        value2      = DEM_tar[index2];\n                                        value3      = DEM_tar[index3];\n                                        value4      = DEM_tar[index4];\n                                        \n                                        if(value1 > -100 && value1 < 10000 && value2 > -100 && value2 < 10000 && value3 > -100 && value3 < 10000 && value4 > -100 && value4 < 10000)\n                                        {\n                                            value       = value1*(1-dcol)*(1-drow) + value2*dcol*(1-drow)\n                                            + value3*(1-dcol)*drow + value4*dcol*drow;\n                                            \n                                            if((DEM[ref_index] - value) < dH_th + average && (DEM[ref_index] - value) > -dH_th + average)\n                                            {\n                                                sum_diff += (DEM[ref_index] - value);\n                                                diff_count++;\n                                                \n                                                save_pts[gcp_index].m_X = gcp_coord.m_X + Coreg_param[1];\n                                                save_pts[gcp_index].m_Y = gcp_coord.m_Y + Coreg_param[0];\n                                                save_pts[gcp_index].m_Z = (DEM[ref_index] - value);\n                                                save_pts[gcp_index].flag = true;\n                                            }\n                                            else\n                                            {\n                                                save_pts[gcp_index].flag = false;\n                                            }\n                                        }\n                                    }\n                                    \n                                    GMA_double_destroy(A_matrix);\n                                    GMA_double_destroy(L_matrix);\n                                    GMA_double_destroy(AT_matrix);\n                                    GMA_double_destroy(ATA_matrix);\n                                    GMA_double_destroy(ATAI_matrix);\n                                    GMA_double_destroy(ATL_matrix);\n                                    GMA_double_destroy(X_matrix);\n                                    GMA_double_destroy(AX_matrix);\n                                    GMA_double_destroy(V_matrix);\n                                    \n                                    GMA_double_destroy(tA_matrix);\n                                    GMA_double_destroy(tL_matrix);\n                                    GMA_double_destroy(tAT_matrix);\n                                    GMA_double_destroy(tATA_matrix);\n                                    GMA_double_destroy(tATAI_matrix);\n                                    GMA_double_destroy(tATL_matrix);\n                                    GMA_double_destroy(tX_matrix);\n                                    GMA_double_destroy(tAX_matrix);\n                                    GMA_double_destroy(tV_matrix);\n                                }\n                            }\n                        }\n      \n                        printf(\"iteration %d\\tcps %d\\n\",while_iter,diff_count);\n                        if(diff_count > 10)\n                        {\n                            average = sum_diff/diff_count;\n                            \n                            vector<double> save_Z;\n                            double sum_var = 0;\n                            \n                            char dem_gcp_filename[500];\n                            sprintf(dem_gcp_filename,\"%s/DEM_gcps_%d.txt\",args.Outputpath,ti);\n                            FILE *fid_dem_gcp = fopen(dem_gcp_filename,\"w\");\n                            \n                            for(long row = 0; row < RA_iter_counts ; row++)\n                            {\n                                if(save_pts[row].flag == true)\n                                {\n                                    save_Z.push_back(save_pts[row].m_Z);\n                                    \n                                    sum_var += (average - save_pts[row].m_Z)*(average - save_pts[row].m_Z);\n                                    fprintf(fid_dem_gcp,\"%f\\t%f\\t%f\\n\",save_pts[row].m_X,save_pts[row].m_Y,save_pts[row].m_Z);\n                                }\n                            }\n                            fclose(fid_dem_gcp);\n                            \n                            diff_count = save_Z.size();\n                            \n                            MED_z = quickselect(save_Z, diff_count, (int)(diff_count/2.0));\n                            SD_z = sqrt(sum_var/diff_count);\n                            \n                            double iter_dH_th = SD_z*3.29;\n                            change_std_ratio = fabs(pre_std - SD_z)/pre_std;\n                            \n                            if(change_std_ratio < 0.01 || dH_th < iter_dH_th)\n                                check_stop = true;\n                            \n                            pre_std = SD_z;\n                            dH_th = iter_dH_th;\n                            \n                            while_iter++;\n                            \n                            double sum_var_med = 0;\n#pragma omp parallel for reduction(+:sum_var_med) schedule(guided)\n                            for(int i=0;i<diff_count;i++)\n                                sum_var_med += (MED_z -save_Z[i])*(MED_z -save_Z[i]);\n                            \n                            SD_z_med = sqrt(sum_var_med/save_Z.size());\n                            \n                            save_Z.clear();\n                        }\n                        else\n                            check_cps = true;\n                        \n                        free(save_pts);\n                        \n                        total_ET = time(0);\n                        total_gap = difftime(total_ET,total_ST);\n                        printf(\"\\nTz average and variation cal time %d\\t%f\\t%d\\t%f\\t%f\\t%f\\t%f\\t%f\\t%f\\n\\n\",while_iter, total_gap,diff_count,average,MED_z,SD_z,SD_z_med,change_std_ratio,dH_th);\n                        total_ST = time(0);\n                    }\n                    \n                    if(!check_cps)\n                    {\n                        //double min_save_Z = 100000;\n                        //double max_save_Z = -100000;\n                        \n                        float* co_dem = NULL;\n                        float* copoly_dem = NULL;\n                        float* co_dem_diff = NULL;\n                        float* copoly_dem_diff = NULL;\n                        \n                        double all_average = 0.0;\n                        double all_med = 0.0;\n                        double all_std = 0.0;\n                        double all_average_med = 0.0;\n                        double all_med_med = 0.0;\n                        double all_std_med = 0.0;\n                        \n                        long tar_data_length = (long)tar_dem_size.width*(long)tar_dem_size.height;\n                        if(args.check_DEM_coreg_output == 2)\n                        {\n                            co_dem = (float*)malloc(sizeof(float)*tar_data_length);\n                            copoly_dem = (float*)malloc(sizeof(float)*tar_data_length);\n                            co_dem_diff = (float*)malloc(sizeof(float)*tar_data_length);\n                            copoly_dem_diff = (float*)malloc(sizeof(float)*tar_data_length);\n                            \n                            for(long int co_index = 0 ; co_index < tar_data_length ; co_index++)\n                            {\n                                co_dem[co_index] = Nodata;\n                                copoly_dem[co_index] = Nodata;\n                                co_dem_diff[co_index] = Nodata;\n                                copoly_dem_diff[co_index] = Nodata;\n                            }\n                        }\n                        \n                        if(args.check_DEM_coreg_output == 1 || args.check_DEM_coreg_output == 2)\n                        {\n                            vector<double> save_dz, save_dz_med;\n                            \n                            double dz_sum = 0;\n                            double dz_sum_med = 0;\n                            //min_save_Z = 100000;\n                            //max_save_Z = -100000;\n                            for(long co_index = 0 ; co_index < tar_data_length ; co_index++)\n                            {\n                                long pts_row = floor(co_index/tar_dem_size.width);\n                                long pts_col = co_index % tar_dem_size.width;\n                                \n                                D2DPOINT gcp_coord,tar_img, ref_img,gcp_coord_ref;\n                                gcp_coord.m_X = pts_col*tar_dx + tar_minX + Coreg_param[1];\n                                gcp_coord.m_Y = tar_maxY - pts_row*tar_dx + Coreg_param[0];\n                                \n                                tar_img.m_X = ( gcp_coord.m_X - tar_minX )/tar_dx;\n                                tar_img.m_Y = ( tar_maxY - gcp_coord.m_Y )/tar_dx;\n                                \n                                gcp_coord_ref.m_X = pts_col*tar_dx + tar_minX;\n                                gcp_coord_ref.m_Y = tar_maxY - pts_row*tar_dx;\n                                \n                                ref_img.m_X = ( gcp_coord_ref.m_X - ref_minX )/ref_dx;\n                                ref_img.m_Y = ( ref_maxY - gcp_coord_ref.m_Y )/ref_dx;\n                                \n                                if(tar_img.m_X - 2 >= 0 && tar_img.m_X + 2 < tar_dem_size.width && tar_img.m_Y - 2 >= 0 && tar_img.m_Y + 2 < tar_dem_size.height &&\n                                   ref_img.m_X >= 0 && ref_img.m_X < ref_dem_size.width && ref_img.m_Y >= 0 && ref_img.m_Y < ref_dem_size.height)\n                                {\n                                    long tar_index = (long)(tar_img.m_Y)*(long)tar_dem_size.width + (long)(tar_img.m_X);\n                                    long ref_index = (long)(ref_img.m_Y)*(long)ref_dem_size.width + (long)(ref_img.m_X);\n                                    \n                                    if(DEM[ref_index] > -100 && DEM[ref_index] < 10000 && DEM_tar[tar_index] > -100 && DEM_tar[tar_index] < 10000)\n                                    {\n                                        long t_col_int   = (long)(tar_img.m_X + 0.01);\n                                        long t_row_int   = (long)(tar_img.m_Y + 0.01);\n                                        \n                                        double dcol        = tar_img.m_X - t_col_int;\n                                        double drow        = tar_img.m_Y - t_row_int;\n                                        \n                                        long index1,index2,index3, index4;\n                                        double value1, value2, value3, value4, value;\n                                        \n                                        index1  = (t_col_int   ) + (t_row_int   )*(long)tar_dem_size.width;\n                                        index2  = (t_col_int +1) + (t_row_int   )*(long)tar_dem_size.width;\n                                        index3  = (t_col_int   ) + (t_row_int +1)*(long)tar_dem_size.width;\n                                        index4  = (t_col_int +1) + (t_row_int +1)*(long)tar_dem_size.width;\n                                        \n                                        value1      = DEM_tar[index1];\n                                        value2      = DEM_tar[index2];\n                                        value3      = DEM_tar[index3];\n                                        value4      = DEM_tar[index4];\n                                        \n                                        value       = value1*(1-dcol)*(1-drow) + value2*dcol*(1-drow)\n                                        + value3*(1-dcol)*drow + value4*dcol*drow;\n                                        \n                                        double co_dem_t = value + average;\n                                        double copoly_dem_t = value + MED_z;\n                                        double co_dem_diff_t = (DEM[ref_index] - co_dem_t);\n                                        double copoly_dem_diff_t = (DEM[ref_index] - copoly_dem_t);\n                                        \n                                        if(args.check_DEM_coreg_output == 2)\n                                        {\n                                            co_dem[tar_index] = co_dem_t;\n                                            copoly_dem[tar_index] = copoly_dem_t;\n                                            \n                                            co_dem_diff[tar_index] = co_dem_diff_t;\n                                            copoly_dem_diff[tar_index] = copoly_dem_diff_t;\n                                        }\n                                        \n                                        \n                                        if(fabs(co_dem_diff_t) < dH_th && fabs(copoly_dem_diff_t) < dH_th)\n                                        {\n                                            dz_sum += co_dem_diff_t;\n                                            dz_sum_med += copoly_dem_diff_t;\n                                            \n                                            save_dz.push_back(co_dem_diff_t);\n                                            save_dz_med.push_back(copoly_dem_diff_t);\n                                        }\n                                    }\n                                }\n                            }\n                           \n                            long dz_count = save_dz.size();\n                            all_average = dz_sum/dz_count;\n                            all_med = quickselect(save_dz, dz_count, (int)(dz_count/2.0));\n                            \n                            all_average_med = dz_sum_med/dz_count;\n                            all_med_med = quickselect(save_dz_med, dz_count, (int)(dz_count/2.0));\n                   \n                            double all_sum_var = 0;\n                            double all_sum_var_med = 0;\n#pragma omp parallel for reduction(+:all_sum_var,all_sum_var_med) schedule(guided)\n                            for(long index = 0 ; index < dz_count ; index++)\n                            {\n                                all_sum_var += (save_dz[index] - all_average)*(save_dz[index] - all_average);\n                                all_sum_var_med += (save_dz_med[index] - all_average_med)*(save_dz_med[index] - all_average_med);\n                            }\n                            save_dz.clear();\n                            save_dz_med.clear();\n                            \n                            all_std = sqrt(all_sum_var/dz_count);\n                            all_std_med = sqrt(all_sum_var_med/dz_count);\n                            \n                            printf(\"all stat %f\\t%f\\t%f\\t%f\\t%f\\t%f\\n\",all_average,all_med,all_std,all_average_med,all_med_med,all_std_med);\n                            \n                            if(args.check_DEM_coreg_output == 2)\n                            {\n                                WriteGeotiff(co_dems_name, co_dem, tar_dem_size.width, tar_dem_size.height, tar_dx, tar_minX, tar_maxY, param.projection, param.utm_zone, param.bHemisphere, 4);\n                                WriteGeotiff(copoly_dems_name, copoly_dem, tar_dem_size.width, tar_dem_size.height, tar_dx, tar_minX, tar_maxY, param.projection, param.utm_zone, param.bHemisphere, 4);\n                                \n                                WriteGeotiff(co_dems_name_diff, co_dem_diff, tar_dem_size.width, tar_dem_size.height, tar_dx, tar_minX, tar_maxY, param.projection, param.utm_zone, param.bHemisphere, 4);\n                                WriteGeotiff(copoly_dems_name_diff, copoly_dem_diff, tar_dem_size.width, tar_dem_size.height, tar_dx, tar_minX, tar_maxY, param.projection, param.utm_zone, param.bHemisphere, 4);\n                                \n                                free(co_dem);\n                                free(copoly_dem);\n                                free(co_dem_diff);\n                                free(copoly_dem_diff);\n                            }\n                            \n                            total_ET = time(0);\n                            total_gap = difftime(total_ET,total_ST);\n                            printf(\"\\noutput save time %f\\n\\n\",total_gap);\n                            total_ST = time(0);\n                        }\n                        \n                        total_ET_iter = time(0);\n                        total_gap = difftime(total_ET_iter,total_ST_iter);\n                        \n                        if(avg_roh > 0.7 && SD_z < 5 && diff_count > 50)\n                        { fprintf(fid_out,\"%s.tif\\t%4.2f\\t\\t%4.2f\\t\\t%4.2f\\t\\t%4.2f\\t\\t%4.2f\\t\\t%4.2f\\t\\t%4.2f\\t\\t%4.2f\\t\\t%4.2f\\t\\t%4.2f\\t\\t%4.2f\\t\\t%4.2f\\t\\t%4.2f\\t\\t%4.2f\\t\\t%4.2f\\t\\t%d\\t%f\\n\",DEM_name_outfile,Coreg_param[1],Coreg_param[0],average,MED_z,adjust_std.m_Y,adjust_std.m_X,SD_z,SD_z_med,avg_roh,\n                                  all_average,all_med,all_std,all_average_med,all_med_med,all_std_med,diff_count,total_gap);\n                        }\n                        else\n                        {\n                            fprintf(fid_out,\"%s.tif\\t%4.2f\\t\\t%4.2f\\t\\t%4.2f\\t\\t%4.2f\\t\\t%4.2f\\t\\t%4.2f\\t\\t%4.2f\\t\\t%4.2f\\t\\t%4.2f\\t\\t%4.2f\\t\\t%4.2f\\t\\t%4.2f\\t\\t%4.2f\\t\\t%4.2f\\t\\t%4.2f\\t\\t%d\\t%f\\n\",DEM_name_outfile,Coreg_param[1],Coreg_param[0],average,MED_z,adjust_std.m_Y,adjust_std.m_X,SD_z,SD_z_med,avg_roh,\n                                    all_average,all_med,all_std,all_average_med,all_med_med,all_std_med,diff_count,total_gap);\n                        }\n                    }\n                    else\n                    {\n                        fprintf(fid_out,\"%s.tif\\tNaN\\t\\tNaN\\t\\tNaN\\t\\tNaN\\t\\tNaN\\t\\tNaN\\t\\tNaN\\t\\tNaN\\t\\tNaN\\t\\tNaN\\t\\tNaN\\t\\tNaN\\t\\tNaN\\t\\tNaN\\t\\tNaN\\t\\tNaN\\t%f\\n\",DEM_name_outfile,total_gap);\n                    }\n                    \n                }\n                else\n                {\n                    fprintf(fid_out,\"%s.tif\\tNaN\\t\\tNaN\\t\\tNaN\\t\\tNaN\\t\\tNaN\\t\\tNaN\\t\\tNaN\\t\\tNaN\\t\\tNaN\\t\\tNaN\\t\\tNaN\\t\\tNaN\\t\\tNaN\\t\\tNaN\\t\\tNaN\\t\\tNaN\\t%f\\n\",DEM_name_outfile,total_gap);\n                }\n                \n                MPs_2D.clear();\n                free(DEM_tar);\n            }\n            fclose(fid_out);\n            \n            for(int level = py_level ; level >= 0 ; level --)\n                free(SubImages_ref[level]);\n    \n            free(SubImages_ref);\n            free(DEM);\n            free(data_size_ref);\n        }\n    }\n    free(proinfo);\n}",
    "bool FilmScan::SourceTIFF(const std::string filename)\n{\n\t// verify the file is a TIFF and get the width and height from the header\n\tInStream img;\n\n\tTIFF *tif;\n\n\tif((tif = TIFFOpen(filename.c_str(), \"r\")) == NULL)\n\t{\n\t\tQString msg;\n\t\tint err;\n\n\t\tmsg += QString(\"FilmScan: Cannot open \");\n\t\tmsg += QString(filename.c_str());\n\t\tmsg += QString(\"\\n\");\n\t\tif((err=errno)!=0) msg += QString(strerror(err));\n\t\tthrow AeoException(msg);\n\t}\n\n\t// just grab the width and height from the header\n\tuint32 w, h;\n\tif(TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w) != 1 ||\n\t\t\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h) != 1)\n\t{\n\t\tTIFFClose(tif);\n\t\tthrow AeoException(\"Invalid image size specification in TIFF.\");\n\t}\n\n\tTIFFClose(tif);\n\n\tthis->width = w;\n\tthis->height = h;\n\tthis->srcFormat = SOURCE_TIFF;\n\n\tthis->TimeCode = \"00:00:00:00\";\n\tSourceIdentifyImageSet(filename);\n\n\treturn true;\n}",
    "unsigned char *ReadFrameTIFF_ImageData(const char *fn, unsigned char *buf,\n\t\tint &width, int &height, bool &endian,\n\t\tGLenum &pix_fmt, int &num_components)\n{\n\tTIFF* tif = TIFFOpen(fn, \"r\");\n\n\tif(tif == NULL)\n\t{\n\t\tQString msg;\n\t\tmsg += \"ReadFrameTIFF: Cannot open \";\n\t\tmsg += fn;\n\t\tmsg += \"\\n\";\n\t\tif(errno)\n\t\t\tmsg += strerror(errno);\n\t\tthrow AeoException(msg);\n\t}\n\n\tif(TIFFIsTiled(tif))\n\t{\n\t\tTIFFClose(tif);\n\t\tthrow AeoException(\"Tiled TIFF not supported.\");\n\t}\n\n\tuint16 bitsPerSample[3];\n\tuint16 bitDepth;\n\tuint16 numChannels;\n\tuint32 imageHeight;\n\tuint32 imageWidth;\n\tuint16 planarConfig;\n\tuint16 sampleFormat(0);\n\tuint16 photometric;\n\n\tif(TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &numChannels) != 1)\n\t{\n\t\tTIFFClose(tif);\n\t\tthrow AeoException(\"Invalid TIFF: no SAMPLESPERPIXEL tag\");\n\t}\n\n\tif(TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric) != 1)\n\t\tphotometric = (numChannels==1)?PHOTOMETRIC_MINISBLACK:PHOTOMETRIC_RGB;\n\telse if(!(numChannels==1 ||\n\t\t\t(numChannels==3 && photometric == PHOTOMETRIC_RGB)))\n\t{\n\t\tTIFFClose(tif);\n\t\tthrow AeoException(\"TIF must be either RGB or grayscale.\");\n\t}\n\n\tif(TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &imageWidth) != 1 ||\n\t\t\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &imageHeight) != 1)\n\t{\n\t\tTIFFClose(tif);\n\t\tthrow AeoException(\"Invalid TIFF image size\");\n\t}\n\n\t// libtiff docs say this returns 1 value, but other sources say it\n\t// returns <numChannels> values, so just to be safe, we allow it to\n\t// return up to 3 values and just use the first one.\n\tif(TIFFGetFieldDefaulted(tif, TIFFTAG_BITSPERSAMPLE, bitsPerSample) != 1)\n\t{\n\t\tTIFFClose(tif);\n\t\tthrow AeoException(\"Invalid TIFF: no bitsPerSample tag\");\n\t}\n\n\tbitDepth = bitsPerSample[0];\n\n\tif(bitDepth != 8 && bitDepth != 16)\n\t{\n\t\tTIFFClose(tif);\n\t\tthrow AeoException(\"TIFF must be 8-bit or 16-bit unsigned int.\");\n\t}\n\n\tif(TIFFGetFieldDefaulted(tif, TIFFTAG_PLANARCONFIG, &planarConfig) != 1)\n\t{\n\t\tTIFFClose(tif);\n\t\tthrow AeoException(\"Invalid TIFF: no planarConfig tag\");\n\t}\n\n\tif(TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLEFORMAT, &sampleFormat) != 1)\n\t{\n\t\tTIFFClose(tif);\n\t\tthrow AeoException(\"Invalid TIFF: no sampleFormat (e.g., uint) tag.\");\n\t}\n\n\tif(sampleFormat != SAMPLEFORMAT_UINT)\n\t{\n\t\tTIFFClose(tif);\n\t\tthrow AeoException(\"TIFF pixel datatype is not unsigned int.\");\n\t}\n\n\ttdata_t tbuf;\n\tuint32 row;\n\n\ttbuf = _TIFFmalloc(TIFFScanlineSize(tif));\n\tif((unsigned char *)tbuf == NULL)\n\t{\n\t\tTIFFClose(tif);\n\t\tthrow AeoException(\"Out of memory: TIFF scanline buffer.\");\n\t}\n\n\tif(buf == NULL)\n\t{\n\t\tbuf = new unsigned char[\n\t\t\t\timageWidth * imageHeight * numChannels * (bitDepth/8u)];\n\t\tif(buf==NULL)\n\t\t{\n\t\t\t_TIFFfree(tbuf);\n\t\t\tTIFFClose(tif);\n\t\t\tthrow AeoException(\"Out of memory: TIFF image buffer.\");\n\t\t}\n\t}\n\n\tswitch(planarConfig)\n\t{\n\tcase PLANARCONFIG_CONTIG:\n\t\tfor (row = 0; row < imageHeight; row++)\n\t\t{\n\t\t\tif(TIFFReadScanline(tif, tbuf, row) != 1)\n\t\t\t{\n\t\t\t\t_TIFFfree(tbuf);\n\t\t\t\tTIFFClose(tif);\n\t\t\t\tthrow AeoException(\"TIFF I/O Error.\");\n\t\t\t}\n\t\t\tmemcpy(buf+row*imageWidth*numChannels*(bitDepth/8u), tbuf,\n\t\t\t\t\timageWidth*numChannels*(bitDepth/8u));\n\t\t}\n\t\tbreak;\n\tcase PLANARCONFIG_SEPARATE:\n\t\tuint16 s, col;\n\n\t\tfor (s = 0; s < numChannels; s++)\n\t\t{\n\t\t\tfor (row = 0; row < imageHeight; row++)\n\t\t\t{\n\t\t\t\tif(TIFFReadScanline(tif, tbuf, row, s) != 1)\n\t\t\t\t{\n\t\t\t\t\t_TIFFfree(tbuf);\n\t\t\t\t\tTIFFClose(tif);\n\t\t\t\t\tthrow AeoException(\"TIFF I/O Error.\");\n\t\t\t\t}\n\t\t\t\tfor(col = 0; col < imageWidth; col++)\n\t\t\t\t{\n\t\t\t\t\tmemcpy(buf+(bitDepth/8u)*(s+numChannels*(col+imageWidth)),\n\t\t\t\t\t\t\ttbuf, (bitDepth/8u));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t_TIFFfree(tbuf);\n\t\tTIFFClose(tif);\n\t\tthrow AeoException(\"Invalid Planar Config in TIFF.\");\n\t}\n\n\t_TIFFfree(tbuf);\n\tTIFFClose(tif);\n\n\twidth = imageWidth;\n\theight = imageHeight;\n\tnum_components = numChannels;\n\n\tif(bitDepth==8) pix_fmt = GL_UNSIGNED_BYTE;\n\telse pix_fmt = GL_UNSIGNED_SHORT;\n\n\tendian = false; // libtiff automatically converts to native endianness\n\n\treturn buf;\n}",
    "void  GrFmtTiffReader::Close()\n{\n    if( m_tif )\n    {\n        TIFF* tif = (TIFF*)m_tif;\n        TIFFClose( tif );\n        m_tif = 0;\n    }\n}",
    "int DNGWriter::write(const char *filename, const Camera *camera,\n\t\t     const StreamConfiguration &config,\n\t\t     const ControlList &metadata,\n\t\t     [[maybe_unused]] const FrameBuffer *buffer,\n\t\t     const void *data)\n{\n\tconst ControlList &cameraProperties = camera->properties();\n\n\tconst auto it = formatInfo.find(config.pixelFormat);\n\tif (it == formatInfo.cend()) {\n\t\tstd::cerr << \"Unsupported pixel format\" << std::endl;\n\t\treturn -EINVAL;\n\t}\n\tconst FormatInfo *info = &it->second;\n\n\tTIFF *tif = TIFFOpen(filename, \"w\");\n\tif (!tif) {\n\t\tstd::cerr << \"Failed to open tiff file\" << std::endl;\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Scanline buffer, has to be large enough to store both a RAW scanline\n\t * or a thumbnail scanline. The latter will always be much smaller than\n\t * the former as we downscale by 16 in both directions.\n\t */\n\tstd::vector<uint8_t> scanline((config.size.width * info->bitsPerSample + 7) / 8);\n\n\ttoff_t rawIFDOffset = 0;\n\ttoff_t exifIFDOffset = 0;\n\n\t/*\n\t * Start with a thumbnail in IFD 0 for compatibility with TIFF baseline\n\t * readers, as required by the TIFF/EP specification. Tags that apply to\n\t * the whole file are stored here.\n\t */\n\tconst uint8_t version[] = { 1, 2, 0, 0 };\n\n\tTIFFSetField(tif, TIFFTAG_DNGVERSION, version);\n\tTIFFSetField(tif, TIFFTAG_DNGBACKWARDVERSION, version);\n\tTIFFSetField(tif, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);\n\tTIFFSetField(tif, TIFFTAG_MAKE, \"libcamera\");\n\n\tconst auto &model = cameraProperties.get(properties::Model);\n\tif (model) {\n\t\tTIFFSetField(tif, TIFFTAG_MODEL, model->c_str());\n\t\t/* \\todo set TIFFTAG_UNIQUECAMERAMODEL. */\n\t}\n\n\tTIFFSetField(tif, TIFFTAG_SOFTWARE, \"qcam\");\n\tTIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n\n\t/*\n\t * Thumbnail-specific tags. The thumbnail is stored as an RGB image\n\t * with 1/16 of the raw image resolution. Greyscale would save space,\n\t * but doesn't seem well supported by RawTherapee.\n\t */\n\tTIFFSetField(tif, TIFFTAG_SUBFILETYPE, FILETYPE_REDUCEDIMAGE);\n\tTIFFSetField(tif, TIFFTAG_IMAGEWIDTH, config.size.width / 16);\n\tTIFFSetField(tif, TIFFTAG_IMAGELENGTH, config.size.height / 16);\n\tTIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8);\n\tTIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n\tTIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n\tTIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 3);\n\tTIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\tTIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT);\n\n\t/*\n\t * Fill in some reasonable colour information in the DNG. We supply\n\t * the \"neutral\" colour values which determine the white balance, and the\n\t * \"ColorMatrix1\" which converts XYZ to (un-white-balanced) camera RGB.\n\t * Note that this is not a \"proper\" colour calibration for the DNG,\n\t * nonetheless, many tools should be able to render the colours better.\n\t */\n\tfloat neutral[3] = { 1, 1, 1 };\n\tMatrix3d wbGain = Matrix3d::identity();\n\t/* From http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html */\n\tconst Matrix3d rgb2xyz(0.4124564, 0.3575761, 0.1804375,\n\t\t\t       0.2126729, 0.7151522, 0.0721750,\n\t\t\t       0.0193339, 0.1191920, 0.9503041);\n\tMatrix3d ccm = Matrix3d::identity();\n\t/*\n\t * Pick a reasonable number eps to protect against singularities. It\n\t * should be comfortably larger than the point at which we run into\n\t * numerical trouble, yet smaller than any plausible gain that we might\n\t * apply to a colour, either explicitly or as part of the colour matrix.\n\t */\n\tconst double eps = 1e-2;\n\n\tconst auto &colourGains = metadata.get(controls::ColourGains);\n\tif (colourGains) {\n\t\tif ((*colourGains)[0] > eps && (*colourGains)[1] > eps) {\n\t\t\twbGain = Matrix3d::diag((*colourGains)[0], 1, (*colourGains)[1]);\n\t\t\tneutral[0] = 1.0 / (*colourGains)[0]; /* red */\n\t\t\tneutral[2] = 1.0 / (*colourGains)[1]; /* blue */\n\t\t}\n\t}\n\n\tconst auto &ccmControl = metadata.get(controls::ColourCorrectionMatrix);\n\tif (ccmControl) {\n\t\tMatrix3d ccmSupplied(*ccmControl);\n\t\tif (ccmSupplied.determinant() > eps)\n\t\t\tccm = ccmSupplied;\n\t}\n\n\t/*\n\t * rgb2xyz is known to be invertible, and we've ensured above that both\n\t * the ccm and wbGain matrices are non-singular, so the product of all\n\t * three is guaranteed to be invertible too.\n\t */\n\tMatrix3d colorMatrix1 = (rgb2xyz * ccm * wbGain).inverse();\n\n\tTIFFSetField(tif, TIFFTAG_COLORMATRIX1, 9, colorMatrix1.m);\n\tTIFFSetField(tif, TIFFTAG_ASSHOTNEUTRAL, 3, neutral);\n\n\t/*\n\t * Reserve space for the SubIFD and ExifIFD tags, pointing to the IFD\n\t * for the raw image and EXIF data respectively. The real offsets will\n\t * be set later.\n\t */\n\tTIFFSetField(tif, TIFFTAG_SUBIFD, 1, &rawIFDOffset);\n\tTIFFSetField(tif, TIFFTAG_EXIFIFD, exifIFDOffset);\n\n\t/* Write the thumbnail. */\n\tconst uint8_t *row = static_cast<const uint8_t *>(data);\n\tfor (unsigned int y = 0; y < config.size.height / 16; y++) {\n\t\tinfo->thumbScanline(*info, scanline.data(), row,\n\t\t\t\t    config.size.width / 16, config.stride);\n\n\t\tif (TIFFWriteScanline(tif, scanline.data(), y, 0) != 1) {\n\t\t\tstd::cerr << \"Failed to write thumbnail scanline\"\n\t\t\t\t  << std::endl;\n\t\t\tTIFFClose(tif);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\trow += config.stride * 16;\n\t}\n\n\tTIFFWriteDirectory(tif);\n\n\t/*\n\t * Workaround for a bug introduced in libtiff version 4.5.1 and no fix\n\t * released. In these versions the CFA* tags were missing in the field\n\t * info.\n\t * Introduced by: https://gitlab.com/libtiff/libtiff/-/commit/738e04099b13192bb1f654e74e9b5829313f3161\n\t * Fixed by: https://gitlab.com/libtiff/libtiff/-/commit/49856998c3d82e65444b47bb4fb11b7830a0c2be\n\t */\n\tif (!TIFFFindField(tif, TIFFTAG_CFAREPEATPATTERNDIM, TIFF_ANY)) {\n\t\tstatic const TIFFFieldInfo infos[] = {\n\t\t\t{ TIFFTAG_CFAREPEATPATTERNDIM, 2, 2, TIFF_SHORT, FIELD_CUSTOM,\n\t\t\t  1, 0, const_cast<char *>(\"CFARepeatPatternDim\") },\n\t\t\t{ TIFFTAG_CFAPATTERN, -1, -1, TIFF_BYTE, FIELD_CUSTOM,\n\t\t\t  1, 1, const_cast<char *>(\"CFAPattern\") },\n\t\t};\n\t\tTIFFMergeFieldInfo(tif, infos, 2);\n\t}\n\n\t/* Create a new IFD for the RAW image. */\n\tconst uint16_t cfaRepeatPatternDim[] = { 2, 2 };\n\tconst uint8_t cfaPlaneColor[] = {\n\t\tCFAPatternRed,\n\t\tCFAPatternGreen,\n\t\tCFAPatternBlue\n\t};\n\n\tTIFFSetField(tif, TIFFTAG_SUBFILETYPE, 0);\n\tTIFFSetField(tif, TIFFTAG_IMAGEWIDTH, config.size.width);\n\tTIFFSetField(tif, TIFFTAG_IMAGELENGTH, config.size.height);\n\tTIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, info->bitsPerSample);\n\tTIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n\tTIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_CFA);\n\tTIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 1);\n\tTIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\tTIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT);\n\tTIFFSetField(tif, TIFFTAG_CFAREPEATPATTERNDIM, cfaRepeatPatternDim);\n\tif (TIFFLIB_VERSION < 20201219)\n\t\tTIFFSetField(tif, TIFFTAG_CFAPATTERN, info->pattern);\n\telse\n\t\tTIFFSetField(tif, TIFFTAG_CFAPATTERN, 4, info->pattern);\n\tTIFFSetField(tif, TIFFTAG_CFAPLANECOLOR, 3, cfaPlaneColor);\n\tTIFFSetField(tif, TIFFTAG_CFALAYOUT, 1);\n\n\tconst uint16_t blackLevelRepeatDim[] = { 2, 2 };\n\tfloat blackLevel[] = { 0.0f, 0.0f, 0.0f, 0.0f };\n\tuint32_t whiteLevel = (1 << info->bitsPerSample) - 1;\n\n\tconst auto &blackLevels = metadata.get(controls::SensorBlackLevels);\n\tif (blackLevels) {\n\t\tSpan<const int32_t, 4> levels = *blackLevels;\n\n\t\t/*\n\t\t * The black levels control is specified in R, Gr, Gb, B order.\n\t\t * Map it to the TIFF tag that is specified in CFA pattern\n\t\t * order.\n\t\t */\n\t\tunsigned int green = (info->pattern[0] == CFAPatternRed ||\n\t\t\t\t      info->pattern[1] == CFAPatternRed)\n\t\t\t\t   ? 0 : 1;\n\n\t\tfor (unsigned int i = 0; i < 4; ++i) {\n\t\t\tunsigned int level;\n\n\t\t\tswitch (info->pattern[i]) {\n\t\t\tcase CFAPatternRed:\n\t\t\t\tlevel = levels[0];\n\t\t\t\tbreak;\n\t\t\tcase CFAPatternGreen:\n\t\t\t\tlevel = levels[green + 1];\n\t\t\t\tgreen = (green + 1) % 2;\n\t\t\t\tbreak;\n\t\t\tcase CFAPatternBlue:\n\t\t\tdefault:\n\t\t\t\tlevel = levels[3];\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Map the 16-bit value to the bits per sample range. */\n\t\t\tblackLevel[i] = level >> (16 - info->bitsPerSample);\n\t\t}\n\t}\n\n\tTIFFSetField(tif, TIFFTAG_BLACKLEVELREPEATDIM, &blackLevelRepeatDim);\n\tTIFFSetField(tif, TIFFTAG_BLACKLEVEL, 4, &blackLevel);\n\tTIFFSetField(tif, TIFFTAG_WHITELEVEL, 1, &whiteLevel);\n\n\t/* Write RAW content. */\n\trow = static_cast<const uint8_t *>(data);\n\tfor (unsigned int y = 0; y < config.size.height; y++) {\n\t\tinfo->packScanline(scanline.data(), row, config.size.width);\n\n\t\tif (TIFFWriteScanline(tif, scanline.data(), y, 0) != 1) {\n\t\t\tstd::cerr << \"Failed to write RAW scanline\"\n\t\t\t\t  << std::endl;\n\t\t\tTIFFClose(tif);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\trow += config.stride;\n\t}\n\n\t/* Checkpoint the IFD to retrieve its offset, and write it out. */\n\tTIFFCheckpointDirectory(tif);\n\trawIFDOffset = TIFFCurrentDirOffset(tif);\n\tTIFFWriteDirectory(tif);\n\n\t/* Create a new IFD for the EXIF data and fill it. */\n\tTIFFCreateEXIFDirectory(tif);\n\n\t/* Store creation time. */\n\ttime_t rawtime;\n\tstruct tm *timeinfo;\n\tchar strTime[20];\n\n\ttime(&rawtime);\n\ttimeinfo = localtime(&rawtime);\n\tstrftime(strTime, 20, \"%Y:%m:%d %H:%M:%S\", timeinfo);\n\n\t/*\n\t * \\todo Handle timezone information by setting OffsetTimeOriginal and\n\t * OffsetTimeDigitized once libtiff catches up to the specification and\n\t * has EXIFTAG_ defines to handle them.\n\t */\n\tTIFFSetField(tif, EXIFTAG_DATETIMEORIGINAL, strTime);\n\tTIFFSetField(tif, EXIFTAG_DATETIMEDIGITIZED, strTime);\n\n\tconst auto &analogGain = metadata.get(controls::AnalogueGain);\n\tif (analogGain) {\n\t\tuint16_t iso = std::min(std::max(*analogGain * 100, 0.0f), 65535.0f);\n\t\tTIFFSetField(tif, EXIFTAG_ISOSPEEDRATINGS, 1, &iso);\n\t}\n\n\tconst auto &exposureTime = metadata.get(controls::ExposureTime);\n\tif (exposureTime)\n\t\tTIFFSetField(tif, EXIFTAG_EXPOSURETIME, *exposureTime / 1e6);\n\n\tTIFFWriteCustomDirectory(tif, &exifIFDOffset);\n\n\t/* Update the IFD offsets and close the file. */\n\tTIFFSetDirectory(tif, 0);\n\tTIFFSetField(tif, TIFFTAG_SUBIFD, 1, &rawIFDOffset);\n\tTIFFSetField(tif, TIFFTAG_EXIFIFD, exifIFDOffset);\n\tTIFFWriteDirectory(tif);\n\n\tTIFFClose(tif);\n\n\treturn 0;\n}",
    "LibTiffReader::~LibTiffReader() {\n    if(this->_is_open)\n\t    TIFFClose(this->_tiff);\n}",
    "void LibTiffReader::recycle() {\n    if(this->_is_open)\n\t    TIFFClose(this->_tiff);\n    this->_is_open = false;\n    this->_width = -1;\n    this->_height = -1;\n    this->_depth = -1;\n    this->_channels = -1;\n}",
    "void LibTiffWriter::_write(Image* im, std::string filename) {\n        struct tiff* img_out;\n\n        int width = im->width();\n        int height = im->height();\n        int channels = im->channels();\n\n\n\t\t/* Check if color profile is implemented. */\n\t\tswitch(im->getColorProfile()) {\n\t\t\tcase none: case ColorSpace::ProPhoto: case ColorSpace::Adobe_RGB_1998:\n\t\t\t\tbreak;\n\t\t\tdefault: case ColorSpace::sRGB: case ColorSpace::Wide_Gamut_RGB: \n\t\t\t\tthrow std::logic_error(\"[LibTiffWriter] Color profile not implemented.\");\n\t\t}\n\n\n\t\tcv::Mat im_16u;\n\t\tim->getMat().convertTo(im_16u, CV_16U, 0xFFFF);\n        uint16_t* bitmap = (uint16_t*) im_16u.data;\n\n\n\n        /* ==============[ Open tiff file for writing ]================== */\n\n\t\timg_out = TIFFOpen(filename.c_str(), \"w\");\n\t\tif(!img_out) \n            throw LibTiff_OpenFileFailed();\n\n\n\n\t\t/* =================[ Write tiff header tags ]================== */\n\n\t\tTIFFSetField(img_out, TIFFTAG_IMAGEWIDTH, width);\n\t\tTIFFSetField(img_out, TIFFTAG_IMAGELENGTH, height);\n\n\t\t/* Set the number of channels. */\n\t\tTIFFSetField(img_out, TIFFTAG_SAMPLESPERPIXEL, channels);\n\n\t\t/* We want 16 bits. */\n\t\tTIFFSetField(img_out, TIFFTAG_BITSPERSAMPLE, 16);\n\t\t\n\t\t/* Image rotation. */\n\t\tTIFFSetField(img_out, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n\n\t\t/* Write all channel data in one array (a bitmap) instead of separating the channels. */\n\t\tTIFFSetField(img_out, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\n\t\t/* Indicate type of image. */\n\t\tif(channels == 3)\n\t\t\tTIFFSetField(img_out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n\t\telse if(channels == 1)\n\t\t\tTIFFSetField(img_out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n\t\telse {\n\t\t\tTIFFSetField(img_out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n\t\t\tuint16_t tags[16] = {EXTRASAMPLE_UNSPECIFIED};\n\t\t\tTIFFSetField(img_out, TIFFTAG_EXTRASAMPLES, channels - 1, tags);\n\t\t}\n\n\t\t/* Set color profile. */\n\t\tswitch(im->getColorProfile()) {\n\n\t\t\tcase none: \n\t\t\t\tbreak;\n\n\t\t\tcase ColorSpace::ProPhoto:\n\t\t\t\tTIFFSetField(img_out, TIFFTAG_ICCPROFILE, ProPhoto_icm_size, ProPhoto_icm_data);\n\t\t\t\tbreak;\n\n\t\t\tcase ColorSpace::Adobe_RGB_1998:\n\t\t\t\tTIFFSetField(img_out, TIFFTAG_ICCPROFILE, AdobeRGB1998_icc_size, AdobeRGB1998_icc_data);\n\t\t\t\tbreak;\n\n\t\t\tcase ColorSpace::sRGB:\n\t\t\tcase ColorSpace::Wide_Gamut_RGB:\n\t\t\tdefault: throw std::logic_error(\"[LibTiffWriter] Invalid color profile.\");\n\t\t}\n\n\t\t/* Set custom application tags as artist. */\n\t\ttry {\n\t\t\tstd::string t = this->getCustomTag(im);\n\t\t\tTIFFSetField(img_out, TIFFTAG_ARTIST, t.c_str());\n\t\t}\n\t\tcatch(...) {\n\t\t\tstd::cerr << \"[LibTiffWriter] Warning: could not write custom tag.\\n\";\n\t\t}\n\n\t\t/* Set software field. */\n\t\tstd::string software_version = std::string(\"BTRGB v\") + PROJECT_VERSION;\n\t\tTIFFSetField(img_out, TIFFTAG_SOFTWARE, software_version.c_str());\n\n\t\t/* Set make and model if available. */\n\t\tbtrgb::exif tags = im->getExifTags();\n\t\tif(tags.make != btrgb::UNSPECIFIED)\n\t\t\tTIFFSetField(img_out, TIFFTAG_MAKE, tags.make.c_str());\n\t\tif(tags.model != btrgb::UNSPECIFIED)\n\t\t\tTIFFSetField(img_out, TIFFTAG_MODEL, tags.model.c_str());\n\n\t\t/* The written data needs to be broken up into \"Strips\" to make buffering easier \n\t\t* for TIFF readers. Rows-per-strip needs to be tagged, this is the number of \n\t\t* physical pixel rows of the image written in each strip. A \"row\" here is a bitmap\n\t\t* row where the length is <image width> X <number of channels>. A strip size of 8kB is \n\t\t* recommended (I wonder if this is for computing standars/capabilities wayback \n\t\t* when). Anyway, since the data type of the return value and estimate rows-per-strip \n\t\t* values are uint32: TIFFDefaultStripSize will not give strips that contain a fraction \n\t\t* of a row, and our image rows are more than 8kB, so the closest to the recommended we \n\t\t* can do is one row per strip. */\n\t\t/*\n\t\tint rows_per_strip = TIFFDefaultStripSize(img_out, 1);\n\t\tTIFFSetField(img_out, TIFFTAG_ROWSPERSTRIP, rows_per_strip);\n\t\t*/\n\t\tTIFFSetField(img_out, TIFFTAG_ROWSPERSTRIP, 1);\n\n\n\n        /* =================[ Write bitmap to file ]================== */\n\n\t\t/* The buffer for each strip to be copied to and then written to disk. \n\t\t* If rows-per-strip is one, scanline size should equate to the number\n\t\t* of bytes for one physical pixel row of the image, and the number of\n\t\t* strips should equal the height of the image. */\n\t\t/*\n\t\ttmsize_t scanline_size = TIFFScanlineSize(img_out);\n\t\tunsigned short* sample_row = (unsigned short *) _TIFFmalloc(scanline_size);\n\t\tif (sample_row)\n\t\t\t_TIFFfree(sample_row);\n\t\t*/\n\n\t\tuint32_t row, row_size = width * channels;\n        void* row_memory_address;\n\n\t\t/* Write all rows to file.\n         * ASSUMPTION: The \"rows per strip\" tiff tag is set to one. */\n\t\tfor( row = 0; row < height; row++) {\n\t\t\t\n\t\t\trow_memory_address = bitmap + row * row_size;\n\n            /* Write row to file. */\n\t\t\tif (TIFFWriteScanline(img_out, row_memory_address, row, 0) < 0) {\n                TIFFClose(img_out);\n\t\t\t\tthrow LibTiff_WriteStripFailed();\n            }\n\n\t\t}\n\n\n\n\t\t/* ==============[ Close tiff file ]================== */\n\t\tTIFFClose(img_out);\n    }",
    "void TIFFBuildOverviews( const char * pszTIFFFilename,\n                         int nOverviews, int * panOvList,\n                         int bUseSubIFDs )\n\n{\n    RawBlockedImage\t**papoRawBIs;\n    uint32\t\tnXSize, nYSize, nBlockXSize, nBlockYSize;\n    uint16\t\tnBitsPerPixel, nPhotometric, nCompressFlag, nSamples,\n                        nPlanarConfig;\n    int\t\t\tbTiled, nSXOff, nSYOff, i, iSample;\n    unsigned char\t*pabySrcTile;\n    TIFF\t\t*hTIFF;\n    uint16\t\t*panRedMap, *panGreenMap, *panBlueMap;\n\n/* -------------------------------------------------------------------- */\n/*      Get the base raster size.                                       */\n/* -------------------------------------------------------------------- */\n    hTIFF = TIFFOpen( pszTIFFFilename, \"r\" );\n    if( hTIFF == NULL )\n    {\n        fprintf( stderr, \"TIFFOpen(%s) failed.\\n\", pszTIFFFilename );\n        exit( 1 );\n    }\n\n    TIFFGetField( hTIFF, TIFFTAG_IMAGEWIDTH, &nXSize );\n    TIFFGetField( hTIFF, TIFFTAG_IMAGELENGTH, &nYSize );\n\n    TIFFGetField( hTIFF, TIFFTAG_BITSPERSAMPLE, &nBitsPerPixel );\n    TIFFGetField( hTIFF, TIFFTAG_SAMPLESPERPIXEL, &nSamples );\n    TIFFGetField( hTIFF, TIFFTAG_PLANARCONFIG, &nPlanarConfig );\n\n    TIFFGetField( hTIFF, TIFFTAG_PHOTOMETRIC, &nPhotometric );\n    TIFFGetField( hTIFF, TIFFTAG_COMPRESSION, &nCompressFlag );\n\n    if( nBitsPerPixel < 8 )\n    {\n        TIFFError( \"TIFFBuildOverviews\",\n                   \"File `%s' has samples of %d bits per sample.  Sample\\n\"\n                   \"sizes of less than 8 bits per sample are not supported.\\n\",\n                   pszTIFFFilename, nBitsPerPixel );\n        return;\n    }\n    \n/* -------------------------------------------------------------------- */\n/*      Get the base raster block size.                                 */\n/* -------------------------------------------------------------------- */\n    if( TIFFGetField( hTIFF, TIFFTAG_ROWSPERSTRIP, &(nBlockYSize) ) )\n    {\n        nBlockXSize = nXSize;\n        bTiled = FALSE;\n    }\n    else\n    {\n        TIFFGetField( hTIFF, TIFFTAG_TILEWIDTH, &nBlockXSize );\n        TIFFGetField( hTIFF, TIFFTAG_TILELENGTH, &nBlockYSize );\n        bTiled = TRUE;\n    }\n\n/* -------------------------------------------------------------------- */\n/*\tCapture the pallette if there is one.\t\t\t\t*/\n/* -------------------------------------------------------------------- */\n    if( TIFFGetField( hTIFF, TIFFTAG_COLORMAP,\n                      &panRedMap, &panGreenMap, &panBlueMap ) )\n    {\n        uint16\t\t*panRed2, *panGreen2, *panBlue2;\n\n        panRed2 = (uint16 *) calloc(2,256);\n        panGreen2 = (uint16 *) calloc(2,256);\n        panBlue2 = (uint16 *) calloc(2,256);\n\n        memcpy( panRed2, panRedMap, 512 );\n        memcpy( panGreen2, panGreenMap, 512 );\n        memcpy( panBlue2, panBlueMap, 512 );\n\n        panRedMap = panRed2;\n        panGreenMap = panGreen2;\n        panBlueMap = panBlue2;\n    }\n    else\n    {\n        panRedMap = panGreenMap = panBlueMap = NULL;\n    }\n        \n/* -------------------------------------------------------------------- */\n/*      Initialize the overview raw layers                              */\n/* -------------------------------------------------------------------- */\n    papoRawBIs = (RawBlockedImage **)\n        calloc(nOverviews*nSamples,sizeof(void*));\n\n    for( i = 0; i < nOverviews; i++ )\n    {\n        int\tnOXSize, nOYSize, nOBlockXSize, nOBlockYSize;\n\n        nOXSize = (nXSize + panOvList[i] - 1) / panOvList[i];\n        nOYSize = (nYSize + panOvList[i] - 1) / panOvList[i];\n\n        nOBlockXSize = MIN((int)nBlockXSize,nOXSize);\n        nOBlockYSize = MIN((int)nBlockYSize,nOYSize);\n\n        if( bTiled )\n        {\n            if( (nOBlockXSize % 16) != 0 )\n                nOBlockXSize = nOBlockXSize + 16 - (nOBlockXSize % 16);\n            \n            if( (nOBlockYSize % 16) != 0 )\n                nOBlockYSize = nOBlockYSize + 16 - (nOBlockYSize % 16);\n        }\n\n        for( iSample = 0; iSample < nSamples; iSample++ )\n        {\n            papoRawBIs[i*nSamples + iSample] =\n                new RawBlockedImage( nOXSize, nOYSize,\n                                     nOBlockXSize, nOBlockYSize,\n                                     nBitsPerPixel );\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Allocate a buffer to hold a source block.                       */\n/* -------------------------------------------------------------------- */\n    if( bTiled )\n        pabySrcTile = (unsigned char *) malloc(TIFFTileSize(hTIFF));\n    else\n        pabySrcTile = (unsigned char *) malloc(TIFFStripSize(hTIFF));\n    \n/* -------------------------------------------------------------------- */\n/*      Loop over the source raster, applying data to the               */\n/*      destination raster.                                             */\n/* -------------------------------------------------------------------- */\n    for( nSYOff = 0; nSYOff < (int) nYSize; nSYOff += nBlockYSize )\n    {\n        for( nSXOff = 0; nSXOff < (int) nXSize; nSXOff += nBlockXSize )\n        {\n            /*\n             * Read and resample into the various overview images.\n             */\n            \n            TIFF_ProcessFullResBlock( hTIFF, nPlanarConfig,\n                                      nOverviews, panOvList,\n                                      nBitsPerPixel, nSamples, papoRawBIs,\n                                      nSXOff, nSYOff, pabySrcTile,\n                                      nBlockXSize, nBlockYSize );\n        }\n    }\n\n    free( pabySrcTile );\n\n    TIFFClose( hTIFF );\n\n/* ==================================================================== */\n/*      We now have the overview rasters built, and held as             */\n/*      RawBlockedImage's.  Now we need to write them to new TIFF       */\n/*      layers.                                                         */\n/* ==================================================================== */\n    hTIFF = TIFFOpen( pszTIFFFilename, \"a\" );\n    if( hTIFF == NULL )\n    {\n        fprintf( stderr,\n                 \"TIFFOpen(%s,\\\"a\\\") failed.  No overviews written.\\n\"\n                 \"Do you have write permissions on that file?\\n\",\n                 pszTIFFFilename );\n    }\n    else\n    {\n        for( i = 0; i < nOverviews; i++ )\n        {\n            TIFF_WriteOverview( hTIFF, nSamples, papoRawBIs + i*nSamples,\n                                bTiled, nCompressFlag, nPhotometric,\n                                panRedMap, panGreenMap, panBlueMap,\n                                bUseSubIFDs );\n        }\n        \n        TIFFClose( hTIFF );\n    }\n    \n/* -------------------------------------------------------------------- */\n/*      Cleanup the rawblockedimage files.                              */\n/* -------------------------------------------------------------------- */\n    for( i = 0; i < nOverviews*nSamples; i++ )\n    {\n        delete papoRawBIs[i];\n    }\n\n    if( papoRawBIs != NULL )\n        free( papoRawBIs );\n\n    if( panRedMap != NULL )\n    {\n        free( panRedMap );\n        free( panGreenMap );\n        free( panBlueMap );\n    }\n}",
    "void PdfImage::LoadFromTiff( const char* pszFilename )\n{\n    TIFFSetErrorHandler(TIFFErrorWarningHandler);\n    TIFFSetWarningHandler(TIFFErrorWarningHandler);\n    \n    if( !pszFilename )\n    {\n        PODOFO_RAISE_ERROR( ePdfError_InvalidHandle );\n    }\n\n    TIFF* hInfile = TIFFOpen(pszFilename, \"rb\");\n\n    if( !hInfile )\n    {\n        PODOFO_RAISE_ERROR_INFO( ePdfError_FileNotFound, pszFilename );\n    }\n\n    int32 row, width, height;\n    uint16 samplesPerPixel, bitsPerSample;\n    uint16* sampleInfo;\n    uint16 extraSamples;\n    uint16 planarConfig, photoMetric, orientation;\n    int32 resolutionUnit;\n\n    TIFFGetField(hInfile,\t   TIFFTAG_IMAGEWIDTH,\t\t&width);\n    TIFFGetField(hInfile,\t   TIFFTAG_IMAGELENGTH,\t\t&height);\n    TIFFGetFieldDefaulted(hInfile, TIFFTAG_BITSPERSAMPLE,\t&bitsPerSample);\n    TIFFGetFieldDefaulted(hInfile, TIFFTAG_SAMPLESPERPIXEL,     &samplesPerPixel);\n    TIFFGetFieldDefaulted(hInfile, TIFFTAG_PLANARCONFIG,\t&planarConfig);\n    TIFFGetFieldDefaulted(hInfile, TIFFTAG_PHOTOMETRIC,\t\t&photoMetric);\n    TIFFGetFieldDefaulted(hInfile, TIFFTAG_EXTRASAMPLES,\t&extraSamples, &sampleInfo);\n    TIFFGetFieldDefaulted(hInfile, TIFFTAG_ORIENTATION,\t\t&orientation);\n\t\n    resolutionUnit = 0;\n    float resX;\n    float resY;\n    TIFFGetFieldDefaulted(hInfile, TIFFTAG_XRESOLUTION,\t\t&resX);\n    TIFFGetFieldDefaulted(hInfile, TIFFTAG_YRESOLUTION,\t\t&resY);\n    TIFFGetFieldDefaulted(hInfile, TIFFTAG_RESOLUTIONUNIT,\t&resolutionUnit);\n\n    int colorChannels = samplesPerPixel - extraSamples;\n\n    int bitsPixel = bitsPerSample * samplesPerPixel;\n\n    // TODO: implement special cases\n    if( TIFFIsTiled(hInfile) )\n    {\n        TIFFClose(hInfile);\n        PODOFO_RAISE_ERROR( ePdfError_UnsupportedImageFormat );\n    }\n\t\t\n    if ( planarConfig != PLANARCONFIG_CONTIG && colorChannels != 1 )\n    {\n        TIFFClose(hInfile);\n        PODOFO_RAISE_ERROR( ePdfError_UnsupportedImageFormat );\n    }\n\n\tif ( orientation != ORIENTATION_TOPLEFT )\n    {\n        TIFFClose(hInfile);\n        PODOFO_RAISE_ERROR( ePdfError_UnsupportedImageFormat );\n    }\n\n\tswitch(photoMetric)\n\t{\n\t\tcase PHOTOMETRIC_MINISBLACK:\n\t\t{\n\t\t\tif( bitsPixel == 1 )\n\t\t\t{\n\t\t\t\tPdfArray decode;\n\t\t\t\tdecode.insert( decode.end(), PdfVariant( static_cast<pdf_int64>(0) ) );\n\t\t\t\tdecode.insert( decode.end(), PdfVariant( static_cast<pdf_int64>(1) ) );\n\t\t\t\tthis->GetObject()->GetDictionary().AddKey( PdfName(\"Decode\"), decode );\n\t\t\t\tthis->GetObject()->GetDictionary().AddKey( PdfName(\"ImageMask\"), PdfVariant( true ) );\n\t\t\t\tthis->GetObject()->GetDictionary().RemoveKey( PdfName(\"ColorSpace\") );\n\t\t\t}\n\t\t\telse if ( bitsPixel == 8)\n\t            SetImageColorSpace(ePdfColorSpace_DeviceGray);\n\t\t\telse\n\t\t\t{\n\t\t\t\tTIFFClose(hInfile);\n\t\t\t\tPODOFO_RAISE_ERROR( ePdfError_UnsupportedImageFormat );\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase PHOTOMETRIC_MINISWHITE:\n\t\t{\n\t\t\tif( bitsPixel == 1 )\n\t\t\t{\n\t\t\t\tPdfArray decode;\n\t\t\t\tdecode.insert( decode.end(), PdfVariant( static_cast<pdf_int64>(1) ) );\n\t\t\t\tdecode.insert( decode.end(), PdfVariant( static_cast<pdf_int64>(0) ) );\n\t\t\t\tthis->GetObject()->GetDictionary().AddKey( PdfName(\"Decode\"), decode );\n\t\t\t\tthis->GetObject()->GetDictionary().AddKey( PdfName(\"ImageMask\"), PdfVariant( true ) );\n\t\t\t\tthis->GetObject()->GetDictionary().RemoveKey( PdfName(\"ColorSpace\") );\n\t\t\t}\n\t\t\telse if ( bitsPixel == 8)\n\t            SetImageColorSpace(ePdfColorSpace_DeviceGray);\n\t\t\telse\n\t\t\t{\n\t\t\t\tTIFFClose(hInfile);\n\t\t\t\tPODOFO_RAISE_ERROR( ePdfError_UnsupportedImageFormat );\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase PHOTOMETRIC_RGB:\n            if ( bitsPixel != 24 )\n\t\t\t{\n\t\t\t\tTIFFClose(hInfile);\n\t\t\t\tPODOFO_RAISE_ERROR( ePdfError_UnsupportedImageFormat );\n\t\t\t}\n\t\t\tSetImageColorSpace(ePdfColorSpace_DeviceRGB);\n\t\tbreak;\n\n\t\tcase PHOTOMETRIC_SEPARATED: \n\t\t\tif( bitsPixel != 32)\n\t\t\t{\n\t\t\t\tTIFFClose(hInfile);\n\t\t\t\tPODOFO_RAISE_ERROR( ePdfError_UnsupportedImageFormat );\n\t\t\t}\n            SetImageColorSpace(ePdfColorSpace_DeviceCMYK);\n\t\tbreak;\n\n\t\tcase PHOTOMETRIC_PALETTE:\n\t\t{\n\t\t\tint numColors = (1 << bitsPixel);\n\n\t\t\tPdfArray decode;\n\t\t\tdecode.insert( decode.end(), PdfVariant( static_cast<pdf_int64>(0) ) );\n\t\t\tdecode.insert( decode.end(), PdfVariant( static_cast<pdf_int64>(numColors-1) ) );\n\t\t\tthis->GetObject()->GetDictionary().AddKey( PdfName(\"Decode\"), decode );\n\n\t\t\tuint16 * rgbRed;\n\t\t\tuint16 * rgbGreen;\n\t\t\tuint16 * rgbBlue;\n\t\t\tTIFFGetField(hInfile, TIFFTAG_COLORMAP, &rgbRed, &rgbGreen, &rgbBlue);\n\n\t\t\tchar *datap = new char[numColors*3];\n\n\t\t\tfor ( int clr = 0; clr < numColors; clr++ )\n\t\t\t{\n\t\t\t\tdatap[3*clr+0] = rgbRed[clr]/257;\n\t\t\t\tdatap[3*clr+1] = rgbGreen[clr]/257;\n\t\t\t\tdatap[3*clr+2] = rgbBlue[clr]/257;\n\t\t\t}\n\t\t    PdfMemoryInputStream stream( datap, numColors*3 );\n\n\t\t    // Create a colorspace object\n\t\t    PdfObject* pIdxObject = this->GetObject()->GetOwner()->CreateObject();\n\t\t\tpIdxObject->GetStream()->Set( &stream );\n    \n\t\t    // Add the colorspace to our image\n\t\t    PdfArray array;\n\t\t    array.push_back( PdfName(\"Indexed\") );\n\t\t    array.push_back( PdfName(\"DeviceRGB\") );\n            array.push_back( static_cast<pdf_int64>(numColors-1) );\n\t\t    array.push_back( pIdxObject->Reference() );\n\t\t    this->GetObject()->GetDictionary().AddKey( PdfName(\"ColorSpace\"), array );\n\n\t\t\tdelete[] datap;\n\t\t}\n\t\tbreak;\n\n\t\tdefault:\n\t        TIFFClose(hInfile);\n\t        PODOFO_RAISE_ERROR( ePdfError_UnsupportedImageFormat );\n\t\tbreak;\n\t}\n\n\tint32 scanlineSize = TIFFScanlineSize(hInfile);\n    long bufferSize = scanlineSize * height;\n    char *buffer = new char[bufferSize];\n    if( !buffer ) \n    {\n        TIFFClose(hInfile);\n        PODOFO_RAISE_ERROR( ePdfError_OutOfMemory );\n    }\n\n    for(row = 0; row < height; row++)\n    {\n        if(TIFFReadScanline(hInfile,\n                            &buffer[row * scanlineSize],\n                            row) == (-1))\n        {\n            TIFFClose(hInfile);\n            PODOFO_RAISE_ERROR( ePdfError_UnsupportedImageFormat );\n        }\n    }\n\n\tPdfMemoryInputStream stream(buffer, bufferSize);\n\n    SetImageData(static_cast<unsigned int>(width), \n                 static_cast<unsigned int>(height),\n                 static_cast<unsigned int>(bitsPerSample), \n                 &stream);\n\n    delete[] buffer;\n\n    TIFFClose(hInfile);\n}",
    "bool ZLWin32ImageManager::tiffConvert(const std::string &stringData, ZLWin32ImageData &data) const {\n\tTIFFReader reader(stringData);\n\tTIFF *tiff = TIFFClientOpen(\"ZLWin32ImageManager\", \"rM\", &reader, TIFFReader::read, TIFFReader::write, TIFFReader::seek, TIFFReader::close, TIFFReader::size, TIFFReader::map, TIFFReader::unmap);\n\tif (tiff == 0) {\n\t\treturn false;\n\t}\n\n\tint width, height;\n\tif (!TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, &width) ||\n\t\t\t!TIFFGetField(tiff, TIFFTAG_IMAGELENGTH, &height)) {\n\t\tTIFFClose(tiff);\n\t\treturn false;\n\t}\n\n\tdata.init(width, height, true, 0);\n\n\tTIFFReadRGBAImage(tiff, width, height, (uint32*)data.myArray, 1);\n\tdata.bgr2rgb();\n\n\tTIFFClose(tiff);\n\treturn true;\n}",
    "ImageReaderTIFF::~ImageReaderTIFF()\n{\n\tif( m_Tiff != NULL ) {\n\t\tTIFFClose(m_Tiff);\n\t\tm_Tiff = NULL;\n\t}\n\tdelete m_TempSource;\n\tm_TempSource = NULL;\n\tdelete m_TempStorage;\n\tm_TempStorage = NULL;\n}",
    "int\nOutputTIFF::addFrame ( void* frame, const char* timestampStr,\n\t\tint64_t expTime __attribute__((unused)), const char* commentStr,\n\t\tFRAME_METADATA* metadata __attribute__((unused)),\n\t\tTIMER_METADATA* timerData __attribute__((unused)))\n{\n  int            ret, i;\n  TIFF*          handle;\n  void*          buffer = frame;\n  unsigned char* s;\n  unsigned char* t;\n\tchar\t\t\t\t\t\ttiffField[128];\n\n  filenameRoot = getNewFilename();\n  fullSaveFilePath = filenameRoot + \".tiff\";\n\n  if (!( handle = TIFFOpen ( fullSaveFilePath.toStdString().c_str(), \"w\" ))) {\n    qWarning() << \"open of \" << fullSaveFilePath << \" failed\";\n    // Need this or we'll never stop\n    frameCount++;\n    return -1;\n  }\n\n  TIFFSetField ( handle, TIFFTAG_IMAGEWIDTH, xSize );\n  TIFFSetField ( handle, TIFFTAG_IMAGELENGTH, ySize );\n  TIFFSetField ( handle, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG );\n  TIFFSetField ( handle, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT );\n  TIFFSetField ( handle, TIFFTAG_ROWSPERSTRIP, ySize );\n\n  if ( colour ) {\n    TIFFSetField ( handle, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB );\n    TIFFSetField ( handle, TIFFTAG_SAMPLESPERPIXEL, 3 );\n  } else {\n    TIFFSetField ( handle, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK );\n    TIFFSetField ( handle, TIFFTAG_SAMPLESPERPIXEL, 1 );\n  }\n  TIFFSetField ( handle, TIFFTAG_BITSPERSAMPLE, pixelDepth );\n\n\t( void ) snprintf ( tiffField, 128, \"%s %s\", applicationName,\n\t\t\tapplicationVersion );\n  TIFFSetField ( handle, TIFFTAG_SOFTWARE, tiffField );\n  TIFFSetField ( handle, TIFFTAG_DATETIME, timestampStr );\n  if ( commentStr && *commentStr ) {\n    TIFFSetField ( handle, TIFFTAG_IMAGEDESCRIPTION, commentStr );\n  }\n\n  // swap byte orders if we need to\n  // swap R and B if we need to\n  // I've done this in for separate loops to avoid tests inside the loops\n\n  s = static_cast<unsigned char*>( frame );\n  t = writeBuffer;\n\n  if ( 16 == pixelDepth ) {\n    if ( reverseByteOrder ) {\n      if ( swapRedBlue ) {\n        for ( i = 0; i < frameSize; i += 6, s += 6 ) {\n          *t++ = *( s + 5 );\n          *t++ = *( s + 4 );\n          *t++ = *( s + 3 );\n          *t++ = *( s + 2 );\n          *t++ = *( s + 1 );\n          *t++ = *s;\n        }\n      } else {\n        for ( i = 0; i < frameSize; i += 2, s += 2 ) {\n          *t++ = *( s + 1 );\n          *t++ = *s;\n        }\n      }\n      buffer = writeBuffer;\n    } else {\n      if ( swapRedBlue ) {\n        for ( i = 0; i < frameSize; i += 6, s += 6 ) {\n          *t++ = *( s + 4 );\n          *t++ = *( s + 5 );\n          *t++ = *( s + 2 );\n          *t++ = *( s + 3 );\n          *t++ = *s;\n          *t++ = *( s + 1 );\n        }\n        buffer = writeBuffer;\n      }\n    }\n  }\n  if ( 8 == pixelDepth ) {\n    if ( swapRedBlue ) {\n      for ( i = 0; i < frameSize; i += 3, s += 3 ) {\n        *t++ = *( s + 2 );\n        *t++ = *( s + 1 );\n        *t++ = *s;\n      }\n      buffer = writeBuffer;\n    }\n  }\n\n  ret = TIFFWriteEncodedStrip ( handle, 0, buffer, frameSize );\n  TIFFClose ( handle );\n  frameCount++;\n  commonState.captureIndex++;\n  return ret;\n}",
    "CML::Pair<CML::FloatImage, CML::Image> loadTiffImage(TIFF *tif, uint32_t width, uint32_t height) {\r\n        FloatImage image(width, height);\r\n        Image colorImage(width, height);\r\n\r\n        tdata_t buf = _TIFFmalloc(TIFFScanlineSize(tif));\r\n        if (!buf) {\r\n            throw std::runtime_error(\"tiff can't malloc ?\");\r\n        }\r\n        T *bufT = (T *) buf;\r\n\r\n        float factor = 255.0f / (float) pow(2, bitspersample);\r\n        float factor85 = 85.0f / (float) pow(2, bitspersample);\r\n\r\n\r\n        for (uint32_t y = 0; y < height; y++) {\r\n            TIFFReadScanline(tif, buf, y);\r\n\r\n            for (uint32_t x = 0; x < width; x++) {\r\n\r\n                colorImage(x, y).g() = (float)bufT[x * 3 + 0] * factor;\r\n                colorImage(x, y).b() = (float)bufT[x * 3 + 1] * factor;\r\n                colorImage(x, y).r() = (float)bufT[x * 3 + 2] * factor;\r\n\r\n                image(x, y) = (float)(bufT[x * 3 + 0] + bufT[x * 3 + 1] + bufT[x * 3 + 2]) * factor85;\r\n                     /*   GrayLookupTable::gammaEncode(\r\n                                (GrayLookupTable::gammaDecode((float)bufT[x * 3 + 0] * factor) +\r\n                            GrayLookupTable::gammaDecode((float)bufT[x * 3 + 1] * factor) +\r\n                            GrayLookupTable::gammaDecode((float)bufT[x * 3 + 2] * factor))\r\n                            / 3.0f\r\n                        );*/\r\n\r\n\r\n            }\r\n        }\r\n\r\n\r\n        _TIFFfree(buf);\r\n        TIFFClose(tif);\r\n\r\n        return {image, colorImage};\r\n    }",
    "PVOID ReadTIFF ( LPCTSTR lpszPath )\r\n{\r\n    void*             pDIB = 0;\r\n    TIFFErrorHandler  wh;\r\n\r\n    wh = TIFFSetWarningHandler(MyWarningHandler);\r\n\r\n    if (ChkTIFF(lpszPath)) {\r\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\r\n        if (tif) {\r\n            char emsg[1024];\r\n\r\n            if (TIFFRGBAImageOK(tif, emsg)) {\r\n                TIFFDibImage img;\r\n                char emsg[1024];\r\n\r\n                if (TIFFRGBAImageBegin(&img.tif, tif, -1, emsg)) {\r\n                    size_t npixels;\r\n                    uint32_t* raster;\r\n\r\n                    DibInstallHack(&img);\r\n\r\n                    npixels = img.tif.width * img.tif.height;\r\n                    raster = (uint32_t*) _TIFFmalloc(npixels * sizeof (uint32_t));\r\n                    if (raster != NULL) {\r\n                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {\r\n                            pDIB = TIFFRGBA2DIB(&img, raster);\r\n                        }\r\n                    }\r\n                    _TIFFfree(raster);\r\n                }\r\n                TIFFRGBAImageEnd(&img.tif);\r\n            }\r\n            else {\r\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\r\n            }\r\n            TIFFClose(tif);\r\n        }\r\n    }\r\n\r\n    TIFFSetWarningHandler(wh);\r\n\r\n    return pDIB;\r\n}",
    "void operator()(TIFF* file) { TIFFClose(file); }",
    "CCodec_TiffContext::~CCodec_TiffContext() {\n  if (m_tif_ctx)\n    TIFFClose(m_tif_ctx);\n}",
    "TIFFWritePimpl::~TIFFWritePimpl()\n{\n\tif(tif)\n\t\tTIFFClose(tif);\n}",
    "int main(int argc, char **argv)\n{\n  std::string ifiles, ofiles, I2Mfiles, order0files;\n  int nphases=DEFAULTNPHASES, napodize=10;\n  int border_size;\n  float dr=0.106f, dz=0.1f, background_dummy=-1.f, background_i2m, xcofm, ycofm, zcofm, xcofm_i2m, ycofm_i2m, zcofm_i2m;\n  float bead_diameter=0.12f, scalefactor=1.0f;\n  float k0angleguess=1.57f, linespacing = 0.2f ; \n  int ifixz[3], ifixr, twolens=0, dorescale=0, ifilein=0, ofilein=0, five_bands=0, do_compen=1, I2M_inc=0, Generate_band0=0, conjugate=0;\n  int bBgInExtHdr = 0; /* if the background of each section is recorded in the extended header's 3rd float number (in Lin's scope) */\n  int icleanup, ileavekz[3]={0,0,0}, ileave1_1, ileave1_2, ileave2, interpkr[2];\n  float NA=1.4f, NIMM=1.515f;\n  float user_dr=0, user_dz=0; /* will use these for dr, dz if these are greater than zero */\n  int bCoherentBSIM = 0; /* In coherent Bessel-SIM, do fixorigin() differently? */\n  int bForcedPIshift=0;\n\n  #ifdef MRC\n  IW_MRC_HEADER header, otfheader;\n  IMAlPrt(0);       \n  #endif\n\n\n  interpkr[0] = 0;\n  interpkr[1] = 0;\n  ifixz[0] = 1;ifixz[1]=1; ifixz[2]=1; ifixr = 0;\n\n  unsigned wavelength = 525;\n\n  if (!commandline(argc, argv, &twolens, &dorescale, &bead_diameter, &k0angleguess, &linespacing, &five_bands, &nphases, interpkr, ileavekz, &do_compen, &I2M_inc, I2Mfiles, &background_dummy, &bBgInExtHdr, &Generate_band0, order0files, &conjugate, &NA, &NIMM, ifixz, &ifixr, &wavelength, &user_dr, &user_dz, &bCoherentBSIM, &bForcedPIshift, ifiles, ofiles, &ifilein, &ofilein))\n    return -1;\n\n  \n  printf(\"ileavekz[0]=%d, ifixz[0]=%d\\n\", ileavekz[0], ifixz[0]);\n\n  if (!ifilein) {\n    std::cout << \" PSF dataset file name: \";\n    getline(std::cin, ifiles);\n  }\n\n  int istream_no=1, ostream_no=2; //! For MRC file I/O\n  // First try with TIFF; if unsuccessful, fall back to MRC\n  bool bTIFF = false;\n  TIFFSetWarningHandler(NULL);\n  TIFFSetErrorHandler(NULL);\n  TIFF *tf = TIFFOpen(ifiles.c_str(), \"r\");\n  CImg <> PSFtiff;\n  if (tf) {\n    TIFFClose(tf);\n    PSFtiff.assign(ifiles.c_str());\n    bTIFF = true;\n  }\n  #ifdef MRC\n  else {\n    std::cout << \"Not a TIFF file; now try MRC\\n\";\n    if (IMOpen(istream_no, ifiles.c_str(), \"ro\")) {\n      std::cerr << \"File \" << ifiles << \" does not exist.\\n\";\n      return -1;\n    }\n  }\n  #endif\n  if (!ofilein) {\n    std::cout << \"Output OTF file name: \";\n    getline(std::cin, ofiles);\n  }\n  #ifdef MRC\n  if (!bTIFF)\n    if (IMOpen(ostream_no, ofiles.c_str(), \"new\")) {\n      std::cerr << \"File \" << ofiles << \" cannot be created.\\n\";\n      return -1;\n    }\n  #endif\n\n  unsigned nx, nxExtra, ny, nz, nxy;\n  if (bTIFF) {\n    nx = PSFtiff.width();\n    ny = PSFtiff.height();\n    nz = PSFtiff.depth();\n    if (user_dr>0)\n      dr = user_dr;  // otherwise, use the default set at declaration; same for \"dz\"\n    if (user_dz>0)\n      dz = user_dz;\n  }\n\n  #ifdef MRC\n  else {\n    int ixyz[3], mxyz[3], pixeltype;\n    float min, max, mean;\n    IMRdHdr(istream_no, ixyz, mxyz, &pixeltype, &min, &max, &mean);\n    IMGetHdr(istream_no, &header);\n\n    nx=header.nx;\n    ny=header.ny;\n    nz=header.nz;\n    dr = header.ylen;\n    dz = header.zlen;\n    wavelength = header.iwav1;\n  }\n  #endif\n\n  if (!I2M_inc)\n    nz /= nphases;\n  else \n    nz /= nphases+1;\n\n  printf(\"nx=%u, ny=%u, nz=%u, dr=%f, dz=%f, wavelength=%u\\n\", nx, ny, nz, dr, dz, wavelength);\n\n  float dkx = 1/(nx*dr);\n  float dky = 1/(ny*dr);\n  float dkz = 1/(nz*dz);\n\n  int norders = (nphases+1)/2;\n\n  if (nx % 2)\n    nxExtra = nx+1;\n  else\n    nxExtra = nx+2;\n  nxy = nxExtra * ny;\n\n  std::vector<CImg<>> floatimage(nphases);\n  std::vector<std::complex<float>*> bands(nphases);\n  \n  for(int i=0; i<nphases; i++) {\n    floatimage[i].assign(nxExtra, ny, nz);\n    bands[i] = (std::complex<float> *) floatimage[i].data();  /* reuse same allocation to save memory */\n  }\n\n  CImg<> I2M_image;\n  if (I2M_inc)\n    I2M_image.assign(nxExtra, ny, nz);\n\n  float *background = new float[nz*nphases];\n  border_size = 20;\n  \n  printf(\"Reading data...\\n\\n\");\n  int zsec = 0;  // incremented by 1 at the end of \"for (phase)\" loop\n  CImg<> buffer;\n  for(auto z=0u; z<nz; z++) {\n    for(int phase=0; phase<nphases; phase++) {\n      if (bTIFF)\n        buffer.assign(PSFtiff.data(0, 0, zsec), nx, ny, 1, 1, true); // Reuse buffer from \"PSFtiff\"; check\n      #ifdef MRC\n      else {\n        buffer.assign(nx, ny);\n        IMRdSec(istream_no, buffer.data());\n      }\n      #endif\n      // Fix camera error at even binnings for some very old Photometric CCD\n      if(buffer(nx-1, ny-1) < 0)\n        buffer(nx-1, ny-1) = buffer(nx-2, ny-1);\n\n      if (bTIFF) {\n        if (background_dummy >=0)\n          background[zsec] = background_dummy;\n        else\n          background[zsec] = estimate_background(buffer, border_size);\n      }\n      #ifdef MRC\n      else if (bBgInExtHdr) {\n        // Some Andor EMCCDs have hidden border pixels that can be used to report fluctuating dark\n        // pixel values, which can be saved in MRC's per-exposure extra header info\n        int extInts;\n        float extFloats[3];\n        IMRtExHdrZWT(istream_no, zsec, 0, 0, &extInts, extFloats);\n        background[zsec] = extFloats[2];\n      }\n      #endif\n\n\n      for(auto i=0u; i<ny; i++) {\n        // Copy from \"buffer\" to floatimage[phase] at section z row-by-row\n        std::memcpy(floatimage[phase].data(0, i, z), buffer.data(0, i), nx*sizeof(float));\n        for (auto j=0u; j<nxExtra - nx; j++)\n          floatimage[phase](nx+j, i, z) = 0.;\n      }\n\n      // To-Do: why not apodize \"buffer\" first before copying to \"floatimage[phase]\"?\n      float *floatsection = floatimage[phase].data(0, 0, z);\n      if(napodize>=0) \n        apodize(napodize, nx, nxExtra, ny, floatsection);\n      else if(napodize==-1)\n        cosapodize(nx, nxExtra, ny, floatsection);\n      \n      zsec ++;\n    } // end for(phase)\n\n    // To-Do; but highly unlikely we'll ever need I2M OTF\n    if (I2M_inc) {  // Data contains one extra section of I2M image\n      if (bTIFF) {\n      }\n      #ifdef MRC\n      else \n        IMRdSec(istream_no, buffer.data());\n      #endif\n      if(buffer(nx-1, ny-1) == -1.0)  /* fix camera error at even binnings */\n        buffer(nx-1, ny-1) = buffer(nx-2, ny-1);\n      if (z==nz/2)\n        background_i2m = estimate_background(buffer, border_size);\n      for(auto i=0u; i<ny; i++) {\n        // Copy from \"buffer\" to I2M_imag at section z row-by-row\n        std::memcpy(I2M_image.data(0, i, z), buffer.data(0, i), nx*sizeof(float));\n        for (auto j=0u; j<nxExtra - nx; j++)\n          I2M_image(nx+j, i, z) = 0.;\n      }\n    }\n  } // end for(z)\n  \n  //! Before FFT, use center band to estimate bead center position:\n  determine_center(floatimage, I2M_image, &xcofm, &ycofm, &zcofm,\n                   &xcofm_i2m, &ycofm_i2m, &zcofm_i2m, twolens, I2M_inc);\n\n  printf(\"Center of mass is (%.3f, %.3f, %.3f)\\n\\n\", xcofm, ycofm, zcofm);\n\n  if (I2M_inc) {\n    // printf(\"I2M psf's background is %.3f\\n\", background_i2m);\n    printf(\"I2M psf's center of mass is (%.3f, %.3f, %.3f)\\n\\n\", xcofm_i2m, ycofm_i2m, zcofm_i2m);\n  }\n\n#pragma omp parallel for\n  for(int z=0; z<nz; z++) {\n    for(int phase=0; phase<nphases; phase++) {\n      CImg<> oneSection(floatimage[phase].data(0, 0, z), nxExtra, ny, 1, 1, true);\n      oneSection -= background[z*nphases + phase]; // This alters floatimage because of shared buffer\n    }\n  }\n  if (I2M_inc) \n    I2M_image -= background_i2m;\n\n  CImg<> sepMatrix(nphases, nphases);\n\n  if (nphases > 1) {\n    makematrix(sepMatrix);\n    separate(floatimage, sepMatrix);\n  }\n\n  if (Generate_band0) {\n    if (bTIFF)\n      floatimage[0].save_tiff(order0files.c_str());\n    #ifdef MRC\n    else\n      mrc_file_write(floatimage[0], nxExtra, ny, nz, dr, dz, 0, wavelength, order0files.c_str());\n    #endif\n  }\n\n  printf(\"Before fft\\n\");\n  unsigned nthreads = 1;\n#ifndef NDEBUG\n#ifdef _WIN32\n  SYSTEM_INFO siSysInfo;\n  GetSystemInfo(&siSysInfo);\n  nthreads = siSysInfo.dwNumberOfProcessors;\n#else\n  nthreads = sysconf(_SC_NPROCESSORS_CONF); // Get number of processors; only works on Unix-based systems and Cygwin (but not MingW)\n#endif\n#endif\n\n  printf(\"Number of threads used: %d\\n\", nthreads);\n\n  fftwf_plan_with_nthreads(nthreads);\n  fftwf_plan rfftplan3d =\n    fftwf_plan_dft_r2c_3d(nz, ny, nx, floatimage[0].data(),\n                          (fftwf_complex *) floatimage[0].data(), FFTW_ESTIMATE);\n  for(int phase=0; phase<nphases; phase++)\n    fftwf_execute_dft_r2c(rfftplan3d, floatimage[phase].data(), (fftwf_complex *) floatimage[phase].data());\n  if (I2M_inc)\n    fftwf_execute_dft_r2c(rfftplan3d, I2M_image.data(), (fftwf_complex *) I2M_image.data());\n\n  fftwf_destroy_plan(rfftplan3d);\n  printf(\"After fft\\n\\n\");\n\n  // Modify the phase of bands, so that it corresponds to FFT of a bead at origin\n  std::cout << \"Shifting center...\\n\";\n  for (int phase=0; phase<nphases; phase++)\n    shift_center(bands[phase], nx, ny, nz, xcofm, ycofm, zcofm);\n\n  if (I2M_inc)\n    shift_center((std::complex<float> *)I2M_image.data(), nx, ny, nz, xcofm_i2m, ycofm_i2m, zcofm_i2m);\n\n  // Now compensate finite bead size for all bands\n  if (do_compen)\n    beadsize_compensate(bands, k0angleguess, linespacing, bead_diameter, norders, nx, ny, nz, dr, dz);\n\n  std::vector<CImg<>> avg_output_buf(nphases);\n  std::vector<std::complex<float> *> avg_output(nphases);\n  //! smaller of the X-Y dimensions; to be used as the lateral dimension in avg_output\n  unsigned nr = std::min(nx, ny);\n\n  for (int phase=0; phase < nphases; phase ++) {\n    avg_output_buf[phase].assign(nz, (nr/2+1)*2, 1, 1, 0.f);\n    avg_output[phase] = (std::complex<float> *) avg_output_buf[phase].data();\n  }\n\n  for (auto order=0; order < norders; order ++) {\n    if (order==0)\n      radialft(bands[0], nx, ny, nz, dr, avg_output[0], nr);\n \n    else {\n      radialft(bands[2*order-1], nx, ny, nz, dr, avg_output[2*order-1], nr);\n      radialft(bands[2*order], nx, ny, nz, dr, avg_output[2*order], nr);\n    }\n  }\n\n  std::complex<float> * I2Mavg_output;\n  if (I2M_inc) {\n    I2Mavg_output = (std::complex<float> *) calloc(nz*(nr/2+1), sizeof(std::complex<float>));\n    radialft((std::complex<float> *)I2M_image.data(), nx, ny, nz, dr, I2Mavg_output, nr);\n  }\n\n  icleanup = nx/2+1;\n  ileave1_1 = ileavekz[0]; ileave1_2 = ileavekz[1]; ileave2 = ileavekz[2];\n\n//  printf(\"ileavekz[0]=%d, ileave1_1=%d\\n\", ileavekz[0], ileave1_1);\n\n  for (int phase=0; phase < nphases; phase ++) {\n    modify(avg_output[phase], nx, nz, ifixz, ifixr, (phase+1)/2, twolens);\n    if (bCoherentBSIM)\n      {/* cleanup_CBSIM(); */}\n    else if (ileave1_1 > 0) {\n      cleanup(avg_output[phase], (phase+1)/2, nr, nz, dr, dz, linespacing, wavelength, icleanup, ileave1_1, ileave1_2, ileave2, twolens, NA, NIMM);\n    }\n    if (phase==0 && interpkr[0] > 0)\n      fixorigin(avg_output[phase], nx, nz, interpkr[0], interpkr[1]);\n    rescale(avg_output[phase], (phase+1)/2, nx, nz, &scalefactor, dorescale);\n  }\n\n  /* For side bands, combine bandre's and bandim's into bandplus */\n  /* Shouldn't this be done later on the averaged bands? */\n  if (!five_bands && nphases > 1)\n    combine_reim(avg_output, norders, nx, nz, bForcedPIshift);\n\n  if (conjugate)\n    for (auto phase=0; phase<nphases; phase++)\n#pragma omp parallel for\n      for (auto i=0; i<(nx/2+1)*nz; i++)\n        avg_output[phase][i] = std::conj(avg_output[phase][i]);\n\n  if (bTIFF) {\n    outputdata(ofiles, avg_output, norders, nx, ny, nz, dkx, dkz, five_bands);\n  }\n  #ifdef MRC\n  else {\n    otfheader = header;\n    outputdata(ostream_no, &otfheader, avg_output, norders, nx, ny, nz, dkx, dkz, five_bands);\n  }\n  if (I2M_inc) {\n/*     cleanup_I2M(I2Mavg_output, nx, nz, dkr, dkz, wavelength, icleanup, NA, NIMM); */\n    fixorigin(I2Mavg_output, nx, nz, interpkr[0], interpkr[1]);\n    rescale(I2Mavg_output, 0, nx, nz, &scalefactor, dorescale);\n    mrc_file_write((float *)I2Mavg_output, nz, nx/2+1, 1, dkz, dkx, 2, wavelength, I2Mfiles.c_str());\n  }\n  #endif\n\n  return 0;\n}",
    "int main(int argc, char *argv[])\n{\n\n  bool bRotatedFull = false;\n  float gamma = 0.4;\n\n  if (argc < 2) {\n    std::cerr << \"Need at least one argument\" <<\n      \"Usage: otfviewer  [-g gamma_value] [-a] OTF_file_name\\n\" <<\n        \"         -g: gamma_value (default is 0.4)\\n\" <<\n        \"         -a: to display OTF in full F space with vertical axis being kz\\n\";\n    return 0;\n  }\n\n  int flags, opt;\n  while ((opt = getopt(argc, argv, \"ag:\")) != -1) {\n    switch (opt) {\n    case 'a':\n      bRotatedFull = true;\n      break;\n    case 'g':\n      gamma = std::stod(optarg);\n      break;\n    default:\n      std::cerr << \"\\nUsage: otfviewer [-g gamma_value] [-a] OTF_file_name \\n\" <<\n        \"         -g: gamma_value (default is 0.4)\\n\" <<\n        \"         -a: to display OTF in full F space with vertical axis being kz\\n\";\n      return 0;\n    }\n  }\n  TIFFSetWarningHandler(NULL);\n  TIFFSetErrorHandler(NULL);\n  TIFF *tf = TIFFOpen(argv[optind], \"r\");\n  CImg<> atiff;\n  if (tf) {\n    TIFFClose(tf);\n    atiff.assign(argv[optind]);\n  }\n  else {\n    std::cout << \"Not a TIFF file; now try MRC\\n\";\n    int istream_no = 1;\n    // Suppress IM header printout; somehow only in this mode would the rest of\n    // IM calls go well on Windows.\n    IMAlPrt(0);\n\n    if (IMOpen(istream_no, argv[optind], \"ro\")) {\n      std::cerr << \"File \" << argv[optind] << \" cannot be opened.\\n\";\n      return -1;\n    }\n    int ixyz[3], mxyz[3], nxyzst[3], pixeltype;\n    float mmm[3];\n    IW_MRC_HEADER header;\n    \n    IMRdHdr(istream_no, ixyz, mxyz, &pixeltype, mmm, mmm+1, mmm+2);\n    IMGetHdr(istream_no, &header);\n\n    atiff.assign(header.nx * 2, header.ny, header.nz);\n    for (int z=0; z<header.nz; z++)\n      IMRdSec(istream_no, atiff.data(0, 0, z));\n    IMClose(istream_no);\n  }\n\n  CImg<> amplitudes(atiff.width()/2, atiff.height(), atiff.depth());\n  cimg_forXYZ(amplitudes, x, y, z) {\n    float r = atiff(2*x, y, z);\n    float i = atiff(2*x+1, y, z);\n    amplitudes(x, y, z) = pow(std::sqrt(r*r + i*i), gamma);\n  }\n\n  if (bRotatedFull) {\n    CImg<> ampAlt(amplitudes.height()*2-1, amplitudes.width(), amplitudes.depth());\n    cimg_forXYZ(amplitudes, x, y, z) {\n      int kz = x;\n      if (x > amplitudes.width()/2) kz -= amplitudes.width(); // origin at corners\n      ampAlt(y+amplitudes.height(), kz+amplitudes.width()/2, z) = amplitudes(x, y, z);\n      ampAlt(amplitudes.height()-y, kz+amplitudes.width()/2, z) = amplitudes(x, y, z);\n    }\n\n    amplitudes = ampAlt;\n  }\n\n  amplitudes.display(argv[optind], false);\n\n  // Somehow doubled XY image looks the same:\n  // CImg<> large = amplitudes.resize_doubleXY();\n  // std::cout << amplitudes.width() << \"  \" << large.width() << std::endl;\n  // large.display(argv[1], false);\n  return 0;\n}",
    "void close()\n  {\n    if (tif != nullptr)\n    {\n      TIFFClose(tif);\n    }\n  }",
    "void close()\n  {\n    if (tif != nullptr)\n    {\n      TIFFClose(tif);\n      tif = nullptr;\n    }\n  }",
    "void TiffFile::close() {\n  if (tiffFile_ == nullptr) {\n    return;\n  }\n  TIFFClose(tiffFile_);\n  tiffFile_ = nullptr;\n}",
    "~TIFFData()\n                    {\n                        if (p)\n                        {\n                            TIFFClose(p);\n                        }\n                    }",
    "~TIFFPrivate()\n    {\n        if (buf) {\n            _TIFFfree(buf);\n        }\n        if (tif) {\n            TIFFClose(tif);\n        }\n        if (data)\n            free(data);\n    }",
    "int main(int argc, char** argv) {\n    double gamma = 1.0;\n    bool   gui = false;\n    bool   savepng = false;\n    bool   savebayer = false;\n    \n    if(argc<2){\n        printf(\"Usage: %s filename [--gui] [--savepng] [--savebayer] [--gamma=1.0]\\n\",argv[0]);\n        return -1;\n    }\n    for(int i=2;i<argc;i++){\n        if(strcmp(argv[i],\"--savepng\")==0){\n            savepng = true;\n        }\n        if(strcmp(argv[i],\"--savebayer\")==0){\n            savebayer = true;\n        }\n        if(strcmp(argv[i],\"--gui\")==0){\n            gui = true;\n        }\n        if(strncmp(argv[i],\"--gamma=\",8)==0) {\n            gamma = atof(argv[i]+8);\n        }\n    }\n    const char* fn = argv[1];\n\n    fprintf(stdout,\"--------------------EFFUSUS--------------------\\n\");\n    fprintf(stdout,\"Gamma:    \\t %f\\n\",gamma);\n    fprintf(stdout,\"GUI:      \\t %s\\n\",gui?\"true\":\"false\");\n    fprintf(stdout,\"Save PNG: \\t %s\\n\",savepng?\"true\":\"false\");\n    fprintf(stdout,\"Save Bayer:\\t %s\\n\",savebayer?\"true\":\"false\");\n    fprintf(stdout,\"Filename: \\t %s\\n\",fn);\n    fprintf(stdout,\"-----------------------------------------------\\n\");\n    // Flush printf\n    fflush(stdout);\n\n    // Load binary\n    uint8_t* fbuf = (uint8_t*)malloc((CCD_H+1)*CCD_W*2);\n    long flen = read_binary_file(fn, fbuf, (CCD_H+1)*CCD_W*2);\n    if(flen==-1) return -1;\n    printf(\"Read Successful, flen=%ld\\n\",flen);\n\n    // Convert binary to rggb raw data\n    uint16_t* raw = (uint16_t*)malloc(2*(SCR_W+1)*SCR_H*4);\n    memset(raw,0xFF,sizeof(raw));\n    effusus_bin2raw(raw, fbuf, CCD_W, CCD_H, SCR_W, SCR_H);\n\n    if(gui) {\n        // Init SDL\n        SDL_Init(SDL_INIT_VIDEO);\n        swin = SDL_SetVideoMode(SCR_W/2, SCR_H/2, 16, false);\n        semu = SDL_CreateRGBSurface(SDL_SWSURFACE,SCR_W, SCR_H,16,0,0,0,0);\n        if ((semu == NULL) || (swin == NULL)) {\n            fprintf(stderr, \"could not create surface: %s\\n\", SDL_GetError());\n            return -1;\n        }\n        uint16_t* vram = (uint16_t*)(semu->pixels);\n\n        // Dither to VRAM\n        effusus_dither_to_vram(vram, raw, gamma, SCR_W, SCR_H, EFFUSUS_DITHER_FS);\n        \n        SDL_Event event;\n        bool running = true;\n        \n        while(running){\n            while(SDL_PollEvent(&event)){\n                running = event.type != SDL_QUIT;\n            }\n            switch( event.type ){\n                case SDL_KEYDOWN:\n                    switch( event.key.keysym.sym ){\n                    case SDLK_ESCAPE:\n                        running = false;\n                        break;\n                    default:\n                        break;\n                }\n            }\n            SDL_SoftStretch(semu,&rsrc,swin,&rdst);\n            SDL_Flip(swin);\n        }\n        SDL_SoftStretch(semu,&rsrc,swin,&rdst);\n        SDL_Flip(swin);\n    }\n\n    unsigned bayerbuf_size = SCR_W*SCR_H*4*2;\n    uint8_t* bayerbuf;\n    bayerbuf = (uint8_t*)malloc(bayerbuf_size);\n    memset(bayerbuf,0x00,bayerbuf_size);\n    effusus_raw2bayer(raw, bayerbuf, SCR_W, SCR_H);\n    if(savebayer){\n        // Store bayer raw to binary file\n        // This will result in the following image format:\n        // 4416 x 2726 RGGB(2x2)\n        // Row-Stride = 8832, Pixel-Stride = 4 \n        // 16-bit per pixel, Little-Endian\n        //\n        // The file can be opened by GIMP, RawTherapee, or LibRaw\n        FILE* fbayer = fopen(\"bayer.raw\",\"wb\");\n        fwrite(bayerbuf,1,bayerbuf_size,fbayer);\n        fclose(fbayer);\n        PRINTINFO(\"Bayer RAW saved to bayer.raw\\n\");\n    }\n\n    if(savepng){\n        // Store raw to PNG\n        effusus_writepng(\"output.png\", raw, SCR_W, SCR_H);\n    }\n\n    // Write to mosaic tiff\n    // print libtiff version\n    printf(\"LIBTIFF %s\\n\", TIFFGetVersion());\n    TIFF* tiff = TIFFOpen(\"output.tiff\",\"w\");\n    if(!tiff){\n        fprintf(stderr,\"Failed to open output.tiff for writing\\n\");\n        return -1;\n    }\n    // Set TIFF tags\n    TIFFSetField(tiff, TIFFTAG_IMAGEWIDTH,  SCR_W*2);\n    TIFFSetField(tiff, TIFFTAG_IMAGELENGTH, SCR_H*2);\n    TIFFSetField(tiff, TIFFTAG_SAMPLESPERPIXEL, 1);\n    TIFFSetField(tiff, TIFFTAG_ROWSPERSTRIP, 1);\n    TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 16);\n    TIFFSetField(tiff, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT);\n    TIFFSetField(tiff, TIFFTAG_ORIENTATION, ORIENTATION_BOTRIGHT);\n    TIFFSetField(tiff, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_CFA);\n\n    TIFFSetField(tiff, TIFFTAG_MAKE, \"DummyMake\");\n    TIFFSetField(tiff, TIFFTAG_MODEL, \"DummyModel\");\n    TIFFSetField(tiff, TIFFTAG_SOFTWARE, \"DummySoftware\");\n    TIFFSetField(tiff, TIFFTAG_ORIGINALRAWFILENAME, 1, \"DummyName.dng\");\n    TIFFSetField(tiff, TIFFTAG_UNIQUECAMERAMODEL, \"DummyUniqueModel\");\n    TIFFSetField(tiff, TIFFTAG_IMAGEDESCRIPTION, \"DummyImageDescription\");\n    TIFFSetField(tiff, TIFFTAG_COPYRIGHT, \"DummyCopyright\");\n    TIFFSetField(tiff, TIFFTAG_DATETIME, \"2016:06:30 11:11:15\");\n    TIFFSetField(tiff, TIFFTAG_DNGVERSION, \"\\01\\01\\00\\00\");\n    TIFFSetField(tiff, TIFFTAG_SUBFILETYPE, 0);\n    TIFFSetField(tiff, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n    TIFFSetField(tiff, TIFFTAG_DNGBACKWARDVERSION, \"\\01\\00\\00\\00\");\n    \n    // Custom TIFF tag for CFA pattern\n    TIFFSetField(tiff, TIFFTAG_CFAPATTERN, 4, \"\\000\\001\\001\\002\"); // RGGB\n\n    // Write bayer data\n    tsize_t linebytes = SCR_W*4 * sizeof(uint8_t);\n    uint8_t *buf = (uint8_t*)_TIFFmalloc(linebytes);\n    for (uint32_t row = 0; row < SCR_H*2; row++) {\n        // Copy data from bayerbuf to buf, big endian\n        for (uint32_t col = 0; col < SCR_W*4; col+=2) {\n            buf[col]   = bayerbuf[row*SCR_W*4+col];\n            buf[col+1] = bayerbuf[row*SCR_W*4+col+1];\n        }\n        if (TIFFWriteScanline(tiff, buf, row, 0) < 0) {\n            fprintf(stderr, \"Failed to write TIFF scanline\\n\");\n            break;\n        }\n    }\n    _TIFFfree(buf);\n    //\n\n    // Close TIFF\n    TIFFClose(tiff);\n\n    free(bayerbuf);\n    free(raw);\n    if(gui)\tSDL_Quit();\n    printf(\"Done!\\n\");\n    \n    return 0;\n}",
    "int DiTIFFPlugin::write(\n  DiImage *image,\n  FILE *stream,\n  const unsigned int frame) const\n{\n  int result = 0;\n  if ((image != NULL) && (stream != NULL))\n  {\n    int stream_fd = fileno(stream);\n\n#ifdef HAVE_WINDOWS_H\n    /* The Win32 version of libtiff expects a Win32 HANDLE (casted to int)\n     * instead of a file descriptor. Therefore, we use _get_osfhandle()\n     * which takes a Unix-style file descriptor and derives the corresponding\n     * Win32 API file handle (HANDLE). This function may not be available on all\n     * compilers for Win32, sorry.\n     */\n#ifdef __CYGWIN__\n    stream_fd = OFstatic_cast(int, get_osfhandle(stream_fd));\n#else\n    stream_fd =OFstatic_cast(int, _get_osfhandle(stream_fd));\n#endif\n#endif\n\n    /* create bitmap with 8 bits per sample */\n    void *data = OFconst_cast(void *, image->getOutputData(frame, 8 /*bits*/, 0 /*planar*/));\n    if (data != NULL)\n    {\n      OFBool isMono = (image->getInternalColorModel() == EPI_Monochrome1) || (image->getInternalColorModel() == EPI_Monochrome2);\n      Uint16 rows = image->getRows();\n      Uint16 cols = image->getColumns();\n\n      short photometric = isMono ? PHOTOMETRIC_MINISBLACK : PHOTOMETRIC_RGB;\n      short samplesperpixel = isMono ? 1 : 3;\n      unsigned int bytesperrow = cols * samplesperpixel;\n      if (bytesperrow > 0)\n      {\n        short opt_predictor = 0;\n        switch (predictor)\n        {\n          case E_tiffLZWPredictorDefault:\n            opt_predictor = 0;\n            break;\n          case E_tiffLZWPredictorNoPrediction:\n            opt_predictor = 1;\n            break;\n          case E_tiffLZWPredictorHDifferencing:\n            opt_predictor = 2;\n            break;\n        }\n\n        unsigned short opt_compression = COMPRESSION_NONE;\n        switch (compressionType)\n        {\n          case E_tiffLZWCompression:\n            opt_compression = COMPRESSION_LZW;\n            break;\n          case E_tiffPackBitsCompression:\n            opt_compression = COMPRESSION_PACKBITS;\n            break;\n          case E_tiffNoCompression:\n            opt_compression = COMPRESSION_NONE;\n            break;\n        }\n\n        long opt_rowsperstrip = OFstatic_cast(long, rowsPerStrip);\n        if (opt_rowsperstrip <= 0) opt_rowsperstrip = 8192 / bytesperrow;\n        if (opt_rowsperstrip == 0) opt_rowsperstrip++;\n\n        OFBool OK = OFTrue;\n        unsigned char *bytedata = OFstatic_cast(unsigned char *, data);\n        TIFF *tif = TIFFFdOpen(stream_fd, \"TIFF\", \"w\");\n        if (tif)\n        {\n          /* Set TIFF parameters. */\n          TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, cols);\n          TIFFSetField(tif, TIFFTAG_IMAGELENGTH, rows);\n          TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8);\n          TIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n          TIFFSetField(tif, TIFFTAG_COMPRESSION, opt_compression);\n          if (opt_compression == COMPRESSION_LZW && opt_predictor != 0)\n          TIFFSetField(tif, TIFFTAG_PREDICTOR, opt_predictor);\n          TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, photometric);\n          TIFFSetField(tif, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);\n          TIFFSetField(tif, TIFFTAG_DOCUMENTNAME, \"unnamed\");\n          TIFFSetField(tif, TIFFTAG_IMAGEDESCRIPTION, \"converted DICOM image\");\n          TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, samplesperpixel);\n          TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, opt_rowsperstrip);\n          /* TIFFSetField(tif, TIFFTAG_STRIPBYTECOUNTS, rows / opt_rowsperstrip); */\n          TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\n          /* Now write the TIFF data. */\n          unsigned int offset = 0;\n          for (Uint16 i=0; (i < rows) && OK; i++)\n          {\n            if (TIFFWriteScanline(tif, bytedata + offset, i, 0) < 0) OK = OFFalse;\n            offset += bytesperrow;\n          }\n          TIFFFlushData(tif);\n          TIFFClose(tif);\n        }\n        if (OK) result = 1;\n      }\n    }\n\n    /* delete pixel data */\n    image->deleteOutputData();\n  }\n  return result;\n}",
    "bool  TiffEncoder::writeLibTiff( const Mat& img, const std::vector<int>& params)\n{\n    int channels = img.channels();\n    int width = img.cols, height = img.rows;\n    int depth = img.depth();\n\n    int bitsPerChannel = -1;\n    switch (depth)\n    {\n        case CV_8U:\n        {\n            bitsPerChannel = 8;\n            break;\n        }\n        case CV_16U:\n        {\n            bitsPerChannel = 16;\n            break;\n        }\n        default:\n        {\n            return false;\n        }\n    }\n\n    const int bitsPerByte = 8;\n    size_t fileStep = (width * channels * bitsPerChannel) / bitsPerByte;\n\n    int rowsPerStrip = (int)((1 << 13)/fileStep);\n    readParam(params, TIFFTAG_ROWSPERSTRIP, rowsPerStrip);\n\n    if( rowsPerStrip < 1 )\n        rowsPerStrip = 1;\n\n    if( rowsPerStrip > height )\n        rowsPerStrip = height;\n\n\n    // do NOT put \"wb\" as the mode, because the b means \"big endian\" mode, not \"binary\" mode.\n    // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n    TIFF* pTiffHandle = TIFFOpen(m_filename.c_str(), \"w\");\n    if (!pTiffHandle)\n    {\n        return false;\n    }\n\n    // defaults for now, maybe base them on params in the future\n    int   compression  = COMPRESSION_LZW;\n    int   predictor    = PREDICTOR_HORIZONTAL;\n\n    readParam(params, TIFFTAG_COMPRESSION, compression);\n    readParam(params, TIFFTAG_PREDICTOR, predictor);\n\n    int   colorspace = channels > 1 ? PHOTOMETRIC_RGB : PHOTOMETRIC_MINISBLACK;\n\n    if ( !TIFFSetField(pTiffHandle, TIFFTAG_IMAGEWIDTH, width)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_IMAGELENGTH, height)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_BITSPERSAMPLE, bitsPerChannel)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_COMPRESSION, compression)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_PHOTOMETRIC, colorspace)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_SAMPLESPERPIXEL, channels)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_ROWSPERSTRIP, rowsPerStrip)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_PREDICTOR, predictor)\n       )\n    {\n        TIFFClose(pTiffHandle);\n        return false;\n    }\n\n    // row buffer, because TIFFWriteScanline modifies the original data!\n    size_t scanlineSize = TIFFScanlineSize(pTiffHandle);\n    AutoBuffer<uchar> _buffer(scanlineSize+32);\n    uchar* buffer = _buffer;\n    if (!buffer)\n    {\n        TIFFClose(pTiffHandle);\n        return false;\n    }\n\n    for (int y = 0; y < height; ++y)\n    {\n        switch(channels)\n        {\n            case 1:\n            {\n                memcpy(buffer, img.ptr(y), scanlineSize);\n                break;\n            }\n\n            case 3:\n            {\n                if (depth == CV_8U)\n                    icvCvt_BGR2RGB_8u_C3R( img.ptr(y), 0, buffer, 0, cvSize(width,1) );\n                else\n                    icvCvt_BGR2RGB_16u_C3R( img.ptr<ushort>(y), 0, (ushort*)buffer, 0, cvSize(width,1) );\n                break;\n            }\n\n            case 4:\n            {\n                if (depth == CV_8U)\n                    icvCvt_BGRA2RGBA_8u_C4R( img.ptr(y), 0, buffer, 0, cvSize(width,1) );\n                else\n                    icvCvt_BGRA2RGBA_16u_C4R( img.ptr<ushort>(y), 0, (ushort*)buffer, 0, cvSize(width,1) );\n                break;\n            }\n\n            default:\n            {\n                TIFFClose(pTiffHandle);\n                return false;\n            }\n        }\n\n        int writeResult = TIFFWriteScanline(pTiffHandle, buffer, y, 0);\n        if (writeResult != 1)\n        {\n            TIFFClose(pTiffHandle);\n            return false;\n        }\n    }\n\n    TIFFClose(pTiffHandle);\n    return true;\n}",
    "bool TiffEncoder::writeHdr(const Mat& _img)\n{\n    Mat img;\n    cvtColor(_img, img, COLOR_BGR2XYZ);\n    TIFF* tif = TIFFOpen(m_filename.c_str(), \"w\");\n    if (!tif)\n    {\n        return false;\n    }\n    TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, img.cols);\n    TIFFSetField(tif, TIFFTAG_IMAGELENGTH, img.rows);\n    TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 3);\n    TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_SGILOG);\n    TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_LOGLUV);\n    TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    TIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_FLOAT);\n    TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, 1);\n    int strip_size = 3 * img.cols;\n    float *ptr = const_cast<float*>(img.ptr<float>());\n    for (int i = 0; i < img.rows; i++, ptr += strip_size)\n    {\n        TIFFWriteEncodedStrip(tif, i, ptr, strip_size * sizeof(float));\n    }\n    TIFFClose(tif);\n    return true;\n}",
    "void save_tiff(Image &img, std::string file)\n    {\n        auto d_depth = img.depth();\n        auto d_channels = img.channels();\n        auto d_height = img.height();\n        auto d_width = img.width();\n\n        if (img.size() == 0 || d_height == 0) // Make sure we aren't just gonna crash\n        {\n            logger->trace(\"Tried to save empty TIFF!\");\n            return;\n        }\n\n        TIFF *tif = TIFFOpen(file.c_str(), \"w\");\n        if (tif)\n        {\n            TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, d_width);\n            TIFFSetField(tif, TIFFTAG_IMAGELENGTH, d_height);\n            TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, d_channels);\n            TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, d_depth);\n            TIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n            TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n            TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, d_channels == 1 ? PHOTOMETRIC_MINISBLACK : PHOTOMETRIC_RGB);\n            if (d_channels == 4)\n            {\n                uint16_t out[1];\n                out[0] = EXTRASAMPLE_UNASSALPHA;\n                TIFFSetField(tif, TIFFTAG_EXTRASAMPLES, 1, &out);\n            }\n\n            tsize_t linebytes = d_channels * d_width * (d_depth == 8 ? sizeof(uint8_t) : sizeof(uint16_t));\n\n            unsigned char *buf = NULL;\n            if (TIFFScanlineSize(tif) == linebytes)\n                buf = (unsigned char *)_TIFFmalloc(linebytes);\n            else\n                buf = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(tif));\n\n            TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, TIFFDefaultStripSize(tif, d_width * d_channels));\n\n            for (size_t y = 0; y < d_height; y++)\n            {\n                for (size_t x = 0; x < d_width; x++)\n                {\n                    size_t i2 = /*((d_height - 1) - y)*/ y * d_width + x;\n                    if (d_depth == 8)\n                    {\n                        for (int i = 0; i < d_channels; i++)\n                            ((uint8_t *)buf)[x * d_channels + i] = img.get(i, i2);\n                    }\n                    else if (d_depth == 16)\n                    {\n                        for (int i = 0; i < d_channels; i++)\n                            ((uint16_t *)buf)[x * d_channels + i] = img.get(i, i2);\n                    }\n                }\n\n                if (TIFFWriteScanline(tif, buf, y, 0) < 0)\n                    break;\n            }\n\n            _TIFFfree(buf);\n\n            if (image::has_metadata(img))\n            {\n                nlohmann::json meta = image::get_metadata(img);\n                if (meta.contains(\"proj_cfg\"))\n                {\n                    try\n                    {\n                        proj::projection_t proj = meta[\"proj_cfg\"];\n                        geotiff::try_write_geotiff(tif, &proj);\n                    }\n                    catch (std::exception &)\n                    {\n                    }\n                }\n            }\n\n            TIFFClose(tif);\n        }\n    }",
    "void load_tiff(Image &img, std::string file)\n    {\n        if (!std::filesystem::exists(file))\n            return;\n\n        TIFF *tif = TIFFOpen(file.c_str(), \"r\");\n        if (tif)\n        {\n            uint32_t w, h;\n            int16_t bit_depth, channels_number;\n\n            TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w);\n            TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\n            TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &channels_number);\n            TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bit_depth);\n\n            proj::projection_t pro;\n            if (geotiff::try_read_geotiff(&pro, tif))\n            {\n                nlohmann::json meta;\n                meta[\"proj_cfg\"] = pro;\n                set_metadata(img, meta);\n            }\n\n            if (bit_depth != 8 && bit_depth != 16)\n            {\n                logger->error(\"Unsupported TIFF bit depth %d\", bit_depth);\n                return;\n            }\n\n            img.init(bit_depth, w, h, channels_number);\n\n            int d_channels = channels_number;\n            size_t d_width = w;\n            size_t d_height = h;\n            int d_depth = bit_depth;\n\n            tsize_t linebytes = d_channels * d_width * (bit_depth == 16 ? sizeof(uint16_t) : sizeof(uint8_t));\n            unsigned char *buf = NULL;\n            if (TIFFScanlineSize(tif) == linebytes)\n                buf = (unsigned char *)_TIFFmalloc(linebytes);\n            else\n                buf = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(tif));\n\n            for (size_t y = 0; y < d_height; y++)\n            {\n                TIFFReadScanline(tif, buf, y, 0);\n\n                if (d_depth == 16)\n                {\n                    for (size_t x = 0; x < d_width; x++)\n                        for (int i = 0; i < d_channels; i++)\n                            img.set(i, y * d_width + x, ((uint16_t *)buf)[x * channels_number + i]);\n                }\n                else if (d_depth == 8)\n                {\n                    for (size_t x = 0; x < d_width; x++)\n                    {\n                        for (int i = 0; i < d_channels; i++)\n                            img.set(i, y * d_width + x, ((uint8_t *)buf)[x * channels_number + i]);\n                    }\n                }\n            }\n\n            _TIFFfree(buf);\n\n            TIFFClose(tif);\n        }\n\n        printf(\"Done Loading TIFF\\n\");\n    }",
    "bool wxTIFFHandler::LoadFile( wxImage *image, wxInputStream& stream, bool verbose, int index )\n{\n    if (index == -1)\n        index = 0;\n\n    image->Destroy();\n\n    TIFF *tif = TIFFwxOpen( stream, \"image\", \"r\" );\n\n    if (!tif)\n    {\n        if (verbose)\n            wxLogError( _(\"TIFF: Error loading image.\") );\n\n        return false;\n    }\n\n    if (!TIFFSetDirectory( tif, (tdir_t)index ))\n    {\n        if (verbose)\n            wxLogError( _(\"Invalid TIFF image index.\") );\n\n        TIFFClose( tif );\n\n        return false;\n    }\n\n    uint32 w, h;\n    uint32 *raster;\n\n    TIFFGetField( tif, TIFFTAG_IMAGEWIDTH, &w );\n    TIFFGetField( tif, TIFFTAG_IMAGELENGTH, &h );\n\n    uint16 extraSamples;\n    uint16* samplesInfo;\n    TIFFGetFieldDefaulted(tif, TIFFTAG_EXTRASAMPLES,\n                          &extraSamples, &samplesInfo);\n    const bool hasAlpha = (extraSamples == 1 &&\n                           (samplesInfo[0] == EXTRASAMPLE_ASSOCALPHA ||\n                            samplesInfo[0] == EXTRASAMPLE_UNASSALPHA));\n\n    // guard against integer overflow during multiplication which could result\n    // in allocating a too small buffer and then overflowing it\n    const double bytesNeeded = (double)w * (double)h * sizeof(uint32);\n    if ( bytesNeeded >= 4294967295U /* UINT32_MAX */ )\n    {\n        if ( verbose )\n            wxLogError( _(\"TIFF: Image size is abnormally big.\") );\n\n        TIFFClose(tif);\n\n        return false;\n    }\n\n    raster = (uint32*) _TIFFmalloc( bytesNeeded );\n\n    if (!raster)\n    {\n        if (verbose)\n            wxLogError( _(\"TIFF: Couldn't allocate memory.\") );\n\n        TIFFClose( tif );\n\n        return false;\n    }\n\n    image->Create( (int)w, (int)h );\n    if (!image->Ok())\n    {\n        if (verbose)\n            wxLogError( _(\"TIFF: Couldn't allocate memory.\") );\n\n        _TIFFfree( raster );\n        TIFFClose( tif );\n\n        return false;\n    }\n\n    if ( hasAlpha )\n        image->SetAlpha();\n\n    if (!TIFFReadRGBAImage( tif, w, h, raster, 0 ))\n    {\n        if (verbose)\n            wxLogError( _(\"TIFF: Error reading image.\") );\n\n        _TIFFfree( raster );\n        image->Destroy();\n        TIFFClose( tif );\n\n        return false;\n    }\n\n    unsigned char *ptr = image->GetData();\n    ptr += w*3*(h-1);\n\n    unsigned char *alpha = hasAlpha ? image->GetAlpha() : NULL;\n    if ( hasAlpha )\n        alpha += w*(h-1);\n\n    uint32 pos = 0;\n\n    for (uint32 i = 0; i < h; i++)\n    {\n        for (uint32 j = 0; j < w; j++)\n        {\n            *(ptr++) = (unsigned char)TIFFGetR(raster[pos]);\n            *(ptr++) = (unsigned char)TIFFGetG(raster[pos]);\n            *(ptr++) = (unsigned char)TIFFGetB(raster[pos]);\n            if ( hasAlpha )\n                *(alpha++) = (unsigned char)TIFFGetA(raster[pos]);\n\n            pos++;\n        }\n\n        // subtract line we just added plus one line:\n        ptr -= 2*w*3;\n        if ( hasAlpha )\n            alpha -= 2*w;\n    }\n\n    _TIFFfree( raster );\n\n    TIFFClose( tif );\n\n    return true;\n}",
    "int wxTIFFHandler::GetImageCount( wxInputStream& stream )\n{\n    TIFF *tif = TIFFwxOpen( stream, \"image\", \"r\" );\n\n    if (!tif)\n        return 0;\n\n    int dircount = 0;  // according to the libtiff docs, dircount should be set to 1 here???\n    do {\n        dircount++;\n    } while (TIFFReadDirectory(tif));\n\n    TIFFClose( tif );\n\n    return dircount;\n}",
    "bool wxTIFFHandler::SaveFile( wxImage *image, wxOutputStream& stream, bool verbose )\n{\n    TIFF *tif = TIFFwxOpen( stream, \"image\", \"w\" );\n\n    if (!tif)\n    {\n        if (verbose)\n            wxLogError( _(\"TIFF: Error saving image.\") );\n\n        return false;\n    }\n\n    TIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n    TIFFSetField(tif, TIFFTAG_IMAGEWIDTH,  (uint32)image->GetWidth());\n    TIFFSetField(tif, TIFFTAG_IMAGELENGTH, (uint32)image->GetHeight());\n    TIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n    TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\n    if ( image->HasOption(wxIMAGE_OPTION_RESOLUTIONX) &&\n            image->HasOption(wxIMAGE_OPTION_RESOLUTIONY) )\n    {\n        TIFFSetField(tif, TIFFTAG_XRESOLUTION,\n                        (float)image->GetOptionInt(wxIMAGE_OPTION_RESOLUTIONX));\n        TIFFSetField(tif, TIFFTAG_YRESOLUTION,\n                        (float)image->GetOptionInt(wxIMAGE_OPTION_RESOLUTIONY));\n    }\n\n    int spp = image->GetOptionInt(wxIMAGE_OPTION_SAMPLESPERPIXEL);\n    if ( !spp )\n        spp = 3;\n\n    int bpp = image->GetOptionInt(wxIMAGE_OPTION_BITSPERSAMPLE);\n    if ( !bpp )\n        bpp=8;\n\n    int compression = image->GetOptionInt(wxIMAGE_OPTION_COMPRESSION);\n    if ( !compression )\n    {\n        // we can't use COMPRESSION_LZW because current version of libtiff\n        // doesn't implement it (\"no longer implemented due to Unisys patent\n        // enforcement\") and other compression methods are lossy so we\n        // shouldn't use them by default -- and the only remaining one is none\n        compression = COMPRESSION_NONE;\n    }\n\n    TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, spp);\n    TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, bpp);\n    TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, spp*bpp == 1 ? PHOTOMETRIC_MINISBLACK\n                                                        : PHOTOMETRIC_RGB);\n    TIFFSetField(tif, TIFFTAG_COMPRESSION, compression);\n\n    // scanlinesize if determined by spp and bpp\n    tsize_t linebytes = (tsize_t)image->GetWidth() * spp * bpp / 8;\n\n    if ( (image->GetWidth() % 8 > 0) && (spp * bpp < 8) )\n        linebytes+=1;\n\n    unsigned char *buf;\n\n    if (TIFFScanlineSize(tif) > linebytes || (spp * bpp < 24))\n    {\n        buf = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(tif));\n        if (!buf)\n        {\n            if (verbose)\n                wxLogError( _(\"TIFF: Couldn't allocate memory.\") );\n\n            TIFFClose( tif );\n\n            return false;\n        }\n    }\n    else\n    {\n        buf = NULL;\n    }\n\n    TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP,TIFFDefaultStripSize(tif, (uint32) -1));\n\n    unsigned char *ptr = image->GetData();\n    for ( int row = 0; row < image->GetHeight(); row++ )\n    {\n        if ( buf )\n        {\n            if ( spp * bpp > 1 )\n            {\n                // color image\n                memcpy(buf, ptr, image->GetWidth());\n            }\n            else // black and white image\n            {\n                for ( int column = 0; column < linebytes; column++ )\n                {\n                    uint8 reverse = 0;\n                    for ( int bp = 0; bp < 8; bp++ )\n                    {\n                        if ( ptr[column*24 + bp*3] > 0 )\n                        {\n                            // check only red as this is sufficient\n                            reverse = (uint8)(reverse | 128 >> bp);\n                        }\n                    }\n\n                    buf[column] = reverse;\n                }\n            }\n        }\n\n        if ( TIFFWriteScanline(tif, buf ? buf : ptr, (uint32)row, 0) < 0 )\n        {\n            if (verbose)\n                wxLogError( _(\"TIFF: Error writing image.\") );\n\n            TIFFClose( tif );\n            if (buf)\n                _TIFFfree(buf);\n\n            return false;\n        }\n\n        ptr += image->GetWidth()*3;\n    }\n\n    (void) TIFFClose(tif);\n\n    if (buf)\n        _TIFFfree(buf);\n\n    return true;\n}",
    "void EERRenderer::read(FileName _fn_movie, int eer_upsampling)\n{\n\tif (ready)\n\t\tREPORT_ERROR(\"Logic error: you cannot recycle EERRenderer for multiple files (now)\");\n\n\tif (eer_upsampling == -1 || eer_upsampling == 1 || eer_upsampling == 2 || eer_upsampling == 3)\n\t\tthis->eer_upsampling = eer_upsampling;\n\telse\n\t{\n\t\tstd::cerr << \"EERRenderer::read: eer_upsampling = \" << eer_upsampling << std::endl;\n\t\tREPORT_ERROR(\"EERRenderer::read: eer_upsampling must be -1, 1, 2 or 3.\");\n\t}\n\n\tfn_movie = _fn_movie;\n\n\t// First of all, check the file size\n\tFILE *fh = fopen(fn_movie.c_str(), \"r\");\n\tif (fh == NULL)\n\t\tREPORT_ERROR(\"Failed to open \" + fn_movie);\n\n\tfseek(fh, 0, SEEK_END);\n\tfile_size = ftell(fh);\n\tfseek(fh, 0, SEEK_SET);\n\n\tsilenceTIFFWarnings();\n\n\t// Try reading as TIFF\n\tTIFF *ftiff = TIFFOpen(fn_movie.c_str(), \"r\");\n\n\tif (ftiff == NULL)\n\t{\n\t\tis_legacy = true;\n\t\treadLegacy(fh);\n\t}\n\telse\n\t{\n\t\tis_legacy = false;\n\n\t\t// Check width & size\n\t\tuint16_t compression = 0;\n\t\tTIFFGetField(ftiff, TIFFTAG_IMAGEWIDTH, &width);\n\t\tTIFFGetField(ftiff, TIFFTAG_IMAGELENGTH, &height);\n\t\tTIFFGetField(ftiff, TIFFTAG_COMPRESSION, &compression);\n\n#ifdef DEBUG_EER\n\t\tprintf(\"EER in TIFF: %s size = %lld, width = %d, height = %d, compression = %d\\n\", fn_movie.c_str(), file_size, width, height, compression);\n#endif\n\n\t\t// TIA can write an EER file whose first page is a sum and compressoin == 1.\n\t\t// This is not supported (yet). EPU never writes such movies.\n\t\tif (compression == EERRenderer::TIFF_COMPRESSION_EER8bit)\n\t\t{\n\t\t\trle_bits = 8;\n\t\t\tsubpixel_bits = 4;\n\t\t}\n\t\telse if (compression == EERRenderer::TIFF_COMPRESSION_EER7bit)\n\t\t{\n\t\t\trle_bits = 7;\n\t\t\tsubpixel_bits = 4;\n\t\t}\n\t\telse if (compression == EERRenderer::TIFF_COMPRESSION_EERDetailed)\n\t\t{\n\t\t\t// See https://stackoverflow.com/questions/33522589/how-to-read-custom-tiff-tags-w-o-tifffieldinfo\n\t\t\t// and \"AUTOREGISTERED TAGS\" in https://manpages.debian.org/testing/libtiff-dev/TIFFGetField.3tiff.en.html.\n\t\t\tuint32_t count;\n\t\t\tuint16_t *rle, *subpix_h, *subpix_v;\n\n\t\t\tTIFFGetField(ftiff, EERRenderer::TIFFTAG_EER_RLE_DEPTH, &count, (void*)&rle);\n\t\t\trle_bits = *rle;\n\t\t\tTIFFGetField(ftiff, EERRenderer::TIFFTAG_EER_SUBPIXEL_H_DEPTH, &count, (void*)&subpix_h);\n\t\t\t// Prototype images apparently don't have TIFFTAG_EER_SUBPIXEL_V_DEPTH\n\t\t\tif (TIFFGetField(ftiff, EERRenderer::TIFFTAG_EER_SUBPIXEL_V_DEPTH, &count, (void*)&subpix_v) == 0)\n\t\t\t\tsubpix_v = subpix_h;\n\n\t\t\tif (rle_bits != 7 || *subpix_h != *subpix_v || *subpix_h != 1)\n\t\t\t{\n\t\t\t\tREPORT_ERROR(\"Unsupported compression scheme: type = \" + integerToString(compression) +\n\t\t\t\t             \", rle_bits = \" + integerToString(rle_bits) + \", subpix_h = \" + integerToString(*subpix_h) +\n\t\t\t\t             \", subpix_v = \" + integerToString(*subpix_v));\n\t\t\t}\n\t\t\tsubpixel_bits = 1 << *subpix_h;\n\n\t\t\tif (subpixel_bits == 2 && (eer_upsampling == -1 || eer_upsampling >= 3))\n\t\t\t{\n\t\t\t\tREPORT_ERROR(\"For subpixel_bits = 2, eer_upsamling must be 1 or 2.\");\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tREPORT_ERROR(\"Unknown compression scheme for EER: \" + integerToString(compression));\n\n\t\tif (width != height || (width != EER_4K && width != EER_2K))\n\t\t\tREPORT_ERROR(\"Currently we support only 4096x4096 or 2048x2048 pixel EER movies.\");\n\n\t\ttotal_pixels = (long long)width * height;\n\n\t\t// Find the number of frames\n\t\t// TODO: FIXME: an EER movie might contain a summed frame\n\t\tnframes = TIFFNumberOfDirectories(ftiff);\n\t\tTIFFClose(ftiff);\n#ifdef DEBUG_EER\n\t\tprintf(\"EER in TIFF: %s rle_bits = %d, subpixel_bits = %d, nframes = %d\\n\", fn_movie.c_str(), rle_bits, subpixel_bits, nframes);\n#endif\n\t}\n\n\tfclose(fh);\n\tready = true;\n}",
    "void EERRenderer::lazyReadFrames()\n{\n\t#pragma omp critical(EERRenderer_lazyReadFrames)\n\t{\n\t\tif (!read_data) // cannot return from within omp critical\n\t\t{\t\n\t\t\tTIFF *ftiff = TIFFOpen(fn_movie.c_str(), \"r\");\n\n\t\t\tframe_starts.resize(nframes, 0);\n\t\t\tframe_sizes.resize(nframes, 0);\n\t\t\tbuf = (unsigned char*)malloc(file_size); // This is big enough\n\t\t\tif (buf == NULL)\n\t\t\t\tREPORT_ERROR(\"Failed to allocate the buffer for \" + fn_movie);\n\t\t\tlong long pos = 0;\n\n\t\t\t// Read everything\n\t\t\tfor (int frame = 0; frame < nframes; frame++)\n\t\t\t{\n\t\t\t\tif ((preread_start > 0 && frame < preread_start) ||\n\t\t\t\t    (preread_end > 0 && frame > preread_end))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tTIFFSetDirectory(ftiff, frame);\n\t\t\t\tconst int nstrips = TIFFNumberOfStrips(ftiff);\n\t\t\t\tframe_starts[frame] = pos;\n\n\t\t\t\tfor (int strip = 0; strip < nstrips; strip++)\n\t\t\t\t{\n\t\t\t\t\tconst int strip_size = TIFFRawStripSize(ftiff, strip);\n\t\t\t\t\tif (pos + strip_size >= file_size)\n\t\t\t\t\t\tREPORT_ERROR(\"EER: buffer overflow when reading raw strips.\");\n\n\t\t\t\t\tTIFFReadRawStrip(ftiff, strip, buf + pos, strip_size);\n\t\t\t\t\tpos += strip_size;\n\t\t\t\t\tframe_sizes[frame] += strip_size;\n\t\t\t\t}\n\t#ifdef DEBUG_EER\n\t\t\t\tprintf(\"EER in TIFF: Read frame %d from %s, nstrips = %d, current pos in buffer = %lld / %lld\\n\", frame, fn_movie.c_str(), nstrips, pos, file_size);\n\t#endif\n\t\t\t}\n\n\t\t\tTIFFClose(ftiff);\n\n\t\t\tread_data = true;\n\t\t}\n\t}\n}",
    "void TIFFConverter::unnormalise(FileName fn_movie, FileName fn_tiff)\n{\n\tFileName fn_tmp = fn_tiff + \".tmp\";\n\tTIFF *tif = TIFFOpen(fn_tmp.c_str(), \"w\");\n\tif (tif == NULL)\n\t\tREPORT_ERROR(\"Failed to open the output TIFF file: \" + fn_tiff);\n\n\tImage<float> frame;\n\tchar msg[256];\n\n\tframe.read(fn_movie, false, -1, false, true); // select_img -1, mmap false, is_2D true\n\tif (XSIZE(frame()) != XSIZE(gain()) || YSIZE(frame()) != YSIZE(gain()))\n\t\tREPORT_ERROR(\"The movie \" + fn_movie + \" has a different size from others.\");\n\n\tconst int nframes = NSIZE(frame());\n\tconst float angpix = frame.samplingRateX();\n\tMultidimArray<T> buf(YSIZE(frame()), XSIZE(frame()));\n\n\tfor (int iframe = 0; iframe < nframes; iframe++)\n\t{\n\t\tint error = 0;\n\t\t\n\t\tframe.read(fn_movie, true, iframe, false, true);\n\n\t\t#pragma omp parallel for num_threads(nr_threads) reduction(+:error)\n\t\tFOR_ALL_DIRECT_ELEMENTS_IN_MULTIDIMARRAY(frame())\n\t\t{\n\t\t\tconst float val = DIRECT_MULTIDIM_ELEM(frame(), n);\n\t\t\tconst float gain_here = DIRECT_MULTIDIM_ELEM(gain(), n);\n\t\t\tbool is_bad = DIRECT_MULTIDIM_ELEM(defects(), n) < thresh_reliable;\n\t\t\t\n\t\t\tif (is_bad)\n\t\t\t{\n\t\t\t\t// TODO: implement other strategy\n\t\t\t\tDIRECT_MULTIDIM_ELEM(buf, n) = val;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tint ival = (int)round(val / gain_here);\n\t\t\tconst float expected = gain_here * ival;\n\t\t\tif (fabs(expected - val) > 0.0001)\n\t\t\t{\n\t\t\t\tsnprintf(msg, 255, \" mismatch: %s frame %2d pos %4ld %4ld obs % 8.4f status %d expected % 8.4f gain %.4f\\n\",\n\t\t\t\t\t fn_movie.c_str(), iframe + 1, n / XSIZE(gain()), n % XSIZE(gain()), (double)val, DIRECT_MULTIDIM_ELEM(defects(), n),\n\t\t\t\t\t (double)expected, (double)gain_here);\n\t\t\t\tstd::cerr << msg << std::endl;\n\t\t\t\tif (!dont_die_on_error)\n\t\t\t\t\tREPORT_ERROR(\"Unexpected pixel value in a pixel that was considered reliable\");\n\t\t\t\terror++;\n\t\t\t}\n\n\t\t\tif (!std::is_same<T, float>::value)\n\t\t\t{\n\t\t\t\tconst int overflow = std::is_same<T, short>::value ? 32767: 127;\n\t\t\t\tconst int underflow = std::is_same<T, short>::value ? -32768: 0;\n\n\t\t\t\tif (ival < underflow)\n\t\t\t\t{\n\t\t\t\t\tival = underflow;\n\t\t\t\t\terror++;\n\t\t\t\t\t\n\t\t\t\t\tprintf(\" underflow: %s frame %2d pos %4ld %4ld obs % 8.4f expected % 8.4f gain %.4f\\n\",\n\t\t\t\t\t       fn_movie.c_str(), iframe + 1, n / XSIZE(gain()), n % XSIZE(gain()), (double)val,\n\t\t\t\t\t       (double)expected, (double)gain_here);\n\t\t\t\t}\n\t\t\t\telse if (ival > overflow)\n\t\t\t\t{\n\t\t\t\t\tival = overflow;\n\t\t\t\t\terror++;\n\n\t\t\t\t\tprintf(\" overflow: %s frame %2d pos %4ld %4ld obs % 8.4f expected % 8.4f gain %.4f\\n\",\n\t\t\t\t\t       fn_movie.c_str(), iframe + 1, n / XSIZE(buf), n % XSIZE(buf), (double)val,\n\t\t\t\t\t       (double)expected, (double)gain_here);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tDIRECT_MULTIDIM_ELEM(buf, n) = ival;\n\t\t}\n\n\t\twrite_tiff_one_page(tif, buf, angpix, decide_filter(XSIZE(buf)), deflate_level, line_by_line);\n\n\t\tprintf(\" %s Frame %3d / %3d #Error %10d\\n\", fn_movie.c_str(), iframe + 1, nframes, error);\n\t}\n\n\tTIFFClose(tif);\n\tstd::rename(fn_tmp.c_str(), fn_tiff.c_str());\n}",
    "void TIFFConverter::only_compress(FileName fn_movie, FileName fn_tiff)\n{\n\tFileName fn_tmp = fn_tiff + \".tmp\";\n\tTIFF *tif = TIFFOpen(fn_tmp.c_str(), \"w\");\n\tif (tif == NULL)\n\t\tREPORT_ERROR(\"Failed to open the output TIFF file.\");\n\n\tif (!EERRenderer::isEER(fn_movie))\n\t{\n\t\tImage<T> frame;\n\t\tframe.read(fn_movie, false, -1, false, true); // select_img -1, mmap false, is_2D true\n\t\tconst int nframes = NSIZE(frame());\n\t\tconst float angpix = frame.samplingRateX();\n\t\t\n\t\tfor (int iframe = 0; iframe < nframes; iframe++)\n\t\t{\n\t\t\tframe.read(fn_movie, true, iframe, false, true);\n\t\t\twrite_tiff_one_page(tif, frame(), angpix, decide_filter(XSIZE(frame())), deflate_level, line_by_line);\n\t\t\tprintf(\" %s Frame %3d / %3d\\n\", fn_movie.c_str(), iframe + 1, nframes);\n\t\t}\n\t}\n\telse\n\t{\n\t\tEERRenderer renderer;\n\t\trenderer.read(fn_movie, eer_upsampling);\n\n\t\tconst int nframes = renderer.getNFrames();\n\t\tstd::cout << \" Found \" << nframes << \" raw frames\" << std::endl;\n\n\t\tMultidimArray<T> buf;\n\t\tfor (int frame = 1; frame < nframes; frame += eer_grouping)\n\t\t{\n\t\t\tconst int frame_end = frame + eer_grouping - 1;\n\t\t\tif (frame_end > nframes)\n\t\t\t\tbreak;\n\n\t\t\tstd::cout << \" Rendering EER (hardware) frame \" << frame << \" to \" << frame_end << std::endl;\n\t\t\tbuf.initZeros(renderer.getHeight(), renderer.getWidth());\n\t\t\trenderer.renderFrames(frame, frame_end, buf);\n\t\t\twrite_tiff_one_page(tif, buf, -1, decide_filter(renderer.getWidth(), true), deflate_level, line_by_line);\n\t\t}\n\t}\n\n\tTIFFClose(tif);\n\tstd::rename(fn_tmp.c_str(), fn_tiff.c_str());\n}",
    "bool CImageTIF::Load(const QString& fileName, CImageEx& outImage)\n{\n    CCryFile file;\n    if (!file.Open(fileName.toUtf8().data(), \"rb\"))\n    {\n        CLogFile::FormatLine(\"File not found %s\", fileName.toUtf8().data());\n        return false;\n    }\n\n    MemImage memImage;\n\n    std::vector<uint8> data;\n\n    memImage.size = static_cast<uint32>(file.GetLength());\n\n    data.resize(memImage.size);\n    memImage.buffer = &data[0];\n    memImage.offset = 0;\n\n    file.ReadRaw(memImage.buffer, memImage.size);\n\n\n    // Open the dummy document (which actually only exists in memory)\n    TIFF* tif = TIFFClientOpen (fileName.toUtf8().data(), \"rm\", (thandle_t)&memImage, libtiffDummyReadProc,\n            libtiffDummyWriteProc, libtiffDummySeekProc,\n            libtiffDummyCloseProc, libtiffDummySizeProc, libtiffDummyMapFileProc, libtiffDummyUnmapFileProc);\n\n    //  TIFF* tif = TIFFOpen(fileName,\"r\");\n\n    bool bRet = false;\n\n    if (tif)\n    {\n        uint32 dwWidth, dwHeight;\n        size_t npixels;\n        uint32* raster;\n        char* dccfilename = nullptr;\n\n        TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &dwWidth);\n        TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &dwHeight);\n        TIFFGetField(tif, TIFFTAG_IMAGEDESCRIPTION, &dccfilename);\n\n        npixels = dwWidth * dwHeight;\n\n        raster = (uint32*)_TIFFmalloc((tsize_t)(npixels * sizeof(uint32)));\n\n        if (raster)\n        {\n            if (TIFFReadRGBAImage(tif, dwWidth, dwHeight, raster, 0))\n            {\n                if (outImage.Allocate(dwWidth, dwHeight))\n                {\n                    char* dest = (char*)outImage.GetData();\n                    uint32 dwPitch = dwWidth * 4;\n\n                    for (uint32 dwY = 0; dwY < dwHeight; ++dwY)\n                    {\n                        char* src2 = (char*)&raster[(dwHeight - 1 - dwY) * dwWidth];\n                        char* dest2 = &dest[dwPitch * dwY];\n\n                        memcpy(dest2, src2, dwWidth * 4);\n                    }\n\n                    if (dccfilename)\n                    {\n                        outImage.SetDccFilename(dccfilename);\n                    }\n\n                    bRet = true;\n                }\n            }\n\n            _TIFFfree(raster);\n        }\n\n        TIFFClose(tif);\n    }\n\n    if (!bRet)\n    {\n        outImage.Detach();\n    }\n\n    return bRet;\n}",
    "bool CImageTIF::Load(const QString& fileName, CFloatImage& outImage)\n{\n    // Defined in GeoTIFF format - http://web.archive.org/web/20160403164508/http://www.remotesensing.org/geotiff/spec/geotiffhome.html\n    // Used to get the X, Y, Z scales from a GeoTIFF file\n    static const int GEOTIFF_MODELPIXELSCALE_TAG = 33550;\n\n    \n    CCryFile file;\n    if (!file.Open(fileName.toUtf8().data(), \"rb\"))\n    {\n        CLogFile::FormatLine(\"File not found %s\", fileName.toUtf8().data());\n        return false;\n    }\n\n    MemImage memImage;\n\n    std::vector<uint8> data;\n\n    memImage.size = static_cast<int>(file.GetLength());\n\n    data.resize(memImage.size);\n    memImage.buffer = &data[0];\n    memImage.offset = 0;\n\n    file.ReadRaw(memImage.buffer, memImage.size);\n\n\n    // Open the dummy document (which actually only exists in memory)\n    TIFF* tif = TIFFClientOpen(fileName.toUtf8().data(), \"rm\", (thandle_t)&memImage, libtiffDummyReadProc,\n        libtiffDummyWriteProc, libtiffDummySeekProc,\n        libtiffDummyCloseProc, libtiffDummySizeProc, libtiffDummyMapFileProc, libtiffDummyUnmapFileProc);\n\n    //  TIFF* tif = TIFFOpen(fileName,\"r\");\n\n    bool bRet = false;\n\n    if (tif)\n    {\n        uint32 width = 0, height = 0;\n        uint16 spp = 0, bpp = 0, format = 0;\n        char* dccfilename = nullptr;\n\n        TIFFGetField(tif, TIFFTAG_IMAGEDESCRIPTION, &dccfilename);\n\n        TIFFGetFieldDefaulted(tif, TIFFTAG_IMAGEWIDTH, &width);\n        TIFFGetFieldDefaulted(tif, TIFFTAG_IMAGELENGTH, &height);\n\n        TIFFGetFieldDefaulted(tif, TIFFTAG_BITSPERSAMPLE, &bpp);     // how many bits each color component is.  typically 8-bit, but could be 16-bit.\n        TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLESPERPIXEL, &spp);   // how many color components per pixel?  1=greyscale, 3=RGB, 4=RGBA\n        TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLEFORMAT, &format);   // format of the pixel data - int, uint, float.  \n\n        // There are two types of 32-bit floating point TIF semantics.  Paint programs tend to use values in the 0.0 - 1.0 range.\n        // GeoTIFF files use values where 1.0 = 1 meter by default, but also have an optional ZScale parameter to provide additional\n        // scaling control.\n\n        // By default, we'll assume this is a regular TIFF that we want to leave in the 0.0 - 1.0 range.\n        float pixelValueScale = 1.0f;\n\n        // Check to see if it's a GeoTIFF, and if so, whether or not it has the ZScale parameter.\n        uint32 tagCount = 0;\n        double *pixelScales = nullptr;\n        if (TIFFGetField(tif, GEOTIFF_MODELPIXELSCALE_TAG, &tagCount, &pixelScales) == 1)\n        {\n            // if there's an xyz scale, and the Z scale isn't 0, let's use it.\n            if ((tagCount == 3) && (pixelScales != nullptr) && (pixelScales[2] != 0.0f))\n            {\n                pixelValueScale = static_cast<float>(pixelScales[2]);\n            }\n        }\n\n        uint32 linesize = static_cast<uint32>(TIFFScanlineSize(tif));\n        uint8* linebuf = static_cast<uint8*>(_TIFFmalloc(linesize));\n\n        // We assume that a scanline has all of the samples in it.  Validate the assumption.\n        assert(linesize == (width * (bpp / 8) * spp));\n\n        // Aliases for linebuf to make it easier to pull different types out of the scanline.\n        uint16* linebufUint16 = reinterpret_cast<uint16*>(linebuf);\n        uint32* linebufUint32 = reinterpret_cast<uint32*>(linebuf);\n        float* linebufFloat = reinterpret_cast<float*>(linebuf);\n\n        if (linebuf)\n        {\n            if (outImage.Allocate(width, height))\n            {\n                float* dest = outImage.GetData();\n                bRet = true;\n\n                float maxPixelValue = 0.0f;\n\n                for (uint32 y = 0; y < height; y++)\n                {\n                    TIFFReadScanline(tif, linebuf, y);\n\n                    // For each pixel, we either scale or clamp the values to a 16-bit range.  It is asymmetric behaviour, but based\n                    // on assumptions about the input data:\n                    // 8-bit values are scaled up because 8-bit textures used as heightmaps are usually scaled-down 16-bit values.\n                    // 32-bit values may or may not need to scale down, depending on the intended authoring range.  Our assumption\n                    // is that they were most likely authored with the intent of 1:1 value translations.\n\n                    for (uint32 x = 0; x < width; x++)\n                    {\n                        switch (bpp)\n                        {\n                            case 8:\n                                // Scale 0-255 to 0.0 - 1.0\n                                dest[(y * width) + x] = static_cast<float>(linebuf[x * spp]) / static_cast<float>(std::numeric_limits<uint8>::max());\n                                break;\n                            case 16:\n                                // Scale 0-65535 to 0.0 - 1.0\n                                dest[(y * width) + x] = static_cast<float>(linebufUint16[x * spp]) / static_cast<float>(std::numeric_limits<uint16>::max());\n                                break;\n                            case 32:\n                                // 32-bit values could be ints or floats.\n\n                                if (format == SAMPLEFORMAT_INT)\n                                {\n                                    // Scale 0-max int32 to 0.0 - 1.0\n                                    dest[(y * width) + x] = clamp_tpl(static_cast<float>(linebufUint32[x * spp]) / static_cast<float>(std::numeric_limits<int32>::max()), 0.0f, 1.0f);\n                                }\n                                else if (format == SAMPLEFORMAT_UINT)\n                                {\n                                    // Scale 0-max uint32 to 0.0 - 1.0\n                                    dest[(y * width) + x] = clamp_tpl(static_cast<float>(linebufUint32[x * spp]) / static_cast<float>(std::numeric_limits<uint32>::max()), 0.0f, 1.0f);\n                                }\n                                else if (format == SAMPLEFORMAT_IEEEFP)\n                                {\n                                    dest[(y * width) + x] = linebufFloat[x * spp] * pixelValueScale;\n                                }\n                                else\n                                {\n                                    // Unknown / unsupported format.\n                                    bRet = false;\n                                }\n                                break;\n                            default:\n                                // Unknown / unsupported format.\n                                bRet = false;\n                                break;\n                        }\n\n                        maxPixelValue = max(maxPixelValue, dest[(y * width) + x]);\n                    }\n                }\n\n                if (dccfilename)\n                {\n                    outImage.SetDccFilename(dccfilename);\n                }\n\n                // If this is a GeoTIFF using 32-bit floats, we will end up outside the 0.0 - 1.0 range.  Let's scale it back down to 0.0 - 1.0.\n                if (maxPixelValue > 1.0f)\n                {\n                    for (uint32 y = 0; y < height; y++)\n                    {\n                        for (uint32 x = 0; x < width; x++)\n                        {\n                            dest[(y * width) + x] = dest[(y * width) + x] / maxPixelValue;\n                        }\n                    }\n                }\n            }\n\n            _TIFFfree(linebuf);\n        }\n\n        TIFFClose(tif);\n    }\n\n    if (!bRet)\n    {\n        outImage.Detach();\n    }\n\n    return bRet;\n}",
    "bool CImageTIF::SaveRAW(const QString& fileName, const void* pData, int width, int height, int bytesPerChannel, int numChannels, bool bFloat, const char* preset)\n{\n    if (bFloat && (bytesPerChannel != 2 && bytesPerChannel != 4))\n    {\n        bFloat = false;\n    }\n\n    bool bRet = false;\n\n    CFileUtil::OverwriteFile(fileName);\n    TIFF* tif = TIFFOpen(fileName.toUtf8().data(), \"wb\");\n    if (tif)\n    {\n        TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, width);\n        TIFFSetField(tif, TIFFTAG_IMAGELENGTH, height);\n        TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, numChannels);\n        TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, bytesPerChannel * 8);\n        TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n        TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, 1);\n        TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n        TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, (numChannels == 1) ? PHOTOMETRIC_MINISBLACK : PHOTOMETRIC_RGB);\n        TIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n        if (bFloat)\n        {\n            TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);\n        }\n\n        if (preset && preset[0])\n        {\n            AZStd::string tiffphotoshopdata, valueheader;\n            AZStd::string presetkeyvalue = AZStd::string(\"/preset=\") + AZStd::string(preset);\n\n            valueheader.push_back('\\x1C');\n            valueheader.push_back('\\x02');\n            valueheader.push_back('\\x28');\n            valueheader.push_back((presetkeyvalue.size() >> 8) & 0xFF);\n            valueheader.push_back((presetkeyvalue.size()) & 0xFF);\n            valueheader.append(presetkeyvalue);\n\n            tiffphotoshopdata.push_back('8');\n            tiffphotoshopdata.push_back('B');\n            tiffphotoshopdata.push_back('I');\n            tiffphotoshopdata.push_back('M');\n            tiffphotoshopdata.push_back('\\x04');\n            tiffphotoshopdata.push_back('\\x04');\n            tiffphotoshopdata.push_back('\\x00');\n            tiffphotoshopdata.push_back('\\x00');\n\n            tiffphotoshopdata.push_back((valueheader.size() >> 24) & 0xFF);\n            tiffphotoshopdata.push_back((valueheader.size() >> 16) & 0xFF);\n            tiffphotoshopdata.push_back((valueheader.size() >> 8) & 0xFF);\n            tiffphotoshopdata.push_back((valueheader.size()) & 0xFF);\n            tiffphotoshopdata.append(valueheader);\n\n            TIFFSetField(tif, TIFFTAG_PHOTOSHOP, tiffphotoshopdata.size(), tiffphotoshopdata.c_str());\n        }\n\n        size_t pitch = width * bytesPerChannel * numChannels;\n        char* raster = (char*) _TIFFmalloc((tsize_t)(pitch * height));\n        memcpy(raster, pData, pitch * height);\n\n        bRet = true;\n        for (int h = 0; h < height; ++h)\n        {\n            size_t offset = h * pitch;\n            int err = TIFFWriteScanline(tif, raster + offset, h, 0);\n            if (err < 0)\n            {\n                bRet = false;\n                break;\n            }\n        }\n        _TIFFfree(raster);\n        TIFFClose(tif);\n    }\n    return bRet;\n}",
    "const char* CImageTIF::GetPreset(const QString& fileName)\n{\n    std::vector<uint8> data;\n    CCryFile file;\n    if (!file.Open(fileName.toUtf8().data(), \"rb\"))\n    {\n        CLogFile::FormatLine(\"File not found %s\", fileName.toUtf8().data());\n        return nullptr;\n    }\n\n    MemImage memImage;\n\n    memImage.size = static_cast<uint32>(file.GetLength());\n\n    data.resize(memImage.size);\n    memImage.buffer = &data[0];\n    memImage.offset = 0;\n\n    file.ReadRaw(memImage.buffer, memImage.size);\n\n    TIFF* tif = TIFFClientOpen (fileName.toUtf8().data(), \"rm\", (thandle_t)&memImage, libtiffDummyReadProc,\n            libtiffDummyWriteProc, libtiffDummySeekProc,\n            libtiffDummyCloseProc, libtiffDummySizeProc, libtiffDummyMapFileProc, libtiffDummyUnmapFileProc);\n\n    AZStd::string strReturn;\n    char* preset = nullptr;\n    int size;\n    if (tif)\n    {\n        TIFFGetField(tif, TIFFTAG_PHOTOSHOP, &size, &preset);\n        for (int i = 0; i < size; ++i)\n        {\n            if (!strncmp((preset + i), \"preset\", 6))\n            {\n                char* presetoffset = preset + i;\n                strReturn = presetoffset;\n                if (strReturn.find('/') != -1)\n                {\n                    strReturn = strReturn.substr(0, strReturn.find('/'));\n                }\n\n                break;\n            }\n        }\n        TIFFClose(tif);\n    }\n    return strReturn.c_str();\n}",
    "FrameCaptureOutputResult TiffFrameCaptureOutput(\n            const AZStd::string& outputFilePath, const AZ::RPI::AttachmentReadback::ReadbackResult& readbackResult)\n        {\n            AZStd::shared_ptr<AZStd::vector<uint8_t>> buffer = readbackResult.m_dataBuffer;\n            const uint32_t width = readbackResult.m_imageDescriptor.m_size.m_width;\n            const uint32_t height = readbackResult.m_imageDescriptor.m_size.m_height;\n            const uint32_t numChannels = AZ::RHI::GetFormatComponentCount(readbackResult.m_imageDescriptor.m_format);\n            const uint32_t bytesPerChannel = AZ::RHI::GetFormatSize(readbackResult.m_imageDescriptor.m_format) / numChannels;\n            const uint32_t bitsPerChannel = bytesPerChannel * 8;\n\n            TIFF* out = TIFFOpen(outputFilePath.c_str(), \"w\");\n            TIFFSetField(out, TIFFTAG_IMAGEWIDTH, width);\n            TIFFSetField(out, TIFFTAG_IMAGELENGTH, height);\n            TIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, numChannels);\n            TIFFSetField(out, TIFFTAG_BITSPERSAMPLE, bitsPerChannel);\n            TIFFSetField(out, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n            TIFFSetField(out, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n            TIFFSetField(out, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n            TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n            TIFFSetField(out, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);   // interpret each pixel as a float\n\n            size_t pitch = width * numChannels * bytesPerChannel;\n            AZ_Assert((pitch * height) == buffer->size(), \"Image buffer does not match allocated bytes for tiff saving.\")\n            unsigned char* raster = (unsigned char*)_TIFFmalloc((tsize_t)(pitch * height));\n            memcpy(raster, buffer->data(), pitch * height);\n            bool success = true;\n            for (uint32_t h = 0; h < height; ++h)\n            {\n                size_t offset = h * pitch;\n                int err = TIFFWriteScanline(out, raster + offset, h, 0);\n                if (err < 0)\n                {\n                    success = false;\n                    break;\n                }\n            }\n            _TIFFfree(raster);\n            TIFFClose(out);\n            return success ? FrameCaptureOutputResult{ FrameCaptureResult::Success, AZStd::nullopt }\n                           : FrameCaptureOutputResult{ FrameCaptureResult::InternalError, \"Unable to save tif frame capture output to \" + outputFilePath };\n        }",
    "~TiffFileRead()\n            {\n                if (m_tif != nullptr)\n                {\n                    TIFFClose(m_tif);\n                }\n            }",
    "Image load(string filename) {\n    TIFF *tiff = TIFFOpen(filename.c_str(), \"r\");\n\n    assert(tiff, \"Could not open file %s\\n\", filename.c_str());\n\n    // Get basic information from TIFF header\n    int w;\n    assert(TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, &w),\n           \"Width not set in TIFF\\n\");\n    int h;\n    assert(TIFFGetField(tiff, TIFFTAG_IMAGELENGTH, &h),\n           \"Height not set in tiff\\n\");\n    unsigned short c;\n    assert(TIFFGetField(tiff, TIFFTAG_SAMPLESPERPIXEL, &c),\n           \"Number of channels not set in tiff\\n\");\n\n    unsigned short bitsPerSample;\n    assert(TIFFGetField(tiff, TIFFTAG_BITSPERSAMPLE, &bitsPerSample),\n           \"Bits per sample not set in TIFF\\n\");\n\n    unsigned short sampleFormat;\n    if (!TIFFGetField(tiff, TIFFTAG_SAMPLEFORMAT, &sampleFormat)) {\n        //printf(\"WARNING: couldn't find sample format in tiff, assuming %i bit unsigned integers\\n\", bitsPerSample);\n        sampleFormat = SAMPLEFORMAT_UINT;\n    }\n\n    Image im(w, h, 1, c);\n    int bytesPerSample = bitsPerSample / 8;\n\n    assert(im.channels *im.width *bytesPerSample == TIFFScanlineSize(tiff),\n           \"Unsupported scanline format in TIFF file, might be stored in tiles or strips.\\n\");\n\n    if (bytesPerSample == 1 && sampleFormat == SAMPLEFORMAT_UINT) {\n        readTiff<uint8_t>(im, tiff, 0x000000ff);\n    } else if (bytesPerSample == 1 && sampleFormat == SAMPLEFORMAT_INT) {\n        readTiff<int8_t>(im, tiff, 0x000000ff);\n    } else if (bytesPerSample == 2 && sampleFormat == SAMPLEFORMAT_UINT) {\n        readTiff<uint16_t>(im, tiff, 0x0000ffff);\n    } else if (bytesPerSample == 2 && sampleFormat == SAMPLEFORMAT_INT) {\n        readTiff<int16_t>(im, tiff, 0x0000ffff);\n#ifndef NO_OPENEXR\n    } else if (bytesPerSample == 2 && sampleFormat == SAMPLEFORMAT_IEEEFP) {\n        readTiff<half>(im, tiff, 1);\n#endif\n    } else if (bytesPerSample == 4 && sampleFormat == SAMPLEFORMAT_UINT) {\n        readTiff<uint32_t>(im, tiff, 0xffffffff);\n    } else if (bytesPerSample == 4 && sampleFormat == SAMPLEFORMAT_INT) {\n        readTiff<int32_t>(im, tiff, 0xffffffff);\n    } else if (bytesPerSample == 4 && sampleFormat == SAMPLEFORMAT_IEEEFP) {\n        readTiff<float>(im, tiff, 1);\n    } else if (bytesPerSample == 8 && sampleFormat == SAMPLEFORMAT_IEEEFP) {\n        readTiff<double>(im, tiff, 1);\n    } else if (sampleFormat == SAMPLEFORMAT_UINT || sampleFormat == SAMPLEFORMAT_INT) {\n        panic(\"%i bytes per sample for integers unsupported\\n\", bytesPerSample);\n    } else if (sampleFormat == SAMPLEFORMAT_IEEEFP) {\n        panic(\"%i bytes per sample for floats unsupported\\n\", bytesPerSample);\n    } else {\n        panic(\"Sample format unsupported (not int, unsigned int, or float)\\n\");\n    }\n\n    TIFFClose(tiff);\n\n    return im;\n}",
    "void save(Image im, string filename, string type) {\n    // Open 16-bit TIFF file for writing\n    TIFF *tiff = TIFFOpen(filename.c_str(), \"w\");\n    assert(tiff, \"Could not open file %s\\n\", filename.c_str());\n\n    if (type == \"\") {\n        type = \"uint16\";\n    }\n\n    assert(im.frames == 1, \"Can only save single frame tiffs\\n\");\n\n    TIFFSetField(tiff, TIFFTAG_SAMPLESPERPIXEL, im.channels);\n    TIFFSetField(tiff, TIFFTAG_IMAGEWIDTH, im.width);\n    TIFFSetField(tiff, TIFFTAG_IMAGELENGTH, im.height);\n\n    if (im.channels == 1) { TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK); } // grayscale, black is 0\n    else if (im.channels == 3) { TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB); }\n    else {\n        printf(\"WARNING: Image is neither 1 channel nor 3 channels, so cannot set a valid photometric interpretation.\\n\");\n    }\n    TIFFSetField(tiff, TIFFTAG_ROWSPERSTRIP, 1L);\n    TIFFSetField(tiff, TIFFTAG_XRESOLUTION, 1.0);\n    TIFFSetField(tiff, TIFFTAG_YRESOLUTION, 1.0);\n    TIFFSetField(tiff, TIFFTAG_RESOLUTIONUNIT, 1);\n    TIFFSetField(tiff, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n    TIFFSetField(tiff, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    TIFFSetField(tiff, TIFFTAG_ORIENTATION, (int)ORIENTATION_TOPLEFT);\n\n    if (type == \"int8\" || type == \"char\") {\n        TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 8);\n        TIFFSetField(tiff, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_INT);\n        writeTiff<int8_t>(im, tiff, 0x000000ff);\n    } else if (type == \"uint8\" || type == \"unsigned char\") {\n        TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 8);\n        TIFFSetField(tiff, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT);\n        writeTiff<uint8_t>(im, tiff, 0x000000ff);\n    } else if (type == \"int16\" || type == \"short\") {\n        TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 16);\n        TIFFSetField(tiff, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_INT);\n        writeTiff<int16_t>(im, tiff, 0x0000ffff);\n    } else if (type == \"uint16\" || type == \"unsigned short\") {\n        TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 16);\n        TIFFSetField(tiff, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT);\n        writeTiff<uint16_t>(im, tiff, 0x0000ffff);\n#ifndef NO_OPENEXR\n    } else if (type == \"float16\" || type == \"half\") {\n        TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 16);\n        TIFFSetField(tiff, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);\n        writeTiff<half>(im, tiff, 1);\n#endif\n    } else if (type == \"int32\" || type == \"int\") {\n        TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 32);\n        TIFFSetField(tiff, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_INT);\n        writeTiff<int32_t>(im, tiff, 0xffffffff);\n    } else if (type == \"uint32\" || type == \"unsigned int\") {\n        TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 32);\n        TIFFSetField(tiff, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT);\n        writeTiff<uint32_t>(im, tiff, 0xffffffff);\n    } else if (type == \"float32\" || type == \"float\") {\n        TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 32);\n        TIFFSetField(tiff, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);\n        writeTiff<float>(im, tiff, 1);\n    } else if (type == \"float64\" || type == \"double\") {\n        TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 64);\n        TIFFSetField(tiff, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);\n        writeTiff<double>(im, tiff, 1);\n    } else {\n        panic(\"Unknown type %s\\n\", type.c_str());\n    }\n\n    // Close 16-bit TIFF file\n    TIFFClose(tiff);\n}",
    "void WriteTIFF(const char *name, float *rgba, int XRes, int YRes, bool hasAlpha) \n{\n    // Open 8-bit TIFF file for writing\n    TIFF *tiff = TIFFOpen(name, \"w\");\n    if (!tiff) {\n\tfprintf(stderr, \"Unable to open TIFF %s for writing\", name);\n\treturn;\n    }\n\n    int nChannels = hasAlpha ? 4 : 3;\n    TIFFSetField(tiff, TIFFTAG_SAMPLESPERPIXEL, nChannels);\n    if (hasAlpha) {\n\tshort int extra[] = { EXTRASAMPLE_ASSOCALPHA };\n\tTIFFSetField(tiff, TIFFTAG_EXTRASAMPLES, (short)1, extra);\n    }\n    // Write image resolution information\n    TIFFSetField(tiff, TIFFTAG_IMAGEWIDTH, XRes);\n    TIFFSetField(tiff, TIFFTAG_IMAGELENGTH, YRes);\n    TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 8);\n    TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n    // Set Generic TIFF Fields\n    TIFFSetField(tiff, TIFFTAG_ROWSPERSTRIP, 1);\n    TIFFSetField(tiff, TIFFTAG_XRESOLUTION, 1.f);\n    TIFFSetField(tiff, TIFFTAG_YRESOLUTION, 1.f);\n    TIFFSetField(tiff, TIFFTAG_RESOLUTIONUNIT, (short)1);\n    TIFFSetField(tiff, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n    TIFFSetField(tiff, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    TIFFSetField(tiff, TIFFTAG_ORIENTATION, (int)ORIENTATION_TOPLEFT);\n    // Write 8-bit scanlines\n    u_char *buf = new u_char[nChannels * XRes];\n    for (int y = 0; y < YRes; ++y) {\n\tu_char *bufp = buf;\n\tfor (int x = 0; x < XRes; ++x) {\n\t    // Pack 8-bit pixels samples into buf\n\t    for (int s = 0; s < nChannels; ++s)\n\t\t*bufp++ = (u_char)*rgba++;\n\t}\n\tTIFFWriteScanline(tiff, buf, y, 1);\n    }\n    // Close 8-bit TIFF file\n    delete[] buf;\n    TIFFClose(tiff);\n}",
    "TerrainImportOp PrepareTerrainImport(\n        const ::Assets::ResChar input[], \n        unsigned destNodeDims, unsigned destCellTreeDepth)\n    {\n        TerrainImportOp result;\n        result._sourceDims = UInt2(0, 0);\n        result._sourceFile = input;\n        result._sourceIsGood = false;\n        result._importCoverageFormat = (unsigned)ImpliedTyping::TypeCat::Float;\n\n        auto ext = XlExtension(input);\n        if (ext && (!XlCompareStringI(ext, \"hdr\") || !XlCompareStringI(ext, \"flt\"))) {\n\n            result._sourceFormat = TerrainImportOp::SourceFormat::AbsoluteFloats;\n            result._sourceHeightRange = Float2(FLT_MAX, -FLT_MAX);\n\n            ::Assets::ResChar inputFile[MaxPath];\n            XlCopyString(inputFile, input);\n            XlChopExtension(inputFile);\n            XlCatString(inputFile, dimof(inputFile), \".hdr\");\n\n            size_t fileSize = 0;\n            auto block = LoadFileAsMemoryBlock(inputFile, &fileSize);\n            if (block.get() && fileSize) {\n                std::string configAsString(block.get(), &block[fileSize]);\n                std::regex parse(\"^(\\\\S+)\\\\s+(.*)\");\n\n                std::vector<int> captureGroups;\n                captureGroups.push_back(1);\n                captureGroups.push_back(2);\n    \n                const std::sregex_token_iterator end;\n                std::sregex_token_iterator iter(configAsString.begin(), configAsString.end(), parse, captureGroups);\n                for (;iter != end;) {\n                    auto paramName = *iter++;\n                    auto paramValue = *iter++;\n\n                        //  we ignore many parameters. But we at least need to get ncols & nrows\n                        //  These tell us the dimensions of the input data\n                    if (!XlCompareStringI(paramName.str().c_str(), \"ncols\")) { result._sourceDims[0] = XlAtoI32(paramValue.str().c_str()); }\n                    if (!XlCompareStringI(paramName.str().c_str(), \"nrows\")) { result._sourceDims[1] = XlAtoI32(paramValue.str().c_str()); }\n                }\n\n                result._sourceIsGood = true;\n            } else {\n                result._warnings.push_back(\"Could not open input file\");\n            }\n\n        } else if (ext && (!XlCompareStringI(ext, \"tif\") || !XlCompareStringI(ext, \"tiff\"))) {\n\n            auto oldWarningHandler = TIFFSetWarningHandler(&TIFFWarningHandler);\n            auto oldErrorHandler = TIFFSetErrorHandler(&TIFFErrorHandler);\n            s_tiffWarningVector = &result._warnings;\n            auto autoClose = MakeAutoClose([oldWarningHandler, oldErrorHandler]() \n                {\n                    TIFFSetWarningHandler(oldWarningHandler);\n                    TIFFSetErrorHandler(oldErrorHandler);\n                    s_tiffWarningVector = nullptr;\n                });\n            \n            auto* tif = TIFFOpen(input, \"r\");\n            if (tif) {\n                auto autoClose = MakeAutoClose([tif]() { TIFFClose(tif); });\n\n                TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &result._sourceDims[0]);\n                TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &result._sourceDims[1]);\n\n                uint32 bitsPerPixel = 32;\n                uint32 sampleFormat = SAMPLEFORMAT_IEEEFP;\n                TIFFGetFieldDefaulted(tif, TIFFTAG_BITSPERSAMPLE, &bitsPerPixel);\n                TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLEFORMAT, &sampleFormat);\n\n                switch (sampleFormat) {\n                case SAMPLEFORMAT_UINT:\n\t\t\t\t\tresult._sourceFormat = TerrainImportOp::SourceFormat::Quantized;\n                    if (bitsPerPixel == 8)          { result._sourceHeightRange = Float2(0.f, float(0xff)); result._importCoverageFormat = (unsigned)ImpliedTyping::TypeCat::UInt8; }\n                    else if (bitsPerPixel == 16)    { result._sourceHeightRange = Float2(0.f, float(0xffff)); result._importCoverageFormat = (unsigned)ImpliedTyping::TypeCat::UInt16; }\n                    else if (bitsPerPixel == 32)    { result._sourceHeightRange = Float2(0.f, float(0xffffffff)); result._importCoverageFormat = (unsigned)ImpliedTyping::TypeCat::UInt32; }\n                    else                            { result._warnings.push_back(\"Bad bits per pixel\"); return result; }\n                    break;\n\n                case SAMPLEFORMAT_INT:\n                    result._sourceFormat = TerrainImportOp::SourceFormat::Quantized;\n                    if (bitsPerPixel == 8)          { result._sourceHeightRange = Float2(float( INT8_MIN), float( INT8_MAX)); result._importCoverageFormat = (unsigned)ImpliedTyping::TypeCat::UInt8; }\n                    else if (bitsPerPixel == 16)    { result._sourceHeightRange = Float2(float(INT16_MIN), float(INT16_MAX)); result._importCoverageFormat = (unsigned)ImpliedTyping::TypeCat::UInt16; }\n                    else if (bitsPerPixel == 32)    { result._sourceHeightRange = Float2(float(INT32_MIN), float(INT32_MAX)); result._importCoverageFormat = (unsigned)ImpliedTyping::TypeCat::UInt32; }\n                    else                            { result._warnings.push_back(\"Bad bits per pixel\"); return result; }\n                    break;\n\n                case SAMPLEFORMAT_IEEEFP:\n                    result._sourceFormat = TerrainImportOp::SourceFormat::AbsoluteFloats;\n                    if (bitsPerPixel != 16 && bitsPerPixel != 32)\n                        { result._warnings.push_back(\"Bad bits per pixel\"); return result; }\n\n                    result._importCoverageFormat = (unsigned)ImpliedTyping::TypeCat::Float;     // (todo -- float16 support?)\n                    break;\n\n                default:\n                    result._warnings.push_back(\"Unsupported sample format\");\n                    return result;\n                }\n\n                result._sourceIsGood = true;\n            } else {\n                result._warnings.push_back(\"Could not open tiff file\");\n            }\n\n        } else {\n            result._warnings.push_back(\"Unknown input file format\");\n        }\n\n        result._importMins = UInt2(0, 0);\n        result._importMaxs = ClampImportDims(result._sourceDims, destNodeDims, destCellTreeDepth);\n        result._importHeightRange = result._sourceHeightRange;\n        return result;\n    }",
    "void ExecuteTerrainImport(\n        const TerrainImportOp& op,\n        const ::Assets::ResChar outputDir[],\n        unsigned destNodeDims, unsigned destCellTreeDepth,\n        SceneEngine::TerrainCoverageId coverageId,\n        ImpliedTyping::TypeCat dstType,\n        ConsoleRig::IProgress* progress)\n    {\n        auto initStep = progress ? progress->BeginStep(\"Load source data\", 1, false) : nullptr;\n\n        auto oldWarningHandler = TIFFSetWarningHandler(&TIFFWarningHandler);\n        auto oldErrorHandler = TIFFSetErrorHandler(&TIFFErrorHandler);\n        s_tiffWarningVector = nullptr;\n        auto autoClose = MakeAutoClose([oldWarningHandler, oldErrorHandler]() \n            {\n                TIFFSetWarningHandler(oldWarningHandler);\n                TIFFSetErrorHandler(oldErrorHandler);\n                s_tiffWarningVector = nullptr;\n            });\n\n        if (!op._sourceIsGood || ((op._importMaxs[0] <= op._importMins[0]) && (op._importMaxs[1] <= op._importMins[1]))) {\n            Throw(\n                ::Exceptions::BasicLabel(\"Bad or missing input terrain config file (%s)\", op._sourceFile.c_str()));\n        }\n\n        UInt2 importOffset =  op._importMins;\n        UInt2 finalDims = ClampImportDims(op._importMaxs - op._importMins, destNodeDims, destCellTreeDepth);\n\n        CreateDirectoryRecursive(outputDir);\n\n        auto dstSampleSize = ImpliedTyping::TypeDesc(dstType).GetSize();\n        uint64 resultSize = \n            sizeof(TerrainUberHeader)\n            + finalDims[0] * finalDims[1] * dstSampleSize\n            ;\n\n        ::Assets::ResChar outputUberFileName[MaxPath]; \n        SceneEngine::TerrainConfig::GetUberSurfaceFilename(\n            outputUberFileName, dimof(outputUberFileName),\n            outputDir, coverageId);\n\n        MemoryMappedFile outputUberFile(outputUberFileName, resultSize, MemoryMappedFile::Access::Write);\n        if (!outputUberFile.IsValid())\n            Throw(::Exceptions::BasicLabel(\"Couldn't open output file (%s)\", outputUberFileName));\n\n        auto& hdr   = *(TerrainUberHeader*)outputUberFile.GetData();\n        hdr._magic  = TerrainUberHeader::Magic;\n        hdr._width  = finalDims[0];\n        hdr._height = finalDims[1];\n        hdr._typeCat = (unsigned)dstType;\n        hdr._typeArrayCount = 1;\n        hdr._dummy[0] = hdr._dummy[1] = hdr._dummy[2]  = 0;\n\n        void* outputArray = PtrAdd(outputUberFile.GetData(), sizeof(TerrainUberHeader));\n\n        auto ext = XlExtension(op._sourceFile.c_str());\n        if (ext && (!XlCompareStringI(ext, \"hdr\") || !XlCompareStringI(ext, \"flt\"))) {\n            if (dstType != ImpliedTyping::TypeCat::Float)\n                Throw(::Exceptions::BasicLabel(\"Attempting to load float format input into non-float destination (%s)\", op._sourceFile.c_str()));\n\n            MemoryMappedFile inputFileData(op._sourceFile.c_str(), 0, MemoryMappedFile::Access::Read);\n            if (!inputFileData.IsValid())\n                Throw(::Exceptions::BasicLabel(\"Couldn't open input file (%s)\", op._sourceFile.c_str()));\n\n            if (op._sourceFormat!=TerrainImportOp::SourceFormat::AbsoluteFloats)\n                Throw(::Exceptions::BasicLabel(\"Expecting absolute floats when loading from raw float array\"));\n\n            if (initStep) {\n                initStep->Advance();\n                initStep.reset();\n            }\n\n            auto copyRows = std::min(finalDims[1], op._importMaxs[1]) - op._importMins[1];\n            const unsigned progressStep = 16;\n            auto copyStep = progress ? progress->BeginStep(\"Create uber surface data\", copyRows / progressStep, true) : nullptr;\n\n            auto inputArray = (const float*)inputFileData.GetData();\n\n            unsigned yoff = op._importMins[1];\n            unsigned y2=0;\n            for (; (y2+progressStep)<=copyRows; y2+=progressStep) {\n                for (unsigned y=0; y<progressStep; ++y) {\n                    std::copy(\n                        &inputArray[(y2+y+yoff) * op._sourceDims[0] + op._importMins[0]],\n                        &inputArray[(y2+y+yoff) * op._sourceDims[0] + std::min(op._sourceDims[0], op._importMaxs[0])],\n                        (float*)PtrAdd(outputArray, ((y2+y) * finalDims[0]) * dstSampleSize));\n                }\n\n                if (copyStep) {\n                    if (copyStep->IsCancelled())\n                        Throw(::Exceptions::BasicLabel(\"User cancelled\"));\n                    copyStep->Advance();\n                }\n            }\n\n                // remainder rows left over after dividing by progressStep\n            for (; y2<copyRows; ++y2) {\n                std::copy(\n                    &inputArray[(y2+yoff) * op._sourceDims[0] + op._importMins[0]],\n                    &inputArray[(y2+yoff) * op._sourceDims[0] + std::min(op._sourceDims[0], op._importMaxs[0])],\n                    (float*)PtrAdd(outputArray, (y2 * finalDims[0]) * dstSampleSize));\n            }\n        } else if (ext && (!XlCompareStringI(ext, \"tif\") || !XlCompareStringI(ext, \"tiff\"))) {\n                // attempt to read geotiff file\n            auto* tif = TIFFOpen(op._sourceFile.c_str(), \"r\");\n            if (!tif)\n                Throw(::Exceptions::BasicLabel(\"Couldn't open input file (%s)\", op._sourceFile.c_str()));\n\n            auto autoClose = MakeAutoClose([tif]() { TIFFClose(tif); });\n            auto stripCount = TIFFNumberOfStrips(tif);\n\n            auto copyStep = \n                  progress \n                ? progress->BeginStep(\"Create uber surface data\", stripCount, true)\n                : nullptr;\n\n            uint32 rowsperstrip = 1;\n            TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n\n            uint32 bitsPerPixel = 32;\n            uint32 sampleFormat = SAMPLEFORMAT_IEEEFP;\n            TIFFGetFieldDefaulted(tif, TIFFTAG_BITSPERSAMPLE, &bitsPerPixel);\n            TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLEFORMAT, &sampleFormat);\n\n                //  We only support loading a few input formats.\n                //  TIFF supports a wide variety of formats. If we get something\n                //  unexpected, just throw;\n            if (sampleFormat != SAMPLEFORMAT_UINT && sampleFormat != SAMPLEFORMAT_INT && sampleFormat != SAMPLEFORMAT_IEEEFP)\n                Throw(::Exceptions::BasicLabel(\"Unexpected sample format in input file (%s). Only supporting integer or floating point inputs\", op._sourceFile.c_str()));\n\n            if (bitsPerPixel != 8 && bitsPerPixel != 16 && bitsPerPixel != 32)\n                Throw(::Exceptions::BasicLabel(\"Unexpected bits per sample in input file (%s). Only supporting 8, 16 or 32 bit formats. Try floating a 32 bit float format.\", op._sourceFile.c_str()));\n\n            auto stripSize = TIFFStripSize(tif);\n            if (!stripSize)\n                Throw(::Exceptions::BasicLabel(\"Could not get strip byte codes from tiff file (%s). Input file may be corrupted.\", op._sourceFile.c_str()));\n            \n            auto stripBuffer = std::make_unique<char[]>(stripSize);\n            XlSetMemory(stripBuffer.get(), 0, stripSize);\n\n            typedef void ConversionFn(void*, const ImpliedTyping::TypeDesc&, const void*, size_t, double, double);\n            ConversionFn* convFn;\n            switch (sampleFormat) {\n            case SAMPLEFORMAT_UINT:\n\t\t\t\tif (bitsPerPixel == 8)          convFn = (ConversionFn*)&SimpleConvertGen<uint8>;\n                else if (bitsPerPixel == 16)    convFn = (ConversionFn*)&SimpleConvertGen<uint16>;\n                else if (bitsPerPixel == 32)    convFn = (ConversionFn*)&SimpleConvertGen<uint32>;\n                else Throw(::Exceptions::BasicLabel(\"Unknown input format.\", op._sourceFile.c_str()));\n                break;\n\n            case SAMPLEFORMAT_INT:\n                if (bitsPerPixel == 8)          convFn = (ConversionFn*)&SimpleConvertGen<int8>;\n                else if (bitsPerPixel == 16)    convFn = (ConversionFn*)&SimpleConvertGen<int16>;\n                else if (bitsPerPixel == 32)    convFn = (ConversionFn*)&SimpleConvertGen<int32>;\n                else Throw(::Exceptions::BasicLabel(\"Unknown input format.\", op._sourceFile.c_str()));\n                break;\n\n            case SAMPLEFORMAT_IEEEFP:\n                if (bitsPerPixel == 16)         convFn = (ConversionFn*)&ConvertFloat16Gen;\n                else if (bitsPerPixel == 32)    convFn = (ConversionFn*)&SimpleConvertGen<float>;\n                else Throw(::Exceptions::BasicLabel(\"8 bit floats not supported in input file (%s). Use 16 or 32 bit floats instead.\", op._sourceFile.c_str()));\n                break;\n\n            default:\n                Throw(::Exceptions::BasicLabel(\"Unknown input format.\", op._sourceFile.c_str()));\n            }\n\n            double valueScale = (double(op._importHeightRange[1]) - double(op._importHeightRange[0])) / (double(op._sourceHeightRange[1]) - double(op._sourceHeightRange[0]));\n            double valueOffset = double(op._importHeightRange[0]) - double(op._sourceHeightRange[0]) * valueScale;\n                \n            for (tstrip_t strip = 0; strip < stripCount; strip++) {\n                auto readResult = TIFFReadEncodedStrip(tif, strip, stripBuffer.get(), stripSize);\n\n                if (readResult != stripSize) {\n\t\t\t\t\t// Sometimes the very last strip is truncated. This occurs if the height\n\t\t\t\t\t// is not an even multiple of the strip size\n\t\t\t\t\t// In this case, we just blank out the remaining part\n\t\t\t\t\tif (readResult > 0 && readResult < stripSize && (strip+1 == stripCount)) {\n\t\t\t\t\t\tstd::memset(PtrAdd(stripBuffer.get(), readResult), 0x0, stripSize - readResult);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tThrow(::Exceptions::BasicLabel(\n\t\t\t\t\t\t\t\"Error while reading from tiff file. File may be truncated or otherwise corrupted.\", \n\t\t\t\t\t\t\top._sourceFile.c_str()));\n\t\t\t\t\t}\n\t\t\t\t}\n\n                for (unsigned r=0; r<rowsperstrip; ++r) {\n                    auto y = strip * rowsperstrip + r;\n                    if (y >= op._importMins[1] && y < op._importMaxs[1]) {\n                        (*convFn)(\n                            PtrAdd(outputArray, ((y - op._importMins[1]) * finalDims[0]) * dstSampleSize),\n                            ImpliedTyping::TypeDesc(dstType),\n                            PtrAdd(stripBuffer.get(), op._importMins[0]*bitsPerPixel/8),\n                            std::min(op._sourceDims[0], op._importMaxs[0]) - op._importMins[0],\n                            valueOffset, valueScale);\n                    }\n                }\n\n                if (copyStep) {\n                    if (copyStep->IsCancelled())\n                        Throw(::Exceptions::BasicLabel(\"User cancelled\"));\n                    copyStep->Advance();\n                }\n            }\n\n            // TIFFClose called by AutoClose\n        }\n\n            // fill in the extra space caused by rounding up\n        float blank = 0.f;\n        if (finalDims[0] > op._sourceDims[0]) {\n            for (unsigned y=0; y<(op._importMaxs[1] - op._importMins[1]); ++y) {\n                for (unsigned x=op._sourceDims[0]; x<finalDims[0]; ++x)\n                    ImpliedTyping::Cast(\n                        PtrAdd(outputArray, (y * finalDims[0] + x)*dstSampleSize),\n                        dstSampleSize, ImpliedTyping::TypeDesc(dstType),\n                        &blank, ImpliedTyping::TypeOf<decltype(blank)>());\n                    \n            }\n        }\n\n        for (unsigned y=op._importMaxs[1] - op._importMins[1]; y < finalDims[1]; ++y) {\n            for (unsigned x=0; x<finalDims[0]; ++x)\n                ImpliedTyping::Cast(\n                    PtrAdd(outputArray, (y * finalDims[0] + x)*dstSampleSize),\n                    dstSampleSize, ImpliedTyping::TypeDesc(dstType),\n                    &blank, ImpliedTyping::TypeOf<decltype(blank)>());\n        }\n    }",
    "void ExecuteTerrainExport(\n        const ::Assets::ResChar dstFile[],\n        const SceneEngine::TerrainConfig& srcCfg, \n        const ::Assets::ResChar srcDir[],\n        SceneEngine::TerrainCoverageId coverageId,\n        ConsoleRig::IProgress* progress)\n    {\n            // Export a uber surface file to tiff format.\n        ::Assets::ResChar dirName[MaxPath];\n        XlDirname(dirName, dimof(dirName), dstFile);\n        CreateDirectoryRecursive(dirName);\n\n        ::Assets::ResChar srcFN[MaxPath];\n        srcCfg.GetUberSurfaceFilename(srcFN, dimof(srcFN), srcDir, coverageId);\n        if (!DoesFileExist(srcFN))\n            Throw(::Exceptions::BasicLabel(\"Could not find input file (%s)\", srcFN));\n\n        TerrainUberSurfaceGeneric uberSurface(srcFN);\n        auto step = \n              progress \n            ? progress->BeginStep(\"Create uber surface data\", uberSurface.GetHeight(), true)\n            : nullptr;\n\n        auto* tif = TIFFOpen(dstFile, \"w\");\n        if (!tif)\n            Throw(::Exceptions::BasicLabel(\"Error openning output file (%s)\", dstFile));\n        auto autoClose = MakeAutoClose([tif]() { TIFFClose(tif); });\n\n        TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, uberSurface.GetWidth());  // set the width of the image\n        TIFFSetField(tif, TIFFTAG_IMAGELENGTH, uberSurface.GetHeight());    // set the height of the image\n        TIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);    // set the origin of the image.\n\n        TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n        TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n\n        auto fmt = uberSurface.Format();\n        TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, fmt._arrayCount);\n        TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, fmt.GetSize() * 8 / fmt._arrayCount);\n        using TC = ImpliedTyping::TypeCat;\n        switch (fmt._type) {\n        case TC::Bool:\n        case TC::Int8:\n        case TC::Int16:\n        case TC::Int32:\n            TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_INT);\n            break;\n\n        case TC::UInt8:\n        case TC::UInt16:\n        case TC::UInt32:\n            TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT);\n            break;\n\n        case TC::Float:\n            TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);\n            break;\n\n        default:\n            Throw(::Exceptions::BasicLabel(\"Unknown uber surface format, can't export\"));\n        }\n\n        TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, 1);\n            // I think this will only work correctly with a single sample per pixel\n        for (unsigned row = 0; row < uberSurface.GetHeight(); row++) {\n            TIFFWriteScanline(tif, uberSurface.GetData(UInt2(0, row)), row, 0);\n\n            if (step) {\n                if (step->IsCancelled())\n                    break;\n                step->Advance();\n            }\n        }\n    }",
    "BaseImage readGenericTIFFImage(const char* imageName,IO::File& source)\n\t{\n\t/* Check if the source file is seekable: */\n\tIO::SeekableFilePtr seekableSource(&source);\n\tif(seekableSource==0)\n\t\t{\n\t\t/* Create a seekable filter for the source file: */\n\t\tseekableSource=new IO::SeekableFilter(&source);\n\t\t}\n\t\n\t/* Set the TIFF error handler: */\n\tTIFFSetErrorHandler(tiffErrorFunction);\n\t\n\tTIFF* tiff=0;\n\tBaseImage result;\n\ttry\n\t\t{\n\t\t/* Pretend to open the TIFF file and register the hook functions: */\n\t\ttiff=TIFFClientOpen(imageName,\"rm\",seekableSource.getPointer(),tiffReadFunction,tiffWriteFunction,tiffSeekFunction,tiffCloseFunction,tiffSizeFunction,tiffMapFileFunction,tiffUnmapFileFunction);\n\t\tif(tiff==0)\n\t\t\tthrow std::runtime_error(\"Error while opening image\");\n\t\t\n\t\t/* Extract the image header: */\n\t\tuint32 width,height;\n\t\tTIFFGetField(tiff,TIFFTAG_IMAGEWIDTH,&width);\n\t\tTIFFGetField(tiff,TIFFTAG_IMAGELENGTH,&height);\n\t\tuint16 numBits,numSamples,sampleFormat;\n\t\tTIFFGetField(tiff,TIFFTAG_BITSPERSAMPLE,&numBits);\n\t\tTIFFGetField(tiff,TIFFTAG_SAMPLESPERPIXEL,&numSamples);\n\t\tTIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLEFORMAT,&sampleFormat);\n\t\t\n\t\t/* Determine the result image's pixel format: */\n\t\tunsigned int numChannels=numSamples;\n\t\tGLenum format=GL_RGB;\n\t\tswitch(numChannels)\n\t\t\t{\n\t\t\tcase 1:\n\t\t\t\tformat=GL_LUMINANCE;\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tcase 2:\n\t\t\t\tformat=GL_LUMINANCE_ALPHA;\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tcase 3:\n\t\t\t\tformat=GL_RGB;\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tcase 4:\n\t\t\t\tformat=GL_RGBA;\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tdefault:\n\t\t\t\tMisc::throwStdErr(\"Unsupported number %u of channels\",numChannels);\n\t\t\t}\n\t\t\n\t\t/* Check whether the image is tiled or stripped: */\n\t\tif(TIFFIsTiled(tiff))\n\t\t\t{\n\t\t\t/* Can't do this yet: */\n\t\t\tthrow std::runtime_error(\"Tiled images not supported\");\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\t/* Determine the result image's pixel type and read the image data: */\n\t\t\tif(numBits==8)\n\t\t\t\t{\n\t\t\t\tswitch(sampleFormat)\n\t\t\t\t\t{\n\t\t\t\t\tcase SAMPLEFORMAT_UINT:\n\t\t\t\t\t\tresult=readStrippedTIFF<Misc::UInt8>(tiff,width,height,numChannels,1,format,GL_UNSIGNED_BYTE);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\tcase SAMPLEFORMAT_INT:\n\t\t\t\t\t\tresult=readStrippedTIFF<Misc::SInt8>(tiff,width,height,numChannels,1,format,GL_BYTE);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tMisc::throwStdErr(\"Unsupported 8-bit sample format %u\",sampleFormat);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\telse if(numBits==16)\n\t\t\t\t{\n\t\t\t\tswitch(sampleFormat)\n\t\t\t\t\t{\n\t\t\t\t\tcase SAMPLEFORMAT_UINT:\n\t\t\t\t\t\tresult=readStrippedTIFF<Misc::UInt16>(tiff,width,height,numChannels,2,format,GL_UNSIGNED_SHORT);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\tcase SAMPLEFORMAT_INT:\n\t\t\t\t\t\tresult=readStrippedTIFF<Misc::SInt16>(tiff,width,height,numChannels,2,format,GL_SHORT);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tMisc::throwStdErr(\"Unsupported 16-bit sample format %u\",sampleFormat);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\telse if(numBits==32)\n\t\t\t\t{\n\t\t\t\tswitch(sampleFormat)\n\t\t\t\t\t{\n\t\t\t\t\tcase SAMPLEFORMAT_UINT:\n\t\t\t\t\t\tresult=readStrippedTIFF<Misc::UInt32>(tiff,width,height,numChannels,4,format,GL_UNSIGNED_INT);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\tcase SAMPLEFORMAT_INT:\n\t\t\t\t\t\tresult=readStrippedTIFF<Misc::SInt32>(tiff,width,height,numChannels,4,format,GL_INT);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\tcase SAMPLEFORMAT_IEEEFP:\n\t\t\t\t\t\tresult=readStrippedTIFF<Misc::Float32>(tiff,width,height,numChannels,4,format,GL_FLOAT);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tMisc::throwStdErr(\"Unsupported 32-bit sample format %u\",sampleFormat);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tMisc::throwStdErr(\"Unsupported channel bit size %u\",numBits);\n\t\t\t}\n\t\t}\n\tcatch(std::runtime_error err)\n\t\t{\n\t\t/* Clean up: */\n\t\tif(tiff!=0)\n\t\t\tTIFFClose(tiff);\n\t\t\n\t\t/* Wrap and re-throw the exception: */\n\t\tMisc::throwStdErr(\"Images::readGenericTIFFImage: Caught exception \\\"%s\\\" while reading image \\\"%s\\\"\",err.what(),imageName);\n\t\t}\n\t\n\t/* Clean up and return the result image: */\n\tif(tiff!=0)\n\t\tTIFFClose(tiff);\n\treturn result;\n\t}",
    "GraphicsBuffer load_image_to_graphics_buffer_tiff(GraphicsDevice device, const char* texturePath, uint32_t& width, uint32_t& height, TextureFormat& textureFormat)\n{\n\t// Set the error callback\n\tTIFFSetErrorHandler(&tif_read_error);\n\n\t// Open the file\n\tTIFF* tif = TIFFOpen(texturePath, \"r\");\n\tassert_msg(tif != nullptr, \"Could not find tiff file.\");\n\n\t// Read the resource's dimensions\n\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n\n\t// Number of channels per pixel\n\tuint16_t channelCount, bitsPerChannel, channelFormat;\n\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &channelCount);\n\tTIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bitsPerChannel);\n\tuint16_t channelSize = bitsPerChannel / 8;\n\tTIFFGetField(tif, TIFFTAG_SAMPLEFORMAT, &channelFormat);\n\tif (channelSize == 1 && channelCount == 3)\n\t\tchannelFormat = SAMPLEFORMAT_UINT;\n\n\t// Get the output format\n\tuint16_t actualChannelCount;\n\tget_adequate_format(channelSize, channelCount, channelFormat, textureFormat, actualChannelCount);\n\n\t// Allocate the upload texture\n\tconst uint16_t pixelSize = actualChannelCount * channelSize;\n\tconst uint32_t imageSize = width * height * pixelSize;\n\tGraphicsBuffer textureBuffer = d3d12::graphics_resources::create_graphics_buffer(device, imageSize, pixelSize, GraphicsBufferType::Upload);\n\tchar* bufferCPU = d3d12::graphics_resources::allocate_cpu_buffer(textureBuffer);\n\n\t// Read the image\n\ttsize_t lineSize = TIFFScanlineSize(tif);\n\n\tassert(lineSize == width * (channelSize * channelCount));\n\n\t// Allocate a buffer for line reading\n\tchar* image = (char*)malloc(width * channelSize * channelCount);\n\tfor (uint32_t channelIdx = 0; channelIdx < channelCount; ++channelIdx)\n\t{\n\t\t// For each line\n\t\tfor (uint32_t y = 0; y < height; y++)\n\t\t{\n\t\t\tTIFFReadScanline(tif, image, y, channelIdx);\n\t\t\tfor (uint32_t x = 0; x < width; x++)\n\t\t\t{\n\t\t\t\tuint32_t inputOffset = channelSize * channelCount * x;\n\t\t\t\tuint32_t outputOffset = pixelSize * (x + y * width);\n\t\t\t\tmemcpy(bufferCPU + outputOffset, image + inputOffset, channelSize * channelCount);\n\t\t\t}\n\t\t}\n\t}\n\n\t// free the buffer\n\tfree(image);\n\n\t// Release the CPU view\n\td3d12::graphics_resources::release_cpu_buffer(textureBuffer);\n\n\t// Close the tiff file\n\tTIFFClose(tif);\n\n\t// Return the created graphics buffer\n\treturn textureBuffer;\n}",
    "MStatus tiffFloatReader::close()\n{\n#if defined(_TIFF_LIBRARY_AVAILABLE_)\n\tif (fInputFile)\n\t\tTIFFClose( fInputFile );\n\tfInputFile = NULL;\n\treturn MS::kSuccess;\n#else\n\treturn MS::kFailure;\n#endif\n}",
    "INGR_VirtualFile CPL_STDCALL INGR_CreateVirtualFile( const char *pszFilename,\n                                                     INGR_Format eFormat,\n                                                     int nXSize, \n                                                     int nYSize,\n                                                     int nTileSize,\n                                                     int nQuality,\n                                                     GByte *pabyBuffer,\n                                                     int nBufferSize,\n                                                     int nBand )\n{\n    INGR_VirtualFile hVirtual;\n\n    hVirtual.pszFileName = CPLSPrintf( \"/vsimem/%s.virtual\",\n        CPLGetBasename( pszFilename ) );\n\n    int nJPGComponents = 1;\n\n    switch( eFormat )\n    {\n    case JPEGRGB: \n        nJPGComponents = 3;\n    case JPEGGRAY:\n        {\n            GByte *pabyHeader = (GByte*) CPLCalloc( 1, 2048 );\n            int nHeaderSize   = JPGHLP_HeaderMaker( pabyHeader,\n                                                    nTileSize,\n                                                    nTileSize,\n                                                    nJPGComponents,\n                                                    0,\n                                                    nQuality );\n            FILE *fp = VSIFOpenL( hVirtual.pszFileName, \"w+\" );\n            VSIFWriteL( pabyHeader, 1, nHeaderSize, fp );\n            VSIFWriteL( pabyBuffer, 1, nBufferSize, fp );\n            VSIFCloseL( fp );\n            CPLFree( pabyHeader );\n            break;\n        }\n    case CCITTGroup4:\n        {\n            REVERSEBITSBUFFER( pabyBuffer, nBufferSize );\n            TIFF *hTIFF = VSI_TIFFOpen( hVirtual.pszFileName, \"w+\" );\n            TIFFSetField( hTIFF, TIFFTAG_IMAGEWIDTH,      nXSize );\n            TIFFSetField( hTIFF, TIFFTAG_IMAGELENGTH,     nYSize );\n            TIFFSetField( hTIFF, TIFFTAG_BITSPERSAMPLE,   1 );\n            TIFFSetField( hTIFF, TIFFTAG_SAMPLEFORMAT,    SAMPLEFORMAT_UINT );\n            TIFFSetField( hTIFF, TIFFTAG_PLANARCONFIG,    PLANARCONFIG_CONTIG );\n            TIFFSetField( hTIFF, TIFFTAG_FILLORDER,       FILLORDER_MSB2LSB );\n            TIFFSetField( hTIFF, TIFFTAG_ROWSPERSTRIP,    -1 );\n            TIFFSetField( hTIFF, TIFFTAG_SAMPLESPERPIXEL, 1 );\n            TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC,     PHOTOMETRIC_MINISWHITE );\n            TIFFSetField( hTIFF, TIFFTAG_COMPRESSION,     COMPRESSION_CCITTFAX4 );\n            TIFFWriteRawStrip( hTIFF, 0, pabyBuffer, nBufferSize );\n            TIFFWriteDirectory( hTIFF );\n            TIFFClose( hTIFF );\n            break;\n        }\n    default:\n        return hVirtual;\n    }\n\n    hVirtual.poDS   = (GDALDataset*) GDALOpen( hVirtual.pszFileName, GA_ReadOnly );\n\n    if( hVirtual.poDS )\n    {\n        hVirtual.poBand = (GDALRasterBand*) GDALGetRasterBand( hVirtual.poDS, nBand );\n    }\n\n    return hVirtual;\n}",
    "int NITFUncompressBILEVEL( NITFImage *psImage, \n                           GByte *pabyInputData, int nInputBytes,\n                           GByte *pabyOutputImage )\n\n{\n    int nOutputBytes= (psImage->nBlockWidth * psImage->nBlockHeight + 7)/8;\n\n/* -------------------------------------------------------------------- */\n/*      Write memory TIFF with the bilevel data.                        */\n/* -------------------------------------------------------------------- */\n    CPLString osFilename;\n\n    osFilename.Printf( \"/vsimem/nitf-wrk-%ld.tif\", (long) CPLGetPID() );\n\n    TIFF *hTIFF = VSI_TIFFOpen( osFilename, \"w+\" );\n    if (hTIFF == NULL)\n    {\n        return FALSE;\n    }\n\n    TIFFSetField( hTIFF, TIFFTAG_IMAGEWIDTH,    psImage->nBlockWidth );\n    TIFFSetField( hTIFF, TIFFTAG_IMAGELENGTH,   psImage->nBlockHeight );\n    TIFFSetField( hTIFF, TIFFTAG_BITSPERSAMPLE, 1 );\n    TIFFSetField( hTIFF, TIFFTAG_SAMPLEFORMAT,  SAMPLEFORMAT_UINT );\n    TIFFSetField( hTIFF, TIFFTAG_PLANARCONFIG,  PLANARCONFIG_CONTIG );\n    TIFFSetField( hTIFF, TIFFTAG_FILLORDER,     FILLORDER_MSB2LSB );\n\n    TIFFSetField( hTIFF, TIFFTAG_ROWSPERSTRIP,  psImage->nBlockHeight );\n    TIFFSetField( hTIFF, TIFFTAG_SAMPLESPERPIXEL, 1 );\n    TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK );\n    TIFFSetField( hTIFF, TIFFTAG_COMPRESSION, COMPRESSION_CCITTFAX3 );\n    \n    if( psImage->szCOMRAT[0] == '2' )\n        TIFFSetField( hTIFF, TIFFTAG_GROUP3OPTIONS, GROUP3OPT_2DENCODING );\n\n    TIFFWriteRawStrip( hTIFF, 0, pabyInputData, nInputBytes );\n    TIFFWriteDirectory( hTIFF );\n\n    TIFFClose( hTIFF );\n\n/* -------------------------------------------------------------------- */\n/*      Now open and read it back.                                      */\n/* -------------------------------------------------------------------- */\n    int bResult = TRUE;\n\n    hTIFF = VSI_TIFFOpen( osFilename, \"r\" );\n    if (hTIFF == NULL)\n    {\n        return FALSE;\n    }\n\n\n    if( TIFFReadEncodedStrip( hTIFF, 0, pabyOutputImage, nOutputBytes ) == -1 )\n    {\n        memset( pabyOutputImage, 0, nOutputBytes );\n        bResult = FALSE;\n    }\n\n    TIFFClose( hTIFF );\n\n    VSIUnlink( osFilename );\n\n    return bResult;\n}",
    "int test_read_tiff()\n{\n\t// reference: http://research.cs.wisc.edu/graphics/Courses/638-f1999/libtiff_tutorial.htm\n#ifdef _MSC_VER\n\tconst std::string image_name { \"E:/GitCode/OCR_Test/test_data/eurotext.tif\" };\n#else\n\tconst std::string image_name { \"test_data/eurotext.tif\" };\n#endif\n\tTIFF* tif = TIFFOpen(image_name.c_str(), \"r\");\n\tint width{ 0 }, height{ 0 };\n\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n\tfprintf(stdout, \"width: %d, height: %d\\n\", width, height);\n\n\tTIFFClose(tif);\n\n\t// Note: liblept library read tiff file will crash: Error in findTiffCompression: tif not opened\n\t//PIX* pixs = pixRead(image_name.c_str());\n\t//if (pixs == nullptr) {\n\t//\tfprintf(stderr, \"read image error\\n\");\n\t//\treturn -1;\n\t//}\n\n\treturn 0;\n}",
    "Image *Read (IStream *file, const ImageReadOptions& options)\n{\n    int                   nrow;\n    int                   result = 0;\n    long                  LineSize;\n    TIFF                  *tif;\n    Image                 *image ;\n    uint16                BitsPerSample;\n    uint16                BytesPerSample = 1;\n    uint16                PhotometricInterpretation;\n    uint16                SamplePerPixel;\n    uint16                Orientation;\n    uint16                ExtraSamples;\n    uint16*               ExtraSampleInfo;\n    uint32                RowsPerStrip;\n    unsigned int          width;\n    unsigned int          height;\n\n    // TODO - TIFF files probably have some gamma info in them by default, but we're currently ignorant about that.\n    // Until that is fixed, use whatever the user has chosen as default.\n    GammaCurvePtr gamma;\n    if (options.gammacorrect && options.defaultGamma)\n        gamma = TranscodingGammaCurve::Get(options.workingGamma, options.defaultGamma);\n\n    // Rather than have libTIFF complain about tags it doesn't understand,\n    // we just suppress all the warnings.\n    TIFFSetWarningHandler(SuppressTIFFWarnings);\n    TIFFSetErrorHandler(SuppressTIFFWarnings);\n\n    // Open and do initial processing\n    tif = TIFFClientOpen(\"Dummy File Name\", \"r\", file,\n        Tiff_Read, Tiff_Write, Tiff_Seek, Tiff_Close,\n        Tiff_Size, Tiff_Map, Tiff_Unmap);\n    if (!tif)\n        return nullptr;\n\n    // Get basic information about the image\n    TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n    TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n    TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n    TIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);\n    TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\n    TIFFGetField(tif, TIFFTAG_ORIENTATION, &Orientation);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_EXTRASAMPLES, &ExtraSamples, &ExtraSampleInfo);\n\n    // [CLi] TIFF provides alpha mode information in the TIFFTAG_EXTRASAMPLES field, so that's the preferred mode to use\n    // for the image container unless the user overrides (e.g. to handle a non-compliant file).\n    // If TIFFTAG_EXTRASAMPLES information is absent or inconclusive, we presume associated (= premultiplied) alpha.\n    bool premul = true;\n    if ((ExtraSamples > 0) && (ExtraSampleInfo[0] == EXTRASAMPLE_UNASSALPHA))\n        premul = false;\n    if (options.premultipliedOverride)\n        premul = options.premultiplied;\n\n    // don't support more than 16 bits per sample\n    if (BitsPerSample == 16)\n    {\n        BytesPerSample = 2 ;\n        options.warnings.push_back (\"Warning: reading 16 bits/sample TIFF file; components crunched to 8\");\n    }\n\n    LineSize = TIFFScanlineSize(tif);\n    POV_IMAGE_ASSERT(SamplePerPixel == (int) (LineSize / width) / BytesPerSample);\n    // SamplePerPixel = (int)(LineSize / width);\n\n#if 0\n    // For now we are ignoring the orientation of the image...\n    switch (Orientation)\n    {\n    case ORIENTATION_TOPLEFT:\n        break;\n    case ORIENTATION_TOPRIGHT:\n        break;\n    case ORIENTATION_BOTRIGHT:\n        break;\n    case ORIENTATION_BOTLEFT:\n        break;\n    case ORIENTATION_LEFTTOP:\n        break;\n    case ORIENTATION_RIGHTTOP:\n        break;\n    case ORIENTATION_RIGHTBOT:\n        break;\n    case ORIENTATION_LEFTBOT:\n        break;\n    default:\n        break;\n    }\n#endif\n\n    //PhotometricInterpretation = 2 image is RGB\n    //PhotometricInterpretation = 3 image have a color palette\n    if ((PhotometricInterpretation == PHOTOMETRIC_PALETTE) && (TIFFIsTiled(tif) == 0))\n    {\n        uint16 *red, *green, *blue;\n\n        //load the palette\n        int cmap_len = (1 << BitsPerSample);\n\n        TIFFGetField(tif, TIFFTAG_COLORMAP, &red, &green, &blue);\n\n        std::vector<Image::RGBMapEntry> colormap;\n        Image::RGBMapEntry entry;\n\n        // I may be mistaken, but it appears that alpha/opacity information doesn't\n        // appear in a Paletted Tiff image.  Well - if it does, it's not as easy to\n        // get at as RGB.\n        // Read the palette\n        // Is the palette 16 or 8 bits ?\n        if (checkcmap(cmap_len, red, green, blue) == 16)\n        {\n            for (int i=0;i<cmap_len;i++)\n            {\n                entry.red   = IntDecode(gamma, red[i],   65535);\n                entry.green = IntDecode(gamma, green[i], 65535);\n                entry.blue  = IntDecode(gamma, blue[i],  65535);\n                colormap.push_back (entry);\n            }\n        }\n        else\n        {\n            for (int i=0;i<cmap_len;i++)\n            {\n                entry.red   = IntDecode(gamma, red[i],   255);\n                entry.green = IntDecode(gamma, green[i], 255);\n                entry.blue  = IntDecode(gamma, blue[i],  255);\n                colormap.push_back (entry);\n            }\n        }\n\n        ImageDataType imagetype = options.itype;\n        if (imagetype == ImageDataType::Undefined)\n            imagetype = ImageDataType::Colour_Map;\n        image = Image::Create (width, height, imagetype, colormap) ;\n        image->SetPremultiplied(premul); // specify whether the color map data has premultiplied alpha\n\n        std::unique_ptr<unsigned char[]> buf (new unsigned char [TIFFStripSize(tif)]);\n\n        //read the tiff lines and save them in the image\n        //with RGB mode, we have to change the order of the 3 samples RGB <=> BGR\n        for (int row=0;row<height;row+=RowsPerStrip)\n        {\n            nrow = (row + (int)RowsPerStrip > height ? height - row : RowsPerStrip);\n            TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, row, 0), buf.get(), nrow * LineSize);\n            for (int l = 0, offset = 0; l < nrow ; l++, offset += LineSize)\n                for (int x = 0 ; x < width ; x++)\n                    image->SetIndexedValue (x, row+l, buf[offset+x]) ;\n        }\n    }\n    else\n    {\n        // Allocate the row buffers for the image\n        std::unique_ptr<uint32[]> buf (new uint32 [width * height]) ;\n\n        ImageDataType imagetype = options.itype;\n        if (imagetype == ImageDataType::Undefined)\n            imagetype = Image::GetImageDataType(8, 3, true, gamma);\n        image = Image::Create (width, height, imagetype) ;\n        image->SetPremultiplied(premul); // set desired storage mode regarding alpha premultiplication\n        image->TryDeferDecoding(gamma, 255); // try to have gamma adjustment being deferred until image evaluation.\n\n        TIFFReadRGBAImage(tif, width, height, buf.get(), 0);\n        uint32 abgr, *tbuf = buf.get();\n        for (int i=height-1;i>=0;i--)\n        {\n            for (int j=0;j<width;j++)\n            {\n                abgr = *tbuf++;\n                unsigned int b = (unsigned char)TIFFGetB(abgr);\n                unsigned int g = (unsigned char)TIFFGetG(abgr);\n                unsigned int r = (unsigned char)TIFFGetR(abgr);\n                unsigned int a = (unsigned char)TIFFGetA(abgr);\n                SetEncodedRGBAValue(image, j, i, gamma, 255, r, g, b, a, premul) ;\n            }\n        }\n    }\n\n    TIFFClose(tif);\n\n    return (image) ;\n}",
    "bool\tExtractGeoTiff(DEMGeo& inMap, const char * inFileName, int post_style, int no_geo_needed)\n{\n\tint result = -1;\n\tdouble\tcorners[8];\n\tTIFF * tif;\n\tTIFFErrorHandler\twarnH = TIFFSetWarningHandler(IgnoreTiffWarnings);\n\tTIFFErrorHandler\terrH = TIFFSetErrorHandler(IgnoreTiffErrs);\n\tStTiffMemFile\ttiffMem(inFileName);\n\tif (tiffMem.file == NULL) goto bail;\n\n\tprintf(\"Trying file: %s\\n\", inFileName);\n\ttif = XTIFFClientOpen(inFileName, \"r\", &tiffMem,\n\t    MemTIFFReadWriteProc, MemTIFFReadWriteProc,\n\t    MemTIFFSeekProc, MemTIFFCloseProc,\n\t    MemTIFFSizeProc,\n\t    MemTIFFMapFileProc, MemTIFFUnmapFileProc);\n\tprintf(\"Opened TIF file.\\n\");\n//    TIFF* tif = TIFFOpen(inFileName, \"r\");\n\n    if (tif == NULL) goto bail;\n\n\tif (!FetchTIFFCornersWithTIFF(tif, corners, post_style))\n\t{\n\t\tif(no_geo_needed)\n\t\t{\n\t\t\tprintf(\"TIFF has no corners - using default.\\n\");\n\t\t\tinMap.mWest = -180;\n\t\t\tinMap.mSouth = -90;\n\t\t\tinMap.mEast = 180;\n\t\t\tinMap.mNorth = 90;\n\t\t\tinMap.mPost = 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"Could not read GeoTiff projection data.\\n\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tinMap.mWest = corners[0];\n\tinMap.mSouth = corners[1];\n\tinMap.mEast = corners[6];\n\tinMap.mNorth = corners[7];\n\tinMap.mPost = (post_style == dem_want_Post);\n\n\tprintf(\"Corners: %.12lf,%.12lf   %.12lf,%.12lf   %.12lf,%.12lf   %.12lf,%.12lf\\n\",\n\t\tcorners[0], corners[1], corners[2], corners[3], corners[4], corners[5], corners[6], corners[7]);\n\n\tuint32 w, h;\n\tuint16 cc;\n\tuint16 d;\n\tuint16 format;\n\t\n\tformat = SAMPLEFORMAT_UINT;\t// sample format is NOT mandatory - unsigned int is the default if not present!\n\n\n\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w);\n\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\n\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &cc);\n\tTIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &d);\n\tTIFFGetField(tif, TIFFTAG_SAMPLEFORMAT, &format);\n\tprintf(\"Image is: %dx%d, samples: %d, depth: %d, format: %d\\n\", w, h, cc, d, format);\n\n\tinMap.resize(w,h);\n\t\n\tif(TIFFIsTiled(tif))\n\t{\n\t\tuint32\ttw, th;\n\t\tTIFFGetField(tif, TIFFTAG_TILEWIDTH, &tw);\n\t\tTIFFGetField(tif, TIFFTAG_TILELENGTH, &th);\n\t\ttdata_t buf = _TIFFmalloc(TIFFTileSize(tif));\n\t\tfor (int y = 0; y < h; y += th)\n\t\tfor (int x = 0; x < w; x += tw)\n\t\t{\n\t\t\tresult = TIFFReadTile(tif, buf, x, y, 0, 0);\n\t\t\tif (result == -1) { printf(\"Tiff error in read.\\n\"); break; }\n\n\t\t\tint ux = min(tw,w-x);\n\t\t\tint uy = min(th,h-y);\n\n\t\t\tswitch(format) {\n\t\t\tcase SAMPLEFORMAT_UINT:\n\t\t\t\tswitch(d) {\n\t\t\t\tcase 8:\n\t\t\t\t\tcopy_tile<unsigned char>((const unsigned char *) buf, x,y,ux,uy, inMap);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 16:\n\t\t\t\t\tcopy_tile<unsigned short>((const unsigned short *) buf, x,y,ux,uy, inMap);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 32:\n\t\t\t\t\tcopy_tile<unsigned int>((const unsigned int *) buf, x,y,ux,uy, inMap);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tprintf(\"TIFF error: unsupported unsigned int sample depth: %d\\n\", d);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase SAMPLEFORMAT_INT:\n\t\t\t\tswitch(d) {\n\t\t\t\tcase 8:\n\t\t\t\t\tcopy_tile<char>((const char *) buf, x,y,ux,uy, inMap);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 16:\n\t\t\t\t\tcopy_tile<short>((const short *) buf, x,y,ux,uy, inMap);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 32:\n\t\t\t\t\tcopy_tile<int>((const int *) buf, x,y,ux,uy, inMap);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tprintf(\"TIFF error: unsupported signed int sample depth: %d\\n\", d);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase SAMPLEFORMAT_IEEEFP:\n\t\t\t\tswitch(d) {\n\t\t\t\tcase 32:\n\t\t\t\t\tcopy_tile<float>((const float *) buf, x,y,ux,uy, inMap);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 64:\n\t\t\t\t\tcopy_tile<double>((const double *) buf, x,y,ux,uy, inMap);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tprintf(\"TIFF error: unsupported floating point sample depth: %d\\n\", d);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"TIFF error: unsupported pixel format %d\\n\", format);\n\t\t\t\tbreak;\t\t\t\n\t\t\t}\n\t\t}\n\n\t\t_TIFFfree(buf);\t\n\n\t\tTIFFClose(tif);\n\n\t\tTIFFSetWarningHandler(warnH);\n\t\tTIFFSetErrorHandler(errH);\n\t\treturn result != -1;\n\t}\n\telse\n\t{\n\t\ttsize_t line_size = TIFFScanlineSize(tif);\n\t\ttdata_t aline = _TIFFmalloc(line_size);\n\n\t\tint cs = TIFFCurrentStrip(tif);\n\t\tint nos = TIFFNumberOfStrips(tif);\n\t\tint cr = TIFFCurrentRow  (tif);\n\n\t\tfor (int y = 0; y < h; ++y)\n\t\t{\n\t\t\tresult = TIFFReadScanline(tif, aline, y, 0);\n\t\t\tif (result == -1) { printf(\"Tiff error in read.\\n\"); break; }\n\n\t\t\tswitch(format) {\n\t\t\tcase SAMPLEFORMAT_UINT:\n\t\t\t\tswitch(d) {\n\t\t\t\tcase 8:\n\t\t\t\t\tcopy_scanline<unsigned char>((const unsigned char *) aline, y, inMap);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 16:\n\t\t\t\t\tcopy_scanline<unsigned short>((const unsigned short *) aline, y, inMap);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 32:\n\t\t\t\t\tcopy_scanline<unsigned int>((const unsigned int *) aline, y, inMap);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tprintf(\"TIFF error: unsupported unsigned int sample depth: %d\\n\", d);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase SAMPLEFORMAT_INT:\n\t\t\t\tswitch(d) {\n\t\t\t\tcase 8:\n\t\t\t\t\tcopy_scanline<char>((const char *) aline, y, inMap);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 16:\n\t\t\t\t\tcopy_scanline<short>((const short *) aline, y, inMap);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 32:\n\t\t\t\t\tcopy_scanline<int>((const int *) aline, y, inMap);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tprintf(\"TIFF error: unsupported signed int sample depth: %d\\n\", d);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase SAMPLEFORMAT_IEEEFP:\n\t\t\t\tswitch(d) {\n\t\t\t\tcase 32:\n\t\t\t\t\tcopy_scanline<float>((const float *) aline, y, inMap);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 64:\n\t\t\t\t\tcopy_scanline<double>((const double *) aline, y, inMap);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tprintf(\"TIFF error: unsupported floating point sample depth: %d\\n\", d);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"TIFF error: unsupported pixel format %d\\n\", format);\n\t\t\t\tbreak;\t\t\t\n\t\t\t}\n\n\t\t}\n\t\t_TIFFfree(aline);\n\n\n\t\tTIFFClose(tif);\n\n\t\tTIFFSetWarningHandler(warnH);\n\t\tTIFFSetErrorHandler(errH);\n\t\treturn result != -1;\n\t}\nbail:\n\tTIFFSetWarningHandler(warnH);\n\tTIFFSetErrorHandler(errH);\n\treturn false;\n\n}",
    "int\t\tCreateBitmapFromTIF(const char * inFilePath, struct ImageInfo * outImageInfo)\n{\n\tint result = -1;\n\tTIFFErrorHandler\terrH = TIFFSetWarningHandler(IgnoreTiffWarnings);\n\tTIFFErrorHandler\terrH2= TIFFSetErrorHandler(IgnoreTiffWarnings);\n#if SUPPORT_UNICODE\n    TIFF* tif = TIFFOpenW(convert_str_to_utf16(inFilePath).c_str(), \"r\");\n#else\n\tFILE_case_correct_path path(inFilePath);  // If earth.wed.xml with case-incorrect .tif references are exchanged, this helps on Linux\n    TIFF* tif = TIFFOpen(path, \"r\");\n#endif\n    if (tif == NULL) goto bail;\n\n\tuint32 w, h;\n\tuint16 cc;\n\tsize_t npixels;\n\tuint32* raster;\n\n\t\n\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w);\n\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\n\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &cc);\n\n\tnpixels = w * h;\n\traster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n\tif (raster != NULL) {\n\t    if (TIFFReadRGBAImage(tif, w, h, raster, 0)) {\n\n\t\t\toutImageInfo->data = (unsigned char *) malloc(npixels * 4);\n\t\t\toutImageInfo->width = w;\n\t\t\toutImageInfo->height = h;\n\t\t\toutImageInfo->channels = 4;\n\t\t\toutImageInfo->pad = 0;\n\t\t\tint\tcount = outImageInfo->width * outImageInfo->height;\n\t\t\tunsigned char * d = outImageInfo->data;\n\t\t\tunsigned char * s = (unsigned char *) raster;\n\t\t\twhile (count--)\n\t\t\t{\n#if BIG\n\t\t\t\td[0] = s[1];\t// B\n\t\t\t\td[1] = s[2];\t// G\n\t\t\t\td[2] = s[3];\t// R\n\t\t\t\td[3] = s[0];\t// A\n#elif LIL\n\t\t\t\td[0] = s[2];\t// B\n\t\t\t\td[1] = s[1];\t// G\n\t\t\t\td[2] = s[0];\t// R\n\t\t\t\td[3] = s[3];\t// A\n#else\n\t#error PLATFORM NOT DEFINED\n#endif\n\t\t\t\ts += 4;\n\t\t\t\td += 4;\n\t\t\t}\n\t\t\tresult = 0;\n\t    }\n\t    _TIFFfree(raster);\n\t}\n\tTIFFClose(tif);\n\tTIFFSetWarningHandler(errH);\n    return result;\nbail:\n\tTIFFSetWarningHandler(errH);\n\treturn -1;\n}",
    "~File()\n                {\n                    if (f)\n                    {\n                        TIFFClose(f);\n                        f = nullptr;\n                    }\n                }",
    "static int\nread_whole_tiff(struct iio_image *x,\n                const char *filename)\n{\n    // tries to read data in the correct format (via scanlines)\n    // if it fails, it tries to read ABGR data\n\n    TIFF *tif = TIFFOpen(filename, \"r\");\n\n    if (!tif) {\n        fail(\"could not open TIFF file \\\"%s\\\"\", filename);\n    }\n    uint32_t w, h;\n    uint16_t spp, bps, fmt;\n    int r = 0, fmt_iio = -1;\n    r += TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w);\n    IIO_DEBUG(\"tiff get field width %d (r=%d)\\n\", (int)w, r);\n    r += TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\n    IIO_DEBUG(\"tiff get field length %d (r=%d)\\n\", (int)h, r);\n    if (r != 2) {\n        fail(\"can not read tiff of unknown size\");\n    }\n\n    r = TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &spp);\n    if (!r) {\n        spp = 1;\n    }\n    if (r) {\n        IIO_DEBUG(\"tiff get field spp %d (r=%d)\\n\", spp, r);\n    }\n\n    r = TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bps);\n    if (!r) {\n        bps = 1;\n    }\n    if (r) {\n        IIO_DEBUG(\"tiff get field bps %d (r=%d)\\n\", bps, r);\n    }\n\n    r = TIFFGetField(tif, TIFFTAG_SAMPLEFORMAT, &fmt);\n    if (!r) {\n        fmt = SAMPLEFORMAT_UINT;\n    }\n    if (r) {\n        IIO_DEBUG(\"tiff get field fmt %d (r=%d)\\n\", fmt, r);\n    }\n    //if (r != 5) error(\"some tiff getfield failed (r=%d)\", r);\n\n    // TODO: consider the missing cases (run through PerlMagick's format database)\n\n    IIO_DEBUG(\"fmt  = %d\\n\", fmt);\n    // set appropriate size and type flags\n    if (fmt == SAMPLEFORMAT_UINT) {\n        if (1 == bps) {\n            fmt_iio = IIO_TYPE_UINT1;\n        } else if (2 == bps) {\n            fmt_iio = IIO_TYPE_UINT2;\n        } else if (4 == bps) {\n            fmt_iio = IIO_TYPE_UINT4;\n        } else if (8 == bps) {\n            fmt_iio = IIO_TYPE_UINT8;\n        } else if (16 == bps) {\n            fmt_iio = IIO_TYPE_UINT16;\n        } else if (32 == bps) {\n            fmt_iio = IIO_TYPE_UINT32;\n        } else {\n            fail(\"unrecognized UINT type of size %d bits\", bps);\n        }\n    } else if (fmt == SAMPLEFORMAT_INT) {\n        if (8 == bps) {\n            fmt_iio = IIO_TYPE_INT8;\n        } else if (16 == bps) {\n            fmt_iio = IIO_TYPE_INT16;\n        } else if (32 == bps) {\n            fmt_iio = IIO_TYPE_INT32;\n        } else {\n            fail(\"unrecognized INT type of size %d bits\", bps);\n        }\n    } else if (fmt == SAMPLEFORMAT_IEEEFP) {\n        IIO_DEBUG(\"floating tiff!\\n\");\n        if (32 == bps) {\n            fmt_iio = IIO_TYPE_FLOAT;\n        } else if (64 == bps) {\n            fmt_iio = IIO_TYPE_DOUBLE;\n        } else {\n            fail(\"unrecognized FLOAT type of size %d bits\", bps);\n        }\n    } else {\n        fail(\"unrecognized tiff sample format %d (see tiff.h)\", fmt);\n    }\n\n    if ( (bps >= 8) && ( bps != 8 * iio_type_size(fmt_iio) ) ) {\n        IIO_DEBUG(\"bps = %d\\n\", bps);\n        IIO_DEBUG(\"fmt_iio = %d\\n\", fmt_iio);\n        IIO_DEBUG( \"ts = %zu\\n\", iio_type_size(fmt_iio) );\n        IIO_DEBUG( \"8*ts = %zu\\n\", 8 * iio_type_size(fmt_iio) );\n    }\n    if (bps >= 8) {\n        assert( bps == 8 * iio_type_size(fmt_iio) );\n    }\n\n\n    // acquire memory block\n    uint32_t scanline_size = (w * spp * bps) / 8;\n    int rbps = bps / 8 ? bps / 8 : 1;\n    uint32_t uscanline_size = w * spp * rbps;\n    IIO_DEBUG(\"bps = %d\\n\", (int)bps);\n    IIO_DEBUG(\"spp = %d\\n\", (int)spp);\n    IIO_DEBUG(\"sls = %d\\n\", (int)scanline_size);\n    int sls = TIFFScanlineSize(tif);\n    IIO_DEBUG(\"sls(r) = %d\\n\", (int)sls);\n    assert( (int)scanline_size == sls );\n    scanline_size = sls;\n    uint8_t *data = (uint8_t *)xmalloc(w * h * spp * rbps);\n    //FORI(h*scanline_size) data[i] = 42;\n    uint8_t *buf = (uint8_t *)xmalloc(scanline_size);\n\n    // dump scanline data\n    FORI(h) {\n        r = TIFFReadScanline(tif, buf, i, 0);\n        if (r < 0) {\n            fail(\"error reading tiff row %d/%d\", i, (int)h);\n        }\n\n        if (bps < 8) {\n            fprintf(stderr, \"unpacking %dth scanline\\n\", i);\n            unpack_to_bytes_here(data + i * uscanline_size, buf,\n                                 scanline_size, bps);\n            fmt_iio = IIO_TYPE_UINT8;\n        } else {\n            memcpy(data + i * scanline_size, buf, scanline_size);\n        }\n    }\n    TIFFClose(tif);\n\n\n    xfree(buf);\n\n    // fill struct fields\n    x->dimension = 2;\n    x->sizes[0] = w;\n    x->sizes[1] = h;\n    x->pixel_dimension = spp;\n    x->type = fmt_iio;\n    x->format = x->meta = -42;\n    x->data = data;\n    x->contiguous_data = false;\n\n    return 0;\n}",
    "ImageIO::errorType ImageIO::loadTIFF(const char * filename)\n{\n#ifdef ENABLE_TIFF\n  TIFF * tiff = TIFFOpen(filename, \"r\");\n  if (!tiff)\n    return IO_ERROR;\n\n  // read the dimensions\n  uint32 tiff_width, tiff_height;\n  uint16 tiff_samplesPerPixel;\n  uint16 tiff_bits;\n  TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, &tiff_width);\n  TIFFGetField(tiff, TIFFTAG_IMAGELENGTH, &tiff_height);\n  TIFFGetField(tiff, TIFFTAG_SAMPLESPERPIXEL, &tiff_samplesPerPixel);\n  TIFFGetField(tiff, TIFFTAG_BITSPERSAMPLE, &tiff_bits);\n\n  //printf(\"tiff_width: %d tiff_height: %d tiff_samplesPerPixel: %d tiff_bits: %d\\n\", tiff_width, tiff_height, tiff_samplesPerPixel, tiff_bits);\n\n  if ((tiff_samplesPerPixel != IMAGE_IO_RGB) && (tiff_samplesPerPixel != IMAGE_IO_RGB_ALPHA))\n  {\n    printf(\"Error in loadTIFF: Sorry, cannot handle %d-channel images.\\n\", tiff_samplesPerPixel);\n    TIFFClose(tiff);\n    return OTHER_ERROR;\n  }\n\n  if (tiff_bits != BITS_PER_CHANNEL_8)\n  {\n    printf(\"Error in loadTIFF: Sorry, cannot handle %d-bit images.\\n\", tiff_bits);\n    TIFFClose(tiff);\n    return OTHER_ERROR;\n  }\n\n  width = tiff_width;\n  height = tiff_height;\n  bytesPerPixel = tiff_samplesPerPixel;\n\n  uint32 * tiff_pixels = (uint32*) _TIFFmalloc(tiff_width * tiff_height * sizeof(uint32));\n  if (!tiff_pixels)\n  {\n    TIFFClose(tiff);\n    return MEMORY_ERROR;\n  }\n\n  printf(\"Loading TIFF image from file %s: resolution: %d x %d, %d-bit.\\n\", filename, width, height, 8 * bytesPerPixel);\n \n  int stopOnError = 1;\n  if (!TIFFReadRGBAImage(tiff, tiff_width, tiff_height, tiff_pixels, stopOnError))\n  { \n    _TIFFfree(tiff_pixels);\n    TIFFClose(tiff);\n    printf(\"Error in loadTIFF: Unknown error when calling TIFFReadRGBAImage.\\n\");\n    return IO_ERROR;\n  }\n\n  pixels = (unsigned char*) malloc (sizeof(unsigned char) * width * height * bytesPerPixel);\n\n  // write tiff_pixels into the pixels array\n  int counter = 0;\n  for(unsigned int row=0; row < height; row++)\n  {\n    for(unsigned int column=0; column < width; column++)\n    {\n      // read the uint32 pixel\n      uint32 tiff_pixel = tiff_pixels[row * tiff_width + column];\n\n      // write R,G,B,A in place into pixels\n      pixels[counter] = TIFFGetR(tiff_pixel);\n      counter++;\n\n      if (bytesPerPixel < 3) \n        continue;\n\n      pixels[counter] = TIFFGetG(tiff_pixel);\n      counter++;\n      pixels[counter] = TIFFGetB(tiff_pixel);\n      counter++;\n\n      if (bytesPerPixel < 4) \n        continue;\n\n      // alpha channel\n      pixels[counter] = TIFFGetA(tiff_pixel);\n      counter++;\n    }\n  }\n\n  _TIFFfree(tiff_pixels);\n  TIFFClose(tiff);\n\n  return OK;\n\n#else\n  return INVALID_FILE_FORMAT;\n#endif\n}",
    "ImageIO::errorType ImageIO::saveTIFF(const char * filename)\n{\n#ifdef ENABLE_TIFF\n\n  TIFF *tif;\n\n  tif = TIFFOpen(filename, \"w\");\n  if( !tif )\n  {\n    printf(\"Error in saveTIFF: Cannot open file %s.\\n\", filename);\n    return IO_ERROR;\n  }\n\n  TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, width);\n  TIFFSetField(tif, TIFFTAG_IMAGELENGTH, height);\n  TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, bytesPerPixel);\n  TIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n  TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, BITS_PER_CHANNEL_8);\n  TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n  if (bytesPerPixel < IMAGE_IO_RGB)\n    TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n  else\n    TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n  TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_LZW);\n  TIFFSetField(tif, TIFFTAG_PREDICTOR, IMAGE_IO_HORIZONTAL_DIFFERENCING);\n\n  tsize_t bytesPerRow = bytesPerPixel * width;    \n  \n  if (TIFFScanlineSize(tif) != bytesPerRow)\n  {\n    printf(\"Error in saveTIFF: the scanline size mismatches the length in memory of one row of pixels in the image.\\n\");\n    TIFFClose(tif);\n    return IO_ERROR;\n  }\n  \n  unsigned char * imageBuf = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(tif));\n  if (imageBuf == NULL)\n  {\n    printf(\"Error in saveTIFF: cannot allocate memory for the storage of a row of pixels.\\n\");\n    TIFFClose(tif);\n    return IO_ERROR;\n  }\n\n  // Set the strip size of the file to be the size of one row of pixels\n  TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, TIFFDefaultStripSize(tif, (uint32)bytesPerRow));\n\n  for (unsigned int row = 0; row < height; row++)\n  {\n    memcpy(imageBuf, &pixels[(height - row - 1) * bytesPerRow], sizeof(unsigned char) * bytesPerRow); \n    if (TIFFWriteScanline(tif, imageBuf, row, 0) < 0)  // an error occurred while writing the image\n    {\n      printf(\"Error in saveTIFF: Error while saving TIFF image to %s.\\n\", filename);\n      _TIFFfree(imageBuf);\n      TIFFClose(tif);\n      return IO_ERROR;\n    }\n  }\n\n  _TIFFfree(imageBuf);\n  TIFFClose(tif);\n\n  return OK;\n#else\n  return INVALID_FILE_FORMAT;\n#endif\n}",
    "TiffFileReader::~TiffFileReader()\n  {\n    if (_tiff)\n      TIFFClose(_tiff);\n  }",
    "void TiffFileWriter::write(const char* filepath)\n  {\n    auto out = TIFFOpen(filepath, \"w\");\n    if (out == NULL)\n      throw std::runtime_error{\"Could not create image file\"};\n\n    // We need to set some values for basic tags before we can add any data\n    TIFFSetField(out, TIFFTAG_IMAGEWIDTH, _width);\n    TIFFSetField(out, TIFFTAG_IMAGELENGTH, _height);\n\n    constexpr auto bit_depth = 8;\n    TIFFSetField(out, TIFFTAG_BITSPERSAMPLE, bit_depth);\n    TIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, _depth);\n    TIFFSetField(out, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\n    TIFFSetField(out, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);\n    TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n\n    // Write the information to the file\n    TIFFWriteEncodedStrip(out, 0, const_cast<unsigned char*>(&_data[0]),\n                          _width * _height * _depth);\n\n    TIFFClose(out);\n  }",
    "GeoTiffPager::~GeoTiffPager()\n{\n   if (mpTiff != NULL)\n   {\n      TIFFClose(mpTiff);\n      mpTiff = NULL;\n   }\n}",
    "bool imread_tiff(string input_image_filename, matrix<float> &returnmatrix,\n\t\tExiv2::ExifData &exifData)\n{\n    TIFFSetWarningHandler(NULL);\n    TIFF* tif = TIFFOpen(input_image_filename.c_str(), \"r\");\n    if (!tif)\n\t{\n        cerr << \"imread_tiff: Could not read input file!\" << endl;\n        return true;\n\t}\n\tuint32 imagelength;\n\tuint32 imagewidth;\n\tuint16 num_chan;//number of color channels\n\tunsigned short * buf16;\n\tunsigned char  * buf8;\n\tuint16 bits_per_sample;\n\n\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &imagelength);\n\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &imagewidth);\n\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &num_chan);\n\tTIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bits_per_sample);\n\n\treturnmatrix.set_size(imagelength,imagewidth*3);\n\n    //The matrix is 3x wider than the image, interleaving the channels.\n\tif(bits_per_sample == 16)\n\t{\n\t  buf16 = (unsigned short *)_TIFFmalloc(TIFFScanlineSize(tif));\n      for ( unsigned int row = 0; row < imagelength; row++)\n\t  {\n\t      TIFFReadScanline(tif, buf16, row);\n          for( unsigned int col = 0; col < imagewidth; col++)\n\t\t  {\n\t\t\t  returnmatrix(row,col*3    ) = buf16[col*num_chan    ];\n\t\t\t  returnmatrix(row,col*3 + 1) = buf16[col*num_chan + 1];\n              returnmatrix(row,col*3 + 2) = buf16[col*num_chan + 2];\n\t\t  }\n\t  }\n\t  _TIFFfree(buf16);\n\t}\n\telse\n\t{\n\t  buf8 = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(tif));\n      for ( unsigned int row = 0; row < imagelength; row++)\n\t  {\n\t      TIFFReadScanline(tif, buf8, row);\n          for( unsigned int col = 0; col < imagewidth; col++)\n\t\t  {\n\t\t\t  returnmatrix(row,col*3    ) = buf8[col*num_chan    ];\n\t\t\t  returnmatrix(row,col*3    ) *= 257;\n\t\t\t  returnmatrix(row,col*3 + 1) = buf8[col*num_chan + 1];\n\t\t\t  returnmatrix(row,col*3 + 1) *= 257;\n              returnmatrix(row,col*3 + 2) = buf8[col*num_chan + 2];\n              returnmatrix(row,col*3 + 2) *= 257;\n\t\t  }\n\t  }\n\t  _TIFFfree(buf8 );\n\t}\n\tTIFFClose(tif);\n\n    cout << \"imread_tiff exiv filename: \" << input_image_filename << endl;\n    auto image = Exiv2::ImageFactory::open(input_image_filename);\n\tassert(image.get() != 0);\n    image->readMetadata();\n\texifData = image->exifData();\n\n\treturn false;\n}",
    "bool imwrite_tiff(const matrix<unsigned short>& output, string outputfilename,\n                  Exiv2::ExifData exifData)\n{\n    int xsize, ysize;\n    xsize = output.nc()/3;\n    ysize = output.nr();\n\n\n\n    outputfilename = outputfilename + \".tif\";\n    TIFF *out = TIFFOpen(outputfilename.c_str(),\"w\");\n    if (!out)\n    {\n        cerr << \"Can't open file for writing\" << endl;\n        return 1;\n    }\t\n    TIFFSetField(out, TIFFTAG_IMAGEWIDTH, xsize);  \n    TIFFSetField(out, TIFFTAG_IMAGELENGTH, ysize);\n    TIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, 3); //RGB\n    TIFFSetField(out, TIFFTAG_BITSPERSAMPLE, 16);\n    TIFFSetField(out, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);    // set the origin of the image.\n    //Magic below\n    TIFFSetField(out, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n    if(!TIFFSetField(out, TIFFTAG_COMPRESSION, COMPRESSION_NONE)) {cout << \"couldn't set tiff compression\" << endl;}\n    //End Magic\n\n    std::string make = exifData[\"Exif.Image.Make\"].toString();\n    TIFFSetField(out, TIFFTAG_MAKE, make.c_str());\n    std::string model = exifData[\"Exif.Image.Model\"].toString();\n    TIFFSetField(out, TIFFTAG_MODEL, model.c_str());\n    TIFFSetField(out, TIFFTAG_SOFTWARE, \"Filmulator\");\n    std::string copyright = exifData[\"Exif.Image.Copyright\"].toString();\n    TIFFSetField(out, TIFFTAG_COPYRIGHT, copyright.c_str());\n    std::string lensinfo = exifData[\"Exif.Image.LensInfo\"].toString();\n    TIFFSetField(out, TIFFTAG_LENSINFO, lensinfo.c_str());\n    std::string datetime = exifData[\"Exif.Image.DateTime\"].toString();\n    TIFFSetField(out, TIFFTAG_DATETIME, datetime.c_str());\n\n    tsize_t linebytes = 3 * xsize * 2;//Size in bytes of a line\n    unsigned short *buf = NULL;\n    buf =(unsigned short *)_TIFFmalloc(linebytes);\n    for (int j = 0; j < ysize; j++)\n    {\n        for(int i = 0; i < xsize; i ++)\n        {\n            buf[i*3  ] = output(j,i*3  );\n            buf[i*3+1] = output(j,i*3+1);\n            buf[i*3+2] = output(j,i*3+2);\n        }\n        if (TIFFWriteScanline(out, buf, j, 0) < 0)\n            break;\n    }\n\n    TIFFWriteDirectory(out);\n\n    (void) TIFFClose(out);\n\n    if (buf)\n        _TIFFfree(buf);\n\n    //Programs reading tiffs really freak out if you write the full exif data\n    //So we write only the basics here.\n    Exiv2::ExifData minimumData;\n    minimumData[\"Exif.Photo.ISOSpeedRatings\"] = exifData[\"Exif.Photo.ISOSpeedRatings\"];\n    minimumData[\"Exif.Photo.ExposureTime\"]    = exifData[\"Exif.Photo.ExposureTime\"];\n    minimumData[\"Exif.Photo.FNumber\"]         = exifData[\"Exif.Photo.FNumber\"];\n    minimumData[\"Exif.Photo.FocalLength\"]     = exifData[\"Exif.Photo.FocalLength\"];\n\n    minimumData.sortByTag(); //darktable's does this so maybe we should\n\n    auto image = Exiv2::ImageFactory::open(outputfilename);\n    assert(image.get() != 0);\n\n    image->setExifData(minimumData);\n    image->writeMetadata();\n\n    return 0;\n}",
    "int main(int argc, char* argv[]) {\n\n    TIFFSetWarningHandler(DummyHandler);\n\n    if (argc != 3) {\n        cerr << \"Usage:  \" << argv[0] << \" FILE.TIFF OUTPUT_FILENAME\" << endl;\n        return -1;\n    }\n\n    filename = argv[1];\n    out_filename = argv[2];\n\n\n    printf(\"Converting %s to %s: \", filename, out_filename);\n\n    FILE *fp = fopen(filename, \"rb\");\n    if (!fp) {\n        cout << \"FP is null\" << endl;\n        return -1;\n    };\n    fclose(fp);\n\n\n    TIFF *tif=TIFFOpen(filename, \"r\");\n    fp = fopen(out_filename, \"wb\");\n\n\n    uint32_t width = 0, height = 0, bits_per_sample = 0, samples_per_pixel = 0, sample_format = 0;\n\n\n    TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);           // uint32 width;\n    TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);        // uint32 height;\n\n    TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bits_per_sample);\n    TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &samples_per_pixel);\n    TIFFGetField(tif, TIFFTAG_SAMPLEFORMAT, &sample_format);\n\n\n    printf(\"(%d x %d, %d bit) \", width, height, bits_per_sample);\n\n    if ( (bits_per_sample != 16) || (sample_format != 2) || (samples_per_pixel != 1) ) {\n        printf(\"ERROR: Bad format. Aborted. \\n\\n\");\n        fclose(fp);\n        TIFFClose(tif);\n        return -1;\n    }\n\n\n    int16_t *buf;\n    tsize_t scanline = TIFFScanlineSize(tif);\n\n\n    buf = (int16_t*) _TIFFmalloc(scanline);\n    for (uint32_t row = 0; row < height; row++) {\n        TIFFReadScanline(tif, buf, row);\n\n\n        for (int i = 0; i < width; i++) {\n            buf[i] /= 2;\n        }\n\n        fwrite( buf, scanline, 1, fp );\n\n    };\n    _TIFFfree(buf);\n\n\n\n    TIFFClose(tif);\n    fclose(fp);\n\n    printf(\"Done.\\n\");\n\n    return 0;\n}",
    "int main(int argc, char* argv[]) {\n\n    TIFFSetWarningHandler(DummyHandler);\n\n    if (argc != 5) {\n        cerr << \"Usage:  \" << argv[0] << \" <background.tiff> <overlay.tiff> <mask.tiff> <output_filename.tiff>\" << endl;\n        return -1;\n    }\n\n    char *fn_tiff1 = argv[1];\n    char *fn_tiff2 = argv[2];\n    char *fn_tiff_mask = argv[3];\n    char *fn_tiff_out = argv[4];\n\n    // only check\n    FILE *fp;\n\n    fp = fopen(fn_tiff1, \"rb\");\n    if (!fp) {\n        fprintf(stderr, \"Not found: %s. Aborted.\\n\", fn_tiff1);\n        return -1;\n    };\n    fclose(fp);\n\n    fp = fopen(fn_tiff2, \"rb\");\n    if (!fp) {\n        fprintf(stderr, \"Not found: %s. Aborted.\\n\", fn_tiff2);\n        return -1;\n    };\n    fclose(fp);\n\n    fp = fopen(fn_tiff_mask, \"rb\");\n    if (!fp) {\n        fprintf(stderr, \"Not found: %s. Aborted.\\n\", fn_tiff_mask);\n        return -1;\n    };\n    fclose(fp);\n\n\n    TIFF *tiff1 = TIFFOpen(fn_tiff1, \"rb\");\n\n    TIFF *tiff2 = TIFFOpen(fn_tiff2, \"rb\");\n\n    TIFF *tiff_mask = TIFFOpen(fn_tiff_mask, \"rb\");\n\n    TIFF *tiff_out = TIFFOpen(fn_tiff_out, \"rb+\");\n\n\n\n    uint32_t width = 0, height = 0, bits_per_sample = 0, samples_per_pixel = 0, sample_format = 0;\n\n\n\n    TIFFGetField(tiff1, TIFFTAG_IMAGEWIDTH, &width);           // uint32 width;\n    TIFFGetField(tiff1, TIFFTAG_IMAGELENGTH, &height);        // uint32 height;\n\n    TIFFGetField(tiff1, TIFFTAG_BITSPERSAMPLE, &bits_per_sample);\n    TIFFGetField(tiff1, TIFFTAG_SAMPLESPERPIXEL, &samples_per_pixel);\n    TIFFGetField(tiff1, TIFFTAG_SAMPLEFORMAT, &sample_format);\n\n\n\n    printf(\"%s: (%d x %d, %d bit) (samples per pixel: %d, format: %d) \\n\", fn_tiff1, width, height, bits_per_sample, samples_per_pixel, sample_format);\n\n    if ( (bits_per_sample != 16) || (sample_format != 2) || (samples_per_pixel != 1) ) {\n        fprintf(stderr, \"ERROR: Bad format. Aborted. \\n\\n\");\n        TIFFClose(tiff1);\n        TIFFClose(tiff2);\n        TIFFClose(tiff_mask);\n        TIFFClose(tiff_out);\n        exit(-1);\n    };\n\n    uint32_t width2 = 0, height2 = 0, bits_per_sample2 = 0, samples_per_pixel2 = 0, sample_format2 = 0;\n\n    TIFFGetField(tiff2, TIFFTAG_IMAGEWIDTH, &width2);           // uint32 width;\n    TIFFGetField(tiff2, TIFFTAG_IMAGELENGTH, &height2);        // uint32 height;\n\n    TIFFGetField(tiff2, TIFFTAG_BITSPERSAMPLE, &bits_per_sample2);\n    TIFFGetField(tiff2, TIFFTAG_SAMPLESPERPIXEL, &samples_per_pixel2);\n    TIFFGetField(tiff2, TIFFTAG_SAMPLEFORMAT, &sample_format2);\n\n    printf(\"%s: (%d x %d, %d bit) (samples per pixel: %d, format: %d) \\n\", fn_tiff2, width2, height2, bits_per_sample2, samples_per_pixel2, sample_format2);\n\n    if (\n        (width != width2)\n        || (height != height2)\n        || (bits_per_sample != bits_per_sample2)\n        || (samples_per_pixel != samples_per_pixel2)\n        || (sample_format != sample_format2)\n\n        ) {\n\n        fprintf(stderr, \"ERROR: Format of %s is different from %s. Aborted. \\n\", fn_tiff2, fn_tiff1 );\n\n        TIFFClose(tiff1);\n        TIFFClose(tiff2);\n        TIFFClose(tiff_mask);\n        TIFFClose(tiff_out);\n\n        exit(-1);\n\n    };\n\n\n\n    uint32_t width_mask = 0, height_mask = 0, bits_per_sample_mask = 0, samples_per_pixel_mask = 0, sample_format_mask = 0;\n\n    TIFFGetField(tiff_mask, TIFFTAG_IMAGEWIDTH, &width_mask);           // uint32 width;\n    TIFFGetField(tiff_mask, TIFFTAG_IMAGELENGTH, &height_mask);        // uint32 height;\n\n    TIFFGetField(tiff_mask, TIFFTAG_BITSPERSAMPLE, &bits_per_sample_mask);\n    TIFFGetField(tiff_mask, TIFFTAG_SAMPLESPERPIXEL, &samples_per_pixel_mask);\n    TIFFGetField(tiff_mask, TIFFTAG_SAMPLEFORMAT, &sample_format_mask);\n\n    printf(\"%s: (%d x %d, %d bit) (samples per pixel: %d, format: %d) \\n\", fn_tiff_mask, width_mask, height_mask, bits_per_sample_mask, samples_per_pixel_mask, sample_format_mask);\n\n\n\n    int16_t *buf1, *buf2;\n    uint8_t *buf_mask;\n    tsize_t scanline = TIFFScanlineSize(tiff1);\n\n    if (TIFFScanlineSize(tiff2) != scanline) {\n        fprintf(stderr, \"ERROR: Scanline Size of %s (%d) is different from %s (%d).\\n\", fn_tiff2, (TIFFScanlineSize(tiff2)), fn_tiff1, scanline );\n        return -1;\n    };\n    if (2*TIFFScanlineSize(tiff_mask) != scanline) {\n        fprintf(stderr, \"ERROR: Scanline Size of %s (%d) must be 1/2 of scanline size of %s (%d).\\n\", fn_tiff_mask, (TIFFScanlineSize(tiff_mask)), fn_tiff1, scanline );\n        return -1;\n    };\n\n\n    buf1 = (int16_t*) _TIFFmalloc(scanline);\n    buf2 = (int16_t*) _TIFFmalloc(scanline);\n    buf_mask = (uint8_t*) _TIFFmalloc(scanline);\n\n\n    for (uint32_t row = 0; row < height; row++) {\n\n        TIFFReadScanline(tiff1, buf1, row);\n        TIFFReadScanline(tiff2, buf2, row);\n        TIFFReadScanline(tiff_mask, buf_mask, row);\n\n\n        for (int i = 0; i < width; i++) {\n\n            float k = 1.0 / 255.0 * buf_mask[i];\n\n            buf1[i] = (int16_t) ( (1.0-k)*buf1[i] + k*buf2[i] );\n\n        };\n\n\n        TIFFWriteScanline(tiff_out, buf1, row);\n\n    };\n\n    _TIFFfree(buf1);\n    _TIFFfree(buf2);\n    _TIFFfree(buf_mask);\n\n\n\n    TIFFClose(tiff1);\n    TIFFClose(tiff2);\n    TIFFClose(tiff_mask);\n    TIFFClose(tiff_out);\n\n\n\n    printf(\"Done.\\n\");\n\n    return 0;\n}",
    "bool\nImage::saveTIFF(const char *file, SaveInfo*)\n{\n    TIFF *tif = TIFFOpen(file, \"w\");\n    if (!tif)\n        return (false);\n\n    TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, rgb_width);\n    TIFFSetField(tif, TIFFTAG_IMAGELENGTH, rgb_height);\n    TIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n    TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8);\n    TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n//    TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_LZW);\nTIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);\n    TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 3);\n    TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n    TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP,\n        TIFFDefaultStripSize(tif, (unsigned int)-1));\n    for (int y = 0; y < rgb_height; y++) {\n        unsigned char *data = rgb_data + (y * rgb_width * 3);\n        TIFFWriteScanline(tif, data, y, 0);\n    }\n    TIFFClose(tif);\n    return (true);\n}",
    "bool\ntiffns::tiff_to_png(const char *tiffname, FILE *pngfp)\n{\n    bool bigendian = test_bigendian();\n\n    TIFF *tif = TIFFOpen(tiffname, \"r\");\n    if (!tif) {\n        err_printf(\"Failed to open %s.\", tiffname);\n        return (false);\n    }\n\n    png_struct *png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING,\n        &jmpbuf_struct, error_handler, 0);\n    if (!png_ptr) {\n        TIFFClose(tif);\n        return (false);\n    }\n\n    png_info *info_ptr = png_create_info_struct(png_ptr);\n    if (!info_ptr) {\n        png_destroy_write_struct(&png_ptr, 0);\n        TIFFClose(tif);\n        return (false);\n    }\n\n    if (setjmp(jmpbuf_struct.jmpbuf)) {\n        png_destroy_write_struct(&png_ptr, 0);\n        TIFFClose(tif);\n        return (false);\n    }\n\n    png_init_io(png_ptr, pngfp);\n\n#ifdef DEBUG\n    if (verbose) {\n        int byteswapped = TIFFIsByteSwapped(tif);\n\n        fprintf(stderr, \"tiff_to_png:  \");\n        TIFFPrintDirectory(tif, stderr, TIFFPRINT_NONE);\n        fprintf(stderr, \"tiff_to_png:  byte order = %s\\n\",\n            ((bigendian && byteswapped) || (!bigendian && !byteswapped))?\n            \"little-endian (Intel)\" : \"big-endian (Motorola)\");\n        fprintf(stderr, \"tiff_to_png:  this machine is %s-endian\\n\",\n            bigendian? \"big\" : \"little\");\n    }\n#endif\n\n    unsigned short photometric;\n    if (!TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric)) {\n        err_printf(\"TIFF photometric could not be retrieved (%s)\", tiffname);\n        png_destroy_write_struct(&png_ptr, &info_ptr);\n        TIFFClose(tif);\n        return (false);\n    }\n    unsigned short bps;\n    if (!TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bps))\n        bps = 1;\n    unsigned short spp;\n    if (!TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &spp))\n        spp = 1;\n    unsigned short planar;\n    if (!TIFFGetField(tif, TIFFTAG_PLANARCONFIG, &planar))\n        planar = 1;\n\n    unsigned short tiled = TIFFIsTiled(tif);\n\n    int cols, rows;\n    TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &cols);\n    TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &rows);\n    png_uint_32 width = cols;\n\n    bool have_res = false;\n    float xres, yres;\n    png_uint_32 res_x=0, res_y=0;\n    int unit_type = 0;\n    if (TIFFGetField(tif, TIFFTAG_XRESOLUTION, &xres) &&\n            TIFFGetField(tif, TIFFTAG_YRESOLUTION, &yres) && \n            (xres != 0.0) && (yres != 0.0)) {\n        uint16_t resunit;\n        have_res = true;\n#ifdef DEBUG\n        if (verbose) {\n            float ratio = xres / yres;\n            fprintf(stderr,\n                \"tiff_to_png:  aspect ratio (hor/vert) = %g (%g / %g)\\n\",\n                ratio, xres, yres);\n            if (0.95 < ratio && ratio < 1.05)\n                fprintf(stderr, \"tiff2png:  near-unity aspect ratio\\n\");\n            else if (1.90 < ratio && ratio < 2.10)\n                fprintf(stderr, \"tiff2png:  near-2X aspect ratio\\n\");\n            else\n                fprintf(stderr, \"tiff2png:  non-square, non-2X pixels\\n\");\n        }\n#endif\n\n        if (!TIFFGetField(tif, TIFFTAG_RESOLUTIONUNIT, &resunit))\n            resunit = RESUNIT_INCH;\n\n        // Convert from TIFF data (floats) to PNG data (unsigned longs).\n        switch (resunit) {\n        case RESUNIT_CENTIMETER:\n            res_x = (png_uint_32)(100.0*xres + 0.5);\n            res_y = (png_uint_32)(100.0*yres + 0.5);\n            unit_type = PNG_RESOLUTION_METER;\n            break;\n        case RESUNIT_INCH:\n            res_x = (png_uint_32)(39.37*xres + 0.5);\n            res_y = (png_uint_32)(39.37*yres + 0.5);\n            unit_type = PNG_RESOLUTION_METER;\n            break;\n        case RESUNIT_NONE:\n        default:\n            res_x = (png_uint_32)(100.0*xres + 0.5);\n            res_y = (png_uint_32)(100.0*yres + 0.5);\n            unit_type = PNG_RESOLUTION_UNKNOWN;\n            break;\n        }\n    }\n\n#ifdef DEBUG\n    if (verbose) {\n        fprintf(stderr, \"tiff_to_png:  %dx%dx%d image\\n\", cols, rows,\n            bps * spp);\n        fprintf(stderr, \"tiff_to_png:  %d bit%s/sample, %d sample%s/pixel\\n\",\n            bps, bps == 1? \"\" : \"s\", spp, spp == 1? \"\" : \"s\");\n    }\n#endif\n\n    // Detect tiff filetype.\n\n    int maxval = (1 << bps) - 1;\n#ifdef DEBUG\n    if (verbose)\n        fprintf(stderr, \"tiff_to_png:  maxval=%d\\n\", maxval);\n#endif\n\n    int color_type = -1;\n    int bit_depth = 0;\n    int colors = 0;\n    png_color palette[MAXCOLORS];\n    unsigned short tiff_compression_method;\n\n    switch (photometric) {\n    case PHOTOMETRIC_MINISWHITE:\n    case PHOTOMETRIC_MINISBLACK:\n#ifdef DEBUG\n        if (verbose) {\n            fprintf(stderr,\n                \"tiff_to_png:  %d graylevels (min = %s)\\n\", maxval + 1,\n                photometric == PHOTOMETRIC_MINISBLACK? \"black\" : \"white\");\n        }\n#endif\n        if (spp == 1) {\n            // no alpha\n            color_type = PNG_COLOR_TYPE_GRAY;\n#ifdef DEBUG\n            if (verbose)\n                fprintf(stderr, \"tiff_to_png:  color type = grayscale\\n\");\n#endif\n            bit_depth = bps;\n        }\n        else {\n            // must be alpha\n            color_type = PNG_COLOR_TYPE_GRAY_ALPHA;\n#ifdef DEBUG\n            if (verbose)\n                fprintf(stderr,\n                    \"tiff_to_png:  color type = grayscale + alpha\\n\");\n#endif\n            if (bps <= 8)\n                bit_depth = 8;\n            else\n                bit_depth = bps;\n        }\n        break;\n\n    case PHOTOMETRIC_PALETTE:\n        {\n            int palette_8bit; // Set iff all color values in TIFF palette\n                              // are < 256.\n\n            color_type = PNG_COLOR_TYPE_PALETTE;\n#ifdef DEBUG\n            if (verbose)\n                fprintf(stderr, \"tiff_to_png:  color type = paletted\\n\");\n#endif\n\n            unsigned short *redcolormap;\n            unsigned short *greencolormap;\n            unsigned short *bluecolormap;\n            if (!TIFFGetField(tif, TIFFTAG_COLORMAP, &redcolormap,\n                    &greencolormap, &bluecolormap)) {\n                err_printf(\"Cannot retrieve TIFF colormaps (%s)\\n\", tiffname);\n                png_destroy_write_struct(&png_ptr, &info_ptr);\n                TIFFClose(tif);\n                return (false);\n            }\n            colors = maxval + 1;\n            if (colors > MAXCOLORS) {\n                err_printf(\"Palette too large (%d colors) (%s)\\n\",\n                    colors, tiffname);\n                png_destroy_write_struct(&png_ptr, &info_ptr);\n                TIFFClose(tif);\n                return (false);\n            }\n            // Max PNG palette-size is 8 bits, you could convert to\n            // full-color.\n            if (bps >= 8) \n                bit_depth = 8;\n            else\n                bit_depth = bps;\n\n            // PLTE chunk\n            // TIFF palettes contain 16-bit shorts, while PNG palettes\n            // are 8-bit.  Some broken (??) software puts 8-bit values\n            // in the shorts, which would make the palette come out\n            // all zeros, which isn't good.  We check...\n\n            palette_8bit = 1;\n            for (int i = 0 ; i < colors ; i++) {\n                if (redcolormap[i] > 255 || greencolormap[i] > 255 ||\n                         bluecolormap[i] > 255) {\n                     palette_8bit = 0;\n                     break;\n                }\n            } \n#ifdef DEBUG\n            if (palette_8bit && verbose)\n                fprintf(stderr,\n                    \"tiff_to_png warning:  assuming 8-bit palette values.\\n\");\n#endif\n\n            for (int i = 0 ; i < colors ; i++) {\n                if (palette_8bit) {\n                    palette[i].red   = (png_byte)redcolormap[i];\n                    palette[i].green = (png_byte)greencolormap[i];\n                    palette[i].blue  = (png_byte)bluecolormap[i];\n                }\n                else {\n                    palette[i].red   = (png_byte)(redcolormap[i] >> 8);\n                    palette[i].green = (png_byte)(greencolormap[i] >> 8);\n                    palette[i].blue  = (png_byte)(bluecolormap[i] >> 8);\n                }\n            }\n            break;\n        }\n\n    case PHOTOMETRIC_YCBCR:\n        TIFFGetField(tif, TIFFTAG_COMPRESSION, &tiff_compression_method);\n        if (tiff_compression_method == COMPRESSION_JPEG &&\n                planar == PLANARCONFIG_CONTIG) {\n            // Can rely on libjpeg to convert to RGB.\n            TIFFSetField(tif, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n            photometric = PHOTOMETRIC_RGB;\n#ifdef DEBUG\n            if (verbose)\n                fprintf(stderr, \"tiff2png:  original color type = YCbCr \"\n                    \"with JPEG compression.\\n\");\n#endif\n        }\n        else {\n            err_printf(\n                \"Don't know how to handle PHOTOMETRIC_YCBCR with \"\n                \"compression %d\\n\"\n                \"  (%sJPEG) and planar config %d (%scontiguous)\\n\"\n                \"  (%s)\\n\", tiff_compression_method,\n                tiff_compression_method == COMPRESSION_JPEG? \"\" : \"not \",\n                planar, planar == PLANARCONFIG_CONTIG? \"\" : \"not \", tiffname);\n            png_destroy_write_struct(&png_ptr, &info_ptr);\n            TIFFClose(tif);\n            return (false);\n        }\n        // fall thru... \n\n    case PHOTOMETRIC_RGB:\n        if (spp == 3) {\n            color_type = PNG_COLOR_TYPE_RGB;\n#ifdef DEBUG\n            if (verbose)\n                fprintf(stderr, \"tiff_to_png:  color type = truecolor\\n\");\n#endif\n        }\n        else {\n            color_type = PNG_COLOR_TYPE_RGB_ALPHA;\n#ifdef DEBUG\n            if (verbose)\n                fprintf(stderr,\n                    \"tiff_to_png:  color type = truecolor + alpha\\n\");\n#endif\n        }\n        if (bps <= 8)\n            bit_depth = 8;\n        else\n            bit_depth = bps;\n        break;\n\n    case PHOTOMETRIC_LOGL:\n    case PHOTOMETRIC_LOGLUV:\n        TIFFGetField(tif, TIFFTAG_COMPRESSION, &tiff_compression_method);\n        if (tiff_compression_method != COMPRESSION_SGILOG &&\n                tiff_compression_method != COMPRESSION_SGILOG24) {\n            err_printf(\"Don't know how to handle PHOTOMETRIC_LOGL%s with\\n\"\n                \"  compression %d (not SGILOG) (%s)\\n\",\n                photometric == PHOTOMETRIC_LOGLUV? \"UV\" : \"\",\n                tiff_compression_method, tiffname);\n            png_destroy_write_struct(&png_ptr, &info_ptr);\n            TIFFClose(tif);\n            return (false);\n        }\n        // rely on library to convert to RGB/greyscale.\n#ifdef LIBTIFF_HAS_16BIT_INTEGER_FORMAT\n        if (bps > 8) {\n            // SGILOGDATAFMT_16BIT converts to a floating-point\n            // luminance value; U,V are left as such. \n            // SGILOGDATAFMT_16BIT_INT doesn't exist.\n\n            TIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_16BIT_INT);\n            bit_depth = bps = 16;\n        }\n        else\n#endif\n        {\n            // SGILOGDATAFMT_8BIT converts to normal grayscale or RGB format.\n            TIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_8BIT);\n            bit_depth = bps = 8;\n        }\n        if (photometric == PHOTOMETRIC_LOGL) {\n            photometric = PHOTOMETRIC_MINISBLACK;\n            color_type = PNG_COLOR_TYPE_GRAY;\n#ifdef DEBUG\n            if (verbose) {\n                fprintf(stderr, \"tiff_to_png:  original color type = \"\n                    \"logL with SGILOG compression.\\n\");\n                fprintf(stderr, \"tiff_to_png:  color type = grayscale.\\n\");\n            }\n#endif\n        }\n        else {\n            photometric = PHOTOMETRIC_RGB;\n            color_type = PNG_COLOR_TYPE_RGB;\n#ifdef DEBUG\n            if (verbose) {\n                fprintf(stderr, \"tiff_to_png:  original color type = \"\n                    \"logLUV with SGILOG compression.\\n\");\n                fprintf(stderr, \"tiff_to_png:  color type = truecolor.\\n\");\n            }\n#endif\n        }\n        break;\n\n    case PHOTOMETRIC_MASK:\n    case PHOTOMETRIC_SEPARATED:\n    case PHOTOMETRIC_CIELAB:\n    case PHOTOMETRIC_DEPTH:\n        err_printf(\"Don't know how to handle %s (%s)\\n\",\n            photometric == PHOTOMETRIC_MASK?      \"PHOTOMETRIC_MASK\" :\n            photometric == PHOTOMETRIC_SEPARATED? \"PHOTOMETRIC_SEPARATED\" :\n            photometric == PHOTOMETRIC_CIELAB?    \"PHOTOMETRIC_CIELAB\" :\n            photometric == PHOTOMETRIC_DEPTH?     \"PHOTOMETRIC_DEPTH\" :\n                                                  \"unknown photometric\",\n            tiffname);\n        png_destroy_write_struct(&png_ptr, &info_ptr);\n        TIFFClose(tif);\n        return (false);\n\n    default:\n        err_printf(\"Unknown photometric (%d) (%s)\\n\",\n            photometric, tiffname);\n        png_destroy_write_struct(&png_ptr, &info_ptr);\n        TIFFClose(tif);\n        return (false);\n    }\n    int tiff_color_type = color_type;\n\n#ifdef DEBUG\n    if (verbose)\n        fprintf(stderr, \"tiff_to_png:  bit depth = %d\\n\", bit_depth);\n#endif\n\n    // Put parameter info in png-chunks.\n\n    png_set_IHDR(png_ptr, info_ptr, width, rows, bit_depth, color_type,\n        PNG_INTERLACE_NONE, PNG_COMPRESSION_TYPE_DEFAULT,\n        PNG_FILTER_TYPE_DEFAULT);\n\n//    if (png_compression_level != -1)\n//        png_set_compression_level(png_ptr, png_compression_level);\n\n    if (color_type == PNG_COLOR_TYPE_PALETTE)\n        png_set_PLTE(png_ptr, info_ptr, palette, colors);\n\n    // gAMA chunk\n//    if (gamma != -1.0) {\n#ifdef DEBUG\n//        if (verbose)\n//            fprintf(stderr, \"tiff_to_png:  gamma = %f\\n\", gamma);\n#endif\n//        png_set_gAMA(png_ptr, info_ptr, gamma);\n//    }\n\n    // pHYs chunk\n    if (have_res)\n        png_set_pHYs(png_ptr, info_ptr, res_x, res_y, unit_type);\n\n    png_write_info(png_ptr, info_ptr);\n    png_set_packing(png_ptr);\n\n    // Allocate space for one line (or row of tiles) of TIFF image.\n\n    unsigned char *tiffline = 0;\n    unsigned char *tifftile = 0;\n    unsigned char *tiffstrip = 0;\n    size_t tilesz = 0L;\n    int num_tilesX = 0;\n    uint32_t tile_width = 0, tile_height = 0;\n\n    if (!tiled) {\n        // strip-based TIFF\n        if (planar == 1) {\n            // contiguous picture\n            tiffline = (unsigned char*)malloc(TIFFScanlineSize(tif));\n        }\n        else {\n            // separated planes\n            tiffline = (unsigned char*)malloc(TIFFScanlineSize(tif) * spp);\n        }\n    }\n    else {\n        // Allocate space for one \"row\" of tiles.\n\n        TIFFGetField(tif, TIFFTAG_TILEWIDTH, &tile_width);\n        TIFFGetField(tif, TIFFTAG_TILELENGTH, &tile_height);\n\n        num_tilesX = (width+tile_width-1)/tile_width;\n\n        if (planar == 1) {\n            tilesz = TIFFTileSize(tif);\n            tifftile = new unsigned char[tilesz];\n            size_t stripsz = (tile_width*num_tilesX) * tile_height * spp;\n            tiffstrip = new unsigned char[stripsz];\n            tiffline = tiffstrip;\n            // Just set the line to the top of the strip, we'll move it\n            // through below.\n        }\n        else {\n            err_printf(\n                \"Can't handle tiled separated-plane TIFF format (%s).\\n\",\n                tiffname);\n            png_destroy_write_struct (&png_ptr, &info_ptr);\n            TIFFClose(tif);\n            return (false);\n        }\n    }\n\n    if (!tiffline) {\n        err_printf(\"Can't allocate memory for TIFF scanline buffer (%s).\\n\",\n            tiffname);\n        png_destroy_write_struct(&png_ptr, &info_ptr);\n        TIFFClose(tif);\n        if (tiled && planar == 1)\n            delete [] tifftile;\n        return (false);\n    }\n\n    if (planar != 1) {\n        // In case we must combine more planes into one.\n        tiffstrip = new unsigned char[TIFFScanlineSize(tif)];\n        if (!tiffstrip) {\n            err_printf(\"Can't allocate memory for TIFF strip buffer (%s).\\n\",\n                tiffname);\n            png_destroy_write_struct(&png_ptr, &info_ptr);\n            TIFFClose(tif);\n            free(tiffline);\n            return (false);\n        }\n    }\n\n    // Allocate space for one line of PNG image.\n    // max: 3 color channels plus one alpha channel, 16 bit => 8 bytes/pixel\n\n    png_byte *pngline = new unsigned char[cols * 8];\n    for (int pass = 0 ; pass < png_set_interlace_handling(png_ptr); pass++) {\n        for (int row = 0; row < rows; row++) {\n            if (planar == 1) {\n                // contiguous picture\n                if (!tiled) {\n                    if (TIFFReadScanline(tif, tiffline, row, 0) < 0) {\n                        err_printf(\"Bad data read on line %d (%s).\\n\",\n                            row, tiffname);\n                        png_destroy_write_struct(&png_ptr, &info_ptr);\n                        TIFFClose(tif);\n                        free(tiffline);\n                        return (false);\n                    }\n                }\n                else {\n                    // tiled\n                    int col, ok=1, r;\n                    int tileno;\n                    // Read in one row of tiles and hand out the data\n                    // one scanline at a time so the code below\n                    // doesn't need to change.\n\n                    // Is it time for a new strip?\n                    if ((row % tile_height) == 0) {\n                        for (col = 0; ok && col < num_tilesX; col += 1 ) {\n                            tileno = col+(row/tile_height)*num_tilesX;\n                            // Read the tile into an RGB array.\n                            if (!TIFFReadEncodedTile(tif, tileno, tifftile,\n                                    tilesz)) {\n                                ok = 0;\n                                break;\n                            }\n\n                            // Copy this tile into the row buffer.\n                            for (r = 0; r < (int) tile_height; r++) {\n                                void *dest = tiffstrip + (r * tile_width *\n                                    num_tilesX * spp) +\n                                    (col * tile_width * spp);\n                                void *src  = tifftile + (r * tile_width * spp);\n                                memcpy(dest, src, (tile_width * spp));\n                            }\n                        }\n                        tiffline = tiffstrip; // Set tileline to top of strip.\n                    }\n                    else {\n                        tiffline = tiffstrip + ((row % tile_height) *\n                            ((tile_width * num_tilesX) * spp));\n                    }\n                }\n            }\n            else {\n                // Separated planes, then combine more strips into one line.\n                unsigned short s;\n\n                // XXX:  this assumes strips; are separated-plane\n                // tiles possible?\n\n                unsigned char *p_line = tiffline;\n                for (int n = 0; n < (cols/8 * bps*spp); n++)\n                    *p_line++ = '\\0';\n\n                for (s = 0; s < spp; s++) {\n                    unsigned char *p_strip = tiffstrip;\n                    int getbitsleft = 8;\n                    p_line = tiffline;\n                    int putbitsleft = 8;\n\n                    if (TIFFReadScanline(tif, tiffstrip, row, s) < 0) {\n                        err_printf(\"Bad data read on line %d (%s).\\n\",\n                            row, tiffname);\n                        png_destroy_write_struct(&png_ptr, &info_ptr);\n                        TIFFClose(tif);\n                        delete [] tiffline;\n                        delete [] tiffstrip;\n                        return (false);\n                    }\n\n                    p_strip = (unsigned char *)tiffstrip;\n                    unsigned char sample = '\\0';\n                    for (int i = 0 ; i < s ; i++)\n                        PUT_LINE_SAMPLE\n                    for (int n = 0; n < cols; n++) {\n                        GET_STRIP_SAMPLE\n                        PUT_LINE_SAMPLE\n                        sample = '\\0';\n                        for (int i = 0 ; i < (spp-1) ; i++)\n                            PUT_LINE_SAMPLE\n                    }\n                }\n            }\n\n            unsigned char *p_line = tiffline;\n            int bitsleft = 8;\n            png_byte *p_png = pngline;\n\n            // Convert from tiff-line to png-line.\n\n            switch (tiff_color_type) {\n            case PNG_COLOR_TYPE_GRAY:       // we know spp == 1\n                for (int col = cols; col > 0; --col) {\n                    switch (bps) {\n                    case 16:\n#ifdef INVERT_MINISWHITE\n                        if (photometric == PHOTOMETRIC_MINISWHITE) {\n                            unsigned char sample;\n                            int sample16;\n                            if (bigendian) {\n                                // same as PNG order\n                                GET_LINE_SAMPLE\n                                sample16 = sample;\n                                sample16 <<= 8;\n                                GET_LINE_SAMPLE\n                                sample16 |= sample;\n                            }\n                            else {\n                                // reverse of PNG\n                                GET_LINE_SAMPLE\n                                sample16 = sample;\n                                GET_LINE_SAMPLE\n                                sample16 |= (((int)sample) << 8);\n                            }\n                            sample16 = maxval - sample16;\n                            *p_png++ = (unsigned char)((sample16 >> 8) & 0xff);\n                            *p_png++ = (unsigned char)(sample16 & 0xff);\n                        }\n                        else // not PHOTOMETRIC_MINISWHITE\n#endif\n                        {\n                            unsigned char sample;\n                            if (bigendian) {\n                                GET_LINE_SAMPLE\n                                *p_png++ = sample;\n                                GET_LINE_SAMPLE\n                                *p_png++ = sample;\n                            }\n                            else {\n                                GET_LINE_SAMPLE\n                                p_png[1] = sample;\n                                GET_LINE_SAMPLE\n                                *p_png = sample;\n                                p_png += 2;\n                            }\n                        }\n                        break;\n\n                    case 8:\n                    case 4:\n                    case 2:\n                    case 1:\n                        {\n                            unsigned char sample;\n                            GET_LINE_SAMPLE\n#ifdef INVERT_MINISWHITE\n                            if (photometric == PHOTOMETRIC_MINISWHITE)\n                                sample = maxval - sample;\n#endif\n                            *p_png++ = sample;\n                        }\n                        break;\n\n                    }\n                }\n                break;\n\n            case PNG_COLOR_TYPE_GRAY_ALPHA:\n                for (int col = 0; col < cols; col++) {\n                    for (int i = 0 ; i < spp ; i++) {\n                        switch (bps) {\n                        case 16:\n#ifdef INVERT_MINISWHITE\n                            if (photometric == PHOTOMETRIC_MINISWHITE &&\n                                    i == 0) {\n                                unsigned char sample;\n                                int sample16;\n                                if (bigendian) {\n                                    GET_LINE_SAMPLE\n                                    sample16 = (sample << 8);\n                                    GET_LINE_SAMPLE\n                                    sample16 |= sample;\n                                }\n                                else {\n                                    GET_LINE_SAMPLE\n                                    sample16 = sample;\n                                    GET_LINE_SAMPLE\n                                    sample16 |= (((int)sample) << 8);\n                                }\n                                sample16 = maxval - sample16;\n                                *p_png++ = (unsigned char)(\n                                    (sample16 >> 8) & 0xff);\n                                *p_png++ = (unsigned char)(sample16 & 0xff);\n                            }\n                            else\n#endif\n                            {\n                                unsigned char sample;\n                                if (bigendian) {\n                                    GET_LINE_SAMPLE\n                                    *p_png++ = sample;\n                                    GET_LINE_SAMPLE\n                                    *p_png++ = sample;\n                                }\n                                else {\n                                    GET_LINE_SAMPLE\n                                    p_png[1] = sample;\n                                    GET_LINE_SAMPLE\n                                    *p_png = sample;\n                                    p_png += 2;\n                                }\n                            }\n                            break;\n\n                        case 8:\n                            {\n                                unsigned char sample;\n                                GET_LINE_SAMPLE\n#ifdef INVERT_MINISWHITE\n                                if (photometric == PHOTOMETRIC_MINISWHITE &&\n                                        i == 0)\n                                    sample = maxval - sample;\n#endif\n                                *p_png++ = sample;\n                            }\n                            break;\n\n                        case 4:\n                            {\n                                unsigned char sample;\n                                GET_LINE_SAMPLE\n#ifdef INVERT_MINISWHITE\n                                if (photometric == PHOTOMETRIC_MINISWHITE &&\n                                        i == 0)\n                                    sample = maxval - sample;\n#endif\n                                *p_png++ = sample * 17;   /* was 16 */\n                            }\n                            break;\n\n                        case 2:\n                            {\n                                unsigned char sample;\n                                GET_LINE_SAMPLE\n#ifdef INVERT_MINISWHITE\n                                if (photometric == PHOTOMETRIC_MINISWHITE &&\n                                        i == 0)\n                                    sample = maxval - sample;\n#endif\n                                *p_png++ = sample * 85;   /* was 64 */\n                            }\n                            break;\n\n                        case 1:\n                            {\n                                unsigned char sample;\n                                GET_LINE_SAMPLE\n#ifdef INVERT_MINISWHITE\n                                if (photometric == PHOTOMETRIC_MINISWHITE &&\n                                        i == 0)\n                                    sample = maxval - sample;\n#endif\n                                *p_png++ = sample * 255;  /* was 128...oops */\n                            }\n                            break;\n\n                        }\n                    }\n                }\n                break;\n\n            case PNG_COLOR_TYPE_RGB:\n            case PNG_COLOR_TYPE_RGB_ALPHA:\n                for (int col = 0; col < cols; col++) {\n                    // Process for red, green and blue (and when\n                    // applicable alpha).\n\n                    for (int i = 0 ; i < spp ; i++) {\n                        switch (bps) {\n                        case 16:\n                            // XXX:  do we need INVERT_MINISWHITE\n                            // support here, too, or is that only for\n                            // grayscale?\n\n                            unsigned char sample;\n                            if (bigendian) {\n                                GET_LINE_SAMPLE\n                                *p_png++ = sample;\n                                GET_LINE_SAMPLE\n                                *p_png++ = sample;\n                            }\n                            else {\n                                GET_LINE_SAMPLE\n                                p_png[1] = sample;\n                                GET_LINE_SAMPLE\n                                *p_png = sample;\n                                p_png += 2;\n                            }\n                            break;\n\n                        case 8:\n                            GET_LINE_SAMPLE\n                            *p_png++ = sample;\n                            break;\n\n                        case 4:\n                            GET_LINE_SAMPLE\n                            *p_png++ = sample * 17;\n                            break;\n\n                        case 2:\n                            GET_LINE_SAMPLE\n                            *p_png++ = sample * 85;\n                            break;\n\n                        case 1:\n                            GET_LINE_SAMPLE\n                            *p_png++ = sample * 255;\n                           break;\n\n                        }\n                    }\n                }\n                break;\n  \n            case PNG_COLOR_TYPE_PALETTE:\n                for (int col = 0; col < cols; col++) {\n                    unsigned char sample;\n                    GET_LINE_SAMPLE\n                    *p_png++ = sample;\n                }\n                break;\n  \n            default:\n                err_printf(\"Unknown photometric (%d) (%s).\\n\",\n                    photometric, tiffname);\n                png_destroy_write_struct(&png_ptr, &info_ptr);\n                TIFFClose(tif);\n                delete [] tiffline;\n                if (tiled && planar == 1)\n                    delete [] tifftile;\n                else if (planar != 1)\n                    delete [] tiffstrip;\n                return (false);\n\n            }\n            png_write_row(png_ptr, pngline);\n        }\n    }\n\n    TIFFClose(tif);\n\n    png_write_end(png_ptr, info_ptr);\n\n    png_destroy_write_struct(&png_ptr, &info_ptr);\n\n    free(tiffline);\n    if (tiled && planar == 1)\n        delete [] tifftile;\n    else if (planar != 1)\n        delete [] tiffstrip;\n    return (true);\n}",
    "bool wxTIFFHandler::SaveFile( wxImage *image, wxOutputStream& stream, bool verbose )\n{\n    TIFF *tif = TIFFwxOpen( stream, \"image\", \"w\" );\n\n    if (!tif)\n    {\n        if (verbose)\n        {\n            wxLogError( _(\"TIFF: Error saving image.\") );\n        }\n\n        return false;\n    }\n\n    const int imageWidth = image->GetWidth();\n    TIFFSetField(tif, TIFFTAG_IMAGEWIDTH,  (wxUint32) imageWidth);\n    TIFFSetField(tif, TIFFTAG_IMAGELENGTH, (wxUint32)image->GetHeight());\n    TIFFSetField(tif, TIFFTAG_ORIENTATION, (wxUint16)ORIENTATION_TOPLEFT);\n    TIFFSetField(tif, TIFFTAG_PLANARCONFIG, (wxUint16)PLANARCONFIG_CONTIG);\n\n    // save the image resolution if we have it\n    int xres, yres;\n    const wxImageResolution res = GetResolutionFromOptions(*image, &xres, &yres);\n    wxUint16 tiffRes;\n    switch ( res )\n    {\n        default:\n            wxFAIL_MSG( wxT(\"unknown image resolution units\") );\n            wxFALLTHROUGH;\n\n        case wxIMAGE_RESOLUTION_NONE:\n            tiffRes = RESUNIT_NONE;\n            break;\n\n        case wxIMAGE_RESOLUTION_INCHES:\n            tiffRes = RESUNIT_INCH;\n            break;\n\n        case wxIMAGE_RESOLUTION_CM:\n            tiffRes = RESUNIT_CENTIMETER;\n            break;\n    }\n\n    if ( tiffRes != RESUNIT_NONE )\n    {\n        TIFFSetField(tif, TIFFTAG_RESOLUTIONUNIT, tiffRes);\n        TIFFSetField(tif, TIFFTAG_XRESOLUTION, static_cast<double>(xres));\n        TIFFSetField(tif, TIFFTAG_YRESOLUTION, static_cast<double>(yres));\n    }\n\n\n    int spp = image->GetOptionInt(wxIMAGE_OPTION_TIFF_SAMPLESPERPIXEL);\n    if ( !spp )\n        spp = 3;\n\n    int bps = image->GetOptionInt(wxIMAGE_OPTION_TIFF_BITSPERSAMPLE);\n    if ( !bps )\n    {\n        bps = 8;\n    }\n    else if (bps == 1)\n    {\n        // One bit per sample combined with 3 samples per pixel is\n        // not allowed and crashes libtiff.\n        spp = 1;\n    }\n\n    int photometric = PHOTOMETRIC_RGB;\n\n    if ( image->HasOption(wxIMAGE_OPTION_TIFF_PHOTOMETRIC) )\n    {\n        photometric = image->GetOptionInt(wxIMAGE_OPTION_TIFF_PHOTOMETRIC);\n        if (photometric == PHOTOMETRIC_MINISWHITE\n            || photometric == PHOTOMETRIC_MINISBLACK)\n        {\n            // either b/w or greyscale\n            spp = 1;\n        }\n    }\n    else if (spp <= 2)\n    {\n        photometric = PHOTOMETRIC_MINISWHITE;\n    }\n\n    const bool hasAlpha = image->HasAlpha();\n\n    int compression = image->GetOptionInt(wxIMAGE_OPTION_TIFF_COMPRESSION);\n    if ( !compression || (compression == COMPRESSION_JPEG && hasAlpha) )\n    {\n        // We can't use COMPRESSION_LZW because current version of libtiff\n        // doesn't implement it (\"no longer implemented due to Unisys patent\n        // enforcement\") and other compression methods are lossy so we\n        // shouldn't use them by default -- and the only remaining one is none.\n        // Also JPEG compression for alpha images is not a good idea (viewers\n        // not opening the image properly).\n        compression = COMPRESSION_NONE;\n    }\n\n    if\n    (\n        (photometric == PHOTOMETRIC_RGB && spp == 4)\n        || (photometric <= PHOTOMETRIC_MINISBLACK && spp == 2)\n    )\n    {\n        // Compensate for user passing a SamplesPerPixel that includes\n        // the alpha channel.\n        spp--;\n    }\n\n\n    int extraSamples = hasAlpha ? 1 : 0;\n\n    TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, (wxUint16)(spp + extraSamples));\n    TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, (wxUint16)bps);\n    TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, (wxUint16)photometric);\n    TIFFSetField(tif, TIFFTAG_COMPRESSION, (wxUint16)compression);\n\n    if (extraSamples)\n    {\n        wxUint16 extra[] = { EXTRASAMPLE_UNSPECIFIED };\n        TIFFSetField(tif, TIFFTAG_EXTRASAMPLES, (wxUint16) 1, &extra);\n    }\n\n    // scanlinesize is determined by spp+extraSamples and bps\n    const tsize_t linebytes =\n        (tsize_t)((imageWidth * (spp + extraSamples) * bps + 7) / 8);\n\n    unsigned char* buf = nullptr;\n\n    // Ensure that everything is cleaned up on scope exit.\n    class CleanUp\n    {\n    public:\n        CleanUp(TIFF* tif, unsigned char* buf)\n            : m_tif(tif), m_buf(buf)\n        {\n        }\n\n        ~CleanUp()\n        {\n            TIFFClose(m_tif);\n\n            if (m_buf)\n                _TIFFfree(m_buf);\n        }\n\n        CleanUp(const CleanUp&) = delete;\n        CleanUp& operator=(const CleanUp&) = delete;\n\n    private:\n        TIFF* const m_tif;\n        unsigned char* const m_buf;\n    } cleanUp(tif, buf);\n\n    const bool isColouredImage = (spp > 1)\n        && (photometric != PHOTOMETRIC_MINISWHITE)\n        && (photometric != PHOTOMETRIC_MINISBLACK);\n\n\n    if (TIFFScanlineSize(tif) > linebytes || !isColouredImage || hasAlpha)\n    {\n        buf = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(tif));\n        if (!buf)\n        {\n            if (verbose)\n            {\n                wxLogError( _(\"TIFF: Couldn't allocate memory.\") );\n            }\n\n            return false;\n        }\n    }\n\n    TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP,TIFFDefaultStripSize(tif, (wxUint32) -1));\n\n    const int bitsPerPixel = (spp + extraSamples) * bps;\n    const int bytesPerPixel = (bitsPerPixel + 7) / 8;\n    const int pixelsPerByte = 8 / bitsPerPixel;\n    int remainingPixelCount = 0;\n\n    if (pixelsPerByte)\n    {\n        // How many pixels to write in the last byte column?\n        remainingPixelCount = imageWidth % pixelsPerByte;\n        if (!remainingPixelCount) remainingPixelCount = pixelsPerByte;\n    }\n\n    const bool minIsWhite = (photometric == PHOTOMETRIC_MINISWHITE);\n    unsigned char *ptr = image->GetData();\n    for ( int row = 0; row < image->GetHeight(); row++ )\n    {\n        if ( buf )\n        {\n            if (isColouredImage)\n            {\n                // colour image\n                if (hasAlpha)\n                {\n                    for ( int column = 0; column < imageWidth; column++ )\n                    {\n                        buf[column*4    ] = ptr[column*3    ];\n                        buf[column*4 + 1] = ptr[column*3 + 1];\n                        buf[column*4 + 2] = ptr[column*3 + 2];\n                        buf[column*4 + 3] = image->GetAlpha(column, row);\n                    }\n                }\n                else\n                {\n                    memcpy(buf, ptr, imageWidth * 3);\n                }\n            }\n            else if (spp * bps == 8) // greyscale image\n            {\n                for ( int column = 0; column < imageWidth; column++ )\n                {\n                    wxUint8 value = ptr[column*3 + 1];\n                    if (minIsWhite)\n                    {\n                        value = 255 - value;\n                    }\n\n                    buf[column * bytesPerPixel] = value;\n\n                    if (hasAlpha)\n                    {\n                        value = image->GetAlpha(column, row);\n                        buf[column*bytesPerPixel+1] = minIsWhite ? 255 - value\n                                                                 : value;\n                    }\n                }\n            }\n            else // black and white image\n            {\n                for ( int column = 0; column < linebytes; column++ )\n                {\n                    wxUint8 reverse = 0;\n                    int pixelsPerByteCount = (column + 1 != linebytes)\n                        ? pixelsPerByte\n                        : remainingPixelCount;\n                    for ( int bp = 0; bp < pixelsPerByteCount; bp++ )\n                    {\n                        if ( (ptr[column * 3 * pixelsPerByte + bp*3 + 1] <=127)\n                            == minIsWhite )\n                        {\n                            // check only green as this is sufficient\n                            reverse |= (wxUint8) (128 >> (bp * bitsPerPixel));\n                        }\n\n                        if (hasAlpha\n                            && (image->GetAlpha(column * pixelsPerByte + bp,\n                                    row) <= 127) == minIsWhite)\n                        {\n                            reverse |= (wxUint8) (64 >> (bp * bitsPerPixel));\n                        }\n                    }\n\n                    buf[column] = reverse;\n                }\n            }\n        }\n\n        if ( TIFFWriteScanline(tif, buf ? buf : ptr, (wxUint32)row, 0) < 0 )\n        {\n            if (verbose)\n            {\n                wxLogError( _(\"TIFF: Error writing image.\") );\n            }\n\n            return false;\n        }\n\n        ptr += imageWidth * 3;\n    }\n\n    if (!TIFFFlush(tif))\n    {\n        if (verbose)\n        {\n            wxLogError( _(\"TIFF: Error flushing data.\") );\n        }\n\n        return false;\n    }\n\n    return true;\n}",
    "~CleanUp()\n        {\n            TIFFClose(m_tif);\n\n            if (m_buf)\n                _TIFFfree(m_buf);\n        }",
    "bool ZLWin32ImageManager::tiffConvert(const std::string &stringData, ZLWin32ImageData &data, bool &result) const {\n\tresult = false;\n\tTIFFReader reader(stringData);\n\tTIFF *tiff = TIFFClientOpen(\"ZLWin32ImageManager\", \"rM\", &reader, TIFFReader::read, TIFFReader::write, TIFFReader::seek, TIFFReader::close, TIFFReader::size, TIFFReader::map, TIFFReader::unmap);\n\tif (tiff == 0) {\n\t\treturn false;\n\t}\n\n\tint width, height;\n\tif (!TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, &width) ||\n\t\t\t!TIFFGetField(tiff, TIFFTAG_IMAGELENGTH, &height)) {\n\t\tTIFFClose(tiff);\n\t\treturn false;\n\t}\n\n\tdata.init(width, height, true, 0);\n\n\tresult = TIFFReadRGBAImage(tiff, width, height, (uint32*)data.myArray, 1) != 0;\n\tdata.bgr2rgb();\n\n\tTIFFClose(tiff);\n\treturn true;\n}",
    "void PdfImage::LoadFromTiffHandle(void* hInHandle) {\n    \n    TIFF* hInTiffHandle = (TIFF*)hInHandle;\n    \n    int32 row, width, height;\n    uint16 samplesPerPixel, bitsPerSample;\n    uint16* sampleInfo;\n    uint16 extraSamples;\n    uint16 planarConfig, photoMetric, orientation;\n    int32 resolutionUnit;\n    \n    TIFFGetField(hInTiffHandle,\t   TIFFTAG_IMAGEWIDTH,\t\t&width);\n    TIFFGetField(hInTiffHandle,\t   TIFFTAG_IMAGELENGTH,\t\t&height);\n    TIFFGetFieldDefaulted(hInTiffHandle, TIFFTAG_BITSPERSAMPLE,\t&bitsPerSample);\n    TIFFGetFieldDefaulted(hInTiffHandle, TIFFTAG_SAMPLESPERPIXEL,     &samplesPerPixel);\n    TIFFGetFieldDefaulted(hInTiffHandle, TIFFTAG_PLANARCONFIG,\t&planarConfig);\n    TIFFGetFieldDefaulted(hInTiffHandle, TIFFTAG_PHOTOMETRIC,\t\t&photoMetric);\n    TIFFGetFieldDefaulted(hInTiffHandle, TIFFTAG_EXTRASAMPLES,\t&extraSamples, &sampleInfo);\n    TIFFGetFieldDefaulted(hInTiffHandle, TIFFTAG_ORIENTATION,\t\t&orientation);\n    \n    resolutionUnit = 0;\n    float resX;\n    float resY;\n    TIFFGetFieldDefaulted(hInTiffHandle, TIFFTAG_XRESOLUTION,\t\t&resX);\n    TIFFGetFieldDefaulted(hInTiffHandle, TIFFTAG_YRESOLUTION,\t\t&resY);\n    TIFFGetFieldDefaulted(hInTiffHandle, TIFFTAG_RESOLUTIONUNIT,\t&resolutionUnit);\n    \n    int colorChannels = samplesPerPixel - extraSamples;\n    \n    int bitsPixel = bitsPerSample * samplesPerPixel;\n    \n    // TODO: implement special cases\n    if( TIFFIsTiled(hInTiffHandle) )\n    {\n        TIFFClose(hInTiffHandle);\n        PODOFO_RAISE_ERROR( ePdfError_UnsupportedImageFormat );\n    }\n    \n    if ( planarConfig != PLANARCONFIG_CONTIG && colorChannels != 1 )\n    {\n        TIFFClose(hInTiffHandle);\n        PODOFO_RAISE_ERROR( ePdfError_UnsupportedImageFormat );\n    }\n    \n    if ( orientation != ORIENTATION_TOPLEFT )\n    {\n        TIFFClose(hInTiffHandle);\n        PODOFO_RAISE_ERROR( ePdfError_UnsupportedImageFormat );\n    }\n    \n    switch(photoMetric)\n    {\n        case PHOTOMETRIC_MINISBLACK:\n        {\n            if( bitsPixel == 1 )\n            {\n                PdfArray decode;\n                decode.insert( decode.end(), PdfVariant( static_cast<pdf_int64>(0) ) );\n                decode.insert( decode.end(), PdfVariant( static_cast<pdf_int64>(1) ) );\n                this->GetObject()->GetDictionary().AddKey( PdfName(\"Decode\"), decode );\n                this->GetObject()->GetDictionary().AddKey( PdfName(\"ImageMask\"), PdfVariant( true ) );\n                this->GetObject()->GetDictionary().RemoveKey( PdfName(\"ColorSpace\") );\n            }\n            else if ( bitsPixel == 8  ||  bitsPixel == 16)\n                SetImageColorSpace(ePdfColorSpace_DeviceGray);\n            else\n            {\n                TIFFClose(hInTiffHandle);\n                PODOFO_RAISE_ERROR( ePdfError_UnsupportedImageFormat );\n            }\n        }\n            break;\n            \n        case PHOTOMETRIC_MINISWHITE:\n        {\n            if( bitsPixel == 1 )\n            {\n                PdfArray decode;\n                decode.insert( decode.end(), PdfVariant( static_cast<pdf_int64>(1) ) );\n                decode.insert( decode.end(), PdfVariant( static_cast<pdf_int64>(0) ) );\n                this->GetObject()->GetDictionary().AddKey( PdfName(\"Decode\"), decode );\n                this->GetObject()->GetDictionary().AddKey( PdfName(\"ImageMask\"), PdfVariant( true ) );\n                this->GetObject()->GetDictionary().RemoveKey( PdfName(\"ColorSpace\") );\n            }\n            else if ( bitsPixel == 8  ||  bitsPixel == 16)\n                SetImageColorSpace(ePdfColorSpace_DeviceGray);\n            else\n            {\n                TIFFClose(hInTiffHandle);\n                PODOFO_RAISE_ERROR( ePdfError_UnsupportedImageFormat );\n            }\n        }\n            break;\n            \n        case PHOTOMETRIC_RGB:\n            if ( bitsPixel != 24 )\n            {\n                TIFFClose(hInTiffHandle);\n                PODOFO_RAISE_ERROR( ePdfError_UnsupportedImageFormat );\n            }\n            SetImageColorSpace(ePdfColorSpace_DeviceRGB);\n            break;\n            \n        case PHOTOMETRIC_SEPARATED:\n            if( bitsPixel != 32)\n            {\n                TIFFClose(hInTiffHandle);\n                PODOFO_RAISE_ERROR( ePdfError_UnsupportedImageFormat );\n            }\n            SetImageColorSpace(ePdfColorSpace_DeviceCMYK);\n            break;\n            \n        case PHOTOMETRIC_PALETTE:\n        {\n            int numColors = (1 << bitsPixel);\n            \n            PdfArray decode;\n            decode.insert( decode.end(), PdfVariant( static_cast<pdf_int64>(0) ) );\n            decode.insert( decode.end(), PdfVariant( static_cast<pdf_int64>(numColors-1) ) );\n            this->GetObject()->GetDictionary().AddKey( PdfName(\"Decode\"), decode );\n            \n            uint16 * rgbRed;\n            uint16 * rgbGreen;\n            uint16 * rgbBlue;\n            TIFFGetField(hInTiffHandle, TIFFTAG_COLORMAP, &rgbRed, &rgbGreen, &rgbBlue);\n            \n            char *datap = new char[numColors*3];\n            \n            for ( int clr = 0; clr < numColors; clr++ )\n            {\n                datap[3*clr+0] = rgbRed[clr]/257;\n                datap[3*clr+1] = rgbGreen[clr]/257;\n                datap[3*clr+2] = rgbBlue[clr]/257;\n            }\n            PdfMemoryInputStream stream( datap, numColors*3 );\n            \n            // Create a colorspace object\n            PdfObject* pIdxObject = this->GetObject()->GetOwner()->CreateObject();\n            pIdxObject->GetStream()->Set( &stream );\n            \n            // Add the colorspace to our image\n            PdfArray array;\n            array.push_back( PdfName(\"Indexed\") );\n            array.push_back( PdfName(\"DeviceRGB\") );\n            array.push_back( static_cast<pdf_int64>(numColors-1) );\n            array.push_back( pIdxObject->Reference() );\n            this->GetObject()->GetDictionary().AddKey( PdfName(\"ColorSpace\"), array );\n            \n            delete[] datap;\n        }\n            break;\n            \n        default:\n            TIFFClose(hInTiffHandle);\n            PODOFO_RAISE_ERROR( ePdfError_UnsupportedImageFormat );\n            break;\n    }\n    \n    int32 scanlineSize = TIFFScanlineSize(hInTiffHandle);\n    long bufferSize = scanlineSize * height;\n    char *buffer = new char[bufferSize];\n    if( !buffer )\n    {\n        TIFFClose(hInTiffHandle);\n        PODOFO_RAISE_ERROR( ePdfError_OutOfMemory );\n    }\n    \n    for(row = 0; row < height; row++)\n    {\n        if(TIFFReadScanline(hInTiffHandle,\n                            &buffer[row * scanlineSize],\n                            row) == (-1))\n        {\n            TIFFClose(hInTiffHandle);\n            PODOFO_RAISE_ERROR( ePdfError_UnsupportedImageFormat );\n        }\n    }\n    \n    PdfMemoryInputStream stream(buffer, bufferSize);\n    \n    SetImageData(static_cast<unsigned int>(width),\n                 static_cast<unsigned int>(height),\n                 static_cast<unsigned int>(bitsPerSample),\n                 &stream);\n    \n    delete[] buffer;\n    \n    TIFFClose(hInTiffHandle);\n}",
    "float * read_tiff_image(const char* inputFile, uint32 *widthOut, uint32 *heightOut, uint32 *nChannels)\n{\n\n\tTIFF *tifFile=TIFFOpen(inputFile, \"r\");\n\t//get height and width of image\n\tTIFFGetField(tifFile, TIFFTAG_IMAGEWIDTH, widthOut);           // uint32 width;\n\tTIFFGetField(tifFile, TIFFTAG_IMAGELENGTH, heightOut);        // uint32 height;\n\tTIFFGetField(tifFile, TIFFTAG_IMAGEDEPTH, nChannels);\n\t*nChannels = (int)fmax((float)*nChannels,(float)1.0);\n\t*nChannels = (int)fmin((float)*nChannels,(float)MAX_CHANNELS);\n\n\tstd::cout << \"Image size : \" << *widthOut << \" x \" <<\n\t\t\t*heightOut << \" x \" << *nChannels << std::endl;\n\tuint32 width = *widthOut;\n\tuint32 height = *heightOut;\n\n\t//reserve temporary space for the image\n\tuint32 npixels=(uint32)(width*height);\n\tuint32* raster=(uint32*) _TIFFmalloc(npixels *sizeof(uint32));\n\n\tfloat *outputImg = new float[npixels*(*nChannels)];\n\t//read the image\n\tif (raster != NULL)\n\t{\n\t\tif (TIFFReadRGBAImage(tifFile, width, height, raster, 0) != 0)\n\t\t{\n\t\t\t//copy image information into the matrix\n\t\t\tfor (uint32 i=0; i<height; i++)\n\t\t\t\tfor (uint32 j=0; j<width; j++)\n\t\t\t\t\tfor (uint32 c=0; c<(*nChannels); c++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint iRaster = height-i-1;\t//note, the libtiff stores the image from the bottom left as the origin\n\t\t\t\t\t\tswitch(c)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\toutputImg[j + i*width] = (float)TIFFGetR(raster[ iRaster*width + j]);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\toutputImg[j + i*width + width*height] =\n\t\t\t\t\t\t\t\t(float)TIFFGetG(raster[ iRaster*width + j]);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\n\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\toutputImg[j + i*width + 2*width*height] =\n\t\t\t\t\t\t\t\t(float)TIFFGetB(raster[ iRaster*width + j]);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n  \t\t\t\t\t\t\t\tstd::cout << \"Error in reading the tiff file, too many channels.\" << std::endl;\n  \t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstd::cout << \"Error reading the image file with TIFFReadRGBAImage\" << std::endl;\n\t\t}\n    }\n\telse\n\t{\n\t\tstd::cout << \"Error, could not read the input image.\" << std::endl;\n\t\tstd::cout << \"File name : \" << inputFile << std::endl;\n\t\tTIFFClose(tifFile);\n\t\treturn(NULL);\n\t}\n    _TIFFfree(raster);\n\n\t//close image\n\tTIFFClose(tifFile);\n\treturn(outputImg);\n}",
    "int write_tiff_image(float* inputImg, unsigned int n, unsigned int m,\n\tunsigned int nChannels, const char* outputFile)\n{\n\tuint32 width,height;\n\twidth = (uint32)n;\n\theight = (uint32)m;\n\n\t//parameters\n\tuint32 samplePerPixel = nChannels;\n\n\tTIFF *tifFile= TIFFOpen(outputFile, \"w\");\n\t//set parameters of image\n\tTIFFSetField (tifFile, TIFFTAG_IMAGEWIDTH, width);  // set the width of the image\n\tTIFFSetField(tifFile, TIFFTAG_IMAGELENGTH, height);    // set the height of the image\n\tTIFFSetField(tifFile, TIFFTAG_SAMPLESPERPIXEL, samplePerPixel);   // set number of channels per pixel\n\tTIFFSetField(tifFile, TIFFTAG_BITSPERSAMPLE, 8);\n\tTIFFSetField(tifFile, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);    // set the origin of the image.\n\t//   Some other essential fields to set that you do not have to understand for now.\n\tTIFFSetField(tifFile, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\tTIFFSetField(tifFile, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n\n\t//create a temporary buffer to write the image info to\n\ttsize_t lineBytes = (tsize_t) (samplePerPixel * width);  // length in memory of one row of pixel in the image.\n\tunsigned char *buf = NULL;        // buffer used to store the row of pixel information for writing to file\n\tunsigned char *bufChar;\n\t//    Allocating memory to store the pixels of current row\n\tif (TIFFScanlineSize(tifFile) == lineBytes)\n\t{\n\t\tbuf = (unsigned char *)_TIFFmalloc(lineBytes);\n\t\tbufChar = new unsigned char[lineBytes];\n\t}\n\telse\n\t{\n\t\tbuf = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(tifFile));\n\t\tbufChar = new unsigned char[TIFFScanlineSize(tifFile)];\n\t}\n\n\t//std::cout << \"line size : \" << TIFFScanlineSize(tifFile)<< std::endl;\n\t//std::cout << \"line bytes : \" << lineBytes << std::endl;\n\t//write the image\n\t // We set the strip size of the file to be size of one row of pixels\n\tTIFFSetField(tifFile, TIFFTAG_ROWSPERSTRIP, TIFFDefaultStripSize(tifFile, width*samplePerPixel));\n\t//std::cout << \"width*samplePerPixel : \" << width*samplePerPixel << std::endl;\n\n\t//Now writing image to the file one strip at a time\n\tfor (uint32 i = 0; i < height; i++)\n\t{\n\t\t//copy the image information into a temporary buffer\n\t\tfor (uint32 j=0; j<width; j++)\n\t\t{\t//the tiff stores the image info in the following order : RGB\n\t\t\tfor (uint32 c=0; c<nChannels; c++)\n\t\t\t\tbufChar[j*nChannels+c] = (unsigned char)(round( inputImg[j + i*width + c*width*height]) );\n\t\t}\n\t\tstd::memcpy(buf, bufChar, lineBytes);\t//copy information to special Tiff buffer\n\t\t//std::cout << \" \" << (*inputImg->get_ptr(i,0)) << std::endl;\n\t\tif (TIFFWriteScanline(tifFile, buf, i, 0) < 0)\n\t\t{\n\t\t\tstd::cout << \"Error in writing the image file.\" << std::endl;\n\t\t\treturn(-1);\n\t\t}\n\t}\n\n    if (buf)\n    \t_TIFFfree(buf);\n\tdelete bufChar;\n\n\t//close image\n\tTIFFClose(tifFile);\n\treturn(0);\n}",
    "static void DLL_CALLCONV\nClose(FreeImageIO *io, fi_handle handle, void *data) {\n\tif(data) {\n\t\tfi_TIFFIO *fio = (fi_TIFFIO*)data;\n\t\tTIFFClose(fio->tif);\n\t\tfree(fio);\n\t}\n}",
    "bool MainWindow::SaveTiffMulti(std::string filename)\n{\n    char *file = &filename[0u];\n    TIFF *out = TIFFOpen(file,\"w\") ;\n\n    if (out) {\n        int NPAGES = ui->listWidget_labels->count() +1; // number of page = nb labels + image\n\n        //// image\n        uint32 imagelength = image.rows;\n        uint32 imagewidth = image.cols;\n        uint8 * buf;\n        uint32 row, col;\n        uint16 nsamples = 3;\n\n        TIFFSetField(out, TIFFTAG_IMAGELENGTH, imagelength); // image length\n        TIFFSetField(out, TIFFTAG_IMAGEWIDTH, imagewidth); // image width\n        TIFFSetField(out, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG); // organized by RGB instead of channel\n        TIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, nsamples); // number of channels per pixel\n        TIFFSetField(out, TIFFTAG_COMPRESSION, COMPRESSION_LZW); // compression\n        TIFFSetField(out, TIFFTAG_BITSPERSAMPLE, 8) ; // size of the channels\n        TIFFSetField(out, TIFFTAG_ROWSPERSTRIP, TIFFDefaultStripSize(out, imagewidth*nsamples)); // strip size of the file to be size of one row of pixels\n        TIFFSetField(out, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT); // set the origin of the image\n        TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB); // RGB image\n        TIFFSetField(out, TIFFTAG_IMAGEDESCRIPTION, \"background\"); // label name\n        TIFFSetField(out, TIFFTAG_SOFTWARE, \"Superpixels Segmentation GUI with openCV by AbsurdePhoton www.absurdephoton.fr\"); // software used\n\n        /* We are writing single page of the multipage file */\n        TIFFSetField(out, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE); // new page\n        TIFFSetField(out, TIFFTAG_PAGENUMBER, 0, NPAGES); // page number\n\n        buf = new uint8 [imagewidth*nsamples] ;\n\n        for (row = 0; row < imagelength; row++) {\n            for(col=0; col < imagewidth; col++) {\n                //writing data - order = RGB\n                Vec3b c = image.at<Vec3b>(row, col);\n                buf[col*nsamples+0] = c[2];\n                buf[col*nsamples+1] = c[1];\n                buf[col*nsamples+2] = c[0];\n            }\n            if (TIFFWriteScanline(out, buf, row) != 1 ) {\n                return false;\n            }\n        }\n        TIFFWriteDirectory(out);\n        _TIFFfree(buf);\n\n        //// Layers\n        int page;\n        for (page = 0; page < (NPAGES - 1); page++){\n            QListWidgetItem *item = ui->listWidget_labels->item(page);\n            QColor c = item->background().color();\n            int nLabel = item->data(Qt::UserRole).toInt();\n            std::string name = item->text().toUtf8().constData();\n\n            uint32 imagelength = image.rows;\n            uint32 imagewidth = image.cols;\n            uint8 * buf;\n            uint32 row, col;\n            uint16 nsamples = 4;\n\n            TIFFSetField(out, TIFFTAG_IMAGELENGTH, imagelength); // image length\n            TIFFSetField(out, TIFFTAG_IMAGEWIDTH, imagewidth); // image width\n            TIFFSetField(out, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG); // organized by RGB instead of channel\n            TIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, nsamples); // number of channels per pixel\n            TIFFSetField(out, TIFFTAG_COMPRESSION, COMPRESSION_LZW); // compression\n            TIFFSetField(out, TIFFTAG_BITSPERSAMPLE, 8) ; // size of the channels\n            TIFFSetField(out, TIFFTAG_ROWSPERSTRIP, TIFFDefaultStripSize(out, imagewidth*nsamples)); // strip size of the file to be size of one row of pixels\n            TIFFSetField(out, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT); // set the origin of the image\n            TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB); // RGB image\n            TIFFSetField(out, TIFFTAG_EXTRASAMPLES, EXTRASAMPLE_ASSOCALPHA); // extra byte is alpha value\n            TIFFSetField(out, TIFFTAG_IMAGEDESCRIPTION, name); // label name\n            TIFFSetField(out, TIFFTAG_PAGENAME, name); // label name\n            TIFFSetField(out, TIFFTAG_SOFTWARE, \"Superpixels Segmentation GUI with openCV by AbsurdePhoton www.absurdephoton.fr\"); // software used\n\n            /* We are writing single page of the multipage file */\n            TIFFSetField(out, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE); // new page\n            TIFFSetField(out, TIFFTAG_PAGENUMBER, page + 1, NPAGES); // page number\n\n            buf = new uint8 [imagewidth*nsamples] ;\n\n            for (row = 0; row < imagelength; row++) {\n                for(col=0; col < imagewidth; col++) {\n                    //writing data - order = RGB\n                    int currentLabel = labels_mask.at<int>(row,col);\n                    if (currentLabel == nLabel) {\n                        buf[col*nsamples+0] = c.red();\n                        buf[col*nsamples+1] = c.green();\n                        buf[col*nsamples+2] = c.blue();\n                        buf[col*nsamples+3] = 255;\n                    }\n                    else {\n                        buf[col*nsamples+0] = 0;\n                        buf[col*nsamples+1] = 0;\n                        buf[col*nsamples+2] = 0;\n                        buf[col*nsamples+3] = 0;\n                    }\n                }\n                if (TIFFWriteScanline(out, buf, row) != 1 ) {\n                    return false;\n                }\n            }\n            TIFFWriteDirectory(out);\n            _TIFFfree(buf);\n        }\n        TIFFClose(out);\n    }\n    return true;\n}",
    "void WriteTiff(std::string filename) {\n    TIFF *output_image;\n    if( (output_image = TIFFOpen(filename.c_str(), \"w\")) == NULL ) {\n      std::cerr << \"Unable to write tif file: \" << filename << std::endl;\n    }\n\n    TIFFSetField(output_image, TIFFTAG_IMAGEWIDTH, m_height);\n    TIFFSetField(output_image, TIFFTAG_IMAGELENGTH, m_width);\n    TIFFSetField(output_image, TIFFTAG_BITSPERSAMPLE, 8);\n    TIFFSetField(output_image, TIFFTAG_SAMPLESPERPIXEL, 1);\n    TIFFSetField(output_image, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    \n    TIFFSetField(output_image, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);\n    TIFFSetField(output_image, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n                                   \n    // Write the information to the file\n    TIFFWriteEncodedStrip(output_image, 0, &m_image_data[0], m_width*m_height);\n    \n    // Close the file\n    TIFFClose(output_image);\n  }",
    "int writeTiff(char const *const filename, char const *const data,\n              const VkExtent2D size, const size_t nchannels)\n{\n    TIFF *tif = TIFFOpen(filename, \"w\");\n    if (tif == NULL)\n        return 1;\n\n    const size_t sample_bits = 8;\n\n    TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, size.width);\n    TIFFSetField(tif, TIFFTAG_IMAGELENGTH, size.height);\n    TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, nchannels);\n    TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, sample_bits);\n    TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_LZW);\n    TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    if (nchannels == 1)\n        TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n    else\n        TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n\n    for (size_t i = 0; i < size.height; i++) {\n        if (TIFFWriteScanline(tif, (void *) &data[i * size.width * nchannels], i, 0) < 0) {\n            TIFFClose(tif);\n            return 1;\n        }\n    }\n\n    TIFFClose(tif);\n    return 0;\n}",
    "int readTiffRGBA(char const *const filename, VkExtent2D *const size,\n                 VkSubresourceLayout *layout, uint8_t *const data)\n{\n    const uint32_t nchannels = 4;\n\n    TIFF *tif = TIFFOpen(filename, \"r\");\n    if (tif == NULL)\n        return 1;\n\n    if (data == NULL) {\n        TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &size->height);\n        TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &size->width);\n    } else {\n        if (layout == NULL || size == NULL)\n            goto cleanup;\n\n        char *const temp = (char *)malloc(nchannels * size->width * size->height);\n        if (!TIFFReadRGBAImage(tif, size->width, size->height, (uint32_t *) temp, 0))\n            goto cleanup;\n\n        for (size_t x = 0; x < size->width; x++)\n            for (size_t y = 0; y < size->height; y++)\n                for (size_t ch = 0; ch < nchannels; ch++) {\n                    data[ch + x * nchannels + y * layout->rowPitch] =\n                        temp[ch + x * nchannels + y * size->width * nchannels];\n                }\n        free(temp);\n    }\n\n    TIFFClose(tif);\n    return 0;\ncleanup:\n    TIFFClose(tif);\n    return 1;\n}",
    "void TPTImage::closeImage()\n{\n  if( tiff != NULL ){\n    TIFFClose( tiff );\n    tiff = NULL;\n  }\n}",
    "void Watermark::init()\n{\n  if( _image.length() > 0 ){\n\n    TIFF *tiff_watermark;\n    if( ( tiff_watermark = TIFFOpen( _image.c_str(), \"r\" ) ) ){\n\n      TIFFGetField( tiff_watermark, TIFFTAG_IMAGEWIDTH, &_width );\n      TIFFGetField( tiff_watermark, TIFFTAG_IMAGELENGTH, &_height );\n      TIFFGetField( tiff_watermark, TIFFTAG_BITSPERSAMPLE, &_bpc );\n\n      uint32_t *buffer = new uint32_t[_width*_height];\n\n      if( TIFFReadRGBAImageOriented( tiff_watermark, _width, _height, buffer, ORIENTATION_TOPLEFT ) == 0 ){\n\tdelete[] buffer;\n\tTIFFClose( tiff_watermark );\n\treturn;\n      }\n\n      // Set our number of channels to 3 as TIFFReadRGBAImage always outputs an 8bit colour image\n      _channels = 3;\n\n      // Set up the memory storage\n      _watermark = new unsigned char[_width*_height*_channels];\n      memset( _watermark, 0, (size_t) _width*_height*_channels );\n\n      // Load the data into our buffers\n      for( uint32_t i=0; i<_width*_height; i++ ){\n\tuint32_t rgba = buffer[i];\n\tunsigned char r,g,b;\n\tfloat a;\n\t// Extract the RGBA values\n\tr = (unsigned char) TIFFGetR(rgba);\n\tg = (unsigned char) TIFFGetG(rgba);\n\tb = (unsigned char) TIFFGetB(rgba);\n\ta = (float) TIFFGetA(rgba) / 255;\n\t_watermark[i*3] = r * _opacity * a;\n\t_watermark[i*3 + 1] = g * _opacity * a;\n\t_watermark[i*3 + 2] = b * _opacity * a;\n      }\n\n      delete[] buffer;\n      TIFFClose( tiff_watermark );\n      _isSet = true;\n    }\n\n  }\n\n}",
    "void TIFFCompressor::InitCompression( const RawTile &rawtile, unsigned int strip_height )\n{\n  // Initialize dest counters to zero\n  dest.current = 0;\n  dest.end = 0;\n\n  // Calculate buffer size necessary - add 4K for TIFF and metadata overhead\n  dest.capacity = (rawtile.width * strip_height * rawtile.channels * (rawtile.bpc/8)) + icc.size() + xmp.size() + 4096;\n\n  // Initialize our buffer\n  dest.buffer = (unsigned char*) malloc( dest.capacity );\n  if( !dest.buffer ) throw string( \"TIFFCompressor :: Unable to allocate memory for buffer\" );\n\n  // Set mode to write and disable memory mapping\n  tiff = TIFFClientOpen( \"_\", \"wm\", (thandle_t) &dest,\n\t\t\t _read,\n\t\t\t _write,\n\t\t\t _seek,\n\t\t\t _close,\n\t\t\t _size,\n\t\t\t _map,\n\t\t\t _unmap );\n\n  // Setup encoding configuration\n  configure( rawtile );\n\n  // Encode as strips - multiply default (which aims for 8kB strips) by 64 for 512kB strips\n  uint32_t strip_size = TIFFDefaultStripSize( tiff, 0 ) * 64;\n\n  // We encode strip-wise (a strip can consist of multiple lines)\n  TIFFSetField( tiff, TIFFTAG_ROWSPERSTRIP, strip_size );\n\n  // Calculate number strips and number of bytes per strip\n  tstrip_t nstrips = (tstrip_t)( (rawtile.height / strip_size) + ( (rawtile.height%strip_size==0) ? 0 : 1 ) );\n  uint32_t nbytes = rawtile.width * rawtile.channels * (rawtile.bpc/8) * strip_size;\n\n  int index = 0;\n  for( tstrip_t n=0; n<nstrips; n++ ){\n    // Write data as TIFF \"strips\"\n    if( n == nstrips-1 ) nbytes = rawtile.dataLength - index;\n    if( TIFFWriteEncodedStrip( tiff, n, (tdata_t) &((unsigned char*)rawtile.data)[index], nbytes ) != nbytes ){\n      TIFFClose( tiff );\n      throw string( \"TIFFCompressor :: TIFFWriteEncodedStrip() error\" );\n    }\n    index += nbytes;\n  }\n\n  // Finish encoding\n  TIFFClose( tiff );\n\n  height = rawtile.height;\n  current_chunk = 0;\n}",
    "unsigned int TIFFCompressor::Compress( RawTile& rawtile )\n{\n  // Estimate our size\n  dest.current = 0;\n  dest.end = 0;\n\n  // Calculate buffer size necessary - add 1K for TIFF and metadata overhead\n  dest.capacity = (rawtile.width * rawtile.height * rawtile.channels * (rawtile.bpc/8)) + icc.size() + xmp.size() + 1024;\n\n  // Initialize our tile buffer\n  dest.buffer = (unsigned char*) malloc( dest.capacity );\n  if( !dest.buffer ) throw string( \"TIFFCompressor :: Unable to allocate memory for buffer\" );\n\n  // Set mode to write and disable memory mapping\n  tiff = TIFFClientOpen( \"_\", \"wm\", (thandle_t) &dest,\n\t\t\t _read,\n\t\t\t _write,\n\t\t\t _seek,\n\t\t\t _close,\n\t\t\t _size,\n\t\t\t _map,\n\t\t\t _unmap );\n\n  // Setup encoding configuration\n  configure( rawtile );\n\n  // In compress() function we encode in a single pass (strip)\n  TIFFSetField( tiff, TIFFTAG_ROWSPERSTRIP, rawtile.height );\n\n  // Number of pixels to write\n  uint32_t len = rawtile.width * rawtile.height * rawtile.channels * (rawtile.bpc/8);\n\n  // Write entire tile as a single TIFF \"strip\"\n  if( TIFFWriteEncodedStrip( tiff, 0, (tdata_t) rawtile.data, len ) != len ){\n    TIFFClose( tiff );\n    throw string( \"TIFFCompressor :: TIFFWriteEncodedStrip() error\" );\n  }\n\n  // Finish up and close image\n  TIFFClose( tiff );\n\n  // Allocate the appropriate amount of memory if the encoded TIFF is larger than the raw image buffer\n  len = dest.end;\n  if( len > rawtile.capacity ){\n    if( rawtile.memoryManaged ) rawtile.deallocate( rawtile.data );\n    rawtile.allocate( len );\n  }\n\n  // Copy data back into tile\n  memcpy( rawtile.data, dest.buffer, len );\n\n  // Free our memory buffer\n  free( dest.buffer );\n\n  // Update data size and type\n  rawtile.dataLength = len;\n  rawtile.compressionType = ImageEncoding::TIFF;\n\n  return rawtile.dataLength;\n\n}",
    "void SlaOutputDev::drawImage(GfxState *state, Object *ref, Stream *str, int width, int height, GfxImageColorMap *colorMap, GBool interpolate, int *maskColors, GBool inlineImg)\r\n{\r\n\tImageStream * imgStr = new ImageStream(str, width, colorMap->getNumPixelComps(), colorMap->getBits());\r\n//\tqDebug() << \"Image Components\" << colorMap->getNumPixelComps() << \"Mask\" << maskColors;\r\n\timgStr->reset();\r\n\tQImage * image = 0;\r\n\tif (maskColors)\r\n\t{\r\n\t\timage = new QImage(width, height, QImage::Format_ARGB32);\r\n\t\tfor (int y = 0; y < height; y++)\r\n\t\t{\r\n\t\t\tQRgb *s = (QRgb*)(image->scanLine(y));\r\n\t\t\tGuchar *pix = imgStr->getLine();\r\n\t\t\tfor (int x = 0; x < width; x++)\r\n\t\t\t{\r\n\t\t\t\tGfxRGB rgb;\r\n\t\t\t\tcolorMap->getRGB(pix, &rgb);\r\n\t\t\t\tint Rc = qRound(colToDbl(rgb.r) * 255);\r\n\t\t\t\tint Gc = qRound(colToDbl(rgb.g) * 255);\r\n\t\t\t\tint Bc = qRound(colToDbl(rgb.b) * 255);\r\n\t\t\t\t*s = qRgba(Rc, Gc, Bc, 255);\r\n\t\t\t\tfor (int i = 0; i < colorMap->getNumPixelComps(); ++i)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (pix[i] < maskColors[2*i] * 255 || pix[i] > maskColors[2*i+1] * 255)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t*s = *s | 0xff000000;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\ts++;\r\n\t\t\t\tpix += colorMap->getNumPixelComps();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\timage = new QImage(width, height, QImage::Format_ARGB32);\r\n\t\tfor (int y = 0; y < height; y++)\r\n\t\t{\r\n\t\t\tQRgb *s = (QRgb*)(image->scanLine(y));\r\n\t\t\tGuchar *pix = imgStr->getLine();\r\n\t\t\tfor (int x = 0; x < width; x++)\r\n\t\t\t{\r\n\t\t\t\tif (colorMap->getNumPixelComps() == 4)\r\n\t\t\t\t{\r\n\t\t\t\t\tGfxCMYK cmyk;\r\n\t\t\t\t\tcolorMap->getCMYK(pix, &cmyk);\r\n\t\t\t\t\tint Cc = qRound(colToDbl(cmyk.c) * 255);\r\n\t\t\t\t\tint Mc = qRound(colToDbl(cmyk.m) * 255);\r\n\t\t\t\t\tint Yc = qRound(colToDbl(cmyk.y) * 255);\r\n\t\t\t\t\tint Kc = qRound(colToDbl(cmyk.k) * 255);\r\n\t\t\t\t\t*s = qRgba(Yc, Mc, Cc, Kc);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tGfxRGB rgb;\r\n\t\t\t\t\tcolorMap->getRGB(pix, &rgb);\r\n\t\t\t\t\tint Rc = qRound(colToDbl(rgb.r) * 255);\r\n\t\t\t\t\tint Gc = qRound(colToDbl(rgb.g) * 255);\r\n\t\t\t\t\tint Bc = qRound(colToDbl(rgb.b) * 255);\r\n\t\t\t\t\t*s = qRgba(Rc, Gc, Bc, 255);\r\n\t\t\t\t}\r\n\t\t\t\ts++;\r\n\t\t\t\tpix += colorMap->getNumPixelComps();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (image == NULL || image->isNull())\r\n\t{\r\n\t\tdelete imgStr;\r\n\t\tdelete image;\r\n\t\treturn;\r\n\t}\r\n\tdouble *ctm;\r\n\tctm = state->getCTM();\r\n\tdouble xCoor = m_doc->currentPage()->xOffset();\r\n\tdouble yCoor = m_doc->currentPage()->yOffset();\r\n\tQRectF crect = QRectF(0, 0, width, height);\r\n\tm_ctm = QTransform(ctm[0] / width, ctm[1] / width, -ctm[2] / height, -ctm[3] / height, ctm[2] + ctm[4], ctm[3] + ctm[5]);\r\n\tQLineF cline = QLineF(0, 0, width, 0);\r\n\tQLineF tline = m_ctm.map(cline);\r\n\tQRectF trect = m_ctm.mapRect(crect);\r\n\tdouble sx = m_ctm.m11();\r\n\tdouble sy = m_ctm.m22();\r\n\tQImage img = image->copy();\r\n\tQTransform mm = QTransform(ctm[0] / width, ctm[1] / width, -ctm[2] / height, -ctm[3] / height, 0, 0);\r\n\tif ((mm.type() == QTransform::TxShear) || (mm.type() == QTransform::TxRotate))\r\n\t{\r\n\t\tmm.reset();\r\n\t\tmm.rotate(-tline.angle());\r\n\t\timg = image->transformed(mm);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tif ((sx < 0) || (sy < 0))\r\n\t\t{\r\n\t\t\tif (sx < 0)\r\n\t\t\t\tmm.scale(-1, 1);\r\n\t\t\tif (sy < 0)\r\n\t\t\t\tmm.scale(1, -1);\r\n\t\t\timg = image->transformed(mm);\r\n\t\t}\r\n\t}\r\n\tint z = m_doc->itemAdd(PageItem::ImageFrame, PageItem::Rectangle, xCoor + trect.x(), yCoor + trect.y(), trect.width(), trect.height(), 0, CommonStrings::None, CommonStrings::None, true);\r\n\tPageItem* ite = m_doc->Items->at(z);\r\n\tite->ClipEdited = true;\r\n\tite->FrameType = 3;\r\n\tm_doc->setRedrawBounding(ite);\r\n\tite->Clip = FlattenPath(ite->PoLine, ite->Segments);\r\n\tite->setTextFlowMode(PageItem::TextFlowDisabled);\r\n\tite->setFillShade(100);\r\n\tite->setLineShade(100);\r\n\tite->setFillEvenOdd(false);\r\n\tite->setFillTransparency(1.0 - state->getFillOpacity());\r\n\tite->setFillBlendmode(getBlendMode(state));\r\n\tm_doc->AdjustItemSize(ite);\r\n\tif (colorMap->getNumPixelComps() == 4)\r\n\t{\r\n\t\tQTemporaryFile *tempFile = new QTemporaryFile(QDir::tempPath() + \"/scribus_temp_pdf_XXXXXX.tif\");\r\n\t\ttempFile->setAutoRemove(false);\r\n\t\tif (tempFile->open())\r\n\t\t{\r\n\t\t\tQString fileName = getLongPathName(tempFile->fileName());\r\n\t\t\tif (!fileName.isEmpty())\r\n\t\t\t{\r\n\t\t\t\ttempFile->close();\r\n\t\t\t\tite->isInlineImage = true;\r\n\t\t\t\tite->isTempFile = true;\r\n\t\t\t\tite->AspectRatio = false;\r\n\t\t\t\tite->ScaleType   = false;\r\n\t\t\t\tTIFF* tif = TIFFOpen(fileName.toLocal8Bit().data(), \"w\");\r\n\t\t\t\tif (tif)\r\n\t\t\t\t{\r\n\t\t\t\t\tTIFFSetField(tif, TIFFTAG_IMAGEWIDTH, img.width());\r\n\t\t\t\t\tTIFFSetField(tif, TIFFTAG_IMAGELENGTH, img.height());\r\n\t\t\t\t\tTIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8);\r\n\t\t\t\t\tTIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 4);\r\n\t\t\t\t\tTIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\r\n\t\t\t\t\tTIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_SEPARATED);\r\n\t\t\t\t\tTIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_LZW);\r\n\t\t\t\t\tfor (int y = 0; y < img.height(); ++y)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tTIFFWriteScanline(tif, img.scanLine(y), y);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tTIFFClose(tif);\r\n\t\t\t\t\tm_doc->loadPict(fileName, ite);\r\n\t\t\t\t}\r\n\t\t\t\tm_Elements->append(ite);\r\n\t\t\t\tif (m_groupStack.count() != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tm_groupStack.top().Items.append(ite);\r\n\t\t\t\t\tapplyMask(ite);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\tm_doc->Items->removeAll(ite);\r\n\t\t}\r\n\t\tdelete tempFile;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tQTemporaryFile *tempFile = new QTemporaryFile(QDir::tempPath() + \"/scribus_temp_pdf_XXXXXX.png\");\r\n\t\ttempFile->setAutoRemove(false);\r\n\t\tif (tempFile->open())\r\n\t\t{\r\n\t\t\tQString fileName = getLongPathName(tempFile->fileName());\r\n\t\t\tif (!fileName.isEmpty())\r\n\t\t\t{\r\n\t\t\t\ttempFile->close();\r\n\t\t\t\tite->isInlineImage = true;\r\n\t\t\t\tite->isTempFile = true;\r\n\t\t\t\tite->AspectRatio = false;\r\n\t\t\t\tite->ScaleType   = false;\r\n\t\t\t\timg.save(fileName, \"PNG\");\r\n\t\t\t\tm_doc->loadPict(fileName, ite);\r\n\t\t\t\tm_Elements->append(ite);\r\n\t\t\t\tif (m_groupStack.count() != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tm_groupStack.top().Items.append(ite);\r\n\t\t\t\t\tapplyMask(ite);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\tm_doc->Items->removeAll(ite);\r\n\t\t}\r\n\t\tdelete tempFile;\r\n\t}\r\n\tif (checkClip())\r\n\t{\r\n\t\tFPointArray out = m_currentClipPath.copy();\r\n\t\tout.translate(m_doc->currentPage()->xOffset(), m_doc->currentPage()->yOffset());\r\n\t\tout.translate(-ite->xPos(), -ite->yPos());\r\n\t\tite->PoLine = out.copy();\r\n\t\tFPoint wh = getMaxClipF(&ite->PoLine);\r\n\t\tite->setWidthHeight(wh.x(),wh.y());\r\n\t\tite->setTextFlowMode(PageItem::TextFlowDisabled);\r\n\t\tite->ScaleType   = true;\r\n\t\tm_doc->AdjustItemSize(ite);\r\n\t\tite->OldB2 = ite->width();\r\n\t\tite->OldH2 = ite->height();\r\n\t\tite->updateClip();\r\n\t}\r\n\tdelete imgStr;\r\n\tdelete image;\r\n}",
    "void ScImgDataLoader_TIFF::loadEmbeddedProfile(const QString& fn, int /*page*/)\n{\n\tScColorMgmtEngine engine(ScCore->defaultEngine);\n\tm_embeddedProfile.resize(0);\n\tm_profileComponents = 0;\n\tif ( !QFile::exists(fn) )\n\t\treturn;\n\tTIFFSetTagExtender(TagExtender);\n\tTIFF* tif = TIFFOpen(fn.toLocal8Bit(), \"r\");\n\tif(tif)\n\t{\n\t\tuint32 EmbedLen = 0;\n\t\tvoid*  EmbedBuffer;\n\t\tif (TIFFGetField(tif, TIFFTAG_ICCPROFILE, &EmbedLen, &EmbedBuffer))\n\t\t{\n\t\t\tQByteArray profArray((const char*) EmbedBuffer, EmbedLen);\n\t\t\tScColorProfile tiffProf = engine.openProfileFromMem(profArray);\n\t\t\tif (tiffProf)\n\t\t\t{\n\t\t\t\tif (tiffProf.colorSpace() == ColorSpace_Rgb)\n\t\t\t\t\tm_profileComponents = 3;\n\t\t\t\tif (tiffProf.colorSpace() == ColorSpace_Cmyk)\n\t\t\t\t\tm_profileComponents = 4;\n\t\t\t\tif (tiffProf.colorSpace() == ColorSpace_Gray)\n\t\t\t\t\tm_profileComponents = 1;\n\t\t\t\tm_embeddedProfile = profArray;\n\t\t\t}\n\t\t}\n\t\tTIFFClose(tif);\n\t}\n}",
    "int ScImgDataLoader_TIFF::getLayers(const QString& fn, int /*page*/)\n{\n\tint layerNum = 1;\n\tint test;\n\tstruct PSDLayer lay;\n\tTIFFSetTagExtender(TagExtender);\n\tTIFF* tif = TIFFOpen(fn.toLocal8Bit(), \"r\");\n\tif (tif)\n\t{\n\t\tdo\n\t\t{\n\t\t\tchar *layerName=0;\n\t\t\tTIFFGetField(tif, TIFFTAG_PAGENAME, &layerName);\n\t\t\tQString name = QString(layerName);\n\t\t\tif (name.isEmpty())\n\t\t\t\tlay.layerName = QString(\"Layer #%1\").arg(layerNum);\n\t\t\telse\n\t\t\t\tlay.layerName = name;\n\t\t\tlay.blend = \"norm\";\n\t\t\tlay.opacity = 255;\n\t\t\tlay.flags = 0;\n\t\t\tm_imageInfoRecord.layerInfo.append(lay);\n\t\t\tm_imageInfoRecord.valid = true;\n\t\t\tlayerNum++;\n\t\t\ttest = TIFFReadDirectory(tif);\n\t\t}\n\t\twhile (test == 1);\n\t\tTIFFClose(tif);\n\t}\n\treturn layerNum;\n}",
    "bool ScImgDataLoader_TIFF::loadPicture(const QString& fn, int page, int res, bool thumbnail)\n{\n\tScColorMgmtEngine engine(ScCore->defaultEngine);\n\tbool bilevel = false;\n\tbool failedPS = false;\n\tbool foundPS = false;\n\tshort resolutionunit = 0;\n\tfloat xres = 72.0, yres = 72.0;\n\tif (!QFile::exists(fn))\n\t\treturn false;\n\tQByteArray byteOrder(2, ' ');\n\tQFile fo(fn);\n\tif (fo.open(QIODevice::ReadOnly))\n\t{\n\t\tfo.read(byteOrder.data(), 1);\n\t\tfo.close();\n\t}\n\tsrand(314159265);\n\tfor (int i = 0; i < 4096; i++)\n\t\trandom_table[i] = rand();\n\tfor (int i = 0; i < 4096; i++)\n\t{\n\t\tint tmp;\n\t\tint swap = i + rand() % (4096 - i);\n\t\ttmp = random_table[i];\n\t\trandom_table[i] = random_table[swap];\n\t\trandom_table[swap] = tmp;\n\t}\n\tint test;\n\tbool valid = m_imageInfoRecord.isRequest;\n\tQMap<int, ImageLoadRequest> req = m_imageInfoRecord.RequestProps;\n\tinitialize();\n\tm_imageInfoRecord.RequestProps = req;\n\tm_imageInfoRecord.isRequest = valid;\n\tm_imageInfoRecord.type = ImageTypeTIF;\n\tgetLayers(fn, page);\n\tTIFFSetTagExtender(TagExtender);\n\tTIFF* tif = TIFFOpen(fn.toLocal8Bit(), \"r\");\n\tif (tif)\n\t{\n\t\tbool isCMYK = false;\n\t\tunsigned int widtht, heightt, size;\n\t\tchar *description=0, *copyright=0, *datetime=0, *artist=0, *scannerMake=0, *scannerModel=0;\n\t\tuint16 bitspersample, fillorder, planar;\n\n\t\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &widtht);\n\t\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &heightt);\n\t\tTIFFGetField(tif, TIFFTAG_XRESOLUTION, &xres);\n\t\tTIFFGetField(tif, TIFFTAG_YRESOLUTION, &yres);\n\t\tTIFFGetField(tif, TIFFTAG_RESOLUTIONUNIT , &resolutionunit);\n\t\tsize = widtht * heightt;\n\t\tTIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric);\n\t\tTIFFGetField(tif, TIFFTAG_PLANARCONFIG, &planar);\n\t\tTIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bitspersample);\n\t\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &samplesperpixel);\n\t\tTIFFGetField(tif, TIFFTAG_FILLORDER, &fillorder);\n\n\t\tTIFFGetField(tif, TIFFTAG_MAKE, &scannerMake);\n\t\tTIFFGetField(tif, TIFFTAG_MODEL, &scannerModel);\n\t\tTIFFGetField(tif, TIFFTAG_IMAGEDESCRIPTION, &description);\n\t\tTIFFGetField(tif, TIFFTAG_COPYRIGHT, &copyright);\n\t\tTIFFGetField(tif, TIFFTAG_DATETIME, &datetime);\n\t\tTIFFGetField(tif, TIFFTAG_ARTIST, &artist);\n\t\tm_imageInfoRecord.exifInfo.cameraName = QString(scannerModel);\n\t\tm_imageInfoRecord.exifInfo.cameraVendor = QString(scannerMake);\n\t\tm_imageInfoRecord.exifInfo.comment = QString(description);\n\t\tm_imageInfoRecord.exifInfo.userComment = QString(copyright);\n\t\tm_imageInfoRecord.exifInfo.width = widtht;\n\t\tm_imageInfoRecord.exifInfo.height = heightt;\n\t\tm_imageInfoRecord.exifInfo.dateTime = QString(datetime);\n\t\tm_imageInfoRecord.exifInfo.artist = QString(artist);\n\t\tm_imageInfoRecord.exifInfo.thumbnail = QImage();\n\t\tm_imageInfoRecord.exifDataValid = true;\n\t\tuint32 EmbedLen = 0;\n\t\tvoid*  EmbedBuffer;\n\t\tif (TIFFGetField(tif, TIFFTAG_ICCPROFILE, &EmbedLen, &EmbedBuffer))\n\t\t{\n\t\t\tQByteArray profArray((const char*) EmbedBuffer, EmbedLen);\n\t\t\tScColorProfile tiffProf = engine.openProfileFromMem(profArray);\n\t\t\tm_embeddedProfile = profArray;\n\t\t\tm_imageInfoRecord.profileName = tiffProf.productDescription();\n\t\t\tm_imageInfoRecord.isEmbedded = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tm_imageInfoRecord.isEmbedded = false;\n\t\t\tm_imageInfoRecord.profileName = \"\";\n\t\t}\n\t\tunsigned int PhotoshopLen = 0;\n\t\tunsigned char* PhotoshopBuffer;\n\t\tif (TIFFGetField(tif, TIFFTAG_PHOTOSHOP, &PhotoshopLen, &PhotoshopBuffer) )\n\t\t{\n\t\t\tif (PhotoshopLen != 0)\n\t\t\t{\n\t\t\t\tQByteArray arrayPhot = QByteArray((const char*)PhotoshopBuffer,PhotoshopLen);\n\t\t\t\tQDataStream strPhot(&arrayPhot,QIODevice::ReadOnly);\n\t\t\t\tstrPhot.setByteOrder( QDataStream::BigEndian );\n\t\t\t\tPSDHeader fakeHeader;\n\t\t\t\tfakeHeader.width = widtht;\n\t\t\t\tfakeHeader.height = heightt;\n\t\t\t\tparseRessourceData(strPhot, fakeHeader, PhotoshopLen);\n\t\t\t\tm_imageInfoRecord.exifInfo.width = widtht;\n\t\t\t\tm_imageInfoRecord.exifInfo.height = heightt;\n\t\t\t\tif (!m_imageInfoRecord.valid)\n\t\t\t\t\tm_imageInfoRecord.valid = (m_imageInfoRecord.PDSpathData.size())>0?true:false;\n\t\t\t\tif (thumbnail)\n\t\t\t\t{\n\t\t\t\t\tif (photometric == PHOTOMETRIC_SEPARATED)\n\t\t\t\t\t{\n\t\t\t\t\t\tisCMYK = true;\n\t\t\t\t\t\tm_imageInfoRecord.colorspace = ColorSpaceCMYK;\n\t\t\t\t\t}\n\t\t\t\t\telse if (samplesperpixel == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tm_imageInfoRecord.colorspace = ColorSpaceGray;\n\t\t\t\t\t\tisCMYK = false;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tm_imageInfoRecord.colorspace = ColorSpaceRGB;\n\t\t\t\t\tif (bitspersample == 1)\n\t\t\t\t\t\tbilevel = true;\n\t\t\t\t\tif (!m_imageInfoRecord.exifInfo.thumbnail.isNull())\n\t\t\t\t\t{\n\t\t\t\t\t\tif (isCMYK)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tr_image.create(m_imageInfoRecord.exifInfo.thumbnail.width(), m_imageInfoRecord.exifInfo.thumbnail.height(), 5);\n\t\t\t\t\t\t\tm_pixelFormat = Format_CMYKA_8;;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tr_image.create(m_imageInfoRecord.exifInfo.thumbnail.width(), m_imageInfoRecord.exifInfo.thumbnail.height(), 4);\n\t\t\t\t\t\t\tm_pixelFormat = (m_imageInfoRecord.colorspace == ColorSpaceCMYK) ? Format_CMYK_8 : Format_RGBA_8;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr_image.fill(0);\n\t\t\t\t\t\tQRgb *s;\n\t\t\t\t\t\tuchar *d;\n\t\t\t\t\t\tunsigned char cc, cm, cy, ck;\n\t\t\t\t\t\tfor( int yit=0; yit < m_imageInfoRecord.exifInfo.thumbnail.height(); ++yit )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ts = (QRgb*)(m_imageInfoRecord.exifInfo.thumbnail.scanLine( yit ));\n\t\t\t\t\t\t\td = r_image.scanLine( yit );\n\t\t\t\t\t\t\tfor(int xit=0; xit < m_imageInfoRecord.exifInfo.thumbnail.width(); ++xit )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (isCMYK)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tcc = 255 - qRed(*s);\n\t\t\t\t\t\t\t\t\tcm = 255 - qGreen(*s);\n\t\t\t\t\t\t\t\t\tcy = 255 - qBlue(*s);\n\t\t\t\t\t\t\t\t\tck = qMin(qMin(cc, cm), cy);\n\t\t\t\t\t\t\t\t\td[0] = cc-ck;\n\t\t\t\t\t\t\t\t\td[1] = cm-ck;\n\t\t\t\t\t\t\t\t\td[2] = cy-ck;\n\t\t\t\t\t\t\t\t\td[3] = ck;\n\t\t\t\t\t\t\t\t\td[4] = 255;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\td[0] = qRed(*s);\n\t\t\t\t\t\t\t\t\td[1] = qGreen(*s);\n\t\t\t\t\t\t\t\t\td[2] = qBlue(*s);\n\t\t\t\t\t\t\t\t\td[3] = 255;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ts++;\n\t\t\t\t\t\t\t\td += r_image.channels();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tTIFFClose(tif);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tunsigned int PhotoshopLen2 = 0;\n\t\tunsigned char* PhotoshopBuffer2;\n\t\tint gotField = TIFFGetField(tif, 37724, &PhotoshopLen2, &PhotoshopBuffer2);\n\t\tif (gotField && (PhotoshopLen2 > 40))\n\t\t{\n\t\t\tm_imageInfoRecord.layerInfo.clear();\n\t\t\tQByteArray arrayPhot = QByteArray::fromRawData((const char*)PhotoshopBuffer2, PhotoshopLen2);\n\t\t\tQDataStream s(&arrayPhot,QIODevice::ReadOnly);\n\t\t\tif (byteOrder[0] == 'M')\n\t\t\t\ts.setByteOrder( QDataStream::BigEndian );\n\t\t\telse\n\t\t\t\ts.setByteOrder( QDataStream::LittleEndian );\n\n\t\t\tfailedPS = !loadLayerInfo(s, m_imageInfoRecord.layerInfo); \n\t\t\tif (!failedPS)\n\t\t\t{\n\t\t\t\tint chans = 4;\n\t\t\t\tint numChannels = m_imageInfoRecord.layerInfo.last().channelType.count();\n\t\t\t\tint numLayers = m_imageInfoRecord.layerInfo.count();\n\t\t\t\tPSDHeader fakeHeader;\n\t\t\t\tfakeHeader.width = widtht;\n\t\t\t\tfakeHeader.height = heightt;\n\t\t\t\tfakeHeader.channel_count = numChannels;\n\t\t\t\tfakeHeader.depth = 8;\n\t\t\t\tif (photometric == PHOTOMETRIC_SEPARATED)\n\t\t\t\t{\n\t\t\t\t\tisCMYK = true;\n\t\t\t\t\tfakeHeader.color_mode = CM_CMYK;\n\t\t\t\t\tchans = 5;\n\t\t\t\t}\n\t\t\t\telse if (samplesperpixel == 1)\n\t\t\t\t{\n\t\t\t\t\tfakeHeader.color_mode = CM_GRAYSCALE;\n\t\t\t\t\tisCMYK = false;\n\t\t\t\t\tchans = 4;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfakeHeader.color_mode = CM_RGB;\n\t\t\t\t\tisCMYK = false;\n\t\t\t\t\tchans = 4;\n\t\t\t\t}\n\t\t\t\tif( !r_image.create( widtht, heightt, chans ))\n\t\t\t\t\treturn false;\n\t\t\t\tr_image.fill(0);\n\t\t\t\tbool firstLayer = true;\n\t\t\t\tfor (int layer = 0; layer < numLayers; layer++)\n\t\t\t\t{\n\t\t\t\t\tloadLayerChannels( s, fakeHeader, m_imageInfoRecord.layerInfo, layer, &firstLayer );\n\t\t\t\t}\n\t\t\t\tarrayPhot.clear();\n\t\t\t\tTIFFClose(tif);\n\t\t\t\tfoundPS = true;\n\t\t\t\tif (m_imageInfoRecord.layerInfo.count() == 1)\n\t\t\t\t\tm_imageInfoRecord.layerInfo.clear();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tarrayPhot.clear();\n\t\t\t\tgetLayers(fn, page);\n\t\t\t}\n\t\t}\n\n\t\tif( xres <= 1.0 || yres <= 1.0 )\n\t\t{\n\t\t\txres = yres = 72.0;\n\t\t\tQFileInfo qfi(fn);\n\t\t\tm_message = QObject::tr(\"%1 may be corrupted : missing resolution tags\").arg(qfi.fileName());\n\t\t\tm_msgType = warningMsg;\n\t\t}\n\t\tif ((!foundPS) || (failedPS))\n\t\t{\n\t\t\tint chans = 4;\n\t\t\tif (photometric == PHOTOMETRIC_SEPARATED)\n\t\t\t{\n\t\t\t\tif (samplesperpixel > 5) \n\t\t\t\t\tchans = 4;\n\t\t\t\telse\n\t\t\t\t\tchans = samplesperpixel;\n\t\t\t}\n\t\t\telse\n\t\t\t\tchans = 4;\n\t\t\tif (!r_image.create(widtht, heightt, chans))\n\t\t\t{\n\t\t\t\tTIFFClose(tif);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tr_image.fill(0);\n\t\t\tint layerNum = 0;\n\t\t\tdo\n\t\t\t{\n\t\t\t\tRawImage tmpImg;\n\t\t\t\tif( !tmpImg.create(widtht, heightt, chans))\n\t\t\t\t{\n\t\t\t\t\tTIFFClose(tif);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\ttmpImg.fill(0);\n\t\t\t\tif (!getImageData(tif, &tmpImg, widtht, heightt, size, photometric, bitspersample, samplesperpixel, bilevel, isCMYK))\n\t\t\t\t{\n\t\t\t\t\tTIFFClose(tif);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tbool visible = true;\n\t\t\t\tbool useMask = true;\n\t\t\t\tif ((m_imageInfoRecord.isRequest) && (m_imageInfoRecord.RequestProps.contains(layerNum)))\n\t\t\t\t\tvisible = m_imageInfoRecord.RequestProps[layerNum].visible;\n\t\t\t\tQString layBlend = \"norm\";\n\t\t\t\tif ((m_imageInfoRecord.isRequest) && (m_imageInfoRecord.RequestProps.contains(layerNum)))\n\t\t\t\t\tlayBlend = m_imageInfoRecord.RequestProps[layerNum].blend;\n\t\t\t\tif ((m_imageInfoRecord.isRequest) && (m_imageInfoRecord.RequestProps.contains(layerNum)))\n\t\t\t\t\tuseMask = m_imageInfoRecord.RequestProps[layerNum].useMask;\n\t\t\t\tint layOpa = 255;\n\t\t\t\tif ((m_imageInfoRecord.isRequest) && (m_imageInfoRecord.RequestProps.contains(layerNum)))\n\t\t\t\t\tlayOpa = m_imageInfoRecord.RequestProps[layerNum].opacity;\n\t\t\t\tif (visible)\n\t\t\t\t{\n\t\t\t\t\tif ((layerNum == 0) && (layBlend != \"diss\"))\n\t\t\t\t\t\tr_image = tmpImg;\n\t\t\t\t\telse\n\t\t\t\t\t\tblendOntoTarget(&tmpImg, layOpa, layBlend, isCMYK, useMask);\n\t\t\t\t}\n\t\t\t\t//JG Copy should not be necessary as QImage is implicitly shared in Qt4\n\t\t\t\tQImage imt; //QImage imt = tmpImg.copy();\n\t\t\t\tdouble sx = tmpImg.width() / 40.0;\n\t\t\t\tdouble sy = tmpImg.height() / 40.0;\n\t\t\t\timt = tmpImg.convertToQImage((chans > 4) ? true : false);\n\t\t\t\timt = sy < sx ?\timt.scaled(qRound(imt.width() / sx), qRound(imt.height() / sx), Qt::IgnoreAspectRatio, Qt::SmoothTransformation) :\n\t\t\t\t\t\t\t\t\t\t\timt.scaled(qRound(imt.width() / sy), qRound(imt.height() / sy), Qt::IgnoreAspectRatio, Qt::SmoothTransformation);\n\t\t\t\tm_imageInfoRecord.layerInfo[layerNum].thumb = imt.copy();\n\t\t\t\tif (chans > 4)\n\t\t\t\t{\n\t\t\t\t\tQImage imt2 = imt.createAlphaMask();\n\t\t\t\t\timt2.invertPixels();\n\t\t\t\t\tm_imageInfoRecord.layerInfo[layerNum].thumb_mask = imt2.copy();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tm_imageInfoRecord.layerInfo[layerNum].thumb_mask = QImage();\n\t\t\t\tlayerNum++;\n\n\t\t\t\tif ((m_imageInfoRecord.layerInfo.count() == 1) && (chans < 5))\n\t\t\t\t\tm_imageInfoRecord.layerInfo.clear();\n\t\t\t\ttest = TIFFReadDirectory(tif);\n\n\t\t\t\t// #10415 : check that image size for the current directory is the same as the main one\n\t\t\t\t// Some progs use tiff directory to store previews, we do not handle such case\n\t\t\t\t// and may perform reads in non allocated blocks if we continue\n\t\t\t\twhile (test == 1)\n\t\t\t\t{\n\t\t\t\t\tunsigned int dirWidth(0), dirHeight(0);\n\t\t\t\t\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &dirWidth);\n\t\t\t\t\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &dirHeight);\n\t\t\t\t\tif (dirWidth == widtht && dirHeight == heightt)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\ttest = TIFFReadDirectory(tif);\n\t\t\t\t\tlayerNum++;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (test == 1);\n\t\t\tTIFFClose(tif);\n\t\t}\n\t\tif (resolutionunit == RESUNIT_INCH)\n\t\t{\n\t\t\tm_image.setDotsPerMeterX ((int) (xres / 0.0254));\n\t\t\tm_image.setDotsPerMeterY ((int) (yres / 0.0254));\n\t\t\tm_imageInfoRecord.xres = qRound(xres);\n\t\t\tm_imageInfoRecord.yres = qRound(yres);\n\t\t}\n\t\telse if (resolutionunit == RESUNIT_CENTIMETER)\n\t\t{\n\t\t\tm_image.setDotsPerMeterX ((int) (xres * 100.0));\n\t\t\tm_image.setDotsPerMeterY ((int) (yres * 100.0));\n\t\t\tm_imageInfoRecord.xres = qRound(xres*2.54);\n\t\t\tm_imageInfoRecord.yres = qRound(yres*2.54);\n\t\t}\n\t\tif (isCMYK)\n\t\t{\n\t\t\tm_imageInfoRecord.colorspace = ColorSpaceCMYK;\n\t\t\tm_pixelFormat = (r_image.channels() == 5) ? Format_CMYKA_8 : Format_CMYK_8;\n\t\t}\n\t\telse if (samplesperpixel == 1)\n\t\t{\n\t\t\t// Do not set m_pixelFormat here as the real pixel format is most probably different than gray\n\t\t\tif (bitspersample == 1)\n\t\t\t{\n\t\t\t\tm_imageInfoRecord.colorspace = ColorSpaceMonochrome;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tm_imageInfoRecord.colorspace = ColorSpaceGray;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tm_imageInfoRecord.colorspace = ColorSpaceRGB;\n\t\t\tm_pixelFormat = Format_RGBA_8;\n\t\t}\n\t\tm_imageInfoRecord.BBoxX = 0;\n\t\tm_imageInfoRecord.BBoxH = r_image.height();\n\t\tif ((m_imageInfoRecord.layerInfo.isEmpty()) && (m_imageInfoRecord.PDSpathData.isEmpty()))\n\t\t\tm_imageInfoRecord.valid = false;\n\t\telse\n\t\t\tm_imageInfoRecord.valid = true;\n\t\treturn true;\n\t}\n\treturn false;\n}",
    "unsigned int\nXdmfTIFFController::getNumberDirectories() const\n{\n  TIFF* tif = TIFFOpen(mFilePath.c_str(), \"r\");\n  unsigned int count = 0;\n  if (tif) {\n    do {\n      count++;\n    } while (TIFFReadDirectory(tif));\n    TIFFClose(tif);\n  }\n  return count;\n}",
    "void\nXdmfTIFFController::read(XdmfArray * const array)\n{\n  TIFF* tif = TIFFOpen(mFilePath.c_str(), \"r\");\n\n  unsigned int compression = 0;\n\n  TIFFGetField(tif, TIFFTAG_COMPRESSION, &compression);\n\n  unsigned int currentDirectory = 0;\n\n  if (tif && mStart.size() >= 3) {\n    // setting the start for the first directory\n    TIFFSetDirectory(tif, mStart[2]);\n    currentDirectory = mStart[2];\n  }\n\n  unsigned int amountWritten = 0;\n  // Only used for 1d controllers\n  unsigned int sizeLeft = this->getSize();\n  if (!array->isInitialized()) {\n    array->initialize(this->getType());\n  }\n  if (array->getSize() != this->getSize()) {\n    array->resize(mDimensions, 0);\n  }\n\n  // For single dimension version only\n  unsigned int currentRowStart = mStart[0];\n  unsigned int scanlineIndex = 0;\n\n  if (mDimensions.size() > 1)\n  {\n    scanlineIndex = mStart[1];\n  }\n\n  if (tif) {\n    bool validDir = true;\n    while (validDir) {\n      // Directories are handled by the third dimension\n      // If no directories are specified, progress as far\n      // as needed to fill the dimensions provided.\n      unsigned int imagelength, bitsPerSample;\n      tdata_t buf;\n      unsigned int row;\n      unsigned int scanlinesize = TIFFScanlineSize(tif);\n\n      shared_ptr<const XdmfArrayType> tiffDataType = array->getArrayType();\n\n      TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bitsPerSample);\n\n      TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &imagelength);\n\n      if (compression == 1) {\n        // Specific to non-compressed read\n\n        if (bitsPerSample / 8 == 1) {\n          tiffDataType = XdmfArrayType::UInt8();\n        }\n        else if (bitsPerSample / 8 == 2) {\n          tiffDataType = XdmfArrayType::UInt16();\n        }\n        else if (bitsPerSample / 8 == 4) {\n          tiffDataType = XdmfArrayType::UInt32();\n        }\n        else if (bitsPerSample / 8 == 8) {\n          tiffDataType = XdmfArrayType::UInt64();\n        }\n\n        // the buffer is a number of bytes equal to the scan line size\n        buf = _TIFFmalloc(scanlinesize );\n\n        scanlinesize /= array->getArrayType()->getElementSize();\n\n        if (mDimensions.size() == 1)\n        {\n          if (sizeLeft == 0) {\n            break;\n          }\n          // If there is one dimensions then we treat the entire entry as a single dataset.\n          // We need to adjust the starting point accordingly.\n          for (row = 0; row < imagelength; ++row)\n          {\n            TIFFReadScanline(tif, buf, row);\n            unsigned int amountRead = sizeLeft;\n            if ((scanlinesize - currentRowStart) / mStride[0] <= sizeLeft) {\n              amountRead = (scanlinesize - currentRowStart) / mStride[0];\n              if (scanlinesize % mStride[0] != 0 &&\n                  currentRowStart % mStride[0] <= scanlinesize - (amountRead * mStride[0] + currentRowStart))\n              {\n                 amountRead++;\n              }\n            }\n            readToArray(array,\n                        buf,\n                        amountWritten,\n                        currentRowStart,\n                        mStride[0],\n                        amountRead,\n                        tiffDataType);\n            // check to see how the start matches up with the scanline size\n            amountWritten += amountRead;\n            if (sizeLeft == 0) {\n              break;\n            }\n\n            if (amountRead < sizeLeft) {\n              sizeLeft = sizeLeft - amountRead;\n            }\n            else {\n              sizeLeft = 0;\n            }\n            if (((int)((amountRead * mStride[0]) + currentRowStart)) - scanlinesize >= 0)\n            {\n              currentRowStart = ((amountRead * mStride[0]) + currentRowStart) - scanlinesize;\n            }\n            else\n            {\n              currentRowStart = ((amountRead * (mStride[0] + 1)) + currentRowStart) - scanlinesize;\n            }\n          }\n        }\n        else {\n        // Dimensions correspond to scanline size and number of scanlines\n          unsigned int rowstride = mStride[1];\n          unsigned int currentRowStart = mStart[0];\n          for (row = mStart[1]; row < imagelength && row < mDataspaceDimensions[1]; row+=rowstride)\n          {\n            TIFFReadScanline(tif, buf, row);\n            readToArray(array,\n                        buf,\n                        amountWritten,\n                        currentRowStart,\n                        mStride[0],\n                        mDimensions[0],\n                        tiffDataType);\n            amountWritten += mDimensions[0];\n          }\n        }\n        _TIFFfree(buf);\n\n      }\n      else if (compression == 5)\n      {\n        // In this case we need to use strips instead of scanlines\n        // scanline size is in bytes when dealing with compression\n        if (bitsPerSample == 1) {\n          tiffDataType = XdmfArrayType::UInt8();\n        }\n        else if (bitsPerSample == 2) {\n          tiffDataType = XdmfArrayType::UInt16();\n        }\n        else if (bitsPerSample == 4) {\n          tiffDataType = XdmfArrayType::UInt32();\n        }\n        else if (bitsPerSample == 8) {\n          tiffDataType = XdmfArrayType::UInt64();\n        }\n\n        // the buffer is a number of bytes equal to the scan line size\n        buf = _TIFFmalloc(TIFFStripSize(tif));\n\n        scanlinesize /= array->getArrayType()->getElementSize();\n\n        // For each strip in the directory\n        for (unsigned int strip = 0; strip < TIFFNumberOfStrips(tif); strip++)\n        {\n          if (sizeLeft == 0) {\n            break;\n          }\n\n          unsigned int currentStripSize = TIFFReadEncodedStrip(tif, strip, buf, -1);\n          currentStripSize = currentStripSize / array->getArrayType()->getElementSize();\n          // Size is in bits, and is not necessarily the same per strip\n          unsigned int numberScanlines = currentStripSize / scanlinesize;\n          // For the case of a partial scanline\n          if (currentStripSize % scanlinesize != 0) {\n            ++numberScanlines;\n          }\n          // If singledimensional\n          // then write out the strip as if it was a scanline\n\n          if (mDimensions.size() == 1)\n          {\n            unsigned int amountRead = sizeLeft;\n            if ((currentStripSize - currentRowStart) / mStride[0] <= sizeLeft) {\n              amountRead = (currentStripSize - currentRowStart) / mStride[0];\n              if (currentStripSize % mStride[0] != 0 &&\n                  currentRowStart % mStride[0] <= currentStripSize - (amountRead * mStride[0] + currentRowStart))\n              {\n                 amountRead++;\n              }\n            }\n            readToArray(array,\n                        buf,\n                        amountWritten,\n                        currentRowStart,\n                        mStride[0],\n                        amountRead,\n                        tiffDataType);\n            amountWritten += amountRead;\n            if (sizeLeft == 0) {\n              break;\n            }\n\n            if (amountRead < sizeLeft) {\n              sizeLeft = sizeLeft - amountRead;\n            }\n            else {\n              sizeLeft = 0;\n            }\n            if (((int)((amountRead * mStride[0]) + currentRowStart)) - currentStripSize >= 0)\n            {\n              currentRowStart = ((amountRead * mStride[0]) + currentRowStart) - currentStripSize;\n            }\n            else\n            {\n              currentRowStart = ((amountRead * (mStride[0] + 1)) + currentRowStart) - currentStripSize;\n            }\n          }\n          else\n          {\n            currentRowStart = scanlineIndex;\n            // If multidimensional\n            // Loop through the scanlines in the strip\n            for (; scanlineIndex < numberScanlines; scanlineIndex += mStride[1])\n            {\n              readToArray(array,\n                          buf,\n                          amountWritten,\n                          currentRowStart,\n                          mStride[0],\n                          mDimensions[0],\n                          tiffDataType);\n              amountWritten += mDimensions[0];\n              currentRowStart = currentRowStart + scanlinesize * mStride[1];\n            }\n            scanlineIndex = scanlineIndex % mStride[1];\n          }\n        }\n      }\n\n      if (mStride.size() >= 3)\n      {\n        currentDirectory += mStride[2];\n      }\n      else\n      {\n        ++currentDirectory;\n      }\n\n      validDir = TIFFSetDirectory(tif, currentDirectory);\n    }\n  }\n  else {\n    XdmfError::message(XdmfError::FATAL, \"Error: Invalid TIFF file\");\n  }\n\n  TIFFClose(tif);\n}",
    "int NITFUncompressBILEVEL(NITFImage *psImage, GByte *pabyInputData,\n                          int nInputBytes, GByte *pabyOutputImage)\n\n{\n    /* -------------------------------------------------------------------- */\n    /*      Write memory TIFF with the bilevel data.                        */\n    /* -------------------------------------------------------------------- */\n    const int nOutputBytes =\n        (psImage->nBlockWidth * psImage->nBlockHeight + 7) / 8;\n\n    const CPLString osFilename(\n        VSIMemGenerateHiddenFilename(\"nitf_bilevel.tif\"));\n    VSILFILE *fpL = VSIFOpenL(osFilename, \"w+\");\n    if (fpL == nullptr)\n        return FALSE;\n    TIFF *hTIFF = VSI_TIFFOpen(osFilename, \"w+\", fpL);\n    if (hTIFF == nullptr)\n    {\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fpL));\n        return FALSE;\n    }\n\n    TIFFSetField(hTIFF, TIFFTAG_IMAGEWIDTH, psImage->nBlockWidth);\n    TIFFSetField(hTIFF, TIFFTAG_IMAGELENGTH, psImage->nBlockHeight);\n    TIFFSetField(hTIFF, TIFFTAG_BITSPERSAMPLE, 1);\n    TIFFSetField(hTIFF, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT);\n    TIFFSetField(hTIFF, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    TIFFSetField(hTIFF, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);\n\n    TIFFSetField(hTIFF, TIFFTAG_ROWSPERSTRIP, psImage->nBlockHeight);\n    TIFFSetField(hTIFF, TIFFTAG_SAMPLESPERPIXEL, 1);\n    TIFFSetField(hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n    TIFFSetField(hTIFF, TIFFTAG_COMPRESSION, COMPRESSION_CCITTFAX3);\n\n    if (psImage->szCOMRAT[0] == '2')\n        TIFFSetField(hTIFF, TIFFTAG_GROUP3OPTIONS, GROUP3OPT_2DENCODING);\n\n    TIFFWriteRawStrip(hTIFF, 0, pabyInputData, nInputBytes);\n    TIFFWriteDirectory(hTIFF);\n\n    TIFFClose(hTIFF);\n\n    /* -------------------------------------------------------------------- */\n    /*      Now open and read it back.                                      */\n    /* -------------------------------------------------------------------- */\n    bool bResult = true;\n\n    hTIFF = VSI_TIFFOpen(osFilename, \"r\", fpL);\n    if (hTIFF == nullptr)\n    {\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fpL));\n        return FALSE;\n    }\n\n    if (TIFFReadEncodedStrip(hTIFF, 0, pabyOutputImage, nOutputBytes) == -1)\n    {\n        memset(pabyOutputImage, 0, nOutputBytes);\n        bResult = false;\n    }\n\n    TIFFClose(hTIFF);\n    CPL_IGNORE_RET_VAL(VSIFCloseL(fpL));\n\n    VSIUnlink(osFilename);\n\n    return bResult;\n}",
    "void generate(int nBands, uint16_t nPhotometric, uint16_t nBitsPerSample)\n{\n    char **papszOpts = nullptr;\n    papszOpts = CSLSetNameValue(papszOpts, \"COMPRESS\", \"JPEG\");\n    if (nPhotometric == PHOTOMETRIC_YCBCR)\n        papszOpts = CSLSetNameValue(papszOpts, \"PHOTOMETRIC\", \"YCBCR\");\n    else if (nPhotometric == PHOTOMETRIC_SEPARATED)\n        papszOpts = CSLSetNameValue(papszOpts, \"PHOTOMETRIC\", \"CMYK\");\n    papszOpts = CSLSetNameValue(papszOpts, \"BLOCKYSIZE\", \"16\");\n    if (nBitsPerSample == 12)\n        papszOpts = CSLSetNameValue(papszOpts, \"NBITS\", \"12\");\n\n    CPLString osTmpFilename;\n    osTmpFilename.Printf(\"gtiffdataset_guess_jpeg_quality_tmp\");\n\n    for (int nQuality = 1; nQuality <= 100; ++nQuality)\n    {\n        papszOpts = CSLSetNameValue(papszOpts, \"JPEG_QUALITY\",\n                                    CPLSPrintf(\"%d\", nQuality));\n        CPLPushErrorHandler(CPLQuietErrorHandler);\n        CPLString osTmp;\n        std::unique_ptr<GDALDataset> poDS(\n            GDALDriver::FromHandle(GDALGetDriverByName(\"GTiff\"))\n                ->Create(\n                    osTmpFilename.c_str(), 16, 16, (nBands <= 4) ? nBands : 1,\n                    nBitsPerSample == 8 ? GDT_Byte : GDT_UInt16, papszOpts));\n        assert(poDS);\n        poDS.reset();\n        CPLPopErrorHandler();\n\n        TIFF *hTIFFTmp = TIFFOpen(osTmpFilename.c_str(), \"rb\");\n        uint32_t nJPEGTableSizeTry = 0;\n        void *pJPEGTableTry = nullptr;\n        if (TIFFGetField(hTIFFTmp, TIFFTAG_JPEGTABLES, &nJPEGTableSizeTry,\n                         &pJPEGTableTry))\n        {\n            const GByte *const pabyTable =\n                static_cast<const GByte *>(pJPEGTableTry);\n            int nLen = static_cast<int>(nJPEGTableSizeTry);\n            const GByte *paby = pabyTable;\n\n            struct CPLMD5Context context;\n            CPLMD5Init(&context);\n\n            while (true)\n            {\n                int nLenTable = 0;\n                const GByte *pabyNew =\n                    GTIFFFindNextTable(paby, 0xDB, nLen, &nLenTable);\n                if (pabyNew == nullptr)\n                    break;\n                CPLMD5Update(&context, pabyNew, nLenTable);\n                pabyNew += nLenTable;\n                nLen -= static_cast<int>(pabyNew - paby);\n                paby = pabyNew;\n            }\n\n            GByte digest[16];\n            CPLMD5Final(digest, &context);\n            printf(\"{\"); /*ok*/\n            for (int i = 0; i < 16; i++)\n                printf(\"0x%02X,\", digest[i]);       /*ok*/\n            printf(\"}, // quality %d\\n\", nQuality); /*ok*/\n        }\n\n        TIFFClose(hTIFFTmp);\n    }\n\n    VSIUnlink(osTmpFilename);\n\n    CSLDestroy(papszOpts);\n}",
    "~TiffHandle()\n    {\n        if (m_pHandle) {\n            TIFFClose(m_pHandle);\n        }\n    }",
    "std::vector<Pixel> load_tiff(const char *path, std::uint32_t &image_width, std::uint32_t &image_height, std::size_t &image_size) {\n        TIFF *image_tiff = TIFFOpen(path, \"r\");\n        if(!image_tiff) {\n            eprintf_error(\"Cannot open %s\", path);\n            exit(EXIT_FAILURE);\n        }\n        TIFFGetField(image_tiff, TIFFTAG_IMAGEWIDTH, &image_width);\n        TIFFGetField(image_tiff, TIFFTAG_IMAGELENGTH, &image_height);\n\n        // Force associated alpha if we have alpha so alpha doesn't get multiplied in TIFFReadRGBAImageOriented\n        std::uint16_t count;\n        std::uint16_t *attributes;\n        int defined = TIFFGetField(image_tiff, TIFFTAG_EXTRASAMPLES, &count, &attributes);\n        if(defined && count == 1) {\n            if(*attributes == EXTRASAMPLE_UNASSALPHA) {\n                std::uint16_t new_value = EXTRASAMPLE_ASSOCALPHA;\n                TIFFSetField(image_tiff, TIFFTAG_EXTRASAMPLES, 1, &new_value);\n            }\n        }\n\n        // Read it all\n        image_size = image_width * image_height * sizeof(Invader::Pixel);\n        auto image_pixels = std::vector<Invader::Pixel>(image_size);\n        TIFFReadRGBAImageOriented(image_tiff, image_width, image_height, reinterpret_cast<std::uint32_t *>(image_pixels.data()), ORIENTATION_TOPLEFT);\n\n        // Close the TIFF\n        TIFFClose(image_tiff);\n\n        // Swap red and blue channels\n        for(std::size_t i = 0; i < image_size / 4; i++) {\n            Invader::Pixel swapped = image_pixels[i];\n            swapped.red = image_pixels[i].blue;\n            swapped.blue = image_pixels[i].red;\n            image_pixels[i] = swapped;\n        }\n\n        return image_pixels;\n    }",
    "static std::optional<bool> recover_bitmap(const Parser::ParserStruct &tag, const std::string &path, const std::filesystem::path &data, bool overwrite) {\n        auto *bitmap = dynamic_cast<const Parser::Bitmap *>(&tag);\n        auto file_path = data / (path + \".tif\");\n\n        std::size_t width, height;\n        if(bitmap) {\n            width = bitmap->color_plate_width;\n            height = bitmap->color_plate_height;\n        }\n        else {\n            return std::nullopt;\n        }\n\n        // Does it already exist?\n        if(std::filesystem::exists(file_path) && !overwrite) {\n            oprintf_success_warn(\"%s already exists\", file_path.string().c_str());\n            return false;\n        }\n\n        // Decompress it\n        auto decompressed_stuff = HEK::decompress_color_plate_data(*bitmap);\n        \n        // Do we have color plate data?\n        if(!decompressed_stuff.has_value()) {\n            eprintf_warn(\"No color plate data to recover from - tag likely extracted\");\n            return false;\n        }\n\n        // Let's begin\n        auto file_path_str = file_path.string();\n        create_directories_for_path(file_path);\n\n        auto *tiff = TIFFOpen(file_path_str.c_str(), \"w\");\n        if(!tiff) {\n            eprintf_error(\"Failed to open %s for writing\", file_path_str.c_str());\n            return false;\n        }\n\n        TIFFSetField(tiff, TIFFTAG_IMAGEWIDTH, width);\n        TIFFSetField(tiff, TIFFTAG_IMAGELENGTH, height);\n\n        std::uint16_t extrasamples = EXTRASAMPLE_UNASSALPHA;\n        TIFFSetField(tiff, TIFFTAG_EXTRASAMPLES, 1, &extrasamples);\n\n        TIFFSetField(tiff, TIFFTAG_SAMPLESPERPIXEL, 4);\n        TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 8, 8, 8, 8);\n        TIFFSetField(tiff, TIFFTAG_ROWSPERSTRIP, 1);\n        TIFFSetField(tiff, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n        TIFFSetField(tiff, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n        TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n        TIFFSetField(tiff, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT);\n        TIFFSetField(tiff, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n\n        // Swap blue and red channels\n        for(auto &i : *decompressed_stuff) {\n            i = (i & 0xFF00FF00) | ((i & 0x00FF0000) >> 16) | ((i & 0x000000FF) << 16);\n        }\n\n        // Write it\n        for (std::size_t y = 0; y < height; y++) {\n            TIFFWriteScanline(tiff, decompressed_stuff->data() + y * width, y, 0);\n        }\n\n        TIFFClose(tiff);\n\n        oprintf(\"Recovered data file %s\\n\", file_path_str.c_str());\n\n        return true;\n    }",
    "const void* NImage::CTIFImageReader::ReadImage\n(\n\tconst char * cpImageName, \n\tuint32& rImageWidth, \n\tuint32& rImageHeight, \n\tEImageFileFormat& rFormat, \n\tconst uint32\n) const\n{\n\tconst uint32 cBPP = 3;\n\tstatic CSHAllocator<float> sAllocator;\n\tTIFF* pTiff = TIFFOpen(cpImageName,\"r\");\n\n\tfloat *pOutput = NULL;\n\tif(pTiff) \n\t{\n\t\tuint32 width, height;\n\t\tsize_t pixelNum;\n\t\tuint32 *pRGBA;\n\n\t\tTIFFGetField(pTiff, TIFFTAG_IMAGEWIDTH, &width);\n\t\tTIFFGetField(pTiff, TIFFTAG_IMAGELENGTH, &height);\n\t\trImageWidth\t\t= width;\n\t\trImageHeight\t= height;\n\t\trFormat\t= (cBPP == 4)?A32B32G32R32F : B32G32R32F;\n\n\t\tpixelNum = width * height;\n\t\tpRGBA = (uint32*) new char[pixelNum * sizeof (uint32)];\n\n\t\tif(pRGBA) \n\t\t{\n\t\t\tif(TIFFReadRGBAImage(pTiff, width, height, pRGBA, 0)) \n\t\t\t{\n\t\t\t\t//convert data into floats\n\t\t\t\t// scan and copy surface, everything is float RGB\n\t\t\t\tpOutput = (float*)(sAllocator.new_mem_array(sizeof(float) * rImageWidth * rImageHeight * cBPP));\n\t\t\t\tassert(pOutput);\t\n\n\t\t\t\tfloat *pCurrentOutput = pOutput;\n\t\t\t\tuint32 *pCurrentInput = pRGBA;\n\n\t\t\t\tfor(unsigned int y=0; y < height; ++y)\n\t\t\t\t{\n\t\t\t\t\tfor(unsigned int x=0; x < width; ++x)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(int i=0; i<cBPP; ++i)\n\t\t\t\t\t\t\tpCurrentOutput[i] = (float)pCurrentInput[i];\n\t\t\t\t\t\tpCurrentOutput\t+= cBPP;\n\t\t\t\t\t\tpCurrentInput\t\t+= cBPP;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSAFE_DELETE_ARRAY(pRGBA);\n\t\t}\n//\t\telse RCLogError(\"ReadImage out of memory\");\n\t}\n\telse\n\t{\n\t\tchar message[200];\n\t\tsprintf(message, \"Could not load Texture: %s\\n\", cpImageName);\n\t\tGetSHLog().LogError(message);\n\t\treturn NULL;\n\t}\n\n\tif(pTiff)\n\t\tTIFFClose(pTiff);\n\n\treturn (void*)pOutput;\n}",
    "inline void operator()(TIFF* context) { TIFFClose(context); }",
    "char *loadTiff3D2Metadata ( char * filename, unsigned int &sz0, unsigned int  &sz1, unsigned int  &sz2, unsigned int  &sz3, int &datatype, int &b_swap, void * &fhandle, int &header_len ) {\r\n\r\n    // 2015-01-30. Alessandro. @ADDED performance (time) measurement in all most time-consuming methods.\r\n    #ifdef _VAA3D_TERAFLY_PLUGIN_MODE\r\n    TERAFLY_TIME_START(TiffLoadMetadata)\r\n    #endif\r\n\r\n\tuint32 XSIZE;\r\n\tuint32 YSIZE;\r\n\tuint16 bpp;\r\n\tuint16 spp;\r\n\tuint16 Cpage;\r\n\tuint16 Npages;\r\n    TIFF *input;\r\n    int check;\r\n\r\n\t//disable warning and error handlers to avoid messages on unrecognized tags\r\n\tTIFFSetWarningHandler(0);\r\n\tTIFFSetErrorHandler(0);\r\n\r\n\tinput=TIFFOpen(filename,\"r\");\r\n\tif (!input)\r\n    {\r\n\t\t//throw iim::IOException(strprintf(\"in IOManager::readTiffMultipage(...): Cannot open the file %s\",finName).c_str());\r\n\t\treturn ((char *) \"Cannot open the file.\");\r\n    }\r\n\r\n\tcheck=TIFFGetField(input, TIFFTAG_IMAGEWIDTH, &XSIZE);\r\n\tif (!check)\r\n\t{\r\n\t\tTIFFClose(input);\r\n\t\t//throw iim::IOException(strprintf(\"in IOManager::readTiffMultipage(...): Image length of %s undefined\\n\", finName).c_str());\r\n\t\treturn ((char *) \"Image width of undefined.\");\r\n\t}\t\t\r\n    \r\n\tcheck=TIFFGetField(input, TIFFTAG_IMAGELENGTH, &YSIZE);\r\n\tif (!check)\r\n\t{\r\n\t\tTIFFClose(input);\r\n\t\t//throw iim::IOException(strprintf(\"in IOManager::readTiffMultipage(...): Image length of %s undefined\\n\", finName).c_str());\r\n\t\treturn ((char *) \"Image length of undefined.\");\r\n\t}\t\t\r\n    \r\n\tcheck=TIFFGetField(input, TIFFTAG_BITSPERSAMPLE, &bpp); \r\n\tif (!check)\r\n\t{\r\n\t\tTIFFClose(input);\r\n\t\t//throw iim::IOException(strprintf(\"in IOManager::readTiffMultipage(...): Undefined bits per sample in %s \\n\", finName).c_str());\r\n\t\treturn ((char *) \"Undefined bits per sample.\");\r\n\t}\r\n\r\n\tcheck=TIFFGetField(input, TIFFTAG_SAMPLESPERPIXEL, &spp);\r\n\tif (!check)\r\n\t{\r\n\t\tspp = 1;\r\n\t\t//TIFFClose(input);\r\n\t\t//throw iim::IOException(strprintf(\"in IOManager::readTiffMultipage(...): Undefined bits per sample in %s \\n\", finName).c_str());\r\n\t\t//return ((char *) \"Undefined samples per pixel.\");\r\n\t}\r\n\r\n\t// 2021-02-10. Giulio. when it is compiled as a Vaa3D plugin does not check the tag TIFFTAG_PAGENUMBER to avoid exceptions on inconsistent files  \r\n\t#ifdef _VAA3D_TERAFLY_PLUGIN_MODE\r\n\tcheck = 0;\r\n\t#else\r\n\t// Onofri\r\n\tcheck=TIFFGetField(input, TIFFTAG_PAGENUMBER, &Cpage, &Npages);\r\n\t#endif\r\n\tif (check!=1 || Npages==0) { // the tag has not been read correctly\r\n\t\t// Add warning?\r\n\t\tNpages = 0;\r\n\t\tdo {\r\n\t\t\tNpages++;\r\n\t\t} while ( TIFFReadDirectory(input) );\r\n\t}\r\n\r\n\tsz0 = XSIZE;\r\n\tsz1 = YSIZE;\r\n\tsz2 = Npages;\r\n\tsz3 = spp;\r\n\tdatatype = bpp/8;\r\n\r\n\t//b_swap = 0;\r\n\tb_swap=TIFFIsByteSwapped(input);\r\n\tfhandle = (void *) input;\r\n\theader_len = -1;\r\n\r\n\t// the file must non be closed (it is responsibility of the caller)\r\n\t//TIFFClose(input);\r\n\r\n    // 2015-01-30. Alessandro. @ADDED performance (time) measurement in all most time-consuming methods.\r\n    #ifdef _VAA3D_TERAFLY_PLUGIN_MODE\r\n    TERAFLY_TIME_STOP(TiffLoadMetadata, tf::IO, tf::strprintf(\"successfully loaded metadata from file \\\"%s\\\"\", filename))\r\n    #endif\r\n\r\n\treturn ((char *) 0);\r\n}",
    "char *openTiff3DFile ( char *filename, char *mode, void *&fhandle, bool reopen ) {\r\n\tchar *completeFilename = (char *) 0;\r\n\tchar *completeMode     = (char *) 0;\r\n\tint fname_len = (int) strlen(filename);\r\n\tchar *suffix = strstr(filename,\".tif\");\r\n\twhile ( suffix && (fname_len - (suffix-filename) > 5) )\r\n\t\tsuffix = strstr(suffix+4,\".tif\");\r\n\t//if ( (suffix != 0) && (fname_len - (suffix-filename) <= 5) ) { // a substring \".tif is already at the end of the filename\r\n\tif ( suffix ) { // a substring \".tif is already at the very end of the filename\r\n\t\tcompleteFilename = new char[fname_len+1];\r\n\t\tstrcpy(completeFilename,filename);\r\n\t}\r\n\telse {\t\r\n\t\tcompleteFilename = new char[fname_len+4+1];\r\n\t\tstrcpy(completeFilename,filename);\r\n\t\tstrcat(completeFilename,\".\");\r\n\t\tstrcat(completeFilename,TIFF3D_SUFFIX);\r\n\t}\r\n\r\n\t//disable warning and error handlers to avoid messages on unrecognized tags\r\n\tTIFFSetWarningHandler(0);\r\n\tTIFFSetErrorHandler(0);\r\n\r\n\t// if mode is 'w' and reopen is true check if the file esists\r\n\tbool mybigtiff = bigtiff;\r\n\tif ( mode[0] == 'w' && reopen ) {\r\n\t\tfhandle = TIFFOpen(completeFilename,\"r\");\r\n\t\tif ( fhandle ) {\r\n#ifndef _VAA3D_TERAFLY_PLUGIN_MODE\r\n\t\t\t// get the file format (classic tiff of bigtiff)\r\n\t\t\tif ( ((TIFF *) fhandle)->tif_flags&TIFF_BIGTIFF ) \r\n                mybigtiff = true;\r\n#endif\r\n\t\t\tTIFFClose((TIFF *) fhandle);\r\n\t\t}\r\n\t}\r\n\r\n\tif ( mybigtiff && !strstr(mode,\"8\") ) {\r\n\t\tcompleteMode = new char[strlen(mode)+2];\r\n\t\tstrcpy(completeMode,mode);\r\n\t\tstrcat(completeMode,\"8\");\r\n\t}\r\n\telse {\r\n\t\tcompleteMode = new char[strlen(mode)+2];\r\n\t\tstrcpy(completeMode,mode);\r\n\t}\r\n\r\n\tfhandle = TIFFOpen(completeFilename,completeMode);\r\n\r\n\tdelete completeFilename;\r\n\tdelete completeMode;\r\n\r\n\tif (!fhandle)\r\n    {\r\n\t\treturn ((char *) \"Cannot open the file.\");\r\n    }\r\n\treturn ((char *) 0);\r\n}",
    "void closeTiff3DFile ( void *fhandle ) {\r\n\tTIFFClose((TIFF *) fhandle);\r\n}",
    "char *initTiff3DFile ( char *filename, unsigned int sz0, unsigned int sz1, unsigned int sz2, unsigned int sz3, int datatype ) {\r\n//int initTiff3DFile ( char *filename, uint32 XSIZE, uint32 YSIZE, uint16 spp, uint16 Npages, int datatype){\r\n\r\n    // 2015-01-30. Alessandro. @ADDED performance (time) measurement in all most time-consuming methods.\r\n    #ifdef _VAA3D_TERAFLY_PLUGIN_MODE\r\n    TERAFLY_TIME_START(TiffInitData)\r\n    #endif\r\n\r\n\tuint32 XSIZE  = sz0;\r\n\tuint32 YSIZE  = sz1;\r\n\tuint16 Npages = sz2;\r\n\tuint16 spp    = sz3;\r\n\r\n\tuint16 bpp=8 * datatype;\r\n\t\r\n\tint check;\r\n \r\n\tif ( sz3 == 1 )\r\n\t\tspp = sz3; \r\n\telse if ( sz3 < 4 )\r\n\t\tspp = 3;\r\n\telse\r\n\t\treturn ((char *) \"More than 3 channels in Tiff files.\");\r\n\r\n\tunsigned char *fakeData=new unsigned char[((iim::sint64) XSIZE) * ((iim::sint64) YSIZE) * spp * (bpp/8)];\r\n\r\n\tchar *completeFilename = (char *) 0;\r\n\tint fname_len = (int) strlen(filename);\r\n\tchar *suffix = strstr(filename,\".tif\");\r\n\twhile ( suffix && (fname_len - (suffix-filename) > 5) )\r\n\t\tsuffix = strstr(suffix+4,\".tif\");\r\n\t//if ( (suffix != 0) && (fname_len - (suffix-filename) <= 5) ) { // a substring \".tif is already at the end of the filename\r\n\tif ( suffix ) { // a substring \".tif is already at the very end of the filename\r\n\t\tcompleteFilename = new char[fname_len+1];\r\n\t\tstrcpy(completeFilename,filename);\r\n\t}\r\n\telse {\t\r\n\t\tcompleteFilename = new char[fname_len+4+1];\r\n\t\tstrcpy(completeFilename,filename);\r\n\t\tstrcat(completeFilename,\".\");\r\n\t\tstrcat(completeFilename,TIFF3D_SUFFIX);\r\n\t}\r\n\r\n\r\n\t// 2015-01-30. Alessandro. @ADDED performance (time) measurement in all most time-consuming methods.\r\n    #ifdef _VAA3D_TERAFLY_PLUGIN_MODE\r\n    TERAFLY_TIME_STOP(TiffInitData, tf::CPU, tf::strprintf(\"generated fake data for 3D tiff \\\"%s\\\"\", completeFilename))\r\n    TERAFLY_TIME_RESTART(TiffInitData)\r\n    #endif\r\n\r\n\t//disable warning and error handlers to avoid messages on unrecognized tags\r\n\tTIFFSetWarningHandler(0);\r\n\tTIFFSetErrorHandler(0);\r\n\r\n\tTIFF *output;\r\n\t\r\n\tiim::sint64 expectedSize = ((iim::sint64) sz0) * ((iim::sint64) sz1) * ((iim::sint64) sz2) * ((iim::sint64) sz3) * ((iim::sint64) datatype); \r\n\r\n\tif ( bigtiff || expectedSize > (4*GBSIZE) ) {\r\n\t\tif ( (rowsPerStrip == -1 && (((iim::sint64) sz0) * ((iim::sint64) sz1)) > (4*GBSIZE)) || ((rowsPerStrip * ((iim::sint64) sz0)) > (4*GBSIZE)) )\r\n\t\t\t// one strip is larger than 4GB\r\n\t\t\treturn ((char *) \"Too many rows per strip for this image width.\");\r\n\t\telse \r\n\t\t\toutput = TIFFOpen(completeFilename,\"w8\");\r\n\t}\r\n\telse\r\n\t\toutput = TIFFOpen(completeFilename,\"w\");\r\n\r\n\r\n\tif (!output) {\r\n\t\tdelete completeFilename;\r\n\t\treturn ((char *) \"Cannot open the file.\");\r\n    }\r\n\r\n\tcheck = TIFFSetField(output, TIFFTAG_IMAGEWIDTH, XSIZE);\r\n\tif (!check) {\r\n\t\tdelete completeFilename;\r\n\t\treturn ((char *) \"Cannot set the image width.\");\r\n    }\r\n\r\n\tcheck = TIFFSetField(output, TIFFTAG_IMAGELENGTH, YSIZE);\r\n\tif (!check) {\r\n\t\tdelete completeFilename;\r\n\t\treturn ((char *) \"Cannot set the image height.\");\r\n    }\r\n\r\n\tcheck = TIFFSetField(output, TIFFTAG_BITSPERSAMPLE, bpp); \r\n\tif (!check) {\r\n\t\tdelete completeFilename;\r\n\t\treturn ((char *) \"Cannot set the image bit per sample.\");\r\n    }\r\n\r\n\tcheck = TIFFSetField(output, TIFFTAG_SAMPLESPERPIXEL, spp);\r\n\tif (!check) {\r\n\t\tdelete completeFilename;\r\n\t\treturn ((char *) \"Cannot set the image sample per pixel.\");\r\n    }\r\n\r\n\tcheck = TIFFSetField(output, TIFFTAG_ROWSPERSTRIP, (rowsPerStrip == -1) ? YSIZE : (uint32)rowsPerStrip); \r\n\tif (!check) {\r\n\t\tdelete completeFilename;\r\n\t\treturn ((char *) \"Cannot set the image rows per strip.\");\r\n    }\r\n\r\n\tcheck = TIFFSetField(output, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT); \r\n\tif (!check) {\r\n\t\tdelete completeFilename;\r\n\t\treturn ((char *) \"Cannot set the image orientation.\");\r\n    }\r\n\r\n\tcheck = TIFFSetField(output, TIFFTAG_COMPRESSION, compressed ? COMPRESSION_LZW : COMPRESSION_NONE);\r\n\tif (!check) {\r\n\t\tdelete completeFilename;\r\n\t\treturn ((char *) \"Cannot set the compression tag.\");\r\n    }\r\n\r\n\tcheck = TIFFSetField(output, TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG);\r\n\tif (!check) {\r\n\t\tdelete completeFilename;\r\n\t\treturn ((char *) \"Cannot set the planarconfig tag.\");\r\n    }\r\n\r\n\tif ( spp == 1 )\r\n\t\tcheck = TIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\t\r\n\telse // spp == 3\r\n\t\tcheck = TIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\t\r\n\tif (!check) {\r\n\t\tdelete completeFilename;\r\n\t\treturn ((char *) \"Cannot set the photometric tag.\");\r\n    }\r\n\r\n\t/* We are writing single page of the multipage file */\r\n\tcheck = TIFFSetField(output, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE);\r\n\tif (!check) {\r\n\t\tdelete completeFilename;\r\n\t\treturn ((char *) \"Cannot set the subfiletype tag.\");\r\n    }\r\n\r\n\tcheck = TIFFSetField(output, TIFFTAG_PAGENUMBER, 0, Npages); \r\n\tif (!check) {\r\n\t\tdelete completeFilename;\r\n\t\treturn ((char *) \"Cannot set the page number.\");\r\n    }\r\n\r\n\r\n\t//check = (int)TIFFWriteEncodedStrip(output, 0, fakeData, XSIZE * YSIZE);\r\n\t//if (!check) {\r\n\t//\tdelete completeFilename;\r\n\t//\treturn ((char *) \"Cannot write encoded strip to file.\");\r\n //   }\r\n\r\n\tif ( rowsPerStrip == -1 ) {\r\n\t\tcheck = TIFFWriteEncodedStrip(output, 0, fakeData, XSIZE * YSIZE * spp * (bpp/8));\r\n\t\tif (!check) {\r\n\t\t\tdelete completeFilename;\r\n\t\t\treturn ((char *) \"Cannot write encoded strip to file.\");\r\n\t\t}\r\n\t}\r\n\telse { \r\n\t\tint check,StripsPerImage,LastStripSize;\r\n\t\tuint32 rps = (uint32)rowsPerStrip;\r\n\t\tunsigned char *buf = fakeData;\r\n\r\n\t\tStripsPerImage =  (YSIZE + rps - 1) / rps;\r\n\t\tLastStripSize = YSIZE % rps;\r\n\t\tif (LastStripSize==0)\r\n\t\t\tLastStripSize=rps;\r\n\r\n\t\tfor (int i=0; i < StripsPerImage-1; i++){\r\n\t\t\tcheck = TIFFWriteEncodedStrip(output, i, buf, spp * rps * XSIZE * (bpp/8));\r\n\t\t\tif (!check) {\r\n\t\t\t\tdelete completeFilename;\r\n\t\t\t\treturn ((char *) \"Cannot write encoded strip to file.\");\r\n\t\t\t}\r\n\t\t\tbuf = buf + spp * rps * XSIZE * (bpp/8);\r\n\t\t}\r\n\r\n\t\tcheck = TIFFWriteEncodedStrip(output, StripsPerImage-1, buf, spp * LastStripSize * XSIZE * (bpp/8));\r\n\t\tif (!check) {\r\n\t\t\tdelete completeFilename;\r\n\t\t\treturn ((char *) \"Cannot write encoded strip to file.\");\r\n\t\t}\r\n\t\t//}\r\n\t\tbuf = buf + spp * LastStripSize * XSIZE * (bpp/8);\r\n\t}\r\n\r\n\tdelete[] fakeData;\r\n\r\n\tcheck = TIFFWriteDirectory(output);\r\n\tif (!check) {\r\n\t\tdelete completeFilename;\r\n\t\treturn ((char *) \"Cannot write a new directory.\");\r\n    }\r\n\r\n\tTIFFClose(output);\r\n\r\n    // 2015-01-30. Alessandro. @ADDED performance (time) measurement in all most time-consuming methods.\r\n    #ifdef _VAA3D_TERAFLY_PLUGIN_MODE\r\n    TERAFLY_TIME_STOP(TiffInitData, tf::IO, tf::strprintf(\"written initialized 3D tiff \\\"%s\\\"\", completeFilename))\r\n    #endif\r\n\r\n\tdelete completeFilename;\r\n\r\n\treturn (char *) 0;\r\n}",
    "char *appendSlice2Tiff3DFile ( char *filename, int slice, unsigned char *img, unsigned int img_width, unsigned int img_height ) {\r\n    // 2015-01-30. Alessandro. @ADDED performance (time) measurement in all most time-consuming methods.\r\n    #ifdef _VAA3D_TERAFLY_PLUGIN_MODE\r\n    TERAFLY_TIME_START(TiffAppendData)\r\n    #endif\r\n\r\n\tTIFF *output;\r\n\tuint16 spp, bpp, NPages, pg0;\r\n\tuint32 rperstrip;\r\n\tuint16 cmprssd;\r\n\tuint16 photomtrcintrp;\r\n\r\n\t//disable warning and error handlers to avoid messages on unrecognized tags\r\n\tTIFFSetWarningHandler(0);\r\n\tTIFFSetErrorHandler(0);\r\n\r\n\toutput=TIFFOpen(filename,\"r\");\r\n\tTIFFGetField(output, TIFFTAG_BITSPERSAMPLE, &bpp); \r\n\tTIFFGetField(output, TIFFTAG_SAMPLESPERPIXEL, &spp);\r\n\tTIFFGetField(output, TIFFTAG_PAGENUMBER, &pg0, &NPages);\r\n\tTIFFGetField(output, TIFFTAG_ROWSPERSTRIP, &rperstrip);\r\n\tTIFFGetField(output, TIFFTAG_COMPRESSION, &cmprssd);\r\n\tTIFFGetField(output, TIFFTAG_PHOTOMETRIC, &photomtrcintrp);\r\n\tTIFFClose(output);\r\n\r\n\tiim::sint64 expectedSize = ((iim::sint64) img_width) * ((iim::sint64) img_height) * ((iim::sint64) NPages) * ((iim::sint64) spp) * ((iim::sint64) (bpp/8)); \r\n\r\n\tif ( bigtiff || expectedSize > (4*GBSIZE) ) {\r\n\t\tif ( (rowsPerStrip == -1 && (((iim::sint64) img_width) * ((iim::sint64) img_height)) > (4*GBSIZE)) || ((rowsPerStrip * ((iim::sint64) img_width)) > (4*GBSIZE)) )\r\n\t\t\t// one strip is larger than 4GB\r\n\t\t\treturn ((char *) \"Too many rows per strip for this image width.\");\r\n\t\telse \r\n\t\t\toutput = (slice==0)? TIFFOpen(filename,\"w8\") : TIFFOpen(filename,\"a8\");\r\n\t}\r\n\telse\r\n\t\toutput = (slice==0)? TIFFOpen(filename,\"w\") : TIFFOpen(filename,\"a\");\r\n\r\n\tTIFFSetDirectory(output,slice); // WARNING: slice must be the first page after the last, otherwise the file can be corrupted\r\n\r\n\tTIFFSetField(output, TIFFTAG_IMAGEWIDTH, img_width);\r\n\tTIFFSetField(output, TIFFTAG_IMAGELENGTH, img_height);\r\n\tTIFFSetField(output, TIFFTAG_BITSPERSAMPLE, bpp); \r\n\tTIFFSetField(output, TIFFTAG_SAMPLESPERPIXEL, spp);\r\n\tTIFFSetField(output, TIFFTAG_ROWSPERSTRIP, rperstrip);\r\n\tTIFFSetField(output, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\r\n\tTIFFSetField(output, TIFFTAG_COMPRESSION, cmprssd);\r\n\tTIFFSetField(output, TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG);\r\n\tTIFFSetField(output, TIFFTAG_PHOTOMETRIC, photomtrcintrp);\t\r\n\t// We are writing single page of the multipage file \r\n\tTIFFSetField(output, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE);\r\n\tTIFFSetField(output, TIFFTAG_PAGENUMBER, (uint16)slice, NPages); \r\n\r\n\tif ( rowsPerStrip == -1 ) \r\n\t\tTIFFWriteEncodedStrip(output, 0, img, img_width * img_height * spp * (bpp/8));\r\n\telse { \r\n\t\tint check,StripsPerImage,LastStripSize;\r\n\t\tuint32 rps = rperstrip;\r\n\t\tunsigned char *buf = img;\r\n\r\n\t\tStripsPerImage =  (img_height + rps - 1) / rps;\r\n\t\tLastStripSize = img_height % rps;\r\n\t\tif (LastStripSize==0)\r\n\t\t\tLastStripSize=rps;\r\n\r\n\t\tfor (int i=0; i < StripsPerImage-1; i++){\r\n\t\t\tTIFFWriteEncodedStrip(output, i, buf, spp * rps * img_width * (bpp/8));\r\n\t\t\tbuf = buf + spp * rps * img_width * (bpp/8);\r\n\t\t}\r\n\r\n\t\tTIFFWriteEncodedStrip(output, StripsPerImage-1, buf, spp * LastStripSize * img_width * (bpp/8));\r\n\t\tbuf = buf + spp * LastStripSize * img_width * (bpp/8);\r\n\t}\r\n\t//img +=  img_width * img_height;\r\n\r\n\tTIFFWriteDirectory(output);\r\n\r\n\tTIFFClose(output);\r\n\r\n    // 2015-01-30. Alessandro. @ADDED performance (time) measurement in all most time-consuming methods.\r\n    #ifdef _VAA3D_TERAFLY_PLUGIN_MODE\r\n    TERAFLY_TIME_STOP(TiffAppendData, tf::IO, tf::strprintf(\"appended slice %d x %d to 3D tiff \\\"%s\\\"\", img_width, img_height, filename))\r\n    #endif\r\n\r\n\treturn (char *) 0;\r\n}",
    "char *readTiff3DFile2Buffer ( char *filename, unsigned char *img, unsigned int img_width, unsigned int img_height, unsigned int first, unsigned int last, \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  int downsamplingFactor, int starti, int endi, int startj, int endj ) {\r\n\r\n    // 2015-01-30. Alessandro. @ADDED performance (time) measurement in all most time-consuming methods.\r\n    #ifdef _VAA3D_TERAFLY_PLUGIN_MODE\r\n    TERAFLY_TIME_START(TiffLoadData)\r\n    #endif\r\n\r\n    TIFF *input;\r\n\r\n\t//disable warning and error handlers to avoid messages on unrecognized tags\r\n\tTIFFSetWarningHandler(0);\r\n\tTIFFSetErrorHandler(0);\r\n\r\n\tinput=TIFFOpen(filename,\"r\");\r\n\tif (!input)\r\n    {\r\n\t\t//throw iim::IOException(strprintf(\"in IOManager::readTiffMultipage(...): Cannot open the file %s\",finName).c_str());\r\n\t\treturn ((char *) \"Cannot open the file.\");\r\n    }\r\n    \r\n\tint b_swap=TIFFIsByteSwapped(input);\r\n\tchar *err_msg = readTiff3DFile2Buffer(input,img,img_width,img_height,first,last,b_swap,downsamplingFactor,starti,endi,startj,endj);\r\n\r\n\tTIFFClose(input);\r\n\r\n    // 2015-01-30. Alessandro. @ADDED performance (time) measurement in all most time-consuming methods.\r\n    #ifdef _VAA3D_TERAFLY_PLUGIN_MODE\r\n    TERAFLY_TIME_STOP(TiffLoadData, tf::IO, tf::strprintf(\"loaded block x(%d), y(%d), z(%d-%d) from 3D tiff \\\"%s\\\"\", img_width, img_height, first, last, filename))\r\n    #endif\r\n\r\n\treturn err_msg;\r\n}",
    "void \r\n\tiomanager::tiff3D::readMetadata(\r\n\tstd::string img_path,\t\t// (INPUT)\timage filepath\r\n\tint & img_width,\t\t\t// (OUTPUT) image width  (in pixels)\r\n\tint & img_height,\t\t\t// (OUTPUT) image height (in pixels)\r\n\tint & img_depth,\t\t\t// (OUTPUT) image depth (in pixels)\r\n\tint & img_bytes_x_chan,\t// (OUTPUT) number of bytes per channel\r\n\tint & img_chans,\t\t\t// (OUTPUT) number of channels\r\n\tconst std::string & params)\t// (INPUT)\tadditional parameters <param1=val, param2=val, ...> \r\nthrow (iom::exception)\r\n{\r\n\t/**/iom::debug(iom::LEV3, iom::strprintf(\"img_path = %s, img_width = %d, img_height = %d, img_depth = %d, img_bytes_x_chan = %d, img_chans = %d, params = \\\"%s\\\"\",\r\n\t\timg_path.c_str(), img_width, img_height, img_depth,\timg_bytes_x_chan, img_chans, params.c_str()).c_str(), __iom__current__function__);\r\n\r\n\t//disable warning and error handlers to avoid messages on unrecognized tags\r\n\tTIFFSetWarningHandler(0);\r\n\tTIFFSetErrorHandler(0);\r\n\r\n\tTIFF* input=TIFFOpen(img_path.c_str(),\"r\");\r\n\tif (!input)\r\n\t\tthrow iom::exception(iom::strprintf(\"unable to open image \\\"%s\\\". Possible unsupported format or it isn't an image.\\nSupported format is 3DTIFF\", img_path.c_str()), __iom__current__function__);\r\n\r\n\tif (!TIFFGetField(input, TIFFTAG_IMAGEWIDTH, &img_width))\r\n\t\tthrow iom::exception(iom::strprintf(\"unable to determine 'TIFFTAG_IMAGEWIDTH' from image \\\"%s\\\". \", img_path.c_str()), __iom__current__function__);\r\n\r\n\tif (!TIFFGetField(input, TIFFTAG_IMAGELENGTH, &img_height))\r\n\t\tthrow iom::exception(iom::strprintf(\"unable to determine 'TIFFTAG_IMAGELENGTH' from image \\\"%s\\\". \", img_path.c_str()), __iom__current__function__);\r\n\r\n\tif (!TIFFGetField(input, TIFFTAG_BITSPERSAMPLE, &img_bytes_x_chan))\r\n\t\tthrow iom::exception(iom::strprintf(\"unable to determine 'TIFFTAG_BITSPERSAMPLE' from image \\\"%s\\\". \", img_path.c_str()), __iom__current__function__);\r\n\timg_bytes_x_chan /= 8;\r\n\r\n\tif (!TIFFGetField(input, TIFFTAG_SAMPLESPERPIXEL, &img_chans)) \r\n\t\timg_chans = 1;\r\n\t\t//throw iom::exception(iom::strprintf(\"unable to determine 'TIFFTAG_SAMPLESPERPIXEL' from image \\\"%s\\\". \", img_path.c_str()), __iom__current__function__);\r\n\r\n\t// Onofri\r\n\tuint16 cpage;  // Current page. We do not actually need it.\r\n\tuint16 npages; // Number of pages. \r\n\tint PNcheck=TIFFGetField(input, TIFFTAG_PAGENUMBER, &cpage, &npages);\r\n\tif (!PNcheck || npages==0) { // the tag has not been read correctly\r\n\t\t//iom::warning(iom::strprintf(\"unable to determine 'TIFFTAG_PAGENUMBER' from image file \\\"%s\\\". \", img_path.c_str()).c_str(),__iom__current__function__);\r\n\t\timg_depth = 0;\r\n\t\tdo {\r\n\t\t\timg_depth++;\r\n\t\t} while (TIFFReadDirectory(input));\r\n\t}\r\n\telse\r\n\t\timg_depth = npages;\r\n\r\n\tTIFFClose(input);\r\n}",
    "void \r\n\tiomanager::tiff2D::readMetadata(\r\n\tstd::string img_path,\t\t\t// (INPUT)  image filepath\r\n\tint & img_width,\t\t\t\t// (OUTPUT) image width  (in pixels)\r\n\tint & img_height,\t\t\t\t// (OUTPUT) image height (in pixels)\r\n\tint & img_bytes_x_chan,\t\t\t// (OUTPUT) number of bytes per channel\r\n\tint & img_chans,\t\t\t\t// (OUTPUT) number of channels\r\n\tconst std::string & params)\t\t// (INPUT)  additional parameters <param1=val, param2=val, ...> \r\nthrow (iom::exception)\r\n{\r\n\t/**/iom::debug(iom::LEV3, iom::strprintf(\"img_path = \\\"%s\\\", params = \\\"%s\\\"\",img_path.c_str(), params.c_str()).c_str(), __iom__current__function__);\r\n\r\n\tuint16 bpp;\r\n\tuint16 spp;\r\n\r\n\t//disable warning and error handlers to avoid messages on unrecognized tags\r\n\tTIFFSetWarningHandler(0);\r\n\tTIFFSetErrorHandler(0);\r\n\r\n\tTIFF* input=TIFFOpen(img_path.c_str(),\"r\");\r\n\tif (!input)\r\n\t\tthrow iom::exception(iom::strprintf(\"unable to open image \\\"%s\\\". Possible unsupported format or it isn't an image.\\nSupported format is 2DTIFF\", img_path.c_str()), __iom__current__function__);\r\n\r\n\tif (!TIFFGetField(input, TIFFTAG_IMAGEWIDTH, &img_width))\r\n\t\tthrow iom::exception(iom::strprintf(\"unable to determine 'TIFFTAG_IMAGEWIDTH' from image \\\"%s\\\". \", img_path.c_str()), __iom__current__function__);\r\n\r\n\tif (!TIFFGetField(input, TIFFTAG_IMAGELENGTH, &img_height))\r\n\t\tthrow iom::exception(iom::strprintf(\"unable to determine 'TIFFTAG_IMAGELENGTH' from image \\\"%s\\\". \", img_path.c_str()), __iom__current__function__);\r\n\r\n\tif (!TIFFGetField(input, TIFFTAG_BITSPERSAMPLE, &bpp))\r\n\t\tthrow iom::exception(iom::strprintf(\"unable to determine 'TIFFTAG_BITSPERSAMPLE' from image \\\"%s\\\". \", img_path.c_str()), __iom__current__function__);\r\n\timg_bytes_x_chan = bpp/8;\r\n\r\n\tif (!TIFFGetField(input, TIFFTAG_SAMPLESPERPIXEL, &spp)) \r\n\t\tspp = 1;\r\n\t\t//throw iom::exception(iom::strprintf(\"unable to determine 'TIFFTAG_SAMPLESPERPIXEL' from image \\\"%s\\\". \", img_path.c_str()), __iom__current__function__);\r\n\timg_chans = spp;\r\n\r\n\t// Onofri\r\n\tint img_depth;\t\t\t// image depth (in pixels)\r\n\tuint16 cpage;  // Current page. We do not actually need it.\r\n\tuint16 npages; // Number of pages. \r\n\tint PNcheck=TIFFGetField(input, TIFFTAG_PAGENUMBER, &cpage, &npages);\r\n\tif (!PNcheck || npages==0) { // the tag has not been read correctly\r\n\t\t//iom::warning(iom::strprintf(\"unable to determine 'TIFFTAG_PAGENUMBER' from image file \\\"%s\\\". \", img_path.c_str()).c_str(),__iom__current__function__);\r\n\t\timg_depth = 0;\r\n\t\tdo {\r\n\t\t\timg_depth++;\r\n\t\t} while (TIFFReadDirectory(input));\r\n\t}\r\n\telse\r\n\t\timg_depth = npages;\r\n\r\n\tTIFFClose(input);\r\n\t\r\n\t// check the exception after closing the file\r\n\tif ( img_depth > 1 ) \r\n\t\tthrow iom::exception(iom::strprintf(\"image \\\"%s\\\" has more than one page.\\nSupported format is 2DTIFF\", img_path.c_str()), __iom__current__function__);\r\n}",
    "OIIO_NAMESPACE_USING\n\nnamespace bioexplorer\n{\nnamespace mediamaker\n{\nusing namespace core;\n// Number of floats used to define the camera\nconst size_t CAMERA_DEFINITION_SIZE = 12;\n\n#define CATCH_STD_EXCEPTION()           \\\n    catch (const std::runtime_error &e) \\\n    {                                   \\\n        response.status = false;        \\\n        response.contents = e.what();   \\\n        PLUGIN_ERROR << e.what() );     \\\n    }\n\nvoid _addDepthRenderer(core::Engine &engine)\n{\n    PLUGIN_REGISTER_RENDERER(RENDERER_DEPTH);\n    core::PropertyMap properties;\n    properties.setProperty(MEDIA_MAKER_RENDERER_PROPERTY_DEPTH_INFINITY);\n    engine.addRendererType(RENDERER_DEPTH, properties);\n}\n\nvoid _addAlbedoRenderer(core::Engine &engine)\n{\n    PLUGIN_REGISTER_RENDERER(RENDERER_ALBEDO);\n    core::PropertyMap properties;\n    properties.setProperty(RENDERER_PROPERTY_MAX_RAY_DEPTH);\n    auto &params = engine.getParametersManager().getApplicationParameters();\n    const auto &engineName = params.getEngine();\n    if (engineName == ENGINE_OSPRAY)\n        properties.setProperty(COMMON_PROPERTY_USE_HARDWARE_RANDOMIZER);\n    engine.addRendererType(RENDERER_ALBEDO, properties);\n}\n\nvoid _addAmbientOcclusionRenderer(core::Engine &engine)\n{\n    PLUGIN_REGISTER_RENDERER(RENDERER_AMBIENT_OCCLUSION);\n    core::PropertyMap properties;\n    auto samples = RENDERER_PROPERTY_GLOBAL_ILLUMINATION_SAMPLES;\n    samples.set(16);\n    properties.setProperty(samples);\n    properties.setProperty(RENDERER_PROPERTY_GLOBAL_ILLUMINATION_RAY_LENGTH);\n    properties.setProperty(RENDERER_PROPERTY_MAX_RAY_DEPTH);\n    auto &params = engine.getParametersManager().getApplicationParameters();\n    const auto &engineName = params.getEngine();\n    if (engineName == ENGINE_OSPRAY)\n        properties.setProperty(COMMON_PROPERTY_USE_HARDWARE_RANDOMIZER);\n    properties.setProperty(COMMON_PROPERTY_USE_HARDWARE_RANDOMIZER);\n    engine.addRendererType(RENDERER_AMBIENT_OCCLUSION, properties);\n}\n\nvoid _addShadowRenderer(core::Engine &engine)\n{\n    PLUGIN_REGISTER_RENDERER(RENDERER_SHADOW);\n    core::PropertyMap properties;\n    properties.setProperty(RENDERER_PROPERTY_SHADOW_SAMPLES);\n    properties.setProperty(RENDERER_PROPERTY_GLOBAL_ILLUMINATION_RAY_LENGTH);\n    properties.setProperty(RENDERER_PROPERTY_SOFT_SHADOW_STRENGTH);\n    engine.addRendererType(RENDERER_SHADOW, properties);\n}\n\nvoid _addRadianceRenderer(core::Engine &engine)\n{\n    PLUGIN_REGISTER_RENDERER(RENDERER_RADIANCE);\n    core::PropertyMap properties;\n    engine.addRendererType(RENDERER_RADIANCE, properties);\n}\n\nMediaMakerPlugin::MediaMakerPlugin()\n    : ExtensionPlugin()\n{\n}\n\nvoid MediaMakerPlugin::init()\n{\n    auto actionInterface = _api->getActionInterface();\n    if (actionInterface)\n    {\n        std::string entryPoint = PLUGIN_API_PREFIX + \"version\";\n        PLUGIN_REGISTER_ENDPOINT(entryPoint);\n        actionInterface->registerRequest<Response>(entryPoint, [&]() { return _version(); });\n\n        entryPoint = PLUGIN_API_PREFIX + \"set-odu-camera\";\n        PLUGIN_REGISTER_ENDPOINT(entryPoint);\n        actionInterface->registerNotification<CameraDefinition>(entryPoint,\n                                                                [&](const CameraDefinition &s) { _setCamera(s); });\n\n        entryPoint = PLUGIN_API_PREFIX + \"get-odu-camera\";\n        PLUGIN_REGISTER_ENDPOINT(entryPoint);\n        actionInterface->registerRequest<CameraDefinition>(entryPoint,\n                                                           [&]() -> CameraDefinition { return _getCamera(); });\n\n        entryPoint = PLUGIN_API_PREFIX + \"export-frames-to-disk\";\n        PLUGIN_REGISTER_ENDPOINT(entryPoint);\n        actionInterface->registerNotification<ExportFramesToDisk>(entryPoint, [&](const ExportFramesToDisk &s)\n                                                                  { _exportFramesToDisk(s); });\n\n        entryPoint = PLUGIN_API_PREFIX + \"get-export-frames-progress\";\n        PLUGIN_REGISTER_ENDPOINT(entryPoint);\n        actionInterface->registerRequest<FrameExportProgress>(entryPoint,\n                                                              [&](void) -> FrameExportProgress\n                                                              { return _getFrameExportProgress(); });\n\n        entryPoint = PLUGIN_API_PREFIX + \"attach-odu-camera-handler\";\n        PLUGIN_REGISTER_ENDPOINT(entryPoint);\n        actionInterface->registerNotification<CameraHandlerDetails>(entryPoint, [&](const CameraHandlerDetails &s)\n                                                                    { _attachCameraHandler(s); });\n    }\n\n    auto &engine = _api->getEngine();\n    auto &params = engine.getParametersManager().getApplicationParameters();\n    const auto &engineName = params.getEngine();\n#ifdef USE_OPTIX6\n    if (engineName == ENGINE_OPTIX_6)\n    {\n        _createOptiXRenderers();\n        _createRenderers();\n    }\n#endif\n    if (engineName == ENGINE_OSPRAY)\n        _createRenderers();\n}\n\n#ifdef USE_OPTIX6\nvoid MediaMakerPlugin::_createOptiXRenderers()\n{\n    std::map<std::string, std::string> renderers = {\n        {RENDERER_ALBEDO, MediaMaker_generated_Albedo_cu_ptx},\n        {RENDERER_SHADING_NORMAL, MediaMaker_generated_ShadingNormal_cu_ptx},\n        {RENDERER_GEOMETRY_NORMAL, MediaMaker_generated_GeometryNormal_cu_ptx},\n        {RENDERER_AMBIENT_OCCLUSION, MediaMaker_generated_AmbientOcclusion_cu_ptx},\n        {RENDERER_SHADOW, MediaMaker_generated_Shadow_cu_ptx},\n        {RENDERER_DEPTH, MediaMaker_generated_Depth_cu_ptx},\n        {RENDERER_RADIANCE, MediaMaker_generated_Radiance_cu_ptx},\n    };\n    ::core::engine::optix::OptiXContext &context = ::core::engine::optix::OptiXContext::get();\n    for (const auto &renderer : renderers)\n    {\n        PLUGIN_REGISTER_RENDERER(renderer.first);\n        const std::string ptx = renderer.second;\n\n        auto osp = std::make_shared<::core::engine::optix::OptixShaderProgram>();\n        osp->closest_hit = context.getOptixContext()->createProgramFromPTXString(\n            ptx, ::core::engine::optix::OPTIX_CUDA_FUNCTION_CLOSEST_HIT_RADIANCE);\n        osp->closest_hit_textured = context.getOptixContext()->createProgramFromPTXString(\n            ptx, ::core::engine::optix::OPTIX_CUDA_FUNCTION_CLOSEST_HIT_RADIANCE_TEXTURED);\n        osp->any_hit = context.getOptixContext()->createProgramFromPTXString(\n            ptx, ::core::engine::optix::OPTIX_CUDA_FUNCTION_ANY_HIT_SHADOW);\n\n        context.addRenderer(renderer.first, osp);\n    }\n}\n#endif\n\nvoid MediaMakerPlugin::_setCamera(const CameraDefinition &payload)\n{\n    auto &camera = _api->getCamera();\n    setCamera(cameraDefinitionToKeyFrame(payload), camera);\n}\n\nCameraDefinition MediaMakerPlugin::_getCamera()\n{\n    auto &camera = _api->getCamera();\n    const auto keyFrame = getCameraKeyFrame(camera);\n    return keyFrameToCameraDefinition(keyFrame);\n}\n\nvoid MediaMakerPlugin::_createRenderers()\n{\n    auto &engine = _api->getEngine();\n    _addAlbedoRenderer(engine);\n    _addDepthRenderer(engine);\n    _addAmbientOcclusionRenderer(engine);\n    _addShadowRenderer(engine);\n    _addRadianceRenderer(engine);\n    engine.addRendererType(RENDERER_GEOMETRY_NORMAL);\n    engine.addRendererType(RENDERER_SHADING_NORMAL);\n}\n\nResponse MediaMakerPlugin::_version() const\n{\n    Response response;\n    response.contents = PACKAGE_VERSION_STRING;\n    return response;\n}\n\nvoid MediaMakerPlugin::preRender()\n{\n    if (_exportFramesToDiskDirty && _accumulationFrameNumber == 0)\n    {\n        auto &frameBuffer = _api->getEngine().getFrameBuffer();\n        frameBuffer.resize(_frameBufferSize);\n        frameBuffer.clear();\n\n        auto &camera = _api->getCamera();\n        if (camera.hasProperty(CAMERA_PROPERTY_ASPECT_RATIO.name))\n            camera.updateProperty(CAMERA_PROPERTY_ASPECT_RATIO.name,\n                                  static_cast<double>(_frameBufferSize.x) / static_cast<double>(_frameBufferSize.y));\n        camera.commit();\n\n        const uint64_t i = CAMERA_DEFINITION_SIZE * _frameNumber;\n        // Camera position\n        CameraDefinition cd;\n        const auto &ci = _exportFramesToDiskPayload.cameraInformation;\n        cd.origin = {ci[i], ci[i + 1], ci[i + 2]};\n        cd.direction = {ci[i + 3], ci[i + 4], ci[i + 5]};\n        cd.up = {ci[i + 6], ci[i + 7], ci[i + 8]};\n        cd.apertureRadius = ci[i + 9];\n        cd.focalDistance = ci[i + 10];\n        cd.interpupillaryDistance = ci[i + 11];\n        _setCamera(cd);\n\n        // Animation parameters\n        const auto &ai = _exportFramesToDiskPayload.animationInformation;\n        if (!ai.empty())\n            _api->getParametersManager().getAnimationParameters().setFrame(ai[_frameNumber]);\n    }\n}\n\nvoid MediaMakerPlugin::postRender()\n{\n    ++_accumulationFrameNumber;\n\n    if (_exportFramesToDiskDirty)\n    {\n        try\n        {\n            if (_exportFramesToDiskPayload.exportIntermediateFrames)\n                _exportFrameToDisk();\n\n            if (_accumulationFrameNumber == _exportFramesToDiskPayload.spp)\n            {\n                ++_frameNumber;\n                _accumulationFrameNumber = 0;\n                _exportFramesToDiskDirty = (_frameNumber < _exportFramesToDiskPayload.endFrame);\n                _exportFrameToDisk();\n            }\n        }\n        catch (const std::runtime_error &e)\n        {\n            PLUGIN_ERROR(e.what());\n        }\n    }\n}\n\nvoid writeBufferToFile(const std::vector<unsigned char> &buffer, const std::string &filename)\n{\n    std::ofstream file(filename, std::ios::binary);\n    if (!file.is_open())\n        CORE_THROW(\"Failed to create \" + filename);\n    file.write(reinterpret_cast<const char *>(buffer.data()), buffer.size());\n    file.close();\n}\n\nvoid MediaMakerPlugin::_exportColorBuffer() const\n{\n    auto &frameBuffer = _api->getEngine().getFrameBuffer();\n    auto image = frameBuffer.getImage();\n    ImageBuf rotatedBuf;\n    ImageBufAlgo::flip(rotatedBuf, image);\n\n    // Determine the output format\n    std::string format = _exportFramesToDiskPayload.format;\n    if (format != \"jpg\" && format != \"png\" && format != \"tiff\")\n        CORE_THROW(\"Unknown format: \" + format);\n\n    int quality = _exportFramesToDiskPayload.quality;\n\n    // Prepare the filename\n    const auto filename = _exportFramesToDiskPayload.path + \"/\" + _exportFramesToDiskPayload.baseName + \".\" + format;\n\n    // Set up ImageSpec for output image\n    ImageSpec spec = rotatedBuf.spec();\n    if (format == \"jpg\")\n        spec.attribute(\"CompressionQuality\", quality);\n\n    // Create an output buffer and write image to memory\n    std::vector<unsigned char> buffer(spec.image_bytes());\n\n    auto out = ImageOutput::create(filename);\n    if (!out)\n        CORE_THROW(\"Could not create image output.\");\n\n    out->open(filename, spec);\n    out->write_image(TypeDesc::UINT8, rotatedBuf.localpixels());\n    out->close();\n\n    PLUGIN_INFO(\"Color frame saved to \" + filename);\n}\n\nvoid MediaMakerPlugin::_exportDepthBuffer() const\n{\n    auto &frameBuffer = _api->getEngine().getFrameBuffer();\n    frameBuffer.map();\n    const auto depthBuffer = frameBuffer.getFloatBuffer();\n    const auto &size = frameBuffer.getSize();\n\n    const auto filename = _exportFramesToDiskPayload.path + \"/\" + _exportFramesToDiskPayload.baseName + \".\" +\n                          _exportFramesToDiskPayload.format;\n\n    TIFF *image = TIFFOpen(filename.c_str(), \"w\");\n    TIFFSetField(image, TIFFTAG_IMAGEWIDTH, size.x);\n    TIFFSetField(image, TIFFTAG_IMAGELENGTH, size.y);\n    TIFFSetField(image, TIFFTAG_BITSPERSAMPLE, 32);\n    TIFFSetField(image, TIFFTAG_SAMPLESPERPIXEL, 1);\n    TIFFSetField(image, TIFFTAG_ROWSPERSTRIP, 1);\n    TIFFSetField(image, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n    TIFFSetField(image, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    TIFFSetField(image, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n    TIFFSetField(image, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);\n    TIFFSetField(image, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n\n    float *scan_line = (float *)malloc(1 + size.x * (sizeof(float)));\n\n    for (uint32_t i = 0; i < size.y; ++i)\n    {\n        memcpy(scan_line, &depthBuffer[i * size.x], size.x * sizeof(float));\n        TIFFWriteScanline(image, scan_line, size.y - 1 - i, 0);\n    }\n\n    TIFFClose(image);\n    free(scan_line);\n\n    PLUGIN_INFO(\"Depth frame saved to \" + filename);\n\n    frameBuffer.unmap();\n}\n\nvoid MediaMakerPlugin::_exportFrameToDisk() const\n{\n    switch (_exportFramesToDiskPayload.frameBufferMode)\n    {\n    case FrameBufferMode::color:\n        _exportColorBuffer();\n        break;\n    case FrameBufferMode::depth:\n        _exportDepthBuffer();\n        break;\n    default:\n        PLUGIN_THROW(\"Undefined frame buffer mode\")\n    }\n}\n\nvoid MediaMakerPlugin::_exportFramesToDisk(const ExportFramesToDisk &payload)\n{\n    _exportFramesToDiskPayload = payload;\n    _exportFramesToDiskDirty = true;\n    _frameNumber = payload.startFrame;\n    _frameBufferSize = Vector2ui(payload.size[0], payload.size[1]);\n    _accumulationFrameNumber = 0;\n    _baseName = payload.baseName;\n\n    const size_t nbFrames = _exportFramesToDiskPayload.endFrame - _exportFramesToDiskPayload.startFrame;\n    PLUGIN_INFO(\n        \"----------------------------------------------------------------------\"\n        \"----------\");\n    PLUGIN_INFO(\"Movie settings               :\");\n    PLUGIN_INFO(\"- Samples per pixel          : \" + std::to_string(payload.spp));\n    PLUGIN_INFO(\"- Frame size                 : \" + std::to_string(_frameBufferSize.x) + \"x\" +\n                std::to_string(_frameBufferSize.y));\n    PLUGIN_INFO(\"- Export folder              : \" + payload.path);\n    PLUGIN_INFO(\"- Export intermediate frames : \" + std::string(payload.exportIntermediateFrames ? \"Yes\" : \"No\"));\n    PLUGIN_INFO(\"- Start frame                : \" + std::to_string(payload.startFrame));\n    PLUGIN_INFO(\"- End frame                  : \" << std::to_string(payload.endFrame));\n    PLUGIN_INFO(\"- Frame base name            : \" << payload.baseName);\n    PLUGIN_INFO(\"- Number of frames           : \" << std::to_string(nbFrames));\n    PLUGIN_INFO(\n        \"----------------------------------------------------------------------\"\n        \"----------\");\n}\n\nFrameExportProgress MediaMakerPlugin::_getFrameExportProgress()\n{\n    FrameExportProgress result;\n    double percentage = 1.f;\n    const size_t nbFrames = _exportFramesToDiskPayload.cameraInformation.size() / CAMERA_DEFINITION_SIZE;\n    const size_t totalNumberOfFrames = nbFrames * _exportFramesToDiskPayload.spp;\n\n    if (totalNumberOfFrames != 0)\n    {\n        const double currentProgress = _frameNumber * _exportFramesToDiskPayload.spp + _accumulationFrameNumber;\n        percentage = currentProgress / double(totalNumberOfFrames);\n    }\n    result.progress = percentage;\n    result.done = !_exportFramesToDiskDirty;\n    PLUGIN_DEBUG(\"Percentage = \" << result.progress << \", Done = \" << (result.done ? \"True\" : \"False\"));\n    return result;\n}\n\nvoid MediaMakerPlugin::_attachCameraHandler(const CameraHandlerDetails &payload)\n{\n    auto &scene = _api->getScene();\n    const auto modelDescriptors = scene.getModelDescriptors();\n    if (modelDescriptors.empty())\n        PLUGIN_THROW(\"At least one model is required in the scene\");\n\n    if (payload.directions.size() != payload.origins.size())\n        PLUGIN_THROW(\"Invalid number of values for direction vectors\");\n\n    if (payload.ups.size() != payload.origins.size())\n        PLUGIN_THROW(\"Invalid number of values for up vectors\");\n\n    const uint64_t nbKeyFrames = payload.origins.size() / 3;\n    CameraKeyFrames keyFrames;\n    for (uint64_t i = 0; i < nbKeyFrames; ++i)\n    {\n        CameraKeyFrame keyFrame;\n        keyFrame.origin = {payload.origins[i * 3], payload.origins[i * 3 + 1], payload.origins[i * 3 + 2]};\n        keyFrame.direction = {payload.directions[i * 3], payload.directions[i * 3 + 1], payload.directions[i * 3 + 2]};\n        keyFrame.up = {payload.ups[i * 3], payload.ups[i * 3 + 1], payload.ups[i * 3 + 2]};\n        keyFrame.apertureRadius = payload.apertureRadii[i];\n        keyFrame.focalDistance = payload.focalDistances[i];\n        keyFrames.push_back(keyFrame);\n    }\n\n    auto modelDescriptor = modelDescriptors[0];\n    if (!modelDescriptor)\n        PLUGIN_THROW(\"Invalid model\");\n\n    auto &model = modelDescriptor->getModel();\n    auto &camera = _api->getCamera();\n    auto handler = std::make_shared<CameraHandler>(camera, keyFrames, payload.stepsBetweenKeyFrames,\n                                                   payload.numberOfSmoothingSteps);\n    model.setSimulationHandler(handler);\n}\n\nextern \"C\" ExtensionPlugin *core_plugin_create(int /*argc*/, char ** /*argv*/)\n{\n    PLUGIN_INFO(\"Initializing Media Maker plug-in (version \" << PACKAGE_VERSION_STRING << \")\");\n    PLUGIN_INFO(\"\");\n    PLUGIN_INFO(\"_|      _|                  _|  _|                _|      _|            _|                          \");\n    PLUGIN_INFO(\"_|_|  _|_|    _|_|      _|_|_|        _|_|_|      _|_|  _|_|    _|_|_|  _|  _|      _|_|    _|  _|_|\");\n    PLUGIN_INFO(\"_|  _|  _|  _|_|_|_|  _|    _|  _|  _|    _|      _|  _|  _|  _|    _|  _|_|      _|_|_|_|  _|_|    \");\n    PLUGIN_INFO(\"_|      _|  _|        _|    _|  _|  _|    _|      _|      _|  _|    _|  _|  _|    _|        _|      \");\n    PLUGIN_INFO(\"_|      _|    _|_|_|    _|_|_|  _|    _|_|_|      _|      _|    _|_|_|  _|    _|    _|_|_|  _|      \");\n    PLUGIN_INFO(\"\");\n    return new MediaMakerPlugin();\n}\n\n} // namespace mediamaker\n}",
    "void MediaMakerPlugin::_exportDepthBuffer() const\n{\n    auto &frameBuffer = _api->getEngine().getFrameBuffer();\n    frameBuffer.map();\n    const auto depthBuffer = frameBuffer.getFloatBuffer();\n    const auto &size = frameBuffer.getSize();\n\n    const auto filename = _exportFramesToDiskPayload.path + \"/\" + _exportFramesToDiskPayload.baseName + \".\" +\n                          _exportFramesToDiskPayload.format;\n\n    TIFF *image = TIFFOpen(filename.c_str(), \"w\");\n    TIFFSetField(image, TIFFTAG_IMAGEWIDTH, size.x);\n    TIFFSetField(image, TIFFTAG_IMAGELENGTH, size.y);\n    TIFFSetField(image, TIFFTAG_BITSPERSAMPLE, 32);\n    TIFFSetField(image, TIFFTAG_SAMPLESPERPIXEL, 1);\n    TIFFSetField(image, TIFFTAG_ROWSPERSTRIP, 1);\n    TIFFSetField(image, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n    TIFFSetField(image, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    TIFFSetField(image, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n    TIFFSetField(image, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);\n    TIFFSetField(image, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n\n    float *scan_line = (float *)malloc(1 + size.x * (sizeof(float)));\n\n    for (uint32_t i = 0; i < size.y; ++i)\n    {\n        memcpy(scan_line, &depthBuffer[i * size.x], size.x * sizeof(float));\n        TIFFWriteScanline(image, scan_line, size.y - 1 - i, 0);\n    }\n\n    TIFFClose(image);\n    free(scan_line);\n\n    PLUGIN_INFO(\"Depth frame saved to \" + filename);\n\n    frameBuffer.unmap();\n}",
    "ImageFloatRGB *readTIFF(const char *filename)\n  {\n    TIFF* tif = TIFFOpen(filename, \"r\");\n    if (tif == NULL) {\n      fprintf(stderr, \"LibTIFF::readTIFF() -> TIFFOpen failed on %s\\n\", filename);\n      return NULL;\n    }\n\n    int width, height;\n\n    TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n    TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n    \n    int dims[2]={height, width};\n    int ok;\n    Matrix<FloatRGB> *m = NULL;\n    ImageFloatRGB *res = NULL;\n    uint32_t *p = NULL;\n    \n    int npixels = width * height;\n    uint32_t *raster = (uint32_t*) _TIFFmalloc(npixels * sizeof (uint32_t));\n    if (raster == NULL) {\n      fprintf(stderr, \"LibTIFF::readTIFF() -> _TIFFMalloc failed on %s\\n\", filename);\n      goto close_file;\n    }\n\n    ok = TIFFReadRGBAImage(tif, width, height, raster, 0);\n    if (!ok) {\n      fprintf(stderr, \"LibTIFF::readTIFF() -> TIFFReadRGBAImage failed on %s\\n\", filename);\n      goto free_image_data;\n    }\n\n    m   = new Matrix<FloatRGB>(2, dims, FloatRGB(0.0f,0.0f,0.0f));\n    res = new ImageFloatRGB(m);\n    /* process raster data */\n    p = raster;\n    for (int y = 0; y < height; y++) {\n      for (int x = 0; x < width; x++) {\n        uint32_t pixel = *p++;\n        float r = TIFFGetR(pixel)/255.0f;\n        float g = TIFFGetG(pixel)/255.0f;\n        float b = TIFFGetB(pixel)/255.0f;\n        (*res)(x,height-1-y) = FloatRGB(r,g,b);\n      }\n    }\n    \n    free_image_data:\n    _TIFFfree(raster);\n    \n    close_file:\n    TIFFClose(tif);\n\n    return res;\n  }",
    "bool writeTIFF(ImageFloatRGB *img, const char *filename)\n  {\n    bool result = false;\n    TIFF* tif = TIFFOpen(filename, \"w\");\n    if (tif == NULL) {\n      fprintf(stderr, \"LibTIFF::writeTIFF() -> TIFFOpen failed on %s\\n\", filename);\n      return result;\n    }\n\n\n    TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, img->width);\n    TIFFSetField(tif, TIFFTAG_IMAGELENGTH, img->height);\n    TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_LZW);\n    TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n    TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8);\n    TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 3);\n    TIFFSetField(tif, TIFFTAG_ARTIST, \"\");\n\n    int size = (img->width * img->height * 3);\n    int i;\n    uint8_t* buffer;\n\n    buffer = (uint8_t*)_TIFFmalloc((unsigned int)size);\n    if (buffer == NULL) {\n      fprintf(stderr, \"LibTIFF::writeTIFF() -> _TIFFMalloc failed on %s\\n\", filename);\n      goto close_file;\n    }\n\n    // copy data into buffer\n    i=0;\n    for (int y = 0; y < img->height; y++) {\n      for (int x = 0; x < img->width; x++) {\n        FloatRGB color((*img)(x,y));\n        buffer[i]   = uint8_t(color.r*255.0f);\n        buffer[i+1] = uint8_t(color.g*255.0f);\n        buffer[i+2] = uint8_t(color.b*255.0f);\n        i+=3;\n      }\n    }\n        \n    // Write the information to the file\n    TIFFWriteEncodedStrip(tif, 0, buffer, size);\n\n    // If we are here, file is OK\n    result=true;\n\n    _TIFFfree(buffer);\n\n    close_file:    \n    TIFFClose(tif);\n\n    return result;\n  }",
    "void MyImage::toTIFF(int bit, float minthresh, float maxthresh, bool zscaleing, float grey, float gamma)\n{\n    /*\n    // If no dynamic range provided, use the data min/max values\n    if (!zscaleing) {\n        minthresh = minVec_T(dataCurrent);\n        maxthresh = maxVec_T(dataCurrent);\n    }\n    */\n\n    if (*verbosity >= 2) emit messageAvailable(\"Creating \"+baseName+\".tiff ...\", \"ignore\");\n\n    if (dataTIFF.isEmpty()) dataTIFF = dataCurrent;\n\n    long n = naxis1;\n    long m = naxis2;\n    long dim = n*m;\n\n    // If z-scale is requested\n    if (zscaleing) {\n        float medVal = medianMask_T(dataTIFF);\n        float rmsVal = rmsMask_T(dataTIFF);\n        minthresh = medVal - 2.*rmsVal;\n        maxthresh = medVal + 10.*rmsVal;\n    }\n\n    // If gamma correction if requested\n    if ( gamma != 1.0 ) {\n        gamma = 1./gamma;\n        double gmaxlevel = pow(maxthresh, gamma);\n#pragma omp parallel for\n        for (long k=0; k<dim; ++k) {\n            dataTIFF[k] = pow(dataTIFF[k], gamma) / gmaxlevel * maxthresh;\n        }\n    }\n\n    // Clipping min and max values\n#pragma omp parallel for\n    for (long k=0; k<dim; k++) {\n        if (dataTIFF[k] <= minthresh) dataTIFF[k] = minthresh;\n        if (dataTIFF[k] >= maxthresh) dataTIFF[k] = maxthresh;\n    }\n\n    float blowup = 0.;\n    if (bit == 8) {\n        grey = grey / 100. * 253.;\n        blowup = (253. - grey) / (maxthresh - minthresh);\n    }\n    else {\n        grey = grey / 100. * 65000.;\n        blowup = (65000. - grey) / (maxthresh - minthresh);\n    }\n\n    std::vector< std::vector<long> > imtiff(n);\n    for (long i=0; i<n; ++i) {\n        imtiff[i].resize(m,0);\n    }\n\n#pragma omp parallel for\n    for (long i=0; i<n; ++i)  {\n        for (long j=0; j<m; ++j)  {\n            dataTIFF[i+n*j] = blowup * (dataTIFF[i+n*j] - minthresh) + grey;\n            // flipping TIFF in y dir\n            imtiff[i][naxis2-j-1] = (long) dataTIFF[i+n*j];\n        }\n    }\n\n    QString outname = path+\"/\"+baseName+\".tiff\";\n    TIFF     *outtiff;             // pointer to the TIFF file, defined in tiffio.h\n    outtiff = TIFFOpen(outname.toUtf8().data(), \"w\");\n    TIFFSetField(outtiff, TIFFTAG_IMAGEWIDTH, n);\n    TIFFSetField(outtiff, TIFFTAG_IMAGELENGTH, m);\n    TIFFSetField(outtiff, TIFFTAG_COMPRESSION, 1);\n    if (bit == 8)  TIFFSetField(outtiff, TIFFTAG_BITSPERSAMPLE, 8);\n    if (bit == 16) TIFFSetField(outtiff, TIFFTAG_BITSPERSAMPLE, 16);\n    TIFFSetField(outtiff, TIFFTAG_SAMPLESPERPIXEL, 1);\n    TIFFSetField(outtiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n    TIFFSetField(outtiff, TIFFTAG_PLANARCONFIG, 1);\n    TIFFSetField(outtiff, TIFFTAG_SOFTWARE, \"THELI\");\n    TIFFSetField(outtiff, TIFFTAG_IMAGEDESCRIPTION, \"Created by THELI\");\n\n    if (bit == 8) {\n        uint8 *outbuf = (uint8 *)_TIFFmalloc(TIFFScanlineSize(outtiff));\n        for (long row=0; row<m; ++row) {\n            uint8 *outb = outbuf;\n            for (long column=0; column<n; ++column) {\n                *outb++ = (uint8) (imtiff[column][row]);\n            }\n            TIFFWriteScanline(outtiff, outbuf, row, 0);\n        }\n        TIFFClose(outtiff);\n        _TIFFfree(outbuf);\n    }\n    else {\n        // bit == 16\n        uint16 *outbuf = (uint16 *)_TIFFmalloc(TIFFScanlineSize(outtiff));\n        for (long row=0; row<m; ++row) {\n            uint16 *outb = outbuf;\n            for (long column=0; column<n; ++column) {\n                *outb++ = (uint16) (imtiff[column][row]);\n            }\n            TIFFWriteScanline(outtiff, outbuf, row, 0);\n        }\n        TIFFClose(outtiff);\n        _TIFFfree(outbuf);\n    }\n}",
    "void ColorPicture::writeRGBTIFF(QVector<float> &R, QVector<float> &G, QVector<float> &B, long n, long m, float min, float max, QString path)\n{\n    emit messageAvailable(\"Creating RGB.tiff ...\", \"ignore\");\n\n    // Clipping min and max values\n    QVector<QVector<float>> RGBlist;\n    RGBlist << R << G << B;\n\n#pragma omp parallel for\n    for (int i=0; i<3; ++i) {\n        for (auto &pixel : RGBlist[i]) {\n            if (pixel <= min) pixel = min;\n            if (pixel >= max) pixel = max;\n        }\n    }\n\n    float grey = 0.;  // inactive\n    grey = grey / 100. * 65000.;\n    float blowup = (65000. - grey) / (max - min);\n\n    std::vector< std::vector<long> > imtiff(n);\n    for (long i=0; i<n; ++i) {\n        imtiff[i].resize(m,0);\n    }\n\n#pragma omp parallel for\n    for (int img=0; img<3; ++img) {\n        for (long i=0; i<n; ++i)  {\n            for (long j=0; j<m; ++j)  {\n                RGBlist[img][i+n*j] = blowup * (RGBlist[img][i+n*j] - min) + grey;\n                // flipping TIFF in y dir\n                imtiff[i][m-j-1] = (long) RGBlist[img][i+n*j];\n            }\n        }\n    }\n\n    QString outname = path+\"/RGB.tiff\";\n    TIFF     *outtiff;             // pointer to the TIFF file, defined in tiffio.h\n    outtiff = TIFFOpen(outname.toUtf8().data(), \"w\");\n    TIFFSetField(outtiff, TIFFTAG_IMAGEWIDTH, n);\n    TIFFSetField(outtiff, TIFFTAG_IMAGELENGTH, m);\n    TIFFSetField(outtiff, TIFFTAG_COMPRESSION, 1);\n    TIFFSetField(outtiff, TIFFTAG_BITSPERSAMPLE, 16);\n    TIFFSetField(outtiff, TIFFTAG_SAMPLESPERPIXEL, 3);\n    TIFFSetField(outtiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n    TIFFSetField(outtiff, TIFFTAG_PLANARCONFIG, 1);       // store pixel values as sequential RGB RGB RGB\n    TIFFSetField(outtiff, TIFFTAG_SOFTWARE, \"THELI\");\n    TIFFSetField(outtiff, TIFFTAG_IMAGEDESCRIPTION, \"Created by THELI\");\n\n    uint16 *outbuf = (uint16 *)_TIFFmalloc(TIFFScanlineSize(outtiff));\n    for (long row=0; row<m; ++row) {\n        uint16 *outb = outbuf;\n        for (long column=0; column<n; ++column) {\n            *outb++ = (uint16) (imtiff[column][row]);\n        }\n        TIFFWriteScanline(outtiff, outbuf, row, 0);\n    }\n    TIFFClose(outtiff);\n    _TIFFfree(outbuf);\n}",
    "bool wxTIFFHandler::LoadFile( wxImage *image, wxInputStream& stream, bool verbose, int index )\n{\n    if (index == -1)\n        index = 0;\n\n    image->Destroy();\n\n    TIFF *tif = TIFFwxOpen( stream, \"image\", \"r\" );\n\n    if (!tif)\n    {\n        if (verbose)\n            wxLogError( _(\"TIFF: Error loading image.\") );\n\n        return false;\n    }\n\n    if (!TIFFSetDirectory( tif, (tdir_t)index ))\n    {\n        if (verbose)\n            wxLogError( _(\"Invalid TIFF image index.\") );\n\n        TIFFClose( tif );\n\n        return false;\n    }\n\n    uint32 w, h;\n    uint32 npixels;\n    uint32 *raster;\n\n    TIFFGetField( tif, TIFFTAG_IMAGEWIDTH, &w );\n    TIFFGetField( tif, TIFFTAG_IMAGELENGTH, &h );\n\n    npixels = w * h;\n\n    raster = (uint32*) _TIFFmalloc( npixels * sizeof(uint32) );\n\n    if (!raster)\n    {\n        if (verbose)\n            wxLogError( _(\"TIFF: Couldn't allocate memory.\") );\n\n        TIFFClose( tif );\n\n        return false;\n    }\n\n    image->Create( (int)w, (int)h );\n    if (!image->Ok())\n    {\n        if (verbose)\n            wxLogError( _(\"TIFF: Couldn't allocate memory.\") );\n\n        _TIFFfree( raster );\n        TIFFClose( tif );\n\n        return false;\n    }\n\n    if (!TIFFReadRGBAImage( tif, w, h, raster, 0 ))\n    {\n        if (verbose)\n            wxLogError( _(\"TIFF: Error reading image.\") );\n\n        _TIFFfree( raster );\n        image->Destroy();\n        TIFFClose( tif );\n\n        return false;\n    }\n\n    bool hasmask = false;\n\n    unsigned char *ptr = image->GetData();\n    ptr += w*3*(h-1);\n    uint32 pos = 0;\n\n    for (uint32 i = 0; i < h; i++)\n    {\n        for (uint32 j = 0; j < w; j++)\n        {\n            unsigned char alpha = (unsigned char)TIFFGetA(raster[pos]);\n            if (alpha < 127)\n            {\n                hasmask = true;\n                ptr[0] = image->GetMaskRed();\n                ptr++;\n                ptr[0] = image->GetMaskGreen();\n                ptr++;\n                ptr[0] = image->GetMaskBlue();\n                ptr++;\n            }\n            else\n            {\n                ptr[0] = (unsigned char)TIFFGetR(raster[pos]);\n                ptr++;\n                ptr[0] = (unsigned char)TIFFGetG(raster[pos]);\n                ptr++;\n                ptr[0] = (unsigned char)TIFFGetB(raster[pos]);\n                ptr++;\n            }\n            pos++;\n        }\n        ptr -= 2*w*3; // subtract line we just added plus one line\n    }\n\n    _TIFFfree( raster );\n\n    TIFFClose( tif );\n\n    image->SetMask( hasmask );\n\n    return true;\n}",
    "bool wxTIFFHandler::SaveFile( wxImage *image, wxOutputStream& stream, bool verbose )\n{\n    TIFF *tif = TIFFwxOpen( stream, \"image\", \"w\" );\n\n    if (!tif)\n    {\n        if (verbose)\n            wxLogError( _(\"TIFF: Error saving image.\") );\n\n        return false;\n    }\n\n    TIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n    TIFFSetField(tif, TIFFTAG_IMAGEWIDTH,  (uint32)image->GetWidth());\n    TIFFSetField(tif, TIFFTAG_IMAGELENGTH, (uint32)image->GetHeight());\n    TIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n    TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\n    if ( image->HasOption(wxIMAGE_OPTION_RESOLUTIONX) &&\n            image->HasOption(wxIMAGE_OPTION_RESOLUTIONY) )\n    {\n        TIFFSetField(tif, TIFFTAG_XRESOLUTION,\n                        (float)image->GetOptionInt(wxIMAGE_OPTION_RESOLUTIONX));\n        TIFFSetField(tif, TIFFTAG_YRESOLUTION,\n                        (float)image->GetOptionInt(wxIMAGE_OPTION_RESOLUTIONY));\n    }\n\n    int spp = image->GetOptionInt(wxIMAGE_OPTION_SAMPLESPERPIXEL);\n    if ( !spp )\n        spp = 3;\n\n    int bpp = image->GetOptionInt(wxIMAGE_OPTION_BITSPERSAMPLE);\n    if ( !bpp )\n        bpp=8;\n\n    int compression = image->GetOptionInt(wxIMAGE_OPTION_COMPRESSION);\n    if ( !compression )\n        compression=COMPRESSION_LZW;\n\n    TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, spp);\n    TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, bpp);\n    TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, spp*bpp == 1 ? PHOTOMETRIC_MINISBLACK\n                                                        : PHOTOMETRIC_RGB);\n    TIFFSetField(tif, TIFFTAG_COMPRESSION, compression);\n\n    // scanlinesize if determined by spp and bpp\n    tsize_t linebytes = (tsize_t)image->GetWidth() * spp * bpp / 8;\n\n    if ( (image->GetWidth() % 8 > 0) && (spp * bpp < 8) )\n        linebytes+=1;\n\n    unsigned char *buf;\n\n    if (TIFFScanlineSize(tif) > linebytes || (spp * bpp < 24))\n    {\n        buf = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(tif));\n        if (!buf)\n        {\n            if (verbose)\n                wxLogError( _(\"TIFF: Couldn't allocate memory.\") );\n\n            TIFFClose( tif );\n\n            return false;\n        }\n    }\n    else\n    {\n        buf = NULL;\n    }\n\n    TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP,TIFFDefaultStripSize(tif, (uint32) -1));\n\n    unsigned char *ptr = image->GetData();\n    for ( int row = 0; row < image->GetHeight(); row++ )\n    {\n        if ( buf )\n        {\n            if ( spp * bpp > 1 )\n            {\n                // color image\n                memcpy(buf, ptr, image->GetWidth());\n            }\n            else // black and white image\n            {\n                for ( int column = 0; column < linebytes; column++ )\n                {\n                    uint8 reverse = 0;\n                    for ( int bp = 0; bp < 8; bp++ )\n                    {\n                        if ( ptr[column*24 + bp*3] > 0 )\n                        {\n                            // check only red as this is sufficient\n                            reverse = reverse | 128 >> bp;\n                        }\n                    }\n\n                    buf[column] = reverse;\n                }\n            }\n        }\n\n        if ( TIFFWriteScanline(tif, buf ? buf : ptr, (uint32)row, 0) < 0 )\n        {\n            if (verbose)\n                wxLogError( _(\"TIFF: Error writing image.\") );\n\n            TIFFClose( tif );\n            if (buf)\n                _TIFFfree(buf);\n\n            return false;\n        }\n\n        ptr += image->GetWidth()*3;\n    }\n\n    (void) TIFFClose(tif);\n\n    if (buf)\n        _TIFFfree(buf);\n\n    return true;\n}",
    "void CImageTIFF::Close()\n{\n\tif (m_state)\n\t{\n\t\tTIFF* tif = static_cast<TIFF*>(m_state);\n\t\tTIFFClose(tif);\n\t\tm_state = NULL;\n\t}\n\tm_width = m_height = 0;\n\tCImage::Close();\n}",
    "void moench_read_data (unsigned int tid,\n                           f_type * destination,\n                           const std::string &path,\n                           const std::vector<mwSize> &mdims,\n                           const std::vector<long> &im_ctr)\n    {\n        /*\n        std::vector<long> fdims{0, 0};\n        std::vector<float> fbuf(0);\n        {\n            TIFF *tiff_handle = TIFFOpen(path.c_str(), \"r\");\n            if (! tiff_handle)\n                throw std::runtime_error(std::string(\"unable to open file \") + path);\n            try {\n                tiff_dims(tiff_handle, fdims);\n                long nelems = fdims[0] * fdims[1];\n                fbuf.resize(nelems);\n                tmsize_t res, sz = fdims[1] * sizeof(float);\n                for (uint32_t strip=0; strip<fdims[0]; strip++) {\n                    float *pos = &fbuf[fdims[1] * strip];\n                    res = TIFFReadRawStrip(tiff_handle, strip, pos, sz);\n                    if (res != sz)\n                        throw std::runtime_error(\"unable to read tiff data\");\n                }\n            } catch (...) {\n                TIFFClose(tiff_handle);\n                throw;\n            }\n            TIFFClose(tiff_handle);\n        }\n        */\n        std::vector<long> fdims{0, 0};\n        std::vector<f_type> fbuf(0);\n        {\n            TIFF *tiff_handle = TIFFOpen(path.c_str(), \"r\");\n            if (! tiff_handle)\n                throw std::runtime_error(std::string(\"unable to open file \") + path);\n            try {\n                tiff_dims(tiff_handle, fdims);\n                long nelems = fdims[0] * fdims[1];\n                fbuf.resize(nelems);\n                std::uint16_t bps;\n                if (TIFFGetField(tiff_handle, TIFFTAG_BITSPERSAMPLE, &bps) != 1)\n                    throw std::runtime_error(std::string(\"unable to read number of bits per sample for file \") + path);\n                std::uint16_t format;\n                if (TIFFGetFieldDefaulted(tiff_handle, TIFFTAG_SAMPLEFORMAT, &format) != 1)\n                    throw std::runtime_error(std::string(\"unable to read sample format for file\") + path);\n                tstrip_t num_strips = TIFFNumberOfStrips(tiff_handle);\n                tsize_t strip_sz = TIFFStripSize(tiff_handle);\n                std::vector<char> cbuf(strip_sz);\n                switch (format) {\n                case 1:\n                    switch (bps) {\n                    case 8:\n                        tiff_read<std::uint8_t, f_type>(tiff_handle, cbuf, fbuf, num_strips); break;\n                    case 16:\n                        tiff_read<std::uint16_t, f_type>(tiff_handle, cbuf, fbuf, num_strips); break;\n                    case 32:\n                        tiff_read<std::uint32_t, f_type>(tiff_handle, cbuf, fbuf, num_strips); break;\n                    default:\n                        throw std::runtime_error(std::string(\"unsupported number of bits per unsigned integer sample in file \") + path);\n                    }\n                    break;\n                case 2:\n                    switch (bps) {\n                    case 8:\n                        tiff_read<std::int8_t, f_type>(tiff_handle, cbuf, fbuf, num_strips); break;\n                    case 16:\n                        tiff_read<std::int16_t, f_type>(tiff_handle, cbuf, fbuf, num_strips); break;\n                    case 32:\n                        tiff_read<std::int32_t, f_type>(tiff_handle, cbuf, fbuf, num_strips); break;\n                    default:\n                        throw std::runtime_error(std::string(\"unsupported number of bits per integer sample in file \") + path);\n                    }\n                    break;\n                case 3:\n                    switch (bps) {\n                    case 32:\n                        tiff_read<float, f_type>(tiff_handle, cbuf, fbuf, num_strips); break;\n                    case 64:\n                        tiff_read<double, f_type>(tiff_handle, cbuf, fbuf, num_strips); break;\n                    default:\n                        throw std::runtime_error(std::string(\"unsupported number of bits per ieee sample in file \") + path);\n                    }\n                    break;\n                default:\n                    throw std::runtime_error(std::string(\"unsupported sample format in file \") + path);\n                }\n            } catch (...) {\n                TIFFClose(tiff_handle);\n                throw;\n            }\n            TIFFClose(tiff_handle);\n        }\n        std::vector<long> fstride{0, 0};\n        std::vector<long> mstride{0, 0};\n        std::vector<long> count{0, 0};\n        adapt_dimensions(fdims, mdims, im_ctr, fstride, mstride, count);\n        DEBUG {\n            LOCK(mutex_cout);\n            OUT << thread_id << \":     fstride=[\" << fstride[0] << ',' << fstride[1] << \"], mstride=[\" << mstride[0] << ',' << mstride[1] << \"], count=[\" << count[0] << ',' << count[1] <<']' << std::endl;\n        }",
    "~tif_holder() {\n        TIFFClose(tif);\n    }",
    "NativeDecoder::~NativeDecoder()\n{\n    LOGI(\"Destructor\");\n    if (image) {\n        TIFFClose(image);\n        image = NULL;\n    }\n\n    //Release global reference for Bitmap.Config\n    if (preferedConfig) {\n        env->DeleteGlobalRef(preferedConfig);\n        preferedConfig = NULL;\n    }\n\n    if (jBitmapOptionsClass) {\n        env->DeleteLocalRef(jBitmapOptionsClass);\n        jBitmapOptionsClass = NULL;\n    }\n\n    if (jIProgressListenerClass) {\n        env->DeleteLocalRef(jIProgressListenerClass);\n        jIProgressListenerClass = NULL;\n    }\n\n    if (jThreadClass) {\n            env->DeleteLocalRef(jThreadClass);\n            jThreadClass = NULL;\n        }\n}",
    "JNIEXPORT jboolean JNICALL Java_org_beyka_tiffbitmapfactory_TiffSaver_save\n    (JNIEnv *env, jclass clazz, jstring filePath, jint fileDescriptor, jobject bitmap, jobject options, jboolean append) {\n\n__android_log_write(ANDROID_LOG_ERROR, \"NativeTiffSaver\", \"Test Error here\");\n\n        //Options class\n        jclass jSaveOptionsClass = env->FindClass(\"org/beyka/tiffbitmapfactory/TiffSaver$SaveOptions\");\n\n        //How much memory can we use?\n        jfieldID availableMemoryFieldID = env->GetFieldID(jSaveOptionsClass,\n                                                                          \"inAvailableMemory\",\n                                                                          \"J\");\n        unsigned long inAvailableMemory = env->GetLongField(options, availableMemoryFieldID);\n\n        //If we need to throw exceptions\n        jfieldID throwExceptionFieldID = env->GetFieldID(jSaveOptionsClass,\n                                                                           \"inThrowException\",\n                                                                           \"Z\");\n        jboolean throwException = env->GetBooleanField(options, throwExceptionFieldID);\n\n        // check is bitmap null\n        if (bitmap == NULL) {\n            const char *message = \"Bitmap is null\\0\";\n            LOGE(message);\n            if (throwException) {\n                jstring jmessage = env->NewStringUTF(message);\n                throw_decode_file_exception(env, filePath, jmessage);\n                env->DeleteLocalRef(jmessage);\n            }\n            return JNI_FALSE;\n        }\n\n\n        jclass bitmapClass = env->FindClass(\"android/graphics/Bitmap\");\n\n        //check is bitmap recycled\n        jmethodID isRecycledMethodid = env->GetMethodID(bitmapClass, \"isRecycled\", \"()Z\");\n        jboolean isRecycled = env->CallBooleanMethod(bitmap, isRecycledMethodid);\n        if (isRecycled) {\n            const char *message = \"Bitmap is recycled\\0\";\n            LOGE(message);\n            if (throwException) {\n                jstring jmessage = env->NewStringUTF(message);\n                throw_decode_file_exception(env, filePath, jmessage);\n                env->DeleteLocalRef(jmessage);\n            }\n            return JNI_FALSE;\n        }\n\n        //Read pixels from bitmap\n\n        AndroidBitmapInfo  info;\n        void* pixels;\n        int ret;\n\n\n\n        if ((ret = AndroidBitmap_getInfo(env, bitmap, &info)) < 0) {\n            LOGE(\"AndroidBitmap_getInfo() failed ! error=\");\n            return JNI_FALSE;\n        }\n\n        if ((ret = AndroidBitmap_lockPixels(env, bitmap, &pixels)) < 0) {\n                LOGE(\"AndroidBitmap_lockPixels() failed ! error=\");\n                return JNI_FALSE;\n        }\n\n        uint32 img_width = info.width;\n        uint32 img_height= info.height;\n\n/*\n        //Get array of jint from jintArray\n        jint *c_array;\n        c_array = env->GetIntArrayElements(img, NULL);\n        if (c_array == NULL) {\n            //if array is null - nothing to save\n            LOGE(\"array is null\");\n            return JNI_FALSE;\n        }\n*/\n\n\n        //Get options\n\n        //Get compression mode from options object\n        jfieldID gOptions_CompressionModeFieldID = env->GetFieldID(jSaveOptionsClass,\n        \"compressionScheme\",\n        \"Lorg/beyka/tiffbitmapfactory/CompressionScheme;\");\n        jobject compressionMode = env->GetObjectField(options, gOptions_CompressionModeFieldID);\n\n        jclass compressionModeClass = env->FindClass(\n        \"org/beyka/tiffbitmapfactory/CompressionScheme\");\n        jfieldID ordinalFieldID = env->GetFieldID(compressionModeClass, \"ordinal\", \"I\");\n        jint compressionInt = env->GetIntField(compressionMode, ordinalFieldID);\n\n        //Get image orientation from options object\n        jfieldID gOptions_OrientationFieldID = env->GetFieldID(jSaveOptionsClass,\n        \"orientation\",\n        \"Lorg/beyka/tiffbitmapfactory/Orientation;\");\n        jobject orientation = env->GetObjectField(options, gOptions_OrientationFieldID);\n\n        jclass orientationClass = env->FindClass(\n        \"org/beyka/tiffbitmapfactory/Orientation\");\n        jfieldID orientationOrdinalFieldID = env->GetFieldID(orientationClass, \"ordinal\", \"I\");\n        jint orientationInt = env->GetIntField(orientation, orientationOrdinalFieldID);\n        env->DeleteLocalRef(orientationClass);\n\n        // variables for resolution\n        jfieldID gOptions_xResolutionFieldID = env->GetFieldID(jSaveOptionsClass, \"xResolution\", \"F\");\n        float xRes = env->GetFloatField(options, gOptions_xResolutionFieldID);\n        jfieldID gOptions_yResolutionFieldID = env->GetFieldID(jSaveOptionsClass, \"yResolution\", \"F\");\n        float yRes = env->GetFloatField(options, gOptions_yResolutionFieldID);\n        jfieldID gOptions_resUnitFieldID = env->GetFieldID(jSaveOptionsClass,\n                                                           \"resUnit\",\n                                                           \"Lorg/beyka/tiffbitmapfactory/ResolutionUnit;\");\n        jobject resUnitObject = env->GetObjectField(options, gOptions_resUnitFieldID);\n        //Get res int from resUnitObject\n        jclass resolutionUnitClass = env->FindClass(\"org/beyka/tiffbitmapfactory/ResolutionUnit\");\n        jfieldID resUnitOrdinalFieldID = env->GetFieldID(resolutionUnitClass, \"ordinal\", \"I\");\n        uint16 resUnit = env->GetIntField(resUnitObject, resUnitOrdinalFieldID);\n        env->DeleteLocalRef(resolutionUnitClass);\n\n        //Get author field if exist\n        jfieldID gOptions_authorFieldID = env->GetFieldID(jSaveOptionsClass, \"author\", \"Ljava/lang/String;\");\n        jstring jAuthor = (jstring)env->GetObjectField(options, gOptions_authorFieldID);\n        const char *authorString = NULL;\n        if (jAuthor) {\n            authorString = env->GetStringUTFChars(jAuthor, 0);\n            LOGIS(\"Author: \", authorString);\n        }\n\n        //Get copyright field if exist\n        jfieldID gOptions_copyrightFieldID = env->GetFieldID(jSaveOptionsClass, \"copyright\", \"Ljava/lang/String;\");\n        jstring jCopyright = (jstring)env->GetObjectField(options, gOptions_copyrightFieldID);\n        const char *copyrightString = NULL;\n        if (jCopyright) {\n            copyrightString = env->GetStringUTFChars(jCopyright, 0);\n            LOGIS(\"Copyright: \", copyrightString);\n        }\n\n        //Get image description field if exist\n        jfieldID gOptions_imgDescrFieldID = env->GetFieldID(jSaveOptionsClass, \"imageDescription\", \"Ljava/lang/String;\");\n        jstring jImgDescr = (jstring)env->GetObjectField(options, gOptions_imgDescrFieldID);\n        const char *imgDescrString = NULL;\n        if (jImgDescr) {\n            imgDescrString = env->GetStringUTFChars(jImgDescr, 0);\n            LOGIS(\"Image Description: \", imgDescrString);\n        }\n\n        //Get software name and number from buildconfig\n        jclass jBuildConfigClass = env->FindClass(\n                \"org/beyka/tiffbitmapfactory/BuildConfig\");\n        jfieldID softwareNameFieldID = env->GetStaticFieldID(jBuildConfigClass, \"softwarename\", \"Ljava/lang/String;\");\n        jstring jsoftwarename = (jstring)env->GetStaticObjectField(jBuildConfigClass, softwareNameFieldID);\n        const char *softwareNameString = NULL;\n        if (jsoftwarename) {\n            softwareNameString = env->GetStringUTFChars(jsoftwarename, 0);\n            LOGIS(\"Software Name: \", softwareNameString);\n        }\n\n        //Get android version\n        jclass build_class = env->FindClass(\"android/os/Build$VERSION\");\n        jfieldID releaseFieldID = env->GetStaticFieldID(build_class, \"RELEASE\", \"Ljava/lang/String;\");\n        jstring jrelease = (jstring)env->GetStaticObjectField(build_class, releaseFieldID);\n        const char *releaseString = NULL;\n        if (jrelease) {\n            releaseString = env->GetStringUTFChars(jrelease, 0);\n            LOGIS(\"Release: \", releaseString);\n        }\n        char *fullReleaseName = concat(\"Android \", releaseString);\n        LOGIS(\"Full Release: \", fullReleaseName);\n\n\n        uint32 pixelsBufferSize = img_width * img_height;\n        uint32* img = NULL;\n        int tmpImgArrayCreated = 0;\n        switch (info.format) {\n            case ANDROID_BITMAP_FORMAT_RGBA_8888:\n            {\n                LOGI(\"ANDROID_BITMAP_FORMAT_RGBA_8888\");\n                img = (uint32*)pixels;\n                break;\n            }\n            case ANDROID_BITMAP_FORMAT_RGBA_4444:\n            {\n                LOGI(\"ANDROID_BITMAP_FORMAT_RGBA_4444\");\n                uint16_t* tmp4444 = (uint16_t*)pixels;\n                img = (uint32*) malloc(sizeof(uint32) * pixelsBufferSize);\n                for (int x = 0; x < img_width; x++) {\n                    for (int y = 0; y < img_height; y++) {\n                        uint16_t pix = tmp4444[y * img_width + x];\n                        int alpha = colorMask & pix >> 16;\n                        int red = colorMask & pix >> 8;\n                        int green = colorMask & pix >> 4;\n                        int blue = colorMask & pix;\n                        uint32 crPix = (alpha << 24) | (blue << 16) | (green << 8) | (red);\n                        img[y * img_width + x] = crPix;\n                    }\n                }\n                tmpImgArrayCreated = 1;\n                break;\n            }\n            case ANDROID_BITMAP_FORMAT_RGB_565:\n            {\n                LOGI(\"ANDROID_BITMAP_FORMAT_RGB_565\");\n                uint16_t* tmp565 = (uint16_t*)pixels;\n                img = (uint32*) malloc(sizeof(uint32) * pixelsBufferSize);\n                for (int x = 0; x < img_width; x++) {\n                    for (int y = 0; y < img_height; y++) {\n                        uint16_t pix = tmp565[y * img_width + x];\n                        unsigned char red = 0b11111 & pix >> 11;\n                        unsigned char green = 0b111111 & pix >> 5;\n                        unsigned char blue = 0b11111 & pix;\n                        uint32 crPix = (blue << 3 << 16) | (green << 2 << 8) | (red<<3);\n                        img[y * img_width + x] = crPix;\n                    }\n                }\n                tmpImgArrayCreated = 1;\n                break;\n            }\n            case ANDROID_BITMAP_FORMAT_A_8:\n            {\n                LOGI(\"ANDROID_BITMAP_FORMAT_A_8\");\n                uint8_t* tmp8 = (uint8_t*)pixels;\n                img = (uint32*) malloc(sizeof(uint32) * pixelsBufferSize);\n                for (int x = 0; x < img_width; x++) {\n                    for (int y = 0; y < img_height; y++) {\n                        uint8_t pix = tmp8[y * img_width + x];\n                        img[y * img_width + x] = pix << 24;\n                    }\n                }\n                tmpImgArrayCreated = 1;\n                break;\n            }\n        }\n\n/*\n        int pixelsBufferSize = img_width * img_height;\n        uint32 *array = (uint32 *) malloc(sizeof(uint32) * pixelsBufferSize);\n        if (!array) {\n            throw_not_enought_memory_exception(env, sizeof(uint32) * pixelsBufferSize, 0);//todo change for estimating memory\n            return JNI_FALSE;\n        }\n\n        uint32_t* img = (uint32_t*)pixels;\n        for (int y = 0; y < img_height; y++) {\n            for (int x = 0; x < img_width; x++) {\n                uint32_t pix = img[y * img_width + x];\n                int alpha = colorMask & pix >> 24;\n                int red = colorMask & pix >> 16;\n                int green = colorMask & pix >> 8;\n                int blue = colorMask & pix;\n                uint32 crPix = (alpha << 24) | (blue << 16) | (green << 8) | (red);\n                array[y * img_width + x] = crPix;\n            }\n        }\n*/\n\n/*\n        for (int i = 0; i < img_width; i++) {\n            for (int j = 0; j < img_height; j++) {\n\n                uint32 crPix = getPixel(pixels,info,i,j);\n\n                //jint crPix = c_array[j * img_width + i];\n                int alpha = colorMask & crPix >> 24;\n                int red = colorMask & crPix >> 16;\n                int green = colorMask & crPix >> 8;\n                int blue = colorMask & crPix;\n\n                crPix = (alpha << 24) | (blue << 16) | (green << 8) | (red);\n                array[j * img_width + i] = crPix;\n            }\n        }\n*/\n        TIFF *output_image;\n\n        LOGII(\"Check file descripor\", fileDescriptor);\n\n        const char *strPath = NULL;\n        if (fileDescriptor == -1) {\n            strPath = env->GetStringUTFChars(filePath, 0);\n            LOGIS(\"nativeTiffOpenForSave\", strPath);\n            int mode = O_RDWR | O_CREAT | O_TRUNC | 0;\n            if (append) {\n                mode = O_RDWR | O_CREAT;\n            }\n            fileDescriptor = open(strPath, mode, 0666);\n            if (fileDescriptor < 0) {\n                throw_cant_open_file_exception(env, filePath);\n                return JNI_FALSE;\n            }\n        }\n\n        // Open the TIFF file\n        if (!append) {\n            if ((output_image = TIFFFdOpen(fileDescriptor, \"\", \"w\")) == NULL) {\n                LOGE(\"Unable to write tif file\");\n                if (strPath) {\n                    throw_cant_open_file_exception(env, filePath);\n                } else {\n                    throw_cant_open_file_exception_fd(env, fileDescriptor);\n                }\n                return JNI_FALSE;\n            }\n        } else {\n            if ((output_image = TIFFFdOpen(fileDescriptor, \"\", \"a\")) == NULL) {\n                LOGE(\"Unable to write tif file\");\n                if (strPath) {\n                    throw_cant_open_file_exception(env, filePath);\n                } else {\n                    throw_cant_open_file_exception_fd(env, fileDescriptor);\n                return JNI_FALSE;\n                }\n            }\n        }\n\n        TIFFSetField(output_image, TIFFTAG_IMAGEWIDTH, img_width);\n        TIFFSetField(output_image, TIFFTAG_IMAGELENGTH, img_height);\n        TIFFSetField(output_image, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n        TIFFSetField(output_image, TIFFTAG_COMPRESSION, compressionInt);\n        TIFFSetField(output_image, TIFFTAG_ORIENTATION, orientationInt);\n        TIFFSetField(output_image, TIFFTAG_XRESOLUTION, xRes);\n        TIFFSetField(output_image, TIFFTAG_YRESOLUTION, yRes);\n        TIFFSetField(output_image, TIFFTAG_RESOLUTIONUNIT, resUnit);\n\n        if (compressionInt == COMPRESSION_CCITTRLE ||compressionInt == COMPRESSION_CCITTFAX3 || compressionInt == COMPRESSION_CCITTFAX4) {\n            TIFFSetField(output_image, TIFFTAG_BITSPERSAMPLE,\t1);\n            TIFFSetField(output_image, TIFFTAG_SAMPLESPERPIXEL,\t1);\n            TIFFSetField(output_image, TIFFTAG_ROWSPERSTRIP, 1);\n            TIFFSetField(output_image, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n            TIFFSetField(output_image, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);\n        } else {\n            TIFFSetField(output_image, TIFFTAG_BITSPERSAMPLE, 8);\n            TIFFSetField(output_image, TIFFTAG_SAMPLESPERPIXEL, 4);\n            TIFFSetField(output_image, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n        }\n\n        //Write additiona tags\n        //CreationDate tag\n        char *date = getCreationDate();\n        TIFFSetField(output_image, TIFFTAG_DATETIME, date);\n        free(date);\n        //Host system\n        TIFFSetField(output_image, TIFFTAG_HOSTCOMPUTER, fullReleaseName);\n\n        //software\n        if (softwareNameString) {\n            TIFFSetField(output_image, TIFFTAG_SOFTWARE, softwareNameString);\n        }\n        //image description\n        if (imgDescrString) {\n            TIFFSetField(output_image, TIFFTAG_IMAGEDESCRIPTION, imgDescrString);\n        }\n        //author\n        if (authorString) {\n            TIFFSetField(output_image, TIFFTAG_ARTIST, authorString);\n        }\n        //copyright\n        if (copyrightString) {\n            TIFFSetField(output_image, TIFFTAG_COPYRIGHT, copyrightString);\n        }\n\n        // Write the information to the file\n        if (compressionInt == COMPRESSION_CCITTRLE || compressionInt == COMPRESSION_CCITTFAX3 || compressionInt == COMPRESSION_CCITTFAX4) {\n            unsigned char *bilevel = convertArgbToBilevel(img, img_width, img_height);\n            int compressedWidth = (img_width/8 + 0.5);\n            for (int i = 0; i < img_height; i++) {\n                TIFFWriteEncodedStrip(output_image, i, &bilevel[i * compressedWidth], (compressedWidth));\n            }\n            free(bilevel);\n        } else if (compressionInt == COMPRESSION_JPEG) {\n            for (int row = 0; row < img_height; row++) {\n                TIFFWriteScanline(output_image, &img[row * img_width], row, 0);\n            }\n        } else {\n            TIFFSetField(output_image, TIFFTAG_ROWSPERSTRIP, 1);\n            for (int row = 0; row < img_height; row++) {\n                TIFFWriteEncodedStrip(output_image, row, &img[row * img_width], img_width * sizeof(uint32));\n                //TIFFWriteScanline(output_image, &img[row * img_width], row, 0);\n            }\n        }\n       ret = TIFFWriteDirectory(output_image);\n        LOGII(\"ret = \", ret);\n\n        // Close the file\n        TIFFClose(output_image);\n/*\n        //free temp array\n        free (array);\n*/\n        if (tmpImgArrayCreated) {\n            free(img);\n        }\n\n        //Now we don't need android pixels, so unlock\n                 AndroidBitmap_unlockPixels(env, bitmap);\n\n        //Remove variables\n        if (releaseString) {\n            env->ReleaseStringUTFChars(jrelease, releaseString);\n        }\n        free(fullReleaseName);\n        if (softwareNameString) {\n            env->ReleaseStringUTFChars(jsoftwarename, softwareNameString);\n        }\n        if (imgDescrString) {\n            env->ReleaseStringUTFChars(jImgDescr, imgDescrString);\n        }\n        if (authorString) {\n            env->ReleaseStringUTFChars(jAuthor, authorString);\n        }\n        if (copyrightString) {\n            env->ReleaseStringUTFChars(jCopyright, copyrightString);\n        }\n        if (strPath) {\n            env->ReleaseStringUTFChars(filePath, strPath);\n        }\n//        env->ReleaseIntArrayElements(img, c_array, 0);\n\n        if (ret == -1) return JNI_FALSE;\n        return JNI_TRUE;\n    }",
    "BmpToTiffConverter::~BmpToTiffConverter()\n{\n    LOGI(\"Destructor\");\n    if (tiffImage) {\n        TIFFClose(tiffImage);\n        tiffImage = NULL;\n    }\n    LOGI(\"Tiff removed\");\n\n    if (inf) {\n        delete inf;\n    }\n    LOGI(\"Inf deleted\");\n\n    if (bmp) {\n        delete bmp;\n    }\n    LOGI(\"header deleted\");\n}",
    "TiffToPngConverter::~TiffToPngConverter()\n{\n    LOGI(\"destructor start\");\n    if (tiffImage) {\n        TIFFClose(tiffImage);\n        tiffImage = NULL;\n    }\n    LOGI(\"tiff free\");\n\n    if (png_info_init) {\n        png_free_data(png_ptr, info_ptr, PNG_FREE_ALL, -1);\n    }\n    LOGI(\"info_ptr free\");\n\n    if (png_ptr_init) {\n        png_destroy_write_struct(&png_ptr, NULL);\n    }\n    LOGI(\"png_ptr free\");\n\n    if (pngFile) {\n        LOGI(\"pngFile != NULL\");\n        fclose(pngFile);\n    }\n    LOGI(\"png file free\");\n}",
    "TiffToJpgConverter::~TiffToJpgConverter()\n{\n    LOGI(\"destructor\");\n    if (tiffImage) {\n        TIFFClose(tiffImage);\n        tiffImage = NULL;\n    }\n        LOGI(\"tiff\");\n\n    if (jpegFile) {\n        /*if (!conversion_result) {\n            const char *strPngPath = NULL;\n            strPngPath = env->GetStringUTFChars(outPath, 0);\n            remove(strPngPath);\n            env->ReleaseStringUTFChars(outPath, strPngPath);\n        }*/\n        fclose(jpegFile);\n    }\n    LOGI(\"file\");\n    if (jpeg_struct_init) {\n        jpeg_destroy_compress(&cinfo);\n    }\n    LOGI(\"destructor finish\");\n\n}",
    "JpgToTiffConverter::~JpgToTiffConverter()\n{\n    LOGI(\"Destructor\");\n    if (tiffImage) {\n        TIFFClose(tiffImage);\n        tiffImage = NULL;\n    }\n    LOGI(\"Tiff removed\");\n\n    if (jpeg_struct_init) {\n        jpeg_destroy_decompress(&cinfo);\n    }\n    LOGI(\"JPEG destroyed\");\n\n    if (inFile) {\n        fclose(inFile);\n    }\n    LOGI(\"IN file closed\");\n}",
    "PngToTiffConverter::~PngToTiffConverter() {\n    if (tiffImage) {\n        TIFFClose(tiffImage);\n        tiffImage = NULL;\n    }\n\n    if (png_info_init) {\n        png_free_data(png_ptr, info_ptr, PNG_FREE_ALL, -1);\n    }\n\n    if (png_ptr_init) {\n        png_destroy_read_struct(&png_ptr, NULL, NULL);\n    }\n\n    if (inFile) {\n        fclose(inFile);\n    }\n}",
    "std::shared_ptr<PrimitiveObject> readTiffFile(std::string const &path, int type = 0) {\n    TIFF* tif = TIFFOpen(path.c_str(), \"r\");\n    if (!tif) {\n        throw std::runtime_error(\"tiff read fail\");\n    }\n    auto img = std::make_shared<PrimitiveObject>();\n\n    uint32 width, height;\n    uint16_t samplesPerPixel, bitsPerSample;\n    TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n    TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n    TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &samplesPerPixel);\n    TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bitsPerSample);\n    img->userData().set2(\"isImage\", 1);\n    img->userData().set2(\"w\", (int)width);\n    img->userData().set2(\"h\", (int)height);\n    img->userData().set2(\"samplesPerPixel\", (int)samplesPerPixel);\n    img->userData().set2(\"bitsPerSample\", (int)bitsPerSample);\n    if (bitsPerSample != 32) {\n        throw std::runtime_error(\"tiff read fail\");\n    }\n\n    std::vector<uint8_t> data_;\n    uint32_t rowSize = TIFFScanlineSize(tif);\n    img->userData().set2(\"rowSize\", (int)rowSize);\n    data_.resize(rowSize * height);\n\n    for (int32_t row = 0; row < height; ++row) {\n        TIFFReadScanline(tif, &data_[row * rowSize], row);\n    }\n    TIFFClose(tif);\n\n    img->resize(width * height);\n    if (samplesPerPixel == 4) {\n        vec4f *ptr = (vec4f*)data_.data();\n        auto &alpha = img->verts.add_attr<float>(\"alpha\");\n        auto &uv = img->verts.add_attr<zeno::vec2f>(\"uv\");\n        for (auto i = 0; i < height; i++) {\n            for (auto j = 0; j < width; j++) {\n                vec4f rgba = ptr[i * width + j];\n                img->verts[i * width + j] =  { rgba[0], rgba[1], rgba[2] };\n                alpha[i * width + j] =  rgba[3];\n                uv[i * width + j] = vec2f(j,i);\n            }\n        }\n    }\n    else if (samplesPerPixel == 3) {\n        vec3f *ptr = (vec3f*)data_.data();\n        auto &uv = img->verts.add_attr<zeno::vec2f>(\"uv\");\n        for (auto i = 0; i < height; i++) {\n            for (auto j = 0; j < width; j++) {\n                vec3f rgb = ptr[i * width + j];\n                img->verts[i * width + j] = rgb;\n                uv[i * width + j] = vec2f(j,i);\n            }\n        }\n    }\n    else if (samplesPerPixel == 1) {\n        auto &uv = img->verts.add_attr<zeno::vec2f>(\"uv\");\n        for (auto i = 0; i < height; i++) {\n            for (auto j = 0; j < width; j++) {\n                float r;\n                if(type == 0)\n                  r = ((int *)data_.data())[i*width + j];\n                else\n                  r = ((float *)data_.data())[i*width + j];\n                img->verts[i * width + j] = {r, r, r};\n                uv[i * width + j] = vec2f(j,i);\n            }\n        }\n    }\n\n    // Process image data here...\n    return img;\n}",
    "bool DkBasicLoader::loadTIFF(const QString &, QImage &, QSharedPointer<QByteArray>) const\n{\n    qWarning() << \"built-in TIFF loader is not included in this build and may be able to load this file\";\n#else\nbool DkBasicLoader::loadTIFF(const QString &filePath, QImage &img, QSharedPointer<QByteArray> ba) const\n{\n    bool success = false;\n\n    // first turn off nasty warning/error dialogs - (we do the GUI : )\n    TIFFErrorHandler oldErrorHandler, oldWarningHandler;\n    oldWarningHandler = TIFFSetWarningHandler(NULL);\n    oldErrorHandler = TIFFSetErrorHandler(NULL);\n\n    DkTimer dt;\n    TIFF *tiff = 0;\n\n// TODO: currently TIFFStreamOpen can only be linked on Windows?!\n#if defined(Q_OS_WIN)\n\n    std::istringstream is(ba ? ba->toStdString() : \"\");\n\n    if (ba)\n        tiff = TIFFStreamOpen(\"MemTIFF\", &is);\n\n    // fallback to direct loading\n    if (!tiff)\n        tiff = TIFFOpen(filePath.toLatin1(), \"r\");\n\n    // FIXME: we could load without buffer if toLatin1()=>toUtf8() and on\n    // windows use wchar_t* version of TIFFOpen();\n\n    // loading from buffer allows us to load files with non-latin names\n    QSharedPointer<QByteArray> bal;\n    if (!tiff)\n        bal = loadFileToBuffer(filePath);\n\n    std::istringstream isl(bal ? bal->toStdString() : \"\");\n\n    if (bal)\n        tiff = TIFFStreamOpen(\"MemTIFF\", &isl);\n#else\n    tiff = TIFFOpen(filePath.toLatin1(), \"r\");\n#endif\n\n    if (!tiff)\n        return success;\n\n    uint32_t width = 0;\n    uint32_t height = 0;\n\n    TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, &width);\n    TIFFGetField(tiff, TIFFTAG_IMAGELENGTH, &height);\n\n    // init the qImage\n    img = QImage(width, height, QImage::Format_ARGB32);\n\n    const int stopOnError = 1;\n    success = TIFFReadRGBAImageOriented(tiff, width, height, reinterpret_cast<uint32_t *>(img.bits()), ORIENTATION_TOPLEFT, stopOnError) != 0;\n\n    if (success) {\n        for (uint32_t y = 0; y < height; ++y)\n            convert32BitOrder(img.scanLine(y), width);\n    }\n\n    TIFFClose(tiff);\n\n    TIFFSetWarningHandler(oldWarningHandler);\n    TIFFSetWarningHandler(oldErrorHandler);\n\n    return success;\n\n#endif // !WITH_LIBTIFF\n    return false;\n}\n\n#define DRIF_IMAGE_IMPL\n#include \"drif_image.h\"\n\nbool isQtFmtCompatible(uint32_t f)\n{\n    switch (f) {\n    case DRIF_FMT_RGB888:\n    case DRIF_FMT_RGBA8888:\n    case DRIF_FMT_GRAY:\n        return true;\n    }\n\n    return false;\n}\n\nuint32_t drif2qtfmt(uint32_t f)\n{\n    switch (f) {\n    case DRIF_FMT_RGB888:\n        return QImage::Format_RGB888;\n    case DRIF_FMT_RGBA8888:\n        return QImage::Format_RGBA8888;\n    case DRIF_FMT_GRAY:\n        return QImage::Format_Grayscale8;\n    }\n\n    return QImage::Format_Invalid;\n}\n\nbool DkBasicLoader::loadDRIF(const QString &filePath, QImage &img, QSharedPointer<QByteArray> ba) const\n{\n    bool success = false;\n\n    uint32_t w;\n    uint32_t h;\n    uint32_t f;\n\n    uint8_t *imgBytes = drifLoadImg(filePath.toLatin1(), &w, &h, &f);\n\n    if (!imgBytes)\n        return success;\n\n    if (isQtFmtCompatible(f)) {\n        img = QImage((int)w, (int)h, (QImage::Format)drif2qtfmt(f));\n        memcpy(reinterpret_cast<void *>(img.bits()), imgBytes, drifGetSize(w, h, f));\n\n        success = true;\n    }\n#ifdef WITH_OPENCV\n    else {\n        img = QImage((int)w, (int)h, QImage::Format_RGB888);\n\n        switch (f) {\n        case DRIF_FMT_BGR888: {\n            cv::Mat imgMat = cv::Mat((int)h, (int)w, CV_8UC3, imgBytes);\n            cv::Mat rgbMat = cv::Mat((int)h, (int)w, CV_8UC3, reinterpret_cast<uint8_t *>(img.bits()));\n            cv::cvtColor(imgMat, rgbMat, CV_BGR2RGB);\n\n            success = true;\n        } break;\n\n        case DRIF_FMT_RGB888P:\n        case DRIF_FMT_RGBA8888P: {\n            cv::Mat imgMatR = cv::Mat((int)h, (int)w, CV_8UC1, imgBytes);\n            cv::Mat imgMatG = cv::Mat((int)h, (int)w, CV_8UC1, imgBytes + w * h);\n            cv::Mat imgMatB = cv::Mat((int)h, (int)w, CV_8UC1, imgBytes + 2 * w * h);\n            cv::Mat rgbMat = cv::Mat((int)h, (int)w, CV_8UC3, reinterpret_cast<uint8_t *>(img.bits()));\n\n            std::vector<cv::Mat> imgMat{imgMatR, imgMatG, imgMatB};\n            cv::merge(imgMat, rgbMat);\n\n            success = true;\n        } break;\n\n        case DRIF_FMT_BGR888P:\n        case DRIF_FMT_BGRA8888P: {\n            cv::Mat imgMatB = cv::Mat((int)h, (int)w, CV_8UC1, imgBytes);\n            cv::Mat imgMatG = cv::Mat((int)h, (int)w, CV_8UC1, imgBytes + w * h);\n            cv::Mat imgMatR = cv::Mat((int)h, (int)w, CV_8UC1, imgBytes + 2 * w * h);\n            cv::Mat rgbMat = cv::Mat((int)h, (int)w, CV_8UC3, reinterpret_cast<uint8_t *>(img.bits()));\n\n            std::vector<cv::Mat> imgMat{imgMatR, imgMatG, imgMatB};\n            cv::merge(imgMat, rgbMat);\n\n            success = true;\n        } break;\n\n        case DRIF_FMT_BGRA8888: {\n            cv::Mat imgMat = cv::Mat((int)h, (int)w, CV_8UC4, imgBytes);\n            cv::Mat rgbMat = cv::Mat((int)h, (int)w, CV_8UC3, reinterpret_cast<uint8_t *>(img.bits()));\n            cv::cvtColor(imgMat, rgbMat, CV_BGR2RGB, 3);\n\n            success = true;\n        } break;\n\n        case DRIF_FMT_RGBA8888: {\n            cv::Mat imgMat = cv::Mat((int)h, (int)w, CV_8UC4, imgBytes);\n            cv::Mat rgbMat = cv::Mat((int)h, (int)w, CV_8UC3, reinterpret_cast<uint8_t *>(img.bits()));\n            cv::cvtColor(imgMat, rgbMat, CV_RGBA2RGB, 3);\n\n            success = true;\n        } break;\n\n        case DRIF_FMT_GRAY: {\n            cv::Mat imgMat = cv::Mat((int)h, (int)w, CV_8UC1, imgBytes);\n            cv::Mat rgbMat = cv::Mat((int)h, (int)w, CV_8UC3, reinterpret_cast<uint8_t *>(img.bits()));\n            cv::cvtColor(imgMat, rgbMat, CV_GRAY2RGB);\n\n            success = true;\n        } break;\n\n        case DRIF_FMT_YUV420P: {\n            cv::Mat imgMat = cv::Mat((int)h + h / 2, (int)w, CV_8UC1, imgBytes);\n            cv::Mat rgbMat = cv::Mat((int)h, (int)w, CV_8UC3, reinterpret_cast<uint8_t *>(img.bits()));\n            cv::cvtColor(imgMat, rgbMat, CV_YUV2RGB_I420);\n\n            success = true;\n        } break;\n\n        case DRIF_FMT_YVU420P: {\n            cv::Mat imgMat = cv::Mat((int)h + h / 2, (int)w, CV_8UC1, imgBytes);\n            cv::Mat rgbMat = cv::Mat((int)h, (int)w, CV_8UC3, reinterpret_cast<uint8_t *>(img.bits()));\n            cv::cvtColor(imgMat, rgbMat, CV_YUV2RGB_YV12);\n\n            success = true;\n        } break;\n\n        case DRIF_FMT_NV12: {\n            cv::Mat imgMat = cv::Mat((int)h + h / 2, (int)w, CV_8UC1, imgBytes);\n            cv::Mat rgbMat = cv::Mat((int)h, (int)w, CV_8UC3, reinterpret_cast<uint8_t *>(img.bits()));\n            cv::cvtColor(imgMat, rgbMat, CV_YUV2RGB_NV12);\n\n            success = true;\n        } break;\n\n        case DRIF_FMT_NV21: {\n            cv::Mat imgMat = cv::Mat((int)h + h / 2, (int)w, CV_8UC1, imgBytes);\n            cv::Mat rgbMat = cv::Mat((int)h, (int)w, CV_8UC3, reinterpret_cast<uint8_t *>(img.bits()));\n            cv::cvtColor(imgMat, rgbMat, CV_YUV2RGB_NV21);\n\n            success = true;\n        } break;\n\n        default:\n            success = false;\n            break;\n        }\n    }\n#endif\n\n    drifFreeImg(imgBytes);\n\n    return success;\n}\n\nvoid DkBasicLoader::setImage(const QImage &img, const QString &editName, const QString &file)\n{\n    mFile = file;\n    setEditImage(img, editName);\n}\n\nvoid DkBasicLoader::pruneEditHistory()\n{\n    // delete all hidden edit states\n    for (int idx = mImages.size() - 1; idx > mImageIndex; idx--) {\n        mImages.pop_back();\n    }\n}\n\nvoid DkBasicLoader::setEditImage(const QImage &img, const QString &editName)\n{\n    if (img.isNull())\n        return;\n\n    // delete all hidden edit states\n    pruneEditHistory();\n\n    // compute new history size\n    int historySize = 0;\n    for (const DkEditImage &e : mImages) {\n        historySize += e.size();\n    }\n\n    // reset exif orientation after image edit\n    if (!mImages.isEmpty())\n        mMetaData->clearOrientation();\n    // new history item with new pixmap (and old or original metadata)\n    DkEditImage newImg(img, mMetaData->copy(), editName); // new image, old/unchanged metadata\n\n    if (historySize + newImg.size() > DkSettingsManager::param().resources().historyMemory && mImages.size() > mMinHistorySize) {\n        mImages.removeAt(1);\n        qWarning() << \"removing history image because it's too large:\" << historySize + newImg.size() << \"MB\";\n    }\n\n    mImages.append(newImg);\n    mImageIndex = mImages.size() - 1; // set the index again to the last\n}\n\nvoid DkBasicLoader::setEditMetaData(const QSharedPointer<DkMetaDataT> &metaData, const QImage &img, const QString &editName)\n{\n    // delete all hidden edit states\n    pruneEditHistory();\n\n    // not removing second history item if oversized (see setEditImage())\n\n    // new history item with new metadata (and image, but hasNewImage() will be false)\n    DkEditImage newImg(metaData->copy(), img, editName); // new metadata, old/unchanged image\n\n    mImages.append(newImg);\n    mImageIndex = mImages.size() - 1; // set the index again to the last\n}\n\nvoid DkBasicLoader::setEditMetaData(const QSharedPointer<DkMetaDataT> &metaData, const QString &editName)\n{\n    // Add history edit with new metadata (hasMetaData()), copying last or original image\n    QImage lastImg = image(); // copy last edit of pixmap (if any) to new history item\n    setEditMetaData(metaData, lastImg, editName);\n}\n\nvoid DkBasicLoader::setEditMetaData(const QString &editName)\n{\n    // Add history edit with edited metadata (hasMetaData()), copying last or original image\n    setEditMetaData(mMetaData, image(), editName);\n}\n\nQImage DkBasicLoader::lastImage() const\n{\n    // Find and return the last/current version of the image (ready to be saved to disk)\n    // This is initially the first item (the original image) or the last one,\n    // excluding history items with images that only have modified metadata,\n    // for example, after rotating there'd be a history item with the rotated image\n    // but this rotated pixmap is for the gui only, it should not be saved.\n    for (int idx = mImageIndex; idx >= 0; idx--) {\n        if (mImages[idx].hasNewImage()) {\n            return mImages[idx].image();\n        }\n    }\n\n    return QImage();\n}\n\nQImage DkBasicLoader::pixmap() const\n{\n    // This is sometimes called with an invalid index, for example, after navigating back and forth\n    // if the history has been edited (i.e., > 1 entry). Sometimes, the index is -1 and the history is empty,\n    // which means we have nothing to return (image requested but nothing loaded). (via ViewPort?)\n    if (mImageIndex < 0 || mImageIndex >= mImages.size()) {\n        if (mImages.isEmpty())\n            return QImage();\n        else\n            return mImages.last().image();\n    }\n    // Return current pixmap, which may contain modification from metadata changes like rotation\n    // This should not be used to write the image to disk, use image() instead.\n    return mImages.at(mImageIndex).image();\n}\n\n/**\n * @brief Returns the pointer to the current metadata object which belongs to the loaded image.\n *\n * Note that this is a pointer, not a copy. After changing the metadata, it's necessary\n * to call setEditMetaData(), passing an appropriate edit name, to add a history item (will be copied).\n *\n * @return QSharedPointer<DkMetaDataT>\n */\nQSharedPointer<DkMetaDataT> DkBasicLoader::getMetaData() const\n{\n    QSharedPointer<DkMetaDataT> metaData(mMetaData);\n    return metaData;\n};\n\nQSharedPointer<DkMetaDataT> DkBasicLoader::lastMetaDataEdit(bool return_nullptr, bool return_orig) const\n{\n    QSharedPointer<DkMetaDataT> lastEdit; // null edit\n    if (return_orig) {\n        // Return original metadata only if requested (otherwise only return modified metadata)\n        lastEdit = mImages.first().metaData();\n    } else if (!return_nullptr) {\n        // Empty null object will be returned if no history item (with edited metadata) could be found\n        lastEdit = QSharedPointer<DkMetaDataT>(new DkMetaDataT());\n    }\n\n    // Get latest modified metadata item from history (or null)\n    for (int idx = mImageIndex; idx > 0; idx--) {\n        if (mImages[idx].hasNewMetaData()) {\n            lastEdit = mImages[idx].metaData();\n            break;\n        }\n    }\n\n    return lastEdit;\n}\n\nbool DkBasicLoader::isImageEdited()\n{\n    for (int i = 1, ii = mImageIndex; i <= ii; i++) {\n        if (mImages[i].hasNewImage()) {\n            return true;\n        }\n    }\n    return false;\n}\n\nbool DkBasicLoader::isMetaDataEdited()\n{\n    for (int i = 1, ii = mImageIndex; i <= ii; i++) {\n        if (mImages[i].hasNewMetaData()) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid DkBasicLoader::undo()\n{\n    // Change history index (for image()...)\n    if (mImageIndex > 0)\n        mImageIndex--;\n\n    // Get last history item with modified metadata (up until new history index)\n    QSharedPointer<DkMetaDataT> metaData(mMetaData);\n    metaData = lastMetaDataEdit(false, true);\n    // Update our current metadata object, which is also used elsewhere (pointer)\n    // for example, see DkMetaDataWidgets/DkMetaDataHUD - or DkCommentWidget\n    mMetaData->update(metaData);\n\n    // Notify listeners about changed metadata\n    emit undoSignal();\n    emit resetMetaDataSignal();\n}\n\nvoid DkBasicLoader::redo()\n{\n    // Change history index (for image()...)\n    if (mImageIndex < mImages.size() - 1)\n        mImageIndex++;\n\n    // Get last history item with modified metadata (up until new history index)\n    QSharedPointer<DkMetaDataT> metaData(mMetaData);\n    metaData = lastMetaDataEdit(false, true);\n    // Update our current metadata object, which is also used elsewhere (pointer)\n    // for example, see DkMetaDataWidgets/DkMetaDataHUD - or DkCommentWidget\n    mMetaData->update(metaData);\n\n    // Notify listeners about changed metadata\n    emit redoSignal();\n    emit resetMetaDataSignal();\n}\n\nQVector<DkEditImage> *DkBasicLoader::history()\n{\n    return &mImages;\n}\n\nDkEditImage DkBasicLoader::lastEdit() const\n{\n    assert(mImageIndex >= 0 && mImageIndex < mImages.size());\n    return mImages[mImageIndex];\n}\n\nint DkBasicLoader::historyIndex() const\n{\n    return mImageIndex;\n}\n\nvoid DkBasicLoader::setMinHistorySize(int size)\n{\n    mMinHistorySize = size;\n}\n\nvoid DkBasicLoader::setHistoryIndex(int idx)\n{\n    mImageIndex = idx;\n    // TODO update mMetaData, see undo()\n}\n\n// QByteArray DkBasicLoader::loadFileToBuffer(const QString &filePath) const\n// {\n//     QFileInfo fi(filePath);\n\n//     if (!fi.exists())\n//         return;\n\n// #ifdef WITH_QUAZIP\n//     if (fi.dir().path().contains(DkZipContainer::zipMarker()))\n//         DkZipContainer::extractImage(DkZipContainer::decodeZipFile(filePath), DkZipContainer::decodeImageFile(filePath), ba);\n// #endif\n\n//     QFile file(filePath);\n//     file.open(QIODevice::ReadOnly);\n\n//     ba = file.readAll();\n// }\n\nQSharedPointer<QByteArray> DkBasicLoader::loadFileToBuffer(const QString &filePath) const\n{\n    QFileInfo fi(filePath);\n\n#ifdef WITH_QUAZIP\n    if (fi.dir().path().contains(DkZipContainer::zipMarker()))\n        return DkZipContainer::extractImage(DkZipContainer::decodeZipFile(filePath), DkZipContainer::decodeImageFile(filePath));\n#endif\n\n    QFile file(filePath);\n    file.open(QIODevice::ReadOnly);\n\n    QSharedPointer<QByteArray> ba(new QByteArray(file.readAll()));\n    file.close();\n\n    return ba;\n}\n\n/**\n * @brief writeBufferToFile() writes the passed in file buffer to the specified file.\n *\n * It's called by the save() routine, which saves the image to that file buffer\n * and updates that file buffer to also contain exif data.\n *\n * @param fileInfo path to file to be written\n * @param ba raw content to be written to file\n */\nbool DkBasicLoader::writeBufferToFile(const QString &fileInfo, const QSharedPointer<QByteArray> ba) const\n{\n    if (!ba || ba->isEmpty())\n        return false;\n\n    QFile file(fileInfo);\n    file.open(QIODevice::WriteOnly);\n    qint64 bytesWritten = file.write(*ba.data(), ba->size());\n    file.close();\n    qDebug() << \"[DkBasicLoader] buffer saved, bytes written: \" << bytesWritten;\n\n    if (!bytesWritten || bytesWritten == -1)\n        return false;\n\n    return true;\n}\n\nvoid DkBasicLoader::indexPages(const QString &filePath, const QSharedPointer<QByteArray> ba)\n{\n    // reset counters\n    mNumPages = 1;\n    mPageIdx = 1;\n\n#ifdef WITH_LIBTIFF\n\n    QFileInfo fInfo(filePath);\n\n    // for now we just support tiff's\n    if (!fInfo.suffix().contains(QRegularExpression(\"(tif|tiff)\", QRegularExpression::CaseInsensitiveOption)))\n        return;\n\n    // first turn off nasty warning/error dialogs - (we do the GUI : )\n    TIFFErrorHandler oldErrorHandler, oldWarningHandler;\n    oldWarningHandler = TIFFSetWarningHandler(NULL);\n    oldErrorHandler = TIFFSetErrorHandler(NULL);\n\n    DkTimer dt;\n    TIFF *tiff = 0;\n\n#if defined(Q_OS_WIN)\n    std::istringstream is(ba ? ba->toStdString() : \"\");\n\n    if (ba)\n        tiff = TIFFStreamOpen(\"MemTIFF\", &is);\n\n    // read from file\n    if (!tiff)\n        tiff = TIFFOpen(filePath.toLatin1(), \"r\"); // this->mFile was here before - not sure why\n\n    // loading from buffer allows us to load files with non-latin names\n    QSharedPointer<QByteArray> bal;\n    if (!tiff)\n        bal = loadFileToBuffer(filePath);\n    ;\n    std::istringstream isl(bal ? bal->toStdString() : \"\");\n\n    if (bal)\n        tiff = TIFFStreamOpen(\"MemTIFF\", &isl);\n#else\n    // read from file\n    tiff = TIFFOpen(filePath.toLatin1(), \"r\"); // this->mFile was here before - not sure why\n#endif\n\n    if (!tiff)\n        return;\n\n    // libtiff example\n    int dircount = 0;\n\n    do {\n        dircount++;\n\n    } while (TIFFReadDirectory(tiff));\n\n    mNumPages = dircount;\n\n    if (mNumPages > 1)\n        mPageIdx = 1;\n\n    qDebug() << dircount << \" TIFF directories... \" << dt;\n    TIFFClose(tiff);\n\n    TIFFSetWarningHandler(oldWarningHandler);\n    TIFFSetWarningHandler(oldErrorHandler);\n#else\n    Q_UNUSED(filePath);\n#endif\n}\n\nbool DkBasicLoader::loadPage(int skipIdx)\n{\n    bool imgLoaded = false;\n\n    mPageIdx += skipIdx;\n\n    // <= 1 since first page is loaded using qt\n    if (mPageIdx > mNumPages || mPageIdx <= 1)\n        return imgLoaded;\n\n    return loadPageAt(mPageIdx);\n}\n\nbool DkBasicLoader::loadPageAt(int pageIdx)\n{\n    bool imgLoaded = false;\n\n#ifdef WITH_LIBTIFF\n\n    // <= 1 since first page is loaded using qt\n    if (pageIdx > mNumPages || pageIdx < 1)\n        return imgLoaded;\n\n    // first turn off nasty warning/error dialogs - (we do the GUI : )\n    TIFFErrorHandler oldErrorHandler, oldWarningHandler;\n    oldWarningHandler = TIFFSetWarningHandler(NULL);\n    oldErrorHandler = TIFFSetErrorHandler(NULL);\n\n    DkTimer dt;\n    TIFF *tiff = TIFFOpen(mFile.toLatin1(), \"r\");\n\n#if defined(Q_OS_WIN)\n\n    // loading from buffer allows us to load files with non-latin names\n    QSharedPointer<QByteArray> ba;\n    if (!tiff)\n        ba = loadFileToBuffer(mFile);\n\n    std::istringstream is(ba ? ba->toStdString() : \"\");\n    if (ba)\n        tiff = TIFFStreamOpen(\"MemTIFF\", &is);\n#endif\n\n    if (!tiff)\n        return imgLoaded;\n\n    uint32_t width = 0;\n    uint32_t height = 0;\n\n    // go to current directory\n    for (int idx = 1; idx < pageIdx; idx++) {\n        if (!TIFFReadDirectory(tiff))\n            return false;\n    }\n    TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, &width);\n    TIFFGetField(tiff, TIFFTAG_IMAGELENGTH, &height);\n\n    // init the qImage\n    QImage img = QImage(width, height, QImage::Format_ARGB32);\n\n    const int stopOnError = 1;\n    imgLoaded = TIFFReadRGBAImageOriented(tiff, width, height, reinterpret_cast<uint32_t *>(img.bits()), ORIENTATION_TOPLEFT, stopOnError) != 0;\n\n    if (imgLoaded) {\n        for (uint32_t y = 0; y < height; ++y)\n            convert32BitOrder(img.scanLine(y), width);\n    }\n\n    TIFFClose(tiff);\n\n    TIFFSetWarningHandler(oldWarningHandler);\n    TIFFSetWarningHandler(oldErrorHandler);\n\n    setEditImage(img, tr(\"Original Image\"));\n#else\n    Q_UNUSED(pageIdx);\n#endif\n\n    return imgLoaded;\n}\n\nbool DkBasicLoader::setPageIdx(int skipIdx)\n{\n    // do nothing if we don't have tiff pages\n    if (mNumPages <= 1)\n        return false;\n\n    mPageIdxDirty = false;\n\n    int newPageIdx = mPageIdx + skipIdx;\n\n    if (newPageIdx > 0 && newPageIdx <= mNumPages) {\n        mPageIdxDirty = true;\n        mPageIdx = newPageIdx;\n    }\n\n    return mPageIdxDirty;\n}\n\nvoid DkBasicLoader::resetPageIdx()\n{\n    mPageIdxDirty = false;\n    mPageIdx = 1;\n}\n\nvoid DkBasicLoader::convert32BitOrder(void *buffer, int width) const\n{\n#ifdef WITH_LIBTIFF\n    // code from Qt QTiffHandler\n    uint32_t *target = reinterpret_cast<uint32_t *>(buffer);\n    for (uint32_t x = 0; x < width; ++x) {\n        uint32_t p = target[x];\n        // convert between ARGB and ABGR\n        target[x] = (p & 0xff000000) | ((p & 0x00ff0000) >> 16) | (p & 0x0000ff00) | ((p & 0x000000ff) << 16);\n    }\n#else\n    Q_UNUSED(buffer);\n    Q_UNUSED(width);\n#endif\n}\n\n/**\n * @brief saves the image and its metadata to the specified file.\n *\n * It writes the image to a file buffer and then writes that buffer back to the original file.\n * Modified metadata is saved afterwards.\n *\n * @param filePath target path to image file\n * @param img source image to be written to file (may be converted along the way)\n * @param compression compression flag for QImageWriter\n */\nQString DkBasicLoader::save(const QString &filePath, const QImage &img, int compression)\n{\n    QSharedPointer<QByteArray> ba;\n\n    DkTimer dt;\n    if (saveToBuffer(filePath, img, ba, compression) && ba) {\n        if (writeBufferToFile(filePath, ba)) {\n            qInfo() << \"saved to\" << filePath << \"in\" << dt;\n            return filePath;\n        }\n    }\n\n    return QString();\n}\n\n/**\n * @brief saveToBuffer() writes the image matrix img to the file buffer.\n *\n * The file path is used to convert the image based on the file suffix.\n *\n * @param filePath path to file to which this image will later be written, the suffix is relevant\n * @param img image to be written to file buffer\n * @param ba in-memory file buffer containing resulting file\n * @param compression compression flag for QImageWriter\n */\nbool DkBasicLoader::saveToBuffer(const QString &filePath, const QImage &img, QSharedPointer<QByteArray> &ba, int compression) const\n{\n    bool bufferCreated = false;\n\n    if (!ba) {\n        ba = QSharedPointer<QByteArray>(new QByteArray());\n        bufferCreated = true;\n    }\n    // copy current metadata object: mMetaData pointer may be reset in the background in the process\n    // and then it won't be saved because !isLoaded()... [2022-08, pse]\n    QSharedPointer<DkMetaDataT> metaData = mMetaData;\n\n    bool saved = false;\n\n    QFileInfo fInfo(filePath);\n\n#ifdef Q_OS_WIN\n    if (0 == fInfo.suffix().compare(\"ico\", Qt::CaseInsensitive)) {\n        saved = saveWindowsIcon(img, ba);\n    } else\n#endif\n    {\n        bool hasAlpha = DkImage::alphaChannelUsed(img);\n\n        QImage sImg = img;\n\n        // JPEG 2000 can only handle 32 or 8bit images\n        if (!hasAlpha && img.colorTable().empty() && !fInfo.suffix().contains(QRegularExpression(\"(avif|j2k|jp2|jpf|jpx|jxl|png)\"))) {\n            sImg = sImg.convertToFormat(QImage::Format_RGB888);\n        } else if (fInfo.suffix().contains(QRegularExpression(\"(j2k|jp2|jpf|jpx)\")) && sImg.depth() != 32 && sImg.depth() != 8) {\n            if (sImg.hasAlphaChannel()) {\n                sImg = sImg.convertToFormat(QImage::Format_ARGB32);\n            } else {\n                sImg = sImg.convertToFormat(QImage::Format_RGB32);\n            }\n        }\n\n        if (fInfo.suffix().contains(QRegularExpression(\"(png)\")))\n            compression = -1;\n\n        QBuffer fileBuffer(ba.data());\n        // size_t s = fileBuffer.size();\n        fileBuffer.open(QIODevice::WriteOnly);\n        QImageWriter *imgWriter = new QImageWriter(&fileBuffer, fInfo.suffix().toStdString().c_str());\n\n        if (compression >= 0) { // -1 -> use Qt's default\n            imgWriter->setCompression(compression);\n            imgWriter->setQuality(compression);\n        }\n        if (compression == -1 && imgWriter->format() == \"jpg\") {\n            imgWriter->setQuality(DkSettingsManager::instance().settings().app().defaultJpgQuality);\n        }\n\n        imgWriter->setOptimizedWrite(true); // this saves space TODO: user option here?\n        imgWriter->setProgressiveScanWrite(true);\n\n        saved = imgWriter->write(sImg); // hint: release() might run now, resetting mMetaData which is used below [2022-08, pse]\n        delete imgWriter;\n    }\n\n    if (saved && metaData) {\n        if (!metaData->isLoaded() || !metaData->hasMetaData()) {\n            if (!bufferCreated)\n                metaData->readMetaData(filePath, ba);\n            else\n                // if we created the buffere here - force loading metadata from the file\n                metaData->readMetaData(filePath);\n        }\n\n        // If we have metadata for the image, save it\n        // If your images are saved without metadata, check if the metadata object is discarded or reset\n        // causing isLoaded() to return false (glitch on reload) - pse\n        if (metaData->isLoaded()) {\n            try {\n                // be careful: here we actually lie about the constness\n                metaData->updateImageMetaData(img, false); // set dimensions in exif (do not reset exif orientation)\n                if (!metaData->saveMetaData(ba, true))\n                    metaData->clearExifState();\n            } catch (...) {\n                // is it still throwing anything?\n                qInfo() << \"Sorry, I could not save the meta data...\";\n                // clear exif state here -> the 'dirty' flag would otherwise edit the original image (see #514)\n                metaData->clearExifState();\n            }\n        }\n    }\n\n    if (!saved)\n        emit errorDialogSignal(tr(\"Sorry, I could not save: %1\").arg(fInfo.fileName()));\n\n    return saved;\n}\n\nvoid DkBasicLoader::saveThumbToMetaData(const QString &filePath)\n{\n    QSharedPointer<QByteArray> ba; // dummy\n    saveThumbToMetaData(filePath, ba);\n}\n\nvoid DkBasicLoader::saveThumbToMetaData(const QString &filePath, QSharedPointer<QByteArray> &ba)\n{\n    if (!hasImage())\n        return;\n\n    mMetaData->setThumbnail(DkImage::createThumb(image()));\n    saveMetaData(filePath, ba);\n}\n\n/**\n * @brief this will write the current exif/metadata to the loaded file.\n *\n * It calls the other overload passing an empty buffer,\n * so it'll load the buffer, save the exif data to the buffer\n * and write the buffer back to the file.\n *\n * @param filePath path to current file to be updated\n */\nvoid DkBasicLoader::saveMetaData(const QString &filePath)\n{\n    QSharedPointer<QByteArray> ba; // dummy\n    saveMetaData(filePath, ba);\n}\n\n/**\n * @brief writes metadata to the file on disk, if it's marked as dirty\n *\n * This routine will write new metadata to the file on disk if metadata is marked dirty.\n * It does this by first loading the file into a buffer (unless a non-empty buffer is passed),\n * then it calls the MetaData module to save the exif data to that buffer\n * and finally, it writes the modified buffer to the file on disk.\n * The MetaData module has an overload which does basically the same thing.\n *\n * See ImageLoader (regular workflow starts there) and ImageContainer.\n *\n * @param filePath path to image file\n * @param ba file buffer to be saved (leave empty to work on the specified file as it is on disk)\n */\nvoid DkBasicLoader::saveMetaData(const QString &filePath, QSharedPointer<QByteArray> &ba)\n{\n    if (!ba)\n        ba = QSharedPointer<QByteArray>(new QByteArray());\n\n    if (ba->isEmpty() && mMetaData->isDirty()) {\n        ba = loadFileToBuffer(filePath);\n    }\n\n    // Update in-memory copy of file (ba) with new meta data\n    bool saved = false;\n    try {\n        saved = mMetaData->saveMetaData(ba);\n    } catch (...) {\n        qInfo() << \"could not save metadata...\";\n    }\n\n    // Write in-memory copy to specified file - use this overload only if you really need it\n    if (saved)\n        writeBufferToFile(filePath, ba);\n}\n\nbool DkBasicLoader::isContainer(const QString &filePath)\n{\n    QFileInfo fInfo(filePath);\n    if (!fInfo.isFile() || !fInfo.exists())\n        return false;\n\n    QString suffix = fInfo.suffix();\n\n    if (suffix.isEmpty())\n        return false;\n\n    for (int idx = 0; idx < DkSettingsManager::param().app().containerFilters.size(); idx++) {\n        if (DkSettingsManager::param().app().containerFilters[idx].contains(suffix))\n            return true;\n    }\n\n    return false;\n}\n\n/**\n * @brief releases the currently loaded images.\n *\n * Clears the history.\n * Called by loadGeneral() and ImageContainer::clear().\n *\n * @note This will *not* silently auto-save your beautiful images.\n * It was apparently intended to be used that way (it called saveMetaData(), like ~DkImageContainerT()).\n * All changes should be explicitly committed, including exif notes.\n * If you think this is wrong, a comment would be appreciated. See issue #799. PSE, 2022.\n *\n **/\nvoid DkBasicLoader::release()\n{\n    // TODO: auto save routines here?\n    // answer: no.\n\n    mImages.clear(); // clear history\n    mImageIndex = -1;\n\n    // Unload metadata\n    mMetaData = QSharedPointer<DkMetaDataT>(new DkMetaDataT());\n}\n\n#ifdef Q_OS_WIN\n// bool DkBasicLoader::saveWindowsIcon(const QString &filePath, const QImage &img) const\n// {\n//     QSharedPointer<QByteArray> ba;\n\n//     if (saveWindowsIcon(img, ba) && ba && !ba->isEmpty()) {\n//         writeBufferToFile(filePath, ba);\n//         return true;\n//     }\n\n//     return false;\n// }\n\nstruct ICONDIRENTRY {\n    UCHAR nWidth;\n    UCHAR nHeight;\n    UCHAR nNumColorsInPalette; // 0 if no palette\n    UCHAR nReserved; // should be 0\n    WORD nNumColorPlanes; // 0 or 1\n    WORD nBitsPerPixel;\n    ULONG nDataLength; // length in bytes\n    ULONG nOffset; // offset of BMP or PNG data from beginning of file\n};\n\nbool DkBasicLoader::saveWindowsIcon(const QImage &img, QSharedPointer<QByteArray> &ba) const\n{\n    // this code is an adopted version of:\n    // http://stackoverflow.com/questions/2289894/how-can-i-save-hicon-to-an-ico-file\n\n    if (!ba)\n        ba = QSharedPointer<QByteArray>(new QByteArray());\n\n#if QT_VERSION < QT_VERSION_CHECK(6, 0, 0)\n    HICON hIcon = QtWin::toHICON(QPixmap::fromImage(img));\n#else\n    HICON hIcon = img.toHICON();\n#endif\n    int nColorBits = 32;\n\n    QBuffer buffer(ba.data());\n    buffer.open(QIODevice::WriteOnly);\n\n    if (!hIcon)\n        return false;\n\n    HDC screenDevice = GetDC(0);\n\n    // Write header:\n    UCHAR icoHeader[6] = {0, 0, 1, 0, 1, 0}; // ICO file with 1 image\n    buffer.write((const char *)(&icoHeader), sizeof(icoHeader));\n\n    // Get information about icon:\n    ICONINFO iconInfo;\n    GetIconInfo(hIcon, &iconInfo);\n    HGDIOBJ handle1(iconInfo.hbmColor); // free bitmaps when function ends\n    BITMAPINFO bmInfo = {0};\n    bmInfo.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);\n    bmInfo.bmiHeader.biBitCount = 0; // don't get the color table\n    if (!GetDIBits(screenDevice, iconInfo.hbmColor, 0, 0, NULL, &bmInfo, DIB_RGB_COLORS)) {\n        return false;\n    }\n\n    // Allocate size of bitmap info header plus space for color table:\n    int nBmInfoSize = sizeof(BITMAPINFOHEADER);\n    if (nColorBits < 24) {\n        nBmInfoSize += sizeof(RGBQUAD) * (int)(1 << nColorBits);\n    }\n\n    QSharedPointer<UCHAR> bitmapInfo(new UCHAR[nBmInfoSize]);\n    BITMAPINFO *pBmInfo = (BITMAPINFO *)bitmapInfo.data();\n    memcpy(pBmInfo, &bmInfo, sizeof(BITMAPINFOHEADER));\n\n    // Get bitmap data:\n    QSharedPointer<UCHAR> bits(new UCHAR[bmInfo.bmiHeader.biSizeImage]);\n    pBmInfo->bmiHeader.biBitCount = (WORD)nColorBits;\n    pBmInfo->bmiHeader.biCompression = BI_RGB;\n    if (!GetDIBits(screenDevice, iconInfo.hbmColor, 0, bmInfo.bmiHeader.biHeight, bits.data(), pBmInfo, DIB_RGB_COLORS)) {\n        return false;\n    }\n\n    // Get mask data:\n    BITMAPINFO maskInfo = {0};\n    maskInfo.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);\n    maskInfo.bmiHeader.biBitCount = 0; // don't get the color table\n    if (!GetDIBits(screenDevice, iconInfo.hbmMask, 0, 0, NULL, &maskInfo, DIB_RGB_COLORS)) {\n        return false;\n    }\n\n    QSharedPointer<UCHAR> maskBits(new UCHAR[maskInfo.bmiHeader.biSizeImage]);\n    QSharedPointer<UCHAR> maskInfoBytes(new UCHAR[sizeof(BITMAPINFO) + 2 * sizeof(RGBQUAD)]);\n    BITMAPINFO *pMaskInfo = (BITMAPINFO *)maskInfoBytes.data();\n    memcpy(pMaskInfo, &maskInfo, sizeof(maskInfo));\n    if (!GetDIBits(screenDevice, iconInfo.hbmMask, 0, maskInfo.bmiHeader.biHeight, maskBits.data(), pMaskInfo, DIB_RGB_COLORS)) {\n        return false;\n    }\n\n    // Write directory entry:\n    ICONDIRENTRY dir;\n    dir.nWidth = (UCHAR)pBmInfo->bmiHeader.biWidth;\n    dir.nHeight = (UCHAR)pBmInfo->bmiHeader.biHeight;\n    dir.nNumColorsInPalette = (nColorBits == 4 ? 16 : 0);\n    dir.nReserved = 0;\n    dir.nNumColorPlanes = 0;\n    dir.nBitsPerPixel = pBmInfo->bmiHeader.biBitCount;\n    dir.nDataLength = pBmInfo->bmiHeader.biSizeImage + pMaskInfo->bmiHeader.biSizeImage + nBmInfoSize;\n    dir.nOffset = sizeof(dir) + sizeof(icoHeader);\n    buffer.write((const char *)&dir, sizeof(dir));\n\n    // Write DIB header (including color table):\n    int nBitsSize = pBmInfo->bmiHeader.biSizeImage;\n    pBmInfo->bmiHeader.biHeight *= 2; // because the header is for both image and mask\n    pBmInfo->bmiHeader.biCompression = 0;\n    pBmInfo->bmiHeader.biSizeImage += pMaskInfo->bmiHeader.biSizeImage; // because the header is for both image and mask\n    buffer.write((const char *)&pBmInfo->bmiHeader, nBmInfoSize);\n\n    // Write image data:\n    buffer.write((const char *)bits.data(), nBitsSize);\n\n    // Write mask data:\n    buffer.write((const char *)maskBits.data(), pMaskInfo->bmiHeader.biSizeImage);\n\n    buffer.close();\n\n    DeleteObject(handle1);\n\n    return true;\n}\n\n#endif // #ifdef Q_OS_WIN\n\n#ifdef WITH_OPENCV\n\n// cv::Mat DkBasicLoader::getImageCv()\n// {\n//     return cv::Mat();\n// }\n\nbool DkBasicLoader::loadOpenCVVecFile(const QString &filePath, QImage &img, QSharedPointer<QByteArray> ba, QSize s) const\n{\n    if (!ba)\n        ba = QSharedPointer<QByteArray>(new QByteArray());\n\n    // load from file?\n    if (ba->isEmpty())\n        ba = loadFileToBuffer(filePath);\n\n    if (ba->isEmpty())\n        return false;\n\n    // read header & get a pointer to the first image\n    int fileCount, vecSize;\n    const unsigned char *imgPtr = (const unsigned char *)ba->constData();\n    if (!readHeader(&imgPtr, fileCount, vecSize))\n        return false;\n\n    int guessedW = 0;\n    int guessedH = 0;\n\n    getPatchSizeFromFileName(QFileInfo(filePath).fileName(), guessedW, guessedH);\n\n    qDebug() << \"patch size from filename: \" << guessedW << \" x \" << guessedH;\n\n    if (vecSize > 0 && !guessedH && !guessedW) {\n        guessedW = qFloor(sqrt((float)vecSize));\n        if (guessedW > 0)\n            guessedH = vecSize / guessedW;\n    }\n\n    if (guessedW <= 0 || guessedH <= 0 || guessedW * guessedH != vecSize) {\n        // TODO: ask user\n        qDebug() << \"dimensions do not match, patch size: \" << guessedW << \" x \" << guessedH << \" vecSize: \" << vecSize;\n        return false;\n    }\n\n    int fSize = ba->size();\n    int numElements = 0;\n\n    // guess size\n    if (s.isEmpty()) {\n        double nEl = (fSize - 64) / (vecSize * 2);\n        nEl = (fSize - 64 - qCeil(nEl)) / (vecSize * 2) + 1; // opencv adds one byte per image - so we take care for this here\n\n        if (qFloor(nEl) != qCeil(nEl))\n            return false;\n        numElements = qRound(nEl);\n    }\n\n    double nRowsCols = sqrt(numElements);\n    int numCols = qCeil(nRowsCols);\n    int minusOneRow = (qFloor(nRowsCols) != qCeil(nRowsCols) && nRowsCols - qFloor(nRowsCols) < 0.5) ? 1 : 0;\n\n    cv::Mat allPatches((numCols - minusOneRow) * guessedH, numCols * guessedW, CV_8UC1, cv::Scalar(125));\n\n    for (int idx = 0; idx < numElements; idx++) {\n        if (*imgPtr != 0) {\n            qDebug() << \"skipping non-empty byte - there is something seriously wrong here!\";\n            // return false;\t// stop if the byte is non-empty -> otherwise we might read wrong memory\n        }\n\n        imgPtr++; // there is an empty byte between images\n        cv::Mat cPatch = getPatch(&imgPtr, QSize(guessedW, guessedH));\n        cv::Mat cPatchAll = allPatches(cv::Rect(idx % numCols * guessedW, qFloor(idx / numCols) * guessedH, guessedW, guessedH));\n\n        if (!cPatchAll.empty())\n            cPatch.copyTo(cPatchAll);\n    }\n\n    img = DkImage::mat2QImage(allPatches);\n    img = img.convertToFormat(QImage::Format_ARGB32);\n\n    // setEditImage(img, tr(\"Original Image\"));\n\n    return true;\n}\n\nvoid DkBasicLoader::getPatchSizeFromFileName(const QString &fileName, int &width, int &height) const\n{\n    // parse patch size from file\n    QStringList sections = fileName.split(QRegularExpression(\"[-\\\\.]\"));\n\n    for (int idx = 0; idx < sections.size(); idx++) {\n        QString tmpSec = sections[idx];\n        qDebug() << \"section: \" << tmpSec;\n\n        if (tmpSec.contains(\"w\"))\n            width = tmpSec.remove(\"w\").toInt();\n        else if (tmpSec.contains(\"h\"))\n            height = tmpSec.remove(\"h\").toInt();\n    }\n}\n\nbool DkBasicLoader::readHeader(const unsigned char **dataPtr, int &fileCount, int &vecSize) const\n{\n    const int *pData = (const int *)*dataPtr;\n    fileCount = *pData;\n    pData++; // read file count\n    vecSize = *pData; // read vec size\n\n    qDebug() << \"vec size: \" << vecSize << \" fileCount \" << fileCount;\n\n    *dataPtr += 12; // skip the first 12 (header) bytes\n\n    return true;\n}\n\n// the double pointer is here needed to additionally increase the pointer value\ncv::Mat DkBasicLoader::getPatch(const unsigned char **dataPtr, QSize patchSize) const\n{\n    cv::Mat img8U(patchSize.height(), patchSize.width(), CV_8UC1, cv::Scalar(0));\n\n    // ok, take just the second byte\n    for (int rIdx = 0; rIdx < img8U.rows; rIdx++) {\n        unsigned char *ptr8U = img8U.ptr<unsigned char>(rIdx);\n\n        for (int cIdx = 0; cIdx < img8U.cols; cIdx++) {\n            ptr8U[cIdx] = **dataPtr;\n            *dataPtr += 2; // it is strange: opencv stores vec files as 16 bit but just use the 2nd byte\n        }\n    }\n\n    return img8U;\n}\n\nint DkBasicLoader::mergeVecFiles(const QStringList &vecFilePaths, QString &saveFilePath) const\n{\n    int lastVecSize = 0;\n    int totalFileCount = 0;\n    int vecCount = 0;\n    int pWidth = 0, pHeight = 0;\n    QByteArray vecBuffer;\n\n    for (const QString &filePath : vecFilePaths) {\n        QFileInfo fInfo(filePath);\n        QSharedPointer<QByteArray> ba = loadFileToBuffer(filePath);\n        if (ba->isEmpty()) {\n            qDebug() << \"could not load: \" << fInfo.fileName();\n            continue;\n        }\n\n        int fileCount, vecSize;\n        const unsigned char *dataPtr = (const unsigned char *)ba->constData();\n        if (!readHeader(&dataPtr, fileCount, vecSize)) {\n            qDebug() << \"could not read header, skipping: \" << fInfo.fileName();\n            continue;\n        }\n\n        if (lastVecSize && vecSize != lastVecSize) {\n            qDebug() << \"wrong vec size, skipping: \" << fInfo.fileName();\n            continue;\n        }\n\n        vecBuffer.append((const char *)dataPtr, vecSize * fileCount * 2 + fileCount); // +fileCount accounts for the '\\0' bytes between the patches\n\n        getPatchSizeFromFileName(fInfo.fileName(), pWidth, pHeight);\n\n        totalFileCount += fileCount;\n        lastVecSize = vecSize;\n\n        vecCount++;\n    }\n\n    // don't save if we could not merge the files\n    if (!vecCount)\n        return vecCount;\n\n    unsigned int *header = new unsigned int[3];\n    header[0] = totalFileCount;\n    header[1] = lastVecSize;\n    header[2] = 0;\n\n    vecBuffer.prepend((const char *)header, 3 * sizeof(int));\n\n    QFileInfo saveFileInfo(saveFilePath);\n\n    // append width, height if we don't know\n    if (pWidth && pHeight) {\n        QString whString = \"-w\" + QString::number(pWidth) + \"-h\" + QString::number(pHeight);\n        saveFileInfo = QFileInfo(saveFileInfo.absolutePath(), saveFileInfo.baseName() + whString + \".\" + saveFileInfo.suffix());\n    }\n\n    QFile file(saveFileInfo.absoluteFilePath());\n    file.open(QIODevice::WriteOnly);\n    file.write(vecBuffer);\n    file.close();\n\n    return vecCount;\n}\n\n#endif // #ifdef WITH_OPENCV\n\n// FileDownloader --------------------------------------------------------------------\nFileDownloader::FileDownloader(const QUrl &imageUrl, const QString &filePath, QObject *parent)\n    : QObject(parent)\n{\n    mFilePath = filePath;\n\n    QNetworkProxyQuery npq(QUrl(\"https://google.com\"));\n    QList<QNetworkProxy> listOfProxies = QNetworkProxyFactory::systemProxyForQuery(npq);\n    if (!listOfProxies.empty() && listOfProxies[0].hostName() != \"\") {\n        mWebCtrl.setProxy(listOfProxies[0]);\n    }\n\n    connect(&mWebCtrl, &QNetworkAccessManager::finished, this, &FileDownloader::fileDownloaded);\n\n    downloadFile(imageUrl);\n}\n\nFileDownloader::~FileDownloader()\n{\n}\n\nvoid FileDownloader::downloadFile(const QUrl &url)\n{\n    QNetworkRequest request(url);\n    mWebCtrl.get(request);\n    mUrl = url;\n}\n\nvoid FileDownloader::saved()\n{\n    if (mSaveWatcher.result()) {\n        qInfo() << \"downloaded image saved to\" << mFilePath;\n        emit downloaded(mFilePath);\n    } else {\n        qWarning() << \"could not download file to \" << mFilePath;\n    }\n}\n\nbool FileDownloader::save(const QString &filePath, const QSharedPointer<QByteArray> data)\n{\n    if (!data) {\n        qWarning() << \"cannot save file if data is NULL\";\n        return false;\n    }\n\n    QFileInfo fi(filePath);\n\n    if (!fi.absoluteDir().exists())\n        QDir().mkpath(fi.absolutePath());\n\n    QFile f(filePath);\n    f.open(QIODevice::WriteOnly);\n\n    return f.write(*data);\n}\n\nvoid FileDownloader::fileDownloaded(QNetworkReply *pReply)\n{\n    if (pReply->error() != QNetworkReply::NoError) {\n        qWarning() << \"I could not download: \" << mUrl;\n        qWarning() << pReply->errorString();\n    }\n\n    mDownloadedData = QSharedPointer<QByteArray>(new QByteArray(pReply->readAll()));\n    // emit a signal\n    pReply->deleteLater();\n\n    // data only requested\n    if (mFilePath.isEmpty()) {\n        emit downloaded();\n    }\n    // ok save it\n    else {\n        connect(&mSaveWatcher, &QFutureWatcherBase::finished, this, &FileDownloader::saved, Qt::UniqueConnection);\n        mSaveWatcher.setFuture(QtConcurrent::run([&] {\n            return save(mFilePath, mDownloadedData);\n        }));\n    }\n}\n\nQSharedPointer<QByteArray> FileDownloader::downloadedData() const\n{\n    return mDownloadedData;\n}\n\nQUrl FileDownloader::getUrl() const\n{\n    return mUrl;\n}\n\n#ifdef WITH_QUAZIP\n\n// DkZipContainer --------------------------------------------------------------------\nDkZipContainer::DkZipContainer(const QString &encodedFilePath)\n{\n    if (!encodedFilePath.isEmpty() && encodedFilePath.contains(mZipMarker)) {\n        mImageInZip = true;\n        mEncodedFilePath = encodedFilePath;\n        mZipFilePath = decodeZipFile(encodedFilePath);\n        mImageFileName = decodeImageFile(encodedFilePath);\n    } else\n        mImageInZip = false;\n}\n\nQString DkZipContainer::encodeZipFile(const QString &zipFile, const QString &imageFile)\n{\n    // if you think this code is unreadable, take a look at the old line:\n    // return QFileInfo(QDir(zipFile.absoluteFilePath() + mZipMarker + imageFile.left(imageFile.lastIndexOf(\"/\") + 1).replace(\"/\",\n    // mZipMarker)),(imageFile.lastIndexOf(\"/\") < 0) ? imageFile : imageFile.right(imageFile.size() - imageFile.lastIndexOf(\"/\") - 1));\n\n    QDir dir = QDir(zipFile + mZipMarker + imageFile.left(imageFile.lastIndexOf(\"/\") + 1).replace(\"/\", mZipMarker));\n    QString fileName = (imageFile.lastIndexOf(\"/\") < 0) ? imageFile : imageFile.right(imageFile.size() - imageFile.lastIndexOf(\"/\") - 1);\n\n    return QFileInfo(dir, fileName).absoluteFilePath();\n}\n\nQString DkZipContainer::decodeZipFile(const QString &encodedFileInfo)\n{\n    QString encodedDir = QFileInfo(encodedFileInfo).absolutePath();\n\n    return encodedDir.left(encodedDir.indexOf(mZipMarker));\n}\n\nQString DkZipContainer::decodeImageFile(const QString &encodedFileInfo)\n{\n    // get relative zip path\n    QString tmp = encodedFileInfo.right(encodedFileInfo.size() - encodedFileInfo.indexOf(mZipMarker) - QString(mZipMarker).size());\n    tmp = tmp.replace(mZipMarker, \"/\");\n    tmp = tmp.replace(\"//\", \"/\");\n\n    // diem: this fixes an issue with images that are in a zip's root folder\n    if (tmp.startsWith(\"/\"))\n        tmp = tmp.right(tmp.length() - 1);\n\n    return tmp;\n}\n\nQSharedPointer<QByteArray> DkZipContainer::extractImage(const QString &zipFile, const QString &imageFile)\n{\n    QuaZip zip(zipFile);\n    if (!zip.open(QuaZip::mdUnzip))\n        return QSharedPointer<QByteArray>(new QByteArray());\n\n    qDebug() << \"DkZip::extractImage filePath: \" << zipFile;\n    qDebug() << \"3.0 image file\" << imageFile;\n\n    zip.setCurrentFile(imageFile);\n    QuaZipFile extractedFile(&zip);\n    if (!extractedFile.open(QIODevice::ReadOnly) || extractedFile.getZipError() != UNZ_OK)\n        return QSharedPointer<QByteArray>(new QByteArray());\n\n    QSharedPointer<QByteArray> ba(new QByteArray(extractedFile.readAll()));\n    extractedFile.close();\n\n    zip.close();\n\n    return ba;\n}\n\nvoid DkZipContainer::extractImage(const QString &zipFile, const QString &imageFile, QByteArray &ba)\n{\n    QuaZip zip(zipFile);\n    if (!zip.open(QuaZip::mdUnzip))\n        return;\n\n    zip.setCurrentFile(imageFile);\n    QuaZipFile extractedFile(&zip);\n    if (!extractedFile.open(QIODevice::ReadOnly) || extractedFile.getZipError() != UNZ_OK)\n        return;\n\n    ba = QByteArray(extractedFile.readAll());\n    extractedFile.close();\n\n    zip.close();\n}\n\nbool DkZipContainer::isZip() const\n{\n    return mImageInZip;\n}\n\nQString DkZipContainer::getZipFilePath() const\n{\n    return mZipFilePath;\n}\n\nQString DkZipContainer::getImageFileName() const\n{\n    return mImageFileName;\n}\n\nQString DkZipContainer::getEncodedFilePath() const\n{\n    return mEncodedFilePath;\n}\n\nQString DkZipContainer::zipMarker()\n{\n    return mZipMarker;\n}\n\n#endif\n\n// DkRawLoader --------------------------------------------------------------------\nDkRawLoader::DkRawLoader(const QString &filePath, const QSharedPointer<DkMetaDataT> &metaData)\n{\n    mFilePath = filePath;\n    mMetaData = metaData;\n}\n\nbool DkRawLoader::isEmpty() const\n{\n    return mFilePath.isEmpty();\n}\n\nvoid DkRawLoader::setLoadFast(bool fast)\n{\n    mLoadFast = fast;\n}\n\nbool DkRawLoader::load(const QSharedPointer<QByteArray> ba)\n{\n    DkTimer dt;\n\n    // try fetching the preview\n    if (loadPreview(ba))\n        return true;\n\n#ifdef WITH_LIBRAW\n\n    try {\n        // open the buffer\n        LibRaw iProcessor;\n\n        iProcessor.imgdata.params.use_camera_wb = 1;\n        iProcessor.imgdata.params.output_color = 1;\n        iProcessor.imgdata.params.output_bps = 8;\n        iProcessor.imgdata.params.four_color_rgb = 1;\n        iProcessor.imgdata.params.user_flip = 0;\n\n        if (DkSettingsManager::param().resources().filterRawImages) {\n            iProcessor.imgdata.params.user_qual = 3;\n            iProcessor.imgdata.params.dcb_enhance_fl = 1;\n            iProcessor.imgdata.params.fbdd_noiserd = 2;\n        } else {\n            iProcessor.imgdata.params.user_qual = 0;\n            iProcessor.imgdata.params.dcb_enhance_fl = 0;\n            iProcessor.imgdata.params.fbdd_noiserd = 0;\n        }\n\n        if (!openBuffer(ba, iProcessor)) {\n            qDebug() << \"could not open buffer for\" << mFilePath;\n            return false;\n        }\n\n        // check camera models for specific hacks\n        detectSpecialCamera(iProcessor);\n\n        // try loading RAW preview\n        if (mLoadFast) {\n            mImg = loadPreviewRaw(iProcessor);\n            mImg.setText(\"RAW.IsPreview\", mImg.isNull() ? \"no\" : \"yes\");\n\n            // are we done already?\n            if (!mImg.isNull())\n                return true;\n        }\n\n        // unpack the data\n        int error = iProcessor.unpack();\n        if (std::strcmp(iProcessor.version(), \"0.13.5\") != 0) // fixes a bug specific to libraw 13 - version call is UNTESTED\n            iProcessor.raw2image();\n\n        if (error != LIBRAW_SUCCESS)\n            return false;\n\n        // develop using libraw\n        error = iProcessor.dcraw_process();\n\n        auto rimg = iProcessor.dcraw_make_mem_image();\n\n        if (rimg) {\n            mImg = QImage(rimg->data, rimg->width, rimg->height, rimg->width * 3, QImage::Format_RGB888);\n            mImg = mImg.copy(); // make a deep copy...\n            mImg.setColorSpace(QColorSpace(QColorSpace::SRgb));\n            LibRaw::dcraw_clear_mem(rimg);\n            mImg.setText(\"RAW.Loader\", \"Default\");\n            mImg.setText(\"RAW.IsPreview\", \"no\");\n            return true;\n        }\n\n        // demosaic image\n        cv::Mat rawMat;\n\n        QHash<QString, QString> info; // info for mImg.setText()\n        info.insert(\"RAW.Loader\", \"Nomacs\");\n        info.insert(\"RAW.IsPreview\", \"no\");\n\n        if (iProcessor.imgdata.idata.filters) {\n            rawMat = demosaic(iProcessor);\n            info.insert(\"RAW.Processing\", \"Demosaic\");\n        } else {\n            rawMat = prepareImg(iProcessor);\n            info.insert(\"RAW.Processing\", \"Copy\");\n        }\n\n        // color correction + white balance\n        if (mIsChromatic)\n            whiteBalance(iProcessor, rawMat);\n\n        info.insert(\"RAW.ColorCorrection\", mIsChromatic ? \"yes\" : \"no\");\n\n        // gamma correction\n        gammaCorrection(iProcessor, rawMat);\n\n        // reduce color noise\n        bool noiseReduced = false;\n        if (DkSettingsManager::param().resources().filterRawImages && mIsChromatic) {\n            reduceColorNoise(iProcessor, rawMat);\n            noiseReduced = true;\n        }\n        info.insert(\"RAW.NoiseReduction\", noiseReduced ? \"yes\" : \"no\");\n\n        mImg = raw2Img(iProcessor, rawMat);\n\n        for (auto &key : qAsConst(info).keys())\n            mImg.setText(key, info.value(key));\n\n        // qDebug() << \"img size\" << mImg.size();\n        // qDebug() << \"raw mat size\" << rawMat.rows << \"x\" << rawMat.cols;\n        iProcessor.recycle();\n        rawMat.release();\n    } catch (...) {\n        qDebug() << \"[RAW] error during processing...\";\n        return false;\n    }\n\n    qInfo() << \"[RAW] loaded in \" << dt;\n\n#endif\n\n    return !mImg.isNull();\n}\n\nQImage DkRawLoader::image() const\n{\n    return mImg;\n}\n\nbool DkRawLoader::loadPreview(const QSharedPointer<QByteArray> &ba)\n{\n    try {\n        // try to get preview image from exiv2\n        if (mMetaData) {\n            if (mLoadFast || DkSettingsManager::param().resources().loadRawThumb == DkSettings::raw_thumb_always\n                || DkSettingsManager::param().resources().loadRawThumb == DkSettings::raw_thumb_if_large) {\n                mMetaData->readMetaData(mFilePath, ba);\n\n                int minWidth = 0;\n\n#ifdef WITH_LIBRAW // if nomacs has libraw - we can still hope for a fallback -> otherwise try whatever we have here\n                if (DkSettingsManager::param().resources().loadRawThumb == DkSettings::raw_thumb_if_large)\n                    minWidth = 1920;\n#endif\n                mImg = mMetaData->getPreviewImage(minWidth);\n\n                if (!mImg.isNull()) {\n                    qDebug() << \"[RAW] loaded with exiv2\";\n                    return true;\n                }\n            }\n        }\n    } catch (...) {\n        qWarning() << \"Exception caught during fetching RAW from thumbnail...\";\n    }\n\n    return false;\n}\n\n#ifdef WITH_LIBRAW\n\n// here are some hints from earlier days...\n//// (-w) Use camera white balance, if possible (otherwise, fallback to auto_wb)\n// iProcessor.imgdata.params.use_camera_wb = 1;\n//// (-a) Use automatic white balance obtained after averaging over the entire image\n// iProcessor.imgdata.params.use_auto_wb = 1;\n//// (-q 3) Adaptive homogeneity-directed de-mosaicing algorithm (AHD)\n// iProcessor.imgdata.params.user_qual = 3;\n// iProcessor.imgdata.params.output_tiff = 1;\n////iProcessor.imgdata.params.four_color_rgb = 1;\n////iProcessor.imgdata.params.output_color = 1; //sRGB  (0...raw)\n//// RAW data filtration mode during data unpacking and post-processing\n// iProcessor.imgdata.params.filtering_mode = LIBRAW_FILTERING_AUTOMATIC;\n\nQImage DkRawLoader::loadPreviewRaw(LibRaw &iProcessor) const\n{\n    int tW = iProcessor.imgdata.thumbnail.twidth;\n\n    if (DkSettingsManager::param().resources().loadRawThumb == DkSettings::raw_thumb_always\n        || (DkSettingsManager::param().resources().loadRawThumb == DkSettings::raw_thumb_if_large && tW >= 1920)) {\n        // crashes here if image is broken\n        int err = iProcessor.unpack_thumb();\n        char *tPtr = iProcessor.imgdata.thumbnail.thumb;\n\n        if (!err && tPtr) {\n            QImage img;\n            img.loadFromData((const uchar *)tPtr, iProcessor.imgdata.thumbnail.tlength);\n\n            // we're good to go\n            if (!img.isNull()) {\n                qDebug() << \"[RAW] I loaded the RAW's thumbnail\";\n                return img;\n            } else\n                qDebug() << \"RAW could not load the thumb\";\n        } else\n            qDebug() << \"error unpacking the thumb...\";\n    }\n\n    // default: return nothing\n    return QImage();\n}\n\nbool DkRawLoader::openBuffer(const QSharedPointer<QByteArray> &ba, LibRaw &iProcessor) const\n{\n    int error = LIBRAW_DATA_ERROR;\n\n    QFileInfo fi(mFilePath);\n\n    // use iprocessor from libraw to read the data\n    // OK - so LibRaw 0.17 cannot identify iiq files in the buffer - so we load them from the file\n    if (fi.suffix().contains(\"iiq\", Qt::CaseInsensitive) || !ba || ba->isEmpty()) {\n        error = iProcessor.open_file(mFilePath.toStdString().c_str());\n    } else {\n        // the buffer check is because:\n        // libraw has an error when loading buffers if the first 4 bytes encode as 'RIFF'\n        // and no data follows at all\n        if (ba->isEmpty() || ba->size() < 100)\n            return false;\n\n        error = iProcessor.open_buffer((void *)ba->constData(), ba->size());\n    }\n\n    return (error == LIBRAW_SUCCESS);\n}\n\nvoid DkRawLoader::detectSpecialCamera(const LibRaw &iProcessor)\n{\n    if (QString(iProcessor.imgdata.idata.model) == \"IQ260 Achromatic\")\n        mIsChromatic = false;\n\n    if (QString(iProcessor.imgdata.idata.model).contains(\"IQ260\"))\n        mCamType = camera_iiq;\n    else if (QString(iProcessor.imgdata.idata.make).compare(\"Canon\", Qt::CaseInsensitive))\n        mCamType = camera_canon;\n\n    // add your camera flag (for hacks) here\n}\n\ncv::Mat DkRawLoader::demosaic(LibRaw &iProcessor) const\n{\n    cv::Mat rawMat = cv::Mat(iProcessor.imgdata.sizes.height, iProcessor.imgdata.sizes.width, CV_16UC1);\n    double dynamicRange = (double)(iProcessor.imgdata.color.maximum - iProcessor.imgdata.color.black);\n\n    // normalize all image values\n    for (int rIdx = 0; rIdx < rawMat.rows; rIdx++) {\n        unsigned short *ptrRaw = rawMat.ptr<unsigned short>(rIdx);\n\n        for (int cIdx = 0; cIdx < rawMat.cols; cIdx++) {\n            int colIdx = iProcessor.COLOR(rIdx, cIdx);\n            double val = (double)(iProcessor.imgdata.image[(rawMat.cols * rIdx) + cIdx][colIdx]);\n\n            // normalize the value w.r.t the black point defined\n            val = (val - iProcessor.imgdata.color.black) / dynamicRange;\n            ptrRaw[cIdx] = clip<unsigned short>(val * USHRT_MAX); // for conversion to 16U\n        }\n    }\n\n    // no demosaicing\n    if (mIsChromatic) {\n        unsigned long type = (unsigned long)iProcessor.imgdata.idata.filters;\n        type = type & 255;\n\n        cv::Mat rgbImg;\n\n        // define bayer pattern\n        if (type == 180) {\n            cvtColor(rawMat, rgbImg, CV_BayerBG2RGB); // bitmask  10 11 01 00  -> 3(G) 2(B) 1(G) 0(R) ->\tRG RG RG\n                                                      //\t\t\t\t\t\t\t\t\t\t\t\t\tGB GB GB\n        } else if (type == 30) {\n            cvtColor(rawMat, rgbImg, CV_BayerRG2RGB); // bitmask  00 01 11 10\t-> 0 1 3 2\n        } else if (type == 225) {\n            cvtColor(rawMat, rgbImg, CV_BayerGB2RGB); // bitmask  11 10 00 01\n        } else if (type == 75) {\n            cvtColor(rawMat, rgbImg, CV_BayerGR2RGB); // bitmask  01 00 10 11\n        } else {\n            qWarning() << \"Wrong Bayer Pattern (not BG, RG, GB, GR)\\n\";\n            return cv::Mat();\n        }\n\n        rawMat = rgbImg;\n    }\n\n    // 16U (1 or 3 channeled) Mat\n    return rawMat;\n}\n\ncv::Mat DkRawLoader::prepareImg(const LibRaw &iProcessor) const\n{\n    cv::Mat rawMat = cv::Mat(iProcessor.imgdata.sizes.height, iProcessor.imgdata.sizes.width, CV_16UC3, cv::Scalar(0));\n    double dynamicRange = (double)(iProcessor.imgdata.color.maximum - iProcessor.imgdata.color.black);\n\n    // normalization function\n    auto normalize = [&](double val) {\n        val = (val - iProcessor.imgdata.color.black) / dynamicRange;\n        return clip<unsigned short>(val * USHRT_MAX);\n    };\n\n    for (int rIdx = 0; rIdx < rawMat.rows; rIdx++) {\n        unsigned short *ptrI = rawMat.ptr<unsigned short>(rIdx);\n\n        for (int cIdx = 0; cIdx < rawMat.cols; cIdx++) {\n            *ptrI = normalize(iProcessor.imgdata.image[rawMat.cols * rIdx + cIdx][0]);\n            ptrI++;\n            *ptrI = normalize(iProcessor.imgdata.image[rawMat.cols * rIdx + cIdx][1]);\n            ptrI++;\n            *ptrI = normalize(iProcessor.imgdata.image[rawMat.cols * rIdx + cIdx][2]);\n            ptrI++;\n        }\n    }\n\n    return rawMat;\n}\n\ncv::Mat DkRawLoader::whiteMultipliers(const LibRaw &iProcessor) const\n{\n    // get camera white balance multipliers\n    cv::Mat wm(1, 4, CV_32FC1);\n\n    float *wmp = wm.ptr<float>();\n\n    for (int idx = 0; idx < wm.cols; idx++)\n        wmp[idx] = iProcessor.imgdata.color.cam_mul[idx];\n\n    if (wmp[3] == 0)\n        wmp[3] = wmp[1]; // take green (usually its RGBG)\n\n    // normalize white balance multipliers\n    float w = (float)cv::sum(wm)[0] / 4.0f;\n    float maxW = 1.0f;\n\n    // clipping according the camera model\n    // if w > 2.0 maxW is 256, otherwise 512\n    // tested empirically\n    // check if it can be defined by some metadata settings?\n    if (w > 2.0f)\n        maxW = 255.0f;\n    if (w > 2.0f && mCamType == camera_canon)\n        maxW = 511.0f; // some cameras would even need ~800 - why?\n\n    // normalize white point\n    wm /= maxW;\n\n    // 1 x 4 32FC1 white balance vector\n    return wm;\n}\n\ncv::Mat DkRawLoader::gammaTable(const LibRaw &iProcessor) const\n{\n    // OK this is an instance of reverse engineering:\n    // we found out that the values of (at least) the PhaseOne's achromatic back have to be doubled\n    // our images are no close to what their software (Capture One does) - only the gamma correction\n    // seems to be slightly different... -> now we can load compressed IIQs that are not supported by PS : )\n    double cameraHackMlp = (QString(iProcessor.imgdata.idata.model) == \"IQ260 Achromatic\") ? 2.0 : 1.0;\n\n    // read gamma value and create gamma table\n    double gamma = (double)iProcessor.imgdata.params.gamm[0];\n\n    cv::Mat gmt(1, USHRT_MAX, CV_16UC1);\n    unsigned short *gmtp = gmt.ptr<unsigned short>();\n\n    for (int idx = 0; idx < gmt.cols; idx++) {\n        gmtp[idx] = clip<unsigned short>(qRound((1.099 * std::pow((double)idx / USHRT_MAX, gamma) - 0.099) * 255 * cameraHackMlp));\n    }\n\n    // a 1 x 65535 U16 gamma table\n    return gmt;\n}\n\nvoid DkRawLoader::whiteBalance(const LibRaw &iProcessor, cv::Mat &img) const\n{\n    // white balance must not be empty at this point\n    cv::Mat wb = whiteMultipliers(iProcessor);\n    const float *wbp = wb.ptr<float>();\n    assert(wb.cols == 4);\n\n    for (int rIdx = 0; rIdx < img.rows; rIdx++) {\n        unsigned short *ptr = img.ptr<unsigned short>(rIdx);\n\n        for (int cIdx = 0; cIdx < img.cols; cIdx++) {\n            // apply white balance correction\n            unsigned short r = clip<unsigned short>(*ptr * wbp[0]);\n            unsigned short g = clip<unsigned short>(*(ptr + 1) * wbp[1]);\n            unsigned short b = clip<unsigned short>(*(ptr + 2) * wbp[2]);\n\n            // apply color correction\n            int cr =\n                qRound(iProcessor.imgdata.color.rgb_cam[0][0] * r + iProcessor.imgdata.color.rgb_cam[0][1] * g + iProcessor.imgdata.color.rgb_cam[0][2] * b);\n            int cg =\n                qRound(iProcessor.imgdata.color.rgb_cam[1][0] * r + iProcessor.imgdata.color.rgb_cam[1][1] * g + iProcessor.imgdata.color.rgb_cam[1][2] * b);\n            int cb =\n                qRound(iProcessor.imgdata.color.rgb_cam[2][0] * r + iProcessor.imgdata.color.rgb_cam[2][1] * g + iProcessor.imgdata.color.rgb_cam[2][2] * b);\n\n            // clip & save color corrected values\n            *ptr = clip<unsigned short>(cr);\n            ptr++;\n            *ptr = clip<unsigned short>(cg);\n            ptr++;\n            *ptr = clip<unsigned short>(cb);\n            ptr++;\n        }\n    }\n}\n\nvoid DkRawLoader::gammaCorrection(const LibRaw &iProcessor, cv::Mat &img) const\n{\n    // white balance must not be empty at this point\n    cv::Mat gt = gammaTable(iProcessor);\n    const unsigned short *gammaLookup = gt.ptr<unsigned short>();\n    assert(gt.cols == USHRT_MAX);\n\n    for (int rIdx = 0; rIdx < img.rows; rIdx++) {\n        unsigned short *ptr = img.ptr<unsigned short>(rIdx);\n\n        for (int cIdx = 0; cIdx < img.cols * img.channels(); cIdx++) {\n            // values close to 0 are treated linear\n            if (ptr[cIdx] <= 5) // 0.018 * 255\n                ptr[cIdx] = (unsigned short)qRound(ptr[cIdx] * (double)iProcessor.imgdata.params.gamm[1] / 255.0);\n            else\n                ptr[cIdx] = gammaLookup[ptr[cIdx]];\n        }\n    }\n}\n\nvoid DkRawLoader::reduceColorNoise(const LibRaw &iProcessor, cv::Mat &img) const\n{\n    // filter color noise with a median filter\n    float isoSpeed = iProcessor.imgdata.other.iso_speed;\n\n    if (isoSpeed > 0) {\n        DkTimer dt;\n\n        int winSize;\n        if (isoSpeed > 6400)\n            winSize = 13;\n        else if (isoSpeed >= 3200)\n            winSize = 11;\n        else if (isoSpeed >= 2500)\n            winSize = 9;\n        else if (isoSpeed >= 400)\n            winSize = 7;\n        else\n            winSize = 5;\n\n        DkTimer dMed;\n\n        // revert back to 8-bit image\n        img.convertTo(img, CV_8U);\n\n        cv::cvtColor(img, img, CV_RGB2YCrCb);\n\n        std::vector<cv::Mat> imgCh;\n        cv::split(img, imgCh);\n        assert(imgCh.size() == 3);\n\n        cv::medianBlur(imgCh[1], imgCh[1], winSize);\n        cv::medianBlur(imgCh[2], imgCh[2], winSize);\n\n        cv::merge(imgCh, img);\n        cv::cvtColor(img, img, CV_YCrCb2RGB);\n        qDebug() << \"median blur takes:\" << dt;\n    }\n}\n\nQImage DkRawLoader::raw2Img(const LibRaw &iProcessor, cv::Mat &img) const\n{\n    // check the pixel aspect ratio of the raw image\n    if (iProcessor.imgdata.sizes.pixel_aspect != 1.0f)\n        cv::resize(img, img, cv::Size(), (double)iProcessor.imgdata.sizes.pixel_aspect, 1.0f);\n\n    // revert back to 8-bit image\n    img.convertTo(img, CV_8U);\n\n    // TODO: for now - fix this!\n    if (img.channels() == 1)\n        cv::cvtColor(img, img, CV_GRAY2RGB);\n\n    return DkImage::mat2QImage(img);\n}\n\n#endif\n\n// -------------------------------------------------------------------- DkTgaLoader\nnamespace tga\n{\nDkTgaLoader::DkTgaLoader(QSharedPointer<QByteArray> ba)\n{\n    mBa = ba;\n}\n\nQImage DkTgaLoader::image() const\n{\n    return mImg;\n}\n\nbool DkTgaLoader::load()\n{\n    if (!mBa || mBa->isEmpty())\n        return false;\n\n    return load(mBa);\n}\n\nbool DkTgaLoader::load(QSharedPointer<QByteArray> ba)\n{\n    // this code is from: http://www.paulbourke.net/dataformats/tga/\n    // thanks!\n    Header header;\n\n    const char *dataC = ba->data();\n\n    /* Display the header fields */\n    header.idlength = *dataC;\n    dataC++;\n    header.colourmaptype = *dataC;\n    dataC++;\n    header.datatypecode = *dataC;\n    dataC++;\n\n    const short *dataS = (const short *)dataC;\n\n    header.colourmaporigin = *dataS;\n    dataS++;\n    header.colourmaplength = *dataS;\n    dataS++;\n    dataC = (const char *)dataS;\n    header.colourmapdepth = *dataC;\n    dataC++;\n    dataS = (const short *)dataC;\n    header.x_origin = *dataS;\n    dataS++;\n    header.y_origin = *dataS;\n    dataS++;\n    header.width = *dataS;\n    dataS++;\n    header.height = *dataS;\n    dataS++;\n    dataC = (const char *)dataS;\n    header.bitsperpixel = *dataC;\n    dataC++;\n    header.imagedescriptor = *dataC;\n    dataC++;\n\n#ifdef _DEBUG\n    qDebug() << \"TGA Header ------------------------------\";\n    qDebug() << \"ID length:         \" << (int)header.idlength;\n    qDebug() << \"Colourmap type:    \" << (int)header.colourmaptype;\n    qDebug() << \"Image type:        \" << (int)header.datatypecode;\n    qDebug() << \"Colour map offset: \" << header.colourmaporigin;\n    qDebug() << \"Colour map length: \" << header.colourmaplength;\n    qDebug() << \"Colour map depth:  \" << (int)header.colourmapdepth;\n    qDebug() << \"X origin:          \" << header.x_origin;\n    qDebug() << \"Y origin:          \" << header.y_origin;\n    qDebug() << \"Width:             \" << header.width;\n    qDebug() << \"Height:            \" << header.height;\n    qDebug() << \"Bits per pixel:    \" << (int)header.bitsperpixel;\n    qDebug() << \"Descriptor:        \" << (int)header.imagedescriptor;\n#endif\n\n    /* What can we handle */\n    if (header.datatypecode != 2 && header.datatypecode != 10) {\n        qWarning() << \"[TGA] Can only handle image type 2 and 10\";\n        return false;\n    }\n\n    if (header.bitsperpixel != 16 && header.bitsperpixel != 24 && header.bitsperpixel != 32) {\n        qWarning() << \"[TGA] Can only handle pixel depths of 16, 24, and 32\";\n        return false;\n    }\n\n    if (header.colourmaptype != 0 && header.colourmaptype != 1) {\n        qWarning() << \"[TGA] Can only handle colour map types of 0 and 1\";\n        return false;\n    }\n\n    Pixel *pixels = new Pixel[header.width * header.height * sizeof(Pixel)];\n\n    if (!pixels) {\n        qWarning() << \"[TGA] could not allocate\" << header.width * header.height * sizeof(Pixel) / 1024 << \"KB\";\n        return false;\n    }\n\n    ///* Skip over unnecessary stuff */\n    int skipover = header.idlength;\n    skipover += header.colourmaptype * header.colourmaplength;\n    dataC += skipover;\n\n    /* Read the image */\n    int bytes2read = header.bitsperpixel / 8; // save?\n    unsigned char p[5];\n\n    for (int n = 0; n < header.width * header.height;) {\n        if (header.datatypecode == 2) { /* Uncompressed */\n\n            // TODO: out-of-bounds not checked here...\n            for (int bi = 0; bi < bytes2read; bi++, dataC++)\n                p[bi] = *dataC;\n\n            mergeBytes(&(pixels[n]), p, bytes2read);\n            n++;\n        } else if (header.datatypecode == 10) { /* Compressed */\n\n            for (int bi = 0; bi < bytes2read + 1; bi++, dataC++)\n                p[bi] = *dataC;\n\n            int j = p[0] & 0x7f;\n            mergeBytes(&(pixels[n]), &(p[1]), bytes2read);\n            n++;\n            if (p[0] & 0x80) { /* RLE chunk */\n                for (int i = 0; i < j; i++) {\n                    mergeBytes(&(pixels[n]), &(p[1]), bytes2read);\n                    n++;\n                }\n            } else { /* Normal chunk */\n                for (int i = 0; i < j; i++) {\n                    for (int bi = 0; bi < bytes2read; bi++, dataC++)\n                        p[bi] = *dataC;\n\n                    mergeBytes(&(pixels[n]), p, bytes2read);\n                    n++;\n                }\n            }\n        }\n    }\n\n    mImg = QImage((uchar *)pixels, header.width, header.height, QImage::Format_ARGB32);\n    mImg = mImg.copy();\n\n    // I somehow expected the 5th bit to be 0x10 -> but Paul seems to have a 0th bit : )\n    if (!(header.imagedescriptor & 0x20))\n        mImg = mImg.mirrored();\n\n    delete[] pixels;\n\n    return true;\n}\n\nvoid DkTgaLoader::mergeBytes(Pixel *pixel, unsigned char *p, int bytes) const\n{\n    if (bytes == 4) {\n        pixel->r = p[0];\n        pixel->g = p[1];\n        pixel->b = p[2];\n        pixel->a = p[3];\n    } else if (bytes == 3) {\n        pixel->r = p[0];\n        pixel->g = p[1];\n        pixel->b = p[2];\n        pixel->a = 255;\n    } else if (bytes == 2) {\n        pixel->r = (p[0] & 0x1f) << 3;\n        pixel->g = ((p[1] & 0x03) << 6) | ((p[0] & 0xe0) >> 2);\n        pixel->b = (p[1] & 0x7c) << 1;\n        pixel->a = 255; // (p[1] & 0x80);\n    }\n}\n}\n\n}",
    "bool DkBasicLoader::loadTIFF(const QString &filePath, QImage &img, QSharedPointer<QByteArray> ba) const\n{\n    bool success = false;\n\n    // first turn off nasty warning/error dialogs - (we do the GUI : )\n    TIFFErrorHandler oldErrorHandler, oldWarningHandler;\n    oldWarningHandler = TIFFSetWarningHandler(NULL);\n    oldErrorHandler = TIFFSetErrorHandler(NULL);\n\n    DkTimer dt;\n    TIFF *tiff = 0;\n\n// TODO: currently TIFFStreamOpen can only be linked on Windows?!\n#if defined(Q_OS_WIN)\n\n    std::istringstream is(ba ? ba->toStdString() : \"\");\n\n    if (ba)\n        tiff = TIFFStreamOpen(\"MemTIFF\", &is);\n\n    // fallback to direct loading\n    if (!tiff)\n        tiff = TIFFOpen(filePath.toLatin1(), \"r\");\n\n    // FIXME: we could load without buffer if toLatin1()=>toUtf8() and on\n    // windows use wchar_t* version of TIFFOpen();\n\n    // loading from buffer allows us to load files with non-latin names\n    QSharedPointer<QByteArray> bal;\n    if (!tiff)\n        bal = loadFileToBuffer(filePath);\n\n    std::istringstream isl(bal ? bal->toStdString() : \"\");\n\n    if (bal)\n        tiff = TIFFStreamOpen(\"MemTIFF\", &isl);\n#else\n    tiff = TIFFOpen(filePath.toLatin1(), \"r\");\n#endif\n\n    if (!tiff)\n        return success;\n\n    uint32_t width = 0;\n    uint32_t height = 0;\n\n    TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, &width);\n    TIFFGetField(tiff, TIFFTAG_IMAGELENGTH, &height);\n\n    // init the qImage\n    img = QImage(width, height, QImage::Format_ARGB32);\n\n    const int stopOnError = 1;\n    success = TIFFReadRGBAImageOriented(tiff, width, height, reinterpret_cast<uint32_t *>(img.bits()), ORIENTATION_TOPLEFT, stopOnError) != 0;\n\n    if (success) {\n        for (uint32_t y = 0; y < height; ++y)\n            convert32BitOrder(img.scanLine(y), width);\n    }\n\n    TIFFClose(tiff);\n\n    TIFFSetWarningHandler(oldWarningHandler);\n    TIFFSetWarningHandler(oldErrorHandler);\n\n    return success;\n\n#endif // !WITH_LIBTIFF\n    return false;\n}",
    "void DkBasicLoader::indexPages(const QString &filePath, const QSharedPointer<QByteArray> ba)\n{\n    // reset counters\n    mNumPages = 1;\n    mPageIdx = 1;\n\n#ifdef WITH_LIBTIFF\n\n    QFileInfo fInfo(filePath);\n\n    // for now we just support tiff's\n    if (!fInfo.suffix().contains(QRegularExpression(\"(tif|tiff)\", QRegularExpression::CaseInsensitiveOption)))\n        return;\n\n    // first turn off nasty warning/error dialogs - (we do the GUI : )\n    TIFFErrorHandler oldErrorHandler, oldWarningHandler;\n    oldWarningHandler = TIFFSetWarningHandler(NULL);\n    oldErrorHandler = TIFFSetErrorHandler(NULL);\n\n    DkTimer dt;\n    TIFF *tiff = 0;\n\n#if defined(Q_OS_WIN)\n    std::istringstream is(ba ? ba->toStdString() : \"\");\n\n    if (ba)\n        tiff = TIFFStreamOpen(\"MemTIFF\", &is);\n\n    // read from file\n    if (!tiff)\n        tiff = TIFFOpen(filePath.toLatin1(), \"r\"); // this->mFile was here before - not sure why\n\n    // loading from buffer allows us to load files with non-latin names\n    QSharedPointer<QByteArray> bal;\n    if (!tiff)\n        bal = loadFileToBuffer(filePath);\n    ;\n    std::istringstream isl(bal ? bal->toStdString() : \"\");\n\n    if (bal)\n        tiff = TIFFStreamOpen(\"MemTIFF\", &isl);\n#else\n    // read from file\n    tiff = TIFFOpen(filePath.toLatin1(), \"r\"); // this->mFile was here before - not sure why\n#endif\n\n    if (!tiff)\n        return;\n\n    // libtiff example\n    int dircount = 0;\n\n    do {\n        dircount++;\n\n    } while (TIFFReadDirectory(tiff));\n\n    mNumPages = dircount;\n\n    if (mNumPages > 1)\n        mPageIdx = 1;\n\n    qDebug() << dircount << \" TIFF directories... \" << dt;\n    TIFFClose(tiff);\n\n    TIFFSetWarningHandler(oldWarningHandler);\n    TIFFSetWarningHandler(oldErrorHandler);\n#else\n    Q_UNUSED(filePath);\n#endif\n}",
    "bool DkBasicLoader::loadPageAt(int pageIdx)\n{\n    bool imgLoaded = false;\n\n#ifdef WITH_LIBTIFF\n\n    // <= 1 since first page is loaded using qt\n    if (pageIdx > mNumPages || pageIdx < 1)\n        return imgLoaded;\n\n    // first turn off nasty warning/error dialogs - (we do the GUI : )\n    TIFFErrorHandler oldErrorHandler, oldWarningHandler;\n    oldWarningHandler = TIFFSetWarningHandler(NULL);\n    oldErrorHandler = TIFFSetErrorHandler(NULL);\n\n    DkTimer dt;\n    TIFF *tiff = TIFFOpen(mFile.toLatin1(), \"r\");\n\n#if defined(Q_OS_WIN)\n\n    // loading from buffer allows us to load files with non-latin names\n    QSharedPointer<QByteArray> ba;\n    if (!tiff)\n        ba = loadFileToBuffer(mFile);\n\n    std::istringstream is(ba ? ba->toStdString() : \"\");\n    if (ba)\n        tiff = TIFFStreamOpen(\"MemTIFF\", &is);\n#endif\n\n    if (!tiff)\n        return imgLoaded;\n\n    uint32_t width = 0;\n    uint32_t height = 0;\n\n    // go to current directory\n    for (int idx = 1; idx < pageIdx; idx++) {\n        if (!TIFFReadDirectory(tiff))\n            return false;\n    }\n    TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, &width);\n    TIFFGetField(tiff, TIFFTAG_IMAGELENGTH, &height);\n\n    // init the qImage\n    QImage img = QImage(width, height, QImage::Format_ARGB32);\n\n    const int stopOnError = 1;\n    imgLoaded = TIFFReadRGBAImageOriented(tiff, width, height, reinterpret_cast<uint32_t *>(img.bits()), ORIENTATION_TOPLEFT, stopOnError) != 0;\n\n    if (imgLoaded) {\n        for (uint32_t y = 0; y < height; ++y)\n            convert32BitOrder(img.scanLine(y), width);\n    }\n\n    TIFFClose(tiff);\n\n    TIFFSetWarningHandler(oldWarningHandler);\n    TIFFSetWarningHandler(oldErrorHandler);\n\n    setEditImage(img, tr(\"Original Image\"));\n#else\n    Q_UNUSED(pageIdx);\n#endif\n\n    return imgLoaded;\n}",
    "int ShowMesh2D::show_mesh_save_screen (const char * tiff_file, Window window, int width, int height)\n{\n  TIFF *fout= TIFFOpen(tiff_file, \"w\");\n  if(!fout) return 1;\n\n  int sampleperpixel = 3;    //RGB channel\n  XImage *ximage = XGetImage(display, window, 0, 0, width, height, AllPlanes, XYPixmap);\n  char *image=new char [width*height*sampleperpixel];\n  //it seems the XQueryColors has the limit of query size of 65535 colors.\n  XColor  *color=new XColor[65535];\n  int lines=65535/width;\n  int currentlines;\n  int count = 0;\n\n  for (int i = 0; i < height; i+=lines)\n  {\n    if(i+lines>=height) currentlines=height-i-1;\n    else currentlines=lines;\n    for (int j = 0; j < currentlines; j++)\n      for (int k = 0; k < width; k++)\n      {\n        unsigned long c;\n        c = XGetPixel(ximage, k, i+j);        /* X pixel value */\n        color[k+j*width].pixel = c;\n      }\n    XQueryColors(display, colormap, color, currentlines*width);\n    for (int j = 0; j < currentlines; j++)\n      for (int k = 0; k < width; k++)\n      {\n        char     r, g, b;\n        r = color[k+j*width].red >> 8;\n        g = color[k+j*width].green >> 8;\n        b = color[k+j*width].blue >> 8;\n\n        image[count++] = r;\n        image[count++] = g;\n        image[count++] = b;\n      }\n  }\n  delete [] color;\n\n  TIFFSetField(fout, TIFFTAG_IMAGEWIDTH, width);  // set the width of the image\n  TIFFSetField(fout, TIFFTAG_IMAGELENGTH, height);    // set the height of the image\n  TIFFSetField(fout, TIFFTAG_SAMPLESPERPIXEL, sampleperpixel);   // set number of channels per pixel\n  TIFFSetField(fout, TIFFTAG_BITSPERSAMPLE, 8);    // set the size of the channels\n  TIFFSetField(fout, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);    // set the origin of the image.\n  TIFFSetField(fout, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n  TIFFSetField(fout, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n  TIFFSetField(fout, TIFFTAG_COMPRESSION, COMPRESSION_PACKBITS);\n\n  tsize_t linebytes = sampleperpixel*width;     // length in memory of one row of pixel in the image.\n  // We set the strip size of the file to be size of one row of pixels\n  TIFFSetField(fout, TIFFTAG_ROWSPERSTRIP, TIFFDefaultStripSize(fout, width*sampleperpixel));\n  //Now writing image to the file one strip at a time\n  for (int row = 0; row < height; row++)\n  {\n    // check the index here, and figure out why not using h*linebytes\n    if(TIFFWriteScanline(fout, &image[row*linebytes], row, 0) < 0)\n      break;\n  }\n  TIFFClose(fout);\n  delete [] image;\n  XDestroyImage(ximage);\n  return 0;\n}",
    "void mat_to_image(const Mat mat, const std::string &image_file)\n{\n  PetscBool assembled;\n  MatAssembled(mat, &assembled);\n  if( !assembled )\n  {\n    MatAssemblyBegin(mat, MAT_FINAL_ASSEMBLY);\n    MatAssemblyEnd(mat, MAT_FINAL_ASSEMBLY);\n  }\n\n  PetscInt m;     //  - the number of local rows\n  PetscInt n;     //  - the number of local columns\n  MatGetLocalSize(mat, &m, &n);\n  PetscInt M, N;      // - the number of global rows and columns\n  MatGetSize(mat, &M, &N);\n\n  PetscInt row_begin ;  // - the global index of the first local row\n  PetscInt row_end;   // - one more than the global index of the last local row\n  MatGetOwnershipRange(mat, &row_begin,  &row_end);\n\n  // matrix entry (row, col) pairs\n  std::vector<PetscInt> rows;\n  std::vector<PetscInt> cols;\n  std::vector<PetscScalar> values;\n\n  // read the row\n  for(PetscInt row=row_begin; row<row_end; row++)\n  {\n    PetscInt ncols;\n    const PetscInt * row_cols_pointer;\n    const PetscScalar * row_vals_pointer;\n\n    MatGetRow(mat, row, &ncols, &row_cols_pointer, &row_vals_pointer);\n\n    for(PetscInt c=0; c<ncols; c++)\n    {\n      PetscInt col = row_cols_pointer[c];\n      rows.push_back(row);\n      cols.push_back(col);\n      values.push_back(fabs(row_vals_pointer[c]));\n    }\n\n    // restore pointers\n    MatRestoreRow(mat, row, &ncols, &row_cols_pointer, &row_vals_pointer);\n  }\n\n  // gather from other processor\n  Parallel::gather(0, rows);\n  Parallel::gather(0, cols);\n  Parallel::gather(0, values);\n\n  const PetscScalar max_value = *( std::max_element( values.begin(), values.end() ) );\n  std::vector< std::vector< std::pair<PetscInt, PetscScalar> > > entry(N);\n  for(unsigned int n=0; n<rows.size(); ++n)\n  {\n    PetscInt row = rows[n];\n    PetscInt col = cols[n];\n    entry[row].push_back( std::make_pair(col, values[n]) );\n  }\n  std::vector< std::vector< std::pair<PetscInt, PetscScalar> > > pad_entry(N);\n  {\n    std::set< std::pair<PetscInt, PetscInt> > mat_entry_set;\n    for(unsigned int n=0; n<values.size(); ++n)\n      mat_entry_set.insert(std::make_pair(rows[n], cols[n]));\n\n    for(unsigned int n=0; n<values.size(); ++n)\n    {\n      if( mat_entry_set.find(std::make_pair(cols[n], rows[n])) == mat_entry_set.end() )\n        pad_entry[cols[n]].push_back( std::make_pair(rows[n], 1.0) );\n    }\n  }\n\n  rows.clear();\n  cols.clear();\n  values.clear();\n\n\n  TIFF *fout= TIFFOpen(image_file.c_str(), \"w\");\n  int sampleperpixel = 3;    //RGB channel\n\n  TIFFSetField(fout, TIFFTAG_IMAGEWIDTH, M);  // set the width of the image\n  TIFFSetField(fout, TIFFTAG_IMAGELENGTH, N);    // set the height of the image\n  TIFFSetField(fout, TIFFTAG_SAMPLESPERPIXEL, sampleperpixel);   // set number of channels per pixel\n  TIFFSetField(fout, TIFFTAG_BITSPERSAMPLE, 8);    // set the size of the channels\n  TIFFSetField(fout, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);    // set the origin of the image.\n  TIFFSetField(fout, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n  TIFFSetField(fout, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n  TIFFSetField(fout, TIFFTAG_COMPRESSION, COMPRESSION_PACKBITS);\n\n  tsize_t linebytes = sampleperpixel*M;     // length in memory of one row of pixel in the image.\n  // We set the strip size of the file to be size of one row of pixels\n  TIFFSetField(fout, TIFFTAG_ROWSPERSTRIP, TIFFDefaultStripSize(fout, linebytes));\n\n  unsigned int rainbow[20][3] =\n    {\n      0, 0, 65535,\n      0, 29298, 65535,\n      0, 41377, 65535,\n      0, 50629, 65535,\n      0, 58596, 65535,\n      0, 65535, 65535,\n      0, 65535, 56797,\n      0, 65535, 46003,\n      0, 65535, 32639,\n      0, 65535, 0,\n      32125, 65535, 0,\n      46260, 65535, 0,\n      56540, 65535, 0,\n      65535, 65535, 0,\n      65535, 59881, 0,\n      65535, 53199, 0,\n      65535, 45746, 0,\n      65535, 38036, 0,\n      65535, 26471, 0,\n      65535, 0, 0\n    };\n\n  //Now writing image to the file one strip at a time\n  for (PetscInt row = 0; row < N; row++)\n  {\n    std::vector<unsigned char> image(linebytes, 255);\n    const std::vector< std::pair<PetscInt, PetscScalar> > & one_row = entry[row];\n    for(unsigned int n=0; n<one_row.size(); ++n)\n    {\n      int col = one_row[n].first;\n      PetscScalar value = one_row[n].second;\n      int level = 19*(value/max_value);//map to rainbow\n      image[3*col + 0] = rainbow[level][0]/255;\n      image[3*col + 1] = rainbow[level][1]/255;\n      image[3*col + 2] = rainbow[level][2]/255;\n    }\n    TIFFWriteScanline(fout, &image[0], row, 0);\n  }\n  TIFFClose(fout);\n}",
    "bool Image::initWithTiffData(const unsigned char * data, ssize_t dataLen)\n{\n#if CC_USE_TIFF\n    bool ret = false;\n    do \n    {\n        // set the read call back function\n        tImageSource imageSource;\n        imageSource.data    = data;\n        imageSource.size    = dataLen;\n        imageSource.offset  = 0;\n\n        TIFF* tif = TIFFClientOpen(\"file.tif\", \"r\", (thandle_t)&imageSource, \n            tiffReadProc, tiffWriteProc,\n            tiffSeekProc, tiffCloseProc, tiffSizeProc,\n            tiffMapProc,\n            tiffUnmapProc);\n\n        CC_BREAK_IF(nullptr == tif);\n\n        uint32 w = 0, h = 0;\n        uint16 bitsPerSample = 0, samplePerPixel = 0, planarConfig = 0;\n        size_t npixels = 0;\n        \n        TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w);\n        TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\n        TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bitsPerSample);\n        TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &samplePerPixel);\n        TIFFGetField(tif, TIFFTAG_PLANARCONFIG, &planarConfig);\n\n        npixels = w * h;\n        \n        _renderFormat = Texture2D::PixelFormat::RGBA8888;\n        _width = w;\n        _height = h;\n\n        _dataLen = npixels * sizeof (uint32);\n        _data = static_cast<unsigned char*>(malloc(_dataLen * sizeof(unsigned char)));\n\n        uint32* raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n        if (raster != nullptr) \n        {\n           if (TIFFReadRGBAImageOriented(tif, w, h, raster, ORIENTATION_TOPLEFT, 0))\n           {\n                /* the raster data is pre-multiplied by the alpha component \n                   after invoking TIFFReadRGBAImageOriented*/\n                _hasPremultipliedAlpha = true;\n\n               memcpy(_data, raster, npixels*sizeof (uint32));\n           }\n\n          _TIFFfree(raster);\n        }\n        \n\n        TIFFClose(tif);\n\n        ret = true;\n    } while (0);\n    return ret;\n#else\n    CCLOG(\"tiff is not enabled\");\n    return false;\n#endif //CC_USE_TIFF\n}",
    "bool TiffWriter::close()\n{\n  // Close the file\n\n  TIFFClose(f);\n\n  return true;\n}",
    "int main(int argc, char **argv) {\n\n\tint devId = 0;\n\n\tchar *fname = NULL;\n\n\tint verbose = 0;\n\tint decWriteOutN = 0;\n\n\tint frameBeg = INT_MIN;\n\tint frameEnd = INT_MAX;\n\tint decodeRange = 0;\n\tint doEncode = 0;\n\tint encWriteOut = 0;\n\n\tint och;\n\twhile(1) {\n\t\tint option_index = 0;\n\t\tstatic struct option long_options[] = {\n\t\t\t{      \"file\", required_argument, 0, 'f'},\n\t\t\t{    \"device\", required_argument, 0, 'd'},\n\t\t\t{\"decode-out\", optional_argument, 0,   1},\n\t\t\t{ \"frame-beg\", required_argument, 0, 'b'},\n\t\t\t{ \"frame-end\", required_argument, 0, 'e'},\n\t\t\t{   \"memtype\", required_argument, 0, 'm'},\n\t\t\t{   \"copyh2d\", required_argument, 0, 'c'},\n\t\t\t{   \"verbose\",       no_argument, 0, 'v'},\n\t\t\t{    \"encode\",       no_argument, 0, 'E'},\n\t\t\t{\"rowsxstrip\", required_argument, 0, 'r'},\n\t\t\t{\"stripalloc\", required_argument, 0, 's'},\n\t\t\t{\"encode-out\", optional_argument, 0,   2},\n\t\t\t{      \"help\",       no_argument, 0, 'h'},\n\t\t\t{           0,                 0, 0,   0}\n\t\t};\n\n\t\toch = getopt_long(argc, argv, \"f:d:vo::hb:e:m:cEr:s:\", long_options, &option_index);\n\t\tif (och == -1) break;\n\t\tswitch (och) {\n\t\t\tcase   0:// handles long opts with non-NULL flag field\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\tdevId = atoi(optarg);\n\t\t\t\tbreak;\n\t\t\tcase 'f':\n\t\t\t\tfname = strdup(optarg);\n\t\t\t\tbreak;\n\t\t\tcase 'b':\n\t\t\t\tframeBeg = atoi(optarg);\n\t\t\t\tdecodeRange = 1;\n\t\t\t\tbreak;\n\t\t\tcase 'e':\n\t\t\t\tframeEnd = atoi(optarg);\n\t\t\t\tdecodeRange = 1;\n\t\t\t\tbreak;\n\t\t\tcase 'v':\n\t\t\t\tverbose++;\n\t\t\t\tbreak;\n\t\t\tcase   1:\n\t\t\t\tdecWriteOutN = 1;\n\t\t\t\tif(!optarg                 &&\n\t\t\t\t   argv[optind]    != NULL &&\n\t\t\t\t   argv[optind][0] != '-') {\n\n\t\t\t\t\tdecWriteOutN = atoi(argv[optind++]);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'E':\n\t\t\t\tdoEncode = 1;\n\t\t\t\tbreak;\n\t\t\tcase   2:\n\t\t\t\tencWriteOut = 1;\n\t\t\t\tbreak;\n\t\t\tcase 'h':\n\t\t\tcase '?':\n\t\t\t\tusage(argv[0]);\n\t\t\tdefault:\n\t\t\t\tfprintf(stderr, \"unknown option: %c\\n\", och);\n\t\t\t\tusage(argv[0]);\n\t\t}\n\t}\n\n\tif (!fname) {\n\t\tfprintf(stderr, \"Please specify a TIFF file with the -f option!\\n\");\n\t\tusage(argv[0]);\n\t}\n\n\tif (frameBeg > frameEnd) {\n\t\tfprintf(stderr, \"Invalid frame range!\\n\");\n\t\tusage(argv[0]);\n\t}\n\n\tCHECK_CUDA(cudaSetDevice(devId));\n\n\tcudaDeviceProp props;\n\n\tprintf(\"\\nUsing GPU:\\n\");\n\tCHECK_CUDA(cudaGetDeviceProperties(&props, devId));\n\tprintf(\"\\t%2d (%s, %d SMs, %d th/SM max, CC %d.%d, ECC %s)\\n\",\n\t\t\tdevId, props.name, props.multiProcessorCount,\n\t\t\tprops.maxThreadsPerMultiProcessor,\n\t\t\tprops.major, props.minor,\n\t\t\tprops.ECCEnabled?\"on\":\"off\");\n\tprintf(\"\\n\");\n\n\t// dummy allocation to initialize subsystems\n\tunsigned char *dummy;\n\tCHECK_CUDA(cudaMalloc(&dummy, 1024*1024*10));\n\tCHECK_CUDA(cudaFree(dummy));\n\n\tcudaStream_t stream;\n\tCHECK_CUDA(cudaStreamCreate(&stream));\n\n\n\tnvtiffStream_t tiff_stream;\n\tnvtiffDecoder_t decoder;\n    CHECK_NVTIFF(nvtiffStreamCreate(&tiff_stream));\n\tCHECK_NVTIFF(nvtiffDecoderCreate(&decoder,\n        nullptr, nullptr, 0));\n\n    CHECK_NVTIFF(nvtiffStreamParseFromFile(fname, tiff_stream));\n\n\tuint32_t num_images = 0;\n    CHECK_NVTIFF(nvtiffStreamGetNumImages(tiff_stream, &num_images));\n\tstd::vector<nvtiffImageInfo_t> image_info(num_images);\n    std::vector<uint8_t*> nvtiff_out(num_images);\n    std::vector<size_t> nvtiff_out_size(num_images);\n    \n\t// BEGIN work (possibly) overlapped with H2D copy of the file data\n\tif (verbose) {\n\t\tCHECK_NVTIFF(nvtiffStreamPrint(tiff_stream));\n\t}\n\t\n\tframeBeg = fmax(frameBeg, 0);\n\tframeEnd = fmin(frameEnd, num_images-1);\n\tconst int nDecode = frameEnd-frameBeg+1;\n\n\tfor (uint32_t image_id = 0; image_id < num_images; image_id++) {\n        CHECK_NVTIFF(nvtiffStreamGetImageInfo(tiff_stream, image_id, &image_info[image_id]));\n        nvtiff_out_size[image_id] = DIV_UP((size_t)image_info[image_id].bits_per_pixel * image_info[image_id].image_width, 8) *\n                                    (size_t)image_info[image_id].image_height;\n        if (image_info[image_id].photometric_int == NVTIFF_PHOTOMETRIC_PALETTE) {\n            nvtiff_out_size[image_id] = image_info[image_id].image_width * image_info[image_id].image_height * 3 * sizeof(uint16_t);\n        }\n        CHECK_CUDA(cudaMalloc(&nvtiff_out[image_id], nvtiff_out_size[image_id]));\n    }\n\n\tprintf(\"Decoding %u, images [%d, %d], from file %s... \",\n\t\tnDecode,\n\t\tframeBeg,\n\t\tframeEnd,\n\t\tfname);\n\tfflush(stdout);\n\n\n\tauto decode_start = perfclock::now();\n\tif (!decodeRange) {\n\t\tCHECK_NVTIFF(nvtiffDecode(tiff_stream, decoder, nvtiff_out.data(), stream));\n\t} else { \n\t\tCHECK_NVTIFF(nvtiffDecodeRange(tiff_stream, decoder, frameBeg, nDecode, nvtiff_out.data(), stream));\n\t}\n\tCHECK_CUDA(cudaStreamSynchronize(stream));\n\tauto decode_end = perfclock::now();\n    double decode_time = std::chrono::duration<float>(decode_end - decode_start).count();\n\n\tprintf(\"done in %lf secs\\n\\n\", decode_time);\n\n\tif (decWriteOutN) {\n        const uint32_t nout = std::min(decWriteOutN, nDecode);\n\n        printf(\"Writing images for the first %d subfile(s)...\\n\", nout);\n        fflush(stdout);\n\n        for (uint32_t image_id = 0; image_id < nout; image_id++) {\n            auto& info = image_info[image_id];\n            std::vector<uint8_t> imageOut_h(nvtiff_out_size[image_id]);\n            CHECK_CUDA(cudaMemcpy(imageOut_h.data(), nvtiff_out[image_id], nvtiff_out_size[image_id], cudaMemcpyDeviceToHost));\n            write_image(fname, info, imageOut_h.data(), image_id);\n        }\n    }\n\n#ifdef LIBTIFF_TEST\n\tTIFF* tif = TIFFOpen(fname, \"r\");\n\tif (tif) {\n\n\t\t// we alredy know that all subfiles have the same porperties\n\t\tuint32_t *raster;\n\t\traster = (uint32_t *)_TIFFmalloc(tiffData->subFiles[0].ncol*tiffData->subFiles[0].nrow * sizeof (uint32_t));\n\n\t\tprintf(\"\\tDecoding with libTIFF... \"); fflush(stdout);\n\t\tauto decode_start = perfclock::now();\n\t\tfor(int i = 0; i < tiffData->nSubFiles; i++) {\n\t\t\tif (!TIFFReadRGBAImage(tif,\n\t\t\t\t\t       tiffData->subFiles[i].ncol,\n\t\t\t\t\t       tiffData->subFiles[i].nrow,\n\t\t\t\t\t       raster, 0)) {\n\t\t\t\tfprintf(stderr, \"Error while decoding image %d with libTiff\\n\", i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tTIFFReadDirectory(tif);\n\t\t}\n\t\tauto decode_end = perfclock::now();\n\t\tdouble decode_time = std::chrono::duration<float>(decode_end - decode_start).count();\n\t\tprintf(\"done in %lf secs\\n\\n\", decode_time);\n\n\t\t_TIFFfree(raster);\n\t\tTIFFClose(tif);\n\t}\n#endif\n\tbool identical_multi_tiff = check_identical(image_info.data(), num_images);\n\tif(!identical_multi_tiff && doEncode){\n\t\tprintf(\"Encoding will be skipped since the images within the tiff file do not have identical properties...\\n\");\n\t}\n\t// TODO check identical\n\tif (doEncode && identical_multi_tiff) {\n\n\t\tunsigned int nrow              = image_info[0].image_height;\n\t\tunsigned int ncol              = image_info[0].image_width;\n\t\tunsigned int photometricInt    = (unsigned int)image_info[0].photometric_int;\n\t\tunsigned int planarConf        = (unsigned int)image_info[0].planar_config;\n\t\tunsigned short pixelSize       = image_info[0].bits_per_pixel/8;\n\t\tunsigned short samplesPerPixel = image_info[0].samples_per_pixel;\n\t\tunsigned short sampleFormat    = image_info[0].sample_format[0];\n\n\t\tunsigned short *bitsPerSample = (unsigned short *)malloc(sizeof(*bitsPerSample)*samplesPerPixel);\n\t\tmemcpy(bitsPerSample,\n\t\t\timage_info[0].bits_per_sample,\n\t\t       sizeof(*bitsPerSample)*samplesPerPixel);\n\n\t\tCHECK_NVTIFF(nvtiffStreamDestroy(tiff_stream));\n        CHECK_NVTIFF(nvtiffDecoderDestroy(decoder, stream));\n\t\ttiff_stream = NULL;\n\t\tdecoder = NULL;\n\n\t\tunsigned int nSubFiles = nDecode;\n\n\t\tprintf(\"Encoding %u, %s %ux%u images ... \",\n\t\t\tnDecode, image_info[0].photometric_int == 2 ? \"RGB\" : \"Grayscale\",\n\t\t\timage_info[0].image_width, image_info[0].image_height);\n\t\tfflush(stdout);\n\n        auto enc_start = perfclock::now();\n\n\t\tnvtiffEncoder_t encoder;\n\t\tCHECK_NVTIFF(nvtiffEncoderCreate(&encoder, nullptr, nullptr, stream));\n\t\tnvtiffEncodeParams_t params;\n\t\tCHECK_NVTIFF(nvtiffEncodeParamsCreate(&params));\n\t\tCHECK_NVTIFF(nvtiffEncodeParamsSetImageInfo(params, &image_info[0]));\n\t\tCHECK_NVTIFF(nvtiffEncodeParamsSetInputs(params, nvtiff_out.data(), nSubFiles));\n\t\tCHECK_NVTIFF(nvtiffEncode(encoder, &params, 1, stream));\n\t\tCHECK_NVTIFF(nvtiffEncodeFinalize(encoder, &params, 1, stream));\n\n\t\tCHECK_CUDA(cudaStreamSynchronize(stream));\n\t\tauto enc_end = perfclock::now();\n\t\tdouble enc_time = std::chrono::duration<float>(enc_end - enc_start).count();\n\n\t    size_t stripSizeTotal = 0;\n        size_t metadataSize = 0;\n\t\tCHECK_NVTIFF(nvtiffGetBitstreamSize(encoder, &params, 1, &metadataSize, &stripSizeTotal));\n\t\tprintf(\"done in %lf secs (compr. ratio: %.2lfx)\\n\\n\",\n\t\t\t\tenc_time, double(nvtiff_out_size[0])*nSubFiles/stripSizeTotal);\n\n\t\tif (encWriteOut) {\n\t\t\tprintf(\"\\tWriting %u compressed images to TIFF file... \", nDecode); fflush(stdout);\n\t\t\tauto write_start = perfclock::now();\n\t\t\tCHECK_NVTIFF(nvtiffWriteTiffFile(encoder, &params, 1, \"outFile.tif\", stream));\n\t\t\tauto write_end = perfclock::now();\n\t\t\tdouble write_time = std::chrono::duration<float>(write_end - write_start).count();\n\t\t\tprintf(\"done in %lf secs\\n\\n\", write_time);\n\n\t\t}\n        CHECK_NVTIFF(nvtiffEncodeParamsDestroy(params, stream));\n\t\tCHECK_NVTIFF(nvtiffEncoderDestroy(encoder, stream));\n\n#ifdef LIBTIFF_TEST\n\t\ttif = TIFFOpen(\"libTiffOut.tif\", \"w\");\n\t\tif (tif) {\n\n\t\t\tunsigned char **imageOut_h = (unsigned char **)Malloc(sizeof(*imageOut_h)*nDecode);\n\t\t\tfor(unsigned int i = 0; i < nDecode; i++) {\n\t\t\t\timageOut_h[i] = (unsigned char *)Malloc(sizeof(*imageOut_h)*imageSize);\n\t\t\t\tCHECK_CUDA(cudaMemcpy(imageOut_h[i],\n\t\t\t\t\t\t\timageOut_d[i],\n\t\t\t\t\t\t\timageSize,\n\t\t\t\t\t\t\tcudaMemcpyDeviceToHost));\n\t\t\t}\n\n\t\t\tsize_t stripSize = sizeof(**imageOut_h)*encRowsPerStrip*ncol*pixelSize;\n\n\t\t\tprintf(\"\\tEncoding with libTIFF... \"); fflush(stdout);\n\t\t\t__t = Wtime();\n\t\t\tfor(unsigned int i = 0; i < nDecode; i++) {\n\n\t\t\t\tTIFFSetField(tif, TIFFTAG_IMAGEWIDTH, nrow);\n\t\t\t\tTIFFSetField(tif, TIFFTAG_IMAGELENGTH, ncol);\n\t\t\t\tTIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8);\n\t\t\t\tTIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_LZW);\n\t\t\t\tTIFFSetField(tif, TIFFTAG_PHOTOMETRIC, photometricInt);\n\t\t\t\tTIFFSetField(tif, TIFFTAG_FILLORDER, 1);\n\t\t\t\tTIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, samplesPerPixel);\n\t\t\t\tTIFFSetField(tif, TIFFTAG_PLANARCONFIG, planarConf);\n\t\t\t\tTIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, encRowsPerStrip);\n\n\t\t\t\tfor(unsigned int j = 0; j < nStripOut; j++) {\n\n\t\t\t\t\tunsigned int currStripSize = stripSize;\n\t\t\t\t\tif (j == nStripOut-1) {\n\t\t\t\t\t\tcurrStripSize = imageSize - j*stripSize;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (-1 == TIFFWriteEncodedStrip(tif,\n\t\t\t\t\t\t\t\tj,\n\t\t\t\t\t\t\t\timageOut_h[i]+j*stripSize,\n\t\t\t\t\t\t\t\tcurrStripSize)) {\n\n\t\t\t\t\t\tfprintf(stderr, \"Error while encoding image %d with libTiff\\n\", i);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// need to find a way to have libTiff to encode in \n\t\t\t\t// memory without writing to disk the last direnctory\n\t\t\t\t// after each TIFFWriteDirectory() call\n\t\t\t\tTIFFWriteDirectory(tif);\n\t\t\t\t//TIFFRewriteDirectory(tif);\n\t\t\t}\n\t\t\t__t = Wtime()-__t;\n\t\t\tprintf(\"done in %lf secs\\n\\n\", __t);\n\n\t\t\tTIFFClose(tif);\n\t\t}\n#endif\n\t}\n\n\t// cleanup\n\tfor(unsigned int i = 0; i < nDecode; i++) {\n\t\tCHECK_CUDA(cudaFree(nvtiff_out[i]));\n\t}\n\n\tfree(fname);\n\t\n\tif(tiff_stream)\t{\n\t\tCHECK_NVTIFF(nvtiffStreamDestroy(tiff_stream));\n\t}\n    \n\tif(decoder){\n\t    CHECK_NVTIFF(nvtiffDecoderDestroy(decoder, stream));\n\t }\n\t\n\tCHECK_CUDA(cudaStreamDestroy(stream));\n\n\tCHECK_CUDA(cudaDeviceReset());\n\n\treturn 0;\n}",
    "void EerFile::CloseFile( ) {\n    if ( tif != NULL )\n        TIFFClose(tif);\n    tif = NULL;\n    if ( fh != NULL )\n        fclose(fh);\n    fh = NULL;\n}",
    "void TiffFile::CloseFile( ) {\n    if ( tif != NULL )\n        TIFFClose(tif);\n    tif = NULL;\n}",
    "TIFRaster::Data::~Data()\r\n{\r\n\tif(tiff) {\r\n\t\tif(page_open)\r\n\t\t\tTIFFRGBAImageEnd(this);\r\n\t\tTIFFClose(tiff);\r\n\t}\r\n}",
    "TIFEncoder::Data::~Data()\r\n{\r\n\tif(tiff) TIFFClose(tiff);\r\n}",
    "void TIFEncoder::Data::WriteLineRaw(const byte *s)\r\n{\r\n\tmemcpy(rowbuf.Begin(), s, linebytes);\r\n\tTIFFWriteScanline(tiff, rowbuf.Begin(), line, 0);\r\n\tif(++line >= size.cy) {\r\n\t\tTIFFClose(tiff);\r\n\t\ttiff = NULL;\r\n\t}\r\n}",
    "void texture_t::load_tiff(int index, bool allow_diff_width_height, bool allow_two_byte_grayscale) {\n\n#ifdef ENABLE_TIFF\n\tTIFF* tif = TIFFOpen(append_texture_dir(name).c_str(), \"r\"); // first try texture directory\n\tif (tif == NULL) {tif = TIFFOpen(name.c_str(), \"r\");} // not found, try current directory\n\n\tif (tif == NULL) {\n\t\tcerr << \"Error opening tiff file \" << name << \" for read.\" << endl;\n\t\texit(1);\n\t}\n\tuint32_t w(0), h(0);\n\tuint16_t bit_depth(0), config(0);\n\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH,    &w);\n\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH,   &h);\n\tTIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bit_depth);\n\tTIFFGetField(tif, TIFFTAG_PLANARCONFIG,  &config);\n\tset_image_size(w, h, allow_diff_width_height);\n\t\n\tif (allow_two_byte_grayscale && (ncolors == 0 || ncolors == 1) && bit_depth == 16) { // 16-bit grayscale\n\t\tset_16_bit_grayscale();\n\t\ttmsize_t const sl_size(TIFFScanlineSize(tif));\n\t\tassert(sl_size == 2*width);\n        tdata_t buf = _TIFFmalloc(sl_size);\n\t\tassert(buf);\n\t\talloc();\n\t\tassert(config == PLANARCONFIG_CONTIG); // no support for PLANARCONFIG_SEPARATE, but could be added later\n\n\t\tfor (int row = 0; row < height; row++) {\n\t\t\tTIFFReadScanline(tif, buf, row);\n\n\t\t\tfor (int i = 0; i < sl_size; ++i) { // x-values\n\t\t\t\tdata[sl_size*(height - row - 1) + i] = ((unsigned char const *)buf)[i]; // assumes little endian byte ordering, no swap required, may need to check this?\n\t\t\t}\n\t\t}\n        _TIFFfree(buf);\n\t}\n\telse {\n\t\tif (ncolors == 0) {ncolors = 4;} // 3?\n\t\tuint32_t *raster = (uint32_t *)_TIFFmalloc(num_pixels() * sizeof(uint32_t));\n\t\tassert(raster != NULL);\n\n\t\tif (!TIFFReadRGBAImage(tif, width, height, raster, 0)) {\n\t\t\tcerr << \"Error reading data from tiff file \" << name << \".\" << endl;\n\t\t\texit(1);\n\t\t}\n\t\talloc();\n\n\t\tfor (int y = 0; y < height; ++y) {\n\t\t\tfor (int x = 0; x < width; ++x) {\n\t\t\t\tunsigned const ix(y*width + x);\n\t\t\t\tunsigned char const *d((unsigned char const *)(raster + ix));\n\t\t\t\tfor (int i = 0; i < ncolors; ++i) {data[ncolors*ix+i] = d[i];} // not correct for lum+alpha textures?\n\t\t\t}\n\t\t}\n\t\t_TIFFfree(raster);\n\t}\n\tTIFFClose(tif);\n#else\n\tcerr << \"Error loading texture image file \" << name << \": tiff support has not been enabled.\" << endl;\n\texit(1);\n#endif\n}",
    "void ImagePyramid::freeAll() {\n    if(m_fileHandle != nullptr) {\n        m_levels.clear();\n        openslide_close(m_fileHandle);\n    } else if(m_tiffHandle != nullptr) {\n        m_levels.clear();\n        TIFFClose(m_tiffHandle);\n        if(m_tempFile) {\n            // If this is a temp file created by FAST. Delete it.\n            std::remove(m_tiffPath.c_str());\n        }\n    } else {\n\t\tfor(auto& item : m_levels) {\n\t\t\tif(item.memoryMapped) {\n#ifdef WIN32\n\t\t\t\tUnmapViewOfFile(item.data);\n\t\t\t\tCloseHandle(item.fileHandle);\n#else\n\t\t\t\tmunmap(item.data, item.width*item.height*m_channels);\n\t\t\t\tclose(item.fileHandle);\n#endif\n\t\t\t} else {\n\t\t\t\tdelete[] item.data;\n\t\t\t}\n\t\t}\n        m_levels.clear();\n    }\n\n\tm_initialized = false;\n\tm_fileHandle = nullptr;\n}",
    "void TIFFImagePyramidExporter::execute() {\n    if(m_filename.empty())\n        throw Exception(\"Must set filename in TIFFImagePyramidExporter\");\n\n    auto input = getInputData<DataObject>();\n    auto imagePyramid = std::dynamic_pointer_cast<ImagePyramid>(input);\n    if(imagePyramid == nullptr) {\n        reportInfo() << \"Data given to TIFFImagePyramidExporter was an Image, not an ImagePyramid, converting ...\" << reportEnd();\n        auto image = std::dynamic_pointer_cast<Image>(input);\n        imagePyramid = ImagePyramid::create(image->getWidth(), image->getHeight(), image->getNrOfChannels(), 256, 256);\n        imagePyramid->setSpacing(image->getSpacing());\n        SceneGraph::setParentNode(imagePyramid, image);\n        auto access = imagePyramid->getAccess(ACCESS_READ_WRITE);\n        for(int y = 0; y < image->getHeight(); y += 256) {\n            for(int x = 0; x < image->getWidth(); x += 256) {\n                auto width = std::min(image->getWidth() - x - 1, 256);\n                auto height = std::min(image->getHeight() - y - 1, 256);\n                access->setPatch(0, x, y, image->crop(Vector2i(x, y), Vector2i(width, height)));\n            }\n        }\n    }\n\n    if(imagePyramid->usesTIFF()) {\n        // If image pyramid is using TIFF backend. It is already stored on disk, we just need to copy it..\n        if(fileExists(m_filename)) {\n            // If destination file already exists, we have to remove the existing file, or copy will not run.\n            QFile::remove(m_filename.c_str());\n        }\n        QFile::copy(imagePyramid->getTIFFPath().c_str(), m_filename.c_str());\n        return;\n    }\n    // If not, we need to do a patch based copy\n\n    const Vector3f spacing = imagePyramid->getSpacing();\n\n    ImageCompression compression = m_compression;\n    if(!m_compressionSet || m_compression == ImageCompression::UNSPECIFIED) {\n        // Default compression\n        if(imagePyramid->getNrOfChannels() == 1) {\n            compression = ImageCompression::LZW;\n        } else if(imagePyramid->getNrOfChannels() == 3 || imagePyramid->getNrOfChannels() == 4) {\n            compression = ImageCompression::JPEG;\n        } else {\n            throw Exception(\"Unexpected nr of channels in ImagePyramid: \" + std::to_string(imagePyramid->getNrOfChannels()));\n        }\n    }\n\n    uint photometric = PHOTOMETRIC_RGB;\n    uint bitsPerSample = 8;\n    uint samplesPerPixel = 3; // RGBA image pyramid is converted to RGB with getPatchAsImage\n    if(imagePyramid->getNrOfChannels() == 1) {\n        photometric = PHOTOMETRIC_MINISBLACK; // Photometric mask causes crash..\n        samplesPerPixel = 1;\n    }\n\n    auto tiff = TIFFOpen(m_filename.c_str(), \"w8\");\n    if(tiff == nullptr) {\n        throw Exception(\"Unable to open file \" + m_filename + \" in TIFFImagePyramidExporter\");\n    }\n\n    // For each level, we need to 1) write fields, 2) write tiles\n    // We have to go from highest res level first\n    for(int level = 0; level < imagePyramid->getNrOfLevels(); ++level) {\n        reportInfo() << \"Writing level \" << level << reportEnd();\n\n        // Write base tags\n        TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, photometric);\n        TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, bitsPerSample);\n        TIFFSetField(tiff, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT);\n        TIFFSetField(tiff, TIFFTAG_SAMPLESPERPIXEL, (uint16_t)samplesPerPixel);\n        TIFFSetField(tiff, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n        TIFFSetField(tiff, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n\n        if(level > 0) {\n            // All levels except highest res level should have this tag?\n            TIFFSetField(tiff, TIFFTAG_SUBFILETYPE, FILETYPE_REDUCEDIMAGE);\n        }\n        switch(compression) {\n            case ImageCompression::RAW:\n                TIFFSetField(tiff, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n                break;\n            case ImageCompression::LZW:\n                TIFFSetField(tiff, TIFFTAG_COMPRESSION, COMPRESSION_LZW);\n                break;\n            case ImageCompression::JPEG:\n                TIFFSetField(tiff, TIFFTAG_COMPRESSION, COMPRESSION_JPEG);\n                break;\n            case ImageCompression::JPEG2000:\n                // TODO NOT IMPLEMENTED\n                throw NotImplementedException();\n                TIFFSetField(tiff, TIFFTAG_COMPRESSION, COMPRESSION_JP2000);\n                break;\n            case ImageCompression::NEURAL_NETWORK:\n                TIFFSetField(tiff, TIFFTAG_COMPRESSION, 34666); // TODO What should the value be?\n                break;\n        }\n\n        TIFFSetField(tiff, TIFFTAG_TILEWIDTH, imagePyramid->getLevelTileWidth(level));\n        TIFFSetField(tiff, TIFFTAG_TILELENGTH, imagePyramid->getLevelTileHeight(level));\n        TIFFSetField(tiff, TIFFTAG_IMAGEWIDTH, imagePyramid->getLevelWidth(level));\n        TIFFSetField(tiff, TIFFTAG_IMAGELENGTH, imagePyramid->getLevelHeight(level));\n        if(spacing.x() != 1 && spacing.y() != 1) { // Spacing == 1 means not set.\n            TIFFSetField(tiff, TIFFTAG_RESOLUTIONUNIT, RESUNIT_CENTIMETER);\n            float scaleX = (float) imagePyramid->getFullWidth() / imagePyramid->getLevelWidth(level);\n            float scaleY = (float) imagePyramid->getFullHeight() / imagePyramid->getLevelHeight(level);\n            TIFFSetField(tiff, TIFFTAG_XRESOLUTION,\n                         1.0f / (spacing.x() / 10) * scaleX); // Convert to cm, and adjust for level\n            TIFFSetField(tiff, TIFFTAG_YRESOLUTION,\n                         1.0f / (spacing.y() / 10) * scaleY); // Convert to cm, and adjust for level\n        }\n\n        std::cout << \"starting patch gen\" << std::endl;\n        auto generator = PatchGenerator::New();\n        generator->setInputData(imagePyramid);\n        generator->setPatchLevel(level);\n        generator->setPatchSize(imagePyramid->getLevelTileWidth(level), imagePyramid->getLevelTileHeight(level));\n        auto stream = DataStream(generator);\n\n        Image::pointer image;\n        int counter = 0;\n        while(!stream.isDone()) {\n            image = stream.getNextFrame<Image>();\n\n            // Write tile to tiff level\n            if(image->getWidth() != imagePyramid->getLevelTileWidth(level) || image->getHeight() != imagePyramid->getLevelTileHeight(level)) {\n                // Have to pad the image, TIFF expects all tiles to be equal\n                // TODO improve\n                auto paddedImage = Image::create(imagePyramid->getLevelTileWidth(level), imagePyramid->getLevelTileHeight(level), image->getDataType(), image->getNrOfChannels());\n                if(imagePyramid->getNrOfChannels() >= 3) {\n                    paddedImage->fill(255);\n                } else {\n                    paddedImage->fill(0);\n                }\n                auto device = std::dynamic_pointer_cast<OpenCLDevice>(getMainDevice());\n                {\n                    auto dest = paddedImage->getOpenCLImageAccess(ACCESS_READ_WRITE, device);\n                    auto src = image->getOpenCLImageAccess(ACCESS_READ, device);\n                    device->getCommandQueue().enqueueCopyImage(*src->get2DImage(), *dest->get2DImage(),\n                                                               createOrigoRegion(), createOrigoRegion(),\n                                                               createRegion(image->getSize()));\n                    device->getCommandQueue().finish();\n                }\n                if(image->isLastFrame())\n                    paddedImage->setLastFrame(\"PatchGenerator\");\n                image = paddedImage;\n            }\n            auto data = image->getImageAccess(ACCESS_READ)->get();\n            std::size_t byteSize = getSizeOfDataType(image->getDataType(), image->getNrOfChannels())*image->getNrOfVoxels();\n            mRuntimeManager->startRegularTimer(\"TIFF write\");\n            TIFFWriteEncodedTile(tiff, counter, data, byteSize);\n            mRuntimeManager->stopRegularTimer(\"TIFF write\");\n            ++counter;\n            mRuntimeManager->printAll();\n        } while(!image->isLastFrame());\n\n        TIFFWriteDirectory(tiff);\n    }\n\n    TIFFClose(tiff);\n}",
    "void GetMatrices(const char* fileName, Mat44f& camera, Mat44f& screen,\n                     bool doTranspose)\n    {\n        TIFF* tif = TIFFOpen(fileName, \"r\");\n        if (tif == NULL)\n        {\n            TWK_EXC_THROW_WHAT(Exception, \"Could not open file\");\n        }\n\n        float* ptr = NULL;\n        int rslt = TIFFGetField(tif, TIFFTAG_CAMERA_MATRIX, &ptr);\n        if (ptr == NULL)\n        {\n            TWK_EXC_THROW_WHAT(Exception, \"Could not get camera matrix\");\n        }\n        else\n        {\n            memcpy((void*)(&(camera[0][0])), (const void*)ptr,\n                   16 * sizeof(float));\n        }\n\n        rslt = TIFFGetField(tif, TIFFTAG_SCREEN_MATRIX, &ptr);\n        if (ptr == NULL)\n        {\n            TWK_EXC_THROW_WHAT(Exception, \"Could not get screen matrix\");\n        }\n        else\n        {\n            memcpy((void*)(&(screen[0][0])), (const void*)ptr,\n                   16 * sizeof(float));\n        }\n\n        TIFFClose(tif);\n\n        if (doTranspose)\n        {\n            camera.transpose();\n            screen.transpose();\n        }\n    }",
    "void IOtiff::getImageInfo(const std::string& filename, FBInfo& fbi) const\n    {\n#ifdef _MSC_VER\n        TIFF* tif = TIFFOpenW(UNICODE_C_STR(filename.c_str()), \"r\");\n#else\n        TIFF* tif = TIFFOpen(UNICODE_C_STR(filename.c_str()), \"r\");\n#endif\n\n        if (!tif)\n        {\n            TWK_THROW_STREAM(Exception,\n                             \"TIFF cannot open \\\"\" << filename << \"\\\"\");\n        }\n\n        unsigned short colorspace;\n        unsigned short orient = ORIENTATION_TOPLEFT;\n\n        TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &fbi.width);\n        TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &fbi.height);\n        TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &colorspace);\n        TIFFGetField(tif, TIFFTAG_ORIENTATION, &orient);\n\n        unsigned short samplesPerPixel = DEFAULT_TIFFTAG_SAMPLESPERPIXEL_VALUE;\n        TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &samplesPerPixel);\n        fbi.numChannels = samplesPerPixel;\n\n        unsigned short bitsPerSample = DEFAULT_TIFFTAG_BITSPERSAMPLE_VALUE;\n        TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bitsPerSample);\n\n        unsigned short sampleFormat = DEFAULT_TIFFTAG_SAMPLEFORMAT_VALUE;\n        TIFFGetField(tif, TIFFTAG_SAMPLEFORMAT, &sampleFormat);\n\n        uint16 config;\n        TIFFGetField(tif, TIFFTAG_PLANARCONFIG, &config);\n\n        float x_rez, y_rez;\n        if (TIFFGetField(tif, TIFFTAG_XRESOLUTION, &x_rez)\n            && TIFFGetField(tif, TIFFTAG_YRESOLUTION, &y_rez))\n        {\n            fbi.pixelAspect = x_rez != 0.0 ? y_rez / x_rez : 1.0;\n            unsigned short unit = 0;\n\n            if (TIFFGetField(tif, TIFFTAG_RESOLUTIONUNIT, &unit))\n            {\n                ostringstream str;\n\n                switch (unit)\n                {\n                case 1:\n                    str << \"None\";\n                    break;\n                case 2:\n                    str << \"Inch\";\n                    break;\n                case 3:\n                    str << \"Centimeter\";\n                    break;\n                default:\n                    str << \"Unknown (\" << unit << \")\";\n                    break;\n                }\n\n                fbi.proxy.newAttribute(\"TIFF/ResolutionUnit\", str.str());\n            }\n\n            fbi.proxy.setPixelAspectRatio(x_rez != 0.0 ? y_rez / x_rez : 1.0);\n            fbi.proxy.newAttribute(\"TIFF/XResolution\", x_rez);\n            fbi.proxy.newAttribute(\"TIFF/YResolution\", y_rez);\n        }\n\n        readAllTags(tif, fbi.proxy);\n\n        switch (bitsPerSample)\n        {\n        case 1:\n            fbi.dataType = FrameBuffer::BIT;\n            break;\n        case 8:\n            if (sampleFormat == SAMPLEFORMAT_INT)\n            {\n                // We promote tif signed int types to\n                // a float type framebuffer, normalized\n                // by the unsigned 8 bit value.\n                fbi.dataType = FrameBuffer::FLOAT;\n            }\n            else\n            {\n                fbi.dataType = FrameBuffer::UCHAR;\n            }\n            break;\n        case 16:\n            if (sampleFormat == SAMPLEFORMAT_INT)\n            {\n                // We promote tif signed int types to\n                // a float type framebuffer, normalized\n                // by the unsigned 16 bit value.\n                fbi.dataType = FrameBuffer::FLOAT;\n            }\n            else\n            {\n                fbi.dataType = FrameBuffer::USHORT;\n            }\n            break;\n        case 32:\n            if (sampleFormat == SAMPLEFORMAT_INT)\n            {\n                // We promote tif signed int types to\n                // a float type framebuffer, normalized\n                // by the unsigned 16 bit value for this case.\n                fbi.dataType = FrameBuffer::FLOAT;\n            }\n            else if (sampleFormat == SAMPLEFORMAT_UINT)\n            {\n                fbi.dataType = FrameBuffer::UINT;\n            }\n            else\n            {\n                fbi.dataType = FrameBuffer::FLOAT;\n            }\n            break;\n        default:\n            TIFFClose(tif);\n            TWK_THROW_STREAM(Exception, \"Sorry, unsupported bit depth.\");\n        }\n\n        bool readAsRGBA = false;\n\n        if ((colorspace != PHOTOMETRIC_RGB\n             && colorspace != PHOTOMETRIC_MINISBLACK\n             && colorspace != PHOTOMETRIC_MINISWHITE)\n            || (m_addAlphaTo3Channel && samplesPerPixel == 3)\n            || (config == PLANARCONFIG_CONTIG && samplesPerPixel > 4))\n        {\n            readAsRGBA = true;\n        }\n\n        if (readAsRGBA)\n        {\n            // TIFFReadRGBAImage(tif, width, height, p, 0);\n            fbi.orientation = FrameBuffer::NATURAL;\n        }\n        else if (TIFFIsTiled(tif))\n        {\n            // readContiguousTiledImage(tif, width, height, fb);\n            //  or readPlanarTiledImage(tif, width, height, fb);\n            bool flip = false;\n            bool flop = false;\n            flip =\n                orient == ORIENTATION_TOPLEFT || orient == ORIENTATION_TOPRIGHT;\n            flop = orient == ORIENTATION_TOPRIGHT\n                   || orient == ORIENTATION_BOTRIGHT;\n\n            if (flip)\n                fbi.orientation =\n                    (flop ? FrameBuffer::TOPRIGHT : FrameBuffer::TOPLEFT);\n            else\n                fbi.orientation =\n                    (flop ? FrameBuffer::BOTTOMRIGHT : FrameBuffer::NATURAL);\n        }\n        else\n        {\n            bool flip = false;\n            bool flop = false;\n            flop = orient == ORIENTATION_TOPRIGHT\n                   || orient == ORIENTATION_BOTRIGHT;\n            fbi.orientation =\n                flop ? FrameBuffer::BOTTOMRIGHT : FrameBuffer::NATURAL;\n        }\n\n        TIFFClose(tif);\n    }",
    "void IOtiff::readImage(FrameBuffer& fb, const std::string& filename,\n                           const ReadRequest& request) const\n    {\n        TIFF* tif = NULL;\n        StreamData* stream = NULL;\n\n        try\n        {\n            if (m_iotype == StandardIO)\n            {\n#ifdef _MSC_VER\n                tif = TIFFOpenW(UNICODE_C_STR(filename.c_str()), \"r\");\n#else\n                tif = TIFFOpen(UNICODE_C_STR(filename.c_str()), \"r\");\n#endif\n            }\n            else\n            {\n                stream = new StreamData(\n                    filename, (FileStream::Type)((unsigned int)m_iotype - 1),\n                    m_iosize, m_iomaxAsync);\n\n                tif = TIFFClientOpen(filename.c_str(), \"r\", (thandle_t)stream,\n                                     readproc, writeproc, seekproc, closeproc,\n                                     sizeproc, NULL, NULL);\n            }\n\n            if (!tif)\n            {\n                TWK_THROW_STREAM(Exception,\n                                 \"TIFF: cannot open \\\"\" << filename << \"\\\"\");\n            }\n\n            int width;\n            int height;\n            unsigned short bitsPerSample = DEFAULT_TIFFTAG_BITSPERSAMPLE_VALUE;\n            FrameBuffer::DataType dataType = FrameBuffer::UCHAR;\n            unsigned short samplesPerPixel =\n                DEFAULT_TIFFTAG_SAMPLESPERPIXEL_VALUE;\n            uint16 config;\n            bool istexture = false;\n            bool isshadow = false;\n            char* texformat = 0;\n            char* datetime = 0;\n            unsigned short colorspace = 2;\n            float x_rez, y_rez;\n            uint16 numExtra = 0, *extraSamples = 0;\n            unsigned short sampleFormat = DEFAULT_TIFFTAG_SAMPLEFORMAT_VALUE;\n\n            TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &colorspace);\n            TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n            TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n            TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bitsPerSample);\n            TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &samplesPerPixel);\n            TIFFGetField(tif, TIFFTAG_SAMPLEFORMAT, &sampleFormat);\n            TIFFGetField(tif, TIFFTAG_PLANARCONFIG, &config);\n            TIFFGetField(tif, TIFFTAG_EXTRASAMPLES, &numExtra, &extraSamples);\n\n#if 0\n        if (TIFFGetField(tif, TIFFTAG_PIXAR_TEXTUREFORMAT, &texformat) == 1)\n        {\n            istexture = true;\n            isshadow = !strcmp(texformat, \"Shadow\");\n        }\n#endif\n\n            FrameBuffer* img = NULL;\n            bool readAsRGBA = false;\n\n            if ((colorspace != PHOTOMETRIC_RGB\n                 && colorspace != PHOTOMETRIC_MINISBLACK\n                 && colorspace != PHOTOMETRIC_MINISWHITE)\n                || (m_addAlphaTo3Channel && samplesPerPixel == 3)\n                || (config == PLANARCONFIG_CONTIG && samplesPerPixel > 4))\n            {\n                readAsRGBA = true;\n                samplesPerPixel = 4;\n            }\n\n            switch (bitsPerSample)\n            {\n            case 1:\n                dataType = FrameBuffer::UCHAR;\n                break;\n\n            case 8:\n                if (sampleFormat == SAMPLEFORMAT_INT)\n                {\n                    // We promote tif signed int types to\n                    // a float type framebuffer, normalized\n                    // by the unsigned 8 bit value.\n                    dataType = FrameBuffer::FLOAT;\n                }\n                else\n                {\n                    dataType = FrameBuffer::UCHAR;\n                }\n                break;\n\n            case 16:\n                if (sampleFormat == SAMPLEFORMAT_INT)\n                {\n                    // We promote tif signed int types to\n                    // a float type framebuffer, normalized\n                    // by the unsigned 16 bit value.\n                    dataType = FrameBuffer::FLOAT;\n                }\n                else\n                {\n                    dataType = FrameBuffer::USHORT;\n                }\n                break;\n\n            case 32:\n                if (sampleFormat == SAMPLEFORMAT_INT)\n                {\n                    // We promote tif signed int types to\n                    // a float type framebuffer, normalized\n                    // by the unsigned 16 bit value for this case.\n                    dataType = FrameBuffer::FLOAT;\n                }\n                else if (sampleFormat == SAMPLEFORMAT_UINT)\n                {\n                    dataType = FrameBuffer::UINT;\n                }\n                else\n                {\n                    dataType = FrameBuffer::FLOAT;\n                }\n                break;\n\n            default:\n                TWK_THROW_STREAM(UnsupportedException,\n                                 \"TIFF: Unsupported bit depth (\"\n                                     << bitsPerSample << \") trying to read \"\n                                     << filename);\n            }\n\n            if (config == PLANARCONFIG_SEPARATE)\n            {\n                const char* chanNames[] = {\"R\", \"G\", \"B\", \"A\", \"Z\",\n                                           \"X\", \"Y\", \"P\", \"D\", \"Q\"};\n\n                StringVector planeNames;\n\n                for (int i = 0; i < samplesPerPixel && i < 10; i++)\n                {\n                    planeNames.push_back(string(chanNames[i]));\n                }\n\n                fb.restructurePlanar(width, height, planeNames, dataType,\n                                     FrameBuffer::NATURAL);\n            }\n            else\n            {\n                fb.restructure(\n                    width, height, 0, min((int)samplesPerPixel, 4),\n                    dataType); // interleaved, we can only do 4 channels\n            }\n\n            string message = \"Reading TIFF \" + stl_ext::basename(filename);\n\n            if (readAsRGBA)\n            {\n                uint32* p = fb.begin<uint32>();\n                const uint32* e = fb.end<uint32>();\n\n                TIFFReadRGBAImage(tif, width, height, p, 0);\n\n#ifdef __BIG_ENDIAN__\n                for (; p < e; p++)\n                {\n                    const uint32 i = *p;\n                    *p = (uint32(TIFFGetR(i)) << 24)\n                         | (uint32(TIFFGetG(i)) << 16)\n                         | (uint32(TIFFGetB(i)) << 8) | uint32(TIFFGetA(i));\n                }\n#endif\n            }\n            else if (TIFFIsTiled(tif))\n            {\n                if (config == PLANARCONFIG_CONTIG)\n                {\n                    readContiguousTiledImage(tif, width, height, fb);\n                    fb.newAttribute(\"TIFF/PlanarConfig\",\n                                    string(\"Tiled Contiguous\"));\n                }\n                else\n                {\n                    readPlanarTiledImage(tif, width, height, fb);\n                    fb.newAttribute(\"TIFF/PlanarConfig\",\n                                    string(\"Tiled Separate\"));\n                }\n            }\n            else\n            {\n                if (config == PLANARCONFIG_CONTIG)\n                {\n                    if (samplesPerPixel == 1\n                        || (dataType != FrameBuffer::USHORT\n                            && samplesPerPixel <= 4))\n                    {\n                        readContiguousScanlineImage(tif, width, height, fb);\n                    }\n                    else\n                    {\n                        const char* chanNames[] = {\"R\", \"G\", \"B\", \"A\", \"Z\",\n                                                   \"X\", \"Y\", \"P\", \"D\", \"Q\"};\n\n                        if (!fb.isPlanar())\n                        {\n                            StringVector planeNames;\n\n                            for (int i = 0; i < samplesPerPixel && i < 10; i++)\n                            {\n                                planeNames.push_back(string(chanNames[i]));\n                            }\n\n                            fb.restructurePlanar(width, height, planeNames,\n                                                 dataType,\n                                                 FrameBuffer::NATURAL);\n                        }\n                        readContiguousScanlineImageAsPlanar(tif, width, height,\n                                                            fb);\n                    }\n\n                    fb.newAttribute(\"TIFF/PlanarConfig\", string(\"Contiguous\"));\n                }\n                else\n                {\n                    readPlanarScanlineImage(tif, width, height, samplesPerPixel,\n                                            fb);\n                    fb.newAttribute(\"TIFF/PlanarConfig\", string(\"Separate\"));\n                }\n            }\n\n            //\n            //  Here we have a workaround for Maya writing the resolution tags\n            //  wrong. Someday this should be replaced with a rule in our fancy\n            //  rules system.\n            //\n\n            char* software = NULL;\n            bool isMaya = false;\n            unsigned int compression;\n\n            if (TIFFGetField(tif, TIFFTAG_COMPRESSION, &compression))\n            {\n                string compressionName = tagToName(compression, compTags);\n                fb.newAttribute(\"TIFF/Compression\", compressionName);\n            }\n\n            if (TIFFGetField(tif, TIFFTAG_SOFTWARE, &software))\n            {\n                fb.newAttribute(\"TIFF/Software\", string(software));\n\n                if (!strncmp(software, \"Maya\", 4))\n                {\n                    isMaya = true;\n                }\n            }\n\n            if (TIFFGetField(tif, TIFFTAG_XRESOLUTION, &x_rez)\n                && TIFFGetField(tif, TIFFTAG_YRESOLUTION, &y_rez))\n            {\n                unsigned short unit = 0;\n\n                if (TIFFGetField(tif, TIFFTAG_RESOLUTIONUNIT, &unit))\n                {\n                    ostringstream str;\n\n                    switch (unit)\n                    {\n                    case 1:\n                        str << \"None\";\n                        break;\n                    case 2:\n                        str << \"Inch\";\n                        break;\n                    case 3:\n                        str << \"Centimeter\";\n                        break;\n                    default:\n                        str << \"Unknown (\" << unit << \")\";\n                        break;\n                    }\n\n                    fb.newAttribute(\"TIFF/ResolutionUnit\", str.str());\n                }\n\n                if (!isMaya)\n                {\n                    fb.setPixelAspectRatio(x_rez != 0.0 ? y_rez / x_rez : 1.0);\n                }\n\n                fb.newAttribute(\"TIFF/XResolution\", x_rez);\n                fb.newAttribute(\"TIFF/YResolution\", y_rez);\n            }\n\n            readAllTags(tif, fb);\n\n            TIFFClose(tif);\n\n#if 0\n        if (isshadow)\n        {\n            TwkFB::normalize(&fb, true, true);\n        }\n#endif\n\n            if (numExtra)\n            {\n                switch (extraSamples[0])\n                {\n                case EXTRASAMPLE_UNASSALPHA:\n                    fb.attribute<string>(\"AlphaType\") = \"Unpremultipled\";\n                    break;\n                case EXTRASAMPLE_ASSOCALPHA:\n                    fb.attribute<string>(\"AlphaType\") = \"Premultiplied\";\n                    break;\n                default:\n                    break;\n                }\n            }\n\n            //\n            //  Most cards can't handle RGB or RGBA 16bit int textures.\n            //\n            if (fb.dataType() == FrameBuffer::USHORT && fb.numChannels() != 1\n                && !fb.isPlanar())\n            {\n                //  cerr << \"converting tiff to planar\" << endl;\n                FrameBufferVector fbv = split(&fb);\n                fbv[0]->setIdentifier(fb.identifier());\n                fb.copyAttributesTo(fbv[0]);\n                for (int j = 1; j < fbv.size(); ++j)\n                    fbv[0]->appendPlane(fbv[j]);\n                fb.copyFrom(fbv[0]);\n                delete fbv[0];\n            }\n        }\n        catch (...)\n        {\n            delete stream;\n            stream = 0;\n            throw;\n        }\n\n        delete stream;\n    }",
    "void IOtiff::writeImage(const FrameBuffer& img, const std::string& filename,\n                            const WriteRequest& request) const\n    {\n#ifdef _MSC_VER\n        TIFF* tif = TIFFOpenW(UNICODE_C_STR(filename.c_str()), \"w\");\n#else\n        TIFF* tif = TIFFOpen(filename.c_str(), \"w\");\n#endif\n        const FrameBuffer* outfb = &img;\n        bool yryby = img.isYRYBY() || img.isYRYBYPlanar();\n\n        if (!tif)\n        {\n            TWK_THROW_STREAM(IOException, \"TIFF: cannot open \"\n                                              << filename << \" for writing\");\n        }\n\n        switch (outfb->dataType())\n        {\n        case FrameBuffer::HALF:\n            outfb = copyConvert(outfb, FrameBuffer::FLOAT);\n            // fall through\n        case FrameBuffer::FLOAT:\n            TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);\n            break;\n        case FrameBuffer::USHORT:\n        case FrameBuffer::UCHAR:\n            TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT);\n            break;\n        case FrameBuffer::PACKED_R10_G10_B10_X2:\n        case FrameBuffer::PACKED_X2_B10_G10_R10:\n        case FrameBuffer::PACKED_Y8_Cb8_Y8_Cr8:\n        case FrameBuffer::PACKED_Cb8_Y8_Cr8_Y8:\n        {\n            const FrameBuffer* nfb = outfb;\n            outfb = convertToLinearRGB709(outfb);\n            delete nfb;\n            TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT);\n            break;\n        }\n        default:\n            TWK_THROW_STREAM(Exception, \"TIFF: Unsupported data format: \"\n                                            << outfb->dataType());\n        }\n\n        //\n        //  If its planar and the request is to convert to packed or for\n        //  the \"common\" format, then make the image packed RGB.\n        //\n\n        if (img.isPlanar()\n            && (!request.keepPlanar || request.preferCommonFormat || yryby))\n        {\n            const FrameBuffer* fb = outfb;\n            outfb = mergePlanes(outfb);\n            if (fb != &img)\n                delete fb;\n        }\n\n        //\n        //  Convert YUV, YRYBY, or non-RGB 709 images to RGB 709 In the\n        //  case of YRYBY, TIFF can't really store it so we need to\n        //  convert no matter what.\n        //\n\n        if ((request.preferCommonFormat\n             && (outfb->hasPrimaries() || outfb->isYUV()))\n            || yryby)\n        {\n            const FrameBuffer* fb = outfb;\n            outfb = convertToLinearRGB709(outfb);\n            if (fb != &img)\n                delete fb;\n        }\n\n        assert(!outfb->isPlanar()); // can't write the planar images yet\n\n        unsigned short tifforientation;\n\n        //\n        //  Don't ask\n        //\n\n        switch (outfb->orientation())\n        {\n        case FrameBuffer::NATURAL:\n            tifforientation = ORIENTATION_TOPLEFT;\n            break;\n        case FrameBuffer::TOPLEFT:\n            tifforientation = ORIENTATION_BOTLEFT;\n            break;\n        case FrameBuffer::TOPRIGHT:\n            tifforientation = ORIENTATION_BOTRIGHT;\n            break;\n        case FrameBuffer::BOTTOMRIGHT:\n            tifforientation = ORIENTATION_TOPRIGHT;\n            break;\n        default:\n            break;\n        };\n\n        TIFFSetField(tif, TIFFTAG_ORIENTATION, tifforientation);\n\n        //\n        //  Basic geometry\n        //\n\n        TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, outfb->width());\n        TIFFSetField(tif, TIFFTAG_IMAGELENGTH, outfb->height());\n        TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, outfb->numChannels());\n        TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8 * outfb->bytesPerChannel());\n        TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n        TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, outfb->height());\n\n        //\n        //  Compression\n        //\n\n        unsigned int compression = COMPRESSION_DEFLATE; // default zip compress\n\n        if (unsigned int ctag =\n                nameToTag(request.compression.c_str(), compTags))\n        {\n            compression = ctag;\n        }\n        else if (request.compression != \"\")\n        {\n            cerr << \"WARNING: IOtiff: unknown compression type \"\n                 << request.compression << \", using DEFLATE instead\" << endl;\n\n            compression = COMPRESSION_DEFLATE;\n        }\n\n        TIFFSetField(tif, TIFFTAG_COMPRESSION, compression);\n\n        //\n        //  Photometric interpretation\n        //\n\n        if (outfb->isYUV())\n        {\n            TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);\n        }\n        else\n        {\n            TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n        }\n\n        if (outfb->hasChannel(\"A\") && outfb->numChannels() > 1)\n        {\n            uint16 extrasamples = 1;\n            uint16 sampleinfo[1] = {EXTRASAMPLE_ASSOCALPHA};\n            TIFFSetField(tif, TIFFTAG_EXTRASAMPLES, extrasamples, sampleinfo);\n        }\n\n        for (int y = 0; y < outfb->height(); ++y)\n        {\n            int flipY = outfb->height() - y - 1;\n\n            if (TIFFWriteScanline(\n                    tif, (void*)outfb->scanline<unsigned char>(flipY), y, 0)\n                == -1)\n            {\n                TWK_THROW_STREAM(IOException,\n                                 \"TIFF: Error write scanline \" << filename);\n            }\n        }\n\n        TIFFClose(tif);\n        if (outfb != &img)\n            delete outfb;\n    }",
    "static void readTIFF(ImageType::ImageStruct* im,\n                         const Mu::String& imgFileName, Thread& thread)\n    {\n        Process* process = thread.process();\n        MuLangContext* context = (MuLangContext*)process->context();\n\n        //\n        // Suppress annoying messages about unknown tags, etc...\n        //\n\n        TIFFSetErrorHandler(0);\n        TIFFSetWarningHandler(0);\n\n        TIFF* tif = TIFFOpen(imgFileName.c_str(), \"r\");\n\n        if (!tif)\n        {\n            const Mu::MuLangContext* context =\n                static_cast<const Mu::MuLangContext*>(thread.context());\n            ExceptionType::Exception* e =\n                new ExceptionType::Exception(context->exceptionType());\n            e->string() = \"failed to open image \\\"\";\n            e->string() += imgFileName;\n            e->string() += \"\\\"\";\n            thread.setException(e);\n            throw ProgramException(e);\n        }\n\n        uint16* sampleinfo;\n        uint16 extrasamples;\n        uint16 bps;\n\n        int width, height;\n\n        TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n        TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n        TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bps);\n\n        im->width = width;\n        im->height = height;\n\n        TIFFGetFieldDefaulted(tif, TIFFTAG_EXTRASAMPLES, &extrasamples,\n                              &sampleinfo);\n\n        unsigned short orient = ORIENTATION_TOPLEFT;\n        TIFFGetField(tif, TIFFTAG_ORIENTATION, &orient);\n        bool flip =\n            orient == ORIENTATION_BOTLEFT || orient == ORIENTATION_BOTRIGHT;\n        bool flop =\n            orient == ORIENTATION_BOTRIGHT || orient == ORIENTATION_TOPRIGHT;\n        flop = false;\n\n        bool hasAlpha = extrasamples == 1 ? true : false;\n\n        DynamicArrayType* dataType = static_cast<DynamicArrayType*>(\n            context->arrayType(context->vec4fType(), 1, 0));\n        im->data = new DynamicArray(dataType, 1);\n        im->data->resize(width * height);\n\n        vector<char> buf(TIFFScanlineSize(tif));\n\n        int y0 = 0;\n        int y1 = height;\n        int inc = 1;\n\n        switch (bps)\n        {\n        case 32:\n            for (int y = 0; y < height; y++)\n            {\n                int oy = flip ? (height - 1 - y) : y;\n\n                if (hasAlpha)\n                {\n                    TIFFReadScanline(tif, (float*)im->row(oy), y);\n                }\n                else\n                {\n                    TIFFReadScanline(tif, &buf[0], y);\n                    Vector4f* dstPixel = im->row(oy);\n                    Vector3f* srcPixel = reinterpret_cast<Vector3f*>(&buf[0]);\n\n                    for (int x = 0; x < width; ++x, ++dstPixel, ++srcPixel)\n                    {\n                        (*dstPixel)[0] = (*srcPixel)[0];\n                        (*dstPixel)[1] = (*srcPixel)[1];\n                        (*dstPixel)[2] = (*srcPixel)[2];\n                        (*dstPixel)[3] = 1.0f;\n                    }\n                }\n\n                if (flop)\n                    reverse(im->row(oy), im->row(oy) + width);\n            }\n            break;\n\n        case 16:\n            for (int y = 0; y < height; y++)\n            {\n                int oy = flip ? (height - 1 - y) : y;\n                TIFFReadScanline(tif, &buf[0], y);\n                Vector4f* dstPixel = im->row(oy);\n\n                if (hasAlpha)\n                {\n                    Vector4s* srcPixel = reinterpret_cast<Vector4s*>(&buf[0]);\n\n                    for (int x = 0; x < width; ++x, ++dstPixel, ++srcPixel)\n                    {\n                        (*dstPixel)[0] = (*srcPixel)[0] / 65535.0f;\n                        (*dstPixel)[1] = (*srcPixel)[1] / 65535.0f;\n                        (*dstPixel)[2] = (*srcPixel)[2] / 65535.0f;\n                        (*dstPixel)[3] = (*srcPixel)[3] / 65535.0f;\n                    }\n                }\n                else\n                {\n                    Vector3s* srcPixel = reinterpret_cast<Vector3s*>(&buf[0]);\n\n                    for (int x = 0; x < width; ++x, ++dstPixel, ++srcPixel)\n                    {\n                        (*dstPixel)[0] = (*srcPixel)[0] / 65535.0f;\n                        (*dstPixel)[1] = (*srcPixel)[1] / 65535.0f;\n                        (*dstPixel)[2] = (*srcPixel)[2] / 65535.0f;\n                        (*dstPixel)[3] = 1.0f;\n                    }\n                }\n\n                if (flop)\n                    reverse(im->row(oy), im->row(oy) + width);\n            }\n            break;\n\n        case 8:\n\n            for (int y = 0; y < height; y++)\n            {\n                int oy = flip ? (height - 1 - y) : y;\n                TIFFReadScanline(tif, &buf[0], y);\n                Vector4f* dstPixel = im->row(oy);\n\n                if (hasAlpha)\n                {\n                    Vector4c* srcPixel = reinterpret_cast<Vector4c*>(&buf[0]);\n\n                    for (int x = 0; x < width; ++x, ++dstPixel, ++srcPixel)\n                    {\n                        (*dstPixel)[0] = (*srcPixel)[0] / 255.0f;\n                        (*dstPixel)[1] = (*srcPixel)[1] / 255.0f;\n                        (*dstPixel)[2] = (*srcPixel)[2] / 255.0f;\n                        (*dstPixel)[3] = (*srcPixel)[3] / 255.0f;\n                    }\n                }\n                else\n                {\n                    Vector3c* srcPixel = reinterpret_cast<Vector3c*>(&buf[0]);\n\n                    for (int x = 0; x < width; ++x, ++dstPixel, ++srcPixel)\n                    {\n                        (*dstPixel)[0] = (*srcPixel)[0] / 255.0f;\n                        (*dstPixel)[1] = (*srcPixel)[1] / 255.0f;\n                        (*dstPixel)[2] = (*srcPixel)[2] / 255.0f;\n                        (*dstPixel)[3] = 1.0f;\n                    }\n                }\n\n                if (flop)\n                    reverse(im->row(oy), im->row(oy) + width);\n            }\n            break;\n\n        default:\n\n            TIFFClose(tif);\n            {\n                width = 0;\n                const Mu::MuLangContext* context =\n                    static_cast<const Mu::MuLangContext*>(thread.context());\n                ExceptionType::Exception* e =\n                    new ExceptionType::Exception(context->exceptionType());\n                e->string() = \"Unsupported bit depth in image file \\\"\";\n                e->string() += imgFileName;\n                e->string() += \"\\\"\";\n                thread.setException(e);\n                throw ProgramException(e);\n            }\n        }\n\n        TIFFClose(tif);\n    }",
    "Img4f* TiffIff::read(const char* imgFileName, bool showWarnings)\n    {\n        if (!showWarnings)\n        {\n            // Suppress annoying messages about unknown tags, etc...\n            TIFFSetErrorHandler(0);\n            TIFFSetWarningHandler(0);\n        }\n\n        TIFF* tif = TIFFOpen(imgFileName, \"r\");\n        if (tif == NULL)\n        {\n            IffExc exc(\"Could not open specified image file for reading\");\n            throw(exc);\n        }\n\n        int width;\n        int height;\n        uint16 bitsPerSample;\n        uint16* sampleinfo;\n        uint16 extrasamples;\n\n        TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n        TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n        TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bitsPerSample);\n\n        TIFFGetFieldDefaulted(tif, TIFFTAG_EXTRASAMPLES, &extrasamples,\n                              &sampleinfo);\n\n        bool hasAlpha = false;\n        if (extrasamples == 1)\n        {\n            hasAlpha = true;\n        }\n\n        Img4f* ret = new Img4f(width, height);\n        tdata_t buf = _TIFFmalloc(TIFFScanlineSize(tif));\n\n        switch (bitsPerSample)\n        {\n        case 32:\n            for (int y = 0; y < height; ++y)\n            {\n                if (hasAlpha)\n                {\n                    TIFFReadScanline(tif, &(ret->pixel(0, height - y - 1)), y);\n                }\n                else\n                {\n                    TIFFReadScanline(tif, buf, y);\n                    Col4f* dstPixel = (*ret)[height - y - 1];\n                    Col3f* srcPixel = (Col3f*)buf;\n                    for (int x = 0; x < width; ++x, ++dstPixel, ++srcPixel)\n                    {\n                        (*dstPixel).x = srcPixel->x;\n                        (*dstPixel).y = srcPixel->y;\n                        (*dstPixel).z = srcPixel->z;\n                        (*dstPixel).w = 1.0f;\n                    }\n                }\n            }\n            break;\n        case 16:\n            for (int y = 0; y < height; ++y)\n            {\n                TIFFReadScanline(tif, buf, y);\n\n                Col4f* dstPixel = (*ret)[height - y - 1];\n                if (hasAlpha)\n                {\n                    Col4us* srcPixel = (Col4us*)buf;\n                    for (int x = 0; x < width; ++x, ++dstPixel, ++srcPixel)\n                    {\n                        (*dstPixel).x = (float)srcPixel->x / 65535.0f;\n                        (*dstPixel).y = (float)srcPixel->y / 65535.0f;\n                        (*dstPixel).z = (float)srcPixel->z / 65535.0f;\n                        (*dstPixel).w = (float)srcPixel->w / 65535.0f;\n                    }\n                }\n                else\n                {\n                    Col3us* srcPixel = (Col3us*)buf;\n                    for (int x = 0; x < width; ++x, ++dstPixel, ++srcPixel)\n                    {\n                        (*dstPixel).x = (float)srcPixel->x / 65535.0f;\n                        (*dstPixel).y = (float)srcPixel->y / 65535.0f;\n                        (*dstPixel).z = (float)srcPixel->z / 65535.0f;\n                        (*dstPixel).w = 1.0f;\n                    }\n                }\n            }\n            break;\n        case 8:\n            for (int y = 0; y < height; ++y)\n            {\n                TIFFReadScanline(tif, buf, y);\n\n                Col4f* dstPixel = (*ret)[height - y - 1];\n\n                if (hasAlpha)\n                {\n                    Col4uc* srcPixel = (Col4uc*)buf;\n                    for (int x = 0; x < width; ++x, ++dstPixel, ++srcPixel)\n                    {\n                        (*dstPixel).x = (float)srcPixel->x / 255.0f;\n                        (*dstPixel).y = (float)srcPixel->y / 255.0f;\n                        (*dstPixel).z = (float)srcPixel->z / 255.0f;\n                        (*dstPixel).w = (float)srcPixel->w / 255.0f;\n                    }\n                }\n                else\n                {\n                    Col3uc* srcPixel = (Col3uc*)buf;\n                    for (int x = 0; x < width; ++x, ++dstPixel, ++srcPixel)\n                    {\n                        (*dstPixel).x = (float)srcPixel->x / 255.0f;\n                        (*dstPixel).y = (float)srcPixel->y / 255.0f;\n                        (*dstPixel).z = (float)srcPixel->z / 255.0f;\n                        (*dstPixel).w = 1.0f;\n                    }\n                }\n            }\n            break;\n        default:\n            IffExc exc(\"Sorry, unsupported TIFF data type.\");\n            throw(exc);\n        } // End switch( bitsPerSample )\n\n        _TIFFfree(buf);\n\n        TIFFClose(tif);\n\n        return ret;\n    }",
    "Img4uc* TiffIff::read4uc(const char* imgFileName, bool showWarnings)\n    {\n        if (!showWarnings)\n        {\n            // Suppress annoying messages about unknown tags, etc...\n            TIFFSetErrorHandler(0);\n            TIFFSetWarningHandler(0);\n        }\n\n        TIFF* tif = TIFFOpen(imgFileName, \"r\");\n        if (tif == NULL)\n        {\n            IffExc exc(\"Could not open specified image file for reading\");\n            throw(exc);\n        }\n\n        int width;\n        int height;\n        uint16 bitsPerSample;\n        uint16* sampleinfo;\n        uint16 extrasamples;\n\n        TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n        TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n        TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bitsPerSample);\n\n        TIFFGetFieldDefaulted(tif, TIFFTAG_EXTRASAMPLES, &extrasamples,\n                              &sampleinfo);\n\n        bool hasAlpha = false;\n        if (extrasamples == 1)\n        {\n            hasAlpha = true;\n        }\n\n        Img4uc* ret = new Img4uc(width, height);\n        tdata_t buf = _TIFFmalloc(TIFFScanlineSize(tif));\n\n        switch (bitsPerSample)\n        {\n        case 32:\n            for (int y = 0; y < height; ++y)\n            {\n                TIFFReadScanline(tif, buf, y);\n\n                Col4uc* dstPixel = (*ret)[height - y - 1];\n                if (hasAlpha)\n                {\n                    Col4f* srcPixel = (Col4f*)buf;\n                    (*dstPixel).x = (unsigned char)(TwkMath::clamp(\n                        (*srcPixel).x * 255.0f, 0.0f, 255.0f));\n                    (*dstPixel).y = (unsigned char)(TwkMath::clamp(\n                        (*srcPixel).y * 255.0f, 0.0f, 255.0f));\n                    (*dstPixel).z = (unsigned char)(TwkMath::clamp(\n                        (*srcPixel).z * 255.0f, 0.0f, 255.0f));\n                    (*dstPixel).w = (unsigned char)(TwkMath::clamp(\n                        (*srcPixel).w * 255.0f, 0.0f, 255.0f));\n                }\n                else\n                {\n                    Col3f* srcPixel = (Col3f*)buf;\n                    (*dstPixel).x = (unsigned char)(TwkMath::clamp(\n                        (*srcPixel).x * 255.0f, 0.0f, 255.0f));\n                    (*dstPixel).y = (unsigned char)(TwkMath::clamp(\n                        (*srcPixel).y * 255.0f, 0.0f, 255.0f));\n                    (*dstPixel).z = (unsigned char)(TwkMath::clamp(\n                        (*srcPixel).z * 255.0f, 0.0f, 255.0f));\n                    (*dstPixel).w = 255;\n                }\n            }\n            break;\n        case 16:\n            for (int y = 0; y < height; ++y)\n            {\n                TIFFReadScanline(tif, buf, y);\n\n                Col4uc* dstPixel = (*ret)[height - y - 1];\n                if (hasAlpha)\n                {\n                    Col4us* srcPixel = (Col4us*)buf;\n                    for (int x = 0; x < width; ++x, ++dstPixel, ++srcPixel)\n                    {\n                        (*dstPixel).x = (unsigned char)(TwkMath::clamp(\n                            (*srcPixel).x / 255.0f, 0.0f, 255.0f));\n                        (*dstPixel).y = (unsigned char)(TwkMath::clamp(\n                            (*srcPixel).y / 255.0f, 0.0f, 255.0f));\n                        (*dstPixel).z = (unsigned char)(TwkMath::clamp(\n                            (*srcPixel).z / 255.0f, 0.0f, 255.0f));\n                        (*dstPixel).w = (unsigned char)(TwkMath::clamp(\n                            (*srcPixel).w / 255.0f, 0.0f, 255.0f));\n                    }\n                }\n                else\n                {\n                    Col3us* srcPixel = (Col3us*)buf;\n                    for (int x = 0; x < width; ++x, ++dstPixel, ++srcPixel)\n                    {\n                        (*dstPixel).x = (unsigned char)(TwkMath::clamp(\n                            (*srcPixel).x / 255.0f, 0.0f, 255.0f));\n                        (*dstPixel).y = (unsigned char)(TwkMath::clamp(\n                            (*srcPixel).y / 255.0f, 0.0f, 255.0f));\n                        (*dstPixel).z = (unsigned char)(TwkMath::clamp(\n                            (*srcPixel).z / 255.0f, 0.0f, 255.0f));\n                        (*dstPixel).w = 255;\n                    }\n                }\n            }\n            break;\n        case 8:\n            for (int y = 0; y < height; ++y)\n            {\n                TIFFReadScanline(tif, buf, y);\n\n                Col4uc* dstPixel = (*ret)[height - y - 1];\n\n                if (hasAlpha)\n                {\n                    TIFFReadScanline(tif, &(ret->pixel(0, height - y - 1)), y);\n                }\n                else\n                {\n                    Col3uc* srcPixel = (Col3uc*)buf;\n                    for (int x = 0; x < width; ++x, ++dstPixel, ++srcPixel)\n                    {\n                        (*dstPixel).x = srcPixel->x;\n                        (*dstPixel).y = srcPixel->y;\n                        (*dstPixel).z = srcPixel->z;\n                        (*dstPixel).w = 255;\n                    }\n                }\n            }\n            break;\n        default:\n            IffExc exc(\"Sorry, unsupported TIFF data type.\");\n            throw(exc);\n        } // End switch( bitsPerSample )\n\n        _TIFFfree(buf);\n\n        TIFFClose(tif);\n\n        return ret;\n    }",
    "static bool TiffIff_write_f(const Img4f* img, const char* fileName,\n                                const TwkMath::Mat44f* Mcamera,\n                                const TwkMath::Mat44f* Mscreen, const int depth)\n    {\n        if (depth != 8 && depth != 16 && depth != 32)\n        {\n            string errmsg = \"Unable to write bit depth: \" + depth;\n            IffExc exc(errmsg.c_str());\n            throw(exc);\n        }\n\n        TIFF* tif = TIFFOpen(fileName, \"w\");\n        if (tif == NULL)\n        {\n            IffExc exc(\"Could not open specified image file for writing\");\n            throw(exc);\n        }\n\n        TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, img->width());\n        TIFFSetField(tif, TIFFTAG_IMAGELENGTH, img->height());\n        TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 4);\n        TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, depth);\n        TIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n        TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n        TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n        TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_PACKBITS);\n\n        if (Mcamera != NULL)\n        {\n            TIFFSetField(tif, TIFFTAG_CAMERA_MATRIX, (uint16)16,\n                         (const float*)Mcamera);\n        }\n        if (Mscreen != NULL)\n        {\n            TIFFSetField(tif, TIFFTAG_SCREEN_MATRIX, (uint16)16,\n                         (const float*)Mscreen);\n        }\n\n        char hostname[64];\n        gethostname(hostname, 64);\n        TIFFSetField(tif, TIFFTAG_HOSTCOMPUTER, hostname);\n\n        switch (depth)\n        {\n        case 32:\n            TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);\n            break;\n        case 16:\n            TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT);\n            break;\n        case 8:\n            TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT);\n            break;\n        default:\n            break;\n        }\n        uint16 extrasamples = 1;\n        uint16 sampleinfo[1] = {EXTRASAMPLE_ASSOCALPHA};\n        TIFFSetField(tif, TIFFTAG_EXTRASAMPLES, extrasamples, sampleinfo);\n\n        tdata_t buf = _TIFFmalloc(TIFFScanlineSize(tif));\n\n        switch (depth)\n        {\n        case 8:\n            for (int y = 0; y < img->height(); ++y)\n            {\n                Col4uc* dstPixel = (Col4uc*)buf;\n                const Col4f* srcPixel = (*img)[img->height() - y - 1];\n\n                for (int x = 0; x < img->width(); ++x, dstPixel++, ++srcPixel)\n                {\n                    (*dstPixel).x = (unsigned char)(TwkMath::clamp(\n                        (*srcPixel).x * 255.0f, 0.0f, 255.0f));\n                    (*dstPixel).y = (unsigned char)(TwkMath::clamp(\n                        (*srcPixel).y * 255.0f, 0.0f, 255.0f));\n                    (*dstPixel).z = (unsigned char)(TwkMath::clamp(\n                        (*srcPixel).z * 255.0f, 0.0f, 255.0f));\n                    (*dstPixel).w = (unsigned char)(TwkMath::clamp(\n                        (*srcPixel).w * 255.0f, 0.0f, 255.0f));\n                }\n                if (TIFFWriteScanline(tif, buf, y, 0) == -1)\n                {\n                    IffExc exc(\"Error while writing TIFF scanline\");\n                    throw(exc);\n                }\n            }\n            break;\n        case 16:\n            for (int y = 0; y < img->height(); ++y)\n            {\n                Col4us* dstPixel = (Col4us*)buf;\n                const Col4f* srcPixel = (*img)[img->height() - y - 1];\n\n                for (int x = 0; x < img->width(); ++x, dstPixel++, ++srcPixel)\n                {\n                    (*dstPixel).x = (unsigned short)(TwkMath::clamp(\n                        (*srcPixel).x * 65535.0f, 0.0f, 65535.0f));\n                    (*dstPixel).y = (unsigned short)(TwkMath::clamp(\n                        (*srcPixel).y * 65535.0f, 0.0f, 65535.0f));\n                    (*dstPixel).z = (unsigned short)(TwkMath::clamp(\n                        (*srcPixel).z * 65535.0f, 0.0f, 65535.0f));\n                    (*dstPixel).w = (unsigned short)(TwkMath::clamp(\n                        (*srcPixel).w * 65535.0f, 0.0f, 65535.0f));\n                }\n                if (TIFFWriteScanline(tif, buf, y, 0) == -1)\n                {\n                    IffExc exc(\"Error while writing TIFF scanline\");\n                    throw(exc);\n                }\n            }\n            break;\n        case 32:\n            for (int y = 0; y < img->height(); ++y)\n            {\n                Col4f* srcPixel = (Col4f*)(*img)[img->height() - y - 1];\n                if (TIFFWriteScanline(tif, srcPixel, y, 0) == -1)\n                {\n                    IffExc exc(\"Error while writing TIFF scanline\");\n                    throw(exc);\n                }\n            }\n            break;\n        }\n\n        _TIFFfree(buf);\n\n        TIFFClose(tif);\n\n        return true;\n    }",
    "static bool TiffIff_write_uc(const Img4uc* img, const char* fileName,\n                                 const Mat44f* Mcamera, const Mat44f* Mscreen)\n    {\n        TIFF* tif = TIFFOpen(fileName, \"w\");\n        if (tif == NULL)\n        {\n            IffExc exc(\"Could not open specified image file for writing\");\n            throw(exc);\n        }\n\n        TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, img->width());\n        TIFFSetField(tif, TIFFTAG_IMAGELENGTH, img->height());\n        TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 4);\n        TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8);\n        TIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n        TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n        TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n        TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_PACKBITS);\n        TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT);\n\n        if (Mcamera != NULL)\n        {\n            TIFFSetField(tif, TIFFTAG_CAMERA_MATRIX, (uint16)16,\n                         (const float*)Mcamera);\n        }\n        if (Mscreen != NULL)\n        {\n            TIFFSetField(tif, TIFFTAG_SCREEN_MATRIX, (uint16)16,\n                         (const float*)Mscreen);\n        }\n\n        char hostname[64];\n        gethostname(hostname, 64);\n        TIFFSetField(tif, TIFFTAG_HOSTCOMPUTER, hostname);\n\n        uint16 extrasamples = 1;\n        uint16 sampleinfo[1] = {EXTRASAMPLE_ASSOCALPHA};\n        TIFFSetField(tif, TIFFTAG_EXTRASAMPLES, extrasamples, sampleinfo);\n\n        tdata_t buf = _TIFFmalloc(TIFFScanlineSize(tif));\n\n        for (int y = 0; y < img->height(); ++y)\n        {\n            Col4uc* srcPixel = (Col4uc*)(*img)[img->height() - y - 1];\n            if (TIFFWriteScanline(tif, srcPixel, y, 0) == -1)\n            {\n                IffExc exc(\"Error while writing TIFF scanline\");\n                throw(exc);\n            }\n        }\n\n        _TIFFfree(buf);\n\n        TIFFClose(tif);\n\n        return true;\n    }",
    "static bool TiffIff_write_us(const Img4us* img, const char* fileName,\n                                 const Mat44f* Mcamera, const Mat44f* Mscreen)\n    {\n        TIFF* tif = TIFFOpen(fileName, \"w\");\n        if (tif == NULL)\n        {\n            IffExc exc(\"Could not open specified image file for writing\");\n            throw(exc);\n        }\n\n        TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, img->width());\n        TIFFSetField(tif, TIFFTAG_IMAGELENGTH, img->height());\n        TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 4);\n        TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 16);\n        TIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n        TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n        TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n        TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_PACKBITS);\n        TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT);\n\n        if (Mcamera != NULL)\n        {\n            TIFFSetField(tif, TIFFTAG_CAMERA_MATRIX, (uint16)16,\n                         (const float*)Mcamera);\n        }\n        if (Mscreen != NULL)\n        {\n            TIFFSetField(tif, TIFFTAG_SCREEN_MATRIX, (uint16)16,\n                         (const float*)Mscreen);\n        }\n\n        char hostname[64];\n        gethostname(hostname, 64);\n        TIFFSetField(tif, TIFFTAG_HOSTCOMPUTER, hostname);\n\n        uint16 extrasamples = 1;\n        uint16 sampleinfo[1] = {EXTRASAMPLE_ASSOCALPHA};\n        TIFFSetField(tif, TIFFTAG_EXTRASAMPLES, extrasamples, sampleinfo);\n\n        tdata_t buf = _TIFFmalloc(TIFFScanlineSize(tif));\n\n        for (int y = 0; y < img->height(); ++y)\n        {\n            Col4us* srcPixel = (Col4us*)(*img)[img->height() - y - 1];\n            if (TIFFWriteScanline(tif, srcPixel, y, 0) == -1)\n            {\n                IffExc exc(\"Error while writing TIFF scanline\");\n                throw(exc);\n            }\n        }\n\n        _TIFFfree(buf);\n\n        TIFFClose(tif);\n\n        return true;\n    }",
    "void PdfImage::loadFromTiff(const string_view& filename, unsigned imageIndex)\n{\n    TIFFSetErrorHandler(TIFFErrorWarningHandler);\n    TIFFSetWarningHandler(TIFFErrorWarningHandler);\n\n    if (filename.length() == 0)\n        PODOFO_RAISE_ERROR(PdfErrorCode::InvalidHandle);\n\n#ifdef _WIN32\n    auto filename16 = utf8::utf8to16((string)filename);\n    TIFF* hInfile = TIFFOpenW((wchar_t*)filename16.c_str(), \"rb\");\n#else\n    TIFF* hInfile = TIFFOpen(filename.data(), \"rb\");\n#endif\n\n    if (hInfile == nullptr)\n    {\n        PODOFO_RAISE_ERROR_INFO(PdfErrorCode::FileNotFound,\n            \"{} not found or error opening file\", filename);\n    }\n\n    try\n    {\n        loadFromTiffHandle(hInfile, imageIndex);\n    }\n    catch (...)\n    {\n        TIFFClose(hInfile);\n        throw;\n    }\n\n    TIFFClose(hInfile);\n}",
    "void PdfImage::loadFromTiffData(const unsigned char* data, size_t len, unsigned imageIndex)\n{\n    TIFFSetErrorHandler(TIFFErrorWarningHandler);\n    TIFFSetWarningHandler(TIFFErrorWarningHandler);\n\n    if (data == nullptr)\n        PODOFO_RAISE_ERROR(PdfErrorCode::InvalidHandle);\n\n    TiffData tiffData(data, (tsize_t)len);\n    TIFF* hInHandle = TIFFClientOpen(\"Memory\", \"r\", (thandle_t)&tiffData,\n        tiff_Read, tiff_Write, tiff_Seek, tiff_Close, tiff_Size,\n        tiff_Map, tiff_Unmap);\n    if (hInHandle == nullptr)\n        PODOFO_RAISE_ERROR(PdfErrorCode::InvalidHandle);\n\n    try\n    {\n        loadFromTiffHandle(hInHandle, imageIndex);\n    }\n    catch (...)\n    {\n        TIFFClose(hInHandle);\n        throw;\n    }\n\n    TIFFClose(hInHandle);\n}",
    "std::unique_ptr<VistaTexture> TextureLoader::loadFromFile(std::string const& sFileName) {\n\n  std::string suffix = sFileName.substr(sFileName.rfind('.'));\n\n  if (suffix == \".tga\") {\n    // load with vista\n    logger().debug(\"Loading Texture '{}' with Vista.\", sFileName);\n    return std::unique_ptr<VistaTexture>(VistaOGLUtils::LoadTextureFromTga(sFileName));\n  }\n\n  std::unique_ptr<VistaTexture> result = std::make_unique<VistaTexture>(GL_TEXTURE_2D);\n\n  if (suffix == \".tiff\" || suffix == \".tif\") {\n    // load with tifflib\n    logger().debug(\"Loading Texture '{}' with libtiff.\", sFileName);\n\n    auto* data = TIFFOpen(sFileName.c_str(), \"r\");\n    if (!data) {\n      logger().error(\"Failed to load '{}' with libtiff!\", sFileName);\n      return nullptr;\n    }\n\n    uint32 width{};\n    uint32 height{};\n    TIFFGetField(data, TIFFTAG_IMAGELENGTH, &height);\n    TIFFGetField(data, TIFFTAG_IMAGEWIDTH, &width);\n\n    uint16 bpp{};\n    TIFFGetField(data, TIFFTAG_BITSPERSAMPLE, &bpp);\n\n    int16 channels{};\n    TIFFGetField(data, TIFFTAG_SAMPLESPERPIXEL, &channels);\n\n    GLenum ePixelFormat = GL_RGBA;\n\n    if (channels == 1) {\n      ePixelFormat = GL_RED;\n    } else if (channels == 2) {\n      ePixelFormat = GL_RG;\n    } else if (channels == 3) {\n      ePixelFormat = GL_RGB;\n    }\n\n    if (bpp != 8 && bpp != 32) {\n      logger().error(\n          \"Failed to load '{}' with libtiff: Only 8 or 32 bit per sample are supported right now!\",\n          sFileName);\n      return nullptr;\n    }\n\n    if (bpp == 32) {\n\n      std::vector<float> pixels(width * height * channels);\n\n      for (unsigned y = 0; y < height; y++) {\n        TIFFReadScanline(data, &pixels[width * channels * y], y);\n      }\n\n      result->Bind();\n      glTexImage2D(\n          GL_TEXTURE_2D, 0, GL_RGB32F, width, height, 0, ePixelFormat, GL_FLOAT, pixels.data());\n      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n\n    } else {\n\n      std::vector<char> pixels(width * height * channels);\n\n      for (unsigned y = 0; y < height; y++) {\n        TIFFReadScanline(data, &pixels[width * channels * y], y);\n      }\n\n      result->UploadTexture(width, height, pixels.data(), true, ePixelFormat);\n    }\n\n    TIFFClose(data);\n\n  } else if (suffix == \".hdr\") {\n\n    // load with stb image\n    logger().debug(\"Loading HDR Texture '{}' with stbi.\", sFileName);\n\n    int width{};\n    int height{};\n    int bpp{};\n    int channels = 4;\n\n    float* pixels = stbi_loadf(sFileName.c_str(), &width, &height, &bpp, channels);\n\n    if (!pixels) {\n      logger().error(\"Failed to load '{}' with stbi!\", sFileName);\n      return nullptr;\n    }\n\n    result->Bind();\n    gluBuild2DMipmaps(GL_TEXTURE_2D, GL_RGBA32F, width, height, GL_RGBA, GL_FLOAT, pixels);\n\n    stbi_image_free(pixels);\n\n  } else {\n    // load with stb image\n    logger().debug(\"Loading Texture '{}' with stbi.\", sFileName);\n\n    int width{};\n    int height{};\n    int bpp{};\n    int channels = 4;\n\n    unsigned char* pixels = stbi_load(sFileName.c_str(), &width, &height, &bpp, channels);\n\n    if (!pixels) {\n      logger().error(\"Failed to load '{}' with stbi!\", sFileName);\n      return nullptr;\n    }\n\n    result->UploadTexture(width, height, pixels);\n\n    stbi_image_free(pixels);\n  }\n\n  return result;\n}",
    "void tiffWriteToVector(std::vector<std::byte>& out, std::vector<T>& in, uint32_t width,\n    uint32_t height, uint32_t samples, uint32_t bits) {\n\n  std::ostringstream oStream;\n  TIFF*              tiff = TIFFStreamOpen(\"MemTIFF\", &oStream);\n\n  TIFFSetField(tiff, TIFFTAG_IMAGEWIDTH, width);\n  TIFFSetField(tiff, TIFFTAG_IMAGELENGTH, height);\n  TIFFSetField(tiff, TIFFTAG_SAMPLESPERPIXEL, samples);\n  TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, bits);\n  TIFFSetField(tiff, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n  TIFFSetField(tiff, TIFFTAG_ROWSPERSTRIP, 16);\n  TIFFSetField(tiff, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n  TIFFSetField(tiff, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n  TIFFSetField(tiff, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);\n\n  if (samples == 3) {\n    TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n  } else {\n    TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n  }\n\n  for (uint32_t i(0); i < height; ++i) {\n    TIFFWriteScanline(tiff, &in.at((height - i - 1) * width * samples), i);\n  }\n\n  TIFFClose(tiff);\n\n  // Convert the stringstream to a std::vector<std::byte>.\n  std::string s = oStream.str();\n  out.reserve(s.size());\n\n  std::transform(s.begin(), s.end(), std::back_inserter(out),\n      [](char& c) { return static_cast<std::byte>(c); });\n}",
    "std::tuple<GLuint, glm::ivec2> read2DTexture(std::string const& path) {\n  auto* data = TIFFOpen(path.c_str(), \"r\");\n\n  if (!data) {\n    logger().error(\"Failed to open TIFF file '{}'\", path);\n    return {0u, {0, 0}};\n  }\n\n  uint32_t width{};\n  uint32_t height{};\n\n  TIFFGetField(data, TIFFTAG_IMAGELENGTH, &height);\n  TIFFGetField(data, TIFFTAG_IMAGEWIDTH, &width);\n\n  std::vector<float> pixels(width * height * 3);\n\n  for (unsigned y = 0; y < height; y++) {\n    TIFFReadScanline(data, &pixels[width * 3 * y], y);\n  }\n\n  TIFFClose(data);\n\n  GLuint texture;\n  glGenTextures(1, &texture);\n  glActiveTexture(GL_TEXTURE0);\n  glBindTexture(GL_TEXTURE_2D, texture);\n  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\n  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\n  glBindBuffer(GL_PIXEL_UNPACK_BUFFER, 0);\n  glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB32F, width, height, 0, GL_RGB, GL_FLOAT, pixels.data());\n\n  return {texture, {width, height}};\n}",
    "std::tuple<GLuint, glm::ivec3> read3DTexture(std::string const& path) {\n  auto* data = TIFFOpen(path.c_str(), \"r\");\n\n  if (!data) {\n    logger().error(\"Failed to open TIFF file '{}'\", path);\n    return {0u, {0, 0, 0}};\n  }\n\n  uint32_t width{};\n  uint32_t height{};\n  uint32_t depth{};\n\n  TIFFGetField(data, TIFFTAG_IMAGELENGTH, &height);\n  TIFFGetField(data, TIFFTAG_IMAGEWIDTH, &width);\n\n  do {\n    depth++;\n  } while (TIFFReadDirectory(data));\n\n  std::vector<float> pixels(width * height * depth * 3);\n\n  for (unsigned z = 0; z < depth; z++) {\n    TIFFSetDirectory(data, z);\n    for (unsigned y = 0; y < height; y++) {\n      TIFFReadScanline(data, &pixels[width * 3 * y + (3 * width * height * z)], y);\n    }\n  }\n\n  TIFFClose(data);\n\n  GLuint texture;\n  glGenTextures(1, &texture);\n  glActiveTexture(GL_TEXTURE0);\n  glBindTexture(GL_TEXTURE_3D, texture);\n  glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n  glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n  glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\n  glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\n  glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);\n  glBindBuffer(GL_PIXEL_UNPACK_BUFFER, 0);\n  glTexImage3D(\n      GL_TEXTURE_3D, 0, GL_RGB32F, width, height, depth, 0, GL_RGB, GL_FLOAT, pixels.data());\n\n  return {texture, {width, height, depth}};\n}",
    "uint32_t getNumLayers(std::string const& path) {\n  auto* data = TIFFOpen(path.c_str(), \"r\");\n\n  if (!data) {\n    std::cerr << \"Failed to open TIFF file'\" << path << \"' \" << std::endl;\n    return 0;\n  }\n\n  uint32_t numLayers = 0;\n\n  do {\n    numLayers++;\n  } while (TIFFReadDirectory(data));\n\n  TIFFClose(data);\n\n  return numLayers;\n}",
    "RGBATexture read2DTexture(std::string const& path, uint32_t layer) {\n  RGBATexture texture;\n\n  auto* data = TIFFOpen(path.c_str(), \"r\");\n\n  if (!data) {\n    std::cerr << \"Failed to open TIFF file '\" << path << \"'\" << std::endl;\n    return texture;\n  }\n\n  TIFFGetField(data, TIFFTAG_IMAGELENGTH, &texture.height);\n  TIFFGetField(data, TIFFTAG_IMAGEWIDTH, &texture.width);\n\n  std::vector<float> rgbData(texture.width * texture.height * 3);\n\n  TIFFSetDirectory(data, layer);\n  for (unsigned y = 0; y < texture.height; y++) {\n    TIFFReadScanline(data, &rgbData[texture.width * 3 * y], y);\n  }\n\n  TIFFClose(data);\n\n  texture.data = addAlphaChannel(rgbData);\n\n  return texture;\n}",
    "void write2D(std::string const& path, float* texture, int width, int height, int components) {\n  auto* tiff = TIFFOpen(path.c_str(), \"w\");\n  TIFFSetField(tiff, TIFFTAG_IMAGEWIDTH, width);\n  TIFFSetField(tiff, TIFFTAG_IMAGELENGTH, height);\n  TIFFSetField(tiff, TIFFTAG_SAMPLESPERPIXEL, components);\n  TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 32);\n  TIFFSetField(tiff, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);\n  TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n  TIFFSetField(tiff, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n  TIFFSetField(tiff, TIFFTAG_ROWSPERSTRIP, 1);\n  for (int y = 0; y < height; ++y) {\n    TIFFWriteScanline(tiff, texture + y * width * components, height - y - 1);\n  }\n  TIFFClose(tiff);\n}",
    "void write3D(\n    std::string const& path, float* texture, int width, int height, int depth, int components) {\n  auto* tiff = TIFFOpen(path.c_str(), \"w\");\n\n  for (int z = 0; z < depth; ++z) {\n    TIFFSetField(tiff, TIFFTAG_PAGENUMBER, z, z);\n    TIFFSetField(tiff, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE);\n    TIFFSetField(tiff, TIFFTAG_IMAGEWIDTH, width);\n    TIFFSetField(tiff, TIFFTAG_IMAGELENGTH, height);\n    TIFFSetField(tiff, TIFFTAG_SAMPLESPERPIXEL, components);\n    TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 32);\n    TIFFSetField(tiff, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);\n    TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n    TIFFSetField(tiff, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    TIFFSetField(tiff, TIFFTAG_ROWSPERSTRIP, 1);\n    for (int y = 0; y < height; ++y) {\n      TIFFWriteScanline(\n          tiff, texture + z * width * height * components + y * width * components, height - y - 1);\n    }\n    TIFFWriteDirectory(tiff);\n  }\n  TIFFClose(tiff);\n}",
    "bool loadImpl(TileSourceWebMapService* source, BaseTileData* tile, TileId const& tileId, int x,\n    int y, CopyPixels which) {\n  std::optional<std::string> cacheFile;\n\n  // First we download the tile data to a local cache file. This will return quickly if the file is\n  // already downloaded but will take some time if it needs to be fetched from the server.\n  try {\n    cacheFile = source->loadData(tileId, x, y);\n  } catch (std::exception const& e) {\n    // This is not critical, the planet will just not refine any further.\n    logger().debug(\"Tile loading failed: {}\", e.what());\n    return false;\n  }\n\n  // Data is not available. That's most likely due to our server being offline.\n  if (!cacheFile) {\n    return false;\n  }\n\n  T* tileData = tile->getTypedPtr<T>();\n\n  // Now the cache file is available, try to load it with libtiff if it's elevation data.\n  if (tile->getDataType() == TileDataType::eElevation) {\n    TIFFSetWarningHandler(nullptr);\n    auto* data = TIFFOpen(cacheFile->c_str(), \"r\");\n    if (!data) {\n\n      // This is also not critical. Something went wrong - we will just remove the cache file and\n      // will try to download it later again if it's requested once more.\n      logger().debug(\"Tile loading failed: Removing invalid cache file '{}'.\", *cacheFile);\n      boost::filesystem::remove(*cacheFile);\n      return false;\n    }\n\n    uint32_t resolution = tile->getResolution();\n\n    // The elevation data can be read. For some patches (those at the international date boundary)\n    // two requests are made. For those, only half of the pixels contain valid data (above or below\n    // the diagonal).\n    int imagelength{};\n    if (TIFFGetField(data, TIFFTAG_IMAGELENGTH, &imagelength) == 0) {\n      logger().debug(\"TIFFGetField failed: Removing invalid cache file '{}'.\", *cacheFile);\n      boost::filesystem::remove(*cacheFile);\n      return false;\n    }\n    int tiffReturn{};\n    for (int y = 0; y < imagelength; y++) {\n      if (which == CopyPixels::eAll) {\n        tiffReturn = TIFFReadScanline(data, &tileData[resolution * y], y);\n      } else if (which == CopyPixels::eAboveDiagonal) {\n        std::vector<float> tmp(resolution);\n        tiffReturn = TIFFReadScanline(data, tmp.data(), y);\n        int offset = resolution * y;\n        int count  = resolution - y - 1;\n\n        // NOLINTNEXTLINE(cppcoreguidelines-pro-bounds-pointer-arithmetic)\n        std::memcpy(tileData + offset, tmp.data(), count * sizeof(float));\n      } else if (which == CopyPixels::eBelowDiagonal) {\n        std::vector<float> tmp(resolution);\n        tiffReturn = TIFFReadScanline(data, tmp.data(), y);\n        int offset = resolution * y + (resolution - y);\n        int count  = y;\n\n        // NOLINTNEXTLINE(cppcoreguidelines-pro-bounds-pointer-arithmetic)\n        std::memcpy(tileData + offset, tmp.data() + resolution - y, count * sizeof(float));\n      }\n    }\n    if (tiffReturn == -1) {\n      logger().debug(\"TIFFReadScanline failed: Removing invalid cache file '{}'.\", *cacheFile);\n      boost::filesystem::remove(*cacheFile);\n      return false;\n    }\n\n    TIFFClose(data);\n  } else {\n\n    // Image tiles are loaded with stbi.\n    int width{};\n    int height{};\n    int bpp{};\n    int channels = 4;\n\n    auto* data =\n        reinterpret_cast<T*>(stbi_load(cacheFile->c_str(), &width, &height, &bpp, channels));\n\n    if (!data) {\n\n      // This is also not critical. Something went wrong - we will just remove the cache file and\n      // will try to download it later again if it's requested once more.\n      logger().debug(\"Tile loading failed: Removing invalid cache file '{}'.\", *cacheFile);\n      boost::filesystem::remove(*cacheFile);\n      return false;\n    }\n\n    // The image data can be read. For some patches (those at the international date boundary)\n    // two requests are made. For those, only half of the pixels contain valid data (above or below\n    // the diagonal).\n    if (which == CopyPixels::eAll) {\n      std::memcpy(tileData, data, channels * width * height);\n    } else if (which == CopyPixels::eAboveDiagonal) {\n      for (int y = 0; y < height; ++y) {\n        int offset = width * y;\n        int count  = channels * (width - y - 1);\n\n        // NOLINTNEXTLINE(cppcoreguidelines-pro-bounds-pointer-arithmetic)\n        std::memcpy(tileData + offset, data + offset, count);\n      }\n    } else if (which == CopyPixels::eBelowDiagonal) {\n      for (int y = 0; y < height; ++y) {\n        int offset = width * y + (width - y);\n        int count  = channels * y;\n\n        // NOLINTNEXTLINE(cppcoreguidelines-pro-bounds-pointer-arithmetic)\n        std::memcpy(tileData + offset, data + offset, count);\n      }\n    }\n\n    stbi_image_free(data);\n  }\n\n  return true;\n}",
    "void Preprocessor::save(std::string const& directory) {\n  std::cout << \"Saving precomputed atmosphere to disk...\" << std::endl;\n\n  // For debugging purposes, we print the maximum ray deviation in degrees.\n  std::vector<float> pixels(\n      mParams.mTransmittanceTextureWidth.get() * mParams.mTransmittanceTextureHeight.get() * 3);\n  glBindTexture(GL_TEXTURE_2D, mThetaDeviationTexture);\n  glGetTexImage(GL_TEXTURE_2D, 0, GL_RGB, GL_FLOAT, pixels.data());\n  glBindTexture(GL_TEXTURE_2D, 0);\n\n  float maxThetaDeviation = 0.F;\n  for (int x = 0; x < mParams.mTransmittanceTextureWidth.get(); ++x) {\n    for (int y = 0; y < mParams.mTransmittanceTextureHeight.get(); ++y) {\n      int i = 3 * (y * mParams.mTransmittanceTextureWidth.get() + x);\n\n      float thetaDeviation = pixels[i];\n      float contactRadius  = pixels[i + 1];\n\n      if (contactRadius > 0.F) {\n        maxThetaDeviation = std::max(maxThetaDeviation, thetaDeviation);\n      }\n    }\n  }\n\n  std::cout << \"Maximum ray deviation: \" << maxThetaDeviation * 180.F / glm::pi<float>()\n            << \" degrees.\" << std::endl;\n\n  auto write2D = [](std::string const& path, GLuint texture, int width, int height) {\n    std::vector<float> data(width * height * 3);\n    glBindTexture(GL_TEXTURE_2D, texture);\n    glGetTexImage(GL_TEXTURE_2D, 0, GL_RGB, GL_FLOAT, data.data());\n    glBindTexture(GL_TEXTURE_2D, 0);\n\n    auto* tiff = TIFFOpen(path.c_str(), \"w\");\n    TIFFSetField(tiff, TIFFTAG_IMAGEWIDTH, width);\n    TIFFSetField(tiff, TIFFTAG_IMAGELENGTH, height);\n    TIFFSetField(tiff, TIFFTAG_SAMPLESPERPIXEL, 3);\n    TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 32);\n    TIFFSetField(tiff, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);\n    TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n    TIFFSetField(tiff, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    TIFFSetField(tiff, TIFFTAG_ROWSPERSTRIP, 1);\n    for (int y = 0; y < height; ++y) {\n      TIFFWriteScanline(tiff, data.data() + y * width * 3, y);\n    }\n    TIFFClose(tiff);\n  };\n\n  auto write3D = [](std::string const& path, GLuint texture, int width, int height, int depth) {\n    std::vector<float> data(width * height * depth * 3);\n    glBindTexture(GL_TEXTURE_3D, texture);\n    glGetTexImage(GL_TEXTURE_3D, 0, GL_RGB, GL_FLOAT, data.data());\n    glBindTexture(GL_TEXTURE_3D, 0);\n\n    auto* tiff = TIFFOpen(path.c_str(), \"w\");\n\n    for (int z = 0; z < depth; ++z) {\n      TIFFSetField(tiff, TIFFTAG_PAGENUMBER, z, z);\n      TIFFSetField(tiff, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE);\n      TIFFSetField(tiff, TIFFTAG_IMAGEWIDTH, width);\n      TIFFSetField(tiff, TIFFTAG_IMAGELENGTH, height);\n      TIFFSetField(tiff, TIFFTAG_SAMPLESPERPIXEL, 3);\n      TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 32);\n      TIFFSetField(tiff, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);\n      TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n      TIFFSetField(tiff, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n      TIFFSetField(tiff, TIFFTAG_ROWSPERSTRIP, 1);\n      for (int y = 0; y < height; ++y) {\n        TIFFWriteScanline(tiff, data.data() + z * width * height * 3 + y * width * 3, y);\n      }\n      TIFFWriteDirectory(tiff);\n    }\n    TIFFClose(tiff);\n  };\n\n  int numAngles = static_cast<int>(mParams.mMolecules.mPhase.size());\n  write2D(directory + \"/phase.tif\", mPhaseTexture, numAngles, 2);\n  write2D(directory + \"/transmittance.tif\", mTransmittanceTexture,\n      mParams.mTransmittanceTextureWidth.get(), mParams.mTransmittanceTextureHeight.get());\n  write2D(directory + \"/indirect_illuminance.tif\", mIrradianceTexture,\n      mParams.mIrradianceTextureWidth.get(), mParams.mIrradianceTextureHeight.get());\n  write3D(directory + \"/multiple_scattering.tif\", mMultipleScatteringTexture,\n      mScatteringTextureWidth, mScatteringTextureHeight, mScatteringTextureDepth);\n  write3D(directory + \"/single_aerosols_scattering.tif\", mSingleAerosolsScatteringTexture,\n      mScatteringTextureWidth, mScatteringTextureHeight, mScatteringTextureDepth);\n\n  if (mParams.mRefraction.get()) {\n    write2D(directory + \"/theta_deviation.tif\", mThetaDeviationTexture,\n        mParams.mTransmittanceTextureWidth.get(), mParams.mTransmittanceTextureHeight.get());\n  }\n\n  std::ofstream  out(directory + \"/metadata.json\");\n  nlohmann::json data = mMetadata;\n  out << std::setw(2) << data;\n\n  std::cout << \"Precomputed atmosphere saved to disk.\" << std::endl;\n}",
    "bool wxTIFFHandler::LoadFile( wxImage *image, wxInputStream& stream, bool verbose, int index )\r\n{\r\n    if (index == -1)\r\n        index = 0;\r\n\r\n    image->Destroy();\r\n\r\n    TIFF *tif = TIFFwxOpen( stream, \"image\", \"r\" );\r\n\r\n    if (!tif)\r\n    {\r\n        if (verbose)\r\n        {\r\n            wxLogError( _(\"TIFF: Error loading image.\") );\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    if (!TIFFSetDirectory( tif, (tdir_t)index ))\r\n    {\r\n        if (verbose)\r\n        {\r\n            wxLogError( _(\"Invalid TIFF image index.\") );\r\n        }\r\n\r\n        TIFFClose( tif );\r\n\r\n        return false;\r\n    }\r\n\r\n    uint32 w, h;\r\n    uint32 *raster;\r\n\r\n    TIFFGetField( tif, TIFFTAG_IMAGEWIDTH, &w );\r\n    TIFFGetField( tif, TIFFTAG_IMAGELENGTH, &h );\r\n\r\n    uint16 extraSamples;\r\n    uint16* samplesInfo;\r\n    TIFFGetFieldDefaulted(tif, TIFFTAG_EXTRASAMPLES,\r\n                          &extraSamples, &samplesInfo);\r\n    const bool hasAlpha = (extraSamples == 1 &&\r\n                           (samplesInfo[0] == EXTRASAMPLE_ASSOCALPHA ||\r\n                            samplesInfo[0] == EXTRASAMPLE_UNASSALPHA));\r\n\r\n    // guard against integer overflow during multiplication which could result\r\n    // in allocating a too small buffer and then overflowing it\r\n    const double bytesNeeded = (double)w * (double)h * sizeof(uint32);\r\n    if ( bytesNeeded >= wxUINT32_MAX )\r\n    {\r\n        if ( verbose )\r\n        {\r\n            wxLogError( _(\"TIFF: Image size is abnormally big.\") );\r\n        }\r\n\r\n        TIFFClose(tif);\r\n\r\n        return false;\r\n    }\r\n\r\n    raster = (uint32*) _TIFFmalloc( (uint32)bytesNeeded );\r\n\r\n    if (!raster)\r\n    {\r\n        if (verbose)\r\n        {\r\n            wxLogError( _(\"TIFF: Couldn't allocate memory.\") );\r\n        }\r\n\r\n        TIFFClose( tif );\r\n\r\n        return false;\r\n    }\r\n\r\n    image->Create( (int)w, (int)h );\r\n    if (!image->Ok())\r\n    {\r\n        if (verbose)\r\n        {\r\n            wxLogError( _(\"TIFF: Couldn't allocate memory.\") );\r\n        }\r\n\r\n        _TIFFfree( raster );\r\n        TIFFClose( tif );\r\n\r\n        return false;\r\n    }\r\n\r\n    if ( hasAlpha )\r\n        image->SetAlpha();\r\n\r\n    if (!TIFFReadRGBAImage( tif, w, h, raster, 0 ))\r\n    {\r\n        if (verbose)\r\n        {\r\n            wxLogError( _(\"TIFF: Error reading image.\") );\r\n        }\r\n\r\n        _TIFFfree( raster );\r\n        image->Destroy();\r\n        TIFFClose( tif );\r\n\r\n        return false;\r\n    }\r\n\r\n    unsigned char *ptr = image->GetData();\r\n    ptr += w*3*(h-1);\r\n\r\n    unsigned char *alpha = hasAlpha ? image->GetAlpha() : NULL;\r\n    if ( hasAlpha )\r\n        alpha += w*(h-1);\r\n\r\n    uint32 pos = 0;\r\n\r\n    for (uint32 i = 0; i < h; i++)\r\n    {\r\n        for (uint32 j = 0; j < w; j++)\r\n        {\r\n            *(ptr++) = (unsigned char)TIFFGetR(raster[pos]);\r\n            *(ptr++) = (unsigned char)TIFFGetG(raster[pos]);\r\n            *(ptr++) = (unsigned char)TIFFGetB(raster[pos]);\r\n            if ( hasAlpha )\r\n                *(alpha++) = (unsigned char)TIFFGetA(raster[pos]);\r\n\r\n            pos++;\r\n        }\r\n\r\n        // subtract line we just added plus one line:\r\n        ptr -= 2*w*3;\r\n        if ( hasAlpha )\r\n            alpha -= 2*w;\r\n    }\r\n\r\n    // set the image resolution if it's available\r\n    uint16 tiffRes;\r\n    if ( TIFFGetField(tif, TIFFTAG_RESOLUTIONUNIT, &tiffRes) )\r\n    {\r\n        wxImageResolution res;\r\n        switch ( tiffRes )\r\n        {\r\n            default:\r\n                wxLogWarning(_(\"Unknown TIFF resolution unit %d ignored\"),\r\n                             tiffRes);\r\n                // fall through\r\n\r\n            case RESUNIT_NONE:\r\n                res = wxIMAGE_RESOLUTION_NONE;\r\n                break;\r\n\r\n            case RESUNIT_INCH:\r\n                res = wxIMAGE_RESOLUTION_INCHES;\r\n                break;\r\n\r\n            case RESUNIT_CENTIMETER:\r\n                res = wxIMAGE_RESOLUTION_CM;\r\n                break;\r\n        }\r\n\r\n        if ( res != wxIMAGE_RESOLUTION_NONE )\r\n        {\r\n            float xres, yres;\r\n            if ( TIFFGetField(tif, TIFFTAG_XRESOLUTION, &xres) )\r\n                image->SetOption(wxIMAGE_OPTION_RESOLUTIONX, wxRound(xres));\r\n\r\n            if ( TIFFGetField(tif, TIFFTAG_YRESOLUTION, &yres) )\r\n                image->SetOption(wxIMAGE_OPTION_RESOLUTIONY, wxRound(yres));\r\n        }\r\n    }\r\n\r\n\r\n    _TIFFfree( raster );\r\n\r\n    TIFFClose( tif );\r\n\r\n    return true;\r\n}",
    "bool wxTIFFHandler::SaveFile( wxImage *image, wxOutputStream& stream, bool verbose )\r\n{\r\n    TIFF *tif = TIFFwxOpen( stream, \"image\", \"w\" );\r\n\r\n    if (!tif)\r\n    {\r\n        if (verbose)\r\n        {\r\n            wxLogError( _(\"TIFF: Error saving image.\") );\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    TIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\r\n    TIFFSetField(tif, TIFFTAG_IMAGEWIDTH,  (uint32)image->GetWidth());\r\n    TIFFSetField(tif, TIFFTAG_IMAGELENGTH, (uint32)image->GetHeight());\r\n    TIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\r\n    TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\r\n\r\n    // save the image resolution if we have it\r\n    int xres, yres;\r\n    const wxImageResolution res = GetResolutionFromOptions(*image, &xres, &yres);\r\n    uint16 tiffRes;\r\n    switch ( res )\r\n    {\r\n        default:\r\n            wxFAIL_MSG( wxT(\"unknown image resolution units\") );\r\n            // fall through\r\n\r\n        case wxIMAGE_RESOLUTION_NONE:\r\n            tiffRes = RESUNIT_NONE;\r\n            break;\r\n\r\n        case wxIMAGE_RESOLUTION_INCHES:\r\n            tiffRes = RESUNIT_INCH;\r\n            break;\r\n\r\n        case wxIMAGE_RESOLUTION_CM:\r\n            tiffRes = RESUNIT_CENTIMETER;\r\n            break;\r\n    }\r\n\r\n    if ( tiffRes != RESUNIT_NONE )\r\n    {\r\n        TIFFSetField(tif, TIFFTAG_RESOLUTIONUNIT, tiffRes);\r\n        TIFFSetField(tif, TIFFTAG_XRESOLUTION, (float)xres);\r\n        TIFFSetField(tif, TIFFTAG_YRESOLUTION, (float)yres);\r\n    }\r\n\r\n\r\n    int spp = image->GetOptionInt(wxIMAGE_OPTION_SAMPLESPERPIXEL);\r\n    if ( !spp )\r\n        spp = 3;\r\n\r\n    int bpp = image->GetOptionInt(wxIMAGE_OPTION_BITSPERSAMPLE);\r\n    if ( !bpp )\r\n        bpp = 8;\r\n\r\n    int compression = image->GetOptionInt(wxIMAGE_OPTION_COMPRESSION);\r\n    if ( !compression )\r\n    {\r\n        // we can't use COMPRESSION_LZW because current version of libtiff\r\n        // doesn't implement it (\"no longer implemented due to Unisys patent\r\n        // enforcement\") and other compression methods are lossy so we\r\n        // shouldn't use them by default -- and the only remaining one is none\r\n        compression = COMPRESSION_NONE;\r\n    }\r\n\r\n    TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, spp);\r\n    TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, bpp);\r\n    TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, spp*bpp == 1 ? PHOTOMETRIC_MINISBLACK\r\n                                                        : PHOTOMETRIC_RGB);\r\n    TIFFSetField(tif, TIFFTAG_COMPRESSION, compression);\r\n\r\n    // scanlinesize if determined by spp and bpp\r\n    tsize_t linebytes = (tsize_t)image->GetWidth() * spp * bpp / 8;\r\n\r\n    if ( (image->GetWidth() % 8 > 0) && (spp * bpp < 8) )\r\n        linebytes+=1;\r\n\r\n    unsigned char *buf;\r\n\r\n    if (TIFFScanlineSize(tif) > linebytes || (spp * bpp < 24))\r\n    {\r\n        buf = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(tif));\r\n        if (!buf)\r\n        {\r\n            if (verbose)\r\n            {\r\n                wxLogError( _(\"TIFF: Couldn't allocate memory.\") );\r\n            }\r\n\r\n            TIFFClose( tif );\r\n\r\n            return false;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        buf = NULL;\r\n    }\r\n\r\n    TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP,TIFFDefaultStripSize(tif, (uint32) -1));\r\n\r\n    unsigned char *ptr = image->GetData();\r\n    for ( int row = 0; row < image->GetHeight(); row++ )\r\n    {\r\n        if ( buf )\r\n        {\r\n            if ( spp * bpp > 1 )\r\n            {\r\n                // color image\r\n                memcpy(buf, ptr, image->GetWidth());\r\n            }\r\n            else // black and white image\r\n            {\r\n                for ( int column = 0; column < linebytes; column++ )\r\n                {\r\n                    uint8 reverse = 0;\r\n                    for ( int bp = 0; bp < 8; bp++ )\r\n                    {\r\n                        if ( ptr[column*24 + bp*3] > 0 )\r\n                        {\r\n                            // check only red as this is sufficient\r\n                            reverse = (uint8)(reverse | 128 >> bp);\r\n                        }\r\n                    }\r\n\r\n                    buf[column] = reverse;\r\n                }\r\n            }\r\n        }\r\n\r\n        if ( TIFFWriteScanline(tif, buf ? buf : ptr, (uint32)row, 0) < 0 )\r\n        {\r\n            if (verbose)\r\n            {\r\n                wxLogError( _(\"TIFF: Error writing image.\") );\r\n            }\r\n\r\n            TIFFClose( tif );\r\n            if (buf)\r\n                _TIFFfree(buf);\r\n\r\n            return false;\r\n        }\r\n\r\n        ptr += image->GetWidth()*3;\r\n    }\r\n\r\n    (void) TIFFClose(tif);\r\n\r\n    if (buf)\r\n        _TIFFfree(buf);\r\n\r\n    return true;\r\n}",
    "void\nTiffPlugin::setImageFiles(QStringList files)\n{\n  QProgressDialog progress(\"Enumerating files - may take some time...\",\n\t\t\t   0,\n\t\t\t   0, 100,\n\t\t\t   0);\n  progress.setMinimumDuration(0);\n\n  QStringList flist;\n  flist.clear();\n  \n  for(uint i=0; i<files.size(); i++)\n    {\n      progress.setValue(100*(float)i/(float)files.size());\n      qApp->processEvents();\n      \n      QFileInfo fileInfo(m_fileName[0], files[i]);\n      QString imgfl = fileInfo.absoluteFilePath();\n\n      m_imageList.append(imgfl);\n    }\n  \n  progress.setValue(100);\n  qApp->processEvents();\n\n  m_depth = m_imageList.size();\n\n  TIFF *image;\n  image = TIFFOpen((char*)m_imageList[0].toUtf8().data(), \"r\");\n  \n  // -- get number of images(directories) within the file\n  m_dirCount = 0;\n  if (image)\n    {\n      do {\n\tm_dirCount ++;\n      } while (TIFFReadDirectory(image));\n      if (m_dirCount > 1)\n\tQMessageBox::information(0, \"3D Tiff\",\n\t\t\t\t QString(\"Number of images : %1\").arg(m_dirCount));\n      if (m_dirCount > 1)\n\tm_depth = m_dirCount;\n    }\n\n  TIFFGetField(image, TIFFTAG_IMAGEWIDTH, &m_width);\n  TIFFGetField(image, TIFFTAG_IMAGELENGTH, &m_height);\n\n  uint16 bitPerSample;\n  TIFFGetField(image, TIFFTAG_BITSPERSAMPLE, &bitPerSample);\n\n  TIFFClose(image);\n\n  if (bitPerSample == 1)\n    {\n      QMessageBox::critical(0, \"Image Format Error\", \"Cannot handle this format : bits per voxel = 1\");\n      m_imageList.clear();\n      return;\n    }\n\n  if (bitPerSample == 8)\n    {\n      m_voxelType = _UChar;\n\n      QStringList vtypes;\n      vtypes << \"UChar\";\n      vtypes << \"Char\";\n      QString option = QInputDialog::getItem(0,\n\t\t\t\t\t     \"Select Voxel Type\",\n\t\t\t\t\t     \"Voxel Type (found 8 bits per voxel)\",\n\t\t\t\t\t     vtypes,\n\t\t\t\t\t     0,\n\t\t\t\t\t     false);\n      int idx = vtypes.indexOf(option);\n      if (idx == 1)\n\tm_voxelType = _Char;\n    }\n  else if (bitPerSample == 16)\n    {\n      m_voxelType = _UShort;\n\n      QStringList vtypes;\n      vtypes << \"UShort\";\n      vtypes << \"Short\";\n      QString option = QInputDialog::getItem(0,\n\t\t\t\t\t     \"Select Voxel Type\",\n\t\t\t\t\t     \"Voxel Type (found 16 bits per voxel)\",\n\t\t\t\t\t     vtypes,\n\t\t\t\t\t     0,\n\t\t\t\t\t     false);\n      int idx = vtypes.indexOf(option);\n      if (idx == 1)\n\tm_voxelType = _Short;\n    }\n  else if (bitPerSample == 32)\n    {\n      m_voxelType = _Float;\n\n      QStringList vtypes;\n      vtypes << \"Float\";\n      vtypes << \"Int\";\n      QString option = QInputDialog::getItem(0,\n\t\t\t\t\t     \"Select Voxel Type\",\n\t\t\t\t\t     \"Voxel Type (found 32 bits per voxel)\",\n\t\t\t\t\t     vtypes,\n\t\t\t\t\t     0,\n\t\t\t\t\t     false);\n      int idx = vtypes.indexOf(option);\n      if (idx == 1)\n\tm_voxelType = _Int;\n    }\n\n  m_headerBytes = 0;\n\n  m_bytesPerVoxel = 1;\n  if (m_voxelType == _UChar) m_bytesPerVoxel = 1;\n  else if (m_voxelType == _Char) m_bytesPerVoxel = 1;\n  else if (m_voxelType == _UShort) m_bytesPerVoxel = 2;\n  else if (m_voxelType == _Short) m_bytesPerVoxel = 2;\n  else if (m_voxelType == _Int) m_bytesPerVoxel = 4;\n  else if (m_voxelType == _Float) m_bytesPerVoxel = 4;\n\n  if (m_voxelType == _UChar ||\n      m_voxelType == _Char ||\n      m_voxelType == _UShort ||\n      m_voxelType == _Short)\n    findMinMaxandGenerateHistogram();\n  else\n    {\n      //QMessageBox::information(0, \"Error\",\n      //\t\t       \"Currently accepting only 1- and 2-byte images\");\n      findMinMax();\n      generateHistogram();\n    }\n}",
    "void\nTiffPlugin::loadTiffImage(int i, uchar* tmp)\n{\n  TIFF *image;\n  if (m_dirCount == 1)\n    image = TIFFOpen((char*)m_imageList[i].toUtf8().data(), \"r\");\n  else\n    {\n      image = TIFFOpen((char*)m_imageList[0].toUtf8().data(), \"r\");\n      TIFFSetDirectory(image, i);\n    }\n\n  uint16 photo, bps, spp, fillorder;\n  uint32 width;\n  tsize_t stripSize;\n  unsigned long imageOffset, result;\n  int stripMax, stripCount;\n  char *buffer, tempbyte;\n  unsigned long bufferSize, count;\n\n\n  // Read in the possibly multiple strips\n  stripSize = TIFFStripSize (image);\n  stripMax = TIFFNumberOfStrips (image);\n  imageOffset = 0;\n  \n  bufferSize = TIFFNumberOfStrips (image) * stripSize;\n  \n  for (stripCount = 0; stripCount < stripMax; stripCount++)\n    {\n      if((result = TIFFReadEncodedStrip (image, stripCount,\n\t\t\t\t\t tmp + imageOffset,\n\t\t\t\t\t stripSize)) == -1)\n\t{\n\t  QMessageBox::critical(0, \"TIFF Read Error\",\n\t\t\t\tQString(\"Read error on input strip number %1\").\\\n\t\t\t\targ(stripCount));\n\t  return;\n\t}\n\n      imageOffset += result;\n    }\n\n  TIFFClose(image);\n\n//  // Deal with fillorder\n//  TIFFGetField(image, TIFFTAG_FILLORDER, &fillorder);\n//  \n//  if(fillorder != FILLORDER_MSB2LSB)\n//    {\n//      // We need to swap bits -- ABCDEFGH becomes HGFEDCBA\n//      for(count = 0; count < bufferSize; count++)\n//\t{\n//\t  tempbyte = 0;\n//\t  if(tmp[count] & 128) tempbyte += 1;\n//\t  if(tmp[count] & 64) tempbyte += 2;\n//\t  if(tmp[count] & 32) tempbyte += 4;\n//\t  if(tmp[count] & 16) tempbyte += 8;\n//\t  if(tmp[count] & 8) tempbyte += 16;\n//\t  if(tmp[count] & 4) tempbyte += 32;\n//\t  if(tmp[count] & 2) tempbyte += 64;\n//\t  if(tmp[count] & 1) tempbyte += 128;\n//\t  tmp[count] = tempbyte;\n//\t}\n//    }\n  \n}",
    "bool loadImageLibTiff(const std::string& path, Image& img)\n{\n    TIFFSetWarningHandler(nullptr);\n    TIFFSetWarningHandlerExt(nullptr);\n\n    TIFF* tif = TIFFOpen(path.c_str(), \"r\");\n\n    if (!tif) return false;\n\n    uint32_t width, height;\n    uint16_t bitspersample = 0, sample_format = SAMPLEFORMAT_UINT, samples = 1;\n\n    // Get the image width and height\n    if (!TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width))\n    {\n        std::cerr << \"The file '\" << path << \"' has no 'TIFFTAG_IMAGEWIDTH'. The file is probably corrupted\\n\";\n        return false;\n    }\n    if (!TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height))\n    {\n        std::cerr << \"The file '\" << path << \"' has no 'TIFFTAG_IMAGELENGTH'. The file is probably corrupted\\n\";\n        return false;\n    }\n    if (!TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bitspersample))\n    {\n        std::cerr << \"The file '\" << path << \"' has no 'TIFFTAG_BITSPERSAMPLE'. The file is probably corrupted\\n\";\n        return false;\n    }\n\n    // These tags might actually be not present. In these cases the default values are used.\n    if (!TIFFGetField(tif, TIFFTAG_SAMPLEFORMAT, &sample_format))\n    {\n        sample_format = SAMPLEFORMAT_UINT;\n    }\n    if (!TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &samples))\n    {\n        samples = 1;\n    }\n\n\n    ImageType type = ImageType::UC1;\n    if (sample_format == SAMPLEFORMAT_IEEEFP)\n    {\n        type = ImageType::F1;\n    }\n    else if (sample_format == SAMPLEFORMAT_UINT)\n    {\n        type = (bitspersample == 8) ? ImageType::UC1 : (bitspersample == 16) ? ImageType::US1 : ImageType::UI1;\n    }\n    else if (sample_format == SAMPLEFORMAT_INT)\n    {\n        type = (bitspersample == 8) ? ImageType::C1 : (bitspersample == 16) ? ImageType::S1 : ImageType::I1;\n    }\n\n\n    if (samples != 1)\n    {\n        std::cout << \"Image '\" << path << \"' has more than one channel. Only loading first channel\\n\";\n        samples = 1;\n    }\n\n    type = (ImageType)((int)type + samples - 1);\n    img.create(height, width, type);\n\n    // size_t buffer_size = TIFFScanlineSize(tif);\n    // SAIGA_ASSERT(buffer_size == img.pitchBytes);\n\n    for (uint32_t row = 0; row < height; ++row)\n    {\n        TIFFReadScanline(tif, img.rowPtr(row), row);\n    }\n\n\n    TIFFClose(tif);\n\n    return true;\n}",
    "bool saveImageLibTiff(const std::string& path, const Image& img)\n{\n    TIFFSetWarningHandler(nullptr);\n    TIFFSetWarningHandlerExt(nullptr);\n\n    TIFF* tif = TIFFOpen(path.c_str(), \"w\");\n    if (!tif) return false;\n\n    uint32_t width  = img.width;\n    uint32_t height = img.height;\n\n    // Get the image width and height\n    if (!TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, width))\n    {\n        return false;\n    }\n    if (!TIFFSetField(tif, TIFFTAG_IMAGELENGTH, height))\n    {\n        return false;\n    }\n\n\n    uint16_t bitspersample = 0, sample_format = SAMPLEFORMAT_UINT;\n    uint16_t samples = 1;\n    switch (img.type)\n    {\n        case ImageType::UC1:\n            sample_format = SAMPLEFORMAT_UINT;\n            bitspersample = 8;\n            break;\n        case ImageType::US1:\n            sample_format = SAMPLEFORMAT_UINT;\n            bitspersample = 16;\n            break;\n        case ImageType::F1:\n            sample_format = SAMPLEFORMAT_IEEEFP;\n            bitspersample = 32;\n            break;\n        default:\n            return false;\n    }\n\n\n    if (!TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, bitspersample))\n    {\n        return false;\n    }\n\n    // These tags might actually be not present. In these cases the default values are used.\n    if (!TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, sample_format))\n    {\n        return false;\n    }\n    if (!TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, samples))\n    {\n        return false;\n    }\n\n\n    for (uint32_t row = 0; row < height; ++row)\n    {\n        TIFFWriteScanline(tif, const_cast<void*>(img.rowPtr(row)), row);\n    }\n\n    TIFFClose(tif);\n\n    return true;\n}",
    "bool loadImageFromMemoryLibTiff(const void* data, size_t size, Image& img)\n{\n    TIFFSetWarningHandler(nullptr);\n    TIFFSetWarningHandlerExt(nullptr);\n\n\n    imemstream strm((const char*)data, size);\n    // TIFF* tif = TIFFOpen(path.c_str(), \"r\");\n    TIFF* tif = TIFFStreamOpen(\"balbla\", &strm);\n\n    if (!tif) return false;\n\n    uint32_t width, height;\n    uint16_t bitspersample = 0, sample_format = SAMPLEFORMAT_UINT, samples = 1;\n\n    // Get the image width and height\n    if (!TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width))\n    {\n        return false;\n    }\n    if (!TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height))\n    {\n        return false;\n    }\n    if (!TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bitspersample))\n    {\n        return false;\n    }\n\n    // These tags might actually be not present. In these cases the default values are used.\n    if (!TIFFGetField(tif, TIFFTAG_SAMPLEFORMAT, &sample_format))\n    {\n        sample_format = SAMPLEFORMAT_UINT;\n    }\n    if (!TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &samples))\n    {\n        samples = 1;\n    }\n\n\n    ImageType type = ImageType::UC1;\n    if (sample_format == SAMPLEFORMAT_IEEEFP)\n    {\n        type = ImageType::F1;\n    }\n    else if (sample_format == SAMPLEFORMAT_UINT)\n    {\n        type = (bitspersample == 8) ? ImageType::UC1 : (bitspersample == 16) ? ImageType::US1 : ImageType::UI1;\n    }\n    else if (sample_format == SAMPLEFORMAT_INT)\n    {\n        type = (bitspersample == 8) ? ImageType::C1 : (bitspersample == 16) ? ImageType::S1 : ImageType::I1;\n    }\n\n\n    if (samples != 1)\n    {\n        samples = 1;\n    }\n\n    type = (ImageType)((int)type + samples - 1);\n    img.create(height, width, type);\n\n    // size_t buffer_size = TIFFScanlineSize(tif);\n    // SAIGA_ASSERT(buffer_size == img.pitchBytes);\n\n    for (uint32_t row = 0; row < height; ++row)\n    {\n        TIFFReadScanline(tif, img.rowPtr(row), row);\n    }\n\n\n    TIFFClose(tif);\n\n    return true;\n}",
    "void Image::LoadTiffFile(const void* pData, size_t Size, IDataBlob* pDstPixels, ImageDesc& Desc)\n{\n    TIFFClientOpenWrapper TiffClientOpenWrpr{pData, Size};\n\n    auto TiffFile = TIFFClientOpen(\"\", \"rm\", &TiffClientOpenWrpr,\n                                   TIFFClientOpenWrapper::TIFFReadProc,\n                                   TIFFClientOpenWrapper::TIFFWriteProc,\n                                   TIFFClientOpenWrapper::TIFFSeekProc,\n                                   TIFFClientOpenWrapper::TIFFCloseProc,\n                                   TIFFClientOpenWrapper::TIFFSizeProc,\n                                   TIFFClientOpenWrapper::TIFFMapFileProc,\n                                   TIFFClientOpenWrapper::TIFFUnmapFileProc);\n\n    TIFFGetField(TiffFile, TIFFTAG_IMAGEWIDTH, &Desc.Width);\n    TIFFGetField(TiffFile, TIFFTAG_IMAGELENGTH, &Desc.Height);\n\n    Uint16 SamplesPerPixel = 0;\n    // SamplesPerPixel is usually 1 for bilevel, grayscale, and palette-color images.\n    // SamplesPerPixel is usually 3 for RGB images. If this value is higher, ExtraSamples\n    // should give an indication of the meaning of the additional channels.\n    TIFFGetField(TiffFile, TIFFTAG_SAMPLESPERPIXEL, &SamplesPerPixel);\n    Desc.NumComponents = SamplesPerPixel;\n\n    Uint16 BitsPerSample = 0;\n    TIFFGetField(TiffFile, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n\n    Uint16 SampleFormat = 0;\n    TIFFGetField(TiffFile, TIFFTAG_SAMPLEFORMAT, &SampleFormat);\n    if (SampleFormat == 0)\n        SampleFormat = SAMPLEFORMAT_UINT;\n\n    switch (SampleFormat)\n    {\n        case SAMPLEFORMAT_UINT:\n            switch (BitsPerSample)\n            {\n                case 8: Desc.ComponentType = VT_UINT8; break;\n                case 16: Desc.ComponentType = VT_UINT16; break;\n                case 32: Desc.ComponentType = VT_UINT32; break;\n                default: LOG_ERROR_AND_THROW(BitsPerSample, \" is not a valid UINT component bit depth. Only 8, 16 and 32 are allowed\");\n            }\n            break;\n\n        case SAMPLEFORMAT_INT:\n            switch (BitsPerSample)\n            {\n                case 8: Desc.ComponentType = VT_INT8; break;\n                case 16: Desc.ComponentType = VT_INT16; break;\n                case 32: Desc.ComponentType = VT_INT32; break;\n                default: LOG_ERROR_AND_THROW(BitsPerSample, \" is not a valid INT component bit depth. Only 8, 16 and 32 are allowed\");\n            }\n            break;\n\n        case SAMPLEFORMAT_IEEEFP:\n            switch (BitsPerSample)\n            {\n                case 16: Desc.ComponentType = VT_FLOAT16; break;\n                case 32: Desc.ComponentType = VT_FLOAT32; break;\n                default: LOG_ERROR_AND_THROW(BitsPerSample, \" is not a valid FLOAT component bit depth. Only 16 and 32 are allowed\");\n            }\n            break;\n\n        case SAMPLEFORMAT_VOID:\n            LOG_ERROR_AND_THROW(\"Untyped tif images are not supported\");\n            break;\n\n        case SAMPLEFORMAT_COMPLEXINT:\n            LOG_ERROR_AND_THROW(\"Complex int tif images are not supported\");\n            break;\n\n        case SAMPLEFORMAT_COMPLEXIEEEFP:\n            LOG_ERROR_AND_THROW(\"Complex floating point tif images are not supported\");\n            break;\n\n        default:\n            LOG_ERROR_AND_THROW(\"Unknown sample format: \", Uint32{SampleFormat});\n    }\n\n    if (pDstPixels != nullptr)\n    {\n        size_t ScanlineSize = TIFFScanlineSize(TiffFile);\n        Desc.RowStride      = AlignUp(Desc.Width * Desc.NumComponents * (BitsPerSample / 8), 4u);\n        pDstPixels->Resize(size_t{Desc.Height} * size_t{Desc.RowStride});\n\n        Uint16 PlanarConfig = 0;\n        TIFFGetField(TiffFile, TIFFTAG_PLANARCONFIG, &PlanarConfig);\n        if (PlanarConfig == PLANARCONFIG_CONTIG || Desc.NumComponents == 1)\n        {\n            VERIFY_EXPR(Desc.RowStride >= ScanlineSize);\n            Uint8* pDataPtr = pDstPixels->GetDataPtr<Uint8>();\n            for (Uint32 row = 0; row < Desc.Height; row++, pDataPtr += Desc.RowStride)\n            {\n                TIFFReadScanline(TiffFile, pDataPtr, row);\n            }\n        }\n        else if (PlanarConfig == PLANARCONFIG_SEPARATE)\n        {\n            std::vector<Uint8> ScanlineData(ScanlineSize);\n            for (Uint32 row = 0; row < Desc.Height; ++row)\n            {\n                for (Uint16 comp = 0; comp < Desc.NumComponents; ++comp)\n                {\n                    Uint8* const pDstRow = pDstPixels->GetDataPtr<Uint8>() + Desc.RowStride * row + comp;\n\n                    TIFFReadScanline(TiffFile, ScanlineData.data(), row, comp);\n\n                    auto CopyComponet = [Width = Desc.Width, NumComp = Desc.NumComponents](const auto* pSrc, auto* pDst) {\n                        for (Uint32 x = 0; x < Width; ++x)\n                        {\n                            pDst[x * NumComp] = pSrc[x];\n                        }\n                    };\n\n                    switch (BitsPerSample)\n                    {\n                        case 8:\n                            CopyComponet(reinterpret_cast<const Uint8*>(ScanlineData.data()), reinterpret_cast<Uint8*>(pDstRow));\n                            break;\n\n                        case 16:\n                            CopyComponet(reinterpret_cast<const Uint16*>(ScanlineData.data()), reinterpret_cast<Uint16*>(pDstRow));\n                            break;\n\n                        case 32:\n                            CopyComponet(reinterpret_cast<const Uint32*>(ScanlineData.data()), reinterpret_cast<Uint32*>(pDstRow));\n                            break;\n\n                        default:\n                            UNEXPECTED(\"Unexpected component bit depth (\", BitsPerSample, \").\");\n                    }\n                }\n            }\n        }\n        else\n        {\n            UNEXPECTED(\"Unexpected planar configuration (\", PlanarConfig, \").\");\n        }\n    }\n\n    TIFFClose(TiffFile);\n}",
    "char *loadTiff3D2Metadata ( char * filename, unsigned int &sz0, unsigned int  &sz1, unsigned int  &sz2, unsigned int  &sz3, int &datatype, int &b_swap, void * &fhandle, int &header_len ) {\r\n\r\n    // 2015-01-30. Alessandro. @ADDED performance (time) measurement in all most time-consuming methods.\r\n    #ifdef _VAA3D_TERAFLY_PLUGIN_MODE\r\n    TERAFLY_TIME_START(TiffLoadMetadata)\r\n    #endif\r\n\r\n\tuint32 XSIZE;\r\n\tuint32 YSIZE;\r\n\tuint16 bpp;\r\n\tuint16 spp;\r\n\tuint16 Cpage;\r\n\tuint16 Npages;\r\n    TIFF *input;\r\n    int check;\r\n\r\n\tinput=TIFFOpen(filename,\"r\");\r\n\tif (!input)\r\n    {\r\n\t\t//throw iim::IOException(strprintf(\"in IOManager::readTiffMultipage(...): Cannot open the file %s\",finName).c_str());\r\n\t\treturn ((char *) \"Cannot open the file.\");\r\n    }\r\n\r\n\tcheck=TIFFGetField(input, TIFFTAG_IMAGEWIDTH, &XSIZE);\r\n\tif (!check)\r\n\t{\r\n\t\tTIFFClose(input);\r\n\t\t//throw iim::IOException(strprintf(\"in IOManager::readTiffMultipage(...): Image length of %s undefined\\n\", finName).c_str());\r\n\t\treturn ((char *) \"Image width of undefined.\");\r\n\t}\t\t\r\n    \r\n\tcheck=TIFFGetField(input, TIFFTAG_IMAGELENGTH, &YSIZE);\r\n\tif (!check)\r\n\t{\r\n\t\tTIFFClose(input);\r\n\t\t//throw iim::IOException(strprintf(\"in IOManager::readTiffMultipage(...): Image length of %s undefined\\n\", finName).c_str());\r\n\t\treturn ((char *) \"Image length of undefined.\");\r\n\t}\t\t\r\n    \r\n\tcheck=TIFFGetField(input, TIFFTAG_BITSPERSAMPLE, &bpp); \r\n\tif (!check)\r\n\t{\r\n\t\tTIFFClose(input);\r\n\t\t//throw iim::IOException(strprintf(\"in IOManager::readTiffMultipage(...): Undefined bits per sample in %s \\n\", finName).c_str());\r\n\t\treturn ((char *) \"Undefined bits per sample.\");\r\n\t}\r\n\r\n\tcheck=TIFFGetField(input, TIFFTAG_SAMPLESPERPIXEL, &spp);\r\n\tif (!check)\r\n\t{\r\n\t\tTIFFClose(input);\r\n\t\t//throw iim::IOException(strprintf(\"in IOManager::readTiffMultipage(...): Undefined bits per sample in %s \\n\", finName).c_str());\r\n\t\treturn ((char *) \"Undefined samples per pixel.\");\r\n\t}\r\n\r\n\t// Onofri\r\n\tcheck=TIFFGetField(input, TIFFTAG_PAGENUMBER, &Cpage, &Npages);\r\n\tif (!check || Npages==0) { // the tag has not been read correctly\r\n\t\t// Add warning?\r\n\t\tNpages = 0;\r\n\t\tdo {\r\n\t\t\tNpages++;\r\n\t\t} while ( TIFFReadDirectory(input) );\r\n\t}\r\n\r\n\tsz0 = XSIZE;\r\n\tsz1 = YSIZE;\r\n\tsz2 = Npages;\r\n\tsz3 = spp;\r\n\tdatatype = bpp/8;\r\n\r\n\t//b_swap = 0;\r\n\tb_swap=TIFFIsByteSwapped(input);\r\n\tfhandle = (void *) input;\r\n\theader_len = -1;\r\n\r\n\t// the file must non be closed (it is responsibility of the caller)\r\n\t//TIFFClose(input);\r\n\r\n    // 2015-01-30. Alessandro. @ADDED performance (time) measurement in all most time-consuming methods.\r\n    #ifdef _VAA3D_TERAFLY_PLUGIN_MODE\r\n    TERAFLY_TIME_STOP(TiffLoadMetadata, itm::IO, itm::strprintf(\"successfully loaded metadata from file \\\"%s\\\"\", filename))\r\n    #endif\r\n\r\n\treturn ((char *) 0);\r\n}",
    "char *initTiff3DFile ( char *filename, unsigned int sz0, unsigned int sz1, unsigned int sz2, unsigned int sz3, int datatype ) {\r\n//int initTiff3DFile ( char *filename, uint32 XSIZE, uint32 YSIZE, uint16 spp, uint16 Npages, int datatype){\r\n\r\n    // 2015-01-30. Alessandro. @ADDED performance (time) measurement in all most time-consuming methods.\r\n    #ifdef _VAA3D_TERAFLY_PLUGIN_MODE\r\n    TERAFLY_TIME_START(TiffInitData)\r\n    #endif\r\n\r\n\tuint32 XSIZE  = sz0;\r\n\tuint32 YSIZE  = sz1;\r\n\tuint16 Npages = sz2;\r\n\tuint16 spp    = sz3;\r\n\r\n\tuint16 bpp=8 * datatype;\r\n\tunsigned char *fakeData=new unsigned char[XSIZE * YSIZE];\r\n\t\r\n\tint check;\r\n\r\n\tif ( sz3 == 1 )\r\n\t\tspp = sz3; \r\n\telse if ( sz3 < 4 )\r\n\t\tspp = 3;\r\n\telse\r\n\t\treturn ((char *) \"More than 3 channels in Tiff files.\");\r\n\r\n\tchar *completeFilename = (char *) 0;\r\n\tint fname_len = (int) strlen(filename);\r\n\tchar *suffix = strstr(filename,\".tif\");\r\n\twhile ( suffix && (fname_len - (suffix-filename) > 5) )\r\n\t\tsuffix = strstr(suffix+4,\".tif\");\r\n\t//if ( (suffix != 0) && (fname_len - (suffix-filename) <= 5) ) { // a substring \".tif is already at the end of the filename\r\n\tif ( suffix ) { // a substring \".tif is already at the very end of the filename\r\n\t\tcompleteFilename = new char[fname_len+1];\r\n\t\tstrcpy(completeFilename,filename);\r\n\t}\r\n\telse {\t\r\n\t\tcompleteFilename = new char[fname_len+4+1];\r\n\t\tstrcpy(completeFilename,filename);\r\n\t\tstrcat(completeFilename,\".\");\r\n\t\tstrcat(completeFilename,TIFF3D_SUFFIX);\r\n\t}\r\n\r\n    // 2015-01-30. Alessandro. @ADDED performance (time) measurement in all most time-consuming methods.\r\n    #ifdef _VAA3D_TERAFLY_PLUGIN_MODE\r\n    TERAFLY_TIME_STOP(TiffInitData, itm::CPU, itm::strprintf(\"generated fake data for 3D tiff \\\"%s\\\"\", completeFilename))\r\n    TERAFLY_TIME_RESTART(TiffInitData)\r\n    #endif\r\n\r\n\tTIFF *output;\r\n\toutput = TIFFOpen(completeFilename,\"w\");\r\n\tif (!output) {\r\n\t\treturn ((char *) \"Cannot open the file.\");\r\n    }\r\n\r\n\tcheck = TIFFSetField(output, TIFFTAG_IMAGEWIDTH, XSIZE);\r\n\tif (!check) {\r\n\t\treturn ((char *) \"Cannot set the image width.\");\r\n    }\r\n\r\n\tcheck = TIFFSetField(output, TIFFTAG_IMAGELENGTH, YSIZE);\r\n\tif (!check) {\r\n\t\treturn ((char *) \"Cannot set the image width.\");\r\n    }\r\n\r\n\tcheck = TIFFSetField(output, TIFFTAG_BITSPERSAMPLE, bpp); \r\n\tif (!check) {\r\n\t\treturn ((char *) \"Cannot set the image width.\");\r\n    }\r\n\r\n\tcheck = TIFFSetField(output, TIFFTAG_SAMPLESPERPIXEL, spp);\r\n\tif (!check) {\r\n\t\treturn ((char *) \"Cannot set the image width.\");\r\n    }\r\n\r\n\tcheck = TIFFSetField(output, TIFFTAG_ROWSPERSTRIP, YSIZE); // one page per strip\r\n\tif (!check) {\r\n\t\treturn ((char *) \"Cannot set the image height.\");\r\n    }\r\n\r\n\tcheck = TIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_LZW);\r\n\tif (!check) {\r\n\t\treturn ((char *) \"Cannot set the compression tag.\");\r\n    }\r\n\r\n\tcheck = TIFFSetField(output, TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG);\r\n\tif (!check) {\r\n\t\treturn ((char *) \"Cannot set the planarconfig tag.\");\r\n    }\r\n\r\n\tif ( spp == 1 )\r\n\t\tcheck = TIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\t\r\n\telse // spp == 3\r\n\t\tcheck = TIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\t\r\n\tif (!check) {\r\n\t\treturn ((char *) \"Cannot set the photometric tag.\");\r\n    }\r\n\r\n\t/* We are writing single page of the multipage file */\r\n\tcheck = TIFFSetField(output, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE);\r\n\tif (!check) {\r\n\t\treturn ((char *) \"Cannot set the subfiletype tag.\");\r\n    }\r\n\r\n\tcheck = TIFFSetField(output, TIFFTAG_PAGENUMBER, 0, Npages); \r\n\tif (!check) {\r\n\t\treturn ((char *) \"Cannot set the page number.\");\r\n    }\r\n\r\n\r\n\tcheck = (int)TIFFWriteEncodedStrip(output, 0, fakeData, XSIZE * YSIZE);\r\n\tif (!check) {\r\n\t\treturn ((char *) \"Cannot write encoded strip to file.\");\r\n    }\r\n\r\n\tdelete[] fakeData;\r\n\tdelete []completeFilename;\r\n\r\n\tcheck = TIFFWriteDirectory(output);\r\n\tif (!check) {\r\n\t\treturn ((char *) \"Cannot write a new directory.\");\r\n    }\r\n\r\n\tTIFFClose(output);\r\n\r\n    // 2015-01-30. Alessandro. @ADDED performance (time) measurement in all most time-consuming methods.\r\n    #ifdef _VAA3D_TERAFLY_PLUGIN_MODE\r\n    TERAFLY_TIME_STOP(TiffInitData, itm::IO, itm::strprintf(\"written initialized 3D tiff \\\"%s\\\"\", completeFilename))\r\n    #endif\r\n\r\n\treturn (char *) 0;\r\n}",
    "char *appendSlice2Tiff3DFile ( char *filename, int slice, unsigned char *img, unsigned int img_width, unsigned int img_height ) {\r\n    // 2015-01-30. Alessandro. @ADDED performance (time) measurement in all most time-consuming methods.\r\n    #ifdef _VAA3D_TERAFLY_PLUGIN_MODE\r\n    TERAFLY_TIME_START(TiffAppendData)\r\n    #endif\r\n\r\n\tTIFF *output;\r\n\tuint16 spp, bpp, NPages, pg0;\r\n\r\n\toutput=TIFFOpen(filename,\"r\");\r\n\tTIFFGetField(output, TIFFTAG_BITSPERSAMPLE, &bpp); \r\n\tTIFFGetField(output, TIFFTAG_SAMPLESPERPIXEL, &spp);\r\n\tTIFFGetField(output, TIFFTAG_PAGENUMBER, &pg0, &NPages);\r\n\tTIFFClose(output);\r\n\t// since we are \r\n\toutput = (slice==0)? TIFFOpen(filename,\"w\") : TIFFOpen(filename,\"a\");\r\n\r\n\tTIFFSetDirectory(output,slice); // WARNING: slice must be the first page after the last, otherwise the file can be corrupted\r\n\r\n\tTIFFSetField(output, TIFFTAG_IMAGEWIDTH, img_width);\r\n\tTIFFSetField(output, TIFFTAG_IMAGELENGTH, img_height);\r\n\tTIFFSetField(output, TIFFTAG_BITSPERSAMPLE, bpp); \r\n\tTIFFSetField(output, TIFFTAG_SAMPLESPERPIXEL, spp);\r\n\tTIFFSetField(output, TIFFTAG_ROWSPERSTRIP, img_height);\r\n\tTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_LZW);\r\n\t//TIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\r\n\tTIFFSetField(output, TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG);\r\n\tTIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\t\r\n\t//TIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\t\r\n\t// We are writing single page of the multipage file \r\n\tTIFFSetField(output, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE);\r\n\tTIFFSetField(output, TIFFTAG_PAGENUMBER, (uint16)slice, NPages); \r\n\r\n\tTIFFWriteEncodedStrip(output, 0, img, img_width * img_height * spp * (bpp/8));\r\n\t//img +=  img_width * img_height;\r\n\r\n\tTIFFWriteDirectory(output);\r\n\r\n\tTIFFClose(output);\r\n\r\n    // 2015-01-30. Alessandro. @ADDED performance (time) measurement in all most time-consuming methods.\r\n    #ifdef _VAA3D_TERAFLY_PLUGIN_MODE\r\n    TERAFLY_TIME_STOP(TiffAppendData, itm::IO, itm::strprintf(\"appended slice %d x %d to 3D tiff \\\"%s\\\"\", img_width, img_height, filename))\r\n    #endif\r\n\r\n\treturn (char *) 0;\r\n}",
    "char *readTiff3DFile2Buffer ( char *filename, unsigned char *img, unsigned int img_width, unsigned int img_height, unsigned int first, unsigned int last ) {\r\n\r\n    // 2015-01-30. Alessandro. @ADDED performance (time) measurement in all most time-consuming methods.\r\n    #ifdef _VAA3D_TERAFLY_PLUGIN_MODE\r\n    TERAFLY_TIME_START(TiffLoadData)\r\n    #endif\r\n\r\n    TIFF *input;\r\n\r\n\tinput=TIFFOpen(filename,\"r\");\r\n\tif (!input)\r\n    {\r\n\t\t//throw iim::IOException(strprintf(\"in IOManager::readTiffMultipage(...): Cannot open the file %s\",finName).c_str());\r\n\t\treturn ((char *) \"Cannot open the file.\");\r\n    }\r\n    \r\n\tint b_swap=TIFFIsByteSwapped(input);\r\n\tchar *err_msg = readTiff3DFile2Buffer(input,img,img_width,img_height,first,last,b_swap);\r\n\r\n\tTIFFClose(input);\r\n\r\n    // 2015-01-30. Alessandro. @ADDED performance (time) measurement in all most time-consuming methods.\r\n    #ifdef _VAA3D_TERAFLY_PLUGIN_MODE\r\n    TERAFLY_TIME_STOP(TiffLoadData, itm::IO, itm::strprintf(\"loaded block x(%d), y(%d), z(%d-%d) from 3D tiff \\\"%s\\\"\", img_width, img_height, first, last, filename))\r\n    #endif\r\n\r\n\treturn err_msg;\r\n}",
    "void \r\n\tiomanager::tiff3D::readMetadata(\r\n\tstd::string img_path,\t\t// (INPUT)\timage filepath\r\n\tint & img_width,\t\t\t// (OUTPUT) image width  (in pixels)\r\n\tint & img_height,\t\t\t// (OUTPUT) image height (in pixels)\r\n\tint & img_depth,\t\t\t// (OUTPUT) image depth (in pixels)\r\n\tint & img_bytes_x_chan,\t// (OUTPUT) number of bytes per channel\r\n\tint & img_chans,\t\t\t// (OUTPUT) number of channels\r\n\tconst std::string & params)\t// (INPUT)\tadditional parameters <param1=val, param2=val, ...> \r\nthrow (iom::exception)\r\n{\r\n\t/**/iom::debug(iom::LEV3, iom::strprintf(\"img_path = %s, img_width = %d, img_height = %d, img_depth = %d, img_bytes_x_chan = %d, img_chans = %d, params = \\\"%s\\\"\",\r\n\t\timg_path.c_str(), img_width, img_height, img_depth,\timg_bytes_x_chan, img_chans, params.c_str()).c_str(), __iom__current__function__);\r\n\r\n\t// disable warning handler to avoid messages on unrecognized tags\r\n\tTIFFSetWarningHandler(0);\r\n\r\n\tTIFF* input=TIFFOpen(img_path.c_str(),\"r\");\r\n\tif (!input)\r\n\t\tthrow iom::exception(iom::strprintf(\"unable to open image \\\"%s\\\". Possible unsupported format or it isn't an image.\\nSupported format is 3DTIFF\", img_path.c_str()), __iom__current__function__);\r\n\r\n\tif (!TIFFGetField(input, TIFFTAG_IMAGEWIDTH, &img_width))\r\n\t\tthrow iom::exception(iom::strprintf(\"unable to determine 'TIFFTAG_IMAGEWIDTH' from image \\\"%s\\\". \", img_path.c_str()), __iom__current__function__);\r\n\r\n\tif (!TIFFGetField(input, TIFFTAG_IMAGELENGTH, &img_height))\r\n\t\tthrow iom::exception(iom::strprintf(\"unable to determine 'TIFFTAG_IMAGELENGTH' from image \\\"%s\\\". \", img_path.c_str()), __iom__current__function__);\r\n\r\n\tif (!TIFFGetField(input, TIFFTAG_BITSPERSAMPLE, &img_bytes_x_chan))\r\n\t\tthrow iom::exception(iom::strprintf(\"unable to determine 'TIFFTAG_BITSPERSAMPLE' from image \\\"%s\\\". \", img_path.c_str()), __iom__current__function__);\r\n\timg_bytes_x_chan /= 8;\r\n\r\n\tif (!TIFFGetField(input, TIFFTAG_SAMPLESPERPIXEL, &img_chans)) \r\n\t\tthrow iom::exception(iom::strprintf(\"unable to determine 'TIFFTAG_SAMPLESPERPIXEL' from image \\\"%s\\\". \", img_path.c_str()), __iom__current__function__);\r\n\r\n\t// Onofri\r\n\tuint16 cpage;  // Current page. We do not actually need it.\r\n\tuint16 npages; // Number of pages. \r\n\tint PNcheck=TIFFGetField(input, TIFFTAG_PAGENUMBER, &cpage, &npages);\r\n\tif (!PNcheck || npages==0) { // the tag has not been read correctly\r\n\t\tiom::warning(iom::strprintf(\"unable to determine 'TIFFTAG_PAGENUMBER' from image file \\\"%s\\\". \", img_path.c_str()).c_str(),__iom__current__function__);\r\n\t\timg_depth = 0;\r\n\t\tdo {\r\n\t\t\timg_depth++;\r\n\t\t} while (TIFFReadDirectory(input));\r\n\t}\r\n\telse\r\n\t\timg_depth = npages;\r\n\r\n\tTIFFClose(input);\r\n}",
    "void \r\n\tiomanager::tiff2D::readMetadata(\r\n\tstd::string img_path,\t\t\t// (INPUT)  image filepath\r\n\tint & img_width,\t\t\t\t// (OUTPUT) image width  (in pixels)\r\n\tint & img_height,\t\t\t\t// (OUTPUT) image height (in pixels)\r\n\tint & img_bytes_x_chan,\t\t\t// (OUTPUT) number of bytes per channel\r\n\tint & img_chans,\t\t\t\t// (OUTPUT) number of channels\r\n\tconst std::string & params)\t\t// (INPUT)  additional parameters <param1=val, param2=val, ...> \r\nthrow (iom::exception)\r\n{\r\n\t/**/iom::debug(iom::LEV3, iom::strprintf(\"img_path = \\\"%s\\\", params = \\\"%s\\\"\",img_path.c_str(), params.c_str()).c_str(), __iom__current__function__);\r\n\r\n\tuint16 bpp;\r\n\tuint16 spp;\r\n\r\n\t // disable warning handler to avoid messages on unrecognized tags\r\n\tTIFFSetWarningHandler(0);\r\n\r\n\tTIFF* input=TIFFOpen(img_path.c_str(),\"r\");\r\n\tif (!input)\r\n\t\tthrow iom::exception(iom::strprintf(\"unable to open image \\\"%s\\\". Possible unsupported format or it isn't an image.\\nSupported format is 2DTIFF\", img_path.c_str()), __iom__current__function__);\r\n\r\n\tif (!TIFFGetField(input, TIFFTAG_IMAGEWIDTH, &img_width))\r\n\t\tthrow iom::exception(iom::strprintf(\"unable to determine 'TIFFTAG_IMAGEWIDTH' from image \\\"%s\\\". \", img_path.c_str()), __iom__current__function__);\r\n\r\n\tif (!TIFFGetField(input, TIFFTAG_IMAGELENGTH, &img_height))\r\n\t\tthrow iom::exception(iom::strprintf(\"unable to determine 'TIFFTAG_IMAGELENGTH' from image \\\"%s\\\". \", img_path.c_str()), __iom__current__function__);\r\n\r\n\tif (!TIFFGetField(input, TIFFTAG_BITSPERSAMPLE, &bpp))\r\n\t\tthrow iom::exception(iom::strprintf(\"unable to determine 'TIFFTAG_BITSPERSAMPLE' from image \\\"%s\\\". \", img_path.c_str()), __iom__current__function__);\r\n\timg_bytes_x_chan = bpp/8;\r\n\r\n\tif (!TIFFGetField(input, TIFFTAG_SAMPLESPERPIXEL, &spp)) \r\n\t\tthrow iom::exception(iom::strprintf(\"unable to determine 'TIFFTAG_SAMPLESPERPIXEL' from image \\\"%s\\\". \", img_path.c_str()), __iom__current__function__);\r\n\timg_chans = spp;\r\n\r\n\t// Onofri\r\n\tint img_depth;\t\t\t// image depth (in pixels)\r\n\tuint16 cpage;  // Current page. We do not actually need it.\r\n\tuint16 npages; // Number of pages. \r\n\tint PNcheck=TIFFGetField(input, TIFFTAG_PAGENUMBER, &cpage, &npages);\r\n\tif (!PNcheck || npages==0) { // the tag has not been read correctly\r\n\t\tiom::warning(iom::strprintf(\"unable to determine 'TIFFTAG_PAGENUMBER' from image file \\\"%s\\\". \", img_path.c_str()).c_str(),__iom__current__function__);\r\n\t\timg_depth = 0;\r\n\t\tdo {\r\n\t\t\timg_depth++;\r\n\t\t} while (TIFFReadDirectory(input));\r\n\t}\r\n\telse\r\n\t\timg_depth = npages;\r\n\r\n\tTIFFClose(input);\r\n\t\r\n\t// check the exception after closing the file\r\n\tif ( img_depth > 1 ) \r\n\t\tthrow iom::exception(iom::strprintf(\"image \\\"%s\\\" has more than one page.\\nSupported format is 2DTIFF\", img_path.c_str()), __iom__current__function__);\r\n}",
    "unsigned char *readtiff(char *myfile, int *width, int *height, int *depth, int *channels )\n//================================================================================\n\n{\n    TIFF* tif = TIFFOpen(myfile, \"r\");\n    if (tif)\n    {\n\t\t*depth = 0;\n\t\tdo\n\t\t{\n\t\t\t(*depth)++;\n\t\t\tuint16 compression, cc, bpp         ;\n\t\t\t\n\t\t\t//check if we are reading a compressed image. If so\n\t\t\t//return with an error\n\t\t\tTIFFGetField(tif, TIFFTAG_COMPRESSION, &compression);\n\t\t\t\n\t\t\tif ( compression != COMPRESSION_NONE )\n\t\t\t{\n\t\t\t\tcerr<<\"File is not an Uncompressed TIFF image !\\n\";\n\t\t\t}\n\t\t\t\n\t\t\t//check if the image has 8 bits-per-pixel in each channel\n\t\t\tTIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bpp);\n\t\t\t\n\t\t\tif ( bpp != 8 )\n\t\t\t{\n\t\t\t\tcerr<<\"File does not have 8 bits per channel !\\n\";\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t//read the dimensions of the TIFF image\n\t\t\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH , width);//width\n\t\t\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, height);//height\n\t\t\t//determine what type of image is it (color or grayscale)\n\t\t\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &cc);\n\t\t\t\n\t\t\t//get the photometric if a grayscale image is\n\t\t\t//being read\n\t\t\tif (cc == 1)\n\t\t\t{\n\t\t\t\t*channels = 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t*channels = 3;\n\t\t\t}\n\t\t}while(TIFFReadDirectory(tif));\n\t\t\n\t\tTIFFClose(tif);\n\t}\n\telse\n    {\n        cerr<<\"Unable to open file for reading !\\n\";\n    }\n\t\n\t\n\ttif = TIFFOpen(myfile,\"r\");\n\tif(tif)\n\t{\n\t\tunsigned char *img = new unsigned char[(*channels)*(*width)*(*height)*(*depth)];\n\t\tint layer = 0;\n\t\tdo\n\t\t{\t\t\t\n\t\t\tuint16 p, compression, cc, bpp;\n\t\t\t\n\t\t\t//check if we are reading a compressed image. If so\n\t\t\t//return with an error\n\t\t\tTIFFGetField(tif, TIFFTAG_COMPRESSION, &compression);\n\t\t\t\n\t\t\tif ( compression != COMPRESSION_NONE )\n\t\t\t{\n\t\t\t\tcerr<<\"File is not an Uncompressed TIFF image !\\n\";\n\t\t\t}\n\t\t\t\n\t\t\t//check if the image has 8 bits-per-pixel in each channel\n\t\t\tTIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bpp);\n\t\t\t\n\t\t\tif ( bpp != 8 )\n\t\t\t{\n\t\t\t\tcerr<<\"File does not have 8 bits per channel !\\n\";\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t//read the dimensions of the TIFF image\n\t\t\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH , width);//width\n\t\t\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, height);//height\n\t\t\t//determine what type of image is it (color or grayscale)\n\t\t\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &cc);\n\t\t\t\n\t\t\t//get the photometric if a grayscale image is\n\t\t\t//being read\n\t\t\tif (cc == 1)\n\t\t\t{\n\t\t\t\t*channels = 1;\n\t\t\t\tTIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &p);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t*channels = 3;\n\t\t\t}\n\t\t\t\n\t\t\t//create the matrix to hold the image data\n\t\t\t\n\t\t\t//create a dummy array\n\t\t\tint linebytes = (*channels)*(*width);\n\t\t\tunsigned char *buf = new unsigned char[linebytes];\n\t\t\t\n\t\t\t//start reading the data from the TIFF file in scanlines\n\t\t\tfor ( int row = 0; row < *height; row++ )\n\t\t\t{\n\t\t\t\tif(TIFFReadScanline(tif, buf, row, 0) != 1)\n\t\t\t\t{\n\t\t\t\t\tcerr<<\"Error reading TIFF scanline !\\n\";\n\t\t\t\t}\n\t\t\t\tmemcpy(&img[layer*(*channels)*(*width)*(*height)+row*linebytes], buf, linebytes);\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tdelete(buf);\n\t\t\n\t\t\tlayer++;\n\t\t} while(TIFFReadDirectory(tif));\n\t\t\t\n        TIFFClose(tif);\n\t\t\n\t\treturn img;\n    }\n\t\n\treturn NULL;\n}",
    "void writetiff( char *myfile, unsigned char *img, int channels, int width, int height, int depth )\n//===================================================================================================\n{\n    TIFF* tif = TIFFOpen(myfile, \"w\");\n    if (tif)\n    {\n\t\tfor(int layerIndex = 0; layerIndex < depth ; layerIndex++)\n\t\t{\n\t\t\t//set tiff tags to generate an uncompressed TIFF image\n\t\t\t//SETTAGS( tif, width, height, channels );\n\t\t\t//dimensions of the image\n\t\t\tTIFFSetField(tif, TIFFTAG_IMAGEWIDTH,  width);\n\t\t\tTIFFSetField(tif, TIFFTAG_IMAGELENGTH, height);\n\t\t\t\n\t\t\t//starting from top-left corner\n\t\t\tTIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n\t\t\t\n\t\t\t//grayscale or color image\n\t\t\tTIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, channels);\n\t\t\tTIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8);\n\t\t\tTIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\t\t\tif (channels == 1)\n\t\t\t\tTIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n\t\t\telse\n\t\t\t\tif (channels == 3)\n\t\t\t\t\tTIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n\t\t\t\n\t\t\t//Miscalleneous Tags\n\t\t\tTIFFSetField( tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\t\t\tTIFFSetField( tif, TIFFTAG_COMPRESSION , COMPRESSION_NONE );\n\t\t\tTIFFSetField( tif, TIFFTAG_ROWSPERSTRIP,\n\t\t\t\t\t\t TIFFDefaultStripSize(tif , (uint32) -1) );\n\t\t\tTIFFSetField(tif, TIFFTAG_XRESOLUTION, 72);\n\t\t\tTIFFSetField(tif, TIFFTAG_YRESOLUTION, 72);\n\t\t\tTIFFSetField(tif, TIFFTAG_RESOLUTIONUNIT, RESUNIT_INCH);\n\t\t\t\n\t\t\t//create a dummy array\n\t\t\tint linebytes = channels*width;\n\t\t\tunsigned char *buf = new unsigned char[linebytes];\n\t\t\tTIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, TIFFDefaultStripSize(tif, linebytes));\n\t\t\t\n\t\t\t//start writing the data into the TIFF file in scanlines\n\t\t\tfor ( int row = 0; row < height; row++)\n\t\t\t{\n\t\t\t\t//check if a grayscale or color image is being written\n\t\t\t\tmemcpy(buf, &img[layerIndex*width*height*channels+row*linebytes], linebytes);\n\t\t\t\t\n\t\t\t\tif (TIFFWriteScanline(tif, buf, row, 0) < 0)\n\t\t\t\t{\n\t\t\t\t\tcerr<<\"Error in scanline while writing !\\n\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tdelete(buf);\n\t\t\tTIFFWriteDirectory(tif);\n\t\t}\n        TIFFClose(tif);\n    }\n    else\n    {\n        cerr<<\"Unable to open file for writing !\\n\";\n    }\n}",
    "char *loadTiffMetaInfo(char* filename, uint32 &sz0, uint32  &sz1, uint32  &sz2, uint32  &sz3, uint16 &datatype)\n{\n    //\n    TIFFSetWarningHandler(0);\n    TIFFSetErrorHandler(0);\n\n    //\n    TIFF *input = TIFFOpen(filename,\"r\");\n    if (!input)\n    {\n        return ((char *) \"Cannot open the file.\");\n    }\n\n    if (!TIFFGetField(input, TIFFTAG_IMAGEWIDTH, &sz0))\n    {\n        TIFFClose(input);\n        return ((char *) \"Image width of undefined.\");\n    }\n\n    if (!TIFFGetField(input, TIFFTAG_IMAGELENGTH, &sz1))\n    {\n        TIFFClose(input);\n        return ((char *) \"Image length of undefined.\");\n    }\n\n    if (!TIFFGetField(input, TIFFTAG_BITSPERSAMPLE, &datatype))\n    {\n        TIFFClose(input);\n        return ((char *) \"Undefined bits per sample.\");\n    }\n\n//    if (!TIFFGetField(input, TIFFTAG_SAMPLESPERPIXEL, &sz3))\n//    {\n//        sz3 = 1;\n//    }\n\n    sz3 = 1; // hard coded here 6/8/2018\n\n    uint16 Cpage;\n    if (!TIFFGetField(input, TIFFTAG_PAGENUMBER, &Cpage, &sz2) || sz2==0)\n    {\n        sz2 = 1;\n        while ( TIFFReadDirectory(input) )\n        {\n            sz2++;\n        }\n    }\n    datatype /= 8;\n\n    //\n    TIFFClose(input);\n\n    //\n    return ((char *) 0);\n}",
    "void readTiff( stringstream *dataStreamInMemory, unsigned char *&img, unsigned int first, unsigned int last, int starti, int endi, int startj, int endj )\n{\n    //\n    TIFF* input = TIFFStreamOpen(\"MemTIFF\", (istream *)dataStreamInMemory);\n\n    //\n    uint32 rps;\n    uint16 spp, bpp, photo, comp, planar_config;\n    int StripsPerImage,LastStripSize;\n    unsigned int img_width, img_height;\n\n    //\n    if (!TIFFGetField(input, TIFFTAG_IMAGEWIDTH, &img_width))\n    {\n        TIFFClose(input);\n        ssclear(dataStreamInMemory);\n        return;\n    }\n\n    if (!TIFFGetField(input, TIFFTAG_IMAGELENGTH, &img_height))\n    {\n        TIFFClose(input);\n        ssclear(dataStreamInMemory);\n        return;\n    }\n\n    if (!TIFFGetField(input, TIFFTAG_BITSPERSAMPLE, &bpp))\n    {\n        TIFFClose(input);\n        ssclear(dataStreamInMemory);\n        return;\n    }\n\n    if (!TIFFGetField(input, TIFFTAG_SAMPLESPERPIXEL, &spp))\n    {\n        spp = 1;\n    }\n\n    int b_swap=TIFFIsByteSwapped(input);\n\n    //\n    if (!TIFFGetField(input, TIFFTAG_PHOTOMETRIC, &photo))\n    {\n        TIFFClose(input);\n        ssclear(dataStreamInMemory);\n        return;\n    }\n\n    if (!TIFFGetField(input, TIFFTAG_COMPRESSION, &comp))\n    {\n        TIFFClose(input);\n        ssclear(dataStreamInMemory);\n        return;\n    }\n\n    if (!TIFFGetField(input, TIFFTAG_PLANARCONFIG, &planar_config))\n    {\n        TIFFClose(input);\n        ssclear(dataStreamInMemory);\n        return;\n    }\n\n    //\n    starti = (starti == -1) ? 0 : starti;\n    endi   = (endi == -1) ? img_height-1 : endi;\n    startj = (startj == -1) ? 0 : startj;\n    endj   = (endj == -1) ? img_width-1 : endj;\n\n    // file is internally tiled\n    if (TIFFIsTiled(input))\n    {\n        uint32 tilewidth;\n        uint32 tilelength;\n        uint32 tiledepth;\n        tsize_t tilenum;\n        tsize_t tilesize;\n        tsize_t tilenum_width;\n        tsize_t tilenum_length;\n        ttile_t tile;\n        tdata_t data;\n        unsigned char *psrc; // pointer in the tile buffer to the top left pixel of the current block to be copied\n        unsigned char *pdst; // pointer in the image buffer to the top left pixel of the current block to be filled\n        uint32 stride_src;\n        uint32 stride_dst;\n        int i; // row index in the slice of the top left pixel of the current block to be filled\n        int j; // column index in the slice of the top left pixel of the current block to be filled\n        uint32 width; // width of the current block to be filled (in pixels)\n        uint32 len; // length of the current block to be filled (in pixels)\n        int page;\n\n        // checks\n        if ( TIFFGetField(input, TIFFTAG_TILEDEPTH, &tiledepth) )\n        {\n            cout<<\"Tiling among slices (z direction) not supported.\"<<endl;\n            return;\n        }\n        if ( spp > 1 )\n        {\n            if ( TIFFGetField(input, TIFFTAG_PLANARCONFIG, &planar_config) )\n            {\n                if ( planar_config > 1 )\n                {\n                    cout<<\"Non-interleaved multiple channels not supported with tiling.\"<<endl;\n                    return;\n                }\n            }\n        }\n\n        // tiling is in x,y only\n        TIFFGetField(input, TIFFTAG_TILEWIDTH, &tilewidth);\n        TIFFGetField(input, TIFFTAG_TILELENGTH, &tilelength);\n        tilenum = TIFFNumberOfTiles(input);\n        tilesize = TIFFTileSize(input);\n        tilenum_width  = (img_width % tilewidth) ? (img_width / tilewidth) + 1 : img_width / tilewidth;\n        tilenum_length = (img_height % tilelength) ? (img_height / tilelength) + 1 : img_height / tilelength;\n\n        data = new unsigned char[tilesize];\n        stride_src = tilewidth * spp; // width of tile (in bytes)\n        stride_dst = (endj - startj + 1) * spp; // width of subregion (in bytes)\n\n        page = 0;\n        do {\n\n            psrc = ((unsigned char *)data) + ((starti % tilelength)*tilewidth + (startj % tilewidth)) * spp; // in the first tile skip (starti % tilelength) rows plus (startj % tilewidth) pixels\n            pdst = img; // the buffer has the size of the subregion\n            len = tilelength - (starti % tilelength); // rows to be copied for the first row of tiles\n            tile = TIFFComputeTile(input,startj,starti,0,0); // index of the first tile to be copied in the current row of tiles\n            for ( i=starti; i<=endi; ) {\n                width = tilewidth - (startj%tilewidth); // width of the first block to be copied/filled\n                for ( j=startj; j<=endj; ) {\n                    TIFFReadEncodedTile(input,tile,data,(tsize_t) -1); // read tile into tile buffer\n                    copydata (psrc,stride_src,pdst,stride_dst,(width * spp),len); // copy the block\n                    j += width;\n                    tile++; // index of the next tile in the same row of tiles\n                    psrc = ((unsigned char *)data) + ((i % tilelength)*tilewidth) * spp; // the block in the next tile begins just after (i % tilelength) rows\n                    pdst += width * spp; // the block in the image buffer move forward of width pixels\n                    width = (((tile%tilenum_width) + 1) * tilewidth <= (endj+1)) ? tilewidth : ((endj+1)%tilewidth); // if the next tile in the row is all within the subregion, width is tilewidth otherwise it is shorter\n                }\n                i += len;\n                tile = TIFFComputeTile(input,startj,i,0,0); // index of the first tile to be copied in the current row of tiles\n                psrc = ((unsigned char *)data) + ((i % tilelength)*tilewidth + (startj % tilewidth)) * spp; // in the first tile of the next row of tiles skip (i % tilelength) rows plus (startj % tilewidth) pixels\n                pdst = img + ((i-starti) * stride_dst); // the block in the image buffer begin after (i-starti) rows\n                len = (((tile/tilenum_width) + 1) * tilelength <= (endi+1)) ? tilelength : ((endi+1)%tilelength); // if the next row of tiles is all within the subregion, len is tilelength otherwise it is shorter\n            }\n\n            page++;\n\n        }while ( page < static_cast<int>(last-first+1) && TIFFReadDirectory(input));\n\n        return;\n    }\n\n    //\n    if (!TIFFGetField(input, TIFFTAG_ROWSPERSTRIP, &rps))\n    {\n        TIFFClose(input);\n        dataStreamInMemory->clear();\n        dataStreamInMemory->str(string());\n        return;\n    }\n\n    StripsPerImage =  (img_height + rps - 1) / rps;\n    LastStripSize = img_height % rps;\n    if (LastStripSize==0)\n        LastStripSize=rps;\n\n    unsigned char *buf = img;\n    int page=0;\n\n    if ( starti < 0 || endi >= img_height || startj < 0 || endj >= img_width || starti >= endi || startj >= endj )\n    {\n        cout<<\"Wrong substack indices.\"<<endl;\n        return;\n    }\n\n    if ( starti == 0 && endi == (img_height-1) && startj == 0 && endj == (img_width-1) ) { // read whole images from files\n\n        if (!TIFFSetDirectory(input, first))\n        {\n            TIFFClose(input);\n            dataStreamInMemory->clear();\n            dataStreamInMemory->str(string());\n            return;\n        }\n\n        do{\n\n            for (int i=0; i < StripsPerImage-1; i++){\n                if (comp==1) {\n                    TIFFReadRawStrip(input, i, buf, spp * rps * img_width * (bpp/8));\n                    buf = buf + spp * rps * img_width * (bpp/8);\n                }\n                else{\n                    TIFFReadEncodedStrip(input, i, buf, spp * rps * img_width * (bpp/8));\n                    buf = buf + spp * rps * img_width * (bpp/8);\n                }\n            }\n\n            if (comp==1) {\n                TIFFReadRawStrip(input, StripsPerImage-1, buf, spp * LastStripSize * img_width * (bpp/8));\n            }\n            else{\n                TIFFReadEncodedStrip(input, StripsPerImage-1, buf, spp * LastStripSize * img_width * (bpp/8));\n            }\n            buf = buf + spp * LastStripSize * img_width * (bpp/8);\n\n            page++;\n\n        }while ( page < static_cast<int>(last-first+1) && TIFFReadDirectory(input));// while (TIFFReadDirectory(input));\n\n    }\n    else { // read only a subregion of images from files\n\n        unsigned int XSIZE = img_width;\n\n        unsigned char *rowbuf = new unsigned char[spp * rps * XSIZE * (bpp/8)];\n        unsigned char *bufptr;\n\n        do{\n            if (!TIFFSetDirectory(input, first + page))\n            {\n                TIFFClose(input);\n                ssclear(dataStreamInMemory);\n                return;\n            }\n\n            int stripIndex = (starti / rps) - 1; // the strip preceeding the first one\n            for (int i=starti; i <= endi; i++) {\n                if ( floor((double)i / rps) > stripIndex ) { // read a new strip\n                    stripIndex = (int)floor((double)i / rps);\n                    if (comp==1) {\n                        TIFFReadRawStrip(input, stripIndex, rowbuf, spp * ((stripIndex < StripsPerImage) ? rps :LastStripSize) * XSIZE * (bpp/8));\n                    }\n                    else{\n                        TIFFReadEncodedStrip(input, stripIndex, rowbuf, spp * ((stripIndex < StripsPerImage) ? rps :LastStripSize) * XSIZE * (bpp/8));\n                    }\n                }\n                bufptr = rowbuf + (i % rps) * (spp * XSIZE * (bpp/8));\n                if ( bpp == 8 )\n                    for (int j=0, j1=startj; j<=(endj-startj); j++, j1++) {\n                        for (int c=0; c<spp; c++) {\n                            buf[j * spp + c] = bufptr[j1 * spp + c];\n                        }\n                    }\n                else\n                    for (int j=0 , j1=startj; j<=(endj-startj); j++, j1++) {\n                        for (int c=0; c<spp; c++) {\n                            ((uint16 *)buf)[j * spp + c] = ((uint16 *)bufptr)[j1 * spp + c];\n                        }\n                    }\n                buf = buf + spp * (endj-startj+1) * (bpp/8);\n            }\n\n            page++;\n\n        }while ( page < static_cast<int>(last-first+1) );\n\n        delete []rowbuf;\n\n    }\n\n    if ( page < static_cast<int>(last-first+1) ){\n        return;\n    }\n\n    //\n    TIFFClose(input);\n    ssclear(dataStreamInMemory);\n\n    // swap the data bytes if necessary\n    if (b_swap)\n    {\n        int i;\n        size_t total = img_width * img_height * spp * (last-first+1);\n        if (bpp/8 == 2)\n        {\n            for (i=0;i<total; i++)\n            {\n                swap2bytes((void *)(img+2*i));\n            }\n        }\n        else if (bpp/8 == 4)\n        {\n            for (i=0;i<total; i++)\n            {\n                swap4bytes((void *)(img+4*i));\n            }\n        }\n    }\n\n    //\n    return;\n}",
    "char *initTiff3DFile(char *filename, int sz0, int sz1, int sz2, int sz3, int datatype)\n{   \n    //\n    uint32 XSIZE  = sz0;\n    uint32 YSIZE  = sz1;\n    uint16 Npages = sz2;\n    uint16 spp    = sz3;\n\n    uint16 bpp=8 * datatype;\n\n    int rowsPerStrip = -1;\n\n    int check;\n\n    if ( sz3 == 1 )\n        spp = sz3;\n    else if ( sz3 < 4 )\n        spp = 3;\n    else\n        return ((char *) \"More than 3 channels in Tiff files.\");\n\n    //\n    long szSlice = (long)XSIZE * (long)YSIZE * (long)spp * (long)datatype;\n    unsigned char *fakeData=NULL;\n    try\n    {\n        fakeData = new unsigned char[ szSlice ];\n        memset(fakeData,0,szSlice);\n    }\n    catch(...)\n    {\n        return ((char *)\"Fail to alloc memory\\n\");\n    }\n\n    //disable warning and error handlers to avoid messages on unrecognized tags\n    TIFFSetWarningHandler(0);\n    TIFFSetErrorHandler(0);\n\n    TIFF *output;\n\n    long expectedSize = ((long) sz0) * ((long) sz1) * ((long) sz2) * ((long) sz3) * ((long) datatype);\n    long fourGBSize = 4;\n    fourGBSize *= 1024;\n    fourGBSize *= 1024;\n    fourGBSize *= 1024;\n\n    if ( expectedSize > (fourGBSize) )\n    {\n        if ( (rowsPerStrip == -1 && (((long) sz0) * ((long) sz1)) > (fourGBSize)) || ((rowsPerStrip * ((long) sz0)) > (fourGBSize)) )\n            return ((char *) \"Too many rows per strip for this image width.\");\n        else\n            output = TIFFOpen(filename,\"w8\");\n    }\n    else\n    {\n        output = TIFFOpen(filename,\"w\");\n    }\n\n    if (!output)\n    {\n        return ((char *) \"Cannot open the file.\");\n    }\n\n    //\n    if ( rowsPerStrip == -1 )\n    {\n        for(long slice=0; slice<Npages; slice++)\n        {\n            //\n            TIFFSetDirectory(output, slice);\n\n            //\n            check = TIFFSetField(output, TIFFTAG_IMAGEWIDTH, XSIZE);\n            if (!check) {\n                return ((char *) \"Cannot set the image width.\");\n            }\n\n            check = TIFFSetField(output, TIFFTAG_IMAGELENGTH, YSIZE);\n            if (!check) {\n                return ((char *) \"Cannot set the image height.\");\n            }\n\n            check = TIFFSetField(output, TIFFTAG_BITSPERSAMPLE, bpp);\n            if (!check) {\n                return ((char *) \"Cannot set the image bit per sample.\");\n            }\n\n            check = TIFFSetField(output, TIFFTAG_SAMPLESPERPIXEL, spp);\n            if (!check) {\n                return ((char *) \"Cannot set the image sample per pixel.\");\n            }\n\n            check = TIFFSetField(output, TIFFTAG_ROWSPERSTRIP, (rowsPerStrip == -1) ? YSIZE : (uint32)rowsPerStrip);\n            if (!check) {\n                return ((char *) \"Cannot set the image rows per strip.\");\n            }\n\n            check = TIFFSetField(output, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n            if (!check) {\n                return ((char *) \"Cannot set the image orientation.\");\n            }\n\n            check = TIFFSetField(output, TIFFTAG_COMPRESSION, COMPPRESSION_METHOD);\n            if (!check) {\n                return ((char *) \"Cannot set the compression tag.\");\n            }\n\n            check = TIFFSetField(output, TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG);\n            if (!check) {\n                return ((char *) \"Cannot set the planarconfig tag.\");\n            }\n\n            if ( spp == 1 )\n                check = TIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n            else // spp == 3\n                check = TIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n            if (!check) {\n                return ((char *) \"Cannot set the photometric tag.\");\n            }\n\n            /* We are writing single page of the multipage file */\n            check = TIFFSetField(output, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE);\n            if (!check) {\n                return ((char *) \"Cannot set the subfiletype tag.\");\n            }\n\n            check = TIFFSetField(output, TIFFTAG_PAGENUMBER, slice, Npages);\n            if (!check) {\n                return ((char *) \"Cannot set the page number.\");\n            }\n\n            if(!TIFFWriteEncodedStrip(output, 0, fakeData, szSlice))\n            {\n                return ((char *) \"Cannot write encoded strip to file.\");\n            }\n\n            //\n            if (!TIFFWriteDirectory(output))\n            {\n                return ((char *) \"Cannot write a new directory.\");\n            }\n        }\n    }\n    else\n    {\n        // TODO: modify codes to save 3D image stack later\n\n        //\n        // save one slice\n        //\n        int check,StripsPerImage,LastStripSize;\n        uint32 rps = (uint32)rowsPerStrip;\n        unsigned char *buf = fakeData;\n\n        StripsPerImage =  (YSIZE + rps - 1) / rps;\n        LastStripSize = YSIZE % rps;\n        if (LastStripSize==0)\n            LastStripSize=rps;\n\n        for (int i=0; i < StripsPerImage-1; i++){\n            check = TIFFWriteEncodedStrip(output, i, buf, spp * rps * XSIZE * (bpp/8));\n            if (!check) {\n                return ((char *) \"Cannot write encoded strip to file.\");\n            }\n            buf = buf + spp * rps * XSIZE * (bpp/8);\n        }\n\n        check = TIFFWriteEncodedStrip(output, StripsPerImage-1, buf, spp * LastStripSize * XSIZE * (bpp/8));\n        if (!check) {\n            return ((char *) \"Cannot write encoded strip to file.\");\n        }\n        buf = buf + spp * LastStripSize * XSIZE * (bpp/8);\n    }\n\n    //\n    if(fakeData)\n    {\n        delete[] fakeData;\n    }\n\n    //\n    TIFFClose(output);\n\n    //\n    return (char *) 0;\n}",
    "int openTiff3DFile(char *filename, char *mode, void *&fhandle, bool reopen)\n{\n    //\n    char *completeMode = NULL;\n\n    //\n    TIFFSetWarningHandler(0);\n    TIFFSetErrorHandler(0);\n\n    // if mode is 'w' and reopen is true check if the file esists\n    if ( mode[0] == 'w' && reopen )\n    {\n        fhandle = TIFFOpen(filename,\"r\");\n        if ( fhandle )\n        {\n            TIFFClose((TIFF *) fhandle);\n        }\n    }\n\n    bool mybigtiff = false;\n    if ( mybigtiff && !strstr(mode,\"8\") )\n    {\n        completeMode = new char[strlen(mode)+2];\n        strcpy(completeMode,mode);\n        strcat(completeMode,\"8\");\n    }\n    else\n    {\n        completeMode = new char[strlen(mode)+2];\n        strcpy(completeMode,mode);\n    }\n\n    fhandle = TIFFOpen(filename,completeMode);\n\n    delete completeMode;\n\n    if (!fhandle)\n    {\n        cout<<\"Cannot open the file.\\n\";\n        return -1;\n    }\n\n    //\n    return 0;\n}",
    "int writeTiff3DFile(char* filename, uint8 *img, int x, int y, int z, int c, int datatype)\n{\n    //\n    TIFFSetWarningHandler(0);\n    TIFFSetErrorHandler(0);\n\n    //\n    void *fhandle = 0;\n    openTiff3DFile(filename, (char *)(\"w\"), fhandle, false);\n\n    for(int i=0; i<z; i++)\n    {\n        appendSlice2Tiff3DFile(fhandle, i, img+i*x*y*c*datatype, x, y, c, datatype*8, z);\n    }\n\n    //\n    del1dp(img);\n\n    //\n    TIFFClose((TIFF *) fhandle);\n\n    //\n    return 0;\n}",
    "int BigTree::reformat()\n{\n    // meta\n//    vector<LAYER> layers;\n\n    //\n    int stack_block[TMITREE_MAX_HEIGHT];\n    int slice_start[TMITREE_MAX_HEIGHT];\n    int slice_end[TMITREE_MAX_HEIGHT];\n\n    int nzsize[TMITREE_MAX_HEIGHT];\n\n    for(int res_i=0; res_i< resolutions; res_i++)\n    {\n        stack_block[res_i] = 0;\n        slice_start[res_i] = 0;\n        slice_end[res_i] = slice_start[res_i] + stacks_D[res_i][0][0][0] - 1;\n\n        //cout<<\"slice_end[\"<<res_i<<\"] \"<<slice_end[res_i]<<endl;\n\n        nzsize[res_i] = 0;\n    }\n\n    //\n    for(long z=zstart, z_parts=zpart; z<depth; z+=z_max_res, z_parts++)\n    {\n        if(!genMetaInfoOnly && !genZeroDataOnly)\n        {\n            auto start = std::chrono::high_resolution_clock::now();\n\n            ubuffer = load(z,(z+z_max_res <= depth) ? (z+z_max_res) : depth, z_parts);\n\n            auto end = std::chrono::high_resolution_clock::now();\n\n            cout<<\"load a sub volume takes \"<<std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count()<<\" ms.\"<<endl;\n\n            //\n            if(datatype>1 && nbits)\n            {\n                long totalvoxels = (height * width * ((z_ratio>0) ? z_max_res : (depth%z_max_res)))*color;\n                if ( datatype == 2 )\n                {\n                    #pragma omp parallel\n                    {\n                        uint16 *ptr = (uint16 *) ubuffer;\n                        #pragma omp for\n                        for(long i=0; i<totalvoxels; i++ )\n                        {\n                            // ptr[i] = ptr[i] >> nbits << nbits; // 16-bit\n                            ptr[i] = ptr[i] >> nbits;\n                        }\n                    }\n                }\n            }\n\n        } // genMetaInfoOnly\n\n        //saving the sub volume\n        auto start = std::chrono::high_resolution_clock::now();\n        for(int i=0; i< resolutions; i++)\n        {\n            //cout<<\"resolution \"<<i<<endl;\n\n            // meta info for index()\n            LAYER layer;\n            layer.rows = n_stacks_V[i];\n            layer.cols = n_stacks_H[i];\n\n            layer.vs_x = pow(2, i);\n            layer.vs_y = pow(2, i);\n            layer.vs_z = pow(2, halve_pow2[i]);\n\n            layer.dim_V = (uint32)(height/layer.vs_y);\n            layer.dim_H = (uint32)(width/layer.vs_x);\n            layer.dim_D = (uint32)(depth/layer.vs_z);\n\n            //\n            long nCopies = 0;\n            string srcFile;\n\n            // check if current block is changed\n            if ( (z / pow(2,halve_pow2[i])) > slice_end[i] ) {\n                stack_block[i]++;\n                slice_start[i] = slice_end[i] + 1;\n                slice_end[i] += stacks_D[i][0][0][stack_block[i]];  \n            }\n\n            // find abs_pos_z at resolution i\n            std::stringstream abs_pos_z;\n            abs_pos_z.width(6);\n            abs_pos_z.fill('0');\n            abs_pos_z << (int)((pow(2,halve_pow2[i])*slice_start[i]) * 10);\n\n            // compute the number of slice of previous groups at resolution i\n            // note that z_parts in the number and not an index (starts from 1)\n            long n_slices_pred  = (z_parts - 1) * z_max_res / pow(2,halve_pow2[i]);\n\n            // buffer size along D is different when the remainder of the subdivision by z_max_res is considered\n            long z_size = (z_ratio>0) ? z_max_res : (depth%z_max_res);\n\n            //cout<<\"z_parts \"<<z_parts<<\" z_ratio \"<<z_ratio<<\" z_max_res \"<<z_max_res<<\" depth \"<<depth<<endl;\n\n            //halvesampling resolution if current resolution is not the deepest one\n            if(i!=0)\n            {\n                if(!genMetaInfoOnly && !genZeroDataOnly)\n                {\n                    if ( halve_pow2[i] == (halve_pow2[i-1]+1) )\n                    {\n                        //cout<<\"3D downsampling \\n\";\n\n                        // 3D\n                        halveSample(ubuffer,(int)height/(pow(2,i-1)),(int)width/(pow(2,i-1)),(int)z_size/(pow(2,halve_pow2[i-1])),HALVE_BY_MAX,datatype);\n\n                        // debug\n                        // writeTiff3DFile(\"test.tif\", ubuffer, (int)width/(pow(2,i)), (int)height/(pow(2,i)), (int)z_size/(pow(2,halve_pow2[i])), 1, datatype);\n                    }\n                    else if ( halve_pow2[i] == halve_pow2[i-1] )\n                    {\n                        //cout<<\"2D downsampling \\n\";\n\n                        // 2D\n                        halveSample2D(ubuffer,(int)height/(pow(2,i-1)),(int)width/(pow(2,i-1)),(int)z_size/(pow(2,halve_pow2[i-1])),HALVE_BY_MAX,datatype);\n                    }\n                    else\n                    {\n                        cout<<\"halve sampling level \"<<halve_pow2[i]<<\" not supported at resolution \"<<i<<endl;\n                        return -1;\n                    }\n                }\n            }\n\n            //saving at current resolution if it has been selected and iff buffer is at least 1 voxel (Z) deep\n            if((z_size/(pow(2,halve_pow2[i]))) > 0)\n            {\n                //storing in 'base_path' the absolute path of the directory that will contain all stacks\n                std::stringstream base_path;\n                base_path << filePaths[i] << \"/\";\n\n                //cout<<\"base_path \"<<base_path.str()<<endl;\n\n                // meta info for index()\n//                bool addMeta = false;\n\n//                if(z == 0)\n//                {\n//                    addMeta = true;\n//                }\n//                else if( (int)(slice_start[i] / stacks_D[i][0][0][stack_block[i]]) > nzsize[i])\n//                {\n//                    nzsize[i]++;\n//                    addMeta = true;\n//                }\n\n                //looping on new stacks\n                for(int stack_row = 0, start_height = 0, end_height = 0; stack_row < n_stacks_V[i]; stack_row++)\n                {\n                    //incrementing end_height\n                    end_height = start_height + stacks_V[i][stack_row][0][0]-1;\n\n                    //computing V_DIR_path and creating the directory the first time it is needed\n                    std::stringstream multires_merging_x_pos;\n                    multires_merging_x_pos.width(6);\n                    multires_merging_x_pos.fill('0');\n                    multires_merging_x_pos << start_height*(int)pow(2.0,i) * 10;\n\n                    std::stringstream V_DIR_path;\n                    V_DIR_path << base_path.str() << multires_merging_x_pos.str();\n\n                    //cout<<\"V_DIR_path \"<<V_DIR_path.str()<<endl;\n\n                    if(z==0)\n                    {\n                        if(makeDir(V_DIR_path.str().c_str()))\n                        {\n                            cout<<\" unable to create V_DIR \"<<V_DIR_path.str()<<endl;\n                            return -1;\n                        }\n                    }\n\n                    int sz[4];\n                    // int datatype_out = 2; // changed to 16-bit 6/1/2018 yy\n                    int datatype_out = 1;\n\n                    //\n                    for(int stack_column = 0, start_width=0, end_width=0; stack_column < n_stacks_H[i]; stack_column++)\n                    {\n                        //\n                        end_width  = start_width  + stacks_H[i][stack_row][stack_column][0]-1;\n\n                        //computing H_DIR_path and creating the directory the first time it is needed\n                        std::stringstream multires_merging_y_pos;\n                        multires_merging_y_pos.width(6);\n                        multires_merging_y_pos.fill('0');\n                        multires_merging_y_pos << start_width*(int)pow(2.0,i) * 10;\n\n                        std::stringstream H_DIR_path;\n                        H_DIR_path << V_DIR_path.str() << \"/\" << multires_merging_x_pos.str() << \"_\" << multires_merging_y_pos.str();\n\n                        //cout<<\"H_DIR_path \"<<H_DIR_path.str()<<endl;\n\n                        //\n                        if(z==0)\n                        {\n                            if(makeDir(H_DIR_path.str().c_str()))\n                            {\n                                cout<<\" unable to create H_DIR \"<<H_DIR_path.str()<<endl;\n                                return -1;\n                            }\n                            else\n                            {\n                                // the directory has been created for the first time\n                                // initialize block files\n                                sz[0] = stacks_H[i][stack_row][stack_column][0];\n                                sz[1] = stacks_V[i][stack_row][stack_column][0];\n                                sz[3] = 1;\n\n                                //\n                                int slice_start_temp = 0;\n                                for ( int j=0; j < n_stacks_D[i]; j++ )\n                                {\n                                    bool copying = false;\n\n                                    if(sz[2] == stacks_D[i][stack_row][stack_column][j])\n                                        copying = true;\n\n                                    sz[2] = stacks_D[i][stack_row][stack_column][j];\n\n                                    //cout<<\" ... \"<<j<<\" sz[2] \"<<sz[2]<<\" slice_end \"<<slice_end[i]<<endl;\n\n                                    std::stringstream abs_pos_z_temp;\n                                    abs_pos_z_temp.width(6);\n                                    abs_pos_z_temp.fill('0');\n                                    abs_pos_z_temp << (int)((pow(2,halve_pow2[i])*slice_start_temp) * 10);\n\n                                    std::stringstream img_path_temp;\n                                    img_path_temp << H_DIR_path.str() << \"/\" << multires_merging_x_pos.str() << \"_\" << multires_merging_y_pos.str() << \"_\" << abs_pos_z_temp.str()<<\".tif\";\n\n                                    //cout<<\"when z=0: z \"<<z<<\" (\"<<sz[0]<<\", \"<<sz[1]<<\", \"<<sz[2]<<\") \"<<abs_pos_z_temp.str()<<endl;\n\n                                    if(!genMetaInfoOnly)\n                                    {\n                                        // auto start_init = std::chrono::high_resolution_clock::now();\n                                        if(nCopies==0)\n                                        {\n                                            if(initTiff3DFile((char *)img_path_temp.str().c_str(),sz[0],sz[1],sz[2],sz[3],datatype_out) != 0)\n                                            {\n                                                cout<<\"fail in initTiff3DFile\\n\";\n                                                return -1;\n                                            }\n                                            srcFile = img_path_temp.str();\n                                        }\n                                        else if(copying)\n                                        {\n                                            copyFile(srcFile.c_str(), img_path_temp.str().c_str());\n                                        }\n                                        else\n                                        {\n                                            if(initTiff3DFile((char *)img_path_temp.str().c_str(),sz[0],sz[1],sz[2],sz[3],datatype_out) != 0)\n                                            {\n                                                cout<<\"fail in initTiff3DFile\\n\";\n                                                return -1;\n                                            }\n                                        }\n                                        nCopies++;\n                                    }// genMetaInfoOnly\n\n                                    //\n                                    //auto end_init = std::chrono::high_resolution_clock::now();\n                                    //cout<<\"writing chunk images takes \"<<std::chrono::duration_cast<std::chrono::milliseconds>(end_init - start_init).count()<<\" ms.\"<<endl;\n\n                                    //\n                                    slice_start_temp += (int)sz[2];\n                                } // j\n                            } // after create H_DIR\n                        } // z\n\n                        //saving HERE\n\n                        //\n                        std::stringstream partial_img_path;\n                        partial_img_path << H_DIR_path.str() << \"/\" << multires_merging_x_pos.str() << \"_\" << multires_merging_y_pos.str() << \"_\";\n\n                        int slice_ind = (int)(n_slices_pred - slice_start[i]);\n\n                        std::stringstream img_path;\n                        img_path << partial_img_path.str() << abs_pos_z.str() << \".tif\";\n\n                        //cout<<\"img_path \"<<img_path.str()<<endl;\n\n                        //\n                        void *fhandle = 0;\n                        int  n_pages_block = stacks_D[i][0][0][stack_block[i]]; // number of pages of current block\n                        bool block_changed = false; // true if block is changed executing the next for cycle\n\n                        if(!genMetaInfoOnly && !genZeroDataOnly)\n                        {\n                            if(openTiff3DFile((char *)img_path.str().c_str(),(char *)(\"a\"),fhandle,true))\n                            {\n                                cout<<\"fail in openTiff3DFile\"<<endl;\n                                return -1;\n                            }\n                        }// genMetaInfoOnly\n\n                        //\n                        sz[0] = end_width - start_width + 1;\n                        sz[1] = end_height - start_height + 1;\n                        sz[2] = n_pages_block;\n                        sz[3] = 1;\n                        long szChunk = sz[0]*sz[1]*sz[3]*datatype_out;\n                        unsigned char *p = NULL;\n\n                        if(!genMetaInfoOnly && !genZeroDataOnly)\n                        {\n                            try\n                            {\n                                p = new unsigned char [szChunk];\n                                memset(p, 0, szChunk);\n                            }\n                            catch(...)\n                            {\n                                cout<<\"fail to alloc memory \\n\";\n                            }\n                        }// genMetaInfoOnly\n\n                        // meta info for index()\n//                        BLOCK block;\n\n//                        if(addMeta)\n//                        {\n//                            block.width = sz[0];\n//                            block.height = sz[1];\n//                            block.depths.push_back(sz[2]);\n//                            block.color = sz[3];\n//                            block.bytesPerVoxel = datatype_out;\n\n//                            block.dirName = multires_merging_x_pos.str() + \"/\" + multires_merging_x_pos.str() + \"_\" + multires_merging_y_pos.str();\n//                            block.offset_H = start_width;\n//                            block.offset_V = start_height;\n//                            block.fileNames.push_back(multires_merging_x_pos.str() + \"_\" + multires_merging_y_pos.str() + \"_\" + abs_pos_z.str() + \".tif\");\n//                            block.offsets_D.push_back(slice_start[i]);\n//                        }\n\n                        bool blocksaved = false;\n\n                        //cout<<\"z \"<<z<<endl;\n\n                        // WARNING: assumes that block size along z is not less that z_size/(powInt(2,i))\n                        for(int buffer_z=0; buffer_z<(int)(z_size/(pow(2,halve_pow2[i]))); buffer_z++, slice_ind++)\n                        {\n                            //cout<<\"buffer_z \"<<buffer_z<<\" slice_ind \"<<slice_ind<<\" z \"<<z<<\" z_size/(pow(2,halve_pow2[i]) \"<<z_size/(pow(2,halve_pow2[i]))<<\" z_size \"<<z_size<<endl;\n                            //cout<<\"(z / pow(2,halve_pow2[i]) + buffer_z) \"<<z / pow(2,halve_pow2[i]) + buffer_z<<\" slice_end[\"<<i<<\"] \"<<slice_end[i]<<endl;\n\n                            // z is an absolute index in volume while slice index should be computed on a relative basis\n                            if ( (int)(z / pow(2,halve_pow2[i]) + buffer_z) > slice_end[i] && !block_changed)\n                            {\n                                //cout<<\"block changed \"<<slice_end[i]<<endl;\n\n                                // start a new block along z\n                                std::stringstream abs_pos_z_next;\n                                abs_pos_z_next.width(6);\n                                abs_pos_z_next.fill('0');\n                                abs_pos_z_next << (pow(2,halve_pow2[i])*(slice_end[i]+1)) * 10;\n                                img_path.str(\"\");\n                                img_path << partial_img_path.str() << abs_pos_z_next.str() << \".tif\";\n\n                                //cout<<\"... img_path \"<<img_path.str()<<endl;\n\n                                slice_ind = 0;\n\n                                if(!genMetaInfoOnly && !genZeroDataOnly)\n                                {\n                                    // close(fhandle) i.e. file corresponding to current block\n                                    TIFFClose((TIFF *) fhandle);\n                                    if(openTiff3DFile((char *)img_path.str().c_str(),(char *)(\"a\"),fhandle,true))\n                                    {\n                                        cout<<\"fail in openTiff3DFile\"<<endl;\n                                        return -1;\n                                    }\n                                }// genMetaInfoOnly\n                                n_pages_block = stacks_D[i][0][0][stack_block[i]+1];\n                                block_changed = true;\n\n                                sz[2] = n_pages_block;\n                                szChunk = sz[0]*sz[1]*sz[3]*datatype_out;\n\n                                //\n                                if(!genMetaInfoOnly && !genZeroDataOnly)\n                                {\n                                    if(!p)\n                                    {\n                                        try\n                                        {\n                                            p = new unsigned char [szChunk];\n                                            memset(p, 0, szChunk);\n                                        }\n                                        catch(...)\n                                        {\n                                            cout<<\"fail to alloc memory \\n\";\n                                        }\n                                    }\n                                    else\n                                    {\n                                        memset(p, 0, szChunk);\n                                    }\n                                }// genMetaInfoOnly\n                            }\n\n                            //\n                            if(!genMetaInfoOnly && !genZeroDataOnly)\n                            {\n                                //\n                                long raw_img_width = width/(pow(2,i));\n\n                                //\n                                if(datatype == 2)\n                                {\n                                    // 16-bit input\n                                    long offset = buffer_z*(long)(height/pow(2,i))*(long)(width/pow(2,i));\n                                    uint16 *raw_ch16 = (uint16 *) ubuffer + offset;\n\n                                    //cout<<\"pointer p: \"<<static_cast<void*>(p)<<endl;\n                                    //cout<<\"pointer raw data: \"<<static_cast<void*>(raw_ch16)<<endl;\n\n                                    if(datatype_out == 1)\n                                    {\n                                        // 8-bit output\n\n                                        //\n                                        #pragma omp parallel for collapse(2)\n                                        for(long y=0; y<sz[1]; y++)\n                                        {\n                                            for(long x=0; x<sz[0]; x++)\n                                            {\n                                                p[y*sz[0]+x] = raw_ch16[(y+start_height)*(raw_img_width) + (x+start_width)];\n                                            }\n                                        }\n\n                                        // temporary save all the way (version 1.01 5/25/2018)\n//                                        int temp_n_chans = color;\n//                                        if(temp_n_chans==2)\n//                                            temp_n_chans++;\n\n                                        appendSlice2Tiff3DFile(fhandle,slice_ind,(unsigned char *)p,sz[0],sz[1],color,8,sz[2]);\n                                        blocksaved = true;\n\n                                        //\n//                                        int numNonZeros = 0;\n//                                        int saveVoxelThresh = 1;\n\n//                                        #pragma omp parallel for reduction(+:numNonZeros)\n//                                        for(int x=0; x<szChunk; x++)\n//                                        {\n//                                            if(p[x]>0)\n//                                                numNonZeros++;\n//                                        }\n\n//                                        if(numNonZeros>saveVoxelThresh)\n//                                        {\n//                                            int temp_n_chans = color;\n//                                            if(temp_n_chans==2)\n//                                                temp_n_chans++;\n\n//                                            appendSlice2Tiff3DFile(fhandle,slice_ind,(unsigned char *)p,sz[0],sz[1],temp_n_chans,8,sz[2]);\n//                                            blocksaved = true;\n//                                        }\n                                    }\n                                    else\n                                    {\n                                        // 16-bit output\n\n                                        uint16 *out_ch16 = (uint16 *) p;\n\n                                        //\n                                        #pragma omp parallel for collapse(2)\n                                        for(long y=0; y<sz[1]; y++)\n                                        {\n                                            for(long x=0; x<sz[0]; x++)\n                                            {\n                                                out_ch16[y*sz[0]+x] = raw_ch16[(y+start_height)*(raw_img_width) + (x+start_width)];\n                                            }\n                                        }\n\n                                        // temporary save all the way (version 1.01 5/25/2018)\n                                        int temp_n_chans = color;\n                                        if(temp_n_chans==2)\n                                            temp_n_chans++;\n\n                                        appendSlice2Tiff3DFile(fhandle,slice_ind,(unsigned char *)out_ch16,sz[0],sz[1],temp_n_chans,16,sz[2]);\n                                        blocksaved = true;\n\n                                    }\n\n                                }\n                                else if(datatype == 1)\n                                {\n                                    // 8-bit input\n                                    long offset = buffer_z*(long)(height/pow(2,i))*(long)(width/pow(2,i));\n                                    uint8 *raw_ch8 = (uint8 *) ubuffer + offset;\n\n                                    if(datatype_out == 1)\n                                    {\n                                        // 8-bit output\n\n                                        //\n                                        #pragma omp parallel for collapse(2)\n                                        for(long y=0; y<sz[1]; y++)\n                                        {\n                                            for(long x=0; x<sz[0]; x++)\n                                            {\n                                                p[y*sz[0]+x] = raw_ch8[(y+start_height)*(raw_img_width) + (x+start_width)];\n                                            }\n                                        }\n\n                                        // temporary save all the way (version 1.01 5/25/2018)\n                                        int temp_n_chans = color;\n                                        if(temp_n_chans==2)\n                                            temp_n_chans++;\n\n                                        appendSlice2Tiff3DFile(fhandle,slice_ind,(unsigned char *)p,sz[0],sz[1],temp_n_chans,8,sz[2]);\n                                        blocksaved = true;\n\n                                        //\n//                                        int numNonZeros = 0;\n//                                        int saveVoxelThresh = 1;\n\n//                                        #pragma omp parallel for reduction(+:numNonZeros)\n//                                        for(int x=0; x<szChunk; x++)\n//                                        {\n//                                            if(p[x]>0)\n//                                                numNonZeros++;\n//                                        }\n\n//                                        //cout<<\"... raw_img_width \"<<raw_img_width<<\" offset \"<<offset<<\" height/pow(2,i) \"<<height/pow(2,i)<<\" width/pow(2,i) \"<<width/pow(2,i)<<endl;\n\n//                                        if(numNonZeros>saveVoxelThresh)\n//                                        {\n//                                            int temp_n_chans = color;\n//                                            if(temp_n_chans==2)\n//                                                temp_n_chans++;\n\n//                                            //cout<<\"... save slice_ind: \"<<slice_ind<<endl;\n//                                            appendSlice2Tiff3DFile(fhandle,slice_ind,(unsigned char *)p,sz[0],sz[1],temp_n_chans,8,sz[2]);\n//                                            blocksaved = true;\n//                                        }\n                                    }\n                                    else\n                                    {\n                                        // 16-bit output\n\n                                    }\n                                }\n                                else\n                                {\n                                    // other datatypes\n                                }\n\n                            }// genMetaInfoOnly\n                        }\n\n                        if(!genMetaInfoOnly && !genZeroDataOnly)\n                        {\n                            //\n                            del1dp(p);\n\n                            // close(fhandle) i.e. currently opened file\n                            TIFFClose((TIFF *) fhandle);\n                        }\n\n                        //\n                        start_width  += stacks_H[i][stack_row][stack_column][0];\n\n                        //\n//                        if(addMeta)\n//                        {\n//                            block.nonZeroBlocks.push_back(blocksaved);\n//                            block.nBlocksPerDir = block.fileNames.size();\n//                            layer.blocks.push_back(block);\n//                            layer.n_scale = i;\n//                        }\n\n                    }\n                    start_height += stacks_V[i][stack_row][0][0];\n                }\n            }\n\n            //\n//            if(!layer.blocks.empty())\n//            {\n//                layers.push_back(layer);\n//            }\n        }\n\n        //releasing allocated memory\n        del1dp(ubuffer);\n\n        //\n        auto end = std::chrono::high_resolution_clock::now();\n        cout<<\"writing sub volume's chunk images takes \"<<std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count()<<\" ms.\"<<endl;\n    }\n\n    // reconstruct meta info\n//    for(int i=0; i<layers.size(); i++)\n//    {\n//        LAYER layer = layers[i];\n//        cout<<\"layer \"<<i<<\": \"<<layer.n_scale<<\" of \"<<layers.size()<<endl;\n\n//        //\n//        if(meta.layers.empty() || meta.layers.size() <= layer.n_scale)\n//        {\n//            meta.layers.push_back(layer);\n//            continue;\n//        }\n\n//        LAYER mlayer = meta.layers[layer.n_scale];\n\n//        cout<<\" ... blocks \"<<layer.blocks.size()<<endl;\n\n//        //\n//        for(int j=0; j<layer.blocks.size(); j++)\n//        {\n//            //cout<<\"block \"<<j<<\" of \"<<layer.blocks.size()<<endl;\n\n//            BLOCK block = layer.blocks[j];\n\n//            bool found = false;\n//            for(int k=0; k<mlayer.blocks.size(); k++)\n//            {\n//                BLOCK mblock = mlayer.blocks[k];\n\n//                //if(mblock.dirName.compare(block.dirName) == 0)\n//                if(compareString(mblock.dirName.c_str(), block.dirName.c_str(), mblock.dirName.length()) == 0)\n//                {\n//                    found = true;\n\n//                    bool added = false;\n//                    for(int iname=0; iname<mblock.fileNames.size(); iname++)\n//                    {\n//                        //if(mblock.fileNames[iname].compare(block.fileNames[0]) == 0)\n//                        if(compareString(mblock.fileNames[iname].c_str(), block.fileNames[0].c_str(), mblock.fileNames[iname].length()) == 0)\n//                        {\n//                            added = true;\n//                            continue;\n//                        }\n//                    }\n\n//                    if(!added)\n//                    {\n//                        meta.layers[layer.n_scale].blocks[k].fileNames.push_back(block.fileNames[0]);\n//                        meta.layers[layer.n_scale].blocks[k].depths.push_back(block.depths[0]);\n//                        meta.layers[layer.n_scale].blocks[k].offsets_D.push_back(block.offsets_D[0]);\n//                    }\n\n//                    continue;\n//                }\n//            }\n\n//            if(found)\n//            {\n//                continue;\n//            }\n//            else\n//            {\n//                meta.layers[layer.n_scale].blocks.push_back(block);\n//            }\n\n//            //cout<<\"block.fileNames[0] \"<<block.fileNames[0]<<\" \"<<block.fileNames.size()<<endl;\n//            //cout<<\"block.dirName \"<<block.dirName<<endl;\n//        }\n//    }\n//    cout<<\"finish meta info construction\"<<endl;\n\n    //\n    return 0;\n}",
    "char *tiffread(const char* filename, unsigned char *&p, uint32 &sz0, uint32  &sz1, uint32  &sz2, uint16 &datatype)\n{\n    //\n    TIFF *input = TIFFOpen(filename,\"r\");\n    if (!input)\n    {\n        return ((char *) \"Cannot open the file.\");\n    }\n\n    if (!TIFFGetField(input, TIFFTAG_IMAGEWIDTH, &sz0))\n    {\n        TIFFClose(input);\n        return ((char *) \"Image width of undefined.\");\n    }\n\n    if (!TIFFGetField(input, TIFFTAG_IMAGELENGTH, &sz1))\n    {\n        TIFFClose(input);\n        return ((char *) \"Image length of undefined.\");\n    }\n\n    if (!TIFFGetField(input, TIFFTAG_BITSPERSAMPLE, &datatype))\n    {\n        TIFFClose(input);\n        return ((char *) \"Undefined bits per sample.\");\n    }\n\n    uint16 Cpage;\n    if (!TIFFGetField(input, TIFFTAG_PAGENUMBER, &Cpage, &sz2) || sz2==0)\n    {\n        sz2 = 1;\n        while ( TIFFReadDirectory(input) )\n        {\n            sz2++;\n        }\n    }\n    datatype /= 8;\n\n    //cout<<\"test \"<<sz0<<\" \"<<sz1<<\" \"<<sz2<<\" \"<<datatype<<endl;\n\n    V3DLONG imgsz = (V3DLONG)sz0*(V3DLONG)sz1*(V3DLONG)sz2*(V3DLONG)datatype;\n\n    //\n    try\n    {\n        p = new unsigned char [imgsz];\n    }\n    catch(...)\n    {\n        return ((char*) \"fail to alloc memory for loading a tiff image.\");\n    }\n\n    //\n    uint32 rps;\n    int StripsPerImage,LastStripSize;\n\n    //\n    if (!TIFFGetField(input, TIFFTAG_ROWSPERSTRIP, &rps))\n    {\n        TIFFClose(input);\n        return ((char *) \"Undefined rowsperstrip.\");\n    }\n\n    uint16 comp;\n    if (!TIFFGetField(input, TIFFTAG_COMPRESSION, &comp))\n    {\n        TIFFClose(input);\n        return ((char *) \"Undefined compression.\");\n    }\n\n    StripsPerImage =  (sz1 + rps - 1) / rps;\n    LastStripSize = sz1 % rps;\n    if (LastStripSize==0)\n        LastStripSize=rps;\n\n    if (!TIFFSetDirectory(input, 0)) // init\n    {\n        TIFFClose(input);\n        return ((char *) \"fail to setdir.\");\n    }\n\n    unsigned char *buf = p;\n    do{\n        for (int i=0; i < StripsPerImage-1; i++)\n        {\n            cout<<\"i \"<<i<<endl;\n\n            if (comp==1)\n            {\n                TIFFReadRawStrip(input, i, buf,  rps * sz0 * datatype);\n                buf = buf + rps * sz0 * datatype;\n            }\n            else\n            {\n                TIFFReadEncodedStrip(input, i, buf, rps * sz0 * datatype);\n                buf = buf + rps * sz0 * datatype;\n            }\n        }\n\n        if (comp==1)\n        {\n            TIFFReadRawStrip(input, StripsPerImage-1, buf, LastStripSize * sz0 * datatype);\n        }\n        else\n        {\n            TIFFReadEncodedStrip(input, StripsPerImage-1, buf, LastStripSize * sz0 * datatype);\n        }\n        buf = buf + LastStripSize * sz0 * datatype;\n\n    } while(TIFFReadDirectory(input));\n\n    //\n    TIFFClose(input);\n\n    //\n    return ((char *) 0);\n}",
    "char *tiffread(char* filename, unsigned char *&p, uint32 &sz0, uint32  &sz1, uint32  &sz2, uint16 &datatype, uint16 &comp)\n{\n    //\n    TIFF *input = TIFFOpen(filename,\"r\");\n    if (!input)\n    {\n        return ((char *) \"Cannot open the file.\");\n    }\n\n    if (!TIFFGetField(input, TIFFTAG_IMAGEWIDTH, &sz0))\n    {\n        TIFFClose(input);\n        return ((char *) \"Image width of undefined.\");\n    }\n\n    if (!TIFFGetField(input, TIFFTAG_IMAGELENGTH, &sz1))\n    {\n        TIFFClose(input);\n        return ((char *) \"Image length of undefined.\");\n    }\n\n    if (!TIFFGetField(input, TIFFTAG_BITSPERSAMPLE, &datatype))\n    {\n        TIFFClose(input);\n        return ((char *) \"Undefined bits per sample.\");\n    }\n\n    uint16 Cpage;\n    if (!TIFFGetField(input, TIFFTAG_PAGENUMBER, &Cpage, &sz2) || sz2==0)\n    {\n        sz2 = 1;\n        while ( TIFFReadDirectory(input) )\n        {\n            sz2++;\n        }\n    }\n    datatype /= 8;\n\n    //cout<<\"test \"<<sz0<<\" \"<<sz1<<\" \"<<sz2<<\" \"<<datatype<<endl;\n\n    long imgsz = (long)sz0*(long)sz1*(long)sz2*(long)datatype;\n\n    //\n    try\n    {\n        p = new unsigned char [imgsz];\n    }\n    catch(...)\n    {\n        return ((char*) \"fail to alloc memory for loading a tiff image.\");\n    }\n\n    //\n    uint32 rps;\n    int StripsPerImage,LastStripSize;\n\n    //\n    if (!TIFFGetField(input, TIFFTAG_ROWSPERSTRIP, &rps))\n    {\n        TIFFClose(input);\n        return ((char *) \"Undefined rowsperstrip.\");\n    }\n\n    if (!TIFFGetField(input, TIFFTAG_COMPRESSION, &comp))\n    {\n        TIFFClose(input);\n        return ((char *) \"Undefined compression.\");\n    }\n\n    StripsPerImage =  (sz1 + rps - 1) / rps;\n    LastStripSize = sz1 % rps;\n    if (LastStripSize==0)\n        LastStripSize=rps;\n\n    if (!TIFFSetDirectory(input, 0)) // init\n    {\n        TIFFClose(input);\n        return ((char *) \"fail to setdir.\");\n    }\n\n    unsigned char *buf = p;\n\n    do{\n        for (int i=0; i < StripsPerImage-1; i++)\n        {\n            if (comp==1)\n            {\n                TIFFReadRawStrip(input, i, buf,  rps * sz0 * datatype);\n                buf = buf + rps * sz0 * datatype;\n            }\n            else\n            {\n                TIFFReadEncodedStrip(input, i, buf, rps * sz0 * datatype);\n                buf = buf + rps * sz0 * datatype;\n            }\n        }\n\n        if (comp==1)\n        {\n            TIFFReadRawStrip(input, StripsPerImage-1, buf, LastStripSize * sz0 * datatype);\n        }\n        else\n        {\n            TIFFReadEncodedStrip(input, StripsPerImage-1, buf, LastStripSize * sz0 * datatype);\n        }\n        buf = buf + LastStripSize * sz0 * datatype;\n\n    }\n    while (TIFFReadDirectory(input)); // while (TIFFReadDirectory(input));\n\n    //\n    TIFFClose(input);\n\n    //\n    return ((char *) 0);\n}",
    "char *tiffwrite(char* filename, unsigned char *p, uint32 sz0, uint32  sz1, uint32  sz2, uint16 datatype, uint16 comp)\n{\n\n    TIFF *output = TIFFOpen(filename,\"w\");\n\n    //\n    if(sz2>1)\n    {\n        // 3D TIFF\n        for(long slice=0; slice<sz2; slice++)\n        {\n            TIFFSetDirectory(output,slice);\n\n            TIFFSetField(output, TIFFTAG_IMAGEWIDTH, sz0);\n            TIFFSetField(output, TIFFTAG_IMAGELENGTH, sz1);\n            TIFFSetField(output, TIFFTAG_BITSPERSAMPLE, (uint16)(datatype*8));\n            TIFFSetField(output, TIFFTAG_SAMPLESPERPIXEL, 1);\n            TIFFSetField(output, TIFFTAG_ROWSPERSTRIP, sz1);\n            TIFFSetField(output, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n            TIFFSetField(output, TIFFTAG_COMPRESSION, comp);\n            TIFFSetField(output, TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG);\n            //TIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n            TIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n\n            // We are writing single page of the multipage file\n            TIFFSetField(output, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE);\n            TIFFSetField(output, TIFFTAG_PAGENUMBER, (uint16)slice, (uint16)sz2);\n\n            // the file has been already opened: rowsPerStrip it is not too large for this image width\n            TIFFWriteEncodedStrip(output, 0, p, sz0 * sz1 * datatype);\n\n            TIFFWriteDirectory(output);\n        }\n    }\n    else\n    {\n        // 2D TIFF\n        TIFFSetField(output, TIFFTAG_IMAGEWIDTH, sz0);\n        TIFFSetField(output, TIFFTAG_IMAGELENGTH, sz1);\n        TIFFSetField(output, TIFFTAG_BITSPERSAMPLE, (uint16)(datatype*8));\n        TIFFSetField(output, TIFFTAG_SAMPLESPERPIXEL, 1);\n        TIFFSetField(output, TIFFTAG_ROWSPERSTRIP, sz1);\n        TIFFSetField(output, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n        TIFFSetField(output, TIFFTAG_COMPRESSION, comp);\n        TIFFSetField(output, TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG);\n        TIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n\n        // the file has been already opened: rowsPerStrip it is not too large for this image width\n        TIFFWriteEncodedStrip(output, 0, p, sz0 * sz1 * datatype);\n\n        //\n        TIFFWriteDirectory(output);\n    }\n\n    //\n    TIFFClose(output);\n\n    //\n    return ((char *) 0);\n}",
    "char *loadTiff3D2Metadata ( char * filename, unsigned int &sz0, unsigned int  &sz1, unsigned int  &sz2, unsigned int  &sz3, int &datatype, int &b_swap, void * &fhandle, int &header_len ) {\r\n\r\n    // 2015-01-30. Alessandro. @ADDED performance (time) measurement in all most time-consuming methods.\r\n    #ifdef _VAA3D_TERAFLY_PLUGIN_MODE\r\n    TERAFLY_TIME_START(TiffLoadMetadata);\r\n    #endif\r\n\r\n    uint32 XSIZE;\r\n    uint32 YSIZE;\r\n    uint16 bpp;\r\n    uint16 spp;\r\n    uint16 Cpage;\r\n    uint16 Npages;\r\n    TIFF *input;\r\n    int check;\r\n\r\n    //disable warning and error handlers to avoid messages on unrecognized tags\r\n    TIFFSetWarningHandler(0);\r\n    TIFFSetErrorHandler(0);\r\n\r\n    input=TIFFOpen(filename,\"r\");\r\n    if (!input)\r\n    {\r\n        //throw iim::IOException(strprintf(\"in IOManager::readTiffMultipage(...): Cannot open the file %s\",finName).c_str());\r\n        return ((char *) \"Cannot open the file.\");\r\n    }\r\n\r\n    check=TIFFGetField(input, TIFFTAG_IMAGEWIDTH, &XSIZE);\r\n    if (!check)\r\n    {\r\n        TIFFClose(input);\r\n        //throw iim::IOException(strprintf(\"in IOManager::readTiffMultipage(...): Image length of %s undefined\\n\", finName).c_str());\r\n        return ((char *) \"Image width of undefined.\");\r\n    }\r\n    \r\n    check=TIFFGetField(input, TIFFTAG_IMAGELENGTH, &YSIZE);\r\n    if (!check)\r\n    {\r\n        TIFFClose(input);\r\n        //throw iim::IOException(strprintf(\"in IOManager::readTiffMultipage(...): Image length of %s undefined\\n\", finName).c_str());\r\n        return ((char *) \"Image length of undefined.\");\r\n    }\r\n    \r\n    check=TIFFGetField(input, TIFFTAG_BITSPERSAMPLE, &bpp);\r\n    if (!check)\r\n    {\r\n        TIFFClose(input);\r\n        //throw iim::IOException(strprintf(\"in IOManager::readTiffMultipage(...): Undefined bits per sample in %s \\n\", finName).c_str());\r\n        return ((char *) \"Undefined bits per sample.\");\r\n    }\r\n\r\n    check=TIFFGetField(input, TIFFTAG_SAMPLESPERPIXEL, &spp);\r\n    if (!check)\r\n    {\r\n        spp = 1;\r\n        //TIFFClose(input);\r\n        //throw iim::IOException(strprintf(\"in IOManager::readTiffMultipage(...): Undefined bits per sample in %s \\n\", finName).c_str());\r\n        //return ((char *) \"Undefined samples per pixel.\");\r\n    }\r\n\r\n    // Onofri\r\n    check=TIFFGetField(input, TIFFTAG_PAGENUMBER, &Cpage, &Npages);\r\n    if (!check || Npages==0) { // the tag has not been read correctly\r\n        // Add warning?\r\n        Npages = 0;\r\n        do {\r\n            Npages++;\r\n        } while ( TIFFReadDirectory(input) );\r\n    }\r\n\r\n    sz0 = XSIZE;\r\n    sz1 = YSIZE;\r\n    sz2 = Npages;\r\n    sz3 = spp;\r\n    datatype = bpp/8;\r\n\r\n    //b_swap = 0;\r\n    b_swap=TIFFIsByteSwapped(input);\r\n    fhandle = (void *) input;\r\n    header_len = -1;\r\n\r\n    // the file must non be closed (it is responsibility of the caller)\r\n    //TIFFClose(input);\r\n\r\n    // 2015-01-30. Alessandro. @ADDED performance (time) measurement in all most time-consuming methods.\r\n    #ifdef _VAA3D_TERAFLY_PLUGIN_MODE\r\n    TERAFLY_TIME_STOP(TiffLoadMetadata, tf::IO, tf::strprintf(\"successfully loaded metadata from file \\\"%s\\\"\", filename));\r\n    #endif\r\n\r\n    return ((char *) 0);\r\n}",
    "char *initTiff3DFile ( char *filename, unsigned int sz0, unsigned int sz1, unsigned int sz2, unsigned int sz3, int datatype ) {\r\n    //int initTiff3DFile ( char *filename, uint32 XSIZE, uint32 YSIZE, uint16 spp, uint16 Npages, int datatype){\r\n\r\n    // 2015-01-30. Alessandro. @ADDED performance (time) measurement in all most time-consuming methods.\r\n    #ifdef _VAA3D_TERAFLY_PLUGIN_MODE\r\n    TERAFLY_TIME_START(TiffInitData);\r\n    #endif\r\n\r\n    uint32 XSIZE  = sz0;\r\n    uint32 YSIZE  = sz1;\r\n    uint16 Npages = sz2;\r\n    uint16 spp    = sz3;\r\n\r\n    uint16 bpp=8 * datatype;\r\n\r\n    int check;\r\n\r\n    if ( sz3 == 1 )\r\n        spp = sz3;\r\n    else if ( sz3 < 4 )\r\n        spp = 3;\r\n    else\r\n        return ((char *) \"More than 3 channels in Tiff files.\");\r\n\r\n    //\r\n    long szSlice = ((iim::sint64) XSIZE) * ((iim::sint64) YSIZE) * spp * (bpp/8);\r\n    unsigned char *fakeData=NULL;\r\n    try\r\n    {\r\n        fakeData = new unsigned char[ szSlice ];\r\n        memset(fakeData,0,szSlice);\r\n    }\r\n    catch(...)\r\n    {\r\n        return ((char *)\"Fail to alloc memory\\n\");\r\n    }\r\n\r\n    char *completeFilename = (char *) 0;\r\n    int fname_len = (int) strlen(filename);\r\n    char *suffix = strstr(filename,\".tif\");\r\n    while ( suffix && (fname_len - (suffix-filename) > 5) )\r\n        suffix = strstr(suffix+4,\".tif\");\r\n    //if ( (suffix != 0) && (fname_len - (suffix-filename) <= 5) ) { // a substring \".tif is already at the end of the filename\r\n    if ( suffix ) { // a substring \".tif is already at the very end of the filename\r\n        completeFilename = new char[fname_len+1];\r\n        strcpy(completeFilename,filename);\r\n    }\r\n    else {\r\n        completeFilename = new char[fname_len+4+1];\r\n        strcpy(completeFilename,filename);\r\n        strcat(completeFilename,\".\");\r\n        strcat(completeFilename,TIFF3D_SUFFIX);\r\n    }\r\n\r\n\r\n    // 2015-01-30. Alessandro. @ADDED performance (time) measurement in all most time-consuming methods.\r\n    #ifdef _VAA3D_TERAFLY_PLUGIN_MODE\r\n    TERAFLY_TIME_STOP(TiffInitData, tf::CPU, tf::strprintf(\"generated fake data for 3D tiff \\\"%s\\\"\", completeFilename));\r\n    TERAFLY_TIME_RESTART(TiffInitData);\r\n    #endif\r\n\r\n    //disable warning and error handlers to avoid messages on unrecognized tags\r\n    TIFFSetWarningHandler(0);\r\n    TIFFSetErrorHandler(0);\r\n\r\n    TIFF *output;\r\n\r\n    iim::sint64 expectedSize = ((iim::sint64) sz0) * ((iim::sint64) sz1) * ((iim::sint64) sz2) * ((iim::sint64) sz3) * ((iim::sint64) datatype);\r\n\r\n    if ( bigtiff || expectedSize > (4*GBSIZE) ) {\r\n        if ( (rowsPerStrip == -1 && (((iim::sint64) sz0) * ((iim::sint64) sz1)) > (4*GBSIZE)) || ((rowsPerStrip * ((iim::sint64) sz0)) > (4*GBSIZE)) )\r\n            // one strip is larger than 4GB\r\n            return ((char *) \"Too many rows per strip for this image width.\");\r\n        else\r\n            output = TIFFOpen(completeFilename,\"w8\");\r\n    }\r\n    else\r\n        output = TIFFOpen(completeFilename,\"w\");\r\n\r\n\r\n    if (!output) {\r\n        delete completeFilename;\r\n        return ((char *) \"Cannot open the file.\");\r\n    }\r\n\r\n    check = TIFFSetField(output, TIFFTAG_IMAGEWIDTH, XSIZE);\r\n    if (!check) {\r\n        delete completeFilename;\r\n        return ((char *) \"Cannot set the image width.\");\r\n    }\r\n\r\n    check = TIFFSetField(output, TIFFTAG_IMAGELENGTH, YSIZE);\r\n    if (!check) {\r\n        delete completeFilename;\r\n        return ((char *) \"Cannot set the image height.\");\r\n    }\r\n\r\n    check = TIFFSetField(output, TIFFTAG_BITSPERSAMPLE, bpp);\r\n    if (!check) {\r\n        delete completeFilename;\r\n        return ((char *) \"Cannot set the image bit per sample.\");\r\n    }\r\n\r\n    check = TIFFSetField(output, TIFFTAG_SAMPLESPERPIXEL, spp);\r\n    if (!check) {\r\n        delete completeFilename;\r\n        return ((char *) \"Cannot set the image sample per pixel.\");\r\n    }\r\n\r\n    check = TIFFSetField(output, TIFFTAG_ROWSPERSTRIP, (rowsPerStrip == -1) ? YSIZE : (uint32)rowsPerStrip);\r\n    if (!check) {\r\n        delete completeFilename;\r\n        return ((char *) \"Cannot set the image rows per strip.\");\r\n    }\r\n\r\n    check = TIFFSetField(output, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\r\n    if (!check) {\r\n        delete completeFilename;\r\n        return ((char *) \"Cannot set the image orientation.\");\r\n    }\r\n\r\n    check = TIFFSetField(output, TIFFTAG_COMPRESSION, compressed ? COMPRESSION_LZW : COMPRESSION_NONE);\r\n    if (!check) {\r\n        delete completeFilename;\r\n        return ((char *) \"Cannot set the compression tag.\");\r\n    }\r\n\r\n    check = TIFFSetField(output, TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG);\r\n    if (!check) {\r\n        delete completeFilename;\r\n        return ((char *) \"Cannot set the planarconfig tag.\");\r\n    }\r\n\r\n    if ( spp == 1 )\r\n        check = TIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\r\n    else // spp == 3\r\n        check = TIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\r\n    if (!check) {\r\n        delete completeFilename;\r\n        return ((char *) \"Cannot set the photometric tag.\");\r\n    }\r\n\r\n    /* We are writing single page of the multipage file */\r\n    check = TIFFSetField(output, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE);\r\n    if (!check) {\r\n        delete completeFilename;\r\n        return ((char *) \"Cannot set the subfiletype tag.\");\r\n    }\r\n\r\n    check = TIFFSetField(output, TIFFTAG_PAGENUMBER, 0, Npages);\r\n    if (!check) {\r\n        delete completeFilename;\r\n        return ((char *) \"Cannot set the page number.\");\r\n    }\r\n\r\n    //check = (int)TIFFWriteEncodedStrip(output, 0, fakeData, XSIZE * YSIZE);\r\n    //if (!check) {\r\n    //\tdelete completeFilename;\r\n    //\treturn ((char *) \"Cannot write encoded strip to file.\");\r\n    //   }\r\n\r\n    if ( rowsPerStrip == -1 ) {\r\n        TIFFSetDirectory(output,0);\r\n        check = TIFFWriteEncodedStrip(output, 0, fakeData, szSlice);\r\n        if (!check) {\r\n            delete completeFilename;\r\n            return ((char *) \"Cannot write encoded strip to file.\");\r\n        }\r\n    }\r\n    else {\r\n        int check,StripsPerImage,LastStripSize;\r\n        uint32 rps = (uint32)rowsPerStrip;\r\n        unsigned char *buf = fakeData;\r\n\r\n        StripsPerImage =  (YSIZE + rps - 1) / rps;\r\n        LastStripSize = YSIZE % rps;\r\n        if (LastStripSize==0)\r\n            LastStripSize=rps;\r\n\r\n        for (int i=0; i < StripsPerImage-1; i++){\r\n            check = TIFFWriteEncodedStrip(output, i, buf, spp * rps * XSIZE * (bpp/8));\r\n            if (!check) {\r\n                delete completeFilename;\r\n                return ((char *) \"Cannot write encoded strip to file.\");\r\n            }\r\n            buf = buf + spp * rps * XSIZE * (bpp/8);\r\n        }\r\n\r\n        check = TIFFWriteEncodedStrip(output, StripsPerImage-1, buf, spp * LastStripSize * XSIZE * (bpp/8));\r\n        if (!check) {\r\n            delete completeFilename;\r\n            return ((char *) \"Cannot write encoded strip to file.\");\r\n        }\r\n        //}\r\n        buf = buf + spp * LastStripSize * XSIZE * (bpp/8);\r\n    }\r\n\r\n    if(fakeData)\r\n        delete[] fakeData;\r\n\r\n    check = TIFFWriteDirectory(output);\r\n    if (!check) {\r\n        delete completeFilename;\r\n        return ((char *) \"Cannot write a new directory.\");\r\n    }\r\n\r\n    TIFFClose(output);\r\n\r\n    // 2015-01-30. Alessandro. @ADDED performance (time) measurement in all most time-consuming methods.\r\n    #ifdef _VAA3D_TERAFLY_PLUGIN_MODE\r\n    TERAFLY_TIME_STOP(TiffInitData, tf::IO, tf::strprintf(\"written initialized 3D tiff \\\"%s\\\"\", completeFilename));\r\n    #endif\r\n\r\n    delete completeFilename;\r\n\r\n    return (char *) 0;\r\n}",
    "char *initTiffFile(char *filename, unsigned int sz0, unsigned int  sz1, unsigned int  sz2, unsigned int  sz3, int datatype)\r\n{\r\n    //\r\n    uint32 XSIZE  = sz0;\r\n    uint32 YSIZE  = sz1;\r\n    uint16 Npages = sz2;\r\n    uint16 spp    = sz3;\r\n\r\n    uint16 bpp=8 * datatype;\r\n\r\n    if ( sz3 == 1 )\r\n        spp = sz3;\r\n    else if ( sz3 < 4 )\r\n        spp = 3;\r\n    else\r\n        return ((char *) \"More than 3 channels in Tiff files.\");\r\n\r\n    //\r\n    TIFF *output = NULL;\r\n\r\n    iim::sint64 expectedSize = ((iim::sint64) sz0) * ((iim::sint64) sz1) * ((iim::sint64) sz2) * ((iim::sint64) sz3) * ((iim::sint64) datatype);\r\n\r\n    if ( bigtiff || expectedSize > (4*GBSIZE) ) {\r\n        if ( (rowsPerStrip == -1 && (((iim::sint64) sz0) * ((iim::sint64) sz1)) > (4*GBSIZE)) || ((rowsPerStrip * ((iim::sint64) sz0)) > (4*GBSIZE)) )\r\n            return ((char *) \"Too many rows per strip for this image width.\");\r\n        else\r\n            output = TIFFOpen(filename,\"w8\");\r\n    }\r\n    else\r\n    {\r\n        output = TIFFOpen(filename,\"w\");\r\n    }\r\n\r\n    if (!output)\r\n    {\r\n        return ((char *) \"Cannot open the file.\");\r\n    }\r\n\r\n    //\r\n    uint32 szPage = XSIZE * YSIZE * spp * datatype;\r\n\r\n    unsigned char *img = NULL;\r\n    try\r\n    {\r\n        img = new unsigned char [szPage];\r\n        memset(img, 0, szPage);\r\n    }\r\n    catch(...)\r\n    {\r\n        return ((char *)\"fail to alloc memory\");\r\n    }\r\n\r\n    // the file has been already opened: rowsPerStrip it is not too large for this image width\r\n    if ( rowsPerStrip == -1 )\r\n    {\r\n        //\r\n        for(int slice=0; slice<Npages; slice++)\r\n        {\r\n            TIFFSetDirectory(output,slice);\r\n\r\n            TIFFSetField(output, TIFFTAG_IMAGEWIDTH, XSIZE);\r\n            TIFFSetField(output, TIFFTAG_IMAGELENGTH, YSIZE);\r\n            TIFFSetField(output, TIFFTAG_BITSPERSAMPLE, (uint16)bpp);\r\n            TIFFSetField(output, TIFFTAG_SAMPLESPERPIXEL, (uint16)spp);\r\n            TIFFSetField(output, TIFFTAG_ROWSPERSTRIP, (rowsPerStrip == -1) ? YSIZE : (uint32)rowsPerStrip);\r\n            TIFFSetField(output, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\r\n            TIFFSetField(output, TIFFTAG_COMPRESSION, compressed ? COMPRESSION_LZW : COMPRESSION_NONE);\r\n            TIFFSetField(output, TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG);\r\n            if ( spp == 1 )\r\n                TIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\r\n            else // spp == 3\r\n                TIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\r\n\r\n            // We are writing single page of the multipage file\r\n            TIFFSetField(output, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE);\r\n            TIFFSetField(output, TIFFTAG_PAGENUMBER, (uint16)slice, (uint16)Npages);\r\n\r\n            //\r\n            TIFFWriteEncodedStrip(output, 0, img, szPage);\r\n\r\n            //\r\n            TIFFWriteDirectory(output);\r\n        }\r\n    }\r\n    else\r\n    {\r\n        int StripsPerImage,LastStripSize;\r\n        uint32 rps = (uint32)rowsPerStrip;\r\n        unsigned char *buf = img;\r\n\r\n        StripsPerImage =  (YSIZE + rps - 1) / rps;\r\n        LastStripSize = YSIZE % rps;\r\n        if (LastStripSize==0)\r\n            LastStripSize=rps;\r\n\r\n        for (int i=0; i < StripsPerImage-1; i++){\r\n            TIFFWriteEncodedStrip(output, i, buf, spp * rps * XSIZE * (bpp/8));\r\n            buf = buf + spp * rps * XSIZE * (bpp/8);\r\n        }\r\n\r\n        TIFFWriteEncodedStrip(output, StripsPerImage-1, buf, spp * LastStripSize * XSIZE * (bpp/8));\r\n        buf = buf + spp * LastStripSize * XSIZE * (bpp/8);\r\n    }\r\n\r\n    //\r\n    TIFFClose(output);\r\n\r\n////    std::ifstream in(filename, std::ifstream::ate | std::ifstream::binary);\r\n////    cout<<\"save \"<<filename<<\" with the size \"<<in.tellg()<<endl;\r\n\r\n    //\r\n//    long szStack = sz0*sz1*sz2*sz3*datatype;\r\n//    unsigned char *img = NULL;\r\n//    try\r\n//    {\r\n//        img = new unsigned char [szStack];\r\n//        memset(img, 0, szStack);\r\n//    }\r\n//    catch(...)\r\n//    {\r\n//        return ((char *)\"fail to alloc memory\");\r\n//    }\r\n\r\n//    //\r\n//    writeTiff3DFile(filename, sz0, sz1, sz2, sz3, datatype, img);\r\n\r\n    //\r\n    if(img)\r\n        delete [] img;\r\n\r\n    //\r\n    return (char *) 0;\r\n}",
    "char *writeTiff3DFile(char *filename, unsigned int sz0, unsigned int  sz1, unsigned int  sz2, unsigned int  sz3, int datatype, unsigned char *img)\r\n{\r\n    //\r\n#ifdef _VAA3D_TERAFLY_PLUGIN_MODE\r\n    TERAFLY_TIME_START(TiffInitData);\r\n#endif\r\n\r\n    uint32 XSIZE  = sz0;\r\n    uint32 YSIZE  = sz1;\r\n    uint16 Npages = sz2;\r\n    uint16 spp    = sz3;\r\n\r\n    uint16 bpp=8 * datatype;\r\n\r\n    int check;\r\n\r\n    if ( sz3 == 1 )\r\n        spp = sz3;\r\n    else if ( sz3 < 4 )\r\n        spp = 3;\r\n    else\r\n        return ((char *) \"More than 3 channels in Tiff files.\");\r\n\r\n    char *completeFilename = (char *) 0;\r\n    int fname_len = (int) strlen(filename);\r\n    char *suffix = strstr(filename,\".tif\");\r\n    while ( suffix && (fname_len - (suffix-filename) > 5) )\r\n        suffix = strstr(suffix+4,\".tif\");\r\n    //if ( (suffix != 0) && (fname_len - (suffix-filename) <= 5) ) { // a substring \".tif is already at the end of the filename\r\n    if ( suffix ) { // a substring \".tif is already at the very end of the filename\r\n        completeFilename = new char[fname_len+1];\r\n        strcpy(completeFilename,filename);\r\n    }\r\n    else {\r\n        completeFilename = new char[fname_len+4+1];\r\n        strcpy(completeFilename,filename);\r\n        strcat(completeFilename,\".\");\r\n        strcat(completeFilename,TIFF3D_SUFFIX);\r\n    }\r\n\r\n\r\n    // 2015-01-30. Alessandro. @ADDED performance (time) measurement in all most time-consuming methods.\r\n#ifdef _VAA3D_TERAFLY_PLUGIN_MODE\r\n    TERAFLY_TIME_STOP(TiffInitData, tf::CPU, tf::strprintf(\"generated fake data for 3D tiff \\\"%s\\\"\", completeFilename));\r\n    TERAFLY_TIME_RESTART(TiffInitData);\r\n#endif\r\n\r\n    //disable warning and error handlers to avoid messages on unrecognized tags\r\n    TIFFSetWarningHandler(0);\r\n    TIFFSetErrorHandler(0);\r\n\r\n    TIFF *output = NULL;\r\n\r\n    iim::sint64 expectedSize = ((iim::sint64) sz0) * ((iim::sint64) sz1) * ((iim::sint64) sz2) * ((iim::sint64) sz3) * ((iim::sint64) datatype);\r\n\r\n    if ( bigtiff || expectedSize > (4*GBSIZE) ) {\r\n        if ( (rowsPerStrip == -1 && (((iim::sint64) sz0) * ((iim::sint64) sz1)) > (4*GBSIZE)) || ((rowsPerStrip * ((iim::sint64) sz0)) > (4*GBSIZE)) )\r\n            // one strip is larger than 4GB\r\n            return ((char *) \"Too many rows per strip for this image width.\");\r\n        else\r\n            output = TIFFOpen(completeFilename,\"w8\");\r\n    }\r\n    else\r\n        output = TIFFOpen(completeFilename,\"w\");\r\n\r\n\r\n    if (!output) {\r\n        delete completeFilename;\r\n        return ((char *) \"Cannot open the file.\");\r\n    }\r\n\r\n    check = TIFFSetField(output, TIFFTAG_IMAGEWIDTH, XSIZE);\r\n    if (!check) {\r\n        delete completeFilename;\r\n        return ((char *) \"Cannot set the image width.\");\r\n    }\r\n\r\n    check = TIFFSetField(output, TIFFTAG_IMAGELENGTH, YSIZE);\r\n    if (!check) {\r\n        delete completeFilename;\r\n        return ((char *) \"Cannot set the image height.\");\r\n    }\r\n\r\n    check = TIFFSetField(output, TIFFTAG_BITSPERSAMPLE, bpp);\r\n    if (!check) {\r\n        delete completeFilename;\r\n        return ((char *) \"Cannot set the image bit per sample.\");\r\n    }\r\n\r\n    check = TIFFSetField(output, TIFFTAG_SAMPLESPERPIXEL, spp);\r\n    if (!check) {\r\n        delete completeFilename;\r\n        return ((char *) \"Cannot set the image sample per pixel.\");\r\n    }\r\n\r\n    check = TIFFSetField(output, TIFFTAG_ROWSPERSTRIP, (rowsPerStrip == -1) ? YSIZE : (uint32)rowsPerStrip);\r\n    if (!check) {\r\n        delete completeFilename;\r\n        return ((char *) \"Cannot set the image rows per strip.\");\r\n    }\r\n\r\n    check = TIFFSetField(output, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\r\n    if (!check) {\r\n        delete completeFilename;\r\n        return ((char *) \"Cannot set the image orientation.\");\r\n    }\r\n\r\n    check = TIFFSetField(output, TIFFTAG_COMPRESSION, compressed ? COMPRESSION_LZW : COMPRESSION_NONE);\r\n    if (!check) {\r\n        delete completeFilename;\r\n        return ((char *) \"Cannot set the compression tag.\");\r\n    }\r\n\r\n    check = TIFFSetField(output, TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG);\r\n    if (!check) {\r\n        delete completeFilename;\r\n        return ((char *) \"Cannot set the planarconfig tTIFFSetDirectoryag.\");\r\n    }\r\n\r\n    if ( spp == 1 )\r\n        check = TIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\r\n    else // spp == 3\r\n        check = TIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\r\n    if (!check) {\r\n        delete completeFilename;\r\n        return ((char *) \"Cannot set the photometric tag.\");\r\n    }\r\n\r\n    /* We are writing single page of the multipage file */\r\n    check = TIFFSetField(output, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE);\r\n    if (!check) {\r\n        delete completeFilename;\r\n        return ((char *) \"Cannot set the subfiletype tag.\");\r\n    }\r\n\r\n    check = TIFFSetField(output, TIFFTAG_PAGENUMBER, 0, Npages);\r\n    if (!check) {\r\n        delete completeFilename;\r\n        return ((char *) \"Cannot set the page number.\");\r\n    }\r\n\r\n    //\r\n    uint32 szPage = XSIZE * YSIZE * spp * datatype;\r\n\r\n    for(int slice=0; slice<Npages; slice++)\r\n    {\r\n        TIFFSetDirectory(output,slice);\r\n\r\n        TIFFSetField(output, TIFFTAG_IMAGEWIDTH, XSIZE);\r\n        TIFFSetField(output, TIFFTAG_IMAGELENGTH, YSIZE);\r\n        TIFFSetField(output, TIFFTAG_BITSPERSAMPLE, (uint16)bpp);\r\n        TIFFSetField(output, TIFFTAG_SAMPLESPERPIXEL, (uint16)spp);\r\n        TIFFSetField(output, TIFFTAG_ROWSPERSTRIP, (rowsPerStrip == -1) ? YSIZE : (uint32)rowsPerStrip);\r\n        TIFFSetField(output, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\r\n        TIFFSetField(output, TIFFTAG_COMPRESSION, compressed ? COMPRESSION_LZW : COMPRESSION_NONE);\r\n        TIFFSetField(output, TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG);\r\n        if ( spp == 1 )\r\n            TIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\r\n        else // spp == 3\r\n            TIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\r\n        // We are writing single page of the multipage file\r\n        TIFFSetField(output, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE);\r\n        TIFFSetField(output, TIFFTAG_PAGENUMBER, (uint16)slice, (uint16)Npages);\r\n\r\n        // the file has been already opened: rowsPerStrip it is not too large for this image width\r\n        if ( rowsPerStrip == -1 )\r\n        {\r\n            //printf(\"offset ... %ld\\n\",  slice*szPage);\r\n            TIFFWriteEncodedStrip(output, 0, img + slice*szPage, szPage);\r\n\r\n//            for ( unsigned int ih = 0; ih < YSIZE; ih++ )\r\n//            {\r\n//                if ( TIFFWriteScanline(output, img, ih, 0) < 0 )\r\n//                {\r\n//                    printf(\"Error out of disk space.\\n\");\r\n//                    break;\r\n//                }\r\n//                img += XSIZE*datatype;\r\n//            }\r\n        }\r\n        else\r\n        {\r\n            int StripsPerImage,LastStripSize;\r\n            uint32 rps = (uint32)rowsPerStrip;\r\n            unsigned char *buf = img;\r\n\r\n            StripsPerImage =  (YSIZE + rps - 1) / rps;\r\n            LastStripSize = YSIZE % rps;\r\n            if (LastStripSize==0)\r\n                LastStripSize=rps;\r\n\r\n            for (int i=0; i < StripsPerImage-1; i++){\r\n                TIFFWriteEncodedStrip(output, i, buf, spp * rps * XSIZE * (bpp/8));\r\n                buf = buf + spp * rps * XSIZE * (bpp/8);\r\n            }\r\n\r\n            TIFFWriteEncodedStrip(output, StripsPerImage-1, buf, spp * LastStripSize * XSIZE * (bpp/8));\r\n            buf = buf + spp * LastStripSize * XSIZE * (bpp/8);\r\n        }\r\n\r\n        //\r\n        TIFFWriteDirectory(output);\r\n    }\r\n\r\n    //\r\n    TIFFClose(output);\r\n\r\n    // 2015-01-30. Alessandro. @ADDED performance (time) measurement in all most time-consuming methods.\r\n#ifdef _VAA3D_TERAFLY_PLUGIN_MODE\r\n    TERAFLY_TIME_STOP(TiffInitData, tf::IO, tf::strprintf(\"written initialized 3D tiff \\\"%s\\\"\", completeFilename));\r\n#endif\r\n\r\n    delete completeFilename;\r\n\r\n    //\r\n    return (char *) 0;\r\n}",
    "int loadLsm2Stack(char * filename, unsigned char * & img, long * & sz, int & datatype)\n{\n\tint berror=0;\n\t\n\tTIFF  *tif=0;\n\tint depth, width, height;\n\tshort bits, colorchannels;\n\t\n\ttif = Open_Tiff(filename,\"r\");\n\tif (!tif) \n\t{\n\t\tfprintf(stderr, \"Cannot open the specified LSM file in loadLsm2Stack(). \\n\");\n\t\treturn 1; //070805, by Hanchuan Peng\n\t}\n\t\n\tdepth = 1;\n\twhile (TIFFReadDirectory(tif))\n\t\tdepth += 1;\n\tTIFFClose(tif);\n\t\n\tprintf(\"Total # of directories is %d, half of them are thumbnails So real data have %d slices.\\n\", depth, depth/2);\n\tdepth = depth / 2;\t\t/* half the dirs are thumbnails */\n\t\n\ttif = Open_Tiff(filename,\"r\");\n\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &colorchannels); \n\tTIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bits);\n\t\n\tif (bits<=8 && bits>0) datatype=1;\n\telse if (bits<=16 && bits>0) datatype=2;\n\telse \n\t{\n\t\tfprintf(stderr, \"LSM file should not support more than 16 bits data. Check the codes in loadLsm2Stack(). \\n\");\n\t\treturn 1; //070805, by Hanchuan Peng\n\t}\n\t\n\tlong pixel_per_slice, pixel_per_channel, ntotalpixel;\n\tif (sz) {delete []sz; sz=0;}\n\tsz = new long [4]; /* reallocate the memory if the input parameter is non-null. Note that this requests the input is also an NULL point, the same to img. */\n\tif (!sz)  \n\t{\n\t\tfprintf(stderr,\"Fail to allocate memory.\\n\");\n\t\tberror = 1;\n\t\treturn berror;\n\t}\n\telse\n\t{\n\t\tsz[0] = width;\n\t\tsz[1] = height;\n\t\tsz[2] = depth;\n\t\tsz[3] = colorchannels;\n\t\tpixel_per_slice = long(width)*long(height);\n\t\tpixel_per_channel = pixel_per_slice*long(depth);\n\t\tntotalpixel = pixel_per_channel*colorchannels;\n\t}\n\t\n\tif (img) {delete []img; img=0;}\n\telse \n\t{\n\t\timg = new unsigned char [long(ntotalpixel)*long(datatype)];\n\t\tif (!img)\n\t\t{\n\t\t\tfprintf(stderr,\"Fail to allocate memory.\\n\");\n\t\t\tif (sz) {delete []sz;sz=0;}\n\t\t\tberror = 1;\n\t\t\treturn berror;\n\t\t}\n\t}\n\t\n\t// read every other directory (real data, the in between are thumbnails \n\tlong d;\n\tshort cur_colorchannels, cur_bits;\n\tint cur_width, cur_height;\n\tfor (d=0;d<depth;d++)\n\t{\n\t\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &cur_width);\n\t\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &cur_height);\n\t\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &cur_colorchannels); \n\t\tTIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &cur_bits);\n\n\t\tprintf(\"d=%ld, current width=%d, height=%d, cur_colorchannels=%d, cur_bits=%d\\n\", d, cur_width, cur_height, cur_colorchannels, cur_bits); fflush(stdout); //080301\n\n\t\tif (cur_width != width || cur_height != height || cur_colorchannels!=colorchannels || cur_bits!=bits) \n\t\t{\n\t\t\tfprintf(stderr, \"The %ld Individual image slice has a different size/colorchannel/bits from the first slice!\", d);\n\t\t\t//in this case, do nothing to read the data and leave it empty\n\t\t}\n\t\telse\n\t\t{\n\t\t\tread_lsm_slice(tif, img+long(d)*long(pixel_per_slice)*long(datatype), pixel_per_slice, pixel_per_channel, datatype);\n\t\t}\n\t\t\n\t\tif (d==depth-1)\n\t\t\tbreak; //no need to do read directory anymore once the last one is read\n\t\telse\n\t\t{ \n\t\t\tif (!TIFFReadDirectory(tif)) break;\t  /* skip the one we just read, it's a thumbnail  */\n\t\t\tif (!TIFFReadDirectory(tif)) break;\t  /* get the next slice  */\n\t\t}\n\t}\n\t\n\tTIFFClose(tif);\n\t\n\t//return (stack);\n\treturn berror;\n}",
    "int loadLsmThumbnail2Stack_middle(char * filename, unsigned char * & img, long * & sz, int & datatype)\n{\n\tint berror=0;\n\t\n\tTIFF  *tif=0;\n\tint depth, width, height;\n\tshort bits, colorchannels;\n\t\n\ttif = Open_Tiff(filename,\"r\");\n\tif (!tif) \n\t{\n\t\tfprintf(stderr, \"Cannot open the specified LSM file in loadLsm2Stack(). \\n\");\n\t\treturn 1; //070805, by Hanchuan Peng\n\t}\n\t\n\tdepth = 1;\n\twhile (TIFFReadDirectory(tif))\n\t\tdepth += 1;\n\tTIFFClose(tif);\n\t\n\tprintf(\"Total # of directories is %d, half of them are thumbnails So real data have %d slices.\\n\", depth, depth/2);\n\tdepth = depth / 2;\t\t/* half the dirs are thumbnails */\n\t\n\ttif = Open_Tiff(filename,\"r\");\n\tTIFFReadDirectory(tif); //bypass a big image and get to the first thumbnail image\n\t\n\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &colorchannels); \n\tTIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bits);\n\n\tif (bits<=8 && bits>0) datatype=1;\n\telse if (bits<=16 && bits>0) datatype=2;\n\telse \n\t{\n\t\tfprintf(stderr, \"LSM file should not support more than 16 bits data. Check the codes in loadLsm2Stack(). \\n\");\n\t\treturn 1; //070805, by Hanchuan Peng\n\t}\n\t\n\tlong pixel_per_slice, pixel_per_channel, ntotalpixel;\n\tif (sz) {delete []sz; sz=0;}\n\tsz = new long [4]; /* reallocate the memory if the input parameter is non-null. Note that this requests the input is also an NULL point, the same to img. */\n\tif (!sz)  \n\t{\n\t\tfprintf(stderr,\"Fail to allocate memory.\\n\");\n\t\tberror = 1;\n\t\treturn berror;\n\t}\n\telse\n\t{\n\t\tsz[0] = width;\n\t\tsz[1] = height;\n\t\tsz[2] = 1;\n\t\tsz[3] = colorchannels;\n\t\tpixel_per_slice = long(width)*long(height);\n\t\tpixel_per_channel = pixel_per_slice*long(sz[2]);\n\t\tntotalpixel = pixel_per_channel*colorchannels;\n\t}\n\t\n\tif (img) {delete []img; img=0;}\n\telse \n\t{\n\t\timg = new unsigned char [long(ntotalpixel)*long(datatype)];\n\t\tif (!img)\n\t\t{\n\t\t\tfprintf(stderr,\"Fail to allocate memory.\\n\");\n\t\t\tif (sz) {delete []sz;sz=0;}\n\t\t\tberror = 1;\n\t\t\treturn berror;\n\t\t}\n\t}\n\t\n\t// read every other directory (real data, the in between are thumbnails )\n\t\n\tlong d;\n\tshort cur_colorchannels, cur_bits;\n\tint cur_width, cur_height;\n\tfor (d=0;d<=int(depth/2);d++)\n\t{\n\t\tif (d<int(depth/2))\n\t\t{\n\t\t\tTIFFReadDirectory(tif); //bypass a thumbnail \n\t\t\tTIFFReadDirectory(tif); //bypass a big image\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &cur_width);\n\t\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &cur_height);\n\t\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &cur_colorchannels); \n\t\tTIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &cur_bits);\n\n\t\tprintf(\"d=%ld, current width=%d, height=%d\\n\", d, cur_width, cur_height); fflush(stdout);\n\n\t\tif (cur_width != width || cur_height != height || cur_colorchannels!=colorchannels || cur_bits!=bits) \n\t\t{\n\t\t\tfprintf(stderr, \"The %ld Individual image slice has a different size/colorchannel/bits from the first slice!\", d);\n\t\t\t//in this case, do nothing to read the data and leave it empty\n\t\t}\n\t\telse\n\t\t{\n\t\t    //note that as we onlky read one slice here, the \"img+long(d)*long(pixel_per_slice)*long(datatype)\" equals \"img\"\n\t\t\tread_lsm_slice(tif, img, pixel_per_slice, pixel_per_channel, datatype);\n\t\t}\n\t\t\n\t\tbreak; //after we read one slice, then stop;\n\t}\n\t\n\tTIFFClose(tif);\n\t\n\treturn berror;\n}",
    "int loadLsmSlice(char * filename, unsigned char * & img, long * & sz, int & datatype, long sliceno, bool b_thumbnail)\n{\n\tint berror=0;\n\t\n\tif (sliceno<-2)\n\t{\n\t\tfprintf(stderr, \"The sliceno parameter is invalid. Must not <-2: -2 to read all slices, -1 to read middle only, 0 to N-1 to read the 1 to N-1 slice. If bigger than N-1, then just read the last slice.\\n\");\n\t\treturn 1; //070805, by Hanchuan Peng\n\t}\n\t\n\tTIFF  *tif=0;\n\tint depth, width, height;\n\tshort bits, colorchannels;\n\t\n\ttif = Open_Tiff(filename,\"r\");\n\tif (!tif) \n\t{\n\t\tfprintf(stderr, \"Cannot open the specified LSM file in loadLsmSlice(). \\n\");\n\t\treturn 1; //070805, by Hanchuan Peng\n\t}\n\t\n\tdepth = 1;\n\twhile (TIFFReadDirectory(tif))\n\t\tdepth += 1;\n\tTIFFClose(tif);\n\t\n\tprintf(\"%d\\n\", depth/2);\n\t//printf(\"Total # of directories is %d, half of them are thumbnails So real data have %d slices.\\n\", depth, depth/2);\n\tdepth = depth / 2;\t\t/* half the dirs are thumbnails */\n\tif (sliceno>depth-1) sliceno=depth-1; \n\t//printf(\"slice #=%d\\n\", sliceno);\n\t\n\ttif = Open_Tiff(filename,\"r\");\n\n\tif (b_thumbnail)\n\t\tTIFFReadDirectory(tif); //by pass one big image and get to the first thumbnail image\n\n\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &colorchannels); \n\tTIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bits);\n\t\n\tif (bits<=8 && bits>0) datatype=1;\n\telse if (bits<=16 && bits>0) datatype=2;\n\telse \n\t{\n\t\tfprintf(stderr, \"LSM file should not support more than 16 bits data. Check the codes in loadLsm2Slice(). \\n\");\n\t\treturn 1; //070805, by Hanchuan Peng\n\t}\n\t\n\tlong pixel_per_slice, pixel_per_channel, ntotalpixel;\n\tif (sz) {delete []sz; sz=0;}\n\tsz = new long [4]; /* reallocate the memory if the input parameter is non-null. Note that this requests the input is also an NULL point, the same to img. */\n\tif (!sz)  \n\t{\n\t\tfprintf(stderr,\"Fail to allocate memory.\\n\");\n\t\tberror = 1;\n\t\treturn berror;\n\t}\n\telse\n\t{\n\t\tsz[0] = width;\n\t\tsz[1] = height;\n\t\tsz[2] = (sliceno==-2) ? depth : 1;\n\t\tsz[3] = colorchannels;\n\t\tpixel_per_slice = long(sz[1])*long(sz[0]);\n\t\tpixel_per_channel = pixel_per_slice*long(sz[2]);\n\t\tntotalpixel = pixel_per_channel*colorchannels;\n\t}\n\t\n\tif (img) {delete []img; img=0;}\n\telse \n\t{\n\t\timg = new unsigned char [long(ntotalpixel)*long(datatype)];\n\t\tif (!img)\n\t\t{\n\t\t\tfprintf(stderr,\"Fail to allocate memory.\\n\");\n\t\t\tif (sz) {delete []sz;sz=0;}\n\t\t\tberror = 1;\n\t\t\treturn berror;\n\t\t}\n\t}\n\t\n\t// read every other directory (real data, the in between are thumbnails \n    bool b_readnow=false;\n\tlong d;\n\tshort cur_colorchannels, cur_bits;\n\tint cur_width, cur_height;\n\tfor (d=0;d<depth;d++)\n\t{\n\t\tif (sliceno>-2)\n\t\t{\n\t\t\tif (sliceno==-1) //middle slice only\n\t\t\t{\n\t\t\t\tb_readnow=(d==int(depth/2))?true:false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tb_readnow=(d==sliceno)?true:false;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tb_readnow=true;\n\t\t}\n\n\t\tif (b_readnow)\n\t\t{\n\t\t\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &cur_width);\n\t\t\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &cur_height);\n\t\t\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &cur_colorchannels); \n\t\t\tTIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &cur_bits);\n\n\t\t\t//printf(\"d=%d, current width=%d, height=%d, cur_colorchannels=%d, cur_bits=%d\\n\", d, cur_width, cur_height, cur_colorchannels, cur_bits); fflush(stdout); //080301\n\n\t\t\tif (cur_width != width || cur_height != height || cur_colorchannels!=colorchannels || cur_bits!=bits) \n\t\t\t{\n\t\t\t\tfprintf(stderr, \"The %ld Individual image slice has a different size/colorchannel/bits from the first slice!\", d);\n\t\t\t\t//in this case, do nothing to read the data and leave it empty\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (sliceno==-2)\n\t\t\t\t{\n\t\t\t\t\tread_lsm_slice(tif, img+long(d)*long(pixel_per_slice)*long(datatype), pixel_per_slice, pixel_per_channel, datatype);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tread_lsm_slice(tif, img, pixel_per_slice, pixel_per_channel, datatype);\n\t\t\t\t\tbreak; //because only 1 read is needed in this case\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (d==depth-1)\n\t\t\tbreak; //no need to do read directory anymore once the last one is read\n\t\telse\n\t\t{ \n\t\t\tif (!TIFFReadDirectory(tif)) break;\t  /* one directory  */\n\t\t\tif (!TIFFReadDirectory(tif)) break;\t  /* another directory */\n\t\t}\n\t}\n\t\n\tTIFFClose(tif);\n\t\n\treturn berror;\n}",
    "int loadTifSlice(char * filename, unsigned char * & img, long * & sz, int & datatype, long sliceno, bool b_thumbnail)\n{\n\tint berror=0;\n\t\n\tif (sliceno<-2)\n\t{\n\t\tfprintf(stderr, \"The sliceno parameter is invalid. Must not <-2: -2 to read all slices, -1 to read middle only, 0 to N-1 to read the 1 to N-1 slice. If bigger than N-1, then just read the last slice.\\n\");\n\t\treturn 1; \n\t}\n\t\n\tTIFF  *tif=0;\n\tint depth, width, height;\n\tshort bits, colorchannels;\n\t\n\ttif = Open_Tiff(filename,\"r\");\n\tif (!tif) \n\t{\n\t\tfprintf(stderr, \"Cannot open the specified TIFF file in loadTifSlice(). \\n\");\n\t\treturn 1; \n\t}\n\t\n\tdepth = 1;\n\twhile (TIFFReadDirectory(tif))\n\t\tdepth += 1;\n\tTIFFClose(tif);\n\t\n\tprintf(\"%d\\n\", depth); //note that this sentence will be output an important info to use the pop_thumbnail php program\n\t//printf(\"Total # of directories is %d, half of them are thumbnails So real data have %d slices.\\n\", depth, depth/2);\n\t//depth = depth / 2;\t\t/* half the dirs are thumbnails */\n\tif (sliceno>depth-1) sliceno=depth-1; \n\t//printf(\"slice #=%d\\n\", sliceno);\n\t\n\ttif = Open_Tiff(filename,\"r\");\n\n\t//if (b_thumbnail) TIFFReadDirectory(tif); //by pass one big image and get to the first thumbnail image\n\n\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &colorchannels); \n\tTIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bits);\n\t\n\tif (bits<=8 && bits>0) datatype=1;\n\telse if (bits<=16 && bits>0) datatype=2;\n\telse \n\t{\n\t\tfprintf(stderr, \"TIF file should not support more than 16 bits data. Check the codes in loadTifSlice(). \\n\");\n\t\treturn 1; //070805, by Hanchuan Peng\n\t}\n\t\n\tlong pixel_per_slice, pixel_per_channel, ntotalpixel;\n\tif (sz) {delete []sz; sz=0;}\n\tsz = new long [4]; /* reallocate the memory if the input parameter is non-null. Note that this requests the input is also an NULL point, the same to img. */\n\tif (!sz)  \n\t{\n\t\tfprintf(stderr,\"Fail to allocate memory.\\n\");\n\t\tberror = 1;\n\t\treturn berror;\n\t}\n\telse\n\t{\n\t\tsz[0] = width;\n\t\tsz[1] = height;\n\t\tsz[2] = (sliceno==-2) ? depth : 1;\n\t\tsz[3] = colorchannels;\n\t\tpixel_per_slice = long(sz[1])*long(sz[0]);\n\t\tpixel_per_channel = pixel_per_slice*long(sz[2]);\n\t\tntotalpixel = pixel_per_channel*colorchannels;\n\t}\n\t\n\tif (img) {delete []img; img=0;}\n\telse \n\t{\n\t\timg = new unsigned char [long(ntotalpixel)*long(datatype)];\n\t\tif (!img)\n\t\t{\n\t\t\tfprintf(stderr,\"Fail to allocate memory.\\n\");\n\t\t\tif (sz) {delete []sz;sz=0;}\n\t\t\tberror = 1;\n\t\t\treturn berror;\n\t\t}\n\t}\n\t\n\t// read every other directory (real data, the in between are thumbnails \n    bool b_readnow=false;\n\tlong d;\n\tshort cur_colorchannels, cur_bits;\n\tint cur_width, cur_height;\n\tfor (d=0;d<depth;d++)\n\t{\n\t\tif (sliceno>-2)\n\t\t{\n\t\t\tif (sliceno==-1) //middle slice only\n\t\t\t{\n\t\t\t\tb_readnow=(d==int(depth/2))?true:false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tb_readnow=(d==sliceno)?true:false;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tb_readnow=true;\n\t\t}\n\n\t\tif (b_readnow)\n\t\t{\n\t\t\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &cur_width);\n\t\t\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &cur_height);\n\t\t\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &cur_colorchannels); \n\t\t\tTIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &cur_bits);\n\n\t\t\t//printf(\"d=%d, current width=%d, height=%d\\n\", d, cur_width, cur_height); fflush(stdout);\n\n\t\t\tif (cur_width != width || cur_height != height || cur_colorchannels!=colorchannels || cur_bits!=bits) \n\t\t\t{\n\t\t\t\tfprintf(stderr, \"The %ld Individual image slice has a different size/colorchannel/bits from the first slice!\", d);\n\t\t\t\t//in this case, do nothing to read the data and leave it empty\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (sliceno==-2)\n\t\t\t\t{\n\t\t\t\t\tread_tif_slice(tif, img+long(d)*long(pixel_per_slice)*long(datatype)*sz[3], width, height);\n\t\t\t\t\t//printf(\"Read No. %d slice.\\n\", d);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tread_tif_slice(tif, img, width, height);\n\t\t\t\t\t//printf(\"width=[%d] height=[%d] color=[%d] bits-per-sample=[%d].\\n\", width, height, cur_colorchannels, cur_bits);\n\t\t\t\t\t//printf(\"Read No. %d slice.\\n\", d);\n\t\t\t\t\t//read_directory(tif,Select_Plane(stack,d),\"Read_Stack\");\n\t\t\t\t\tbreak; //because only 1 read is needed in this case\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (d==depth-1)\n\t\t\tbreak; //no need to do read directory anymore once the last one is read\n\t\telse\n\t\t{ \n\t\t\tif (!TIFFReadDirectory(tif)) break;\t  /* one directory  */\n\t\t\t//if (!TIFFReadDirectory(tif)) break;\t  /* another directory */\n\t\t}\n\t}\n\t\n\tTIFFClose(tif);\n\t\n\t//debugging code: verification succeeds in Matlab reading code: \n\t//t=fopen('/Users/pengh/Desktop/temp/test1.dat');a=fread(t, 512*512*3, 'uint8');a=reshape(a,[3 512 512]);a=permute(a, [2 3 1]);fclose(t); imshow(a(:,:,1:3)/255)\n\t\t\t\n\t//FILE * tmp_fp=fopen(\"/Users/pengh/temp/test1.dat\", \"w\");\n\t//fwrite(img, 3, width*height,tmp_fp);\n\t//fclose(tmp_fp);\n\t\n\t\n\t//produce thumbnail if required\n\tif (b_thumbnail)\n\t{\n\t\tlong thumbsz0=128, thumbsz1=128;\n\t\tif (sz[0]>thumbsz0 || sz[1]>thumbsz1)\n\t\t{\t\n\t\t\tunsigned char * img1 = new unsigned char [long(thumbsz0)*thumbsz1*sz[2]*sz[3]*long(datatype)];\n\t\t\tunsigned char ****img4d1 = 0;\n\t\t\tnew4dpointer(img4d1, sz[3], thumbsz0, thumbsz1, sz[2], img1);\n\t\n\t\t\tunsigned char ****img4d = 0;\n\t\t\tnew4dpointer(img4d, sz[3], sz[0], sz[1], sz[2], img);\n\t\t\t\n\t\t\tdouble factor_jj=sz[1]/thumbsz1, factor_ii=sz[0]/thumbsz0;\n\t\t\tfor (long kk=0;kk<sz[2];kk++)\n\t\t\t{\n\t\t\t\tfor (long jj=0; jj<thumbsz1; jj++)\n\t\t\t\t{\n\t\t\t\t\tfor (long ii=0;ii<thumbsz0; ii++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (long cc=0;cc<sz[3];cc++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\timg4d1[kk][jj][ii][cc] = img4d[kk][long(floor(jj*factor_jj))][long(floor(ii*factor_ii))][cc];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tdelete4dpointer(img4d, sz[3], sz[0], sz[1], sz[2]);\n\t\t\tdelete4dpointer(img4d1, sz[3], thumbsz0, thumbsz1, sz[2]);\n\n\t\t\tdelete []img;\n\t\t\timg = img1;\n\t\t\tsz[0] = thumbsz0;\n\t\t\tsz[1] = thumbsz1;\n\t\t\t//sz[2] and sz[3] do not need change\n\t\t}\n\t}\n\n\t//FILE * tmp_fp=fopen(\"/Users/pengh/temp/test1.dat\", \"w\");\n\t//fwrite(img, 3, width*height,tmp_fp);\n\t//fclose(tmp_fp);\n\t\n\t//permute the data to make sure it will be output correctly\n\tunsigned char ****img4d = 0;\n\tnew4dpointer(img4d, sz[3], sz[0], sz[1], sz[2], img); //must realize this order!\n\t\n\tunsigned char * img1 = new unsigned char [sz[0]*sz[1]*sz[2]*sz[3]];\n\tunsigned char ****img4d1 = 0;\n\tnew4dpointer(img4d1, sz[0], sz[1], sz[2], sz[3], img1);\n\t\n\tfor (long tcc=0;tcc<sz[3];tcc++)\n\t{\n\t\tfor (long tkk=0;tkk<sz[2];tkk++)\n\t\t{\n\t\t\tfor (long tjj=0;tjj<sz[1];tjj++)\n\t\t\t{\n\t\t\t\tfor (long tii=0;tii<sz[0];tii++)\n\t\t\t\t{\n\t\t\t\t\timg4d1[tcc][tkk][tjj][tii] = img4d[tkk][tjj][tii][tcc];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tdelete4dpointer(img4d1, sz[0], sz[1], sz[2], sz[3]);\n\tdelete4dpointer(img4d, sz[3], sz[0], sz[1], sz[2]);\n\tif (img) {delete []img; img=0;}\n\timg = img1;\n\t\n\treturn berror;\n}",
    "void Close_Tiff(TIFF *tif)\n{ TIFFClose(tif); }",
    "Image *Read_Image(char *file_name)\n{ TIFF  *tif;\n  Image *img;\n  int    lastone;\n\n  tif = Open_Tiff(file_name,\"r\");\n\n  img = Read_Tiff(tif,&lastone);\n\n  TIFFClose(tif);\n\n  return (img);\n}",
    "Stack *Read_Stack(char *file_name)\n{ Stack *stack;\n\n  TIFF  *tif;\n  int    depth, width, height, kind;\n\n  tif = Open_Tiff(file_name,\"r\");\n  depth = 1;\n  while (TIFFReadDirectory(tif))\n    depth += 1;\n  TIFFClose(tif);\n\n  tif = Open_Tiff(file_name,\"r\");\n  TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n  TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n\n  kind  = determine_kind(tif);\n  stack = new_stack(depth*height*width*kind,\"Read_Stack\");\n\n  stack->width  = width;\n  stack->height = height;\n  stack->depth  = depth;\n  stack->kind   = kind;\n\n  { int d;\n\n    d = 0;\n    while (1)\n      { read_directory(tif,Select_Plane(stack,d),\"Read_Stack\");\n\n        d += 1;\n        if (!TIFFReadDirectory(tif)) break;\n\n        TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n        TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n        if (width != stack->width || height != stack->height)\n          error(\"Images of stack are not of the same dimensions!\",NULL);\n\n        kind = determine_kind(tif);\n        if (kind != stack->kind)\n          error(\"Images of stack are not of the same type (GREY, GREY16, or COLOR)!\",NULL);\n      }\n  }\n\n  TIFFClose(tif);\n\n  return (stack);\n}",
    "Stack *Read_LSM_Stack(char *file_name)\n{\n  Stack *stack;\n\n  TIFF  *tif;\n  int    depth, width, height, kind;\n\n  tif = Open_Tiff(file_name,\"r\");\n  if (!tif) return 0; //070805, bu Hanchuan Peng\n\t\n  depth = 1;\n  while (TIFFReadDirectory(tif))\n    depth += 1;\n  TIFFClose(tif);\n  depth = depth / 2;\t\t/* half the dirs are thumbnails */\n\n  tif = Open_Tiff(file_name,\"r\");\n  TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n  TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n\n  kind  = determine_kind(tif);\n  stack = new_stack(depth*height*width*kind,\"Read_Stack\");\n\n  stack->width  = width;\n  stack->height = height;\n  stack->depth  = depth;\n  stack->kind   = kind;\n\n  printf(\"test1 done\\n\");\n\n  int d;\n\n  d = 0;\n  /* read every other directory (real data, the in between are thumbnails */\n  while (1)\n  {\n\t  read_directory(tif,Select_Plane(stack,d),\"Read_Stack\");\n\t  \n\t  d += 1;\n\t  if (!TIFFReadDirectory(tif)) break;\n\t  /* skip the one we just read, it's a thumbnail  */\n\n\t  if (!TIFFReadDirectory(tif)) break;\n\t  \n\t  TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n\t  TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n\t  if (width != stack->width || height != stack->height)\n          error(\"Images of stack are not of the same dimensions!\",NULL);\n\t  \n\t  kind = determine_kind(tif);\n\t  if (kind != stack->kind)\n          error(\"Images of stack are not of the same type (GREY, GREY16, or COLOR)!\",NULL);\n  }\n  \n  TIFFClose(tif);\n\n  return (stack);\n}",
    "Stack *Read_Stack_Planes(char *prefix, int num_width, int first_num)\n{ Stack *stack;\n\n  char  sname[1000];\n  int   width, height, depth, kind;\n  TIFF *tif;\n\n  depth = 0;\n  while (1)\n    { FILE *fd;\n\n      sprintf(sname,\"%s%0*d.tif\",prefix,num_width,first_num+depth);\n      if ((fd = fopen(sname,\"r\")) == NULL)\n        break;\n      fclose(fd);\n\n      depth += 1;\n    }\n\n  sprintf(sname,\"%s%0*d.tif\",prefix,num_width,first_num);\n  tif = Open_Tiff(sname,\"r\");\n  TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n  TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n\n  kind  = determine_kind(tif);\n  stack = new_stack(depth*height*width*kind,\"Read_Stack_Planes\");\n\n  stack->width  = width;\n  stack->height = height;\n  stack->depth  = depth;\n  stack->kind   = kind;\n\n  { int d;\n\n    d = 0;\n    while (1)\n      { read_directory(tif,Select_Plane(stack,d),\"Read_Stack_Planes\");\n        TIFFClose(tif);\n\n        d += 1;\n        if (d >= depth) break;\n\n        sprintf(sname,\"%s%0*d.tif\",prefix,num_width,first_num+d);\n        tif = Open_Tiff(sname,\"r\");\n        TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n        TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n        if (width != stack->width || height != stack->height)\n          error(\"Images of stack are not of the same dimensions!\",NULL);\n\n        kind = determine_kind(tif);\n        if (kind != stack->kind)\n          error(\"Images of stack are not of the same type (GREY, GREY16, or COLOR)!\",NULL);\n      }\n  }\n\n  return (stack);\n}",
    "void Write_Image(char *file_name, Image *a_image)\n{ TIFF *tif;\n\n  tif = Open_Tiff(file_name,\"w\");\n  Write_Tiff(tif,a_image);\n  TIFFClose(tif);\n}",
    "void Write_Stack(char *file_name, Stack *a_stack)\n{ TIFF *tif;\n  int   i;\n\n  tif = Open_Tiff(file_name,\"w\");\n  for (i = 0; i < a_stack->depth; i++)\n    Write_Tiff(tif,Select_Plane(a_stack,i));\n  TIFFClose(tif);\n}",
    "BMMRES BitmapIO_TIF::GetImageInfo ( BitmapInfo *fbi ) {\n     \n     //-- Get File Header\n\ttry\n\t\t{\n\t\ttif=TIFFOpen(fbi->Name(), _T(\"r\"));\n\t\t}\n\tcatch(MAXException exc)\n\t\t{\n\t\tif (tif)\n\t\t\tTIFFClose(tif);\n\t\ttif = NULL;\n\t\treturn ProcessImageIOError(fbi, BMMRES_BADFILEHEADER);\n\t\t}\n\n     //tif=TIFFReadHdr(inStream);\n     if(tif==NULL) {\n\t\tDebugPrint(\"TIFFOpen failed\\n\");\n\t\treturn (ProcessImageIOError(fbi,BMMRES_BADFILEHEADER));\n\t\t}\n     td = &tif->tif_dir;\n\n     /* Fill in appropriate info slots */\n\n     nsamp = td->td_samplesperpixel;\n     fbi->SetWidth(td->td_imagewidth);\n     fbi->SetHeight(td->td_imagelength);\n     fbi->SetAspect(1.0f);\n     //fbi->SetGamma(1.0f);\n     fbi->SetFirstFrame(0);\n\t fbi->SetStartFrame(0);\n\t\n\ttiff_error_off();\n\ttry {\n\t\tfbi->SetLastFrame(TIFFNumberOfDirectories(tif)-1);\n\t\tfbi->SetEndFrame(TIFFNumberOfDirectories(tif)-1);\n\t} catch(...) {\n\t\tfbi->SetLastFrame(0);\n\t\tfbi->SetEndFrame(0);\n\t}\n\ttiff_error_on();\n\t \n\t int type = BMM_NO_TYPE;\n\n     switch (td->td_photometric) {\n     \tcase PHOTOMETRIC_MINISWHITE:  \n\t\tcase PHOTOMETRIC_MINISBLACK:\n\t\t\tif (td->td_bitspersample == 1)\n\t     \t\ttype = BMM_LINE_ART;\n\t\t\telse if(td->td_bitspersample==16)\n     \t\t\ttype = BMM_GRAY_16;\n\t\t\telse\n     \t\t\ttype = BMM_GRAY_8;\n     \t\tbreak;\n\t\t//-- This thing was ignoring 16bit images and assuming a single alpha channel \n\t\t// GG: 08/12/02\n     \tcase PHOTOMETRIC_RGB:\n\t\t\tif(td->td_bitspersample==8)\n\t\t\t\ttype = (td->td_samplesperpixel > 3) ? BMM_TRUE_32 : BMM_TRUE_24;\n\t\t\telse if(td->td_bitspersample==16)\n\t\t\t\ttype = (td->td_samplesperpixel > 3) ? BMM_TRUE_64 : BMM_TRUE_48;\n\t\t\telse if(td->td_bitspersample==32)\n\t\t\t\ttype = BMM_REALPIX_32;\n\t\t\telse\n\t\t\t\ttype = BMM_NO_TYPE;\n     \t\tbreak;\n     \tcase PHOTOMETRIC_PALETTE:\n\t\t\ttype = BMM_PALETTED;\n     \t\tbreak;\n\t\tcase PHOTOMETRIC_LOGL:/* High dynamic range luminance */\n\t\t\ttype = BMM_LOGLUV_32;//We don't have a type for LogL, but this is a subset of LogLUV\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_LOGLUV:\n\t\t\ttype = BMM_LOGLUV_32;\n\t\t\tbreak;\n     \t}\n\n     if(type == BMM_NO_TYPE) {\n\t\tDebugPrint(\"Unknown TIF type\\n\");\n\t\treturn (ProcessImageIOError(fbi,GetString(IDS_UNKNOWN)));\n\t\t}\n\n\t fbi->SetType(type);\n\n     if (tif)\n\t\t {\n         TIFFClose(tif);\n\t\t tif=NULL;\n\t\t }\n\t\t\n     return BMMRES_SUCCESS;\n}",
    "BitmapStorage *BitmapIO_TIF::Load(BitmapInfo *fbi, Bitmap *map, BMMRES *status) {\n\n   //-- Initialize Status Optimistically\n\n   *status = BMMRES_SUCCESS;\n\n   //-- Make sure nothing weird is going on\n\n   if(openMode != BMM_NOT_OPEN) {\n      *status = ProcessImageIOError(fbi,BMMRES_INTERNALERROR);\n      return NULL;\n   }\n\n   openMode = BMM_OPEN_R;\n   loadMap  = map;\n   BitmapStorage* s = NULL;\n   try\n   {\n      s = ReadTIFFile(fbi, map->Manager(), status);\n   }\n   catch (MAXException exp)\n   {\n      if (tif)\n        TIFFClose(tif);\n      tif = NULL;\n      *status = ProcessImageIOError(fbi, BMMRES_INTERNALERROR);\n      return NULL;\n   }\n\n   if(!s)\n      return NULL;\n\n   // GG: 10/02/02 - Correction, this was bug: 312453. I'm leaving this\n   // here because I'm not sure what the intent was. However, saving this\n   // on load is not that meaningful unless the consumer has some hardcoded\n   // knowledge about this structure.\n\n   // bug fix 312452\n   // need to set the UserData in the bitmap info so that it can be \n   // extracted on the other side\n\n   fbi->AllocPiData(sizeof(UserData));\n   if( fbi->GetPiData() != NULL)\n      memcpy( fbi->GetPiData(), &UserData, sizeof(UserData));\n\n   //-- Set the storage's BitmapInfo\n\n   s->bi.CopyImageInfo(fbi);\n\n   return s;\n}",
    "BitmapStorage *BitmapIO_TIF::ReadTIFFile(BitmapInfo *fbi, BitmapManager *manager, BMMRES *status) {\n\n     BitmapStorage *s = NULL;\n\n\tint res=1;\n\n\ttif=TIFFOpen(fbi->Name(), _T(\"r\"));\n\tif (tif==NULL) {\n\t\t*status = ProcessImageIOError(fbi,BMMRES_BADFILEHEADER);\n\t\treturn(0);\n\t}\n\n\t //Multiple frames access...\n\t fbi->SetFirstFrame(0);\n\n\tint nDirs;\n\ttiff_error_off();\n\ttry {\n\t\tnDirs = TIFFNumberOfDirectories(tif);\n\t} catch (...) {\n\t\tnDirs = 1;\n\t}\n\ttiff_error_on();\n\t \n\t fbi->SetLastFrame(nDirs-1);\n\n\t int dirOff = fbi->CurrentFrame();\n\t if (TIFFSetDirectory(tif, dirOff))\n\t\tfbi->SetCurrentFrame(dirOff);\n\t else\n\t\t {\n\t\t *status = ProcessImageIOError(fbi,BMMRES_BADFRAME);\n\t\t return NULL;\n\t\t }\n\t td = &tif->tif_dir;\n\n#ifdef GEOREFSYS_UVW_MAPPING\n\t tif->tif_name = const_cast<char *>(fbi->Name());\n\t GTIFF * gtif = GeoTIFFRead(tif, td);\n\t if (gtif)\n\t {\n\t\tGeoTableItem * data = new GeoTableItem;\n\t\t\n\t\tdata->m_geoInfo = true;\n//\t\tGeoTIFFCoordSysName(gtif, UserData.name);\n\t\tdata->m_matrix = GeoTIFFModelTransform(gtif);\n\t\tdata->m_names.AddName(const_cast<TCHAR *>(fbi->Name()));\n\t\tGeoTIFFExtents(data, gtif);\n\t\tTheManager->Execute(0, (ULONG)(fbi->Name()), (ULONG)(data), 0);\n\t }\n#endif\n\n \n\twidth = td->td_imagewidth;\n\theight = td->td_imagelength;\n\tfbi->SetWidth(width);\n\tfbi->SetHeight(height);\n\tfbi->SetAspect(1.0f);\n\t//fbi->SetGamma(1.0f);\n\n\t// if we're reading in logluv data, set the data format before allocating the \n\t//decompression buffer to make sure it's the correct size.\n\t//use TIFFSetField to update dependencies...\n\n\tif (td->td_photometric == PHOTOMETRIC_LOGLUV || td->td_photometric == PHOTOMETRIC_LOGL)\n\t\t{\n\t\t//We have to reset samplesperpixel here if requesting the raw data - the Tiff \n\t\t//library manipulates this value when we set the above line, so that it is \n\t\t//expecting to give 32 bits as 16, 8, and 8, but really, we just want the raw data.\n\t\tTIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 1L);\n\t\tif (td->td_photometric == PHOTOMETRIC_LOGL)\n\t\t\tTIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_FLOAT);//request a decompressed array of floats\n\t\telse\n\t\t\tTIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_RAW);//this is significantly faster than requesting\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//data using *float* to avoid converting luv to xyz space.\n\t\t}\n\n\t//refresh dependent scanlinesize.\n\t//tif->tif_scanlinesize = TIFFScanlineSize(tif);\n\n\tnsamp = td->td_samplesperpixel;\n\t//-- Bad Assumption (GG: 08/12/02)\n\t//if (nsamp>4)\n\t//\tnsamp = 4;\t\t\n\n\tload_alpha = (nsamp > 3) ? TRUE : FALSE;\n\n\n\t/* allocate decompression buffer memory */ \n\tPixelBuf8 lbuf(tif->tif_scanlinesize);\n\tloadbuf = lbuf.Ptr();\n\n\t switch (td->td_photometric) {\n     \tcase PHOTOMETRIC_MINISWHITE:\n\t\tcase PHOTOMETRIC_MINISBLACK:\n\t\t\tif(td->td_bitspersample == 1) {\n\t     \t\tfbi->SetType(BMM_LINE_ART); \t\n\t\t \t\ts = TifReadLineArt(fbi, manager); \n\t\t\t} else {\n\t\t\t\t//-- Assumed if it ain't 1 it must be 8. What about 16? GG:08/12/02\n\t\t\t\tif (td->td_bitspersample == 16) {\n     \t\t\t\tfbi->SetType(BMM_GRAY_16);\n\t\t\t\t\ts = TifReadGrayScale16(fbi,manager); \n\t\t\t\t} else {\n\t\t\t\t\tfbi->SetType(BMM_GRAY_8);\n     \t\t\t\ts = TifReadGrayScale(fbi, manager); \n\t\t\t\t}\n\t\t\t}\n     \t\tbreak;\n     \tcase PHOTOMETRIC_RGB:\n\t\t\tif (td->td_bitspersample == 8)\n     \t\t\tfbi->SetType(BMM_TRUE_32);\n\t\t\telse if (td->td_bitspersample == 16)\n\t\t\t\tfbi->SetType(BMM_TRUE_64);\n\t\t\telse\n\t\t\t\tfbi->SetType(BMM_NO_TYPE);\n     \t\tif (td->td_planarconfig==PLANARCONFIG_SEPARATE)\n     \t\t\ts = TifReadPlanarRGB(fbi, manager);\n     \t\telse \n     \t\t\ts = TifReadChunkyRGB(fbi, manager);\n     \t\tbreak;\n     \tcase PHOTOMETRIC_PALETTE:\n\t\t\tfbi->SetType(BMM_PALETTED);\n     \t\ts = TifReadColPal(fbi, manager); \n     \t\tbreak;\n\t\tcase PHOTOMETRIC_LOGL:\n\t\t\tfbi->SetType(BMM_LOGLUV_32);\n\t\t\ts = TifReadLogLUV(fbi, manager);\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_LOGLUV:\n\t\t\tfbi->SetType(BMM_LOGLUV_32);\n\t\t\ts = TifReadLogLUV(fbi, manager);\n\t\t\tbreak;\n     \t}\n\n#ifdef GEOREFSYS_UVW_MAPPING \n\t\t GeoTIFFClose(gtif);\n#endif\n\n\tif (tif)\n\t\t{\n\t\tTIFFClose(tif);\n\t\ttif=NULL;\n\t\t}\n     if(s)\n        return s;\n\n     //-- If we get here, something went wrong!\n\n\t*status = ProcessImageIOError(fbi,GetString(IDS_READ_ERROR));\n     return NULL;\n\n}",
    "BMMRES BitmapIO_TIF::Write(int frame) {\n     \n\t//-- If we haven't gone through an OpenOutput(), leave\n\n\tif (openMode != BMM_OPEN_W)\n\t\treturn (ProcessImageIOError(&bi,BMMRES_INTERNALERROR));\n\n\t//-- Resolve Filename --------------------------------\n\n\t// Write a multiframe TIF file if UserData.lightActive has been set,\n\t// to support the Lighting Data Export utility. CA - 312242\n\tbool multiFrame = UserData.lightActive && frame != BMM_SINGLEFRAME;\t// CA - 312242\n\tif (frame == BMM_SINGLEFRAME || UserData.lightActive) {\n\t\t_tcscpy(fileName,bi.Name());\n\t} else {\t// CA - 312242\n\t\t// If lightActive is not set, then we will not do multi-frame\n\t\t// tiff files.\n\t\tif (!BMMCreateNumberedFilename(bi.Name(),frame,fileName))\n\t\t\treturn (ProcessImageIOError(&bi,BMMRES_NUMBEREDFILENAMEERROR));\n\t}\n\n    //-- Create Image File -------------------------------\n\tif (!multiFrame && tif != NULL) {\t\t// CA - 312242\n\t\t// If we aren't using multiframe, then close any open file\n\t\tTIFFClose(tif);\n\t\ttif = NULL;\n\t}\n\n\t// Open the file, if it isn't open\n\tif (!tif) {\t\t\t// CA - 312242\n\t\ttry {\n\t\t\ttif = TIFFOpen(fileName, _T(\"w\"));\n\t\t} catch (MAXException exp) {\n\t\t\tif (tif)\n\t\t\t\tTIFFClose(tif);\n\t\t\ttif=NULL;\n\t\t\treturn ProcessImageIOError(&bi, BMMRES_CANTSTORAGE);\n\t\t}\n\t\tif (!tif)\n\t\t\treturn ProcessImageIOError(&bi, BMMRES_IOERROR);\n\t}\n\n\tif (tif) {\t\t\t// CA - 312242\n\t\tif (tif->tif_name == NULL) {\n\t\t\ttif->tif_name = fileName;\n\t\t}\n\n\t\t// Make sure the frames are sequential\n\t\tif (multiFrame) {\n\t\t\ttdir_t curDir = TIFFCurrentDirectory(tif);\n\t\t\tif (curDir == (unsigned short)(frame - 1) )//sequential.  This is fine.\n\t\t\t\t//flush out previous frames\n\t\t\t\tTIFFFlush(tif);\n\t\t\telse if (curDir != 65535)\n\t\t\t\treturn ProcessImageIOError(&bi, BMMRES_NUMBEREDFILENAMEERROR);\n\t\t}\n\t}\n\n\tint result;\n\ttry {\n\t\tresult = SaveTIF();\n\t\tif (!multiFrame && tif != NULL) {\t\t// CA - 312242\n\t\t\tTIFFClose(tif);\n\t\t\ttif = NULL;\n\t\t}\n\t} catch (MAXException exp) {\n        if (tif)\n\t\t    TIFFClose(tif);\n\t\ttif=NULL;\n\t\treturn ProcessImageIOError(&bi, BMMRES_INTERNALERROR);\n\t}\n\t\n\n\tswitch(result) {\n\t\tcase TIF_SAVE_OK:\n\t\t\treturn BMMRES_SUCCESS;\n\t\tcase TIF_SAVE_WRITE_ERROR:\n\t\tdefault:\n\t\t\treturn (ProcessImageIOError(&bi,GetString(IDS_WRITE_ERROR)));\n\t}\n}",
    "int  BitmapIO_TIF::Close( int flag ) {\n    if ( openMode != BMM_OPEN_W )\n\t\treturn 0;\n\tif (tif)\n\t\t{\n\t\tTIFFClose(tif);\n\t\ttif = NULL;\n\t\t}\n    return 1;\n}",
    "int img_write_tzup(unsigned short *filename, IMAGE *image) {\n  TIFF *tfp;\n  int bits_per_sample, samples_per_pixel, photometric, planar_config;\n  int orientation, rows_per_strip, bytes_per_line;\n  int width, height, row, scanline, cmap_size, i;\n  char str[200], *history;\n  UCHAR *outbuf;\n  USHORT window[TOONZWINDOW_COUNT];\n  USHORT palette[TOONZPALETTE_COUNT];\n  TCM_INFO *tcm;\n  UINT tif_compression;\n\n  /* CHECK_IMAGEDLL_LICENSE_AND_GET_IMG_LICENSE_ATTR */\n\n  Silent_tiff_print_error               = 1;\n  Tiff_ignore_missing_internal_colormap = 1;\n  tfp                                   = TIFFOpen(filename, \"w\");\n  if (!tfp) {\n    /*throw \"unable to open file for output\"; , filename);*/\n    return FALSE;\n  }\n\n  switch (image->type) {\n    CASE RGB : bits_per_sample       = 8;\n    samples_per_pixel                = 4;\n    photometric                      = PHOTOMETRIC_RGB;\n    planar_config                    = PLANARCONFIG_CONTIG;\n    CASE CMAPPED : bits_per_sample   = 16;\n    samples_per_pixel                = 1;\n    photometric                      = PHOTOMETRIC_PALETTE;\n    planar_config                    = PLANARCONFIG_CONTIG;\n    CASE CMAPPED24 : bits_per_sample = 32;\n    samples_per_pixel                = 1;\n    photometric                      = PHOTOMETRIC_PALETTE;\n    planar_config                    = PLANARCONFIG_CONTIG;\n  DEFAULT:\n    /*tmsg_error(\"bad image type writing file %s\", filename);*/\n    goto bad;\n  }\n\n  orientation = ORIENTATION_BOTLEFT;\n  /*\nwidth  = image->pixmap.xsize;\nheight = image->pixmap.ysize;\n*/\n  width  = image->pixmap.xSBsize;\n  height = image->pixmap.ySBsize;\n\n  if (image->cmap.info.n_pencils && image->cmap.info.n_colors)\n    tcm = &image->cmap.info;\n  else if (image->type == CMAPPED24)\n    tcm = (TCM_INFO *)&Tcm_24_default_info;\n  else\n    tcm = (TCM_INFO *)&Tcm_new_default_info;\n\n  if (image->cmap.offset)\n    cmap_size = TCM_MIN_CMAP_BUFFER_SIZE(*tcm);\n  else\n    cmap_size = TCM_CMAP_BUFFER_SIZE(*tcm);\n  palette[0]  = (image->cmap.offset > 0) ? 4 : 3;\n  palette[1]  = image->cmap.offset;\n  palette[2]  = cmap_size <= 0xffff ? cmap_size : 0;\n  palette[3]  = 0 /* tcm->tone_offs */;\n  palette[4]  = tcm->tone_bits;\n  palette[5]  = tcm->color_offs;\n  palette[6]  = tcm->color_bits;\n  palette[7]  = tcm->pencil_offs;\n  palette[8]  = tcm->pencil_bits;\n  palette[9]  = tcm->offset_mask;\n  palette[10] = tcm->n_colors;\n  palette[11] = tcm->n_pencils;\n\n  for (i = 12; i < TOONZPALETTE_COUNT; i++) palette[i] = 0;\n\n  tif_compression = get_output_compression();\n\n  TIFFSetField(tfp, TIFFTAG_TOONZPALETTE, palette);\n  TIFFSetField(tfp, TIFFTAG_BITSPERSAMPLE, bits_per_sample);\n  TIFFSetField(tfp, TIFFTAG_SAMPLESPERPIXEL, samples_per_pixel);\n  TIFFSetField(tfp, TIFFTAG_IMAGEWIDTH, width);\n  TIFFSetField(tfp, TIFFTAG_IMAGELENGTH, height);\n  TIFFSetField(tfp, TIFFTAG_ORIENTATION, orientation);\n  TIFFSetField(tfp, TIFFTAG_PLANARCONFIG, planar_config);\n  TIFFSetField(tfp, TIFFTAG_PHOTOMETRIC, photometric);\n  TIFFSetField(tfp, TIFFTAG_COMPRESSION, tif_compression);\n\n  /*\n* NOTARE CHE VA COMPLETATA LA PARTE RELAITVA AL SETTAGGIO DELLA RISOLUZIONE\n*\n*/\n  TIFFSetField(tfp, TIFFTAG_RESOLUTIONUNIT, RESUNIT_INCH);\n  TIFFSetField(tfp, TIFFTAG_XRESOLUTION, image->pixmap.x_dpi);\n  TIFFSetField(tfp, TIFFTAG_YRESOLUTION, image->pixmap.y_dpi);\n  switch (orientation) {\n    CASE ORIENTATION_BOTLEFT\n        : __OR ORIENTATION_BOTRIGHT\n          : __OR ORIENTATION_TOPLEFT\n            : __OR ORIENTATION_TOPRIGHT\n              : if (image->pixmap.x_dpi) TIFFSetField(\n                    tfp, TIFFTAG_XPOSITION,\n                    image->pixmap.h_pos / image->pixmap.x_dpi + 8.0);\n    CASE ORIENTATION_LEFTBOT\n        : __OR ORIENTATION_RIGHTBOT\n          : __OR ORIENTATION_LEFTTOP\n            : __OR ORIENTATION_RIGHTTOP\n              : if (image->pixmap.y_dpi) TIFFSetField(\n                    tfp, TIFFTAG_XPOSITION,\n                    image->pixmap.h_pos / image->pixmap.y_dpi + 8.0);\n  }\n  /*snprintf(str, sizeof(str), \"TOONZ %s\", versione_del_software);*/\n  TIFFSetField(tfp, TIFFTAG_SOFTWARE, str);\n\n  /* Aggiungo le informazioni relative alla savebox a all'history */\n\n  window[0] = image->pixmap.xD;\n  window[1] = image->pixmap.yD;\n  window[2] = image->pixmap.xsize;\n  window[3] = image->pixmap.ysize;\n  window[4] = image->pixmap.extra_mask;\n\n  for (i = 5; i < TOONZWINDOW_COUNT - 1; i++) window[i] = 0;\n\n  window[TOONZWINDOW_COUNT - 1] = 0;\n  /*  (Img_license_attr & TA_TOONZ_EDU) != 0;*/\n\n  TIFFSetField(tfp, TIFFTAG_TOONZWINDOW, window);\n\n  history = build_history();\n  /*\nif (image->history)\n{\nswitch(check_history(image->history, history))\n{\nCASE APPEND:\nimage->history = append_history(image->history, history);\nCASE REPLACE:\nimage->history = replace_last_history(image->history, history);\nDEFAULT:\ntmsg_error(\"Internal error: bad history type\");\nabort();\n}\nfree (history);\n}\nelse\n*/\n  image->history = history;\n\n  TIFFSetField(tfp, TIFFTAG_TOONZHISTORY, image->history);\n\n  bytes_per_line = TIFFScanlineSize(tfp);\n\n  /*\n* massima lunghezza di bytes in una strip e' 8k\n* vedi Graphics File Formats pag.48\n*/\n  if (planar_config == PLANARCONFIG_CONTIG)\n    rows_per_strip = (8 * 1024) / bytes_per_line;\n  else\n    rows_per_strip = 1L;\n\n  TIFFSetField(tfp, TIFFTAG_ROWSPERSTRIP,\n               rows_per_strip == 0 ? 1L : rows_per_strip);\n\n  switch (image->type) {\n    CASE RGB : if (!write_rgb_image(image, tfp)) {\n      // tmsg_error(\"unable to write buffer to file %s\", filename);\n      goto bad;\n    }\n    CASE CMAPPED : if (!write_cmapped_image(image, tfp)) {\n      // tmsg_error(\"unable to write buffer to file %s\", filename);\n      goto bad;\n    }\n    CASE CMAPPED24 : if (!write_cmapped24_image(image, tfp)) {\n      // tmsg_error(\"unable to write buffer to file %s\", filename);\n      goto bad;\n    }\n  DEFAULT:\n    // tmsg_error(\"bad image type writing file %s\", filename);\n    goto bad;\n  }\n\n  Silent_tiff_print_error               = 0;\n  Tiff_ignore_missing_internal_colormap = 0;\n  TIFFClose(tfp);\n  return TRUE;\n\nbad:\n  Silent_tiff_print_error               = 0;\n  Tiff_ignore_missing_internal_colormap = 0;\n  TIFFClose(tfp);\n  return FALSE;\n}",
    "TImageP TImageReaderTZP::load() {\n  /*\nFILE *fp;\nif ((fp = _wfopen(getFilePath().getWideString().c_str(), L\"rb\")) == NULL)\n{\nthrow TImageException(getFilePath(),\"can't open file\");\n}\n\n//{\n//  fclose(fp);\n//  throw TImageException(getFilePath(),\"invalid file format\");\n//}\n\nTRaster32P raster(lx,ly);\nTPixel32* row;\n\nTRasterImageP rasImage(raster);\n\nTImageP image(rasImage);\n\n*/\n\n  wstring fn = getFilePath().getWideString();\n  TIFF *tfp;\n  IMAGE *image = NIL;\n  TZUP_FIELDS tzup_f;\n  // char pltname[1024];\n  USHORT *window = NIL;\n  USHORT *palette; /*  [TOONZPALETTE_COUNT] */\n  // int max_n_colors, max_n_pencils;\n\n  /*\nCHECK_IMAGEDLL_LICENSE_AND_GET_IMG_LICENSE_ATTR\nSET_READ_WITH_EXTRA\n*/\n\n  Silent_tiff_print_error               = 1;\n  Tiff_ignore_missing_internal_colormap = 1;\n  tfp                                   = TIFFOpen(fn.c_str(), \"r\");\n  if (!tfp) return TImageP();\n\n  if (!get_tzup_fields(tfp, &tzup_f)) return TImageP();\n\n  /*\nif (tzup_f.edu_file && !(Img_license_attr & TA_TOONZ_EDU))\n{\nchar str[1024];\nBUILD_EDU_ERROR_STRING(str)\ntmsg_error (str);\ngoto bad;\n}\n*/\n\n  // image = new IMAGE; // new_img();\n  // if (!image)\n  //  goto bad;\n\n  if (!TIFFGetField(tfp, TIFFTAG_TOONZPALETTE, &palette)) {\n    // image->cmap.info = Tcm_old_default_info;\n  } else {\n    //// image->cmap.info.tone_offs   = palette[3]; sempre 0\n    /*\nimage->cmap.info.tone_bits   = (UCHAR)palette[4];\nimage->cmap.info.color_offs  = (UCHAR)palette[5];\nimage->cmap.info.color_bits  = (UCHAR)palette[6];\nimage->cmap.info.pencil_offs = (UCHAR)palette[7];\nimage->cmap.info.pencil_bits = (UCHAR)palette[8];\nimage->cmap.info.offset_mask = palette[9];\nimage->cmap.info.n_tones     = 1 << palette[4];\nimage->cmap.info.n_colors    = palette[10];\nimage->cmap.info.n_pencils   = palette[11];\nimage->cmap.info.default_val = (image->cmap.info.n_tones-1) |\n                      image->cmap.info.offset_mask;\n*/\n  }\n\n  /* estendo la palette */\n\n  /*\nmax_n_colors  = 1 << image->cmap.info.color_bits;\nmax_n_pencils = 1 << image->cmap.info.pencil_bits;\nif (max_n_colors  > image->cmap.info.n_colors ||\nmax_n_pencils > image->cmap.info.n_pencils)\n{\nimage->cmap.info.n_colors  = max_n_colors;\nimage->cmap.info.n_pencils = max_n_pencils;\nimage->cmap.color_n  = image->cmap.info.n_colors;\nimage->cmap.pencil_n = image->cmap.info.n_pencils;\n}\n*/\n\n  TRasterCM16P raster(tzup_f.xsize, tzup_f.ysize);\n\n  ///===========\n  {\n    bool swapNeeded = scanline_needs_swapping(tfp);\n\n    int x0    = tzup_f.x0;\n    int y0    = tzup_f.y0;\n    int lx    = tzup_f.xSBsize;\n    int ly    = tzup_f.ySBsize;\n    int x1    = x0 + lx - 1;\n    int y1    = y0 + ly - 1;\n    int xsize = tzup_f.xsize;\n    int ysize = tzup_f.ysize;\n\n    int wrap = tzup_f.xsize;\n\n    assert(raster->getBounds().contains(TRect(x0, y0, x1, y1)));\n    raster->fillOutside(TRect(x0, y0, x1, y1), TPixelCM16(0, 0, 15));\n    raster->lock();\n    for (int y = y0; y <= y1; y++) {\n      TPixelCM16 *row = raster->pixels(y) + x0;\n      if (TIFFReadScanline(tfp, (UCHAR *)row, y - y0, 0) < 0)\n        if (swapNeeded) TIFFSwabArrayOfShort((USHORT *)row, lx);\n    }\n    raster->unlock();\n    /*\nbuf   = image->pixmap.buffer;\ndefault_val = image->cmap.info.default_val;\nfor (y = 0; y < y0; y++)\n{\npix = buf + y * wrap;\nfor (x = 0; x < xsize; x++)\n*pix++ = default_val;\n}\nfor ( ; y <= y1; y++)\n{\npix = buf + y * wrap;\nfor (x = 0; x < x0; x++)\n*pix++ = default_val;\nif (TIFFReadScanline (tf, (UCHAR *)pix, y - y0, 0) < 0)\n{\nstatic int gia_dato = FALSE;\nif ( !gia_dato)\n{\n//tmsg_error(\"bad data read on line %d\", y);\ngia_dato = TRUE;\n}\nmemset (pix, 0, lx * sizeof(*pix));\n}\nif (swap_needed)\nTIFFSwabArrayOfShort((USHORT *)pix, lx);\npix += lx;\nfor (x = x1 + 1; x < xsize; x++)\n*pix++ = default_val;\n}\nfor ( ; y < ysize; y++)\n{\npix = buf + y * wrap;\nfor (x = 0; x < xsize; x++)\n*pix++ = default_val;\n}\n*/\n  }\n  ///===========\n\n  switch (tzup_f.photometric) {\n    CASE PHOTOMETRIC_MINISBLACK : __OR PHOTOMETRIC_MINISWHITE\n                                  : __OR PHOTOMETRIC_RGB\n                                    :;  // image->type = RGB;\n\n    CASE PHOTOMETRIC_PALETTE :\n        /*\nif (tzup_f.bits_per_sample == 32)\nimage->type = CMAPPED24;\nelse\nimage->type = CMAPPED;\n*/\n\n        DEFAULT:\n        // tmsg_error(\"bad photometric interpretation in file %s\", filename);\n        // goto bad;\n        ;\n  }\n\n  // if (!get_history(tfp, &image->history))\n  //  image->history = NIL;\n\n  // image->pixmap.extra_mask = tzup_f.extra_mask;\n\n  // if (!allocate_pixmap(image, tzup_f.xsize, tzup_f.ysize))\n  // image->pixmap.buffer = new USHORT[tzup_f.xsize*tzup_f.ysize];\n  // if(!image->pixmap.buffer)\n  //  goto bad;\n\n  // image->pixmap.xD      = tzup_f.x0;\n  // image->pixmap.yD      = tzup_f.y0;\n  // image->pixmap.xSBsize = tzup_f.xSBsize;\n  // image->pixmap.ySBsize = tzup_f.ySBsize;\n\n  /*\nif (!get_image(tfp, image))\n{\n//tmsg_error(\"no image while reading file %s\", filename);\ngoto bad;\n}\nif (!get_icon(tfp, image))\n{\n//make_icon(image, ICON_WIDTH, ICON_HEIGHT);\n}\nif (image->pixmap.extra)\nif ( !get_extra (tfp, image))\n{\n//tmsg_error(\"missing extra information while reading file %s\", filename);\ngoto bad;\n}\nimage->pixmap.x_dpi = tzup_f.x_dpi;\nimage->pixmap.y_dpi = tzup_f.y_dpi;\nimage->pixmap.h_pos = tzup_f.h_pos;\n\nSilent_tiff_print_error = 0;\nTiff_ignore_missing_internal_colormap = 0;\n*/\n\n  TIFFClose(tfp);\n\n  // image->filename = 0; // strsave(filename);\n\n  // get_plt_name(filename, pltname);\n  // image->cmap.name = 0; // strsave(pltname);\n\n  assert(0);\n  return 0;\n  // TToonzImageP toonzImage(raster);\n  // return TImageP(toonzImage);\n\n  /*\nbad:\nif (image)\n{\n//free_img(image);\n}\nSilent_tiff_print_error = 0;\nTiff_ignore_missing_internal_colormap = 0;\nif (tfp)\nTIFFClose(tfp);\nreturn NIL;\n\n*/\n}",
    "IMAGE *img_read_region_tzup(unsigned short *filename, int x1, int y1, int x2,\n                            int y2, int scale) {\n  TIFF *tfp    = NIL;\n  IMAGE *image = NIL;\n  INFO_REGION region;\n  TZUP_FIELDS tzup_f;\n  char pltname[1024];\n  UCHAR *buf = NIL;\n  USHORT planarconfig;\n  int rowperstrip;\n  int xsize_out, ysize_out, clear_xsize, clear_ysize;\n  int xD_offset, yD_offset;\n  int x1_reg, y1_reg, x2_reg, y2_reg;\n  int box_x1, box_y1, box_x2, box_y2;\n  USHORT *palette; /*  [TOONZPALETTE_COUNT] */\n  int scanline_size;\n  int ret;\n  int max_n_colors, max_n_pencils;\n\n  /*\nCHECK_IMAGEDLL_LICENSE_AND_GET_IMG_LICENSE_ATTR\nSET_READ_WITH_EXTRA\n*/\n\n  Silent_tiff_print_error               = 1;\n  Tiff_ignore_missing_internal_colormap = 1;\n  tfp                                   = TIFFOpen(filename, \"r\");\n  if (!tfp) return NIL;\n\n  if (!get_tzup_fields(tfp, &tzup_f)) goto bad;\n\n  /*\nif (tzup_f.edu_file && !(Img_license_attr & TA_TOONZ_EDU))\n{\nchar str[1024];\nBUILD_EDU_ERROR_STRING(str)\ntmsg_error (str);\ngoto bad;\n}\n*/\n\n  TIFFGetField(tfp, TIFFTAG_ROWSPERSTRIP, &rowperstrip);\n\n  TIFFGetField(tfp, TIFFTAG_PLANARCONFIG, &planarconfig);\n  if (planarconfig == PLANARCONFIG_SEPARATE) {\n    // tmsg_error(\"separate buffer image in file %s not supported\n    // yet\",filename);\n    goto bad;\n  }\n\n  image = new IMAGE;  // new_img();\n  if (!image) goto bad;\n\n  if (!TIFFGetField(tfp, TIFFTAG_TOONZPALETTE, &palette)) {\n    image->cmap.info = Tcm_old_default_info;\n  } else {\n    /*image->cmap.info.tone_offs   = palette[3]; */\n    image->cmap.info.tone_bits   = (UCHAR)palette[4];\n    image->cmap.info.color_offs  = (UCHAR)palette[5];\n    image->cmap.info.color_bits  = (UCHAR)palette[6];\n    image->cmap.info.pencil_offs = (UCHAR)palette[7];\n    image->cmap.info.pencil_bits = (UCHAR)palette[8];\n    image->cmap.info.offset_mask = palette[9];\n    image->cmap.info.n_tones     = 1 << palette[4];\n    image->cmap.info.n_colors    = palette[10];\n    image->cmap.info.n_pencils   = palette[11];\n    image->cmap.info.default_val =\n        (image->cmap.info.n_tones - 1) | image->cmap.info.offset_mask;\n  }\n\n  /* estendo la palette */\n\n  max_n_colors  = 1 << image->cmap.info.color_bits;\n  max_n_pencils = 1 << image->cmap.info.pencil_bits;\n  if (max_n_colors > image->cmap.info.n_colors ||\n      max_n_pencils > image->cmap.info.n_pencils) {\n    image->cmap.info.n_colors  = max_n_colors;\n    image->cmap.info.n_pencils = max_n_pencils;\n    image->cmap.color_n        = image->cmap.info.n_colors;\n    image->cmap.pencil_n       = image->cmap.info.n_pencils;\n  }\n\n  switch (tzup_f.photometric) {\n    CASE PHOTOMETRIC_MINISBLACK : __OR PHOTOMETRIC_MINISWHITE\n                                  : __OR PHOTOMETRIC_RGB : image->type = RGB;\n\n    CASE PHOTOMETRIC_PALETTE : if (tzup_f.bits_per_sample == 32) image->type =\n        CMAPPED24;\n    else image->type = CMAPPED;\n\n  DEFAULT:\n    // tmsg_error(\"bad photometric interpretation in file %s\", filename);\n    goto bad;\n  }\n\n  x1_reg = x1 - tzup_f.x0;\n  y1_reg = y1 - tzup_f.y0;\n\n  x2_reg = x2 - tzup_f.x0;\n  y2_reg = y2 - tzup_f.y0;\n\n  xsize_out = (x2 - x1) / scale + 1;\n  ysize_out = (y2 - y1) / scale + 1;\n\n  getInfoRegion(&region, x1_reg, y1_reg, x2_reg, y2_reg, scale, tzup_f.xSBsize,\n                tzup_f.ySBsize);\n\n  xD_offset = region.x_offset;\n  yD_offset = region.y_offset;\n\n  // if (Verbose)\n  //  printInfoRegion(&region);\n\n  image->pixmap.extra_mask = tzup_f.extra_mask;\n\n  // if (!allocate_pixmap(image, xsize_out, ysize_out))\n  image->pixmap.buffer = new USHORT[xsize_out * ysize_out];\n  if (image->pixmap.buffer) goto bad;\n\n  if (TRUE /* x1 != 0 || x2 != tzup_f.xsize - 1 ||\n             y1 != 0 || y2 != tzup_f.ysize - 1 */) {\n    clear_xsize = xsize_out;\n    clear_ysize = ysize_out;\n    if (image->type == CMAPPED)\n      clear_image_region_buffer_16(image->pixmap.buffer, 0, 0, clear_xsize,\n                                   clear_ysize, xsize_out,\n                                   image->cmap.info.offset_mask + 15);\n    else if (image->type == CMAPPED24)\n      clear_image_region_buffer_24((ULONG *)image->pixmap.buffer, 0, 0,\n                                   clear_xsize, clear_ysize, xsize_out, 255);\n    else\n      abort();\n  } else {\n    clear_xsize = 0;\n    clear_ysize = 0;\n  }\n  if (Verbose) {\n    printf(\"Clear xsize/xsize_out: %d/%d in %d:\\n\", clear_xsize, xsize_out,\n           tzup_f.xsize);\n    printf(\"Clear ysize/ysize_out: %d/%d in %d:\\n\", clear_ysize, ysize_out,\n           tzup_f.ysize);\n  }\n  if (image->pixmap.extra)\n    clear_extra_region(image->pixmap.extra, 0, 0, clear_xsize, clear_ysize,\n                       xsize_out, 0);\n  box_x1 = tzup_f.x0;\n  box_y1 = tzup_f.y0;\n  box_x2 = tzup_f.x0 + tzup_f.xSBsize - 1;\n  box_y2 = tzup_f.y0 + tzup_f.ySBsize - 1;\n  if (x1 > box_x2 || x2 < box_x1 || y1 > box_y2 || y2 < box_y1) {\n    image->pixmap.xsize   = xsize_out;\n    image->pixmap.ysize   = ysize_out;\n    image->pixmap.xSBsize = xsize_out;\n    image->pixmap.ySBsize = ysize_out;\n    image->pixmap.xD      = 0;\n    image->pixmap.yD      = 0;\n    image->pixmap.x_dpi   = tzup_f.x_dpi;\n    image->pixmap.y_dpi   = tzup_f.y_dpi;\n    image->pixmap.h_pos   = tzup_f.h_pos;\n    image->filename       = strsave(filename);\n    get_plt_name(filename, pltname);\n    image->cmap.name = strsave(pltname);\n    goto ok;\n  }\n  image->pixmap.xD      = xD_offset;\n  image->pixmap.yD      = yD_offset;\n  image->pixmap.xSBsize = region.scanNcol;\n  image->pixmap.ySBsize = region.scanNrow;\n\n  /* Buffer per la scanline */\n  scanline_size = TIFFScanlineSize(tfp);\n  TMALLOC(buf, scanline_size)\n  if (!buf) goto bad;\n\n  switch (image->type) {\n    CASE CMAPPED : ret = read_region_tzup_16(\n                       image, tfp, filename, &region, scale, buf, scanline_size,\n                       rowperstrip, xsize_out, xD_offset, yD_offset);\n    CASE CMAPPED24\n        : ret = read_region_tzup_24(image, tfp, filename, &region, scale, buf,\n                                    scanline_size, rowperstrip, xsize_out,\n                                    xD_offset, yD_offset);\n  DEFAULT:\n    ret = FALSE;\n    abort();\n  }\n  if (!ret) goto bad;\n\n  image->pixmap.x_dpi = tzup_f.x_dpi;\n  image->pixmap.y_dpi = tzup_f.y_dpi;\n  image->pixmap.h_pos = tzup_f.h_pos;\n\n  image->filename = strsave(filename);\n  get_plt_name(filename, pltname);\n  image->cmap.name = strsave(pltname);\n\n  if (!get_icon(tfp, image)) make_icon(image, ICON_WIDTH, ICON_HEIGHT);\n\n  if (image->pixmap.extra) {\n    ret = read_region_extra(image, tfp, filename, &region, scale, buf,\n                            xsize_out, xD_offset, yD_offset);\n    if (!ret) goto bad;\n  }\n\nok:\n  Silent_tiff_print_error               = 0;\n  Tiff_ignore_missing_internal_colormap = 0;\n  TIFFClose(tfp);\n  TFREE(buf);\n  return image;\n\nbad:\n  if (image) free_img(image);\n  Silent_tiff_print_error               = 0;\n  Tiff_ignore_missing_internal_colormap = 0;\n  TIFFClose(tfp);\n  TFREE(buf);\n  return NIL;\n}",
    "IMAGE *img_read_tzup_info(unsigned short *filename) {\n  TIFF *tfp;\n  IMAGE *image = NIL;\n  TZUP_FIELDS tzup_f;\n  USHORT *palette; /*  [TOONZPALETTE_COUNT] */\n  int max_n_colors, max_n_pencils;\n\n  /* CHECK_IMAGEDLL_LICENSE_AND_GET_IMG_LICENSE_ATTR */\n\n  Silent_tiff_print_error               = 1;\n  Tiff_ignore_missing_internal_colormap = 1;\n\n  tfp = TIFFOpen((wchar_t *)filename, \"r\");\n  if (!tfp) goto bad;\n\n  if (!get_tzup_fields(tfp, &tzup_f)) goto bad;\n\n  /*if (tzup_f.edu_file && !(Img_license_attr & TA_TOONZ_EDU))\n{\nchar str[1024];\nBUILD_EDU_ERROR_STRING(str)\ntmsg_warning (str);\n}\n*/\n\n  image = new IMAGE;  // new_img();\n  if (!image) goto bad;\n\n  if (!TIFFGetField(tfp, TIFFTAG_TOONZPALETTE, &palette)) {\n    image->cmap.info = Tcm_old_default_info;\n  } else {\n    /*image->cmap.info.tone_offs   = palette[3]; */\n    image->cmap.info.tone_bits   = (UCHAR)palette[4];\n    image->cmap.info.color_offs  = (UCHAR)palette[5];\n    image->cmap.info.color_bits  = (UCHAR)palette[6];\n    image->cmap.info.pencil_offs = (UCHAR)palette[7];\n    image->cmap.info.pencil_bits = (UCHAR)palette[8];\n    image->cmap.info.offset_mask = palette[9];\n    image->cmap.info.n_tones     = 1 << palette[4];\n    image->cmap.info.n_colors    = palette[10];\n    image->cmap.info.n_pencils   = palette[11];\n    image->cmap.info.default_val =\n        (image->cmap.info.n_tones - 1) | image->cmap.info.offset_mask;\n  }\n\n  /* estendo la palette */\n\n  max_n_colors  = 1 << image->cmap.info.color_bits;\n  max_n_pencils = 1 << image->cmap.info.pencil_bits;\n  if (max_n_colors > image->cmap.info.n_colors ||\n      max_n_pencils > image->cmap.info.n_pencils) {\n    image->cmap.info.n_colors  = max_n_colors;\n    image->cmap.info.n_pencils = max_n_pencils;\n    image->cmap.color_n        = image->cmap.info.n_colors;\n    image->cmap.pencil_n       = image->cmap.info.n_pencils;\n  }\n\n  switch (tzup_f.photometric) {\n    CASE PHOTOMETRIC_MINISBLACK : __OR PHOTOMETRIC_MINISWHITE\n                                  : __OR PHOTOMETRIC_RGB : image->type = RGB;\n\n    CASE PHOTOMETRIC_PALETTE : if (tzup_f.bits_per_sample == 32) image->type =\n        CMAPPED24;\n    else image->type = CMAPPED;\n\n  DEFAULT:\n    // tmsg_error(\"bad photometric interpretation in file %s\", filename);\n    goto bad;\n  }\n  image->pixmap.extra_mask = tzup_f.extra_mask;\n\n  if (!get_history(tfp, &image->history)) {\n    image->history = NIL;\n  }\n  image->pixmap.xsize   = tzup_f.xsize;\n  image->pixmap.ysize   = tzup_f.ysize;\n  image->pixmap.xD      = tzup_f.x0;\n  image->pixmap.yD      = tzup_f.y0;\n  image->pixmap.xSBsize = tzup_f.xSBsize;\n  image->pixmap.ySBsize = tzup_f.ySBsize;\n  image->pixmap.x_dpi   = tzup_f.x_dpi;\n  image->pixmap.y_dpi   = tzup_f.y_dpi;\n  image->pixmap.h_pos   = tzup_f.h_pos;\n\n  Silent_tiff_print_error               = 0;\n  Tiff_ignore_missing_internal_colormap = 0;\n  TIFFClose(tfp);\n  return image;\n\nbad:\n  if (image) {\n    // free_img(image);\n  }\n  Silent_tiff_print_error               = 0;\n  Tiff_ignore_missing_internal_colormap = 0;\n  if (tfp) TIFFClose(tfp);\n  return NIL;\n}",
    "IMAGE *img_read_tzup_icon(char *filename) {\n  TIFF *tfp;\n  IMAGE *image = NIL;\n  TZUP_FIELDS tzup_f;\n  char pltname[1024];\n  USHORT *palette; /*  [TOONZPALETTE_COUNT] */\n  int max_n_colors, max_n_pencils;\n\n  Silent_tiff_print_error               = 1;\n  Tiff_ignore_missing_internal_colormap = 1;\n  tfp                                   = TIFFOpen(filename, \"r\");\n  if (!tfp) return NIL;\n\n  if (!get_tzup_fields(tfp, &tzup_f)) goto bad;\n\n  image = new_img();\n  if (!image) goto bad;\n\n  image->type           = (tzup_f.bits_per_sample == 32) ? CMAPPED24 : CMAPPED;\n  image->pixmap.xsize   = tzup_f.xsize;\n  image->pixmap.ysize   = tzup_f.ysize;\n  image->pixmap.xSBsize = tzup_f.xSBsize;\n  image->pixmap.ySBsize = tzup_f.ySBsize;\n  image->pixmap.xD      = tzup_f.x0;\n  image->pixmap.yD      = tzup_f.y0;\n\n  get_plt_name(filename, pltname);\n  image->cmap.name = strsave(pltname);\n\n  if (!TIFFGetField(tfp, TIFFTAG_TOONZPALETTE, &palette)) {\n    image->cmap.info = Tcm_old_default_info;\n  } else {\n    /*image->cmap.info.tone_offs   = palette[3]; */\n    image->cmap.info.tone_bits   = palette[4];\n    image->cmap.info.color_offs  = palette[5];\n    image->cmap.info.color_bits  = palette[6];\n    image->cmap.info.pencil_offs = palette[7];\n    image->cmap.info.pencil_bits = palette[8];\n    image->cmap.info.offset_mask = palette[9];\n    image->cmap.info.n_tones     = 1 << palette[4];\n    image->cmap.info.n_colors    = palette[10];\n    image->cmap.info.n_pencils   = palette[11];\n    image->cmap.info.default_val =\n        (image->cmap.info.n_tones - 1) | image->cmap.info.offset_mask;\n  }\n\n  /* estendo la palette */\n\n  max_n_colors  = 1 << image->cmap.info.color_bits;\n  max_n_pencils = 1 << image->cmap.info.pencil_bits;\n  if (max_n_colors > image->cmap.info.n_colors ||\n      max_n_pencils > image->cmap.info.n_pencils) {\n    image->cmap.info.n_colors  = max_n_colors;\n    image->cmap.info.n_pencils = max_n_pencils;\n    image->cmap.color_n        = image->cmap.info.n_colors;\n    image->cmap.pencil_n       = image->cmap.info.n_pencils;\n  }\n\n  if (!get_icon(tfp, image)) {\n    // tmsg_error(\"unable to read icon image of file %s\", filename);\n    goto bad;\n  }\n  Silent_tiff_print_error               = 0;\n  Tiff_ignore_missing_internal_colormap = 0;\n  TIFFClose(tfp);\n  return image;\n\nbad:\n  if (image) free_img(image);\n  Silent_tiff_print_error               = 0;\n  Tiff_ignore_missing_internal_colormap = 0;\n  TIFFClose(tfp);\n  return NIL;\n}",
    "TifReader::~TifReader() {\n  if (m_tiff) TIFFClose(m_tiff);\n\n  if (m_tmpRas) m_tmpRas->unlock();\n\n  delete m_info.m_properties;\n}",
    "static bool save_tiff(const char *fn, TexImage32 *img, int chan_cnt, unsigned char *app_data, unsigned int app_data_len)\n{\n  G_ASSERTF_RETURN(chan_cnt == 3 || chan_cnt == 4, false, \"%s: unsupported chan_cnt=%d\", fn, chan_cnt);\n  file_ptr_t fp = df_open(fn, DF_CREATE | DF_WRITE);\n  TIFF *tif = TIFFClientOpen(fn, \"w\", reinterpret_cast<thandle_t>(fp), &tiff_ReadProc, &tiff_WriteProc, &tiff_SeekProc,\n    &tiff_CloseProc, &tiff_SizeProc, &tiff_nullMapProc, &tiff_nullUnmapProc);\n\n  if (!tif)\n  {\n    logerr(\"Could create TIFF <%s> writing\", fn);\n    return false;\n  }\n\n  int rows = img->h;\n  while (rows > 4 && int64_t(img->w) * rows * chan_cnt > (128 << 10))\n    rows /= 2;\n\n  // We need to set some values for basic tags before we can add any data\n  TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, img->w);\n  TIFFSetField(tif, TIFFTAG_IMAGELENGTH, img->h);\n  TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8);\n  TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, chan_cnt);\n  if (chan_cnt > 3)\n  {\n    uint16_t sampleinfo[16];\n    for (int i = 0; i < chan_cnt - 3; i++) //-V1008\n      sampleinfo[i] = EXTRASAMPLE_UNSPECIFIED;\n    TIFFSetField(tif, TIFFTAG_EXTRASAMPLES, chan_cnt - 3, sampleinfo);\n  }\n  TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n  TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, rows);\n  TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_LZW);\n  TIFFSetField(tif, TIFFTAG_PREDICTOR, 2);\n\n  TIFFSetField(tif, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);\n  TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\n  TIFFSetField(tif, TIFFTAG_XRESOLUTION, 72.0);\n  TIFFSetField(tif, TIFFTAG_YRESOLUTION, 72.0);\n  TIFFSetField(tif, TIFFTAG_RESOLUTIONUNIT, RESUNIT_INCH);\n  if (app_data && app_data_len)\n    TIFFSetField(tif, TIFFTAG_IMAGEDESCRIPTION, String(0, \"%.*s\", app_data_len, app_data).str());\n\n  // Write the information to the file\n  int ht = img->h, strip = 0, y = 0;\n  char *buf = new char[img->w * chan_cnt * rows + 1];\n  while (ht > 0)\n  {\n    int h = ht > rows ? rows : ht;\n    TexPixel32 *pix = img->getPixels() + y * img->w;\n    for (char *dst = buf, *dst_e = dst + img->w * h * chan_cnt; dst < dst_e; pix++, dst += chan_cnt)\n    {\n      dst[0] = pix->r;\n      dst[1] = pix->g;\n      dst[2] = pix->b;\n      if (chan_cnt > 3)\n        dst[3] = pix->a;\n    }\n\n    TIFFWriteEncodedStrip(tif, strip, buf, img->w * h * chan_cnt);\n    ht -= h;\n    y += h;\n    strip++;\n  }\n  delete[] buf;\n\n  // Close the file\n  TIFFClose(tif);\n  return true;\n}",
    "TexImage32 *load_tiff32(IGenLoad &crd, IMemAlloc *mem, bool *out_used_alpha)\n{\n  uint32_t width, height;\n  uint16_t bps, spp;\n  TIFF *tif = TIFFClientOpen(crd.getTargetName(), \"r\", reinterpret_cast<thandle_t>(&crd), &tiff_ReadProc, &tiff_WriteProc,\n    &tiff_SeekProc, &tiff_CloseProc, &tiff_SizeProc, &tiff_nullMapProc, &tiff_nullUnmapProc);\n\n  if (!tif)\n  {\n    logerr(\"%s: could not open image\", crd.getTargetName());\n    return nullptr;\n  }\n\n  // Do whatever it is we do with the buffer -- we dump it in hex\n  if (TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width) == 0)\n  {\n    logerr(\"%s: no image width\", crd.getTargetName());\n    TIFFClose(tif);\n    return nullptr;\n  }\n  if (TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height) == 0)\n  {\n    logerr(\"%s: no image height\", crd.getTargetName());\n    TIFFClose(tif);\n    return nullptr;\n  }\n\n  // Check that it is of a type that we support\n  if (TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bps) == 0)\n  {\n    logerr(\"%s: undefined bits-per-sample\", crd.getTargetName());\n    TIFFClose(tif);\n    return nullptr;\n  }\n  if (bps != 1 && bps != 2 && bps != 4 && bps != 8 && bps != 16 && bps != 32)\n  {\n    logerr(\"%s: unsupported bits-per-sample: %d\", crd.getTargetName(), bps);\n    TIFFClose(tif);\n    return nullptr;\n  }\n\n  if (TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &spp) == 0)\n  {\n    logerr(\"%s: undefined samples-per-pixel\", crd.getTargetName());\n    TIFFClose(tif);\n    return nullptr;\n  }\n\n  if (spp != 1 && spp != 2 && spp != 3 && spp != 4)\n  {\n    logerr(\"%s: unsupported samples-per-pixel: %d\", crd.getTargetName(), spp);\n    TIFFClose(tif);\n    return nullptr;\n  }\n\n  if (spp <= 4 && bps <= 8) //-V560\n  {\n    TexImage32 *im32 = TexImage32::create(width, height, mem);\n\n    // set extra channels to EXTRASAMPLE_UNSPECIFIED to treat alpha as ordinary (non-premultiplied) channel\n    uint16_t *sampleinfo, extrasamples = 0, new_sampleinfo[16];\n    TIFFGetFieldDefaulted(tif, TIFFTAG_EXTRASAMPLES, &extrasamples, &sampleinfo);\n    for (int i = 0; i < spp - 3; i++) //-V1008\n      new_sampleinfo[i] = EXTRASAMPLE_UNSPECIFIED;\n    TIFFSetField(tif, TIFFTAG_EXTRASAMPLES, extrasamples, new_sampleinfo);\n\n    if (!TIFFReadRGBAImageOriented(tif, width, height, (unsigned *)im32->getPixels(), ORIENTATION_TOPLEFT, 0))\n    {\n      mem->free(im32);\n      TIFFClose(tif);\n      return nullptr;\n    }\n    TIFFClose(tif);\n\n    for (TexPixel32 *p = im32->getPixels(), *pe = p + width * height; p < pe; p++)\n      eastl::swap(p->b, p->r); // TexPixel32 is BGRA while TIFFRGBAImage is RGBA\n\n    if (out_used_alpha)\n    {\n      *out_used_alpha = false;\n      if (spp >= 4)\n        for (TexPixel32 *p = im32->getPixels(), *pe = p + width * height; p < pe; p++)\n          if (p->a != 255)\n          {\n            *out_used_alpha = true;\n            break;\n          }\n    }\n    return im32;\n  }\n  logerr(\"%s: unsupported samples-per-pixel=%d and bits-per-sample=%d\", crd.getTargetName(), spp, bps);\n  return nullptr;\n}",
    "virtual BaseTexture *createTex(const char *fn, int /*flg*/, int /*levels*/, const char *fn_ext, const TextureMetaData &tmd)\n  {\n    if (!fn_ext || (dd_strnicmp(fn_ext, \".tif\", 3) != 0 && dd_strnicmp(fn_ext, \".tiff\", 4) != 0))\n      return NULL;\n\n    TIFF *image = TIFFOpen(fn, \"rb\");\n    if (!image)\n    {\n      logerr(\"Cannot open TIFF file '%s'\", fn);\n      return NULL;\n    }\n\n    uint16_t spp = 1, bpp = 8, fileFormat = SAMPLEFORMAT_UINT;\n    uint32_t width = 1, height = 1;\n    TIFFGetField(image, TIFFTAG_IMAGELENGTH, &height);\n    TIFFGetField(image, TIFFTAG_IMAGEWIDTH, &width);\n    TIFFGetField(image, TIFFTAG_BITSPERSAMPLE, &bpp);\n    TIFFGetField(image, TIFFTAG_SAMPLESPERPIXEL, &spp);\n    TIFFGetField(image, TIFFTAG_SAMPLEFORMAT, &fileFormat);\n\n    struct FormatMap\n    {\n      int tiffFormat, tiffIsFloat, tiffBitsPerChannel, tiffChannels;\n      int dagorFormat, dagorIsFloat, dagorBitsPerChannel, dagorChannels;\n      bool swapRB;\n    };\n\n    const static struct FormatMap formatMap[] = {\n      {SAMPLEFORMAT_UINT, false, 1, 1, TEXFMT_L8, false, 8, 1, false},\n      {SAMPLEFORMAT_UINT, false, 8, 1, TEXFMT_L8, false, 8, 1, false},\n      {SAMPLEFORMAT_UINT, false, 8, 2, TEXFMT_R8G8, false, 8, 2, false},\n      {SAMPLEFORMAT_UINT, false, 8, 3, TEXFMT_A8R8G8B8, false, 8, 4, true},\n      {SAMPLEFORMAT_UINT, false, 8, 4, TEXFMT_A8R8G8B8, false, 8, 4, true},\n      {SAMPLEFORMAT_UINT, false, 16, 1, TEXFMT_L16, false, 16, 1, false},\n      {SAMPLEFORMAT_UINT, false, 16, 2, TEXFMT_G16R16, false, 16, 2, false},\n      {SAMPLEFORMAT_UINT, false, 16, 3, TEXFMT_A32B32G32R32F, true, 32, 4, false}, // TODO: figure out why A16B16G16R16 is not\n                                                                                   // supported?\n      {SAMPLEFORMAT_UINT, false, 16, 4, TEXFMT_A32B32G32R32F, true, 32, 4, false}, // *\n      {SAMPLEFORMAT_UINT, false, 32, 1, TEXFMT_R32UI, false, 32, 1, false},\n      {SAMPLEFORMAT_UINT, false, 32, 3, TEXFMT_A32B32G32R32UI, false, 32, 4, false},\n      {SAMPLEFORMAT_UINT, false, 32, 4, TEXFMT_A32B32G32R32UI, false, 32, 4, false},\n      {SAMPLEFORMAT_INT, false, 1, 1, TEXFMT_L8, false, 8, 1, false},\n      {SAMPLEFORMAT_INT, false, 8, 1, TEXFMT_L8, false, 8, 1, false},\n      {SAMPLEFORMAT_INT, false, 8, 2, TEXFMT_R8G8, false, 8, 2, false},\n      {SAMPLEFORMAT_INT, false, 8, 3, TEXFMT_A8R8G8B8, false, 8, 4, true},\n      {SAMPLEFORMAT_INT, false, 8, 4, TEXFMT_A8R8G8B8, false, 8, 4, true},\n      {SAMPLEFORMAT_INT, false, 16, 1, TEXFMT_L16, false, 16, 1, false},\n      {SAMPLEFORMAT_INT, false, 16, 2, TEXFMT_G16R16, false, 16, 2, false},\n      {SAMPLEFORMAT_INT, false, 16, 3, TEXFMT_A32B32G32R32F, false, 16, 4, false}, // *\n      {SAMPLEFORMAT_INT, false, 16, 4, TEXFMT_A32B32G32R32F, false, 16, 4, false}, // *\n      {SAMPLEFORMAT_INT, false, 32, 1, TEXFMT_R32UI, false, 32, 1, false},\n      {SAMPLEFORMAT_INT, false, 32, 2, TEXFMT_R32G32UI, false, 32, 2, false},\n      {SAMPLEFORMAT_INT, false, 32, 3, TEXFMT_A32B32G32R32UI, false, 32, 4, false},\n      {SAMPLEFORMAT_INT, false, 32, 4, TEXFMT_A32B32G32R32UI, false, 32, 4, false},\n      {SAMPLEFORMAT_IEEEFP, true, 16, 1, TEXFMT_R16F, true, 16, 1, false},\n      {SAMPLEFORMAT_IEEEFP, true, 16, 2, TEXFMT_G16R16F, true, 16, 2, false},\n      {SAMPLEFORMAT_IEEEFP, true, 16, 3, TEXFMT_A16B16G16R16F, true, 16, 4, false},\n      {SAMPLEFORMAT_IEEEFP, true, 16, 4, TEXFMT_A16B16G16R16F, true, 16, 4, false},\n      {SAMPLEFORMAT_IEEEFP, true, 32, 1, TEXFMT_R32F, true, 32, 1, false},\n      {SAMPLEFORMAT_IEEEFP, true, 32, 2, TEXFMT_G32R32F, true, 32, 2, false},\n      {SAMPLEFORMAT_IEEEFP, true, 32, 3, TEXFMT_A32B32G32R32F, true, 32, 4, false},\n      {SAMPLEFORMAT_IEEEFP, true, 32, 4, TEXFMT_A32B32G32R32F, true, 32, 4, false},\n    };\n\n    int formatIndex = -1;\n    for (int i = 0; i < countof(formatMap); i++)\n      if (formatMap[i].tiffFormat == fileFormat && formatMap[i].tiffBitsPerChannel == bpp && formatMap[i].tiffChannels == spp)\n      {\n        formatIndex = i;\n        break;\n      }\n\n    if (formatIndex < 0)\n    {\n      logerr(\"Unsupported TIFF format: '%s' format=%d, bpp=%d, channels=%d\", fn, fileFormat, bpp, spp);\n      TIFFClose(image);\n      return NULL;\n    }\n\n    const FormatMap &fm = formatMap[formatIndex];\n\n    BaseTexture *t = NULL;\n    BaseTexture *ref = NULL;\n    if (!tmd.baseTexName.empty())\n    {\n      TEXTUREID id = get_managed_texture_id(tmd.baseTexName);\n      if (id == BAD_TEXTUREID)\n        id = add_managed_texture(tmd.baseTexName);\n      ref = acquire_managed_tex(id);\n      if (!ref)\n      {\n        release_managed_tex(id);\n        TIFFClose(image);\n        return t;\n      }\n    }\n\n    int tiffStride = TIFFScanlineSize(image);\n    Tab<uint8_t> tiffLine(tiffStride, 0);\n    t = d3d::create_tex(NULL, width, height, fm.dagorFormat, 1, fn);\n\n    if (t)\n    {\n      apply_gen_tex_props(t, tmd);\n\n      uint8_t *data = NULL;\n      int stride = 0;\n\n      if (((Texture *)t)->lockimg((void **)&data, stride, 0, TEXLOCK_WRITE))\n      {\n        memset(data, 0x22, height * stride);\n\n        for (int y = 0; y < height; y++)\n        {\n          int idx = stride * y;\n          TIFFReadScanline(image, tiffLine.data(), y, 0);\n          if (!convert_image_line(tiffLine.data(), width, fm.tiffChannels, fm.tiffBitsPerChannel, fm.tiffIsFloat, data + idx,\n                fm.dagorChannels, fm.dagorBitsPerChannel, fm.dagorIsFloat, fm.swapRB))\n          {\n            break;\n          }\n        }\n\n        ((Texture *)t)->unlockimg();\n      }\n      else\n      {\n        G_ASSERTF(0, \"cannot lock texture\");\n        del_d3dres(t);\n        TIFFClose(image);\n        return NULL;\n      }\n    }\n\n    TIFFClose(image);\n    return t;\n  }",
    "virtual bool saveImage(BitmapMask &img, const char *fname)\n  {\n    TIFF *image;\n\n    // Open the TIFF file\n    if ((image = TIFFOpen(fname, \"w\")) == NULL)\n    {\n      debug(\"Could not open <%s> writing\", (char *)fname);\n      return false;\n    }\n\n    int rows = img.getHeight();\n    while (rows > 4 && rows * img.getWidth() * img.getBitsPerPixel() / 8 > 32768)\n      rows /= 2;\n\n    // We need to set some values for basic tags before we can add any data\n    TIFFSetField(image, TIFFTAG_IMAGEWIDTH, img.getWidth());\n    TIFFSetField(image, TIFFTAG_IMAGELENGTH, img.getHeight());\n    if (img.getBitsPerPixel() == 32)\n    {\n      TIFFSetField(image, TIFFTAG_BITSPERSAMPLE, 8);\n      TIFFSetField(image, TIFFTAG_SAMPLESPERPIXEL, img.getBitsPerPixel() / 8);\n      TIFFSetField(image, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n    }\n    else\n    {\n      TIFFSetField(image, TIFFTAG_BITSPERSAMPLE, img.getBitsPerPixel());\n      TIFFSetField(image, TIFFTAG_SAMPLESPERPIXEL, 1);\n      TIFFSetField(image, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n    }\n    TIFFSetField(image, TIFFTAG_ROWSPERSTRIP, rows);\n\n    switch (img.getBitsPerPixel())\n    {\n      case 1: TIFFSetField(image, TIFFTAG_COMPRESSION, COMPRESSION_CCITTFAX4); break;\n      case 2:\n      case 4: TIFFSetField(image, TIFFTAG_COMPRESSION, COMPRESSION_PACKBITS); break;\n      case 8:\n      case 32: TIFFSetField(image, TIFFTAG_COMPRESSION, COMPRESSION_LZW); break;\n\n      default: return false;\n    }\n\n    TIFFSetField(image, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);\n    TIFFSetField(image, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\n    TIFFSetField(image, TIFFTAG_XRESOLUTION, 72.0);\n    TIFFSetField(image, TIFFTAG_YRESOLUTION, 72.0);\n    TIFFSetField(image, TIFFTAG_RESOLUTIONUNIT, RESUNIT_INCH);\n\n    // Write the information to the file\n    int ht = img.getHeight(), strip = 0;\n    char *buf = (char *)img.getBits();\n    while (ht > 0)\n    {\n      int h = ht > rows ? rows : ht;\n      TIFFWriteEncodedStrip(image, strip, buf, img.getWidth() * rows * img.getBitsPerPixel() / 8);\n      ht -= h;\n      buf += h * img.getWidth() * img.getBitsPerPixel() / 8;\n      strip++;\n    }\n\n    // Close the file\n    TIFFClose(image);\n    debug(\"saved %dx%dx%dbit to %s\", img.getWidth(), img.getHeight(), img.getBitsPerPixel(), (char *)fname);\n    return true;\n  }",
    "static TexImage32 *load_tiff32(const char *fn, IMemAlloc *mem, bool *out_used_alpha = NULL)\n{\n  TIFF *image = TIFFOpen(fn, \"rb\");\n\n  if (!image)\n    return NULL;\n\n  uint16 spp = 0, bpp = 0, format = 0;\n  uint32 width = 1, height = 1;\n  TIFFGetField(image, TIFFTAG_IMAGELENGTH, &height);\n  TIFFGetField(image, TIFFTAG_IMAGEWIDTH, &width);\n  TIFFGetField(image, TIFFTAG_BITSPERSAMPLE, &bpp);\n  TIFFGetField(image, TIFFTAG_SAMPLESPERPIXEL, &spp);\n  TIFFGetField(image, TIFFTAG_SAMPLEFORMAT, &format);\n\n  if (format && (format != SAMPLEFORMAT_UINT && format != SAMPLEFORMAT_INT))\n  {\n    logerr(\"Invalid TIFF format, only 'integer' type is supported\");\n    TIFFClose(image);\n    return NULL;\n  }\n\n  if (bpp != 1 && bpp != 8 && bpp != 16)\n  {\n    logerr(\"Invalid TIFF format, only 1, 8 and 16-bit is supported\");\n    TIFFClose(image);\n    return NULL;\n  }\n\n  if (spp != 1 && spp != 3 && spp != 4)\n  {\n    logerr(\"Invalid TIFF format, only 1, 3 and 4 channels supported\");\n    TIFFClose(image);\n    return NULL;\n  }\n\n\n  TexImage32 *im = (TexImage32 *)mem->tryAlloc(sizeof(TexImage32) + width * height * 4);\n  if (!im)\n  {\n    TIFFClose(image);\n    return NULL;\n  }\n\n  TexPixel32 *ptr = (TexPixel32 *)(im + 1);\n  int res = TIFFReadRGBAImageOriented(image, width, height, (uint32_t *)ptr, ORIENTATION_TOPLEFT, 1);\n\n  if (!res)\n  {\n    mem->free(im);\n    TIFFClose(image);\n    return NULL;\n  }\n\n  int pixelCount = width * height;\n  uint8_t *bytePtr = (uint8_t *)ptr;\n  for (int i = 0; i < pixelCount; i++)\n  {\n    uint8_t tmp = bytePtr[0];\n    bytePtr[0] = bytePtr[2];\n    bytePtr[2] = tmp;\n    bytePtr += 4;\n  }\n\n  if (out_used_alpha)\n    *out_used_alpha = (spp == 4);\n\n  TIFFClose(image);\n\n  im->w = width;\n  im->h = height;\n\n  return im;\n}",
    "virtual bool loadImage(BitmapMask &_img, const char *folder, const char *image_name)\n  {\n    String fname;\n    makeFullPath(fname, folder, image_name, \".tif\");\n\n    PublicBitmapMask &img = static_cast<PublicBitmapMask &>(_img);\n    img.init();\n\n    TIFF *image;\n    uint16_t photo, bps, spp, fillorder;\n    uint32_t width, height;\n    tsize_t stripSize;\n    unsigned long result;\n    int stripMax;\n    char *buffer, *buffer_end, tempbyte;\n\n    // debug(\"reading image <%s>\", (char*)fname);\n    //  Open the TIFF image\n    if ((image = TIFFOpen(fname, \"r\")) == NULL)\n    {\n      debug(\"Could not open image <%s>\", (char *)fname);\n\n      // try load .tga, if exist\n      makeFullPath(fname, folder, image_name, \".tga\");\n      TexImage32 *im = ::load_tga32(fname, tmpmem);\n      if (!im)\n      {\n        debug(\"  Could not open image <%s>\", (char *)fname);\n        return false;\n      }\n      img.alloc(im->w, im->h, 32, true);\n      if (img.singleTile())\n        memcpy(img.singleTile(), (im + 1), im->w * im->h * 4);\n      else\n      {\n        logerr(\"Could not initialize image <%s>\", (char *)fname);\n        memfree(im, tmpmem);\n        return false;\n      }\n      debug(\"loaded %dx%dx%dbit from %s\", img.getWidth(), img.getHeight(), img.getBitsPerPixel(), (char *)fname);\n      memfree(im, tmpmem);\n      return true;\n    }\n\n    // Do whatever it is we do with the buffer -- we dump it in hex\n    if (TIFFGetField(image, TIFFTAG_IMAGEWIDTH, &width) == 0)\n    {\n      debug(\"Image does not define its width\");\n      TIFFClose(image);\n      return false;\n    }\n    if (TIFFGetField(image, TIFFTAG_IMAGELENGTH, &height) == 0)\n    {\n      debug(\"Image does not define its height\");\n      TIFFClose(image);\n      return false;\n    }\n\n    // Check that it is of a type that we support\n    if (TIFFGetField(image, TIFFTAG_BITSPERSAMPLE, &bps) == 0)\n    {\n      debug(\"undefined number of bits per sample\");\n      TIFFClose(image);\n      return false;\n    }\n    if (bps != 1 && bps != 4 && bps != 8 && bps != 16 && bps != 32)\n    {\n      debug(\"unsupported number of bits per sample: %d\", bps);\n      TIFFClose(image);\n      return false;\n    }\n\n    if (TIFFGetField(image, TIFFTAG_SAMPLESPERPIXEL, &spp) == 0)\n    {\n      debug(\"undefined number of samples per pixel\");\n      TIFFClose(image);\n      return false;\n    }\n\n    if (spp != 1 && spp != 3 && spp != 4)\n    {\n      debug(\"unsupported number of samples per pixel: %d\", spp);\n      TIFFClose(image);\n      return false;\n    }\n\n    // Deal with photometric interpretations\n    if (TIFFGetField(image, TIFFTAG_PHOTOMETRIC, &photo) == 0)\n    {\n      debug(\"Image has an undefined photometric interpretation\");\n      TIFFClose(image);\n      return false;\n    }\n\n    // Deal with fillorder\n    if (TIFFGetField(image, TIFFTAG_FILLORDER, &fillorder) == 0)\n      fillorder = FILLORDER_MSB2LSB;\n\n    if (spp == 3 && bps <= 8)\n    {\n      img.alloc(width, height, 32, true);\n      TIFFReadRGBAImage(image, width, height, (unsigned *)img.singleTile(), 0);\n      TIFFClose(image);\n      return true;\n    }\n\n    img.alloc(width, height, bps * spp);\n\n    // Read in the possibly multiple strips\n    stripSize = TIFFStripSize(image);\n    stripMax = TIFFNumberOfStrips(image);\n\n    if (spp == 1 && photo != PHOTOMETRIC_MINISBLACK)\n      debug(\"Fixing the photometric interpretation\");\n    if (fillorder != FILLORDER_MSB2LSB)\n      debug(\"Fixing the fillorder\");\n\n    // debug(\"width=%d bps=%d spp=%d stripSize=%d\", width, bps, spp, stripSize);\n    buffer = new char[stripSize];\n    for (int stripCount = 0, img_y = 0; stripCount < stripMax; stripCount++)\n    {\n      if ((result = TIFFReadEncodedStrip(image, stripCount, buffer, stripSize)) == -1)\n      {\n        debug(\"Read error on input strip number %d\", stripCount);\n        img.destroy();\n        TIFFClose(image);\n        delete[] buffer;\n        return false;\n      }\n      if (spp == 1 && photo != PHOTOMETRIC_MINISBLACK) // Flip bits\n        for (char *b = buffer, *be = b + result; b < be; b++)\n          *b = ~*b;\n      if (fillorder != FILLORDER_MSB2LSB) // We need to swap bits -- ABCDEFGH becomes HGFEDCBA\n        for (char *b = buffer, *be = b + result; b < be; b++)\n        {\n          tempbyte = 0;\n          if (*buffer & 128)\n            tempbyte += 1;\n          if (*buffer & 64)\n            tempbyte += 2;\n          if (*buffer & 32)\n            tempbyte += 4;\n          if (*buffer & 16)\n            tempbyte += 8;\n          if (*buffer & 8)\n            tempbyte += 16;\n          if (*buffer & 4)\n            tempbyte += 32;\n          if (*buffer & 2)\n            tempbyte += 64;\n          if (*buffer & 1)\n            tempbyte += 128;\n          *buffer = tempbyte;\n        }\n\n      int rows = result / (width * bps * spp / 8);\n      G_ASSERT(result = rows * (width * bps * spp / 8));\n\n      G_ASSERT(img_y + rows <= img.getHeight());\n      img.copyFrom(buffer, img_y, rows);\n      img_y += rows;\n    }\n    delete[] buffer;\n\n    TIFFClose(image);\n\n    debug(\"loaded %dx%dx%dbit from %s\", img.getWidth(), img.getHeight(), img.getBitsPerPixel(), (char *)fname);\n    return true;\n  }",
    "virtual bool getBitMaskProps(const char *folder, const char *image_name, int &out_w, int &out_h, int &out_bpp)\n  {\n    String fname;\n    makeFullPath(fname, folder, image_name, \".tif\");\n\n    TIFF *image;\n    uint16_t photo, bps, spp, fillorder;\n    tsize_t stripSize;\n    unsigned long result;\n    int stripMax;\n    char *buffer, *buffer_end, tempbyte;\n\n    if ((image = TIFFOpen(fname, \"r\")) == NULL)\n      return false;\n\n    if (TIFFGetField(image, TIFFTAG_IMAGEWIDTH, &out_w) == 0 || TIFFGetField(image, TIFFTAG_IMAGELENGTH, &out_h) == 0 ||\n        TIFFGetField(image, TIFFTAG_BITSPERSAMPLE, &bps) == 0 || TIFFGetField(image, TIFFTAG_SAMPLESPERPIXEL, &spp) == 0)\n    {\n      TIFFClose(image);\n      return false;\n    }\n    out_bpp = spp * bps;\n    return true;\n  }",
    "virtual bool checkBitMask(const char *folder, const char *image_name, int w, int h, int bpp)\n  {\n    String fname;\n    makeFullPath(fname, folder, image_name, \".tif\");\n\n    TIFF *image;\n    uint16_t photo, bps, spp, fillorder;\n    uint32_t width, height;\n    tsize_t stripSize;\n    unsigned long result;\n    int stripMax;\n    char *buffer, *buffer_end, tempbyte;\n\n    if ((image = TIFFOpen(fname, \"r\")) == NULL)\n      return false;\n\n    if (TIFFGetField(image, TIFFTAG_IMAGEWIDTH, &width) == 0 || TIFFGetField(image, TIFFTAG_IMAGELENGTH, &height) == 0 ||\n        TIFFGetField(image, TIFFTAG_BITSPERSAMPLE, &bps) == 0 || TIFFGetField(image, TIFFTAG_SAMPLESPERPIXEL, &spp) == 0)\n    {\n      TIFFClose(image);\n      return false;\n    }\n\n    if ((bps != 1 && bps != 4 && bps != 8 && bps != 16 && bps != 32) || (spp != 1 && spp != 3 && spp != 4) || width != w ||\n        height != h || bpp != spp * bps)\n    {\n      TIFFClose(image);\n      return false;\n    }\n    TIFFClose(image);\n    debug(\"%s confirmed: %dx%d, %d bpp\", fname.str(), w, h, bpp);\n    return true;\n  }",
    "virtual bool saveImage(BitmapMask &_img, const char *folder, const char *image_name)\n  {\n    PublicBitmapMask &img = static_cast<PublicBitmapMask &>(_img);\n    String fname;\n    makeFullPath(fname, folder, image_name, \".tif\");\n    TIFF *image;\n\n    // Open the TIFF file\n    if ((image = TIFFOpen(fname, \"w\")) == NULL)\n    {\n      debug(\"Could not open <%s> writing\", (char *)fname);\n      return false;\n    }\n\n    int rows = img.getHeight();\n    while (rows > 4 && int64_t(rows) * img.getWidth() * img.getBitsPerPixel() / 8 > 128 << 10)\n      rows /= 2;\n\n    // We need to set some values for basic tags before we can add any data\n    TIFFSetField(image, TIFFTAG_IMAGEWIDTH, img.getWidth());\n    TIFFSetField(image, TIFFTAG_IMAGELENGTH, img.getHeight());\n    if (img.isImage32())\n    {\n      TIFFSetField(image, TIFFTAG_BITSPERSAMPLE, 8);\n      TIFFSetField(image, TIFFTAG_SAMPLESPERPIXEL, img.getBitsPerPixel() / 8);\n      TIFFSetField(image, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n    }\n    else\n    {\n      TIFFSetField(image, TIFFTAG_BITSPERSAMPLE, img.getBitsPerPixel());\n      TIFFSetField(image, TIFFTAG_SAMPLESPERPIXEL, 1);\n      TIFFSetField(image, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n    }\n    TIFFSetField(image, TIFFTAG_ROWSPERSTRIP, rows);\n\n    switch (img.getBitsPerPixel())\n    {\n      case 1: TIFFSetField(image, TIFFTAG_COMPRESSION, COMPRESSION_CCITTFAX4); break;\n      case 2:\n      case 4: TIFFSetField(image, TIFFTAG_COMPRESSION, COMPRESSION_PACKBITS); break;\n      case 8:\n      case 16:\n      case 32: TIFFSetField(image, TIFFTAG_COMPRESSION, COMPRESSION_LZW); break;\n\n      default: return false;\n    }\n\n    TIFFSetField(image, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);\n    TIFFSetField(image, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\n    TIFFSetField(image, TIFFTAG_XRESOLUTION, 72.0);\n    TIFFSetField(image, TIFFTAG_YRESOLUTION, 72.0);\n    TIFFSetField(image, TIFFTAG_RESOLUTIONUNIT, RESUNIT_INCH);\n\n    // Write the information to the file\n    int ht = img.getHeight(), strip = 0, y = 0;\n    char *buf = new char[img.getWidth() * img.getBitsPerPixel() / 8 * rows];\n    while (ht > 0)\n    {\n      int h = ht > rows ? rows : ht;\n      img.copyTo(buf, y, h);\n      TIFFWriteEncodedStrip(image, strip, buf, img.getWidth() * h * img.getBitsPerPixel() / 8);\n      ht -= h;\n      y += h;\n      strip++;\n    }\n    delete[] buf;\n\n    // Close the file\n    TIFFClose(image);\n    debug(\"saved %dx%dx%dbit to %s (%d rows/strip)\", img.getWidth(), img.getHeight(), img.getBitsPerPixel(), (char *)fname, rows);\n    return true;\n  }",
    "TypedImage LoadTiff(\n    const std::string& filename\n) {\n#ifdef HAVE_LIBTIFF\n    TIFFSetWarningHandler(DummyTiffOpenHandler);\n\n    TIFF* tif = TIFFOpen(filename.c_str(),\"r\");\n    if (!tif) {\n        throw std::runtime_error(\"libtiff failed to open \" + filename);\n    }\n\n    const auto width = GetOrThrow<uint32_t>(tif, TIFFTAG_IMAGEWIDTH);\n    const auto height = GetOrThrow<uint32_t>(tif, TIFFTAG_IMAGELENGTH);\n    const auto channels = GetOrThrow<uint16_t>(tif, TIFFTAG_SAMPLESPERPIXEL);\n    const auto bits_per_channel = GetOrThrow<uint16_t>(tif, TIFFTAG_BITSPERSAMPLE);\n    const auto sample_format = GetOrDefault<uint16_t>(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT);\n    const auto planar = GetOrThrow<uint16_t>(tif, TIFFTAG_PLANARCONFIG);\n//    const auto photom = GetOrThrow<uint16_t>(tif, TIFFTAG_PHOTOMETRIC);\n\n    // comparison of unsigned with >= 0 is always true!\n    //assert(width >= 0 && height >= 0 && channels >= 0 && bits_per_channel > 0);\n\n    if(planar != PLANARCONFIG_CONTIG /*|| photom != PHOTOMETRIC_RGB*/ || bits_per_channel % 8 != 0 || !(channels == 1 || channels == 3))\n        throw std::runtime_error(\"TIFF support is currently limited. Consider contributing to image_io_tiff.cpp.\");\n\n    std::string sfmt;\n    switch(sample_format) {\n    case SAMPLEFORMAT_UINT: sfmt = (channels == 3) ? \"RGB24\" : \"GRAY8\"; break;\n    case SAMPLEFORMAT_IEEEFP: sfmt = (channels == 3) ? \"RGB96F\" : \"GRAY32F\"; break;\n    default: throw std::runtime_error(\"TIFF support is currently limited. Consider contributing to image_io_tiff.cpp.\");\n    }\n\n    TypedImage image(width, height, PixelFormatFromString(sfmt));\n    const tsize_t scanlength_bytes = TIFFScanlineSize(tif);\n    if(scanlength_bytes != tsize_t(image.pitch))\n        throw std::runtime_error(\"TIFF: unexpected scanline length\");\n\n    for (size_t row = 0; row < height; ++row) {\n        TIFFReadScanline(tif, image.RowPtr(row), row);\n    }\n\n    TIFFClose(tif);\n\n    return image;\n#else\n    PANGOLIN_UNUSED(filename);\n    throw std::runtime_error(\"Rebuild Pangolin for libtiff support.\");\n#endif\n}",
    "void close_tif()\n    {\n        if (m_tif) {\n            TIFFClose(m_tif);\n            m_tif = NULL;\n            m_rgbadata.clear();\n            m_rgbadata.shrink_to_fit();\n        }\n    }",
    "void closetif()\n    {\n        if (m_tif) {\n            write_exif_data();\n            TIFFClose(m_tif);  // N.B. TIFFClose doesn't return a status code\n            m_tif = nullptr;\n        }\n    }",
    "void operator()(TIFF* tiff) { TIFFClose(tiff); }",
    "int Screenshot(const char *fname, bool convert)\n{\n#ifdef GLVIS_DEBUG\n   cout << \"Screenshot: glFinish() ... \" << flush;\n#endif\n   glFinish();\n#ifdef GLVIS_DEBUG\n   cout << \"done.\" << endl;\n#endif\n#ifndef __EMSCRIPTEN__\n   if (wnd->isExposePending())\n   {\n      MFEM_WARNING(\"Expose pending, some events may not have been handled.\" << endl);\n   }\n   string filename = fname;\n   string convert_name = fname;\n   bool call_convert = false;\n   if (convert)\n   {\n      // check the extension of 'fname' to see if convert is needed\n      size_t ext_size = strlen(glvis_screenshot_ext);\n      if (filename.size() < ext_size ||\n          filename.compare(filename.size() - ext_size,\n                           ext_size, glvis_screenshot_ext) != 0)\n      {\n         call_convert = true;\n         filename += glvis_screenshot_ext;\n      }\n   }\n   else // do not call convert\n   {\n      filename += glvis_screenshot_ext;\n   }\n\n   int w, h;\n   wnd->getGLDrawSize(w, h);\n   if (wnd->isSwapPending())\n   {\n#ifdef GLVIS_DEBUG\n      cerr << \"Screenshot: reading image data from back buffer...\" << endl;\n#endif\n      glReadBuffer(GL_BACK);\n   }\n   else\n   {\n#ifdef GLVIS_DEBUG\n      cerr << \"Screenshot: reading image data from front buffer...\" << endl;\n#endif\n      MFEM_WARNING(\"Screenshot: Reading from the front buffer is unreliable. \"\n                   << \" Resulting screenshots may be incorrect.\" << endl);\n      glReadBuffer(GL_FRONT);\n   }\n#if defined(GLVIS_USE_LIBTIFF)\n   // Save a TIFF image. This requires the libtiff library, see www.libtiff.org\n   TIFF* image;\n\n   // MyExpose(w,h);\n\n   unsigned char *pixels = new unsigned char[3*w];\n   if (!pixels)\n   {\n      return 1;\n   }\n\n   image = TIFFOpen(filename.c_str(), \"w\");\n   if (!image)\n   {\n      delete [] pixels;\n      return 2;\n   }\n\n   TIFFSetField(image, TIFFTAG_IMAGEWIDTH, w);\n   TIFFSetField(image, TIFFTAG_IMAGELENGTH, h);\n   TIFFSetField(image, TIFFTAG_BITSPERSAMPLE, 8);\n   TIFFSetField(image, TIFFTAG_COMPRESSION, COMPRESSION_PACKBITS);\n   TIFFSetField(image, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n   TIFFSetField(image, TIFFTAG_SAMPLESPERPIXEL, 3);\n   TIFFSetField(image, TIFFTAG_ROWSPERSTRIP, 1);\n   TIFFSetField(image, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);\n   TIFFSetField(image, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n   for (int i = 0; i < h; i++)\n   {\n      glReadPixels(0, h-i-1, w, 1, GL_RGB, GL_UNSIGNED_BYTE, pixels);\n      if (TIFFWriteScanline(image, pixels, i, 0) < 0)\n      {\n         TIFFClose(image);\n         delete [] pixels;\n         return 3;\n      }\n   }\n\n   TIFFFlushData(image);\n   TIFFClose(image);\n   delete [] pixels;\n\n#elif defined(GLVIS_USE_LIBPNG)\n   // Save as png image. Requires libpng.\n   int status = SaveAsPNG(filename.c_str(), w, h, wnd->isHighDpi());\n   if (status != 0) { return status; }\n\n#else\n   // use SDL for screenshots\n\n   // https://stackoverflow.com/questions/20233469/how-do-i-take-and-save-a-bmp-screenshot-in-sdl-2\n   unsigned char * pixels = new unsigned char[w*h*4]; // 4 bytes for RGBA\n   glReadPixels(0, 0, w, h, GL_RGBA, GL_UNSIGNED_BYTE, pixels);\n\n   SDL_Surface * surf = SDL_CreateRGBSurfaceFrom(pixels, w, h, 8*4, w*4, rmask,\n                                                 gmask, bmask, amask);\n   if (surf == nullptr)\n   {\n      std::cerr << \"unable to take screenshot: \" << SDL_GetError() << std::endl;\n   }\n   else\n   {\n      if (InvertSurfaceVertical(surf))\n      {\n         std::cerr << \"failed to invert surface, your screenshot may be upside down\" <<\n                   std::endl;\n      }\n      SDL_SaveBMP(surf, filename.c_str());\n      SDL_FreeSurface(surf);\n      // automatically convert to png if not being used\n      if (!call_convert)\n      {\n         call_convert = true;\n         convert_name += \".png\";\n      }\n   }\n   delete [] pixels;\n#endif\n\n   if (call_convert)\n   {\n      ostringstream cmd;\n      cmd << \"convert \" << filename << ' ' << convert_name;\n      if (system(cmd.str().c_str()))\n      {\n         return 1;\n      }\n      remove(filename.c_str());\n   }\n   return 0;\n#else\n   cout << \"Screenshots not yet implemented for JS\" << endl;\n   return 1;\n#endif\n}",
    "Img * Img::loadTIF(void *_tex, ImageReader read_func)\n{\n#if HAVE_LIBTIFF\n  // downloads the tiff file and put it into the cache\n\n  Texture *tex = static_cast<Texture *>(_tex);\n  char filename[PATH_LEN] = {0};\n\n  Cache::setCachePath(tex->url, filename);\n  Cache *cache = new Cache();\n  FILE *f = cache->open(filename, tex->http);\n  if (! f) {\n    error(\"can't read %s\", tex->url);\n    delete cache;\n    return NULL;\n  }\n  cache->close();\n  delete cache;\n\n  // opens the tiff file\n  TIFF *fp;\n  if (! (fp = TIFFOpen(filename, \"r\"))) return NULL;\n\n  /* reads the header */\n  uint32_t width, height;\n  uint8_t bpp = Img::RGB;\n\n  TIFFGetField(fp, TIFFTAG_IMAGEWIDTH, &width);\n  TIFFGetField(fp, TIFFTAG_IMAGELENGTH, &height);\n  TIFFGetField(fp, TIFFTAG_SAMPLESPERPIXEL, &bpp);\n  if (bpp <= Img::RGB) bpp = Img::RGB;\n  else bpp = Img::RGBA;\n\n  trace1(DBG_2D, \"loadTIF: w=%d h=%d c=%d\", width, height, bpp);\n\n  // always 4 bytes per pixel for this\n  uint32_t * tifImage = static_cast<uint32_t *>(_TIFFmalloc((tsize_t)(width * height * sizeof(uint32_t))));\n\n  // reads the data with the library\n  if (! TIFFReadRGBAImage(fp, width, height, tifImage, 0)) {\n    error(\"loadTIF: error reading file %s\", filename);\n    return NULL;\n  }\n\n  // allocs img\n  Img *img = new Img(width, height, bpp);\n\n  // converts component format\n  uint8_t *pixptr = img->pixmap;\n\n  // fills the pixmap\n  for (int i=0; i < height ; i++) {\n    for (int j=0; j < width ; j++) {\n      uint32_t pixel = tifImage[(i*width) + j];\n\n      *pixptr++ = (uint8_t)TIFFGetR(pixel);\n      *pixptr++ = (uint8_t)TIFFGetG(pixel);\n      *pixptr++ = (uint8_t)TIFFGetB(pixel);\n      if (bpp == Img::RGBA) {\n        *pixptr++ = (uint8_t)TIFFGetA(pixel);\n      }\n    }\n  }\n  _TIFFfree(tifImage);\n  TIFFClose(fp);\n\n  return img;\n#else\n  return NULL;\n#endif\n}",
    "int imagetotif(opj_image_t * image, const char *outfile)\n{\n    TIFF *tif;\n    tdata_t buf;\n    uint32_t width, height;\n    uint16_t bps, tiPhoto;\n    int adjust, sgnd;\n    int64_t strip_size, rowStride, TIFF_MAX;\n    OPJ_UINT32 i, numcomps;\n    OPJ_INT32* buffer32s = NULL;\n    OPJ_INT32 const* planes[4];\n    convert_32s_PXCX cvtPxToCx = NULL;\n    convert_32sXXx_C1R cvt32sToTif = NULL;\n\n    bps = (uint16_t)image->comps[0].prec;\n    planes[0] = image->comps[0].data;\n\n    numcomps = image->numcomps;\n\n    if (image->color_space == OPJ_CLRSPC_CMYK) {\n        if (numcomps < 4U) {\n            fprintf(stderr,\n                    \"imagetotif: CMYK images shall be composed of at least 4 planes.\\n\");\n            fprintf(stderr, \"\\tAborting\\n\");\n            return 1;\n        }\n        tiPhoto = PHOTOMETRIC_SEPARATED;\n        if (numcomps > 4U) {\n            numcomps = 4U; /* Alpha not supported */\n        }\n    } else if (numcomps > 2U) {\n        tiPhoto = PHOTOMETRIC_RGB;\n        if (numcomps > 4U) {\n            numcomps = 4U;\n        }\n    } else {\n        tiPhoto = PHOTOMETRIC_MINISBLACK;\n    }\n    for (i = 1U; i < numcomps; ++i) {\n        if (image->comps[0].dx != image->comps[i].dx) {\n            break;\n        }\n        if (image->comps[0].dy != image->comps[i].dy) {\n            break;\n        }\n        if (image->comps[0].prec != image->comps[i].prec) {\n            break;\n        }\n        if (image->comps[0].sgnd != image->comps[i].sgnd) {\n            break;\n        }\n        planes[i] = image->comps[i].data;\n        if (planes[i] == NULL) {\n            fprintf(stderr,\n                    \"imagetotif: planes[%d] == NULL.\\n\", i);\n            fprintf(stderr, \"\\tAborting\\n\");\n            return 1;\n        }\n    }\n    if (i != numcomps) {\n        fprintf(stderr,\n                \"imagetotif: All components shall have the same subsampling, same bit depth.\\n\");\n        fprintf(stderr, \"\\tAborting\\n\");\n        return 1;\n    }\n\n    if (bps > 16) {\n        bps = 0;\n    }\n    if (bps == 0) {\n        fprintf(stderr, \"imagetotif: Bits=%d, Only 1 to 16 bits implemented\\n\", bps);\n        fprintf(stderr, \"\\tAborting\\n\");\n        return 1;\n    }\n    tif = TIFFOpen(outfile, \"wb\");\n    if (!tif) {\n        fprintf(stderr, \"imagetotif:failed to open %s for writing\\n\", outfile);\n        return 1;\n    }\n    for (i = 0U; i < numcomps; ++i) {\n        clip_component(&(image->comps[i]), image->comps[0].prec);\n    }\n    cvtPxToCx = convert_32s_PXCX_LUT[numcomps];\n    switch (bps) {\n    case 1:\n    case 2:\n    case 4:\n    case 6:\n    case 8:\n        cvt32sToTif = convert_32sXXu_C1R_LUT[bps];\n        break;\n    case 3:\n        cvt32sToTif = tif_32sto3u;\n        break;\n    case 5:\n        cvt32sToTif = tif_32sto5u;\n        break;\n    case 7:\n        cvt32sToTif = tif_32sto7u;\n        break;\n    case 9:\n        cvt32sToTif = tif_32sto9u;\n        break;\n    case 10:\n        cvt32sToTif = tif_32sto10u;\n        break;\n    case 11:\n        cvt32sToTif = tif_32sto11u;\n        break;\n    case 12:\n        cvt32sToTif = tif_32sto12u;\n        break;\n    case 13:\n        cvt32sToTif = tif_32sto13u;\n        break;\n    case 14:\n        cvt32sToTif = tif_32sto14u;\n        break;\n    case 15:\n        cvt32sToTif = tif_32sto15u;\n        break;\n    case 16:\n        cvt32sToTif = (convert_32sXXx_C1R)tif_32sto16u;\n        break;\n    default:\n        /* never here */\n        break;\n    }\n    sgnd = (int)image->comps[0].sgnd;\n    adjust = sgnd ? (int)(1 << (image->comps[0].prec - 1)) : 0;\n    width   = (uint32_t)image->comps[0].w;\n    height  = (uint32_t)image->comps[0].h;\n\n    TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, width);\n    TIFFSetField(tif, TIFFTAG_IMAGELENGTH, height);\n    TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, (uint16_t)numcomps);\n    TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, bps);\n    TIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n    TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, tiPhoto);\n    TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, 1);\n    if (sizeof(tsize_t) == 4) {\n        TIFF_MAX = INT_MAX;\n    } else {\n        TIFF_MAX = UINT_MAX;\n    }\n    strip_size = (int64_t)TIFFStripSize(tif);\n\n    if ((int64_t)width > (int64_t)(TIFF_MAX / numcomps) ||\n            (int64_t)(width * numcomps) > (int64_t)(TIFF_MAX / bps) ||\n            (int64_t)(width * numcomps) > (int64_t)(TIFF_MAX / (int64_t)sizeof(\n                        OPJ_INT32))) {\n        fprintf(stderr, \"Buffer overflow\\n\");\n        TIFFClose(tif);\n        return 1;\n    }\n    rowStride = (int64_t)((width * numcomps * bps + 7U) / 8U);\n    if (rowStride != strip_size) {\n        fprintf(stderr, \"Invalid TIFF strip size\\n\");\n        TIFFClose(tif);\n        return 1;\n    }\n    buf = malloc((OPJ_SIZE_T)strip_size);\n    if (buf == NULL) {\n        TIFFClose(tif);\n        return 1;\n    }\n    buffer32s = (OPJ_INT32 *)malloc(sizeof(OPJ_INT32) * width * numcomps);\n    if (buffer32s == NULL) {\n        _TIFFfree(buf);\n        TIFFClose(tif);\n        return 1;\n    }\n\n    for (i = 0; i < image->comps[0].h; ++i) {\n        cvtPxToCx(planes, buffer32s, (OPJ_SIZE_T)width, adjust);\n        cvt32sToTif(buffer32s, (OPJ_BYTE *)buf, (OPJ_SIZE_T)width * numcomps);\n        (void)TIFFWriteEncodedStrip(tif, i, (void*)buf, (tsize_t)strip_size);\n        planes[0] += width;\n        planes[1] += width;\n        planes[2] += width;\n        planes[3] += width;\n    }\n    _TIFFfree((void*)buf);\n    TIFFClose(tif);\n    free(buffer32s);\n\n    return 0;\n}",
    "opj_image_t* tiftoimage(const char *filename, opj_cparameters_t *parameters,\n                        const unsigned int target_bitdepth)\n{\n    int subsampling_dx = parameters->subsampling_dx;\n    int subsampling_dy = parameters->subsampling_dy;\n    TIFF *tif;\n    tdata_t buf;\n    tstrip_t strip;\n    int64_t strip_size, rowStride, TIFF_MAX;\n    int j, currentPlane, numcomps = 0, w, h;\n    OPJ_COLOR_SPACE color_space = OPJ_CLRSPC_UNKNOWN;\n    opj_image_cmptparm_t cmptparm[4]; /* RGBA */\n    opj_image_t *image = NULL;\n    uint16_t tiBps, tiPhoto, tiSf, tiSpp, tiPC;\n    uint32_t tiWidth, tiHeight;\n    OPJ_BOOL is_cinema = OPJ_IS_CINEMA(parameters->rsiz);\n    convert_XXx32s_C1R cvtTifTo32s = NULL;\n    convert_32s_CXPX cvtCxToPx = NULL;\n    OPJ_INT32* buffer32s = NULL;\n    OPJ_INT32* planes[4];\n\n    tif = TIFFOpen(filename, \"r\");\n\n    if (!tif) {\n        fprintf(stderr, \"tiftoimage:Failed to open %s for reading\\n\", filename);\n        return 0;\n    }\n    tiBps = tiPhoto = tiSf = tiSpp = tiPC = 0;\n    tiWidth = tiHeight = 0;\n\n    TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &tiWidth);\n    TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &tiHeight);\n    TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &tiBps);\n    TIFFGetField(tif, TIFFTAG_SAMPLEFORMAT, &tiSf);\n    TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &tiSpp);\n    TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &tiPhoto);\n    TIFFGetField(tif, TIFFTAG_PLANARCONFIG, &tiPC);\n\n    if (tiSpp == 0 || tiSpp > 4) { /* should be 1 ... 4 */\n        fprintf(stderr, \"tiftoimage: Bad value for samples per pixel == %d.\\n\"\n                \"\\tAborting.\\n\", tiSpp);\n        TIFFClose(tif);\n        return NULL;\n    }\n    if (tiBps > 16U || tiBps == 0) {\n        fprintf(stderr, \"tiftoimage: Bad values for Bits == %d.\\n\"\n                \"\\tMax. 16 Bits are allowed here.\\n\\tAborting.\\n\", tiBps);\n        TIFFClose(tif);\n        return NULL;\n    }\n    if (tiPhoto != PHOTOMETRIC_MINISBLACK && tiPhoto != PHOTOMETRIC_RGB) {\n        fprintf(stderr,\n                \"tiftoimage: Bad color format %d.\\n\\tOnly RGB(A) and GRAY(A) has been implemented\\n\\tAborting.\\n\",\n                (int) tiPhoto);\n        TIFFClose(tif);\n        return NULL;\n    }\n    if (tiWidth == 0 || tiHeight == 0) {\n        fprintf(stderr, \"tiftoimage: Bad values for width(%u) \"\n                \"and/or height(%u)\\n\\tAborting.\\n\", tiWidth, tiHeight);\n        TIFFClose(tif);\n        return NULL;\n    }\n    w = (int)tiWidth;\n    h = (int)tiHeight;\n\n    switch (tiBps) {\n    case 1:\n    case 2:\n    case 4:\n    case 6:\n    case 8:\n        cvtTifTo32s = convert_XXu32s_C1R_LUT[tiBps];\n        break;\n    /* others are specific to TIFF */\n    case 3:\n        cvtTifTo32s = tif_3uto32s;\n        break;\n    case 5:\n        cvtTifTo32s = tif_5uto32s;\n        break;\n    case 7:\n        cvtTifTo32s = tif_7uto32s;\n        break;\n    case 9:\n        cvtTifTo32s = tif_9uto32s;\n        break;\n    case 10:\n        cvtTifTo32s = tif_10uto32s;\n        break;\n    case 11:\n        cvtTifTo32s = tif_11uto32s;\n        break;\n    case 12:\n        cvtTifTo32s = tif_12uto32s;\n        break;\n    case 13:\n        cvtTifTo32s = tif_13uto32s;\n        break;\n    case 14:\n        cvtTifTo32s = tif_14uto32s;\n        break;\n    case 15:\n        cvtTifTo32s = tif_15uto32s;\n        break;\n    case 16:\n        cvtTifTo32s = (convert_XXx32s_C1R)tif_16uto32s;\n        break;\n    default:\n        /* never here */\n        break;\n    }\n\n    /* initialize image components */\n    memset(&cmptparm[0], 0, 4 * sizeof(opj_image_cmptparm_t));\n\n    if ((tiPhoto == PHOTOMETRIC_RGB) && (is_cinema) && (tiBps != 12U)) {\n        fprintf(stdout, \"WARNING:\\n\"\n                \"Input image bitdepth is %d bits\\n\"\n                \"TIF conversion has automatically rescaled to 12-bits\\n\"\n                \"to comply with cinema profiles.\\n\",\n                tiBps);\n    } else {\n        is_cinema = 0U;\n    }\n\n    numcomps = tiSpp;\n    if (tiPhoto == PHOTOMETRIC_RGB) { /* RGB(A) */\n        color_space = OPJ_CLRSPC_SRGB;\n    } else if (tiPhoto == PHOTOMETRIC_MINISBLACK) { /* GRAY(A) */\n        color_space = OPJ_CLRSPC_GRAY;\n    }\n\n    cvtCxToPx = convert_32s_CXPX_LUT[numcomps];\n    if (tiPC == PLANARCONFIG_SEPARATE) {\n        cvtCxToPx = convert_32s_CXPX_LUT[1]; /* override */\n        tiSpp = 1U; /* consider only one sample per plane */\n    }\n\n    for (j = 0; j < numcomps; j++) {\n        cmptparm[j].prec = tiBps;\n        cmptparm[j].dx = (OPJ_UINT32)subsampling_dx;\n        cmptparm[j].dy = (OPJ_UINT32)subsampling_dy;\n        cmptparm[j].w = (OPJ_UINT32)w;\n        cmptparm[j].h = (OPJ_UINT32)h;\n    }\n\n    image = opj_image_create((OPJ_UINT32)numcomps, &cmptparm[0], color_space);\n    if (!image) {\n        TIFFClose(tif);\n        return NULL;\n    }\n    /* set image offset and reference grid */\n    image->x0 = (OPJ_UINT32)parameters->image_offset_x0;\n    image->y0 = (OPJ_UINT32)parameters->image_offset_y0;\n    image->x1 = !image->x0 ? (OPJ_UINT32)(w - 1) * (OPJ_UINT32)subsampling_dx + 1 :\n                image->x0 + (OPJ_UINT32)(w - 1) * (OPJ_UINT32)subsampling_dx + 1;\n    if (image->x1 <= image->x0) {\n        fprintf(stderr, \"tiftoimage: Bad value for image->x1(%d) vs. \"\n                \"image->x0(%d)\\n\\tAborting.\\n\", image->x1, image->x0);\n        TIFFClose(tif);\n        opj_image_destroy(image);\n        return NULL;\n    }\n    image->y1 = !image->y0 ? (OPJ_UINT32)(h - 1) * (OPJ_UINT32)subsampling_dy + 1 :\n                image->y0 + (OPJ_UINT32)(h - 1) * (OPJ_UINT32)subsampling_dy + 1;\n    if (image->y1 <= image->y0) {\n        fprintf(stderr, \"tiftoimage: Bad value for image->y1(%d) vs. \"\n                \"image->y0(%d)\\n\\tAborting.\\n\", image->y1, image->y0);\n        TIFFClose(tif);\n        opj_image_destroy(image);\n        return NULL;\n    }\n\n    for (j = 0; j < numcomps; j++) {\n        planes[j] = image->comps[j].data;\n    }\n    image->comps[numcomps - 1].alpha = (OPJ_UINT16)(1 - (numcomps & 1));\n\n    strip_size = (int64_t)TIFFStripSize(tif);\n\n    buf = malloc((OPJ_SIZE_T)strip_size);\n    if (buf == NULL) {\n        TIFFClose(tif);\n        opj_image_destroy(image);\n        return NULL;\n    }\n    if (sizeof(tsize_t) == 4) {\n        TIFF_MAX = INT_MAX;\n    } else {\n        TIFF_MAX = UINT_MAX;\n    }\n    if ((int64_t)tiWidth > (int64_t)(TIFF_MAX / tiSpp) ||\n            (int64_t)(tiWidth * tiSpp) > (int64_t)(TIFF_MAX / tiBps) ||\n            (int64_t)(tiWidth * tiSpp) > (int64_t)(TIFF_MAX / (int64_t)sizeof(OPJ_INT32))) {\n        fprintf(stderr, \"Buffer overflow\\n\");\n        _TIFFfree(buf);\n        TIFFClose(tif);\n        opj_image_destroy(image);\n        return NULL;\n    }\n\n    rowStride = (int64_t)((tiWidth * tiSpp * tiBps + 7U) / 8U);\n    buffer32s = (OPJ_INT32 *)malloc(sizeof(OPJ_INT32) * tiWidth * tiSpp);\n    if (buffer32s == NULL) {\n        _TIFFfree(buf);\n        TIFFClose(tif);\n        opj_image_destroy(image);\n        return NULL;\n    }\n\n    strip = 0;\n    currentPlane = 0;\n    do {\n        planes[0] = image->comps[currentPlane].data; /* to manage planar data */\n        h = (int)tiHeight;\n        /* Read the Image components */\n        for (; (h > 0) && (strip < TIFFNumberOfStrips(tif)); strip++) {\n            const OPJ_UINT8 *dat8;\n            int64_t ssize;\n\n            ssize = (int64_t)TIFFReadEncodedStrip(tif, strip, buf, (tsize_t)strip_size);\n\n            if (ssize < 1 || ssize > strip_size) {\n                fprintf(stderr, \"tiftoimage: Bad value for ssize(%\" PRId64 \") \"\n                        \"vs. strip_size(%\" PRId64 \").\\n\\tAborting.\\n\", ssize, strip_size);\n                _TIFFfree(buf);\n                _TIFFfree(buffer32s);\n                TIFFClose(tif);\n                opj_image_destroy(image);\n                return NULL;\n            }\n            dat8 = (const OPJ_UINT8*)buf;\n\n            while (ssize >= rowStride) {\n                cvtTifTo32s(dat8, buffer32s, (OPJ_SIZE_T)w * tiSpp);\n                cvtCxToPx(buffer32s, planes, (OPJ_SIZE_T)w);\n                planes[0] += w;\n                planes[1] += w;\n                planes[2] += w;\n                planes[3] += w;\n                dat8  += rowStride;\n                ssize -= rowStride;\n                h--;\n            }\n        }\n        currentPlane++;\n    } while ((tiPC == PLANARCONFIG_SEPARATE) && (currentPlane < numcomps));\n\n    free(buffer32s);\n    _TIFFfree(buf);\n    TIFFClose(tif);\n\n    if (is_cinema) {\n        for (j = 0; j < numcomps; ++j) {\n            scale_component(&(image->comps[j]), 12);\n        }\n\n    } else if ((target_bitdepth > 0) && (target_bitdepth != tiBps)) {\n        for (j = 0; j < numcomps; ++j) {\n            scale_component(&(image->comps[j]), target_bitdepth);\n        }\n    }\n    return image;\n\n}",
    "TIFFGenerator::~TIFFGenerator()\n{\n    if (d->tiff) {\n        TIFFClose(d->tiff);\n        d->tiff = nullptr;\n    }\n\n    delete d;\n}",
    "bool TIFFGenerator::doCloseDocument()\n{\n    // closing the old document\n    if (d->tiff) {\n        TIFFClose(d->tiff);\n        d->tiff = nullptr;\n        delete d->dev;\n        d->dev = nullptr;\n        d->data.clear();\n        m_pageMapping.clear();\n    }\n\n    return true;\n}",
    "Expected<void> writeRawTiff( const uint8_t* bytes, const std::filesystem::path& path, const BaseTiffParameters& params )\n{\n    TIFF* tif = TIFFOpen( MR::utf8string( path ).c_str(), \"w\" );\n    if ( !tif )\n        return unexpected(\"Cannot write file: \"+ utf8string( path ) );\n\n    TIFFSetField( tif, TIFFTAG_IMAGEWIDTH, params.imageSize.x );\n    TIFFSetField( tif, TIFFTAG_IMAGELENGTH, params.imageSize.y );\n    TIFFSetField( tif, TIFFTAG_BITSPERSAMPLE, params.bytesPerSample * 8 );\n    int numSamples = 1;\n    switch ( params.valueType )\n    {\n    case BaseTiffParameters::ValueType::Scalar:\n        numSamples = 1;\n        break;\n    case BaseTiffParameters::ValueType::RGB:\n        numSamples = 3;\n        break;\n    case BaseTiffParameters::ValueType::RGBA:\n        numSamples = 4;\n        break;\n    default:\n        break;\n    }\n    TIFFSetField( tif, TIFFTAG_SAMPLESPERPIXEL, numSamples );\n\n    int sampleType = 0;\n    switch ( params.sampleType )\n    {\n    case BaseTiffParameters::SampleType::Float:\n        sampleType = SAMPLEFORMAT_IEEEFP;\n        break;\n    case BaseTiffParameters::SampleType::Uint:\n        sampleType = SAMPLEFORMAT_UINT;\n        break;\n    case BaseTiffParameters::SampleType::Int:\n        sampleType = SAMPLEFORMAT_INT;\n        break;\n    default:\n        return unexpected( \"Unknown sample format\" );\n        break;\n    }\n\n    TIFFSetField( tif, TIFFTAG_SAMPLEFORMAT, sampleType );\n\n    TIFFSetField( tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG );\n    TIFFSetField( tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISWHITE );\n\n    for ( int row = 0; row < params.imageSize.y; row++ )\n        TIFFWriteScanline( tif, ( void* )( bytes + row * params.imageSize.x * numSamples * params.bytesPerSample ), row );\n\n    TIFFClose( tif );\n    return {};\n}",
    "~TiffHolder()\n    {\n        if ( !tiffPtr_ )\n            return;\n        TIFFClose( tiffPtr_ );\n        tiffPtr_ = nullptr;\n    }",
    "Expected<void> toTiff( const Image& image, const std::filesystem::path& path )\n{\n    auto tiff = TIFFOpen( utf8string( path ).c_str(), \"w\" );\n    if ( !tiff )\n        return unexpected( \"Cannot write file: \" + utf8string( path ) );\n    MR_FINALLY {\n        TIFFClose( tiff );\n    };\n\n    TIFFSetField( tiff, TIFFTAG_IMAGEWIDTH, image.resolution.x );\n    TIFFSetField( tiff, TIFFTAG_IMAGELENGTH, image.resolution.y );\n\n    // 32-bit RGBA\n    TIFFSetField( tiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB );\n    TIFFSetField( tiff, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT );\n    TIFFSetField( tiff, TIFFTAG_BITSPERSAMPLE, 8 );\n    TIFFSetField( tiff, TIFFTAG_SAMPLESPERPIXEL, 4 );\n\n    // FIXME: orientation is ignored\n    TIFFSetField( tiff, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT );\n    TIFFSetField( tiff, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG );\n\n    for ( auto row = 0; row < image.resolution.y; ++row )\n    {\n        // FIXME: orientation is ignored\n        const auto* data = image.pixels.data() + (size_t)( image.resolution.y - 1 - row ) * image.resolution.x;\n        TIFFWriteScanline( tiff, (void*)data, row );\n    }\n    TIFFFlush( tiff );\n\n    return {};\n}",
    "void DngWriter::WriteDNG() {\n\n    LOGD(\"init ext tags\");\n    LOGD(\"init ext tags done\");\n    TIFF *tif;\n    LOGD(\"has file description: %b\", hasFileDes);\n    if(hasFileDes == true)\n    {\n        tif = openfTIFFFD(\"\", fileDes);\n    }\n    else\n        tif = openfTIFF(fileSavePath);\n\n    LOGD(\"writeIfd0\");\n    writeIfd0(tif);\n\n    if(opCode != NULL)\n    {\n        if(opCode->op2Size > 0)\n        {\n            LOGD(\"Set OP2 %i\", opCode->op2Size);\n            TIFFSetField(tif, TIFFTAG_OPC2, opCode->op2Size, opCode->op2);\n        }\n        else\n        {\n            LOGD(\"opcode2 null\");\n        }\n        if(opCode->op3Size > 0)\n        {\n            LOGD(\"Set OP3 %i\", opCode->op3Size);\n            TIFFSetField(tif, TIFFTAG_OPC3, opCode->op3Size, opCode->op3);\n        }\n        else\n        {\n            LOGD(\"opcode3 null\");\n        }\n    } else\n    {\n        LOGD(\"opcode null\");\n    }\n    LOGD(\"writeRawStuff\");\n    writeRawStuff(tif);\n\n    TIFFWriteDirectory(tif);\n    LOGD(\"set exif\");\n    if(exifInfo != NULL)\n    {\n        uint64 exif_offset = 0;\n        TIFFCreateEXIFDirectory(tif);\n        writeExifIfd(tif);\n        TIFFWriteCustomDirectory(tif, &exif_offset);\n        TIFFSetDirectory(tif, 0);\n        TIFFSetField (tif, TIFFTAG_EXIFIFD, exif_offset);\n        TIFFRewriteDirectory(tif);\n    }\n\n    if(gpsInfo != NULL)\n    {\n        uint64 gps_offset = 0;\n        LOGD(\"makeGPSIFD\");\n        makeGPS_IFD(tif);\n        LOGD(\"TIFFWriteCustomDirectory\");\n        TIFFWriteCustomDirectory(tif, &gps_offset);\n        // set GPSIFD tag\n        LOGD(\"TIFFSetDirectory\");\n        TIFFSetDirectory(tif, 0);\n        LOGD(\"setgpsoffset\");\n        TIFFSetField (tif, TIFFTAG_GPSIFD, gps_offset);\n\n    }\n\n    TIFFClose(tif);\n\n\n    LOGD(\"DONE\");\n}",
    "JNIEXPORT void JNICALL Java_freed_jni_DngStack_startStack(JNIEnv *env, jobject thiz, jobjectArray filesToStack, jstring outputfile)\n{\n    int stringCount = (*env).GetArrayLength(filesToStack);\n    int width,height, outputcount;\n    const char * files[stringCount];\n    const char * outfile =(*env).GetStringUTFChars( outputfile, NULL);\n    unsigned short tmpPixel, bitdeep,bitdeeptemp;\n    unsigned char * rawOutputData;\n    unsigned char* cfa= new unsigned char[4];\n    unsigned char* cfatmp= new unsigned char[4];\n    float* cmat1 = new float[9];\n    float * cmat2 = new float[9];\n    float * neutMat = new float[3];\n    float * fmat1= new float[9];\n    float * fmat2= new float[9];\n    float * calib1= new float[9];\n    float * calib2= new float[9];\n    double *noisemat  = new double[6];\n    float *blackleveltmp;\n    short blacklevel;\n    float * tmpmat = new float[9];\n    double * tmpdouble = new double[6];\n    long * whitelvl;\n    long white;\n\n    //short * whitelvltmp;\n    //short whitelvl;\n    unsigned char * inbuf;\n    /*unsigned char * opcodetmp;\n    unsigned char * opcode2;\n    unsigned char * opcode3;*/\n    LOGD(\"FilesToReadCount: %i\", stringCount);\n    for (int i=0; i<stringCount; i++) {\n        jstring string = (jstring) (*env).GetObjectArrayElement(filesToStack, i);\n        files[i] = (*env).GetStringUTFChars( string, NULL);\n    }\n\n\n    TIFF *tif=TIFFOpen(files[0], \"rw\");\n    //read needed dng tags\n    TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n    LOGD(\"GetWidth\");\n    TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n    LOGD(\"GetHeight\");\n    TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bitdeeptemp);\n    LOGD(\"GetBitDeep\");\n    bitdeep = bitdeeptemp;\n    TIFFGetField(tif, TIFFTAG_COLORMATRIX1,9, &tmpmat);\n    LOGD(\"cc1\");\n    moveToMem(tmpmat, cmat1,9);\n    TIFFGetField(tif, TIFFTAG_COLORMATRIX2,9, &tmpmat);\n    LOGD(\"cc2\");\n    moveToMem(tmpmat, cmat2,9);\n    TIFFGetField(tif, TIFFTAG_ASSHOTNEUTRAL,3, &tmpmat);\n    LOGD(\"neutral\");\n    moveToMem(tmpmat, neutMat,3);\n    TIFFGetField(tif, TIFFTAG_FOWARDMATRIX1,9, &tmpmat);\n    moveToMem(tmpmat, fmat1,9);\n    TIFFGetField(tif, TIFFTAG_FOWARDMATRIX2,9, &tmpmat);\n    moveToMem(tmpmat, fmat2,9);\n    TIFFGetField(tif, TIFFTAG_CAMERACALIBRATION1,9, &tmpmat);\n    moveToMem(tmpmat, calib1,9);\n    TIFFGetField(tif, TIFFTAG_CAMERACALIBRATION2,9, &tmpmat);\n    moveToMem(tmpmat, calib2,9);\n    TIFFGetField(tif, TIFFTAG_NOISEPROFILE,6, &tmpdouble);\n    for (int i = 0; i < 6; ++i) {\n        noisemat[i] = tmpdouble[i];\n    }\n    TIFFGetField(tif, TIFFTAG_CFAPATTERN, &cfatmp);\n    for (int i = 0; i < 4; ++i) {\n        cfa[i] = cfatmp[i];\n    }\n    LOGD(\"cfa pattern %c%c&c&c\", cfa[0],cfa[1],cfa[2],cfa[3]);\n\n    TIFFGetField(tif, TIFFTAG_WHITELEVEL, &whitelvl);\n    LOGD(\"whitelvl:%i\" , whitelvl[0]);\n    white = whitelvl[0];\n    LOGD(\"whitelvl:%i\" , white);\n    //whitelvl = whitelvltmp[0];\n    TIFFGetField(tif, TIFFTAG_BLACKLEVEL, &blackleveltmp);\n    /*TIFFGetField(tif, TIFFTAG_OPC2, &opcodetmp);\n    opcode2 = opcodetmp;\n    TIFFGetField(tif, TIFFTAG_OPC3, &opcodetmp);\n    opcode3 = opcodetmp;*/\n    blacklevel = blackleveltmp[0];\n\n    rawOutputData = new unsigned char[((width*height)*16)/8];\n\n    int scanlinesize = TIFFStripSize(tif);\n    inbuf = (unsigned char*)_TIFFmalloc(scanlinesize);\n    outputcount = 0;\n    for (int row = 0; row < height; row++)\n    {\n        TIFFReadRawStrip(tif,row, inbuf, scanlinesize);\n        if(bitdeep == 10)\n        {\n            for (int i = 0; i < scanlinesize; i+=5) {\n                tmpPixel = (inbuf[i] << 2 | (inbuf[i+1] & 0b11000000) >> 6); //11111111 11\n                rawOutputData[outputcount++] = tmpPixel & 0xff;\n                rawOutputData[outputcount++] = tmpPixel >>8;\n\n                tmpPixel = ((inbuf[i+1] & 0b00111111 ) << 4 | (inbuf[i+2] & 0b11110000) >> 4); // 222222 2222\n                rawOutputData[outputcount++] = tmpPixel & 0xff;\n                rawOutputData[outputcount++] = tmpPixel >>8;\n\n                tmpPixel = ((inbuf[i+2]& 0b00001111 ) << 6 | (inbuf[i+3] & 0b11111100) >> 2); // 3333 333333\n                rawOutputData[outputcount++] = tmpPixel & 0xff;\n                rawOutputData[outputcount++] = tmpPixel >>8;\n\n                tmpPixel = ((inbuf[i+3]& 0b00000011 ) << 8 | inbuf[i+4]); // 44 44444444\n                rawOutputData[outputcount++] = tmpPixel & 0xff;\n                rawOutputData[outputcount++] = tmpPixel >>8;\n            }\n        }\n        else if(bitdeep == 16)\n        {\n            for (int i = 0; i < scanlinesize; i+=8) {\n                tmpPixel = (inbuf[i] | inbuf[i+1]<<8);\n                rawOutputData[outputcount++] = tmpPixel & 0xff;\n                rawOutputData[outputcount++] = tmpPixel >>8;\n\n                tmpPixel = (inbuf[i+2] | inbuf[i+3]<<8);\n                rawOutputData[outputcount++] = tmpPixel & 0xff;\n                rawOutputData[outputcount++] = tmpPixel >>8;\n\n                tmpPixel = (inbuf[i+4] | inbuf[i+5]<<8);\n                rawOutputData[outputcount++] = tmpPixel & 0xff;\n                rawOutputData[outputcount++] = tmpPixel >>8;\n\n                tmpPixel = (inbuf[i+6] | inbuf[i+7]<<8);\n                rawOutputData[outputcount++] = tmpPixel & 0xff;\n                rawOutputData[outputcount++] = tmpPixel >>8;\n            }\n        }\n    }\n    TIFFClose(tif);\n\n    //read left dngs and merge them\n    for (int i = 1; i < stringCount; ++i) {\n        TIFF *tif=TIFFOpen(files[i], \"rw\");\n        TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bitdeeptemp);\n        bitdeep = bitdeeptemp;\n        outputcount = 0;\n        for (int row = 0; row < height; row++)\n        {\n            TIFFReadRawStrip(tif,row, inbuf, scanlinesize);\n            if(bitdeep == 10)\n            {\n                for (int i = 0; i < scanlinesize; i+=5) {\n                    tmpPixel = (((inbuf[i] << 2 | (inbuf[i+1] & 0b11000000) >> 6)) + (rawOutputData[outputcount] | rawOutputData[outputcount+1]<<8))/2; //11111111 11\n                    rawOutputData[outputcount++] = tmpPixel & 0xff;\n                    rawOutputData[outputcount++] = tmpPixel >>8;\n\n                    tmpPixel = ((((inbuf[i+1] & 0b00111111 ) << 4 | (inbuf[i+2] & 0b11110000) >> 4)) + (rawOutputData[outputcount] | rawOutputData[outputcount+1]<<8))/2; // 222222 2222\n                    rawOutputData[outputcount++] = tmpPixel & 0xff;\n                    rawOutputData[outputcount++] = tmpPixel >>8;\n\n                    tmpPixel = ((((inbuf[i+2]& 0b00001111 )  | (inbuf[i+3] & 0b11111100) >> 2)) + (rawOutputData[outputcount] | rawOutputData[outputcount+1]<<8))/2; // 3333 333333\n                    rawOutputData[outputcount++] = tmpPixel & 0xff;\n                    rawOutputData[outputcount++] = tmpPixel >>8;\n\n                    tmpPixel = ((((inbuf[i+3]& 0b00000011 ) << 8 | inbuf[i+4])) + (rawOutputData[outputcount] | rawOutputData[outputcount+1]<<8))/2; // 44 44444444\n                    rawOutputData[outputcount++] = tmpPixel & 0xff;\n                    rawOutputData[outputcount++] = tmpPixel >>8;\n                }\n            }\n            else if(bitdeep == 16)\n            {\n                for (int i = 0; i < scanlinesize; i+=8) {\n                    tmpPixel = (((inbuf[i] | inbuf[i+1]<<8))+ (rawOutputData[outputcount] | rawOutputData[outputcount+1]<<8))/2;\n                    rawOutputData[outputcount++] = tmpPixel & 0xff;\n                    rawOutputData[outputcount++] = tmpPixel >>8;\n\n                    tmpPixel = (((inbuf[i+2] | inbuf[i+3]<<8))+ (rawOutputData[outputcount] | rawOutputData[outputcount+1]<<8))/2;\n                    rawOutputData[outputcount++] = tmpPixel & 0xff;\n                    rawOutputData[outputcount++] = tmpPixel >>8;\n\n                    tmpPixel = (((inbuf[i+4] | inbuf[i+5]<<8))+ (rawOutputData[outputcount] | rawOutputData[outputcount+1]<<8))/2;\n                    rawOutputData[outputcount++] = tmpPixel & 0xff;\n                    rawOutputData[outputcount++] = tmpPixel >>8;\n\n                    tmpPixel = (((inbuf[i+6] | inbuf[i+7]<<8))+ (rawOutputData[outputcount] | rawOutputData[outputcount+1]<<8))/2;\n                    rawOutputData[outputcount++] = tmpPixel & 0xff;\n                    rawOutputData[outputcount++] = tmpPixel >>8;\n                }\n            }\n        }\n        TIFFClose(tif);\n    }\n    free(inbuf);\n    //create stacked dng\n    tif=TIFFOpen(outfile, \"w\");\n\n    TIFFSetField (tif, TIFFTAG_SUBFILETYPE, 0);\n    TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, width);\n    TIFFSetField(tif, TIFFTAG_IMAGELENGTH, height);\n    TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 16);\n    TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_CFA);\n    TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n    TIFFSetField (tif, TIFFTAG_SAMPLESPERPIXEL, 1);\n    TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    TIFFSetField(tif, TIFFTAG_DNGVERSION, \"\\001\\003\\0\\0\");\n    TIFFSetField(tif, TIFFTAG_DNGBACKWARDVERSION, \"\\001\\001\\0\\0\");\n    TIFFSetField(tif, TIFFTAG_COLORMATRIX1, 9, cmat1);\n    LOGD(\"colormatrix1\");\n    TIFFSetField(tif, TIFFTAG_COLORMATRIX2, 9, cmat2);\n    TIFFSetField(tif, TIFFTAG_ASSHOTNEUTRAL, 3, neutMat);\n    LOGD(\"neutralMatrix\");\n    if(fmat1 != NULL)\n        TIFFSetField(tif, TIFFTAG_FOWARDMATRIX1, 9,  fmat1);\n    if(fmat2 != NULL)\n        TIFFSetField(tif, TIFFTAG_FOWARDMATRIX2, 9,  fmat2);\n    if(calib1 != NULL)\n        TIFFSetField(tif, TIFFTAG_CAMERACALIBRATION1, 9,  calib1);\n    if(calib2 != NULL)\n        TIFFSetField(tif, TIFFTAG_CAMERACALIBRATION2, 9,  calib2);\n    if(noisemat != NULL)\n        TIFFSetField(tif, TIFFTAG_NOISEPROFILE, 6,  noisemat);\n    TIFFSetField(tif, TIFFTAG_CALIBRATIONILLUMINANT1, 17);\n    TIFFSetField(tif, TIFFTAG_CALIBRATIONILLUMINANT2, 21);\n\n    TIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n\n    TIFFSetField (tif, TIFFTAG_CFAPATTERN, cfa);\n    LOGD(\"whitelvl:%i\" , white);\n    TIFFSetField (tif, TIFFTAG_WHITELEVEL,1, &white);\n\n    short CFARepeatPatternDim[] = { 2,2 };\n    TIFFSetField (tif, TIFFTAG_CFAREPEATPATTERNDIM, CFARepeatPatternDim);\n    int bl = blacklevel;\n    float *blacklevelar = new float[4];\n    for (int i = 0; i < 4; ++i) {\n        blacklevelar[i] = bl;\n    }\n    TIFFSetField (tif, TIFFTAG_BLACKLEVEL, 4, blacklevelar);\n    LOGD(\"wrote blacklevel\");\n    TIFFSetField (tif, TIFFTAG_BLACKLEVELREPEATDIM, CFARepeatPatternDim);\n\n    //TODO find out why OPCODE cause ueof ex in ps\n    /*if(sizeof(opcode2)>0)\n        TIFFSetField(tif,TIFFTAG_OPC2, sizeof(opcode2), opcode2);\n    if(sizeof(opcode3)>0)\n        TIFFSetField(tif,TIFFTAG_OPC3, sizeof(opcode3), opcode3);*/\n    TIFFCheckpointDirectory(tif);\n\n    TIFFWriteRawStrip(tif, 0, rawOutputData, ((width*height)*16)/8);\n\n    TIFFRewriteDirectory(tif);\n\n    //TIFFWriteRawStrip(tif, 0, rawOutputData, width*height);\n\n    TIFFClose(tif);\n    delete[] rawOutputData;\n}",
    "void close_tif()\n    {\n        if (m_tif) {\n            TIFFClose(m_tif);\n            m_tif = NULL;\n            if (m_rgbadata.size())\n                std::vector<uint32_t>().swap(m_rgbadata);  // release\n        }\n    }",
    "void\nTIFFInput::readspec(bool read_meta)\n{\n    uint32 width = 0, height = 0, depth = 0;\n    TIFFGetField(m_tif, TIFFTAG_IMAGEWIDTH, &width);\n    TIFFGetField(m_tif, TIFFTAG_IMAGELENGTH, &height);\n    TIFFGetFieldDefaulted(m_tif, TIFFTAG_IMAGEDEPTH, &depth);\n    TIFFGetFieldDefaulted(m_tif, TIFFTAG_SAMPLESPERPIXEL, &m_inputchannels);\n\n    if (read_meta) {\n        // clear the whole m_spec and start fresh\n        m_spec = ImageSpec((int)width, (int)height, (int)m_inputchannels);\n    } else {\n        // assume m_spec is valid, except for things that might differ\n        // between MIP levels\n        m_spec.width     = (int)width;\n        m_spec.height    = (int)height;\n        m_spec.depth     = (int)depth;\n        m_spec.nchannels = (int)m_inputchannels;\n    }\n\n    float xpos = 0, ypos = 0;\n    TIFFGetField(m_tif, TIFFTAG_XPOSITION, &xpos);\n    TIFFGetField(m_tif, TIFFTAG_YPOSITION, &ypos);\n    if (xpos || ypos) {\n        // In the TIFF files, the positions are in resolutionunit. But we\n        // didn't used to interpret it that way, hence the mess below.\n        float xres = 1, yres = 1;\n        TIFFGetField(m_tif, TIFFTAG_XRESOLUTION, &xres);\n        TIFFGetField(m_tif, TIFFTAG_YRESOLUTION, &yres);\n        // See if the 'Software' field has a clue about what version of OIIO\n        // wrote the TIFF file. This can save us from embarrassing mistakes\n        // misinterpreting the image offset.\n        int oiio_write_version = 0;\n        string_view software;\n        if (tiff_get_string_field(TIFFTAG_SOFTWARE, software)\n            && Strutil::parse_prefix(software, \"OpenImageIO\")) {\n            int major = 0, minor = 0, patch = 0;\n            if (Strutil::parse_int(software, major)\n                && Strutil::parse_char(software, '.')\n                && Strutil::parse_int(software, minor)\n                && Strutil::parse_char(software, '.')\n                && Strutil::parse_int(software, patch)) {\n                oiio_write_version = major * 10000 + minor * 100 + patch;\n            }\n        }\n        // Old version of OIIO did not write the field correctly, so try\n        // to compensate.\n        if (oiio_write_version && oiio_write_version < 10803) {\n            xres = yres = 1.0f;\n        }\n        m_spec.x = (int)(xpos * xres);\n        m_spec.y = (int)(ypos * yres);\n    } else {\n        m_spec.x = 0;\n        m_spec.y = 0;\n    }\n    m_spec.z = 0;\n\n    // Start by assuming the \"full\" (aka display) window is the same as the\n    // data window. That's what we'll stick to if there is no further\n    // information in the file. But if the file has tags for hte \"full\"\n    // size, assume a display window with origin (0,0) and those dimensions.\n    // (Unfortunately, there are no TIFF tags for \"full\" origin.)\n    m_spec.full_x      = m_spec.x;\n    m_spec.full_y      = m_spec.y;\n    m_spec.full_z      = m_spec.z;\n    m_spec.full_width  = m_spec.width;\n    m_spec.full_height = m_spec.height;\n    m_spec.full_depth  = m_spec.depth;\n    if (TIFFGetField(m_tif, TIFFTAG_PIXAR_IMAGEFULLWIDTH, &width) == 1\n        && TIFFGetField(m_tif, TIFFTAG_PIXAR_IMAGEFULLLENGTH, &height) == 1\n        && width > 0 && height > 0) {\n        m_spec.full_width  = width;\n        m_spec.full_height = height;\n        m_spec.full_x      = 0;\n        m_spec.full_y      = 0;\n    }\n\n    if (TIFFIsTiled(m_tif)) {\n        TIFFGetField(m_tif, TIFFTAG_TILEWIDTH, &m_spec.tile_width);\n        TIFFGetField(m_tif, TIFFTAG_TILELENGTH, &m_spec.tile_height);\n        TIFFGetFieldDefaulted(m_tif, TIFFTAG_TILEDEPTH, &m_spec.tile_depth);\n    } else {\n        m_spec.tile_width  = 0;\n        m_spec.tile_height = 0;\n        m_spec.tile_depth  = 0;\n    }\n\n    m_bitspersample = 8;\n    TIFFGetField(m_tif, TIFFTAG_BITSPERSAMPLE, &m_bitspersample);\n    m_spec.attribute(\"oiio:BitsPerSample\", (int)m_bitspersample);\n\n    unsigned short sampleformat = SAMPLEFORMAT_UINT;\n    TIFFGetFieldDefaulted(m_tif, TIFFTAG_SAMPLEFORMAT, &sampleformat);\n    switch (m_bitspersample) {\n    case 1:\n    case 2:\n    case 4:\n    case 6:\n        // Make 1, 2, 4, 6 bpp look like byte images\n    case 8:\n        if (sampleformat == SAMPLEFORMAT_UINT)\n            m_spec.set_format(TypeDesc::UINT8);\n        else if (sampleformat == SAMPLEFORMAT_INT)\n            m_spec.set_format(TypeDesc::INT8);\n        else\n            m_spec.set_format(TypeDesc::UINT8);  // punt\n        break;\n    case 10:\n    case 12:\n    case 14:\n        // Make 10, 12, 14 bpp look like 16 bit images\n    case 16:\n        if (sampleformat == SAMPLEFORMAT_UINT)\n            m_spec.set_format(TypeDesc::UINT16);\n        else if (sampleformat == SAMPLEFORMAT_INT)\n            m_spec.set_format(TypeDesc::INT16);\n        else if (sampleformat == SAMPLEFORMAT_IEEEFP) {\n            m_spec.set_format(TypeDesc::HALF);\n            // Adobe extension, see http://chriscox.org/TIFFTN3d1.pdf\n        } else\n            m_spec.set_format(TypeDesc::UNKNOWN);\n        break;\n    case 24:\n        // Make 24 bit look like 32 bit\n    case 32:\n        if (sampleformat == SAMPLEFORMAT_IEEEFP)\n            m_spec.set_format(TypeDesc::FLOAT);\n        else if (sampleformat == SAMPLEFORMAT_UINT)\n            m_spec.set_format(TypeDesc::UINT32);\n        else if (sampleformat == SAMPLEFORMAT_INT)\n            m_spec.set_format(TypeDesc::INT32);\n        else\n            m_spec.set_format(TypeDesc::UNKNOWN);\n        break;\n    case 64:\n        if (sampleformat == SAMPLEFORMAT_IEEEFP)\n            m_spec.set_format(TypeDesc::DOUBLE);\n        else\n            m_spec.set_format(TypeDesc::UNKNOWN);\n        break;\n    default: m_spec.set_format(TypeDesc::UNKNOWN); break;\n    }\n\n    // Use the table for all the obvious things that can be mindlessly\n    // shoved into the image spec.\n    if (read_meta) {\n        for (const auto& tag : tag_table(\"TIFF\"))\n            find_tag(tag.tifftag, tag.tifftype, tag.name);\n        for (const auto& tag : tag_table(\"Exif\"))\n            find_tag(tag.tifftag, tag.tifftype, tag.name);\n    }\n\n    // Now we need to get fields \"by hand\" for anything else that is less\n    // straightforward...\n\n    readspec_photometric();\n\n    TIFFGetFieldDefaulted(m_tif, TIFFTAG_PLANARCONFIG, &m_planarconfig);\n    m_separate = (m_planarconfig == PLANARCONFIG_SEPARATE\n                  && m_spec.nchannels > 1\n                  && m_photometric != PHOTOMETRIC_PALETTE);\n    m_spec.attribute(\"tiff:PlanarConfiguration\", (int)m_planarconfig);\n    if (m_planarconfig == PLANARCONFIG_SEPARATE)\n        m_spec.attribute(\"planarconfig\", \"separate\");\n    else\n        m_spec.attribute(\"planarconfig\", \"contig\");\n\n    m_compression = 0;\n    TIFFGetFieldDefaulted(m_tif, TIFFTAG_COMPRESSION, &m_compression);\n    m_spec.attribute(\"tiff:Compression\", (int)m_compression);\n    if (const char* compressname = tiff_compression_name(m_compression))\n        m_spec.attribute(\"compression\", compressname);\n    m_predictor = PREDICTOR_NONE;\n    if (!safe_tiffgetfield(\"Predictor\", TIFFTAG_PREDICTOR, &m_predictor))\n        m_predictor = PREDICTOR_NONE;\n\n    m_rowsperstrip = -1;\n    if (!m_spec.tile_width) {\n        TIFFGetField(m_tif, TIFFTAG_ROWSPERSTRIP, &m_rowsperstrip);\n        if (m_rowsperstrip > 0)\n            m_spec.attribute(\"tiff:RowsPerStrip\", m_rowsperstrip);\n    }\n\n    // The libtiff docs say that only uncompressed images, or those with\n    // rowsperstrip==1, support random access to scanlines.\n    m_no_random_access = (m_compression != COMPRESSION_NONE\n                          && m_rowsperstrip != 1);\n\n    // Do we care about fillorder?  No, the TIFF spec says, \"We\n    // recommend that FillOrder=2 (lsb-to-msb) be used only in\n    // special-purpose applications\".  So OIIO will assume msb-to-lsb\n    // convention until somebody finds a TIFF file in the wild that\n    // breaks this assumption.\n\n    unsigned short* sampleinfo  = NULL;\n    unsigned short extrasamples = 0;\n    TIFFGetFieldDefaulted(m_tif, TIFFTAG_EXTRASAMPLES, &extrasamples,\n                          &sampleinfo);\n    // std::cerr << \"Extra samples = \" << extrasamples << \"\\n\";\n    bool alpha_is_unassociated = false;  // basic assumption\n    if (extrasamples) {\n        // If the TIFF ExtraSamples tag was specified, use that to figure\n        // out the meaning of alpha.\n        int colorchannels = 3;\n        if (m_photometric == PHOTOMETRIC_MINISWHITE\n            || m_photometric == PHOTOMETRIC_MINISBLACK\n            || m_photometric == PHOTOMETRIC_PALETTE\n            || m_photometric == PHOTOMETRIC_MASK)\n            colorchannels = 1;\n        for (int i = 0, c = colorchannels;\n             i < extrasamples && c < m_inputchannels; ++i, ++c) {\n            // std::cerr << \"   extra \" << i << \" \" << sampleinfo[i] << \"\\n\";\n            if (sampleinfo[i] == EXTRASAMPLE_ASSOCALPHA) {\n                // This is the alpha channel, associated as usual\n                m_spec.alpha_channel = c;\n            } else if (sampleinfo[i] == EXTRASAMPLE_UNASSALPHA) {\n                // This is the alpha channel, but color is unassociated\n                m_spec.alpha_channel  = c;\n                alpha_is_unassociated = true;\n                if (m_keep_unassociated_alpha)\n                    m_spec.attribute(\"oiio:UnassociatedAlpha\", 1);\n            } else {\n                DASSERT(sampleinfo[i] == EXTRASAMPLE_UNSPECIFIED);\n                // This extra channel is not alpha at all.  Undo any\n                // assumptions we previously made about this channel.\n                if (m_spec.alpha_channel == c) {\n                    m_spec.channelnames[c] = Strutil::sprintf(\"channel%d\", c);\n                    m_spec.alpha_channel   = -1;\n                }\n            }\n        }\n        if (m_spec.alpha_channel >= 0) {\n            m_spec.channelnames[m_spec.alpha_channel] = \"A\";\n            // Special case: \"R\",\"A\" should really be named \"Y\",\"A\", since\n            // the first channel is luminance, not red.\n            if (m_spec.nchannels == 2 && m_spec.alpha_channel == 1)\n                m_spec.channelnames[0] = \"Y\";\n        }\n    }\n    if (alpha_is_unassociated)\n        m_spec.attribute(\"tiff:UnassociatedAlpha\", 1);\n    // Will we need to do alpha conversions?\n    m_convert_alpha = (m_spec.alpha_channel >= 0 && alpha_is_unassociated\n                       && !m_keep_unassociated_alpha);\n\n    // N.B. we currently ignore the following TIFF fields:\n    // GrayResponseCurve GrayResponseUnit\n    // MaxSampleValue MinSampleValue\n    // NewSubfileType SubfileType(deprecated)\n    // Colorimetry fields\n\n    // If we've been instructed to skip reading metadata, because it is\n    // assumed to be identical to what we already have in m_spec,\n    // skip everything following.\n    if (!read_meta)\n        return;\n\n    short resunit = -1;\n    TIFFGetField(m_tif, TIFFTAG_RESOLUTIONUNIT, &resunit);\n    switch (resunit) {\n    case RESUNIT_NONE: m_spec.attribute(\"ResolutionUnit\", \"none\"); break;\n    case RESUNIT_INCH: m_spec.attribute(\"ResolutionUnit\", \"in\"); break;\n    case RESUNIT_CENTIMETER: m_spec.attribute(\"ResolutionUnit\", \"cm\"); break;\n    }\n    float xdensity = m_spec.get_float_attribute(\"XResolution\", 0.0f);\n    float ydensity = m_spec.get_float_attribute(\"YResolution\", 0.0f);\n    if (xdensity && ydensity)\n        m_spec.attribute(\"PixelAspectRatio\", ydensity / xdensity);\n\n    get_matrix_attribute(\"worldtocamera\", TIFFTAG_PIXAR_MATRIX_WORLDTOCAMERA);\n    get_matrix_attribute(\"worldtoscreen\", TIFFTAG_PIXAR_MATRIX_WORLDTOSCREEN);\n    get_int_attribute(\"tiff:subfiletype\", TIFFTAG_SUBFILETYPE);\n    // FIXME -- should subfiletype be \"conventionized\" and used for all\n    // plugins uniformly?\n\n    // Special names for shadow maps\n    char* s = NULL;\n    TIFFGetField(m_tif, TIFFTAG_PIXAR_TEXTUREFORMAT, &s);\n    if (s)\n        m_emulate_mipmap = true;\n    if (s && !strcmp(s, \"Shadow\")) {\n        for (int c = 0; c < m_spec.nchannels; ++c)\n            m_spec.channelnames[c] = \"z\";\n    }\n\n    /// read color profile\n    unsigned int icc_datasize = 0;\n    unsigned char* icc_buf    = NULL;\n    TIFFGetField(m_tif, TIFFTAG_ICCPROFILE, &icc_datasize, &icc_buf);\n    if (icc_datasize && icc_buf)\n        m_spec.attribute(ICC_PROFILE_ATTR,\n                         TypeDesc(TypeDesc::UINT8, icc_datasize), icc_buf);\n\n        // Search for an EXIF IFD in the TIFF file, and if found, rummage\n        // around for Exif fields.\n#if TIFFLIB_VERSION > 20050912 /* compat with old TIFF libs - skip Exif */\n    toff_t exifoffset = 0;\n    if (TIFFGetField(m_tif, TIFFTAG_EXIFIFD, &exifoffset)\n        && TIFFReadEXIFDirectory(m_tif, exifoffset)) {\n        for (const auto& tag : tag_table(\"Exif\"))\n            find_tag(tag.tifftag, tag.tifftype, tag.name);\n        // Look for a Makernote\n        auto makerfield = find_field(EXIF_MAKERNOTE, TIFF_UNDEFINED);\n        // std::unique_ptr<uint32_t[]> buf (new uint32_t[]);\n        if (makerfield) {\n            // bool ok = TIFFGetField (m_tif, tag, dest, &ptr);\n            unsigned int mn_datasize = 0;\n            unsigned char* mn_buf    = NULL;\n            TIFFGetField(m_tif, EXIF_MAKERNOTE, &mn_datasize, &mn_buf);\n        }\n        // I'm not sure what state TIFFReadEXIFDirectory leaves us.\n        // So to be safe, close and re-seek.\n        TIFFClose(m_tif);\n#    ifdef _WIN32\n        std::wstring wfilename = Strutil::utf8_to_utf16(m_filename);\n        m_tif                  = TIFFOpenW(wfilename.c_str(), \"rm\");\n#    else\n        m_tif = TIFFOpen(m_filename.c_str(), \"rm\");\n#    endif\n        if (m_subimage)\n            TIFFSetDirectory(m_tif, m_subimage);\n\n        // A few tidbits to look for\n        ParamValue* p;\n        if ((p = m_spec.find_attribute(\"Exif:ColorSpace\", TypeDesc::INT))) {\n            // Exif spec says that anything other than 0xffff==uncalibrated\n            // should be interpreted to be sRGB.\n            if (*(const int*)p->data() != 0xffff)\n                m_spec.attribute(\"oiio:ColorSpace\", \"sRGB\");\n        }\n    }\n#endif\n\n#if TIFFLIB_VERSION >= 20051230\n    // Search for IPTC metadata in IIM form -- but older versions of\n    // libtiff botch the size, so ignore it for very old libtiff.\n    int iptcsize         = 0;\n    const void* iptcdata = NULL;\n    if (TIFFGetField(m_tif, TIFFTAG_RICHTIFFIPTC, &iptcsize, &iptcdata)) {\n        std::vector<uint32> iptc((uint32*)iptcdata,\n                                 (uint32*)iptcdata + iptcsize);\n        if (TIFFIsByteSwapped(m_tif))\n            TIFFSwabArrayOfLong((uint32*)&iptc[0], iptcsize);\n        decode_iptc_iim(&iptc[0], iptcsize * 4, m_spec);\n    }\n#endif\n\n    // Search for an XML packet containing XMP (IPTC, Exif, etc.)\n    int xmlsize         = 0;\n    const void* xmldata = NULL;\n    if (TIFFGetField(m_tif, TIFFTAG_XMLPACKET, &xmlsize, &xmldata)) {\n        // std::cerr << \"Found XML data, size \" << xmlsize << \"\\n\";\n        if (xmldata && xmlsize) {\n            std::string xml((const char*)xmldata, xmlsize);\n            decode_xmp(xml, m_spec);\n        }\n    }\n\n#if 0\n    // Experimental -- look for photoshop data\n    int photoshopsize = 0;\n    const void *photoshopdata = NULL;\n    if (TIFFGetField (m_tif, TIFFTAG_PHOTOSHOP, &photoshopsize, &photoshopdata)) {\n        std::cerr << \"Found PHOTOSHOP data, size \" << photoshopsize << \"\\n\";\n        if (photoshopdata && photoshopsize) {\n//            std::string photoshop ((const char *)photoshopdata, photoshopsize);\n//            std::cerr << \"PHOTOSHOP:\\n\" << photoshop << \"\\n---\\n\";\n        }\n    }\n#endif\n\n    // If Software and IPTC:OriginatingProgram are identical, kill the latter\n    if (m_spec.get_string_attribute(\"Software\")\n        == m_spec.get_string_attribute(\"IPTC:OriginatingProgram\"))\n        m_spec.erase_attribute(\"IPTC:OriginatingProgram\");\n\n    std::string desc = m_spec.get_string_attribute(\"ImageDescription\");\n    // If ImageDescription and IPTC:Caption are identical, kill the latter\n    if (desc == m_spec.get_string_attribute(\"IPTC:Caption\"))\n        m_spec.erase_attribute(\"IPTC:Caption\");\n\n    // Because TIFF doesn't support arbitrary metadata, we look for certain\n    // hints in the ImageDescription and turn them into metadata, also\n    // removing them from the ImageDescrption.\n    bool updatedDesc = false;\n    auto cc = Strutil::excise_string_after_head(desc, \"oiio:ConstantColor=\");\n    if (cc.size()) {\n        m_spec.attribute(\"oiio:ConstantColor\", cc);\n        updatedDesc = true;\n    }\n    auto ac = Strutil::excise_string_after_head(desc, \"oiio:AverageColor=\");\n    if (ac.size()) {\n        m_spec.attribute(\"oiio:AverageColor\", ac);\n        updatedDesc = true;\n    }\n    std::string sha = Strutil::excise_string_after_head(desc, \"oiio:SHA-1=\");\n    if (sha.empty())  // back compatibility with OIIO < 1.5\n        sha = Strutil::excise_string_after_head(desc, \"SHA-1=\");\n    if (sha.size()) {\n        m_spec.attribute(\"oiio:SHA-1\", sha);\n        updatedDesc = true;\n    }\n\n    if (updatedDesc) {\n        string_view d(desc);\n        Strutil::skip_whitespace(d);  // erase if it's only whitespace\n        if (d.size())\n            m_spec.attribute(\"ImageDescription\", desc);\n        else\n            m_spec.erase_attribute(\"ImageDescription\");\n    }\n\n    // Squash some problematic texture metadata if we suspect it's wrong\n    pvt::check_texture_metadata_sanity(m_spec);\n\n    if (m_testopenconfig)  // open-with-config debugging\n        m_spec.attribute(\"oiio:DebugOpenConfig!\", 42);\n}",
    "bool\nTIFFOutput::close()\n{\n    if (m_tif) {\n        write_exif_data();\n        TIFFClose(m_tif);  // N.B. TIFFClose doesn't return a status code\n    }\n    init();       // re-initialize\n    return true;  // How can we fail?\n}",
    "~TiffFile() {\n         if( tiff_ ) {\n            TIFFClose( tiff_ );\n         }\n      }",
    "bool CTIFFReader::Open()\n{\n\tZFUNCTRACE_RUNTIME();\n\n\t//\n\t// Used for reading lengths of TIFF custom tags.  Different tags\n\t// return length as uint8, uint16, uint16[2], or uint32\n\t//\n\tunion\n\t{\n\t\tuint32_t Long;\n\t\tuint16_t Short1;\n\t\tuint16_t Short2[2];\n\t\tuint8_t Char[4];\n\t} unionLong{ 0 };\n\n\t// Used to read pointer to data when reading custom tags\n\tvoid* pVoidArray{ nullptr };\n\n\tbool\t\t\tbResult = false;\n\tQSettings\t\tsettings;\n\n\tconst auto dwSkipExifInfo = settings.value(\"SkipTIFFExifInfo\", uint(0)).toUInt();\n\n\t//\n\t// Quietly attempt to open the putative TIFF file \n\t//\n\tTIFFErrorHandler\toldHandler = TIFFSetErrorHandler(nullptr);\n\tTIFFErrorHandlerExt\toldHandlerExt = TIFFSetErrorHandlerExt(nullptr);\n#ifdef Q_OS_WIN\n\tm_tiff = TIFFOpenW(file.wstring().c_str(), \"r\");\n#else\n\tm_tiff = TIFFOpen(reinterpret_cast<const char*>(file.u8string().c_str()), \"r\");\n#endif\n\tTIFFSetErrorHandler(oldHandler);\n\tTIFFSetErrorHandlerExt(oldHandlerExt);\n\n\tif (m_tiff != nullptr)\n\t{\n\t\tZTRACE_RUNTIME(\"Opened %s\", file.generic_u8string().c_str());\n\n\t\tcfa = false;\n\t\tcfatype = CFATYPE_NONE;\n\t\tmaster = 0;\n\t\tsamplemin = 0;\n\t\tsamplemax = 1.0;\n\t\texposureTime = 0.0;\n\t\tisospeed = 0;\n\t\tgain = -1;\n\n\t\tTIFFGetField(m_tiff,TIFFTAG_IMAGEWIDTH, &w);\n        TIFFGetField(m_tiff,TIFFTAG_IMAGELENGTH, &h);\n\n\t\tif (!TIFFGetField(m_tiff, TIFFTAG_COMPRESSION, &compression))\n\t\t\tcompression = COMPRESSION_NONE;\n\t\tif (!TIFFGetField(m_tiff, TIFFTAG_BITSPERSAMPLE, &bps))\n\t\t\tbps = 1;\n\t\tif (!TIFFGetField(m_tiff, TIFFTAG_SAMPLESPERPIXEL, &spp))\n\t\t\tspp = 1;\n\t\tif (!TIFFGetField(m_tiff, TIFFTAG_PLANARCONFIG, &planarconfig))\n\t\t\tplanarconfig = PLANARCONFIG_CONTIG;\n\t\tTIFFGetField(m_tiff, TIFFTAG_PHOTOMETRIC, &photo);\n\t\tif (!TIFFGetField(m_tiff, TIFFTAG_SAMPLEFORMAT, &sampleformat))\n\t\t\tsampleformat = SAMPLEFORMAT_UINT;\n\n\t\tif (!TIFFGetField(m_tiff, TIFFTAG_DSS_MASTER, &master))\n\t\t\tmaster = 0;\n\n\t\tchar *\t\t\t\tszMake = nullptr;\n\t\tchar *\t\t\t\tszModel = nullptr;\n\n\t\tif (TIFFGetField(m_tiff, TIFFTAG_MODEL, &szModel))\n\t\t\tstrMakeModel = szModel;\n\t\telse if (TIFFGetField(m_tiff, TIFFTAG_MAKE, &szMake))\n\t\t\tstrMakeModel = szMake;\n\n\t\tif (!TIFFGetField(m_tiff, TIFFTAG_DSS_ISO, &isospeed))\n\t\t\tisospeed = 0;\n\t\tif (!TIFFGetField(m_tiff, TIFFTAG_DSS_GAIN, &gain))\n\t\t\tgain = -1;\n\t\tif (!TIFFGetField(m_tiff, TIFFTAG_DSS_APERTURE, &aperture))\n\t\t\taperture = 0.0;\n\t\tif (!TIFFGetField(m_tiff, TIFFTAG_DSS_TOTALEXPOSURE, &exposureTime))\n\t\t{\n\t\t\tint\t\t\tlExposure;\n\t\t\tif (TIFFGetField(m_tiff, TIFFTAG_DSS_TOTALEXPOSUREOLD, &lExposure))\n\t\t\t\texposureTime = lExposure;\n\t\t}\n\n\t\t// Check that this is a compatible TIFF format\n\t\t// Support is :\n\t\t// 8, 16, 32 bits per pixels (with slight restriction on format)\n\t\t// No compression or LZW compression or ZIP (deflate) compression\n\t\t// sample per pixel 1 (gray levels) or 3 (rgb)\n\t\tif ((planarconfig == PLANARCONFIG_CONTIG) &&\n\t\t\t((compression == COMPRESSION_NONE) ||\n\t\t\t (compression == COMPRESSION_LZW) ||\n\t\t\t (compression == COMPRESSION_DEFLATE) ||\n\t\t\t (compression == COMPRESSION_ADOBE_DEFLATE)) &&\n\t\t\t((spp == 3) || (spp==4) || (spp == 1)))\n\t\t{\n\t\t\tif ((bps == 8) || (bps == 16))\n\t\t\t{\n\t\t\t\tbResult = (sampleformat == SAMPLEFORMAT_UINT) ||\n\t\t\t\t\t\t  (sampleformat == SAMPLEFORMAT_INT);\n\t\t\t}\n\t\t\telse if (bps == 32)\n\t\t\t{\n\t\t\t\tbResult = (sampleformat == SAMPLEFORMAT_UINT) ||\n\t\t\t\t\t(sampleformat == SAMPLEFORMAT_INT) ||\n\t\t\t\t\t(sampleformat == SAMPLEFORMAT_IEEEFP);\n\n\t\t\t\tif (sampleformat == SAMPLEFORMAT_IEEEFP)\n\t\t\t\t{\n\t\t\t\t\t// Read min/max values\n\t\t\t\t\tTIFFGetField(m_tiff, TIFFTAG_SMINSAMPLEVALUE, &samplemin);\n\t\t\t\t\tTIFFGetField(m_tiff, TIFFTAG_SMAXSAMPLEVALUE, &samplemax);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (bResult)\n\t\t\t{\n\t\t\t\tif ((spp == 3) || (spp == 4))\n\t\t\t\t\tbResult = (PHOTOMETRIC_RGB == photo);\n\t\t\t\telse if (spp == 1)\n\t\t\t\t\tbResult = (PHOTOMETRIC_MINISBLACK == photo || PHOTOMETRIC_CFA == photo);\n\t\t\t}\n\t\t}\n\n\t\t// Retrieve the Date/Time as in the TIFF TAG\n\t\tchar* szDateTime;\n\n\t\tif (TIFFGetField(m_tiff, TIFFTAG_DATETIME, &szDateTime))\n\t\t{\n\t\t\tQString\tstrDateTime{ szDateTime };\n\n\t\t\t// Decode 2007:11:02 22:07:03\n\t\t\t//        0123456789012345678\n\n\t\t\tif (strDateTime.length() >= 19)\n\t\t\t{\n\t\t\t\tm_DateTime = QDateTime::fromString(strDateTime, \"yyyy:MM:dd hh:mm:ss\");\n\t\t\t}\n\t\t}\n\n\t\t//\n\t\t// Attempt to read the CFA from the root IFD if this is could be a CFA image\n\t\t//\n\t\tif (bResult && 1 == spp)\n\t\t{\n\t\t\tif (PHOTOMETRIC_CFA == photo) ZTRACE_RUNTIME(\"TIFFTAG_PHOTOMETRIC is set to PHOTOMETRIC_CFA\");\n\t\t\telse ZTRACE_RUNTIME(\"TIFFTAG_PHOTOMETRIC is set to PHOTOMETRIC_MINISBLACK\");\n\t\t\tint count{ 0 };\n\n\t\t\tZTRACE_RUNTIME(\"Checking for TIFFTAG_CFAREPEATPATTERNDIM, TIFFTAG_CFAPATTERN\");\n\n\t\t\tif (TIFFGetField(m_tiff, TIFFTAG_CFAREPEATPATTERNDIM, &pVoidArray))\n\t\t\t{\n\t\t\t\tZTRACE_RUNTIME(\"TIFFTAG_CFAREPEATPATTERNDIM read OK\");\n\t\t\t\tcfaDimPat = {};\t\t// clear the Dimension and Pattern structure\n\t\t\t\tmemcpy(&cfaDimPat.dim, pVoidArray, sizeof(cfaDimPat.dim));\n\n\t\t\t\tint patternSize{ cfaDimPat.dim[0] * cfaDimPat.dim[1] };\n\n\t\t\t\tif (TIFFGetField(m_tiff, TIFFTAG_CFAPATTERN, &unionLong, &pVoidArray))\n\t\t\t\t{\n\t\t\t\t\tZTRACE_RUNTIME(\"TIFFTAG_CFAPATTERN read OK\");\n\t\t\t\t\tcount = unionLong.Short1;\n\t\t\t\t\tZASSERT(count == patternSize && count <= sizeof(cfaDimPat.cfa));\n\t\t\t\t\tmemcpy(&cfaDimPat.cfa, pVoidArray, count);\n\t\t\t\t\tdecodeCfaDimPat(patternSize, \"TIFFTAG_CFAPATTERN\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (dwSkipExifInfo == 0)\n\t\t{\n\t\t\t// Try to read EXIF data\n\t\t\tuint64_t ExifID;\n\n\t\t\tif (TIFFGetField(m_tiff, TIFFTAG_EXIFIFD, &ExifID))\n\t\t\t{\n\t\t\t\t//\n\t\t\t\t// Get current TIFF Directory so we can return to it\n\t\t\t\t//\n\t\t\t\tauto currentIFD = TIFFCurrentDirectory(m_tiff);\n\t\t\t\tif (TIFFReadEXIFDirectory(m_tiff, ExifID))\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFGetField(m_tiff, EXIFTAG_EXPOSURETIME, &exposureTime))\n\t\t\t\t\t\texposureTime = 0.0;\n\n\t\t\t\t\tif (!TIFFGetField(m_tiff, EXIFTAG_FNUMBER, &aperture))\n\t\t\t\t\t\taperture = 0.0;\n\n\t\t\t\t\t// EXIFTAG_ISOSPEEDRATINGS is an array of uint16 according to the EXIF spec\n\t\t\t\t\tisospeed = 0;\n\t\t\t\t\tuint16_t\tcount = 0;\n\t\t\t\t\tuint16_t* iso_setting = nullptr;\n\t\t\t\t\tif (TIFFGetField(m_tiff, EXIFTAG_ISOSPEEDRATINGS, &count, &iso_setting))\n\t\t\t\t\t{\n\t\t\t\t\t\tisospeed = iso_setting[0];\n\t\t\t\t\t}\n\t\t\t\t\telse isospeed = 0;\n\n\t\t\t\t\t// EXIFTAG_GAINCONTROL does not represent a gain value, so ignore it.\n\n\t\t\t\t\t//\n\t\t\t\t\t// If we've not yet detected a cfa pattern interrogate EXIFTAG_CFAPATTERN\n\t\t\t\t\t//\n\t\t\t\t\tif (!cfa && spp == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tZTRACE_RUNTIME(\"Checking for EXIF_CFAPATTERN tag\");\n\n\t\t\t\t\t\tif (TIFFGetField(m_tiff, EXIFTAG_CFAPATTERN, &unionLong, &pVoidArray))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmemcpy(&cfaDimPat, pVoidArray, unionLong.Short1);\n\t\t\t\t\t\t\tdecodeCfaDimPat(cfaDimPat.dim[0] * cfaDimPat.dim[1], \"EXIFTAG_CFAPATTERN\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Revert IFD to status quo ante TIFFReadEXIFDirectory\n\t\t\t\t\t//\n\t\t\t\t\tTIFFSetDirectory(m_tiff, currentIFD);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tCBitmapInfo\t\t\tBitmapInfo;\n\t\t\tif (RetrieveEXIFInfo(file, BitmapInfo))\n\t\t\t{\n\t\t\t\texposureTime = BitmapInfo.m_fExposure;\n\t\t\t\taperture\t = BitmapInfo.m_fAperture;\n\t\t\t\tisospeed\t = BitmapInfo.m_lISOSpeed;\n\t\t\t\tgain\t\t = BitmapInfo.m_lGain;\n\t\t\t\tm_DateTime\t = BitmapInfo.m_DateTime;\n\t\t\t}\n\t\t}\n\n\t\t//\n\t\t// If we have not yet found a setting for the CFA look to see if\n\t\t// it is recorded in our private TIFF tags.\n\t\t//\n\t\tif (!cfa && spp == 1)\n\t\t{\n\t\t\tZTRACE_RUNTIME(\"CFAType not yet set: Checking DSS private TIFF tags\");\n\t\t\tint32_t cfaValue = 0;\n\n\t\t\tif (!TIFFGetField(m_tiff, TIFFTAG_DSS_CFA, &cfaValue))\n\t\t\t\tcfaValue = 0;\n\t\t\tif (0 != cfaValue)\n\t\t\t\tcfa = true;\n\t\t\tif (TIFFGetField(m_tiff, TIFFTAG_DSS_CFATYPE, &cfatype))\n\t\t\t{\n\t\t\t\tZTRACE_RUNTIME(\"CFAType set to %u\", cfatype);\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tcfa = false;\n\t\t\t\tcfatype = CFATYPE_NONE;\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\t\t// If this file is an eight bit TIFF, and purports to have a Bayer pattern\n\t\t// inform the the user that we aren't going to play\n\t\t//\n\t\tif ((1 == spp) && (8 == bps) && cfa)\n\t\t{\n\t\t\t// \n\t\t\t// Set CFA type to none even if the TIFF tags specified otherwise\n\t\t\t//\n\t\t\tcfatype = CFATYPE_NONE;\n\t\t\tcfa = false;\n\t\t\tQString errorMessage{ QCoreApplication::translate(\"TIFFUtil\",\n\t\t\t\t\t\t\t\t\t\"DeepSkyStacker will not de-Bayer 8 bit images\",\n\t\t\t\t\t\t\t\t\t\"IDS_8BIT_FITS_NODEBAYER\") };\n\t\t\tDSSBase::instance()->reportError(\n\t\t\t\terrorMessage,\n\t\t\t\t\"Will not de-Bayer 8 bit images\",\n\t\t\t\tDSSBase::Severity::Warning,\n\t\t\t\tDSSBase::Method::QErrorMessage);\n\t\t}\n\n\n\n\n\t\tif (bResult)\n\t\t\tbResult = OnOpen();\n\t\tif (!bResult)\n\t\t{\n\t\t\tTIFFClose(m_tiff);\n\t\t\tm_tiff = nullptr;\n\t\t}\n\t}\n\n\treturn bResult;\n}",
    "bool CTIFFReader::Close()\n{\n\tZFUNCTRACE_RUNTIME();\n\tbool\t\t\tbResult = true;\n\tif (m_tiff != nullptr)\n\t{\n\t\tbResult = OnClose();\n\t\tif (bResult)\n\t\t{\n\t\t\tTIFFClose(m_tiff);\n\t\t\tm_tiff = nullptr;\n\t\t}\n\t}\n\n\treturn bResult;\n}",
    "bool CTIFFWriter::Open()\n{\n\tZFUNCTRACE_RUNTIME();\n\tbool bResult = false;\n\tconstexpr unsigned char exifVersion[4] {'0', '2', '3', '1' }; // EXIF 2.31 version is 4 characters of a string!\n\tuint64_t dir_offset_EXIF{ 0 };\n\n#ifdef Q_OS_WIN\n\tm_tiff = TIFFOpenW(file.wstring().c_str(), \"w\");\n#else\n\tm_tiff = TIFFOpen(reinterpret_cast<const char*>(file.u8string().c_str()), \"w\");\n#endif\n\tif (m_tiff != nullptr)\n\t{\n\t\tphoto = PHOTOMETRIC_RGB;\n\n\t\tbResult = OnOpen();\n\t\tif (bResult)\n\t\t{\n\t\t\tTIFFSetField(m_tiff, TIFFTAG_IMAGEWIDTH, w);\n\t\t\tTIFFSetField(m_tiff, TIFFTAG_IMAGELENGTH, h);\n\t\t\tTIFFSetField(m_tiff, TIFFTAG_COMPRESSION, compression);\n\n\t\t\tTIFFSetField(m_tiff, TIFFTAG_BITSPERSAMPLE, bps);\n\t\t\tTIFFSetField(m_tiff, TIFFTAG_SAMPLESPERPIXEL, spp);\n\t\t\tTIFFSetField(m_tiff, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\n\t\t\tif (spp == 1)\n\t\t\t{\n\t\t\t\t//\n\t\t\t\t// Only support CFA types BGGR, GRBG, GBRG, RGGB\n\t\t\t\t//\n\t\t\t\tif (cfa && cfatype >= static_cast<uint32_t>(CFATYPE_BGGR) && cfatype <= static_cast<uint32_t>(CFATYPE_RGGB))\n\t\t\t\t{\n\t\t\t\t\tcfaDimPat = {};\n\t\t\t\t\t// TIFFSetField(m_tiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_CFA);  // Don't use this - breaks too many things\n\t\t\t\t\tcfaDimPat.dim[0] = 2; cfaDimPat.dim[1] = 2;\n\t\t\t\t\tTIFFSetField(m_tiff, TIFFTAG_CFAREPEATPATTERNDIM, cfaDimPat.dim);\n\t\t\t\t\t//\n\t\t\t\t\t// Note that when writing the CFA pattern, need to specify how many\n\t\t\t\t\t// octets are to be written.\n\t\t\t\t\t//\n\t\t\t\t\tswitch (cfatype)\n\t\t\t\t\t{\n\t\t\t\t\tcase CFATYPE_BGGR:\n\t\t\t\t\t\tmemcpy(cfaDimPat.cfa.cfa4, TIFF_CFAPattern_BGGR.data(), sizeof(cfaDimPat.cfa.cfa4));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CFATYPE_GRBG:\n\t\t\t\t\t\tmemcpy(cfaDimPat.cfa.cfa4, TIFF_CFAPattern_GRBG.data(), sizeof(cfaDimPat.cfa.cfa4));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CFATYPE_GBRG:\n\t\t\t\t\t\tmemcpy(cfaDimPat.cfa.cfa4, TIFF_CFAPattern_GBRG.data(), sizeof(cfaDimPat.cfa.cfa4));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CFATYPE_RGGB:\n\t\t\t\t\t\tmemcpy(cfaDimPat.cfa.cfa4, TIFF_CFAPattern_RGGB.data(), sizeof(cfaDimPat.cfa.cfa4));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tTIFFSetField(m_tiff, TIFFTAG_CFAPATTERN, 4, cfaDimPat.cfa.cfa4);\n\n\t\t\t\t}\n\t\t\t\tphoto = PHOTOMETRIC_MINISBLACK;\n\t\t\t}\n\t\t\t\n\t\t\tTIFFSetField(m_tiff, TIFFTAG_PHOTOMETRIC, photo);\n\n\t\t\tTIFFSetField(m_tiff, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n\t\t\tTIFFSetField(m_tiff, TIFFTAG_SAMPLEFORMAT, sampleformat);\n\n\t\t\t//\n\t\t\t// Following line commented out as enabling this broke Photoshop (16 August 2020)\n\t\t\t//\n\t\t\t//if (IsFloat()) TIFFSetField(m_tiff, TIFFTAG_PREDICTOR, PREDICTOR_FLOATINGPOINT);\n\n\t\t\tif (samplemax != samplemin)\n\t\t\t{\n\t\t\t\tTIFFSetField(m_tiff, TIFFTAG_SMINSAMPLEVALUE, samplemin);\n\t\t\t\tTIFFSetField(m_tiff, TIFFTAG_SMAXSAMPLEVALUE, samplemax);\n\t\t\t}\n\n\t\t\t//\n\t\t\t// Set Software name in the same way we do elsewhere.\n\t\t\t//\n\t\t\tconst QString strSoftware{ QString(\"DeepSkyStacker %1\").arg(VERSION_DEEPSKYSTACKER) };\n\t\t\tTIFFSetField(m_tiff, TIFFTAG_SOFTWARE, strSoftware.toLatin1().constData());\n\n\t\t\tif (!m_strDescription.isEmpty())\n\t\t\t{\n\t\t\t\tTIFFSetField(m_tiff, TIFFTAG_IMAGEDESCRIPTION, m_strDescription.toStdString().c_str());\n\t\t\t}\n\n\t\t\tif (m_DateTime.isValid())\n\t\t\t{\n\t\t\t\t// Set the DATETIME TIFF tag\n\t\t\t\tQString strDateTime = m_DateTime.toString(\"yyyy:MM:dd hh:mm:ss\");\n\n\t\t\t\tTIFFSetField(m_tiff, TIFFTAG_DATETIME, strDateTime.toStdString().c_str());\n\t\t\t}\n\n\t\t\t/* It is good to set resolutions too (but it is not nesessary) */\n\t\t\tTIFFSetField(m_tiff, TIFFTAG_XRESOLUTION, 100.0f);\n\t\t\tTIFFSetField(m_tiff, TIFFTAG_YRESOLUTION, 100.0f);\n\t\t\tTIFFSetField(m_tiff, TIFFTAG_RESOLUTIONUNIT, RESUNIT_INCH);\n\n\t\t\tif (cfa)\n\t\t\t\tTIFFSetField(m_tiff, TIFFTAG_DSS_CFA, cfa ? 1 : 0);\n\t\t\tif (cfa && cfatype)\n\t\t\t\tTIFFSetField(m_tiff, TIFFTAG_DSS_CFATYPE, cfatype);\n\n\t\t\tif (master)\n\t\t\t\tTIFFSetField(m_tiff, TIFFTAG_DSS_MASTER, master);\n\n\t\t\tif (isospeed)\n\t\t\t\tTIFFSetField(m_tiff, TIFFTAG_DSS_ISO, isospeed);\n\n\t\t\tif (gain >= 0)\n\t\t\t\tTIFFSetField(m_tiff, TIFFTAG_DSS_GAIN, gain);\n\n\t\t\tif (exposureTime)\n\t\t\t\tTIFFSetField(m_tiff, TIFFTAG_DSS_TOTALEXPOSURE, exposureTime);\n\n\t\t\tif (aperture)\n\t\t\t\tTIFFSetField(m_tiff, TIFFTAG_DSS_APERTURE, aperture);\n\n\t\t\tif (nrframes)\n\t\t\t\tTIFFSetField(m_tiff, TIFFTAG_DSS_NRFRAMES, nrframes);\n\n\t\t\tconst tmsize_t scanLineSize = TIFFScanlineSize(m_tiff);\n\t\t\tZTRACE_RUNTIME(\"TIFF Scan Line Size %zu\", scanLineSize);\n\n\t\t\t//\n\t\t\t// Work out how many scanlines fit into the default strip\n\t\t\t//\n\t\t\tconst unsigned int rowsPerStrip = STRIP_SIZE_DEFAULT / scanLineSize;\n\n\t\t\tZTRACE_RUNTIME(\"Seting TIFFTAG_ROWSPERSTRIP to: %u\", rowsPerStrip);\n\t\t\tTIFFSetField(m_tiff, TIFFTAG_ROWSPERSTRIP, rowsPerStrip);\n\n\t\t\tint numStrips = h / rowsPerStrip;\n\t\t\t//\n\t\t\t// If it wasn't an exact division (IOW there's a remainder), add one\n\t\t\t// for the final (short) strip.\n\t\t\t//\n\t\t\tif (0 != (h % rowsPerStrip))\n\t\t\t\t++numStrips;\n\n\t\t\t//\n\t\t\t// Pre-fill the StripOffsets and StripByteCounts tags with values of zero.\n\t\t\t// \n\t\t\t// The values will be updated when the data is actually written, but the size\n\t\t\t// of the base IFD won't change which in turn means it can be rewritten in \n\t\t\t// the same location as the file is closed.\n\t\t\t// \n\t\t\t// Turn off the TIFF error handle while we do this, otherwise an error message\n\t\t\t// \n\t\t\t//\t\tZIPEncode: Encoder error: buffer error.\n\t\t\t//\n\t\t\t// is issued for each empty strip.\n\t\t\t//\n\t\t\tTIFFErrorHandler    oldHandler = TIFFSetErrorHandler(nullptr);\n\t\t\tTIFFErrorHandlerExt oldHandlerExt = TIFFSetErrorHandlerExt(nullptr);\n\t\t\tZTRACE_RUNTIME(\"Writing %d empty encoded strips\", numStrips);\n\t\t\tfor (int strip = 0; strip < numStrips; ++strip)\n\t\t\t{\n\t\t\t\tTIFFWriteEncodedStrip(m_tiff, strip, nullptr, 0);\n\t\t\t}\n\t\t\tTIFFSetErrorHandler(oldHandler);\n\t\t\tTIFFSetErrorHandlerExt(oldHandlerExt);\n\n\n\t\t\t//***************************************************************************\n\t\t\t// \n\t\t\t// Now write the EXIF IFD\n\t\t\t// \n\t\t\t// **************************************************************************\n\t\t\t\n\t\t\t//\n\t\t\t// Set a dummy EXIF tag in the original tiff-structure in order to reserve\n\t\t\t// space for final dir_offset value, which is properly written at the end.\n\t\t\t// \n\t\t\t// Initially use a value of 0 for dir_offset_EXIF\n\t\t\t//\n\t\t\tTIFFSetField(m_tiff, TIFFTAG_EXIFIFD, dir_offset_EXIF);\n\n\t\t\t//\n\t\t\t// Save current tiff-directory to file before directory is changed.\n\t\t\t// Otherwise it will be lost! The tif-structure is overwritten/ freshly\n\t\t\t// initialized by any \"CreateDirectory\"\n\t\t\t//\n\t\t\tTIFFWriteDirectory(m_tiff);\n\t\t\t//\n\t\t\t// Get current TIFF Directory so we can return to it\n\t\t\t//\n\t\t\tconst auto currentIFD = TIFFCurrentDirectory(m_tiff);\n\t\t\tTIFFCreateEXIFDirectory(m_tiff);\n\t\t\tTIFFSetField(m_tiff, EXIFTAG_EXIFVERSION, exifVersion);\n\n\t\t\t//\n\t\t\t// Now we can write EXIF tags we want to ...\n\t\t\t//\n\t\t\tif (0.0 != exposureTime)\n\t\t\t{\n\t\t\t\tTIFFSetField(m_tiff, EXIFTAG_EXPOSURETIME, exposureTime);\n\t\t\t}\n\t\t\tif (0.0 != aperture)\n\t\t\t{\n\t\t\t\tTIFFSetField(m_tiff, EXIFTAG_FNUMBER, aperture);\n\t\t\t}\n\t\t\tif (0 != isospeed)\n\t\t\t{\n\t\t\t\t// EXIFTAG_ISOSPEEDRATINGS is array of uint16 according to the EXIF spec\n\t\t\t\tconstexpr uint16_t count = 1U;\n\t\t\t\tconst uint16_t iso_setting = static_cast<uint16_t>(isospeed);\n\t\t\t\tTIFFSetField(m_tiff, EXIFTAG_ISOSPEEDRATINGS, count, &iso_setting);\n\t\t\t}\n\t\t\t\n\t\t\t//\n\t\t\t// Now write EXIFTAG_CFAPATTERN which is basically what we put into cfaDimPat \n\t\t\t// when the other (non-EXIF) CFA related tags were written.\n\t\t\t//\n\t\t\tif (cfa)\n\t\t\t{\n\t\t\t\tconstexpr uint16_t count = sizeof(cfaDimPat.dim) + sizeof(cfaDimPat.cfa.cfa4);\n\t\t\t\tTIFFSetField(m_tiff, EXIFTAG_CFAPATTERN, count, cfaDimPat);\n\t\t\t}\n\t\t\t\n\t\t\t//\n\t\t\t// Now that all the EXIF tags are written, need to write the EXIF\n\t\t\t// custom directory into the file...\n\t\t\t// \n\t\t\t// WriteCustomDirectory returns the actual offset of the EXIF directory.\n\t\t\t//\n\t\t\tTIFFWriteCustomDirectory(m_tiff, &dir_offset_EXIF);\n\n\t\t\t// Go back to the first (main) directory, and set correct value of the\n\t\t\t// EXIFIFD pointer. Note that the directory is reloaded from the file!\n\t\t\t//\n\t\t\tTIFFSetDirectory(m_tiff, currentIFD);\n\t\t\tTIFFSetField(m_tiff, TIFFTAG_EXIFIFD, dir_offset_EXIF);\n\t\t\tTIFFCheckpointDirectory(m_tiff);\n\n\t\t\t//\n\t\t\t// The ZIP compression level must be set after the ZIP state has been re-initialised by TIFFSetDirectory().\n\t\t\t//\n\t\t\tif (COMPRESSION_DEFLATE == compression) TIFFSetField(m_tiff, TIFFTAG_ZIPQUALITY, Z_BEST_SPEED);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tTIFFClose(m_tiff);\n\t\t\tm_tiff = nullptr;\n\t\t}\n\t}\n\n\treturn bResult;\n}",
    "bool CTIFFWriter::Close()\n{\n\tZFUNCTRACE_RUNTIME();\n\tbool\t\t\tbResult = true;\n\n\tif (m_tiff != nullptr)\n\t{\n\t\tbResult = OnClose();\n\t\t//\n\t\t// Write the updated base IFD to disk.  This is only safe to do if the directory SIZE\n\t\t// hasn't changed at all since the end of the Open() member function.\n\t\t// \n\t\t// This should be be case if the number of entries in the StripOffsets and StripByteCounts\n\t\t// tags haven't changed.\n\t\t//\n\t\tTIFFWriteDirectory(m_tiff);\n\t\tif (bResult)\n\t\t{\n\t\t\tTIFFClose(m_tiff);\n\t\t\tm_tiff = nullptr;\n\t\t}\n\t}\n\n\treturn bResult;\n}",
    "void image_info::readtif(const char *filename){\n#ifdef USE_LIBTIFF\n#ifdef _USE_DL_\n  if(!have_tiff){\n    if(init_tiff(LIBTIFF_SOLIBRARY)){ \n      have_tiff = 1;\n    }\n  }\n  if(!have_tiff){\n    printf(\"tiff library not found\\n\");\n    printf(\"Please try reading from a supported format\\n\");\n    return;\n  }\n#endif  \n  TIFF* tif = TIFFOpen(filename, \"r\");\n  uint16 spp;\n  TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &spp);\n  TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n  TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n  if(spp!=1&&spp!=3&&spp!=4){\n    uint32 tileWidth, tileLength;\n    uint32 *bc, *bc2;\n    bool istiled = true, isstripped = true;\n    int success = TIFFGetField(tif, TIFFTAG_TILEWIDTH, &tileWidth);\n    if(!success)  istiled = false;\n    success = TIFFGetField(tif, TIFFTAG_TILELENGTH, &tileLength);\n    if(!success)  istiled = false;\n    success = TIFFGetField(tif, TIFFTAG_STRIPBYTECOUNTS, &bc);\n    if(!success)  isstripped = false;\n    uint32 stripsize = bc[0];\n    success = TIFFGetField(tif,  TIFFTAG_TILEBYTECOUNTS, &bc2);\n    if(!success)  isstripped = false;\n    uint32 tilesize = bc2[0];\n    if(istiled&&isstripped) {\n      printf(\"Seems to be tiled and stripped in readtiff.\\n\");\n      printf(\"Unlikley!!, quitting ...\\n\");\n      return;\n    }\n    if(istiled) {\n      pixels = new unsigned char[width*height*spp];\n      colourspace = spp;\n      if(spp==2){\n        colourspace_type = IMAGEINFO_MONOA;\n      }else{\n        printf(\"Unsupported samples per pixel in readtiff: %d\\n\",spp);\n        delete [] pixels;\n        return;\n      }\n      /*\n      printf(\"Samples per pixel size of %d tiled tiff files is currently not supported by CCP4MG\\n\",spp);\n      printf(\"Please convert to another tiff format, eg rgb or rgb+alpha\\n\");\n      printf(\"The following is developer info to help rectify the problem\\n\");\n      printf(\"Scanline size:%d\\n\",TIFFScanlineSize(tif));\n      printf(\"Number of tiles:%d\\n\",TIFFNumberOfTiles(tif));\n      printf(\"Number of strips:%d\\n\",TIFFNumberOfStrips(tif));\n      printf(\"Strip size:%d\\n\",TIFFStripSize(tif));\n      printf(\"Strip size from TIFFGetField:%d\\n\",stripsize);\n      printf(\"Tile size from TIFFGetField:%d\\n\",tilesize);\n      printf(\"Tile width:%d\\n\",tileWidth);\n      printf(\"Tile length:%d\\n\",tileLength);\n      printf(\"Seems to be tiled\\n\");\n      */\n      uint32 imageWidth, imageLength;\n      uint32 tileWidth, tileLength;\n      uint32 x, y;\n      tdata_t buf;\n      uint16 config;\n\n      TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n      TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &imageLength);\n      TIFFGetField(tif, TIFFTAG_TILEWIDTH, &tileWidth);\n      TIFFGetField(tif, TIFFTAG_TILELENGTH, &tileLength);\n      TIFFGetField(tif, TIFFTAG_PLANARCONFIG, &config);\n      buf = _TIFFmalloc(TIFFTileSize(tif));\n      if (config == PLANARCONFIG_CONTIG) {\n        for (y = 0; y < imageLength; y += tileLength){\n          for (x = 0; x < imageWidth; x += tileWidth){\n            TIFFReadTile(tif, buf, x, y, 0, 0);\n            for(unsigned jj=0;jj<tileLength;jj++){\n              for(unsigned ii=0;ii<tileWidth*spp;ii++){\n                pixels[(y+jj)*width*spp+x+ii] = ((unsigned char *)buf)[jj*tileWidth*spp+ii];\n              }\n            }\n          }\n        }\n      } else if (config == PLANARCONFIG_SEPARATE) {\n        uint16 s;\n        for (s = 0; s < spp; s++){\n          for (y = 0; y < imageLength; y += tileLength){\n            for (x = 0; x < imageWidth; x += tileWidth){\n              TIFFReadTile(tif, buf, x, y, 0, s);\n              for(unsigned jj=0;jj<tileLength;jj++){\n                for(unsigned ii=0;ii<tileWidth;ii++){\n                  pixels[(y+jj)*width*spp+x+ii+s] = ((unsigned char *)buf)[jj*tileWidth+ii];\n                }\n              }\n            }\n          }\n        }\n      }\n      _TIFFfree(buf);\n    }\n    if(isstripped) {\n      pixels = new unsigned char[width*height*spp];\n      colourspace = spp;\n      if(spp==2){\n        colourspace_type = IMAGEINFO_MONOA;\n      }else{\n        printf(\"Unsupported samples per pixel in readtiff: %d\\n\",spp);\n        delete [] pixels;\n        return;\n      }\n      uint32 imagelength;\n      tdata_t buf;\n      uint32 row;\n      uint16 config;\n\n      TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &imagelength);\n      TIFFGetField(tif, TIFFTAG_PLANARCONFIG, &config);\n      buf = _TIFFmalloc(TIFFScanlineSize(tif));\n      if (config == PLANARCONFIG_CONTIG) {\n        for (row = 0; row < imagelength; row++){\n          TIFFReadScanline(tif, buf, row,0);\n          /* Just possible this may ignore a colourmap, not sure */\n          memcpy(pixels+row*TIFFScanlineSize(tif),(unsigned char *)buf,sizeof(unsigned char)*TIFFScanlineSize(tif));\n        }\n      } else if (config == PLANARCONFIG_SEPARATE) {\n        uint16 s;\n        for (s = 0; s < spp; s++){\n          for (row = 0; row < imagelength; row++){\n            TIFFReadScanline(tif, buf, row, s);\n            for(int ii=0;ii<width;ii++){\n              pixels[spp*ii+s+width*row*spp] = ((unsigned char *)buf)[ii];\n            }\n          }\n        }\n      }\n      _TIFFfree(buf);\n    }\n  } else {\n    uint32 *raster;\n    raster = (uint32*) _TIFFmalloc(width*height*sizeof(uint32));\n    if(!raster){\n      printf(\"Error reading tif image\\n\");\n      return;\n    }\n    TIFFReadRGBAImage(tif, width, height, raster, 0);\n    pixels = new unsigned char[width*height*4];\n    colourspace = 4;\n    colourspace_type = IMAGEINFO_RGBA;\n    int ii=0;\n    for(int i=height-1;i>=0;i--){\n      for(int j=0;j<width;j++){\n         uint32 pix = raster[i*width+j];\n         unsigned char a = (pix>>24)&255;\n         unsigned char b = (pix>>16)&255;\n         unsigned char g = (pix>>8)&255;\n         unsigned char r = pix&255;\n         pixels[ii++] = r;\n         pixels[ii++] = g;\n         pixels[ii++] = b;\n         pixels[ii++] = a;\n      }\n    }\n    _TIFFfree(raster);\n  }\n  TIFFClose(tif);\n#else\n    printf(\"No tiff support compiled into this program\\n\");\n    printf(\"Please install libtiff (if not already done) and\\n\");\n    printf(\"rebuild adding -DUSE_LIBTIFF to C_DEFINES\\n\");\n    printf(\"and CXX_DEFINES. Or convert input file to a\\n\");\n    printf(\"supported format.\\n\");\n#endif  \n}",
    "void image_info::writetif(const char *filename) const {\n#ifdef USE_LIBTIFF\n#ifdef _USE_DL_\n  if(!have_tiff){\n    if(init_tiff(LIBTIFF_SOLIBRARY)){ \n      have_tiff = 1;\n    }\n  }\n  if(!have_tiff){\n    printf(\"tiff library not found\\n\");\n    printf(\"Please try reading from a supported format\\n\");\n    return;\n  }\n#endif  \n  image_info tmp = *this;\n  tmp.convert_rgba();\n  TIFF* tif = TIFFOpen(filename, \"w\");\n  TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, tmp.width);\n  TIFFSetField(tif, TIFFTAG_IMAGELENGTH, tmp.height);\n  TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n  TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE,8);\n  TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL,4);\n  TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n  TIFFSetField(tif, TIFFTAG_COMPRESSION,COMPRESSION_NONE);\n  uint32 *raster = (uint32*) _TIFFmalloc(tmp.width*tmp.height*sizeof(uint32));\n\n  int ii=0;\n  for(int i=0;i<tmp.height;i++){\n    for(int j=0;j<tmp.width;j++){\n       unsigned char r,g, b,a;\n       r = tmp.pixels[ii++];\n       g = tmp.pixels[ii++];\n       b = tmp.pixels[ii++];\n       a = tmp.pixels[ii++];\n       uint32 pix = 0;\n       pix |= r;\n       pix |= (g<<8);\n       pix |= (b<<16);\n       pix |= (a<<24);\n       raster[i*tmp.width+j] = pix;\n    }\n  }\n  for (int row = 0; row < tmp.height; row++)\n    TIFFWriteScanline(tif, raster+row*tmp.width, row, 0);\n  _TIFFfree(raster);\n  TIFFClose(tif);\n#else\n    printf(\"No tiff support compiled into this program\\n\");\n    printf(\"Please install libtiff (if not already done) and\\n\");\n    printf(\"rebuild adding -DUSE_LIBTIFF to C_DEFINES\\n\");\n    printf(\"and CXX_DEFINES. Or try writing to a\\n\");\n    printf(\"supported format.\\n\");\n#endif  \n}",
    "void close() {\n      if( tif ) {\n        TIFFClose(tif);\n        tif=NULL;\n      }\n    }",
    "void vw::DiskImageResourceTIFF::open( std::string const& filename ) {\n  m_info->filename = filename;\n\n  TIFFSetWarningHandler( &tiff_warning_handler );\n  TIFFSetErrorHandler( &tiff_error_handler );\n\n  TIFF* tif = TIFFOpen( filename.c_str(), \"r\" );\n  if( !tif ) vw_throw( vw::ArgumentErr() << \"DiskImageResourceTIFF: Failed to open \\\"\" << filename << \"\\\" for reading!\" );\n\n  // Read into temp variables first to ensure we are using the right integer type.\n  // Otherwise we can run into endianness problems.\n  uint32 cols_tmp, rows_tmp;\n  uint16 planes_tmp;\n  check_retval(TIFFGetField( tif, TIFFTAG_IMAGEWIDTH, &cols_tmp ), 0);\n  check_retval(TIFFGetField( tif, TIFFTAG_IMAGELENGTH, &rows_tmp ), 0);\n  check_retval(\n    TIFFGetFieldDefaulted( tif, TIFFTAG_SAMPLESPERPIXEL, &planes_tmp ), 0);\n  m_format.cols = cols_tmp;\n  m_format.rows = rows_tmp;\n  m_format.planes = planes_tmp;\n\n  uint16 sample_format = 0, bits_per_sample = 0, photometric = 0;\n  check_retval(\n    TIFFGetFieldDefaulted( tif, TIFFTAG_BITSPERSAMPLE, &bits_per_sample ), 0);\n  check_retval(\n    TIFFGetFieldDefaulted( tif, TIFFTAG_SAMPLEFORMAT, &sample_format ), 0);\n  check_retval(TIFFGetField( tif, TIFFTAG_PHOTOMETRIC, &photometric ), 0);\n\n  m_format.channel_type = VW_CHANNEL_UNKNOWN;\n  switch( sample_format ) {\n  case SAMPLEFORMAT_UINT:\n    if (bits_per_sample == 8)\n      m_format.channel_type = VW_CHANNEL_UINT8;\n    else if (bits_per_sample == 16)\n      m_format.channel_type = VW_CHANNEL_UINT16;\n    else if (bits_per_sample == 32)\n      m_format.channel_type = VW_CHANNEL_UINT32;\n    else if (bits_per_sample == 64)\n      m_format.channel_type = VW_CHANNEL_UINT64;\n    break;\n  case SAMPLEFORMAT_INT:\n    if (bits_per_sample == 8)\n      m_format.channel_type = VW_CHANNEL_INT8;\n    else if (bits_per_sample == 16)\n      m_format.channel_type = VW_CHANNEL_INT16;\n    else if (bits_per_sample == 32)\n      m_format.channel_type = VW_CHANNEL_INT32;\n    else if (bits_per_sample == 64)\n      m_format.channel_type = VW_CHANNEL_INT64;\n    break;\n  case SAMPLEFORMAT_IEEEFP:\n    if (bits_per_sample == 16)\n      m_format.channel_type = VW_CHANNEL_FLOAT16;\n    else if (bits_per_sample == 32)\n      m_format.channel_type = VW_CHANNEL_FLOAT32;\n    else if (bits_per_sample == 64)\n      m_format.channel_type = VW_CHANNEL_FLOAT64;\n    break;\n  }\n  if( ! m_format.channel_type ) {\n    vw_throw( IOErr() << \"DiskImageResourceTIFF: \" << m_filename << \" has an unsupported channel type (\"\n              << sample_format << \",\" << bits_per_sample << \")!\" );\n  }\n\n  uint16 plane_configuration = 0;\n  check_retval(TIFFGetField(tif, TIFFTAG_PLANARCONFIG, &plane_configuration), 0);\n\n  // FIXME: Tiff might actually provide us with some info on\n  // colorimetric interpretation of the channels, so maybe we should\n  // try to use that here as well?\n  if( photometric == PHOTOMETRIC_PALETTE ) {\n    m_format.channel_type = VW_CHANNEL_UINT16;\n    m_format.pixel_format = VW_PIXEL_RGB;\n  }\n  else if( m_format.planes == 1 ) {\n    m_format.pixel_format = VW_PIXEL_GRAY;\n  }\n  else {\n    switch( m_format.planes ) {\n    case 2:  m_format.pixel_format = VW_PIXEL_GRAYA;  m_format.planes=1; break;\n    case 3:  m_format.pixel_format = VW_PIXEL_RGB;    m_format.planes=1; break;\n    case 4:  m_format.pixel_format = VW_PIXEL_RGBA;   m_format.planes=1; break;\n    default: m_format.pixel_format = VW_PIXEL_SCALAR; break;\n    }\n  }\n\n  if( TIFFIsTiled(tif) ) {\n    uint32 tile_width, tile_length;\n    check_retval(TIFFGetField( tif, TIFFTAG_TILEWIDTH, &tile_width ), 0);\n    check_retval(TIFFGetField( tif, TIFFTAG_TILELENGTH, &tile_length ), 0);\n    m_info->block_size = Vector2i(tile_width,tile_length);\n  }\n  else {\n    uint32 rows_per_strip;\n    check_retval(TIFFGetField( tif, TIFFTAG_ROWSPERSTRIP, &rows_per_strip ), 0);\n    m_info->block_size = Vector2i(cols(),rows_per_strip);\n  }\n\n  TIFFClose(tif);\n}",
    "void CTiffImg::Close()\n{\n  m_nWidth = 0;\n  m_nHeight = 0;\n  m_nBitsPerSample = 0;\n  m_nSamples = 0;\n  m_nExtraSamples = 0;\n\n  if (m_hTif) {\n    TIFFClose(m_hTif);\n\n    m_hTif = NULL;\n  }\n\n  if (m_pStripBuf) {\n    free(m_pStripBuf);\n    m_pStripBuf = NULL;\n  }\n}",
    "bool SlaOutputDev::radialShadedFill(GfxState *state, GfxRadialShading *shading, double sMin, double sMax)\r\n{\r\n//\tqDebug() << \"SlaOutputDev::radialShadedFill\";\r\n\tdouble GrStartX;\r\n\tdouble GrStartY;\r\n\tdouble GrEndX;\r\n\tdouble GrEndY;\r\n\tint shade = 100;\r\n\tconst Function *func = shading->getFunc(0);\r\n\tVGradient fillGradient(VGradient::linear);\r\n\tfillGradient.clearStops();\r\n\tGfxColorSpace *color_space = shading->getColorSpace();\r\n#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(24, 3, 0)\r\n\tif (func->getType() == Function::Type::Stitching)\r\n#else\r\n\tif (func->getType() == 3)\r\n#endif\r\n\t{\r\n\t\tconst auto *stitchingFunc = (const StitchingFunction*) func;\r\n\t\tconst double *bounds = stitchingFunc->getBounds();\r\n\t\tint num_funcs = stitchingFunc->getNumFuncs();\r\n\t\tdouble domain_min = stitchingFunc->getDomainMin(0);\r\n\t\tdouble domain_max = stitchingFunc->getDomainMax(0);\r\n\t\tif (fabs(domain_max - domain_min) < 1e-6)\r\n\t\t{\r\n\t\t\tdomain_min = 0.0;\r\n\t\t\tdomain_max = 1.0;\r\n\t\t}\r\n\t\t// Add stops from all the stitched functions\r\n\t\tfor (int i = 0 ; i <= num_funcs ; i++)\r\n\t\t{\r\n\t\t\tGfxColor temp;\r\n\t\t\tshading->getColor(bounds[i], &temp);\r\n\t\t\tQString stopColor = getColor(color_space, &temp, &shade);\r\n\t\t\tdouble stopPoint = (bounds[i] - domain_min) / (domain_max - domain_min);\r\n\t\t\tfillGradient.addStop( ScColorEngine::getShadeColor(m_doc->PageColors[stopColor], m_doc, shade), stopPoint, 0.5, 1.0, stopColor, shade );\r\n\t\t}\r\n\t}\r\n#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(24, 3, 0)\r\n\telse if ((func->getType() == Function::Type::Exponential) || (func->getType() == Function::Type::Sampled))\r\n#else\r\n\telse if ((func->getType() == 2) || (func->getType() == 0))\r\n#endif\r\n\t{\r\n\t\tGfxColor stop1;\r\n\t\tshading->getColor(0.0, &stop1);\r\n\t\tQString stopColor1 = getColor(color_space, &stop1, &shade);\r\n\t\tfillGradient.addStop( ScColorEngine::getShadeColor(m_doc->PageColors[stopColor1], m_doc, shade), 0.0, 0.5, 1.0, stopColor1, shade );\r\n\t\tGfxColor stop2;\r\n\t\tshading->getColor(1.0, &stop2);\r\n\t\tQString stopColor2 = getColor(color_space, &stop2, &shade);\r\n\t\tfillGradient.addStop( ScColorEngine::getShadeColor(m_doc->PageColors[stopColor2], m_doc, shade), 1.0, 0.5, 1.0, stopColor2, shade );\r\n\t}\r\n\r\n\tdouble r0, x1, y1, r1;\r\n\tshading->getCoords(&GrStartX, &GrStartY, &r0, &x1, &y1, &r1);\r\n\tdouble xmin, ymin, xmax, ymax;\r\n\t// get the clip region bbox\r\n\tstate->getClipBBox(&xmin, &ymin, &xmax, &ymax);\r\n\tQRectF crect(QPointF(xmin, ymin), QPointF(xmax, ymax));\r\n\tcrect = crect.normalized();\r\n\tdouble GrFocalX = x1;\r\n\tdouble GrFocalY = y1;\r\n\tGrEndX = GrFocalX + r1;\r\n\tGrEndY = GrFocalY;\r\n\tconst double *ctm = state->getCTM();\r\n\tm_ctm = QTransform(ctm[0], ctm[1], ctm[2], ctm[3], ctm[4], ctm[5]);\r\n\tFPointArray gr;\r\n\tgr.addPoint(GrStartX, GrStartY);\r\n\tgr.addPoint(GrEndX, GrEndY);\r\n\tgr.addPoint(GrFocalX, GrFocalY);\r\n\tgr.map(m_ctm);\r\n\tGrStartX = gr.point(0).x() - crect.x();\r\n\tGrStartY = gr.point(0).y() - crect.y();\r\n\tGrEndX = gr.point(1).x() - crect.x();\r\n\tGrEndY = gr.point(1).y() - crect.y();\r\n\tGrFocalX = gr.point(2).x() - crect.x();\r\n\tGrFocalY = gr.point(2).y() - crect.y();\r\n\tdouble xCoor = m_doc->currentPage()->xOffset();\r\n\tdouble yCoor = m_doc->currentPage()->yOffset();\r\n\tQString output = QString(\"M %1 %2\").arg(0.0).arg(0.0);\r\n\toutput += QString(\"L %1 %2\").arg(crect.width()).arg(0.0);\r\n\toutput += QString(\"L %1 %2\").arg(crect.width()).arg(crect.height());\r\n\toutput += QString(\"L %1 %2\").arg(0.0).arg(crect.height());\r\n\toutput += QString(\"L %1 %2\").arg(0.0).arg(0.0);\r\n\toutput += QString(\"Z\");\r\n\tm_pathIsClosed = true;\r\n\tm_coords = output;\r\n\r\n\tconst auto& graphicState = m_graphicStack.top();\r\n\tint z = m_doc->itemAdd(PageItem::Polygon, PageItem::Rectangle, xCoor + crect.x(), yCoor + crect.y(), crect.width(), crect.height(), 0, graphicState.fillColor, CommonStrings::None);\r\n\tPageItem* ite = m_doc->Items->at(z);\r\n\tif (checkClip())\r\n\t{\r\n\t\tQPainterPath out = graphicState.clipPath;\r\n\t\tout.translate(m_doc->currentPage()->xOffset(), m_doc->currentPage()->yOffset());\r\n\t\tout.translate(-ite->xPos(), -ite->yPos());\r\n\t\tite->PoLine.fromQPainterPath(out, true);\r\n\t\tite->setFillEvenOdd(out.fillRule() == Qt::OddEvenFill);\r\n\t}\r\n\tite->ClipEdited = true;\r\n\tite->FrameType = 3;\r\n\tite->setFillShade(graphicState.fillShade);\r\n\tite->setLineShade(100);\r\n\tite->setFillTransparency(1.0 - state->getFillOpacity());\r\n\tite->setFillBlendmode(getBlendMode(state));\r\n\tite->setLineEnd(m_lineEnd);\r\n\tite->setLineJoin(m_lineJoin);\r\n\tite->setTextFlowMode(PageItem::TextFlowDisabled);\r\n\tite->GrType = 7;\r\n\tif (!shading->getExtend0() || !shading->getExtend1())\r\n\t{\r\n\t\tfillGradient.setRepeatMethod(VGradient::none);\r\n\t\tite->setGradientExtend(VGradient::none);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tfillGradient.setRepeatMethod(VGradient::pad);\r\n\t\tite->setGradientExtend(VGradient::pad);\r\n\t}\r\n\tite->fill_gradient = fillGradient;\r\n\tite->setGradientVector(GrStartX, GrStartY, GrEndX, GrEndY, GrFocalX, GrFocalY, 1, 0);\r\n\tm_doc->adjustItemSize(ite);\r\n\tm_Elements->append(ite);\r\n\tif (m_groupStack.count() != 0)\r\n\t{\r\n\t\tm_groupStack.top().Items.append(ite);\r\n\t\tapplyMask(ite);\r\n\t}\r\n\treturn true;\r\n}\r\n\r\nbool SlaOutputDev::gouraudTriangleShadedFill(GfxState *state, GfxGouraudTriangleShading *shading)\r\n{\r\n//\tqDebug() << \"SlaOutputDev::gouraudTriangleShadedFill\";\r\n\tdouble xCoor = m_doc->currentPage()->xOffset();\r\n\tdouble yCoor = m_doc->currentPage()->yOffset();\r\n\tdouble xmin, ymin, xmax, ymax;\r\n\t// get the clip region bbox\r\n\tstate->getClipBBox(&xmin, &ymin, &xmax, &ymax);\r\n\tQRectF crect(QPointF(xmin, ymin), QPointF(xmax, ymax));\r\n\tcrect = crect.normalized();\r\n\tQString output = QString(\"M %1 %2\").arg(0.0).arg(0.0);\r\n\toutput += QString(\"L %1 %2\").arg(crect.width()).arg(0.0);\r\n\toutput += QString(\"L %1 %2\").arg(crect.width()).arg(crect.height());\r\n\toutput += QString(\"L %1 %2\").arg(0.0).arg(crect.height());\r\n\toutput += QString(\"L %1 %2\").arg(0.0).arg(0.0);\r\n\toutput += QString(\"Z\");\r\n\tm_pathIsClosed = true;\r\n\tm_coords = output;\r\n\tconst double *ctm = state->getCTM();\r\n\tm_ctm = QTransform(ctm[0], ctm[1], ctm[2], ctm[3], ctm[4], ctm[5]);\r\n\tconst auto& graphicState = m_graphicStack.top();\r\n\tint z = m_doc->itemAdd(PageItem::Polygon, PageItem::Rectangle, xCoor + crect.x(), yCoor + crect.y(), crect.width(), crect.height(), 0, graphicState.fillColor, CommonStrings::None);\r\n\tPageItem* ite = m_doc->Items->at(z);\r\n\tite->ClipEdited = true;\r\n\tite->FrameType = 3;\r\n\tite->setFillShade(graphicState.fillShade);\r\n\tite->setLineShade(100);\r\n\tite->setFillEvenOdd(false);\r\n\tite->setFillTransparency(1.0 - state->getFillOpacity());\r\n\tite->setFillBlendmode(getBlendMode(state));\r\n\tite->setLineEnd(m_lineEnd);\r\n\tite->setLineJoin(m_lineJoin);\r\n\tite->setTextFlowMode(PageItem::TextFlowDisabled);\r\n\tm_doc->adjustItemSize(ite);\r\n\tm_Elements->append(ite);\r\n\tif (m_groupStack.count() != 0)\r\n\t{\r\n\t\tm_groupStack.top().Items.append(ite);\r\n\t\tapplyMask(ite);\r\n\t}\r\n\tGfxColor color[3];\r\n\tdouble x0, y0, x1, y1, x2, y2;\r\n\tfor (int i = 0; i < shading->getNTriangles(); i++)\r\n\t{\r\n\t\tint shade = 100;\r\n\t\tmeshGradientPatch patchM;\r\n\t\tshading->getTriangle(i, &x0, &y0, &color[0],  &x1, &y1, &color[1],  &x2, &y2, &color[2]);\r\n\t\tpatchM.BL.resetTo(FPoint(x0, y0));\r\n\t\tpatchM.BL.shade = 100;\r\n\t\tpatchM.BL.transparency = 1.0;\r\n\t\tpatchM.BL.colorName = getColor(shading->getColorSpace(), &color[0], &shade);\r\n\t\tpatchM.BL.color = ScColorEngine::getShadeColorProof(m_doc->PageColors[patchM.BL.colorName], m_doc, shade);\r\n\t\tpatchM.TL.resetTo(FPoint(x1, y1));\r\n\t\tpatchM.TL.shade = 100;\r\n\t\tpatchM.TL.transparency = 1.0;\r\n\t\tpatchM.TL.colorName = getColor(shading->getColorSpace(), &color[1], &shade);\r\n\t\tpatchM.TL.color = ScColorEngine::getShadeColorProof(m_doc->PageColors[patchM.TL.colorName], m_doc, shade);\r\n\t\tpatchM.TR.resetTo(FPoint(x2, y2));\r\n\t\tpatchM.TR.shade = 100;\r\n\t\tpatchM.TR.transparency = 1.0;\r\n\t\tpatchM.TR.colorName = getColor(shading->getColorSpace(), &color[2], &shade);\r\n\t\tpatchM.TR.color = ScColorEngine::getShadeColorProof(m_doc->PageColors[patchM.TR.colorName], m_doc, shade);\r\n\t\tpatchM.BR.resetTo(FPoint(x0, y0));\r\n\t\tpatchM.BR.shade = 100;\r\n\t\tpatchM.BR.transparency = 1.0;\r\n\t\tpatchM.BR.colorName = getColor(shading->getColorSpace(), &color[0], &shade);\r\n\t\tpatchM.BR.color = ScColorEngine::getShadeColorProof(m_doc->PageColors[patchM.BR.colorName], m_doc, shade);\r\n\t\tpatchM.TL.transform(m_ctm);\r\n\t\tpatchM.TL.moveRel(-crect.x(), -crect.y());\r\n\t\tpatchM.TR.transform(m_ctm);\r\n\t\tpatchM.TR.moveRel(-crect.x(), -crect.y());\r\n\t\tpatchM.BR.transform(m_ctm);\r\n\t\tpatchM.BR.moveRel(-crect.x(), -crect.y());\r\n\t\tpatchM.BL.transform(m_ctm);\r\n\t\tpatchM.BL.moveRel(-crect.x(), -crect.y());\r\n\t\tite->meshGradientPatches.append(patchM);\r\n\t}\r\n\tite->GrType = 12;\r\n\treturn true;\r\n}\r\n\r\nbool SlaOutputDev::patchMeshShadedFill(GfxState *state, GfxPatchMeshShading *shading)\r\n{\r\n//\tqDebug() << \"SlaOutputDev::patchMeshShadedFill\";\r\n\tdouble xCoor = m_doc->currentPage()->xOffset();\r\n\tdouble yCoor = m_doc->currentPage()->yOffset();\r\n\tdouble xmin, ymin, xmax, ymax;\r\n\t// get the clip region bbox\r\n\tstate->getClipBBox(&xmin, &ymin, &xmax, &ymax);\r\n\tQRectF crect(QPointF(xmin, ymin), QPointF(xmax, ymax));\r\n\tcrect = crect.normalized();\r\n\tQString output = QString(\"M %1 %2\").arg(0.0).arg(0.0);\r\n\toutput += QString(\"L %1 %2\").arg(crect.width()).arg(0.0);\r\n\toutput += QString(\"L %1 %2\").arg(crect.width()).arg(crect.height());\r\n\toutput += QString(\"L %1 %2\").arg(0.0).arg(crect.height());\r\n\toutput += QString(\"L %1 %2\").arg(0.0).arg(0.0);\r\n\toutput += QString(\"Z\");\r\n\tm_pathIsClosed = true;\r\n\tm_coords = output;\r\n\tconst double *ctm = state->getCTM();\r\n\tm_ctm = QTransform(ctm[0], ctm[1], ctm[2], ctm[3], ctm[4], ctm[5]);\r\n\tconst auto& graphicState = m_graphicStack.top();\r\n\tint z = m_doc->itemAdd(PageItem::Polygon, PageItem::Rectangle, xCoor + crect.x(), yCoor + crect.y(), crect.width(), crect.height(), 0, graphicState.fillColor, CommonStrings::None);\r\n\tPageItem* ite = m_doc->Items->at(z);\r\n\tite->ClipEdited = true;\r\n\tite->FrameType = 3;\r\n\tite->setFillShade(graphicState.fillShade);\r\n\tite->setLineShade(100);\r\n\tite->setFillEvenOdd(false);\r\n\tite->setFillTransparency(1.0 - state->getFillOpacity());\r\n\tite->setFillBlendmode(getBlendMode(state));\r\n\tite->setLineEnd(m_lineEnd);\r\n\tite->setLineJoin(m_lineJoin);\r\n\tite->setTextFlowMode(PageItem::TextFlowDisabled);\r\n\tm_doc->adjustItemSize(ite);\r\n\tm_Elements->append(ite);\r\n\tif (m_groupStack.count() != 0)\r\n\t{\r\n\t\tm_groupStack.top().Items.append(ite);\r\n\t\tapplyMask(ite);\r\n\t}\r\n\tite->meshGradientPatches.clear();\r\n\tfor (int i = 0; i < shading->getNPatches(); i++)\r\n\t{\r\n\t\tint shade = 100;\r\n\t\tconst GfxPatch *patch = shading->getPatch(i);\r\n\t\tGfxColor color;\r\n\t\tmeshGradientPatch patchM;\r\n\t\tint u, v;\r\n\t\tpatchM.BL.resetTo(FPoint(patch->x[0][0], patch->y[0][0]));\r\n\t\tpatchM.BL.controlTop = FPoint(patch->x[0][1], patch->y[0][1]);\r\n\t\tpatchM.BL.controlRight = FPoint(patch->x[1][0], patch->y[1][0]);\r\n\t\tpatchM.BL.controlColor = FPoint(patch->x[1][1], patch->y[1][1]);\r\n\t\tu = 0;\r\n\t\tv = 0;\r\n\t\tif (shading->isParameterized())\r\n\t\t{\r\n\t\t\tshading->getParameterizedColor (patch->color[u][v].c[0], &color);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tfor (int k = 0; k < shading->getColorSpace()->getNComps(); k++)\r\n\t\t\t{\r\n\t\t\t\tcolor.c[k] = GfxColorComp (patch->color[u][v].c[k]);\r\n\t\t\t}\r\n\t\t}\r\n\t\tpatchM.BL.colorName = getColor(shading->getColorSpace(), &color, &shade);\r\n\t\tpatchM.BL.shade = 100;\r\n\t\tpatchM.BL.transparency = 1.0;\r\n\t\tpatchM.BL.color = ScColorEngine::getShadeColorProof(m_doc->PageColors[patchM.BL.colorName], m_doc, shade);\r\n\r\n\t\tu = 0;\r\n\t\tv = 1;\r\n\t\tpatchM.TL.resetTo(FPoint(patch->x[0][3], patch->y[0][3]));\r\n\t\tpatchM.TL.controlRight = FPoint(patch->x[1][3], patch->y[1][3]);\r\n\t\tpatchM.TL.controlBottom = FPoint(patch->x[0][2], patch->y[0][2]);\r\n\t\tpatchM.TL.controlColor = FPoint(patch->x[1][2], patch->y[1][2]);\r\n\t\tif (shading->isParameterized())\r\n\t\t{\r\n\t\t\tshading->getParameterizedColor (patch->color[u][v].c[0], &color);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tfor (int k = 0; k < shading->getColorSpace()->getNComps(); k++)\r\n\t\t\t{\r\n\t\t\t\tcolor.c[k] = GfxColorComp (patch->color[u][v].c[k]);\r\n\t\t\t}\r\n\t\t}\r\n\t\tpatchM.TL.colorName = getColor(shading->getColorSpace(), &color, &shade);\r\n\t\tpatchM.TL.shade = 100;\r\n\t\tpatchM.TL.transparency = 1.0;\r\n\t\tpatchM.TL.color = ScColorEngine::getShadeColorProof(m_doc->PageColors[patchM.TL.colorName], m_doc, shade);\r\n\r\n\t\tu = 1;\r\n\t\tv = 1;\r\n\t\tpatchM.TR.resetTo(FPoint(patch->x[3][3], patch->y[3][3]));\r\n\t\tpatchM.TR.controlBottom = FPoint(patch->x[3][2], patch->y[3][2]);\r\n\t\tpatchM.TR.controlLeft = FPoint(patch->x[2][3], patch->y[2][3]);\r\n\t\tpatchM.TR.controlColor = FPoint(patch->x[2][2], patch->y[2][2]);\r\n\t\tif (shading->isParameterized())\r\n\t\t{\r\n\t\t\tshading->getParameterizedColor (patch->color[u][v].c[0], &color);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tfor (int k = 0; k < shading->getColorSpace()->getNComps(); k++)\r\n\t\t\t{\r\n\t\t\t\tcolor.c[k] = GfxColorComp (patch->color[u][v].c[k]);\r\n\t\t\t}\r\n\t\t}\r\n\t\tpatchM.TR.colorName = getColor(shading->getColorSpace(), &color, &shade);\r\n\t\tpatchM.TR.shade = 100;\r\n\t\tpatchM.TR.transparency = 1.0;\r\n\t\tpatchM.TR.color = ScColorEngine::getShadeColorProof(m_doc->PageColors[patchM.TR.colorName], m_doc, shade);\r\n\r\n\t\tu = 1;\r\n\t\tv = 0;\r\n\t\tpatchM.BR.resetTo(FPoint(patch->x[3][0], patch->y[3][0]));\r\n\t\tpatchM.BR.controlLeft = FPoint(patch->x[2][0], patch->y[2][0]);\r\n\t\tpatchM.BR.controlTop = FPoint(patch->x[3][1], patch->y[3][1]);\r\n\t\tpatchM.BR.controlColor = FPoint(patch->x[2][1], patch->y[2][1]);\r\n\t\tif (shading->isParameterized())\r\n\t\t{\r\n\t\t\tshading->getParameterizedColor (patch->color[u][v].c[0], &color);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tfor (int k = 0; k < shading->getColorSpace()->getNComps(); k++)\r\n\t\t\t{\r\n\t\t\t\tcolor.c[k] = GfxColorComp (patch->color[u][v].c[k]);\r\n\t\t\t}\r\n\t\t}\r\n\t\tpatchM.BR.colorName = getColor(shading->getColorSpace(), &color, &shade);\r\n\t\tpatchM.BR.shade = 100;\r\n\t\tpatchM.BR.transparency = 1.0;\r\n\t\tpatchM.BR.color = ScColorEngine::getShadeColorProof(m_doc->PageColors[patchM.BR.colorName], m_doc, shade);\r\n\r\n\t\tpatchM.TL.transform(m_ctm);\r\n\t\tpatchM.TL.moveRel(-crect.x(), -crect.y());\r\n\t\tpatchM.TR.transform(m_ctm);\r\n\t\tpatchM.TR.moveRel(-crect.x(), -crect.y());\r\n\t\tpatchM.BR.transform(m_ctm);\r\n\t\tpatchM.BR.moveRel(-crect.x(), -crect.y());\r\n\t\tpatchM.BL.transform(m_ctm);\r\n\t\tpatchM.BL.moveRel(-crect.x(), -crect.y());\r\n\t\tite->meshGradientPatches.append(patchM);\r\n\t}\r\n\tite->GrType = 12;\r\n\treturn true;\r\n}\r\n\r\nbool SlaOutputDev::tilingPatternFill(GfxState *state, Gfx * /*gfx*/, Catalog *cat, GfxTilingPattern *tPat, const double *mat, int x0, int y0, int x1, int y1, double xStep, double yStep)\r\n{\r\n//\tqDebug() << \"SlaOutputDev::tilingPatternFill\";\r\n\tconst double *bbox = tPat->getBBox();\r\n\tconst double *pmat = tPat->getMatrix();\r\n\tDict *resDict = tPat->getResDict();\r\n\r\n\tPDFRectangle box;\r\n\tGfx *gfx;\r\n\tQString id;\r\n\tPageItem *ite;\r\n\tgroupEntry gElements;\r\n\tm_groupStack.push(gElements);\r\n\tdouble width, height;\r\n\twidth = bbox[2] - bbox[0];\r\n\theight = bbox[3] - bbox[1];\r\n\tif (xStep != width || yStep != height)\r\n\t\treturn false;\r\n\tbox.x1 = bbox[0];\r\n\tbox.y1 = bbox[1];\r\n\tbox.x2 = bbox[2];\r\n\tbox.y2 = bbox[3];\r\n\r\n\tconst double *ctm = state->getCTM();\r\n\tm_ctm = QTransform(ctm[0], ctm[1], ctm[2], ctm[3], ctm[4], ctm[5]);\r\n\tQTransform mm(mat[0], mat[1], mat[2], mat[3], mat[4], mat[5]);\r\n\tQTransform mmx = mm * m_ctm;\r\n\r\n\tgfx = new Gfx(m_pdfDoc, this, resDict, &box, nullptr);\r\n\tm_inPattern++;\r\n\t// Unset the clip path as it is unrelated to the pattern's coordinate space.\r\n\tQPainterPath savedClip = m_graphicStack.top().clipPath;\r\n\tm_graphicStack.top().clipPath = QPainterPath();\r\n\tgfx->display(tPat->getContentStream());\r\n\tm_graphicStack.top().clipPath = savedClip;\r\n\tm_inPattern--;\r\n\tm_doc->m_Selection->clear();\r\n\r\n\tgElements = m_groupStack.pop();\r\n\tif (gElements.Items.count() > 0)\r\n\t{\r\n\t\tfor (int dre = 0; dre < gElements.Items.count(); ++dre)\r\n\t\t{\r\n\t\t\tm_doc->m_Selection->addItem(gElements.Items.at(dre), true);\r\n\t\t\tm_Elements->removeAll(gElements.Items.at(dre));\r\n\t\t}\r\n\t\tm_doc->itemSelection_FlipV();\r\n\t\tPageItem *ite;\r\n\t\tif (m_doc->m_Selection->count() > 1)\r\n\t\t\tite = m_doc->groupObjectsSelection();\r\n\t\telse\r\n\t\t\tite = m_doc->m_Selection->itemAt(0);\r\n\t\tite->setFillTransparency(1.0 - state->getFillOpacity());\r\n\t\tite->setFillBlendmode(getBlendMode(state));\r\n\t\tm_doc->m_Selection->clear();\r\n\t\tm_doc->DoDrawing = true;\r\n\t\tScPattern pat(m_doc);\r\n\t\tpat.pattern = ite->DrawObj_toImage(qMin(qMax(ite->width(), ite->height()), 500.0));\r\n\t\tpat.xoffset = 0;\r\n\t\tpat.yoffset = 0;\r\n\t\tm_doc->DoDrawing = false;\r\n\t\tpat.width = ite->width();\r\n\t\tpat.height = ite->height();\r\n\t\tite->gXpos = 0;\r\n\t\tite->gYpos = 0;\r\n\t\tite->setXYPos(ite->gXpos, ite->gYpos, true);\r\n\t\tpat.items.append(ite);\r\n\t\tm_doc->Items->removeAll(ite);\r\n\t\tid = QString(\"Pattern_from_PDF_%1\").arg(m_doc->docPatterns.count() + 1);\r\n\t\tm_doc->addPattern(id, pat);\r\n\t}\r\n\tdouble xCoor = m_doc->currentPage()->xOffset();\r\n\tdouble yCoor = m_doc->currentPage()->yOffset();\r\n\tdouble xmin, ymin, xmax, ymax;\r\n\t// get the clip region bbox\r\n\tstate->getClipBBox(&xmin, &ymin, &xmax, &ymax);\r\n\tQRectF crect(QPointF(xmin, ymin), QPointF(xmax, ymax));\r\n\tcrect = crect.normalized();\r\n\tQString output = QString(\"M %1 %2\").arg(0.0).arg(0.0);\r\n\toutput += QString(\"L %1 %2\").arg(crect.width()).arg(0.0);\r\n\toutput += QString(\"L %1 %2\").arg(crect.width()).arg(crect.height());\r\n\toutput += QString(\"L %1 %2\").arg(0.0).arg(crect.height());\r\n\toutput += QString(\"L %1 %2\").arg(0.0).arg(0.0);\r\n\toutput += QString(\"Z\");\r\n\tm_pathIsClosed = true;\r\n\tm_coords = output;\r\n\r\n\tconst auto& graphicState = m_graphicStack.top();\r\n\tint z = m_doc->itemAdd(PageItem::Polygon, PageItem::Rectangle, xCoor + crect.x(), yCoor + crect.y(), crect.width(), crect.height(), 0, graphicState.fillColor, CommonStrings::None);\r\n\tite = m_doc->Items->at(z);\r\n\r\n\tm_ctm = QTransform(ctm[0], ctm[1], ctm[2], ctm[3], ctm[4], ctm[5]);\r\n\tdouble angle = m_ctm.map(QLineF(0, 0, 1, 0)).angle();\r\n\tite->setRotation(-angle);\r\n\tif (checkClip())\r\n\t{\r\n\t\tQPainterPath outline = graphicState.clipPath;\r\n\t\toutline.translate(xCoor - ite->xPos(), yCoor - ite->yPos());\r\n\t\t// Undo the rotation of the clipping path as it is rotated together with the item.\r\n\t\tQTransform mm;\r\n\t\tmm.rotate(angle);\r\n\t\toutline = mm.map(outline);\r\n\t\tite->PoLine.fromQPainterPath(outline, true);\r\n\t\tite->setFillEvenOdd(outline.fillRule() == Qt::OddEvenFill);\r\n\t}\r\n\tite->ClipEdited = true;\r\n\tite->FrameType = 3;\r\n\tite->setFillShade(graphicState.fillShade);\r\n\tite->setLineShade(100);\r\n\tite->setFillTransparency(1.0 - state->getFillOpacity());\r\n\tite->setFillBlendmode(getBlendMode(state));\r\n\tite->setLineEnd(m_lineEnd);\r\n\tite->setLineJoin(m_lineJoin);\r\n\tite->setTextFlowMode(PageItem::TextFlowDisabled);\r\n\tite->GrType = 8;\r\n\tite->setPattern(id);\r\n\tite->setPatternTransform(fabs(pmat[0]), fabs(pmat[3]), mmx.dx() - ctm[4], mmx.dy() - ctm[5], 0, -1 * pmat[1], pmat[2]);\r\n\tm_doc->adjustItemSize(ite);\r\n\tm_Elements->append(ite);\r\n\tif (m_groupStack.count() != 0)\r\n\t{\r\n\t\tm_groupStack.top().Items.append(ite);\r\n\t\tapplyMask(ite);\r\n\t}\r\n\tdelete gfx;\r\n\treturn true;\r\n}\r\n\r\nvoid SlaOutputDev::drawImageMask(GfxState *state, Object *ref, Stream *str, int width, int height, bool invert, bool interpolate, bool inlineImg)\r\n{\r\n//\tqDebug() << \"Draw Image Mask\";\r\n\tauto imgStr = std::make_unique<ImageStream>(str, width, 1, 1);\r\n\timgStr->reset();\r\n#ifdef WORDS_BIGENDIAN\r\n\tQImage image(width, height, QImage::Format_Mono);\r\n#else\r\n\tQImage image(width, height, QImage::Format_MonoLSB);\r\n#endif\r\n\tif (image.isNull())\r\n\t\treturn;\r\n\r\n\tint invertBit = invert ? 1 : 0;\r\n\tunsigned char* buffer = image.bits();\r\n\tunsigned char* dest = nullptr;\r\n\tqsizetype rowStride = image.bytesPerLine();\r\n\tint i, bit;\r\n\tunsigned char* pix;\r\n\r\n\tfor (int y = 0; y < height; y++)\r\n\t{\r\n\t\tpix = imgStr->getLine();\r\n\t\tdest = buffer + y * rowStride;\r\n\t\ti = 0;\r\n\t\tbit = 0;\r\n\t\tfor (int x = 0; x < width; x++)\r\n\t\t{\r\n\t\t\tif (bit == 0)\r\n\t\t\t\tdest[i] = 0;\r\n\t\t\tif (!(pix[x] ^ invertBit))\r\n\t\t\t{\r\n#ifdef WORDS_BIGENDIAN\r\n\t\t\t\tdest[i] |= (1 << (7 - bit));\r\n#else\r\n\t\t\t\tdest[i] |= (1 << bit);\r\n#endif\r\n\t\t\t}\r\n\t\t\tbit++;\r\n\t\t\tif (bit > 7)\r\n\t\t\t{\r\n\t\t\t\tbit = 0;\r\n\t\t\t\ti++;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tconst auto& graphicState = m_graphicStack.top();\r\n\tQColor backColor = ScColorEngine::getShadeColorProof(m_doc->PageColors[graphicState.fillColor], m_doc, graphicState.fillShade);\r\n\tQImage res(width, height, QImage::Format_ARGB32);\r\n\tres.fill(backColor.rgb());\r\n\tunsigned char cc, cm, cy, ck;\r\n\tfor (int yi = 0; yi < res.height(); ++yi)\r\n\t{\r\n\t\tQRgb *t = (QRgb*)(res.scanLine( yi ));\r\n\t\tfor (int xi = 0; xi < res.width(); ++xi)\r\n\t\t{\r\n\t\t\tcc = static_cast<unsigned char>( qRed(*t) );\r\n\t\t\tcm = static_cast<unsigned char>( qGreen(*t) );\r\n\t\t\tcy = static_cast<unsigned char>( qBlue(*t) );\r\n\t\t\tck = static_cast<unsigned char>( image.pixel(xi, yi) );\r\n\t\t\tif (ck == 0)\r\n\t\t\t\t(*t) = qRgba(cc, cm, cy, 0);\r\n\t\t\telse\r\n\t\t\t\t(*t) = qRgba(cc, cm, cy, 255);\r\n\t\t\tt++;\r\n\t\t}\r\n\t}\r\n\r\n\tcreateImageFrame(res, state, 3);\r\n\r\n\timgStr->close();\r\n}\r\n\r\nvoid SlaOutputDev::drawSoftMaskedImage(GfxState *state, Object *ref, Stream *str, int width, int height, GfxImageColorMap *colorMap, bool interpolate, Stream *maskStr, int maskWidth, int maskHeight,\r\n\t\t\t\t   GfxImageColorMap *maskColorMap, bool maskInterpolate)\r\n{\r\n//\tqDebug() << \"SlaOutputDev::drawSoftMaskedImage Masked Image Components\" << colorMap->getNumPixelComps();\r\n\tauto imgStr = std::make_unique<ImageStream>(str, width, colorMap->getNumPixelComps(), colorMap->getBits());\r\n\timgStr->reset();\r\n\tunsigned int *dest = nullptr;\r\n\tunsigned char * buffer = new unsigned char[width * height * 4];\r\n\tfor (int y = 0; y < height; y++)\r\n\t{\r\n\t\tdest = (unsigned int *)(buffer + y * 4 * width);\r\n\t\tunsigned char * pix = imgStr->getLine();\r\n\t\tcolorMap->getRGBLine(pix, dest, width);\r\n\t}\r\n\r\n\tQImage image(buffer, width, height, QImage::Format_RGB32);\r\n\tif (image.isNull())\r\n\t{\r\n\t\tdelete[] buffer;\r\n\t\treturn;\r\n\t}\r\n\r\n\tauto mskStr = std::make_unique<ImageStream>(maskStr, maskWidth, maskColorMap->getNumPixelComps(), maskColorMap->getBits());\r\n\tmskStr->reset();\r\n\tunsigned char *mdest = nullptr;\r\n\tunsigned char * mbuffer = new unsigned char[maskWidth * maskHeight];\r\n\tmemset(mbuffer, 0, maskWidth * maskHeight);\r\n\tfor (int y = 0; y < maskHeight; y++)\r\n\t{\r\n\t\tmdest = mbuffer + y * maskWidth;\r\n\t\tunsigned char * pix = mskStr->getLine();\r\n\t\tmaskColorMap->getGrayLine(pix, mdest, maskWidth);\r\n\t}\r\n\tif ((maskWidth != width) || (maskHeight != height))\r\n\t\timage = image.scaled(maskWidth, maskHeight, Qt::IgnoreAspectRatio, Qt::SmoothTransformation);\r\n\tQImage res = image.convertToFormat(QImage::Format_ARGB32);\r\n\r\n\tint matteRc, matteGc, matteBc;\r\n\tconst GfxColor *matteColor = maskColorMap->getMatteColor();\r\n\tif (matteColor != nullptr)\r\n\t{\r\n\t\tGfxRGB matteRgb;\r\n\t\tcolorMap->getColorSpace()->getRGB(matteColor, &matteRgb);\r\n\t\tmatteRc = qRound(colToDbl(matteRgb.r) * 255);\r\n\t\tmatteGc = qRound(colToDbl(matteRgb.g) * 255);\r\n\t\tmatteBc = qRound(colToDbl(matteRgb.b) * 255);\r\n\t}\r\n\r\n\tunsigned char cr, cg, cb, ca;\r\n\tint s = 0;\r\n\tfor (int yi = 0; yi < res.height(); ++yi)\r\n\t{\r\n\t\tQRgb *t = (QRgb*)(res.scanLine( yi ));\r\n\t\tfor (int xi = 0; xi < res.width(); ++xi)\r\n\t\t{\r\n\t\t\tcr = static_cast<unsigned char>( qRed(*t) );\r\n\t\t\tcg = static_cast<unsigned char>( qGreen(*t) );\r\n\t\t\tcb = static_cast<unsigned char>( qBlue(*t) );\r\n\t\t\tca = mbuffer[s];\r\n\t\t\tif (matteColor != nullptr)\r\n\t\t\t{\r\n\t\t\t\tcr = static_cast<unsigned char>( unblendMatte(cr, ca, matteRc) );\r\n\t\t\t\tcg = static_cast<unsigned char>( unblendMatte(cg, ca, matteGc) );\r\n\t\t\t\tcb = static_cast<unsigned char>( unblendMatte(cb, ca, matteBc) );\r\n\t\t\t}\r\n\t\t\t(*t) = qRgba(cr, cg, cb, ca);\r\n\t\t\ts++;\r\n\t\t\tt++;\r\n\t\t}\r\n\t}\r\n\r\n\tcreateImageFrame(res, state, 3);\r\n\r\n\tdelete[] buffer;\r\n\tdelete[] mbuffer;\r\n}\r\n\r\nvoid SlaOutputDev::drawMaskedImage(GfxState *state, Object *ref, Stream *str,  int width, int height, GfxImageColorMap *colorMap, bool interpolate, Stream *maskStr, int maskWidth, int maskHeight, bool maskInvert, bool maskInterpolate)\r\n{\r\n//\tqDebug() << \"SlaOutputDev::drawMaskedImage\";\r\n\tauto imgStr = std::make_unique<ImageStream>(str, width, colorMap->getNumPixelComps(), colorMap->getBits());\r\n\timgStr->reset();\r\n\tunsigned int *dest = nullptr;\r\n\tunsigned char * buffer = new unsigned char[width * height * 4];\r\n\tfor (int y = 0; y < height; y++)\r\n\t{\r\n\t\tdest = (unsigned int *)(buffer + y * 4 * width);\r\n\t\tunsigned char * pix = imgStr->getLine();\r\n\t\tcolorMap->getRGBLine(pix, dest, width);\r\n\t}\r\n\r\n\tQImage image(buffer, width, height, QImage::Format_RGB32);\r\n\tif (image.isNull())\r\n\t{\r\n\t\tdelete[] buffer;\r\n\t\treturn;\r\n\t}\r\n\r\n\tauto mskStr = std::make_unique<ImageStream>(maskStr, maskWidth, 1, 1);\r\n\tmskStr->reset();\r\n\tunsigned char *mdest = nullptr;\r\n\tint invert_bit = maskInvert ? 1 : 0;\r\n\tunsigned char * mbuffer = new unsigned char[maskWidth * maskHeight];\r\n\tmemset(mbuffer, 0, maskWidth * maskHeight);\r\n\tfor (int y = 0; y < maskHeight; y++)\r\n\t{\r\n\t\tmdest = mbuffer + y * maskWidth;\r\n\t\tunsigned char * pix = mskStr->getLine();\r\n\t\tfor (int x = 0; x < maskWidth; x++)\r\n\t\t{\r\n\t\t\tif (pix[x] ^ invert_bit)\r\n\t\t\t\t*mdest++ = 0;\r\n\t\t\telse\r\n\t\t\t\t*mdest++ = 255;\r\n\t\t}\r\n\t}\r\n\tif ((maskWidth != width) || (maskHeight != height))\r\n\t\timage = image.scaled(maskWidth, maskHeight, Qt::IgnoreAspectRatio, Qt::SmoothTransformation);\r\n\tQImage res = image.convertToFormat(QImage::Format_ARGB32);\r\n\tunsigned char cc, cm, cy, ck;\r\n\tint s = 0;\r\n\tfor (int yi = 0; yi < res.height(); ++yi)\r\n\t{\r\n\t\tQRgb *t = (QRgb*)(res.scanLine( yi ));\r\n\t\tfor (int xi = 0; xi < res.width(); ++xi)\r\n\t\t{\r\n\t\t\tcc = static_cast<unsigned char>( qRed(*t) );\r\n\t\t\tcm = static_cast<unsigned char>( qGreen(*t) );\r\n\t\t\tcy = static_cast<unsigned char>( qBlue(*t) );\r\n\t\t\tck = mbuffer[s];\r\n\t\t\t(*t) = qRgba(cc, cm, cy, ck);\r\n\t\t\ts++;\r\n\t\t\tt++;\r\n\t\t}\r\n\t}\r\n\r\n\tcreateImageFrame(res, state, 3);\r\n\r\n\tdelete[] buffer;\r\n\tdelete[] mbuffer;\r\n}\r\n\r\nvoid SlaOutputDev::drawImage(GfxState *state, Object *ref, Stream *str, int width, int height, GfxImageColorMap *colorMap, bool interpolate, const int* maskColors, bool inlineImg)\r\n{\r\n\tauto imgStr = std::make_unique<ImageStream>(str, width, colorMap->getNumPixelComps(), colorMap->getBits());\r\n\timgStr->reset();\r\n\r\n\tQImage image(width, height, QImage::Format_ARGB32);\r\n\tif (image.isNull())\r\n\t\treturn;\r\n\r\n\tif (maskColors)\r\n\t{\r\n\t\tfor (int y = 0; y < height; y++)\r\n\t\t{\r\n\t\t\tQRgb *s = (QRgb*)(image.scanLine(y));\r\n\t\t\tunsigned char *pix = imgStr->getLine();\r\n\t\t\tfor (int x = 0; x < width; x++)\r\n\t\t\t{\r\n\t\t\t\tGfxRGB rgb;\r\n\t\t\t\tcolorMap->getRGB(pix, &rgb);\r\n\t\t\t\tint Rc = qRound(colToDbl(rgb.r) * 255);\r\n\t\t\t\tint Gc = qRound(colToDbl(rgb.g) * 255);\r\n\t\t\t\tint Bc = qRound(colToDbl(rgb.b) * 255);\r\n\t\t\t\t*s = qRgba(Rc, Gc, Bc, 255);\r\n\t\t\t\tfor (int i = 0; i < colorMap->getNumPixelComps(); ++i)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (pix[i] < maskColors[2*i] * 255 || pix[i] > maskColors[2*i+1] * 255)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t*s = *s | 0xff000000;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\ts++;\r\n\t\t\t\tpix += colorMap->getNumPixelComps();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tfor (int y = 0; y < height; y++)\r\n\t\t{\r\n\t\t\tQRgb *s = (QRgb*)(image.scanLine(y));\r\n\t\t\tunsigned char *pix = imgStr->getLine();\r\n\t\t\tfor (int x = 0; x < width; x++)\r\n\t\t\t{\r\n\t\t\t\tif (colorMap->getNumPixelComps() == 4)\r\n\t\t\t\t{\r\n\t\t\t\t\tGfxCMYK cmyk;\r\n\t\t\t\t\tcolorMap->getCMYK(pix, &cmyk);\r\n\t\t\t\t\tint Cc = qRound(colToDbl(cmyk.c) * 255);\r\n\t\t\t\t\tint Mc = qRound(colToDbl(cmyk.m) * 255);\r\n\t\t\t\t\tint Yc = qRound(colToDbl(cmyk.y) * 255);\r\n\t\t\t\t\tint Kc = qRound(colToDbl(cmyk.k) * 255);\r\n\t\t\t\t\t*s = qRgba(Yc, Mc, Cc, Kc);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tGfxRGB rgb;\r\n\t\t\t\t\tcolorMap->getRGB(pix, &rgb);\r\n\t\t\t\t\tint Rc = qRound(colToDbl(rgb.r) * 255);\r\n\t\t\t\t\tint Gc = qRound(colToDbl(rgb.g) * 255);\r\n\t\t\t\t\tint Bc = qRound(colToDbl(rgb.b) * 255);\r\n\t\t\t\t\t*s = qRgba(Rc, Gc, Bc, 255);\r\n\t\t\t\t}\r\n\t\t\t\ts++;\r\n\t\t\t\tpix += colorMap->getNumPixelComps();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tcreateImageFrame(image, state, colorMap->getNumPixelComps());\r\n}\r\n\r\nvoid SlaOutputDev::createImageFrame(QImage& image, GfxState *state, int numColorComponents)\r\n{\r\n//\tqDebug() << \"SlaOutputDev::createImageFrame\";\r\n\tconst double *ctm = state->getCTM();\r\n\tdouble xCoor = m_doc->currentPage()->xOffset();\r\n\tdouble yCoor = m_doc->currentPage()->yOffset();\r\n\r\n\tm_ctm = QTransform(ctm[0], ctm[1], ctm[2], ctm[3], ctm[4], ctm[5]);\r\n\tdouble angle = m_ctm.map(QLineF(0, 0, 1, 0)).angle();\r\n\tQPointF torigin;\r\n\t// In PDF all images considered squares with unit length that are transformed into the proper\r\n\t// dimensions by ctm.\r\n\t// A positive determinant retains orientation. Thus orientation is the same as in the PDF\r\n\t// coordinate system (y-axis increases upwards). As Scribus uses the inverse orientation the\r\n\t// image needs to be flipped (a horizontal flip is applied later).  For a flipped image the\r\n\t// corner that will be origin in Scribus is the upper right corner (1, 1) of the image.\r\n\t// A negative determinant changes the orientation such that the image is already in the Scribus\r\n\t// coordinate orientation and no flip is necessary. The origin will be the upper left corner (0, 1).\r\n\tif (m_ctm.determinant() > 0) {\r\n\t\ttorigin = m_ctm.map(QPointF(1, 1));\r\n\t} else {\r\n\t\ttorigin = m_ctm.map(QPointF(0, 1));\r\n\t}\r\n\r\n\t// Determine the visible area of the picture after clipping it. If it is empty, no item\r\n\t// needs to be created.\r\n\tQPainterPath outline;\r\n\toutline.addRect(0, 0, 1, 1);\r\n\toutline = m_ctm.map(outline);\r\n\toutline = intersection(outline, m_graphicStack.top().clipPath);\r\n\r\n\tif ((m_inPattern == 0) && (outline.isEmpty() || outline.boundingRect().isNull()))\r\n\t\treturn;\r\n\r\n    // Determine the width and height of the image by undoing the rotation part\r\n\t// of the CTM and applying the result to the unit square.\r\n\tQTransform without_rotation;\r\n\twithout_rotation = m_ctm * without_rotation.rotate(angle);\r\n\tQRectF trect_wr = without_rotation.mapRect(QRectF(0, 0, 1, 1));\r\n\r\n\tint z = m_doc->itemAdd(PageItem::ImageFrame, PageItem::Rectangle, xCoor + torigin.x(), yCoor + torigin.y(), trect_wr.width(), trect_wr.height(), 0, CommonStrings::None, CommonStrings::None);\r\n\tPageItem* ite = m_doc->Items->at(z);\r\n\tite->ClipEdited = true;\r\n\tite->FrameType = 3;\r\n\tm_doc->setRedrawBounding(ite);\r\n\tite->Clip = flattenPath(ite->PoLine, ite->Segments);\r\n\tite->setTextFlowMode(PageItem::TextFlowDisabled);\r\n\tite->setFillShade(100);\r\n\tite->setLineShade(100);\r\n\tite->setFillEvenOdd(false);\r\n\tite->setFillTransparency(1.0 - state->getFillOpacity());\r\n\tite->setFillBlendmode(getBlendMode(state));\r\n\tif (m_ctm.determinant() > 0)\r\n\t{\r\n\t\tite->setRotation(-(angle - 180));\r\n\t\tite->setImageFlippedH(true);\r\n\t}\r\n\telse\r\n\t\tite->setRotation(-angle);\r\n\tm_doc->adjustItemSize(ite);\r\n\r\n\tif (numColorComponents == 4)\r\n\t{\r\n\t\tauto *tempFile = new QTemporaryFile(QDir::tempPath() + \"/scribus_temp_pdf_XXXXXX.tif\");\r\n\t\ttempFile->setAutoRemove(false);\r\n\t\tif (tempFile->open())\r\n\t\t{\r\n\t\t\tQString fileName = getLongPathName(tempFile->fileName());\r\n\t\t\tif (!fileName.isEmpty())\r\n\t\t\t{\r\n\t\t\t\ttempFile->close();\r\n\t\t\t\tite->isInlineImage = true;\r\n\t\t\t\tite->isTempFile = true;\r\n\t\t\t\tite->AspectRatio = false;\r\n\t\t\t\tite->ScaleType   = false;\r\n\t\t\t\tTIFF* tif = TIFFOpen(fileName.toLocal8Bit().data(), \"w\");\r\n\t\t\t\tif (tif)\r\n\t\t\t\t{\r\n\t\t\t\t\tTIFFSetField(tif, TIFFTAG_IMAGEWIDTH, image.width());\r\n\t\t\t\t\tTIFFSetField(tif, TIFFTAG_IMAGELENGTH, image.height());\r\n\t\t\t\t\tTIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8);\r\n\t\t\t\t\tTIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 4);\r\n\t\t\t\t\tTIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\r\n\t\t\t\t\tTIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_SEPARATED);\r\n\t\t\t\t\tTIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_LZW);\r\n\t\t\t\t\tfor (int y = 0; y < image.height(); ++y)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tTIFFWriteScanline(tif, image.scanLine(y), y);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tTIFFClose(tif);\r\n\t\t\t\t\tm_doc->loadPict(fileName, ite);\r\n\t\t\t\t}\r\n\t\t\t\tm_Elements->append(ite);\r\n\t\t\t\tif (m_groupStack.count() != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tm_groupStack.top().Items.append(ite);\r\n\t\t\t\t\tapplyMask(ite);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\tm_doc->Items->removeAll(ite);\r\n\t\t}\r\n\t\tdelete tempFile;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tauto *tempFile = new QTemporaryFile(QDir::tempPath() + \"/scribus_temp_pdf_XXXXXX.png\");\r\n\t\ttempFile->setAutoRemove(false);\r\n\t\tif (tempFile->open())\r\n\t\t{\r\n\t\t\tQString fileName = getLongPathName(tempFile->fileName());\r\n\t\t\tif (!fileName.isEmpty())\r\n\t\t\t{\r\n\t\t\t\ttempFile->close();\r\n\t\t\t\tite->isInlineImage = true;\r\n\t\t\t\tite->isTempFile = true;\r\n\t\t\t\tite->AspectRatio = false;\r\n\t\t\t\tite->ScaleType   = false;\r\n\t\t\t\timage.save(fileName, \"PNG\");\r\n\t\t\t\tm_doc->loadPict(fileName, ite);\r\n\t\t\t\tm_Elements->append(ite);\r\n\t\t\t\tif (m_groupStack.count() != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tm_groupStack.top().Items.append(ite);\r\n\t\t\t\t\tapplyMask(ite);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\tm_doc->Items->removeAll(ite);\r\n\t\t}\r\n\t\tdelete tempFile;\r\n\t}\r\n\tif (m_inPattern == 0)\r\n\t{\r\n\t\toutline.translate(xCoor - ite->xPos(), yCoor - ite->yPos());\r\n\t\t// Undo the rotation of the clipping path as it is rotated together with the image.\r\n\t\tQTransform mm;\r\n\t\tmm.rotate(-ite->rotation());\r\n\t\toutline = mm.map(outline);\r\n\t\tite->PoLine.fromQPainterPath(outline, true);\r\n\t\tite->setFillEvenOdd(outline.fillRule() == Qt::OddEvenFill);\r\n\t\tite->ClipEdited = true;\r\n\t\tite->FrameType = 3;\r\n\t\tite->setTextFlowMode(PageItem::TextFlowDisabled);\r\n\t\tite->ScaleType   = true;\r\n\t\tm_doc->adjustItemSize(ite);\r\n\t\tite->OldB2 = ite->width();\r\n\t\tite->OldH2 = ite->height();\r\n\t\tite->updateClip();\r\n\t}\r\n}\r\n\r\nvoid SlaOutputDev::beginMarkedContent(const char *name, Object *dictRef)\r\n{\r\n\tmContent mSte;\r\n\tmSte.name = QString(name);\r\n\tmSte.ocgName = \"\";\r\n\tif (m_importerFlags & LoadSavePlugin::lfCreateDoc)\r\n\t{\r\n\t\tif (dictRef->isNull())\r\n\t\t\treturn;\r\n\t\tPOPPLER_CONST_25_02 OCGs *contentConfig = m_catalog->getOptContentConfig();\r\n\t\tOptionalContentGroup *oc;\r\n\t\tif (dictRef->isRef())\r\n\t\t{\r\n\t\t\toc = contentConfig->findOcgByRef(dictRef->getRef());\r\n\t\t\tif (oc)\r\n\t\t\t{\r\n//\t\t\t\tqDebug() << \"Begin OCG Content (Ref) with Name \" << QString(name) << \"Layer\" << UnicodeParsedString(oc->getName());\r\n\t\t\t\tm_doc->setActiveLayer(UnicodeParsedString(oc->getName()));\r\n\t\t\t\tmSte.ocgName = UnicodeParsedString(oc->getName());\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tObject dictObj = dictRef->fetch(m_xref);\r\n\t\t\tif (!dictObj.isDict())\r\n\t\t\t\treturn;\r\n\t\t\tconst Dict* dict = dictObj.getDict();\r\n\t\t\tObject dictType = dict->lookup(\"Type\");\r\n\t\t\tif (dictType.isName(\"OCG\"))\r\n\t\t\t{\r\n\t\t\t\toc = contentConfig->findOcgByRef(dictRef->getRef());\r\n\t\t\t\tif (oc)\r\n\t\t\t\t{\r\n//\t\t\t\t\tqDebug() << \"Begin OCG Content with Name \" << UnicodeParsedString(oc->getName());\r\n\t\t\t\t\tm_doc->setActiveLayer(UnicodeParsedString(oc->getName()));\r\n\t\t\t\t\tmSte.ocgName = UnicodeParsedString(oc->getName());\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tm_mcStack.push(mSte);\r\n}\r\n\r\nvoid SlaOutputDev::beginMarkedContent(const char *name, Dict *properties)\r\n{\r\n//\tqDebug() << \"Begin Marked Content with Name \" << QString(name);\r\n\tQString nam(name);\r\n\tmContent mSte;\r\n\tmSte.name = nam;\r\n\tmSte.ocgName = \"\";\r\n\tm_mcStack.push(mSte);\r\n\tif (m_importerFlags & LoadSavePlugin::lfCreateDoc)\r\n\t{\r\n\t\tif (nam == \"Layer\")\t\t// Handle Adobe Illustrator Layer command\r\n\t\t{\r\n\t\t\tif (layersSetByOCG)\r\n\t\t\t\treturn;\r\n\t\t\tQString lName = QString(\"Layer_%1\").arg(m_layerNum + 1);\r\n\t\t\tObject obj = properties->lookup(\"Title\");\r\n\t\t\tif (obj.isString())\r\n\t\t\t\tlName = QString(obj.getString()->c_str());\r\n\t\t\tfor (const auto& layer : m_doc->Layers)\r\n\t\t\t{\r\n\t\t\t\tif (layer.Name == lName)\r\n\t\t\t\t{\r\n\t\t\t\t\tm_doc->setActiveLayer(lName);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tm_layerNum++;\r\n\t\t\tif (!m_firstLayer)\r\n\t\t\t\tm_currentLayer = m_doc->addLayer(lName, true);\r\n\t\t\tm_firstLayer = false;\r\n\r\n\t\t\tobj = properties->lookup(\"Visible\");\r\n\t\t\tif (obj.isBool())\r\n\t\t\t\tm_doc->setLayerVisible(m_currentLayer, obj.getBool());\r\n\t\t\tobj = properties->lookup(\"Editable\");\r\n\t\t\tif (obj.isBool())\r\n\t\t\t\tm_doc->setLayerLocked(m_currentLayer, !obj.getBool());\r\n\t\t\tobj = properties->lookup(\"Printed\");\r\n\t\t\tif (obj.isBool())\r\n\t\t\t\tm_doc->setLayerPrintable(m_currentLayer, obj.getBool());\r\n\t\t\tobj = properties->lookup(\"Color\");\r\n\t\t\tif (obj.isArray())\r\n\t\t\t{\r\n\t\t\t\tObject obj1;\r\n\t\t\t\tobj1 = obj.arrayGet(0);\r\n\t\t\t\tint r = obj1.getNum() / 256;\r\n\t\t\t\tobj1 = obj.arrayGet(1);\r\n\t\t\t\tint g = obj1.getNum() / 256;\r\n\t\t\t\tobj1 = obj.arrayGet(2);\r\n\t\t\t\tint b = obj1.getNum() / 256;\r\n\t\t\t\tm_doc->setLayerMarker(m_currentLayer, QColor(r, g, b));\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid SlaOutputDev::endMarkedContent(GfxState *state)\r\n{\r\n\tif (m_mcStack.isEmpty())\r\n\t\treturn;\r\n\r\n\tmContent mSte = m_mcStack.pop();\r\n\tif ((m_importerFlags & LoadSavePlugin::lfCreateDoc) == 0)\r\n\t\treturn;\r\n\tif (mSte.name != \"OC\")\r\n\t\treturn;\r\n\r\n\tfor (const auto& layer : m_doc->Layers)\r\n\t{\r\n\t\tif (layer.Name == mSte.ocgName)\r\n\t\t{\r\n\t\t\tm_doc->setActiveLayer(mSte.ocgName);\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid SlaOutputDev::markPoint(const char *name)\r\n{\r\n//\tqDebug() << \"Begin Marked Point with Name \" << QString(name);\r\n}\r\n\r\nvoid SlaOutputDev::markPoint(const char *name, Dict *properties)\r\n{\r\n//\tqDebug() << \"Begin Marked Point with Name \" << QString(name) << \"and Properties\";\r\n\tbeginMarkedContent(name, properties);\r\n}\r\n\r\nvoid SlaOutputDev::updateFont(GfxState *state)\r\n{\r\n\tstd::optional<GfxFontLoc> fontLoc;\r\n\tstd::string fileName;\r\n\tstd::unique_ptr<FoFiTrueType> ff;\r\n\tstd::optional<std::vector<unsigned char>> tmpBuf;\r\n\tGfxFontType fontType;\r\n#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(24, 11, 0)\r\n\tstd::unique_ptr<SlaOutFontFileID> id;\r\n#else\r\n\tSlaOutFontFileID *id;\r\n#endif\r\n\tSplashFontFile *fontFile;\r\n\tSplashFontSrc *fontsrc = nullptr;\r\n\tObject refObj, strObj;\r\n#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(25, 2, 0)\r\n\tstd::vector<int> codeToGID;\r\n#else\r\n\tint *codeToGID = nullptr;\r\n#endif\r\n\tconst double *textMat = nullptr;\r\n\tdouble m11, m12, m21, m22, fontSize;\r\n\tSplashCoord mat[4] = { 1.0, 0.0, 0.0, 1.0 };\r\n\tint n = 0;\r\n\tint faceIndex = 0;\r\n\tSplashCoord matrix[6] = { 1.0, 0.0, 0.0, 1.0, 0.0, 0.0 };\r\n\r\n\tm_font = nullptr;\r\n\r\n\tGfxFont* gfxFont = state->getFont().get();\r\n\tif (!gfxFont)\r\n\t\tgoto err1;\r\n\r\n\tfontType = gfxFont->getType();\r\n\tif (fontType == fontType3)\r\n\t\tgoto err1;\r\n\r\n\t// check the font file cache\r\n#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(24, 11, 0)\r\n\tid = std::make_unique<SlaOutFontFileID>(gfxFont->getID());\r\n\tif ((fontFile = m_fontEngine->getFontFile(*id)))\r\n\t\tid.reset();\r\n#else\r\n\tid = new SlaOutFontFileID(gfxFont->getID());\r\n\tif ((fontFile = m_fontEngine->getFontFile(id)))\r\n\t\tdelete id;\r\n#endif\r\n\telse\r\n\t{\r\n\t\tfontLoc = gfxFont->locateFont(m_xref ? m_xref : m_pdfDoc->getXRef(), nullptr);\r\n\t\tif (!fontLoc)\r\n\t\t{\r\n\t\t\terror(errSyntaxError, -1, \"Couldn't find a font for '{0:s}'\", gfxFont->getName() ? gfxFont->getName()->c_str() : \"(unnamed)\");\r\n\t\t\tgoto err2;\r\n\t\t}\r\n\r\n\t\t// embedded font\r\n\t\tif (fontLoc->locType == gfxFontLocEmbedded)\r\n\t\t{\r\n\t\t\t// if there is an embedded font, read it to memory\r\n\t\t\ttmpBuf = gfxFont->readEmbFontFile(m_xref ? m_xref : m_pdfDoc->getXRef());\r\n\t\t\tif (! tmpBuf)\r\n\t\t\t\tgoto err2;\r\n\r\n\t\t\t// external font\r\n\t\t}\r\n\t\telse\r\n\t\t{ // gfxFontLocExternal\r\n\t\t\tfileName = fontLoc->path;\r\n\t\t\tfontType = fontLoc->fontType;\r\n\t\t}\r\n\r\n\t\tfontsrc = new SplashFontSrc;\r\n\t\tif (!fileName.empty())\r\n\t\t\tfontsrc->setFile(fileName);\r\n\t\telse\r\n\t\t\tfontsrc->setBuf(std::move(tmpBuf.value()));\r\n\r\n\t\t// load the font file\r\n\t\tswitch (fontType) {\r\n\t\tcase fontType1:\r\n#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(24, 11, 0)\r\n\t\t\tif (!(fontFile = m_fontEngine->loadType1Font(std::move(id), fontsrc, (const char**) ((Gfx8BitFont*) gfxFont)->getEncoding(), fontLoc->fontNum)))\r\n\t\t\t{\r\n\t\t\t\terror(errSyntaxError, -1, \"Couldn't create a font for '{0:s}'\", gfxFont->getName() ? gfxFont->getName()->c_str() : \"(unnamed)\");\r\n\t\t\t\tgoto err2;\r\n\t\t\t}\r\n#else\r\n\t\t\tif (!(fontFile = m_fontEngine->loadType1Font(id, fontsrc, (const char **)((Gfx8BitFont *) gfxFont)->getEncoding())))\r\n\t\t\t{\r\n\t\t\t\terror(errSyntaxError, -1, \"Couldn't create a font for '{0:s}'\", gfxFont->getName() ? gfxFont->getName()->c_str() : \"(unnamed)\");\r\n\t\t\t\tgoto err2;\r\n\t\t\t}\r\n#endif\r\n\t\t\tbreak;\r\n\t\tcase fontType1C:\r\n#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(24, 11, 0)\r\n\t\t\tif (!(fontFile = m_fontEngine->loadType1CFont(std::move(id), fontsrc, (const char**) ((Gfx8BitFont*) gfxFont)->getEncoding(), fontLoc->fontNum)))\r\n\t\t\t{\r\n\t\t\t\terror(errSyntaxError, -1, \"Couldn't create a font for '{0:s}'\", gfxFont->getName() ? gfxFont->getName()->c_str() : \"(unnamed)\");\r\n\t\t\t\tgoto err2;\r\n\t\t\t}\r\n#else\r\n\t\t\tif (!(fontFile = m_fontEngine->loadType1CFont(id, fontsrc, (const char **)((Gfx8BitFont *) gfxFont)->getEncoding())))\r\n\t\t\t{\r\n\t\t\t\terror(errSyntaxError, -1, \"Couldn't create a font for '{0:s}'\", gfxFont->getName() ? gfxFont->getName()->c_str() : \"(unnamed)\");\r\n\t\t\t\tgoto err2;\r\n\t\t\t}\r\n#endif\r\n\t\t\tbreak;\r\n\t\tcase fontType1COT:\r\n#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(24, 11, 0)\r\n\t\t\tif (!(fontFile = m_fontEngine->loadOpenTypeT1CFont(std::move(id), fontsrc, (const char **)((Gfx8BitFont *) gfxFont)->getEncoding(), fontLoc->fontNum)))\r\n\t\t\t{\r\n\t\t\t\terror(errSyntaxError, -1, \"Couldn't create a font for '{0:s}'\", gfxFont->getName() ? gfxFont->getName()->c_str() : \"(unnamed)\");\r\n\t\t\t\tgoto err2;\r\n\t\t\t}\r\n#else\r\n\t\t\tif (!(fontFile = m_fontEngine->loadOpenTypeT1CFont(id, fontsrc, (const char **)((Gfx8BitFont *) gfxFont)->getEncoding())))\r\n\t\t\t{\r\n\t\t\t\terror(errSyntaxError, -1, \"Couldn't create a font for '{0:s}'\", gfxFont->getName() ? gfxFont->getName()->c_str() : \"(unnamed)\");\r\n\t\t\t\tgoto err2;\r\n\t\t\t}\r\n#endif\r\n\t\t\tbreak;\r\n\t\tcase fontTrueType:\r\n\t\tcase fontTrueTypeOT:\r\n#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(24, 11, 0)\r\n\t\t\tif (!fileName.empty())\r\n\t\t\t\tff = FoFiTrueType::load(fileName.c_str(), fontLoc->fontNum);\r\n\t\t\telse\r\n\t\t\t\tff = FoFiTrueType::make(fontsrc->buf.data(), fontsrc->buf.size(), fontLoc->fontNum);\r\n#else\r\n\t\t\tif (!fileName.empty())\r\n\t\t\t\tff = FoFiTrueType::load(fileName.c_str());\r\n\t\t\telse\r\n\t\t\t\tff = FoFiTrueType::make(fontsrc->buf.data(), fontsrc->buf.size());\r\n#endif\r\n\t\t\tif (ff)\r\n\t\t\t{\r\n\t\t\t\tcodeToGID = ((Gfx8BitFont*) gfxFont)->getCodeToGIDMap(ff.get());\r\n\t\t\t\tff.reset();\r\n\t\t\t\tn = 256;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(25, 2, 0)\r\n\t\t\t\tcodeToGID.clear();\r\n#else\r\n\t\t\t\tcodeToGID = nullptr;\r\n#endif\r\n\t\t\t\tn = 0;\r\n\t\t\t}\r\n#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(25, 2, 0)\r\n\t\t\tif (!(fontFile = m_fontEngine->loadTrueTypeFont(std::move(id), fontsrc, std::move(codeToGID), fontLoc->fontNum)))\r\n\t\t\t{\r\n\t\t\t\terror(errSyntaxError, -1, \"Couldn't create a font for '{0:s}'\", gfxFont->getName() ? gfxFont->getName()->c_str() : \"(unnamed)\");\r\n\t\t\t\tgoto err2;\r\n\t\t\t}\r\n#elif POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(24, 11, 0)\r\n\t\t\tif (!(fontFile = m_fontEngine->loadTrueTypeFont(std::move(id), fontsrc, codeToGID, n, fontLoc->fontNum)))\r\n\t\t\t{\r\n\t\t\t\terror(errSyntaxError, -1, \"Couldn't create a font for '{0:s}'\", gfxFont->getName() ? gfxFont->getName()->c_str() : \"(unnamed)\");\r\n\t\t\t\tgoto err2;\r\n\t\t\t}\r\n#else\r\n\t\t\tif (!(fontFile = m_fontEngine->loadTrueTypeFont(id, fontsrc, codeToGID, n)))\r\n\t\t\t{\r\n\t\t\t\terror(errSyntaxError, -1, \"Couldn't create a font for '{0:s}'\", gfxFont->getName() ? gfxFont->getName()->c_str() : \"(unnamed)\");\r\n\t\t\t\tgoto err2;\r\n\t\t\t}\r\n#endif\r\n\t\t\tbreak;\r\n\t\tcase fontCIDType0:\r\n\t\tcase fontCIDType0C:\r\n#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(24, 11, 0)\r\n\t\t\tif (!(fontFile = m_fontEngine->loadCIDFont(std::move(id), fontsrc, fontLoc->fontNum)))\r\n\t\t\t{\r\n\t\t\t\terror(errSyntaxError, -1, \"Couldn't create a font for '{0:s}'\", gfxFont->getName() ? gfxFont->getName()->c_str() : \"(unnamed)\");\r\n\t\t\t\tgoto err2;\r\n\t\t\t}\r\n#else\r\n\t\t\tif (!(fontFile = m_fontEngine->loadCIDFont(id, fontsrc)))\r\n\t\t\t{\r\n\t\t\t\terror(errSyntaxError, -1, \"Couldn't create a font for '{0:s}'\", gfxFont->getName() ? gfxFont->getName()->c_str() : \"(unnamed)\");\r\n\t\t\t\tgoto err2;\r\n\t\t\t}\r\n#endif\r\n\t\t\tbreak;\r\n\t\tcase fontCIDType0COT:\r\n#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(25, 2, 0)\r\n\t\t\tif (((GfxCIDFont*) gfxFont)->getCIDToGIDLen() > 0)\r\n\t\t\t{\r\n\t\t\t\tcodeToGID = ((GfxCIDFont*) gfxFont)->getCIDToGID();\r\n\t\t\t\tn = codeToGID.size();\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tcodeToGID.clear();\r\n\t\t\t\tn = 0;\r\n\t\t\t}\r\n#else\r\n\t\t\tif (((GfxCIDFont *) gfxFont)->getCIDToGID())\r\n\t\t\t{\r\n\t\t\t\tn = ((GfxCIDFont *) gfxFont)->getCIDToGIDLen();\r\n\t\t\t\tcodeToGID = (int *) gmallocn(n, sizeof(*codeToGID));\r\n\t\t\t\tmemcpy(codeToGID, ((GfxCIDFont *) gfxFont)->getCIDToGID(), n * sizeof(*codeToGID));\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tcodeToGID = nullptr;\r\n\t\t\t\tn = 0;\r\n\t\t\t}\r\n#endif\r\n#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(25, 2, 0)\r\n\t\t\tif (!(fontFile = m_fontEngine->loadOpenTypeCFFFont(std::move(id), fontsrc, std::move(codeToGID), fontLoc->fontNum)))\r\n\t\t\t{\r\n\t\t\t\terror(errSyntaxError, -1, \"Couldn't create a font for '{0:s}'\",\r\n\t\t\t\t\tgfxFont->getName() ? gfxFont->getName()->c_str() : \"(unnamed)\");\r\n\t\t\t\tgoto err2;\r\n\t\t\t}\r\n#elif POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(24, 11, 0)\r\n\t\t\tif (!(fontFile = m_fontEngine->loadOpenTypeCFFFont(std::move(id), fontsrc, codeToGID, n, fontLoc->fontNum)))\r\n\t\t\t{\r\n\t\t\t\terror(errSyntaxError, -1, \"Couldn't create a font for '{0:s}'\",\r\n\t\t\t\t\tgfxFont->getName() ? gfxFont->getName()->c_str() : \"(unnamed)\");\r\n\t\t\t\tgoto err2;\r\n\t\t\t}\r\n#else\r\n\t\t\tif (!(fontFile = m_fontEngine->loadOpenTypeCFFFont(id, fontsrc, codeToGID, n)))\r\n\t\t\t{\r\n\t\t\t\terror(errSyntaxError, -1, \"Couldn't create a font for '{0:s}'\",\r\n\t\t\t\tgfxFont->getName() ? gfxFont->getName()->c_str() : \"(unnamed)\");\r\n\t\t\t\tgoto err2;\r\n\t\t\t}\r\n#endif\r\n\t\t\tbreak;\r\n\t\tcase fontCIDType2:\r\n\t\tcase fontCIDType2OT:\r\n#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(25, 2, 0)\r\n\t\t\tcodeToGID.clear();\r\n\t\t\tn = 0;\r\n\t\t\tif (((GfxCIDFont*) gfxFont)->getCIDToGIDLen() > 0)\r\n\t\t\t{\r\n\t\t\t\tcodeToGID = ((GfxCIDFont*) gfxFont)->getCIDToGID();\r\n\t\t\t\tn = codeToGID.size();\r\n\t\t\t}\r\n#else\r\n\t\t\tcodeToGID = nullptr;\r\n\t\t\tn = 0;\r\n\t\t\tif (((GfxCIDFont *) gfxFont)->getCIDToGID())\r\n\t\t\t{\r\n\t\t\t\tn = ((GfxCIDFont *) gfxFont)->getCIDToGIDLen();\r\n\t\t\t\tif (n)\r\n\t\t\t\t{\r\n\t\t\t\t\tcodeToGID = (int *)gmallocn(n, sizeof(*codeToGID));\r\n\t\t\t\t\tmemcpy(codeToGID, ((GfxCIDFont *)gfxFont)->getCIDToGID(), n * sizeof(*codeToGID));\r\n\t\t\t\t}\r\n\t\t\t}\r\n#endif\r\n\t\t\telse\r\n\t\t\t{\r\n#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(24, 11, 0)\r\n\t\t\t\tif (!fileName.empty())\r\n\t\t\t\t\tff = FoFiTrueType::load(fileName.c_str(), fontLoc->fontNum);\r\n\t\t\t\telse\r\n\t\t\t\t\tff = FoFiTrueType::make(fontsrc->buf.data(), fontsrc->buf.size(), fontLoc->fontNum);\r\n#else\r\n\t\t\t\tif (!fileName.empty())\r\n\t\t\t\t\tff = FoFiTrueType::load(fileName.c_str());\r\n\t\t\t\telse\r\n\t\t\t\t\tff = FoFiTrueType::make(fontsrc->buf.data(), fontsrc->buf.size());\r\n#endif\r\n\t\t\t\tif (! ff)\r\n\t\t\t\t\tgoto err2;\r\n#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(25, 2, 0)\r\n\t\t\t\tcodeToGID = ((GfxCIDFont*) gfxFont)->getCodeToGIDMap(ff.get());\r\n#else\r\n\t\t\t\tcodeToGID = ((GfxCIDFont*) gfxFont)->getCodeToGIDMap(ff.get(), &n);\r\n#endif\r\n\t\t\t\tff.reset();\r\n\t\t\t}\r\n#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(25, 2, 0)\r\n\t\t\tif (!(fontFile = m_fontEngine->loadTrueTypeFont(std::move(id), fontsrc, std::move(codeToGID), fontLoc->fontNum)))\r\n\t\t\t{\r\n\t\t\t\terror(errSyntaxError, -1, \"Couldn't create a font for '{0:s}'\", gfxFont->getName() ? gfxFont->getName()->c_str() : \"(unnamed)\");\r\n\t\t\t\tgoto err2;\r\n\t\t\t}\r\n#elif POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(24, 11, 0)\r\n\t\t\tif (!(fontFile = m_fontEngine->loadTrueTypeFont(std::move(id), fontsrc, codeToGID, n, fontLoc->fontNum)))\r\n\t\t\t{\r\n\t\t\t\terror(errSyntaxError, -1, \"Couldn't create a font for '{0:s}'\", gfxFont->getName() ? gfxFont->getName()->c_str() : \"(unnamed)\");\r\n\t\t\t\tgoto err2;\r\n\t\t\t}\r\n#else\r\n\t\t\tif (!(fontFile = m_fontEngine->loadTrueTypeFont(id, fontsrc, codeToGID, n, faceIndex)))\r\n\t\t\t{\r\n\t\t\t\terror(errSyntaxError, -1, \"Couldn't create a font for '{0:s}'\", gfxFont->getName() ? gfxFont->getName()->c_str() : \"(unnamed)\");\r\n\t\t\t\tgoto err2;\r\n\t\t\t}\r\n#endif\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\t// this shouldn't happen\r\n\t\t\tgoto err2;\r\n\t\t}\r\n\t}",
    "void SlaOutputDev::createImageFrame(QImage& image, GfxState *state, int numColorComponents)\r\n{\r\n//\tqDebug() << \"SlaOutputDev::createImageFrame\";\r\n\tconst double *ctm = state->getCTM();\r\n\tdouble xCoor = m_doc->currentPage()->xOffset();\r\n\tdouble yCoor = m_doc->currentPage()->yOffset();\r\n\r\n\tm_ctm = QTransform(ctm[0], ctm[1], ctm[2], ctm[3], ctm[4], ctm[5]);\r\n\tdouble angle = m_ctm.map(QLineF(0, 0, 1, 0)).angle();\r\n\tQPointF torigin;\r\n\t// In PDF all images considered squares with unit length that are transformed into the proper\r\n\t// dimensions by ctm.\r\n\t// A positive determinant retains orientation. Thus orientation is the same as in the PDF\r\n\t// coordinate system (y-axis increases upwards). As Scribus uses the inverse orientation the\r\n\t// image needs to be flipped (a horizontal flip is applied later).  For a flipped image the\r\n\t// corner that will be origin in Scribus is the upper right corner (1, 1) of the image.\r\n\t// A negative determinant changes the orientation such that the image is already in the Scribus\r\n\t// coordinate orientation and no flip is necessary. The origin will be the upper left corner (0, 1).\r\n\tif (m_ctm.determinant() > 0) {\r\n\t\ttorigin = m_ctm.map(QPointF(1, 1));\r\n\t} else {\r\n\t\ttorigin = m_ctm.map(QPointF(0, 1));\r\n\t}\r\n\r\n\t// Determine the visible area of the picture after clipping it. If it is empty, no item\r\n\t// needs to be created.\r\n\tQPainterPath outline;\r\n\toutline.addRect(0, 0, 1, 1);\r\n\toutline = m_ctm.map(outline);\r\n\toutline = intersection(outline, m_graphicStack.top().clipPath);\r\n\r\n\tif ((m_inPattern == 0) && (outline.isEmpty() || outline.boundingRect().isNull()))\r\n\t\treturn;\r\n\r\n    // Determine the width and height of the image by undoing the rotation part\r\n\t// of the CTM and applying the result to the unit square.\r\n\tQTransform without_rotation;\r\n\twithout_rotation = m_ctm * without_rotation.rotate(angle);\r\n\tQRectF trect_wr = without_rotation.mapRect(QRectF(0, 0, 1, 1));\r\n\r\n\tint z = m_doc->itemAdd(PageItem::ImageFrame, PageItem::Rectangle, xCoor + torigin.x(), yCoor + torigin.y(), trect_wr.width(), trect_wr.height(), 0, CommonStrings::None, CommonStrings::None);\r\n\tPageItem* ite = m_doc->Items->at(z);\r\n\tite->ClipEdited = true;\r\n\tite->FrameType = 3;\r\n\tm_doc->setRedrawBounding(ite);\r\n\tite->Clip = flattenPath(ite->PoLine, ite->Segments);\r\n\tite->setTextFlowMode(PageItem::TextFlowDisabled);\r\n\tite->setFillShade(100);\r\n\tite->setLineShade(100);\r\n\tite->setFillEvenOdd(false);\r\n\tite->setFillTransparency(1.0 - state->getFillOpacity());\r\n\tite->setFillBlendmode(getBlendMode(state));\r\n\tif (m_ctm.determinant() > 0)\r\n\t{\r\n\t\tite->setRotation(-(angle - 180));\r\n\t\tite->setImageFlippedH(true);\r\n\t}\r\n\telse\r\n\t\tite->setRotation(-angle);\r\n\tm_doc->adjustItemSize(ite);\r\n\r\n\tif (numColorComponents == 4)\r\n\t{\r\n\t\tauto *tempFile = new QTemporaryFile(QDir::tempPath() + \"/scribus_temp_pdf_XXXXXX.tif\");\r\n\t\ttempFile->setAutoRemove(false);\r\n\t\tif (tempFile->open())\r\n\t\t{\r\n\t\t\tQString fileName = getLongPathName(tempFile->fileName());\r\n\t\t\tif (!fileName.isEmpty())\r\n\t\t\t{\r\n\t\t\t\ttempFile->close();\r\n\t\t\t\tite->isInlineImage = true;\r\n\t\t\t\tite->isTempFile = true;\r\n\t\t\t\tite->AspectRatio = false;\r\n\t\t\t\tite->ScaleType   = false;\r\n\t\t\t\tTIFF* tif = TIFFOpen(fileName.toLocal8Bit().data(), \"w\");\r\n\t\t\t\tif (tif)\r\n\t\t\t\t{\r\n\t\t\t\t\tTIFFSetField(tif, TIFFTAG_IMAGEWIDTH, image.width());\r\n\t\t\t\t\tTIFFSetField(tif, TIFFTAG_IMAGELENGTH, image.height());\r\n\t\t\t\t\tTIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8);\r\n\t\t\t\t\tTIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 4);\r\n\t\t\t\t\tTIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\r\n\t\t\t\t\tTIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_SEPARATED);\r\n\t\t\t\t\tTIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_LZW);\r\n\t\t\t\t\tfor (int y = 0; y < image.height(); ++y)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tTIFFWriteScanline(tif, image.scanLine(y), y);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tTIFFClose(tif);\r\n\t\t\t\t\tm_doc->loadPict(fileName, ite);\r\n\t\t\t\t}\r\n\t\t\t\tm_Elements->append(ite);\r\n\t\t\t\tif (m_groupStack.count() != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tm_groupStack.top().Items.append(ite);\r\n\t\t\t\t\tapplyMask(ite);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\tm_doc->Items->removeAll(ite);\r\n\t\t}\r\n\t\tdelete tempFile;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tauto *tempFile = new QTemporaryFile(QDir::tempPath() + \"/scribus_temp_pdf_XXXXXX.png\");\r\n\t\ttempFile->setAutoRemove(false);\r\n\t\tif (tempFile->open())\r\n\t\t{\r\n\t\t\tQString fileName = getLongPathName(tempFile->fileName());\r\n\t\t\tif (!fileName.isEmpty())\r\n\t\t\t{\r\n\t\t\t\ttempFile->close();\r\n\t\t\t\tite->isInlineImage = true;\r\n\t\t\t\tite->isTempFile = true;\r\n\t\t\t\tite->AspectRatio = false;\r\n\t\t\t\tite->ScaleType   = false;\r\n\t\t\t\timage.save(fileName, \"PNG\");\r\n\t\t\t\tm_doc->loadPict(fileName, ite);\r\n\t\t\t\tm_Elements->append(ite);\r\n\t\t\t\tif (m_groupStack.count() != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tm_groupStack.top().Items.append(ite);\r\n\t\t\t\t\tapplyMask(ite);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\tm_doc->Items->removeAll(ite);\r\n\t\t}\r\n\t\tdelete tempFile;\r\n\t}\r\n\tif (m_inPattern == 0)\r\n\t{\r\n\t\toutline.translate(xCoor - ite->xPos(), yCoor - ite->yPos());\r\n\t\t// Undo the rotation of the clipping path as it is rotated together with the image.\r\n\t\tQTransform mm;\r\n\t\tmm.rotate(-ite->rotation());\r\n\t\toutline = mm.map(outline);\r\n\t\tite->PoLine.fromQPainterPath(outline, true);\r\n\t\tite->setFillEvenOdd(outline.fillRule() == Qt::OddEvenFill);\r\n\t\tite->ClipEdited = true;\r\n\t\tite->FrameType = 3;\r\n\t\tite->setTextFlowMode(PageItem::TextFlowDisabled);\r\n\t\tite->ScaleType   = true;\r\n\t\tm_doc->adjustItemSize(ite);\r\n\t\tite->OldB2 = ite->width();\r\n\t\tite->OldH2 = ite->height();\r\n\t\tite->updateClip();\r\n\t}\r\n}",
    "void ScImgDataLoader_TIFF::loadEmbeddedProfile(const QString& fn, int /*page*/)\n{\n\tm_embeddedProfile.resize(0);\n\tm_profileComponents = 0;\n\tif (!QFile::exists(fn))\n\t\treturn;\n\n\tTIFFSetTagExtender(TagExtender);\n\tTIFF* tif = TIFFOpen(fn.toLocal8Bit(), \"r\");\n\tif (!tif)\n\t\treturn;\n\n\tuint32_t EmbedLen = 0;\n\tvoid*  EmbedBuffer;\n\tif (TIFFGetField(tif, TIFFTAG_ICCPROFILE, &EmbedLen, &EmbedBuffer))\n\t{\n\t\tbool profileIsValid = false;\n\t\tQByteArray profArray((const char*) EmbedBuffer, EmbedLen);\n\t\tScColorMgmtEngine engine(ScCore->defaultEngine);\n\t\tScColorProfile tiffProf = engine.openProfileFromMem(profArray);\n\t\tif (tiffProf)\n\t\t{\n\t\t\tuint16_t photometric = 0;\n\t\t\tuint16_t samplesPerPixel = 0;\n\t\t\tTIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric);\n\t\t\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &samplesPerPixel);\n\t\t\teColorSpaceType colorSpace = tiffProf.colorSpace();\n\t\t\tif (colorSpace == ColorSpace_Rgb)\n\t\t\t\tprofileIsValid = (photometric == PHOTOMETRIC_RGB);\n\t\t\tif (colorSpace == ColorSpace_Cmyk)\n\t\t\t\tprofileIsValid = (photometric == PHOTOMETRIC_SEPARATED && samplesPerPixel >= 4);\n\t\t\tif (colorSpace == ColorSpace_Gray)\n\t\t\t\tprofileIsValid = (photometric == PHOTOMETRIC_MINISBLACK || photometric == PHOTOMETRIC_MINISWHITE);\n\t\t}\n\t\tif (profileIsValid)\n\t\t{\n\t\t\tif (tiffProf.colorSpace() == ColorSpace_Rgb)\n\t\t\t\tm_profileComponents = 3;\n\t\t\tif (tiffProf.colorSpace() == ColorSpace_Cmyk)\n\t\t\t\tm_profileComponents = 4;\n\t\t\tif (tiffProf.colorSpace() == ColorSpace_Gray)\n\t\t\t\tm_profileComponents = 1;\n\t\t\tm_embeddedProfile = profArray;\n\t\t}\n\t}\n\tTIFFClose(tif);\n}",
    "int ScImgDataLoader_TIFF::getLayers(const QString& fn, int /*page*/)\n{\n\tint layerNum = 1;\n\tint test;\n\tstruct PSDLayer lay;\n\tTIFFSetTagExtender(TagExtender);\n\tTIFF* tif = TIFFOpen(fn.toLocal8Bit(), \"r\");\n\tif (!tif)\n\t\treturn layerNum;\n\n\tdo\n\t{\n\t\tchar *layerName = nullptr;\n\t\tTIFFGetField(tif, TIFFTAG_PAGENAME, &layerName);\n\t\tQString name(layerName);\n\t\tif (name.isEmpty())\n\t\t\tlay.layerName = QString(\"Layer #%1\").arg(layerNum);\n\t\telse\n\t\t\tlay.layerName = name;\n\t\tlay.blend = \"norm\";\n\t\tlay.opacity = 255;\n\t\tlay.flags = 0;\n\t\tm_imageInfoRecord.layerInfo.append(lay);\n\t\tm_imageInfoRecord.valid = true;\n\t\tlayerNum++;\n\t\ttest = TIFFReadDirectory(tif);\n\t}\n\twhile (test == 1);\n\tTIFFClose(tif);\n\n\treturn layerNum;\n}",
    "bool ScImgDataLoader_TIFF::getImageData(TIFF* tif, RawImage *image, uint widtht, uint heightt, uint size, const SampleFormatInfo& sampleInfo, bool &bilevel, bool &isCMYK)\n{\n\tif (sampleInfo.photometric != PHOTOMETRIC_SEPARATED)\n\t{\n\t\tif (!getImageData_RGBA(tif, image, widtht, heightt, size, sampleInfo))\n\t\t\treturn false;\n\t\tif (sampleInfo.bitsPerSample == 1)\n\t\t\tbilevel = true;\n\t\tm_pixelFormat = Format_RGBA_8;\n\t\treturn true;\n\t}\n\n\t// Now we are in the PHOTOMETRIC_SEPARATED case\n\tif (sampleInfo.samplesPerPixel > 5)\n\t{\n\t\tif (!getImageData_RGBA(tif, image, widtht, heightt, size, sampleInfo))\n\t\t\treturn false;\n\t\tif (sampleInfo.bitsPerSample == 1)\n\t\t\tbilevel = true;\n\t\tisCMYK = false;\n\t\tm_pixelFormat = Format_RGBA_8;\n\t\treturn true;\n\t}\n\n\tif (sampleInfo.samplesFormat != SAMPLEFORMAT_UINT && sampleInfo.samplesFormat != SAMPLEFORMAT_INT)\n\t{\n\t\tm_message = QObject::tr(\"This image uses an unsupported non integer sample format\");\n\t\tm_msgType = errorMsg;\n\t\treturn false;\n\t}\n\n\tif (sampleInfo.bitsPerSample > 16)\n\t{\n\t\tm_message = QObject::tr(\"This image uses an unsupported bit depth: %1 bits per sample.\").arg(sampleInfo.bitsPerSample);\n\t\tm_msgType = errorMsg;\n\t\treturn false;\n\t}\n\n\tif (TIFFIsTiled(tif))\n\t{\n\t\tuint32_t columns, rows;\n\t\tuint32_t *tile_buf;\n\t\tuint32_t xt, yt;\n\t\tTIFFGetField(tif, TIFFTAG_TILEWIDTH,  &columns);\n\t\tTIFFGetField(tif, TIFFTAG_TILELENGTH, &rows);\n\t\ttile_buf = (uint32_t*) _TIFFmalloc(columns * rows * sizeof(uint32_t));\n\t\tif (tile_buf == nullptr)\n\t\t{\n\t\t\tTIFFClose(tif);\n\t\t\treturn false;\n\t\t}\n\t\tuint32_t tileW = columns, tileH = rows;\n\t\tfor (yt = 0; yt < (uint32_t) image->height(); yt += rows)\n\t\t{\n\t\t\tif (yt > (uint) image->height())\n\t\t\t\tbreak;\n\t\t\tif (image->height() - yt < rows)\n\t\t\t\ttileH = image->height() - yt;\n\t\t\ttileW = columns;\n\t\t\tuint32_t yi;\n\t\t\tint chans = image->channels();\n\t\t\tfor (xt = 0; xt < (uint) image->width(); xt += columns)\n\t\t\t{\n\t\t\t\tTIFFReadTile(tif, tile_buf, xt, yt, 0, 0);\n\t\t\t\tfor (yi = 0; yi < tileH; yi++)\n\t\t\t\t{\n\t\t\t\t\t_TIFFmemcpy(image->scanLine(yt + (tileH - 1 - yi)) + xt, tile_buf + tileW * yi, tileW * chans);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_TIFFfree(tile_buf);\n\t}\n\telse\n\t{\n\t\tint chans = image->channels();\n\t\ttsize_t bytesperrow = TIFFScanlineSize(tif);\n\t\tuint32_t *bits = (uint32_t *) _TIFFmalloc(bytesperrow);\n\t\tif (bits)\n\t\t{\n\t\t\tfor (unsigned int y = 0; y < heightt; y++)\n\t\t\t{\n\t\t\t\tif (!TIFFReadScanline(tif, bits, y, 0))\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (sampleInfo.bitsPerSample == 16 && sampleInfo.samplesFormat == SAMPLEFORMAT_UINT)\n\t\t\t\t\tconvertImageData((uint16_t*) bits, (uint8_t*) image->scanLine(y), chans * widtht);\n\t\t\t\telse if (sampleInfo.bitsPerSample == 16 && sampleInfo.samplesFormat == SAMPLEFORMAT_INT)\n\t\t\t\t\tconvertImageData((int16_t*) bits, (uint8_t*) image->scanLine(y), chans * widtht);\n\t\t\t\telse\n\t\t\t\t\tmemcpy(image->scanLine(y), bits, chans * widtht);\n\t\t\t}\n\t\t\t_TIFFfree(bits);\n\t\t}\n\t}\n\tisCMYK = true;\n\tm_pixelFormat = (image->channels() == 5) ? Format_CMYKA_8 : Format_CMYK_8;\n\n\treturn true;\n}",
    "bool ScImgDataLoader_TIFF::loadPicture(const QString& fn, int page, int res, bool thumbnail)\n{\n\tScColorMgmtEngine engine(ScCore->defaultEngine);\n\tbool bilevel = false;\n\tbool failedPS = false;\n\tbool foundPS = false;\n\tshort resolutionUnit = RESUNIT_INCH; // Default unit is inch\n\tfloat xres = 72.0, yres = 72.0;\n\tif (!QFile::exists(fn))\n\t\treturn false;\n\tQByteArray byteOrder(2, ' ');\n\tQFile fo(fn);\n\tif (fo.open(QIODevice::ReadOnly))\n\t{\n\t\tfo.read(byteOrder.data(), 1);\n\t\tfo.close();\n\t}\n\tsrand(314159265);\n\tfor (int i = 0; i < 4096; i++)\n\t\tm_random_table[i] = rand();\n\tfor (int i = 0; i < 4096; i++)\n\t{\n\t\tint tmp;\n\t\tint swap = i + rand() % (4096 - i);\n\t\ttmp = m_random_table[i];\n\t\tm_random_table[i] = m_random_table[swap];\n\t\tm_random_table[swap] = tmp;\n\t}\n\n\tinitialize();\n\n\tint test;\n\tbool valid = m_imageInfoRecord.isRequest;\n\tQMap<int, ImageLoadRequest> req = m_imageInfoRecord.RequestProps;\n\tm_imageInfoRecord.RequestProps = req;\n\tm_imageInfoRecord.isRequest = valid;\n\tm_imageInfoRecord.type = ImageTypeTIF;\n\tgetLayers(fn, page);\n\n\tTIFFSetTagExtender(TagExtender);\n\tTIFF* tif = TIFFOpen(fn.toLocal8Bit(), \"r\");\n\tif (!tif)\n\t\treturn false;\n\n\tbool isCMYK = false;\n\tunsigned int widtht, heightt, size;\n\tchar* description = nullptr;\n\tchar* copyright = nullptr;\n\tchar* datetime = nullptr;\n\tchar* artist = nullptr;\n\tchar* scannerMake = nullptr;\n\tchar* scannerModel = nullptr;\n\tuint16_t bitsPerSample = 1;\n\tuint16_t sampleFormat = SAMPLEFORMAT_UINT;\n\tuint16_t fillorder = FILLORDER_MSB2LSB;\n\tuint16_t planar = PLANARCONFIG_CONTIG;\n\n\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &widtht);\n\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &heightt);\n\tTIFFGetField(tif, TIFFTAG_XRESOLUTION, &xres);\n\tTIFFGetField(tif, TIFFTAG_YRESOLUTION, &yres);\n\tTIFFGetField(tif, TIFFTAG_RESOLUTIONUNIT , &resolutionUnit);\n\tsize = widtht * heightt;\n\tTIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &m_photometric);\n\tTIFFGetField(tif, TIFFTAG_PLANARCONFIG, &planar);\n\tTIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bitsPerSample);\n\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &m_samplesPerPixel);\n\tTIFFGetField(tif, TIFFTAG_SAMPLEFORMAT, &sampleFormat);\n\tTIFFGetField(tif, TIFFTAG_FILLORDER, &fillorder);\n\n\tTIFFGetField(tif, TIFFTAG_MAKE, &scannerMake);\n\tTIFFGetField(tif, TIFFTAG_MODEL, &scannerModel);\n\tTIFFGetField(tif, TIFFTAG_IMAGEDESCRIPTION, &description);\n\tTIFFGetField(tif, TIFFTAG_COPYRIGHT, &copyright);\n\tTIFFGetField(tif, TIFFTAG_DATETIME, &datetime);\n\tTIFFGetField(tif, TIFFTAG_ARTIST, &artist);\n\n\tSampleFormatInfo sampleInfo;\n\tsampleInfo.photometric = m_photometric;\n\tsampleInfo.bitsPerSample = bitsPerSample;\n\tsampleInfo.samplesPerPixel = m_samplesPerPixel;\n\tsampleInfo.samplesFormat = sampleFormat;\n\tsampleInfo.fillOrder = fillorder;\n\n\tm_imageInfoRecord.exifInfo.cameraName = QString(scannerModel);\n\tm_imageInfoRecord.exifInfo.cameraVendor = QString(scannerMake);\n\tm_imageInfoRecord.exifInfo.comment = QString(description);\n\tm_imageInfoRecord.exifInfo.userComment = QString(copyright);\n\tm_imageInfoRecord.exifInfo.width = widtht;\n\tm_imageInfoRecord.exifInfo.height = heightt;\n\tm_imageInfoRecord.exifInfo.dateTime = QString(datetime);\n\tm_imageInfoRecord.exifInfo.artist = QString(artist);\n\tm_imageInfoRecord.exifInfo.thumbnail = QImage();\n\tm_imageInfoRecord.exifDataValid = true;\n\n\tm_imageInfoRecord.isEmbedded = false;\n\tm_imageInfoRecord.profileName.clear();\n\tm_imageInfoRecord.embeddedProfileName.clear();\n\n\tuint32_t EmbedLen = 0;\n\tvoid*  EmbedBuffer;\n\tif (TIFFGetField(tif, TIFFTAG_ICCPROFILE, &EmbedLen, &EmbedBuffer))\n\t{\n\t\tbool profileIsValid = false;\n\t\tQByteArray profArray((const char*) EmbedBuffer, EmbedLen);\n\t\tScColorProfile tiffProf = engine.openProfileFromMem(profArray);\n\t\tif (tiffProf)\n\t\t{\n\t\t\teColorSpaceType colorSpace = tiffProf.colorSpace();\n\t\t\tif (colorSpace == ColorSpace_Rgb)\n\t\t\t\tprofileIsValid = (m_photometric == PHOTOMETRIC_RGB);\n\t\t\tif (colorSpace == ColorSpace_Cmyk)\n\t\t\t\tprofileIsValid = (m_photometric == PHOTOMETRIC_SEPARATED && m_samplesPerPixel >= 4);\n\t\t\tif (colorSpace == ColorSpace_Gray)\n\t\t\t\tprofileIsValid = (m_photometric == PHOTOMETRIC_MINISBLACK || m_photometric == PHOTOMETRIC_MINISWHITE);\n\t\t}\n\t\tif (profileIsValid)\n\t\t{\n\t\t\tm_embeddedProfile = profArray;\n\t\t\tm_imageInfoRecord.profileName = tiffProf.productDescription();\n\t\t\tm_imageInfoRecord.embeddedProfileName = m_imageInfoRecord.profileName;\n\t\t\tm_imageInfoRecord.isEmbedded = true;\n\t\t}\n\t}\n\n\tunsigned int PhotoshopLen = 0;\n\tunsigned char* PhotoshopBuffer;\n\tif (TIFFGetField(tif, TIFFTAG_PHOTOSHOP, &PhotoshopLen, &PhotoshopBuffer) )\n\t{\n\t\tif (PhotoshopLen != 0)\n\t\t{\n\t\t\tQByteArray arrayPhot = QByteArray((const char*)PhotoshopBuffer,PhotoshopLen);\n\t\t\tQDataStream strPhot(&arrayPhot,QIODevice::ReadOnly);\n\t\t\tstrPhot.setByteOrder( QDataStream::BigEndian );\n\t\t\tPSDHeader fakeHeader;\n\t\t\tfakeHeader.width = widtht;\n\t\t\tfakeHeader.height = heightt;\n\t\t\tparseResourceData(strPhot, fakeHeader, PhotoshopLen);\n\t\t\tm_imageInfoRecord.exifInfo.width = widtht;\n\t\t\tm_imageInfoRecord.exifInfo.height = heightt;\n\t\t\tif (!m_imageInfoRecord.valid)\n\t\t\t\tm_imageInfoRecord.valid = (m_imageInfoRecord.PDSpathData.size())>0;\n\t\t\tif (thumbnail)\n\t\t\t{\n\t\t\t\tif (m_photometric == PHOTOMETRIC_SEPARATED)\n\t\t\t\t{\n\t\t\t\t\tisCMYK = true;\n\t\t\t\t\tm_imageInfoRecord.colorspace = ColorSpaceCMYK;\n\t\t\t\t}\n\t\t\t\telse if (m_samplesPerPixel == 1)\n\t\t\t\t{\n\t\t\t\t\tm_imageInfoRecord.colorspace = ColorSpaceGray;\n\t\t\t\t\tisCMYK = false;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tm_imageInfoRecord.colorspace = ColorSpaceRGB;\n\t\t\t\tif (bitsPerSample == 1)\n\t\t\t\t\tbilevel = true;\n\t\t\t\tif (!m_imageInfoRecord.exifInfo.thumbnail.isNull())\n\t\t\t\t{\n\t\t\t\t\tif (isCMYK)\n\t\t\t\t\t{\n\t\t\t\t\t\tr_image.create(m_imageInfoRecord.exifInfo.thumbnail.width(), m_imageInfoRecord.exifInfo.thumbnail.height(), 5);\n\t\t\t\t\t\tm_pixelFormat = Format_CMYKA_8;;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tr_image.create(m_imageInfoRecord.exifInfo.thumbnail.width(), m_imageInfoRecord.exifInfo.thumbnail.height(), 4);\n\t\t\t\t\t\tm_pixelFormat = (m_imageInfoRecord.colorspace == ColorSpaceCMYK) ? Format_CMYK_8 : Format_RGBA_8;\n\t\t\t\t\t}\n\t\t\t\t\tr_image.fill(0);\n\t\t\t\t\tQRgb *s;\n\t\t\t\t\tuchar *d;\n\t\t\t\t\tunsigned char cc, cm, cy, ck;\n\t\t\t\t\tfor (int yit = 0; yit < m_imageInfoRecord.exifInfo.thumbnail.height(); ++yit)\n\t\t\t\t\t{\n\t\t\t\t\t\ts = (QRgb*)(m_imageInfoRecord.exifInfo.thumbnail.scanLine(yit));\n\t\t\t\t\t\td = r_image.scanLine(yit);\n\t\t\t\t\t\tfor (int xit = 0; xit < m_imageInfoRecord.exifInfo.thumbnail.width(); ++xit)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (isCMYK)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcc = 255 - qRed(*s);\n\t\t\t\t\t\t\t\tcm = 255 - qGreen(*s);\n\t\t\t\t\t\t\t\tcy = 255 - qBlue(*s);\n\t\t\t\t\t\t\t\tck = qMin(qMin(cc, cm), cy);\n\t\t\t\t\t\t\t\td[0] = cc-ck;\n\t\t\t\t\t\t\t\td[1] = cm-ck;\n\t\t\t\t\t\t\t\td[2] = cy-ck;\n\t\t\t\t\t\t\t\td[3] = ck;\n\t\t\t\t\t\t\t\td[4] = 255;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\td[0] = qRed(*s);\n\t\t\t\t\t\t\t\td[1] = qGreen(*s);\n\t\t\t\t\t\t\t\td[2] = qBlue(*s);\n\t\t\t\t\t\t\t\td[3] = 255;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ts++;\n\t\t\t\t\t\t\td += r_image.channels();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tTIFFClose(tif);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tunsigned int PhotoshopLen2 = 0;\n\tunsigned char* PhotoshopBuffer2;\n\tint gotField = TIFFGetField(tif, 37724, &PhotoshopLen2, &PhotoshopBuffer2);\n\tif (gotField && (PhotoshopLen2 > 40))\n\t{\n\t\tm_imageInfoRecord.layerInfo.clear();\n\t\tQByteArray arrayPhot = QByteArray::fromRawData((const char*)PhotoshopBuffer2, PhotoshopLen2);\n\t\tQDataStream s(&arrayPhot,QIODevice::ReadOnly);\n\t\tif (byteOrder[0] == 'M')\n\t\t\ts.setByteOrder( QDataStream::BigEndian );\n\t\telse\n\t\t\ts.setByteOrder( QDataStream::LittleEndian );\n\n\t\tfailedPS = !loadLayerInfo(s, m_imageInfoRecord.layerInfo); \n\t\tif (!failedPS)\n\t\t{\n\t\t\tint chans = 4;\n\t\t\tint numChannels = m_imageInfoRecord.layerInfo.last().channelType.count();\n\t\t\tint numLayers = m_imageInfoRecord.layerInfo.count();\n\t\t\tPSDHeader fakeHeader;\n\t\t\tfakeHeader.width = widtht;\n\t\t\tfakeHeader.height = heightt;\n\t\t\tfakeHeader.channel_count = numChannels;\n\t\t\tfakeHeader.depth = 8;\n\t\t\tif (m_photometric == PHOTOMETRIC_SEPARATED)\n\t\t\t{\n\t\t\t\tisCMYK = true;\n\t\t\t\tfakeHeader.color_mode = CM_CMYK;\n\t\t\t\tchans = 5;\n\t\t\t}\n\t\t\telse if (m_samplesPerPixel == 1)\n\t\t\t{\n\t\t\t\tfakeHeader.color_mode = CM_GRAYSCALE;\n\t\t\t\tisCMYK = false;\n\t\t\t\tchans = 4;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfakeHeader.color_mode = CM_RGB;\n\t\t\t\tisCMYK = false;\n\t\t\t\tchans = 4;\n\t\t\t}\n\t\t\tif (!r_image.create(widtht, heightt, chans))\n\t\t\t\treturn false;\n\t\t\tr_image.fill(0);\n\t\t\tbool firstLayer = true;\n\t\t\tfor (int layer = 0; layer < numLayers; layer++)\n\t\t\t{\n\t\t\t\tloadLayerChannels( s, fakeHeader, m_imageInfoRecord.layerInfo, layer, &firstLayer );\n\t\t\t}\n\t\t\tarrayPhot.clear();\n\t\t\tTIFFClose(tif);\n\t\t\tfoundPS = true;\n\t\t\tif (m_imageInfoRecord.layerInfo.count() == 1)\n\t\t\t\tm_imageInfoRecord.layerInfo.clear();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tarrayPhot.clear();\n\t\t\tgetLayers(fn, page);\n\t\t}\n\t}\n\n\tif (xres <= 1.0 || yres <= 1.0)\n\t{\n\t\txres = yres = 72.0;\n\t\tQFileInfo qfi(fn);\n\t\tm_message = QObject::tr(\"%1 may be corrupted : missing resolution tags\").arg(qfi.fileName());\n\t\tm_msgType = warningMsg;\n\t}\n\tif ((!foundPS) || (failedPS))\n\t{\n\t\tint chans = 4;\n\t\tif (m_photometric == PHOTOMETRIC_SEPARATED)\n\t\t{\n\t\t\tif (m_samplesPerPixel > 5) \n\t\t\t\tchans = 4;\n\t\t\telse\n\t\t\t\tchans = m_samplesPerPixel;\n\t\t}\n\t\telse\n\t\t\tchans = 4;\n\t\tif (!r_image.create(widtht, heightt, chans))\n\t\t{\n\t\t\tTIFFClose(tif);\n\t\t\treturn false;\n\t\t}\n\t\tr_image.fill(0);\n\t\tint layerNum = 0;\n\t\tdo\n\t\t{\n\t\t\tRawImage tmpImg;\n\t\t\tif (!tmpImg.create(widtht, heightt, chans))\n\t\t\t{\n\t\t\t\tTIFFClose(tif);\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\ttmpImg.fill(0);\n\t\t\tif (!getImageData(tif, &tmpImg, widtht, heightt, size, sampleInfo, bilevel, isCMYK))\n\t\t\t{\n\t\t\t\tTIFFClose(tif);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbool visible = true;\n\t\t\tbool useMask = true;\n\t\t\tif ((m_imageInfoRecord.isRequest) && (m_imageInfoRecord.RequestProps.contains(layerNum)))\n\t\t\t\tvisible = m_imageInfoRecord.RequestProps[layerNum].visible;\n\t\t\tQString layBlend(\"norm\");\n\t\t\tif ((m_imageInfoRecord.isRequest) && (m_imageInfoRecord.RequestProps.contains(layerNum)))\n\t\t\t\tlayBlend = m_imageInfoRecord.RequestProps[layerNum].blend;\n\t\t\tif ((m_imageInfoRecord.isRequest) && (m_imageInfoRecord.RequestProps.contains(layerNum)))\n\t\t\t\tuseMask = m_imageInfoRecord.RequestProps[layerNum].useMask;\n\t\t\tint layOpa = 255;\n\t\t\tif ((m_imageInfoRecord.isRequest) && (m_imageInfoRecord.RequestProps.contains(layerNum)))\n\t\t\t\tlayOpa = m_imageInfoRecord.RequestProps[layerNum].opacity;\n\t\t\tif (visible)\n\t\t\t{\n\t\t\t\tif ((layerNum == 0) && (layBlend != \"diss\"))\n\t\t\t\t\tr_image = tmpImg;\n\t\t\t\telse\n\t\t\t\t\tblendOntoTarget(&tmpImg, layOpa, layBlend, isCMYK, useMask);\n\t\t\t}\n\t\t\t//JG Copy should not be necessary as QImage is implicitly shared in Qt4\n\t\t\tQImage imt; //QImage imt = tmpImg.copy();\n\t\t\tdouble sx = tmpImg.width() / 40.0;\n\t\t\tdouble sy = tmpImg.height() / 40.0;\n\t\t\timt = tmpImg.convertToQImage(chans > 4);\n\t\t\timt = sy < sx ?\timt.scaled(qRound(imt.width() / sx), qRound(imt.height() / sx), Qt::IgnoreAspectRatio, Qt::SmoothTransformation) :\n\t\t\t\t\t\t\t\t\t\timt.scaled(qRound(imt.width() / sy), qRound(imt.height() / sy), Qt::IgnoreAspectRatio, Qt::SmoothTransformation);\n\t\t\tm_imageInfoRecord.layerInfo[layerNum].thumb = imt.copy();\n\t\t\tif (chans > 4)\n\t\t\t{\n\t\t\t\tQImage imt2 = imt.createAlphaMask();\n\t\t\t\timt2.invertPixels();\n\t\t\t\tm_imageInfoRecord.layerInfo[layerNum].thumb_mask = imt2.copy();\n\t\t\t}\n\t\t\telse\n\t\t\t\tm_imageInfoRecord.layerInfo[layerNum].thumb_mask = QImage();\n\t\t\tlayerNum++;\n\n\t\t\tif ((m_imageInfoRecord.layerInfo.count() == 1) && (chans < 5))\n\t\t\t\tm_imageInfoRecord.layerInfo.clear();\n\t\t\ttest = TIFFReadDirectory(tif);\n\n\t\t\t// #10415 : check that image size for the current directory is the same as the main one\n\t\t\t// Some progs use tiff directory to store previews, we do not handle such case\n\t\t\t// and may perform reads in non allocated blocks if we continue\n\t\t\twhile (test == 1)\n\t\t\t{\n\t\t\t\tunsigned int dirWidth(0), dirHeight(0);\n\t\t\t\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &dirWidth);\n\t\t\t\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &dirHeight);\n\t\t\t\tif (dirWidth == widtht && dirHeight == heightt)\n\t\t\t\t\tbreak;\n\t\t\t\ttest = TIFFReadDirectory(tif);\n\t\t\t\tlayerNum++;\n\t\t\t}\n\t\t}\n\t\twhile (test == 1);\n\t\tTIFFClose(tif);\n\t}\n\tif (resolutionUnit == RESUNIT_INCH)\n\t{\n\t\tm_image.setDotsPerMeterX ((int) (xres / 0.0254));\n\t\tm_image.setDotsPerMeterY ((int) (yres / 0.0254));\n\t\tm_imageInfoRecord.xres = qRound(xres);\n\t\tm_imageInfoRecord.yres = qRound(yres);\n\t}\n\telse if (resolutionUnit == RESUNIT_CENTIMETER)\n\t{\n\t\tm_image.setDotsPerMeterX ((int) (xres * 100.0));\n\t\tm_image.setDotsPerMeterY ((int) (yres * 100.0));\n\t\tm_imageInfoRecord.xres = qRound(xres*2.54);\n\t\tm_imageInfoRecord.yres = qRound(yres*2.54);\n\t}\n\tif (isCMYK)\n\t{\n\t\tm_imageInfoRecord.colorspace = ColorSpaceCMYK;\n\t\tm_pixelFormat = (r_image.channels() == 5) ? Format_CMYKA_8 : Format_CMYK_8;\n\t}\n\telse if (m_samplesPerPixel == 1)\n\t{\n\t\t// Do not set m_pixelFormat here as the real pixel format is most probably different than gray\n\t\tif (bitsPerSample == 1)\n\t\t\tm_imageInfoRecord.colorspace = ColorSpaceMonochrome;\n\t\telse\n\t\t\tm_imageInfoRecord.colorspace = ColorSpaceGray;\n\t}\n\telse\n\t{\n\t\tm_imageInfoRecord.colorspace = ColorSpaceRGB;\n\t\tm_pixelFormat = Format_RGBA_8;\n\t}\n\tm_imageInfoRecord.BBoxX = 0;\n\tm_imageInfoRecord.BBoxH = r_image.height();\n\tm_imageInfoRecord.valid = !(m_imageInfoRecord.layerInfo.isEmpty() && m_imageInfoRecord.PDSpathData.isEmpty());\n\treturn true;\n}",
    "bool QTiffHandler::read(QImage *image)\n{\n   if (!canRead()) {\n      return false;\n   }\n\n   TIFF *const tiff = TIFFClientOpen(\"foo\",\n         \"r\",\n         this,\n         qtiffReadProc,\n         qtiffWriteProc,\n         qtiffSeekProc,\n         qtiffCloseProc,\n         qtiffSizeProc,\n         qtiffMapProc,\n         qtiffUnmapProc);\n\n   if (!tiff) {\n      return false;\n   }\n\n   uint32_t width;\n   uint32_t height;\n   uint16_t photometric;\n\n   if (!TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, &width)\n      || !TIFFGetField(tiff, TIFFTAG_IMAGELENGTH, &height)\n      || !TIFFGetField(tiff, TIFFTAG_PHOTOMETRIC, &photometric)) {\n      TIFFClose(tiff);\n      return false;\n   }\n\n   // BitsPerSample defaults to 1 according to the TIFF spec.\n   uint16_t bitPerSample;\n   if (!TIFFGetField(tiff, TIFFTAG_BITSPERSAMPLE, &bitPerSample)) {\n      bitPerSample = 1;\n   }\n\n   uint16_t samplesPerPixel; // they may be e.g. grayscale with 2 samples per pixel\n   if (!TIFFGetField(tiff, TIFFTAG_SAMPLESPERPIXEL, &samplesPerPixel)) {\n      samplesPerPixel = 1;\n   }\n\n   bool grayscale = photometric == PHOTOMETRIC_MINISBLACK || photometric == PHOTOMETRIC_MINISWHITE;\n   if (grayscale && bitPerSample == 1 && samplesPerPixel == 1) {\n      if (image->size() != QSize(width, height) || image->format() != QImage::Format_Mono) {\n         *image = QImage(width, height, QImage::Format_Mono);\n      }\n      QVector<QRgb> colortable(2);\n      if (photometric == PHOTOMETRIC_MINISBLACK) {\n         colortable[0] = 0xff000000;\n         colortable[1] = 0xffffffff;\n      } else {\n         colortable[0] = 0xffffffff;\n         colortable[1] = 0xff000000;\n      }\n      image->setColorTable(colortable);\n\n      if (!image->isNull()) {\n         for (uint32_t y = 0; y < height; ++y) {\n            if (TIFFReadScanline(tiff, image->scanLine(y), y, 0) < 0) {\n               TIFFClose(tiff);\n               return false;\n            }\n         }\n      }\n   } else {\n      if ((grayscale || photometric == PHOTOMETRIC_PALETTE) && bitPerSample == 8 && samplesPerPixel == 1) {\n         if (image->size() != QSize(width, height) || image->format() != QImage::Format_Indexed8) {\n            *image = QImage(width, height, QImage::Format_Indexed8);\n         }\n         if (!image->isNull()) {\n            const uint16_t tableSize = 256;\n            QVector<QRgb> qtColorTable(tableSize);\n\n            if (grayscale) {\n               for (int i = 0; i < tableSize; ++i) {\n                  const int c = (photometric == PHOTOMETRIC_MINISBLACK) ? i : (255 - i);\n                  qtColorTable[i] = qRgb(c, c, c);\n               }\n\n            } else {\n               // create the color table\n               uint16_t *redTable   = nullptr;\n               uint16_t *greenTable = nullptr;\n               uint16_t *blueTable  = nullptr;\n\n               if (!TIFFGetField(tiff, TIFFTAG_COLORMAP, &redTable, &greenTable, &blueTable)) {\n                  TIFFClose(tiff);\n                  return false;\n               }\n               if (!redTable || !greenTable || !blueTable) {\n                  TIFFClose(tiff);\n                  return false;\n               }\n\n               for (int i = 0; i < tableSize ; ++i) {\n                  const int red = redTable[i] / 257;\n                  const int green = greenTable[i] / 257;\n                  const int blue = blueTable[i] / 257;\n                  qtColorTable[i] = qRgb(red, green, blue);\n               }\n            }\n\n            image->setColorTable(qtColorTable);\n            for (uint32_t y = 0; y < height; ++y) {\n               if (TIFFReadScanline(tiff, image->scanLine(y), y, 0) < 0) {\n                  TIFFClose(tiff);\n                  return false;\n               }\n            }\n\n            // free redTable, greenTable and greenTable done by libtiff\n         }\n      } else {\n         if (image->size() != QSize(width, height) || image->format() != QImage::Format_ARGB32) {\n            *image = QImage(width, height, QImage::Format_ARGB32);\n         }\n         if (!image->isNull()) {\n            const int stopOnError = 1;\n            if (TIFFReadRGBAImageOriented(tiff, width, height, reinterpret_cast<uint32_t *>(image->bits()), ORIENTATION_TOPLEFT,\n                  stopOnError)) {\n               for (uint32_t y = 0; y < height; ++y) {\n                  convert32BitOrder(image->scanLine(y), width);\n               }\n            } else {\n               TIFFClose(tiff);\n               return false;\n            }\n         }\n      }\n   }\n\n   if (image->isNull()) {\n      TIFFClose(tiff);\n      return false;\n   }\n\n   float resX = 0;\n   float resY = 0;\n   uint16_t resUnit;\n\n   if (!TIFFGetField(tiff, TIFFTAG_RESOLUTIONUNIT, &resUnit)) {\n      resUnit = RESUNIT_INCH;\n   }\n\n   if (TIFFGetField(tiff, TIFFTAG_XRESOLUTION, &resX)\n      && TIFFGetField(tiff, TIFFTAG_YRESOLUTION, &resY)) {\n      switch (resUnit) {\n         case RESUNIT_CENTIMETER:\n            image->setDotsPerMeterX(qRound(resX * 100));\n            image->setDotsPerMeterY(qRound(resY * 100));\n            break;\n         case RESUNIT_INCH:\n            image->setDotsPerMeterX(qRound(resX * (100 / 2.54)));\n            image->setDotsPerMeterY(qRound(resY * (100 / 2.54)));\n            break;\n         default:\n            // do nothing as defaults have already\n            // been set within the QImage class\n            break;\n      }\n   }\n\n   // rotate the image if the orientation is defined in the file\n   uint16_t orientationTag;\n   if (TIFFGetField(tiff, TIFFTAG_ORIENTATION, &orientationTag)) {\n      if (image->format() == QImage::Format_ARGB32) {\n         // TIFFReadRGBAImageOriented() flip the image but does not rotate them\n         switch (orientationTag) {\n            case 5:\n               rotate_right_mirror_horizontal(image);\n               break;\n            case 6:\n               rotate_right_mirror_vertical(image);\n               break;\n            case 7:\n               rotate_right_mirror_horizontal(image);\n               break;\n            case 8:\n               rotate_right_mirror_vertical(image);\n               break;\n         }\n      } else {\n         switch (orientationTag) {\n            case 1: // default orientation\n               break;\n            case 2: // mirror horizontal\n               *image = image->mirrored(true, false);\n               break;\n            case 3: // mirror both\n               *image = image->mirrored(true, true);\n               break;\n            case 4: // mirror vertical\n               *image = image->mirrored(false, true);\n               break;\n            case 5: { // rotate right mirror horizontal\n               QMatrix transformation;\n               transformation.rotate(90);\n               *image = image->transformed(transformation);\n               *image = image->mirrored(true, false);\n               break;\n            }\n            case 6: { // rotate right\n               QMatrix transformation;\n               transformation.rotate(90);\n               *image = image->transformed(transformation);\n               break;\n            }\n            case 7: { // rotate right, mirror vertical\n               QMatrix transformation;\n               transformation.rotate(90);\n               *image = image->transformed(transformation);\n               *image = image->mirrored(false, true);\n               break;\n            }\n            case 8: { // rotate left\n               QMatrix transformation;\n               transformation.rotate(270);\n               *image = image->transformed(transformation);\n               break;\n            }\n         }\n      }\n   }\n\n\n   TIFFClose(tiff);\n   return true;\n}",
    "bool QTiffHandler::write(const QImage &image)\n{\n   if (!device()->isWritable()) {\n      return false;\n   }\n\n   TIFF *const tiff = TIFFClientOpen(\"foo\",\n         \"w\",\n         this,\n         qtiffReadProc,\n         qtiffWriteProc,\n         qtiffSeekProc,\n         qtiffCloseProc,\n         qtiffSizeProc,\n         qtiffMapProc,\n         qtiffUnmapProc);\n   if (!tiff) {\n      return false;\n   }\n\n   const int width = image.width();\n   const int height = image.height();\n\n   if (!TIFFSetField(tiff, TIFFTAG_IMAGEWIDTH, width)\n      || !TIFFSetField(tiff, TIFFTAG_IMAGELENGTH, height)\n      || !TIFFSetField(tiff, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG)) {\n      TIFFClose(tiff);\n      return false;\n   }\n\n   // set the resolution\n   bool  resolutionSet = false;\n   const int dotPerMeterX = image.dotsPerMeterX();\n   const int dotPerMeterY = image.dotsPerMeterY();\n   if ((dotPerMeterX % 100) == 0\n      && (dotPerMeterY % 100) == 0) {\n      resolutionSet = TIFFSetField(tiff, TIFFTAG_RESOLUTIONUNIT, RESUNIT_CENTIMETER)\n         && TIFFSetField(tiff, TIFFTAG_XRESOLUTION, dotPerMeterX / 100.0)\n         && TIFFSetField(tiff, TIFFTAG_YRESOLUTION, dotPerMeterY / 100.0);\n   } else {\n      resolutionSet = TIFFSetField(tiff, TIFFTAG_RESOLUTIONUNIT, RESUNIT_INCH)\n         && TIFFSetField(tiff, TIFFTAG_XRESOLUTION, static_cast<float>(image.logicalDpiX()))\n         && TIFFSetField(tiff, TIFFTAG_YRESOLUTION, static_cast<float>(image.logicalDpiY()));\n   }\n   if (!resolutionSet) {\n      TIFFClose(tiff);\n      return false;\n   }\n\n   // configure image depth\n   const QImage::Format format = image.format();\n   if (format == QImage::Format_Mono || format == QImage::Format_MonoLSB) {\n      uint16_t photometric = PHOTOMETRIC_MINISBLACK;\n      if (image.colorTable().at(0) == 0xffffffff) {\n         photometric = PHOTOMETRIC_MINISWHITE;\n      }\n      if (!TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, photometric)\n         || !TIFFSetField(tiff, TIFFTAG_COMPRESSION, compression == NoCompression ? COMPRESSION_NONE : COMPRESSION_CCITTRLE)\n         || !TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 1)) {\n         TIFFClose(tiff);\n         return false;\n      }\n\n      // try to do the conversion in chunks no greater than 16 MB\n      int chunks = (width * height / (1024 * 1024 * 16)) + 1;\n      int chunkHeight = qMax(height / chunks, 1);\n\n      int y = 0;\n      while (y < height) {\n         QImage chunk = image.copy(0, y, width, qMin(chunkHeight, height - y)).convertToFormat(QImage::Format_Mono);\n\n         int chunkStart = y;\n         int chunkEnd = y + chunk.height();\n         while (y < chunkEnd) {\n            if (TIFFWriteScanline(tiff, reinterpret_cast<uint32_t *>(chunk.scanLine(y - chunkStart)), y) != 1) {\n               TIFFClose(tiff);\n               return false;\n            }\n            ++y;\n         }\n      }\n      TIFFClose(tiff);\n   } else if (format == QImage::Format_Indexed8) {\n      const QVector<QRgb> colorTable = image.colorTable();\n      bool isGrayscale = checkGrayscale(colorTable);\n      if (isGrayscale) {\n         uint16_t photometric = PHOTOMETRIC_MINISBLACK;\n         if (image.colorTable().at(0) == 0xffffffff) {\n            photometric = PHOTOMETRIC_MINISWHITE;\n         }\n         if (!TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, photometric)\n            || !TIFFSetField(tiff, TIFFTAG_COMPRESSION, compression == NoCompression ? COMPRESSION_NONE : COMPRESSION_PACKBITS)\n            || !TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 8)) {\n            TIFFClose(tiff);\n            return false;\n         }\n      } else {\n         if (!TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_PALETTE)\n            || !TIFFSetField(tiff, TIFFTAG_COMPRESSION, compression == NoCompression ? COMPRESSION_NONE : COMPRESSION_PACKBITS)\n            || !TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 8)) {\n            TIFFClose(tiff);\n            return false;\n         }\n         //// write the color table\n         // allocate the color tables\n         uint16_t *redTable   = static_cast<uint16_t *>(malloc(256 * sizeof(uint16_t)));\n         uint16_t *greenTable = static_cast<uint16_t *>(malloc(256 * sizeof(uint16_t)));\n         uint16_t *blueTable  = static_cast<uint16_t *>(malloc(256 * sizeof(uint16_t)));\n\n         if (!redTable || !greenTable || !blueTable) {\n            free(redTable);\n            free(greenTable);\n            free(blueTable);\n            TIFFClose(tiff);\n            return false;\n         }\n\n         // set the color table\n         const int tableSize = colorTable.size();\n         Q_ASSERT(tableSize <= 256);\n         for (int i = 0; i < tableSize; ++i) {\n            const QRgb color = colorTable.at(i);\n            redTable[i] = qRed(color) * 257;\n            greenTable[i] = qGreen(color) * 257;\n            blueTable[i] = qBlue(color) * 257;\n         }\n\n         const bool setColorTableSuccess = TIFFSetField(tiff, TIFFTAG_COLORMAP, redTable, greenTable, blueTable);\n\n         free(redTable);\n         free(greenTable);\n         free(blueTable);\n\n         if (!setColorTableSuccess) {\n            TIFFClose(tiff);\n            return false;\n         }\n      }\n\n      //// write the data\n      // try to do the conversion in chunks no greater than 16 MB\n      int chunks = (width * height / (1024 * 1024 * 16)) + 1;\n      int chunkHeight = qMax(height / chunks, 1);\n\n      int y = 0;\n      while (y < height) {\n         QImage chunk = image.copy(0, y, width, qMin(chunkHeight, height - y));\n\n         int chunkStart = y;\n         int chunkEnd = y + chunk.height();\n         while (y < chunkEnd) {\n            if (TIFFWriteScanline(tiff, reinterpret_cast<uint32_t *>(chunk.scanLine(y - chunkStart)), y) != 1) {\n               TIFFClose(tiff);\n               return false;\n            }\n            ++y;\n         }\n      }\n      TIFFClose(tiff);\n\n   } else {\n      if (!TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB)\n         || !TIFFSetField(tiff, TIFFTAG_COMPRESSION, compression == NoCompression ? COMPRESSION_NONE : COMPRESSION_LZW)\n         || !TIFFSetField(tiff, TIFFTAG_SAMPLESPERPIXEL, 4)\n         || !TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 8)) {\n         TIFFClose(tiff);\n         return false;\n      }\n      // try to do the ARGB32 conversion in chunks no greater than 16 MB\n      int chunks = (width * height * 4 / (1024 * 1024 * 16)) + 1;\n      int chunkHeight = qMax(height / chunks, 1);\n\n      int y = 0;\n      while (y < height) {\n         QImage chunk = image.copy(0, y, width, qMin(chunkHeight, height - y)).convertToFormat(QImage::Format_ARGB32);\n\n         int chunkStart = y;\n         int chunkEnd = y + chunk.height();\n\n         while (y < chunkEnd) {\n            if constexpr (QSysInfo::ByteOrder == QSysInfo::LittleEndian) {\n               convert32BitOrder(chunk.scanLine(y - chunkStart), width);\n            } else {\n               convert32BitOrderBigEndian(chunk.scanLine(y - chunkStart), width);\n            }\n\n            if (TIFFWriteScanline(tiff, reinterpret_cast<uint32_t *>(chunk.scanLine(y - chunkStart)), y) != 1) {\n               TIFFClose(tiff);\n               return false;\n            }\n            ++y;\n         }\n      }\n      TIFFClose(tiff);\n   }\n\n   return true;\n}",
    "QVariant QTiffHandler::option(ImageOption option)\n{\n   if (option == Size && canRead()) {\n      QSize imageSize;\n      qint64 pos = device()->pos();\n      TIFF *tiff = TIFFClientOpen(\"foo\",\n            \"r\",\n            const_cast<QTiffHandler *>(this),\n            qtiffReadProc,\n            qtiffWriteProc,\n            qtiffSeekProc,\n            qtiffCloseProc,\n            qtiffSizeProc,\n            qtiffMapProc,\n            qtiffUnmapProc);\n\n      if (tiff) {\n         uint32_t width = 0;\n         uint32_t height = 0;\n         TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, &width);\n         TIFFGetField(tiff, TIFFTAG_IMAGELENGTH, &height);\n         imageSize = QSize(width, height);\n         TIFFClose(tiff);\n      }\n\n      device()->seek(pos);\n      if (imageSize.isValid()) {\n         return imageSize;\n      }\n\n   } else if (option == CompressionRatio) {\n      return compression;\n   } else if (option == ImageFormat) {\n      return QImage::Format_ARGB32;\n   }\n\n   return QVariant();\n}",
    "WriteResult::WriteStatus writeTIFStream(std::ostream& fout, const osg::Image& img, const osgDB::ReaderWriter::Options* options) const\n        {\n            int compressionType = COMPRESSION_PACKBITS;\n            if (options) {\n                std::istringstream iss(options->getOptionString());\n                std::string opt;\n                while (iss >> opt) {\n                    opt = osgDB::convertToLowerCase(opt);\n\n                    std::size_t eqInd = opt.find(\"=\");\n                    if (opt.substr(0, eqInd) == \"tiff_compression\") {\n                        std::string compressTypeOpt;\n                        compressTypeOpt = opt.substr(eqInd + 1);\n                        compressTypeOpt = osgDB::convertToLowerCase(compressTypeOpt);\n                        if (compressTypeOpt == \"packbits\") {\n                            compressionType = COMPRESSION_PACKBITS;\n                        }\n                        else if (compressTypeOpt == \"lzw\") {\n                            compressionType = COMPRESSION_LZW;\n                        }\n                        else if (compressTypeOpt == \"jpeg\") {\n                            compressionType = COMPRESSION_JPEG;\n                        }\n                    }\n                }\n            }\n\n\n            //Code is based from the following article on CodeProject.com\n            //http://www.codeproject.com/bitmap/BitmapsToTiffs.asp\n\n            TIFF *image;\n            int samplesPerPixel;\n            int bitsPerSample;\n            uint16 photometric;\n\n            image = TIFFClientOpen(\"outputstream\", \"w\", (thandle_t)&fout,\n                                    libtiffOStreamReadProc, //Custom read function\n                                    libtiffOStreamWriteProc, //Custom write function\n                                    libtiffOStreamSeekProc, //Custom seek function\n                                    libtiffStreamCloseProc, //Custom close function\n                                    libtiffOStreamSizeProc, //Custom size function\n                                    libtiffStreamMapProc, //Custom map function\n                                    libtiffStreamUnmapProc); //Custom unmap function\n\n            if(image == NULL)\n            {\n                return WriteResult::ERROR_IN_WRITING_FILE;\n            }\n\n            switch(img.getPixelFormat()) {\n                case GL_DEPTH_COMPONENT:\n                case GL_LUMINANCE:\n                case GL_ALPHA:\n                    photometric = PHOTOMETRIC_MINISBLACK;\n                    samplesPerPixel = 1;\n                    break;\n                case GL_LUMINANCE_ALPHA:\n                    photometric = PHOTOMETRIC_MINISBLACK;\n                    samplesPerPixel = 2;\n                    break;\n                case GL_RGB:\n                    photometric = PHOTOMETRIC_RGB;\n                    samplesPerPixel = 3;\n                    break;\n                case GL_RGBA:\n                    photometric = PHOTOMETRIC_RGB;\n                    samplesPerPixel = 4;\n                    break;\n                default:\n                    return WriteResult::ERROR_IN_WRITING_FILE;\n                    break;\n            }\n\n            switch(img.getDataType()){\n                case GL_FLOAT:\n                    TIFFSetField(image, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);\n                    TIFFSetField(image, TIFFTAG_ROWSPERSTRIP, 1);\n                    bitsPerSample = 32;\n                    break;\n                case GL_SHORT:\n                    TIFFSetField(image, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_INT);\n                    bitsPerSample = 16;\n                    break;\n                default:\n                    bitsPerSample = 8;\n                    break;\n            }\n\n            TIFFSetField(image, TIFFTAG_IMAGEWIDTH,img.s());\n            TIFFSetField(image, TIFFTAG_IMAGELENGTH,img.t());\n            TIFFSetField(image, TIFFTAG_BITSPERSAMPLE,bitsPerSample);\n            TIFFSetField(image, TIFFTAG_SAMPLESPERPIXEL,samplesPerPixel);\n            TIFFSetField(image, TIFFTAG_PHOTOMETRIC, photometric);\n            TIFFSetField(image, TIFFTAG_COMPRESSION, compressionType);\n            TIFFSetField(image, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);\n            TIFFSetField(image, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\n            //uint32 rowsperstrip = TIFFDefaultStripSize(image, -1);\n            //TIFFSetField(image, TIFFTAG_ROWSPERSTRIP, rowsperstrip);\n\n            // Write the information to the file\n            for(int i = 0; i < img.t(); ++i) {\n                TIFFWriteScanline(image,(tdata_t)img.data(0,img.t()-i-1),i,0);\n            }\n\n            // Close the file\n            TIFFClose(image);\n\n            return WriteResult::FILE_SAVED;\n        }",
    "TiffReader::Context::~Context() {\n  if (tiff_ != nullptr) {\n    TIFFClose(tiff_);\n  }\n}",
    "TiffWriter::Context::~Context() {\n  if (tiff_ != nullptr) {\n    TIFFFlush(tiff_);\n    TIFFClose(tiff_);\n  }\n}",
    "absl::Status TiffWriter::Context::Close() {\n  if (tiff_ != nullptr) {\n    TIFFFlush(tiff_);\n    TIFFClose(tiff_);\n    tiff_ = nullptr;\n  }\n  if (!writer_->Close()) {\n    return writer_->status();\n  }\n  return ExtractErrors();\n}",
    "void writetiff(char *filename, char *description,\n               int x, int y, int width, int height, int compression)\n{\n    TIFF *file;\n    GLubyte *image = NULL, *p;\n    int i;\n\n    file = TIFFOpen(filename, \"w\");\n    if (file == NULL)\n    {\n        exit(ANIM_ERROR);\n    }\n    /*pe image = (GLubyte *) malloc(width * height * sizeof(GLubyte) * 3); */\n    OWN_CALLOC(image, GLubyte, width * height * 3);\n\n    /* OpenGL's default 4 byte pack alignment would leave extra bytes at the\n     end of each image row so that each full row contained a number of bytes\n     divisible by 4.  Ie, an RGB row with 3 pixels and 8-bit componets would\n     be laid out like \"RGBRGBRGBxxx\" where the last three \"xxx\" bytes exist\n     just to pad the row out to 12 bytes (12 is divisible by 4). To make sure\n     the rows are packed as tight as possible (no row padding), set the pack\n     alignment to 1. */\n    glPixelStorei(GL_PACK_ALIGNMENT, 1);\n\n    glReadPixels(x, y, width, height, GL_RGB, GL_UNSIGNED_BYTE, image);\n    TIFFSetField(file, TIFFTAG_IMAGEWIDTH, (uint32)width);\n    TIFFSetField(file, TIFFTAG_IMAGELENGTH, (uint32)height);\n    TIFFSetField(file, TIFFTAG_BITSPERSAMPLE, 8);\n    TIFFSetField(file, TIFFTAG_COMPRESSION, compression);\n    TIFFSetField(file, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n    TIFFSetField(file, TIFFTAG_SAMPLESPERPIXEL, 3);\n    TIFFSetField(file, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    TIFFSetField(file, TIFFTAG_ROWSPERSTRIP, 1);\n    TIFFSetField(file, TIFFTAG_IMAGEDESCRIPTION, description);\n    p = image;\n    for (i = height - 1; i >= 0; i--)\n    {\n        if (TIFFWriteScanline(file, p, i, 0) < 0)\n        {\n            OWN_FREE(image);\n            TIFFClose(file);\n            exit(ANIM_ERROR);\n        }\n        p += width * sizeof(GLubyte) * 3;\n    }\n    TIFFClose(file);\n    OWN_FREE(image);\n}",
    "unsigned char *tifread(const char *filename, int *w, int *h, int *nc)\n{\n    TIFF *tif = TIFFOpen(filename, \"r\");\n    if (tif)\n    {\n        int samples = 4;\n        TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, w);\n        TIFFGetField(tif, TIFFTAG_IMAGELENGTH, h);\n        TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &samples);\n        size_t npixels = *w * *h;\n        uint32 *raster = (uint32 *)malloc(npixels * sizeof(uint32));\n        if (raster != NULL)\n        {\n            if (TIFFReadRGBAImage(tif, *w, *h, raster, 0))\n            {\n                *nc = 4;\n\n                unsigned char *raster2 = (unsigned char *)malloc(npixels * sizeof(uint32));\n                unsigned char *image = (unsigned char *)raster;\n                size_t widthbytes = *w * sizeof(uint32);\n                for (int i = 0; i < *h; i++)\n                {\n                    memcpy(raster2 + (npixels * sizeof(uint32)) - ((i + 1) * widthbytes), image + (i * widthbytes), widthbytes);\n                }\n                free(raster);\n                return (unsigned char *)raster2;\n            }\n            free(raster);\n        }\n        TIFFClose(tif);\n    }\n    return NULL;\n}",
    "float\nLogo::changeFileName()\n{\n    // open file\n    bild_ = TIFFOpen(p_file_->getValue(), \"r\");\n    if (bild_ == NULL)\n    {\n        sendError(\"Could not open file.\");\n        return -1.0;\n    }\n    // read width in pixels\n    if (TIFFGetField(bild_, TIFFTAG_IMAGEWIDTH, &w_) != 1)\n    {\n        sendError(\"Could not allocate memory for raster_.\");\n        TIFFClose(bild_);\n        bild_ = NULL;\n        return -1.0;\n    }\n    // read height in pixels\n    if (TIFFGetField(bild_, TIFFTAG_IMAGELENGTH, &h_) != 1)\n    {\n        sendError(\"Could not read image.\");\n        TIFFClose(bild_);\n        bild_ = NULL;\n        return -1.0;\n    }\n    // @@@ problems with segmented memory (Windows...)\n    delete[] raster_;\n    raster_ = new uint32[w_ * h_];\n\n    if (raster_ == NULL)\n    {\n        sendError(\"Could not allocate memory for raster_.\");\n        TIFFClose(bild_);\n        bild_ = NULL;\n        return -1.0;\n    }\n    // read image content\n    if (TIFFReadRGBAImage(bild_, w_, h_, raster_, 0) != 1)\n    {\n        sendError(\"Could not read TIFF image.\");\n        TIFFClose(bild_);\n        delete[] raster_; // @@@ problems with segmented memory (Windows...)\n        bild_ = NULL;\n        raster_ = NULL;\n        return -1.0;\n    }\n\n    float XResolution, YResolution;\n    if (TIFFGetField(bild_, TIFFTAG_XRESOLUTION, &XResolution) != 1)\n    {\n        sendError(\"Could not read X Resolution.\");\n        return -1.0;\n    }\n    else if (TIFFGetField(bild_, TIFFTAG_YRESOLUTION, &YResolution) != 1)\n    {\n        sendInfo(\"Could not read Y Resolution. Assuming the same value as for the X dimension.\");\n        YResolution = XResolution;\n    }\n    TIFFClose(bild_);\n    bild_ = NULL;\n\n    float Width, Height;\n    Width = w_ / XResolution;\n    Height = h_ / YResolution;\n\n    if (p_size_->getValue() <= 0.0)\n    {\n        sendError(\"A positive value is expected in SizeX\");\n        return -1.0;\n    }\n\n    return p_size_->getValue() * Height / Width;\n}",
    "void\nImageToTexture::changeFileName()\n{\n    changeFileNameFailed_ = true;\n    // assume physical-soze image dimension is available in file\n    mode_ = TextureMapping::NONE;\n    // open file\n    bild_ = TIFFOpen(FileName_.c_str(), \"r\");\n\n    if (bild_ == NULL)\n    {\n        sendWarning(\"Could not open file.\");\n        return;\n    }\n\n    // read width in pixels\n    if (TIFFGetField(bild_, TIFFTAG_IMAGEWIDTH, &w_) != 1)\n    {\n        sendWarning(\"Could not allocate memory for raster_.\");\n        TIFFClose(bild_);\n        bild_ = NULL;\n        return;\n    }\n    // read height in pixels\n    if (TIFFGetField(bild_, TIFFTAG_IMAGELENGTH, &h_) != 1)\n    {\n        sendWarning(\"Could not read image.\");\n        TIFFClose(bild_);\n        bild_ = NULL;\n        return;\n    }\n\n    // @@@ problems with segmented memory (Windows...)\n    delete[] raster_;\n    raster_ = new uint32[w_ * h_];\n\n    if (raster_ == NULL)\n    {\n        sendWarning(\"Could not allocate memory for raster_.\");\n        TIFFClose(bild_);\n        bild_ = NULL;\n        return;\n    }\n    // read image content\n    if (TIFFReadRGBAImage(bild_, w_, h_, raster_, 0) != 1)\n    {\n        sendWarning(\"Could not read TIFF file.\");\n        TIFFClose(bild_);\n        delete[] raster_; // @@@\n        bild_ = NULL;\n        raster_ = NULL;\n        return;\n    }\n    // Calculate image dimensions from the file (if possible)\n    // first of all get resolution unit\n    XResolution_ = 0.0, YResolution_ = 0.0;\n    if (TIFFGetField(bild_, TIFFTAG_RESOLUTIONUNIT, &resUnit_) != 1\n        || resUnit_ == RESUNIT_NONE)\n    {\n        sendInfo(\"The image has no resolution unit. Please, set physical image dimensions manually\");\n        mode_ = TextureMapping::MANUAL;\n    }\n    else // we have resolution unit\n    {\n        if (TIFFGetField(bild_, TIFFTAG_XRESOLUTION, &XResolution_) != 1)\n        {\n            sendInfo(\"Could not read X Resolution. Please, set physical image dimension manually\");\n            mode_ = TextureMapping::MANUAL;\n        }\n        else if (TIFFGetField(bild_, TIFFTAG_YRESOLUTION, &YResolution_) != 1)\n        {\n            sendInfo(\"Could not read Y Resolution. Assuming the same value as for the X dimension. You may always control the behaviour manually\");\n            YResolution_ = XResolution_;\n            mode_ = TextureMapping::AUTOMATIC;\n        }\n        else\n        {\n            sendInfo(\"A valid image size has been read from file\");\n            mode_ = TextureMapping::AUTOMATIC;\n        }\n        if (mode_ == TextureMapping::AUTOMATIC) // give the user a hint\n        {\n            float Width, Height;\n            Width = w_ / XResolution_;\n            Height = h_ / YResolution_;\n            if (resUnit_ == RESUNIT_INCH)\n            {\n                Width *= 2.54f;\n                Height *= 2.54f;\n            }\n            sendInfo(\"Image size according to file information: width, %f; height, %f (cm)\", Width, Height);\n        }\n    }\n    TIFFClose(bild_);\n    bild_ = NULL;\n    changeFileNameFailed_ = false;\n    // transform RGBA format from raster_ to image_\n    return;\n}",
    "TIFFHeader getTIFFHeader(const std::filesystem::path& filename) {\n#ifdef cimg_use_tiff\n    TIFF* tif = TIFFOpen(filename.string().c_str(), \"r\");\n    util::OnScopeExit closeFile([tif]() {\n        if (tif) TIFFClose(tif);\n    });\n\n    if (!tif) {\n        throw DataReaderException(SourceContext{}, \"Error could not open input file: {}\", filename);\n    }\n    TIFFSetDirectory(tif, 0);\n\n    std::uint16_t samplesPerPixel = 1, bitsPerSample = 8, sampleFormat = 1;\n    if (!TIFFGetFieldDefaulted(tif, TIFFTAG_BITSPERSAMPLE, &bitsPerSample)) {\n        bitsPerSample = 8;\n    }\n    if (!TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLESPERPIXEL, &samplesPerPixel)) {\n        samplesPerPixel = 1;\n    }\n    if (!TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLEFORMAT, &sampleFormat)) {\n        sampleFormat = 1;\n    }\n\n    float xres = 1.0f;\n    float yres = 1.0f;\n    // X and Y resolution tags are stored as float\n    if (!TIFFGetFieldDefaulted(tif, TIFFTAG_XRESOLUTION, &xres)) {\n        xres = 1.0f;\n    }\n    if (!TIFFGetFieldDefaulted(tif, TIFFTAG_YRESOLUTION, &yres)) {\n        yres = 1.0f;\n    }\n    const dvec2 res{xres, yres};\n\n    std::uint16_t resUnit = 2;\n    if (!TIFFGetFieldDefaulted(tif, TIFFTAG_RESOLUTIONUNIT, &resUnit)) {\n        resUnit = 2;\n    }\n    const TIFFResolutionUnit resolutionUnit = static_cast<TIFFResolutionUnit>(resUnit);\n\n    std::uint32_t x = 0, y = 0, z = 0;\n    TIFFGetFieldDefaulted(tif, TIFFTAG_IMAGEWIDTH, &x);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_IMAGELENGTH, &y);\n    // count the images\n    do {\n        ++z;\n    } while (TIFFReadDirectory(tif));\n\n    NumericType numericType;\n    switch (sampleFormat) {\n        case SAMPLEFORMAT_UINT:\n            numericType = NumericType::UnsignedInteger;\n            break;\n        case SAMPLEFORMAT_INT:\n            numericType = NumericType::SignedInteger;\n            break;\n        case SAMPLEFORMAT_IEEEFP:\n            numericType = NumericType::Float;\n            break;\n        case SAMPLEFORMAT_COMPLEXIEEEFP:\n            [[fallthrough]];\n        case SAMPLEFORMAT_COMPLEXINT:\n            throw DataReaderException(\"Unsupported TIFF format\");\n            break;\n        default:\n            numericType = NumericType::UnsignedInteger;\n            break;\n    }\n\n    SwizzleMask swizzleMask;\n    if (samplesPerPixel == 1) {\n        swizzleMask = swizzlemasks::luminance;\n    } else if (samplesPerPixel == 2) {\n        swizzleMask = swizzlemasks::luminanceAlpha;\n    } else if (samplesPerPixel == 3) {\n        swizzleMask = swizzlemasks::rgb;\n    } else if (samplesPerPixel == 4) {\n        swizzleMask = swizzlemasks::rgba;\n    } else {\n        throw DataReaderException(\"Unsupported TIFF format with more than 4 channels\");\n    }\n\n    auto df = DataFormatBase::get(numericType, samplesPerPixel, bitsPerSample);\n\n    return {df, size3_t{x, y, z}, res, resolutionUnit, swizzleMask};\n#else\n    throw Exception(\"TIFF not available\");\n    return {};\n#endif\n}",
    "void QTiffHandlerPrivate::close()\n{\n    if (tiff)\n        TIFFClose(tiff);\n    tiff = 0;\n}",
    "bool QTiffHandler::write(const QImage &image)\n{\n    if (!device()->isWritable())\n        return false;\n\n    TIFF *const tiff = TIFFClientOpen(\"foo\",\n                                      \"wB\",\n                                      device(),\n                                      qtiffReadProc,\n                                      qtiffWriteProc,\n                                      qtiffSeekProc,\n                                      qtiffCloseProc,\n                                      qtiffSizeProc,\n                                      qtiffMapProc,\n                                      qtiffUnmapProc);\n    if (!tiff)\n        return false;\n\n    const int width = image.width();\n    const int height = image.height();\n    const int compression = d->compression;\n\n    if (!TIFFSetField(tiff, TIFFTAG_IMAGEWIDTH, width)\n        || !TIFFSetField(tiff, TIFFTAG_IMAGELENGTH, height)\n        || !TIFFSetField(tiff, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG)) {\n        TIFFClose(tiff);\n        return false;\n    }\n\n    // set the resolution\n    bool  resolutionSet = false;\n    const int dotPerMeterX = image.dotsPerMeterX();\n    const int dotPerMeterY = image.dotsPerMeterY();\n    if ((dotPerMeterX % 100) == 0\n        && (dotPerMeterY % 100) == 0) {\n        resolutionSet = TIFFSetField(tiff, TIFFTAG_RESOLUTIONUNIT, RESUNIT_CENTIMETER)\n                        && TIFFSetField(tiff, TIFFTAG_XRESOLUTION, dotPerMeterX/100.0)\n                        && TIFFSetField(tiff, TIFFTAG_YRESOLUTION, dotPerMeterY/100.0);\n    } else {\n        resolutionSet = TIFFSetField(tiff, TIFFTAG_RESOLUTIONUNIT, RESUNIT_INCH)\n                        && TIFFSetField(tiff, TIFFTAG_XRESOLUTION, static_cast<float>(image.logicalDpiX()))\n                        && TIFFSetField(tiff, TIFFTAG_YRESOLUTION, static_cast<float>(image.logicalDpiY()));\n    }\n    if (!resolutionSet) {\n        TIFFClose(tiff);\n        return false;\n    }\n    // set the orienataion\n    bool orientationSet = false;\n    orientationSet = TIFFSetField(tiff, TIFFTAG_ORIENTATION, qt2Exif(d->transformation));\n    if (!orientationSet) {\n        TIFFClose(tiff);\n        return false;\n    }\n\n    // configure image depth\n    const QImage::Format format = image.format();\n    if (format == QImage::Format_Mono || format == QImage::Format_MonoLSB) {\n        uint16 photometric = PHOTOMETRIC_MINISBLACK;\n        if (image.colorTable().at(0) == 0xffffffff)\n            photometric = PHOTOMETRIC_MINISWHITE;\n        if (!TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, photometric)\n            || !TIFFSetField(tiff, TIFFTAG_COMPRESSION, compression == NoCompression ? COMPRESSION_NONE : COMPRESSION_CCITTRLE)\n            || !TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 1)) {\n            TIFFClose(tiff);\n            return false;\n        }\n\n        // try to do the conversion in chunks no greater than 16 MB\n        int chunks = (width * height / (1024 * 1024 * 16)) + 1;\n        int chunkHeight = qMax(height / chunks, 1);\n\n        int y = 0;\n        while (y < height) {\n            QImage chunk = image.copy(0, y, width, qMin(chunkHeight, height - y)).convertToFormat(QImage::Format_Mono);\n\n            int chunkStart = y;\n            int chunkEnd = y + chunk.height();\n            while (y < chunkEnd) {\n                if (TIFFWriteScanline(tiff, reinterpret_cast<uint32 *>(chunk.scanLine(y - chunkStart)), y) != 1) {\n                    TIFFClose(tiff);\n                    return false;\n                }\n                ++y;\n            }\n        }\n        TIFFClose(tiff);\n    } else if (format == QImage::Format_Indexed8\n               || format == QImage::Format_Grayscale8\n               || format == QImage::Format_Alpha8) {\n        QVector<QRgb> colorTable = effectiveColorTable(image);\n        bool isGrayscale = checkGrayscale(colorTable);\n        if (isGrayscale) {\n            uint16 photometric = PHOTOMETRIC_MINISBLACK;\n            if (colorTable.at(0) == 0xffffffff)\n                photometric = PHOTOMETRIC_MINISWHITE;\n            if (!TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, photometric)\n                    || !TIFFSetField(tiff, TIFFTAG_COMPRESSION, compression == NoCompression ? COMPRESSION_NONE : COMPRESSION_PACKBITS)\n                    || !TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 8)) {\n                TIFFClose(tiff);\n                return false;\n            }\n        } else {\n            if (!TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_PALETTE)\n                    || !TIFFSetField(tiff, TIFFTAG_COMPRESSION, compression == NoCompression ? COMPRESSION_NONE : COMPRESSION_PACKBITS)\n                    || !TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 8)) {\n                TIFFClose(tiff);\n                return false;\n            }\n            //// write the color table\n            // allocate the color tables\n            const int tableSize = colorTable.size();\n            Q_ASSERT(tableSize <= 256);\n            QVarLengthArray<uint16> redTable(tableSize);\n            QVarLengthArray<uint16> greenTable(tableSize);\n            QVarLengthArray<uint16> blueTable(tableSize);\n\n            // set the color table\n            for (int i = 0; i<tableSize; ++i) {\n                const QRgb color = colorTable.at(i);\n                redTable[i] = qRed(color) * 257;\n                greenTable[i] = qGreen(color) * 257;\n                blueTable[i] = qBlue(color) * 257;\n            }\n\n            const bool setColorTableSuccess = TIFFSetField(tiff, TIFFTAG_COLORMAP, redTable.data(), greenTable.data(), blueTable.data());\n\n            if (!setColorTableSuccess) {\n                TIFFClose(tiff);\n                return false;\n            }\n        }\n\n        //// write the data\n        // try to do the conversion in chunks no greater than 16 MB\n        int chunks = (width * height/ (1024 * 1024 * 16)) + 1;\n        int chunkHeight = qMax(height / chunks, 1);\n\n        int y = 0;\n        while (y < height) {\n            QImage chunk = image.copy(0, y, width, qMin(chunkHeight, height - y));\n\n            int chunkStart = y;\n            int chunkEnd = y + chunk.height();\n            while (y < chunkEnd) {\n                if (TIFFWriteScanline(tiff, reinterpret_cast<uint32 *>(chunk.scanLine(y - chunkStart)), y) != 1) {\n                    TIFFClose(tiff);\n                    return false;\n                }\n                ++y;\n            }\n        }\n        TIFFClose(tiff);\n    } else if (!image.hasAlphaChannel()) {\n        if (!TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB)\n            || !TIFFSetField(tiff, TIFFTAG_COMPRESSION, compression == NoCompression ? COMPRESSION_NONE : COMPRESSION_LZW)\n            || !TIFFSetField(tiff, TIFFTAG_SAMPLESPERPIXEL, 3)\n            || !TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 8)) {\n            TIFFClose(tiff);\n            return false;\n        }\n        // try to do the RGB888 conversion in chunks no greater than 16 MB\n        const int chunks = (width * height * 3 / (1024 * 1024 * 16)) + 1;\n        const int chunkHeight = qMax(height / chunks, 1);\n\n        int y = 0;\n        while (y < height) {\n            const QImage chunk = image.copy(0, y, width, qMin(chunkHeight, height - y)).convertToFormat(QImage::Format_RGB888);\n\n            int chunkStart = y;\n            int chunkEnd = y + chunk.height();\n            while (y < chunkEnd) {\n                if (TIFFWriteScanline(tiff, (void*)chunk.scanLine(y - chunkStart), y) != 1) {\n                    TIFFClose(tiff);\n                    return false;\n                }\n                ++y;\n            }\n        }\n        TIFFClose(tiff);\n    } else {\n        const bool premultiplied = image.format() != QImage::Format_ARGB32\n                                && image.format() != QImage::Format_RGBA8888;\n        const uint16 extrasamples = premultiplied ? EXTRASAMPLE_ASSOCALPHA : EXTRASAMPLE_UNASSALPHA;\n        if (!TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB)\n            || !TIFFSetField(tiff, TIFFTAG_COMPRESSION, compression == NoCompression ? COMPRESSION_NONE : COMPRESSION_LZW)\n            || !TIFFSetField(tiff, TIFFTAG_SAMPLESPERPIXEL, 4)\n            || !TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 8)\n            || !TIFFSetField(tiff, TIFFTAG_EXTRASAMPLES, 1, &extrasamples)) {\n            TIFFClose(tiff);\n            return false;\n        }\n        // try to do the RGBA8888 conversion in chunks no greater than 16 MB\n        const int chunks = (width * height * 4 / (1024 * 1024 * 16)) + 1;\n        const int chunkHeight = qMax(height / chunks, 1);\n\n        const QImage::Format format = premultiplied ? QImage::Format_RGBA8888_Premultiplied\n                                                    : QImage::Format_RGBA8888;\n        int y = 0;\n        while (y < height) {\n            const QImage chunk = image.copy(0, y, width, qMin(chunkHeight, height - y)).convertToFormat(format);\n\n            int chunkStart = y;\n            int chunkEnd = y + chunk.height();\n            while (y < chunkEnd) {\n                if (TIFFWriteScanline(tiff, (void*)chunk.scanLine(y - chunkStart), y) != 1) {\n                    TIFFClose(tiff);\n                    return false;\n                }\n                ++y;\n            }\n        }\n        TIFFClose(tiff);\n    }\n\n    return true;\n}",
    "~tiff_file()\n    {\n        TIFFClose(tiff_);\n    }",
    "void TIFF::close()\n{\n    if (tiff_client_)\n    {\n        TIFFClose(tiff_client_);\n        tiff_client_ = nullptr;\n    }\n    if (metadata_)\n    {\n        delete reinterpret_cast<json*>(metadata_);\n        metadata_ = nullptr;\n    }\n}",
    "void tiffDecode(PointerRange<const char> inBuffer, ImageImpl *impl)\n\t{\n\t\tTIFF *t = nullptr;\n\t\ttry\n\t\t{\n\t\t\tBufferIStream stream(inBuffer);\n\t\t\tt = TIFFStreamOpen(\"MemTIFF\", &stream);\n\t\t\tif (!t)\n\t\t\t\tCAGE_THROW_ERROR(Exception, \"failed to initialize tiff decoding\");\n\t\t\t{\n\t\t\t\tuint16 planarconfig = 0;\n\t\t\t\tTIFFGetField(t, TIFFTAG_PLANARCONFIG, &planarconfig);\n\t\t\t\tif (planarconfig != PLANARCONFIG_CONTIG)\n\t\t\t\t\tCAGE_THROW_ERROR(Exception, \"unsupported planar configuration in tiff decoding\");\n\t\t\t}\n\t\t\tTIFFGetField(t, TIFFTAG_IMAGEWIDTH, &impl->width);\n\t\t\tTIFFGetField(t, TIFFTAG_IMAGELENGTH, &impl->height);\n\t\t\t{\n\t\t\t\tuint16 ch = 0;\n\t\t\t\tTIFFGetField(t, TIFFTAG_SAMPLESPERPIXEL, &ch);\n\t\t\t\timpl->channels = ch;\n\t\t\t}\n\t\t\t{\n\t\t\t\tuint16 bpp = 0;\n\t\t\t\tTIFFGetField(t, TIFFTAG_BITSPERSAMPLE, &bpp);\n\t\t\t\tuint16 sampleformat = 0;\n\t\t\t\tTIFFGetField(t, TIFFTAG_SAMPLEFORMAT, &sampleformat);\n\t\t\t\tif (sampleformat == 0)\n\t\t\t\t\tsampleformat = SAMPLEFORMAT_UINT;\n\t\t\t\tif (bpp == 8 && sampleformat == SAMPLEFORMAT_UINT)\n\t\t\t\t\timpl->format = ImageFormatEnum::U8;\n\t\t\t\telse if (bpp == 16 && sampleformat == SAMPLEFORMAT_UINT)\n\t\t\t\t\timpl->format = ImageFormatEnum::U16;\n\t\t\t\telse if (bpp == 32 && sampleformat == SAMPLEFORMAT_IEEEFP)\n\t\t\t\t\timpl->format = ImageFormatEnum::Float;\n\t\t\t\telse\n\t\t\t\t\tCAGE_THROW_ERROR(Exception, \"unsupported format in tiff decoding\");\n\t\t\t}\n\t\t\tconst uint32 stride = numeric_cast<uint32>(TIFFScanlineSize(t));\n\t\t\tCAGE_ASSERT(stride == impl->width * impl->channels * formatBytes(impl->format));\n\t\t\timpl->mem.resize(impl->height * stride);\n\t\t\tfor (uint32 row = 0; row < impl->height; row++)\n\t\t\t{\n\t\t\t\tchar *dst = impl->mem.data() + row * stride;\n\t\t\t\tif (TIFFReadScanline(t, dst, row) < 0)\n\t\t\t\t\tCAGE_THROW_ERROR(Exception, \"failed scanline reading in tiff decoding\");\n\t\t\t}\n\t\t\tTIFFClose(t);\n\n\t\t\t// color config\n\t\t\t// todo deduce it from the file\n\t\t}\n\t\tcatch (...)\n\t\t{\n\t\t\tif (t)\n\t\t\t\tTIFFClose(t);\n\t\t\tthrow;\n\t\t}\n\t}",
    "MemoryBuffer tiffEncode(const ImageImpl *impl)\n\t{\n\t\tTIFF *t = nullptr;\n\t\ttry\n\t\t{\n\t\t\tMemoryBuffer res;\n\t\t\tres.resize(impl->width * impl->height * impl->channels * formatBytes(impl->format) + 100); // preallocate and fill, instead of reserve\n\t\t\tdetail::memset(res.data(), 0, res.size()); // avoid storing uninitialized memory from the tiff library\n\t\t\tres.resize(0);\n\t\t\tBufferOStream stream(res);\n\t\t\tt = TIFFStreamOpen(\"MemTIFF\", &stream);\n\t\t\tif (!t)\n\t\t\t\tCAGE_THROW_ERROR(Exception, \"failed to initialize tiff encoding\");\n\t\t\tTIFFSetField(t, TIFFTAG_IMAGEWIDTH, impl->width);\n\t\t\tTIFFSetField(t, TIFFTAG_IMAGELENGTH, impl->height);\n\t\t\tTIFFSetField(t, TIFFTAG_SAMPLESPERPIXEL, impl->channels);\n\t\t\tswitch (impl->format)\n\t\t\t{\n\t\t\t\tcase ImageFormatEnum::U8:\n\t\t\t\t\tTIFFSetField(t, TIFFTAG_BITSPERSAMPLE, 8);\n\t\t\t\t\tTIFFSetField(t, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ImageFormatEnum::U16:\n\t\t\t\t\tTIFFSetField(t, TIFFTAG_BITSPERSAMPLE, 16);\n\t\t\t\t\tTIFFSetField(t, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ImageFormatEnum::Float:\n\t\t\t\t\tTIFFSetField(t, TIFFTAG_BITSPERSAMPLE, 32);\n\t\t\t\t\tTIFFSetField(t, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tCAGE_THROW_ERROR(Exception, \"unsupported format in tiff encoding\");\n\t\t\t}\n\t\t\tTIFFSetField(t, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\t\t\tTIFFSetField(t, TIFFTAG_COMPRESSION, COMPRESSION_ADOBE_DEFLATE);\n\t\t\tsetExtraSamples(t, impl);\n\t\t\tTIFFSetField(t, TIFFTAG_SOFTWARE, \"CageEngine\");\n\t\t\tconst uint32 stride = numeric_cast<uint32>(TIFFScanlineSize(t));\n\t\t\tCAGE_ASSERT(stride == impl->width * impl->channels * formatBytes(impl->format));\n\t\t\tfor (uint32 row = 0; row < impl->height; row++)\n\t\t\t{\n\t\t\t\tconst char *src = impl->mem.data() + row * stride;\n\t\t\t\tif (TIFFWriteScanline(t, (void *)src, row) < 0)\n\t\t\t\t\tCAGE_THROW_ERROR(Exception, \"failed scanline writing in tiff encoding\");\n\t\t\t}\n\t\t\tTIFFClose(t);\n\t\t\treturn res;\n\t\t}\n\t\tcatch (...)\n\t\t{\n\t\t\tif (t)\n\t\t\t\tTIFFClose(t);\n\t\t\tthrow;\n\t\t}\n\t}",
    "void save_tiff(cv::Mat data,std::string file,bool bgr2rgb)\n    {\n        if(bgr2rgb) {\n            cv::Mat tmp;\n            if(data.channels() == 3) {\n                cv::cvtColor(data,tmp,cv::COLOR_BGR2RGB);\n                data = tmp;\n            }\n            else if(data.channels() == 4) {\n                cv::cvtColor(data,tmp,cv::COLOR_BGRA2RGBA);\n                data = tmp;\n            }\n        }\n            \n        TIFF *out= TIFFOpen(file.c_str(), \"w\");\n        if(!out)\n            throw std::runtime_error(\"Failed to open file to write \"+ file);\n        try {\n            TIFFSetField(out,TIFFTAG_IMAGEWIDTH,data.cols);\n            TIFFSetField(out,TIFFTAG_IMAGELENGTH,data.rows);\n            TIFFSetField(out,TIFFTAG_SAMPLESPERPIXEL,data.channels());\n            TIFFSetField(out,TIFFTAG_BITSPERSAMPLE,data.elemSize1()*8);\n            TIFFSetField(out,TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n            TIFFSetField(out,TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG);\n            TIFFSetField(out,TIFFTAG_PHOTOMETRIC, data.channels()== 3 ? PHOTOMETRIC_RGB : PHOTOMETRIC_MINISBLACK);\n            switch(data.type() & CV_MAT_DEPTH_MASK) {\n            case CV_8U:\n            case CV_16U:\n                TIFFSetField(out,TIFFTAG_SAMPLEFORMAT,SAMPLEFORMAT_UINT);\n                break;\n            case CV_8S:\n            case CV_16S:\n            case CV_32S:\n                TIFFSetField(out,TIFFTAG_SAMPLEFORMAT,SAMPLEFORMAT_INT);\n                break;\n            case CV_32F:\n            case CV_64F:\n                TIFFSetField(out,TIFFTAG_SAMPLEFORMAT,SAMPLEFORMAT_IEEEFP);\n                break;\n            default:\n                throw std::runtime_error(\"Unsupported matrix format\");\n            }\n            size_t n = TIFFScanlineSize(out);\n            if(n != data.cols * data.channels() * data.elemSize1())\n                throw std::runtime_error(\"Internal error scanline size is inconsistent\");\n            for(int i=0;i<data.rows;i++) { \n                if(TIFFWriteScanline(out,(char*)(data.data) + data.step[0]*i,i,0) < 0)\n                    throw std::runtime_error(\"Failed to write tiff image\");\n            }\n        }\n        catch(...) {\n            TIFFClose(out);\n            throw;\n        }\n        TIFFClose(out);\n    }",
    "cv::Mat load_tiff(std::string file,bool bgr2rgb)\n    {\n        TIFF *in = TIFFOpen(file.c_str(),\"r\");\n        if(!in)\n            throw std::runtime_error(\"Failed to open tiff file \" + file);\n        try {\n            uint32_t width,height;\n            uint16_t depth,spp,format = SAMPLEFORMAT_UINT;\n            TIFFGetField(in,TIFFTAG_IMAGEWIDTH,&width);\n            TIFFGetField(in,TIFFTAG_IMAGELENGTH,&height);\n            TIFFGetField(in,TIFFTAG_SAMPLESPERPIXEL,&spp);\n            TIFFGetField(in,TIFFTAG_BITSPERSAMPLE,&depth);\n            TIFFGetField(in,TIFFTAG_SAMPLEFORMAT,&format);\n            if(spp <= 0 || spp > 4)\n                throw std::runtime_error(\"Invalid format for \" + file);\n            int type = -1;\n            switch(depth) {\n            case 8:\n                switch(format) {\n                case SAMPLEFORMAT_INT: type = CV_MAKETYPE(CV_8S,spp);  break;\n                case SAMPLEFORMAT_UINT: type = CV_MAKETYPE(CV_8U,spp);  break;\n                }\n                break;\n            case 16:\n                switch(format) {\n                case SAMPLEFORMAT_INT: type = CV_MAKETYPE(CV_16S,spp);  break;\n                case SAMPLEFORMAT_UINT: type = CV_MAKETYPE(CV_16U,spp);  break;\n                }\n                break;\n            case 32:\n                switch(format) {\n                case SAMPLEFORMAT_INT: type = CV_MAKETYPE(CV_32S,spp);  break;\n                case SAMPLEFORMAT_IEEEFP: type = CV_MAKETYPE(CV_32F,spp);  break;\n                }\n                break;\n            case 64:\n                switch(format) {\n                case SAMPLEFORMAT_IEEEFP: type = CV_MAKETYPE(CV_64F,spp);  break;\n                }\n                break;\n            }\n            if(type == -1)\n                throw std::runtime_error(\"Unsupported tiff format \" + file + \": spp=\" + std::to_string(spp) + \" depth=\" + std::to_string(depth) + \" format=\" + std::to_string(format));\n            cv::Mat res(height,width,type);\n            if(TIFFScanlineSize(in)!=int(res.step[0])) {\n                throw std::runtime_error(\"Internal error in stride/scanline size in \" + file);\n            }\n            for(unsigned i=0;i<height;i++) {\n                if(TIFFReadScanline(in,(char*)res.data + res.step[0]*i,i,0)<0)\n                    throw std::runtime_error(\"Failed to read \" + file);\n            }\n            TIFFClose(in);\n            if(bgr2rgb) {\n                cv::Mat tmp;\n                if(res.channels() == 3) {\n                    cv::cvtColor(res,tmp,cv::COLOR_RGB2BGR);\n                    res = tmp;\n                }\n                else if(res.channels() == 4) {\n                    cv::cvtColor(res,tmp,cv::COLOR_RGBA2BGRA);\n                    res = tmp;\n                }\n            }\n            return res;\n        }\n        catch(...) {\n            TIFFClose(in);\n            throw;\n        }\n    }",
    "bool tiff_read(const char *name, float scale, ctl::dpx::fb<float> *pixels,\n               format_t *format) {\n\tTIFF *t;\n\tuint16_t samples_per_pixel;\n\tuint16_t bits_per_sample;\n\tuint16_t sample_format;\n\tuint16_t planar_config;\n\tuint16_t photometric;\n\tuint16_t orientation;\n\n\tTIFFSetErrorHandler(ErrorHandler);\n\tTIFFSetWarningHandler(WarningHandler);\n\n\tt=TIFFOpen(name, \"r\");\n\tif(t==NULL) {\n\t\t// This is set if the file is not a tiff, we just sort of punt.\n\t\treturn FALSE;\n\t}\n\n\tTIFFGetFieldDefaulted(t, TIFFTAG_SAMPLESPERPIXEL, &samples_per_pixel);\n\tTIFFGetFieldDefaulted(t, TIFFTAG_BITSPERSAMPLE, &bits_per_sample);\n\tformat->src_bps=bits_per_sample;\n\tTIFFGetFieldDefaulted(t, TIFFTAG_SAMPLEFORMAT, &sample_format);\n\tTIFFGetFieldDefaulted(t, TIFFTAG_PHOTOMETRIC, &photometric);\n\tTIFFGetFieldDefaulted(t, TIFFTAG_ORIENTATION, &orientation);\n\n//\ttiff_read_failsafe(t, scale, pixels);\n//\treturn TRUE;\n\n\tif(!(bits_per_sample==16 && sample_format<3) &&\n\t   !(bits_per_sample==32 && sample_format==3) &&\n\t   photometric!=PHOTOMETRIC_RGB &&\n\t   orientation!=ORIENTATION_TOPLEFT &&\n\t   orientation!=ORIENTATION_BOTLEFT) {\n\n\t\tif(bits_per_sample!=8) {\n\t\t\tfprintf(stderr, \"falling back to failsafe TIFF reader. Reading \"\n\t\t\t        \"as \\n8 bits per sample RGBA.\\n\");\n\t\t}\n\t\ttiff_read_failsafe(t, scale, pixels);\n\t\tTIFFClose(t);\n\t\treturn TRUE;\n\t}\n\n\tTIFFGetField(t, TIFFTAG_PLANARCONFIG, &planar_config);\n\tif(planar_config==PLANARCONFIG_CONTIG) {\n\t\ttiff_read_interleaved(t, scale, pixels);\n\t} else if(planar_config==PLANARCONFIG_SEPARATE) {\n\t\ttiff_read_multiplane(t, scale, pixels);\n\t}\n\n\tTIFFClose(t);\n\n\treturn TRUE;\n}",
    "void tiff_write(const char *name, float scale,\n                const ctl::dpx::fb<float> &pixels,\n                format_t *format) {\n\tTIFF *t;\n\tuint16_t bits_per_sample;\n\ttdata_t scanline_buffer;\n\tuint32_t y;\n\tuint8_t channel;\n\tconst float *row;\n\n\tchannel = 0;\n\n\tTIFFSetErrorHandler(ErrorHandler);\n\tTIFFSetWarningHandler(WarningHandler);\n\n\tbits_per_sample=format->bps;\n\tif(format->bps<=8) {\n\t\tbits_per_sample=8;\n\t} else if(format->bps<=16) {\n\t\tbits_per_sample=16;\n\t} else if(format->bps!=32) {\n\t\tTHROW(Iex::ArgExc, \"TIFF files can only support files with <=16 bps \"\n\t\t      \"(integer) or 32 bps (float).\");\n\t}\n\n\tt=TIFFOpen(name, \"w\");\n\tif(t==NULL) {\n\t\t// What went wrong\n\t\t//fprintf(stderr, \"WARNING on line %d of file %s in function %s(): tiff_write() cannot open output file %s\\n\", __LINE__, __FILE__, __FUNCTION__, name);\n\t\tTHROW(Iex::ArgExc, \"tiff_write() cannot open output file \" << std::string(name) );\n\t\treturn;\n\t}\n\n\tTIFFSetField(t, TIFFTAG_SAMPLESPERPIXEL, pixels.depth());\n\tTIFFSetField(t, TIFFTAG_BITSPERSAMPLE, bits_per_sample);\n\tTIFFSetField(t, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\tTIFFSetField(t, TIFFTAG_IMAGEWIDTH, pixels.width());\n\tTIFFSetField(t, TIFFTAG_IMAGELENGTH, pixels.height());\n\tTIFFSetField(t, TIFFTAG_ROWSPERSTRIP, 1);\n\tTIFFSetField(t, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n\t// Worst case...\n\tscanline_buffer=alloca(sizeof(float)*pixels.depth()*pixels.width());\n\n\tif(bits_per_sample==8) {\n\t\tTIFFSetField(t, TIFFTAG_SAMPLEFORMAT, 1);\n\t\tfor(y=0; y<pixels.height(); y++) {\n\t\t\trow=pixels.ptr()+y*pixels.width()*pixels.depth();\n\t\t\ttiff_convert_uint8((uint8_t *)scanline_buffer, row,\n\t\t\t                   scale, pixels.depth()*pixels.width());\n\t\t\tTIFFWriteScanline(t, scanline_buffer, y, 0);\n\t\t}\n\t} else if(bits_per_sample==16) {\n\t\tTIFFSetField(t, TIFFTAG_SAMPLEFORMAT, 1);\n\t\tfor(y=0; y<pixels.height(); y++) {\n\t\t\trow=pixels.ptr()+y*pixels.width()*pixels.depth();\n\t\t\ttiff_convert_uint16((uint16_t *)scanline_buffer, row,\n\t\t\t                    scale, pixels.depth()*pixels.width());\n\t\t\tTIFFWriteScanline(t, scanline_buffer, y, channel);\n\t\t}\n\t} else if(bits_per_sample==32) {\n\t\tTIFFSetField(t, TIFFTAG_SAMPLEFORMAT, 3);\n\t\tfor(y=0; y<pixels.height(); y++) {\n\t\t\trow=pixels.ptr()+y*pixels.width()*pixels.depth();\n\t\t\ttiff_convert_float((float *)scanline_buffer, row,\n\t\t\t                   scale, pixels.depth()*pixels.width());\n\t\t\tTIFFWriteScanline(t, scanline_buffer, y, channel);\n\t\t}\n\t}\n\n\tTIFFClose(t);\n}",
    "void QFECamTestCamera::seriesStep1() {\r\n    int camera=0;\r\n\r\n    uint16 frame_samplesperpixel=1;\r\n    uint16 frame_bitspersample=8;\r\n    uint16 frame_sampleformat = SAMPLEFORMAT_UINT;\r\n    uint32 frame_width=getCameraImageWidth(camera);\r\n    uint32 frame_height=getCameraImageHeight(camera);\r\n    uint32 rowsperstrip = (uint32)-1;\r\n\r\n    uint32* frame32 = (uint32*)qfCalloc(frame_width*frame_height, sizeof(uint32));\r\n    uint32 frame_min=0xFFFFFFFF;\r\n    uint32 frame_max=0;\r\n    acquireOnCamera(camera, frame32);\r\n    for (register unsigned int i=0; i<frame_width*frame_height; i++) {\r\n        register uint32 v=frame32[i];\r\n        if (v<frame_min) frame_min=v;\r\n        if (v>frame_max) frame_max=v;\r\n    }\r\n    uint8* frame = (uint8*)qfMalloc(frame_width*frame_height*sizeof(uint8));\r\n    for (register unsigned int i=0; i<frame_width*frame_height; i++) {\r\n        register uint64_t v=255;\r\n        if (frame_max-frame_min!=0) v=(frame32[i]-frame_min)*255/(frame_max-frame_min);\r\n        if (v>255) v=255;\r\n        frame[i]=v;\r\n    }\r\n\r\n\r\n    TIFFSetField(tif[camera], TIFFTAG_IMAGEWIDTH, frame_width);\r\n    TIFFSetField(tif[camera], TIFFTAG_IMAGELENGTH, frame_height);\r\n    TIFFSetField(tif[camera], TIFFTAG_COMPRESSION, COMPRESSION_NONE);\r\n    TIFFSetField(tif[camera], TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\r\n    TIFFSetField(tif[camera], TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\r\n    TIFFSetField(tif[camera], TIFFTAG_BITSPERSAMPLE, frame_bitspersample);\r\n    TIFFSetField(tif[camera], TIFFTAG_SAMPLESPERPIXEL, frame_samplesperpixel);\r\n    rowsperstrip = TIFFDefaultStripSize(tif[camera], rowsperstrip);\r\n    TIFFSetField(tif[camera], TIFFTAG_ROWSPERSTRIP, rowsperstrip);\r\n    TIFFSetField(tif[camera], TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);\r\n    TIFFSetField(tif[camera],TIFFTAG_SAMPLEFORMAT,frame_sampleformat);\r\n    TIFFSetField(tif[camera],TIFFTAG_ORIENTATION,ORIENTATION_TOPLEFT);\r\n\r\n    // write frame data\r\n    // data is broken up into strips where each strip contains rowsperstrip complete rows of data\r\n    // each stript then has a size of rowsperstrip*frame_width pixels. the last strip is possibly\r\n    // smaller, so it is NOT padded with dummy data.\r\n    uint8* const buf = (uint8*)_TIFFmalloc(TIFFStripSize(tif[camera])); // data buffer for a strip of the image\r\n    for (unsigned int row = 0; (row<frame_height); row+=rowsperstrip) {\r\n        // compute rows in this strip:\r\n        uint32 nrow = rowsperstrip;\r\n        if ((row + rowsperstrip)>frame_height) {\r\n            nrow=frame_height-row; // this is the last strip ... and it is a bit smaller! ... it only contains the last rows of the image\r\n        }\r\n        tstrip_t strip = TIFFComputeStrip(tif[camera],row,0);\r\n        tsize_t bi = 0;\r\n        // go through the fraem row-wise\r\n        for (unsigned int rr = 0; rr<nrow; ++rr) {\r\n            for (unsigned int cc = 0; cc<frame_width; ++cc) { // go through all pixels in the current row\r\n                buf[bi++] = (uint8)frame[cc+(row + rr)*frame_width];\r\n            }\r\n        }\r\n        TIFFWriteEncodedStrip(tif[camera],strip,buf,bi*sizeof(uint8));\r\n    }\r\n    _TIFFfree(buf);\r\n    // write current directory, i.e. start new image\r\n    TIFFWriteDirectory(tif[camera]);\r\n\r\n\r\n    qfFree(frame);\r\n    qfFree(frame32);\r\n\r\n    seriesCount[camera]++;\r\n    seriesRunning[camera] = seriesRunning[camera] && (seriesCount[camera]<seriesAcquisitions);\r\n\r\n    if (seriesRunning[camera]) {\r\n        QTimer::singleShot(seriesDelay, this, SLOT(seriesStep1()));\r\n        //QApplication::processEvents();\r\n        //seriesStep1();\r\n    } else {\r\n        TIFFClose(tif[camera]);\r\n    }\r\n}",
    "void QFECamTestCamera::seriesStep2() {\r\n    int camera=1;\r\n\r\n    uint16 frame_samplesperpixel=1;\r\n    uint16 frame_bitspersample=8;\r\n    uint16 frame_sampleformat = SAMPLEFORMAT_UINT;\r\n    uint32 frame_width=getCameraImageWidth(camera);\r\n    uint32 frame_height=getCameraImageHeight(camera);\r\n    uint32 rowsperstrip = (uint32)-1;\r\n\r\n    uint32* frame32 = (uint32*)qfCalloc(frame_width*frame_height, sizeof(uint32));\r\n    uint32 frame_min=0xFFFFFFFF;\r\n    uint32 frame_max=0;\r\n    acquireOnCamera(camera, frame32);\r\n    for (register unsigned int i=0; i<frame_width*frame_height; i++) {\r\n        register uint32 v=frame32[i];\r\n        if (v<frame_min) frame_min=v;\r\n        if (v>frame_max) frame_max=v;\r\n    }\r\n    //std::cout<<\"frame_min=\"<<frame_min<<\"   frame_max=\"<<frame_max<<std::endl;\r\n    uint8* frame = (uint8*)qfMalloc(frame_width*frame_height*sizeof(uint8));\r\n    for (register unsigned int i=0; i<frame_width*frame_height; i++) {\r\n        register uint64_t v=(frame32[i]-frame_min)*255/(frame_max-frame_min);\r\n        if (v>255) v=255;\r\n        frame[i]=v;\r\n    }\r\n\r\n\r\n    TIFFSetField(tif[camera], TIFFTAG_IMAGEWIDTH, frame_width);\r\n    TIFFSetField(tif[camera], TIFFTAG_IMAGELENGTH, frame_height);\r\n    TIFFSetField(tif[camera], TIFFTAG_COMPRESSION, COMPRESSION_NONE);\r\n    TIFFSetField(tif[camera], TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\r\n    TIFFSetField(tif[camera], TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\r\n    TIFFSetField(tif[camera], TIFFTAG_BITSPERSAMPLE, frame_bitspersample);\r\n    TIFFSetField(tif[camera], TIFFTAG_SAMPLESPERPIXEL, frame_samplesperpixel);\r\n    rowsperstrip = TIFFDefaultStripSize(tif[camera], rowsperstrip);\r\n    TIFFSetField(tif[camera], TIFFTAG_ROWSPERSTRIP, rowsperstrip);\r\n    TIFFSetField(tif[camera], TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);\r\n    TIFFSetField(tif[camera],TIFFTAG_SAMPLEFORMAT,frame_sampleformat);\r\n    TIFFSetField(tif[camera],TIFFTAG_ORIENTATION,ORIENTATION_TOPLEFT);\r\n\r\n    // write frame data\r\n    // data is broken up into strips where each strip contains rowsperstrip complete rows of data\r\n    // each stript then has a size of rowsperstrip*frame_width pixels. the last strip is possibly\r\n    // smaller, so it is NOT padded with dummy data.\r\n    uint8* const buf = (uint8*)_TIFFmalloc(TIFFStripSize(tif[camera])); // data buffer for a strip of the image\r\n    for (unsigned int row = 0; (row<frame_height); row+=rowsperstrip) {\r\n        // compute rows in this strip:\r\n        uint32 nrow = rowsperstrip;\r\n        if ((row + rowsperstrip)>frame_height) {\r\n            nrow=frame_height-row; // this is the last strip ... and it is a bit smaller! ... it only contains the last rows of the image\r\n        }\r\n        tstrip_t strip = TIFFComputeStrip(tif[camera],row,0);\r\n        tsize_t bi = 0;\r\n        // go through the fraem row-wise\r\n        for (unsigned int rr = 0; rr<nrow; ++rr) {\r\n            for (unsigned int cc = 0; cc<frame_width; ++cc) { // go through all pixels in the current row\r\n                buf[bi++] = (uint8)frame[cc+(row + rr)*frame_width];\r\n            }\r\n        }\r\n        TIFFWriteEncodedStrip(tif[camera],strip,buf,bi*sizeof(uint8));\r\n    }\r\n    _TIFFfree(buf);\r\n    // write current directory, i.e. start new image\r\n    TIFFWriteDirectory(tif[camera]);\r\n\r\n\r\n    qfFree(frame);\r\n    qfFree(frame32);\r\n\r\n    seriesCount[camera]++;\r\n    seriesRunning[camera] = seriesRunning[camera] && (seriesCount[camera]<seriesAcquisitions);\r\n\r\n    if (seriesRunning[camera]) {\r\n        QTimer::singleShot(seriesDelay, this,SLOT(seriesStep2()));\r\n    } else {\r\n        TIFFClose(tif[camera]);\r\n    }\r\n}",
    "QFImageReaderLIBTIFF::~QFImageReaderLIBTIFF() {\n    if (tif!=NULL) TIFFClose(tif);\n    tif=NULL;\n}",
    "void QFImageReaderLIBTIFF::close() {\n    if (!tif) return;\n    //qDebug()<<\"QFImageReaderLIBTIFF::close()     tif=\"<<tif;\n    TIFFClose(tif);\n    QString fn=filename;\n    filename=\"\";\n    imageDescription=\"\";\n    tif=NULL;\n    logTIFFMessage(\"QFImageReaderLIBTIFF\", \"closed file %s\\n\", fn.toLocal8Bit().data());\n    //qDebug()<<\"  QFImageReaderLIBTIFF::close()   tif=\"<<tif;\n}",
    "void QFImageWriterLibTIFF::close()\n{\n    for (int i=0; i<tif.size(); i++) {\n        if (tif[i]) TIFFClose(tif[i]);\n    }\n    tif.clear();\n    frames=0;\n}",
    "int main(int argc, char *argv[])\n{\n    uint16_t             defconfig = (uint16_t)-1;\n    uint16_t             deffillorder = 0;\n    uint32_t             deftilewidth = (uint32_t)-1;\n    uint32_t             deftilelength = (uint32_t)-1;\n    uint32_t             defrowsperstrip = (uint32_t)-1;\n    uint32_t             diroff = 0;\n    TIFF *             in;\n    TIFF *             out;\n    const char *       mode = \"w\";\n    int                c;\n    extern int         optind;\n    extern const char *myoptarg;\n\n    while ((c = getopt(argc, argv, \"c:f:l:m:M:n:o:p:r:w:e:g:4:aistd\")) != -1) switch (c) {\n        case 'a': /* append to output */ mode = \"a\"; break;\n        case 'd': /* down cast 8bit to 4bit */ convert_8_to_4 = 1; break;\n        case 'c': /* compression scheme */\n            if (!processCompressOptions(myoptarg)) usage();\n            break;\n        case 'e': worldfile = myoptarg; break;\n        case 'f': /* fill order */\n            if (streq(myoptarg, \"lsb2msb\"))\n                deffillorder = FILLORDER_LSB2MSB;\n            else if (streq(myoptarg, \"msb2lsb\"))\n                deffillorder = FILLORDER_MSB2LSB;\n            else\n                usage();\n            break;\n        case 'i': /* ignore errors */ ignore = TRUE; break;\n        case 'g': /* GeoTIFF metadata file */ geofile = myoptarg; break;\n        case 'm': /*multiple times and latlon extents file */\n            timeLonLatName = myoptarg;\n            timeLonLatFile = fopen(timeLonLatName, \"r\");\n            if (!timeLonLatFile) {\n                fprintf(stderr, \"Failure to open %s\\n\", timeLonLatName);\n                exit(-1);\n            }\n            break;\n        case 'M': /*multiple timestamps file */\n            timeName = myoptarg;\n            timeFile = fopen(timeName, \"r\");\n            if (!timeFile) {\n                fprintf(stderr, \"Failure to open %s\\n\", timeName);\n                exit(-1);\n            }\n            break;\n        case 'n': /* single latlong extents, requires option 4 */\n        {\n            int retval = sscanf(myoptarg, \"%f %f %f %f\", lonLatExts, lonLatExts + 1, lonLatExts + 2, lonLatExts + 3);\n            if (retval != 4) {\n                fprintf(stderr, \"Four lon/lat extent values required\\n\");\n                exit(-1);\n            }\n        } break;\n\n        case '4': proj4_string = myoptarg; break;\n        case 'l': /* tile length */\n            outtiled = TRUE;\n            deftilelength = atoi(myoptarg);\n            break;\n        case 'o': /* initial directory offset */ diroff = strtoul(myoptarg, NULL, 0); break;\n        case 'p': /* planar configuration */\n            if (streq(myoptarg, \"separate\"))\n                defconfig = PLANARCONFIG_SEPARATE;\n            else if (streq(myoptarg, \"contig\"))\n                defconfig = PLANARCONFIG_CONTIG;\n            else\n                usage();\n            break;\n        case 'r': /* rows/strip */ defrowsperstrip = atoi(myoptarg); break;\n        case 's': /* generate stripped output */ outtiled = FALSE; break;\n        case 't': /* generate tiled output */ outtiled = TRUE; break;\n        case 'w': /* tile width */\n            outtiled = TRUE;\n            deftilewidth = atoi(myoptarg);\n            break;\n        case '?':\n            usage();\n            /*NOTREACHED*/\n        }\n    if (argc - optind < 2) usage();\n    out = TIFFOpen(argv[argc - 1], mode);\n    if (out == NULL) return (-2);\n    for (; optind < argc - 1; optind++) {\n        in = TIFFOpen(argv[optind], \"r\");\n        if (in == NULL) return (-3);\n        if (diroff != 0 && !TIFFSetSubDirectory(in, diroff)) {\n            TIFFError(TIFFFileName(in), \"Error, setting subdirectory at %#x\", diroff);\n            (void)TIFFClose(out);\n            return (1);\n        }\n        do {\n            config = defconfig;\n            compression = defcompression;\n            predictor = defpredictor;\n            fillorder = deffillorder;\n            rowsperstrip = defrowsperstrip;\n            tilewidth = deftilewidth;\n            tilelength = deftilelength;\n            g3opts = defg3opts;\n            if (!tiffcp(in, out) || !TIFFWriteDirectory(out)) {\n                (void)TIFFClose(out);\n                return (1);\n            }\n        } while (TIFFReadDirectory(in));\n        (void)TIFFClose(in);\n    }\n    (void)TIFFClose(out);\n    return (0);\n}",
    "bool QFRDRImagingFCSData::loadOverview(double* overviewF, double* overviewF2, const QString& filename) {\r\n    bool ok=false;\r\n\r\n    if (!overviewF && !overviewF2) return false;\r\n\r\n    //qDebug()<<getID()<<\"loadedOverview \"<<filename;\r\n    if (QFile::exists(filename)) {\r\n        TIFF* tif=TIFFOpen(filename.toLatin1().data(), \"r\");\r\n        if (tif) {\r\n            uint32 nx,ny;\r\n            TIFFGetField(tif,TIFFTAG_IMAGEWIDTH,&nx);\r\n            TIFFGetField(tif,TIFFTAG_IMAGELENGTH,&ny);\r\n            double* tmp=(double*)qfMalloc(nx*ny*sizeof(double));\r\n            ok=TIFFReadFrame<double>(tif, tmp);\r\n            TIFFClose(tif);\r\n\r\n            if (ok) {\r\n\r\n                splitImage(overviewF, overviewF2, tmp, nx, ny);\r\n            }\r\n            qfFree(tmp);\r\n        } else {\r\n            log_warning(tr(\"WARNING: could not load overview image file '%1'\\n\").arg(filename));\r\n        }\r\n    } else {\r\n        log_warning(tr(\"WARNING: could not find overview image file '%1'\\n\").arg(filename));\r\n    }\r\n\r\n    //QFRawDataRecordReadLocker locker(this);\r\n    if (!ok && overviewF) {\r\n        for (int i=0; i<width*height; i++) {\r\n            overviewF[i]=0;\r\n        }\r\n    }\r\n    if (!ok && overviewF2) {\r\n        for (int i=0; i<width*height; i++) {\r\n            overviewF2[i]=0;\r\n        }\r\n    }\r\n    double crscaling=getProperty(\"OVERVIEW_SCALING\", 1.0).toDouble();\r\n    if (crscaling!=1.0 && overviewF) {\r\n        for (int i=0; i<width*height; i++) {\r\n            overviewF[i]=overviewF[i]*crscaling;\r\n        }\r\n\r\n    }\r\n    if (crscaling!=1.0 && overviewF2) {\r\n        for (int i=0; i<width*height; i++) {\r\n            overviewF2[i]=overviewF2[i]*crscaling;\r\n        }\r\n\r\n    }\r\n    //qDebug()<<getID()<<\"loadedOverview \"<<filename<<\"   OK=\"<<ok;\r\n    return ok;\r\n}",
    "bool QFRDRImagingFCSData::loadImage(const QString& filename, double** data, int* width, int* height) {\r\n    bool ok=false;\r\n\r\n    if (*data) qfFree(*data);\r\n    *data=NULL;\r\n    *width=0;\r\n    *height=0;\r\n\r\n    if (QFile::exists(filename)) {\r\n        TIFF* tif=TIFFOpen(filename.toLatin1().data(), \"r\");\r\n        if (tif) {\r\n            uint32 nx,ny;\r\n            TIFFGetField(tif,TIFFTAG_IMAGEWIDTH,&nx);\r\n            TIFFGetField(tif,TIFFTAG_IMAGELENGTH,&ny);\r\n            *width=nx;\r\n            *height=ny;\r\n            *data=(double*)qfMalloc(nx*ny*sizeof(double));\r\n            ok=TIFFReadFrame<double>(tif, *data);\r\n            TIFFClose(tif);\r\n        } else {\r\n            log_warning(tr(\"WARNING: could not load overview image file '%1'\\n\").arg(filename));\r\n        }\r\n    } else {\r\n        log_warning(tr(\"WARNING: could not find overview image file '%1'\\n\").arg(filename));\r\n    }\r\n\r\n    double crscaling=getProperty(\"OVERVIEW_SCALING\", 1.0).toDouble();\r\n    if (crscaling!=1.0 && (*data)) {\r\n        for (int i=0; i<(*width)*(*height); i++) {\r\n            (*data)[i]=(*data)[i]*crscaling;\r\n        }\r\n\r\n    }\r\n    return ok;\r\n}",
    "bool QFRDRImagingFCSData::loadVideo(const QString& filename, double** data, int* width, int* height, uint32_t* frames, double scaleFactor, double scaleOffset) {\r\n    bool ok=false;\r\n\r\n    //qDebug()<<filename<<data<<width<<height<<frames;\r\n    if (!data || !width || !height || !frames) return false;\r\n\r\n    if (*data) qfFree(*data);\r\n    *data=NULL;\r\n    *width=0;\r\n    *height=0;\r\n    *frames=0;\r\n\r\n    if (QFile::exists(filename)) {\r\n        TIFF* tif=TIFFOpen(filename.toLatin1().data(), \"r\");\r\n        if (tif) {\r\n            *frames=TIFFCountDirectories(tif);\r\n            uint32 nx,ny;\r\n            TIFFGetField(tif,TIFFTAG_IMAGEWIDTH,&nx);\r\n            TIFFGetField(tif,TIFFTAG_IMAGELENGTH,&ny);\r\n            uint16 bitspersample;\r\n            uint16 sampleformat = SAMPLEFORMAT_UINT;\r\n            TIFFGetField(tif, TIFFTAG_SAMPLEFORMAT, &sampleformat);\r\n            TIFFGetFieldDefaulted(tif,TIFFTAG_BITSPERSAMPLE,&bitspersample);\r\n\r\n            *width=nx;\r\n            *height=ny;\r\n            if (*frames>0 && *width>0 && *height>0) {\r\n                *data=(double*)qfMalloc(nx*ny*(*frames)*sizeof(double));\r\n                uint32_t i=0;\r\n                if (*data) {\r\n                    do {\r\n                        ok=ok & TIFFReadFrame<double>(tif, &((*data)[i*nx*ny]));\r\n                        if (sampleformat == SAMPLEFORMAT_UINT && bitspersample==16 && (scaleFactor!=1.0 || scaleOffset!=0.0)) {\r\n                            for (uint32_t jj=0; jj<nx*ny; jj++) {\r\n                                (*data)[i*nx*ny+jj]=scaleOffset+(*data)[i*nx*ny+jj]*scaleFactor;\r\n                            }\r\n                        }\r\n                        i++;\r\n                    } while (TIFFReadDirectory(tif) && i<=(*frames));\r\n                }\r\n            } else {\r\n                log_warning(tr(\"WARNING: could not load overview image file '%1'\\n\").arg(filename));\r\n            }\r\n            TIFFClose(tif);\r\n            //qDebug()<<getID()<<\"loading video \"<<filename<<\"   siez=\"<<*width<<\"x\"<<*height<<\"   frames=\"<<*frames;\r\n        } else {\r\n            log_warning(tr(\"WARNING: could not load overview image file '%1'\\n\").arg(filename));\r\n        }\r\n    } else {\r\n        log_warning(tr(\"WARNING: could not find overview image file '%1'\\n\").arg(filename));\r\n    }\r\n    return ok;\r\n}",
    "bool QFESPIMB040MainWindow2::savePreview(QFExtension* /*extension*/, QFExtensionCamera* ecamera, int camera, const QString& previewSettingsFilename, const QString& filename, QString* filename32, QMap<QString, QVariant>* acquisitionDescription, const QString& acquisitionDescriptionPrefix, bool mainShutterOpenOnlyForAcquisition, int frames, bool getMeasurements) {\r\n    //////////////////////////////////////////////////////////////////////////////////////\r\n    // INIT variables\r\n    //////////////////////////////////////////////////////////////////////////////////////\r\n    bool ok=true;\r\n    QString TIFFFIlename=filename;\r\n    QString TIFFFIlename32=filename.left(filename.size()-(QFileInfo(filename).suffix().size()+1))+\".32.\"+QFileInfo(filename).suffix();\r\n    TIFF* tiff=NULL;\r\n\r\n    if (filename32) *filename32=\"\";\r\n\r\n\r\n    bool oldShutterState=false;\r\n    if (mainShutterOpenOnlyForAcquisition && optSetup->isMainIlluminationShutterAvailable()) oldShutterState=optSetup->getMainIlluminationShutter();\r\n    //////////////////////////////////////////////////////////////////////////////////////\r\n    // Close Main shutter\r\n    //////////////////////////////////////////////////////////////////////////////////////\r\n    if (mainShutterOpenOnlyForAcquisition && oldShutterState && optSetup->isMainIlluminationShutterAvailable()) {\r\n        optSetup->setMainIlluminationShutter(false, true);\r\n    }\r\n\r\n\r\n    //////////////////////////////////////////////////////////////////////////////////////\r\n    // PREPARE CAMERA\r\n    //////////////////////////////////////////////////////////////////////////////////////\r\n    int width=0, height=0;\r\n    uint32_t* buffer=NULL;\r\n    if (ok) {\r\n        if (!previewSettingsFilename.isEmpty())  {\r\n            QSettings settings(previewSettingsFilename, QSettings::IniFormat);\r\n            ecamera->useCameraSettings(camera, settings);\r\n        }\r\n        width=ecamera->getCameraImageWidth(camera);\r\n        height=ecamera->getCameraImageHeight(camera);\r\n        buffer=(uint32_t*)qfCalloc(width*height, sizeof(uint32_t));\r\n        if (!buffer) {\r\n            ok=false;\r\n        }\r\n    }\r\n\r\n\r\n    //////////////////////////////////////////////////////////////////////////////////////\r\n    // Open Main shutter\r\n    //////////////////////////////////////////////////////////////////////////////////////\r\n    if (mainShutterOpenOnlyForAcquisition && optSetup->isMainIlluminationShutterAvailable()) {\r\n        optSetup->setMainIlluminationShutter(true, true);\r\n    }\r\n\r\n    //////////////////////////////////////////////////////////////////////////////////////\r\n    // OPEN OUTPUT TIFF FILES\r\n    //////////////////////////////////////////////////////////////////////////////////////\r\n    if (ok) {\r\n        QMap<QString, QVariant> acqD;\r\n        if (frames<=1) {\r\n\r\n            QTime time=QTime::currentTime();\r\n            if (ecamera->acquireOnCamera(camera, buffer, NULL, &acqD)) {\r\n                //////////////////////////////////////////////////////////////////////////////////////\r\n                // Close Main shutter\r\n                //////////////////////////////////////////////////////////////////////////////////////\r\n                if (mainShutterOpenOnlyForAcquisition && optSetup->isMainIlluminationShutterAvailable()) {\r\n                    optSetup->setMainIlluminationShutter(false, true);\r\n                }\r\n                if (acquisitionDescription) {\r\n                    QMapIterator<QString, QVariant> it(acqD);\r\n                    while (it.hasNext()) {\r\n                        it.next();\r\n                        (*acquisitionDescription)[acquisitionDescriptionPrefix+it.key()]=it.value();\r\n                    }\r\n                    (*acquisitionDescription)[acquisitionDescriptionPrefix+\"/dualview_mode\"]=optSetup->dualViewMode(ecamera, camera);\r\n                    (*acquisitionDescription)[acquisitionDescriptionPrefix+\"/image_width\"]=width;\r\n                    (*acquisitionDescription)[acquisitionDescriptionPrefix+\"/image_height\"]=height;\r\n                    (*acquisitionDescription)[acquisitionDescriptionPrefix+\"/exposure_time\"]=ecamera->getCameraExposureTime(camera);\r\n                    optSetup->saveLightpathConfig((*acquisitionDescription), optSetup->getCurrentLightpath(), acquisitionDescriptionPrefix+\"/lightpath/\", QList<bool>(), true);\r\n                    (*acquisitionDescription)[acquisitionDescriptionPrefix+\"/timestamp\"]=time;\r\n                    getAdditionalCameraSettings(ecamera, camera, acquisitionDescriptionPrefix, (*acquisitionDescription), getMeasurements);\r\n\r\n                }\r\n                QDir().mkpath(QFileInfo(TIFFFIlename.toLatin1().data()).absolutePath());\r\n                tiff=TIFFOpen(TIFFFIlename.toLatin1().data(), \"w\");\r\n                if (!tiff) {\r\n                    ok=false;\r\n                } else {\r\n                    TIFFTWriteUint16from32(tiff, buffer, width, height, false);\r\n                    TIFFClose(tiff);\r\n                }\r\n                bool is32bit=false;\r\n                for (int i=0; i<width*height; i++) {\r\n                    if ((buffer[i]&0xFFFF0000) != 0) {\r\n                        is32bit=true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (ok && is32bit) {\r\n                    tiff=TIFFOpen(TIFFFIlename32.toLatin1().data(), \"w\");\r\n                    if (!tiff) {\r\n                        ok=false;\r\n                    } else {\r\n                        if (filename32) {\r\n                            *filename32=TIFFFIlename32;\r\n                        }\r\n                        TIFFTWriteUint32(tiff, buffer, width, height);\r\n                        TIFFClose(tiff);\r\n                    }\r\n                }\r\n            } else {\r\n                ok=false;\r\n            }\r\n        } else if (frames>=2) {\r\n\r\n            QDir().mkpath(QFileInfo(TIFFFIlename.toLatin1().data()).absolutePath());\r\n            tiff=TIFFOpen(TIFFFIlename.toLatin1().data(), \"w\");\r\n            if (tiff) {\r\n                ok=true;\r\n                bool is32bit=false;\r\n                for (int f=0; f<frames; f++) {\r\n                    QTime time=QTime::currentTime();\r\n                    if (ecamera->acquireOnCamera(camera, buffer, NULL, &acqD)) {\r\n\r\n                        if (acquisitionDescription) {\r\n                            if (f==0) {\r\n                                QMapIterator<QString, QVariant> it(acqD);\r\n                                while (it.hasNext()) {\r\n                                    it.next();\r\n                                    (*acquisitionDescription)[acquisitionDescriptionPrefix+it.key()]=it.value();\r\n                                }\r\n                                (*acquisitionDescription)[acquisitionDescriptionPrefix+\"/dualview_mode\"]=optSetup->dualViewMode(ecamera, camera);\r\n                                (*acquisitionDescription)[acquisitionDescriptionPrefix+\"/image_width\"]=width;\r\n                                (*acquisitionDescription)[acquisitionDescriptionPrefix+\"/image_height\"]=height;\r\n                                (*acquisitionDescription)[acquisitionDescriptionPrefix+\"/exposure_time\"]=ecamera->getCameraExposureTime(camera);\r\n                                optSetup->saveLightpathConfig((*acquisitionDescription), optSetup->getCurrentLightpath(), acquisitionDescriptionPrefix+\"/lightpath/\", QList<bool>(), true);\r\n                                getAdditionalCameraSettings(ecamera, camera, acquisitionDescriptionPrefix, (*acquisitionDescription), getMeasurements);\r\n                            }\r\n                            (*acquisitionDescription)[acquisitionDescriptionPrefix+QString(\"/timestamp%1\").arg(f+1)]=time;\r\n\r\n                        }\r\n                        if (f==0) {\r\n                            for (int i=0; i<width*height; i++) {\r\n                                if ((buffer[i]&0xFFFF0000) != 0) {\r\n                                    is32bit=true;\r\n                                    break;\r\n                                }\r\n                            }\r\n                        }\r\n                        if (!tiff) {\r\n                            ok=false;\r\n                        } else {\r\n                            if (ok && is32bit) {\r\n                                TIFFTWriteUint32(tiff, buffer, width, height);\r\n                            } else if (ok) {\r\n                                TIFFTWriteUint16from32(tiff, buffer, width, height, false);\r\n                            }\r\n                            TIFFWriteDirectory(tiff);\r\n                        }\r\n                    } else {\r\n                        ok=false;\r\n                    }\r\n                    if (!ok) break;\r\n                }\r\n                //////////////////////////////////////////////////////////////////////////////////////\r\n                // Close Main shutter\r\n                //////////////////////////////////////////////////////////////////////////////////////\r\n                if (mainShutterOpenOnlyForAcquisition && optSetup->isMainIlluminationShutterAvailable()) {\r\n                    optSetup->setMainIlluminationShutter(false, true);\r\n                }\r\n                TIFFClose(tiff);\r\n            } else {\r\n                ok=false;\r\n            }\r\n        }\r\n\r\n        if (buffer) qfFree(buffer);\r\n    }\r\n\r\n    //////////////////////////////////////////////////////////////////////////////////////\r\n    // Reset Main shutter\r\n    //////////////////////////////////////////////////////////////////////////////////////\r\n    if (mainShutterOpenOnlyForAcquisition && optSetup->isMainIlluminationShutterAvailable()) {\r\n        optSetup->setMainIlluminationShutter(oldShutterState, true);\r\n    }\r\n\r\n\r\n    return ok;\r\n}",
    "void QFESPIMB040ImageStackConfigWidget2::performStack()\r\n{\r\n    if (!(use1() || use2())) {\r\n        QMessageBox::critical(this, tr(\"B040SPIM: Image Stack Acquisition\"), tr(\"Cannot start image acquisition: No camera selected!\"));\r\n        return;\r\n    }\r\n\r\n    QDateTime startDateTime=QDateTime::currentDateTime();\r\n    QList<QFESPIMB040OpticsSetupBase::measuredValues> measured;\r\n\r\n\r\n    QProgressListDialog progress(tr(\"Image Stack Acquisition\"), tr(\"&Cancel\"), 0, 100, this);\r\n    progress.setWindowModality(Qt::WindowModal);\r\n    //progress.setMinimumDuration(0);\r\n    progress.setValue(0);\r\n    progress.addItem(tr(\"initializing stages\"));\r\n    progress.addItem(tr(\"preparing cameras\"));\r\n    progress.addItem(tr(\"performing acquisition\"));\r\n    progress.addItem(tr(\"storing data to disk\"));\r\n    progress.addItem(tr(\"clean up\"));\r\n    progress.setHasProgressBar(true);\r\n    progress.show();\r\n\r\n\r\n    log->log_text(tr(\"starting image stack acquisition:\\n\"));\r\n    log->log_text(tr(\"  - locking stages\\n\"));\r\n    progress.start();\r\n    opticsSetup->lockStages();\r\n    opticsSetup->lockLightpath();\r\n\r\n    bool ok=true;\r\n    int axisCount=1; // number of axes to use for scan\r\n\r\n    //////////////////////////////////////////////////////////////////////////////////////\r\n    // CHECK/CONNECT SELECTED STAGE 1\r\n    //////////////////////////////////////////////////////////////////////////////////////\r\n    QFExtensionLinearStage* stage=this->stage();\r\n    int stageAxis=currentAxisID();\r\n    double stageInitialPos=0;\r\n    progress.setProgressText(tr(\"locking stage 1 ...\"));\r\n    ok=acqTools->connectStageForAcquisition(stage, stageAxis, stageInitialPos, tr(\"B040SPIM: Image Stack Acquisition\"),1);\r\n\r\n\r\n    if (ok) {\r\n\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        // CHECK/CONNECT SELECTED STAGE 2 (if selected)\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        QFExtensionLinearStage* stage2=this->stage2();\r\n        int stageAxis2=currentAxisID2();\r\n        double stageInitialPos2=0;\r\n        if (useStage2()) {\r\n            progress.setProgressText(tr(\"locking stage 2 ...\"));\r\n            ok=acqTools->connectStageForAcquisition(stage2, stageAxis2, stageInitialPos2, tr(\"B040SPIM: Image Stack Acquisition\"),2);\r\n            if (ok) axisCount++;\r\n\r\n        }\r\n\r\n        if (!ok) {\r\n            opticsSetup->unlockStages();\r\n            opticsSetup->unlockLightpath();\r\n            return;\r\n        }\r\n\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        // CHECK/CONNECT SELECTED STAGE 3 (if selected)\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        QFExtensionLinearStage* stage3=this->stage3();\r\n        int stageAxis3=currentAxisID3();\r\n        double stageInitialPos3=0;\r\n        if (useStage3()) {\r\n            progress.setProgressText(tr(\"locking stage 3 ...\"));\r\n            ok=acqTools->connectStageForAcquisition(stage3, stageAxis3, stageInitialPos3, tr(\"B040SPIM: Image Stack Acquisition\"),3);\r\n            if (ok) axisCount++;\r\n\r\n        }\r\n\r\n        if (!ok) {\r\n            opticsSetup->unlockStages();\r\n            opticsSetup->unlockLightpath();\r\n            return;\r\n        }\r\n\r\n\r\n        progress.nextItem();\r\n\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        // LOCK/INIT CAMERA 1\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        bool useCam1=false;\r\n        QFExtension* extension1=NULL;\r\n        QFExtensionCamera* ecamera1=NULL;\r\n        int camera1=0;\r\n        QString acquisitionSettingsFilename1=\"\", previewSettingsFilename1=\"\";\r\n        QString acquisitionPrefix1=prefix1();\r\n        QStringList TIFFFIlename1;;\r\n        QList<TIFF*> tiff1;\r\n        TIFF* tiff1_background=NULL;\r\n        QString TIFFFIlenameBackground1;\r\n        if (use1()) {\r\n            progress.setProgressText(tr(\"locking camera 1 ...\"));\r\n            if (!(useCam1=opticsSetup->lockCamera(0, &extension1, &ecamera1, &camera1, &previewSettingsFilename1))) {\r\n                IMAGESTACK_ERROR(tr(\"error locking camera 1!\\n\"));\r\n            }\r\n        }\r\n        if (QFile::exists(currentConfigFilename(0))) acquisitionSettingsFilename1=currentConfigFilename(0);\r\n\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        // LOCK/INIT CAMERA 2\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        bool useCam2=false;\r\n        QFExtension* extension2=NULL;\r\n        QFExtensionCamera* ecamera2=NULL;\r\n        QString acquisitionSettingsFilename2=\"\", previewSettingsFilename2=\"\";\r\n        QString acquisitionPrefix2=prefix2();\r\n        QStringList TIFFFIlename2;\r\n        QList<TIFF*> tiff2;\r\n        TIFF* tiff2_background=NULL;\r\n        QString TIFFFIlenameBackground2;\r\n\r\n        int camera2=0;\r\n        if (use2()) {\r\n            progress.setProgressText(tr(\"locking camera 2 ...\"));\r\n            if(!(useCam2=opticsSetup->lockCamera(1, &extension2, &ecamera2, &camera2, &previewSettingsFilename2))) {\r\n                IMAGESTACK_ERROR(tr(\"error locking camer 2!\\n\"));\r\n            }\r\n        }\r\n        if (QFile::exists(currentConfigFilename(1))) acquisitionSettingsFilename2=currentConfigFilename(1);\r\n\r\n        if (ok && !useCam1 && !useCam2) {\r\n            IMAGESTACK_ERROR(tr(\"Cannot start image acquisition: No camera selected, or both cameras not usable!\"));\r\n            ok=false;\r\n        }\r\n\r\n        if (ok && useCam1) log->log_text(tr(\"  - storing files with prefix 1: '%1'\\n\").arg(acquisitionPrefix1));\r\n        if (ok && useCam2) log->log_text(tr(\"  - storing files with prefix 2: '%1'\\n\").arg(acquisitionPrefix2));\r\n\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        // PREPARE CAMERA 1\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        int width1=0, height1=0;\r\n        uint32_t* buffer1=NULL;\r\n        if (ok && useCam1) {\r\n            progress.setLabelText(tr(\"preparing camera 1 ...\"));\r\n            ok=acqTools->prepareCamera(1, camera1, ecamera1, acquisitionSettingsFilename1, width1, height1, &buffer1);\r\n\r\n        }\r\n\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        // PREPARE CAMERA 2\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        int width2=0, height2=0;\r\n        uint32_t* buffer2=NULL;\r\n        if (ok && useCam2) {\r\n            progress.setLabelText(tr(\"preparing camera 2 ...\"));\r\n            ok=acqTools->prepareCamera(2, camera2, ecamera2, acquisitionSettingsFilename2, width2, height2, &buffer2);\r\n\r\n\r\n        }\r\n\r\n\r\n        progress.setLabelText(tr(\"preparing lightpathes ...\"));\r\n\r\n\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        // COUNT LIGHTPATHS\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        QStringList lightpathList;\r\n        QStringList lightpathNames;\r\n        TIFFFIlenameBackground1=acquisitionPrefix1+\".background.tif\";\r\n        TIFFFIlenameBackground2=acquisitionPrefix2+\".background.tif\";\r\n        if (lightpath1Activated()) {\r\n            if (QFile::exists(lightpath1Filename())) {\r\n                lightpathList.append(lightpath1Filename());\r\n                lightpathNames.append(lightpath1());\r\n                TIFFFIlename1.append(acquisitionPrefix1+\".lightpath1.tif\");\r\n                tiff1.append(NULL);\r\n                TIFFFIlename2.append(acquisitionPrefix2+\".lightpath1.tif\");\r\n                tiff2.append(NULL);\r\n            } else {\r\n                ok=false;\r\n                IMAGESTACK_ERROR(tr(\"acquisition lightpath 1 '%1' configuration not found!\").arg(lightpath1()));\r\n            }\r\n        }\r\n        if (lightpath2Activated()) {\r\n            if (QFile::exists(lightpath2Filename())) {\r\n                lightpathList.append(lightpath2Filename());\r\n                lightpathNames.append(lightpath2());\r\n                TIFFFIlename1.append(acquisitionPrefix1+\".lightpath2.tif\");\r\n                tiff1.append(NULL);\r\n                TIFFFIlename2.append(acquisitionPrefix2+\".lightpath2.tif\");\r\n                tiff2.append(NULL);\r\n            } else {\r\n                ok=false;\r\n                IMAGESTACK_ERROR(tr(\"acquisition lightpath 2 '%1' configuration not found!\").arg(lightpath2()));\r\n            }\r\n        }\r\n        if (lightpath3Activated()) {\r\n            if (QFile::exists(lightpath3Filename())) {\r\n                lightpathList.append(lightpath3Filename());\r\n                lightpathNames.append(lightpath3());\r\n                TIFFFIlename1.append(acquisitionPrefix1+\".lightpath3.tif\");\r\n                tiff1.append(NULL);\r\n                TIFFFIlename2.append(acquisitionPrefix2+\".lightpath3.tif\");\r\n                tiff2.append(NULL);\r\n            } else {\r\n                ok=false;\r\n                IMAGESTACK_ERROR(tr(\"acquisition lightpath 3 '%1' configuration not found!\").arg(lightpath3()));\r\n            }\r\n        }\r\n        if (ok && lightpathList.isEmpty()) {\r\n            lightpathList.append(\"\");\r\n            lightpathNames.append(\"default\");\r\n            TIFFFIlename1.append(acquisitionPrefix1+\".tif\");\r\n            tiff1.append(NULL);\r\n            TIFFFIlename2.append(acquisitionPrefix2+\".tif\");\r\n            tiff2.append(NULL);\r\n        }\r\n\r\n        progress.setLabelText(tr(\"opening/creating output files ...\"));\r\n\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        // OPEN OUTPUT TIFF FILES\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        progress.setLabelText(tr(\"opening output files ...\"));\r\n        QApplication::processEvents();\r\n        if (ok && useCam1) {\r\n            QDir().mkpath(QFileInfo(TIFFFIlenameBackground1.toLatin1().data()).absolutePath());\r\n            tiff1_background=TIFFOpen(TIFFFIlenameBackground1.toLatin1().data(), \"w\");;\r\n            if (!tiff1_background) {\r\n                ok=false;\r\n                IMAGESTACK_ERROR(tr(\"error opening TIFF file (camera 1) '%1'!\").arg(TIFFFIlenameBackground1));\r\n            }\r\n\r\n            for (int i=0; i<TIFFFIlename1.size(); i++) {\r\n                QDir().mkpath(QFileInfo(TIFFFIlename1[i].toLatin1().data()).absolutePath());\r\n                tiff1[i]=TIFFOpen(TIFFFIlename1[i].toLatin1().data(), \"w\");\r\n                if (!tiff1[i]) {\r\n                    ok=false;\r\n                    IMAGESTACK_ERROR(tr(\"error opening TIFF file (camera 1) '%1'!\").arg(TIFFFIlename1[i]));\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (ok && useCam2) {\r\n            QDir().mkpath(QFileInfo(TIFFFIlenameBackground2.toLatin1().data()).absolutePath());\r\n            tiff2_background=TIFFOpen(TIFFFIlenameBackground2.toLatin1().data(), \"w\");;\r\n            if (!tiff2_background) {\r\n                ok=false;\r\n                IMAGESTACK_ERROR(tr(\"error opening TIFF file (camera 2) '%1'!\").arg(TIFFFIlenameBackground2));\r\n            }\r\n            for (int i=0; i<TIFFFIlename2.size(); i++) {\r\n                QDir().mkpath(QFileInfo(TIFFFIlename2[i].toLatin1().data()).absolutePath());\r\n                tiff2[i]=TIFFOpen(TIFFFIlename2[i].toLatin1().data(), \"w\");\r\n                if (!tiff2[i]) {\r\n                    ok=false;\r\n                    IMAGESTACK_ERROR(tr(\"error opening TIFF file (camera 2) '%1'!\").arg(TIFFFIlename2[i]));\r\n                }\r\n            }\r\n        }\r\n\r\n        progress.setLabelText(tr(\"switching main shutter on ...\"));\r\n\r\n\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        // switch off light\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        bool formerMainShutterState=opticsSetup->getMainIlluminationShutter();\r\n        if (opticsSetup->isMainIlluminationShutterAvailable()){\r\n            log->log_text(tr(\"  - switch main shutter off for background frames!\\n\"));\r\n            opticsSetup->setMainIlluminationShutter(false, true);\r\n        }\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        // acquire backrgound images\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n            log->log_text(tr(\"  - acquiring background images ...\\n\"));\r\n\r\n            if (useCam1) {\r\n                if (ecamera1->acquireOnCamera(camera1, buffer1, NULL)) {\r\n                    TIFFTWriteUint16from32(tiff1_background, buffer1, width1, height1, false);\r\n                    log->log_text(tr(\"  - acquired overview image background from camera 1!\\n\"));\r\n                } else {\r\n                    ok=false;\r\n                    IMAGESTACK_ERROR(tr(\"error acquiring background image on camera 1!\\n\"));\r\n                }\r\n            }\r\n            //QApplication::processEvents();\r\n            if (useCam2) {\r\n                if (ecamera2->acquireOnCamera(camera2, buffer2, NULL)) {\r\n                    TIFFTWriteUint16from32(tiff2_background, buffer2, width2, height2, false);\r\n                    log->log_text(tr(\"  - acquired overview image background from camera 2!\\n\"));\r\n                } else {\r\n                    ok=false;\r\n                    IMAGESTACK_ERROR(tr(\"error acquiring background image on camera 2!\\n\"));\r\n                }\r\n            }\r\n\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        // switch on light\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        if (opticsSetup->isMainIlluminationShutterAvailable()){\r\n            log->log_text(tr(\"  - switch main shutter on!\\n\"));\r\n            opticsSetup->setMainIlluminationShutter(true, true);\r\n        }\r\n\r\n\r\n        if (progress.wasCanceled()) {\r\n            log->log_warning(tr(\"canceled by user!\\n\"));\r\n            ok=false;\r\n        }\r\n\r\n\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        // CALCULATE A LIST WITH ALL POSITIONS TO MOVE TO\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        progress.setLabelText(tr(\"preparing list of stage positions ...\"));\r\n        double stageStart=stackStart();\r\n        double stageDelta=stackDelta();\r\n        int stageCount=stackCount();\r\n\r\n        double stageStart2=stackStart2();\r\n        double stageDelta2=stackDelta2();\r\n        int stageCount2=stackCount2();\r\n        bool stageReturn2=stage2Cycling();\r\n\r\n        double stageStart3=stackStart3();\r\n        double stageDelta3=stackDelta3();\r\n        int stageCount3=stackCount3();\r\n        bool stageReturn3=stage3Cycling();\r\n\r\n        QList<QTriple<double, double, double> > moveTo;\r\n\r\n        if (axisCount==1) {\r\n            double pos=stageStart;\r\n            for (int x=0; x<stageCount; x++) {\r\n                moveTo.append(qMakeTriple(pos, 0.0, 0.0));\r\n                pos=pos+stageDelta;\r\n            }\r\n        } else if (axisCount==2) {\r\n            double pos=stageStart;\r\n            double pos2=stageStart2;\r\n            for (int x=0; x<stageCount; x++) {\r\n                if (stageReturn2) pos2=stageStart2;\r\n                for (int y=0; y<stageCount2; y++) {\r\n                    moveTo.append(qMakeTriple(pos, pos2, 0.0));\r\n                    pos2=pos2+stageDelta2;\r\n                }\r\n                pos=pos+stageDelta;\r\n            }\r\n        } else if (axisCount==3) {\r\n            double pos=stageStart;\r\n            double pos2=stageStart2;\r\n            double pos3=stageStart3;\r\n            for (int x=0; x<stageCount; x++) {\r\n                if (stageReturn2) pos2=stageStart2;\r\n                for (int y=0; y<stageCount2; y++) {\r\n                    if (stageReturn3) pos3=stageStart3;\r\n                    for (int z=0; z<stageCount3; z++) {\r\n                        moveTo.append(qMakeTriple(pos, pos2, pos3));\r\n                        pos3=pos3+stageDelta3;\r\n                    }\r\n                    pos2=pos2+stageDelta2;\r\n                }\r\n                pos=pos+stageDelta;\r\n            }\r\n        }\r\n\r\n\r\n        int images=moveTo.size()*this->images()*lightpathList.size();\r\n\r\n\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        // ACQUIRE IMAGE, MOVE, ACQUIRE IMAGE, MOVE, ...\r\n        //    images are stored in TIFF files using libtiff and they are (possibly) downscaled to 16-bit\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        progress.nextItem();\r\n\r\n        QMap<QString, QVariant> acquisitionDescription, acquisitionDescription1, acquisitionDescription2;\r\n        QList<QVariant> positions, positions2, positions3;\r\n        QTime timAcquisition=QTime::currentTime();\r\n        QDateTime timStart;\r\n        QString estimation=\"\";\r\n        QString fps=\"\";\r\n        double duration=0;\r\n        if (ok) {\r\n            progress.setLabelText(tr(\"acquiring images ...\"));\r\n            bool running=ok;\r\n            //double newPos=stageStart;\r\n            int posIdx=0;\r\n            int imageIdx=0;\r\n            measured.append(opticsSetup->getMeasuredValues());\r\n            while (running && (posIdx<=moveTo.size())) {\r\n                double newPos=stageInitialPos;\r\n                double newPos2=stageInitialPos2;\r\n                double newPos3=stageInitialPos3;\r\n                if (posIdx<moveTo.size()) {\r\n                    newPos=moveTo[posIdx].first;\r\n                    newPos2=moveTo[posIdx].second;\r\n                    newPos3=moveTo[posIdx].third;\r\n                }\r\n                if (axisCount==1) {\r\n                    log->log_text(tr(\"  - moving to position %1 micron ...\").arg(newPos));\r\n                    stage->move(stageAxis, newPos);\r\n                    QTime t1;\r\n                    t1.start();\r\n                    while (stage->getAxisState(stageAxis)==QFExtensionLinearStage::Moving) {\r\n                        if (t1.elapsed()>PROCESS_EVENTS_TIMEOUT_MS) {\r\n                            progress.setLabelText(tr(\"moving stage to %1 microns (distance: %2) ...%3%4\").arg(newPos).arg(fabs(stage->getPosition(stageAxis)-newPos)).arg(estimation).arg(fps));\r\n                            QApplication::processEvents(QEventLoop::AllEvents, 2);\r\n                            if (progress.wasCanceled()) break;\r\n                            t1.start();\r\n                        }\r\n                    }\r\n\r\n                    // wait additional time-span after moving stages!\r\n                    QTime t;\r\n                    int DeltaT=qMin(5000,qMax(1,delay()));\r\n                    t.start();\r\n                    t1.start();\r\n                    while (t.elapsed()<DeltaT) {\r\n                        if (t1.elapsed()>PROCESS_EVENTS_TIMEOUT_MS)  {\r\n                            progress.setLabelText(tr(\"moving stage to %1 microns (distance: %2) ... waiting%3%4\").arg(newPos).arg(fabs(stage->getPosition(stageAxis)-newPos)).arg(estimation).arg(fps));\r\n                            QApplication::processEvents(QEventLoop::AllEvents, 2);\r\n                            if (progress.wasCanceled()) break;\r\n                            t1.start();\r\n                        }\r\n                    }\r\n                    if (ok) {\r\n                        if (stage->getAxisState(stageAxis)==QFExtensionLinearStage::Ready) {\r\n                            log->log_text(tr(\" OK\\n\"));\r\n                            positions.append(stage->getPosition(stageAxis));\r\n                        } else {\r\n                            IMAGESTACK_ERROR(tr(\"error moving to position %1 micron!\\n\").arg(newPos));\r\n                            ok=false;\r\n                        }\r\n                    }\r\n\r\n                } else if (axisCount==2) {\r\n                    log->log_text(tr(\"  - moving to position (%1, %2) micron ...\").arg(newPos).arg(newPos2));\r\n                    stage->move(stageAxis, newPos);\r\n                    stage2->move(stageAxis2, newPos2);\r\n                    QTime t1;\r\n                    t1.start();\r\n                    while (stage->getAxisState(stageAxis)==QFExtensionLinearStage::Moving || stage2->getAxisState(stageAxis2)==QFExtensionLinearStage::Moving) {\r\n                        if (t1.elapsed()>PROCESS_EVENTS_TIMEOUT_MS) {\r\n                            double dist=sqrt(qfSqr(stage->getPosition(stageAxis)-newPos)+qfSqr(stage2->getPosition(stageAxis2)-newPos2));\r\n                            progress.setLabelText(tr(\"moving stage to (%1, %2) microns (distance: %3) ...%4%5\").arg(newPos).arg(newPos2).arg(dist).arg(estimation).arg(fps));\r\n                            QApplication::processEvents(QEventLoop::AllEvents, 2);\r\n                            if (progress.wasCanceled()) break;\r\n                            t1.start();\r\n                        }\r\n                    }\r\n\r\n                    // wait additional time-span after moving stages!\r\n                    QTime t;\r\n                    int DeltaT=qMin(5000,qMax(1,delay()));\r\n                    t.start();\r\n                    t1.start();\r\n                    while (t.elapsed()<DeltaT) {\r\n                        if (t1.elapsed()>PROCESS_EVENTS_TIMEOUT_MS) {\r\n                            double dist=sqrt(qfSqr(stage->getPosition(stageAxis)-newPos)+qfSqr(stage2->getPosition(stageAxis2)-newPos2));\r\n                            progress.setLabelText(tr(\"moving stage to (%1, %2) microns (distance: %3) ... waiting%4%5\").arg(newPos).arg(newPos2).arg(dist).arg(estimation).arg(fps));\r\n                            QApplication::processEvents(QEventLoop::AllEvents, 2);\r\n                            if (progress.wasCanceled()) break;\r\n                            t1.start();\r\n                        }\r\n                    }\r\n                    if (ok) {\r\n                        if (stage->getAxisState(stageAxis)==QFExtensionLinearStage::Ready && stage2->getAxisState(stageAxis2)==QFExtensionLinearStage::Ready) {\r\n                            log->log_text(tr(\" OK\\n\"));\r\n                            positions.append(stage->getPosition(stageAxis));\r\n                            positions2.append(stage2->getPosition(stageAxis2));\r\n                        } else {\r\n                            IMAGESTACK_ERROR(tr(\"error moving to position (%1, %2) micron!\\n\").arg(newPos).arg(newPos2));\r\n                            ok=false;\r\n                        }\r\n                    }\r\n                } else if (axisCount==3) {\r\n                    log->log_text(tr(\"  - moving to position (%1, %2, %3) micron ...\").arg(newPos).arg(newPos2).arg(newPos3));\r\n                    stage->move(stageAxis, newPos);\r\n                    stage2->move(stageAxis2, newPos2);\r\n                    stage3->move(stageAxis3, newPos3);\r\n                    QTime t1;\r\n                    t1.start();\r\n                    while (stage->getAxisState(stageAxis)==QFExtensionLinearStage::Moving || stage2->getAxisState(stageAxis2)==QFExtensionLinearStage::Moving || stage3->getAxisState(stageAxis3)==QFExtensionLinearStage::Moving) {\r\n                        if (t1.elapsed()>PROCESS_EVENTS_TIMEOUT_MS) {\r\n                            double dist=sqrt(qfSqr(stage->getPosition(stageAxis)-newPos) + qfSqr(stage2->getPosition(stageAxis2)-newPos2) + qfSqr(stage3->getPosition(stageAxis3)-newPos3));\r\n                            progress.setLabelText(tr(\"moving stage to (%1, %2, %3) microns (distance: %4) ...%5%6\").arg(newPos).arg(newPos2).arg(newPos3).arg(dist).arg(estimation).arg(fps));\r\n                            QApplication::processEvents(QEventLoop::AllEvents, 2);\r\n                            if (progress.wasCanceled()) break;\r\n                            t1.start();\r\n                        }\r\n                    }\r\n\r\n                    // wait additional time-span after moving stages!\r\n                    QTime t;\r\n                    int DeltaT=qMin(5000,qMax(1,delay()));\r\n                    t.start();\r\n                    t1.start();\r\n                    while (t.elapsed()<DeltaT) {\r\n                        if (t1.elapsed()>PROCESS_EVENTS_TIMEOUT_MS) {\r\n                            double dist=sqrt(qfSqr(stage->getPosition(stageAxis)-newPos) + qfSqr(stage2->getPosition(stageAxis2)-newPos2) + qfSqr(stage3->getPosition(stageAxis3)-newPos3));\r\n                            progress.setLabelText(tr(\"moving stage to (%1, %2, %3) microns (distance: %4) ... waiting%5%6\").arg(newPos).arg(newPos2).arg(newPos3).arg(dist).arg(estimation).arg(fps));\r\n                            QApplication::processEvents(QEventLoop::AllEvents, 2);\r\n                            if (progress.wasCanceled()) break;\r\n                            t1.start();\r\n                        }\r\n                    }\r\n                    if (ok) {\r\n                        if (stage->getAxisState(stageAxis)==QFExtensionLinearStage::Ready && stage2->getAxisState(stageAxis2)==QFExtensionLinearStage::Ready && stage3->getAxisState(stageAxis3)==QFExtensionLinearStage::Ready) {\r\n                            log->log_text(tr(\" OK\\n\"));\r\n                            positions.append(stage->getPosition(stageAxis));\r\n                            positions2.append(stage2->getPosition(stageAxis2));\r\n                            positions3.append(stage3->getPosition(stageAxis3));\r\n                        } else {\r\n                            IMAGESTACK_ERROR(tr(\"error moving to position (%1, %2, %3) micron!\\n\").arg(newPos).arg(newPos2).arg(newPos3));\r\n                            ok=false;\r\n                        }\r\n                    }\r\n                }\r\n\r\n\r\n                QApplication::processEvents(QEventLoop::AllEvents, 2);\r\n                if (posIdx<moveTo.size()) {\r\n                    if (progress.wasCanceled()) {\r\n                        running=false;\r\n                        log->log_warning(tr(\"  - acquisition canceled by user!\\n\"));\r\n                    } else {\r\n                        if (saveMeasurements()) measured.append(opticsSetup->getMeasuredValues());\r\n                        for (int lp=0; lp<lightpathList.size(); lp++) {\r\n                            if (lightpathList.size()>1 || lp==0) {\r\n                                if (!lightpathList[lp].isEmpty() && QFile::exists(lightpathList[lp])) {\r\n                                    log->log_text(tr(\"  - setting lightpath '%1' (%2) ...\").arg(lightpathNames[lp]).arg(lp));\r\n                                    opticsSetup->loadLightpathConfig(lightpathList[lp], true);\r\n                                    log->log_text(tr(\" DONE\\n\"));\r\n                                }\r\n                                if (posIdx<=0) {\r\n                                    opticsSetup->saveLightpathConfig(acquisitionDescription, lightpathNames[lp], QString(\"lightpath%1/\").arg(lp+1), QList<bool>(), true);\r\n                                }\r\n                            }\r\n                            for (int img=0; img<this->images(); img++) {\r\n                                            log->log_text(tr(\"  - acquiring images (%1/%2) ...\\n\").arg(imageIdx+1).arg(images));\r\n                                            if (posIdx>3) {\r\n                                                double duration=double(timAcquisition.elapsed())/1000.0;\r\n                                                double eta=duration/double(posIdx+1.0)*double(moveTo.size());\r\n                                                double etc=eta-duration;\r\n                                    uint mini=floor(etc/60.0);\r\n                                    uint secs=round(etc-double(mini)*60.0);\r\n                                    estimation=tr(\"\\nest. remaining duration (min:secs): %1:%2 \").arg(mini, 2, 10, QChar('0')).arg(secs, 2, 10, QChar('0'));\r\n\r\n                                    fps=tr(\"\\nacquisition rate: %1fps\").arg(double(imageIdx+1)/duration, 0, 'f', 2);\r\n                                }\r\n                                progress.setLabelText(tr(\"acquiring images (%1/%2) ...%3%4\").arg(imageIdx+1).arg(images).arg(estimation).arg(fps));\r\n                                QApplication::processEvents(QEventLoop::AllEvents, 2);\r\n                                if (progress.wasCanceled()) {\r\n                                    running=false;\r\n                                    log->log_warning(tr(\"  - acquisition canceled by user!\\n\"));\r\n                                    break;\r\n                                }\r\n                                if (posIdx==0) {\r\n                                    timAcquisition.start();\r\n                                    timStart=QDateTime::currentDateTime();\r\n                                }\r\n                                uint64_t timestampDummy=0;\r\n                                if (useCam1) {\r\n                                    if (ecamera1->acquireOnCamera(camera1, buffer1, NULL, &acquisitionDescription1)) {\r\n                                        TIFFTWriteUint16from32(tiff1[lp], buffer1, width1, height1, false);\r\n                                        TIFFWriteDirectory(tiff1[lp]);\r\n                                    } else {\r\n                                        ok=false;\r\n                                        IMAGESTACK_ERROR(tr(\"error acquiring image %1/%2 on camera 1!\\n\").arg(imageIdx+1).arg(images));\r\n                                    }\r\n                                }\r\n                                //QApplication::processEvents();\r\n                                if (useCam2) {\r\n                                    if (ecamera2->acquireOnCamera(camera2, buffer2, NULL, &acquisitionDescription2)) {\r\n                                        TIFFTWriteUint16from32(tiff2[lp], buffer2, width2, height2, false);\r\n                                        TIFFWriteDirectory(tiff2[lp]);\r\n                                    } else {\r\n                                        ok=false;\r\n                                        IMAGESTACK_ERROR(tr(\"error acquiring image %1/%2 on camera 2!\\n\").arg(imageIdx+1).arg(images));\r\n                                    }\r\n                                }\r\n                                imageIdx++;\r\n\r\n                            }\r\n                        }\r\n\r\n                        //QApplication::processEvents();\r\n                    }\r\n                }\r\n                if (!ok) running=false;\r\n\r\n                posIdx++;\r\n                newPos+=stageDelta;\r\n                progress.setValue((int)round((double)posIdx/(double)moveTo.size()*100.0));\r\n                QApplication::processEvents(QEventLoop::AllEvents, 10);\r\n                if (progress.wasCanceled()) {\r\n                    break;\r\n                }\r\n            }\r\n            duration=timAcquisition.elapsed()/1000.0;\r\n        }\r\n        progress.setValue(100);\r\n        if (saveMeasurements()) measured.append(opticsSetup->getMeasuredValues());\r\n\r\n        progress.nextItem();\r\n        progress.setProgressText(tr(\"switching main shutter off ...\"));\r\n\r\n\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        // switch on/off light\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        if (opticsSetup->isMainIlluminationShutterAvailable()){\r\n            log->log_text(tr(\"  - switch main shutter %1!\\n\").arg((formerMainShutterState)?tr(\"on\"):tr(\"off\")));\r\n            opticsSetup->setMainIlluminationShutter(formerMainShutterState, true);\r\n        }\r\n\r\n\r\n        progress.setProgressText(tr(\"closing TIF files ...\"));\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        // close tiff files and free buffers\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        progress.setLabelText(tr(\"closing output files ...\"));\r\n        QApplication::processEvents();\r\n        if (tiff1_background) TIFFClose(tiff1_background);\r\n        if (tiff2_background) TIFFClose(tiff2_background);\r\n\r\n        for (int lp=0; lp<tiff1.size(); lp++) if (tiff1[lp]) TIFFClose(tiff1[lp]);\r\n        for (int lp=0; lp<tiff2.size(); lp++) if (tiff2[lp]) TIFFClose(tiff2[lp]);\r\n        tiff1.clear();\r\n        tiff2.clear();\r\n        if (buffer1) qfFree(buffer1);\r\n        if (buffer2) qfFree(buffer2);\r\n        buffer1=buffer2=NULL;\r\n\r\n        progress.setProgressText(tr(\"collecting acquisition data ...\"));\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        // collect acquisition data common to all cameras\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        QString positionsCSV;\r\n        if (ok) {\r\n            acquisitionDescription[\"type\"]=\"stack 1 axis\";\r\n            acquisitionDescription[\"axis1/type\"]=\"other\";\r\n            if (opticsSetup->getStage(QFESPIMB040OpticsSetupBase::StageX)==stage && opticsSetup->getStageAxis(QFESPIMB040OpticsSetupBase::StageX)==stageAxis) acquisitionDescription[\"axis1/type\"]=\"x\";\r\n            if (opticsSetup->getStage(QFESPIMB040OpticsSetupBase::StageY)==stage && opticsSetup->getStageAxis(QFESPIMB040OpticsSetupBase::StageY)==stageAxis) acquisitionDescription[\"axis1/type\"]=\"y\";\r\n            if (opticsSetup->getStage(QFESPIMB040OpticsSetupBase::StageZ)==stage && opticsSetup->getStageAxis(QFESPIMB040OpticsSetupBase::StageZ)==stageAxis) acquisitionDescription[\"axis1/type\"]=\"z\";\r\n            acquisitionDescription[\"axis1/stage_name\"]=stageExtension()->getName();\r\n            acquisitionDescription[\"axis1/stage_axis\"]=stageAxis;\r\n            acquisitionDescription[\"axis1/stack_start\"]=stageStart;\r\n            acquisitionDescription[\"axis1/stack_delta\"]=stageDelta;\r\n            acquisitionDescription[\"axis1/stack_count\"]=stageCount;\r\n            acquisitionDescription[\"sequence_overall_length\"]=images;\r\n            acquisitionDescription[\"images_per_position\"]=this->images();\r\n            acquisitionDescription[\"lightpath_count\"]=lightpathList.count();\r\n            acquisitionDescription[\"lightpaths\"]=lightpathNames;\r\n            acquisitionDescription[\"start_time\"]=timStart;\r\n            acquisitionDescription[\"duration\"]=duration;\r\n            acquisitionDescription[\"stack_positions\"]=positions;\r\n            if (useStage2() && useStage3()) {\r\n                acquisitionDescription[\"type\"]=\"stack 3 axis\";\r\n                acquisitionDescription[\"axis2/stack_positions\"]=positions2;\r\n                acquisitionDescription[\"axis3/stack_positions\"]=positions3;\r\n            } else if (useStage2() && !useStage3()) {\r\n                acquisitionDescription[\"type\"]=\"stack 2 axis\";\r\n                acquisitionDescription[\"axis1/stack_positions\"]=positions2;\r\n            }\r\n\r\n            if (useStage2()) {\r\n                acquisitionDescription[\"axis2/type\"]=\"other\";\r\n                if (opticsSetup->getStage(QFESPIMB040OpticsSetupBase::StageX)==stage2 && opticsSetup->getStageAxis(QFESPIMB040OpticsSetupBase::StageX)==stageAxis2) acquisitionDescription[\"axis2/type\"]=\"x\";\r\n                if (opticsSetup->getStage(QFESPIMB040OpticsSetupBase::StageY)==stage2 && opticsSetup->getStageAxis(QFESPIMB040OpticsSetupBase::StageY)==stageAxis2) acquisitionDescription[\"axis2/type\"]=\"y\";\r\n                if (opticsSetup->getStage(QFESPIMB040OpticsSetupBase::StageZ)==stage2 && opticsSetup->getStageAxis(QFESPIMB040OpticsSetupBase::StageZ)==stageAxis2) acquisitionDescription[\"axis2/type\"]=\"z\";\r\n                acquisitionDescription[\"axis2/stage_name\"]=stageExtension2()->getName();\r\n                acquisitionDescription[\"axis2/stage_axis\"]=stageAxis2;\r\n                acquisitionDescription[\"axis2/stack_start\"]=stageStart2;\r\n                acquisitionDescription[\"axis2/stack_delta\"]=stageDelta2;\r\n                acquisitionDescription[\"axis2/stack_count\"]=stageCount2;\r\n            }\r\n\r\n            if (useStage3()) {\r\n                acquisitionDescription[\"axis3/type\"]=\"other\";\r\n                if (opticsSetup->getStage(QFESPIMB040OpticsSetupBase::StageX)==stage3 && opticsSetup->getStageAxis(QFESPIMB040OpticsSetupBase::StageX)==stageAxis3) acquisitionDescription[\"axis3/type\"]=\"x\";\r\n                if (opticsSetup->getStage(QFESPIMB040OpticsSetupBase::StageY)==stage3 && opticsSetup->getStageAxis(QFESPIMB040OpticsSetupBase::StageY)==stageAxis3) acquisitionDescription[\"axis3/type\"]=\"y\";\r\n                if (opticsSetup->getStage(QFESPIMB040OpticsSetupBase::StageZ)==stage3 && opticsSetup->getStageAxis(QFESPIMB040OpticsSetupBase::StageZ)==stageAxis3) acquisitionDescription[\"axis3/type\"]=\"z\";\r\n                acquisitionDescription[\"axis3/stage_name\"]=stageExtension3()->getName();\r\n                acquisitionDescription[\"axis3/stage_axis\"]=stageAxis3;\r\n                acquisitionDescription[\"axis3/stack_start\"]=stageStart3;\r\n                acquisitionDescription[\"axis3/stack_delta\"]=stageDelta3;\r\n                acquisitionDescription[\"axis3/stack_count\"]=stageCount3;\r\n            }\r\n\r\n\r\n            QTextStream pf(&positionsCSV);\r\n            if (axisCount==3) {\r\n                pf<<\"# number, position 1[micrometer], position 2 [micrometer], position 3 [micrometer], ideal position 1 [micrometer], ideal position 2 [micrometer], ideal position 3 [micrometer] \\n\";\r\n                for (int i=0; i<qMin(positions.size(), moveTo.size()); i++) {\r\n                    pf<<i<<\", \"<<CDoubleToQString(positions[i].toDouble())<<\", \"<<CDoubleToQString(positions2[i].toDouble())<<\", \"<<CDoubleToQString(positions3[i].toDouble())<<\", \"<<CDoubleToQString(moveTo[i].first)<<\", \"<<CDoubleToQString(moveTo[i].second)<<\", \"<<CDoubleToQString(moveTo[i].third)<<\"\\n\";\r\n                }\r\n            } else if (axisCount==2) {\r\n                pf<<\"# number, position 1[micrometer], position 2 [micrometer], ideal position 1 [micrometer], ideal position 2 [micrometer] \\n\";\r\n                for (int i=0; i<qMin(positions.size(), moveTo.size()); i++) {\r\n                    pf<<i<<\", \"<<CDoubleToQString(positions[i].toDouble())<<\", \"<<CDoubleToQString(positions2[i].toDouble())<<\", \"<<CDoubleToQString(moveTo[i].first)<<\", \"<<CDoubleToQString(moveTo[i].second)<<\"\\n\";\r\n                }\r\n            } else if (axisCount==1) {\r\n                pf<<\"# number, position 1[micrometer], ideal position 1 [micrometer] \\n\";\r\n                for (int i=0; i<qMin(positions.size(), moveTo.size()); i++) {\r\n                    pf<<i<<\", \"<<CDoubleToQString(positions[i].toDouble())<<\", \"<<CDoubleToQString(moveTo[i].first)<<\"\\n\";\r\n                }\r\n            }\r\n        }\r\n\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        // write image stack properties to files, also collects camera specific information\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        if (ok && useCam1) {\r\n            QMap<QString, QVariant> acquisitionDescription11=acquisitionDescription;\r\n            acquisitionDescription11=acquisitionDescription11.unite(acquisitionDescription1);\r\n            QList<QFExtensionCamera::CameraAcquititonFileDescription> files;\r\n            for (int lp=0; lp<TIFFFIlename1.size(); lp++) {\r\n                QFExtensionCamera::CameraAcquititonFileDescription d;\r\n                d.name=TIFFFIlename1[lp];\r\n                d.description=\"image stack from camera 1, lightpath \"+QString(lp+1)+\" '\"+lightpathNames[lp]+\"'\";\r\n                d.type=\"TIFF16\";\r\n                files.append(d);\r\n            }\r\n\r\n\r\n            QString PositionsFilename=acquisitionPrefix1+\".positions.dat\";\r\n            QFile posFile(PositionsFilename);\r\n            if (posFile.open(QIODevice::WriteOnly)) {\r\n                posFile.write(positionsCSV.toLatin1().data());\r\n                posFile.close();\r\n                QFExtensionCamera::CameraAcquititonFileDescription d;\r\n                d.name=PositionsFilename;\r\n                d.description=\"positions of image stack from camera 1\";\r\n                d.type=\"CSV\";\r\n                files.append(d);\r\n            } else {\r\n                log->log_error(tr(\"  - could not write positions file '%1' for camera 1: %2 ...\").arg(PositionsFilename).arg(posFile.errorString()));\r\n            }\r\n\r\n            QString MeasurementsFilename=acqTools->saveMeasuredData(acquisitionPrefix1, measured);\r\n            if (!MeasurementsFilename.isEmpty() && QFile::exists(MeasurementsFilename)) {\r\n                QFExtensionCamera::CameraAcquititonFileDescription d;\r\n                d.name=MeasurementsFilename;\r\n                d.description=\"measureable properties of setup\";\r\n                d.type=\"CSV\";\r\n                files.append(d);\r\n            }\r\n\r\n            if (useCam1){\r\n                QFExtensionCamera::CameraAcquititonFileDescription d;\r\n                d.name=TIFFFIlenameBackground1;\r\n                d.description=\"background frame from camera 1\";\r\n                d.type=\"TIFF16\";\r\n                files.append(d);\r\n            }\r\n            if (useCam2){\r\n                QFExtensionCamera::CameraAcquititonFileDescription d;\r\n                d.name=TIFFFIlenameBackground2;\r\n                d.description=\"background frame from camera 2\";\r\n                d.type=\"TIFF16\";\r\n                files.append(d);\r\n            }\r\n            log->log_text(tr(\"  - writing acquisition description 1 ...\"));\r\n            acqTools->savePreviewDescription(0, extension1, ecamera1, camera1, acquisitionPrefix1, acquisitionDescription11, files, startDateTime);\r\n            log->log_text(tr(\" DONE!\\n\"));\r\n        }\r\n        if (ok && useCam2) {\r\n            QMap<QString, QVariant> acquisitionDescription22=acquisitionDescription;\r\n            acquisitionDescription22=acquisitionDescription22.unite(acquisitionDescription2);\r\n            QList<QFExtensionCamera::CameraAcquititonFileDescription> files;\r\n            for (int lp=0; lp<TIFFFIlename1.size(); lp++) {\r\n                QFExtensionCamera::CameraAcquititonFileDescription d;\r\n                d.name=TIFFFIlename2[lp];\r\n                d.description=\"image stack from camera 2, lightpath \"+QString(lp+1)+\" '\"+lightpathNames[lp]+\"'\";\r\n                d.type=\"TIFF16\";\r\n                files.append(d);\r\n            }\r\n\r\n\r\n            QString PositionsFilename=acquisitionPrefix2+\".positions.dat\";\r\n            QFile posFile(PositionsFilename);\r\n            if (posFile.open(QIODevice::WriteOnly)) {\r\n                posFile.write(positionsCSV.toLatin1().data());\r\n                posFile.close();\r\n                QFExtensionCamera::CameraAcquititonFileDescription d;\r\n                d.name=PositionsFilename;\r\n                d.description=\"positions of image stack from camera 1\";\r\n                d.type=\"CSV\";\r\n                files.append(d);\r\n            } else {\r\n                log->log_error(tr(\"  - could not write positions file '%1' for camera 2: %2 ...\").arg(PositionsFilename).arg(posFile.errorString()));\r\n            }\r\n\r\n            QString MeasurementsFilename=acqTools->saveMeasuredData(acquisitionPrefix2, measured);\r\n            if (!MeasurementsFilename.isEmpty() && QFile::exists(MeasurementsFilename)) {\r\n                QFExtensionCamera::CameraAcquititonFileDescription d;\r\n                d.name=MeasurementsFilename;\r\n                d.description=\"measureable properties of setup\";\r\n                d.type=\"CSV\";\r\n                files.append(d);\r\n            }\r\n\r\n            log->log_text(tr(\"  - writing acquisition description 2 ...\"));\r\n            acqTools->savePreviewDescription(1, extension2, ecamera2, camera2, acquisitionPrefix2, acquisitionDescription22, files, startDateTime);\r\n            log->log_text(tr(\" DONE!\\n\"));\r\n        }\r\n\r\n        progress.nextItem();\r\n        progress.setProgressText(tr(\"releasing cameras ...\"));\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        // release cameras\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        if (useCam1) {\r\n            opticsSetup->releaseCamera(0);\r\n            log->log_text(tr(\"  - released camera 1!\\n\"));\r\n        }\r\n        if (useCam2) {\r\n            opticsSetup->releaseCamera(1);\r\n            log->log_text(tr(\"  - released camera 2!\\n\"));\r\n        }\r\n\r\n        if (ok && useCam1) log->log_text(tr(\"  - stored files with prefix 1: '%1'\\n\").arg(acquisitionPrefix1));\r\n        if (ok && useCam2) log->log_text(tr(\"  - stored files with prefix 2: '%1'\\n\").arg(acquisitionPrefix2));\r\n\r\n        if (ok) log->log_text(tr(\"image stack acquisition DONE!\\n\"));\r\n    }\r\n    progress.setProgressText(tr(\"releasing stages and lightpath ...\"));\r\n    opticsSetup->unlockStages();\r\n    opticsSetup->unlockLightpath();\r\n    opticsSetup->ensureLightpath();\r\n    progress.close();\r\n}",
    "void QFRDRImagingFCSCorrelationJobThread::run() {\r\n    QTime ptime;\r\n\r\n    ptime.start();\r\n\r\n    emit messageChanged(tr(\"loading data ...\"));\r\n    if ((job.fileFormat<0)||(job.fileFormat>=getImageReaderCount(pluginservices))) {\r\n        m_status=-1;\r\n        emit statusChanged(m_status);\r\n        emit messageChanged(tr(\"file format not supported or given ... format given was: %1\").arg(job.fileFormat));\r\n        emit rangeChanged(0,100);\r\n        emit progressChanged(0);\r\n    } else if (!QFile::exists(job.filename)) {\r\n        m_status=-1;\r\n        emit statusChanged(m_status);\r\n        emit messageChanged(tr(\"file does not exist ...\"));\r\n        emit rangeChanged(0,100);\r\n        emit progressChanged(0);\r\n    } else {\r\n        m_status=1;\r\n        emit statusChanged(m_status);\r\n        emit rangeChanged(0,3780+1000*job.DCCFDeltaX.size());\r\n\r\n\r\n        reader=NULL;\r\n        bool OK=false;\r\n        if (job.fileFormat>=0 && job.fileFormat<getImageReaderCount(pluginservices)) {\r\n            reader=getImageReader(job.fileFormat, pluginservices);\r\n        }\r\n        if (reader) {\r\n            emit messageChanged(tr(\"opening %1 file ...\").arg(reader->formatName()));\r\n            OK=reader->open(job.filename);\r\n            if (!OK) {\r\n                m_status=-1; emit statusChanged(m_status);\r\n                if (reader) messageChanged(tr(\"error opening file '%1': %2\").arg(job.filename).arg(reader->lastError()));\r\n                else emit messageChanged(tr(\"error opening file '%1'\").arg(job.filename));\r\n            } else {\r\n                emit progressIncrement(10);\r\n                emit messageChanged(tr(\"counting frames ...\"));\r\n                props=reader->getFileInfo().properties;\r\n                comment=reader->getFileInfo().comment;\r\n                reader->setBinning(job.binning);\r\n                reader->setInterleavedBinning(job.interleaved_binning);\r\n                reader->setAverageBinning(job.binAverage);\r\n                if (job.use_cropping) {\r\n                    reader->setCropping(job.crop_x0, job.crop_x1, job.crop_y0, job.crop_y1);\r\n                } else {\r\n                    reader->unsetCropping();\r\n                }\r\n                first_frame=0;\r\n                int32_t frame_count=reader->countFrames();\r\n                if (job.range_min>0 && job.range_min<frame_count) first_frame=job.range_min;\r\n                frames=frame_count-first_frame;\r\n                if (job.range_max>(int64_t)first_frame && job.range_max<frame_count) frames=job.range_max-first_frame;\r\n                double input_length=frames*job.frameTime;\r\n                if (frames>0) {\r\n                    frame_width=reader->frameWidth();\r\n                    frame_height=reader->frameHeight();\r\n                    average_frame=(float*)qfCalloc(frame_width*frame_height, sizeof(float));\r\n                    sqrsum_frame=(float*)qfCalloc(frame_width*frame_height, sizeof(float));\r\n                    average_uncorrected_frame=(float*)qfCalloc(frame_width*frame_height, sizeof(float));\r\n                    sqrsum_uncorrected_frame=(float*)qfCalloc(frame_width*frame_height, sizeof(float));\r\n\r\n                    baseline=job.backgroundOffset;\r\n\r\n                    acf_tau=NULL;\r\n                    acf=NULL;\r\n                    acf_std=NULL;\r\n                    acf_segments=NULL;\r\n                    acf_blocklevel=NULL;\r\n                    acf_blocksuccess=NULL;\r\n                    acf_N=0;\r\n                    dccf.clear();\r\n                    for (int id=0; id<job.DCCFDeltaX.size(); id++) {\r\n                        DCCFRecord rec;\r\n                        rec.dccf_tau=NULL;\r\n                        rec.dccf=NULL;\r\n                        rec.dccf_segments=NULL;\r\n                        rec.dccf_std=NULL;\r\n                        rec.dccf_N=0;\r\n                        rec.dccfframe_width=0;\r\n                        rec.dccfframe_height=0;\r\n                        rec.dccf_blocklevel=NULL;\r\n                        rec.dccf_blocksuccess=NULL;\r\n                        dccf.append(rec);\r\n                    }\r\n                    lastFrames=NULL;\r\n                    firstFrames=NULL;\r\n                    bleachAmplitude=NULL;\r\n                    bleachTime=NULL;\r\n                    bleachPoly2=NULL;\r\n                    bleachPoly3=NULL;\r\n                    fit_frames=NULL;\r\n                    fit_t=NULL;\r\n                    NFitFrames=0;\r\n\r\n                    video_count=floor(frames/job.video_frames);\r\n                    real_video_count=video_count;\r\n                    video=(float*)qfCalloc(frame_width*frame_height*video_count, sizeof(float));\r\n                    video_uncorrected=(float*)qfCalloc(frame_width*frame_height*video_count, sizeof(float));\r\n                    bleachAmplitude=(float*)qfCalloc(frame_width*frame_height, sizeof(float));\r\n                    bleachTime=(float*)qfCalloc(frame_width*frame_height, sizeof(float));\r\n                    bleachAmplitude2=(float*)qfCalloc(frame_width*frame_height, sizeof(float));\r\n                    bleachTime2=(float*)qfCalloc(frame_width*frame_height, sizeof(float));\r\n                    bleachPoly2=(float*)qfCalloc(frame_width*frame_height, sizeof(float));\r\n                    bleachPoly3=(float*)qfCalloc(frame_width*frame_height, sizeof(float));\r\n                    bleachPoly4=(float*)qfCalloc(frame_width*frame_height, sizeof(float));\r\n                    bleachPoly5=(float*)qfCalloc(frame_width*frame_height, sizeof(float));\r\n                    bleachFitOK=(uint8_t*)qfCalloc(frame_width*frame_height, sizeof(uint8_t));\r\n                    bleachPercentage=(float*)qfCalloc(frame_width*frame_height, sizeof(float));\r\n                    firstFrames=(float*)qfCalloc(frame_width*frame_height,sizeof(float));\r\n                    //firstFrames=(float*)qfCalloc(frame_width*frame_height, sizeof(float));\r\n                    //lastFrames=(float*)qfCalloc(frame_width*frame_height, sizeof(float));\r\n\r\n                    ////////////////////////////////////////////////////////////////////////////////////////////\r\n                    // CREATE FILENAMES FOR RESULTS AND MAKE SURE THE DIRECTORY FOR THE FILES EXISTS (mkpath() )\r\n                    ////////////////////////////////////////////////////////////////////////////////////////////\r\n                    QDir d=QFileInfo(job.filename).dir();\r\n\r\n                    if (mutexFilename) mutexFilename->lock();\r\n                    int counter=-1;\r\n                    do {\r\n                        outputFilenameBase=d.absoluteFilePath(replacePostfixSpecials(job.prefix)+QFileInfo(job.filename).completeBaseName()+replacePostfixSpecials(job.postfix, counter));\r\n                        counter++;\r\n                    } while (QFile::exists(outputFilenameBase+\".evalsettings.txt\"));\r\n                    //qDebug()<<outputFilenameBase;\r\n                    QString configFilename=outputFilenameBase+\".evalsettings.txt\";\r\n                    QString averageFilename=\"\";\r\n                    QString stdFilename=\"\";\r\n                    QString averageUncorrectedFilename=\"\";\r\n                    QString stdUncorrectedFilename=\"\";\r\n                    QString backstdFilename=\"\";\r\n                    QString averageFilenameF=\"\";\r\n                    QString backgroundFilename=\"\";\r\n                    QString videoFilename=\"\";\r\n                    QString videoUncorrectedFilename=\"\";\r\n                    QString statisticsFilename=\"\";\r\n                    QString statisticsFilename_dv1=\"\";\r\n                    QString statisticsFilename_dv2=\"\";\r\n                    QString uncorrectedStatisticsFilename=\"\";\r\n                    QString uncorrectedStatisticsFilename_dv1=\"\";\r\n                    QString uncorrectedStatisticsFilename_dv2=\"\";\r\n                    QString backstatisticsFilename=\"\";\r\n                    QString backstatisticsFilename_dv1=\"\";\r\n                    QString backstatisticsFilename_dv2=\"\";\r\n                    QString acfFilename=\"\";\r\n                    QStringList dccfFilename;\r\n                    QString acfFilenameBin=\"\";\r\n                    QStringList dccfFilenameBin;\r\n                    QString bleachAmplitudeFilename=\"\";\r\n                    QString bleachPercentageFilename=\"\";\r\n                    QString bleachTimeFilename=\"\";\r\n                    QString bleachAmplitude2Filename=\"\";\r\n                    QString bleachTime2Filename=\"\";\r\n                    QString bleachFitSuccessFilename=\"\";\r\n                    QString bleachPoly2Filename=\"\";\r\n                    QString bleachPoly3Filename=\"\";\r\n                    QString bleachPoly4Filename=\"\";\r\n                    QString bleachPoly5Filename=\"\";\r\n                    QString firstFramesFilename=\"\";\r\n                    QString lastFramesFilename=\"\";\r\n                    QString bleachtimesFilename=\"\";\r\n                    QString bleachframesFilename=\"\";\r\n                    QString acfBlockLevelFilename;\r\n                    QString acfBlockSuccessFilename;\r\n                    QStringList dccfBlockLevelFilename;\r\n                    QStringList dccfBlockSuccessFilename;\r\n                    QString localFileDirectory=QFileInfo(d.absoluteFilePath(configFilename)).dir().absolutePath();\r\n\r\n                    if (d.mkpath(localFileDirectory)) {\r\n                        ////////////////////////////////////////////////////////////////////////////////////////////\r\n                        // TOUCH OUTPUT FILE (.evalsettings.txt)\r\n                        ////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n                        touchFile(configFilename);\r\n\r\n                        if (mutexFilename) mutexFilename->unlock();\r\n\r\n\r\n\r\n\r\n                        ////////////////////////////////////////////////////////////////////////////////////////////\r\n                        // RUN THE CORRELATION\r\n                        ////////////////////////////////////////////////////////////////////////////////////////////\r\n                        if (job.correlator==CORRELATOR_MTAUALLMON || job.correlator==CORRELATOR_MTAUONEMON) {\r\n                            correlate_loadsingle();\r\n                        } else {\r\n                            correlate_loadall();\r\n                        }\r\n                        reader->close();\r\n\r\n\r\n\r\n\r\n                        ////////////////////////////////////////////////////////////////////////////////////////////\r\n                        // SAVE THE RESULTS\r\n                        ////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n                        //************** SAVE OVERVIEW IMAGE\r\n                        if ((m_status==1) && !was_canceled && average_frame) {\r\n                            emit messageChanged(tr(\"saving overview image ...\"));\r\n                            QString localFilename=averageFilename=outputFilenameBase+\".overview.tif\";\r\n                            QString error=\"\";\r\n                            if (!SaveTIFFUInt16_scaled(localFilename, average_frame, frame_width, frame_height, tr(\"UInt16 overview image\"), &error)) {\r\n                                m_status=-1; emit statusChanged(m_status);\r\n                                averageFilename=\"\";\r\n                                emit messageChanged(error);\r\n                            }\r\n\r\n                            localFilename=averageFilenameF=outputFilenameBase+\".overview_float.tif\";\r\n                            if (!SaveTIFFFloat(localFilename, average_frame, frame_width, frame_height, tr(\"float overview image\"), &error)) {\r\n                                m_status=-1; emit statusChanged(m_status);\r\n                                averageFilenameF=\"\";\r\n                                emit messageChanged(error);\r\n                            }\r\n\r\n                        }\r\n                        emit progressIncrement(5);\r\n\r\n                        //************** SAVE OVERVIEWSTD IMAGE\r\n                        if ((m_status==1) && !was_canceled && sqrsum_frame) {\r\n                            emit messageChanged(tr(\"saving overview stddev image ...\"));\r\n                            QString localFilename=stdFilename=outputFilenameBase+\".overviewstd.tif\";\r\n\r\n                            QString error=\"\";\r\n                            if (!SaveSDTIFF(localFilename, average_frame, sqrsum_frame, frame_width, frame_height, frames, tr(\"stddev overview image\"), &error)) {\r\n                                m_status=-1; emit statusChanged(m_status);\r\n                                stdFilename=\"\";\r\n                                emit messageChanged(error);\r\n                            }\r\n                        }\r\n                        emit progressIncrement(5);\r\n\r\n                        //************** SAVE UNCORRECTED OVERVIEW IMAGE\r\n                        if ((m_status==1) && !was_canceled && average_uncorrected_frame) {\r\n                            emit messageChanged(tr(\"saving uncorrected overview image ...\"));\r\n                            QString localFilename=averageUncorrectedFilename=outputFilenameBase+\".overview_uncorrected.tif\";\r\n\r\n                            QString error=\"\";\r\n                            if (!SaveTIFFFloat(localFilename, average_uncorrected_frame, frame_width, frame_height, tr(\"uncorrected overview image\"), &error)) {\r\n                                m_status=-1; emit statusChanged(m_status);\r\n                                averageUncorrectedFilename=\"\";\r\n                                emit messageChanged(error);\r\n                            }\r\n\r\n                        }\r\n                        emit progressIncrement(5);\r\n\r\n                        //************** SAVE UNCORRECTED OVERVIEWSTD IMAGE\r\n                        if ((m_status==1) && !was_canceled && sqrsum_uncorrected_frame && average_uncorrected_frame) {\r\n                            emit messageChanged(tr(\"saving uncorrected overview stddev image ...\"));\r\n                            QString localFilename=stdUncorrectedFilename=outputFilenameBase+\".overviewstd_uncorrected.tif\";\r\n\r\n                            QString error=\"\";\r\n                            if (!SaveSDTIFF(localFilename, average_uncorrected_frame, sqrsum_uncorrected_frame, frame_width, frame_height, frames, tr(\"uncorrected overview stddev image\"), &error)) {\r\n                                m_status=-1; emit statusChanged(m_status);\r\n                                stdUncorrectedFilename=\"\";\r\n                                emit messageChanged(error);\r\n                            }\r\n                        }\r\n                        emit progressIncrement(5);\r\n\r\n                        //************** SAVE BACKGROUND IMAGE\r\n                        if ((m_status==1) && !was_canceled && backgroundImage) {\r\n                            bool doSave=false;\r\n                            for (uint32_t i=0; i<frame_width*frame_height; i++) {\r\n                                if (backgroundImage[i]!=0) {\r\n                                    doSave=true;\r\n                                    break;\r\n                                }\r\n                            }\r\n                            if (doSave) {\r\n                                emit messageChanged(tr(\"saving background image ...\"));\r\n                                QString localFilename=backgroundFilename=outputFilenameBase+\".background.tif\";\r\n\r\n                                QString error=\"\";\r\n                                if (!SaveTIFFFloat(localFilename, backgroundImage, frame_width, frame_height, tr(\"background image\"), &error)) {\r\n                                    m_status=-1; emit statusChanged(m_status);\r\n                                    backgroundFilename=\"\";\r\n                                    emit messageChanged(error);\r\n                                }\r\n\r\n                            }\r\n\r\n                        }\r\n                        //************** SAVE BACKGROUND STDDEV IMAGE\r\n                        if ((m_status==1) && !was_canceled && backgroundImageStd) {\r\n                            bool doSave=false;\r\n                            for (uint32_t i=0; i<frame_width*frame_height; i++) {\r\n                                if (backgroundImageStd[i]!=0) {\r\n                                    doSave=true;\r\n                                    break;\r\n                                }\r\n                            }\r\n                            if (doSave) {\r\n                                emit messageChanged(tr(\"saving background S.D. image ...\"));\r\n                                QString localFilename=backstdFilename=outputFilenameBase+\".backgroundstd.tif\";\r\n\r\n                                QString error=\"\";\r\n                                if (!SaveTIFFFloat(localFilename, backgroundImageStd, frame_width, frame_height, tr(\"background S.D. image\"), &error)) {\r\n                                    m_status=-1; emit statusChanged(m_status);\r\n                                    backstdFilename=\"\";\r\n                                    emit messageChanged(error);\r\n                                }\r\n                            }\r\n                        }\r\n                        emit progressIncrement(10);\r\n\r\n                        if ((m_status==1) && !was_canceled && firstFrames && lastFrames) {\r\n                            QString localFilename=bleachPercentageFilename=outputFilenameBase+\".bleachpercentage.tif\";\r\n                            QString error=\"\";\r\n                            for (uint32_t i=0; i<frame_width*frame_height; i++) {\r\n                                bleachPercentage[i]=(firstFrames[i]-lastFrames[i])/(firstFrames[i])*100.0;\r\n                            }\r\n                            if (!SaveTIFFFloat(localFilename, bleachPercentage, frame_width, frame_height, tr(\"bleach percentage image\"), &error)) {\r\n                                m_status=-1; emit statusChanged(m_status);\r\n                                bleachPercentageFilename=\"\";\r\n                                emit messageChanged(error);\r\n                            }\r\n                        }\r\n\r\n                        //************** SAVE BLEACHING PARAMETERS IMAGE\r\n                        if ((m_status==1) && !was_canceled ) {\r\n                            if (job.bleach==BLEACH_EXP || job.bleach==BLEACH_EXP_POLY2 || job.bleach==BLEACH_EXP_POLY3  || job.bleach==BLEACH_EXP_POLY4 || job.bleach==BLEACH_EXP_POLY5  || job.bleach==BLEACH_DBL_EXP || job.bleach==BLEACH_EXPREG) {\r\n                                emit messageChanged(tr(\"saving bleach parameter images ...\"));\r\n                                QString localFilename;\r\n                                TIFF* tif;\r\n                                bool error=false;\r\n\r\n                                localFilename=bleachAmplitudeFilename=outputFilenameBase+\".bleachamplitude.tif\";\r\n                                tif = TIFFOpen(localFilename.toLatin1().data(),\"w\");\r\n                                if (tif) {\r\n                                    TIFFTWriteFloat(tif, bleachAmplitude, frame_width, frame_height);\r\n                                    TIFFClose(tif);\r\n                                } else error=true;\r\n\r\n                                localFilename=bleachTimeFilename=outputFilenameBase+\".bleachtime.tif\";\r\n                                tif = TIFFOpen(localFilename.toLatin1().data(),\"w\");\r\n                                if (tif) {\r\n                                    TIFFTWriteFloat(tif, bleachTime, frame_width, frame_height);\r\n                                    TIFFClose(tif);\r\n                                } else error=true;\r\n\r\n                                if (job.bleach==BLEACH_DBL_EXP) {\r\n                                    localFilename=bleachAmplitude2Filename=outputFilenameBase+\".bleachamplitude2.tif\";\r\n                                    tif = TIFFOpen(localFilename.toLatin1().data(),\"w\");\r\n                                    if (tif) {\r\n                                        TIFFTWriteFloat(tif, bleachAmplitude2, frame_width, frame_height);\r\n                                        TIFFClose(tif);\r\n                                    } else error=true;\r\n\r\n                                    localFilename=bleachTime2Filename=outputFilenameBase+\".bleachtime2.tif\";\r\n                                    tif = TIFFOpen(localFilename.toLatin1().data(),\"w\");\r\n                                    if (tif) {\r\n                                        TIFFTWriteFloat(tif, bleachTime2, frame_width, frame_height);\r\n                                        TIFFClose(tif);\r\n                                    } else error=true;\r\n\r\n                                }\r\n\r\n                                if (job.bleach==BLEACH_EXP_POLY2||job.bleach==BLEACH_EXP_POLY3||job.bleach==BLEACH_EXP_POLY4||job.bleach==BLEACH_EXP_POLY5 ) {\r\n                                    localFilename=bleachPoly2Filename=outputFilenameBase+\".bleachpoly2.tif\";\r\n                                    tif = TIFFOpen(localFilename.toLatin1().data(),\"w\");\r\n                                    if (tif) {\r\n                                        TIFFTWriteFloat(tif, bleachPoly2, frame_width, frame_height);\r\n                                        TIFFClose(tif);\r\n                                    } else error=true;\r\n\r\n                                }\r\n                                if (job.bleach==BLEACH_EXP_POLY3||job.bleach==BLEACH_EXP_POLY4||job.bleach==BLEACH_EXP_POLY5 ) {\r\n                                    localFilename=bleachPoly3Filename=outputFilenameBase+\".bleachpoly3.tif\";\r\n                                    tif = TIFFOpen(localFilename.toLatin1().data(),\"w\");\r\n                                    if (tif) {\r\n                                        TIFFTWriteFloat(tif, bleachPoly3, frame_width, frame_height);\r\n                                        TIFFClose(tif);\r\n                                    } else error=true;\r\n                                }\r\n                                if (job.bleach==BLEACH_EXP_POLY4||job.bleach==BLEACH_EXP_POLY5 ) {\r\n                                    localFilename=bleachPoly4Filename=outputFilenameBase+\".bleachpoly4.tif\";\r\n                                    tif = TIFFOpen(localFilename.toLatin1().data(),\"w\");\r\n                                    if (tif) {\r\n                                        TIFFTWriteFloat(tif, bleachPoly4, frame_width, frame_height);\r\n                                        TIFFClose(tif);\r\n                                    } else error=true;\r\n                                }\r\n                                if (job.bleach==BLEACH_EXP_POLY5 ) {\r\n                                    localFilename=bleachPoly5Filename=outputFilenameBase+\".bleachpoly5.tif\";\r\n                                    tif = TIFFOpen(localFilename.toLatin1().data(),\"w\");\r\n                                    if (tif) {\r\n                                        TIFFTWriteFloat(tif, bleachPoly5, frame_width, frame_height);\r\n                                        TIFFClose(tif);\r\n                                    } else error=true;\r\n                                }\r\n                                localFilename=bleachFitSuccessFilename=outputFilenameBase+\".bleachfitok.tif\";\r\n                                tif = TIFFOpen(localFilename.toLatin1().data(),\"w\");\r\n                                if (tif) {\r\n                                    TIFFTWriteUint8(tif, bleachFitOK, frame_width, frame_height);\r\n                                    TIFFClose(tif);\r\n                                } else error=true;\r\n\r\n                                localFilename=firstFramesFilename=outputFilenameBase+\".firstframes.tif\";\r\n                                tif = TIFFOpen(localFilename.toLatin1().data(),\"w\");\r\n                                if (tif) {\r\n                                    TIFFTWriteFloat(tif, firstFrames, frame_width, frame_height);\r\n                                    TIFFClose(tif);\r\n                                } else error=true;\r\n\r\n                                localFilename=lastFramesFilename=outputFilenameBase+\".lastframes.tif\";\r\n                                tif = TIFFOpen(localFilename.toLatin1().data(),\"w\");\r\n                                if (tif) {\r\n                                    TIFFTWriteFloat(tif, lastFrames, frame_width, frame_height);\r\n                                    TIFFClose(tif);\r\n                                } else error=true;\r\n\r\n                                if (NFitFrames>0 && fit_t) {\r\n                                    localFilename=bleachtimesFilename=outputFilenameBase+\".bleachfittimes.txt\";\r\n                                    {\r\n                                        QFile f(localFilename);\r\n                                        if (f.open(QIODevice::WriteOnly|QIODevice::Text)) {\r\n                                            QTextStream text(&f);\r\n                                            text.setLocale(outLocale);\r\n                                            for (int i=0; i<NFitFrames; i++) {\r\n                                                text<<fit_t[i]<<\"\\n\";\r\n                                            }\r\n                                            f.close();\r\n                                        } else {\r\n                                            error=true;\r\n                                        }\r\n                                    }\r\n                                }\r\n\r\n                                if (NFitFrames>0 && fit_frames) {\r\n                                    localFilename=bleachframesFilename=outputFilenameBase+\".bleachfitframes.tif\";\r\n                                    tif = TIFFOpen(localFilename.toLatin1().data(),\"w\");\r\n                                    if (tif) {\r\n                                        for (int i=0; i<NFitFrames; i++) {\r\n                                            TIFFTWriteFloat(tif, &(fit_frames[i*frame_width*frame_height]), frame_width, frame_height);\r\n                                            TIFFWriteDirectory(tif);\r\n                                        }\r\n                                        TIFFClose(tif);\r\n                                    } else error=true;\r\n                                }\r\n\r\n\r\n                                if (error) {\r\n                                    m_status=-1; emit statusChanged(m_status);\r\n                                    backgroundFilename=\"\";\r\n                                    emit messageChanged(tr(\"could not create background image '%1'!\").arg(localFilename));\r\n                                }\r\n                            }\r\n                        }\r\n                        emit progressIncrement(10);\r\n\r\n                        //************** SAVE ACF blocking results\r\n                        if ((m_status==1) && !was_canceled ) {\r\n                            if (job.useBlockingErrorEstimate && acf_blocklevel) {\r\n                                emit messageChanged(tr(\"saving ACF block level image ...\"));\r\n                                QString localFilename;\r\n                                TIFF* tif;\r\n                                bool error=false;\r\n\r\n                                localFilename=acfBlockLevelFilename=outputFilenameBase+\".acfblocklevels.tif\";\r\n                                tif = TIFFOpen(localFilename.toLatin1().data(),\"w\");\r\n                                if (tif) {\r\n                                    TIFFTWriteUint16from32(tif, acf_blocklevel, frame_width, frame_height, false);\r\n                                    TIFFClose(tif);\r\n                                } else error=true;\r\n                            }\r\n                            if (job.useBlockingErrorEstimate && acf_blocksuccess) {\r\n                                emit messageChanged(tr(\"saving ACF block success image ...\"));\r\n                                QString localFilename;\r\n                                TIFF* tif;\r\n                                bool error=false;\r\n\r\n                                localFilename=acfBlockSuccessFilename=outputFilenameBase+\".acfblocksuccess.tif\";\r\n                                tif = TIFFOpen(localFilename.toLatin1().data(),\"w\");\r\n                                if (tif) {\r\n                                    TIFFTWriteBoolAsUint8(tif, acf_blocksuccess, frame_width, frame_height, false);\r\n                                    TIFFClose(tif);\r\n                                } else error=true;\r\n                            }\r\n\r\n                            if (job.distanceCCF) {\r\n                                TIFF* tif;\r\n                                for (int id=0; id<job.DCCFDeltaX.size(); id++) {\r\n                                    if (dccf[id].dccf_blocklevel) {\r\n                                        emit messageChanged(tr(\"saving DCCF block level image ...\"));\r\n                                        QString localFilename=outputFilenameBase+QString(\".dccf%1_blocklevels.tif\").arg(id,3,10,QLatin1Char('0'));\r\n                                        dccfBlockLevelFilename.append(localFilename);\r\n                                        tif = TIFFOpen(localFilename.toLatin1().data(),\"w\");\r\n                                        if (tif) {\r\n                                            TIFFTWriteUint16from32(tif, dccf[id].dccf_blocklevel, frame_width, frame_height, false);\r\n                                            TIFFClose(tif);\r\n                                        }\r\n\r\n                                        localFilename=outputFilenameBase+QString(\".dccf%1_blocksuccess.tif\").arg(id,3,10,QLatin1Char('0'));\r\n                                        dccfBlockSuccessFilename.append(localFilename);\r\n                                        tif = TIFFOpen(localFilename.toLatin1().data(),\"w\");\r\n                                        if (tif) {\r\n                                            TIFFTWriteBoolAsUint8(tif, dccf[id].dccf_blocksuccess, frame_width, frame_height, false);\r\n                                            TIFFClose(tif);\r\n                                        }\r\n                                    } else {\r\n                                        dccfBlockLevelFilename.append(QString());\r\n                                        dccfBlockSuccessFilename.append(QString());\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        double videoAvgMin=0;\r\n                        double videoAvgMax=(float)0xFFFF;\r\n                        //************** SAVE VIDEO\r\n                        if ((m_status==1) && !was_canceled && video && real_video_count>0 ) {\r\n                            emit messageChanged(tr(\"saving video ...\"));\r\n                            QString localFilename=videoFilename=outputFilenameBase+\".video.tif\";\r\n                            TinyTIFFFile* tif=TinyTIFFWriter_open(localFilename.toLatin1().data(), 16, frame_width, frame_height);\r\n                            //TIFF* tif = TIFFOpen(localFilename.toLatin1().data(),\"w\");\r\n                            if (tif) {\r\n                                float avgMin=video[0];\r\n                                float avgMax=video[0];\r\n                                for (register uint32_t i=0; i<frame_width*frame_height*video_count; i++) {\r\n                                    avgMin=(video[i]<avgMin)?video[i]:avgMin;\r\n                                    avgMax=(video[i]>avgMax)?video[i]:avgMax;\r\n                                }\r\n                                uint16_t* img=(uint16_t*)qfMalloc(frame_width*frame_height*sizeof(uint16_t));\r\n                                for (register uint32_t c=0; c<real_video_count; c++) {\r\n                                    for (register uint32_t i=0; i<frame_width*frame_height; i++) {\r\n                                        img[i]=(uint16_t)round((float)(video[c*frame_width*frame_height+i]-avgMin)*(float)0xFFFF/fabs(avgMax-avgMin));\r\n                                    }\r\n                                    TinyTIFFWriter_writeImage(tif, img);\r\n                                    if (real_video_count/10>0) {\r\n                                        if (c%(real_video_count/10)==0) {\r\n                                            emit messageChanged(tr(\"saving video %1/%2...\").arg(c+1).arg(video_count));\r\n                                            progressIncrement(10);\r\n                                        }\r\n                                    }\r\n                                }\r\n                                if (real_video_count/10<=0) progressIncrement(100);\r\n                                qfFree(img);\r\n                                TinyTIFFWriter_close(tif);\r\n                                videoAvgMin = avgMin;\r\n                                videoAvgMax = avgMax;\r\n                            } else {\r\n                                m_status=-1; emit statusChanged(m_status);\r\n                                emit messageChanged(tr(\"could not create video '%1'!\").arg(localFilename));\r\n                            }\r\n\r\n                        } else emit progressIncrement(100);\r\n\r\n                        double videoUncorrectedAvgMin=0;\r\n                        double videoUncorrectedAvgMax=(float)0xFFFF;\r\n                        //************** SAVE VIDEO\r\n                        if ((m_status==1) && !was_canceled && video_uncorrected && real_video_count>0 ) {\r\n                            emit messageChanged(tr(\"saving uncorrected video ...\"));\r\n                            QString localFilename=videoUncorrectedFilename=outputFilenameBase+\".videouncorr.tif\";\r\n                            TinyTIFFFile* tif=TinyTIFFWriter_open(localFilename.toLatin1().data(), 16, frame_width, frame_height);\r\n                            //TIFF* tif = TIFFOpen(localFilename.toLatin1().data(),\"w\");\r\n                            if (tif) {\r\n                                float avgMin=video_uncorrected[0];\r\n                                float avgMax=video_uncorrected[0];\r\n                                for (register uint32_t i=0; i<frame_width*frame_height*video_count; i++) {\r\n                                    avgMin=(video_uncorrected[i]<avgMin)?video_uncorrected[i]:avgMin;\r\n                                    avgMax=(video_uncorrected[i]>avgMax)?video_uncorrected[i]:avgMax;\r\n                                }\r\n                                uint16_t* img=(uint16_t*)qfMalloc(frame_width*frame_height*sizeof(uint16_t));\r\n                                for (register uint32_t c=0; c<real_video_count; c++) {\r\n                                    for (register uint32_t i=0; i<frame_width*frame_height; i++) {\r\n                                        img[i]=(uint16_t)round((float)(video_uncorrected[c*frame_width*frame_height+i]-avgMin)*(float)0xFFFF/fabs(avgMax-avgMin));\r\n                                    }\r\n                                    TinyTIFFWriter_writeImage(tif, img);\r\n                                    if (real_video_count/10>0) {\r\n                                        if (c%(real_video_count/10)==0) {\r\n                                            emit messageChanged(tr(\"saving uncorrected video %1/%2...\").arg(c+1).arg(video_count));\r\n                                            progressIncrement(10);\r\n                                        }\r\n                                    }\r\n                                }\r\n                                if (real_video_count/10<=0) progressIncrement(100);\r\n                                qfFree(img);\r\n                                TinyTIFFWriter_close(tif);\r\n                                videoUncorrectedAvgMin = avgMin;\r\n                                videoUncorrectedAvgMax = avgMax;\r\n                            } else {\r\n                                m_status=-1; emit statusChanged(m_status);\r\n                                emit messageChanged(tr(\"could not create uncorrected video '%1'!\").arg(localFilename));\r\n                            }\r\n\r\n                        } else emit progressIncrement(100);\r\n\r\n                        //************** SAVE STATISTICS\r\n                        if ((m_status==1) && !was_canceled && job.statistics) {\r\n                            QString error=\"\";\r\n                            emit messageChanged(tr(\"saving statistics ...\"));\r\n                            if (!saveStatistics(statisticsFilename=outputFilenameBase+\".statistics.dat\", outputFilenameBase+\".statistics.plt\", statistics, tr(\"Corrected Statistics\"), &error)) {\r\n                                m_status=-1; emit statusChanged(m_status);\r\n                                emit messageChanged(tr(\"could not create statistics file %1!\").arg(error));\r\n                            }\r\n\r\n                            emit messageChanged(tr(\"saving background statistics ...\"));\r\n                            if (!saveStatistics(backstatisticsFilename=outputFilenameBase+\".backstatistics.dat\", outputFilenameBase+\".backstatistics.plt\", backstatistics, tr(\"Background Statistics\"), &error)) {\r\n                                m_status=-1; emit statusChanged(m_status);\r\n                                emit messageChanged(tr(\"could not create backgrond statistics file %1!\").arg(error));\r\n                            }\r\n\r\n                            emit messageChanged(tr(\"saving uncorrected statistics ...\"));\r\n                            if (!saveStatistics(uncorrectedStatisticsFilename=outputFilenameBase+\".uncorrstatistics.dat\", outputFilenameBase+\".uncorrstatistics.plt\", statistics_uncorrected, tr(\"Uncorrected Statistics\"), &error)) {\r\n                                m_status=-1; emit statusChanged(m_status);\r\n                                emit messageChanged(tr(\"could not create uncorrected statistics file %1!\").arg(error));\r\n                            }\r\n\r\n                            if (job.dualViewMode!=DUALVIEW_NONE) {\r\n                                emit messageChanged(tr(\"saving DV 1 statistics ...\"));\r\n                                if (!saveStatistics(statisticsFilename_dv1=outputFilenameBase+\".statistics_dv1.dat\", outputFilenameBase+\".statistics_dv1.plt\", dv_statistics[0], tr(\"Corrected Statistics, DV 1\"), &error)) {\r\n                                    m_status=-1; emit statusChanged(m_status);\r\n                                    emit messageChanged(tr(\"could not create DV 1 statistics file %1!\").arg(error));\r\n                                }\r\n                                emit messageChanged(tr(\"saving DV 2 statistics ...\"));\r\n                                if (!saveStatistics(statisticsFilename_dv2=outputFilenameBase+\".statistics_dv2.dat\", outputFilenameBase+\".statistics_dv2.plt\", dv_statistics[1], tr(\"Corrected Statistics, DV 2\"), &error)) {\r\n                                    m_status=-1; emit statusChanged(m_status);\r\n                                    emit messageChanged(tr(\"could not create DV 2 statistics file %1!\").arg(error));\r\n                                }\r\n\r\n\r\n                                emit messageChanged(tr(\"saving DV 1 background statistics ...\"));\r\n                                if (!saveStatistics(backstatisticsFilename_dv1=outputFilenameBase+\".backstatistics_dv1.dat\", outputFilenameBase+\".backstatistics_dv1.plt\", dv_backstatistics[0], tr(\"Background Statistics, DV 1\"), &error)) {\r\n                                    m_status=-1; emit statusChanged(m_status);\r\n                                    emit messageChanged(tr(\"could not create DV 1 background statistics file %1!\").arg(error));\r\n                                }\r\n                                emit messageChanged(tr(\"saving DV 2 background statistics ...\"));\r\n                                if (!saveStatistics(backstatisticsFilename_dv2=outputFilenameBase+\".backstatistics_dv2.dat\", outputFilenameBase+\".backstatistics_dv2.plt\", dv_backstatistics[1], tr(\"Background Statistics, DV 2\"), &error)) {\r\n                                    m_status=-1; emit statusChanged(m_status);\r\n                                    emit messageChanged(tr(\"could not create DV 2 background statistics file %1!\").arg(error));\r\n                                }\r\n\r\n\r\n                                emit messageChanged(tr(\"saving DV 1 uncorrected statistics ...\"));\r\n                                if (!saveStatistics(uncorrectedStatisticsFilename_dv1=outputFilenameBase+\".uncorrstatistics_dv1.dat\", outputFilenameBase+\".uncorrstatistics_dv1.plt\", dv_statistics_uncorrected[0], tr(\"Background Statistics, DV 1\"), &error)) {\r\n                                    m_status=-1; emit statusChanged(m_status);\r\n                                    emit messageChanged(tr(\"could not create DV 1 uncorrected statistics file %1!\").arg(error));\r\n                                }\r\n                                emit messageChanged(tr(\"saving DV 2 uncorrected statistics ...\"));\r\n                                if (!saveStatistics(uncorrectedStatisticsFilename_dv2=outputFilenameBase+\".uncorrstatistics_dv2.dat\", outputFilenameBase+\".uncorrstatistics_dv2.plt\", dv_statistics_uncorrected[1], tr(\"Background Statistics, DV 2\"), &error)) {\r\n                                    m_status=-1; emit statusChanged(m_status);\r\n                                    emit messageChanged(tr(\"could not create DV 2 uncorrected statistics file %1!\").arg(error));\r\n                                }\r\n\r\n                            }\r\n\r\n                        }\r\n                        emit progressIncrement(10);\r\n\r\n\r\n\r\n                        //************** SAVE SETTINGS\r\n                        if ((m_status==1) && !was_canceled) {\r\n                            emit messageChanged(tr(\"saving settings ...\"));\r\n                            QString& localFilename=configFilename;\r\n                            QFile f(localFilename);\r\n                            QDir d=QFileInfo(localFilename).absoluteDir();\r\n                            if (f.open(QIODevice::WriteOnly|QIODevice::Text)) {\r\n                                QTextStream text(&f);\r\n                                text.setLocale(outLocale);\r\n\r\n                                text<<\"date/time                   : \"<<QDateTime::currentDateTime().toString(\"yyyy/MM/dd hh:mm:ss\") << \"\\n\";\r\n                                text<<\"input file                  : \"<<d.relativeFilePath(job.filename) << \"\\n\";\r\n                                if (!job.descriptionFilename.isEmpty()) text<<\"input description file      : \" << d.relativeFilePath(job.descriptionFilename) << \"\\n\";\r\n                                if (!averageFilename.isEmpty())         text<<\"overview image file         : \" << d.relativeFilePath(averageFilename) << \"\\n\";\r\n                                if (!averageFilenameF.isEmpty())        text<<\"overview image file real    : \" << d.relativeFilePath(averageFilenameF) << \"\\n\";\r\n                                if (!stdFilename.isEmpty())             text<<\"overview std image          : \" << d.relativeFilePath(stdFilename) << \"\\n\";\r\n                                if (!backgroundFilename.isEmpty())      text<<\"background image file       : \" << d.relativeFilePath(backgroundFilename) << \"\\n\";\r\n                                if (!backstdFilename.isEmpty())         text<<\"background stddev           : \" << d.relativeFilePath(backstdFilename) << \"\\n\";\r\n                                if (!averageUncorrectedFilename.isEmpty())         text<<\"uncorr. overview image file : \" << d.relativeFilePath(averageUncorrectedFilename) << \"\\n\";\r\n                                if (!stdUncorrectedFilename.isEmpty())             text<<\"uncorr. overview std image  : \" << d.relativeFilePath(stdUncorrectedFilename) << \"\\n\";\r\n                                if (!videoFilename.isEmpty())           text<<\"video file                  : \" << d.relativeFilePath(videoFilename) << \"\\n\";\r\n                                if (!videoUncorrectedFilename.isEmpty())text<<\"uncorrected video file      : \" << d.relativeFilePath(videoUncorrectedFilename) << \"\\n\";\r\n                                if (!statisticsFilename.isEmpty())      text<<\"statistics file             : \" << d.relativeFilePath(statisticsFilename) << \"\\n\";\r\n                                if (!backstatisticsFilename.isEmpty())         text<<\"background statistics file  : \" << d.relativeFilePath(backstatisticsFilename) << \"\\n\";\r\n                                if (!uncorrectedStatisticsFilename.isEmpty())  text<<\"uncorrected statistics file : \" << d.relativeFilePath(uncorrectedStatisticsFilename) << \"\\n\";\r\n\r\n                                if (!statisticsFilename_dv1.isEmpty())      text<<\"statistics file DV1         : \" << d.relativeFilePath(statisticsFilename_dv1) << \"\\n\";\r\n                                if (!backstatisticsFilename_dv1.isEmpty())         text<<\"background statistics file DV1 : \" << d.relativeFilePath(backstatisticsFilename_dv1) << \"\\n\";\r\n                                if (!uncorrectedStatisticsFilename_dv1.isEmpty())  text<<\"uncorrected statistics file DV1 : \" << d.relativeFilePath(uncorrectedStatisticsFilename_dv1) << \"\\n\";\r\n                                if (!statisticsFilename_dv2.isEmpty())      text<<\"statistics file DV2         : \" << d.relativeFilePath(statisticsFilename_dv2) << \"\\n\";\r\n                                if (!backstatisticsFilename_dv2.isEmpty())         text<<\"background statistics file DV2 : \" << d.relativeFilePath(backstatisticsFilename_dv2) << \"\\n\";\r\n                                if (!uncorrectedStatisticsFilename_dv2.isEmpty())  text<<\"uncorrected statistics file DV2 : \" << d.relativeFilePath(uncorrectedStatisticsFilename_dv2) << \"\\n\";\r\n\r\n                                if (!acfFilename.isEmpty())             text<<\"autocorrelation file        : \" << d.relativeFilePath(acfFilename) << \"\\n\";\r\n                                if (!acfFilenameBin.isEmpty())          text<<\"bin. autocorrelation file   : \" << d.relativeFilePath(acfFilenameBin) << \"\\n\";\r\n                                for (int id=0; id<qMax(dccfFilename.size(), dccfFilenameBin.size()); id++) {\r\n                                    if (id<dccfFilename.size())            text<<QString(\"distance ccf file %1        : \").arg(id) << d.relativeFilePath(dccfFilename[id]) << \"\\n\";\r\n                                    if (id<dccfFilenameBin.size())         text<<QString(\"bin. distance ccf file %1   : \").arg(id) << d.relativeFilePath(dccfFilenameBin[id]) << \"\\n\";\r\n                                }\r\n                                text<<\"width                       : \"<<outLocale.toString(frame_width) << \"\\n\";\r\n                                text<<\"height                      : \"<<outLocale.toString(frame_height) << \"\\n\";\r\n                                if (job.cameraSettingsGiven) {\r\n                                    text<<\"pixel width                 : \"<<outLocale.toString(job.cameraPixelWidth) << \"\\n\";\r\n                                    text<<\"pixel height                : \"<<outLocale.toString(job.cameraPixelHeight) << \"\\n\";\r\n                                }\r\n                                text<<\"frametime (ms)              : \"<<job.frameTime*1.0e3 << \"\\n\";\r\n                                text<<\"frametime (s)               : \"<<job.frameTime << \"\\n\";\r\n                                text<<\"dualview mode               : \"<<job.dualViewMode << \"\\n\";\r\n                                text<<\"binning                     : \"<<outLocale.toString(reader->getBinning()) << \"\\n\";\r\n                                text<<\"interleaved binning         : \"<< QString((reader->getInterleavedBinning())?\"true\":\"false\") << \"\\n\";\r\n                                text<<\"averaging binning           : \"<< QString((reader->getAverageBinning())?\"true\":\"false\") << \"\\n\";\r\n                                if (reader->getUseCropping()) {\r\n                                    text<<\"crop x0                     : \"<<outLocale.toString(reader->getCropX0()) << \"\\n\";\r\n                                    text<<\"crop x1                     : \"<<outLocale.toString(reader->getCropX1()) << \"\\n\";\r\n                                    text<<\"crop y0                     : \"<<outLocale.toString(reader->getCropY0()) << \"\\n\";\r\n                                    text<<\"crop y1                     : \"<<outLocale.toString(reader->getCropY1()) << \"\\n\";\r\n                                }\r\n                                text<<\"frame count in file         : \"<<outLocale.toString(frame_count) << \"\\n\";\r\n                                text<<\"frame count                 : \"<<outLocale.toString(frames) << \"\\n\";\r\n                                text<<\"first frame                 : \"<<outLocale.toString(first_frame) << \"\\n\";\r\n                                text<<\"last frame                  : \"<<outLocale.toString(first_frame+frames-1) << \"\\n\";\r\n                                text<<\"correlation segments        : \"<<outLocale.toString(job.segments) << \"\\n\";\r\n                                text<<\"correlation use blocking    : \"<<boolToQString(job.useBlockingErrorEstimate) << \"\\n\";\r\n                                text<<\"segments length (s)         : \"<<outLocale.toString(double(frames)/double(job.segments)*job.frameTime) << \"\\n\";\r\n                                text<<\"correlator S                : \"<<outLocale.toString(job.S) << \"\\n\";\r\n                                text<<\"correlator m                : \"<<outLocale.toString(job.m) << \"\\n\";\r\n                                text<<\"correlator P                : \"<<outLocale.toString(job.P) << \"\\n\";\r\n                                text<<\"correlator type             : \"<<outLocale.toString(job.correlator) << \"\\n\";\r\n                                text<<\"correlator type name        : \";\r\n                                switch(job.correlator) {\r\n                                    case CORRELATOR_DIRECT:      text<<\"direct\\n\"; break;\r\n                                    case CORRELATOR_DIRECTAVG:   text<<\"direct with averaging\\n\"; break;\r\n                                    case CORRELATOR_DIRECT_INT:    text<<\"direct, integer\\n\"; break;\r\n                                    case CORRELATOR_DIRECTAVG_INT: text<<\"direct with averaging, integer\\n\"; break;\r\n                                    case CORRELATOR_MTAUALLMON:  text<<\"multi-tau with monitors for all channels\\n\"; break;\r\n                                    case CORRELATOR_MTAUONEMON:  text<<\"multi-tau with a single monitor\\n\"; break;\r\n                                    case CORRELATOR_CORRELATORFROMSHAREDLIB:  text<<\"multi-tau from shared library\\n\"; break;\r\n\r\n                                    default: text<<\"correlator type name        : unknown\\n\"; break;\r\n                                }\r\n                                text<<\"smallest tau [s]            : \"<<outLocale.toString(job.frameTime) << \"\\n\";\r\n                                text<<\"baseline                    : \"<<outLocale.toString(baseline) << \"\\n\";\r\n                                if (video && job.video) {\r\n                                    text<<\"video sum up                : \"<<outLocale.toString(job.video_frames) << \"\\n\";\r\n                                    text<<\"video frames                : \"<<outLocale.toString(real_video_count) << \"\\n\";\r\n                                    text<<\"video avgMin                : \"<<outLocale.toString(videoAvgMin) << \"\\n\";\r\n                                    text<<\"video avgMax                : \"<<outLocale.toString(videoAvgMax) << \"\\n\";\r\n                                    text<<\"video uncorrected avgMin    : \"<<outLocale.toString(videoUncorrectedAvgMin) << \"\\n\";\r\n                                    text<<\"video uncorrected avgMax    : \"<<outLocale.toString(videoUncorrectedAvgMax) << \"\\n\";\r\n                                }\r\n                                if (job.statistics) {\r\n                                    text<<\"statistics over             : \"<<outLocale.toString(job.statistics_frames) << \"\\n\";\r\n                                }\r\n                                if (job.distanceCCF) {\r\n                                    for (int id=0; id<job.DCCFDeltaX.size(); id++) {\r\n                                        text<<QString(\"DCCF %1 role                   : \").arg(id)<<job.DCCFrole[id] << \"\\n\";\r\n                                        text<<QString(\"DCCF %1 Delta x                : \").arg(id)<<outLocale.toString(job.DCCFDeltaX[id]) << \"\\n\";\r\n                                        text<<QString(\"DCCF %1 Delta y                : \").arg(id)<<outLocale.toString(job.DCCFDeltaY[id]) << \"\\n\";\r\n                                        text<<QString(\"DCCF %1 frame width            : \").arg(id)<<outLocale.toString(dccf[id].dccfframe_width) << \"\\n\";\r\n                                        text<<QString(\"DCCF %1 frame height           : \").arg(id)<<outLocale.toString(dccf[id].dccfframe_height) << \"\\n\";\r\n                                    }\r\n\r\n                                }\r\n                                text<<\"bleach percentage file      : \"<<d.relativeFilePath(bleachPercentageFilename) << \"\\n\";\r\n                                text<<\"bleach correction           : \";\r\n                                if (job.bleach==BLEACH_EXP) {\r\n                                    text<<\"remove mono-exponential f(t)=A*exp(-t/tau) using LM-Fit\\n\";\r\n                                    text<<\"bleach average frames       : \"<<outLocale.toString(job.bleachAvgFrames) << \"\\n\";\r\n                                    text<<\"bleach amplitude file       : \"<<d.relativeFilePath(bleachAmplitudeFilename) << \"\\n\";\r\n                                    text<<\"bleach time file            : \"<<d.relativeFilePath(bleachTimeFilename) << \"\\n\";\r\n                                    text<<\"bleach fit success          : \"<<d.relativeFilePath(bleachFitSuccessFilename) << \"\\n\";\r\n                                    text<<\"bleach timeseries t file    : \"<<d.relativeFilePath(bleachtimesFilename) << \"\\n\";\r\n                                    text<<\"bleach timeseries I file    : \"<<d.relativeFilePath(bleachframesFilename) << \"\\n\";\r\n                                    text<<\"bleach correction           : \";\r\n                                } else if (job.bleach==BLEACH_EXP_POLY2 ) {\r\n                                    text<<\"remove mono-exponential(polynomial) f(t)=A*exp(-(t+f2*t^2)/tau) using LM-Fit\\n\";\r\n                                    text<<\"bleach average frames       : \"<<outLocale.toString(job.bleachAvgFrames) << \"\\n\";\r\n                                    text<<\"bleach amplitude file       : \"<<d.relativeFilePath(bleachAmplitudeFilename) << \"\\n\";\r\n                                    text<<\"bleach time file            : \"<<d.relativeFilePath(bleachTimeFilename) << \"\\n\";\r\n                                    text<<\"bleach polynomial factor file : \"<<d.relativeFilePath(bleachPoly2Filename) << \"\\n\";\r\n                                    text<<\"bleach polynomial factor 3 file : \"<<d.relativeFilePath(bleachPoly3Filename) << \"\\n\";\r\n                                    text<<\"bleach fit success          : \"<<d.relativeFilePath(bleachFitSuccessFilename) << \"\\n\";\r\n                                    text<<\"bleach timeseries t file    : \"<<d.relativeFilePath(bleachtimesFilename) << \"\\n\";\r\n                                    text<<\"bleach timeseries I file    : \"<<d.relativeFilePath(bleachframesFilename) << \"\\n\";\r\n                                } else if (job.bleach==BLEACH_EXP_POLY3) {\r\n                                    text<<\"remove mono-exponential(polynomial) f(t)=A*exp(-(t+f2*t^2+f3*t^3)/tau) using LM-Fit\\n\";\r\n                                    text<<\"bleach average frames       : \"<<outLocale.toString(job.bleachAvgFrames) << \"\\n\";\r\n                                    text<<\"bleach amplitude file       : \"<<d.relativeFilePath(bleachAmplitudeFilename) << \"\\n\";\r\n                                    text<<\"bleach time file            : \"<<d.relativeFilePath(bleachTimeFilename) << \"\\n\";\r\n                                    text<<\"bleach polynomial factor file : \"<<d.relativeFilePath(bleachPoly2Filename) << \"\\n\";\r\n                                    text<<\"bleach polynomial factor 3 file : \"<<d.relativeFilePath(bleachPoly3Filename) << \"\\n\";\r\n                                    text<<\"bleach fit success          : \"<<d.relativeFilePath(bleachFitSuccessFilename) << \"\\n\";\r\n                                    text<<\"bleach timeseries t file    : \"<<d.relativeFilePath(bleachtimesFilename) << \"\\n\";\r\n                                    text<<\"bleach timeseries I file    : \"<<d.relativeFilePath(bleachframesFilename) << \"\\n\";\r\n                                } else if (job.bleach==BLEACH_EXP_POLY4) {\r\n                                    text<<\"remove mono-exponential(polynomial) f(t)=A*exp(-(t+f*t^2+f3*t^3+f4*t^4)/tau) using LM-Fit\\n\";\r\n                                    text<<\"bleach average frames       : \"<<outLocale.toString(job.bleachAvgFrames) << \"\\n\";\r\n                                    text<<\"bleach amplitude file       : \"<<d.relativeFilePath(bleachAmplitudeFilename) << \"\\n\";\r\n                                    text<<\"bleach time file            : \"<<d.relativeFilePath(bleachTimeFilename) << \"\\n\";\r\n                                    text<<\"bleach polynomial factor file : \"<<d.relativeFilePath(bleachPoly2Filename) << \"\\n\";\r\n                                    text<<\"bleach polynomial factor 3 file : \"<<d.relativeFilePath(bleachPoly3Filename) << \"\\n\";\r\n                                    text<<\"bleach polynomial factor 4 file : \"<<d.relativeFilePath(bleachPoly4Filename) << \"\\n\";\r\n                                    text<<\"bleach fit success          : \"<<d.relativeFilePath(bleachFitSuccessFilename) << \"\\n\";\r\n                                    text<<\"bleach timeseries t file    : \"<<d.relativeFilePath(bleachtimesFilename) << \"\\n\";\r\n                                    text<<\"bleach timeseries I file    : \"<<d.relativeFilePath(bleachframesFilename) << \"\\n\";\r\n                                } else if (job.bleach==BLEACH_EXP_POLY5) {\r\n                                    text<<\"remove mono-exponential(polynomial) f(t)=A*exp(-(t+f*t^2+f3*t^3+f4*t^4+f5*t^5)/tau) using LM-Fit\\n\";\r\n                                    text<<\"bleach average frames       : \"<<outLocale.toString(job.bleachAvgFrames) << \"\\n\";\r\n                                    text<<\"bleach amplitude file       : \"<<d.relativeFilePath(bleachAmplitudeFilename) << \"\\n\";\r\n                                    text<<\"bleach time file            : \"<<d.relativeFilePath(bleachTimeFilename) << \"\\n\";\r\n                                    text<<\"bleach polynomial factor file : \"<<d.relativeFilePath(bleachPoly2Filename) << \"\\n\";\r\n                                    text<<\"bleach polynomial factor 3 file : \"<<d.relativeFilePath(bleachPoly3Filename) << \"\\n\";\r\n                                    text<<\"bleach polynomial factor 4 file : \"<<d.relativeFilePath(bleachPoly4Filename) << \"\\n\";\r\n                                    text<<\"bleach polynomial factor 5 file : \"<<d.relativeFilePath(bleachPoly5Filename) << \"\\n\";\r\n                                    text<<\"bleach fit success          : \"<<d.relativeFilePath(bleachFitSuccessFilename) << \"\\n\";\r\n                                    text<<\"bleach timeseries t file    : \"<<d.relativeFilePath(bleachtimesFilename) << \"\\n\";\r\n                                    text<<\"bleach timeseries I file    : \"<<d.relativeFilePath(bleachframesFilename) << \"\\n\";\r\n                                } else if (job.bleach==BLEACH_DBL_EXP) {\r\n                                    text<<\"remove double-exponential f(t)=A*exp(-t/tau)+A2*exp(-t/tau2) using LM-Fit\\n\";\r\n                                    text<<\"bleach average frames       : \"<<outLocale.toString(job.bleachAvgFrames) << \"\\n\";\r\n                                    text<<\"bleach amplitude file       : \"<<d.relativeFilePath(bleachAmplitudeFilename) << \"\\n\";\r\n                                    text<<\"bleach time file            : \"<<d.relativeFilePath(bleachTimeFilename) << \"\\n\";\r\n                                    text<<\"bleach amplitude 2 file       : \"<<d.relativeFilePath(bleachAmplitude2Filename) << \"\\n\";\r\n                                    text<<\"bleach time 2 file            : \"<<d.relativeFilePath(bleachTime2Filename) << \"\\n\";\r\n                                    text<<\"bleach fit success          : \"<<d.relativeFilePath(bleachFitSuccessFilename) << \"\\n\";\r\n                                    text<<\"bleach timeseries t file    : \"<<d.relativeFilePath(bleachtimesFilename) << \"\\n\";\r\n                                    text<<\"bleach timeseries I file    : \"<<d.relativeFilePath(bleachframesFilename) << \"\\n\";\r\n                                } else if (job.bleach==BLEACH_EXPREG) {\r\n                                    text<<\"remove mono-exponential f(t)=A*exp(-t/tau) using linear regression\\n\";\r\n                                    text<<\"bleach average frames       : \"<<outLocale.toString(job.bleachAvgFrames) << \"\\n\";\r\n                                    text<<\"bleach amplitude file       : \"<<d.relativeFilePath(bleachAmplitudeFilename) << \"\\n\";\r\n                                    text<<\"bleach time file            : \"<<d.relativeFilePath(bleachTimeFilename) << \"\\n\";\r\n                                    text<<\"bleach fit success          : \"<<d.relativeFilePath(bleachFitSuccessFilename) << \"\\n\";\r\n                                    text<<\"bleach timeseries t file    : \"<<d.relativeFilePath(bleachtimesFilename) << \"\\n\";\r\n                                    text<<\"bleach timeseries I file    : \"<<d.relativeFilePath(bleachframesFilename) << \"\\n\";\r\n                                }  else if (job.bleach==BLEACH_NONE) {\r\n                                        text<<\"remove frame average\\n\";\r\n                                        text<<\"bleach average frames       : \"<<outLocale.toString(job.bleachAvgFrames) << \"\\n\";\r\n\r\n                                } else {\r\n                                    text<<\"none\\n\";\r\n                                }\r\n                                if (acfBlockLevelFilename.size()>0) text<<\"ACF blocking level file     : \"<<d.relativeFilePath(acfBlockLevelFilename) << \"\\n\";\r\n                                if (acfBlockSuccessFilename.size()>0) text<<\"ACF blocking success file   : \"<<d.relativeFilePath(acfBlockSuccessFilename) << \"\\n\";\r\n                                if (job.distanceCCF) {\r\n                                    for (int id=0; id<job.DCCFDeltaX.size(); id++) {\r\n                                        if (dccfBlockLevelFilename.value(id).size()>0) text<<QString(\"DCCF %1 (%2) blocking level file : \").arg(id).arg(job.DCCFrole[id])<<d.relativeFilePath(dccfBlockLevelFilename.value(id)) << \"\\n\";\r\n                                        if (dccfBlockSuccessFilename.value(id).size()>0) text<<QString(\"DCCF %1 (%2) blocking success file : \").arg(id).arg(job.DCCFrole[id])<<d.relativeFilePath(dccfBlockSuccessFilename.value(id)) << \"\\n\";\r\n                                    }\r\n                                }\r\n                                text<<\"duration [s]                : \"<<ptime.elapsed()/1000.0 << \"\\n\";\r\n\r\n                                f.close();\r\n                            } else {\r\n                                m_status=-1; emit statusChanged(m_status);\r\n                                emit messageChanged(tr(\"could not create settings file '%1': %2!\").arg(localFilename).arg(f.errorString()));\r\n                            }\r\n\r\n                        }\r\n                        emit progressIncrement(10);\r\n\r\n\r\n                        //************** SAVE ACF\r\n                        if ((m_status==1) && !was_canceled && job.acf && acf && acf_tau && acf_N>0) {\r\n                            QString localFilename=acfFilename=outputFilenameBase+\".autocorrelation.dat\";\r\n                            QString localFilename1=acfFilenameBin=outputFilenameBase+\".autocorrelation.bin\";\r\n\r\n                            emit messageChanged(tr(\"saving autocorrelation ...\"));\r\n                            double* ccf[1]={acf};\r\n                            double* ccferr[1]={acf_std};\r\n                            double* ccfsegments[1]={acf_segments};\r\n                            QString error;\r\n                            //qDebug()<<\"acf = \"<<acf<<\"  acf_std = \"<<acf_std;\r\n                            if (!saveCorrelationCSV(localFilename, acf_tau, ccf, ccferr, 1, acf_N, frame_width, frame_height, input_length, error,125, double(frames)/double(job.segments)*job.frameTime)) {\r\n                                m_status=-1; emit statusChanged(m_status);\r\n                                emit messageChanged(tr(\"could not create autocorrelation file '%1': %2!\").arg(localFilename).arg(error));\r\n                            }\r\n                            if (!saveCorrelationBIN(localFilename1, acf_tau, ccf, ccferr, 1, acf_N, frame_width, frame_height, ccfsegments, error,125, double(frames)/double(job.segments)*job.frameTime)) {\r\n                                m_status=-1; emit statusChanged(m_status);\r\n                                emit messageChanged(tr(\"could not create binary autocorrelation file '%1': %2!\").arg(localFilename1).arg(error));\r\n                            }\r\n                            if (job.addFCCSSeparately && job.dualViewMode!=DUALVIEW_NONE) {\r\n                                if (QFile::exists(localFilename1)) {\r\n                                    addFiles.append(getFileInfo(localFilename1, configFilename, \"ACF0\", 0, getGroupName()));\r\n                                    addFiles.append(getFileInfo(localFilename1, configFilename, \"ACF1\", 1, getGroupName()));\r\n                                } else {\r\n                                    addFiles.append(getFileInfo(localFilename, configFilename, \"ACF0\", 0, getGroupName()));\r\n                                    addFiles.append(getFileInfo(localFilename, configFilename, \"ACF1\", 1, getGroupName()));\r\n                                }\r\n                            } else {\r\n                                if (QFile::exists(localFilename1)) addFiles.append(getFileInfo(localFilename1, configFilename, \"ACF\", getGroupName()));\r\n                                else addFiles.append(getFileInfo(localFilename, configFilename, \"ACF\", getGroupName()));\r\n                            }\r\n\r\n                        }\r\n                        emit progressIncrement(250);\r\n\r\n\r\n                        //************** SAVE DCCF\r\n                        if ((m_status==1) && !was_canceled && job.distanceCCF) {\r\n                            for (int id=0; id<job.DCCFDeltaX.size(); id++) {\r\n                                if (dccf[id].dccf && dccf[id].dccf_tau && dccf[id].dccf_N>0) {\r\n                                    QString localFilename=outputFilenameBase+QString(\".dccf%1.dat\").arg(id,3,10,QLatin1Char('0'));\r\n                                    QString localFilename1=outputFilenameBase+QString(\".dccf%1.bin\").arg(id,3,10,QLatin1Char('0'));;\r\n                                    dccfFilename.append(localFilename);\r\n                                    dccfFilenameBin.append(localFilename1);\r\n\r\n                                    emit messageChanged(tr(\"saving distance distance crosscorrelation ...\"));\r\n                                    double* ccf[1]={dccf[id].dccf};\r\n                                    double* ccferr[1]={dccf[id].dccf_std};\r\n                                    double* ccfsegments[1]={dccf[id].dccf_segments};\r\n                                    QString error;\r\n                                    if (!saveCorrelationCSV(localFilename, dccf[id].dccf_tau, ccf, ccferr, 1, dccf[id].dccf_N, frame_width, frame_height, input_length, error,125, double(frames)/double(job.segments)*job.frameTime)) {\r\n                                        m_status=-1; emit statusChanged(m_status);\r\n                                        emit messageChanged(tr(\"could not create distance crosscorrelation file '%1': %2!\").arg(localFilename).arg(error));\r\n                                    }\r\n                                    if (!saveCorrelationBIN(localFilename1, dccf[id].dccf_tau, ccf, ccferr, 1, dccf[id].dccf_N, frame_width, frame_height, ccfsegments, error,125, double(frames)/double(job.segments)*job.frameTime)) {\r\n                                        m_status=-1; emit statusChanged(m_status);\r\n                                        emit messageChanged(tr(\"could not create binary distance crosscorrelation file '%1': %2!\").arg(localFilename1).arg(error));\r\n                                    }\r\n                                    QString role=job.DCCFrole.value(id, \"DCCF\");\r\n                                    if (role.toLower()==\"fccs\") {\r\n                                        if (QFile::exists(localFilename1)) addFiles.append(getFileInfo(localFilename1, configFilename, role, 0, getGroupName()));\r\n                                        else addFiles.append(getFileInfo(localFilename, configFilename, role, 0, getGroupName()));\r\n                                    } else {\r\n                                        if (QFile::exists(localFilename1)) addFiles.append(getFileInfo(localFilename1, configFilename, role, getGroupName()));\r\n                                        else addFiles.append(getFileInfo(localFilename, configFilename, role, getGroupName()));\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                        emit progressIncrement(250);\r\n\r\n\r\n\r\n\r\n\r\n                        //qDebug()<<job.addNandB<< QFile::exists(averageFilenameF)<< QFile::exists(stdFilename)<< QFile::exists(backgroundFilename)<< QFile::exists(backstdFilename);\r\n\r\n                        //************** CREATE N&B job\r\n                        if (job.addNandB\r\n                                && QFile::exists(averageFilenameF)\r\n                                && QFile::exists(stdFilename)\r\n                                /*&& QFile::exists(backgroundFilename)\r\n                                && QFile::exists(backstdFilename)*/) {\r\n\r\n                            if (job.addFCCSSeparately && job.dualViewMode!=DUALVIEW_NONE) {\r\n                                addFiles.append(getFileInfoNandB(averageFilenameF, stdFilename, backgroundFilename, backstdFilename, configFilename, \"N&B1\", 0, getGroupName()));\r\n                                addFiles.append(getFileInfoNandB(averageFilenameF, stdFilename, backgroundFilename, backstdFilename, configFilename, \"N&B2\", 1, getGroupName()));\r\n                            } else {\r\n                                addFiles.append(getFileInfoNandB(averageFilenameF, stdFilename, backgroundFilename, backstdFilename, configFilename, \"N&B\", 0, getGroupName()));\r\n                            }\r\n                        }\r\n                    } else {\r\n                        if (mutexFilename) mutexFilename->unlock();\r\n                        m_status=-1; emit statusChanged(m_status);\r\n                        emit messageChanged(tr(\"could not create output subdirectory '%1' in '%2'!\").arg(localFileDirectory).arg(d.absolutePath()));\r\n                    }\r\n\r\n                    if (video) qfFree(video);\r\n                    if (video_uncorrected) qfFree(video_uncorrected);\r\n                    if (fit_frames) qfFree(fit_frames);\r\n                    if (fit_t) qfFree(fit_t);\r\n                    if (bleachAmplitude) qfFree(bleachAmplitude);\r\n                    if (bleachTime) qfFree(bleachTime);\r\n                    if (bleachAmplitude2) qfFree(bleachAmplitude2);\r\n                    if (bleachTime2) qfFree(bleachTime2);\r\n                    if (bleachPoly2) qfFree(bleachPoly2);\r\n                    if (bleachPoly3) qfFree(bleachPoly3);\r\n                    if (bleachPoly4) qfFree(bleachPoly4);\r\n                    if (bleachPoly5) qfFree(bleachPoly5);\r\n                    if (bleachFitOK) qfFree(bleachFitOK);\r\n                    if (firstFrames) qfFree(firstFrames);\r\n                    firstFrames=NULL;\r\n                    if (lastFrames) qfFree(lastFrames);\r\n                    lastFrames=NULL;\r\n                    if (average_frame) qfFree(average_frame);\r\n                    if (sqrsum_frame) qfFree(sqrsum_frame);\r\n                    if (acf_tau) qfFree(acf_tau);\r\n                    if (acf) qfFree(acf);\r\n                    if (acf_segments) qfFree(acf_segments);\r\n                    if (acf_std) qfFree(acf_std);\r\n                    if (acf_blocklevel) qfFree(acf_blocklevel);\r\n                    if (acf_blocksuccess) qfFree(acf_blocksuccess);\r\n\r\n                    if (bleachPercentage) qfFree(bleachPercentage);\r\n                    bleachPercentage=NULL;\r\n                    for (int id=0; id<dccf.size(); id++) {\r\n                        if (dccf[id].dccf_tau) qfFree(dccf[id].dccf_tau);\r\n                        if (dccf[id].dccf) qfFree(dccf[id].dccf);\r\n                        if (dccf[id].dccf_std) qfFree(dccf[id].dccf_std);\r\n                        if (dccf[id].dccf_segments) qfFree(dccf[id].dccf_segments);\r\n                        if (dccf[id].dccf_blocklevel) qfFree(dccf[id].dccf_blocklevel);\r\n                        if (dccf[id].dccf_blocksuccess) qfFree(dccf[id].dccf_blocksuccess);\r\n                    }\r\n                    dccf.clear();\r\n                    if (m_status==1) {\r\n                        if (was_canceled) {\r\n                            m_status=-1; emit statusChanged(m_status);\r\n                            duration=ptime.elapsed();\r\n                            emit messageChanged(tr(\"canceled by user\"));\r\n                        } else {\r\n                            m_status=2; emit statusChanged(m_status);\r\n                            duration=ptime.elapsed();\r\n                            emit messageChanged(tr(\"correlation ... done [duration = %1 s]\").arg(duration/1.0e3));\r\n                        }\r\n                        emit statusChanged(m_status);\r\n                    }\r\n                } else {\r\n                    m_status=-1; emit statusChanged(m_status);\r\n                    duration=ptime.elapsed();\r\n                    emit messageChanged(tr(\"no frames in file/selected\"));\r\n                }\r\n\r\n\r\n            }\r\n            delete reader;\r\n        } else {\r\n            m_status=-1; emit statusChanged(m_status);\r\n            duration=ptime.elapsed();\r\n            emit messageChanged(tr(\"could not create image reader object\"));\r\n        }\r\n    }\r\n\r\n\r\n    duration=ptime.elapsed();\r\n}",
    "bool QFRDRImagingFCSCorrelationJobThread::SaveSDTIFF(const QString &filename, float *average_frame, float *sqrsum_frame, int frame_width, int frame_height, int frames, const QString &title, QString *error)\r\n{\r\n    TIFF* tif = TIFFOpen(filename.toLatin1().data(),\"w\");\r\n    if (tif) {\r\n        float* sd=(float*)qfCalloc(frame_width*frame_height, sizeof(float));\r\n\r\n        if (frames>1) {\r\n            for (int i=0; i<frame_width*frame_height; i++) {\r\n                sd[i]=sqrt(float(frames)/float(frames-1)*(sqrsum_frame[i]-average_frame[i]*average_frame[i]));\r\n            }\r\n        } else {\r\n            for (int i=0; i<frame_width*frame_height; i++) {\r\n                sd[i]=0;\r\n            }\r\n\r\n        }\r\n\r\n        TIFFTWriteFloat(tif, sd, frame_width, frame_height);\r\n        TIFFClose(tif);\r\n        qfFree(sd);\r\n        return true;\r\n    } else {\r\n        if (error) *error=tr(\"could not create %2 '%1'!\").arg(filename).arg(title);\r\n        return false;\r\n    }\r\n}",
    "bool QFRDRImagingFCSCorrelationJobThread::SaveTIFFFloat(const QString &filename, float *average_frame, int frame_width, int frame_height, const QString &title, QString *error)\r\n{\r\n    TIFF* tif = TIFFOpen(filename.toLatin1().data(),\"w\");\r\n    if (tif) {\r\n\r\n        TIFFTWriteFloat(tif, average_frame, frame_width, frame_height);\r\n        TIFFClose(tif);\r\n        return true;\r\n    } else {\r\n        if (error) *error=tr(\"could not create %2 image '%1'!\").arg(filename).arg(title);\r\n        return false;\r\n    }\r\n}",
    "bool QFRDRImagingFCSCorrelationJobThread::SaveTIFFUInt16_scaled(const QString &filename, float *average_frame, int frame_width, int frame_height, const QString &title, QString *error)\r\n{\r\n    TIFF* tif = TIFFOpen(filename.toLatin1().data(),\"w\");\r\n    if (tif) {\r\n        float avgMin=average_frame[0];\r\n        float avgMax=average_frame[0];\r\n        for (int64_t i=0; i<frame_width*frame_height; i++) {\r\n            avgMin=(average_frame[i]<avgMin)?average_frame[i]:avgMin;\r\n            avgMax=(average_frame[i]>avgMax)?average_frame[i]:avgMax;\r\n        }\r\n        uint16_t* img=(uint16_t*)qfMalloc(frame_width*frame_height*sizeof(uint16_t));\r\n        for (int64_t i=0; i<frame_width*frame_height; i++) {\r\n            img[i]=(uint16_t)round((double)(average_frame[i]-avgMin)*(double)0xFFFF/fabs(avgMax-avgMin));\r\n        }\r\n        TIFFTWriteUint16(tif, img, frame_width, frame_height);\r\n        qfFree(img);\r\n        TIFFClose(tif);\r\n        return true;\r\n    } else {\r\n        if (error) *error=tr(\"could not create %2 '%1'!\").arg(filename).arg(title);\r\n        return false;\r\n    }\r\n}",
    "void QFESPIMB040CamParamStackConfigWidget2::performStack()\r\n{\r\n    if (!(this->use1() || this->use2())) {\r\n        QMessageBox::critical(this, tr(\"B040SPIM: Parameter Stack Acquisition\"), tr(\"Cannot start image acquisition: No camera selected!\"));\r\n        return;\r\n    }\r\n\r\n    QDateTime startDateTime=QDateTime::currentDateTime();\r\n    QList<QFESPIMB040OpticsSetupBase::measuredValues> measured;\r\n\r\n\r\n    bool ok=true;\r\n\r\n    //////////////////////////////////////////////////////////////////////////////////////\r\n    // get array of values\r\n    //////////////////////////////////////////////////////////////////////////////////////\r\n    QList<double> scanVals=this->stack();\r\n    if (scanVals.isEmpty()) {\r\n        QMessageBox::critical(this, tr(\"B040SPIM: Parameter Stack Acquisition\"), tr(\"No values to scan selected!\"));\r\n        return;\r\n    }\r\n    int images=scanVals.size()*this->images();\r\n\r\n\r\n    log->log_text(tr(\"starting parameter stack acquisition:\\n\"));\r\n    log->log_text(tr(\"  - scan parameter: %1\\n\").arg(this->stackParameterName()));\r\n    log->log_text(tr(\"  - scan mode: %1\\n\").arg(this->stackModeName()));\r\n    log->log_text(tr(\"  - scan start: %1\\n\").arg(this->stackStart()));\r\n    log->log_text(tr(\"  - scan end: %1\\n\").arg(this->stackEnd()));\r\n    log->log_text(tr(\"  - scan delta: %1\\n\").arg(this->stackDelta()));\r\n    opticsSetup->lockLightpath();\r\n\r\n\r\n    //////////////////////////////////////////////////////////////////////////////////////\r\n    // LOCK/INIT CAMERA 1\r\n    //////////////////////////////////////////////////////////////////////////////////////\r\n    bool useCam1=false;\r\n    QFExtension* extension1=NULL;\r\n    QFExtensionCamera* ecamera1=NULL;\r\n    int camera1=0;\r\n    QString acquisitionSettingsFilename1=\"\", previewSettingsFilename1=\"\";\r\n    QString acquisitionPrefix1=this->prefix1();\r\n    QString TIFFFIlename1=acquisitionPrefix1+\".tif\";\r\n    TIFF* tiff1=NULL;\r\n    if (this->use1()) {\r\n        if (!(useCam1=opticsSetup->lockCamera(0, &extension1, &ecamera1, &camera1, &previewSettingsFilename1))) {\r\n            CAMPARAMSTACK_ERROR(tr(\"error locking camer 1!\\n\"));\r\n        }\r\n    }\r\n    if (QFile::exists(this->currentConfigFilename(0))) acquisitionSettingsFilename1=this->currentConfigFilename(0);\r\n\r\n    //////////////////////////////////////////////////////////////////////////////////////\r\n    // LOCK/INIT CAMERA 2\r\n    //////////////////////////////////////////////////////////////////////////////////////\r\n    bool useCam2=false;\r\n    QFExtension* extension2=NULL;\r\n    QFExtensionCamera* ecamera2=NULL;\r\n    QString acquisitionSettingsFilename2=\"\", previewSettingsFilename2=\"\";\r\n    QString acquisitionPrefix2=this->prefix2();\r\n    QString TIFFFIlename2=acquisitionPrefix2+\".tif\";\r\n    TIFF* tiff2=NULL;\r\n    int camera2=0;\r\n    if (this->use2()) {\r\n        if(!(useCam2=opticsSetup->lockCamera(1, &extension2, &ecamera2, &camera2, &previewSettingsFilename2))) {\r\n            CAMPARAMSTACK_ERROR(tr(\"error locking camer 2!\\n\"));\r\n        }\r\n    }\r\n    if (QFile::exists(this->currentConfigFilename(1))) acquisitionSettingsFilename2=this->currentConfigFilename(1);\r\n\r\n    if (ok && !useCam1 && !useCam2) {\r\n        CAMPARAMSTACK_ERROR(tr(\"Cannot start image acquisition: No camera selected, or both cameras not usable!\"));\r\n        opticsSetup->unlockLightpath();\r\n        ok=false;\r\n    }\r\n\r\n\r\n    //////////////////////////////////////////////////////////////////////////////////////\r\n    // CHECK WHETHER HARDWRAE SUPPORTS CHANGING THE SELECTED PARAMETER\r\n    //////////////////////////////////////////////////////////////////////////////////////\r\n    int stackParamI=this->stackParameter();\r\n    QFExtensionCamera::CameraSetting stackParam=QFExtensionCamera::CameraSetting(stackParamI);\r\n    if (ok) {\r\n        if (stackParam>=0 && stackParam<=QFExtensionCamera::CamSetMaxParam) {\r\n            if (useCam1 && !ecamera1->isCameraSettingChangable(stackParam)) {\r\n                ok=false;\r\n                CAMPARAMSTACK_ERROR(tr(\"camera 1 does not support changing the %1!\\n\").arg(this->stackParameterName()));\r\n            }\r\n            if (ok && useCam2 && !ecamera2->isCameraSettingChangable(stackParam)) {\r\n                ok=false;\r\n                CAMPARAMSTACK_ERROR(tr(\"camera 2 does not support changing the %1!\\n\").arg(this->stackParameterName()));\r\n            }\r\n        } else {\r\n            ok=false;\r\n            CAMPARAMSTACK_ERROR(tr(\"invalid stack parameter %1 '%2'\\n\").arg(stackParam).arg(this->stackParameterName()));\r\n        }\r\n    }\r\n\r\n\r\n\r\n    if (ok) {\r\n        if (ok && useCam1) log->log_text(tr(\"  - storing files with prefix 1: '%1'\\n\").arg(acquisitionPrefix1));\r\n        if (ok && useCam2) log->log_text(tr(\"  - storing files with prefix 2: '%1'\\n\").arg(acquisitionPrefix2));\r\n\r\n        QProgressListDialog progress(tr(\"Parameter Stack Acquisition\"), tr(\"&Cancel\"), 0, 100, this);\r\n        progress.addItem(tr(\"preparation\"));\r\n        progress.addItem(tr(\"acquisition\"));\r\n        progress.addItem(tr(\"cleanup\"));\r\n        progress.setWindowModality(Qt::WindowModal);\r\n        progress.setValue(0);\r\n        progress.start();\r\n\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        // SET LIGHTPATH\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        opticsSetup->lockLighpathCombobox();\r\n        QString oldLightpath=opticsSetup->getCurrentLightpathFilename();\r\n        QString oldLightpathName=opticsSetup->getCurrentLightpath();\r\n        QString lightpathName=\"unknown\";\r\n        if (this->lightpathActivated()) {\r\n            if (!QFile::exists(this->lightpathFilename())) {\r\n                CAMPARAMSTACK_ERROR(tr(\"  - acquisition lighpath configuration '%1' does not exist!\\n\").arg(this->lightpath()));\r\n                opticsSetup->unlockLightpath();\r\n                return;\r\n\r\n            } else {\r\n                log->log_text(tr(\"  - setting acquisition lightpath settings '%1' ...\\n\").arg(this->lightpath()));\r\n                opticsSetup->loadLightpathConfig(this->lightpathFilename(), true, &lightpathName);\r\n                log->log_text(tr(\"  - setting acquisition lightpath settings '%1' ... DONE\\n\").arg(this->lightpath()));\r\n            }\r\n        }\r\n\r\n\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        // switch on light\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        bool formerMainShutterState=opticsSetup->getMainIlluminationShutter();\r\n        if (opticsSetup->isMainIlluminationShutterAvailable()){\r\n            log->log_text(tr(\"  - switch main shutter on!\\n\"));\r\n            opticsSetup->setMainIlluminationShutter(true, true);\r\n        }\r\n\r\n        QList<QVariant> realValues1, realValues2;\r\n        QTime timAcquisition=QTime::currentTime();\r\n        QDateTime timStart;\r\n        double duration=0;\r\n\r\n\r\n        progress.nextItem();\r\n        if (this->previewMode()) {\r\n            log->log_text(tr(\"acquiring stack in PREVIEW MODE ...\\n\"));\r\n\r\n\r\n            //////////////////////////////////////////////////////////////////////////////////////\r\n            // OPEN OUTPUT TIFF FILES\r\n            //////////////////////////////////////////////////////////////////////////////////////\r\n            progress.setLabelText(tr(\"opening output files ...\"));\r\n            QApplication::processEvents();\r\n            if (ok && useCam1) {\r\n                QDir().mkpath(QFileInfo(TIFFFIlename1.toLatin1().data()).absolutePath());\r\n                tiff1=TIFFOpen(TIFFFIlename1.toLatin1().data(), \"w\");\r\n                if (!tiff1) {\r\n                    ok=false;\r\n                    CAMPARAMSTACK_ERROR(tr(\"error opening TIFF file (camera 1) '%1'!\").arg(TIFFFIlename1));\r\n                }\r\n            }\r\n            if (ok && useCam2) {\r\n                QDir().mkpath(QFileInfo(TIFFFIlename2.toLatin1().data()).absolutePath());\r\n                tiff2=TIFFOpen(TIFFFIlename2.toLatin1().data(), \"w\");\r\n                if (!tiff2) {\r\n                    ok=false;\r\n                    CAMPARAMSTACK_ERROR(tr(\"error opening TIFF file (camera 2) '%1'!\").arg(TIFFFIlename2));\r\n                }\r\n            }\r\n\r\n\r\n\r\n            if (progress.wasCanceled()) {\r\n                log->log_warning(tr(\"canceled by user!\\n\"));\r\n                ok=false;\r\n            }\r\n\r\n\r\n\r\n            //////////////////////////////////////////////////////////////////////////////////////\r\n            // CHANGE PARAM, ACQUIRE IMAGE, CHANGE PARAM, ACQUIRE IMAGE, ...\r\n            //    images are stored in TIFF files using libtiff and they are (possibly) downscaled to 16-bit\r\n            //////////////////////////////////////////////////////////////////////////////////////\r\n            timAcquisition=QTime::currentTime();\r\n            duration=0;\r\n            if (ok) {\r\n                progress.setLabelText(tr(\"acquiring images ...\"));\r\n                bool running=ok;\r\n                //double newPos=stageStart;\r\n                int stackIdx=0;\r\n                int width1=0, height1=0;\r\n                uint32_t* buffer1=NULL;\r\n                int width2=0, height2=0;\r\n                uint32_t* buffer2=NULL;\r\n                int imageCnt=0;\r\n\r\n                measured.append(opticsSetup->getMeasuredValues());\r\n\r\n                while (running && (stackIdx<scanVals.size())) {\r\n\r\n                    if (ok && useCam1) {\r\n\r\n                        //////////////////////////////////////////////////////////////////////////////////////\r\n                        // PREPARE CAMERA 1\r\n                        //////////////////////////////////////////////////////////////////////////////////////\r\n                        if (ok && useCam1) {\r\n                            progress.setLabelText(tr(\"preparing camera 1 ...\"));\r\n                            QApplication::processEvents();\r\n\r\n                            QString tmpName1=QDir::temp().absoluteFilePath(\"qf3spimb040_cam1tmpsettings.ini\");\r\n\r\n                            QFTemporaryFile file1;\r\n                            if (file1.open()) {\r\n                                 tmpName1=file1.fileName();\r\n                            }\r\n                            if (QFile::exists(tmpName1)) QFile::remove(tmpName1);\r\n\r\n                            if (useCam1) QFile::copy(acquisitionSettingsFilename1, tmpName1);\r\n\r\n                            QSettings settings(tmpName1, QSettings::IniFormat);\r\n\r\n                            //QSettings settings(acquisitionSettingsFilename1, QSettings::IniFormat);\r\n\r\n                            ecamera1->changeCameraSetting(settings, stackParam, scanVals[stackIdx]);\r\n                            ecamera1->useCameraSettings(camera1, settings);\r\n                            realValues1.append(ecamera1->getCameraCurrentSetting(camera1, stackParam));\r\n                            //realValues1.append(ecamera1->getExposureTime(camera1));\r\n                            log->log_text(tr(\"  - prepared camer 1!\\n\"));\r\n                            width1=ecamera1->getCameraImageWidth(camera1);\r\n                            height1=ecamera1->getCameraImageHeight(camera1);\r\n                            buffer1=(uint32_t*)qfRealloc(buffer1, width1*height1*sizeof(uint32_t));\r\n                            if (!buffer1) {\r\n                                ok=false;\r\n                                CAMPARAMSTACK_ERROR(tr(\"could not allocate image buffer for camera 1!\\n\"));\r\n                            }\r\n                            if (QFile::exists(tmpName1)) QFile::remove(tmpName1);\r\n                        }\r\n                    }\r\n\r\n                    if (ok && useCam2) {\r\n\r\n                        //////////////////////////////////////////////////////////////////////////////////////\r\n                        // PREPARE CAMERA 1\r\n                        //////////////////////////////////////////////////////////////////////////////////////\r\n                        if (ok && useCam2) {\r\n                            progress.setLabelText(tr(\"preparing camera 2 ...\"));\r\n                            QApplication::processEvents();\r\n                            QString tmpName1=QDir::temp().absoluteFilePath(\"qf3spimb040_cam2tmpsettings.ini\");\r\n\r\n                            QFTemporaryFile file1;\r\n                            if (file1.open()) {\r\n                                 tmpName1=file1.fileName();\r\n                            }\r\n                            if (QFile::exists(tmpName1)) QFile::remove(tmpName1);\r\n\r\n                            if (useCam2) QFile::copy(acquisitionSettingsFilename2, tmpName1);\r\n\r\n                            QSettings settings(tmpName1, QSettings::IniFormat);\r\n\r\n                            ecamera2->changeCameraSetting(settings, stackParam, scanVals[stackIdx]);\r\n                            ecamera2->useCameraSettings(camera2, settings);\r\n                            realValues2.append(ecamera2->getCameraCurrentSetting(camera2, stackParam));\r\n                            //realValues2.append(ecamera2->getExposureTime(camera2));\r\n                            log->log_text(tr(\"  - prepared camer 2!\\n\"));\r\n                            width2=ecamera2->getCameraImageWidth(camera2);\r\n                            height2=ecamera2->getCameraImageHeight(camera2);\r\n                            buffer2=(uint32_t*)qfRealloc(buffer2, width2*height2*sizeof(uint32_t));\r\n                            if (!buffer2) {\r\n                                ok=false;\r\n                                CAMPARAMSTACK_ERROR(tr(\"could not allocate image buffer for camera 2!\\n\"));\r\n                            }\r\n                            if (QFile::exists(tmpName1)) QFile::remove(tmpName1);\r\n                        }\r\n                    }\r\n\r\n                    QApplication::processEvents();\r\n                    if (progress.wasCanceled()) {\r\n                        running=false;\r\n                        log->log_warning(tr(\"  - acquisition canceled by user!\\n\"));\r\n                    } else {\r\n                        for (int img=0; img<this->images(); img++) {\r\n                            log->log_text(tr(\"acquiring images (%1/%2) ...\\n\").arg(imageCnt+1).arg(images));\r\n                            progress.setLabelText(tr(\"acquiring images (%1/%2) ...\").arg(imageCnt+1).arg(images));\r\n                            QApplication::processEvents();\r\n                            if (progress.wasCanceled()) {\r\n                                running=false;\r\n                                log->log_warning(tr(\"  - acquisition canceled by user!\\n\"));\r\n                                break;\r\n                            }\r\n                            if (stackIdx==0) {\r\n                                timAcquisition.start();\r\n                                timStart=QDateTime::currentDateTime();\r\n                            }\r\n                            if (useCam1) {\r\n                                if (ecamera1->acquireOnCamera(camera1, buffer1)) {\r\n                                    TIFFTWriteUint16from32(tiff1, buffer1, width1, height1, false);\r\n                                    TIFFWriteDirectory(tiff1);\r\n                                } else {\r\n                                    ok=false;\r\n                                    CAMPARAMSTACK_ERROR(tr(\"error acquiring image %1/%2 on camera 1!\\n\").arg(imageCnt+1).arg(images));\r\n                                }\r\n                            }\r\n                            //QApplication::processEvents();\r\n                            if (useCam2) {\r\n                                if (ecamera2->acquireOnCamera(camera2, buffer2)) {\r\n                                    TIFFTWriteUint16from32(tiff2, buffer2, width2, height2, false);\r\n                                    TIFFWriteDirectory(tiff2);\r\n                                } else {\r\n                                    ok=false;\r\n                                    CAMPARAMSTACK_ERROR(tr(\"error acquiring image %1/%2 on camera 2!\\n\").arg(imageCnt+1).arg(images));\r\n                                }\r\n                            }\r\n                            imageCnt++;\r\n                        }\r\n                        if (this->saveMeasurements()) measured.append(opticsSetup->getMeasuredValues());\r\n                        //QApplication::processEvents();\r\n                    }\r\n                    if (!ok) running=false;\r\n\r\n                    stackIdx++;\r\n                    progress.setValue((int)round((double)stackIdx/(double)scanVals.size()*100.0));\r\n                    QApplication::processEvents();\r\n                }\r\n                duration=timAcquisition.elapsed()/1000.0;\r\n                if (buffer1) qfFree(buffer1);\r\n                if (buffer2) qfFree(buffer2);\r\n                buffer1=buffer2=NULL;\r\n\r\n            }\r\n        } else {\r\n            log->log_text(tr(\"acquiring stack in ACQUISITION MODE ...\\n\"));\r\n\r\n            if (progress.wasCanceled()) {\r\n                log->log_warning(tr(\"canceled by user!\\n\"));\r\n                ok=false;\r\n            }\r\n            QMap<QString, QVariant> acquisitionDescription1;\r\n            QList<QFExtensionCamera::CameraAcquititonFileDescription> moreFiles1;\r\n            QMap<QString, QVariant> acquisitionDescription2;\r\n            QList<QFExtensionCamera::CameraAcquititonFileDescription> moreFiles2;\r\n\r\n            //////////////////////////////////////////////////////////////////////////////////////\r\n            // CHANGE PARAM, ACQUIRE IMAGE, CHANGE PARAM, ACQUIRE IMAGE, ...\r\n            //    images are stored in TIFF files using libtiff and they are (possibly) downscaled to 16-bit\r\n            //////////////////////////////////////////////////////////////////////////////////////\r\n            timAcquisition=QTime::currentTime();\r\n            duration=0;\r\n            if (ok) {\r\n                progress.setLabelText(tr(\"acquiring images ...\"));\r\n                bool running=ok;\r\n                //double newPos=stageStart;\r\n                int stackIdx=0;\r\n                int width1=0, height1=0;\r\n                uint32_t* buffer1=NULL;\r\n                int width2=0, height2=0;\r\n                uint32_t* buffer2=NULL;\r\n                int imageCnt=0;\r\n                int frames=this->images();\r\n\r\n                measured.append(opticsSetup->getMeasuredValues());\r\n\r\n                while (running && (stackIdx<scanVals.size())) {\r\n                    QString tmpName1=QDir::temp().absoluteFilePath(\"qf3spimb040_cam1tmpsettings.ini\");\r\n\r\n                    QFTemporaryFile file1;\r\n                    if (file1.open()) {\r\n                         tmpName1=file1.fileName();\r\n                    }\r\n                    if (QFile::exists(tmpName1)) QFile::remove(tmpName1);\r\n                    if (useCam1) QFile::copy(acquisitionSettingsFilename1, tmpName1);\r\n                    QSettings settings1(tmpName1, QSettings::IniFormat);\r\n                    if (frames>0 && ecamera1->isCameraSettingChangable(QFExtensionCamera::CamSetNumberFrames)) ecamera1->changeCameraSetting(settings1, QFExtensionCamera::CamSetNumberFrames, frames);\r\n                    ecamera1->changeCameraSetting(settings1, stackParam, scanVals[stackIdx]);\r\n\r\n\r\n\r\n\r\n\r\n\r\n                    QString tmpName2=QDir::temp().absoluteFilePath(\"qf3spimb040_cam2tmpsettings.ini\");\r\n\r\n                    QFTemporaryFile file2;\r\n                    if (file2.open()) {\r\n                         tmpName2=file2.fileName();\r\n                    }\r\n                    if (QFile::exists(tmpName2)) QFile::remove(tmpName2);\r\n\r\n                    if (useCam2) QFile::copy(acquisitionSettingsFilename2, tmpName2);\r\n\r\n                    QSettings settings2(tmpName2, QSettings::IniFormat);\r\n\r\n                    if (frames>0 && ecamera2->isCameraSettingChangable(QFExtensionCamera::CamSetNumberFrames)) ecamera2->changeCameraSetting(settings2, QFExtensionCamera::CamSetNumberFrames, frames);\r\n                    ecamera2->changeCameraSetting(settings2, stackParam, scanVals[stackIdx]);\r\n\r\n\r\n\r\n\r\n                    //////////////////////////////////////////////////////////////////////////////////////\r\n                    // acquire image series\r\n                    //////////////////////////////////////////////////////////////////////////////////////\r\n                    ok = acqTools->acquireSeries(lightpathName, QString(\"camstack%1\").arg(stackIdx,4,10,QLatin1Char('0')), tr(\"cam parameter stack\"), useCam1, extension1, ecamera1, camera1, acquisitionPrefix1+QString(\"__sidx%1\").arg(stackIdx,4,10,QLatin1Char('0')), settings1, acquisitionDescription1, moreFiles1, useCam2, extension2, ecamera2, camera2, acquisitionPrefix2+QString(\"__sidx%1\").arg(stackIdx,4,10,QLatin1Char('0')), settings2, acquisitionDescription2, moreFiles2, &measured, &progress, NULL);\r\n                    if (!ok) {\r\n                        if (frames>1) {\r\n                            CAMPARAMSTACK_ERROR(tr(\"error acquiring image (%1...%2)/%3 !\\n\").arg(imageCnt+1).arg(imageCnt+1+frames).arg(images));\r\n                        } else {\r\n                            CAMPARAMSTACK_ERROR(tr(\"error acquiring image %1/%2 !\\n\").arg(imageCnt+1).arg(images));\r\n                        }\r\n                    }\r\n\r\n                    if (QFile::exists(tmpName1)) QFile::remove(tmpName1);\r\n                    if (QFile::exists(tmpName2)) QFile::remove(tmpName2);\r\n\r\n                    if (!ok) running=false;\r\n\r\n                    stackIdx++;\r\n                    imageCnt+=frames;\r\n                    progress.setValue((int)round((double)stackIdx/(double)scanVals.size()*100.0));\r\n                    QApplication::processEvents();\r\n\r\n                    if (progress.wasCanceled()) {\r\n                        running=false;\r\n                        log->log_error(tr(\"CANCELED BY USER!\\n\"));\r\n                    }\r\n                }\r\n                duration=timAcquisition.elapsed()/1000.0;\r\n                if (buffer1) qfFree(buffer1);\r\n                if (buffer2) qfFree(buffer2);\r\n                buffer1=buffer2=NULL;\r\n\r\n            }\r\n        }\r\n        progress.setValue(100);\r\n        measured.append(opticsSetup->getMeasuredValues());\r\n        progress.nextItem();\r\n\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        // collect lightpath data common to all cameras\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        QMap<QString, QVariant> acquisitionDescription;\r\n        opticsSetup->saveLightpathConfig(acquisitionDescription, \"\", \"lightpath/\");\r\n\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        // switch on/off light\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        if (opticsSetup->isMainIlluminationShutterAvailable()){\r\n            log->log_text(tr(\"  - switch main shutter %1!\\n\").arg((formerMainShutterState)?tr(\"on\"):tr(\"off\")));\r\n            opticsSetup->setMainIlluminationShutter(formerMainShutterState, true);\r\n        }\r\n\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        // RESET LIGHTPATH\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        if (this->lightpathActivated()) {\r\n            opticsSetup->loadLightpathConfig(oldLightpath, false);\r\n            log->log_text(tr(\"  - resetting to old lightpath settings (%1) ...\\n\").arg(oldLightpath));//Name));\r\n        }\r\n        opticsSetup->unlockLighpathCombobox();\r\n\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        // close tiff files and free buffers\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        progress.setLabelText(tr(\"closing output files ...\"));\r\n        QApplication::processEvents();\r\n        if (tiff1) TIFFClose(tiff1);\r\n        if (tiff2) TIFFClose(tiff2);\r\n        tiff1=tiff2=NULL;\r\n\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        // collect acquisition data common to all cameras\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        QString scanCSV;\r\n        if (ok) {\r\n            acquisitionDescription[\"type\"]=\"parameter stack\";\r\n            acquisitionDescription[\"stack_parameter\"]=this->stackParameterName();\r\n            acquisitionDescription[\"stack_mode\"]=this->stackModeName();\r\n            acquisitionDescription[\"stack_start\"]=this->stackStart();\r\n            acquisitionDescription[\"stack_delta\"]=this->stackDelta();\r\n            acquisitionDescription[\"stack_end\"]=this->stackEnd();\r\n            acquisitionDescription[\"sequence_overall_length\"]=images;\r\n            acquisitionDescription[\"images_per_step\"]=this->images();\r\n            acquisitionDescription[\"stack_length\"]=scanVals.size();\r\n            acquisitionDescription[\"start_time\"]=timStart;\r\n            acquisitionDescription[\"duration\"]=duration;\r\n            acquisitionDescription[\"stack_value_count\"]=scanVals.size();\r\n            acquisitionDescription[\"stack_values\"]=CDoubleListToQString(scanVals);\r\n            if (useCam1) acquisitionDescription[\"real_stack_values/camera1\"]=realValues1;\r\n            if (useCam2) acquisitionDescription[\"real_stack_values/camera2\"]=realValues2;\r\n\r\n\r\n\r\n            QTextStream pf(&scanCSV);\r\n            pf<<\"# number,   ideal value\";\r\n            if (useCam1) pf<<\",   real value camera1\";\r\n            if (useCam2) pf<<\",   real value camera2\";\r\n            pf<<\"\\n\";\r\n            for (int i=0; i<qMin(scanVals.size(), qMax(realValues1.size(), realValues2.size())); i++) {\r\n                pf<<i<<\", \"<<CDoubleToQString(scanVals[i]);\r\n                if (useCam1 && i<realValues1.size()) pf<<\", \"<<CDoubleToQString(realValues1[i].toDouble());\r\n                if (useCam2 && i<realValues2.size()) pf<<\", \"<<CDoubleToQString(realValues2[i].toDouble());\r\n                pf<<\"\\n\";\r\n            }\r\n        }\r\n\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        // write image stack properties to files, also collects camera specific information\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        if (ok && useCam1) {\r\n            QMap<QString, QVariant> acquisitionDescription1=acquisitionDescription;\r\n            QList<QFExtensionCamera::CameraAcquititonFileDescription> files;\r\n            QFExtensionCamera::CameraAcquititonFileDescription d;\r\n            d.name=TIFFFIlename1;\r\n            d.description=\"image stack from camera 1\";\r\n            d.type=\"TIFF16\";\r\n            files.append(d);\r\n\r\n\r\n            QString ParamValuesFilename=acquisitionPrefix1+\".param.dat\";\r\n            QFile posFile(ParamValuesFilename);\r\n            if (posFile.open(QIODevice::WriteOnly)) {\r\n                posFile.write(scanCSV.toLatin1().data());\r\n                posFile.close();\r\n                d.name=ParamValuesFilename;\r\n                d.description=\"parameter values\";\r\n                d.type=\"CSV\";\r\n                files.append(d);\r\n            } else {\r\n                log->log_error(tr(\"  - could not write parameter values file '%1' for camera 1: %2 ...\").arg(ParamValuesFilename).arg(posFile.errorString()));\r\n            }\r\n\r\n            QString MeasurementsFilename=acqTools->saveMeasuredData(acquisitionPrefix1, measured);\r\n            if (!MeasurementsFilename.isEmpty() && QFile::exists(MeasurementsFilename)) {\r\n                QFExtensionCamera::CameraAcquititonFileDescription d;\r\n                d.name=MeasurementsFilename;\r\n                d.description=\"measureable properties of setup\";\r\n                d.type=\"CSV\";\r\n                files.append(d);\r\n            }\r\n\r\n            log->log_text(tr(\"  - writing acquisition description 1 ...\"));\r\n            acqTools->savePreviewDescription(0, extension1, ecamera1, camera1, acquisitionPrefix1, acquisitionDescription1, files, startDateTime);\r\n            log->log_text(tr(\" DONE!\\n\"));\r\n        }\r\n        if (ok && useCam2) {\r\n            QMap<QString, QVariant> acquisitionDescription2=acquisitionDescription;\r\n            QList<QFExtensionCamera::CameraAcquititonFileDescription> files;\r\n            QFExtensionCamera::CameraAcquititonFileDescription d;\r\n            d.name=TIFFFIlename1;\r\n            d.description=\"image stack from camera 2\";\r\n            d.type=\"TIFF16\";\r\n            files.append(d);\r\n\r\n\r\n            QString ParamValuesFilename=acquisitionPrefix2+\".param.dat\";\r\n            QFile posFile(ParamValuesFilename);\r\n            if (posFile.open(QIODevice::WriteOnly)) {\r\n                posFile.write(scanCSV.toLatin1().data());\r\n                posFile.close();\r\n                d.name=ParamValuesFilename;\r\n                d.description=\"parameter values\";\r\n                d.type=\"CSV\";\r\n                files.append(d);\r\n            } else {\r\n                log->log_error(tr(\"  - could not write parameter values file '%1' for camera 2: %2 ...\").arg(ParamValuesFilename).arg(posFile.errorString()));\r\n            }\r\n\r\n            QString MeasurementsFilename=acqTools->saveMeasuredData(acquisitionPrefix2, measured);\r\n            if (!MeasurementsFilename.isEmpty() && QFile::exists(MeasurementsFilename)) {\r\n                QFExtensionCamera::CameraAcquititonFileDescription d;\r\n                d.name=MeasurementsFilename;\r\n                d.description=\"measureable properties of setup\";\r\n                d.type=\"CSV\";\r\n                files.append(d);\r\n            }\r\n\r\n\r\n            log->log_text(tr(\"  - writing acquisition description 2 ...\"));\r\n            acqTools->savePreviewDescription(1, extension2, ecamera2, camera2, acquisitionPrefix2, acquisitionDescription2, files, startDateTime);\r\n            log->log_text(tr(\" DONE!\\n\"));\r\n        }\r\n\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        // release cameras\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        if (useCam1) {\r\n            opticsSetup->releaseCamera(0);\r\n            log->log_text(tr(\"  - released camera 1!\\n\"));\r\n        }\r\n        if (useCam2) {\r\n            opticsSetup->releaseCamera(1);\r\n            log->log_text(tr(\"  - released camera 2!\\n\"));\r\n        }\r\n\r\n        if (ok && useCam1) log->log_text(tr(\"  - stored files with prefix 1: '%1'\\n\").arg(acquisitionPrefix1));\r\n        if (ok && useCam2) log->log_text(tr(\"  - stored files with prefix 2: '%1'\\n\").arg(acquisitionPrefix2));\r\n\r\n        if (ok) log->log_text(tr(\"image stack acquisition DONE!\\n\"));\r\n    }\r\n    opticsSetup->unlockLightpath();\r\n    opticsSetup->ensureLightpath();\r\n}",
    "void QFESPIMB040DeviceParamStackConfigWidget::performStack()\r\n{\r\n\r\n    if (!(use1() || use2())) {\r\n        QMessageBox::critical(this, tr(\"B040SPIM: Parameter Stack Acquisition\"), tr(\"Cannot start image acquisition: No camera selected!\"));\r\n        return;\r\n    }\r\n\r\n    QDateTime startDateTime=QDateTime::currentDateTime();\r\n    QList<QFESPIMB040OpticsSetupBase::measuredValues> measured;\r\n    QList<QFExtensionCamera::CameraAcquititonFileDescription> files1, files2;\r\n    QMap<QString, QVariant> finalAcquisitionDescription1;\r\n    QMap<QString, QVariant> finalAcquisitionDescription2;\r\n\r\n\r\n    bool ok=true;\r\n\r\n    //////////////////////////////////////////////////////////////////////////////////////\r\n    // get array of values\r\n    //////////////////////////////////////////////////////////////////////////////////////\r\n    QList<double> scanVals=stack();\r\n    if (scanVals.isEmpty()) {\r\n        QMessageBox::critical(this, tr(\"B040SPIM: Parameter Stack Acquisition\"), tr(\"No values to scan selected!\"));\r\n        return;\r\n    }\r\n    int images=scanVals.size()*numImages();\r\n\r\n\r\n    log->log_text(tr(\"starting parameter stack acquisition:\\n\"));\r\n    log->log_text(tr(\"  - scan parameter: %1\\n\").arg(stackParameterName()));\r\n    log->log_text(tr(\"  - scan mode: %1\\n\").arg(stackModeName()));\r\n    log->log_text(tr(\"  - scan start: %1\\n\").arg(stackStart()));\r\n    log->log_text(tr(\"  - scan end: %1\\n\").arg(stackEnd()));\r\n    log->log_text(tr(\"  - scan delta: %1\\n\").arg(stackDelta()));\r\n    opticsSetup->lockLightpath();\r\n\r\n\r\n    //////////////////////////////////////////////////////////////////////////////////////\r\n    // LOCK/INIT CAMERA 1\r\n    //////////////////////////////////////////////////////////////////////////////////////\r\n    bool useCam1=false;\r\n    QFExtension* extension1=NULL;\r\n    QFExtensionCamera* ecamera1=NULL;\r\n    int camera1=0;\r\n    QString acquisitionSettingsFilename1=\"\", previewSettingsFilename1=\"\";\r\n    QString acquisitionPrefix1=prefix1();\r\n    QString TIFFFIlename1=acquisitionPrefix1+\".tif\";\r\n    TIFF* tiff1=NULL;\r\n    if (use1()) {\r\n        if (!(useCam1=opticsSetup->lockCamera(0, &extension1, &ecamera1, &camera1, &previewSettingsFilename1))) {\r\n            CAMPARAMSTACK_ERROR(tr(\"error locking camer 1!\\n\"));\r\n        }\r\n    }\r\n    if (QFile::exists(currentConfigFilename(0))) acquisitionSettingsFilename1=currentConfigFilename(0);\r\n\r\n    //////////////////////////////////////////////////////////////////////////////////////\r\n    // LOCK/INIT CAMERA 2\r\n    //////////////////////////////////////////////////////////////////////////////////////\r\n    bool useCam2=false;\r\n    QFExtension* extension2=NULL;\r\n    QFExtensionCamera* ecamera2=NULL;\r\n    QString acquisitionSettingsFilename2=\"\", previewSettingsFilename2=\"\";\r\n    QString acquisitionPrefix2=prefix2();\r\n    QString TIFFFIlename2=acquisitionPrefix2+\".tif\";\r\n    TIFF* tiff2=NULL;\r\n    int camera2=0;\r\n    if (use2()) {\r\n        if(!(useCam2=opticsSetup->lockCamera(1, &extension2, &ecamera2, &camera2, &previewSettingsFilename2))) {\r\n            CAMPARAMSTACK_ERROR(tr(\"error locking camer 2!\\n\"));\r\n        }\r\n    }\r\n    if (QFile::exists(currentConfigFilename(1))) acquisitionSettingsFilename2=currentConfigFilename(1);\r\n\r\n    if (ok && !useCam1 && !useCam2) {\r\n        CAMPARAMSTACK_ERROR(tr(\"Cannot start image acquisition: No camera selected, or both cameras not usable!\"));\r\n        opticsSetup->unlockLightpath();\r\n        ok=false;\r\n    }\r\n\r\n\r\n\r\n\r\n    if (ok) {\r\n        if (ok && useCam1) log->log_text(tr(\"  - storing files with prefix 1: '%1'\\n\").arg(acquisitionPrefix1));\r\n        if (ok && useCam2) log->log_text(tr(\"  - storing files with prefix 2: '%1'\\n\").arg(acquisitionPrefix2));\r\n\r\n        QProgressListDialog progress(tr(\"Parameter Stack Acquisition\"), tr(\"&Cancel\"), 0, 100, this);\r\n        progress.addItem(tr(\"preparation\"));\r\n        progress.addItem(tr(\"acquisition\"));\r\n        progress.addItem(tr(\"cleanup\"));\r\n        progress.setWindowModality(Qt::WindowModal);\r\n        progress.setValue(0);\r\n        progress.start();\r\n        progress.show();\r\n\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        // SET LIGHTPATH\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        QString oldLightpath=opticsSetup->getCurrentLightpathFilename();\r\n        QString oldLightpathName=opticsSetup->getCurrentLightpath();\r\n        QString lightpathName=\"unknown\";\r\n        if (lightpathActivated()) {\r\n            if (!QFile::exists(lightpathFilename())) {\r\n                CAMPARAMSTACK_ERROR(tr(\"  - acquisition lighpath configuration '%1' does not exist!\\n\").arg(lightpath()));\r\n                opticsSetup->unlockLightpath();\r\n                return;\r\n\r\n            } else {\r\n                log->log_text(tr(\"  - setting acquisition lightpath settings '%1' ...\\n\").arg(lightpath()));\r\n                opticsSetup->loadLightpathConfig(lightpathFilename(), true, &lightpathName);\r\n                log->log_text(tr(\"  - setting acquisition lightpath settings '%1' ... DONE\\n\").arg(lightpath()));\r\n            }\r\n        }\r\n\r\n\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        // switch on light\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        bool formerMainShutterState=opticsSetup->getMainIlluminationShutter();\r\n        if (opticsSetup->isMainIlluminationShutterAvailable()){\r\n            log->log_text(tr(\"  - switch main shutter on!\\n\"));\r\n            opticsSetup->setMainIlluminationShutter(true, true);\r\n        }\r\n\r\n        QList<QVariant> realValues;\r\n        QTime timAcquisition=QTime::currentTime();\r\n        QDateTime timStart;\r\n        double duration=0;\r\n        int stackParam=ui->cmbParameter->currentIndex();\r\n\r\n\r\n        progress.nextItem();\r\n        if (previewMode()) {\r\n            log->log_text(tr(\"acquiring stack in PREVIEW MODE ...\\n\"));\r\n\r\n\r\n            //////////////////////////////////////////////////////////////////////////////////////\r\n            // OPEN OUTPUT TIFF FILES\r\n            //////////////////////////////////////////////////////////////////////////////////////\r\n            progress.setLabelText(tr(\"opening output files ...\"));\r\n            QApplication::processEvents();\r\n            if (ok && useCam1) {\r\n                QDir().mkpath(QFileInfo(TIFFFIlename1.toLatin1().data()).absolutePath());\r\n                tiff1=TIFFOpen(TIFFFIlename1.toLatin1().data(), \"w\");\r\n                if (!tiff1) {\r\n                    ok=false;\r\n                    CAMPARAMSTACK_ERROR(tr(\"error opening TIFF file (camera 1) '%1'!\").arg(TIFFFIlename1));\r\n                }\r\n            }\r\n            if (ok && useCam2) {\r\n                QDir().mkpath(QFileInfo(TIFFFIlename2.toLatin1().data()).absolutePath());\r\n                tiff2=TIFFOpen(TIFFFIlename2.toLatin1().data(), \"w\");\r\n                if (!tiff2) {\r\n                    ok=false;\r\n                    CAMPARAMSTACK_ERROR(tr(\"error opening TIFF file (camera 2) '%1'!\").arg(TIFFFIlename2));\r\n                }\r\n            }\r\n\r\n\r\n\r\n            if (progress.wasCanceled()) {\r\n                log->log_warning(tr(\"canceled by user!\\n\"));\r\n                ok=false;\r\n            }\r\n\r\n\r\n\r\n            //////////////////////////////////////////////////////////////////////////////////////\r\n            // CHANGE PARAM, ACQUIRE IMAGE, CHANGE PARAM, ACQUIRE IMAGE, ...\r\n            //    images are stored in TIFF files using libtiff and they are (possibly) downscaled to 16-bit\r\n            //////////////////////////////////////////////////////////////////////////////////////\r\n            timAcquisition=QTime::currentTime();\r\n            duration=0;\r\n            if (ok) {\r\n                progress.setLabelText(tr(\"acquiring images ...\"));\r\n                bool running=ok;\r\n                //double newPos=stageStart;\r\n                int stackIdx=0;\r\n                int width1=0, height1=0;\r\n                uint32_t* buffer1=NULL;\r\n                int width2=0, height2=0;\r\n                uint32_t* buffer2=NULL;\r\n                int imageCnt=0;\r\n\r\n                measured.append(opticsSetup->getMeasuredValues());\r\n\r\n                while (running && (stackIdx<scanVals.size())) {\r\n\r\n                    //////////////////////////////////////////////////////////////////////////////////////\r\n                    // set device parameter and poosibly wait the set delay\r\n                    //////////////////////////////////////////////////////////////////////////////////////\r\n                    if (ok) {\r\n                        setDeviceParameter(stackParam, scanVals[stackIdx]);\r\n                        if (ui->spinDelay->value()>0) {\r\n                            QTime tDelay=QTime::currentTime();\r\n                            while (double(tDelay.elapsed())<ui->spinDelay->value()) {\r\n                                QApplication::processEvents();\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if (ok && useCam1) {\r\n\r\n                        //////////////////////////////////////////////////////////////////////////////////////\r\n                        // PREPARE CAMERA 1\r\n                        //////////////////////////////////////////////////////////////////////////////////////\r\n                        if (ok && useCam1) {\r\n                            progress.setLabelText(tr(\"preparing camera 1 ...\"));\r\n                            QApplication::processEvents();\r\n\r\n                            QString tmpName1=QDir::temp().absoluteFilePath(\"qf3spimb040_cam1tmpsettings.ini\");\r\n\r\n                            QFTemporaryFile file1;\r\n                            if (file1.open()) {\r\n                                 tmpName1=file1.fileName();\r\n                            }\r\n                            if (QFile::exists(tmpName1)) QFile::remove(tmpName1);\r\n\r\n                            if (useCam1) QFile::copy(acquisitionSettingsFilename1, tmpName1);\r\n\r\n                            QSettings settings(tmpName1, QSettings::IniFormat);\r\n\r\n                            ecamera1->useCameraSettings(camera1, settings);\r\n                            log->log_text(tr(\"  - prepared camera 1!\\n\"));\r\n                            width1=ecamera1->getCameraImageWidth(camera1);\r\n                            height1=ecamera1->getCameraImageHeight(camera1);\r\n                            buffer1=(uint32_t*)qfRealloc(buffer1, width1*height1*sizeof(uint32_t));\r\n                            if (!buffer1) {\r\n                                ok=false;\r\n                                CAMPARAMSTACK_ERROR(tr(\"could not allocate image buffer for camera 1!\\n\"));\r\n                            }\r\n                            if (QFile::exists(tmpName1)) QFile::remove(tmpName1);\r\n                        }\r\n                    }\r\n\r\n                    if (ok && useCam2) {\r\n\r\n                        //////////////////////////////////////////////////////////////////////////////////////\r\n                        // PREPARE CAMERA 1\r\n                        //////////////////////////////////////////////////////////////////////////////////////\r\n                        if (ok && useCam2) {\r\n                            progress.setLabelText(tr(\"preparing camera 2 ...\"));\r\n                            QApplication::processEvents();\r\n                            QString tmpName1=QDir::temp().absoluteFilePath(\"qf3spimb040_cam2tmpsettings.ini\");\r\n\r\n                            QFTemporaryFile file1;\r\n                            if (file1.open()) {\r\n                                 tmpName1=file1.fileName();\r\n                            }\r\n                            if (QFile::exists(tmpName1)) QFile::remove(tmpName1);\r\n\r\n                            if (useCam2) QFile::copy(acquisitionSettingsFilename2, tmpName1);\r\n\r\n                            QSettings settings(tmpName1, QSettings::IniFormat);\r\n\r\n                            ecamera2->useCameraSettings(camera2, settings);\r\n                            log->log_text(tr(\"  - prepared camera 2!\\n\"));\r\n                            width2=ecamera2->getCameraImageWidth(camera2);\r\n                            height2=ecamera2->getCameraImageHeight(camera2);\r\n                            buffer2=(uint32_t*)qfRealloc(buffer2, width2*height2*sizeof(uint32_t));\r\n                            if (!buffer2) {\r\n                                ok=false;\r\n                                CAMPARAMSTACK_ERROR(tr(\"could not allocate image buffer for camera 2!\\n\"));\r\n                            }\r\n                            if (QFile::exists(tmpName1)) QFile::remove(tmpName1);\r\n                        }\r\n                    }\r\n\r\n                    QApplication::processEvents();\r\n                    if (progress.wasCanceled()) {\r\n                        running=false;\r\n                        log->log_warning(tr(\"  - acquisition canceled by user!\\n\"));\r\n                    } else {\r\n                        for (int img=0; img<numImages(); img++) {\r\n                            log->log_text(tr(\"acquiring images (%1/%2) ...\\n\").arg(imageCnt+1).arg(images));\r\n                            progress.setLabelText(tr(\"acquiring images (%1/%2) ...\").arg(imageCnt+1).arg(images));\r\n                            QApplication::processEvents();\r\n                            if (progress.wasCanceled()) {\r\n                                running=false;\r\n                                log->log_warning(tr(\"  - acquisition canceled by user!\\n\"));\r\n                                break;\r\n                            }\r\n                            if (stackIdx==0) {\r\n                                timAcquisition.start();\r\n                                timStart=QDateTime::currentDateTime();\r\n                            }\r\n                            if (useCam1) {\r\n                                if (ecamera1->acquireOnCamera(camera1, buffer1)) {\r\n                                    TIFFTWriteUint16from32(tiff1, buffer1, width1, height1, false);\r\n                                    TIFFWriteDirectory(tiff1);\r\n                                } else {\r\n                                    ok=false;\r\n                                    CAMPARAMSTACK_ERROR(tr(\"error acquiring image %1/%2 on camera 1!\\n\").arg(imageCnt+1).arg(images));\r\n                                }\r\n                            }\r\n                            //QApplication::processEvents();\r\n                            if (useCam2) {\r\n                                if (ecamera2->acquireOnCamera(camera2, buffer2)) {\r\n                                    TIFFTWriteUint16from32(tiff2, buffer2, width2, height2, false);\r\n                                    TIFFWriteDirectory(tiff2);\r\n                                } else {\r\n                                    ok=false;\r\n                                    CAMPARAMSTACK_ERROR(tr(\"error acquiring image %1/%2 on camera 2!\\n\").arg(imageCnt+1).arg(images));\r\n                                }\r\n                            }\r\n                            realValues.append(getDeviceParameter(stackParam));\r\n                            imageCnt++;\r\n                        }\r\n                        if (saveMeasurements()) measured.append(opticsSetup->getMeasuredValues());\r\n                        //QApplication::processEvents();\r\n                    }\r\n                    if (!ok) running=false;\r\n\r\n                    stackIdx++;\r\n                    progress.setValue((int)round((double)stackIdx/(double)scanVals.size()*100.0));\r\n                    QApplication::processEvents();\r\n                }\r\n                duration=timAcquisition.elapsed()/1000.0;\r\n                if (buffer1) qfFree(buffer1);\r\n                if (buffer2) qfFree(buffer2);\r\n                buffer1=buffer2=NULL;\r\n\r\n            }\r\n\r\n            //////////////////////////////////////////////////////////////////////////////////////\r\n            // close tiff files and free buffers\r\n            //////////////////////////////////////////////////////////////////////////////////////\r\n            progress.setLabelText(tr(\"closing output files ...\"));\r\n            QApplication::processEvents();\r\n            if (tiff1) TIFFClose(tiff1);\r\n            if (tiff2) TIFFClose(tiff2);\r\n            tiff1=tiff2=NULL;\r\n        } else {\r\n            log->log_text(tr(\"acquiring stack in ACQUISITION MODE ...\\n\"));\r\n\r\n            if (progress.wasCanceled()) {\r\n                log->log_warning(tr(\"canceled by user!\\n\"));\r\n                ok=false;\r\n            }\r\n            QList<QFExtensionCamera::CameraAcquititonFileDescription> moreFiles1;\r\n            QMap<QString, QVariant> acquisitionDescription1;\r\n            QMap<QString, QVariant> acquisitionDescription2;\r\n            QList<QFExtensionCamera::CameraAcquititonFileDescription> moreFiles2;\r\n\r\n\r\n            //////////////////////////////////////////////////////////////////////////////////////\r\n            // CHANGE PARAM, ACQUIRE IMAGE, CHANGE PARAM, ACQUIRE IMAGE, ...\r\n            //    images are stored in TIFF files using libtiff and they are (possibly) downscaled to 16-bit\r\n            //////////////////////////////////////////////////////////////////////////////////////\r\n            timAcquisition=QTime::currentTime();\r\n            duration=0;\r\n            if (ok) {\r\n                progress.setLabelText(tr(\"acquiring images ...\"));\r\n                bool running=ok;\r\n                //double newPos=stageStart;\r\n                int stackIdx=0;\r\n                int width1=0, height1=0;\r\n                uint32_t* buffer1=NULL;\r\n                int width2=0, height2=0;\r\n                uint32_t* buffer2=NULL;\r\n                int imageCnt=0;\r\n                int frames=numImages();\r\n                QMap<QFExtensionCamera::CameraSetting, QVariant> camset1, camset2;\r\n                QMap<QString, QVariant> camsetstr1, camsetstr2;\r\n                camset1[QFExtensionCamera::CamSetNumberFrames]=frames;\r\n                camset2[QFExtensionCamera::CamSetNumberFrames]=frames;\r\n\r\n                measured.append(opticsSetup->getMeasuredValues());\r\n\r\n                while (running && (stackIdx<scanVals.size())) {\r\n                    log->log_text(tr(\"  - setting device parameter to %1 ... \").arg(scanVals[stackIdx]));\r\n                    progress.setLabelText(tr(\"  - setting device parameter to %1 ... \").arg(scanVals[stackIdx]));\r\n                    //qDebug()<<tr(\"  - setting device parameter to %1 ... \").arg(scanVals[stackIdx]);\r\n                    //////////////////////////////////////////////////////////////////////////////////////\r\n                    // set device parameter and poosibly wait the set delay\r\n                    //////////////////////////////////////////////////////////////////////////////////////\r\n                    setDeviceParameter(stackParam, scanVals[stackIdx]);\r\n                    if (ui->spinDelay->value()>0) {\r\n                        log->log_text(tr(\"waiting ... \"));\r\n                        //qDebug()<<tr(\"  - waiting\");\r\n                        QTime tDelay=QTime::currentTime();\r\n                        while (double(tDelay.elapsed())<ui->spinDelay->value()) {\r\n                            QApplication::processEvents();\r\n                        }\r\n                    }\r\n                    log->log_text(tr(\"DONE!\\n\"));\r\n                    log->log_text(tr(\"  - acquiring image series\\n\"));\r\n                    //qDebug()<<tr(\"  - acquiring image series\");\r\n                    progress.setLabelText(tr(\"acquiring image series ...\"));\r\n                    //////////////////////////////////////////////////////////////////////////////////////\r\n                    // acquire image series\r\n                    //////////////////////////////////////////////////////////////////////////////////////\r\n                    if (useCam1) QDir().mkpath(QFileInfo(acquisitionPrefix1+QString(\"__sidx%1.txt\").arg(stackIdx,4,10,QLatin1Char('0'))).absolutePath());\r\n                    if (useCam2) QDir().mkpath(QFileInfo(acquisitionPrefix2+QString(\"__sidx%1.txt\").arg(stackIdx,4,10,QLatin1Char('0'))).absolutePath());\r\n                    ok = acqTools->acquireSeries(lightpathName, QString(\"paramstack%1\").arg(stackIdx,4,10,QLatin1Char('0')), tr(\"device parameter stack\"), useCam1, extension1, ecamera1, camera1, acquisitionPrefix1+QString(\"__sidx%1\").arg(stackIdx,4,10,QLatin1Char('0')), acquisitionSettingsFilename1, acquisitionDescription1, moreFiles1, useCam2, extension2, ecamera2, camera2, acquisitionPrefix2+QString(\"__sidx%1\").arg(stackIdx,4,10,QLatin1Char('0')), acquisitionSettingsFilename2, acquisitionDescription2, moreFiles2, camset1, camset2, camsetstr1, camsetstr2, &measured, &progress, NULL);\r\n                    if (!ok) {\r\n                        if (frames>1) {\r\n                            CAMPARAMSTACK_ERROR(tr(\"error acquiring image (%1...%2)/%3 !\\n\").arg(imageCnt+1).arg(imageCnt+1+frames).arg(images));\r\n                        } else {\r\n                            CAMPARAMSTACK_ERROR(tr(\"error acquiring image %1/%2 !\\n\").arg(imageCnt+1).arg(images));\r\n                        }\r\n                    }\r\n                    realValues.append(getDeviceParameter(stackParam));\r\n\r\n                    if (!ok) running=false;\r\n\r\n                    stackIdx++;\r\n                    imageCnt+=frames;\r\n                    progress.setValue((int)round((double)stackIdx/(double)scanVals.size()*100.0));\r\n                    QApplication::processEvents();\r\n                    if (progress.wasCanceled()) {\r\n                        running=false;\r\n                        log->log_error(tr(\"CANCELED BY USER!\\n\"));\r\n                    }\r\n                }\r\n                duration=timAcquisition.elapsed()/1000.0;\r\n                if (buffer1) qfFree(buffer1);\r\n                if (buffer2) qfFree(buffer2);\r\n                buffer1=buffer2=NULL;\r\n\r\n            }\r\n\r\n            /*QMapIterator<QString, QVariant> it1(acquisitionDescription1), it2(acquisitionDescription2);\r\n            while (it1.hasNext()) {\r\n                it1.next();\r\n                finalAcquisitionDescription1[\"cam1/\"+it1.key()]=it1.value();\r\n                finalAcquisitionDescription1[\"cam1/\"+it1.key()]=it1.value();\r\n            }\r\n            while (it2.hasNext()) {\r\n                it1.next();\r\n                finalAcquisitionDescription2[\"cam2/\"+it1.key()]=it1.value();\r\n                finalAcquisitionDescription2[\"cam2/\"+it1.key()]=it1.value();\r\n            }*/\r\n            finalAcquisitionDescription1.unite(acquisitionDescription1);\r\n            finalAcquisitionDescription2.unite(acquisitionDescription2);\r\n\r\n            files1.append(moreFiles1);\r\n            files2.append(moreFiles2);\r\n        }\r\n        progress.setValue(100);\r\n        measured.append(opticsSetup->getMeasuredValues());\r\n        progress.nextItem();\r\n\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        // collect lightpath data common to all cameras\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        opticsSetup->saveLightpathConfig(finalAcquisitionDescription1, \"\", \"lightpath/\");\r\n        opticsSetup->saveLightpathConfig(finalAcquisitionDescription2, \"\", \"lightpath/\");\r\n\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        // switch on/off light\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        if (opticsSetup->isMainIlluminationShutterAvailable()){\r\n            log->log_text(tr(\"  - switch main shutter %1!\\n\").arg((formerMainShutterState)?tr(\"on\"):tr(\"off\")));\r\n            opticsSetup->setMainIlluminationShutter(formerMainShutterState, true);\r\n        }\r\n\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        // RESET LIGHTPATH\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        if (lightpathActivated()) {\r\n            opticsSetup->loadLightpathConfig(oldLightpath, false);\r\n            log->log_text(tr(\"  - resetting to old lightpath settings (%1) ...\\n\").arg(oldLightpath));//Name));\r\n        }\r\n\r\n\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        // collect acquisition data common to all cameras\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        QString scanCSV;\r\n        if (ok) {\r\n            finalAcquisitionDescription1[\"type\"]=\"parameter stack\";\r\n            finalAcquisitionDescription1[\"stack_parameter\"]=stackParameterName();\r\n            finalAcquisitionDescription1[\"stack_mode\"]=stackModeName();\r\n            finalAcquisitionDescription1[\"stack_start\"]=stackStart();\r\n            finalAcquisitionDescription1[\"stack_delta\"]=stackDelta();\r\n            finalAcquisitionDescription1[\"stack_end\"]=stackEnd();\r\n            finalAcquisitionDescription1[\"sequence_overall_length\"]=images;\r\n            finalAcquisitionDescription1[\"images_per_step\"]=numImages();\r\n            finalAcquisitionDescription1[\"stack_length\"]=scanVals.size();\r\n            finalAcquisitionDescription1[\"start_time\"]=timStart;\r\n            finalAcquisitionDescription1[\"duration\"]=duration;\r\n            finalAcquisitionDescription1[\"stack_value_count\"]=scanVals.size();\r\n            finalAcquisitionDescription1[\"stack_values\"]=CDoubleListToQString(scanVals);\r\n            finalAcquisitionDescription1[\"real_stack_values\"]=realValues;\r\n\r\n\r\n            finalAcquisitionDescription2[\"type\"]=\"parameter stack\";\r\n            finalAcquisitionDescription2[\"stack_parameter\"]=stackParameterName();\r\n            finalAcquisitionDescription2[\"stack_mode\"]=stackModeName();\r\n            finalAcquisitionDescription2[\"stack_start\"]=stackStart();\r\n            finalAcquisitionDescription2[\"stack_delta\"]=stackDelta();\r\n            finalAcquisitionDescription2[\"stack_end\"]=stackEnd();\r\n            finalAcquisitionDescription2[\"sequence_overall_length\"]=images;\r\n            finalAcquisitionDescription2[\"images_per_step\"]=numImages();\r\n            finalAcquisitionDescription2[\"stack_length\"]=scanVals.size();\r\n            finalAcquisitionDescription2[\"start_time\"]=timStart;\r\n            finalAcquisitionDescription2[\"duration\"]=duration;\r\n            finalAcquisitionDescription2[\"stack_value_count\"]=scanVals.size();\r\n            finalAcquisitionDescription2[\"stack_values\"]=CDoubleListToQString(scanVals);\r\n            finalAcquisitionDescription2[\"real_stack_values\"]=realValues;\r\n\r\n\r\n\r\n            QTextStream pf(&scanCSV);\r\n            pf<<\"# number,   ideal value,   real value\\n\";\r\n            for (int i=0; i<qMin(scanVals.size(), realValues.size()); i++) {\r\n                pf<<i<<\", \"<<CDoubleToQString(scanVals[i]);\r\n                if (i<realValues.size()) pf<<\", \"<<CDoubleToQString(realValues[i].toDouble());\r\n                pf<<\"\\n\";\r\n            }\r\n        }\r\n\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        // write image stack properties to files, also collects camera specific information\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        if (ok && useCam1) {\r\n            QMap<QString, QVariant> acquisitionDescription1=finalAcquisitionDescription1;\r\n            QFExtensionCamera::CameraAcquititonFileDescription d;\r\n            d.name=TIFFFIlename1;\r\n            d.description=\"image stack from camera 1\";\r\n            d.type=\"TIFF16\";\r\n            files1.append(d);\r\n\r\n\r\n            QString ParamValuesFilename=acquisitionPrefix1+\".param.dat\";\r\n            QFile posFile(ParamValuesFilename);\r\n            if (posFile.open(QIODevice::WriteOnly)) {\r\n                posFile.write(scanCSV.toLatin1().data());\r\n                posFile.close();\r\n                d.name=ParamValuesFilename;\r\n                d.description=\"parameter values\";\r\n                d.type=\"CSV\";\r\n                files1.append(d);\r\n            } else {\r\n                log->log_error(tr(\"  - could not write parameter values file '%1' for camera 1: %2 ...\").arg(ParamValuesFilename).arg(posFile.errorString()));\r\n            }\r\n\r\n            QString MeasurementsFilename=acqTools->saveMeasuredData(acquisitionPrefix1, measured);\r\n            if (!MeasurementsFilename.isEmpty() && QFile::exists(MeasurementsFilename)) {\r\n                QFExtensionCamera::CameraAcquititonFileDescription d;\r\n                d.name=MeasurementsFilename;\r\n                d.description=\"measureable properties of setup\";\r\n                d.type=\"CSV\";\r\n                files1.append(d);\r\n            }\r\n\r\n            log->log_text(tr(\"  - writing acquisition description 1 ...\"));\r\n            acqTools->savePreviewDescription(0, extension1, ecamera1, camera1, acquisitionPrefix1, acquisitionDescription1, files1, startDateTime);\r\n            log->log_text(tr(\" DONE!\\n\"));\r\n        }\r\n        if (ok && useCam2) {\r\n            QMap<QString, QVariant> acquisitionDescription2=finalAcquisitionDescription2;\r\n\r\n            QFExtensionCamera::CameraAcquititonFileDescription d;\r\n            d.name=TIFFFIlename1;\r\n            d.description=\"image stack from camera 2\";\r\n            d.type=\"TIFF16\";\r\n            files2.append(d);\r\n\r\n\r\n            QString ParamValuesFilename=acquisitionPrefix2+\".param.dat\";\r\n            QFile posFile(ParamValuesFilename);\r\n            if (posFile.open(QIODevice::WriteOnly)) {\r\n                posFile.write(scanCSV.toLatin1().data());\r\n                posFile.close();\r\n                d.name=ParamValuesFilename;\r\n                d.description=\"parameter values\";\r\n                d.type=\"CSV\";\r\n                files2.append(d);\r\n            } else {\r\n                log->log_error(tr(\"  - could not write parameter values file '%1' for camera 2: %2 ...\").arg(ParamValuesFilename).arg(posFile.errorString()));\r\n            }\r\n\r\n            QString MeasurementsFilename=acqTools->saveMeasuredData(acquisitionPrefix2, measured);\r\n            if (!MeasurementsFilename.isEmpty() && QFile::exists(MeasurementsFilename)) {\r\n                QFExtensionCamera::CameraAcquititonFileDescription d;\r\n                d.name=MeasurementsFilename;\r\n                d.description=\"measureable properties of setup\";\r\n                d.type=\"CSV\";\r\n                files2.append(d);\r\n            }\r\n\r\n\r\n            log->log_text(tr(\"  - writing acquisition description 2 ...\"));\r\n            acqTools->savePreviewDescription(1, extension2, ecamera2, camera2, acquisitionPrefix2, acquisitionDescription2, files2, startDateTime);\r\n            log->log_text(tr(\" DONE!\\n\"));\r\n        }\r\n\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        // release cameras\r\n        //////////////////////////////////////////////////////////////////////////////////////\r\n        if (useCam1) {\r\n            opticsSetup->releaseCamera(0);\r\n            log->log_text(tr(\"  - released camera 1!\\n\"));\r\n        }\r\n        if (useCam2) {\r\n            opticsSetup->releaseCamera(1);\r\n            log->log_text(tr(\"  - released camera 2!\\n\"));\r\n        }\r\n\r\n        if (ok && useCam1) log->log_text(tr(\"  - stored files with prefix 1: '%1'\\n\").arg(acquisitionPrefix1));\r\n        if (ok && useCam2) log->log_text(tr(\"  - stored files with prefix 2: '%1'\\n\").arg(acquisitionPrefix2));\r\n\r\n        if (ok) log->log_text(tr(\"image stack acquisition DONE!\\n\"));\r\n    }\r\n    opticsSetup->unlockLightpath();\r\n    opticsSetup->ensureLightpath();\r\n}",
    "bool QFRDRNumberAndBrightnessData::loadFile(double *target, const QString &filename, QFRDRNumberAndBrightnessData::FileOperations op)\n{\n    bool ok=false;\n\n    if (!target) return false;\n\n\n    QFImageHalf ihalf=getSelectedImageHalf();\n\n    if (QFile::exists(filename)) {\n        TIFF* tif=TIFFOpen(filename.toLatin1().data(), \"r\");\n        if (tif) {\n            uint32 nx,ny;\n            TIFFGetField(tif,TIFFTAG_IMAGEWIDTH,&nx);\n            TIFFGetField(tif,TIFFTAG_IMAGELENGTH,&ny);\n            if (ihalf==qfihNone) {\n                if ((int64_t)nx!=width || (int64_t)ny!=height) {\n                    ok=false;\n                } else {\n                    //double* filedata=(double*)qfMalloc(nx*ny*sizeof(double));\n                    //ok=TIFFReadFrame<double>(tif, filedata);\n                    ok=TIFFReadFrame<double>(tif, target);\n                }\n            } else if (ihalf==qfihLeft || ihalf==qfihRight) {\n                if ((int64_t)nx/2!=width || (int64_t)ny!=height) {\n                    ok=false;\n                } else {\n                    double* filedata=(double*)qfMalloc(nx*ny*sizeof(double));\n                    ok=TIFFReadFrame<double>(tif, filedata);\n                    qfCopyImageHalf(target, filedata, nx, ny, ihalf);\n                    qfFree(filedata);\n                }\n            } else if (ihalf==qfihTop || ihalf==qfihBottom) {\n                if ((int64_t)nx!=width || (int64_t)ny/2!=height) {\n                    ok=false;\n                } else {\n                    double* filedata=(double*)qfMalloc(nx*ny*sizeof(double));\n                    ok=TIFFReadFrame<double>(tif, filedata);\n                    qfCopyImageHalf(target, filedata, nx, ny, ihalf);\n                    qfFree(filedata);\n                }\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    if (!ok && target) {\n        for (int i=0; i<width*height; i++) {\n            target[i]=0;\n        }\n    }\n\n\n    switch(op) {\n        case QFRDRNumberAndBrightnessData::TakeSqrt:\n            for (int i=0; i<width*height; i++) {\n                target[i]=sqrt(target[i]);\n            }\n            break;\n        case QFRDRNumberAndBrightnessData::Square:\n            for (int i=0; i<width*height; i++) {\n                target[i]=target[i]*target[i];\n            }\n            break;\n        default:\n            break;\n    }\n    return ok;\n}",
    "bool QFRDRNumberAndBrightnessData::loadImage(const QString& filename, double** data, int* width, int* height) {\n    bool ok=false;\n\n    if (*data) qfFree(*data);\n    *data=NULL;\n    *width=0;\n    *height=0;\n\n    if (QFile::exists(filename)) {\n        TIFF* tif=TIFFOpen(filename.toLatin1().data(), \"r\");\n        if (tif) {\n            uint32 nx,ny;\n            TIFFGetField(tif,TIFFTAG_IMAGEWIDTH,&nx);\n            TIFFGetField(tif,TIFFTAG_IMAGELENGTH,&ny);\n            *width=nx;\n            *height=ny;\n            *data=(double*)qfMalloc(nx*ny*sizeof(double));\n            ok=TIFFReadFrame<double>(tif, *data);\n            TIFFClose(tif);\n        }\n    }\n    return ok;\n}",
    "bool QFRDRNumberAndBrightnessData::loadVideo(const QString& filename, double** data, int* width, int* height, uint32_t* frames) {\n    bool ok=false;\n\n    if (*data) qfFree(*data);\n    *data=NULL;\n    *width=0;\n    *height=0;\n    *frames=0;\n\n    if (QFile::exists(filename)) {\n        TIFF* tif=TIFFOpen(filename.toLatin1().data(), \"r\");\n        if (tif) {\n            *frames=TIFFCountDirectories(tif);\n            uint32 nx,ny;\n            TIFFGetField(tif,TIFFTAG_IMAGEWIDTH,&nx);\n            TIFFGetField(tif,TIFFTAG_IMAGELENGTH,&ny);\n            *width=nx;\n            *height=ny;\n            *data=(double*)qfMalloc(nx*ny*(*frames)*sizeof(double));\n            uint32_t i=0;\n            do {\n                ok=ok & TIFFReadFrame<double>(tif, &((*data)[i*nx*ny]));\n                i++;\n            } while (TIFFReadDirectory(tif) && i<=(*frames));\n            TIFFClose(tif);\n        }\n    }\n    return ok;\n}",
    "void QFRDRNnumberAndBrightnessProcessingThread::run()\r\n{\r\n    for (int j=0; j<jobs.size(); j++) {\r\n        const Job& job=jobs[j];\r\n        if (m_canceled) break;\r\n        emit setJobProgress(0);\r\n        emit setJobProgress(threadID, 0);\r\n        bool jobDone=true;\r\n\r\n        QFImporterImageSeries* r=NULL;\r\n\r\n        QFImporter* imp=QFPluginServices::getInstance()->getImporterManager()->createImporter(job.readerID);\r\n        r=dynamic_cast<QFImporterImageSeries*>(imp);\r\n        if (r) {\r\n            QFile fSet(job.outputname);\r\n            QDir d=QFileInfo(job.outputname).absoluteDir();\r\n            if (fSet.open(QIODevice::WriteOnly | QIODevice::Text)) {\r\n                QTextStream set(&fSet);\r\n                set<<\"date/time                   : \"<<QDateTime::currentDateTime().toString(Qt::ISODate)<<\"\\n\";\r\n                set<<\"input file                  : \"<<d.relativeFilePath(job.inputfile)<<\"\\n\";\r\n                set<<\"input background file       : \"<<d.relativeFilePath(job.backgroundfile)<<\"\\n\";\r\n\r\n                int frame_width=0, frame_height=0;\r\n                //qDebug()<<j<<\"opening \"<<job.inputfile;\r\n                if (r->open(job.inputfile)) {\r\n                    int width=frame_width=r->frameWidth();\r\n                    int height=frame_height=r->frameHeight();\r\n                    int framescnt=r->countFrames();\r\n                    int expectedFrames=framescnt;\r\n                    set<<\"width                       : \"<<width<<\"\\n\";\r\n                    set<<\"height                      : \"<<height<<\"\\n\";\r\n                    set<<\"dualview mode               : \"<<job.dvmode<<\"\\n\";\r\n                    double* frame=(double*)qfMalloc(width*height*sizeof(double));\r\n                    double* fSum=(double*)qfMalloc(width*height*sizeof(double));\r\n                    double* fSum2=(double*)qfMalloc(width*height*sizeof(double));\r\n                    for (int i=0; i<width*height; i++) {\r\n                        fSum[i]=0;\r\n                        fSum2[i]=0;\r\n                    }\r\n                    double frames=0;\r\n                    int f=0;\r\n                    bool fok=true;\r\n                    if (job.start>0) {\r\n                        while (f<job.start && fok) {\r\n                            fok=r->nextFrame();\r\n                            f++;\r\n                            if (m_canceled) break;\r\n                        }\r\n                    }\r\n                    if (fok) {\r\n                        do {\r\n                            r->readFrameDouble(frame);\r\n                            for (int i=0; i<width*height; i++) {\r\n                                fSum[i]=fSum[i]+frame[i];\r\n                                fSum2[i]=fSum2[i]+frame[i]*frame[i];\r\n                            }\r\n                            frames++;\r\n                            f++;\r\n                            if (m_canceled) break;\r\n                            if (expectedFrames>25 && f%(expectedFrames/25)==0) {\r\n                                emit setJobProgress(f/(expectedFrames/25));\r\n                                emit setJobProgress(threadID, f/(expectedFrames/25));\r\n                            }\r\n                        } while (r->nextFrame() && (f<=job.end || job.end<0));\r\n                    }\r\n                    set<<\"frame count                 : \"<<int(frames)<<\"\\n\";\r\n                    set<<\"frame count in file         : \"<<int(framescnt)<<\"\\n\";\r\n                    if (job.start>=0) set<<\"first frame                 : \"<<job.start<<\"\\n\";\r\n                    else  set<<\"first frame                 : \"<<0<<\"\\n\";\r\n                    if (job.end>=0) set<<\"last frame                  : \"<<job.end<<\"\\n\";\r\n                    else set<<\"last frame                  : \"<<int(framescnt-1)<<\"\\n\";\r\n                    set<<\"detector type               : \"<<job.detectorMode<<\"\\n\";\r\n                    set<<\"detector gain               : \"<<CDoubleToQString(job.gain)<<\"\\n\";\r\n                    set<<\"detector excess noise       : \"<<CDoubleToQString(job.excessNoise)<<\"\\n\";\r\n\r\n                    for (int i=0; i<width*height; i++) {\r\n                        fSum2[i]=sqrt((fSum2[i]-qfSqr(fSum[i])/frames)/(frames-1.0));\r\n                        fSum[i]=fSum[i]/frames;\r\n                    }\r\n\r\n                    TIFF* tif;\r\n                    QString fn;\r\n                    tif=TIFFOpen((fn=job.basename+\".overview_uncorrected.tif\").toLocal8Bit().data(), \"w\");\r\n                    if (tif) {\r\n                        TIFFTWriteDoubleAsFloat(tif, fSum, width, height, job.pixel_size, job.pixel_size);\r\n                        TIFFClose(tif);\r\n                        set<<\"uncorr. overview image file : \"<<d.relativeFilePath(fn)<<\"\\n\";\r\n                    }\r\n\r\n                    tif=TIFFOpen((fn=job.basename+\".overviewstd_uncorrected.tif\").toLocal8Bit().data(), \"w\");\r\n                    if (tif) {\r\n                        TIFFTWriteDoubleAsFloat(tif, fSum2, width, height, job.pixel_size, job.pixel_size);\r\n                        TIFFClose(tif);\r\n                        set<<\"uncorr. overview std image  : \"<<d.relativeFilePath(fn)<<\"\\n\";\r\n                    }\r\n                    r->close();\r\n\r\n                    if (frame) qfFree(frame);\r\n                    if (fSum) qfFree(fSum);\r\n                    if (fSum2) qfFree(fSum2);\r\n                } else {\r\n                    emit errorMessage(tr(\"Could not open file '%1'\").arg(job.inputfile));\r\n                }\r\n\r\n                //qDebug()<<j<<\"opening \"<<job.backgroundfile;\r\n                if (QFile::exists(job.backgroundfile) && r->open(job.backgroundfile)) {\r\n                    int width=r->frameWidth();\r\n                    int height=r->frameHeight();\r\n                    if (width==frame_width && height==frame_height) {\r\n                        double* frame=(double*)qfMalloc(width*height*sizeof(double));\r\n                        double* fSum=(double*)qfMalloc(width*height*sizeof(double));\r\n                        double* fSum2=(double*)qfMalloc(width*height*sizeof(double));\r\n                        for (int i=0; i<width*height; i++) {\r\n                            fSum[i]=0;\r\n                            fSum2[i]=0;\r\n                        }\r\n                        double frames=0;\r\n                        int f=0;\r\n                        int expectedFrames=r->countFrames();\r\n                        do {\r\n                            r->readFrameDouble(frame);\r\n                            for (int i=0; i<width*height; i++) {\r\n                                fSum[i]=fSum[i]+frame[i];\r\n                                fSum2[i]=fSum2[i]+frame[i]*frame[i];\r\n                            }\r\n                            frames++;\r\n                            f++;\r\n                            if (m_canceled) break;\r\n                            if (expectedFrames>25 && f%(expectedFrames/25)==0) {\r\n                                emit setJobProgress(50+f/(expectedFrames/25));\r\n                                emit setJobProgress(threadID, 50+f/(expectedFrames/25));\r\n                            }\r\n\r\n                        } while (r->nextFrame() && (f<=job.end || job.end<0));\r\n\r\n                        for (int i=0; i<width*height; i++) {\r\n                            fSum2[i]=sqrt((fSum2[i]-qfSqr(fSum[i])/frames)/(frames-1.0));\r\n                            fSum[i]=fSum[i]/frames;\r\n                        }\r\n\r\n                        TIFF* tif;\r\n                        QString fn;\r\n                        tif=TIFFOpen((fn=job.basename+\".background.tif\").toLocal8Bit().data(), \"w\");\r\n                        if (tif) {\r\n                            TIFFTWriteDoubleAsFloat(tif, fSum, width, height, job.pixel_size, job.pixel_size);\r\n                            TIFFClose(tif);\r\n                            set<<\"background image file       : \"<<d.relativeFilePath(fn)<<\"\\n\";\r\n                        }\r\n\r\n                        tif=TIFFOpen((fn=job.basename+\".backgroundstd.tif\").toLocal8Bit().data(), \"w\");\r\n                        if (tif) {\r\n                            TIFFTWriteDoubleAsFloat(tif, fSum2, width, height, job.pixel_size, job.pixel_size);\r\n                            TIFFClose(tif);\r\n                            set<<\"background stddev           : \"<<d.relativeFilePath(fn)<<\"\\n\";\r\n                        }\r\n\r\n\r\n                        if (frame) qfFree(frame);\r\n                        if (fSum) qfFree(fSum);\r\n                        if (fSum2) qfFree(fSum2);\r\n                    } else {\r\n                        emit errorMessage(tr(\"Background file '%1' and image stack '%2' do not have the same width and height!\").arg(job.backgroundfile).arg(job.inputfile));\r\n                    }\r\n                    r->close();\r\n                } else {\r\n                    if (QFile::exists(job.backgroundfile)) emit errorMessage(tr(\"Could not open background file '%1'\").arg(job.backgroundfile));\r\n                }\r\n                fSet.close();\r\n            } else {\r\n                jobDone=false;\r\n            }\r\n\r\n            delete r;\r\n        } else {\r\n            if (imp) delete imp;\r\n        }\r\n\r\n\r\n\r\n        emit setJobProgress(100);\r\n        emit setJobProgress(threadID, 100);\r\n        if (jobDone) emit finishedJob(job.outputname);\r\n        else emit finishedJob(\"\");\r\n\r\n    }\r\n    if (m_canceled) emit errorMessage(tr(\"Canceled by User!\"));\r\n}",
    "void QFRDRNumberAndBrightnessProcessingJobThread::run() {\r\n    QTime ptime;\r\n\r\n    ptime.start();\r\n\r\n    emit messageChanged(tr(\"loading data ...\"));\r\n    if ((job.fileFormat<0)||(job.fileFormat>=getImageReaderCount(pluginservices))) {\r\n        m_status=-1;\r\n        emit statusChanged(m_status);\r\n        emit messageChanged(tr(\"file format not supported or given ... format given was: %1\").arg(job.fileFormat));\r\n        emit rangeChanged(0,100);\r\n        emit progressChanged(0);\r\n    } else if (!QFile::exists(job.filename)) {\r\n        m_status=-1;\r\n        emit statusChanged(m_status);\r\n        emit messageChanged(tr(\"file does not exist ...\"));\r\n        emit rangeChanged(0,100);\r\n        emit progressChanged(0);\r\n    } else {\r\n        m_status=1;\r\n        emit statusChanged(m_status);\r\n        emit rangeChanged(0,3780+1000*job.DCCFDeltaX.size());\r\n\r\n\r\n        reader=NULL;\r\n        bool OK=false;\r\n        if (job.fileFormat>=0 && job.fileFormat<getImageReaderCount(pluginservices)) {\r\n            reader=getImageReader(job.fileFormat, pluginservices);\r\n        }\r\n        if (reader) {\r\n            emit messageChanged(tr(\"opening %1 file ...\").arg(reader->formatName()));\r\n            OK=reader->open(job.filename);\r\n            if (!OK) {\r\n                m_status=-1; emit statusChanged(m_status);\r\n                if (reader) messageChanged(tr(\"error opening file '%1': %2\").arg(job.filename).arg(reader->lastError()));\r\n                else emit messageChanged(tr(\"error opening file '%1'\").arg(job.filename));\r\n            } else {\r\n                emit progressIncrement(10);\r\n                emit messageChanged(tr(\"counting frames ...\"));\r\n                props=reader->getFileInfo().properties;\r\n                comment=reader->getFileInfo().comment;\r\n                reader->setBinning(job.binning);\r\n                reader->setInterleavedBinning(job.interleaved_binning);\r\n                reader->setAverageBinning(job.binAverage);\r\n                if (job.use_cropping) {\r\n                    reader->setCropping(job.crop_x0, job.crop_x1, job.crop_y0, job.crop_y1);\r\n                } else {\r\n                    reader->unsetCropping();\r\n                }\r\n                first_frame=0;\r\n                int32_t frame_count=reader->countFrames();\r\n                if (job.range_min>0 && job.range_min<frame_count) first_frame=job.range_min;\r\n                frames=frame_count-first_frame;\r\n                if (job.range_max>(int64_t)first_frame && job.range_max<frame_count) frames=job.range_max-first_frame;\r\n                double input_length=frames*job.frameTime;\r\n                if (frames>0) {\r\n                    frame_width=reader->frameWidth();\r\n                    frame_height=reader->frameHeight();\r\n                    average_frame=(float*)qfCalloc(frame_width*frame_height, sizeof(float));\r\n                    sqrsum_frame=(float*)qfCalloc(frame_width*frame_height, sizeof(float));\r\n                    average_uncorrected_frame=(float*)qfCalloc(frame_width*frame_height, sizeof(float));\r\n                    sqrsum_uncorrected_frame=(float*)qfCalloc(frame_width*frame_height, sizeof(float));\r\n\r\n                    baseline=job.backgroundOffset;\r\n\r\n                    acf_tau=NULL;\r\n                    acf=NULL;\r\n                    acf_std=NULL;\r\n                    acf_segments=NULL;\r\n                    acf_N=0;\r\n                    ccf_tau=NULL;\r\n                    ccf1=NULL;\r\n                    ccf2=NULL;\r\n                    ccf3=NULL;\r\n                    ccf4=NULL;\r\n                    ccf1_std=NULL;\r\n                    ccf2_std=NULL;\r\n                    ccf3_std=NULL;\r\n                    ccf4_std=NULL;\r\n                    ccf1_segments=NULL;\r\n                    ccf2_segments=NULL;\r\n                    ccf3_segments=NULL;\r\n                    ccf4_segments=NULL;\r\n                    ccf_N=0;\r\n                    //dccf_tau=NULL;\r\n                    //dccf=NULL;\r\n                    //dccf_segments=NULL;\r\n                    //dccf_std=NULL;\r\n                    //dccf_N=0;\r\n                    //dccfframe_width=0;\r\n                    //dccfframe_height=0;\r\n                    dccf.clear();\r\n                    for (int id=0; id<job.DCCFDeltaX.size(); id++) {\r\n                        DCCFRecord rec;\r\n                        rec.dccf_tau=NULL;\r\n                        rec.dccf=NULL;\r\n                        rec.dccf_segments=NULL;\r\n                        rec.dccf_std=NULL;\r\n                        rec.dccf_N=0;\r\n                        rec.dccfframe_width=0;\r\n                        rec.dccfframe_height=0;\r\n                        dccf.append(rec);\r\n                    }\r\n                    lastFrames=NULL;\r\n                    firstFrames=NULL;\r\n                    bleachAmplitude=NULL;\r\n                    bleachTime=NULL;\r\n                    bleachPoly2=NULL;\r\n                    bleachPoly3=NULL;\r\n                    fit_frames=NULL;\r\n                    fit_t=NULL;\r\n                    NFitFrames=0;\r\n\r\n                    video_count=floor(frames/job.video_frames);\r\n                    real_video_count=video_count;\r\n                    video=(float*)qfCalloc(frame_width*frame_height*video_count, sizeof(float));\r\n                    video_uncorrected=(float*)qfCalloc(frame_width*frame_height*video_count, sizeof(float));\r\n                    bleachAmplitude=(float*)qfCalloc(frame_width*frame_height, sizeof(float));\r\n                    bleachTime=(float*)qfCalloc(frame_width*frame_height, sizeof(float));\r\n                    bleachAmplitude2=(float*)qfCalloc(frame_width*frame_height, sizeof(float));\r\n                    bleachTime2=(float*)qfCalloc(frame_width*frame_height, sizeof(float));\r\n                    bleachPoly2=(float*)qfCalloc(frame_width*frame_height, sizeof(float));\r\n                    bleachPoly3=(float*)qfCalloc(frame_width*frame_height, sizeof(float));\r\n                    bleachPoly4=(float*)qfCalloc(frame_width*frame_height, sizeof(float));\r\n                    bleachPoly5=(float*)qfCalloc(frame_width*frame_height, sizeof(float));\r\n                    bleachFitOK=(uint8_t*)qfCalloc(frame_width*frame_height, sizeof(uint8_t));\r\n                    //firstFrames=(float*)qfCalloc(frame_width*frame_height, sizeof(float));\r\n                    //lastFrames=(float*)qfCalloc(frame_width*frame_height, sizeof(float));\r\n\r\n                    ////////////////////////////////////////////////////////////////////////////////////////////\r\n                    // CREATE FILENAMES FOR RESULTS AND MAKE SURE THE DIRECTORY FOR THE FILES EXISTS (mkpath() )\r\n                    ////////////////////////////////////////////////////////////////////////////////////////////\r\n                    QDir d=QFileInfo(job.filename).dir();\r\n\r\n                    if (mutexFilename) mutexFilename->lock();\r\n                    int counter=-1;\r\n                    do {\r\n                        outputFilenameBase=d.absoluteFilePath(replacePostfixSpecials(job.prefix)+QFileInfo(job.filename).completeBaseName()+replacePostfixSpecials(job.postfix, counter));\r\n                        counter++;\r\n                    } while (QFile::exists(outputFilenameBase+\".evalsettings.txt\"));\r\n                    //qDebug()<<outputFilenameBase;\r\n                    QString configFilename=outputFilenameBase+\".evalsettings.txt\";\r\n                    QString averageFilename=\"\";\r\n                    QString stdFilename=\"\";\r\n                    QString averageUncorrectedFilename=\"\";\r\n                    QString stdUncorrectedFilename=\"\";\r\n                    QString backstdFilename=\"\";\r\n                    QString averageFilenameF=\"\";\r\n                    QString backgroundFilename=\"\";\r\n                    QString videoFilename=\"\";\r\n                    QString videoUncorrectedFilename=\"\";\r\n                    QString statisticsFilename=\"\";\r\n                    QString statisticsFilename_dv1=\"\";\r\n                    QString statisticsFilename_dv2=\"\";\r\n                    QString uncorrectedStatisticsFilename=\"\";\r\n                    QString uncorrectedStatisticsFilename_dv1=\"\";\r\n                    QString uncorrectedStatisticsFilename_dv2=\"\";\r\n                    QString backstatisticsFilename=\"\";\r\n                    QString backstatisticsFilename_dv1=\"\";\r\n                    QString backstatisticsFilename_dv2=\"\";\r\n                    QString acfFilename=\"\";\r\n                    QString ccfFilename=\"\";\r\n                    QStringList dccfFilename;\r\n                    QString acfFilenameBin=\"\";\r\n                    QString ccfFilenameBin=\"\";\r\n                    QStringList dccfFilenameBin;\r\n                    QString bleachAmplitudeFilename=\"\";\r\n                    QString bleachTimeFilename=\"\";\r\n                    QString bleachAmplitude2Filename=\"\";\r\n                    QString bleachTime2Filename=\"\";\r\n                    QString bleachFitSuccessFilename=\"\";\r\n                    QString bleachPoly2Filename=\"\";\r\n                    QString bleachPoly3Filename=\"\";\r\n                    QString bleachPoly4Filename=\"\";\r\n                    QString bleachPoly5Filename=\"\";\r\n                    QString firstFramesFilename=\"\";\r\n                    QString lastFramesFilename=\"\";\r\n                    QString bleachtimesFilename=\"\";\r\n                    QString bleachframesFilename=\"\";\r\n                    QString localFileDirectory=QFileInfo(d.absoluteFilePath(configFilename)).dir().absolutePath();\r\n\r\n                    if (d.mkpath(localFileDirectory)) {\r\n                        ////////////////////////////////////////////////////////////////////////////////////////////\r\n                        // TOUCH OUTPUT FILE (.evalsettings.txt)\r\n                        ////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n                        touchFile(configFilename);\r\n\r\n                        if (mutexFilename) mutexFilename->unlock();\r\n\r\n\r\n\r\n\r\n                        ////////////////////////////////////////////////////////////////////////////////////////////\r\n                        // RUN THE CORRELATION\r\n                        ////////////////////////////////////////////////////////////////////////////////////////////\r\n                        if (job.correlator==CORRELATOR_MTAUALLMON || job.correlator==CORRELATOR_MTAUONEMON) {\r\n                            correlate_loadsingle();\r\n                        } else {\r\n                            correlate_loadall();\r\n                        }\r\n                        reader->close();\r\n\r\n\r\n\r\n\r\n                        ////////////////////////////////////////////////////////////////////////////////////////////\r\n                        // SAVE THE RESULTS\r\n                        ////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n                        //************** SAVE OVERVIEW IMAGE\r\n                        if ((m_status==1) && !was_canceled && average_frame) {\r\n                            emit messageChanged(tr(\"saving overview image ...\"));\r\n                            QString localFilename=averageFilename=outputFilenameBase+\".overview.tif\";\r\n                            QString error=\"\";\r\n                            if (!SaveTIFFUInt16_scaled(localFilename, average_frame, frame_width, frame_height, tr(\"UInt16 overview image\"), &error)) {\r\n                                m_status=-1; emit statusChanged(m_status);\r\n                                averageFilename=\"\";\r\n                                emit messageChanged(error);\r\n                            }\r\n\r\n                            localFilename=averageFilenameF=outputFilenameBase+\".overview_float.tif\";\r\n                            if (!SaveTIFFFloat(localFilename, average_frame, frame_width, frame_height, tr(\"float overview image\"), &error)) {\r\n                                m_status=-1; emit statusChanged(m_status);\r\n                                averageFilenameF=\"\";\r\n                                emit messageChanged(error);\r\n                            }\r\n\r\n                        }\r\n                        emit progressIncrement(5);\r\n\r\n                        //************** SAVE OVERVIEWSTD IMAGE\r\n                        if ((m_status==1) && !was_canceled && sqrsum_frame) {\r\n                            emit messageChanged(tr(\"saving overview stddev image ...\"));\r\n                            QString localFilename=stdFilename=outputFilenameBase+\".overviewstd.tif\";\r\n\r\n                            QString error=\"\";\r\n                            if (!SaveSDTIFF(localFilename, average_frame, sqrsum_frame, frame_width, frame_height, frames, tr(\"stddev overview image\"), &error)) {\r\n                                m_status=-1; emit statusChanged(m_status);\r\n                                stdFilename=\"\";\r\n                                emit messageChanged(error);\r\n                            }\r\n                        }\r\n                        emit progressIncrement(5);\r\n\r\n                        //************** SAVE UNCORRECTED OVERVIEW IMAGE\r\n                        if ((m_status==1) && !was_canceled && average_uncorrected_frame) {\r\n                            emit messageChanged(tr(\"saving uncorrected overview image ...\"));\r\n                            QString localFilename=averageUncorrectedFilename=outputFilenameBase+\".overview_uncorrected.tif\";\r\n\r\n                            QString error=\"\";\r\n                            if (!SaveTIFFFloat(localFilename, average_uncorrected_frame, frame_width, frame_height, tr(\"uncorrected overview image\"), &error)) {\r\n                                m_status=-1; emit statusChanged(m_status);\r\n                                averageUncorrectedFilename=\"\";\r\n                                emit messageChanged(error);\r\n                            }\r\n\r\n                        }\r\n                        emit progressIncrement(5);\r\n\r\n                        //************** SAVE UNCORRECTED OVERVIEWSTD IMAGE\r\n                        if ((m_status==1) && !was_canceled && sqrsum_uncorrected_frame && average_uncorrected_frame) {\r\n                            emit messageChanged(tr(\"saving uncorrected overview stddev image ...\"));\r\n                            QString localFilename=stdUncorrectedFilename=outputFilenameBase+\".overviewstd_uncorrected.tif\";\r\n\r\n                            QString error=\"\";\r\n                            if (!SaveSDTIFF(localFilename, average_uncorrected_frame, sqrsum_uncorrected_frame, frame_width, frame_height, frames, tr(\"uncorrected overview stddev image\"), &error)) {\r\n                                m_status=-1; emit statusChanged(m_status);\r\n                                stdUncorrectedFilename=\"\";\r\n                                emit messageChanged(error);\r\n                            }\r\n                        }\r\n                        emit progressIncrement(5);\r\n\r\n                        //************** SAVE BACKGROUND IMAGE\r\n                        if ((m_status==1) && !was_canceled && backgroundImage) {\r\n                            bool doSave=false;\r\n                            for (uint32_t i=0; i<frame_width*frame_height; i++) {\r\n                                if (backgroundImage[i]!=0) {\r\n                                    doSave=true;\r\n                                    break;\r\n                                }\r\n                            }\r\n                            if (doSave) {\r\n                                emit messageChanged(tr(\"saving background image ...\"));\r\n                                QString localFilename=backgroundFilename=outputFilenameBase+\".background.tif\";\r\n\r\n                                QString error=\"\";\r\n                                if (!SaveTIFFFloat(localFilename, backgroundImage, frame_width, frame_height, tr(\"background image\"), &error)) {\r\n                                    m_status=-1; emit statusChanged(m_status);\r\n                                    backgroundFilename=\"\";\r\n                                    emit messageChanged(error);\r\n                                }\r\n\r\n                            }\r\n\r\n                        }\r\n                        //************** SAVE BACKGROUND STDDEV IMAGE\r\n                        if ((m_status==1) && !was_canceled && backgroundImageStd) {\r\n                            bool doSave=false;\r\n                            for (uint32_t i=0; i<frame_width*frame_height; i++) {\r\n                                if (backgroundImageStd[i]!=0) {\r\n                                    doSave=true;\r\n                                    break;\r\n                                }\r\n                            }\r\n                            if (doSave) {\r\n                                emit messageChanged(tr(\"saving background S.D. image ...\"));\r\n                                QString localFilename=backstdFilename=outputFilenameBase+\".backgroundstd.tif\";\r\n\r\n                                QString error=\"\";\r\n                                if (!SaveTIFFFloat(localFilename, backgroundImageStd, frame_width, frame_height, tr(\"background S.D. image\"), &error)) {\r\n                                    m_status=-1; emit statusChanged(m_status);\r\n                                    backstdFilename=\"\";\r\n                                    emit messageChanged(error);\r\n                                }\r\n                            }\r\n                        }\r\n                        emit progressIncrement(10);\r\n\r\n\r\n                        //************** SAVE BLEACHING PARAMETERS IMAGE\r\n                        if ((m_status==1) && !was_canceled ) {\r\n                            if (job.bleach==BLEACH_EXP || job.bleach==BLEACH_EXP_POLY2 || job.bleach==BLEACH_EXP_POLY3  || job.bleach==BLEACH_EXP_POLY4 || job.bleach==BLEACH_EXP_POLY5  || job.bleach==BLEACH_DBL_EXP || job.bleach==BLEACH_EXPREG) {\r\n                                emit messageChanged(tr(\"saving bleach parameter images ...\"));\r\n                                QString localFilename;\r\n                                TIFF* tif;\r\n                                bool error=false;\r\n\r\n                                localFilename=bleachAmplitudeFilename=outputFilenameBase+\".bleachamplitude.tif\";\r\n                                tif = TIFFOpen(localFilename.toAscii().data(),\"w\");\r\n                                if (tif) {\r\n                                    TIFFTWriteFloat(tif, bleachAmplitude, frame_width, frame_height);\r\n                                    TIFFClose(tif);\r\n                                } else error=true;\r\n\r\n                                localFilename=bleachTimeFilename=outputFilenameBase+\".bleachtime.tif\";\r\n                                tif = TIFFOpen(localFilename.toAscii().data(),\"w\");\r\n                                if (tif) {\r\n                                    TIFFTWriteFloat(tif, bleachTime, frame_width, frame_height);\r\n                                    TIFFClose(tif);\r\n                                } else error=true;\r\n\r\n                                if (job.bleach==BLEACH_DBL_EXP) {\r\n                                    localFilename=bleachAmplitude2Filename=outputFilenameBase+\".bleachamplitude2.tif\";\r\n                                    tif = TIFFOpen(localFilename.toAscii().data(),\"w\");\r\n                                    if (tif) {\r\n                                        TIFFTWriteFloat(tif, bleachAmplitude2, frame_width, frame_height);\r\n                                        TIFFClose(tif);\r\n                                    } else error=true;\r\n\r\n                                    localFilename=bleachTime2Filename=outputFilenameBase+\".bleachtime2.tif\";\r\n                                    tif = TIFFOpen(localFilename.toAscii().data(),\"w\");\r\n                                    if (tif) {\r\n                                        TIFFTWriteFloat(tif, bleachTime2, frame_width, frame_height);\r\n                                        TIFFClose(tif);\r\n                                    } else error=true;\r\n\r\n                                }\r\n\r\n                                if (job.bleach==BLEACH_EXP_POLY2||job.bleach==BLEACH_EXP_POLY3||job.bleach==BLEACH_EXP_POLY4||job.bleach==BLEACH_EXP_POLY5 ) {\r\n                                    localFilename=bleachPoly2Filename=outputFilenameBase+\".bleachpoly2.tif\";\r\n                                    tif = TIFFOpen(localFilename.toAscii().data(),\"w\");\r\n                                    if (tif) {\r\n                                        TIFFTWriteFloat(tif, bleachPoly2, frame_width, frame_height);\r\n                                        TIFFClose(tif);\r\n                                    } else error=true;\r\n\r\n                                }\r\n                                if (job.bleach==BLEACH_EXP_POLY3||job.bleach==BLEACH_EXP_POLY4||job.bleach==BLEACH_EXP_POLY5 ) {\r\n                                    localFilename=bleachPoly3Filename=outputFilenameBase+\".bleachpoly3.tif\";\r\n                                    tif = TIFFOpen(localFilename.toAscii().data(),\"w\");\r\n                                    if (tif) {\r\n                                        TIFFTWriteFloat(tif, bleachPoly3, frame_width, frame_height);\r\n                                        TIFFClose(tif);\r\n                                    } else error=true;\r\n                                }\r\n                                if (job.bleach==BLEACH_EXP_POLY4||job.bleach==BLEACH_EXP_POLY5 ) {\r\n                                    localFilename=bleachPoly4Filename=outputFilenameBase+\".bleachpoly4.tif\";\r\n                                    tif = TIFFOpen(localFilename.toAscii().data(),\"w\");\r\n                                    if (tif) {\r\n                                        TIFFTWriteFloat(tif, bleachPoly4, frame_width, frame_height);\r\n                                        TIFFClose(tif);\r\n                                    } else error=true;\r\n                                }\r\n                                if (job.bleach==BLEACH_EXP_POLY5 ) {\r\n                                    localFilename=bleachPoly5Filename=outputFilenameBase+\".bleachpoly5.tif\";\r\n                                    tif = TIFFOpen(localFilename.toAscii().data(),\"w\");\r\n                                    if (tif) {\r\n                                        TIFFTWriteFloat(tif, bleachPoly5, frame_width, frame_height);\r\n                                        TIFFClose(tif);\r\n                                    } else error=true;\r\n                                }\r\n                                localFilename=bleachFitSuccessFilename=outputFilenameBase+\".bleachfitok.tif\";\r\n                                tif = TIFFOpen(localFilename.toAscii().data(),\"w\");\r\n                                if (tif) {\r\n                                    TIFFTWriteUint8(tif, bleachFitOK, frame_width, frame_height);\r\n                                    TIFFClose(tif);\r\n                                } else error=true;\r\n\r\n                                localFilename=firstFramesFilename=outputFilenameBase+\".firstframes.tif\";\r\n                                tif = TIFFOpen(localFilename.toAscii().data(),\"w\");\r\n                                if (tif) {\r\n                                    TIFFTWriteFloat(tif, firstFrames, frame_width, frame_height);\r\n                                    TIFFClose(tif);\r\n                                } else error=true;\r\n\r\n                                localFilename=lastFramesFilename=outputFilenameBase+\".lastframes.tif\";\r\n                                tif = TIFFOpen(localFilename.toAscii().data(),\"w\");\r\n                                if (tif) {\r\n                                    TIFFTWriteFloat(tif, lastFrames, frame_width, frame_height);\r\n                                    TIFFClose(tif);\r\n                                } else error=true;\r\n\r\n                                if (NFitFrames>0 && fit_t) {\r\n                                    localFilename=bleachtimesFilename=outputFilenameBase+\".bleachfittimes.txt\";\r\n                                    {\r\n                                        QFile f(localFilename);\r\n                                        if (f.open(QIODevice::WriteOnly|QIODevice::Text)) {\r\n                                            QTextStream text(&f);\r\n                                            text.setLocale(outLocale);\r\n                                            for (int i=0; i<NFitFrames; i++) {\r\n                                                text<<fit_t[i]<<\"\\n\";\r\n                                            }\r\n                                            f.close();\r\n                                        } else {\r\n                                            error=true;\r\n                                        }\r\n                                    }\r\n                                }\r\n\r\n                                if (NFitFrames>0 && fit_frames) {\r\n                                    localFilename=bleachframesFilename=outputFilenameBase+\".bleachfitframes.tif\";\r\n                                    tif = TIFFOpen(localFilename.toAscii().data(),\"w\");\r\n                                    if (tif) {\r\n                                        for (int i=0; i<NFitFrames; i++) {\r\n                                            TIFFTWriteFloat(tif, &(fit_frames[i*frame_width*frame_height]), frame_width, frame_height);\r\n                                            TIFFWriteDirectory(tif);\r\n                                        }\r\n                                        TIFFClose(tif);\r\n                                    } else error=true;\r\n                                }\r\n\r\n\r\n                                if (error) {\r\n                                    m_status=-1; emit statusChanged(m_status);\r\n                                    backgroundFilename=\"\";\r\n                                    emit messageChanged(tr(\"could not create background image '%1'!\").arg(localFilename));\r\n                                }\r\n                            }\r\n                        }\r\n                        emit progressIncrement(10);\r\n\r\n                        double videoAvgMin=0;\r\n                        double videoAvgMax=(float)0xFFFF;\r\n                        //************** SAVE VIDEO\r\n                        if ((m_status==1) && !was_canceled && video && real_video_count>0 ) {\r\n                            emit messageChanged(tr(\"saving video ...\"));\r\n                            QString localFilename=videoFilename=outputFilenameBase+\".video.tif\";\r\n                            TinyTIFFFile* tif=TinyTIFFWriter_open(localFilename.toAscii().data(), 16, frame_width, frame_height);\r\n                            //TIFF* tif = TIFFOpen(localFilename.toAscii().data(),\"w\");\r\n                            if (tif) {\r\n                                float avgMin=video[0];\r\n                                float avgMax=video[0];\r\n                                for (register uint32_t i=0; i<frame_width*frame_height*video_count; i++) {\r\n                                    avgMin=(video[i]<avgMin)?video[i]:avgMin;\r\n                                    avgMax=(video[i]>avgMax)?video[i]:avgMax;\r\n                                }\r\n                                uint16_t* img=(uint16_t*)qfMalloc(frame_width*frame_height*sizeof(uint16_t));\r\n                                for (register uint32_t c=0; c<real_video_count; c++) {\r\n                                    for (register uint32_t i=0; i<frame_width*frame_height; i++) {\r\n                                        img[i]=(uint16_t)round((float)(video[c*frame_width*frame_height+i]-avgMin)*(float)0xFFFF/fabs(avgMax-avgMin));\r\n                                    }\r\n                                    TinyTIFFWriter_writeImage(tif, img);\r\n                                    if (real_video_count/10>0) {\r\n                                        if (c%(real_video_count/10)==0) {\r\n                                            emit messageChanged(tr(\"saving video %1/%2...\").arg(c+1).arg(video_count));\r\n                                            progressIncrement(10);\r\n                                        }\r\n                                    }\r\n                                }\r\n                                if (real_video_count/10<=0) progressIncrement(100);\r\n                                qfFree(img);\r\n                                TinyTIFFWriter_close(tif);\r\n                                videoAvgMin = avgMin;\r\n                                videoAvgMax = avgMax;\r\n                            } else {\r\n                                m_status=-1; emit statusChanged(m_status);\r\n                                emit messageChanged(tr(\"could not create video '%1'!\").arg(localFilename));\r\n                            }\r\n\r\n                        } else emit progressIncrement(100);\r\n\r\n                        double videoUncorrectedAvgMin=0;\r\n                        double videoUncorrectedAvgMax=(float)0xFFFF;\r\n                        //************** SAVE VIDEO\r\n                        if ((m_status==1) && !was_canceled && video_uncorrected && real_video_count>0 ) {\r\n                            emit messageChanged(tr(\"saving uncorrected video ...\"));\r\n                            QString localFilename=videoUncorrectedFilename=outputFilenameBase+\".videouncorr.tif\";\r\n                            TinyTIFFFile* tif=TinyTIFFWriter_open(localFilename.toAscii().data(), 16, frame_width, frame_height);\r\n                            //TIFF* tif = TIFFOpen(localFilename.toAscii().data(),\"w\");\r\n                            if (tif) {\r\n                                float avgMin=video_uncorrected[0];\r\n                                float avgMax=video_uncorrected[0];\r\n                                for (register uint32_t i=0; i<frame_width*frame_height*video_count; i++) {\r\n                                    avgMin=(video_uncorrected[i]<avgMin)?video_uncorrected[i]:avgMin;\r\n                                    avgMax=(video_uncorrected[i]>avgMax)?video_uncorrected[i]:avgMax;\r\n                                }\r\n                                uint16_t* img=(uint16_t*)qfMalloc(frame_width*frame_height*sizeof(uint16_t));\r\n                                for (register uint32_t c=0; c<real_video_count; c++) {\r\n                                    for (register uint32_t i=0; i<frame_width*frame_height; i++) {\r\n                                        img[i]=(uint16_t)round((float)(video_uncorrected[c*frame_width*frame_height+i]-avgMin)*(float)0xFFFF/fabs(avgMax-avgMin));\r\n                                    }\r\n                                    TinyTIFFWriter_writeImage(tif, img);\r\n                                    if (real_video_count/10>0) {\r\n                                        if (c%(real_video_count/10)==0) {\r\n                                            emit messageChanged(tr(\"saving uncorrected video %1/%2...\").arg(c+1).arg(video_count));\r\n                                            progressIncrement(10);\r\n                                        }\r\n                                    }\r\n                                }\r\n                                if (real_video_count/10<=0) progressIncrement(100);\r\n                                qfFree(img);\r\n                                TinyTIFFWriter_close(tif);\r\n                                videoUncorrectedAvgMin = avgMin;\r\n                                videoUncorrectedAvgMax = avgMax;\r\n                            } else {\r\n                                m_status=-1; emit statusChanged(m_status);\r\n                                emit messageChanged(tr(\"could not create uncorrected video '%1'!\").arg(localFilename));\r\n                            }\r\n\r\n                        } else emit progressIncrement(100);\r\n\r\n                        //************** SAVE STATISTICS\r\n                        if ((m_status==1) && !was_canceled && job.statistics) {\r\n                            QString error=\"\";\r\n                            emit messageChanged(tr(\"saving statistics ...\"));\r\n                            if (!saveStatistics(statisticsFilename=outputFilenameBase+\".statistics.dat\", outputFilenameBase+\".statistics.plt\", statistics, tr(\"Corrected Statistics\"), &error)) {\r\n                                m_status=-1; emit statusChanged(m_status);\r\n                                emit messageChanged(tr(\"could not create statistics file %1!\").arg(error));\r\n                            }\r\n\r\n                            emit messageChanged(tr(\"saving background statistics ...\"));\r\n                            if (!saveStatistics(backstatisticsFilename=outputFilenameBase+\".backstatistics.dat\", outputFilenameBase+\".backstatistics.plt\", backstatistics, tr(\"Background Statistics\"), &error)) {\r\n                                m_status=-1; emit statusChanged(m_status);\r\n                                emit messageChanged(tr(\"could not create backgrond statistics file %1!\").arg(error));\r\n                            }\r\n\r\n                            emit messageChanged(tr(\"saving uncorrected statistics ...\"));\r\n                            if (!saveStatistics(uncorrectedStatisticsFilename=outputFilenameBase+\".uncorrstatistics.dat\", outputFilenameBase+\".uncorrstatistics.plt\", statistics_uncorrected, tr(\"Uncorrected Statistics\"), &error)) {\r\n                                m_status=-1; emit statusChanged(m_status);\r\n                                emit messageChanged(tr(\"could not create uncorrected statistics file %1!\").arg(error));\r\n                            }\r\n\r\n                            if (job.dualViewMode!=0) {\r\n                                emit messageChanged(tr(\"saving DV 1 statistics ...\"));\r\n                                if (!saveStatistics(statisticsFilename_dv1=outputFilenameBase+\".statistics_dv1.dat\", outputFilenameBase+\".statistics_dv1.plt\", dv_statistics[0], tr(\"Corrected Statistics, DV 1\"), &error)) {\r\n                                    m_status=-1; emit statusChanged(m_status);\r\n                                    emit messageChanged(tr(\"could not create DV 1 statistics file %1!\").arg(error));\r\n                                }\r\n                                emit messageChanged(tr(\"saving DV 2 statistics ...\"));\r\n                                if (!saveStatistics(statisticsFilename_dv2=outputFilenameBase+\".statistics_dv2.dat\", outputFilenameBase+\".statistics_dv2.plt\", dv_statistics[1], tr(\"Corrected Statistics, DV 2\"), &error)) {\r\n                                    m_status=-1; emit statusChanged(m_status);\r\n                                    emit messageChanged(tr(\"could not create DV 2 statistics file %1!\").arg(error));\r\n                                }\r\n\r\n\r\n                                emit messageChanged(tr(\"saving DV 1 background statistics ...\"));\r\n                                if (!saveStatistics(backstatisticsFilename_dv1=outputFilenameBase+\".backstatistics_dv1.dat\", outputFilenameBase+\".backstatistics_dv1.plt\", dv_backstatistics[0], tr(\"Background Statistics, DV 1\"), &error)) {\r\n                                    m_status=-1; emit statusChanged(m_status);\r\n                                    emit messageChanged(tr(\"could not create DV 1 background statistics file %1!\").arg(error));\r\n                                }\r\n                                emit messageChanged(tr(\"saving DV 2 background statistics ...\"));\r\n                                if (!saveStatistics(backstatisticsFilename_dv2=outputFilenameBase+\".backstatistics_dv2.dat\", outputFilenameBase+\".backstatistics_dv2.plt\", dv_backstatistics[1], tr(\"Background Statistics, DV 2\"), &error)) {\r\n                                    m_status=-1; emit statusChanged(m_status);\r\n                                    emit messageChanged(tr(\"could not create DV 2 background statistics file %1!\").arg(error));\r\n                                }\r\n\r\n\r\n                                emit messageChanged(tr(\"saving DV 1 uncorrected statistics ...\"));\r\n                                if (!saveStatistics(uncorrectedStatisticsFilename_dv1=outputFilenameBase+\".uncorrstatistics_dv1.dat\", outputFilenameBase+\".uncorrstatistics_dv1.plt\", dv_statistics_uncorrected[0], tr(\"Background Statistics, DV 1\"), &error)) {\r\n                                    m_status=-1; emit statusChanged(m_status);\r\n                                    emit messageChanged(tr(\"could not create DV 1 uncorrected statistics file %1!\").arg(error));\r\n                                }\r\n                                emit messageChanged(tr(\"saving DV 2 uncorrected statistics ...\"));\r\n                                if (!saveStatistics(uncorrectedStatisticsFilename_dv2=outputFilenameBase+\".uncorrstatistics_dv2.dat\", outputFilenameBase+\".uncorrstatistics_dv2.plt\", dv_statistics_uncorrected[1], tr(\"Background Statistics, DV 2\"), &error)) {\r\n                                    m_status=-1; emit statusChanged(m_status);\r\n                                    emit messageChanged(tr(\"could not create DV 2 uncorrected statistics file %1!\").arg(error));\r\n                                }\r\n\r\n                            }\r\n\r\n                        }\r\n                        emit progressIncrement(10);\r\n\r\n\r\n\r\n                        //************** SAVE SETTINGS\r\n                        if ((m_status==1) && !was_canceled) {\r\n                            emit messageChanged(tr(\"saving settings ...\"));\r\n                            QString& localFilename=configFilename;\r\n                            QFile f(localFilename);\r\n                            QDir d=QFileInfo(localFilename).absoluteDir();\r\n                            if (f.open(QIODevice::WriteOnly|QIODevice::Text)) {\r\n                                QTextStream text(&f);\r\n                                text.setLocale(outLocale);\r\n\r\n                                text<<\"date/time                   : \"<<QDateTime::currentDateTime().toString(\"yyyy/MM/dd hh:mm:ss\") << \"\\n\";\r\n                                text<<\"input file                  : \"<<d.relativeFilePath(job.filename) << \"\\n\";\r\n                                if (!job.descriptionFilename.isEmpty()) text<<\"input description file      : \" << d.relativeFilePath(job.descriptionFilename) << \"\\n\";\r\n                                if (!averageFilename.isEmpty())         text<<\"overview image file         : \" << d.relativeFilePath(averageFilename) << \"\\n\";\r\n                                if (!averageFilenameF.isEmpty())        text<<\"overview image file real    : \" << d.relativeFilePath(averageFilenameF) << \"\\n\";\r\n                                if (!stdFilename.isEmpty())             text<<\"overview std image          : \" << d.relativeFilePath(stdFilename) << \"\\n\";\r\n                                if (!backgroundFilename.isEmpty())      text<<\"background image file       : \" << d.relativeFilePath(backgroundFilename) << \"\\n\";\r\n                                if (!backstdFilename.isEmpty())         text<<\"background stddev           : \" << d.relativeFilePath(backstdFilename) << \"\\n\";\r\n                                if (!averageUncorrectedFilename.isEmpty())         text<<\"uncorr. overview image file : \" << d.relativeFilePath(averageUncorrectedFilename) << \"\\n\";\r\n                                if (!stdUncorrectedFilename.isEmpty())             text<<\"uncorr. overview std image  : \" << d.relativeFilePath(stdUncorrectedFilename) << \"\\n\";\r\n                                if (!videoFilename.isEmpty())           text<<\"video file                  : \" << d.relativeFilePath(videoFilename) << \"\\n\";\r\n                                if (!videoUncorrectedFilename.isEmpty())text<<\"uncorrected video file      : \" << d.relativeFilePath(videoUncorrectedFilename) << \"\\n\";\r\n                                if (!statisticsFilename.isEmpty())      text<<\"statistics file             : \" << d.relativeFilePath(statisticsFilename) << \"\\n\";\r\n                                if (!backstatisticsFilename.isEmpty())         text<<\"background statistics file  : \" << d.relativeFilePath(backstatisticsFilename) << \"\\n\";\r\n                                if (!uncorrectedStatisticsFilename.isEmpty())  text<<\"uncorrected statistics file : \" << d.relativeFilePath(uncorrectedStatisticsFilename) << \"\\n\";\r\n\r\n                                if (!statisticsFilename_dv1.isEmpty())      text<<\"statistics file DV1         : \" << d.relativeFilePath(statisticsFilename_dv1) << \"\\n\";\r\n                                if (!backstatisticsFilename_dv1.isEmpty())         text<<\"background statistics file DV1 : \" << d.relativeFilePath(backstatisticsFilename_dv1) << \"\\n\";\r\n                                if (!uncorrectedStatisticsFilename_dv1.isEmpty())  text<<\"uncorrected statistics file DV1 : \" << d.relativeFilePath(uncorrectedStatisticsFilename_dv1) << \"\\n\";\r\n                                if (!statisticsFilename_dv2.isEmpty())      text<<\"statistics file DV2         : \" << d.relativeFilePath(statisticsFilename_dv2) << \"\\n\";\r\n                                if (!backstatisticsFilename_dv2.isEmpty())         text<<\"background statistics file DV2 : \" << d.relativeFilePath(backstatisticsFilename_dv2) << \"\\n\";\r\n                                if (!uncorrectedStatisticsFilename_dv2.isEmpty())  text<<\"uncorrected statistics file DV2 : \" << d.relativeFilePath(uncorrectedStatisticsFilename_dv2) << \"\\n\";\r\n\r\n                                if (!acfFilename.isEmpty())             text<<\"autocorrelation file        : \" << d.relativeFilePath(acfFilename) << \"\\n\";\r\n                                if (!acfFilenameBin.isEmpty())          text<<\"bin. autocorrelation file   : \" << d.relativeFilePath(acfFilenameBin) << \"\\n\";\r\n                                if (!ccfFilename.isEmpty())             text<<\"crosscorrelation file       : \" << d.relativeFilePath(ccfFilename) << \"\\n\";\r\n                                if (!ccfFilenameBin.isEmpty())          text<<\"bin. crosscorrelation file  : \" << d.relativeFilePath(ccfFilenameBin) << \"\\n\";\r\n                                for (int id=0; id<qMax(dccfFilename.size(), dccfFilenameBin.size()); id++) {\r\n                                    if (id<dccfFilename.size())            text<<QString(\"distance ccf file %1        : \").arg(id) << d.relativeFilePath(dccfFilename[id]) << \"\\n\";\r\n                                    if (id<dccfFilenameBin.size())         text<<QString(\"bin. distance ccf file %1   : \").arg(id) << d.relativeFilePath(dccfFilenameBin[id]) << \"\\n\";\r\n                                }\r\n                                text<<\"width                       : \"<<outLocale.toString(frame_width) << \"\\n\";\r\n                                text<<\"height                      : \"<<outLocale.toString(frame_height) << \"\\n\";\r\n                                if (job.cameraSettingsGiven) {\r\n                                    text<<\"pixel width                 : \"<<outLocale.toString(job.cameraPixelWidth) << \"\\n\";\r\n                                    text<<\"pixel height                : \"<<outLocale.toString(job.cameraPixelHeight) << \"\\n\";\r\n                                }\r\n                                text<<\"frametime (ms)              : \"<<job.frameTime*1.0e3 << \"\\n\";\r\n                                text<<\"frametime (s)               : \"<<job.frameTime << \"\\n\";\r\n                                text<<\"dualview mode               : \"<<job.dualViewMode << \"\\n\";\r\n                                text<<\"binning                     : \"<<outLocale.toString(reader->getBinning()) << \"\\n\";\r\n                                text<<\"interleaved binning         : \"<< QString((reader->getInterleavedBinning())?\"true\":\"false\") << \"\\n\";\r\n                                text<<\"averaging binning           : \"<< QString((reader->getAverageBinning())?\"true\":\"false\") << \"\\n\";\r\n                                if (reader->getUseCropping()) {\r\n                                    text<<\"crop x0                     : \"<<outLocale.toString(reader->getCropX0()) << \"\\n\";\r\n                                    text<<\"crop x1                     : \"<<outLocale.toString(reader->getCropX1()) << \"\\n\";\r\n                                    text<<\"crop y0                     : \"<<outLocale.toString(reader->getCropY0()) << \"\\n\";\r\n                                    text<<\"crop y1                     : \"<<outLocale.toString(reader->getCropY1()) << \"\\n\";\r\n                                }\r\n                                text<<\"frame count in file         : \"<<outLocale.toString(frame_count) << \"\\n\";\r\n                                text<<\"frame count                 : \"<<outLocale.toString(frames) << \"\\n\";\r\n                                text<<\"first frame                 : \"<<outLocale.toString(first_frame) << \"\\n\";\r\n                                text<<\"last frame                  : \"<<outLocale.toString(first_frame+frames-1) << \"\\n\";\r\n                                text<<\"correlation segments        : \"<<outLocale.toString(double(frames)/double(job.segments)*job.frameTime) << \"\\n\";\r\n                                text<<\"segments length (s)         : \"<<outLocale.toString(job.segments) << \"\\n\";\r\n                                text<<\"correlator S                : \"<<outLocale.toString(job.S) << \"\\n\";\r\n                                text<<\"correlator m                : \"<<outLocale.toString(job.m) << \"\\n\";\r\n                                text<<\"correlator P                : \"<<outLocale.toString(job.P) << \"\\n\";\r\n                                text<<\"correlator type             : \"<<outLocale.toString(job.correlator) << \"\\n\";\r\n                                text<<\"correlator type name        : \";\r\n                                switch(job.correlator) {\r\n                                    case CORRELATOR_DIRECT:      text<<\"direct\\n\"; break;\r\n                                    case CORRELATOR_DIRECTAVG:   text<<\"direct with averaging\\n\"; break;\r\n                                    case CORRELATOR_DIRECT_INT:    text<<\"direct, integer\\n\"; break;\r\n                                    case CORRELATOR_DIRECTAVG_INT: text<<\"direct with averaging, integer\\n\"; break;\r\n                                    case CORRELATOR_MTAUALLMON:  text<<\"multi-tau with monitors for all channels\\n\"; break;\r\n                                    case CORRELATOR_MTAUONEMON:  text<<\"multi-tau with a single monitor\\n\"; break;\r\n                                    case CORRELATOR_CORRELATORFROMSHAREDLIB:  text<<\"multi-tau from shared library\\n\"; break;\r\n\r\n                                    default: text<<\"correlator type name        : unknown\\n\"; break;\r\n                                }\r\n                                text<<\"smallest tau [s]            : \"<<outLocale.toString(job.frameTime) << \"\\n\";\r\n                                text<<\"baseline                    : \"<<outLocale.toString(baseline) << \"\\n\";\r\n                                if (video && job.video) {\r\n                                    text<<\"video sum up                : \"<<outLocale.toString(job.video_frames) << \"\\n\";\r\n                                    text<<\"video frames                : \"<<outLocale.toString(real_video_count) << \"\\n\";\r\n                                    text<<\"video avgMin                : \"<<outLocale.toString(videoAvgMin) << \"\\n\";\r\n                                    text<<\"video avgMax                : \"<<outLocale.toString(videoAvgMax) << \"\\n\";\r\n                                    text<<\"video uncorrected avgMin    : \"<<outLocale.toString(videoUncorrectedAvgMin) << \"\\n\";\r\n                                    text<<\"video uncorrected avgMax    : \"<<outLocale.toString(videoUncorrectedAvgMax) << \"\\n\";\r\n                                }\r\n                                if (job.statistics) {\r\n                                    text<<\"statistics over             : \"<<outLocale.toString(job.statistics_frames) << \"\\n\";\r\n                                }\r\n                                if (job.distanceCCF) {\r\n                                    for (int id=0; id<job.DCCFDeltaX.size(); id++) {\r\n                                        text<<QString(\"DCCF %1 role                   : \").arg(id)<<job.DCCFrole[id] << \"\\n\";\r\n                                        text<<QString(\"DCCF %1 Delta x                : \").arg(id)<<outLocale.toString(job.DCCFDeltaX[id]) << \"\\n\";\r\n                                        text<<QString(\"DCCF %1 Delta y                : \").arg(id)<<outLocale.toString(job.DCCFDeltaY[id]) << \"\\n\";\r\n                                        text<<QString(\"DCCF %1 frame width            : \").arg(id)<<outLocale.toString(dccf[id].dccfframe_width) << \"\\n\";\r\n                                        text<<QString(\"DCCF %1 frame height           : \").arg(id)<<outLocale.toString(dccf[id].dccfframe_height) << \"\\n\";\r\n                                    }\r\n\r\n                                }\r\n                                text<<\"bleach correction           : \";\r\n                                if (job.bleach==BLEACH_EXP) {\r\n                                    text<<\"remove mono-exponential f(t)=A*exp(-t/tau) using LM-Fit\\n\";\r\n                                    text<<\"bleach average frames       : \"<<outLocale.toString(job.bleachAvgFrames) << \"\\n\";\r\n                                    text<<\"bleach amplitude file       : \"<<d.relativeFilePath(bleachAmplitudeFilename) << \"\\n\";\r\n                                    text<<\"bleach time file            : \"<<d.relativeFilePath(bleachTimeFilename) << \"\\n\";\r\n                                    text<<\"bleach fit success          : \"<<d.relativeFilePath(bleachFitSuccessFilename) << \"\\n\";\r\n                                    text<<\"bleach timeseries t file    : \"<<d.relativeFilePath(bleachtimesFilename) << \"\\n\";\r\n                                    text<<\"bleach timeseries I file    : \"<<d.relativeFilePath(bleachframesFilename) << \"\\n\";\r\n                                    text<<\"bleach correction           : \";\r\n                                } else if (job.bleach==BLEACH_EXP_POLY2 ) {\r\n                                    text<<\"remove mono-exponential(polynomial) f(t)=A*exp(-(t+f2*t^2)/tau) using LM-Fit\\n\";\r\n                                    text<<\"bleach average frames       : \"<<outLocale.toString(job.bleachAvgFrames) << \"\\n\";\r\n                                    text<<\"bleach amplitude file       : \"<<d.relativeFilePath(bleachAmplitudeFilename) << \"\\n\";\r\n                                    text<<\"bleach time file            : \"<<d.relativeFilePath(bleachTimeFilename) << \"\\n\";\r\n                                    text<<\"bleach polynomial factor file : \"<<d.relativeFilePath(bleachPoly2Filename) << \"\\n\";\r\n                                    text<<\"bleach polynomial factor 3 file : \"<<d.relativeFilePath(bleachPoly3Filename) << \"\\n\";\r\n                                    text<<\"bleach fit success          : \"<<d.relativeFilePath(bleachFitSuccessFilename) << \"\\n\";\r\n                                    text<<\"bleach timeseries t file    : \"<<d.relativeFilePath(bleachtimesFilename) << \"\\n\";\r\n                                    text<<\"bleach timeseries I file    : \"<<d.relativeFilePath(bleachframesFilename) << \"\\n\";\r\n                                } else if (job.bleach==BLEACH_EXP_POLY3) {\r\n                                    text<<\"remove mono-exponential(polynomial) f(t)=A*exp(-(t+f2*t^2+f3*t^3)/tau) using LM-Fit\\n\";\r\n                                    text<<\"bleach average frames       : \"<<outLocale.toString(job.bleachAvgFrames) << \"\\n\";\r\n                                    text<<\"bleach amplitude file       : \"<<d.relativeFilePath(bleachAmplitudeFilename) << \"\\n\";\r\n                                    text<<\"bleach time file            : \"<<d.relativeFilePath(bleachTimeFilename) << \"\\n\";\r\n                                    text<<\"bleach polynomial factor file : \"<<d.relativeFilePath(bleachPoly2Filename) << \"\\n\";\r\n                                    text<<\"bleach polynomial factor 3 file : \"<<d.relativeFilePath(bleachPoly3Filename) << \"\\n\";\r\n                                    text<<\"bleach fit success          : \"<<d.relativeFilePath(bleachFitSuccessFilename) << \"\\n\";\r\n                                    text<<\"bleach timeseries t file    : \"<<d.relativeFilePath(bleachtimesFilename) << \"\\n\";\r\n                                    text<<\"bleach timeseries I file    : \"<<d.relativeFilePath(bleachframesFilename) << \"\\n\";\r\n                                } else if (job.bleach==BLEACH_EXP_POLY4) {\r\n                                    text<<\"remove mono-exponential(polynomial) f(t)=A*exp(-(t+f*t^2+f3*t^3+f4*t^4)/tau) using LM-Fit\\n\";\r\n                                    text<<\"bleach average frames       : \"<<outLocale.toString(job.bleachAvgFrames) << \"\\n\";\r\n                                    text<<\"bleach amplitude file       : \"<<d.relativeFilePath(bleachAmplitudeFilename) << \"\\n\";\r\n                                    text<<\"bleach time file            : \"<<d.relativeFilePath(bleachTimeFilename) << \"\\n\";\r\n                                    text<<\"bleach polynomial factor file : \"<<d.relativeFilePath(bleachPoly2Filename) << \"\\n\";\r\n                                    text<<\"bleach polynomial factor 3 file : \"<<d.relativeFilePath(bleachPoly3Filename) << \"\\n\";\r\n                                    text<<\"bleach polynomial factor 4 file : \"<<d.relativeFilePath(bleachPoly4Filename) << \"\\n\";\r\n                                    text<<\"bleach fit success          : \"<<d.relativeFilePath(bleachFitSuccessFilename) << \"\\n\";\r\n                                    text<<\"bleach timeseries t file    : \"<<d.relativeFilePath(bleachtimesFilename) << \"\\n\";\r\n                                    text<<\"bleach timeseries I file    : \"<<d.relativeFilePath(bleachframesFilename) << \"\\n\";\r\n                                } else if (job.bleach==BLEACH_EXP_POLY5) {\r\n                                    text<<\"remove mono-exponential(polynomial) f(t)=A*exp(-(t+f*t^2+f3*t^3+f4*t^4+f5*t^5)/tau) using LM-Fit\\n\";\r\n                                    text<<\"bleach average frames       : \"<<outLocale.toString(job.bleachAvgFrames) << \"\\n\";\r\n                                    text<<\"bleach amplitude file       : \"<<d.relativeFilePath(bleachAmplitudeFilename) << \"\\n\";\r\n                                    text<<\"bleach time file            : \"<<d.relativeFilePath(bleachTimeFilename) << \"\\n\";\r\n                                    text<<\"bleach polynomial factor file : \"<<d.relativeFilePath(bleachPoly2Filename) << \"\\n\";\r\n                                    text<<\"bleach polynomial factor 3 file : \"<<d.relativeFilePath(bleachPoly3Filename) << \"\\n\";\r\n                                    text<<\"bleach polynomial factor 4 file : \"<<d.relativeFilePath(bleachPoly4Filename) << \"\\n\";\r\n                                    text<<\"bleach polynomial factor 5 file : \"<<d.relativeFilePath(bleachPoly5Filename) << \"\\n\";\r\n                                    text<<\"bleach fit success          : \"<<d.relativeFilePath(bleachFitSuccessFilename) << \"\\n\";\r\n                                    text<<\"bleach timeseries t file    : \"<<d.relativeFilePath(bleachtimesFilename) << \"\\n\";\r\n                                    text<<\"bleach timeseries I file    : \"<<d.relativeFilePath(bleachframesFilename) << \"\\n\";\r\n                                } else if (job.bleach==BLEACH_DBL_EXP) {\r\n                                    text<<\"remove double-exponential f(t)=A*exp(-t/tau)+A2*exp(-t/tau2) using LM-Fit\\n\";\r\n                                    text<<\"bleach average frames       : \"<<outLocale.toString(job.bleachAvgFrames) << \"\\n\";\r\n                                    text<<\"bleach amplitude file       : \"<<d.relativeFilePath(bleachAmplitudeFilename) << \"\\n\";\r\n                                    text<<\"bleach time file            : \"<<d.relativeFilePath(bleachTimeFilename) << \"\\n\";\r\n                                    text<<\"bleach amplitude 2 file       : \"<<d.relativeFilePath(bleachAmplitude2Filename) << \"\\n\";\r\n                                    text<<\"bleach time 2 file            : \"<<d.relativeFilePath(bleachTime2Filename) << \"\\n\";\r\n                                    text<<\"bleach fit success          : \"<<d.relativeFilePath(bleachFitSuccessFilename) << \"\\n\";\r\n                                    text<<\"bleach timeseries t file    : \"<<d.relativeFilePath(bleachtimesFilename) << \"\\n\";\r\n                                    text<<\"bleach timeseries I file    : \"<<d.relativeFilePath(bleachframesFilename) << \"\\n\";\r\n                                } else if (job.bleach==BLEACH_EXPREG) {\r\n                                    text<<\"remove mono-exponential f(t)=A*exp(-t/tau) using linear regression\\n\";\r\n                                    text<<\"bleach average frames       : \"<<outLocale.toString(job.bleachAvgFrames) << \"\\n\";\r\n                                    text<<\"bleach amplitude file       : \"<<d.relativeFilePath(bleachAmplitudeFilename) << \"\\n\";\r\n                                    text<<\"bleach time file            : \"<<d.relativeFilePath(bleachTimeFilename) << \"\\n\";\r\n                                    text<<\"bleach fit success          : \"<<d.relativeFilePath(bleachFitSuccessFilename) << \"\\n\";\r\n                                    text<<\"bleach timeseries t file    : \"<<d.relativeFilePath(bleachtimesFilename) << \"\\n\";\r\n                                    text<<\"bleach timeseries I file    : \"<<d.relativeFilePath(bleachframesFilename) << \"\\n\";\r\n                                }  else if (job.bleach==BLEACH_NONE) {\r\n                                        text<<\"remove frame average\\n\";\r\n                                        text<<\"bleach average frames       : \"<<outLocale.toString(job.bleachAvgFrames) << \"\\n\";\r\n\r\n                                } else {\r\n                                    text<<\"none\\n\";\r\n                                }\r\n                                text<<\"duration [s]                : \"<<ptime.elapsed()/1000.0 << \"\\n\";\r\n\r\n                                f.close();\r\n                            } else {\r\n                                m_status=-1; emit statusChanged(m_status);\r\n                                emit messageChanged(tr(\"could not create settings file '%1': %2!\").arg(localFilename).arg(f.errorString()));\r\n                            }\r\n\r\n                        }\r\n                        emit progressIncrement(10);\r\n\r\n\r\n                        //************** SAVE ACF\r\n                        if ((m_status==1) && !was_canceled && job.acf && acf && acf_tau && acf_N>0) {\r\n                            QString localFilename=acfFilename=outputFilenameBase+\".autocorrelation.dat\";\r\n                            QString localFilename1=acfFilenameBin=outputFilenameBase+\".autocorrelation.bin\";\r\n\r\n                            emit messageChanged(tr(\"saving autocorrelation ...\"));\r\n                            double* ccf[1]={acf};\r\n                            double* ccferr[1]={acf_std};\r\n                            double* ccfsegments[1]={acf_segments};\r\n                            QString error;\r\n                            //qDebug()<<\"acf = \"<<acf<<\"  acf_std = \"<<acf_std;\r\n                            if (!saveCorrelationCSV(localFilename, acf_tau, ccf, ccferr, 1, acf_N, frame_width, frame_height, input_length, error,125, double(frames)/double(job.segments)*job.frameTime)) {\r\n                                m_status=-1; emit statusChanged(m_status);\r\n                                emit messageChanged(tr(\"could not create autocorrelation file '%1': %2!\").arg(localFilename).arg(error));\r\n                            }\r\n                            if (!saveCorrelationBIN(localFilename1, acf_tau, ccf, ccferr, 1, acf_N, frame_width, frame_height, ccfsegments, error,125, double(frames)/double(job.segments)*job.frameTime)) {\r\n                                m_status=-1; emit statusChanged(m_status);\r\n                                emit messageChanged(tr(\"could not create binary autocorrelation file '%1': %2!\").arg(localFilename1).arg(error));\r\n                            }\r\n                            if (job.addFCCSSeparately && job.dualViewMode!=0) {\r\n                                if (QFile::exists(localFilename1)) {\r\n                                    addFiles.append(getFileInfo(localFilename1, configFilename, \"ACF0\", 0, getGroupName()));\r\n                                    addFiles.append(getFileInfo(localFilename1, configFilename, \"ACF1\", 1, getGroupName()));\r\n                                } else {\r\n                                    addFiles.append(getFileInfo(localFilename, configFilename, \"ACF0\", 0, getGroupName()));\r\n                                    addFiles.append(getFileInfo(localFilename, configFilename, \"ACF1\", 1, getGroupName()));\r\n                                }\r\n                            } else {\r\n                                if (QFile::exists(localFilename1)) addFiles.append(getFileInfo(localFilename1, configFilename, \"ACF\", getGroupName()));\r\n                                else addFiles.append(getFileInfo(localFilename, configFilename, \"ACF\", getGroupName()));\r\n                            }\r\n\r\n                        }\r\n                        emit progressIncrement(250);\r\n\r\n\r\n                        //************** SAVE DCCF\r\n                        if ((m_status==1) && !was_canceled && job.distanceCCF) {\r\n                            for (int id=0; id<job.DCCFDeltaX.size(); id++) {\r\n                                if (dccf[id].dccf && dccf[id].dccf_tau && dccf[id].dccf_N>0) {\r\n                                    QString localFilename=outputFilenameBase+QString(\".dccf%1.dat\").arg(id,3,10,QLatin1Char('0'));\r\n                                    QString localFilename1=outputFilenameBase+QString(\".dccf%1.bin\").arg(id,3,10,QLatin1Char('0'));;\r\n                                    dccfFilename.append(localFilename);\r\n                                    dccfFilenameBin.append(localFilename1);\r\n\r\n                                    emit messageChanged(tr(\"saving distance distance crosscorrelation ...\"));\r\n                                    double* ccf[1]={dccf[id].dccf};\r\n                                    double* ccferr[1]={dccf[id].dccf_std};\r\n                                    double* ccfsegments[1]={dccf[id].dccf_segments};\r\n                                    QString error;\r\n                                    if (!saveCorrelationCSV(localFilename, dccf[id].dccf_tau, ccf, ccferr, 1, dccf[id].dccf_N, frame_width, frame_height, input_length, error,125, double(frames)/double(job.segments)*job.frameTime)) {\r\n                                        m_status=-1; emit statusChanged(m_status);\r\n                                        emit messageChanged(tr(\"could not create distance crosscorrelation file '%1': %2!\").arg(localFilename).arg(error));\r\n                                    }\r\n                                    if (!saveCorrelationBIN(localFilename1, dccf[id].dccf_tau, ccf, ccferr, 1, dccf[id].dccf_N, frame_width, frame_height, ccfsegments, error,125, double(frames)/double(job.segments)*job.frameTime)) {\r\n                                        m_status=-1; emit statusChanged(m_status);\r\n                                        emit messageChanged(tr(\"could not create binary distance crosscorrelation file '%1': %2!\").arg(localFilename1).arg(error));\r\n                                    }\r\n                                    QString role=job.DCCFrole.value(id, \"DCCF\");\r\n                                    if (role.toLower()==\"fccs\") {\r\n                                        if (QFile::exists(localFilename1)) addFiles.append(getFileInfo(localFilename1, configFilename, role, 0, getGroupName()));\r\n                                        else addFiles.append(getFileInfo(localFilename, configFilename, role, 0, getGroupName()));\r\n                                    } else {\r\n                                        if (QFile::exists(localFilename1)) addFiles.append(getFileInfo(localFilename1, configFilename, role, getGroupName()));\r\n                                        else addFiles.append(getFileInfo(localFilename, configFilename, role, getGroupName()));\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                        emit progressIncrement(250);\r\n\r\n\r\n                        //************** SAVE CCF\r\n                        if ((m_status==1) && !was_canceled && job.ccf && ccf_tau && ccf1 && ccf2 && ccf3 && ccf4 && ccf_N>0) {\r\n                            QString localFilename=ccfFilename=outputFilenameBase+\".crosscorrelation.dat\";\r\n                            QString localFilename1=ccfFilenameBin=outputFilenameBase+\".crosscorrelation.bin\";\r\n\r\n                            emit messageChanged(tr(\"saving distance crosscorrelation ...\"));\r\n                            double* ccf[4]={ccf1, ccf2, ccf3, ccf4};\r\n                            double* ccferr[4]={ccf1_std, ccf2_std, ccf3_std, ccf4_std};\r\n                            double* ccfsegments[4]={ccf1_segments, ccf2_segments, ccf3_segments, ccf4_segments};\r\n                            QString error;\r\n                            if (!saveCorrelationCSV(localFilename, ccf_tau, ccf, ccferr, 4, ccf_N, frame_width, frame_height, input_length, error, 0, double(frames)/double(job.segments)*job.frameTime)) {\r\n                                m_status=-1; emit statusChanged(m_status);\r\n                                emit messageChanged(tr(\"could not create crosscorrelation file '%1': %2!\").arg(localFilename).arg(error));\r\n                            }\r\n                            if (!saveCorrelationBIN(localFilename1, ccf_tau, ccf, ccferr, 4, ccf_N, frame_width, frame_height, ccfsegments, error, 0, double(frames)/double(job.segments)*job.frameTime)) {\r\n                                m_status=-1; emit statusChanged(m_status);\r\n                                emit messageChanged(tr(\"could not create binary crosscorrelation file '%1': %2!\").arg(localFilename1).arg(error));\r\n                            }\r\n                            if (QFile::exists(localFilename1)) addFiles.append(getFileInfo(localFilename1, configFilename, QString(\"CCF\"), getGroupName()));\r\n                            else addFiles.append(getFileInfo((localFilename), configFilename, \"CCF\", getGroupName()));\r\n\r\n                        }\r\n                        emit progressIncrement(10);\r\n\r\n\r\n\r\n                        //qDebug()<<job.addNandB<< QFile::exists(averageFilenameF)<< QFile::exists(stdFilename)<< QFile::exists(backgroundFilename)<< QFile::exists(backstdFilename);\r\n\r\n                        //************** CREATE N&B job\r\n                        if (job.addNandB\r\n                                && QFile::exists(averageFilenameF)\r\n                                && QFile::exists(stdFilename)\r\n                                /*&& QFile::exists(backgroundFilename)\r\n                                && QFile::exists(backstdFilename)*/) {\r\n\r\n                            if (job.addFCCSSeparately && job.dualViewMode!=0) {\r\n                                addFiles.append(getFileInfoNandB(averageFilenameF, stdFilename, backgroundFilename, backstdFilename, configFilename, \"N&B1\", 0, getGroupName()));\r\n                                addFiles.append(getFileInfoNandB(averageFilenameF, stdFilename, backgroundFilename, backstdFilename, configFilename, \"N&B2\", 1, getGroupName()));\r\n                            } else {\r\n                                addFiles.append(getFileInfoNandB(averageFilenameF, stdFilename, backgroundFilename, backstdFilename, configFilename, \"N&B\", 0, getGroupName()));\r\n                            }\r\n                        }\r\n                    } else {\r\n                        if (mutexFilename) mutexFilename->unlock();\r\n                        m_status=-1; emit statusChanged(m_status);\r\n                        emit messageChanged(tr(\"could not create output subdirectory '%1' in '%2'!\").arg(localFileDirectory).arg(d.absolutePath()));\r\n                    }\r\n\r\n                    if (video) qfFree(video);\r\n                    if (video_uncorrected) qfFree(video_uncorrected);\r\n                    if (fit_frames) qfFree(fit_frames);\r\n                    if (fit_t) qfFree(fit_t);\r\n                    if (bleachAmplitude) qfFree(bleachAmplitude);\r\n                    if (bleachTime) qfFree(bleachTime);\r\n                    if (bleachAmplitude2) qfFree(bleachAmplitude2);\r\n                    if (bleachTime2) qfFree(bleachTime2);\r\n                    if (bleachPoly2) qfFree(bleachPoly2);\r\n                    if (bleachPoly3) qfFree(bleachPoly3);\r\n                    if (bleachPoly4) qfFree(bleachPoly4);\r\n                    if (bleachPoly5) qfFree(bleachPoly5);\r\n                    if (bleachFitOK) qfFree(bleachFitOK);\r\n                    if (average_frame) qfFree(average_frame);\r\n                    if (sqrsum_frame) qfFree(sqrsum_frame);\r\n                    if (acf_tau) qfFree(acf_tau);\r\n                    if (acf) qfFree(acf);\r\n                    if (acf_segments) qfFree(acf_segments);\r\n                    if (acf_std) qfFree(acf_std);\r\n                    if (ccf_tau) qfFree(ccf_tau);\r\n                    if (ccf1) qfFree(ccf1);\r\n                    if (ccf2) qfFree(ccf2);\r\n                    if (ccf3) qfFree(ccf3);\r\n                    if (ccf4) qfFree(ccf4);\r\n                    if (ccf1_std) qfFree(ccf1_std);\r\n                    if (ccf2_std) qfFree(ccf2_std);\r\n                    if (ccf3_std) qfFree(ccf3_std);\r\n                    if (ccf4_std) qfFree(ccf4_std);\r\n                    if (ccf1_segments) qfFree(ccf1_segments);\r\n                    if (ccf2_segments) qfFree(ccf2_segments);\r\n                    if (ccf3_segments) qfFree(ccf3_segments);\r\n                    if (ccf4_segments) qfFree(ccf4_segments);\r\n                    for (int id=0; id<dccf.size(); id++) {\r\n                        if (dccf[id].dccf_tau) qfFree(dccf[id].dccf_tau);\r\n                        if (dccf[id].dccf) qfFree(dccf[id].dccf);\r\n                        if (dccf[id].dccf_std) qfFree(dccf[id].dccf_std);\r\n                        if (dccf[id].dccf_segments) qfFree(dccf[id].dccf_segments);\r\n                    }\r\n                    dccf.clear();\r\n                    if (m_status==1) {\r\n                        if (was_canceled) {\r\n                            m_status=-1; emit statusChanged(m_status);\r\n                            duration=ptime.elapsed();\r\n                            emit messageChanged(tr(\"canceled by user\"));\r\n                        } else {\r\n                            m_status=2; emit statusChanged(m_status);\r\n                            duration=ptime.elapsed();\r\n                            emit messageChanged(tr(\"correlation ... done [duration = %1 s]\").arg(duration/1.0e3));\r\n                        }\r\n                        emit statusChanged(m_status);\r\n                    }\r\n                } else {\r\n                    m_status=-1; emit statusChanged(m_status);\r\n                    duration=ptime.elapsed();\r\n                    emit messageChanged(tr(\"no frames in file/selected\"));\r\n                }\r\n\r\n\r\n            }\r\n            delete reader;\r\n        } else {\r\n            m_status=-1; emit statusChanged(m_status);\r\n            duration=ptime.elapsed();\r\n            emit messageChanged(tr(\"could not create image reader object\"));\r\n        }\r\n    }\r\n\r\n\r\n    duration=ptime.elapsed();\r\n}",
    "bool QFRDRNumberAndBrightnessProcessingJobThread::SaveSDTIFF(const QString &filename, float *average_frame, float *sqrsum_frame, int frame_width, int frame_height, int frames, const QString &title, QString *error)\r\n{\r\n    TIFF* tif = TIFFOpen(filename.toAscii().data(),\"w\");\r\n    if (tif) {\r\n        float* sd=(float*)qfCalloc(frame_width*frame_height, sizeof(float));\r\n\r\n        if (frames>1) {\r\n            for (int i=0; i<frame_width*frame_height; i++) {\r\n                sd[i]=sqrt(float(frames)/float(frames-1)*(sqrsum_frame[i]-average_frame[i]*average_frame[i]));\r\n            }\r\n        } else {\r\n            for (int i=0; i<frame_width*frame_height; i++) {\r\n                sd[i]=0;\r\n            }\r\n\r\n        }\r\n\r\n        TIFFTWriteFloat(tif, sd, frame_width, frame_height);\r\n        TIFFClose(tif);\r\n        qfFree(sd);\r\n        return true;\r\n    } else {\r\n        if (error) *error=tr(\"could not create %2 '%1'!\").arg(filename).arg(title);\r\n        return false;\r\n    }\r\n}",
    "bool QFRDRNumberAndBrightnessProcessingJobThread::SaveTIFFFloat(const QString &filename, float *average_frame, int frame_width, int frame_height, const QString &title, QString *error)\r\n{\r\n    TIFF* tif = TIFFOpen(filename.toAscii().data(),\"w\");\r\n    if (tif) {\r\n\r\n        TIFFTWriteFloat(tif, average_frame, frame_width, frame_height);\r\n        TIFFClose(tif);\r\n        return true;\r\n    } else {\r\n        if (error) *error=tr(\"could not create %2 image '%1'!\").arg(filename).arg(title);\r\n        return false;\r\n    }\r\n}",
    "bool QFRDRNumberAndBrightnessProcessingJobThread::SaveTIFFUInt16_scaled(const QString &filename, float *average_frame, int frame_width, int frame_height, const QString &title, QString *error)\r\n{\r\n    TIFF* tif = TIFFOpen(filename.toAscii().data(),\"w\");\r\n    if (tif) {\r\n        float avgMin=average_frame[0];\r\n        float avgMax=average_frame[0];\r\n        for (int64_t i=0; i<frame_width*frame_height; i++) {\r\n            avgMin=(average_frame[i]<avgMin)?average_frame[i]:avgMin;\r\n            avgMax=(average_frame[i]>avgMax)?average_frame[i]:avgMax;\r\n        }\r\n        uint16_t* img=(uint16_t*)qfMalloc(frame_width*frame_height*sizeof(uint16_t));\r\n        for (int64_t i=0; i<frame_width*frame_height; i++) {\r\n            img[i]=(uint16_t)round((double)(average_frame[i]-avgMin)*(double)0xFFFF/fabs(avgMax-avgMin));\r\n        }\r\n        TIFFTWriteUint16(tif, img, frame_width, frame_height);\r\n        qfFree(img);\r\n        TIFFClose(tif);\r\n        return true;\r\n    } else {\r\n        if (error) *error=tr(\"could not create %2 '%1'!\").arg(filename).arg(title);\r\n        return false;\r\n    }\r\n}",
    "bool CxImageTIF::Decode(FILE * infile)\n{\n\t//Open file and fill the TIFF structure\n\t// m_tif = TIFFOpen(imageFileName,\"rb\");\n\tTIFF* m_tif = TIFFOpenEx(infile, \"rb\");\n\n\tuint32 height=0;\n\tuint32 width=0;\n\tuint16 bitspersample=1;\n\tuint16 samplesperpixel=1;\n\tuint32 rowsperstrip=-1;\n\tuint16 photometric=0;\n\tuint16 compression=1;\n\tuint32 x, y;\n\tBOOL isRGB;\n\tBYTE *bits;\t\t//pointer to source data\n\tBYTE *bits2;\t//pointer to destination data\n\n  try{\n\t//check if it's a tiff file\n\tif (!m_tif)\n\t\tthrow \"Error encountered while opening TIFF file\";\n\n\tinfo.nNumFrames=0;\n\twhile(TIFFSetDirectory(m_tif,(uint16)info.nNumFrames)) info.nNumFrames++;\n\n\n\tif (!TIFFSetDirectory(m_tif, (uint16)info.nFrame))\n\t\tthrow \"Error: page not present in TIFF file\";\t\t\t\n\n\t//get image info\n\tTIFFGetField(m_tif, TIFFTAG_COMPRESSION, &compression);\n\tif (compression == COMPRESSION_LZW)\n\t\tthrow \"LZW compression is no longer supported due to Unisys patent enforcement\";\t\t\t\n\n\tTIFFGetField(m_tif, TIFFTAG_IMAGEWIDTH, &width);\n\tTIFFGetField(m_tif, TIFFTAG_IMAGELENGTH, &height);\n\tTIFFGetField(m_tif, TIFFTAG_SAMPLESPERPIXEL, &samplesperpixel);\n\tTIFFGetField(m_tif, TIFFTAG_BITSPERSAMPLE, &bitspersample);\n\tTIFFGetField(m_tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);   \n\tTIFFGetField(m_tif, TIFFTAG_PHOTOMETRIC, &photometric);\n\n\thead.biWidth  = width;\n\thead.biHeight = height;\n\thead.biClrUsed=0;\n\tinfo.nBkgndIndex =-1;\n\n\tisRGB = (bitspersample >= 8) &&\n\t\t(photometric == PHOTOMETRIC_RGB) ||\n\t\t(photometric == PHOTOMETRIC_YCBCR) ||\n\t\t(photometric == PHOTOMETRIC_SEPARATED) ||\n\t\t(photometric == PHOTOMETRIC_LOGLUV);\n\n\tif (isRGB){\n\t\thead.biBitCount=24;\n\t\tinfo.bColorType = COLORTYPE_COLOR;\n\t}else{\n\t\tinfo.bColorType = COLORTYPE_PALETTE;\n\t\tif ((photometric==PHOTOMETRIC_MINISBLACK)||(photometric==PHOTOMETRIC_MINISWHITE)){\n\t\t\tif\t(bitspersample == 1){\n\t\t\t\thead.biBitCount=1;\t\t//B&W image\n\t\t\t\thead.biClrUsed =2;\n\t\t\t} else {\n\t\t\t\thead.biBitCount=8;\t\t//gray scale\n\t\t\t\thead.biClrUsed =256;\n\t\t\t}\n\t\t} else if (bitspersample == 4) {\n\t\t\thead.biBitCount=4;\t\t\t// 16 colors\n\t\t\thead.biClrUsed=16;\n\t\t} else {\n\t\t\thead.biBitCount=8;\t\t\t//256 colors\n\t\t\thead.biClrUsed=256;\n\t\t}\n\t}\n\n\tCreate(head.biWidth,head.biHeight,head.biBitCount);\t//image creation\n\n\tif (isRGB) {\n\t\t// Read the whole image into one big RGBA buffer using\n\t\t// the traditional TIFFReadRGBAImage() API that we trust.\n\t\tuint32* raster;\t\t// retrieve RGBA image\n\t\tuint32 *row;\n\n\t\traster = (uint32*)_TIFFmalloc(width * height * sizeof (uint32));\n\t\tif (raster == NULL) throw \"No space for raster buffer\";\n\t\t\t\n\t\t// Read the image in one chunk into an RGBA array\n\t\tif(!TIFFReadRGBAImage(m_tif, width, height, raster, 1)) {\n\t\t\t\t_TIFFfree(raster);\n\t\t\t\tthrow \"Corrupted TIFF file!\";\n\t\t}\n\n\t\t// read the raster lines and save them in the DIB\n\t\t// with RGB mode, we have to change the order of the 3 samples RGB\n\t\trow = &raster[0];\n\t\tbits2 = info.pImage;\n\t\tfor (y = 0; y < height; y++) {\n\t\t\tbits = bits2;\n\t\t\tfor (x = 0; x < width; x++) {\n\t\t\t\t*bits++ = (BYTE)TIFFGetB(row[x]);\n\t\t\t\t*bits++ = (BYTE)TIFFGetG(row[x]);\n\t\t\t\t*bits++ = (BYTE)TIFFGetR(row[x]);\n\t\t\t}\n\t\t\trow += width;\n\t\t\tbits2 += info.dwEffWidth;\n\t\t}\n\t\t_TIFFfree(raster);\n\t} else {\n\t\tRGBQUAD *pal;\n\t\tpal=(RGBQUAD*)calloc(256,sizeof(RGBQUAD));\n\t\tif (pal==NULL) throw \"Unable to allocate TIFF palette\";\n\n\t\t// set up the colormap based on photometric\t\n\t\tswitch(photometric) {\n\t\t\tcase PHOTOMETRIC_MINISBLACK:\t// bitmap and greyscale image types\n\t\t\tcase PHOTOMETRIC_MINISWHITE:\n\t\t\t\tif (bitspersample == 1) {\t// Monochrome image\n\t\t\t\t\tif (photometric == PHOTOMETRIC_MINISBLACK) {\n\t\t\t\t\t\tpal[1].rgbRed = pal[1].rgbGreen = pal[1].rgbBlue = 255;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpal[0].rgbRed = pal[0].rgbGreen = pal[0].rgbBlue = 255;\n\t\t\t\t\t}\n\t\t\t\t} else {\t\t// need to build the scale for greyscale images\n\t\t\t\t\tif (photometric == PHOTOMETRIC_MINISBLACK) {\n\t\t\t\t\t\tfor (int i = 0; i < 256; i++) {\n\t\t\t\t\t\t\tpal[i].rgbRed = pal[i].rgbGreen = pal[i].rgbBlue = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (int i = 0; i < 256; i++) {\n\t\t\t\t\t\t\tpal[i].rgbRed =\tpal[i].rgbGreen = pal[i].rgbBlue = 255 - i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PHOTOMETRIC_PALETTE:\t// color map indexed\n\t\t\t\tuint16 *red;\n\t\t\t\tuint16 *green;\n\t\t\t\tuint16 *blue;\n\t\t\t\tTIFFGetField(m_tif, TIFFTAG_COLORMAP, &red, &green, &blue); \n\n\t\t\t\t// Is the palette 16 or 8 bits ?\n\t\t\t\tBOOL Palette16Bits = FALSE;\n\t\t\t\tint n=1<<bitspersample;\n\t\t\t\twhile (n-- > 0) {\n\t\t\t\t\tif (red[n] >= 256 || green[n] >= 256 || blue[n] >= 256) {\n\t\t\t\t\t\tPalette16Bits=TRUE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// load the palette in the DIB\n\t\t\t\tfor (int i = (1 << bitspersample) - 1; i >= 0; i--) {\n\t\t\t\t\tif (Palette16Bits) {\n\t\t\t\t\t\tpal[i].rgbRed =(BYTE) CVT(red[i]);\n\t\t\t\t\t\tpal[i].rgbGreen = (BYTE) CVT(green[i]);\n\t\t\t\t\t\tpal[i].rgbBlue = (BYTE) CVT(blue[i]);           \n\t\t\t\t\t} else {\n\t\t\t\t\t\tpal[i].rgbRed = (BYTE) red[i];\n\t\t\t\t\t\tpal[i].rgbGreen = (BYTE) green[i];\n\t\t\t\t\t\tpal[i].rgbBlue = (BYTE) blue[i];        \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t\tSetPalette(pal,head.biClrUsed);\t//palette assign\n\t\tfree(pal);\n\n\t\t// read the tiff lines and save them in the DIB\n\t\tuint32 nrow;\n\t\tuint32 ys;\n\t\tint line = CalculateLine(width, bitspersample * samplesperpixel);\n//\t\tint pitch = CalculatePitch(line);\n\t\tlong bitsize= TIFFStripSize(m_tif);\n\t\tbits = (BYTE*)malloc(bitsize);\n\n\t\tfor (ys = 0; ys < height; ys += rowsperstrip) {\n\t\t\tnrow = (ys + rowsperstrip > height ? height - ys : rowsperstrip);\n\t\t\tif (TIFFReadEncodedStrip(m_tif, TIFFComputeStrip(m_tif, ys, 0), bits, nrow * line) == -1) {\n\t\t\t\tfree(bits);\n\t\t\t\tthrow \"Corrupted TIFF file!\";\n\t\t\t}\n\t\t\tfor (y = 0; y < nrow; y++) {\n\t\t\t\tmemcpy(info.pImage+info.dwEffWidth*(height-ys-nrow+y),bits+(nrow-y-1)*line,line);\n\t\t\t}\n\t\t\t/*if (head.biClrUsed==2){\n\t\t\t\tfor (y = 0; y < nrow; y++) { for (x = 0; x < width; x++) {\n\t\t\t\t\tSetPixelIndex(x,y+ys,(bits[y*line+(x>>3)]>>(7-x%8))&0x01);\n\t\t\t}}}*/\n\t\t}\n\t\tfree(bits);\n\t}\n  } catch (char *message) {\n\t  strncpy(info.szLastError,message,255);\n\t  if (m_tif) TIFFClose(m_tif);\n\t  return FALSE;\n  }\n\tTIFFClose(m_tif);\n\treturn TRUE;\n}",
    "bool CxImageTIF::Encode(FILE * infile)\n{\n\tTIFF *m_tif=NULL; // = (TIFF *)new(byte[512]);\n\tm_tif=TIFFOpenEx(infile, \"wb\");\n\t//\tm_tif=TIFFOpen(imageFileName,\"wb\");\n\tif (m_tif==NULL) return false;\n\n\tuint32 height=head.biHeight;\n\tuint32 width=head.biWidth;\n\tuint16 bitspersample=head.biBitCount;\n\tuint16 samplesperpixel;\n\tuint16 photometric;\n\tuint16 compression;\n\tuint16 pitch;\n\tint line;\n\tuint32 x, y;\n\n\tsamplesperpixel = ((bitspersample == 24) || (bitspersample == 32)) ? 3 : 1;\n\n\t//set the PHOTOMETRIC tag\n\tRGBQUAD *rgb = GetPalette();\n\tswitch (bitspersample) {\n\t\tcase 1:\n\t\t\tif (RGB2GRAY(rgb[0].rgbRed,rgb[0].rgbGreen,rgb[0].rgbBlue)<\n\t\t\t\tRGB2GRAY(rgb[1].rgbRed,rgb[1].rgbGreen,rgb[1].rgbBlue))\n\t\t\t\tphotometric = PHOTOMETRIC_MINISBLACK;\n\t\t\telse\n\t\t\t\tphotometric = PHOTOMETRIC_MINISWHITE;\n\t\t\tbreak;\n\t\tcase 4:\t// Check if the DIB has a color or a greyscale palette\n\t\tcase 8:\n\t\t\tphotometric = PHOTOMETRIC_MINISBLACK; //default to gray scale\n\t\t\tfor (x = 0; x < head.biClrUsed; x++) {\n\t\t\t\tif ((rgb->rgbRed != x)||(rgb->rgbRed != rgb->rgbGreen)||(rgb->rgbRed != rgb->rgbBlue)){\n\t\t\t\t\tphotometric = PHOTOMETRIC_PALETTE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\trgb++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 24:\n\t\t\tphotometric = PHOTOMETRIC_RGB;\t\t\t\n\t\t\tbreak;\n\t}\n\n\tline = CalculateLine(width, bitspersample * samplesperpixel);\n\tpitch = CalculatePitch(line);\n\n\t//prepare the palette struct\n\tRGBQUAD pal[256];\n\tif (GetPalette()){\n\t\tBYTE b;\n\t\tmemcpy(pal,GetPalette(),GetPaletteSize());\n\t\tfor(WORD a=0;a<head.biClrUsed;a++){\t//swap blue and red components\n\t\t\tb=pal[a].rgbBlue; pal[a].rgbBlue=pal[a].rgbRed; pal[a].rgbRed=b;\n\t\t}\n\t}\n\n\t// handle standard width/height/bpp stuff\n\tTIFFSetField(m_tif, TIFFTAG_IMAGEWIDTH, width);\n\tTIFFSetField(m_tif, TIFFTAG_IMAGELENGTH, height);\n\tTIFFSetField(m_tif, TIFFTAG_SAMPLESPERPIXEL, samplesperpixel);\n\tTIFFSetField(m_tif, TIFFTAG_BITSPERSAMPLE, ((bitspersample == 32) ? 24 : bitspersample) / samplesperpixel);\n\tTIFFSetField(m_tif, TIFFTAG_PHOTOMETRIC, photometric);\n\tTIFFSetField(m_tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\t// single image plane \n\tTIFFSetField(m_tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n\tTIFFSetField(m_tif, TIFFTAG_ROWSPERSTRIP, 1);\n//\tTIFFSetField(m_tif, TIFFTAG_ROWSPERSTRIP, TIFFDefaultStripSize(m_tif, rowsperstrip));\n\n\t// handle metrics\n\tTIFFSetField(m_tif, TIFFTAG_RESOLUTIONUNIT, RESUNIT_INCH);\n\tTIFFSetField(m_tif, TIFFTAG_XRESOLUTION, 72.0);\n\tTIFFSetField(m_tif, TIFFTAG_YRESOLUTION, 72.0);\n\n\t// multi-paging\n//\tif (page >= 0) {\n//\t\tchar page_number[20];\n//\t\tsprintf(page_number, \"Page %d\", page);\n//\n//\t\tTIFFSetField(m_tif, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE);\n//\t\tTIFFSetField(m_tif, TIFFTAG_PAGENUMBER, page);\n//\t\tTIFFSetField(m_tif, TIFFTAG_PAGENAME, page_number);\n//\t} else {\n\t\tTIFFSetField(m_tif, TIFFTAG_SUBFILETYPE, 0);\n//\t}\n\n\t// palettes (image colormaps are automatically scaled to 16-bits)\n\tif (photometric == PHOTOMETRIC_PALETTE) {\n\t\tuint16 *r, *g, *b;\n\t\tr = (uint16 *) _TIFFmalloc(sizeof(uint16) * 3 * 256);\n\t\tg = r + 256;\n\t\tb = g + 256;\n\n\t\tfor (int i = 255; i >= 0; i--) {\n\t\t\tb[i] = SCALE((uint16)pal[i].rgbRed);\n\t\t\tg[i] = SCALE((uint16)pal[i].rgbGreen);\n\t\t\tr[i] = SCALE((uint16)pal[i].rgbBlue);\n\t\t}\n\n\t\tTIFFSetField(m_tif, TIFFTAG_COLORMAP, r, g, b);\n\t\t_TIFFfree(r);\n\t}\n\n\t// compression\n\tswitch(bitspersample) {\n\t\tcase 1 :\n\t\t\tcompression = COMPRESSION_CCITTFAX3; //COMPRESSION_CCITTFAX4;\n\t\t\tbreak;\n\t\tcase 8 :\n\t\tcase 24 :\n\t\tcase 32 :\n\t\t\tcompression = COMPRESSION_PACKBITS;\n\t\t\tbreak;\n\t\tdefault :\n\t\t\tcompression = COMPRESSION_NONE;\n\t\t\tbreak;\n\t}\n\tTIFFSetField(m_tif, TIFFTAG_COMPRESSION, compression);\n\n\t// read the DIB lines from bottom to top\n\t// and save them in the TIF\n\t// -------------------------------------\t\n\tBYTE *bits;\n\tswitch(bitspersample) {\t\t\t\t\n\t\tcase 1 :\n\t\tcase 4 :\n\t\tcase 8 :\n\t\t{\n\t\t\tfor (y = 0; y < height; y++) {\n\t\t\t\tbits= info.pImage + (height - y - 1)*info.dwEffWidth;\n\t\t\t\tTIFFWriteScanline(m_tif,bits, y, 0);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\t\t\t\t\n\t\tcase 24:\n\t\tcase 32 :\n\t\t{\n\t\t\tBYTE *buffer = (BYTE *)malloc(info.dwEffWidth);\n\t\t\tfor (y = 0; y < height; y++) {\n\t\t\t\t// get a pointer to the scanline\n\t\t\t\tmemcpy(buffer, info.pImage + (height - y - 1)*info.dwEffWidth, info.dwEffWidth);\n\t\t\t\t// TIFFs store color data RGB instead of BGR\n\t\t\t\tBYTE *pBuf = buffer;\n\t\t\t\tfor (x = 0; x < width; x++) {\n\t\t\t\t\tBYTE tmp = pBuf[0];\n\t\t\t\t\tpBuf[0] = pBuf[2];\n\t\t\t\t\tpBuf[2] = tmp;\n\t\t\t\t\tpBuf += 3;\n\t\t\t\t}\n\t\t\t\t// write the scanline to disc\n\t\t\t\tTIFFWriteScanline(m_tif, buffer, y, 0);\n\t\t\t}\n\t\t\tfree(buffer);\n\t\t\tbreak;\n\t\t}\t\t\t\t\n\t}\n\tTIFFClose(m_tif);\n\treturn true;\n}",
    "static osg::ImageSequence* tiffLoad(std::istream& fin, const osgDB::Options* options)\n{\n    TIFFSetErrorHandler(tiffError);\n    TIFFSetWarningHandler(tiffWarn);\n    TIFF* in = TIFFClientOpen(\"inputstream\", \"r\", (thandle_t)&fin,\n                              tiffStreamReadProc, tiffStreamWriteProc,\n                              tiffStreamSeekProc, tiffStreamCloseProc,\n                              tiffStreamSizeProc, tiffStreamMapProc, tiffStreamUnmapProc);\n    if (in == NULL) { OSG_WARN << \"[ReaderWriterTiff] Unable to open stream\" << std::endl; return NULL; }\n\n    uint16_t photometric = 0;\n    if (TIFFGetField(in, TIFFTAG_PHOTOMETRIC, &photometric) == 1)\n    {\n        if (photometric != PHOTOMETRIC_RGB && photometric != PHOTOMETRIC_PALETTE &&\n            photometric != PHOTOMETRIC_MINISWHITE && photometric != PHOTOMETRIC_MINISBLACK)\n        {\n            OSG_WARN << \"[ReaderWriterTiff] Photometric type \" << photometric << \" not handled\" << std::endl;\n            TIFFClose(in); return NULL;\n        }\n    }\n    else\n    {\n        OSG_WARN << \"[ReaderWriterTiff] Unable to get photometric type\" << std::endl;\n        TIFFClose(in); return NULL;\n    }\n\n    uint16_t samplesperpixel = 0;\n    if (TIFFGetField(in, TIFFTAG_SAMPLESPERPIXEL, &samplesperpixel) == 1)\n    {\n        if (samplesperpixel != 1 && samplesperpixel != 2 &&\n            samplesperpixel != 3 && samplesperpixel != 4)\n        {\n            OSG_WARN << \"[ReaderWriterTiff] Bad samples per pixel: \" << samplesperpixel << std::endl;\n            TIFFClose(in); return NULL;\n        }\n    }\n    else\n    {\n        OSG_WARN << \"[ReaderWriterTiff] Unable to get samples per pixel\" << std::endl;\n        TIFFClose(in); return NULL;\n    }\n\n    uint16_t bitspersample = 0;\n    if (TIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bitspersample) == 1)\n    {\n        if (bitspersample != 8 && bitspersample != 16 && bitspersample != 32)\n        {\n            OSG_WARN << \"[ReaderWriterTiff] Can only handle 8, 16 and 32 bit samples\" << std::endl;\n            TIFFClose(in); return NULL;\n        }\n    }\n    else\n    {\n        OSG_WARN << \"[ReaderWriterTiff] Unable to get bits per sample\" << std::endl;\n        TIFFClose(in); return NULL;\n    }\n\n    uint32_t w = 0, h = 0, d = 1; uint16_t config = 0, dataType = 0;\n    if (TIFFGetField(in, TIFFTAG_IMAGEWIDTH, &w) != 1 || TIFFGetField(in, TIFFTAG_IMAGELENGTH, &h) != 1 ||\n        TIFFGetField(in, TIFFTAG_PLANARCONFIG, &config) != 1)\n    {\n        OSG_WARN << \"[ReaderWriterTiff] Unable to get width / height / depth parameters\" << std::endl;\n        TIFFClose(in); return NULL;\n    }\n\n    // if it has a palette, data returned is 3 byte rgb\n    int format = (photometric == PHOTOMETRIC_PALETTE) ? 3 : (samplesperpixel * bitspersample / 8);\n    int bytespersample = bitspersample / 8;\n    int bytesperpixel = bytespersample * samplesperpixel;\n    TIFFGetField(in, TIFFTAG_DATATYPE, &dataType);\n    TIFFGetField(in, TIFFTAG_IMAGEDEPTH, &d);\n\n    osg::ref_ptr<osg::ImageSequence> seq = new osg::ImageSequence;\n    if (d > 1)\n    {\n        // TODO...\n        OSG_WARN << \"[ReaderWriterTiff] Unsupported dimension\" << std::endl;\n    }\n    else\n    {\n        int dirCount = 0, imgSize = w * h * format;\n        do\n        {\n            unsigned char* inBuffer = NULL; bool hasError = false;\n            unsigned char* buffer = new unsigned char[imgSize];\n            memset(buffer, 0, imgSize); dirCount++;\n\n            unsigned char* currPtr = buffer + (h - 1) * w * format;\n            uint16_t *red = NULL, *green = NULL, *blue = NULL;\n            size_t rowSize = TIFFScanlineSize(in);\n            switch (PACK(photometric, config))\n            {\n            case PACK(PHOTOMETRIC_MINISWHITE, PLANARCONFIG_CONTIG):\n            case PACK(PHOTOMETRIC_MINISBLACK, PLANARCONFIG_CONTIG):\n            case PACK(PHOTOMETRIC_MINISWHITE, PLANARCONFIG_SEPARATE):\n            case PACK(PHOTOMETRIC_MINISBLACK, PLANARCONFIG_SEPARATE):\n                inBuffer = new unsigned char[rowSize];\n                for (uint32_t row = 0; row < h; row++)\n                {\n                    if (TIFFReadScanline(in, inBuffer, row, 0) < 0) { hasError = true; break; }\n                    invertRow(currPtr, inBuffer, samplesperpixel * w,\n                              photometric == PHOTOMETRIC_MINISWHITE, bitspersample);\n                    currPtr -= format * w;\n                }\n                break;\n\n            case PACK(PHOTOMETRIC_PALETTE, PLANARCONFIG_CONTIG):\n            case PACK(PHOTOMETRIC_PALETTE, PLANARCONFIG_SEPARATE):\n                if (TIFFGetField(in, TIFFTAG_COLORMAP, &red, &green, &blue) != 1)\n                { hasError = true; break; }\n                else if (!hasError && bitspersample != 32 && checkColormap(1<<bitspersample, red, green, blue) == 16)\n                {\n                    for (int i = (1 << bitspersample) - 1; i >= 0; --i)\n                    { red[i] = CVT(red[i]); green[i] = CVT(green[i]); blue[i] = CVT(blue[i]); }\n                }\n\n                inBuffer = new unsigned char[rowSize];\n                for (uint32_t row = 0; row < h; row++)\n                {\n                    if (TIFFReadScanline(in, inBuffer, row, 0) < 0) { hasError = true; break; }\n                    remapRow(currPtr, inBuffer, w, red, green, blue); currPtr -= format * w;\n                }\n                break;\n\n            case PACK(PHOTOMETRIC_RGB, PLANARCONFIG_CONTIG):\n                inBuffer = new unsigned char[rowSize];\n                for (uint32_t row = 0; row < h; row++)\n                {\n                    if (TIFFReadScanline(in, inBuffer, row, 0) < 0) { hasError = true; break; }\n                    memcpy(currPtr, inBuffer, format * w); currPtr -= format * w;\n                }\n                break;\n\n            case PACK(PHOTOMETRIC_RGB, PLANARCONFIG_SEPARATE):\n                inBuffer = new unsigned char[format * rowSize];\n                for (uint32_t row = 0; !hasError && row < h; row++)\n                {\n                    for (int s = 0; s < format; s++)\n                    {\n                        if (TIFFReadScanline(in, (tdata_t)(inBuffer + s * rowSize), (uint32_t)row, (tsample_t)s) < 0)\n                        { hasError = true; break; }\n                    }\n\n                    if (!hasError)\n                    {\n                        unsigned char *inBuffer2 = inBuffer + rowSize, *inBuffer3 = inBuffer + 2 * rowSize,\n                                      *inBuffer4 = inBuffer + 3 * rowSize;\n                        if (format == 4) interleaveRow(currPtr, inBuffer, inBuffer2, inBuffer3, inBuffer4, w, format, bitspersample);\n                        else if (format == 3) interleaveRow(currPtr, inBuffer, inBuffer2, inBuffer3, w, format, bitspersample);\n                        currPtr -= format * w;\n                    }\n                }\n                break;\n            default:\n                OSG_WARN << \"[ReaderWriterTiff] Unsupported Packing: \" << photometric << \", \" << config << std::endl;\n                hasError = true; break;\n            }\n\n            if (inBuffer) delete[] inBuffer;\n            if (hasError)\n            {\n                OSG_WARN << \"[ReaderWriterTiff] Failed to read with packing: \" << photometric << \", \" << config << std::endl;\n                if (buffer) delete[] buffer; continue;\n            }\n\n            int numComponents = (photometric == PHOTOMETRIC_PALETTE) ? format : samplesperpixel;\n            unsigned int pixelFormat =\n                (numComponents) == 1 ? GL_LUMINANCE :\n                (numComponents) == 2 ? GL_LUMINANCE_ALPHA :\n                (numComponents) == 3 ? GL_RGB :\n                (numComponents) == 4 ? GL_RGBA : (GLenum)-1;\n            unsigned int dataType =\n                (bitspersample == 8) ? GL_UNSIGNED_BYTE :\n                (bitspersample == 16) ? GL_UNSIGNED_SHORT :\n                (bitspersample == 32) ? GL_FLOAT : (GLenum)-1;\n            unsigned int internalFormat = computeInternalFormat(pixelFormat, dataType);\n            if (internalFormat <= 0)\n            {\n                OSG_WARN << \"[ReaderWriterTiff] Unsupported image format\" << std::endl;\n                continue;\n            }\n\n            osg::Image* image = new osg::Image;\n            image->setImage(w, h, d, internalFormat, pixelFormat, dataType,\n                            buffer, osg::Image::USE_NEW_DELETE);\n            seq->addImage(image);\n        } while (TIFFReadDirectory(in));\n    }\n    TIFFClose(in);\n    return seq.release();\n}",
    "int WriteTIFF(unsigned short * buffer, int cols, int rows, char * filename)\n{\n\tTIFF *image;\n\tunsigned char *out;\n\tout = new unsigned char[cols*rows];\n\n\tAdjustImage(buffer, cols, rows, out);\n\n\t// Open the TIFF file\n\tif((image = TIFFOpen(filename, \"w\")) == NULL)\n\t{\n\t\tprintf(\"Could not open output.tif for writing\\n\");\n\t\texit(42);\n\t}\n\t\n\t// We need to set some values for basic tags before we can add any data\n\tTIFFSetField(image, TIFFTAG_IMAGEWIDTH, cols);\n\tTIFFSetField(image, TIFFTAG_IMAGELENGTH, rows);\n\tTIFFSetField(image, TIFFTAG_BITSPERSAMPLE, 8);\n\tTIFFSetField(image, TIFFTAG_SAMPLESPERPIXEL, 1);\n\tTIFFSetField(image, TIFFTAG_ROWSPERSTRIP, 1);\n\t\n\tTIFFSetField(image, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n\tTIFFSetField(image, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n\tTIFFSetField(image, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);\n\tTIFFSetField(image, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\t\n\tTIFFSetField(image, TIFFTAG_XRESOLUTION, 150.0);\n\tTIFFSetField(image, TIFFTAG_YRESOLUTION, 150.0);\n\tTIFFSetField(image, TIFFTAG_RESOLUTIONUNIT, RESUNIT_INCH);\n\t\n\t// Write the information to the file\n\tfor (int y = 0; y < rows; y++)\n\t{\n\t\tTIFFWriteScanline(image, &out[cols*y], y);\n\t}\n\t\n\t// Close the file\n\tTIFFClose(image);\n\tdelete[] (out);\n\treturn 0;\n}",
    "int WriteTIFF(unsigned short * buffer, int cols, int rows, char * filename)\n{\n#ifdef HAVE_TIFFIO_H\n\tTIFF *image;\n\tunsigned char out[cols*rows];\n\n\tAdjustImage(buffer, cols, rows, out);\n\n\t// Open the TIFF file\n\tif((image = TIFFOpen(filename, \"w\")) == NULL)\n\t{\n\t\tprintf(\"Could not open %s for writing\\n\", filename);\n\t\texit(1);\n\t}\n\t\n\t// We need to set some values for basic tags before we can add any data\n\tTIFFSetField(image, TIFFTAG_IMAGEWIDTH, cols);\n\tTIFFSetField(image, TIFFTAG_IMAGELENGTH, rows);\n\tTIFFSetField(image, TIFFTAG_BITSPERSAMPLE, 8);\n\tTIFFSetField(image, TIFFTAG_SAMPLESPERPIXEL, 1);\n\tTIFFSetField(image, TIFFTAG_ROWSPERSTRIP, 1);\n\t\n\tTIFFSetField(image, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n\tTIFFSetField(image, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n\tTIFFSetField(image, TIFFTAG_FILLORDER, FILLORDER_LSB2MSB);\n\tTIFFSetField(image, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\t\n\tTIFFSetField(image, TIFFTAG_XRESOLUTION, 150.0);\n\tTIFFSetField(image, TIFFTAG_YRESOLUTION, 150.0);\n\tTIFFSetField(image, TIFFTAG_RESOLUTIONUNIT, RESUNIT_INCH);\n\t\n\t// Write the information to the file\n\tfor (int y = 0; y < rows; y++)\n\t{\n\t\tTIFFWriteScanline(image, &out[cols*y], y);\n\t}\n\t\n\t// Close the file\n\tTIFFClose(image);\n#else /* HAVE_TIFFIO_H */\n\tstd::cerr << \"TIFF not supported\" << std::endl;\n\treturn -1;\n#endif /* HAVE_TIFFIO_H */\n}",
    "uint8_t isImageJIm(const char* fileName){\n    TIFF* tif = TIFFOpen(fileName, \"r\");\n    if(!tif) return 0;\n    char* tiffDesc = NULL;\n    if(TIFFGetField(tif, TIFFTAG_IMAGEDESCRIPTION, &tiffDesc)){\n        if(strstr(tiffDesc, \"ImageJ\")){\n            uint64_t* size = getImageSize(fileName);\n            if(size[2] > 1){\n                if(TIFFSetDirectory(tif,1)){\n                    free(size);\n                    return 0;\n                }\n            }\n            free(size);\n            uint16_t compressed = 1;\n            TIFFGetField(tif, TIFFTAG_COMPRESSION, &compressed);\n            TIFFClose(tif);\n            if(compressed != 1) return 0;\n            else return 1;\n        }\n    }\n    TIFFClose(tif);\n    return 0;\n}",
    "uint64_t imageJImGetZ(const char* fileName){\n    TIFF* tif = TIFFOpen(fileName, \"r\");\n    if(!tif) return 0;\n    char* tiffDesc = NULL;\n    if(TIFFGetField(tif, TIFFTAG_IMAGEDESCRIPTION, &tiffDesc)){\n        if(strstr(tiffDesc, \"ImageJ\")){\n            char* nZ = strstr(tiffDesc,\"images=\");\n            if(nZ){\n                TIFFClose(tif);\n                nZ+=7;\n                char* temp;\n                return strtol(nZ,&temp,10);\n            }\n        }\n    }\n    TIFFClose(tif);\n    return 0;\n}",
    "uint32_t getImageSizeZ(const char* fileName){\n    TIFFSetWarningHandler(DummyHandler);\n    TIFF* tif = TIFFOpen(fileName, \"r\");\n    if(!tif) printf(\"File \\\"%s\\\" cannot be opened\",fileName);\n\n    uint32_t s = 0, m = 0, t = 1, z = 1;\n    while(TIFFSetDirectory(tif,t)){\n        s = t;\n        t *= 8;\n        if(s > t){\n            t = 4294967295;\n            printf(\"Number of slices > 1073741824\\n\");\n            break;\n        }\n    }\n    while(s != t){\n        m = (s+t+1)/2;\n        if(TIFFSetDirectory(tif,m)){\n            s = m;\n        }\n        else{\n            if(m > 0) t = m-1;\n            else t = m;\n        }\n    }\n    z = s+1;\n    TIFFClose(tif);\n    return z;\n}",
    "uint64_t* getImageSize(const char* fileName){\n    TIFFSetWarningHandler(DummyHandler);\n    TIFF* tif = TIFFOpen(fileName, \"r\");\n    if(!tif) printf(\"File \\\"%s\\\" cannot be opened\",fileName);\n\n    uint64_t x = 1,y = 1,z = 1;\n    TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &x);\n    TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &y);\n    z = getImageSizeZ(fileName);\n    TIFFClose(tif);\n\n    uint64_t* dims = (uint64_t*)malloc(3*sizeof(uint64_t));\n    dims[0] = y;\n    dims[1] = x;\n    dims[2] = z;\n    return dims;\n}",
    "uint64_t getDataType(const char* fileName){\n    TIFFSetWarningHandler(DummyHandler);\n    TIFF* tif = TIFFOpen(fileName, \"r\");\n    if(!tif) printf(\"File \\\"%s\\\" cannot be opened\",fileName);\n\n    uint64_t bits = 1;\n    TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bits);\n    TIFFClose(tif);\n\n    return bits;\n}",
    "uint8_t readTiffParallelBak(uint64_t x, uint64_t y, uint64_t z, const char* fileName, void* tiff, uint64_t bits, uint64_t startSlice, uint8_t flipXY){\n    int32_t numWorkers = omp_get_max_threads();\n    int32_t batchSize = (z-1)/numWorkers+1;\n    uint64_t bytes = bits/8;\n\n    int32_t w;\n\tuint8_t err = 0;\n\tchar errString[10000];\n    #pragma omp parallel for\n    for(w = 0; w < numWorkers; w++){\n\t\tif(err) continue;\n        TIFF* tif = TIFFOpen(fileName, \"r\");\n        if(!tif){\n\t\t\tsprintf(errString,\"Thread %d: File \\\"%s\\\" cannot be opened\\n\",w,fileName);\n\t\t\terr = 1;\n\t\t}\n        void* buffer = malloc(x*bytes);\n        for(int64_t dir = startSlice+(w*batchSize); dir < startSlice+((w+1)*batchSize); dir++){\n            if(dir>=z+startSlice || err) break;\n\n            int counter = 0;\n            while(!TIFFSetDirectory(tif, (uint64_t)dir) && counter<3){\n                printf(\"Thread %d: File \\\"%s\\\" Directory \\\"%d\\\" failed to open. Try %d\\n\",w,fileName,dir,counter+1);\n                counter++;\n            }\n\n            for (int64_t i = 0; i < y; i++)\n            {\n                TIFFReadScanline(tif, buffer, i, 0);\n                if(!flipXY){\n                    // Probably need to fix this\n                    memcpy(tiff+(((i*y)+((dir-startSlice)*(x*y)))*bytes),buffer,x*bytes);\n                    continue;\n                }\n                //loading the data into a buffer\n                switch(bits){\n                    case 8:\n                        // Map Values to flip x and y for MATLAB\n                        for(int64_t j = 0; j < x; j++){\n                            ((uint8_t*)tiff)[((j*y)+i)+((dir-startSlice)*(x*y))] = ((uint8_t*)buffer)[j];\n                        }\n                            break;\n                    case 16:\n                        // Map Values to flip x and y for MATLAB\n                        for(int64_t j = 0; j < x; j++){\n                            ((uint16_t*)tiff)[((j*y)+i)+((dir-startSlice)*(x*y))] = ((uint16_t*)buffer)[j];\n                        }\n                            break;\n                    case 32:\n                        // Map Values to flip x and y for MATLAB\n                        for(int64_t j = 0; j < x; j++){\n                            ((float*)tiff)[((j*y)+i)+((dir-startSlice)*(x*y))] = ((float*)buffer)[j];\n                        }\n                            break;\n                    case 64:\n                        // Map Values to flip x and y for MATLAB\n                        for(int64_t j = 0; j < x; j++){\n                            ((double*)tiff)[((j*y)+i)+((dir-startSlice)*(x*y))] = ((double*)buffer)[j];\n                        }\n                            break;\n                }\n            }\n        }\n        free(buffer);\n        TIFFClose(tif);\n    }\n\tif(err){\n\t\tprintf(errString);\n\t}\n\treturn err;\n}",
    "uint8_t readTiffParallel(uint64_t x, uint64_t y, uint64_t z, const char* fileName, void* tiff, uint64_t bits, uint64_t startSlice, uint64_t stripSize, uint8_t flipXY){\n    int32_t numWorkers = omp_get_max_threads();\n    int32_t batchSize = (z-1)/numWorkers+1;\n    uint64_t bytes = bits/8;\n\n    int32_t w;\n    uint8_t errBak = 0;\n    uint8_t err = 0;\n    char errString[10000];\n    #pragma omp parallel for\n    for(w = 0; w < numWorkers; w++){\n\n        uint8_t outCounter = 0;\n        TIFF* tif = TIFFOpen(fileName, \"r\");\n        while(!tif){\n            tif = TIFFOpen(fileName, \"r\");\n            if(outCounter == 3){\n                #pragma omp critical\n                {\n                    err = 1;\n                    sprintf(errString,\"Thread %d: File \\\"%s\\\" cannot be opened\\n\",w,fileName);\n                }\n                continue;\n            }\n            outCounter++;\n        }\n\n        void* buffer = malloc(x*stripSize*bytes);\n        for(int64_t dir = startSlice+(w*batchSize); dir < startSlice+((w+1)*batchSize); dir++){\n            if(dir>=z+startSlice || err) break;\n\n            uint8_t counter = 0;\n            while(!TIFFSetDirectory(tif, (uint64_t)dir) && counter<3){\n                counter++;\n                if(counter == 3){\n                    #pragma omp critical\n                    {\n                        err = 1;\n                        sprintf(errString,\"Thread %d: File \\\"%s\\\" cannot be opened\\n\",w,fileName);\n                    }\n                }\n            }\n            if(err) break;\n            for (int64_t i = 0; i*stripSize < y; i++)\n            {\n\n                //loading the data into a buffer\n                int64_t cBytes = TIFFReadEncodedStrip(tif, i, buffer, stripSize*x*bytes);\n                if(cBytes < 0){\n                    #pragma omp critical\n                    {\n                        errBak = 1;\n                        err = 1;\n                        sprintf(errString,\"Thread %d: Strip %ld cannot be read\\n\",w,i);\n                    }\n                    break;\n                }\n                if(!flipXY){\n                    memcpy(tiff+(((i*stripSize*x)+((dir-startSlice)*(x*y)))*bytes),buffer,cBytes);\n                    continue;\n                }\n                switch(bits){\n                    case 8:\n                        // Map Values to flip x and y for MATLAB\n                        for(int64_t k = 0; k < stripSize; k++){\n                            if((k+(i*stripSize)) >= y) break;\n                            for(int64_t j = 0; j < x; j++){\n                                ((uint8_t*)tiff)[((j*y)+(k+(i*stripSize)))+((dir-startSlice)*(x*y))] = ((uint8_t*)buffer)[j+(k*x)];\n                            }\n                        }\n                                break;\n                    case 16:\n                        // Map Values to flip x and y for MATLAB\n                        for(int64_t k = 0; k < stripSize; k++){\n                            if((k+(i*stripSize)) >= y) break;\n                            for(int64_t j = 0; j < x; j++){\n                                ((uint16_t*)tiff)[((j*y)+(k+(i*stripSize)))+((dir-startSlice)*(x*y))] = ((uint16_t*)buffer)[j+(k*x)];\n                            }\n                        }\n                                break;\n                    case 32:\n                        // Map Values to flip x and y for MATLAB\n                        for(int64_t k = 0; k < stripSize; k++){\n                            if((k+(i*stripSize)) >= y) break;\n                            for(int64_t j = 0; j < x; j++){\n                                ((float*)tiff)[((j*y)+(k+(i*stripSize)))+((dir-startSlice)*(x*y))] = ((float*)buffer)[j+(k*x)];\n                            }\n                        }\n                                break;\n                    case 64:\n                        // Map Values to flip x and y for MATLAB\n                        for(int64_t k = 0; k < stripSize; k++){\n                            if((k+(i*stripSize)) >= y) break;\n                            for(int64_t j = 0; j < x; j++){\n                                ((double*)tiff)[((j*y)+(k+(i*stripSize)))+((dir-startSlice)*(x*y))] = ((double*)buffer)[j+(k*x)];\n                            }\n                        }\n                                break;\n                }\n            }\n        }\n        free(buffer);\n        TIFFClose(tif);\n    }\n    if(err){\n        if(errBak) return readTiffParallelBak(x, y, z, fileName, tiff, bits, startSlice, flipXY);\n        else {\n\t\t\tprintf(errString);\n\t\t}\n    }\n\treturn err;\n}",
    "uint8_t readTiffParallel2DBak(uint64_t x, uint64_t y, uint64_t z, const char* fileName, void* tiff, uint64_t bits, uint64_t startSlice, uint8_t flipXY){\n    int32_t numWorkers = omp_get_max_threads();\n    int32_t batchSize = (y-1)/numWorkers+1;\n    uint64_t bytes = bits/8;\n\n    int32_t w;\n\tuint8_t err = 0;\n\tchar errString[10000];\n    #pragma omp parallel for\n    for(w = 0; w < numWorkers; w++){\n\t\tif(err) continue;\n        TIFF* tif = TIFFOpen(fileName, \"r\");\n        if(!tif) {\n\t\t\tsprintf(errString,\"tiff:threadError\",\"Thread %d: File \\\"%s\\\" cannot be opened\\n\",w,fileName);\n\t\t\terr = 1;\n\t\t}\n        void* buffer = malloc(x*bytes);\n        for(int64_t dir = startSlice+(w*batchSize); dir < startSlice+((w+1)*batchSize); dir++){\n            if(dir>=z+startSlice || err) break;\n\n            int counter = 0;\n            while(!TIFFSetDirectory(tif, startSlice) && counter<3){\n                printf(\"Thread %d: File \\\"%s\\\" Directory \\\"%d\\\" failed to open. Try %d\\n\",w,fileName,dir,counter+1);\n                counter++;\n            }\n\n            for (int64_t i = (w*batchSize); i < ((w+1)*batchSize); i++)\n            {\n                if(i >= y) break;\n                TIFFReadScanline(tif, buffer, i, 0);\n                if(!flipXY){\n                    memcpy(tiff+((i*x)*bytes),buffer,x*bytes);\n                    continue;\n                }\n                //loading the data into a buffer\n                switch(bits){\n                    case 8:\n                        // Map Values to flip x and y for MATLAB\n                        for(int64_t j = 0; j < x; j++){\n                            ((uint8_t*)tiff)[((j*y)+i)+((dir-startSlice)*(x*y))] = ((uint8_t*)buffer)[j];\n                        }\n                            break;\n                    case 16:\n                        // Map Values to flip x and y for MATLAB\n                        for(int64_t j = 0; j < x; j++){\n                            ((uint16_t*)tiff)[((j*y)+i)+((dir-startSlice)*(x*y))] = ((uint16_t*)buffer)[j];\n                        }\n                            break;\n                    case 32:\n                        // Map Values to flip x and y for MATLAB\n                        for(int64_t j = 0; j < x; j++){\n                            ((float*)tiff)[((j*y)+i)+((dir-startSlice)*(x*y))] = ((float*)buffer)[j];\n                        }\n                            break;\n                    case 64:\n                        // Map Values to flip x and y for MATLAB\n                        for(int64_t j = 0; j < x; j++){\n                            ((double*)tiff)[((j*y)+i)+((dir-startSlice)*(x*y))] = ((double*)buffer)[j];\n                        }\n                            break;\n                }\n            }\n        }\n        free(buffer);\n        TIFFClose(tif);\n    }\n\tif(err){\n\t\tprintf(errString);\n\t}\n\treturn err;\n}",
    "uint8_t readTiffParallel2D(uint64_t x, uint64_t y, uint64_t z, const char* fileName, void* tiff, uint64_t bits, uint64_t startSlice, uint64_t stripSize, uint8_t flipXY){\n    int32_t numWorkers = omp_get_max_threads();\n    uint64_t stripsPerDir = (uint64_t)ceil((double)y/(double)stripSize);\n    int32_t batchSize = (stripsPerDir-1)/numWorkers+1;\n    uint64_t bytes = bits/8;\n\n    int32_t w;\n    uint8_t err = 0;\n    uint8_t errBak = 0;\n    char errString[10000];\n    uint16_t compressed = 1;\n    TIFF* tif = TIFFOpen(fileName, \"r\");\n    TIFFGetField(tif, TIFFTAG_COMPRESSION, &compressed);\n\n    // The other method won't work on specific slices of 3D images for now\n    // so start slice must also be 0\n    if(numWorkers > 1 || compressed > 1){\n        #pragma omp parallel for\n        for(w = 0; w < numWorkers; w++){\n    \n            uint8_t outCounter = 0;\n            TIFF* tif = TIFFOpen(fileName, \"r\");\n            while(!tif){\n                tif = TIFFOpen(fileName, \"r\");\n                if(outCounter == 3){\n                    #pragma omp critical\n                    {\n                        err = 1;\n                        sprintf(errString,\"Thread %d: File \\\"%s\\\" cannot be opened\\n\",w,fileName);\n                    }\n                    continue;\n                }\n                outCounter++;\n            }\n    \n            void* buffer = malloc(x*stripSize*bytes);\n    \n    \n            uint8_t counter = 0;\n            while(!TIFFSetDirectory(tif, startSlice) && counter<3){\n                printf(\"Thread %d: File \\\"%s\\\" Directory \\\"%d\\\" failed to open. Try %d\\n\",w,fileName,0,counter+1);\n                counter++;\n                if(counter == 3){\n                    #pragma omp critical\n                    {\n                        err = 1;\n                        sprintf(errString,\"Thread %d: File \\\"%s\\\" cannot be opened\\n\",w,fileName);\n                    }\n                }\n            }\n            for (int64_t i = (w*batchSize); i < (w+1)*batchSize; i++)\n            {\n                if(i*stripSize >= y || err) break;\n                //loading the data into a buffer\n                int64_t cBytes = TIFFReadEncodedStrip(tif, i, buffer, stripSize*x*bytes);\n                if(cBytes < 0){\n                    #pragma omp critical\n                    {\n                        //errBak = 1;\n                        err = 1;\n                        sprintf(errString,\"Thread %d: Strip %ld cannot be read\\n\",w,i);\n                    }\n                    break;\n                }\n                if(!flipXY){\n                    memcpy(tiff+((i*stripSize*x)*bytes),buffer,cBytes);\n                    continue;\n                }\n                switch(bits){\n                    case 8:\n                        // Map Values to flip x and y for MATLAB\n                        for(int64_t k = 0; k < stripSize; k++){\n                            if((k+(i*stripSize)) >= y) break;\n                            for(int64_t j = 0; j < x; j++){\n                                ((uint8_t*)tiff)[((j*y)+(k+(i*stripSize)))] = ((uint8_t*)buffer)[j+(k*x)];\n                            }\n                        }\n                                break;\n                    case 16:\n                        // Map Values to flip x and y for MATLAB\n                        for(int64_t k = 0; k < stripSize; k++){\n                            if((k+(i*stripSize)) >= y) break;\n                            for(int64_t j = 0; j < x; j++){\n                                ((uint16_t*)tiff)[((j*y)+(k+(i*stripSize)))] = ((uint16_t*)buffer)[j+(k*x)];\n                            }\n                        }\n                                break;\n                    case 32:\n                        // Map Values to flip x and y for MATLAB\n                        for(int64_t k = 0; k < stripSize; k++){\n                            if((k+(i*stripSize)) >= y) break;\n                            for(int64_t j = 0; j < x; j++){\n                                ((float*)tiff)[((j*y)+(k+(i*stripSize)))] = ((float*)buffer)[j+(k*x)];\n                            }\n                        }\n                                break;\n                    case 64:\n                        // Map Values to flip x and y for MATLAB\n                        for(int64_t k = 0; k < stripSize; k++){\n                            if((k+(i*stripSize)) >= y) break;\n                            for(int64_t j = 0; j < x; j++){\n                                ((double*)tiff)[((j*y)+(k+(i*stripSize)))] = ((double*)buffer)[j+(k*x)];\n                            }\n                        }\n                                break;\n                }\n            }\n            free(buffer);\n            TIFFClose(tif);\n        }\n    }\n    else{\n        void* tiffC = NULL;\n        FILE *fp = fopen(fileName, \"rb\");\n        if(!fp){ \n\t\t\tprintf(\"File \\\"%s\\\" cannot be opened from Disk\\n\",fileName);\n\t\t\terr = 1;\n\t\t\treturn err;\n\t\t}\n\n        if(!tif){ \n\t\t\tprintf(\"File \\\"%s\\\" cannot be opened\\n\",fileName);\n\t\t\terr = 1;\n\t\t\treturn err;\n\t\t}\n        \n\t\tuint64_t offset = 0;\n        uint64_t* offsets = NULL;\n        TIFFGetField(tif, TIFFTAG_STRIPOFFSETS, &offsets);\n        if(!offsets){ \n\t\t\tprintf(\"Could not get offsets from the tiff file\\n\");\n       \t\terr = 1;\n\t\t\treturn err;\n\t\t}\n\t\toffset = offsets[0];\n        uint64_t zSize = x*y*bytes;\n    \n        fseek(fp, offset, SEEK_SET);\n\n\n        TIFFClose(tif);\n        \n        if(!flipXY){\n            fread(tiff, 1, zSize, fp);\n        }\n        else{\n            uint64_t size = x*y*z*(bits/8);\n            tiffC = malloc(size);\n            fread(tiffC, 1, zSize, fp);\n        }\n        fclose(fp);\n        if(flipXY){   \n            for(uint64_t k = 0; k < z; k++){\n                for(uint64_t j = 0; j < x; j++){\n                    for(uint64_t i = 0; i < y; i++){\n                        switch(bits){\n                            case 8:\n                                ((uint8_t*)tiff)[i+(j*y)+(k*x*y)] = ((uint8_t*)tiffC)[j+(i*x)+(k*x*y)];\n                                break;\n                            case 16:\n                                ((uint16_t*)tiff)[i+(j*y)+(k*x*y)] = ((uint16_t*)tiffC)[j+(i*x)+(k*x*y)];\n                                break;\n                            case 32:\n                                ((float*)tiff)[i+(j*y)+(k*x*y)] = ((float*)tiffC)[j+(i*x)+(k*x*y)];\n                                break;\n                            case 64:\n                                ((double*)tiff)[i+(j*y)+(k*x*y)] = ((double*)tiffC)[j+(i*x)+(k*x*y)];\n                                break;\n                        }\n                    }\n                }\n            }\n            free(tiffC);\n        }\n    }\n\n    if(err) {\n        if(errBak) return readTiffParallel2DBak(x, y, z, fileName, tiff, bits, startSlice, flipXY);\n        else printf(errString);\n    }\n\treturn err;\n}",
    "uint8_t readTiffParallelImageJ(uint64_t x, uint64_t y, uint64_t z, const char* fileName, void* tiff, uint64_t bits, uint64_t startSlice, uint64_t stripSize, uint8_t flipXY){\n    uint8_t err = 0;\n    FILE *fp = fopen(fileName, \"rb\");\n    if(!fp){ \n\t\tprintf(\"File \\\"%s\\\" cannot be opened from Disk\\n\",fileName);\n\t\terr = 1;\n\t\treturn err;\n\t}\n    TIFF* tif = TIFFOpen(fileName, \"r\");\n    if(!tif){ \n\t\tprintf(\"File \\\"%s\\\" cannot be opened\\n\",fileName);\n\t\terr = 1;\n\t\treturn err;\n\t}\n    uint64_t offset = 0;\n    uint64_t* offsets = NULL;\n    TIFFGetField(tif, TIFFTAG_STRIPOFFSETS, &offsets);\n    if(offsets) offset = offsets[0];\n\n    TIFFClose(tif);\n\n    fseek(fp, offset, SEEK_SET);\n\n    uint64_t bytes = bits/8;\n    //#pragma omp parallel for\n    /*\n    for(uint64_t i = 0; i < z; i++){\n    uint64_t cOffset = x*y*bytes*i;\n    //pread(fd,tiff+cOffset,x*y*bytes,offset+cOffset);\n    read(fd,tiff+cOffset,x*y*bytes);\n    }*/\n    uint64_t chunk = 0;\n    uint64_t tBytes = x*y*z*bytes;\n    uint64_t bytesRead;\n    uint64_t rBytes = tBytes;\n\n    // Can probably read more than INT_MAX now that we use fread\n    if(tBytes < INT_MAX) bytesRead = fread(tiff,1,tBytes,fp);\n    else{\n        while(chunk < tBytes){\n            rBytes = tBytes-chunk;\n            if(rBytes > INT_MAX) bytesRead = fread(tiff+chunk,1,INT_MAX,fp);\n            else bytesRead = fread(tiff+chunk,1,rBytes,fp);\n            chunk += bytesRead;\n        }\n    }\n    fclose(fp);\n    // Swap endianess for types greater than 8 bits\n    // TODO: May need to change later because we may not always need to swap\n    if(bits > 8){\n        #pragma omp parallel for\n        for(uint64_t i = 0; i < x*y*z; i++){\n            switch(bits){\n                case 16:\n                    //((uint16_t*)tiff)[i] = ((((uint16_t*)tiff)[i] & 0xff) >> 8) | (((uint16_t*)tiff)[i] << 8);\n                    //((uint16_t*)tiff)[i] = bswap_16(((uint16_t*)tiff)[i]);\n                    ((uint16_t*)tiff)[i] = ((((uint16_t*)tiff)[i] << 8) & 0xff00) | ((((uint16_t*)tiff)[i] >> 8) & 0x00ff);\n                    break;\n                case 32:\n                    //((num & 0xff000000) >> 24) | ((num & 0x00ff0000) >> 8) | ((num & 0x0000ff00) << 8) | (num << 24)\n                    //((float*)tiff)[i] = bswap_32(((float*)tiff)[i]);\n                    ((uint32_t*)tiff)[i] = ((((uint32_t*)tiff)[i] << 24) & 0xff000000 ) |\n                        ((((uint32_t*)tiff)[i] <<  8) & 0x00ff0000 ) |\n                        ((((uint32_t*)tiff)[i] >>  8) & 0x0000ff00 ) |\n                        ((((uint32_t*)tiff)[i] >> 24) & 0x000000ff );\n                    break;\n                case 64:\n                    //((double*)tiff)[i] = bswap_64(((double*)tiff)[i]);\n                    ((uint64_t*)tiff)[i] = ( (((uint64_t*)tiff)[i] << 56) & 0xff00000000000000UL ) |\n                        ( (((uint64_t*)tiff)[i] << 40) & 0x00ff000000000000UL ) |\n                        ( (((uint64_t*)tiff)[i] << 24) & 0x0000ff0000000000UL ) |\n                        ( (((uint64_t*)tiff)[i] <<  8) & 0x000000ff00000000UL ) |\n                        ( (((uint64_t*)tiff)[i] >>  8) & 0x00000000ff000000UL ) |\n                        ( (((uint64_t*)tiff)[i] >> 24) & 0x0000000000ff0000UL ) |\n                        ( (((uint64_t*)tiff)[i] >> 40) & 0x000000000000ff00UL ) |\n                        ( (((uint64_t*)tiff)[i] >> 56) & 0x00000000000000ffUL );\n                    break;\n            }\n\n        }\n    }\n    // Find a way to do this in-place without making a copy\n    if(flipXY){\n        uint64_t size = x*y*z*(bits/8);\n        void* tiffC = malloc(size);\n        memcpy(tiffC,tiff,size);\n        #pragma omp parallel for\n        for(uint64_t k = 0; k < z; k++){\n            for(uint64_t j = 0; j < x; j++){\n                for(uint64_t i = 0; i < y; i++){\n                    switch(bits){\n                        case 8:\n                            ((uint8_t*)tiff)[i+(j*y)+(k*x*y)] = ((uint8_t*)tiffC)[j+(i*x)+(k*x*y)];\n                            break;\n                        case 16:\n                            ((uint16_t*)tiff)[i+(j*y)+(k*x*y)] = ((uint16_t*)tiffC)[j+(i*x)+(k*x*y)];\n                            break;\n                        case 32:\n                            ((float*)tiff)[i+(j*y)+(k*x*y)] = ((float*)tiffC)[j+(i*x)+(k*x*y)];\n                            break;\n                        case 64:\n                            ((double*)tiff)[i+(j*y)+(k*x*y)] = ((double*)tiffC)[j+(i*x)+(k*x*y)];\n                            break;\n                    }\n                }\n            }\n        }\n        free(tiffC);\n    }\n\treturn err;\n}",
    "void* readTiffParallelWrapperHelper(const char* fileName, void* tiff, uint8_t flipXY)\n{\n\tTIFFSetWarningHandler(DummyHandler);\n\tTIFF* tif = TIFFOpen(fileName, \"r\");\n\tif(!tif) return NULL;\n\n\tuint64_t x = 1,y = 1,z = 1,bits = 1, startSlice = 0;\n\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &x);\n\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &y);\n    z = getImageSizeZ(fileName);\n\n\tTIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bits);\n\tuint64_t stripSize = 1;\n\tTIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &stripSize);\n\tTIFFClose(tif);\n\n\t// Check if image is an imagej image with imagej metadata\n\t// Get the correct\n\tuint8_t imageJIm = 0;\n\tif(isImageJIm(fileName)){\n\t\timageJIm = 1;\n\t\tuint64_t tempZ = imageJImGetZ(fileName);\n\t\tif(tempZ) z = tempZ;\n\t}\n\n\n\tif(imageJIm){\n\t\tif(bits == 8){\n\t\t\tif(!tiff) tiff = (uint8_t*)malloc(x*y*z*sizeof(uint8_t));\n\t\t\treadTiffParallelImageJ(x,y,z,fileName, (void*)tiff, bits, startSlice, stripSize,flipXY);\n\t\t\treturn (void*)tiff;\n\t\t}\n\t\telse if(bits == 16){\n\t\t\tif(!tiff) tiff = (uint16_t*)malloc(x*y*z*sizeof(uint16_t));\n\t\t\treadTiffParallelImageJ(x,y,z,fileName, (void*)tiff, bits, startSlice, stripSize, flipXY);\n\t\t\treturn (void*)tiff;\n\t\t}\n\t\telse if(bits == 32){\n\t\t\tif(!tiff) tiff = (float*)malloc(x*y*z*sizeof(float));\n\t\t\treadTiffParallelImageJ(x,y,z,fileName, (void*)tiff, bits, startSlice, stripSize, flipXY);\n\t\t\treturn (void*)tiff;\n\t\t}\n\t\telse if(bits == 64){\n\t\t\tif(!tiff) tiff = (double*)malloc(x*y*z*sizeof(double));\n\t\t\treadTiffParallelImageJ(x,y,z,fileName, (void*)tiff, bits, startSlice, stripSize, flipXY);\n\t\t\treturn (void*)tiff;\n\t\t}\n\t\telse{\n\t\t\treturn NULL;\n\t\t}\n\t}\n\telse if(z <= 1){\n\t\tif(bits == 8){\n\t\t\tif(!tiff) tiff = (uint8_t*)malloc(x*y*z*sizeof(uint8_t));\n\t\t\treadTiffParallel2D(x,y,z,fileName, (void*)tiff, bits, startSlice, stripSize,flipXY);\n\t\t\treturn (void*)tiff;\n\t\t}\n\t\telse if(bits == 16){\n\t\t\tif(!tiff) tiff = (uint16_t*)malloc(x*y*z*sizeof(uint16_t));\n\t\t\treadTiffParallel2D(x,y,z,fileName, (void*)tiff, bits, startSlice, stripSize, flipXY);\n\t\t\treturn (void*)tiff;\n\t\t}\n\t\telse if(bits == 32){\n\t\t\tif(!tiff) tiff = (float*)malloc(x*y*z*sizeof(float));\n\t\t\treadTiffParallel2D(x,y,z,fileName, (void*)tiff, bits, startSlice, stripSize, flipXY);\n\t\t\treturn (void*)tiff;\n\t\t}\n\t\telse if(bits == 64){\n\t\t\tif(!tiff) tiff = (double*)malloc(x*y*z*sizeof(double));\n\t\t\treadTiffParallel2D(x,y,z,fileName, (void*)tiff, bits, startSlice, stripSize, flipXY);\n\t\t\treturn (void*)tiff;\n\t\t}\n\t\telse{\n\t\t\treturn NULL;\n\t\t}\n\t}\n\telse{\n\t\tif(bits == 8){\n\t\t\tif(!tiff) tiff = (uint8_t*)malloc(x*y*z*sizeof(uint8_t));\n\t\t\treadTiffParallel(x,y,z,fileName, (void*)tiff, bits, startSlice, stripSize, flipXY);\n\t\t\treturn (void*)tiff;\n\t\t}\n\t\telse if(bits == 16){\n\t\t\tif(!tiff) tiff = (uint16_t*)malloc(x*y*z*sizeof(uint16_t));\n\t\t\treadTiffParallel(x,y,z,fileName, (void*)tiff, bits, startSlice, stripSize, flipXY);\n\t\t\treturn (void*)tiff;\n\t\t}\n\t\telse if(bits == 32){\n\t\t\tif(!tiff) tiff = (float*)malloc(x*y*z*sizeof(float));\n\t\t\treadTiffParallel(x,y,z,fileName, (void*)tiff, bits, startSlice, stripSize, flipXY);\n\t\t\treturn (void*)tiff;\n\t\t}\n\t\telse if(bits == 64){\n\t\t\tif(!tiff) tiff = (double*)malloc(x*y*z*sizeof(double));\n\t\t\treadTiffParallel(x,y,z,fileName, (void*)tiff, bits, startSlice, stripSize, flipXY);\n\t\t\treturn (void*)tiff;\n\t\t}\n\t\telse{\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\t// Should never get here but return NULL if we do\n\treturn NULL;\n}",
    "uint8_t writeTiffSingle(const uint64_t x, const uint64_t y, const uint64_t z, const char* fileName, const void* tiff, const void* tiffOld, const uint64_t bits, const uint64_t startSlice, const uint64_t stripSize, const char* mode, const bool transpose, const std::string &compression){\n    TIFF* tif = NULL;\n    if(!strcmp(mode,\"w\")){\n        tif = TIFFOpen(fileName, \"w8\");\n        if(!tif){\n            printf(\"Error: File \\\"%s\\\" cannot be opened\",fileName);\n\t\t\treturn 1;\n        }\n    }\n    else if(!strcmp(mode,\"a\")){\n        tif = TIFFOpen(fileName, \"a8\");\n        if(!tif){\n            printf(\"Error: File \\\"%s\\\" cannot be opened\",fileName);\n\t\t\treturn 1;\n        }\n    }\n    else{\n        printf(\"Error: mode \\\"%s\\\" is not supported. Use w or a for mode type\", mode);\n        return 1;\n    }\n\n    uint64_t len = 0;\n    int compressionType = COMPRESSION_NONE;\n    if(compression != \"none\"){\n        compressionType = COMPRESSION_LZW;\n    }\n    for(uint64_t dir = startSlice; dir < z; dir++){\n        if(dir>=z+startSlice) break;\n        TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, x);\n        TIFFSetField(tif, TIFFTAG_IMAGELENGTH, y);\n        TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, bits);\n        TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, stripSize);\n        TIFFSetField(tif, TIFFTAG_COMPRESSION, compressionType);\n        TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, 1);\n        TIFFSetField(tif, TIFFTAG_PLANARCONFIG, 1);\n        TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 1);\n\n        if(bits >= 32){\n            TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);\n        }\n\n        for (int64_t i = 0; i*stripSize < y; i++)\n        {   \n                if (stripSize*(i+1) > y){\n                    len = (y-(stripSize*i))*x*(bits/8);\n                }\n                else{\n                    len = stripSize*x*(bits/8);\n                }\n                TIFFWriteEncodedStrip(tif, i, (uint8_t*)tiff+((((i*stripSize)*x)+((dir-startSlice)*(x*y)))*(bits/8)), len);\n                //if(transpose) TIFFWriteEncodedStrip(tif, i, (uint8_t*)tiff+((((i*stripSize)*x)+((dir-startSlice)*(x*y)))*(bits/8)), len);\n                //else TIFFWriteEncodedStrip(tif,i,(uint8_t*)tiffOld+((((i*stripSize)*x)+((dir-startSlice)*(x*y)))*(bits/8)), len);\n                //TIFFWriteRawStrip(tif,i,(uint8_t*)tiff+((((i*stripSize)*x)+((dir-startSlice)*(x*y)))*(bits/8)), len);\n        }\n        TIFFWriteDirectory(tif);\n    }\n    TIFFClose(tif);\n    return 0;\n}",
    "uint8_t writeTiffThread(const uint64_t x, const uint64_t y, const uint64_t z, const char* fileName, const void* tiff, const uint64_t bits, const uint64_t startSlice, const uint64_t stripSize, const char* mode, const uint64_t stripsPerDir, uint8_t** &comprA, uint64_t* cSizes, const std::string &compression){\n    TIFF* tif = NULL;\n    if(!strcmp(mode,\"w\")){\n        tif = TIFFOpen(fileName, \"w8\");\n        if(!tif){\n            printf(\"Error: File \\\"%s\\\" cannot be opened\",fileName);\n            return 1;\n        }\n    }\n    else if(!strcmp(mode,\"a\")){\n        tif = TIFFOpen(fileName, \"a8\");\n        if(!tif){\n            printf(\"Error: File \\\"%s\\\" cannot be opened\",fileName);\n            return 1;\n        }\n    }\n    else{\n        printf(\"Error: mode \\\"%s\\\" is not supported. Use w or a for mode type\", mode);\n        return 1;\n    }\n\n    uint64_t len = 0;\n    int compressionType = COMPRESSION_NONE;\n    bool compress = false;\n    if(compression != \"none\"){\n        compress = true;\n        compressionType = COMPRESSION_LZW;\n    }\n    for(uint64_t dir = startSlice; dir < z; dir++){\n        TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, x);\n        TIFFSetField(tif, TIFFTAG_IMAGELENGTH, y);\n        TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, bits);\n        TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, stripSize);\n        TIFFSetField(tif, TIFFTAG_COMPRESSION, compressionType);\n        TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, 1);\n        TIFFSetField(tif, TIFFTAG_PLANARCONFIG, 1);\n        TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 1);\n\n        if(bits >= 32){\n            TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);\n        }\n\n        for (int64_t i = 0; i*stripSize < y; i++)\n        {\n            if(compress){\n                while(!cSizes[i+(dir*stripsPerDir)]){\n                    std::this_thread::sleep_for(std::chrono::microseconds(1));\n                }\n                TIFFWriteRawStrip(tif,i,comprA[i+(dir*stripsPerDir)], cSizes[i+(dir*stripsPerDir)]);\n                free(comprA[i+(dir*stripsPerDir)]);\n            }\n            else{\n                if (stripSize*(i+1) > y){\n                    len = (y-(stripSize*i))*x*(bits/8);\n                }\n                else{\n                    len = stripSize*x*(bits/8);\n                }\n                TIFFWriteRawStrip(tif,i,(uint8_t*)tiff+((((i*stripSize)*x)+((dir-startSlice)*(x*y)))*(bits/8)), len);\n            }\n        }\n        TIFFWriteDirectory(tif);\n    }\n\tfree(comprA);\n\tfree(cSizes);\n    TIFFClose(tif);\n    return 0;\n}",
    "void mexFunction(int nlhs, mxArray *plhs[],\n        int nrhs, const mxArray *prhs[])\n{\n    if(nrhs != 1) mexErrMsgIdAndTxt(\"tiff:inputError\",\"This function requires one argument only\");\n    // Check if the fileName is a char array or matlab style\n    char* fileName = NULL;\n    if(!mxIsClass(prhs[0], \"string\")){\n        if(!mxIsChar(prhs[0])) mexErrMsgIdAndTxt(\"tiff:inputError\",\"The first argument must be a string\");\n        fileName = mxArrayToString(prhs[0]);\n    }\n    else{ \n        mxArray* mString[1];\n        mxArray* mCharA[1];\n\n        // Convert string to char array\n        mString[0] = mxDuplicateArray(prhs[0]);\n        mexCallMATLAB(1, mCharA, 1, mString, \"char\");\n        fileName = mxArrayToString(mCharA[0]);\n    }\n\n    // Handle the tilde character in filenames on Linux/Mac\n    #ifndef _WIN32\n    if(strchr(fileName,'~')) fileName = expandTilde(fileName);\n    #endif\n    \n    TIFFSetWarningHandler(DummyHandler);\n    TIFF* tif = TIFFOpen(fileName, \"r\");\n    if(!tif) mexErrMsgIdAndTxt(\"tiff:inputError\",\"File \\\"%s\\\" cannot be opened\",fileName);\n    \n    uint64_t x = 1,y = 1,z = 1;    \n    if(nrhs == 1){\n        TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &x);\n        TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &y);\n        z = getImageSizeZ(fileName);\n    }\n    else{\n        mexErrMsgIdAndTxt(\"tiff:inputError\",\"Function only accepts one input argument\");       \n    }\n  \n    TIFFClose(tif);\n\tif(isImageJIm(fileName)){\n\t\tuint64_t tempZ = imageJImGetZ(fileName);\n\t\tif(tempZ) z = tempZ;\n\t}\n\n    plhs[0] = mxCreateNumericMatrix(1,3,mxDOUBLE_CLASS, mxREAL);\n    double* dims = (double*)mxGetPr(plhs[0]);\n    dims[0] = y;\n    dims[1] = x;\n    dims[2] = z;\n    \n}",
    "void mexFunction(int nlhs, mxArray *plhs[],\n                 int nrhs, const mxArray *prhs[])\n{\n    if(nrhs < 1 || nrhs > 2) mexErrMsgIdAndTxt(\"tiff:inputError\",\"This function takes one or two arguments only\");\n    // Check if the fileName is a char array or matlab style\n    char* fileName = NULL;\n    if(!mxIsClass(prhs[0], \"string\")){\n        if(!mxIsChar(prhs[0])) mexErrMsgIdAndTxt(\"tiff:inputError\",\"The first argument must be a string\");\n        fileName = mxArrayToString(prhs[0]);\n    }\n    else{ \n        mxArray* mString[1];\n        mxArray* mCharA[1];\n\n        // Convert string to char array\n        mString[0] = mxDuplicateArray(prhs[0]);\n        mexCallMATLAB(1, mCharA, 1, mString, \"char\");\n        fileName = mxArrayToString(mCharA[0]);\n    }\n\n    // Handle the tilde character in filenames on Linux/Mac\n    #ifndef _WIN32\n    if(strchr(fileName,'~')) fileName = expandTilde(fileName);\n    #endif\n\n    uint8_t flipXY = 1;\n    //uint8_t flipXY = 0;\n\n\n    //if(nrhs > 2){\n    //    flipXY = (uint8_t)*(mxGetPr(prhs[2]));\n    //}\n\n\n    TIFFSetWarningHandler(DummyHandler);\n    TIFF* tif = TIFFOpen(fileName, \"r\");\n    if(!tif) mexErrMsgIdAndTxt(\"tiff:inputError\",\"File \\\"%s\\\" cannot be opened\",fileName);\n\n    uint64_t x = 1,y = 1,z = 1,bits = 1, startSlice = 0;\n    TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &x);\n    TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &y);\n\n    if(nrhs == 1){\n        z = getImageSizeZ(fileName);\n    }\n    else{\n        if(mxGetN(prhs[1]) != 2){\n            mexErrMsgIdAndTxt(\"tiff:inputError\",\"Input range is not 2\");\n        }\n        else{\n            startSlice = (uint64_t)*(mxGetPr(prhs[1]))-1;\n            z = (uint64_t)*((mxGetPr(prhs[1])+1))-startSlice;\n            if (!TIFFSetDirectory(tif,startSlice+z-1) || !TIFFSetDirectory(tif,startSlice)){\n                mexErrMsgIdAndTxt(\"tiff:rangeOutOfBound\",\"Range is out of bounds\");\n            }\n        }\n    }\n\n    TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bits);\n    uint64_t stripSize = 1;\n    TIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &stripSize);\n    TIFFClose(tif);\n\n    uint8_t imageJIm = 0;\n    if(isImageJIm(fileName)){\n        imageJIm = 1;\n        uint64_t tempZ = imageJImGetZ(fileName);\n        if(tempZ) z = tempZ;\n    }\n\n    uint64_t dim[3];\n    dim[0] = y;\n    dim[1] = x;\n    dim[2] = z;\n\n\n\n    // Case for ImageJ\n    uint8_t err = 0;\n    if(imageJIm){\n        if(bits == 8){\n            plhs[0] = mxCreateNumericArray(3,(mwSize*)dim,mxUINT8_CLASS, mxREAL);\n            uint8_t* tiff = (uint8_t*)mxGetPr(plhs[0]);\n            err = readTiffParallelImageJ(x,y,z,fileName, (void*)tiff, bits, startSlice, stripSize, flipXY);\n        }\n        else if(bits == 16){\n            plhs[0] = mxCreateNumericArray(3,(mwSize*)dim,mxUINT16_CLASS, mxREAL);\n            uint16_t* tiff = (uint16_t*)mxGetPr(plhs[0]);\n            err = readTiffParallelImageJ(x,y,z,fileName, (void*)tiff, bits, startSlice, stripSize, flipXY);\n        }\n        else if(bits == 32){\n            plhs[0] = mxCreateNumericArray(3,(mwSize*)dim,mxSINGLE_CLASS, mxREAL);\n            float* tiff = (float*)mxGetPr(plhs[0]);\n            err = readTiffParallelImageJ(x,y,z,fileName, (void*)tiff, bits, startSlice, stripSize, flipXY);\n        }\n        else if(bits == 64){\n            plhs[0] = mxCreateNumericArray(3,(mwSize*)dim,mxDOUBLE_CLASS, mxREAL);\n            double* tiff = (double*)mxGetPr(plhs[0]);\n            err = readTiffParallelImageJ(x,y,z,fileName, (void*)tiff, bits, startSlice, stripSize, flipXY);\n        }\n        else{\n            mexErrMsgIdAndTxt(\"tiff:dataTypeError\",\"Data type not suppported\");\n        }\n    }\n    // Case for 2D\n    else if(z <= 1){\n        if(bits == 8){\n            plhs[0] = mxCreateNumericArray(3,(mwSize*)dim,mxUINT8_CLASS, mxREAL);\n            uint8_t* tiff = (uint8_t*)mxGetPr(plhs[0]);\n            err = readTiffParallel2D(x,y,z,fileName, (void*)tiff, bits, startSlice, stripSize, flipXY);\n        }\n        else if(bits == 16){\n            plhs[0] = mxCreateNumericArray(3,(mwSize*)dim,mxUINT16_CLASS, mxREAL);\n            uint16_t* tiff = (uint16_t*)mxGetPr(plhs[0]);\n            err = readTiffParallel2D(x,y,z,fileName, (void*)tiff, bits, startSlice, stripSize, flipXY);\n        }\n        else if(bits == 32){\n            plhs[0] = mxCreateNumericArray(3,(mwSize*)dim,mxSINGLE_CLASS, mxREAL);\n            float* tiff = (float*)mxGetPr(plhs[0]);\n            err = readTiffParallel2D(x,y,z,fileName, (void*)tiff, bits, startSlice, stripSize, flipXY);\n        }\n        else if(bits == 64){\n            plhs[0] = mxCreateNumericArray(3,(mwSize*)dim,mxDOUBLE_CLASS, mxREAL);\n            double* tiff = (double*)mxGetPr(plhs[0]);\n            err = readTiffParallel2D(x,y,z,fileName, (void*)tiff, bits, startSlice, stripSize, flipXY);\n        }\n        else{\n            mexErrMsgIdAndTxt(\"tiff:dataTypeError\",\"Data type not suppported\");\n        }\n    }\n    // Case for 3D\n    else{\n        if(bits == 8){\n            plhs[0] = mxCreateNumericArray(3,(mwSize*)dim,mxUINT8_CLASS, mxREAL);\n            uint8_t* tiff = (uint8_t*)mxGetPr(plhs[0]);\n            err = readTiffParallel(x,y,z,fileName, (void*)tiff, bits, startSlice, stripSize, flipXY);\n        }\n        else if(bits == 16){\n            plhs[0] = mxCreateNumericArray(3,(mwSize*)dim,mxUINT16_CLASS, mxREAL);\n            uint16_t* tiff = (uint16_t*)mxGetPr(plhs[0]);\n            err = readTiffParallel(x,y,z,fileName, (void*)tiff, bits, startSlice, stripSize, flipXY);\n        }\n        else if(bits == 32){\n            plhs[0] = mxCreateNumericArray(3,(mwSize*)dim,mxSINGLE_CLASS, mxREAL);\n            float* tiff = (float*)mxGetPr(plhs[0]);\n            err = readTiffParallel(x,y,z,fileName, (void*)tiff, bits, startSlice, stripSize, flipXY);\n        }\n        else if(bits == 64){\n            plhs[0] = mxCreateNumericArray(3,(mwSize*)dim,mxDOUBLE_CLASS, mxREAL);\n            double* tiff = (double*)mxGetPr(plhs[0]);\n            err = readTiffParallel(x,y,z,fileName, (void*)tiff, bits, startSlice, stripSize, flipXY);\n        }\n        else{\n            mexErrMsgIdAndTxt(\"tiff:dataTypeError\",\"Data type not suppported\");\n        }\n    }\n    if(err) mexErrMsgIdAndTxt(\"tiff:tiffError\",\"An Error occured within the read function\");\n}",
    "char * _loadTIFF(const char *filename, unsigned *width, unsigned *height, unsigned *numcolors, unsigned *numbits, std::map<std::string,std::string> &info, std::string params=\"\", char ** icc_m=NULL, unsigned  *icclength=0)\n{\n\tchar *img, *buf;\n\tFILE * infile;\n\tuint32_t w, h;\n\tuint16_t c, b;\n\n\tTIFFSetErrorHandler(0);\n\n\tTIFF* tif = TIFFOpen(filename, \"r\");\n\tif (tif) {\n\n\t\tsize_t npixels;\n\t\tuint32_t* raster;\n\n\t\tuint32_t imagelength, imagewidth;\n\t\tuint16_t config, nsamples, sampleformat, uval;\n\n\t\tunsigned len;\n\t\tchar * buffer;\n        \n\t\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w);\n\t\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\n\t\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &c);\n\t\tTIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &b);\n\t\tTIFFGetField(tif, TIFFTAG_PLANARCONFIG, &config);\n\t\t\n\t\tif (config != PLANARCONFIG_CONTIG) return NULL;\n\n\t\tchar *infobuf;\n\t\t//if (TIFFGetField(tif, TIFFTAG_ARTIST, &infobuf)) info[\"Artist\"]=infobuf; \n\t\t//if (TIFFGetField(tif, TIFFTAG_MAKE, &infobuf))  info[\"Make\"]=infobuf;\n\t\t//if (TIFFGetField(tif, TIFFTAG_MODEL, &infobuf))  info[\"Model\"]=infobuf;\n\t\t//if (TIFFGetField(tif, TIFFTAG_SOFTWARE, &infobuf))  info[\"Software\"]=infobuf; \n\t\t//if (TIFFGetField(tif, TIFFTAG_COPYRIGHT, &infobuf))  info[\"Copyright\"]=infobuf; \n\t\t//if (TIFFGetField(tif, TIFFTAG_LENSINFO, &infobuf))  info[\"LensInfo\"]=infobuf; \n\t\t//if (TIFFGetField(tif, TIFFTAG_IMAGEDESCRIPTION, &infobuf))  info[\"ImageDescription\"]=infobuf; \n\t\t//if (TIFFGetField(tif, TIFFTAG_DATETIME, &infobuf)) info[\"DateTime\"]=infobuf;\n\t\t//if (TIFFGetField(tif, TIFFTAG_SAMPLEFORMAT, &sampleformat)) {\n\t\t//\tif (sampleformat == SAMPLEFORMAT_UINT) info[\"SampleFormat\"]=\"uint\";\n\t\t//\tif (sampleformat == SAMPLEFORMAT_INT) info[\"SampleFormat\"]=\"int\";\n\t\t//\tif (sampleformat == SAMPLEFORMAT_IEEEFP) info[\"SampleFormat\"]=\"float\";\n\t\t//\tif (sampleformat == SAMPLEFORMAT_VOID) info[\"SampleFormat\"]=\"void\";\n\t\t//}\n\t\t//if (TIFFGetField(tif, TIFFTAG_ORIENTATION, &uval)) info[\"Orientation\"]=tostr(uval);\n/*\n\t\tif (TIFFGetField(tif, TIFFTAG_ICCPROFILE, &len, &buffer)) {\n\t\t\t*icc_m = new char[len];\n\t\t\tmemcpy(*icc_m, buffer, len);\n\t\t\t*icclength = len;\n\t\t}\n*/\n//\t\telse {\n\t\t\t*icc_m = NULL;\n\t\t\t*icclength = 0;\n//\t\t}\n\t\t\n\t\timg = new char[w*h*c*(b/8)];\n\t\tbuf = (char *) _TIFFmalloc(TIFFScanlineSize(tif));\n\t\tint stride = TIFFScanlineSize(tif);\n\t\t\n\t\tchar * dst = (char *) img;\n\t\tfor (unsigned y = 0; y < h; y++){\n\t\t\tTIFFReadScanline(tif, buf, y, 0);\n\t\t\tmemcpy(dst,buf,stride);\n\t\t\tdst += stride;\n\t\t}\n\t\t\n/*\n\t\tuint32_t read_dir_offset; uint32_t count;\n\t\tfloat fval;\n\t\tuint16_t * sval;\n\t\tif (TIFFGetField(tif, TIFFTAG_EXIFIFD, &read_dir_offset )) {\n\t\t\tif (TIFFReadEXIFDirectory(tif, read_dir_offset)) {\n\t\t\t\tif (TIFFGetField( tif, EXIFTAG_FNUMBER, &fval)) info[\"FNumber\"] = tostr(fval);\n\t\t\t\tif (TIFFGetField( tif, EXIFTAG_EXPOSURETIME, &fval)) info[\"ExposureTime\"] = tostr(fval);\n\t\t\t\tif (TIFFGetField( tif, EXIFTAG_FOCALLENGTH, &fval)) info[\"FocalLength\"] = tostr(fval);\n\t\t\t\tif (TIFFGetField( tif, EXIFTAG_ISOSPEEDRATINGS, &count, &sval)) info[\"ISOSpeedRatings\"] = tostr(*sval);\n\t\t\t}\n\t\t\telse printf(\"TIFFReadEXIFDirectory failed\\n\");\n\t\t}\n*/\n\t\t\n\t\t*width = w;\n\t\t*height = h;\n\t\t*numcolors = c;\n\t\t*numbits = b;\n\t\tif (buf) _TIFFfree(buf);\n\t\tTIFFClose(tif);\n\t\treturn img;\n\t}\n\telse return NULL;\n}",
    "bool _writeTIFF(const char *filename, char *imagedata, unsigned width, unsigned height, unsigned numcolors, unsigned numbits, std::map<std::string,std::string> info, char *iccprofile, unsigned iccprofilelength)\n{\n\tchar *img;\n\tunsigned char *buf;\n\tuint32_t w, h;\n\tuint16_t c, b;\n\t\n\tTIFFSetErrorHandler(0);\n\n\tTIFF* tif = TIFFOpen(filename, \"w\");\n\tif (tif) {\n\n\t\tTIFFSetField(tif, TIFFTAG_IMAGEWIDTH, width);  \n\t\tTIFFSetField(tif, TIFFTAG_IMAGELENGTH, height);    \n\t\tTIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, numcolors);   \n\t\tTIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, numbits);\n\t\tif (numbits == 8 | numbits == 16)\n\t\t\tTIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT);\n\t\telse if (numbits == 32)\n\t\t\tTIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);\n\t\telse\n\t\t\treturn false;\n\t\tTIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);   \n\n\t\tTIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\t\tTIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n\t\tTIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_NONE); //todo: COMPRESSION_ADOBE_DEFLATE);\n\t\t// We set the strip size of the file to be size of one row of pixels\n\t\tTIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, TIFFDefaultStripSize(tif, width*numcolors));\n\n\t\t//if (info.find(\"Artist\") != info.end())  TIFFSetField(tif, TIFFTAG_ARTIST, info[\"Artist\"].c_str());\n\t\t//if (info.find(\"Make\") != info.end())  TIFFSetField(tif, TIFFTAG_MAKE, info[\"Make\"].c_str());\n\t\t//if (info.find(\"Model\") != info.end())  TIFFSetField(tif, TIFFTAG_MODEL, info[\"Model\"].c_str());\n\t\t//if (info.find(\"Software\") != info.end())  TIFFSetField(tif, TIFFTAG_SOFTWARE, info[\"Software\"].c_str());\n\t\t//if (info.find(\"Copyright\") != info.end())  TIFFSetField(tif, TIFFTAG_COPYRIGHT, info[\"Copyright\"].c_str());\n\t\t//if (info.find(\"LensInfo\") != info.end())  TIFFSetField(tif, TIFFTAG_LENSINFO, info[\"LensInfo\"].c_str());\n\t\t//if (info.find(\"DateTime\") != info.end()) TIFFSetField(tif, TIFFTAG_DATETIME, info[\"DateTime\"].c_str());\n\t\t//if (info.find(\"ImageDescription\") != info.end())  TIFFSetField(tif, TIFFTAG_IMAGEDESCRIPTION, info[\"ImageDescription\"].c_str());\n\t\t//if (info.find(\"Orientation\") != info.end()) {\n\t\t//\tuint16_t orient = (uint16_t) atoi(info[\"Orientation\"].c_str());\n\t\t//\tTIFFSetField(tif, TIFFTAG_ORIENTATION, 1, &orient);\n\t\t//}\n\n\t\t//if (iccprofile) TIFFSetField(tif, TIFFTAG_ICCPROFILE, iccprofilelength, iccprofile);\n\t\t\t\t\n\t\tunsigned scanlinesize = TIFFScanlineSize(tif);\n\t\tbuf = (unsigned char *) _TIFFmalloc(scanlinesize);\n\t\timg = imagedata;\n\n\t\tfor (unsigned row = 0; row < height; row++)\n\t\t{\n\t\t\tmemcpy(buf, img, scanlinesize);\n\t\t\tif (TIFFWriteScanline(tif, buf, row, 0) < 0) {\n\t\t\t\tprintf(\"TIFFWriteScanline got an error...\\n\");\n\t\t\t\tTIFFError(NULL,NULL);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\timg+=scanlinesize;\n\t\t}\n\n\t\tTIFFWriteDirectory( tif );\n\n\t\t(void) TIFFClose(tif);\n\t\tif (buf) _TIFFfree(buf);\n\t\treturn true;\n\t}\n\telse return true;\n\n}",
    "CImage* CImageIOTiff::ReadImage(CNcbiIstream& istr)\n{\n    TIFF*            tiff             = NULL;\n    uint32*          raster           = NULL;\n    TIFFErrorHandler old_err_handler  = NULL;\n    TIFFErrorHandler old_warn_handler = NULL;\n    CRef<CImage> image;\n    try {\n\n        old_err_handler  = TIFFSetErrorHandler(&s_TiffReadErrorHandler);\n        old_warn_handler = TIFFSetWarningHandler(&s_TiffWarningHandler);\n\n        // open our file\n        tiff = TIFFClientOpen(\"\", \"rm\",\n                              reinterpret_cast<thandle_t>(&istr),\n                              s_TIFFReadHandler,\n                              s_TIFFDummyIOHandler,\n                              s_TIFFSeekHandler,\n                              s_TIFFCloseHandler,\n                              s_TIFFSizeHandler,\n                              s_TIFFMapFileHandler,\n                              s_TIFFUnmapFileHandler);\n        if ( !tiff ) {\n            NCBI_THROW(CImageException, eReadError,\n                       \"CImageIOTiff::ReadImage(): error opening file \");\n        }\n\n        // extract the size parameters\n        size_t width  = 0;\n        size_t height = 0;\n        size_t depth  = 0;\n        TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH,  &width);\n        TIFFGetField(tiff, TIFFTAG_IMAGELENGTH, &height);\n        TIFFGetField(tiff, TIFFTAG_SAMPLESPERPIXEL, &depth);\n\n        if (depth != 1  &&  depth != 3  &&  depth != 4) {\n            string msg(\"CImageIOTiff::ReadImage(): unhandled image depth: \");\n            msg += NStr::NumericToString(depth);\n            NCBI_THROW(CImageException, eReadError, msg);\n        }\n\n        // NB: we treat single plane images as RGB\n        if (depth == 1) {\n            depth = 3;\n        }\n\n        // allocate a temporary buffer for the image\n        raster = (uint32*)_TIFFmalloc(tsize_t(width * height * sizeof(uint32)));\n        if ( !TIFFReadRGBAImage(tiff, (uint32)width, (uint32)height, raster, 1) ) {\n            _TIFFfree(raster);\n\n            NCBI_THROW(CImageException, eReadError,\n                       \"CImageIOTiff::ReadImage(): error reading file\");\n        }\n\n        // now we need to copy this data and pack it appropriately\n        // according to the TIFFRGBAImage man page, TIFFRGBAImage and\n        // TIFFReadRGBAImage create the image in *RASTER* format - i.e.,\n        // with (0, 0) being the lower-left corner, not the upper-left\n        // corner as everyone else in the world expects\n        image = new CImage(width, height, depth);\n        unsigned char* data = image->SetData();\n        for (size_t j = 0;  j < height;  ++j) {\n            // implicit inversion\n            size_t from_idx_base = j * width;\n            size_t to_idx_base   = (height - j - 1) * width;\n\n            size_t i;\n            switch (depth) {\n            case 3:\n                for (i = 0;  i < width;  ++i) {\n                    size_t from_idx = from_idx_base + i;\n                    size_t to_idx   = to_idx_base + i;\n\n                    // TIFFReadRGBAImage() returns data in ABGR image,\n                    // packed as a 32-bit value, so we need to pick this\n                    // apart here\n                    uint32 pixel = raster[from_idx];\n                    data[3 * to_idx + 0] = TIFFGetR(pixel);\n                    data[3 * to_idx + 1] = TIFFGetG(pixel);\n                    data[3 * to_idx + 2] = TIFFGetB(pixel);\n                }\n                break;\n\n            case 4:\n                for (i = 0;  i < width;  ++i) {\n                    size_t from_idx = from_idx_base + i;\n                    size_t to_idx   = to_idx_base + i;\n\n                    // TIFFReadRGBAImage() returns data in ABGR image,\n                    // packed as a 32-bit value, so we need to pick this\n                    // apart here\n                    uint32 pixel = raster[from_idx];\n                    data[4 * to_idx + 0] = TIFFGetR(pixel);\n                    data[4 * to_idx + 1] = TIFFGetG(pixel);\n                    data[4 * to_idx + 2] = TIFFGetB(pixel);\n                    data[4 * to_idx + 3] = (unsigned char)TIFFGetA(pixel);\n                }\n                break;\n            }\n        }\n\n        // clean-up\n        _TIFFfree(raster);\n        TIFFClose(tiff);\n    }\n    catch (...) {\n        if (raster) {\n            _TIFFfree(raster);\n            raster = NULL;\n        }\n\n        if (tiff) {\n            TIFFClose(tiff);\n            tiff = NULL;\n        }\n\n        TIFFSetErrorHandler(old_err_handler);\n        TIFFSetWarningHandler(old_warn_handler);\n\n        // throw to a higher level\n        throw;\n    }\n\n    TIFFSetErrorHandler(old_err_handler);\n    TIFFSetWarningHandler(old_warn_handler);\n    return image.Release();\n}",
    "bool CImageIOTiff::ReadImageInfo(CNcbiIstream& istr,\n                                size_t* width, size_t* height, size_t* depth)\n{\n    TIFF*            tiff             = NULL;\n    TIFFErrorHandler old_err_handler  = NULL;\n    TIFFErrorHandler old_warn_handler = NULL;\n\n    bool success = false;\n    try {\n\n        old_err_handler  = TIFFSetErrorHandler(&s_TiffReadErrorHandler);\n        old_warn_handler = TIFFSetWarningHandler(&s_TiffWarningHandler);\n\n        // open our file\n        tiff = TIFFClientOpen(\"\", \"rm\",\n                              reinterpret_cast<thandle_t>(&istr),\n                              s_TIFFReadHandler,\n                              s_TIFFDummyIOHandler,\n                              s_TIFFSeekHandler,\n                              s_TIFFCloseHandler,\n                              s_TIFFSizeHandler,\n                              s_TIFFMapFileHandler,\n                              s_TIFFUnmapFileHandler);\n        if ( !tiff ) {\n            NCBI_THROW(CImageException, eReadError,\n                       \"CImageIOTiff::ReadImageInfo(): error opening file \");\n        }\n\n        // extract the size parameters\n        if (width) {\n            TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, width);\n        }\n        if (height) {\n            TIFFGetField(tiff, TIFFTAG_IMAGELENGTH, height);\n        }\n        if (depth) {\n            TIFFGetField(tiff, TIFFTAG_SAMPLESPERPIXEL, depth);\n        }\n        TIFFClose(tiff);\n\n        success = true;\n    }\n    catch (...) {\n    }\n\n    TIFFSetErrorHandler(old_err_handler);\n    TIFFSetWarningHandler(old_warn_handler);\n\n    return success;\n}",
    "void CImageIOTiff::WriteImage(const CImage& image, CNcbiOstream& ostr,\n                              CImageIO::ECompress)\n{\n    TIFF* tiff = NULL;\n    TIFFErrorHandler old_err_handler = NULL;\n    TIFFErrorHandler old_warn_handler = NULL;\n\n    try {\n        if ( !image.GetData() ) {\n            NCBI_THROW(CImageException, eWriteError,\n                       \"CImageIOTiff::WriteImage(): cannot write empty image\");\n        }\n\n        old_err_handler  = TIFFSetErrorHandler(&s_TiffWriteErrorHandler);\n        old_warn_handler = TIFFSetWarningHandler(&s_TiffWarningHandler);\n\n        // open our file\n        //ostr.open(file.c_str(), ios::out|ios::binary);\n        tiff = TIFFClientOpen(\"\", \"wm\",\n                              reinterpret_cast<thandle_t>(&ostr),\n                              s_TIFFDummyIOHandler,\n                              s_TIFFWriteHandler,\n                              s_TIFFSeekHandler,\n                              s_TIFFCloseHandler,\n                              s_TIFFSizeHandler,\n                              s_TIFFMapFileHandler,\n                              s_TIFFUnmapFileHandler);\n        if ( !tiff ) {\n            NCBI_THROW(CImageException, eWriteError,\n                       \"CImageIOTiff::WriteImage(): cannot write file\");\n        }\n\n        // set a bunch of standard fields, defining our image dimensions\n        TIFFSetField(tiff, TIFFTAG_IMAGEWIDTH,        image.GetWidth());\n        TIFFSetField(tiff, TIFFTAG_IMAGELENGTH,       image.GetHeight());\n        TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE,     8);\n        TIFFSetField(tiff, TIFFTAG_SAMPLESPERPIXEL,   image.GetDepth());\n        TIFFSetField(tiff, TIFFTAG_ROWSPERSTRIP,      image.GetHeight());\n\n        // TIFF options\n        TIFFSetField(tiff, TIFFTAG_COMPRESSION,   COMPRESSION_DEFLATE);\n        TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC,   PHOTOMETRIC_RGB);\n        TIFFSetField(tiff, TIFFTAG_FILLORDER,     FILLORDER_MSB2LSB);\n        TIFFSetField(tiff, TIFFTAG_PLANARCONFIG,  PLANARCONFIG_CONTIG);\n\n        // write our information\n        TIFFWriteEncodedStrip(tiff, 0,\n                              const_cast<void*>\n                              (reinterpret_cast<const void*> (image.GetData())),\n                              tsize_t(image.GetWidth() * image.GetHeight() * image.GetDepth()));\n        TIFFClose(tiff);\n\n        TIFFSetErrorHandler(old_err_handler);\n        TIFFSetWarningHandler(old_warn_handler);\n    }\n    catch (...) {\n\n        // close our file and wipe it from the system\n        if (tiff) {\n            TIFFClose(tiff);\n            tiff = NULL;\n        }\n\n        // restore the standard error handlers\n        TIFFSetErrorHandler  (old_err_handler);\n        TIFFSetWarningHandler(old_warn_handler);\n\n        throw;\n    }\n}",
    "int main(int argc, char** argv)\r\n{\r\n\tTIFF* image;\r\n\tuint32 width, height;\r\n\tint r1, c1, t1, imagesize;\r\n\tint nsamples;\r\n\tunsigned char* scanline = NULL;\r\n\r\n\tuint16 BitsPerSample;           // normally 8 for grayscale image\r\n\tuint16 SamplesPerPixel;         // normally 1 for grayscale image\r\n\tuint16 i;\r\n\r\n\t// Open the TIFF image\r\n\tif ((image = TIFFOpen(argv[1], \"r\")) == NULL) {\r\n\t\tfprintf(stderr, \"Could not open incoming image\\n\");\r\n\t\texit(42);\r\n\t}\r\n\r\n\t// Find the width and height of the image\r\n\tTIFFGetField(image, TIFFTAG_IMAGEWIDTH, &width);\r\n\tTIFFGetField(image, TIFFTAG_IMAGELENGTH, &height);\r\n\tTIFFGetField(image, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\r\n\tTIFFGetField(image, TIFFTAG_SAMPLESPERPIXEL, &SamplesPerPixel);\r\n\timagesize = height * width + 1;\t//get image size\r\n\r\n\t//allocate memory for reading tif image\r\n\tscanline = (unsigned char*)_TIFFmalloc(SamplesPerPixel * width);\r\n\tif (scanline == NULL) {\r\n\t\tfprintf(stderr, \"Could not allocate memory!\\n\");\r\n\t\texit(0);\r\n\t}\r\n\r\n\tfprintf(stderr, \"W=%i H=%i BitsPerSample=%i SamplesPerPixel=%i\\n\", width, height, BitsPerSample, SamplesPerPixel);\r\n\tfor (r1 = 0; r1 < height; r1++)\r\n\t{\r\n\t\tTIFFReadScanline(image, scanline, r1, 0);\r\n\t\tfor (c1 = 0; c1 < width; c1++)\r\n\t\t{\r\n\t\t\tt1 = c1 * SamplesPerPixel;\r\n\r\n\t\t\tfor (i = 0; i < SamplesPerPixel; i++)\r\n\t\t\t\tprintf(\"%u \\t\", *(scanline + t1 + i));\r\n\t\t\tprintf(\"\\n\");\r\n\t\t}\r\n\t}\r\n\r\n\t_TIFFfree(scanline); //free allocate memory\r\n\r\n\tTIFFClose(image);\r\n\r\n}",
    "int ImageIO::loadTIFF(const Glib::ustring &fname)\n{\n\n    static MyMutex thumbMutex;\n    MyMutex::MyLock lock(thumbMutex);\n\n    if(!options.serializeTiffRead) {\n        lock.release();\n    }\n\n    IMFILE *src = fopen(fname.c_str());\n    TIFF *in = TIFFClientOpen(\n        fname.c_str(), \"r\", static_cast<thandle_t>(src),\n        tiff_Read, tiff_Write, tiff_Seek, tiff_Close, tiff_Size,\n        tiff_Map, tiff_Unmap);\n\n    if (in == nullptr) {\n        return IMIO_CANNOTREADFILE;\n    }\n\n    if (pl) {\n        pl->setProgressStr (\"PROGRESSBAR_LOADTIFF\");\n        pl->setProgress (0.0);\n    }\n\n    int width, height;\n    TIFFGetField(in, TIFFTAG_IMAGEWIDTH, &width);\n    TIFFGetField(in, TIFFTAG_IMAGELENGTH, &height);\n\n    uint16 bitspersample, samplesperpixel;\n    int hasTag = TIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bitspersample);\n    hasTag &= TIFFGetField(in, TIFFTAG_SAMPLESPERPIXEL, &samplesperpixel);\n\n    if (!hasTag) {\n        // These are needed\n        TIFFClose(in);\n        return IMIO_VARIANTNOTSUPPORTED;\n    }\n\n    uint16 config;\n    TIFFGetField(in, TIFFTAG_PLANARCONFIG, &config);\n\n    if (config != PLANARCONFIG_CONTIG) {\n        TIFFClose(in);\n        return IMIO_VARIANTNOTSUPPORTED;\n    }\n\n    if (sampleFormat & (IIOSF_LOGLUV24 | IIOSF_LOGLUV32)) {\n        TIFFSetField(in, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_FLOAT);\n    }\n\n    /*\n     * We could use the min/max values set in TIFFTAG_SMINSAMPLEVALUE and\n     * TIFFTAG_SMAXSAMPLEVALUE, but for now, we normalize the image to the\n     * effective minimum and maximum values\n     */\n    if (options.rtSettings.verbose) {\n        printf(\"Information of \\\"%s\\\":\\n\", fname.c_str());\n        uint16 tiffDefaultScale, tiffBaselineExposure, tiffLinearResponseLimit;\n        if (TIFFGetField(in, TIFFTAG_DEFAULTSCALE, &tiffDefaultScale)) {\n            printf(\"   DefaultScale: %d\\n\", tiffDefaultScale);\n        }\n        else\n            printf(\"   No DefaultScale value!\\n\");\n        if (TIFFGetField(in, TIFFTAG_BASELINEEXPOSURE, &tiffBaselineExposure)) {\n            printf(\"   BaselineExposure: %d\\n\", tiffBaselineExposure);\n        }\n        else\n            printf(\"   No BaselineExposure value!\\n\");\n        if (TIFFGetField(in, TIFFTAG_LINEARRESPONSELIMIT, &tiffLinearResponseLimit)) {\n            printf(\"   LinearResponseLimit: %d\\n\", tiffLinearResponseLimit);\n        }\n        else\n            printf(\"   No LinearResponseLimit value!\\n\");\n\n        // agriggio 2020-11-06: this causes a segfault when compiled with -O3 and PROC_TARGET_NUMBER=2\n        // on gcc 7.5.0, Ubuntu 18.04. Need to understand why...\n        // \n        // uint16 tiffMinValue, tiffMaxValue;\n        // if (TIFFGetField(in, TIFFTAG_SMINSAMPLEVALUE, &tiffMinValue)) {\n        //     printf(\"   MinValue: %d\\n\", tiffMinValue);\n        // }\n        // else\n        //     printf(\"   No minimum value!\\n\");\n        // if (TIFFGetField(in, TIFFTAG_SMAXSAMPLEVALUE, &tiffMaxValue)) {\n        //     printf(\"   MaxValue: %d\\n\\n\", tiffMaxValue);\n        // }\n        // else\n        //     printf(\"   No maximum value!\\n\\n\");\n        // printf(\"   Those values are not taken into account, the image data are normalized to a [0;1] range\\n\\n\");\n    }\n\n    char* profdata;\n    deleteLoadedProfileData();\n    loadedProfileDataJpg = false;\n\n    if (TIFFGetField(in, TIFFTAG_ICCPROFILE, &loadedProfileLength, &profdata)) {\n        embProfile = cmsOpenProfileFromMem (profdata, loadedProfileLength);\n        loadedProfileData = new char [loadedProfileLength];\n        memcpy (loadedProfileData, profdata, loadedProfileLength);\n    } else {\n        embProfile = nullptr;\n    }\n\n    allocate (width, height);\n\n    unsigned char* linebuffer = new unsigned char[TIFFScanlineSize(in) * (samplesperpixel == 1 ? 3 : 1)];\n\n    for (int row = 0; row < height; row++) {\n        if (TIFFReadScanline(in, linebuffer, row, 0) < 0) {\n            TIFFClose(in);\n            delete [] linebuffer;\n            return IMIO_READERROR;\n        }\n\n        if (samplesperpixel > 3) {\n            for (int i = 0; i < width; i++) {\n                memmove(linebuffer + i * 3 * bitspersample / 8, linebuffer + i * samplesperpixel * bitspersample / 8, 3 * bitspersample / 8);\n            }\n        }\n        else if (samplesperpixel == 1) {\n            const size_t bytes = bitspersample / 8;\n            for (int i = width - 1; i >= 0; --i) {\n                const unsigned char* const src = linebuffer + i * bytes;\n                unsigned char* const dest = linebuffer + i * 3 * bytes;\n                memcpy(dest + 2 * bytes, src, bytes);\n                memcpy(dest + 1 * bytes, src, bytes);\n                memcpy(dest + 0 * bytes, src, bytes);\n            }\n        }\n\n        setScanline (row, linebuffer, bitspersample);\n\n        if (pl && !(row % 100)) {\n            pl->setProgress ((double)(row + 1) / height);\n        }\n    }\n\n    TIFFClose(in);\n    delete [] linebuffer;\n\n    if (pl) {\n        pl->setProgressStr (\"PROGRESSBAR_READY\");\n        pl->setProgress (1.0);\n    }\n\n    return IMIO_SUCCESS;\n}",
    "int ImageIO::saveTIFF (const Glib::ustring &fname, int bps, bool isFloat, bool uncompressed) const\n{\n    if (getWidth() < 1 || getHeight() < 1) {\n        return IMIO_HEADERERROR;\n    }\n\n    bool writeOk = true;\n    int width = getWidth ();\n    int height = getHeight ();\n\n    if (bps < 0) {\n        bps = getBPS ();\n    }\n\n    int lineWidth = width * 3 * bps / 8;\n    unsigned char* linebuffer = new unsigned char[lineWidth];\n\n    // little hack to get libTiff to use proper byte order (see TIFFClienOpen()):\n    const char *mode = \"w\";\n#ifdef WIN32\n    FILE *file = g_fopen_withBinaryAndLock (fname);\n    int fileno = _fileno(file);\n    int osfileno = _get_osfhandle(fileno);\n    TIFF* out = TIFFFdOpen (osfileno, fname.c_str(), mode);\n#else\n    TIFF* out = TIFFOpen(fname.c_str(), mode);\n    // int fileno = TIFFFileno (out);\n#endif\n\n    if (!out) {\n        delete [] linebuffer;\n        return IMIO_CANNOTWRITEFILE;\n    }\n\n    if (pl) {\n        pl->setProgressStr (\"PROGRESSBAR_SAVETIFF\");\n        pl->setProgress (0.0);\n    }\n\n    bool needsReverse = false;\n\n    TIFFSetField (out, TIFFTAG_SOFTWARE, RTNAME \" \" RTVERSION);\n    TIFFSetField (out, TIFFTAG_IMAGEWIDTH, width);\n    TIFFSetField (out, TIFFTAG_IMAGELENGTH, height);\n    TIFFSetField (out, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n    TIFFSetField (out, TIFFTAG_SAMPLESPERPIXEL, 3);\n    TIFFSetField (out, TIFFTAG_ROWSPERSTRIP, height);\n    TIFFSetField (out, TIFFTAG_BITSPERSAMPLE, bps);\n    TIFFSetField (out, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    TIFFSetField (out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n    TIFFSetField (out, TIFFTAG_COMPRESSION, uncompressed ? COMPRESSION_NONE : COMPRESSION_ADOBE_DEFLATE);\n    TIFFSetField (out, TIFFTAG_SAMPLEFORMAT, (bps == 16 || bps == 32) && isFloat ? SAMPLEFORMAT_IEEEFP : SAMPLEFORMAT_UINT);\n\n    // somehow Exiv2 (tested with 0.27.3) doesn't seem to be able to update\n    // XResolution and YResolution, so we do it ourselves here....\n    constexpr float default_resolution = 300.f;\n    float x_res = default_resolution;\n    float y_res = default_resolution;\n    int res_unit = RESUNIT_INCH;\n    if (!metadataInfo.filename().empty()) {\n        auto exif = metadataInfo.getOutputExifData();\n        auto it = exif.findKey(Exiv2::ExifKey(\"Exif.Image.XResolution\"));\n        if (it != exif.end()) {\n            x_res = it->toFloat();\n        }\n        it = exif.findKey(Exiv2::ExifKey(\"Exif.Image.YResolution\"));\n        if (it != exif.end()) {\n            y_res = it->toFloat();\n        }\n        it = exif.findKey(Exiv2::ExifKey(\"Exif.Image.ResolutionUnit\"));\n        if (it != exif.end()) {\n            res_unit = exiv2_to_long(*it);\n        }\n    }\n    TIFFSetField(out, TIFFTAG_XRESOLUTION, x_res);\n    TIFFSetField(out, TIFFTAG_YRESOLUTION, y_res);\n    TIFFSetField(out, TIFFTAG_RESOLUTIONUNIT, res_unit);\n\n    if (!uncompressed) {\n        TIFFSetField (out, TIFFTAG_PREDICTOR, (bps == 16 || bps == 32) && isFloat ? PREDICTOR_FLOATINGPOINT : PREDICTOR_HORIZONTAL);\n    }\n    if (profileData) {\n        TIFFSetField (out, TIFFTAG_ICCPROFILE, profileLength, profileData);\n    }\n\n    for (int row = 0; row < height; row++) {\n        getScanline (row, linebuffer, bps, isFloat);\n\n        if (bps == 16) {\n            if(needsReverse && !uncompressed && isFloat) {\n                for(int i = 0; i < lineWidth; i += 2) {\n                    char temp = linebuffer[i];\n                    linebuffer[i] = linebuffer[i + 1];\n                    linebuffer[i + 1] = temp;\n                }\n            }\n        } else if (bps == 32) {\n            if(needsReverse && !uncompressed) {\n                for(int i = 0; i < lineWidth; i += 4) {\n                    char temp = linebuffer[i];\n                    linebuffer[i] = linebuffer[i + 3];\n                    linebuffer[i + 3] = temp;\n                    temp = linebuffer[i + 1];\n                    linebuffer[i + 1] = linebuffer[i + 2];\n                    linebuffer[i + 2] = temp;\n                }\n            }\n        }\n\n        if (TIFFWriteScanline (out, linebuffer, row, 0) < 0) {\n            TIFFClose (out);\n            delete [] linebuffer;\n            return IMIO_CANNOTWRITEFILE;\n        }\n\n        if (pl && !(row % 100)) {\n            pl->setProgress ((double)(row + 1) / height);\n        }\n    }\n\n    if (TIFFFlush(out) != 1) {\n        writeOk = false;\n    }\n\n    TIFFClose (out);\n#ifdef WIN32\n    fclose (file);\n#endif\n\n    delete [] linebuffer;\n\n    if (!saveMetadata(fname)) {\n        writeOk = false;\n    }\n\n    if (pl) {\n        pl->setProgressStr (\"PROGRESSBAR_READY\");\n        pl->setProgress (1.0);\n    }\n\n    if(writeOk) {\n        return IMIO_SUCCESS;\n    } else {\n        g_remove (fname.c_str());\n        return IMIO_CANNOTWRITEFILE;\n    }\n}",
    "void Tiffload::Open() throw(invalid_argument, runtime_error)\n{\n\t// have we already opened the image?\n\tif (buffer != NULL) {\n\t\treturn;\n\t}\n\t\n  TIFF* image;\n  if ((image = TIFFOpen(filename.c_str(), \"r\")) == NULL) {\n    throw invalid_argument(\"Could not open image!\");\n  }\n  \n  TIFFGetField(image, TIFFTAG_BITSPERSAMPLE, &depth);\n  depth = (2 << (depth - 1)) - 1;\n  \n/*  uint16 spp;\n  if ((TIFFGetField(image, TIFFTAG_SAMPLESPERPIXEL, &spp) == 0) || (spp != 1)) {\n    throw invalid_argument(\"Either undefined or unsupported number of samples per pixel\");\n  }*/\n    \n  tsize_t stripSize = TIFFStripSize(image);\n  int stripMax = TIFFNumberOfStrips(image);\n  unsigned long imageOffset = 0;\n  \n  unsigned long bufferSize = stripMax * stripSize;\n  try {\n    buffer = new unsigned char[bufferSize];\n  } catch (bad_alloc&) {\n    throw runtime_error(\"Failure to allocate storage for tiff image\");\n  }\n  \n  for (int stripCount = 0; stripCount < stripMax; ++stripCount) {\n    long result = TIFFReadEncodedStrip(image, stripCount, buffer + imageOffset, stripSize);\n\tif (result == -1) {\n\t  throw invalid_argument(\"Read error for tiff image\");\n\t}\n    imageOffset += result;\n  }\n  \n  // find the number of rows and number of columns\n  if (TIFFGetField(image, TIFFTAG_IMAGEWIDTH, &cols) == 0) {\n    throw invalid_argument(\"Tiff image does not define its width\");\n  }\n  if (TIFFGetField(image, TIFFTAG_IMAGELENGTH, &rows) == 0) {\n    throw invalid_argument(\"Tiff image does not define its length\");\n  }\n\n  TIFFClose(image);\n}",
    "long SaveContainerTiff::_writeFile(void* f,Data &aData,\n\t\t\t\t   CtSaving::HeaderMap &/*aHeader*/,\n\t\t\t\t   CtSaving::FileFormat /*aFormat*/)\n{\n    DEB_MEMBER_FUNCT();\n\n    TIFF *image;\n    std::string* filename = (std::string*)f;\n    if((image = TIFFOpen(filename->c_str(), \"w\")) == NULL)\n      {\n\tDEB_TRACE()<<\"SaveContainerTiff::_writeFile() - not able to open tiff file\";\n\tthrow LIMA_CTL_EXC(Error,\"SaveContainerTiff::_writeFile() - not able to open tiff file\");\n      }\n    \n    /* If additional info wants to be written */\n  \n    char add_info[1000] = \"\\0\";\n    sprintf(add_info,\"Frame number %d\", aData.frameNumber);\n    \n    TIFFSetField(image, TIFFTAG_IMAGEWIDTH, aData.dimensions[0]);\n    TIFFSetField(image, TIFFTAG_IMAGELENGTH, aData.dimensions[1]);\n\n    int sampleformat = SAMPLEFORMAT_UINT;\n    int bytespersample = 0;\n \n    switch(aData.type)\n      {\n      case Data::UINT8:\n\tbytespersample = sizeof(std::uint8_t);\n\tsampleformat = SAMPLEFORMAT_UINT;\n\tbreak;\n      case Data::INT8: \n\tbytespersample = sizeof(std::int8_t);\n\tsampleformat = SAMPLEFORMAT_INT;\n\tbreak;\n      case Data::UINT16:\n\tbytespersample = sizeof(std::uint16_t);\n\tsampleformat = SAMPLEFORMAT_UINT;\n\tbreak;\n      case Data::INT16:\t\n\tbytespersample = sizeof(std::int16_t);\n\tsampleformat = SAMPLEFORMAT_INT;\n\tbreak;\n      case Data::UINT32:\n\tbytespersample = sizeof(std::uint32_t);\n\tsampleformat = SAMPLEFORMAT_UINT;\n\tbreak;\n      case Data::INT32:\t\n\tbytespersample = sizeof(std::int32_t);\n\tsampleformat = SAMPLEFORMAT_INT;\n\tbreak;\n      case Data::UINT64:\n\tbytespersample = 8;\n\tsampleformat = SAMPLEFORMAT_UINT;\n\tbreak;\n      case Data::INT64:\t\n\tbytespersample = 8;\n\tsampleformat = SAMPLEFORMAT_INT;\n\tbreak;\n      case Data::FLOAT:\t\n\tbytespersample = sizeof(float);\n\tsampleformat = SAMPLEFORMAT_IEEEFP;\n\tbreak;\n      case Data::DOUBLE: \n\tbytespersample = sizeof(double);\n\tsampleformat = SAMPLEFORMAT_IEEEFP;\n\tbreak;\n      default:\n\tbreak;\t\t// @todo ERROR has to be manage\n      }\n\n\n \n    TIFFSetField(image, TIFFTAG_BITSPERSAMPLE, bytespersample * 8);\n    TIFFSetField(image, TIFFTAG_SAMPLESPERPIXEL, 1);\n    TIFFSetField(image, TIFFTAG_SAMPLEFORMAT,  sampleformat);\n    TIFFSetField(image, TIFFTAG_ROWSPERSTRIP, aData.dimensions[1]);\n    TIFFSetField(image, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n    TIFFSetField(image, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n    TIFFSetField(image, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);    // set the origin of the image.\n    TIFFSetField(image, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    TIFFSetField(image, TIFFTAG_SOFTWARE, \"Lima image\");  \n    TIFFSetField(image, TIFFTAG_IMAGEDESCRIPTION, add_info);\n\n\n    // Write the information to the file\n\n    long w_size = TIFFWriteEncodedStrip(image, 0, (unsigned char*)aData.data(), (aData.dimensions[0]* aData.dimensions[1] * bytespersample));\n \n    DEB_TRACE() <<  \"Bytes written to tif file : \" << w_size;\n\n    // Close the file\n    TIFFClose(image);\n    return w_size;\n}",
    "PayloadWithMetaData<QImage> readTiffFile(const QString &filename)\n{\n    QFile inFile(filename);\n    if(!inFile.open(QIODevice::ReadOnly))\n    {\n        LOG_WARNING() << LOGGING_CTX << \"Can't open\" << filename;\n        return QImage();\n    }\n\n#if defined (TIFFLIB_VERSION) && (TIFFLIB_VERSION >= 20221213) && (QT_VERSION >= QT_VERSION_CHECK(5, 5, 0))\n    TIFFOpenOptions *opts = TIFFOpenOptionsAlloc();\n    TIFFOpenOptionsSetErrorHandlerExtR(opts, errorHandlerProc, Q_NULLPTR);\n    TIFFOpenOptionsSetWarningHandlerExtR(opts, &warningHandlerProc, Q_NULLPTR);\n    TIFF *tiff = TIFFClientOpenExt(\"DecoderLibTiff\", \"r\", &inFile, readProc, writeProc, seekProc, closeProc, sizeProc, mapProc, unmapProc, opts);\n    TIFFOpenOptionsFree(opts);\n#else\n    TIFF *tiff = TIFFClientOpen(\"DecoderLibTiff\", \"r\", &inFile, readProc, writeProc, seekProc, closeProc, sizeProc, mapProc, unmapProc);\n#endif\n    if(!tiff)\n    {\n        LOG_WARNING() << LOGGING_CTX << \"Can't TIFFClientOpen for\" << filename;\n        return QImage();\n    }\n\n    if(!TIFFSetDirectory(tiff, 0))\n    {\n        LOG_WARNING() << LOGGING_CTX << \"Can't TIFFSetDirectory for\" << filename;\n        TIFFClose(tiff);\n        return QImage();\n    }\n\n    quint32 width = 0;\n    if(!TIFFGetFieldDefaulted(tiff, TIFFTAG_IMAGEWIDTH, &width) || width <= 0)\n    {\n        LOG_WARNING() << LOGGING_CTX << \"Can't get TIFFTAG_IMAGEWIDTH for\" << filename;\n        TIFFClose(tiff);\n        return QImage();\n    }\n\n    quint32 height = 0;\n    if(!TIFFGetFieldDefaulted(tiff, TIFFTAG_IMAGELENGTH, &height) || height <= 0)\n    {\n        LOG_WARNING() << LOGGING_CTX << \"Can't get TIFFTAG_IMAGELENGTH for\" << filename;\n        TIFFClose(tiff);\n        return QImage();\n    }\n\n    quint16 compression = 0;\n    TIFFGetFieldDefaulted(tiff, TIFFTAG_COMPRESSION, &compression);\n\n    /// @todo LibTIFF-4.6.0: Looks like samples layout for subsampled YCbCr data\n    /// for JPEG compression is differ from samples layout for other compression\n    /// types. So we will enforce built-in YCbCr to RGB converter. Despite tag\n    /// name, non-YCbCr colorspaces like CMYK or RGB are not affected\n    if(compression == COMPRESSION_JPEG)\n        TIFFSetField(tiff, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n\n    quint16 samplesPerPixel = 0;\n    if(!TIFFGetFieldDefaulted(tiff, TIFFTAG_SAMPLESPERPIXEL, &samplesPerPixel) || samplesPerPixel <= 0)\n        samplesPerPixel = 1;\n\n    int alphaIndex = -1;\n    quint16 extrasamplesCount = 0;\n    const quint16 *extrasamples = Q_NULLPTR;\n    if(TIFFGetFieldDefaulted(tiff, TIFFTAG_EXTRASAMPLES, &extrasamplesCount, &extrasamples))\n    {\n        for(quint16 i = 0; i < extrasamplesCount && alphaIndex < 0; ++i)\n        {\n            if(extrasamples[i] == EXTRASAMPLE_ASSOCALPHA)\n                alphaIndex = static_cast<int>(i);\n        }\n        for(quint16 i = 0; i < extrasamplesCount && alphaIndex < 0; ++i)\n        {\n            if(extrasamples[i] == EXTRASAMPLE_UNASSALPHA)\n                alphaIndex = static_cast<int>(i);\n        }\n    }\n    const quint16 primarysamplesCount = samplesPerPixel > extrasamplesCount ? samplesPerPixel - extrasamplesCount : 0;\n\n    quint16 photometric = 0;\n    if(!TIFFGetFieldDefaulted(tiff, TIFFTAG_PHOTOMETRIC, &photometric))\n    {\n        LOG_WARNING() << LOGGING_CTX << \"Can't get TIFFTAG_PHOTOMETRIC for\" << filename;\n        if(primarysamplesCount == 1)\n        {\n            photometric = PHOTOMETRIC_MINISWHITE;\n            LOG_WARNING() << LOGGING_CTX << \"Assuming PHOTOMETRIC_MINISWHITE\";\n        }\n        else if(primarysamplesCount == 3)\n        {\n            photometric = PHOTOMETRIC_RGB;\n            LOG_WARNING() << LOGGING_CTX << \"Assuming PHOTOMETRIC_RGB\";\n        }\n        else\n        {\n            TIFFClose(tiff);\n            return QImage();\n        }\n    }\n\n    /// @note Enable converting PHOTOMETRIC_LOGL and PHOTOMETRIC_LOGLUV to 8 bit\n    /// RGB and grayscale values respective\n    if(IsOneOf(photometric, PHOTOMETRIC_LOGL, PHOTOMETRIC_LOGLUV))\n        TIFFSetField(tiff, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_8BIT);\n\n    quint16 orientation = 0;\n    if(!TIFFGetFieldDefaulted(tiff, TIFFTAG_ORIENTATION, &orientation) || orientation <= 0)\n        orientation = ORIENTATION_TOPLEFT;\n\n    quint16 bitsPerSample = 0;\n    if(!TIFFGetField(tiff, TIFFTAG_BITSPERSAMPLE, &bitsPerSample) || bitsPerSample <= 0)\n        bitsPerSample = 1;\n\n    quint16 sampleFormat = 0;\n    if(!TIFFGetFieldDefaulted(tiff, TIFFTAG_SAMPLEFORMAT, &sampleFormat) || sampleFormat <= 0)\n        sampleFormat = SAMPLEFORMAT_VOID;\n\n    quint16 inkSet = 0;\n    if(photometric == PHOTOMETRIC_SEPARATED)\n    {\n        if(!TIFFGetFieldDefaulted(tiff, TIFFTAG_INKSET, &inkSet) || inkSet <= 0)\n            inkSet = INKSET_CMYK;\n    }\n\n    quint16 planarConfig = 0;\n    TIFFGetField(tiff, TIFFTAG_PLANARCONFIG, &planarConfig);\n\n    const float *ycbcrcoeffs = Q_NULLPTR;\n    TIFFGetFieldDefaulted(tiff, TIFFTAG_YCBCRCOEFFICIENTS, &ycbcrcoeffs);\n\n    quint16 subsamplinghor = 0, subsamplingver = 0;\n    TIFFGetFieldDefaulted(tiff, TIFFTAG_YCBCRSUBSAMPLING, &subsamplinghor, &subsamplingver);\n\n    quint16 ycbcrpositioning = 0;\n    TIFFGetFieldDefaulted(tiff, TIFFTAG_YCBCRPOSITIONING, &ycbcrpositioning);\n\n    const quint16 *redTable = Q_NULLPTR;\n    const quint16 *greenTable = Q_NULLPTR;\n    const quint16 *blueTable = Q_NULLPTR;\n    TIFFGetFieldDefaulted(tiff, TIFFTAG_COLORMAP, &redTable, &greenTable, &blueTable);\n\n    QScopedPointer<ICCProfile> iccProfile(readICCProfile(tiff));\n    if((!iccProfile || !iccProfile->isValid()) && photometric == PHOTOMETRIC_SEPARATED && inkSet == INKSET_CMYK)\n        iccProfile.reset(new ICCProfile(ICCProfile::defaultCmykProfileData()));\n\n    LOG_DEBUG() << LOGGING_CTX << \"TIFFTAG_IMAGEWIDTH =\" << width;\n    LOG_DEBUG() << LOGGING_CTX << \"TIFFTAG_IMAGELENGTH =\" << height;\n    LOG_DEBUG() << LOGGING_CTX << \"TIFFTAG_PHOTOMETRIC =\" << photometricToString(photometric).toLatin1().data();\n    LOG_DEBUG() << LOGGING_CTX << \"TIFFTAG_INKSET =\" << inkSetToString(inkSet).toLatin1().data();\n    LOG_DEBUG() << LOGGING_CTX << \"TIFFTAG_ORIENTATION =\" << orientationToString(orientation).toLatin1().data();\n    LOG_DEBUG() << LOGGING_CTX << \"TIFFTAG_BITSPERSAMPLE =\" << bitsPerSample;\n    LOG_DEBUG() << LOGGING_CTX << \"TIFFTAG_SAMPLESPERPIXEL =\" << samplesPerPixel;\n    LOG_DEBUG() << LOGGING_CTX << \"TIFFTAG_SAMPLEFORMAT =\" << sampleFormatToString(sampleFormat).toLatin1().data();\n    LOG_DEBUG() << LOGGING_CTX << \"TIFFTAG_EXTRASAMPLES =\" << extrasamplesToString(extrasamplesCount, extrasamples).toLatin1().data();\n    LOG_DEBUG() << LOGGING_CTX << \"TIFFTAG_PLANARCONFIG =\" << planarConfigToString(planarConfig).toLatin1().data();\n    LOG_DEBUG() << LOGGING_CTX << \"TIFFTAG_COMPRESSION =\" << compressionToString(compression).toLatin1().data();\n    LOG_DEBUG() << LOGGING_CTX << \"TIFFTAG_YCBCRSUBSAMPLING =\" << subsamplinghor << subsamplingver;\n    LOG_DEBUG() << LOGGING_CTX << \"TIFFTAG_YCBCRPOSITIONING =\" << ycbcrpositioningToString(ycbcrpositioning).toLatin1().data();\n\n    const bool isSupportedInt = IsOneOf(sampleFormat, SAMPLEFORMAT_UINT, SAMPLEFORMAT_VOID, SAMPLEFORMAT_INT) && bitsPerSample <= 64;\n    const bool isSupportedFp = sampleFormat == SAMPLEFORMAT_IEEEFP && IsOneOf(bitsPerSample, 16, 24, 32, 64);\n    bool isReadingSupported = false;\n    switch(photometric)\n    {\n    case PHOTOMETRIC_MINISWHITE:\n    case PHOTOMETRIC_MINISBLACK:\n    case PHOTOMETRIC_LOGL:\n        isReadingSupported = (isSupportedInt || isSupportedFp) && primarysamplesCount >= 1;\n        break;\n    case PHOTOMETRIC_RGB:\n    case PHOTOMETRIC_YCBCR:\n    case PHOTOMETRIC_LOGLUV:\n        isReadingSupported = (isSupportedInt || isSupportedFp) && primarysamplesCount >= 3;\n        break;\n    case PHOTOMETRIC_SEPARATED:\n        isReadingSupported = (isSupportedInt || isSupportedFp) && primarysamplesCount >= 4;\n        break;\n    case PHOTOMETRIC_CIELAB:\n    case PHOTOMETRIC_ICCLAB:\n    case PHOTOMETRIC_ITULAB:\n        isReadingSupported = (isSupportedInt || isSupportedFp) && primarysamplesCount >= 1;\n        break;\n    case PHOTOMETRIC_PALETTE:\n        isReadingSupported = redTable && greenTable && blueTable && bitsPerSample <= 16 && primarysamplesCount >= 1;\n        break;\n    // case PHOTOMETRIC_MASK:\n    // case PHOTOMETRIC_CFA:\n    default:\n        break;\n    }\n\n    QImage result;\n    if(isReadingSupported)\n    {\n        Context ctx;\n        memset(&ctx, 0, sizeof(ctx));\n        ctx.tiff = tiff;\n        ctx.width = static_cast<qint64>(width);\n        ctx.height = static_cast<qint64>(height);\n        ctx.compression = compression;\n        ctx.photometric = compression == COMPRESSION_JPEG && photometric == PHOTOMETRIC_YCBCR ? PHOTOMETRIC_RGB : photometric;\n        ctx.samplesPerPixel = static_cast<qint64>(samplesPerPixel);\n        ctx.bitsPerSample = static_cast<qint64>(bitsPerSample);\n        ctx.sampleFormat = sampleFormat;\n        ctx.inkSet = inkSet;\n        ctx.iccProfile = iccProfile.data();\n        ctx.ycbcrcoeffs = ycbcrcoeffs;\n        ctx.subsamplinghor = static_cast<qint64>(subsamplinghor);\n        ctx.subsamplingver = static_cast<qint64>(subsamplingver);\n        ctx.ycbcrpositioning = ycbcrpositioning;\n        ctx.extrasamplesCount = static_cast<qint64>(extrasamplesCount);\n        ctx.primarysamplesCount = static_cast<qint64>(primarysamplesCount);\n        ctx.alphaIndex = alphaIndex;\n        ctx.alphaPremultiplied = alphaIndex >= 0 ? extrasamples[alphaIndex] == EXTRASAMPLE_ASSOCALPHA : false;\n        ctx.redTable = redTable;\n        ctx.greenTable = greenTable;\n        ctx.blueTable = blueTable;\n        ctx.colorTablesIs16Bit = false;\n\n        if(photometric == PHOTOMETRIC_PALETTE && redTable && greenTable && blueTable)\n        {\n            /// @note See buildMap and checkcmap in tif_getimage.c\n            for(quint64 i = 0, count = (1ull << bitsPerSample); i < count && !ctx.colorTablesIs16Bit; ++i)\n                if(redTable[i] >= 256 || greenTable[i] >= 256 || blueTable[i] >= 256)\n                    ctx.colorTablesIs16Bit = true;\n        }\n\n        if(TIFFIsTiled(tiff))\n            result = readTiffFileTiled(&ctx);\n        else\n            result = readTiffFileStriped(&ctx);\n    }\n\n    /// @todo LibTIFF-4.6.0: TIFFRGBA* has bad errors handling and reports OK\n    /// sometimes even if no data was decoded. So we will disable it for all\n    /// supported formats\n    if(result.isNull() && !isReadingSupported)\n    {\n        TIFFRGBAImage img;\n        char emsg[1024];\n        if(!TIFFRGBAImageBegin(&img, tiff, 0, emsg))\n        {\n            LOG_WARNING() << LOGGING_CTX << \"Can't TIFFRGBAImageBegin for\" << filename;\n            LOG_WARNING() << LOGGING_CTX << \"Reason:\" << emsg;\n            TIFFClose(tiff);\n            return QImage();\n        }\n\n        result = QImage(static_cast<int>(img.width), static_cast<int>(img.height),\n#if (USE_RGBA_8888)\n                      QImage::Format_RGBA8888);\n#else\n                      QImage::Format_ARGB32);\n#endif\n        if(result.isNull())\n        {\n            LOG_WARNING() << LOGGING_CTX << \"Invalid image size\";\n            TIFFClose(tiff);\n            return QImage();\n        }\n\n        img.req_orientation = img.orientation;\n\n#if defined (TIFFLIB_VERSION) && (TIFFLIB_VERSION >= 20210416)\n        typedef uint32_t TiffImageBitsType;\n#else\n        typedef uint32 TiffImageBitsType;\n#endif\n\n        if(!TIFFRGBAImageGet(&img, reinterpret_cast<TiffImageBitsType*>(result.bits()), img.width, img.height))\n        {\n            LOG_WARNING() << LOGGING_CTX << \"Can't TIFFRGBAImageGet for\" << filename;\n            TIFFClose(tiff);\n            return QImage();\n        }\n\n#if (!USE_RGBA_8888)\n        QImage_rgbSwap(result);\n#endif\n\n#undef USE_RGBA_8888\n\n        TIFFRGBAImageEnd(&img);\n\n        if(iccProfile)\n            iccProfile->applyToImage(&result);\n    }\n\n    // Some image formats can't be rendered successfully\n    if(!IsOneOf(result.format(), QImage::Format_RGB32, QImage::Format_ARGB32))\n        QImage_convertTo(result, result.hasAlphaChannel() ? QImage::Format_ARGB32 : QImage::Format_RGB32);\n\n    ImageMetaData *metaData = ImageMetaData::createMetaData(filename);\n    if(!metaData)\n        metaData = readExifMetaData(tiff);\n    if(!metaData)\n        metaData = new ImageMetaData;\n\n    metaData->addCustomOrientation(orientation);\n    metaData->applyExifOrientation(&result);\n\n    quint16 resUnit = 0;\n    if(!TIFFGetField(tiff, TIFFTAG_RESOLUTIONUNIT, &resUnit))\n        resUnit = RESUNIT_INCH;\n    float resX = 0.0f, resY = 0.0f;\n    if(TIFFGetField(tiff, TIFFTAG_XRESOLUTION, &resX) && TIFFGetField(tiff, TIFFTAG_YRESOLUTION, &resY))\n    {\n        if(resUnit == RESUNIT_CENTIMETER)\n            metaData->addCustomDpi(static_cast<qreal>(resX * 2.54f), static_cast<qreal>(resY * 2.54f));\n        else if(resUnit == RESUNIT_INCH)\n            metaData->addCustomDpi(static_cast<qreal>(resX), static_cast<qreal>(resY));\n    }\n\n    TIFFClose(tiff);\n\n    return PayloadWithMetaData<QImage>(result, metaData);\n}",
    "bool QTiffHandler::read(QImage *image)\n{\n    if (!canRead())\n        return false;\n\n    TIFF *const tiff = TIFFClientOpen(\"foo\",\n                                      \"r\",\n                                      this,\n                                      qtiffReadProc,\n                                      qtiffWriteProc,\n                                      qtiffSeekProc,\n                                      qtiffCloseProc,\n                                      qtiffSizeProc,\n                                      qtiffMapProc,\n                                      qtiffUnmapProc);\n\n    if (!tiff) {\n        return false;\n    }\n    uint32 width;\n    uint32 height;\n    uint16 photometric;\n    if (!TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, &width)\n        || !TIFFGetField(tiff, TIFFTAG_IMAGELENGTH, &height)\n        || !TIFFGetField(tiff, TIFFTAG_PHOTOMETRIC, &photometric)) {\n        TIFFClose(tiff);\n        return false;\n    }\n\n    uint16 bitPerSample;\n    if (!TIFFGetField(tiff, TIFFTAG_BITSPERSAMPLE, &bitPerSample)) {\n        TIFFClose(tiff);\n        return false;\n    }\n\n    bool grayscale = photometric == PHOTOMETRIC_MINISBLACK || photometric == PHOTOMETRIC_MINISWHITE;\n    if (grayscale && bitPerSample == 1) {\n        if (image->size() != QSize(width, height) || image->format() != QImage::Format_Mono)\n            *image = QImage(width, height, QImage::Format_Mono);\n        QVector<QRgb> colortable(2);\n        if (photometric == PHOTOMETRIC_MINISBLACK) {\n            colortable[0] = 0xff000000;\n            colortable[1] = 0xffffffff;\n        } else {\n            colortable[0] = 0xffffffff;\n            colortable[1] = 0xff000000;\n        }\n        image->setColorTable(colortable);\n\n        if (!image->isNull()) {\n            for (uint32 y=0; y<height; ++y) {\n                if (TIFFReadScanline(tiff, image->scanLine(y), y, 0) < 0) {\n                    TIFFClose(tiff);\n                    return false;\n                }\n            }\n        }\n    } else {\n        if ((grayscale || photometric == PHOTOMETRIC_PALETTE) && bitPerSample == 8) {\n            if (image->size() != QSize(width, height) || image->format() != QImage::Format_Indexed8)\n                *image = QImage(width, height, QImage::Format_Indexed8);\n            if (!image->isNull()) {\n                const uint16 tableSize = 256;\n                QVector<QRgb> qtColorTable(tableSize);\n                if (grayscale) {\n                    for (int i = 0; i<tableSize; ++i) {\n                        const int c = (photometric == PHOTOMETRIC_MINISBLACK) ? i : (255 - i);\n                        qtColorTable[i] = qRgb(c, c, c);\n                    }\n                } else {\n                    // create the color table\n                    uint16 *redTable = static_cast<uint16 *>(qMalloc(tableSize * sizeof(uint16)));\n                    uint16 *greenTable = static_cast<uint16 *>(qMalloc(tableSize * sizeof(uint16)));\n                    uint16 *blueTable = static_cast<uint16 *>(qMalloc(tableSize * sizeof(uint16)));\n                    if (!redTable || !greenTable || !blueTable) {\n                        TIFFClose(tiff);\n                        return false;\n                    }\n                    if (!TIFFGetField(tiff, TIFFTAG_COLORMAP, &redTable, &greenTable, &blueTable)) {\n                        TIFFClose(tiff);\n                        return false;\n                    }\n\n                    for (int i = 0; i<tableSize ;++i) {\n                        const int red = redTable[i] / 257;\n                        const int green = greenTable[i] / 257;\n                        const int blue = blueTable[i] / 257;\n                        qtColorTable[i] = qRgb(red, green, blue);\n                    }\n                }\n\n                image->setColorTable(qtColorTable);\n                for (uint32 y=0; y<height; ++y) {\n                    if (TIFFReadScanline(tiff, image->scanLine(y), y, 0) < 0) {\n                        TIFFClose(tiff);\n                        return false;\n                    }\n                }\n\n                // free redTable, greenTable and greenTable done by libtiff\n            }\n        } else {\n            if (image->size() != QSize(width, height) || image->format() != QImage::Format_ARGB32)\n                *image = QImage(width, height, QImage::Format_ARGB32);\n            if (!image->isNull()) {\n                const int stopOnError = 1;\n                if (TIFFReadRGBAImageOriented(tiff, width, height, reinterpret_cast<uint32 *>(image->bits()), ORIENTATION_TOPLEFT, stopOnError)) {\n                    for (uint32 y=0; y<height; ++y)\n                        convert32BitOrder(image->scanLine(y), width);\n                } else {\n                    TIFFClose(tiff);\n                    return false;\n                }\n            }\n        }\n    }\n\n    if (image->isNull()) {\n        TIFFClose(tiff);\n        return false;\n    }\n\n    float resX = 0;\n    float resY = 0;\n    uint16 resUnit = RESUNIT_NONE;\n    if (TIFFGetField(tiff, TIFFTAG_RESOLUTIONUNIT, &resUnit)\n        && TIFFGetField(tiff, TIFFTAG_XRESOLUTION, &resX)\n        && TIFFGetField(tiff, TIFFTAG_YRESOLUTION, &resY)) {\n\n        switch(resUnit) {\n        case RESUNIT_CENTIMETER:\n            image->setDotsPerMeterX(qRound(resX * 100));\n            image->setDotsPerMeterY(qRound(resY * 100));\n            break;\n        case RESUNIT_INCH:\n            image->setDotsPerMeterX(qRound(resX * (100 / 2.54)));\n            image->setDotsPerMeterY(qRound(resY * (100 / 2.54)));\n            break;\n        default:\n            // do nothing as defaults have already\n            // been set within the QImage class\n            break;\n        }\n    }\n\n    // rotate the image if the orientation is defined in the file\n    uint16 orientationTag;\n    if (TIFFGetField(tiff, TIFFTAG_ORIENTATION, &orientationTag)) {\n        if (image->format() == QImage::Format_ARGB32) {\n            // TIFFReadRGBAImageOriented() flip the image but does not rotate them\n            switch (orientationTag) {\n            case 5:\n                rotate_right_mirror_horizontal(image);\n                break;\n            case 6:\n                rotate_right_mirror_vertical(image);\n                break;\n            case 7:\n                rotate_right_mirror_horizontal(image);\n                break;\n            case 8:\n                rotate_right_mirror_vertical(image);\n                break;\n            }\n        } else {\n            switch (orientationTag) {\n            case 1: // default orientation\n                break;\n            case 2: // mirror horizontal\n                *image = image->mirrored(true, false);\n                break;\n            case 3: // mirror both\n                *image = image->mirrored(true, true);\n                break;\n            case 4: // mirror vertical\n                *image = image->mirrored(false, true);\n                break;\n            case 5: // rotate right mirror horizontal\n                {\n                    QMatrix transformation;\n                    transformation.rotate(90);\n                    *image = image->transformed(transformation);\n                    *image = image->mirrored(true, false);\n                    break;\n                }\n            case 6: // rotate right\n                {\n                    QMatrix transformation;\n                    transformation.rotate(90);\n                    *image = image->transformed(transformation);\n                    break;\n                }\n            case 7: // rotate right, mirror vertical\n                {\n                    QMatrix transformation;\n                    transformation.rotate(90);\n                    *image = image->transformed(transformation);\n                    *image = image->mirrored(false, true);\n                    break;\n                }\n            case 8: // rotate left\n                {\n                    QMatrix transformation;\n                    transformation.rotate(270);\n                    *image = image->transformed(transformation);\n                    break;\n                }\n            }\n        }\n    }\n\n\n    TIFFClose(tiff);\n    return true;\n}",
    "bool QTiffHandler::ensureHaveDirectoryCount() const\n{\n    if (d->directoryCount > 0)\n        return true;\n\n    TIFF *tiff = d->openInternal(\"rh\", device());\n\n    if (!tiff) {\n        device()->reset();\n        return false;\n    }\n\n    while (TIFFReadDirectory(tiff))\n      ++d->directoryCount;\n    TIFFClose(tiff);\n    device()->reset();\n    return true;\n}",
    "bool QTiffHandler::write(const QImage &image)\n{\n    if (!device()->isWritable())\n        return false;\n\n    TIFF *const tiff = TIFFClientOpen(\"foo\",\n                                      \"wB\",\n                                      this,\n                                      qtiffReadProc,\n                                      qtiffWriteProc,\n                                      qtiffSeekProc,\n                                      qtiffCloseProc,\n                                      qtiffSizeProc,\n                                      qtiffMapProc,\n                                      qtiffUnmapProc);\n    if (!tiff)\n        return false;\n\n    const int width = image.width();\n    const int height = image.height();\n\n    if (!TIFFSetField(tiff, TIFFTAG_IMAGEWIDTH, width)\n        || !TIFFSetField(tiff, TIFFTAG_IMAGELENGTH, height)\n        || !TIFFSetField(tiff, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG)) {\n        TIFFClose(tiff);\n        return false;\n    }\n\n    // set the resolution\n    bool  resolutionSet = false;\n    const int dotPerMeterX = image.dotsPerMeterX();\n    const int dotPerMeterY = image.dotsPerMeterY();\n    if ((dotPerMeterX % 100) == 0\n        && (dotPerMeterY % 100) == 0) {\n        resolutionSet = TIFFSetField(tiff, TIFFTAG_RESOLUTIONUNIT, RESUNIT_CENTIMETER)\n                        && TIFFSetField(tiff, TIFFTAG_XRESOLUTION, dotPerMeterX/100.0)\n                        && TIFFSetField(tiff, TIFFTAG_YRESOLUTION, dotPerMeterY/100.0);\n    } else {\n        resolutionSet = TIFFSetField(tiff, TIFFTAG_RESOLUTIONUNIT, RESUNIT_INCH)\n                        && TIFFSetField(tiff, TIFFTAG_XRESOLUTION, static_cast<float>(image.logicalDpiX()))\n                        && TIFFSetField(tiff, TIFFTAG_YRESOLUTION, static_cast<float>(image.logicalDpiY()));\n    }\n    if (!resolutionSet) {\n        TIFFClose(tiff);\n        return false;\n    }\n\n    // configure image depth\n    const QImage::Format format = image.format();\n    if (format == QImage::Format_Mono || format == QImage::Format_MonoLSB) {\n        uint16 photometric = PHOTOMETRIC_MINISBLACK;\n        if (image.colorTable().at(0) == 0xffffffff)\n            photometric = PHOTOMETRIC_MINISWHITE;\n        if (!TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, photometric)\n            || !TIFFSetField(tiff, TIFFTAG_COMPRESSION, compression == NoCompression ? COMPRESSION_NONE : COMPRESSION_CCITTRLE)\n            || !TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 1)) {\n            TIFFClose(tiff);\n            return false;\n        }\n\n        // try to do the conversion in chunks no greater than 16 MB\n        int chunks = (width * height / (1024 * 1024 * 16)) + 1;\n        int chunkHeight = qMax(height / chunks, 1);\n\n        int y = 0;\n        while (y < height) {\n            QImage chunk = image.copy(0, y, width, qMin(chunkHeight, height - y)).convertToFormat(QImage::Format_Mono);\n\n            int chunkStart = y;\n            int chunkEnd = y + chunk.height();\n            while (y < chunkEnd) {\n                if (TIFFWriteScanline(tiff, reinterpret_cast<uint32 *>(chunk.scanLine(y - chunkStart)), y) != 1) {\n                    TIFFClose(tiff);\n                    return false;\n                }\n                ++y;\n            }\n        }\n        TIFFClose(tiff);\n    } else if (format == QImage::Format_Indexed8) {\n        const QVector<QRgb> colorTable = image.colorTable();\n        bool isGrayscale = checkGrayscale(colorTable);\n        if (isGrayscale) {\n            uint16 photometric = PHOTOMETRIC_MINISBLACK;\n            if (image.colorTable().at(0) == 0xffffffff)\n                photometric = PHOTOMETRIC_MINISWHITE;\n            if (!TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, photometric)\n                    || !TIFFSetField(tiff, TIFFTAG_COMPRESSION, compression == NoCompression ? COMPRESSION_NONE : COMPRESSION_PACKBITS)\n                    || !TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 8)) {\n                TIFFClose(tiff);\n                return false;\n            }\n        } else {\n            if (!TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_PALETTE)\n                    || !TIFFSetField(tiff, TIFFTAG_COMPRESSION, compression == NoCompression ? COMPRESSION_NONE : COMPRESSION_PACKBITS)\n                    || !TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 8)) {\n                TIFFClose(tiff);\n                return false;\n            }\n            //// write the color table\n            // allocate the color tables\n            const int tableSize = colorTable.size();\n            Q_ASSERT(tableSize <= 256);\n            QVarLengthArray<uint16> redTable(tableSize);\n            QVarLengthArray<uint16> greenTable(tableSize);\n            QVarLengthArray<uint16> blueTable(tableSize);\n\n            // set the color table\n            for (int i = 0; i<tableSize; ++i) {\n                const QRgb color = colorTable.at(i);\n                redTable[i] = qRed(color) * 257;\n                greenTable[i] = qGreen(color) * 257;\n                blueTable[i] = qBlue(color) * 257;\n            }\n\n            const bool setColorTableSuccess = TIFFSetField(tiff, TIFFTAG_COLORMAP, redTable.data(), greenTable.data(), blueTable.data());\n\n            if (!setColorTableSuccess) {\n                TIFFClose(tiff);\n                return false;\n            }\n        }\n\n        //// write the data\n        // try to do the conversion in chunks no greater than 16 MB\n        int chunks = (width * height/ (1024 * 1024 * 16)) + 1;\n        int chunkHeight = qMax(height / chunks, 1);\n\n        int y = 0;\n        while (y < height) {\n            QImage chunk = image.copy(0, y, width, qMin(chunkHeight, height - y));\n\n            int chunkStart = y;\n            int chunkEnd = y + chunk.height();\n            while (y < chunkEnd) {\n                if (TIFFWriteScanline(tiff, reinterpret_cast<uint32 *>(chunk.scanLine(y - chunkStart)), y) != 1) {\n                    TIFFClose(tiff);\n                    return false;\n                }\n                ++y;\n            }\n        }\n        TIFFClose(tiff);\n\n    } else if (!image.hasAlphaChannel()) {\n        if (!TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB)\n            || !TIFFSetField(tiff, TIFFTAG_COMPRESSION, compression == NoCompression ? COMPRESSION_NONE : COMPRESSION_LZW)\n            || !TIFFSetField(tiff, TIFFTAG_SAMPLESPERPIXEL, 3)\n            || !TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 8)) {\n            TIFFClose(tiff);\n            return false;\n        }\n        // try to do the RGB888 conversion in chunks no greater than 16 MB\n        const int chunks = (width * height * 3 / (1024 * 1024 * 16)) + 1;\n        const int chunkHeight = qMax(height / chunks, 1);\n\n        int y = 0;\n        while (y < height) {\n            const QImage chunk = image.copy(0, y, width, qMin(chunkHeight, height - y)).convertToFormat(QImage::Format_RGB888);\n\n            int chunkStart = y;\n            int chunkEnd = y + chunk.height();\n            while (y < chunkEnd) {\n                if (TIFFWriteScanline(tiff, (void*)chunk.scanLine(y - chunkStart), y) != 1) {\n                    TIFFClose(tiff);\n                    return false;\n                }\n                ++y;\n            }\n        }\n        TIFFClose(tiff);\n    } else {\n        if (!TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB)\n            || !TIFFSetField(tiff, TIFFTAG_COMPRESSION, compression == NoCompression ? COMPRESSION_NONE : COMPRESSION_LZW)\n            || !TIFFSetField(tiff, TIFFTAG_SAMPLESPERPIXEL, 4)\n            || !TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 8)) {\n            TIFFClose(tiff);\n            return false;\n        }\n#if (QT_VERSION >= QT_VERSION_CHECK(5, 2, 0))\n        // try to do the RGBA8888 conversion in chunks no greater than 16 MB\n#else\n        // try to do the ARGB32 conversion in chunks no greater than 16 MB\n#endif\n        const int chunks = (width * height * 4 / (1024 * 1024 * 16)) + 1;\n        const int chunkHeight = qMax(height / chunks, 1);\n\n        int y = 0;\n        while (y < height) {\n#if (QT_VERSION >= QT_VERSION_CHECK(5, 2, 0))\n            const QImage chunk = image.copy(0, y, width, qMin(chunkHeight, height - y)).convertToFormat(QImage::Format_RGBA8888);\n#else\n            QImage chunk = image.copy(0, y, width, qMin(chunkHeight, height - y)).convertToFormat(QImage::Format_ARGB32);\n#endif\n\n            int chunkStart = y;\n            int chunkEnd = y + chunk.height();\n            while (y < chunkEnd) {\n#if (QT_VERSION < QT_VERSION_CHECK(5, 2, 0))\n                if (QSysInfo::ByteOrder == QSysInfo::LittleEndian)\n                    convert32BitOrder(chunk.scanLine(y - chunkStart), width);\n                else\n                    convert32BitOrderBigEndian(chunk.scanLine(y - chunkStart), width);\n#endif\n                if (TIFFWriteScanline(tiff, (void*)chunk.scanLine(y - chunkStart), y) != 1) {\n                    TIFFClose(tiff);\n                    return false;\n                }\n                ++y;\n            }\n        }\n        TIFFClose(tiff);\n    }\n\n    return true;\n}"
]