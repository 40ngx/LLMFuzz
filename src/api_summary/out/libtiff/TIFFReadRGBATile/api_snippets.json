[
    "bool  GrFmtTiffReader::ReadData( uchar* data, int step, int color )\n{\n\tbool result = false;\n\tuchar* buffer = 0;\n\n\tcolor = color > 0 || (color < 0 && m_iscolor);\n\n\tif( m_tif && m_width && m_height )\n\t{\n\t\tTIFF* tif = (TIFF*)m_tif;\n\t\tint tile_width0 = m_width, tile_height0 = 0;\n\t\tint x, y, i;\n\t\tint is_tiled = TIFFIsTiled(tif);\n\n\t\tif( !is_tiled &&\n\t\t\tTIFFGetField( tif, TIFFTAG_ROWSPERSTRIP, &tile_height0 ) ||\n\t\t\tis_tiled &&\n\t\t\tTIFFGetField( tif, TIFFTAG_TILEWIDTH, &tile_width0 ) &&\n\t\t\tTIFFGetField( tif, TIFFTAG_TILELENGTH, &tile_height0 ))\n\t\t{\n\t\t\tif( tile_width0 <= 0 )\n\t\t\t\ttile_width0 = m_width;\n\n\t\t\tif( tile_height0 <= 0 )\n\t\t\t\ttile_height0 = m_height;\n\n\t\t\tbuffer = new uchar[tile_height0*tile_width0*4];\n\n\t\t\tfor( y = 0; y < m_height; y += tile_height0, data += step*tile_height0 )\n\t\t\t{\n\t\t\t\tint tile_height = tile_height0;\n\n\t\t\t\tif( y + tile_height > m_height )\n\t\t\t\t\ttile_height = m_height - y;\n\n\t\t\t\tfor( x = 0; x < m_width; x += tile_width0 )\n\t\t\t\t{\n\t\t\t\t\tint tile_width = tile_width0, ok;\n\n\t\t\t\t\tif( x + tile_width > m_width )\n\t\t\t\t\t\ttile_width = m_width - x;\n\n\t\t\t\t\tif( !is_tiled )\n\t\t\t\t\t\tok = TIFFReadRGBAStrip( tif, y, (uint32*)buffer );\n\t\t\t\t\telse\n\t\t\t\t\t\tok = TIFFReadRGBATile( tif, x, y, (uint32*)buffer );\n\n\t\t\t\t\tif( !ok )\n\t\t\t\t\t\tgoto exit_func;\n\n\t\t\t\t\tfor( i = 0; i < tile_height; i++ )\n\t\t\t\t\t\tif( color )\n\t\t\t\t\t\t\ticvCvt_BGRA2BGR_8u_C4C3R( buffer + i*tile_width*4, 0,\n\t\t\t\t\t\t\t\t\t\t  data + x*3 + step*(tile_height - i - 1), 0,\n\t\t\t\t\t\t\t\t\t\t  cvSize(tile_width,1), 2 );\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\ticvCvt_BGRA2Gray_8u_C4C1R( buffer + i*tile_width*4, 0,\n\t\t\t\t\t\t\t\t\t\t\tdata + x + step*(tile_height - i - 1), 0,\n\t\t\t\t\t\t\t\t\t\t\tcvSize(tile_width,1), 2 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresult = true;\n\t\t}\n\t}\n\nexit_func:\n\n\tClose();\n\tdelete[] buffer;\n\n\treturn result;\n}",
    "bool ossimTiffTileSource::loadFromRgbaU8Tile(const ossimIrect &tile_rect,\n                                             const ossimIrect &clip_rect,\n                                             ossimImageData *result)\n{\n   static const char MODULE[] = \"ossimTiffTileSource::loadFromRgbaTile\";\n\n   if (theSamplesPerPixel != 3 || theBytesPerPixel != 1)\n   {\n      ossimNotify(ossimNotifyLevel_WARN)\n          << MODULE << \" Error:\"\n          << \"\\nInvalid number of bands or bytes per pixel!\" << endl;\n   }\n\n   //***\n   // Shift the upper left corner of the \"clip_rect\" to the an even tile\n   // boundary.  Note this will shift in the upper left direction.\n   //***\n   ossimIpt tileOrigin = clip_rect.ul();\n   adjustToStartOfTile(tileOrigin);\n\n   //---\n   // Calculate the number of tiles needed in the line/sample directions\n   // to fill the tile.\n   //---\n   ossim_uint32 tiles_in_v_dir = (clip_rect.lr().x - tileOrigin.x + 1) /\n                                 theInputTileSize[theCurrentDirectory].x;\n   ossim_uint32 tiles_in_u_dir = (clip_rect.lr().y - tileOrigin.y + 1) /\n                                 theInputTileSize[theCurrentDirectory].y;\n\n   if ((clip_rect.lr().x - tileOrigin.x + 1) %\n       theInputTileSize[theCurrentDirectory].x)\n      ++tiles_in_v_dir;\n   if ((clip_rect.lr().y - tileOrigin.y + 1) %\n       theInputTileSize[theCurrentDirectory].y)\n      ++tiles_in_u_dir;\n\n   ossimIpt ulTilePt = tileOrigin;\n\n#if 0\n   if (traceDebug())\n   {\n      CLOG << \"DEBUG:\"\n           << \"\\ntile_rect:  \" << tile_rect\n           << \"\\nclip_rect:  \" << clip_rect\n           << \"\\ntiles_in_v_dir:  \" << tiles_in_v_dir\n           << \"\\ntiles_in_u_dir:  \" << tiles_in_u_dir\n           << endl;\n   }\n#endif\n\n   // Tile loop in line direction.\n   for (ossim_uint32 u = 0; u < tiles_in_u_dir; u++)\n   {\n      ulTilePt.x = tileOrigin.x;\n\n      // Tile loop in sample direction.\n      for (ossim_uint32 v = 0; v < tiles_in_v_dir; v++)\n      {\n         ossimIrect tiff_tile_rect = ossimIrect(ulTilePt.x,\n                                                ulTilePt.y,\n                                                ulTilePt.x +\n                                                    theInputTileSize[theCurrentDirectory].x - 1,\n                                                ulTilePt.y +\n                                                    theInputTileSize[theCurrentDirectory].y - 1);\n\n         if (theBufferRLevel != getCurrentTiffRLevel() ||\n             tiff_tile_rect != theBufferRect)\n         {\n            // Need to grab a new tile.\n            // Read a tile into the buffer.\n            if (!TIFFReadRGBATile(theTiffPtr,\n                                  ulTilePt.x,\n                                  ulTilePt.y,\n                                  (uint32 *)theBuffer)) // use tiff typedef\n            {\n               ossimNotify(ossimNotifyLevel_WARN)\n                   << MODULE << \" Read Error!\"\n                   << \"\\nReturning error...\" << endl;\n               theErrorStatus = ossimErrorCodes::OSSIM_ERROR;\n               return false;\n            }\n\n            // Capture the rectangle.\n            theBufferRect = tiff_tile_rect;\n            theBufferRLevel = getCurrentTiffRLevel();\n         }\n\n         ossimIrect tile_clip_rect = clip_rect.clipToRect(theBufferRect);\n\n         //***\n         // Get the offset to the first valid pixel.\n         //\n         // Note: The data in the tile buffer is organized bottom up.  So the\n         //       coordinate must be negated in the line direction since\n         //       the met assumes an origin of upper left.\n         //***\n         ossim_uint32 in_buf_offset =\n             (tiff_tile_rect.lr().y - tile_clip_rect.ul().y) *\n                 theInputTileSize[theCurrentDirectory].x * 4 +\n             ((tile_clip_rect.ul().x - ulTilePt.x) * 4);\n\n         ossim_uint32 out_buf_offset =\n             (tile_clip_rect.ul().y - tile_rect.ul().y) *\n                 ((ossim_int32)result->getWidth()) +\n             tile_clip_rect.ul().x - tile_rect.ul().x;\n\n         //\n         // Get a pointer positioned at the first valid pixel in buffers.\n         //\n         ossim_uint32 *s = (ossim_uint32 *)(theBuffer + in_buf_offset); // s for source...\n                                                                        //         ossim_uint8* s = theBuffer + in_buf_offset;  // s for source...\n         ossim_uint8 *r = static_cast<ossim_uint8 *>(result->getBuf(0)) +\n                          out_buf_offset;\n         ossim_uint8 *g = static_cast<ossim_uint8 *>(result->getBuf(1)) +\n                          out_buf_offset;\n         ossim_uint8 *b = static_cast<ossim_uint8 *>(result->getBuf(2)) +\n                          out_buf_offset;\n\n         ossim_uint32 lines2copy = tile_clip_rect.lr().y - tile_clip_rect.ul().y + 1;\n         ossim_uint32 samps2copy = tile_clip_rect.lr().x - tile_clip_rect.ul().x + 1;\n\n         // Line loop through valid portion of the tiff tile.\n         for (ossim_uint32 line = 0; line < lines2copy; line++)\n         {\n            // Sample loop through the tiff tile.\n            ossim_uint32 i = 0;\n            ossim_uint32 j = 0;\n\n            // note the bands from the TIFF READ are stored in a, b, g, r ordering.\n            // we must reverse the bands and skip the first byte.\n            for (ossim_uint32 sample = 0; sample < samps2copy; sample++)\n            {\n               r[i] = (ossim_uint8)OSSIM_TIFF_UNPACK_R4(s[j]);\n               g[i] = (ossim_uint8)OSSIM_TIFF_UNPACK_G4(s[j]);\n               b[i] = (ossim_uint8)OSSIM_TIFF_UNPACK_B4(s[j]);\n               i++;\n               ++j;\n            }\n\n            // Increment the pointers by one line.\n            const ossim_uint32 OUTPUT_TILE_WIDTH = result->getWidth();\n            r += OUTPUT_TILE_WIDTH;\n            g += OUTPUT_TILE_WIDTH;\n            b += OUTPUT_TILE_WIDTH;\n            s -= theInputTileSize[theCurrentDirectory].x;\n         }\n\n         ulTilePt.x += theInputTileSize[theCurrentDirectory].x;\n\n      } // End of tile loop in the sample direction.\n\n      ulTilePt.y += theInputTileSize[theCurrentDirectory].y;\n\n   } // End of tile loop in the line direction.\n\n   return true;\n}",
    "jint * NativeDecoder::getSampledRasterFromTile(int inSampleSize, int *bitmapwidth, int *bitmapheight) {\n\n        //init signal handler for catch SIGSEGV error that could be raised in libtiff\n        struct sigaction act;\n        memset(&act, 0, sizeof(act));\n        sigemptyset(&act.sa_mask);\n        act.sa_sigaction = tileErrorHandler;\n        act.sa_flags = SA_SIGINFO | SA_ONSTACK;\n        if(sigaction(SIGSEGV, &act, 0) < 0) {\n            LOGE(\"Can\\'t setup signal handler. Working without errors catching mechanism\");\n        }\n\n        jint *pixels = NULL;\n        *bitmapwidth = origwidth / inSampleSize;\n        *bitmapheight = origheight / inSampleSize;\n        uint32 pixelsBufferSize = *bitmapwidth * *bitmapheight;\n\n        uint32 tileWidth = 0, tileHeight = 0;\n        TIFFGetField(image, TIFFTAG_TILEWIDTH, &tileWidth);\n        TIFFGetField(image, TIFFTAG_TILEWIDTH, &tileHeight);\n\n        unsigned long estimateMem = 0;\n        estimateMem += (sizeof(jint) * pixelsBufferSize); //buffer for decoded pixels\n        estimateMem += (tileWidth * tileHeight * sizeof(uint32)) * 3; //current, left and right tiles buffers\n        estimateMem += (tileWidth * sizeof(uint32)); //work line for rotate tile\n        LOGII(\"estimateMem\", estimateMem);\n        if (estimateMem > availableMemory) {\n            if (throwException) {\n                throw_not_enought_memory_exception(env, availableMemory, estimateMem);\n            }\n            return NULL;\n        }\n\n        pixels = (jint *) malloc(sizeof(jint) * pixelsBufferSize);\n        if (pixels == NULL) {\n            LOGE(\"Can\\'t allocate memory for temp buffer\");\n            return NULL;\n        }\n\n        uint32 row, column;\n\n        //main worker tile\n        uint32 *rasterTile = (uint32 *)_TIFFmalloc(tileWidth * tileHeight * sizeof(uint32));\n        //left tile\n        uint32 *rasterTileLeft = (uint32 *)_TIFFmalloc(tileWidth * tileHeight * sizeof(uint32));\n        //right tile\n        uint32 *rasterTileRight = (uint32 *)_TIFFmalloc(tileWidth * tileHeight * sizeof(uint32));\n\n        uint32 *work_line_buf = (uint32*)_TIFFmalloc(tileWidth * sizeof (uint32));\n\n        //this variable calculate processed pixels for x and y direction to make right offsets at the begining of next tile\n        //offset calculated from condition globalProcessed % inSampleSize should be 0\n        uint32 globalProcessedX = 0;\n        uint32 globalProcessedY = 0;\n\n        //check for error\n        if (setjmp(NativeDecoder::tile_buf)) {\n            if (rasterTile) {\n                _TIFFfree(rasterTile);\n                rasterTile = NULL;\n            }\n            if (rasterTileLeft) {\n                _TIFFfree(rasterTileLeft);\n                rasterTileLeft = NULL;\n            }\n            if (rasterTileRight) {\n                _TIFFfree(rasterTileRight);\n                rasterTileRight = NULL;\n            }\n            if (work_line_buf) {\n                _TIFFfree(work_line_buf);\n                work_line_buf = NULL;\n            }\n\n            const char * err = \"Caught SIGSEGV signal(Segmentation fault or invalid memory reference)\";\n            LOGE(err);\n            if (throwException) {\n                throwDecodeFileException(err);\n            }\n\n            return NULL;\n        }\n\n        for (row = 0; row < origheight; row += tileHeight) {\n            short leftTileExists = 0;\n            short rightTileExists = 0;\n            for (column = 0; column < origwidth; column += tileWidth) {\n                sendProgress(row * origwidth + column, progressTotal);\n\n                //If not first column - we should have previous tile - copy it to left tile buffer\n                if (column != 0) {\n                    _TIFFmemcpy(rasterTileLeft, rasterTile, tileWidth * tileHeight * sizeof(uint32));\n                    leftTileExists = 1;\n                } else {\n                    leftTileExists = 0;\n                }\n\n                //if current column + tile width is less than origin width - we have right tile - copy it to current tile and read next tile to rasterTileRight buffer\n                if (column + tileWidth < origwidth && rightTileExists) {\n                    _TIFFmemcpy(rasterTile, rasterTileRight, tileWidth * tileHeight * sizeof(uint32));\n                    TIFFReadRGBATile(image, column + tileWidth, row, rasterTileRight);\n                    rightTileExists = 1;\n                } else if (column + tileWidth < origwidth) {\n                    //have right tile but this is first tile in row, so need to read raster and right raster\n                    TIFFReadRGBATile(image, column + tileWidth, row, rasterTileRight);\n                    TIFFReadRGBATile(image, column, row, rasterTile);\n                    rightTileExists = 1;\n\n                    //in that case we also need to invert lines in rasterTile\n                    switch(origorientation) {\n                        case 1:\n                        case 5:\n                            rotateTileLinesVertical(tileHeight, tileWidth, rasterTile, work_line_buf);\n                            break;\n                        case 2:\n                        case 6:\n                            rotateTileLinesVertical(tileHeight, tileWidth, rasterTile, work_line_buf);\n                            rotateTileLinesHorizontal(tileHeight, tileWidth, rasterTile, work_line_buf);\n                            break;\n                        case 3:\n                        case 7:\n                            rotateTileLinesHorizontal(tileHeight, tileWidth, rasterTile, work_line_buf);\n                            break;\n                    }\n                } else {\n                    //otherwise we haven't right tile buffer, so we should read tile to current buffer\n                    TIFFReadRGBATile(image, column, row, rasterTile);\n                    rightTileExists = 0;\n                }\n\n                //if we have right tile - current tile already rotated and we need to rotate only right tile\n                if (rightTileExists) {\n                    switch(origorientation) {\n                        case 1:\n                        case 5:\n                            rotateTileLinesVertical(tileHeight, tileWidth, rasterTileRight, work_line_buf);\n                            break;\n                        case 2:\n                        case 6:\n                            rotateTileLinesVertical(tileHeight, tileWidth, rasterTileRight, work_line_buf);\n                            rotateTileLinesHorizontal(tileHeight, tileWidth, rasterTileRight, work_line_buf);\n                            break;\n                        case 3:\n                        case 7:\n                            rotateTileLinesHorizontal(tileHeight, tileWidth, rasterTileRight, work_line_buf);\n                            break;\n                    }\n                } else {\n                    //otherwise - current tile not rotated so rotate it\n                    //tile orig is on bottom left - should change lines\n                     switch(origorientation) {\n                        case 1:\n                        case 5:\n                            rotateTileLinesVertical(tileHeight, tileWidth, rasterTile, work_line_buf);\n                            break;\n                        case 2:\n                        case 6:\n                            rotateTileLinesVertical(tileHeight, tileWidth, rasterTile, work_line_buf);\n                            rotateTileLinesHorizontal(tileHeight, tileWidth, rasterTile, work_line_buf);\n                            break;\n                        case 3:\n                        case 7:\n                            rotateTileLinesHorizontal(tileHeight, tileWidth, rasterTile, work_line_buf);\n                            break;\n                    }\n                }\n\n                if (inSampleSize > 1 )\n                {\n                    //Tile could begin from not filled pixel(pixel[x,y] == 0). This variables allow to calculate begining of filled pixels\n                    int tileStartDataX = -1;\n                    int tileStartDataY = -1;\n\n                    for (int origTileY = 0, pixY = row/inSampleSize; origTileY < tileHeight && pixY < *bitmapheight; origTileY++) {\n\n                        if (checkStop()) {\n                            if (rasterTile) {\n                                _TIFFfree(rasterTile);\n                                rasterTile = NULL;\n                            }\n                            if (rasterTileLeft) {\n                                _TIFFfree(rasterTileLeft);\n                                rasterTileLeft = NULL;\n                            }\n                            if (rasterTileRight) {\n                                _TIFFfree(rasterTileRight);\n                                rasterTileRight = NULL;\n                            }\n                            if (work_line_buf) {\n                                _TIFFfree(work_line_buf);\n                                work_line_buf = NULL;\n                            }\n                            LOGI(\"Thread stopped\");\n                            return NULL;\n                        }\n\n                        if (tileStartDataY != -1 && globalProcessedY % inSampleSize != 0) {\n                            if (tileStartDataY != -1) {\n                                globalProcessedY++;\n                            }\n                        }\n                        else\n                        {\n                            for (int origTileX = 0, pixX = column/inSampleSize; origTileX < tileWidth && pixX < *bitmapwidth; origTileX++) {\n                                if (tileStartDataX != -1 && globalProcessedX % inSampleSize != 0)\n                                {\n                                    if (tileStartDataX != -1) {\n                                        globalProcessedX++;\n                                    }\n                                }\n                                else\n                                {\n                                    uint32 srcPosition = origTileY * tileWidth + origTileX;\n                                    if (rasterTile[srcPosition] != 0) {\n                                        if (tileStartDataX == -1) {\n                                            tileStartDataX = origTileX;\n                                        }\n                                        if (tileStartDataY == -1) {\n                                            tileStartDataY = origTileY;\n                                        }\n\n                                        //Apply filter to pixel\n                                        jint crPix = rasterTile[srcPosition];//origBuffer[j1 * origwidth + i1];\n                                        int sum = 1;\n\n                                        int alpha = colorMask & crPix >> 24;\n                                        int red = colorMask & crPix >> 16;\n                                        int green = colorMask & crPix >> 8;\n                                        int blue = colorMask & crPix;\n\n                                        //using kernel 3x3\n\n                                        //topleft\n                                        if (origTileX - 1 >= 0 && origTileY - 1 >= 0) {\n                                            crPix = rasterTile[(origTileY - 1) * tileWidth + origTileX - 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        } else if (origTileY - 1 >= 0 && leftTileExists) {\n                                            crPix = rasterTileLeft[(origTileY - 1) * tileWidth + tileWidth - 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        }\n\n                                        //top\n                                        if (origTileY - 1 >= 0) {\n                                            crPix = rasterTile[(origTileY - 1) * tileWidth + origTileX];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        }\n\n                                        // topright\n                                        if (origTileX + 1 < tileWidth && origTileY - 1 >= 0) {\n                                            crPix = rasterTile[(origTileY - 1) * tileWidth + origTileX + 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        } else if (origTileY - 1 >= 0 && rightTileExists) {\n                                            crPix = rasterTileRight[(origTileY - 1) * tileWidth];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        }\n\n                                        //right\n                                        if (origTileX + 1 < tileWidth) {\n                                            crPix = rasterTile[origTileY * tileWidth + origTileX + 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        } else if (rightTileExists) {\n                                            crPix = rasterTileRight[origTileY * tileWidth];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        }\n\n                                        //bottomright\n                                        if (origTileX + 1 < tileWidth && origTileY + 1 < tileHeight) {\n                                            crPix = rasterTile[(origTileY + 1) * tileWidth + origTileX + 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        } else if (origTileY + 1 < tileHeight && rightTileExists) {\n                                            crPix = rasterTileRight[(origTileY + 1) * tileWidth];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        }\n\n                                        //bottom\n                                        if (origTileY + 1 < tileHeight) {\n                                            crPix = rasterTile[(origTileY + 1) * tileWidth + origTileX];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        }\n\n                                        //bottomleft\n                                        if (origTileX - 1 >= 0 && origTileY + 1 < tileHeight) {\n                                            crPix = rasterTile[(origTileY + 1) * tileWidth + origTileX - 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        } else if (origTileY + 1 < tileHeight && leftTileExists) {\n                                            crPix = rasterTileLeft[(origTileY + 1) * tileWidth + tileWidth - 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        }\n\n                                        //left\n                                        if (origTileX - 1 >= 0) {\n                                            crPix = rasterTile[origTileY * tileWidth + origTileX - 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        } else if (leftTileExists) {\n                                            crPix = rasterTileLeft[origTileY * tileWidth + tileWidth - 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        }\n\n                                        red /= sum;\n                                        if (red > 255) red = 255;\n                                        if (red < 0) red = 0;\n\n                                        green /= sum;\n                                        if (green > 255) green = 255;\n                                        if (green < 0) green = 0;\n\n                                        blue /= sum;\n                                        if (blue > 255) blue = 255;\n                                        if (blue < 0) blue = 0;\n\n                                        alpha /= sum;///= sum;\n                                        if (alpha > 255) alpha = 255;\n                                        if (alpha < 0) alpha = 0;\n\n                                        crPix = (alpha << 24) | (red << 16) | (green << 8) | (blue);\n\n                                        int position;\n                                        if (origorientation <= 4) {\n                                            position = pixY * *bitmapwidth + pixX;\n                                        } else {\n                                            position = pixX * *bitmapheight + pixY;\n                                        }\n                                        pixels[position] = crPix;\n                                    } else {\n                                        if (tileStartDataX != -1) tileStartDataX = -1;\n                                        if (tileStartDataY != -1) tileStartDataY = -1;\n                                    }\n\n                                    if (tileStartDataX != -1) {\n                                        pixX++;\n                                        globalProcessedX++;\n                                    }\n\n                                }\n                            }\n                            if (tileStartDataY != -1) {\n                                pixY++;\n                                globalProcessedY++;\n                            }\n                        }\n                    }\n                } else {\n                    int rowHasPixels = 0;\n                        for (int th = 0, bh = 0; th < tileHeight; th++) {\n                            for (int tw = 0, bw = 0; tw < tileWidth; tw++) {\n                                uint32 srcPosition = th * tileWidth + tw;\n                                if (rasterTile[srcPosition] != 0) {\n                                    int position = 0;\n                                    if (origorientation <= 4) {\n                                        position = (row + bh) * *bitmapwidth + column + bw;\n                                    } else {\n                                        position = (column + bw) * *bitmapheight + row + bh;\n                                    }\n                                    pixels[position] = rasterTile[srcPosition];\n                                    rowHasPixels = 1;\n                                    bw++;\n                                }\n                            }\n                            if (rowHasPixels) {\n                                bh++;\n                                rowHasPixels = 0;\n                            }\n                        }\n                }\n            }\n        }\n\n        if (rasterTile) {\n            _TIFFfree(rasterTile);\n            rasterTile = NULL;\n        }\n        if (rasterTileLeft) {\n            _TIFFfree(rasterTileLeft);\n            rasterTileLeft = NULL;\n        }\n        if (rasterTileRight) {\n            _TIFFfree(rasterTileRight);\n            rasterTileRight = NULL;\n        }\n        if (work_line_buf) {\n            _TIFFfree(work_line_buf);\n            work_line_buf = NULL;\n        }\n\n        if (useOrientationTag) {\n            switch (origorientation) {\n                case ORIENTATION_TOPLEFT:\n                case ORIENTATION_LEFTTOP:\n                    break;\n                case ORIENTATION_TOPRIGHT:\n                    flipPixelsHorizontal(*bitmapwidth, *bitmapheight, pixels);\n                    break;\n                case ORIENTATION_RIGHTTOP:\n                    flipPixelsHorizontal(*bitmapheight, *bitmapwidth, pixels);\n                    break;\n                case ORIENTATION_BOTRIGHT:\n                case ORIENTATION_RIGHTBOT:\n                    rotateRaster(pixels, 180, bitmapwidth, bitmapheight);\n                    break;\n                case ORIENTATION_BOTLEFT:\n                    flipPixelsVertical(*bitmapwidth, *bitmapheight, pixels);\n                    break;\n                case ORIENTATION_LEFTBOT:\n                    flipPixelsVertical(*bitmapheight, *bitmapwidth, pixels);\n                    break;\n            }\n        } else {\n            if (origorientation > 4) {\n                uint32 buf = *bitmapwidth;\n                *bitmapwidth = *bitmapheight;\n                *bitmapheight = buf;\n                rotateRaster(pixels, 90, bitmapwidth, bitmapheight);\n                flipPixelsHorizontal(*bitmapwidth, *bitmapheight, pixels);\n            }\n        }\n\n        return pixels;\n}",
    "jint * NativeDecoder::getSampledRasterFromTileWithBounds(int inSampleSize, int *bitmapwidth, int *bitmapheight) {\n\n        //init signal handler for catch SIGSEGV error that could be raised in libtiff\n        struct sigaction act;\n        memset(&act, 0, sizeof(act));\n        sigemptyset(&act.sa_mask);\n        act.sa_sigaction = tileErrorHandler;\n        act.sa_flags = SA_SIGINFO | SA_ONSTACK;\n        if(sigaction(SIGSEGV, &act, 0) < 0) {\n            LOGE(\"Can\\'t setup signal handler. Working without errors catching mechanism\");\n        }\n\n\n        //First read all tiles that are on necessary area\n\n        uint32 tileWidth = 0, tileHeight = 0;\n        TIFFGetField(image, TIFFTAG_TILEWIDTH, &tileWidth);\n        TIFFGetField(image, TIFFTAG_TILEWIDTH, &tileHeight);\n\n        //find first and last tile to process\n        uint32 firstTileX = (uint32)(boundX / tileWidth);\n        uint32 firstTileY = (uint32)(boundY / tileHeight);\n\n        uint32 lastTileX = (uint32)((boundX + boundWidth) / tileWidth) + 1;\n        uint32 lastTileY = (uint32)((boundY + boundHeight) / tileHeight) + 1;\n\n        jint *pixels = NULL;\n        *bitmapwidth = /*boundWidth*/ (lastTileX - firstTileX) * tileWidth / inSampleSize;//origwidth / inSampleSize;\n        *bitmapheight = /*boundHeight*/ (lastTileY - firstTileY) * tileHeight / inSampleSize;//origheight / inSampleSize;\n        uint32 pixelsBufferSize = *bitmapwidth * *bitmapheight;\n\n         unsigned long estimateMem = 0;\n         estimateMem += (sizeof(jint) * pixelsBufferSize); //buffer for decoded pixels\n         estimateMem += (tileWidth * tileHeight * sizeof(uint32)) * 3; //current, left and right tiles buffers\n         estimateMem += (tileWidth * sizeof(uint32)); //work line for rotate tile\n         LOGII(\"estimateMem\", estimateMem);\n         if (estimateMem > availableMemory) {\n            if (throwException) {\n                throw_not_enought_memory_exception(env, availableMemory, estimateMem);\n            }\n            return NULL;\n         }\n\n        pixels = (jint *) malloc(sizeof(jint) * pixelsBufferSize);\n        if (pixels == NULL) {\n            LOGE(\"Can\\'t allocate memory for temp buffer\");\n            return NULL;\n        }\n\n        progressTotal = pixelsBufferSize + (boundWidth/inSampleSize) * (boundHeight/inSampleSize);\n        sendProgress(0, progressTotal);\n        jlong processedProgress = 0;\n\n        uint32 row, column, rowDest, columnDest;\n\n        //main worker tile\n        uint32 *rasterTile = (uint32 *)_TIFFmalloc(tileWidth * tileHeight * sizeof(uint32));\n        //left tile\n        uint32 *rasterTileLeft = (uint32 *)_TIFFmalloc(tileWidth * tileHeight * sizeof(uint32));\n        //right tile\n        uint32 *rasterTileRight = (uint32 *)_TIFFmalloc(tileWidth * tileHeight * sizeof(uint32));\n\n        uint32 *work_line_buf = (uint32*)_TIFFmalloc(tileWidth * sizeof (uint32));\n\n        //check for error\n        if (setjmp(NativeDecoder::tile_buf)) {\n            if (rasterTile) {\n                _TIFFfree(rasterTile);\n                rasterTile = NULL;\n            }\n            if (rasterTileLeft) {\n                _TIFFfree(rasterTileLeft);\n                rasterTileLeft = NULL;\n            }\n            if (rasterTileRight) {\n                _TIFFfree(rasterTileRight);\n                rasterTileRight = NULL;\n            }\n            if (work_line_buf) {\n                _TIFFfree(work_line_buf);\n                work_line_buf = NULL;\n            }\n\n        const char * err = \"Caught SIGSEGV signal(Segmentation fault or invalid memory reference)\";\n        LOGE(err);\n        if (throwException) {\n            throwDecodeFileException(err);\n        }\n\n            return NULL;\n        }\n\n        //this variable calculate processed pixels for x and y direction to make right offsets at the begining of next tile\n        //offset calculated from condition globalProcessed % inSampleSize should be 0\n        uint32 globalProcessedX = 0;\n        uint32 globalProcessedY = 0;\n\n        uint32 progressRow = 0;\n        uint32 progressColumn = 0;\n\n        rowDest = columnDest = 0;\n        for (row = firstTileY * tileHeight; row < lastTileY * tileHeight; row += tileHeight, progressRow += tileHeight) {\n            columnDest = 0;\n            short leftTileExists = 0;\n            short rightTileExists = 0;\n            for (column = firstTileX * tileWidth; column < lastTileX * tileWidth; column += tileWidth, progressColumn += tileWidth) {\n                processedProgress = progressRow * *bitmapwidth + progressColumn;\n                sendProgress(processedProgress, progressTotal);\n\n                //If not first column - we should have previous tile - copy it to left tile buffer\n                if (column != firstTileY) {\n                    _TIFFmemcpy(rasterTileLeft, rasterTile, tileWidth * tileHeight * sizeof(uint32));\n                    leftTileExists = 1;\n                } else {\n                    leftTileExists = 0;\n                }\n                //if current column + tile width is less than origin width - we have right tile - copy it to current tile and read next tile to rasterTileRight buffer\n                if (column + tileWidth < origwidth && rightTileExists) {\n                    _TIFFmemcpy(rasterTile, rasterTileRight, tileWidth * tileHeight * sizeof(uint32));\n                    TIFFReadRGBATile(image, column + tileWidth, row, rasterTileRight);\n                    rightTileExists = 1;\n                } else if (column + tileWidth < origwidth) {\n                    //have right tile but this is first tile in row, so need to read raster and right raster\n                    TIFFReadRGBATile(image, column + tileWidth, row, rasterTileRight);\n                    TIFFReadRGBATile(image, column, row, rasterTile);\n                    rightTileExists = 1;\n\n                    //in that case we also need to invert lines in rasterTile\n                    switch(origorientation) {\n                        case 1:\n                        case 5:\n                            rotateTileLinesVertical(tileHeight, tileWidth, rasterTile, work_line_buf);\n                            break;\n                        case 2:\n                        case 6:\n                            rotateTileLinesVertical(tileHeight, tileWidth, rasterTile, work_line_buf);\n                            rotateTileLinesHorizontal(tileHeight, tileWidth, rasterTile, work_line_buf);\n                            break;\n                        case 3:\n                        case 7:\n                            rotateTileLinesHorizontal(tileHeight, tileWidth, rasterTile, work_line_buf);\n                            break;\n                    }\n                } else {\n                    //otherwise we haven't right tile buffer, so we should read tile to current buffer\n                    TIFFReadRGBATile(image, column, row, rasterTile);\n                    rightTileExists = 0;\n                }\n\n                //if we have right tile - current tile already rotated and we need to rotate only right tile\n                if (rightTileExists) {\n                    switch(origorientation) {\n                        case 1:\n                        case 5:\n                            rotateTileLinesVertical(tileHeight, tileWidth, rasterTileRight, work_line_buf);\n                            break;\n                        case 2:\n                        case 6:\n                            rotateTileLinesVertical(tileHeight, tileWidth, rasterTileRight, work_line_buf);\n                            rotateTileLinesHorizontal(tileHeight, tileWidth, rasterTileRight, work_line_buf);\n                            break;\n                        case 3:\n                        case 7:\n                            rotateTileLinesHorizontal(tileHeight, tileWidth, rasterTileRight, work_line_buf);\n                            break;\n                    }\n                } else {\n                    //otherwise - current tile not rotated so rotate it\n                    //tile orig is on bottom left - should change lines\n                     switch(origorientation) {\n                        case 1:\n                        case 5:\n                            rotateTileLinesVertical(tileHeight, tileWidth, rasterTile, work_line_buf);\n                            break;\n                        case 2:\n                        case 6:\n                            rotateTileLinesVertical(tileHeight, tileWidth, rasterTile, work_line_buf);\n                            rotateTileLinesHorizontal(tileHeight, tileWidth, rasterTile, work_line_buf);\n                            break;\n                        case 3:\n                        case 7:\n                            rotateTileLinesHorizontal(tileHeight, tileWidth, rasterTile, work_line_buf);\n                            break;\n                    }\n                }\n\n                    //Tile could begin from not filled pixel(pixel[x,y] == 0). This variables allow to calculate begining of filled pixels\n                    int tileStartDataX = -1;\n                    int tileStartDataY = -1;\n\n                    for (int origTileY = 0, pixY = rowDest/inSampleSize; origTileY < tileHeight && pixY < *bitmapheight; origTileY++) {\n                        if (checkStop()) {\n                            if (rasterTile) {\n                                _TIFFfree(rasterTile);\n                                rasterTile = NULL;\n                            }\n                            if (rasterTileLeft) {\n                                _TIFFfree(rasterTileLeft);\n                                rasterTileLeft = NULL;\n                            }\n                            if (rasterTileRight) {\n                                _TIFFfree(rasterTileRight);\n                                rasterTileRight = NULL;\n                            }\n                            if (work_line_buf) {\n                                _TIFFfree(work_line_buf);\n                                work_line_buf = NULL;\n                            }\n                            LOGI(\"Thread stopped\");\n                            return NULL;\n                        }\n\n                        if (tileStartDataY != -1 && globalProcessedY % inSampleSize != 0) {\n                            if (tileStartDataY != -1) {\n                                globalProcessedY++;\n                            }\n                        }\n                        else\n                        {\n\n                            for (int origTileX = 0, pixX = columnDest/inSampleSize; origTileX < tileWidth && pixX < *bitmapwidth; origTileX++) {\n\n\n                                if (tileStartDataX != -1 && globalProcessedX % inSampleSize != 0)\n                                {\n                                    if (tileStartDataX != -1) {\n                                        globalProcessedX++;\n                                    }\n                                }\n                                else\n                                {\n                                    uint32 srcPosition = origTileY * tileWidth + origTileX;\n                                    if (rasterTile[srcPosition] != 0) {\n\n                                        if (tileStartDataX == -1) {\n                                            tileStartDataX = origTileX;\n                                        }\n                                        if (tileStartDataY == -1) {\n                                            tileStartDataY = origTileY;\n                                        }\n\n                                        //Apply filter to pixel\n                                        jint crPix = rasterTile[srcPosition];//origBuffer[j1 * origwidth + i1];\n                                        int sum = 1;\n\n                                        int alpha = colorMask & crPix >> 24;\n                                        int red = colorMask & crPix >> 16;\n                                        int green = colorMask & crPix >> 8;\n                                        int blue = colorMask & crPix;\n\n                                        //using kernel 3x3\n\n                                        //topleft\n                                        if (origTileX - 1 >= 0 && origTileY - 1 >= 0) {\n                                            crPix = rasterTile[(origTileY - 1) * tileWidth + origTileX - 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        } else if (origTileY - 1 >= 0 && leftTileExists) {\n                                            crPix = rasterTileLeft[(origTileY - 1) * tileWidth + tileWidth - 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        }\n\n                                        //top\n                                        if (origTileY - 1 >= 0) {\n                                            crPix = rasterTile[(origTileY - 1) * tileWidth + origTileX];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        }\n\n                                        // topright\n                                        if (origTileX + 1 < tileWidth && origTileY - 1 >= 0) {\n                                            crPix = rasterTile[(origTileY - 1) * tileWidth + origTileX + 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        } else if (origTileY - 1 >= 0 && rightTileExists) {\n                                            crPix = rasterTileRight[(origTileY - 1) * tileWidth];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        }\n\n                                        //right\n                                        if (origTileX + 1 < tileWidth) {\n                                            crPix = rasterTile[origTileY * tileWidth + origTileX + 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        } else if (rightTileExists) {\n                                            crPix = rasterTileRight[origTileY * tileWidth];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        }\n\n                                        //bottomright\n                                        if (origTileX + 1 < tileWidth && origTileY + 1 < tileHeight) {\n                                            crPix = rasterTile[(origTileY + 1) * tileWidth + origTileX + 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        } else if (origTileY + 1 < tileHeight && rightTileExists) {\n                                            crPix = rasterTileRight[(origTileY + 1) * tileWidth];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        }\n\n                                        //bottom\n                                        if (origTileY + 1 < tileHeight) {\n                                            crPix = rasterTile[(origTileY + 1) * tileWidth + origTileX];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        }\n\n                                        //bottomleft\n                                        if (origTileX - 1 >= 0 && origTileY + 1 < tileHeight) {\n                                            crPix = rasterTile[(origTileY + 1) * tileWidth + origTileX - 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        } else if (origTileY + 1 < tileHeight && leftTileExists) {\n                                            crPix = rasterTileLeft[(origTileY + 1) * tileWidth + tileWidth - 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        }\n\n                                        //left\n                                        if (origTileX - 1 >= 0) {\n                                            crPix = rasterTile[origTileY * tileWidth + origTileX - 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        } else if (leftTileExists) {\n                                            crPix = rasterTileLeft[origTileY * tileWidth + tileWidth - 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        }\n\n                                        red /= sum;\n                                        if (red > 255) red = 255;\n                                        if (red < 0) red = 0;\n\n                                        green /= sum;\n                                        if (green > 255) green = 255;\n                                        if (green < 0) green = 0;\n\n                                        blue /= sum;\n                                        if (blue > 255) blue = 255;\n                                        if (blue < 0) blue = 0;\n\n                                        alpha /= sum;///= sum;\n                                        if (alpha > 255) alpha = 255;\n                                        if (alpha < 0) alpha = 0;\n\n                                        crPix = (alpha << 24) | (red << 16) | (green << 8) | (blue);\n\n                                        int position;\n                                        if (origorientation <= 4) {\n                                            position = pixY * *bitmapwidth + pixX;\n                                        } else {\n                                            position = pixX * *bitmapheight + pixY;\n                                        }\n                                        pixels[position] = crPix;\n                                    } else {\n                                        if (tileStartDataX != -1) tileStartDataX = -1;\n                                        if (tileStartDataY != -1) tileStartDataY = -1;\n                                    }\n\n                                    if (tileStartDataX != -1) {\n                                        pixX++;\n                                        globalProcessedX++;\n                                    }\n\n                                }\n                            }\n                            if (tileStartDataY != -1) {\n                                pixY++;\n                                globalProcessedY++;\n                            }\n                        }\n                    }\n                columnDest += tileWidth;\n            }\n            rowDest += tileHeight;\n        }\n\n        if (rasterTile) {\n            _TIFFfree(rasterTile);\n            rasterTile = NULL;\n        }\n        if (rasterTileLeft) {\n            _TIFFfree(rasterTileLeft);\n            rasterTileLeft = NULL;\n        }\n        if (rasterTileRight) {\n            _TIFFfree(rasterTileRight);\n            rasterTileRight = NULL;\n        }\n        if (work_line_buf) {\n            _TIFFfree(work_line_buf);\n            work_line_buf = NULL;\n        }\n\n        //Copy necessary pixels to new array if orientation <=4\n        uint32 tmpPixelBufferSize = (boundWidth / inSampleSize) * (boundHeight / inSampleSize);\n\n        estimateMem = (sizeof(jint) * pixelsBufferSize); //buffer for decoded pixels\n        estimateMem += (sizeof(jint) * tmpPixelBufferSize); //finall buffer\n        LOGII(\"estimateMem\", estimateMem);\n        if (estimateMem > availableMemory) {\n            if (throwException) {\n                throw_not_enought_memory_exception(env, availableMemory, estimateMem);\n            }\n            return NULL;\n        }\n\n        if (origorientation <= 4) {\n\n            jint* tmpPixels = (jint *) malloc(sizeof(jint) * tmpPixelBufferSize);\n            uint32 startPosX = boundX%tileWidth /inSampleSize;//(firstTileX * tileWidth - tileWidth + boundX) / inSampleSize;\n            uint32 startPosY = boundY%tileHeight /inSampleSize;//(firstTileY * tileHeight - tileHeight + boundY) /inSampleSize;\n            for (int ox = startPosX, nx = 0; nx < boundWidth/inSampleSize; ox++, nx++) {\n                sendProgress(processedProgress + nx * (boundHeight/inSampleSize), progressTotal);\n                for (int oy = startPosY, ny = 0; ny < boundHeight/inSampleSize; oy++, ny++) {\n                    tmpPixels[ny * (boundWidth/inSampleSize) + nx] = pixels[oy * *bitmapwidth + ox];\n                }\n            }\n\n            free(pixels);\n            pixels = tmpPixels;\n            *bitmapwidth = boundWidth/inSampleSize;\n            *bitmapheight = boundHeight/inSampleSize;\n        }\n\n        if (useOrientationTag) {\n            switch (origorientation) {\n                case ORIENTATION_TOPLEFT:\n                case ORIENTATION_LEFTTOP:\n                    break;\n                case ORIENTATION_TOPRIGHT:\n                    flipPixelsHorizontal(*bitmapwidth, *bitmapheight, pixels);\n                    break;\n                case ORIENTATION_RIGHTTOP:\n                    flipPixelsHorizontal(*bitmapheight, *bitmapwidth, pixels);\n                    break;\n                case ORIENTATION_BOTRIGHT:\n                case ORIENTATION_RIGHTBOT:\n                    rotateRaster(pixels, 180, bitmapwidth, bitmapheight);\n                    break;\n                case ORIENTATION_BOTLEFT:\n                    flipPixelsVertical(*bitmapwidth, *bitmapheight, pixels);\n                    break;\n                case ORIENTATION_LEFTBOT:\n                    flipPixelsVertical(*bitmapheight, *bitmapwidth, pixels);\n                    break;\n            }\n        } else {\n            if (origorientation > 4) {\n                uint32 buf = *bitmapwidth;\n                *bitmapwidth = *bitmapheight;\n                *bitmapheight = buf;\n                rotateRaster(pixels, 90, bitmapwidth, bitmapheight);\n                flipPixelsHorizontal(*bitmapwidth, *bitmapheight, pixels);\n            }\n        }\n\n        //Copy necessary pixels to new array if orientation >4\n        if (origorientation > 4) {\n            jint* tmpPixels = (jint *) malloc(sizeof(jint) * tmpPixelBufferSize);\n            uint32 startPosX = boundX%tileWidth /inSampleSize;\n            uint32 startPosY = boundY%tileHeight /inSampleSize;\n            for (int ox = startPosX, nx = 0; nx < boundWidth/inSampleSize; ox++, nx++) {\n                sendProgress(processedProgress + nx * (boundHeight/inSampleSize), progressTotal);\n                for (int oy = startPosY, ny = 0; ny < boundHeight/inSampleSize; oy++, ny++) {\n                    if (useOrientationTag) {\n                        tmpPixels[nx * (boundHeight/inSampleSize) + ny] = pixels[ox * *bitmapheight + oy];\n                    } else {\n                        tmpPixels[ny * (boundWidth/inSampleSize) + nx] = pixels[oy * *bitmapwidth + ox];\n                    }\n                }\n            }\n\n            free(pixels);\n            pixels = tmpPixels;\n            *bitmapwidth = boundWidth/inSampleSize;\n            *bitmapheight = boundHeight/inSampleSize;\n        }\n\n        return pixels;\n}",
    "jboolean TiffToPngConverter::convertFromTile() {\n    uint32 tileWidth = 0, tileHeight = 0;\n    TIFFGetField(tiffImage, TIFFTAG_TILEWIDTH, &tileWidth);\n    TIFFGetField(tiffImage, TIFFTAG_TILEWIDTH, &tileHeight);\n    LOGII(\"Tile width\", tileWidth);\n    LOGII(\"Tile height\", tileHeight);\n\n    //uint32 *raster = (uint32 *)_TIFFmalloc(width * tileHeight * sizeof(uint32));\n    uint32 workingWidth = (width/tileWidth + (width%tileWidth == 0 ? 0 : 1)) * tileWidth;\n    LOGII(\"workingWidth \", workingWidth );\n    uint32 rasterSize =  workingWidth  * tileHeight ;\n    LOGII(\"rasterSize \", rasterSize );\n    //uint32 *raster = (uint32 *)_TIFFmalloc(rasterSize * sizeof(uint32));\n\n\n    unsigned long estimateMem = rasterSize * sizeof(uint32); //raster\n    estimateMem += tileWidth * tileHeight * sizeof(uint32); //tile raster\n    estimateMem += tileWidth * sizeof (uint32); //working buf\n    estimateMem += 4 * outWidth * sizeof(png_bytep); //bufer for writing to png\n    LOGII(\"estimateMem\", estimateMem);\n    if (estimateMem > availableMemory && availableMemory != -1) {\n        LOGEI(\"Not enought memory\", availableMemory);\n        if (throwException) {\n            throw_not_enought_memory_exception(env, availableMemory, estimateMem);\n        }\n        return JNI_FALSE;\n    }\n\n    uint32 *rasterTile = (uint32 *)_TIFFmalloc(tileWidth * tileHeight * sizeof(uint32));\n    uint32 *work_line_buf = (uint32*)_TIFFmalloc(tileWidth * sizeof (uint32));\n\n    jlong total = ((width/tileWidth + (width%tileWidth == 0 ? 0 : 1)) * tileWidth)\n                * ((height/tileHeight + (height%tileHeight == 0 ? 0 : 1)) * tileHeight);\n        sendProgress(0, total);\n\n    uint32 row, column;\n\n    int startx = -1, starty = -1, endx = -1, endy = -1;\n    uint32 imageWritedLines = 0;\n\n    for (row = 0; row < height; row += tileHeight) {\n        sendProgress(row * width, total);\n        endy = -1;\n        starty = -1;\n        uint32 *raster = (uint32 *)_TIFFmalloc(rasterSize * sizeof(uint32));\n\n        for (column = 0; column < width; column += tileWidth) {\n            if (checkStop()) {\n                free(raster);\n                raster = NULL;\n                if (rasterTile) {\n                    _TIFFfree(rasterTile);\n                    rasterTile = NULL;\n                }\n                if (work_line_buf) {\n                    _TIFFfree(rasterTile);\n                    work_line_buf = NULL;\n                }\n                return JNI_FALSE;\n            }\n            endx = -1;\n            startx = -1;\n            TIFFReadRGBATile(tiffImage, column , row, rasterTile);\n            switch(origorientation) {\n                case 1:\n                case 5:\n                    rotateTileLinesVertical(tileHeight, tileWidth, rasterTile, work_line_buf);\n                    break;\n                case 2:\n                case 6:\n                    rotateTileLinesVertical(tileHeight, tileWidth, rasterTile, work_line_buf);\n                    rotateTileLinesHorizontal(tileHeight, tileWidth, rasterTile, work_line_buf);\n                    break;\n                case 3:\n                case 7:\n                {\n                    rotateTileLinesHorizontal(tileHeight, tileWidth, rasterTile, work_line_buf);\n\n                    break;\n                    }\n            }\n\n            normalizeTile(tileHeight, tileWidth, rasterTile);\n\n\n            //find start and end position\n            for (int ty = 0; ty < tileHeight; ty++) {\n\n                for (int tx = 0; tx < tileWidth; tx++) {\n                    if (rasterTile[ty * tileWidth + tx] != 0) {\n                        if (startx == -1) {\n                            startx = tx;\n                        }\n                        if (starty == -1) {\n                            starty = ty;\n                        }\n\n                        if (tx > endx)\n                            endx = tx;\n                        if (ty > endy)\n                            endy = ty;\n\n                        uint32 rasterPos = (ty ) * workingWidth + (tx + column);\n                        //LOGII(\"rp\", rasterPos);\n                        raster[rasterPos] = rasterTile[ty * tileWidth + tx];\n                    }\n\n                }\n            }\n        }\n\n        int outY, outX;\n        for (int y = starty; y < tileHeight; y++) {\n            if (imageWritedLines == height) break;\n            if (y + row < outStartY || y + row >= outStartY + outHeight) continue;\n            outY = y + row - outStartY;\n            //create temp raster and write there pixels than not null\n            png_bytep pngrow = (png_bytep)malloc(4 * outWidth * sizeof(png_bytep));\n            memcpy(pngrow, raster + y * workingWidth + outStartX, outWidth * 4);\n            //memcpy(pngrow, rasterLine, width * 4);\n            png_write_row(png_ptr, pngrow);\n            free(pngrow);\n            //delete(rasterLine);\n            imageWritedLines++;\n        }\n        //LOGII(\"imageWritedLines\", imageWritedLines);\n\n        free(raster);\n\n    }\n\n    /*if (raster) {\n        _TIFFfree(raster);\n        raster = NULL;\n    }*/\n\n    if (rasterTile) {\n        _TIFFfree(rasterTile);\n        rasterTile = NULL;\n    }\n\n    if (work_line_buf) {\n        _TIFFfree(rasterTile);\n        work_line_buf = NULL;\n    }\n\n    sendProgress(total, total);\n\n    return JNI_TRUE;\n\n}",
    "jboolean TiffToBmpConverter::convertFromTile() {\n    uint32 tileWidth = 0, tileHeight = 0;\n    TIFFGetField(tiffImage, TIFFTAG_TILEWIDTH, &tileWidth);\n    TIFFGetField(tiffImage, TIFFTAG_TILEWIDTH, &tileHeight);\n    LOGII(\"Tile width\", tileWidth);\n    LOGII(\"Tile height\", tileHeight);\n\n    uint32 workingWidth = (width/tileWidth + (width%tileWidth == 0 ? 0 : 1)) * tileWidth;\n    LOGII(\"workingWidth \", workingWidth );\n    uint32 rasterSize =  workingWidth  * tileHeight ;\n    LOGII(\"rasterSize \", rasterSize );\n\n\n    unsigned long estimateMem = rasterSize * sizeof(uint32); //raster\n    estimateMem += tileWidth * tileHeight * sizeof(uint32); //tile raster\n    estimateMem += tileWidth * sizeof (uint32); //working buf\n    estimateMem += width * 3 + width % 4; //bufer for writing scanline to bmp\n    LOGII(\"estimateMem\", estimateMem);\n    if (estimateMem > availableMemory && availableMemory != -1) {\n        LOGEI(\"Not enought memory\", availableMemory);\n        if (throwException) {\n            throw_not_enought_memory_exception(env, availableMemory, estimateMem);\n        }\n        return JNI_FALSE;\n    }\n\n    uint32 *rasterTile = (uint32 *)_TIFFmalloc(tileWidth * tileHeight * sizeof(uint32));\n    uint32 *work_line_buf = (uint32*)_TIFFmalloc(tileWidth * sizeof (uint32));\n\n     jlong total = ((width/tileWidth + (width%tileWidth == 0 ? 0 : 1)) * tileWidth)\n                * ((height/tileHeight + (height%tileHeight == 0 ? 0 : 1)) * tileHeight);\n        sendProgress(0, total);\n\n    uint32 row, column;\n\n    int startx = -1, starty = -1, endx = -1, endy = -1;\n    uint32 imageWritedLines = 0;\n\n    //24 bpp bmp should has with multiple 4\n    int scanlineSize = outWidth * 3 + outWidth % 4;\n    unsigned char *scanline = new unsigned char[scanlineSize];\n\n    for (row = 0; row < height; row += tileHeight) {\n        sendProgress(row * width, total);\n        endy = -1;\n        starty = -1;\n        uint32 *raster = (uint32 *)_TIFFmalloc(rasterSize * sizeof(uint32));\n\n        for (column = 0; column < width; column += tileWidth) {\n            if (checkStop()) {\n                free(raster);\n                raster = NULL;\n                if (rasterTile) {\n                    _TIFFfree(rasterTile);\n                    rasterTile = NULL;\n                }\n                if (work_line_buf) {\n                    _TIFFfree(rasterTile);\n                    work_line_buf = NULL;\n                }\n                return JNI_FALSE;\n            }\n            endx = -1;\n            startx = -1;\n            TIFFReadRGBATile(tiffImage, column , row, rasterTile);\n            switch(origorientation) {\n                case 1:\n                case 5:\n                    rotateTileLinesVertical(tileHeight, tileWidth, rasterTile, work_line_buf);\n                    break;\n                case 2:\n                case 6:\n                    rotateTileLinesVertical(tileHeight, tileWidth, rasterTile, work_line_buf);\n                    rotateTileLinesHorizontal(tileHeight, tileWidth, rasterTile, work_line_buf);\n                    break;\n                case 3:\n                case 7:\n                    rotateTileLinesHorizontal(tileHeight, tileWidth, rasterTile, work_line_buf);\n                    break;\n            }\n\n            normalizeTile(tileHeight, tileWidth, rasterTile);\n\n            //find start and end position\n            for (int ty = 0; ty < tileHeight; ty++) {\n\n                for (int tx = 0; tx < tileWidth; tx++) {\n                    if (rasterTile[ty * tileWidth + tx] != 0) {\n                        if (startx == -1) {\n                            startx = tx;\n                        }\n                        if (starty == -1) {\n                            starty = ty;\n                        }\n\n                        if (tx > endx)\n                            endx = tx;\n                        if (ty > endy)\n                            endy = ty;\n\n                        uint32 rasterPos = (ty ) * workingWidth + (tx + column);\n                        //LOGII(\"rp\", rasterPos);\n                        raster[rasterPos] = rasterTile[ty * tileWidth + tx];\n                    }\n\n                }\n            }\n        }\n\n        int outY, outX;\n        int tileShift = 0;\n        for (int y = starty; y < tileHeight; y++) {\n            if (imageWritedLines == height) break;\n            if (y + row < outStartY || y + row >= outStartY + outHeight) continue;\n            outY = y + row - outStartY;\n            for (int x = 0; x < width * 3; x += 3) {\n                if (x < outStartX * 3 || x >= (outStartX + outWidth) * 3) continue;\n                outX = x - (outStartX*3);\n                uint32 pix = raster[y * workingWidth + x/3];\n                unsigned char *vp = (unsigned char *)&pix;\n                scanline[outX] = vp[2];\n                scanline[outX+1] = vp[1];\n                scanline[outX+2] = vp[0];\n            }\n\n            //in bmp lines stored fliped verticaly. Write lines from bottom to top\n            fseek(outFIle, 122 + (/*height - tileShift - row*/outHeight - outY - 1) * scanlineSize , SEEK_SET);\n            fwrite(scanline,scanlineSize,1,outFIle);\n            tileShift++;\n            imageWritedLines++;\n        }\n        //LOGII(\"imageWritedLines\", imageWritedLines);\n        free(raster);\n    }\n    free(scanline);\n\n    if (rasterTile) {\n        _TIFFfree(rasterTile);\n        rasterTile = NULL;\n    }\n\n    if (work_line_buf) {\n        _TIFFfree(rasterTile);\n        work_line_buf = NULL;\n    }\n\n    sendProgress(total, total);\n    return JNI_TRUE;\n\n}",
    "jboolean TiffToJpgConverter::convertFromTile() {\n    uint32 tileWidth = 0, tileHeight = 0;\n    TIFFGetField(tiffImage, TIFFTAG_TILEWIDTH, &tileWidth);\n    TIFFGetField(tiffImage, TIFFTAG_TILEWIDTH, &tileHeight);\n    LOGII(\"Tile width\", tileWidth);\n    LOGII(\"Tile height\", tileHeight);\n\n    //uint32 *raster = (uint32 *)_TIFFmalloc(width * tileHeight * sizeof(uint32));\n    uint32 workingWidth = (width/tileWidth + (width%tileWidth == 0 ? 0 : 1)) * tileWidth;\n    LOGII(\"workingWidth \", workingWidth );\n    uint32 rasterSize =  workingWidth  * tileHeight ;\n    LOGII(\"rasterSize \", rasterSize );\n    //uint32 *raster = (uint32 *)_TIFFmalloc(rasterSize * sizeof(uint32));\n\n\n    unsigned long estimateMem = rasterSize * sizeof(uint32); //raster\n    estimateMem += tileWidth * tileHeight * sizeof(uint32); //tile raster\n    estimateMem += tileWidth * sizeof (uint32); //working buf\n    estimateMem += outWidth * sizeof(unsigned char) * 3; //bufer for writing to jpg\n    LOGII(\"estimateMem\", estimateMem);\n    if (estimateMem > availableMemory && availableMemory != -1) {\n        LOGEI(\"Not enought memory\", availableMemory);\n        if (throwException) {\n            throw_not_enought_memory_exception(env, availableMemory, estimateMem);\n        }\n        return JNI_FALSE;\n    }\n\n    uint32 *rasterTile = (uint32 *)_TIFFmalloc(tileWidth * tileHeight * sizeof(uint32));\n    uint32 *work_line_buf = (uint32*)_TIFFmalloc(tileWidth * sizeof (uint32));\n\n     jlong total = ((width/tileWidth + (width%tileWidth == 0 ? 0 : 1)) * tileWidth)\n                * ((height/tileHeight + (height%tileHeight == 0 ? 0 : 1)) * tileHeight);\n        sendProgress(0, total);\n\n    uint32 row, column;\n\n    int startx = -1, starty = -1, endx = -1, endy = -1;\n    uint32 imageWritedLines = 0;\n\n    for (row = 0; row < height; row += tileHeight) {\n        sendProgress(row * width, total);\n        endy = -1;\n        starty = -1;\n        uint32 *raster = (uint32 *)_TIFFmalloc(rasterSize * sizeof(uint32));\n\n        for (column = 0; column < width; column += tileWidth) {\n            if (checkStop()) {\n                free(raster);\n                raster = NULL;\n                if (rasterTile) {\n                    _TIFFfree(rasterTile);\n                    rasterTile = NULL;\n                }\n                if (work_line_buf) {\n                    _TIFFfree(rasterTile);\n                    work_line_buf = NULL;\n                }\n                return JNI_FALSE;\n            }\n            endx = -1;\n            startx = -1;\n            TIFFReadRGBATile(tiffImage, column , row, rasterTile);\n            switch(origorientation) {\n                case 1:\n                case 5:\n                    rotateTileLinesVertical(tileHeight, tileWidth, rasterTile, work_line_buf);\n                    break;\n                case 2:\n                case 6:\n                    rotateTileLinesVertical(tileHeight, tileWidth, rasterTile, work_line_buf);\n                    rotateTileLinesHorizontal(tileHeight, tileWidth, rasterTile, work_line_buf);\n                    break;\n                case 3:\n                case 7:\n                    rotateTileLinesHorizontal(tileHeight, tileWidth, rasterTile, work_line_buf);\n                    break;\n            }\n\n            normalizeTile(tileHeight, tileWidth, rasterTile);\n\n            //find start and end position\n            for (int ty = 0; ty < tileHeight; ty++) {\n\n                for (int tx = 0; tx < tileWidth; tx++) {\n                    if (rasterTile[ty * tileWidth + tx] != 0) {\n                        if (startx == -1) {\n                            startx = tx;\n                        }\n                        if (starty == -1) {\n                            starty = ty;\n                        }\n\n                        if (tx > endx)\n                            endx = tx;\n                        if (ty > endy)\n                            endy = ty;\n\n                        uint32 rasterPos = (ty ) * workingWidth + (tx + column);\n                        //LOGII(\"rp\", rasterPos);\n                        raster[rasterPos] = rasterTile[ty * tileWidth + tx];\n                    }\n\n                }\n            }\n        }\n\n        int outY, outX;\n        JSAMPROW row_pointer[1];\n        for (int y = starty; y < tileHeight; y++) {\n            if (imageWritedLines == height) break;\n            if (y + row < outStartY || y + row >= outStartY + outHeight) continue;\n            outY = y + row - outStartY;\n            unsigned char *jpgrow = (unsigned char*)malloc(outWidth * sizeof(unsigned char) * 3);\n\n           // uint32 *rasterLine = (uint32 *)malloc(width * sizeof(uint32));\n\n            //for (int x = startx, x2 = 0; x2 < width; x++, x2++) {\n            //   rasterLine[x2] = raster[y * workingWidth + x];\n            //}\n\n            for (int x = 0; x < width * 3; x += 3) {\n                if (x < outStartX * 3 || x >= (outStartX + outWidth) * 3) continue;\n                outX = x - (outStartX*3);\n                uint32 pix = raster[y * workingWidth + x/3];\n                unsigned char *vp = (unsigned char *)&pix;\n                jpgrow[outX] = vp[0];\n                jpgrow[outX+1] = vp[1];\n                jpgrow[outX+2] = vp[2];\n            }\n            row_pointer[0] = jpgrow;\n            jpeg_write_scanlines(&cinfo, row_pointer, 1);\n            delete(jpgrow);\n            //delete(rasterLine);\n\n            imageWritedLines++;\n        }\n        //LOGII(\"imageWritedLines\", imageWritedLines);\n        free(raster);\n    }\n\n    /*if (raster) {\n        _TIFFfree(raster);\n        raster = NULL;\n    }*/\n\n    if (rasterTile) {\n        _TIFFfree(rasterTile);\n        rasterTile = NULL;\n    }\n\n    if (work_line_buf) {\n        _TIFFfree(rasterTile);\n        work_line_buf = NULL;\n    }\n\n    sendProgress(total, total);\n    return JNI_TRUE;\n\n}",
    "bool  TiffDecoder::readData( Mat& img )\n{\n    int type = img.type();\n    int depth = CV_MAT_DEPTH(type);\n\n    CV_Assert(!m_tif.empty());\n    TIFF* tif = (TIFF*)m_tif.get();\n\n    uint16 photometric = (uint16)-1;\n    CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric));\n\n    if (m_hdr && depth >= CV_32F)\n    {\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_FLOAT));\n    }\n\n    bool color = img.channels() > 1;\n\n    CV_CheckType(type, depth == CV_8U || depth == CV_8S || depth == CV_16U || depth == CV_16S || depth == CV_32S || depth == CV_32F || depth == CV_64F, \"\");\n\n    if (m_width && m_height)\n    {\n        int is_tiled = TIFFIsTiled(tif) != 0;\n        bool isGrayScale = photometric == PHOTOMETRIC_MINISWHITE || photometric == PHOTOMETRIC_MINISBLACK;\n        uint16 bpp = 8, ncn = isGrayScale ? 1 : 3;\n        if (0 == TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bpp))\n        {\n            // TIFF bi-level images don't require TIFFTAG_BITSPERSAMPLE tag\n            bpp = 1;\n        }\n        CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &ncn));\n        uint16 img_orientation = ORIENTATION_TOPLEFT;\n        CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_ORIENTATION, &img_orientation));\n        constexpr const int bitsPerByte = 8;\n        int dst_bpp = (int)(img.elemSize1() * bitsPerByte);\n        bool vert_flip = dst_bpp == 8 &&\n                        (img_orientation == ORIENTATION_BOTRIGHT || img_orientation == ORIENTATION_RIGHTBOT ||\n                         img_orientation == ORIENTATION_BOTLEFT || img_orientation == ORIENTATION_LEFTBOT);\n        int wanted_channels = normalizeChannelsNumber(img.channels());\n\n        if (dst_bpp == 8)\n        {\n            char errmsg[1024];\n            if (!TIFFRGBAImageOK(tif, errmsg))\n            {\n                CV_LOG_WARNING(NULL, \"OpenCV TIFF: TIFFRGBAImageOK: \" << errmsg);\n                close();\n                return false;\n            }\n        }\n\n        uint32 tile_width0 = m_width, tile_height0 = 0;\n\n        if (is_tiled)\n        {\n            CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_TILEWIDTH, &tile_width0));\n            CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_TILELENGTH, &tile_height0));\n        }\n        else\n        {\n            // optional\n            CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &tile_height0));\n        }\n\n        {\n            if (tile_width0 == 0)\n                tile_width0 = m_width;\n\n            if (tile_height0 == 0 ||\n                    (!is_tiled && tile_height0 == std::numeric_limits<uint32>::max()) )\n                tile_height0 = m_height;\n\n            const int TILE_MAX_WIDTH = (1 << 24);\n            const int TILE_MAX_HEIGHT = (1 << 24);\n            CV_Assert((int)tile_width0 > 0 && (int)tile_width0 <= TILE_MAX_WIDTH);\n            CV_Assert((int)tile_height0 > 0 && (int)tile_height0 <= TILE_MAX_HEIGHT);\n            const uint64_t MAX_TILE_SIZE = (CV_BIG_UINT(1) << 30);\n            CV_CheckLE((int)ncn, 4, \"\");\n            CV_CheckLE((int)bpp, 64, \"\");\n            CV_Assert(((uint64_t)tile_width0 * tile_height0 * ncn * std::max(1, (int)(bpp / bitsPerByte)) < MAX_TILE_SIZE) && \"TIFF tile size is too large: >= 1Gb\");\n\n            if (dst_bpp == 8)\n            {\n                // we will use TIFFReadRGBA* functions, so allocate temporary buffer for 32bit RGBA\n                bpp = 8;\n                ncn = 4;\n            }\n            else if (dst_bpp == 32 || dst_bpp == 64)\n            {\n                CV_Assert(ncn == img.channels());\n                CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP));\n            }\n            const size_t src_buffer_bytes_per_row = divUp(static_cast<size_t>(ncn * tile_width0 * bpp), static_cast<size_t>(bitsPerByte));\n            const size_t src_buffer_size = tile_height0 * src_buffer_bytes_per_row;\n            const size_t src_buffer_unpacked_bytes_per_row = divUp(static_cast<size_t>(ncn * tile_width0 * dst_bpp), static_cast<size_t>(bitsPerByte));\n            const size_t src_buffer_unpacked_size = tile_height0 * src_buffer_unpacked_bytes_per_row;\n            const bool needsUnpacking = (bpp < dst_bpp);\n            AutoBuffer<uchar> _src_buffer(src_buffer_size);\n            uchar* src_buffer = _src_buffer.data();\n            AutoBuffer<uchar> _src_buffer_unpacked(needsUnpacking ? src_buffer_unpacked_size : 0);\n            uchar* src_buffer_unpacked = needsUnpacking ? _src_buffer_unpacked.data() : nullptr;\n            int tileidx = 0;\n\n            for (int y = 0; y < m_height; y += (int)tile_height0)\n            {\n                int tile_height = std::min((int)tile_height0, m_height - y);\n\n                const int img_y = vert_flip ? m_height - y - tile_height : y;\n\n                for(int x = 0; x < m_width; x += (int)tile_width0, tileidx++)\n                {\n                    int tile_width = std::min((int)tile_width0, m_width - x);\n\n                    switch (dst_bpp)\n                    {\n                        case 8:\n                        {\n                            uchar* bstart = src_buffer;\n                            if (!is_tiled)\n                            {\n                                CV_TIFF_CHECK_CALL(TIFFReadRGBAStrip(tif, y, (uint32*)src_buffer));\n                            }\n                            else\n                            {\n                                CV_TIFF_CHECK_CALL(TIFFReadRGBATile(tif, x, y, (uint32*)src_buffer));\n                                // Tiles fill the buffer from the bottom up\n                                bstart += (tile_height0 - tile_height) * tile_width0 * 4;\n                            }\n\n                            for (int i = 0; i < tile_height; i++)\n                            {\n                                if (color)\n                                {\n                                    if (wanted_channels == 4)\n                                    {\n                                        icvCvt_BGRA2RGBA_8u_C4R(bstart + i*tile_width0*4, 0,\n                                                img.ptr(img_y + tile_height - i - 1, x), 0,\n                                                Size(tile_width, 1) );\n                                    }\n                                    else\n                                    {\n                                        CV_CheckEQ(wanted_channels, 3, \"TIFF-8bpp: BGR/BGRA images are supported only\");\n                                        icvCvt_BGRA2BGR_8u_C4C3R(bstart + i*tile_width0*4, 0,\n                                                img.ptr(img_y + tile_height - i - 1, x), 0,\n                                                Size(tile_width, 1), 2);\n                                    }\n                                }\n                                else\n                                {\n                                    CV_CheckEQ(wanted_channels, 1, \"\");\n                                    icvCvt_BGRA2Gray_8u_C4C1R( bstart + i*tile_width0*4, 0,\n                                            img.ptr(img_y + tile_height - i - 1, x), 0,\n                                            Size(tile_width, 1), 2);\n                                }\n                            }\n                            break;\n                        }\n\n                        case 16:\n                        {\n                            if (!is_tiled)\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedStrip(tif, tileidx, (uint32*)src_buffer, src_buffer_size) >= 0);\n                            }\n                            else\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedTile(tif, tileidx, (uint32*)src_buffer, src_buffer_size) >= 0);\n                            }\n\n                            for (int i = 0; i < tile_height; i++)\n                            {\n                                ushort* buffer16 = (ushort*)(src_buffer+i*src_buffer_bytes_per_row);\n                                if (needsUnpacking)\n                                {\n                                    const uchar* src_packed = src_buffer+i*src_buffer_bytes_per_row;\n                                    uchar* dst_unpacked = src_buffer_unpacked+i*src_buffer_unpacked_bytes_per_row;\n                                    if (bpp == 10)\n                                        _unpack10To16(src_packed, src_packed+src_buffer_bytes_per_row,\n                                                      (ushort*)dst_unpacked, (ushort*)(dst_unpacked+src_buffer_unpacked_bytes_per_row),\n                                                      ncn * tile_width0);\n                                    else if (bpp == 12)\n                                        _unpack12To16(src_packed, src_packed+src_buffer_bytes_per_row,\n                                                      (ushort*)dst_unpacked, (ushort*)(dst_unpacked+src_buffer_unpacked_bytes_per_row),\n                                                      ncn * tile_width0);\n                                    else if (bpp == 14)\n                                        _unpack14To16(src_packed, src_packed+src_buffer_bytes_per_row,\n                                                      (ushort*)dst_unpacked, (ushort*)(dst_unpacked+src_buffer_unpacked_bytes_per_row),\n                                                      ncn * tile_width0);\n                                    buffer16 = (ushort*)dst_unpacked;\n                                }\n\n                                if (color)\n                                {\n                                    if (ncn == 1)\n                                    {\n                                        CV_CheckEQ(wanted_channels, 3, \"\");\n                                        icvCvt_Gray2BGR_16u_C1C3R(buffer16, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1));\n                                    }\n                                    else if (ncn == 3)\n                                    {\n                                        CV_CheckEQ(wanted_channels, 3, \"\");\n                                        icvCvt_RGB2BGR_16u_C3R(buffer16, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1));\n                                    }\n                                    else if (ncn == 4)\n                                    {\n                                        if (wanted_channels == 4)\n                                        {\n                                            icvCvt_BGRA2RGBA_16u_C4R(buffer16, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1));\n                                        }\n                                        else\n                                        {\n                                            CV_CheckEQ(wanted_channels, 3, \"TIFF-16bpp: BGR/BGRA images are supported only\");\n                                            icvCvt_BGRA2BGR_16u_C4C3R(buffer16, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1), 2);\n                                        }\n                                    }\n                                    else\n                                    {\n                                        CV_Error(Error::StsError, \"Not supported\");\n                                    }\n                                }\n                                else\n                                {\n                                    CV_CheckEQ(wanted_channels, 1, \"\");\n                                    if( ncn == 1 )\n                                    {\n                                        memcpy(img.ptr<ushort>(img_y + i, x),\n                                               buffer16,\n                                               tile_width*sizeof(ushort));\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2Gray_16u_CnC1R(buffer16, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1), ncn, 2);\n                                    }\n                                }\n                            }\n                            break;\n                        }\n\n                        case 32:\n                        case 64:\n                        {\n                            if( !is_tiled )\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedStrip(tif, tileidx, src_buffer, src_buffer_size) >= 0);\n                            }\n                            else\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedTile(tif, tileidx, src_buffer, src_buffer_size) >= 0);\n                            }\n\n                            Mat m_tile(Size(tile_width0, tile_height0), CV_MAKETYPE((dst_bpp == 32) ? (depth == CV_32S ? CV_32S : CV_32F) : CV_64F, ncn), src_buffer);\n                            Rect roi_tile(0, 0, tile_width, tile_height);\n                            Rect roi_img(x, img_y, tile_width, tile_height);\n                            if (!m_hdr && ncn == 3)\n                                cvtColor(m_tile(roi_tile), img(roi_img), COLOR_RGB2BGR);\n                            else if (!m_hdr && ncn == 4)\n                                cvtColor(m_tile(roi_tile), img(roi_img), COLOR_RGBA2BGRA);\n                            else\n                                m_tile(roi_tile).copyTo(img(roi_img));\n                            break;\n                        }\n                        default:\n                        {\n                            CV_Assert(0 && \"OpenCV TIFF: unsupported depth\");\n                        }\n                    }  // switch (dst_bpp)\n                }  // for x\n            }  // for y\n        }\n        if (bpp < dst_bpp)\n          img *= (1<<(dst_bpp-bpp));\n        fixOrientation(img, img_orientation, dst_bpp);\n    }\n\n    if (m_hdr && depth >= CV_32F)\n    {\n        CV_Assert(photometric == PHOTOMETRIC_LOGLUV);\n        cvtColor(img, img, COLOR_XYZ2BGR);\n    }\n    return true;\n}",
    "bool  TiffDecoder::readData( Mat& img )\n{\n    int type = img.type();\n    int depth = CV_MAT_DEPTH(type);\n\n    CV_Assert(!m_tif.empty());\n    TIFF* tif = (TIFF*)m_tif.get();\n\n    uint16 photometric = (uint16)-1;\n    CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric));\n\n    if (m_hdr && depth >= CV_32F)\n    {\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_FLOAT));\n    }\n\n    bool color = img.channels() > 1;\n\n    CV_CheckType(type, depth == CV_8U || depth == CV_16U || depth == CV_32F || depth == CV_64F, \"\");\n\n    if (m_width && m_height)\n    {\n        int is_tiled = TIFFIsTiled(tif) != 0;\n        bool isGrayScale = photometric == PHOTOMETRIC_MINISWHITE || photometric == PHOTOMETRIC_MINISBLACK;\n        uint16 bpp = 8, ncn = isGrayScale ? 1 : 3;\n        CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bpp));\n        CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &ncn));\n        uint16 img_orientation = ORIENTATION_TOPLEFT;\n        CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_ORIENTATION, &img_orientation));\n        const int bitsPerByte = 8;\n        int dst_bpp = (int)(img.elemSize1() * bitsPerByte);\n        bool vert_flip = dst_bpp == 8 &&\n                        (img_orientation == ORIENTATION_BOTRIGHT || img_orientation == ORIENTATION_RIGHTBOT ||\n                         img_orientation == ORIENTATION_BOTLEFT || img_orientation == ORIENTATION_LEFTBOT);\n        int wanted_channels = normalizeChannelsNumber(img.channels());\n\n        if (dst_bpp == 8)\n        {\n            char errmsg[1024];\n            if (!TIFFRGBAImageOK(tif, errmsg))\n            {\n                CV_LOG_WARNING(NULL, \"OpenCV TIFF: TIFFRGBAImageOK: \" << errmsg);\n                close();\n                return false;\n            }\n        }\n\n        uint32 tile_width0 = m_width, tile_height0 = 0;\n\n        if (is_tiled)\n        {\n            CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_TILEWIDTH, &tile_width0));\n            CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_TILELENGTH, &tile_height0));\n        }\n        else\n        {\n            // optional\n            CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &tile_height0));\n        }\n\n        {\n            if (tile_width0 == 0)\n                tile_width0 = m_width;\n\n            if (tile_height0 == 0 ||\n                    (!is_tiled && tile_height0 == std::numeric_limits<uint32>::max()) )\n                tile_height0 = m_height;\n\n            const int TILE_MAX_WIDTH = (1 << 24);\n            const int TILE_MAX_HEIGHT = (1 << 24);\n            CV_Assert((int)tile_width0 > 0 && (int)tile_width0 <= TILE_MAX_WIDTH);\n            CV_Assert((int)tile_height0 > 0 && (int)tile_height0 <= TILE_MAX_HEIGHT);\n            const uint64_t MAX_TILE_SIZE = (CV_BIG_UINT(1) << 30);\n            CV_CheckLE((int)ncn, 4, \"\");\n            CV_CheckLE((int)bpp, 64, \"\");\n            CV_Assert(((uint64_t)tile_width0 * tile_height0 * ncn * std::max(1, (int)(bpp / bitsPerByte)) < MAX_TILE_SIZE) && \"TIFF tile size is too large: >= 1Gb\");\n\n            if (dst_bpp == 8)\n            {\n                // we will use TIFFReadRGBA* functions, so allocate temporary buffer for 32bit RGBA\n                bpp = 8;\n                ncn = 4;\n            }\n            else if (dst_bpp == 32 || dst_bpp == 64)\n            {\n                CV_Assert(ncn == img.channels());\n                CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP));\n            }\n            const size_t buffer_size = (bpp / bitsPerByte) * ncn * tile_height0 * tile_width0;\n            AutoBuffer<uchar> _buffer(buffer_size);\n            uchar* buffer = _buffer.data();\n            ushort* buffer16 = (ushort*)buffer;\n            int tileidx = 0;\n\n            for (int y = 0; y < m_height; y += (int)tile_height0)\n            {\n                int tile_height = std::min((int)tile_height0, m_height - y);\n\n                const int img_y = vert_flip ? m_height - y - tile_height : y;\n\n                for(int x = 0; x < m_width; x += (int)tile_width0, tileidx++)\n                {\n                    int tile_width = std::min((int)tile_width0, m_width - x);\n\n                    switch (dst_bpp)\n                    {\n                        case 8:\n                        {\n                            uchar* bstart = buffer;\n                            if (!is_tiled)\n                            {\n                                CV_TIFF_CHECK_CALL(TIFFReadRGBAStrip(tif, y, (uint32*)buffer));\n                            }\n                            else\n                            {\n                                CV_TIFF_CHECK_CALL(TIFFReadRGBATile(tif, x, y, (uint32*)buffer));\n                                // Tiles fill the buffer from the bottom up\n                                bstart += (tile_height0 - tile_height) * tile_width0 * 4;\n                            }\n\n                            for (int i = 0; i < tile_height; i++)\n                            {\n                                if (color)\n                                {\n                                    if (wanted_channels == 4)\n                                    {\n                                        icvCvt_BGRA2RGBA_8u_C4R(bstart + i*tile_width0*4, 0,\n                                                img.ptr(img_y + tile_height - i - 1, x), 0,\n                                                Size(tile_width, 1) );\n                                    }\n                                    else\n                                    {\n                                        CV_CheckEQ(wanted_channels, 3, \"TIFF-8bpp: BGR/BGRA images are supported only\");\n                                        icvCvt_BGRA2BGR_8u_C4C3R(bstart + i*tile_width0*4, 0,\n                                                img.ptr(img_y + tile_height - i - 1, x), 0,\n                                                Size(tile_width, 1), 2);\n                                    }\n                                }\n                                else\n                                {\n                                    CV_CheckEQ(wanted_channels, 1, \"\");\n                                    icvCvt_BGRA2Gray_8u_C4C1R( bstart + i*tile_width0*4, 0,\n                                            img.ptr(img_y + tile_height - i - 1, x), 0,\n                                            Size(tile_width, 1), 2);\n                                }\n                            }\n                            break;\n                        }\n\n                        case 16:\n                        {\n                            if (!is_tiled)\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedStrip(tif, tileidx, (uint32*)buffer, buffer_size) >= 0);\n                            }\n                            else\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedTile(tif, tileidx, (uint32*)buffer, buffer_size) >= 0);\n                            }\n\n                            for (int i = 0; i < tile_height; i++)\n                            {\n                                if (color)\n                                {\n                                    if (ncn == 1)\n                                    {\n                                        CV_CheckEQ(wanted_channels, 3, \"\");\n                                        icvCvt_Gray2BGR_16u_C1C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1));\n                                    }\n                                    else if (ncn == 3)\n                                    {\n                                        CV_CheckEQ(wanted_channels, 3, \"\");\n                                        icvCvt_RGB2BGR_16u_C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1));\n                                    }\n                                    else if (ncn == 4)\n                                    {\n                                        if (wanted_channels == 4)\n                                        {\n                                            icvCvt_BGRA2RGBA_16u_C4R(buffer16 + i*tile_width0*ncn, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1));\n                                        }\n                                        else\n                                        {\n                                            CV_CheckEQ(wanted_channels, 3, \"TIFF-16bpp: BGR/BGRA images are supported only\");\n                                            icvCvt_BGRA2BGR_16u_C4C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1), 2);\n                                        }\n                                    }\n                                    else\n                                    {\n                                        CV_Error(Error::StsError, \"Not supported\");\n                                    }\n                                }\n                                else\n                                {\n                                    CV_CheckEQ(wanted_channels, 1, \"\");\n                                    if( ncn == 1 )\n                                    {\n                                        memcpy(img.ptr<ushort>(img_y + i, x),\n                                               buffer16 + i*tile_width0*ncn,\n                                               tile_width*sizeof(ushort));\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2Gray_16u_CnC1R(buffer16 + i*tile_width0*ncn, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1), ncn, 2);\n                                    }\n                                }\n                            }\n                            break;\n                        }\n\n                        case 32:\n                        case 64:\n                        {\n                            if( !is_tiled )\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedStrip(tif, tileidx, buffer, buffer_size) >= 0);\n                            }\n                            else\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedTile(tif, tileidx, buffer, buffer_size) >= 0);\n                            }\n\n                            Mat m_tile(Size(tile_width0, tile_height0), CV_MAKETYPE((dst_bpp == 32) ? CV_32F : CV_64F, ncn), buffer);\n                            Rect roi_tile(0, 0, tile_width, tile_height);\n                            Rect roi_img(x, img_y, tile_width, tile_height);\n                            if (!m_hdr && ncn == 3)\n                                cvtColor(m_tile(roi_tile), img(roi_img), COLOR_RGB2BGR);\n                            else if (!m_hdr && ncn == 4)\n                                cvtColor(m_tile(roi_tile), img(roi_img), COLOR_RGBA2BGRA);\n                            else\n                                m_tile(roi_tile).copyTo(img(roi_img));\n                            break;\n                        }\n                        default:\n                        {\n                            CV_Assert(0 && \"OpenCV TIFF: unsupported depth\");\n                        }\n                    }  // switch (dst_bpp)\n                }  // for x\n            }  // for y\n        }\n        fixOrientation(img, img_orientation, dst_bpp);\n    }\n\n    if (m_hdr && depth >= CV_32F)\n    {\n        CV_Assert(photometric == PHOTOMETRIC_LOGLUV);\n        cvtColor(img, img, COLOR_XYZ2BGR);\n    }\n    return true;\n}",
    "CPLErr GTiffRGBABand::IReadBlock( int nBlockXOff, int nBlockYOff,\n                                  void * pImage )\n\n{\n    if( !poGDS->SetDirectory() )\n        return CE_Failure;\n\n    CPLAssert( nBlocksPerRow != 0 );\n    const int nBlockBufSize = 4 * nBlockXSize * nBlockYSize;\n    const int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n\n#ifdef INTERNAL_LIBTIFF\n    if( poGDS->nCompression == COMPRESSION_OJPEG )\n    {\n        // Need to fetch all offsets for Old-JPEG compression\n        if( poGDS->pabyBlockBuf == nullptr )\n        {\n            toff_t *panByteCounts = nullptr;\n            toff_t *panOffsets = nullptr;\n            const bool bIsTiled = CPL_TO_BOOL( TIFFIsTiled(poGDS->hTIFF) );\n\n            if( bIsTiled )\n            {\n                TIFFGetField( poGDS->hTIFF, TIFFTAG_TILEBYTECOUNTS, &panByteCounts );\n                TIFFGetField( poGDS->hTIFF, TIFFTAG_TILEOFFSETS, &panOffsets );\n            }\n            else\n            {\n                TIFFGetField( poGDS->hTIFF, TIFFTAG_STRIPBYTECOUNTS, &panByteCounts );\n                TIFFGetField( poGDS->hTIFF, TIFFTAG_STRIPOFFSETS, &panOffsets );\n            }\n        }\n    }\n#endif\n\n    if( poGDS->nPlanarConfig == PLANARCONFIG_SEPARATE )\n    {\n        for( int iBand = 0; iBand < poGDS->nSamplesPerPixel; iBand ++ )\n        {\n            int nBlockIdBand = nBlockId + iBand * poGDS->nBlocksPerBand;\n            if( !poGDS->IsBlockAvailable(nBlockIdBand) )\n                return CE_Failure;\n        }\n    }\n    else\n    {\n        if( !poGDS->IsBlockAvailable(nBlockId) )\n            return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Allocate a temporary buffer for this strip.                     */\n/* -------------------------------------------------------------------- */\n    if( poGDS->pabyBlockBuf == nullptr )\n    {\n        poGDS->pabyBlockBuf =\n            static_cast<GByte *>(\n                VSI_MALLOC3_VERBOSE( 4, nBlockXSize, nBlockYSize ) );\n        if( poGDS->pabyBlockBuf == nullptr )\n            return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Read the strip                                                  */\n/* -------------------------------------------------------------------- */\n    CPLErr eErr = CE_None;\n\n    if( poGDS->nLoadedBlock != nBlockId )\n    {\n        if( TIFFIsTiled( poGDS->hTIFF ) )\n        {\n#if defined(INTERNAL_LIBTIFF) || TIFFLIB_VERSION > 20161119\n            if( TIFFReadRGBATileExt(\n                   poGDS->hTIFF,\n                   nBlockXOff * nBlockXSize,\n                   nBlockYOff * nBlockYSize,\n                   reinterpret_cast<uint32 *>(poGDS->pabyBlockBuf),\n                   !poGDS->bIgnoreReadErrors) == 0\n                && !poGDS->bIgnoreReadErrors )\n#else\n            if( TIFFReadRGBATile(\n                   poGDS->hTIFF,\n                   nBlockXOff * nBlockXSize,\n                   nBlockYOff * nBlockYSize,\n                   reinterpret_cast<uint32 *>(poGDS->pabyBlockBuf)) == 0\n                && !poGDS->bIgnoreReadErrors )\n#endif\n            {\n                // Once TIFFError() is properly hooked, this can go away.\n                CPLError( CE_Failure, CPLE_AppDefined,\n                          \"TIFFReadRGBATile() failed.\" );\n\n                memset( poGDS->pabyBlockBuf, 0, nBlockBufSize );\n\n                eErr = CE_Failure;\n            }\n        }\n        else\n        {\n#if defined(INTERNAL_LIBTIFF) || TIFFLIB_VERSION > 20161119\n            if( TIFFReadRGBAStripExt(\n                   poGDS->hTIFF,\n                   nBlockId * nBlockYSize,\n                   reinterpret_cast<uint32 *>(poGDS->pabyBlockBuf),\n                   !poGDS->bIgnoreReadErrors) == 0\n                && !poGDS->bIgnoreReadErrors )\n#else\n            if( TIFFReadRGBAStrip(\n                   poGDS->hTIFF,\n                   nBlockId * nBlockYSize,\n                   reinterpret_cast<uint32 *>(poGDS->pabyBlockBuf)) == 0\n                && !poGDS->bIgnoreReadErrors )\n#endif\n            {\n                // Once TIFFError() is properly hooked, this can go away.\n                CPLError( CE_Failure, CPLE_AppDefined,\n                          \"TIFFReadRGBAStrip() failed.\" );\n\n                memset( poGDS->pabyBlockBuf, 0, nBlockBufSize );\n\n                eErr = CE_Failure;\n            }\n        }\n    }\n\n    poGDS->nLoadedBlock = nBlockId;\n\n/* -------------------------------------------------------------------- */\n/*      Handle simple case of eight bit data, and pixel interleaving.   */\n/* -------------------------------------------------------------------- */\n    int nThisBlockYSize = nBlockYSize;\n\n    if( nBlockYOff * nBlockYSize > GetYSize() - nBlockYSize\n        && !TIFFIsTiled( poGDS->hTIFF ) )\n        nThisBlockYSize = GetYSize() - nBlockYOff * nBlockYSize;\n\n#ifdef CPL_LSB\n    const int nBO = nBand - 1;\n#else\n    const int nBO = 4 - nBand;\n#endif\n\n    for( int iDestLine = 0; iDestLine < nThisBlockYSize; ++iDestLine )\n    {\n        const int nSrcOffset =\n            (nThisBlockYSize - iDestLine - 1) * nBlockXSize * 4;\n\n        GDALCopyWords(\n            poGDS->pabyBlockBuf + nBO + nSrcOffset, GDT_Byte, 4,\n            static_cast<GByte *>(pImage)+iDestLine*nBlockXSize, GDT_Byte, 1,\n            nBlockXSize );\n    }\n\n    if( eErr == CE_None )\n        eErr = FillCacheForOtherBands(nBlockXOff, nBlockYOff);\n\n    return eErr;\n}",
    "bool  TiffDecoder::readData( Mat& img )\n{\n    if(m_hdr && img.type() == CV_32FC3)\n    {\n        return readData_32FC3(img);\n    }\n    if(img.type() == CV_32FC1)\n    {\n        return readData_32FC1(img);\n    }\n    bool result = false;\n    bool color = img.channels() > 1;\n\n    if( img.depth() != CV_8U && img.depth() != CV_16U && img.depth() != CV_32F && img.depth() != CV_64F )\n        return false;\n\n    if( m_tif && m_width && m_height )\n    {\n        TIFF* tif = (TIFF*)m_tif;\n        uint32 tile_width0 = m_width, tile_height0 = 0;\n        int x, y, i;\n        int is_tiled = TIFFIsTiled(tif);\n        uint16 photometric;\n        TIFFGetField( tif, TIFFTAG_PHOTOMETRIC, &photometric );\n        uint16 bpp = 8, ncn = photometric > 1 ? 3 : 1;\n        TIFFGetField( tif, TIFFTAG_BITSPERSAMPLE, &bpp );\n        TIFFGetField( tif, TIFFTAG_SAMPLESPERPIXEL, &ncn );\n        uint16 img_orientation = ORIENTATION_TOPLEFT;\n        TIFFGetField( tif, TIFFTAG_ORIENTATION, &img_orientation);\n        bool vert_flip = (img_orientation == ORIENTATION_BOTRIGHT) || (img_orientation == ORIENTATION_RIGHTBOT) ||\n                         (img_orientation == ORIENTATION_BOTLEFT) || (img_orientation == ORIENTATION_LEFTBOT);\n        const int bitsPerByte = 8;\n        int dst_bpp = (int)(img.elemSize1() * bitsPerByte);\n        int wanted_channels = normalizeChannelsNumber(img.channels());\n\n        if(dst_bpp == 8)\n        {\n            char errmsg[1024];\n            if(!TIFFRGBAImageOK( tif, errmsg ))\n            {\n                close();\n                return false;\n            }\n        }\n\n        if( (!is_tiled) ||\n            (is_tiled &&\n            TIFFGetField( tif, TIFFTAG_TILEWIDTH, &tile_width0 ) &&\n            TIFFGetField( tif, TIFFTAG_TILELENGTH, &tile_height0 )))\n        {\n            if(!is_tiled)\n                TIFFGetField( tif, TIFFTAG_ROWSPERSTRIP, &tile_height0 );\n\n            if( tile_width0 <= 0 )\n                tile_width0 = m_width;\n\n            if( tile_height0 <= 0 ||\n               (!is_tiled && tile_height0 == std::numeric_limits<uint32>::max()) )\n                tile_height0 = m_height;\n\n            if(dst_bpp == 8) {\n                // we will use TIFFReadRGBA* functions, so allocate temporary buffer for 32bit RGBA\n                bpp = 8;\n                ncn = 4;\n            }\n            const size_t buffer_size = (bpp/bitsPerByte) * ncn * tile_height0 * tile_width0;\n            AutoBuffer<uchar> _buffer( buffer_size );\n            uchar* buffer = _buffer.data();\n            ushort* buffer16 = (ushort*)buffer;\n            float* buffer32 = (float*)buffer;\n            double* buffer64 = (double*)buffer;\n            int tileidx = 0;\n\n            for( y = 0; y < m_height; y += tile_height0 )\n            {\n                int tile_height = tile_height0;\n\n                if( y + tile_height > m_height )\n                    tile_height = m_height - y;\n\n                uchar* data = img.ptr(vert_flip ? m_height - y - tile_height : y);\n\n                for( x = 0; x < m_width; x += tile_width0, tileidx++ )\n                {\n                    int tile_width = tile_width0, ok;\n\n                    if( x + tile_width > m_width )\n                        tile_width = m_width - x;\n\n                    switch(dst_bpp)\n                    {\n                        case 8:\n                        {\n                            uchar * bstart = buffer;\n                            if( !is_tiled )\n                                ok = TIFFReadRGBAStrip( tif, y, (uint32*)buffer );\n                            else\n                            {\n                                ok = TIFFReadRGBATile( tif, x, y, (uint32*)buffer );\n                                //Tiles fill the buffer from the bottom up\n                                bstart += (tile_height0 - tile_height) * tile_width0 * 4;\n                            }\n                            if( !ok )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                                if( color )\n                                {\n                                    if (wanted_channels == 4)\n                                    {\n                                        icvCvt_BGRA2RGBA_8u_C4R( bstart + i*tile_width0*4, 0,\n                                                             data + x*4 + img.step*(tile_height - i - 1), 0,\n                                                             Size(tile_width,1) );\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2BGR_8u_C4C3R( bstart + i*tile_width0*4, 0,\n                                                             data + x*3 + img.step*(tile_height - i - 1), 0,\n                                                             Size(tile_width,1), 2 );\n                                    }\n                                }\n                                else\n                                    icvCvt_BGRA2Gray_8u_C4C1R( bstart + i*tile_width0*4, 0,\n                                                              data + x + img.step*(tile_height - i - 1), 0,\n                                                              Size(tile_width,1), 2 );\n                            break;\n                        }\n\n                        case 16:\n                        {\n                            if( !is_tiled )\n                                ok = (int)TIFFReadEncodedStrip( tif, tileidx, (uint32*)buffer, buffer_size ) >= 0;\n                            else\n                                ok = (int)TIFFReadEncodedTile( tif, tileidx, (uint32*)buffer, buffer_size ) >= 0;\n\n                            if( !ok )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                            {\n                                if( color )\n                                {\n                                    if( ncn == 1 )\n                                    {\n                                        icvCvt_Gray2BGR_16u_C1C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                                  (ushort*)(data + img.step*i) + x*3, 0,\n                                                                  Size(tile_width,1) );\n                                    }\n                                    else if( ncn == 3 )\n                                    {\n                                        icvCvt_RGB2BGR_16u_C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                               (ushort*)(data + img.step*i) + x*3, 0,\n                                                               Size(tile_width,1) );\n                                    }\n                                    else if (ncn == 4)\n                                    {\n                                        if (wanted_channels == 4)\n                                        {\n                                            icvCvt_BGRA2RGBA_16u_C4R(buffer16 + i*tile_width0*ncn, 0,\n                                                (ushort*)(data + img.step*i) + x * 4, 0,\n                                                Size(tile_width, 1));\n                                        }\n                                        else\n                                        {\n                                            icvCvt_BGRA2BGR_16u_C4C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                (ushort*)(data + img.step*i) + x * 3, 0,\n                                                Size(tile_width, 1), 2);\n                                        }\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2BGR_16u_C4C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                               (ushort*)(data + img.step*i) + x*3, 0,\n                                                               Size(tile_width,1), 2 );\n                                    }\n                                }\n                                else\n                                {\n                                    if( ncn == 1 )\n                                    {\n                                        memcpy((ushort*)(data + img.step*i)+x,\n                                               buffer16 + i*tile_width0*ncn,\n                                               tile_width*sizeof(buffer16[0]));\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2Gray_16u_CnC1R(buffer16 + i*tile_width0*ncn, 0,\n                                                               (ushort*)(data + img.step*i) + x, 0,\n                                                               Size(tile_width,1), ncn, 2 );\n                                    }\n                                }\n                            }\n                            break;\n                        }\n\n                        case 32:\n                        case 64:\n                        {\n                            if( !is_tiled )\n                                ok = (int)TIFFReadEncodedStrip( tif, tileidx, buffer, buffer_size ) >= 0;\n                            else\n                                ok = (int)TIFFReadEncodedTile( tif, tileidx, buffer, buffer_size ) >= 0;\n\n                            if( !ok || ncn != 1 )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                            {\n                                if(dst_bpp == 32)\n                                {\n                                    memcpy((float*)(data + img.step*i)+x,\n                                           buffer32 + i*tile_width0*ncn,\n                                           tile_width*sizeof(buffer32[0]));\n                                }\n                                else\n                                {\n                                    memcpy((double*)(data + img.step*i)+x,\n                                         buffer64 + i*tile_width0*ncn,\n                                         tile_width*sizeof(buffer64[0]));\n                                }\n                            }\n\n                            break;\n                        }\n                        default:\n                        {\n                            close();\n                            return false;\n                        }\n                    }\n                }\n            }\n\n            result = true;\n        }\n    }\n\n    return result;\n}",
    "CPLErr GTiffRGBABand::IReadBlock( int nBlockXOff, int nBlockYOff,\n                                  void * pImage )\n\n{\n    m_poGDS->Crystalize();\n\n    CPLAssert( nBlocksPerRow != 0 );\n    const auto nBlockBufSize = 4 * static_cast<GPtrDiff_t>(nBlockXSize) * nBlockYSize;\n    const int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n\n    if( m_poGDS->m_nPlanarConfig == PLANARCONFIG_SEPARATE )\n    {\n        for( int iBand = 0; iBand < m_poGDS->m_nSamplesPerPixel; iBand ++ )\n        {\n            int nBlockIdBand = nBlockId + iBand * m_poGDS->m_nBlocksPerBand;\n            if( !m_poGDS->IsBlockAvailable(nBlockIdBand) )\n                return CE_Failure;\n        }\n    }\n    else\n    {\n        if( !m_poGDS->IsBlockAvailable(nBlockId) )\n            return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Allocate a temporary buffer for this strip.                     */\n/* -------------------------------------------------------------------- */\n    if( m_poGDS->m_pabyBlockBuf == nullptr )\n    {\n        m_poGDS->m_pabyBlockBuf =\n            static_cast<GByte *>(\n                VSI_MALLOC3_VERBOSE( 4, nBlockXSize, nBlockYSize ) );\n        if( m_poGDS->m_pabyBlockBuf == nullptr )\n            return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Read the strip                                                  */\n/* -------------------------------------------------------------------- */\n    CPLErr eErr = CE_None;\n\n    if( m_poGDS->m_nLoadedBlock != nBlockId )\n    {\n        if( TIFFIsTiled( m_poGDS->m_hTIFF ) )\n        {\n#if TIFFLIB_VERSION > 20161119\n            if( TIFFReadRGBATileExt(\n                   m_poGDS->m_hTIFF,\n                   nBlockXOff * nBlockXSize,\n                   nBlockYOff * nBlockYSize,\n                   reinterpret_cast<uint32 *>(m_poGDS->m_pabyBlockBuf),\n                   !m_poGDS->m_bIgnoreReadErrors) == 0\n                && !m_poGDS->m_bIgnoreReadErrors )\n#else\n            if( TIFFReadRGBATile(\n                   m_poGDS->m_hTIFF,\n                   nBlockXOff * nBlockXSize,\n                   nBlockYOff * nBlockYSize,\n                   reinterpret_cast<uint32 *>(m_poGDS->m_pabyBlockBuf)) == 0\n                && !m_poGDS->m_bIgnoreReadErrors )\n#endif\n            {\n                // Once TIFFError() is properly hooked, this can go away.\n                ReportError( CE_Failure, CPLE_AppDefined,\n                          \"TIFFReadRGBATile() failed.\" );\n\n                memset( m_poGDS->m_pabyBlockBuf, 0, nBlockBufSize );\n\n                eErr = CE_Failure;\n            }\n        }\n        else\n        {\n#if TIFFLIB_VERSION > 20161119\n            if( TIFFReadRGBAStripExt(\n                   m_poGDS->m_hTIFF,\n                   nBlockId * nBlockYSize,\n                   reinterpret_cast<uint32 *>(m_poGDS->m_pabyBlockBuf),\n                   !m_poGDS->m_bIgnoreReadErrors) == 0\n                && !m_poGDS->m_bIgnoreReadErrors )\n#else\n            if( TIFFReadRGBAStrip(\n                   m_poGDS->m_hTIFF,\n                   nBlockId * nBlockYSize,\n                   reinterpret_cast<uint32 *>(m_poGDS->m_pabyBlockBuf)) == 0\n                && !m_poGDS->m_bIgnoreReadErrors )\n#endif\n            {\n                // Once TIFFError() is properly hooked, this can go away.\n                ReportError( CE_Failure, CPLE_AppDefined,\n                          \"TIFFReadRGBAStrip() failed.\" );\n\n                memset( m_poGDS->m_pabyBlockBuf, 0, nBlockBufSize );\n\n                eErr = CE_Failure;\n            }\n        }\n    }\n\n    m_poGDS->m_nLoadedBlock = nBlockId;\n\n/* -------------------------------------------------------------------- */\n/*      Handle simple case of eight bit data, and pixel interleaving.   */\n/* -------------------------------------------------------------------- */\n    int nThisBlockYSize = nBlockYSize;\n\n    if( nBlockYOff * nBlockYSize > GetYSize() - nBlockYSize\n        && !TIFFIsTiled( m_poGDS->m_hTIFF ) )\n        nThisBlockYSize = GetYSize() - nBlockYOff * nBlockYSize;\n\n#ifdef CPL_LSB\n    const int nBO = nBand - 1;\n#else\n    const int nBO = 4 - nBand;\n#endif\n\n    for( int iDestLine = 0; iDestLine < nThisBlockYSize; ++iDestLine )\n    {\n        const auto nSrcOffset =\n            static_cast<GPtrDiff_t>(nThisBlockYSize - iDestLine - 1) * nBlockXSize * 4;\n\n        GDALCopyWords(\n            m_poGDS->m_pabyBlockBuf + nBO + nSrcOffset, GDT_Byte, 4,\n            static_cast<GByte *>(pImage)+static_cast<GPtrDiff_t>(iDestLine)*nBlockXSize, GDT_Byte, 1,\n            nBlockXSize );\n    }\n\n    if( eErr == CE_None )\n        eErr = FillCacheForOtherBands(nBlockXOff, nBlockYOff);\n\n    return eErr;\n}",
    "bool  TiffDecoder::readData( Mat& img )\n{\n    bool result = false;\n    bool color = img.channels() > 1;\n    uchar* data = img.data;\n\n    if( img.depth() != CV_8U && img.depth() != CV_16U && img.depth() != CV_32F && img.depth() != CV_64F )\n        return false;\n\n    if( m_tif && m_width && m_height )\n    {\n        TIFF* tif = (TIFF*)m_tif;\n        uint32 tile_width0 = m_width, tile_height0 = 0;\n        int x, y, i;\n        int is_tiled = TIFFIsTiled(tif);\n        uint16 photometric;\n        TIFFGetField( tif, TIFFTAG_PHOTOMETRIC, &photometric );\n        uint16 bpp = 8, ncn = photometric > 1 ? 3 : 1;\n        TIFFGetField( tif, TIFFTAG_BITSPERSAMPLE, &bpp );\n        TIFFGetField( tif, TIFFTAG_SAMPLESPERPIXEL, &ncn );\n        const int bitsPerByte = 8;\n        int dst_bpp = (int)(img.elemSize1() * bitsPerByte);\n\n        if(dst_bpp == 8)\n        {\n            char errmsg[1024];\n            if(!TIFFRGBAImageOK( tif, errmsg ))\n            {\n                close();\n                return false;\n            }\n        }\n\n        if( (!is_tiled) ||\n            (is_tiled &&\n            TIFFGetField( tif, TIFFTAG_TILEWIDTH, &tile_width0 ) &&\n            TIFFGetField( tif, TIFFTAG_TILELENGTH, &tile_height0 )))\n        {\n            if(!is_tiled)\n                TIFFGetField( tif, TIFFTAG_ROWSPERSTRIP, &tile_height0 );\n\n            if( tile_width0 <= 0 )\n                tile_width0 = m_width;\n\n            if( tile_height0 <= 0 ||\n                (!is_tiled && tile_height0 == std::numeric_limits<uint32>::max()) )\n                tile_height0 = m_height;\n\n            const size_t buffer_size = bpp * ncn * tile_height0 * tile_width0;\n            AutoBuffer<uchar> _buffer( buffer_size );\n            uchar* buffer = _buffer;\n            ushort* buffer16 = (ushort*)buffer;\n            float* buffer32 = (float*)buffer;\n            double* buffer64 = (double*)buffer;\n            int tileidx = 0;\n\n            for( y = 0; y < m_height; y += tile_height0, data += img.step*tile_height0 )\n            {\n                int tile_height = tile_height0;\n\n                if( y + tile_height > m_height )\n                    tile_height = m_height - y;\n\n                for( x = 0; x < m_width; x += tile_width0, tileidx++ )\n                {\n                    int tile_width = tile_width0, ok;\n\n                    if( x + tile_width > m_width )\n                        tile_width = m_width - x;\n\n                    switch(dst_bpp)\n                    {\n                        case 8:\n                        {\n                            uchar * bstart = buffer;\n                            if( !is_tiled )\n                                ok = TIFFReadRGBAStrip( tif, y, (uint32*)buffer );\n                            else\n                            {\n                                ok = TIFFReadRGBATile( tif, x, y, (uint32*)buffer );\n                                //Tiles fill the buffer from the bottom up\n                                bstart += (tile_height0 - tile_height) * tile_width0 * 4;\n                            }\n                            if( !ok )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                                if( color )\n                                    icvCvt_BGRA2BGR_8u_C4C3R( bstart + i*tile_width0*4, 0,\n                                                             data + x*3 + img.step*(tile_height - i - 1), 0,\n                                                             cvSize(tile_width,1), 2 );\n                                else\n                                    icvCvt_BGRA2Gray_8u_C4C1R( bstart + i*tile_width0*4, 0,\n                                                              data + x + img.step*(tile_height - i - 1), 0,\n                                                              cvSize(tile_width,1), 2 );\n                            break;\n                        }\n\n                        case 16:\n                        {\n                            if( !is_tiled )\n                                ok = (int)TIFFReadEncodedStrip( tif, tileidx, (uint32*)buffer, buffer_size ) >= 0;\n                            else\n                                ok = (int)TIFFReadEncodedTile( tif, tileidx, (uint32*)buffer, buffer_size ) >= 0;\n\n                            if( !ok )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                            {\n                                if( color )\n                                {\n                                    if( ncn == 1 )\n                                    {\n                                        icvCvt_Gray2BGR_16u_C1C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                                  (ushort*)(data + img.step*i) + x*3, 0,\n                                                                  cvSize(tile_width,1) );\n                                    }\n                                    else if( ncn == 3 )\n                                    {\n                                        icvCvt_RGB2BGR_16u_C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                               (ushort*)(data + img.step*i) + x*3, 0,\n                                                               cvSize(tile_width,1) );\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2BGR_16u_C4C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                               (ushort*)(data + img.step*i) + x*3, 0,\n                                                               cvSize(tile_width,1), 2 );\n                                    }\n                                }\n                                else\n                                {\n                                    if( ncn == 1 )\n                                    {\n                                        memcpy((ushort*)(data + img.step*i)+x,\n                                               buffer16 + i*tile_width0*ncn,\n                                               tile_width*sizeof(buffer16[0]));\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2Gray_16u_CnC1R(buffer16 + i*tile_width0*ncn, 0,\n                                                               (ushort*)(data + img.step*i) + x, 0,\n                                                               cvSize(tile_width,1), ncn, 2 );\n                                    }\n                                }\n                            }\n                            break;\n                        }\n\n                        case 32:\n                        case 64:\n                        {\n                            if( !is_tiled )\n                                ok = (int)TIFFReadEncodedStrip( tif, tileidx, buffer, buffer_size ) >= 0;\n                            else\n                                ok = (int)TIFFReadEncodedTile( tif, tileidx, buffer, buffer_size ) >= 0;\n\n                            if( !ok || ncn != 1 )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                            {\n                                if(dst_bpp == 32)\n                                {\n                                    memcpy((float*)(data + img.step*i)+x,\n                                           buffer32 + i*tile_width0*ncn,\n                                           tile_width*sizeof(buffer32[0]));\n                                }\n                                else\n                                {\n                                    memcpy((double*)(data + img.step*i)+x,\n                                         buffer64 + i*tile_width0*ncn,\n                                         tile_width*sizeof(buffer64[0]));\n                                }\n                            }\n\n                            break;\n                        }\n                        default:\n                        {\n                            close();\n                            return false;\n                        }\n                    }\n                }\n            }\n\n            result = true;\n        }\n    }\n\n    close();\n    return result;\n}",
    "bool  TiffDecoder::readData( Mat& img )\n{\n    if(m_hdr && img.type() == CV_32FC3)\n    {\n        return readHdrData(img);\n    }\n    bool result = false;\n    bool color = img.channels() > 1;\n    uchar* data = img.ptr();\n\n    if( img.depth() != CV_8U && img.depth() != CV_16U && img.depth() != CV_32F && img.depth() != CV_64F )\n        return false;\n\n    if( m_tif && m_width && m_height )\n    {\n        TIFF* tif = (TIFF*)m_tif;\n        uint32 tile_width0 = m_width, tile_height0 = 0;\n        int x, y, i;\n        int is_tiled = TIFFIsTiled(tif);\n        uint16 photometric;\n        TIFFGetField( tif, TIFFTAG_PHOTOMETRIC, &photometric );\n        uint16 bpp = 8, ncn = photometric > 1 ? 3 : 1;\n        TIFFGetField( tif, TIFFTAG_BITSPERSAMPLE, &bpp );\n        TIFFGetField( tif, TIFFTAG_SAMPLESPERPIXEL, &ncn );\n        const int bitsPerByte = 8;\n        int dst_bpp = (int)(img.elemSize1() * bitsPerByte);\n        int wanted_channels = normalizeChannelsNumber(img.channels());\n\n        if(dst_bpp == 8)\n        {\n            char errmsg[1024];\n            if(!TIFFRGBAImageOK( tif, errmsg ))\n            {\n                close();\n                return false;\n            }\n        }\n\n        if( (!is_tiled) ||\n            (is_tiled &&\n            TIFFGetField( tif, TIFFTAG_TILEWIDTH, &tile_width0 ) &&\n            TIFFGetField( tif, TIFFTAG_TILELENGTH, &tile_height0 )))\n        {\n            if(!is_tiled)\n                TIFFGetField( tif, TIFFTAG_ROWSPERSTRIP, &tile_height0 );\n\n            if( tile_width0 <= 0 )\n                tile_width0 = m_width;\n\n            if( tile_height0 <= 0 ||\n               (!is_tiled && tile_height0 == std::numeric_limits<uint32>::max()) )\n                tile_height0 = m_height;\n\n            if(dst_bpp == 8) {\n                // we will use TIFFReadRGBA* functions, so allocate temporary buffer for 32bit RGBA\n                bpp = 8;\n                ncn = 4;\n            }\n            const size_t buffer_size = (bpp/bitsPerByte) * ncn * tile_height0 * tile_width0;\n            AutoBuffer<uchar> _buffer( buffer_size );\n            uchar* buffer = _buffer;\n            ushort* buffer16 = (ushort*)buffer;\n            float* buffer32 = (float*)buffer;\n            double* buffer64 = (double*)buffer;\n            int tileidx = 0;\n\n            for( y = 0; y < m_height; y += tile_height0, data += img.step*tile_height0 )\n            {\n                int tile_height = tile_height0;\n\n                if( y + tile_height > m_height )\n                    tile_height = m_height - y;\n\n                for( x = 0; x < m_width; x += tile_width0, tileidx++ )\n                {\n                    int tile_width = tile_width0, ok;\n\n                    if( x + tile_width > m_width )\n                        tile_width = m_width - x;\n\n                    switch(dst_bpp)\n                    {\n                        case 8:\n                        {\n                            uchar * bstart = buffer;\n                            if( !is_tiled )\n                                ok = TIFFReadRGBAStrip( tif, y, (uint32*)buffer );\n                            else\n                            {\n                                ok = TIFFReadRGBATile( tif, x, y, (uint32*)buffer );\n                                //Tiles fill the buffer from the bottom up\n                                bstart += (tile_height0 - tile_height) * tile_width0 * 4;\n                            }\n                            if( !ok )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                                if( color )\n                                {\n                                    if (wanted_channels == 4)\n                                    {\n                                        icvCvt_BGRA2RGBA_8u_C4R( bstart + i*tile_width0*4, 0,\n                                                             data + x*4 + img.step*(tile_height - i - 1), 0,\n                                                             cvSize(tile_width,1) );\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2BGR_8u_C4C3R( bstart + i*tile_width0*4, 0,\n                                                             data + x*3 + img.step*(tile_height - i - 1), 0,\n                                                             cvSize(tile_width,1), 2 );\n                                    }\n                                }\n                                else\n                                    icvCvt_BGRA2Gray_8u_C4C1R( bstart + i*tile_width0*4, 0,\n                                                              data + x + img.step*(tile_height - i - 1), 0,\n                                                              cvSize(tile_width,1), 2 );\n                            break;\n                        }\n\n                        case 16:\n                        {\n                            if( !is_tiled )\n                                ok = (int)TIFFReadEncodedStrip( tif, tileidx, (uint32*)buffer, buffer_size ) >= 0;\n                            else\n                                ok = (int)TIFFReadEncodedTile( tif, tileidx, (uint32*)buffer, buffer_size ) >= 0;\n\n                            if( !ok )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                            {\n                                if( color )\n                                {\n                                    if( ncn == 1 )\n                                    {\n                                        icvCvt_Gray2BGR_16u_C1C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                                  (ushort*)(data + img.step*i) + x*3, 0,\n                                                                  cvSize(tile_width,1) );\n                                    }\n                                    else if( ncn == 3 )\n                                    {\n                                        icvCvt_RGB2BGR_16u_C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                               (ushort*)(data + img.step*i) + x*3, 0,\n                                                               cvSize(tile_width,1) );\n                                    }\n                                    else if (ncn == 4)\n                                    {\n                                        if (wanted_channels == 4)\n                                        {\n                                            icvCvt_BGRA2RGBA_16u_C4R(buffer16 + i*tile_width0*ncn, 0,\n                                                (ushort*)(data + img.step*i) + x * 4, 0,\n                                                cvSize(tile_width, 1));\n                                        }\n                                        else\n                                        {\n                                            icvCvt_BGRA2BGR_16u_C4C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                (ushort*)(data + img.step*i) + x * 3, 0,\n                                                cvSize(tile_width, 1), 2);\n                                        }\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2BGR_16u_C4C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                               (ushort*)(data + img.step*i) + x*3, 0,\n                                                               cvSize(tile_width,1), 2 );\n                                    }\n                                }\n                                else\n                                {\n                                    if( ncn == 1 )\n                                    {\n                                        memcpy((ushort*)(data + img.step*i)+x,\n                                               buffer16 + i*tile_width0*ncn,\n                                               tile_width*sizeof(buffer16[0]));\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2Gray_16u_CnC1R(buffer16 + i*tile_width0*ncn, 0,\n                                                               (ushort*)(data + img.step*i) + x, 0,\n                                                               cvSize(tile_width,1), ncn, 2 );\n                                    }\n                                }\n                            }\n                            break;\n                        }\n\n                        case 32:\n                        case 64:\n                        {\n                            if( !is_tiled )\n                                ok = (int)TIFFReadEncodedStrip( tif, tileidx, buffer, buffer_size ) >= 0;\n                            else\n                                ok = (int)TIFFReadEncodedTile( tif, tileidx, buffer, buffer_size ) >= 0;\n\n                            if( !ok || ncn != 1 )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                            {\n                                if(dst_bpp == 32)\n                                {\n                                    memcpy((float*)(data + img.step*i)+x,\n                                           buffer32 + i*tile_width0*ncn,\n                                           tile_width*sizeof(buffer32[0]));\n                                }\n                                else\n                                {\n                                    memcpy((double*)(data + img.step*i)+x,\n                                         buffer64 + i*tile_width0*ncn,\n                                         tile_width*sizeof(buffer64[0]));\n                                }\n                            }\n\n                            break;\n                        }\n                        default:\n                        {\n                            close();\n                            return false;\n                        }\n                    }\n                }\n            }\n\n            result = true;\n        }\n    }\n\n    return result;\n}",
    "bool\nTIFFInput::read_native_tile(int subimage, int miplevel, int x, int y, int z,\n                            void* data)\n{\n    lock_guard lock(m_mutex);\n    if (!seek_subimage(subimage, miplevel))\n        return false;\n    x -= m_spec.x;\n    y -= m_spec.y;\n\n    if (m_use_rgba_interface) {\n        // We punted and used the RGBA image interface\n        // libtiff has a call to read just one tile as RGBA. So that's all\n        // we need to do, not buffer the whole image.\n        m_rgbadata.resize(m_spec.tile_pixels() * 4);\n        bool ok = TIFFReadRGBATile(m_tif, x, y, &m_rgbadata[0]);\n        if (!ok) {\n            error(\"Unknown error trying to read TIFF as RGBA\");\n            return false;\n        }\n        // Copy, and use stride magic to reverse top-to-bottom\n        int tw = std::min(m_spec.tile_width, m_spec.width - x);\n        int th = std::min(m_spec.tile_height, m_spec.height - y);\n        copy_image(m_spec.nchannels, tw, th, 1,\n                   &m_rgbadata[(th - 1) * m_spec.tile_width], m_spec.nchannels,\n                   4, -m_spec.tile_width * 4, AutoStride, data,\n                   m_spec.nchannels, m_spec.nchannels * m_spec.tile_width,\n                   AutoStride);\n        return true;\n    }\n\n    imagesize_t tile_pixels = m_spec.tile_pixels();\n    imagesize_t nvals       = tile_pixels * m_spec.nchannels;\n    m_scratch.resize(m_spec.tile_bytes());\n    bool no_bit_convert = (m_bitspersample == 8 || m_bitspersample == 16\n                           || m_bitspersample == 32);\n    if (m_photometric == PHOTOMETRIC_PALETTE) {\n        // Convert from palette to RGB\n        if (TIFFReadTile(m_tif, &m_scratch[0], x, y, z, 0) < 0) {\n            error(\"%s\", oiio_tiff_last_error());\n            return false;\n        }\n        palette_to_rgb(tile_pixels, &m_scratch[0], (unsigned char*)data);\n    } else {\n        // Not palette\n        imagesize_t plane_bytes = m_spec.tile_pixels() * m_spec.format.size();\n        int planes              = m_separate ? m_spec.nchannels : 1;\n        std::vector<unsigned char> scratch2(m_separate ? m_spec.tile_bytes()\n                                                       : 0);\n        // Where to read?  Directly into user data if no channel shuffling\n        // or bit shifting is needed, otherwise into scratch space.\n        unsigned char* readbuf = (no_bit_convert && !m_separate)\n                                     ? (unsigned char*)data\n                                     : &m_scratch[0];\n        // Perform the reads.  Note that for contig, planes==1, so it will\n        // only do one TIFFReadTile.\n        for (int c = 0; c < planes; ++c) /* planes==1 for contig */\n            if (TIFFReadTile(m_tif, &readbuf[plane_bytes * c], x, y, z, c)\n                < 0) {\n                error(\"%s\", oiio_tiff_last_error());\n                return false;\n            }\n        if (m_bitspersample < 8) {\n            // m_scratch now holds nvals n-bit values, contig or separate\n            std::swap(m_scratch, scratch2);\n            for (int c = 0; c < planes; ++c) /* planes==1 for contig */\n                bit_convert(m_separate ? tile_pixels : nvals,\n                            &scratch2[plane_bytes * c], m_bitspersample,\n                            m_separate ? &m_scratch[plane_bytes * c]\n                                       : (unsigned char*)data + plane_bytes * c,\n                            8);\n        } else if (m_bitspersample > 8 && m_bitspersample < 16) {\n            // m_scratch now holds nvals n-bit values, contig or separate\n            std::swap(m_scratch, scratch2);\n            for (int c = 0; c < planes; ++c) /* planes==1 for contig */\n                bit_convert(m_separate ? tile_pixels : nvals,\n                            &scratch2[plane_bytes * c], m_bitspersample,\n                            m_separate ? &m_scratch[plane_bytes * c]\n                                       : (unsigned char*)data + plane_bytes * c,\n                            16);\n        }\n        if (m_separate) {\n            // Convert from separate (RRRGGGBBB) to contiguous (RGBRGBRGB).\n            // We know the data is in m_scratch at this point, so\n            // contiguize it into the user data area.\n            separate_to_contig(planes, tile_pixels, &m_scratch[0],\n                               (unsigned char*)data);\n        }\n    }\n\n    if (m_photometric == PHOTOMETRIC_MINISWHITE)\n        invert_photometric(nvals, data);\n\n    return true;\n}",
    "bool  TiffDecoder::readData( Mat& img )\n{\n    if(m_hdr && img.type() == CV_32FC3)\n    {\n        return readHdrData(img);\n    }\n    bool result = false;\n    bool color = img.channels() > 1;\n    uchar* data = img.ptr();\n\n    if( img.depth() != CV_8U && img.depth() != CV_16U && img.depth() != CV_32F && img.depth() != CV_64F )\n        return false;\n\n    if( m_tif && m_width && m_height )\n    {\n        TIFF* tif = (TIFF*)m_tif;\n        uint32 tile_width0 = m_width, tile_height0 = 0;\n        int x, y, i;\n        int is_tiled = TIFFIsTiled(tif);\n        uint16 photometric;\n        TIFFGetField( tif, TIFFTAG_PHOTOMETRIC, &photometric );\n        uint16 bpp = 8, ncn = photometric > 1 ? 3 : 1;\n        TIFFGetField( tif, TIFFTAG_BITSPERSAMPLE, &bpp );\n        TIFFGetField( tif, TIFFTAG_SAMPLESPERPIXEL, &ncn );\n        const int bitsPerByte = 8;\n        int dst_bpp = (int)(img.elemSize1() * bitsPerByte);\n        int wanted_channels = normalizeChannelsNumber(img.channels());\n\n        if(dst_bpp == 8)\n        {\n            char errmsg[1024];\n            if(!TIFFRGBAImageOK( tif, errmsg ))\n            {\n                close();\n                return false;\n            }\n        }\n\n        if( (!is_tiled) ||\n            (is_tiled &&\n            TIFFGetField( tif, TIFFTAG_TILEWIDTH, &tile_width0 ) &&\n            TIFFGetField( tif, TIFFTAG_TILELENGTH, &tile_height0 )))\n        {\n            if(!is_tiled)\n                TIFFGetField( tif, TIFFTAG_ROWSPERSTRIP, &tile_height0 );\n\n            if( tile_width0 <= 0 )\n                tile_width0 = m_width;\n\n            if( tile_height0 <= 0 )\n                tile_height0 = m_height;\n\n            AutoBuffer<uchar> _buffer( size_t(8) * tile_height0*tile_width0);\n            uchar* buffer = _buffer;\n            ushort* buffer16 = (ushort*)buffer;\n            float* buffer32 = (float*)buffer;\n            double* buffer64 = (double*)buffer;\n            int tileidx = 0;\n\n            for( y = 0; y < m_height; y += tile_height0, data += img.step*tile_height0 )\n            {\n                int tile_height = tile_height0;\n\n                if( y + tile_height > m_height )\n                    tile_height = m_height - y;\n\n                for( x = 0; x < m_width; x += tile_width0, tileidx++ )\n                {\n                    int tile_width = tile_width0, ok;\n\n                    if( x + tile_width > m_width )\n                        tile_width = m_width - x;\n\n                    switch(dst_bpp)\n                    {\n                        case 8:\n                        {\n                            uchar * bstart = buffer;\n                            if( !is_tiled )\n                                ok = TIFFReadRGBAStrip( tif, y, (uint32*)buffer );\n                            else\n                            {\n                                ok = TIFFReadRGBATile( tif, x, y, (uint32*)buffer );\n                                //Tiles fill the buffer from the bottom up\n                                bstart += (tile_height0 - tile_height) * tile_width0 * 4;\n                            }\n                            if( !ok )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                                if( color )\n                                {\n                                    if (wanted_channels == 4)\n                                    {\n                                        icvCvt_BGRA2RGBA_8u_C4R( bstart + i*tile_width0*4, 0,\n                                                             data + x*4 + img.step*(tile_height - i - 1), 0,\n                                                             cvSize(tile_width,1) );\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2BGR_8u_C4C3R( bstart + i*tile_width0*4, 0,\n                                                             data + x*3 + img.step*(tile_height - i - 1), 0,\n                                                             cvSize(tile_width,1), 2 );\n                                    }\n                                }\n                                else\n                                    icvCvt_BGRA2Gray_8u_C4C1R( bstart + i*tile_width0*4, 0,\n                                                              data + x + img.step*(tile_height - i - 1), 0,\n                                                              cvSize(tile_width,1), 2 );\n                            break;\n                        }\n\n                        case 16:\n                        {\n                            if( !is_tiled )\n                                ok = (int)TIFFReadEncodedStrip( tif, tileidx, (uint32*)buffer, (tsize_t)-1 ) >= 0;\n                            else\n                                ok = (int)TIFFReadEncodedTile( tif, tileidx, (uint32*)buffer, (tsize_t)-1 ) >= 0;\n\n                            if( !ok )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                            {\n                                if( color )\n                                {\n                                    if( ncn == 1 )\n                                    {\n                                        icvCvt_Gray2BGR_16u_C1C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                                  (ushort*)(data + img.step*i) + x*3, 0,\n                                                                  cvSize(tile_width,1) );\n                                    }\n                                    else if( ncn == 3 )\n                                    {\n                                        icvCvt_RGB2BGR_16u_C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                               (ushort*)(data + img.step*i) + x*3, 0,\n                                                               cvSize(tile_width,1) );\n                                    }\n                                    else if (ncn == 4)\n                                    {\n                                        if (wanted_channels == 4)\n                                        {\n                                            icvCvt_BGRA2RGBA_16u_C4R(buffer16 + i*tile_width0*ncn, 0,\n                                                (ushort*)(data + img.step*i) + x * 4, 0,\n                                                cvSize(tile_width, 1));\n                                        }\n                                        else\n                                        {\n                                            icvCvt_BGRA2BGR_16u_C4C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                (ushort*)(data + img.step*i) + x * 3, 0,\n                                                cvSize(tile_width, 1), 2);\n                                        }\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2BGR_16u_C4C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                               (ushort*)(data + img.step*i) + x*3, 0,\n                                                               cvSize(tile_width,1), 2 );\n                                    }\n                                }\n                                else\n                                {\n                                    if( ncn == 1 )\n                                    {\n                                        memcpy((ushort*)(data + img.step*i)+x,\n                                               buffer16 + i*tile_width0*ncn,\n                                               tile_width*sizeof(buffer16[0]));\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2Gray_16u_CnC1R(buffer16 + i*tile_width0*ncn, 0,\n                                                               (ushort*)(data + img.step*i) + x, 0,\n                                                               cvSize(tile_width,1), ncn, 2 );\n                                    }\n                                }\n                            }\n                            break;\n                        }\n\n                        case 32:\n                        case 64:\n                        {\n                            if( !is_tiled )\n                                ok = (int)TIFFReadEncodedStrip( tif, tileidx, buffer, (tsize_t)-1 ) >= 0;\n                            else\n                                ok = (int)TIFFReadEncodedTile( tif, tileidx, buffer, (tsize_t)-1 ) >= 0;\n\n                            if( !ok || ncn != 1 )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                            {\n                                if(dst_bpp == 32)\n                                {\n                                    memcpy((float*)(data + img.step*i)+x,\n                                           buffer32 + i*tile_width0*ncn,\n                                           tile_width*sizeof(buffer32[0]));\n                                }\n                                else\n                                {\n                                    memcpy((double*)(data + img.step*i)+x,\n                                         buffer64 + i*tile_width0*ncn,\n                                         tile_width*sizeof(buffer64[0]));\n                                }\n                            }\n\n                            break;\n                        }\n                        default:\n                        {\n                            close();\n                            return false;\n                        }\n                    }\n                }\n            }\n\n            result = true;\n        }\n    }\n\n    close();\n    return result;\n}",
    "bool  TiffDecoder::readData( Mat& img )\n{\n    bool result = false;\n    bool color = img.channels() > 1;\n    uchar* data = img.data;\n\n    if( img.depth() != CV_8U && img.depth() != CV_16U && img.depth() != CV_32F && img.depth() != CV_64F )\n        return false;\n\n    if( m_tif && m_width && m_height )\n    {\n        TIFF* tif = (TIFF*)m_tif;\n        int tile_width0 = m_width, tile_height0 = 0;\n        int x, y, i;\n        int is_tiled = TIFFIsTiled(tif);\n        int photometric;\n        TIFFGetField( tif, TIFFTAG_PHOTOMETRIC, &photometric );\n        int bpp = 8, ncn = photometric > 1 ? 3 : 1;\n        TIFFGetField( tif, TIFFTAG_BITSPERSAMPLE, &bpp );\n        TIFFGetField( tif, TIFFTAG_SAMPLESPERPIXEL, &ncn );\n        const int bitsPerByte = 8;\n        int dst_bpp = (int)(img.elemSize1() * bitsPerByte);\n\n        if(dst_bpp == 8)\n        {\n            char errmsg[1024];\n            if(!TIFFRGBAImageOK( tif, errmsg ))\n            {\n                close();\n                return false;\n            }\n        }\n\n        if( (!is_tiled) ||\n            (is_tiled &&\n            TIFFGetField( tif, TIFFTAG_TILEWIDTH, &tile_width0 ) &&\n            TIFFGetField( tif, TIFFTAG_TILELENGTH, &tile_height0 )))\n        {\n            if(!is_tiled)\n                TIFFGetField( tif, TIFFTAG_ROWSPERSTRIP, &tile_height0 );\n\n            if( tile_width0 <= 0 )\n                tile_width0 = m_width;\n\n            if( tile_height0 <= 0 )\n                tile_height0 = m_height;\n\n            AutoBuffer<uchar> _buffer( size_t(8) * tile_height0*tile_width0);\n            uchar* buffer = _buffer;\n            ushort* buffer16 = (ushort*)buffer;\n            float* buffer32 = (float*)buffer;\n            double* buffer64 = (double*)buffer;\n            int tileidx = 0;\n\n            for( y = 0; y < m_height; y += tile_height0, data += img.step*tile_height0 )\n            {\n                int tile_height = tile_height0;\n\n                if( y + tile_height > m_height )\n                    tile_height = m_height - y;\n\n                for( x = 0; x < m_width; x += tile_width0, tileidx++ )\n                {\n                    int tile_width = tile_width0, ok;\n\n                    if( x + tile_width > m_width )\n                        tile_width = m_width - x;\n\n                    switch(dst_bpp)\n                    {\n                        case 8:\n                        {\n                            if( !is_tiled )\n                                ok = TIFFReadRGBAStrip( tif, y, (uint32*)buffer );\n                            else\n                                ok = TIFFReadRGBATile( tif, x, y, (uint32*)buffer );\n\n                            if( !ok )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                                if( color )\n                                    icvCvt_BGRA2BGR_8u_C4C3R( buffer + i*tile_width*4, 0,\n                                                             data + x*3 + img.step*(tile_height - i - 1), 0,\n                                                             cvSize(tile_width,1), 2 );\n                                else\n                                    icvCvt_BGRA2Gray_8u_C4C1R( buffer + i*tile_width*4, 0,\n                                                              data + x + img.step*(tile_height - i - 1), 0,\n                                                              cvSize(tile_width,1), 2 );\n                            break;\n                        }\n\n                        case 16:\n                        {\n                            if( !is_tiled )\n                                ok = (int)TIFFReadEncodedStrip( tif, tileidx, (uint32*)buffer, (tsize_t)-1 ) >= 0;\n                            else\n                                ok = (int)TIFFReadEncodedTile( tif, tileidx, (uint32*)buffer, (tsize_t)-1 ) >= 0;\n\n                            if( !ok )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                            {\n                                if( color )\n                                {\n                                    if( ncn == 1 )\n                                    {\n                                        icvCvt_Gray2BGR_16u_C1C3R(buffer16 + i*tile_width*ncn, 0,\n                                                                  (ushort*)(data + img.step*i) + x*3, 0,\n                                                                  cvSize(tile_width,1) );\n                                    }\n                                    else if( ncn == 3 )\n                                    {\n                                        icvCvt_RGB2BGR_16u_C3R(buffer16 + i*tile_width*ncn, 0,\n                                                               (ushort*)(data + img.step*i) + x*3, 0,\n                                                               cvSize(tile_width,1) );\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2BGR_16u_C4C3R(buffer16 + i*tile_width*ncn, 0,\n                                                               (ushort*)(data + img.step*i) + x*3, 0,\n                                                               cvSize(tile_width,1), 2 );\n                                    }\n                                }\n                                else\n                                {\n                                    if( ncn == 1 )\n                                    {\n                                        memcpy((ushort*)(data + img.step*i)+x,\n                                               buffer16 + i*tile_width*ncn,\n                                               tile_width*sizeof(buffer16[0]));\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2Gray_16u_CnC1R(buffer16 + i*tile_width*ncn, 0,\n                                                               (ushort*)(data + img.step*i) + x, 0,\n                                                               cvSize(tile_width,1), ncn, 2 );\n                                    }\n                                }\n                            }\n                            break;\n                        }\n\n                        case 32:\n                        case 64:\n                        {\n                            if( !is_tiled )\n                                ok = (int)TIFFReadEncodedStrip( tif, tileidx, buffer, (tsize_t)-1 ) >= 0;\n                            else\n                                ok = (int)TIFFReadEncodedTile( tif, tileidx, buffer, (tsize_t)-1 ) >= 0;\n\n                            if( !ok || ncn != 1 )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                            {\n                                if(dst_bpp == 32)\n                                {\n                                    memcpy((float*)(data + img.step*i)+x,\n                                           buffer32 + i*tile_width*ncn,\n                                           tile_width*sizeof(buffer32[0]));\n                                }\n                                else\n                                {\n                                    memcpy((double*)(data + img.step*i)+x,\n                                         buffer64 + i*tile_width*ncn,\n                                         tile_width*sizeof(buffer64[0]));\n                                }\n                            }\n\n                            break;\n                        }\n                        default:\n                        {\n                            close();\n                            return false;\n                        }\n                    }\n                }\n            }\n\n            result = true;\n        }\n    }\n\n    close();\n    return result;\n}",
    "bool  TiffDecoder::readData( Mat& img )\n{\n    bool result = false;\n    bool color = img.channels() > 1;\n    uchar* data = img.data;\n    int step = (int)img.step;\n\n    if( img.depth() != CV_8U && img.depth() != CV_16U && img.depth() != CV_32F && img.depth() != CV_64F )\n        return false;\n\n    if( m_tif && m_width && m_height )\n    {\n        TIFF* tif = (TIFF*)m_tif;\n        int tile_width0 = m_width, tile_height0 = 0;\n        int x, y, i;\n        int is_tiled = TIFFIsTiled(tif);\n        int photometric;\n        TIFFGetField( tif, TIFFTAG_PHOTOMETRIC, &photometric );\n        int bpp = 8, ncn = photometric > 1 ? 3 : 1;\n        TIFFGetField( tif, TIFFTAG_BITSPERSAMPLE, &bpp );\n        TIFFGetField( tif, TIFFTAG_SAMPLESPERPIXEL, &ncn );\n        const int bitsPerByte = 8;\n        int dst_bpp = (int)(img.elemSize1() * bitsPerByte);\n\n        if(dst_bpp == 8)\n        {\n            char errmsg[1024];\n            if(!TIFFRGBAImageOK( tif, errmsg ))\n            {\n                close();\n                return false;\n            }\n        }\n\n        if( (!is_tiled &&\n            TIFFGetField( tif, TIFFTAG_ROWSPERSTRIP, &tile_height0 )) ||\n            (is_tiled &&\n            TIFFGetField( tif, TIFFTAG_TILEWIDTH, &tile_width0 ) &&\n            TIFFGetField( tif, TIFFTAG_TILELENGTH, &tile_height0 )))\n        {\n            if( tile_width0 <= 0 )\n                tile_width0 = m_width;\n\n            if( tile_height0 <= 0 )\n                tile_height0 = m_height;\n\n            AutoBuffer<uchar> _buffer(tile_height0*tile_width0*8);\n            uchar* buffer = _buffer;\n            ushort* buffer16 = (ushort*)buffer;\n            float* buffer32 = (float*)buffer;\n            double* buffer64 = (double*)buffer;\n            int tileidx = 0;\n\n            for( y = 0; y < m_height; y += tile_height0, data += step*tile_height0 )\n            {\n                int tile_height = tile_height0;\n\n                if( y + tile_height > m_height )\n                    tile_height = m_height - y;\n\n                for( x = 0; x < m_width; x += tile_width0, tileidx++ )\n                {\n                    int tile_width = tile_width0, ok;\n\n                    if( x + tile_width > m_width )\n                        tile_width = m_width - x;\n\n                    switch(dst_bpp)\n                    {\n                        case 8:\n                        {\n                            if( !is_tiled )\n                                ok = TIFFReadRGBAStrip( tif, y, (uint32*)buffer );\n                            else\n                                ok = TIFFReadRGBATile( tif, x, y, (uint32*)buffer );\n\n                            if( !ok )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                                if( color )\n                                    icvCvt_BGRA2BGR_8u_C4C3R( buffer + i*tile_width*4, 0,\n                                                             data + x*3 + step*(tile_height - i - 1), 0,\n                                                             cvSize(tile_width,1), 2 );\n                                else\n                                    icvCvt_BGRA2Gray_8u_C4C1R( buffer + i*tile_width*4, 0,\n                                                              data + x + step*(tile_height - i - 1), 0,\n                                                              cvSize(tile_width,1), 2 );\n                            break;\n                        }\n\n                        case 16:\n                        {\n                            if( !is_tiled )\n                                ok = (int)TIFFReadEncodedStrip( tif, tileidx, (uint32*)buffer, (tsize_t)-1 ) >= 0;\n                            else\n                                ok = (int)TIFFReadEncodedTile( tif, tileidx, (uint32*)buffer, (tsize_t)-1 ) >= 0;\n\n                            if( !ok )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                            {\n                                if( color )\n                                {\n                                    if( ncn == 1 )\n                                    {\n                                        icvCvt_Gray2BGR_16u_C1C3R(buffer16 + i*tile_width*ncn, 0,\n                                                                  (ushort*)(data + step*i) + x*3, 0,\n                                                                  cvSize(tile_width,1) );\n                                    }\n                                    else if( ncn == 3 )\n                                    {\n                                        icvCvt_RGB2BGR_16u_C3R(buffer16 + i*tile_width*ncn, 0,\n                                                               (ushort*)(data + step*i) + x*3, 0,\n                                                               cvSize(tile_width,1) );\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2BGR_16u_C4C3R(buffer16 + i*tile_width*ncn, 0,\n                                                               (ushort*)(data + step*i) + x*3, 0,\n                                                               cvSize(tile_width,1), 2 );\n                                    }\n                                }\n                                else\n                                {\n                                    if( ncn == 1 )\n                                    {\n                                        memcpy((ushort*)(data + step*i)+x,\n                                               buffer16 + i*tile_width*ncn,\n                                               tile_width*sizeof(buffer16[0]));\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2Gray_16u_CnC1R(buffer16 + i*tile_width*ncn, 0,\n                                                               (ushort*)(data + step*i) + x, 0,\n                                                               cvSize(tile_width,1), ncn, 2 );\n                                    }\n                                }\n                            }\n                            break;\n                        }\n\n                        case 32:\n                        case 64:\n                        {\n                            if( !is_tiled )\n                                ok = (int)TIFFReadEncodedStrip( tif, tileidx, buffer, (tsize_t)-1 ) >= 0;\n                            else\n                                ok = (int)TIFFReadEncodedTile( tif, tileidx, buffer, (tsize_t)-1 ) >= 0;\n\n                            if( !ok || ncn != 1 )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                            {\n                                if(dst_bpp == 32)\n                                {\n                                    memcpy((float*)(data + step*i)+x,\n                                           buffer32 + i*tile_width*ncn,\n                                           tile_width*sizeof(buffer32[0]));\n                                }\n                                else\n                                {\n                                    memcpy((double*)(data + step*i)+x,\n                                         buffer64 + i*tile_width*ncn,\n                                         tile_width*sizeof(buffer64[0]));\n                                }\n                            }\n\n                            break;\n                        }\n                        default:\n                        {\n                            close();\n                            return false;\n                        }\n                    }\n                }\n            }\n\n            result = true;\n        }\n    }\n\n    close();\n    return result;\n}",
    "CPLErr GTiffRGBABand::IReadBlock( int nBlockXOff, int nBlockYOff,\n                                    void * pImage )\n\n{\n    int\t\t\tnBlockBufSize, nBlockId;\n    CPLErr\t\teErr = CE_None;\n\n    if (!poGDS->SetDirectory())\n        return CE_Failure;\n\n    nBlockBufSize = 4 * nBlockXSize * nBlockYSize;\n    nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n\n/* -------------------------------------------------------------------- */\n/*      Allocate a temporary buffer for this strip.                     */\n/* -------------------------------------------------------------------- */\n    if( poGDS->pabyBlockBuf == NULL )\n    {\n        poGDS->pabyBlockBuf = (GByte *) VSIMalloc3( 4, nBlockXSize, nBlockYSize );\n        if( poGDS->pabyBlockBuf == NULL )\n            return( CE_Failure );\n    }\n    \n/* -------------------------------------------------------------------- */\n/*      Read the strip                                                  */\n/* -------------------------------------------------------------------- */\n    if( poGDS->nLoadedBlock != nBlockId )\n    {\n        if( TIFFIsTiled( poGDS->hTIFF ) )\n        {\n            if( TIFFReadRGBATile(poGDS->hTIFF, \n                                 nBlockXOff * nBlockXSize, \n                                 nBlockYOff * nBlockYSize,\n                                 (uint32 *) poGDS->pabyBlockBuf) == -1 )\n            {\n                /* Once TIFFError() is properly hooked, this can go away */\n                CPLError( CE_Failure, CPLE_AppDefined,\n                          \"TIFFReadRGBATile() failed.\" );\n                \n                memset( poGDS->pabyBlockBuf, 0, nBlockBufSize );\n                \n                eErr = CE_Failure;\n            }\n        }\n        else\n        {\n            if( TIFFReadRGBAStrip(poGDS->hTIFF, \n                                  nBlockId * nBlockYSize,\n                                  (uint32 *) poGDS->pabyBlockBuf) == -1 )\n            {\n                /* Once TIFFError() is properly hooked, this can go away */\n                CPLError( CE_Failure, CPLE_AppDefined,\n                          \"TIFFReadRGBAStrip() failed.\" );\n                \n                memset( poGDS->pabyBlockBuf, 0, nBlockBufSize );\n                \n                eErr = CE_Failure;\n            }\n        }\n    }\n\n    poGDS->nLoadedBlock = nBlockId;\n                              \n/* -------------------------------------------------------------------- */\n/*      Handle simple case of eight bit data, and pixel interleaving.   */\n/* -------------------------------------------------------------------- */\n    int   iDestLine, nBO;\n    int   nThisBlockYSize;\n\n    if( (nBlockYOff+1) * nBlockYSize > GetYSize()\n        && !TIFFIsTiled( poGDS->hTIFF ) )\n        nThisBlockYSize = GetYSize() - nBlockYOff * nBlockYSize;\n    else\n        nThisBlockYSize = nBlockYSize;\n\n#ifdef CPL_LSB\n    nBO = nBand - 1;\n#else\n    nBO = 4 - nBand;\n#endif\n\n    for( iDestLine = 0; iDestLine < nThisBlockYSize; iDestLine++ )\n    {\n        int\tnSrcOffset;\n\n        nSrcOffset = (nThisBlockYSize - iDestLine - 1) * nBlockXSize * 4;\n\n        GDALCopyWords( poGDS->pabyBlockBuf + nBO + nSrcOffset, GDT_Byte, 4,\n                       ((GByte *) pImage)+iDestLine*nBlockXSize, GDT_Byte, 1, \n                       nBlockXSize );\n    }\n\n    return eErr;\n}",
    "bool  TiffDecoder::readData( Mat& img )\n{\n    int type = img.type();\n    int depth = CV_MAT_DEPTH(type);\n\n    CV_Assert(!m_tif.empty());\n    TIFF* tif = (TIFF*)m_tif.get();\n\n    uint16_t photometric = (uint16_t)-1;\n    CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric));\n\n    if (m_hdr && depth >= CV_32F)\n    {\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_FLOAT));\n    }\n\n    bool color = img.channels() > 1;\n\n    CV_CheckType(type, depth == CV_8U || depth == CV_8S || depth == CV_16U || depth == CV_16S || depth == CV_32S || depth == CV_32F || depth == CV_64F, \"\");\n\n    if (m_width && m_height)\n    {\n        int is_tiled = TIFFIsTiled(tif) != 0;\n        bool isGrayScale = photometric == PHOTOMETRIC_MINISWHITE || photometric == PHOTOMETRIC_MINISBLACK;\n        uint16_t bpp = 8, ncn = isGrayScale ? 1 : 3;\n        if (0 == TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bpp))\n        {\n            // TIFF bi-level images don't require TIFFTAG_BITSPERSAMPLE tag\n            bpp = 1;\n        }\n        CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &ncn));\n        uint16_t img_orientation = ORIENTATION_TOPLEFT;\n        CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_ORIENTATION, &img_orientation));\n        constexpr const int bitsPerByte = 8;\n        int dst_bpp = (int)(img.elemSize1() * bitsPerByte);\n        bool vert_flip = dst_bpp == 8 &&\n                        (img_orientation == ORIENTATION_BOTRIGHT || img_orientation == ORIENTATION_RIGHTBOT ||\n                         img_orientation == ORIENTATION_BOTLEFT || img_orientation == ORIENTATION_LEFTBOT);\n        int wanted_channels = normalizeChannelsNumber(img.channels());\n        bool doReadScanline = false;\n\n        uint32_t tile_width0 = m_width, tile_height0 = 0;\n\n        if (is_tiled)\n        {\n            CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_TILEWIDTH, &tile_width0));\n            CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_TILELENGTH, &tile_height0));\n        }\n        else\n        {\n            // optional\n            CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &tile_height0));\n        }\n\n        {\n            if (tile_width0 == 0)\n                tile_width0 = m_width;\n\n            if (tile_height0 == 0 ||\n                    (!is_tiled && tile_height0 == std::numeric_limits<uint32_t>::max()) )\n                tile_height0 = m_height;\n\n            const int TILE_MAX_WIDTH = (1 << 24);\n            const int TILE_MAX_HEIGHT = (1 << 24);\n            CV_Assert((int)tile_width0 > 0 && (int)tile_width0 <= TILE_MAX_WIDTH);\n            CV_Assert((int)tile_height0 > 0 && (int)tile_height0 <= TILE_MAX_HEIGHT);\n            const uint64_t MAX_TILE_SIZE = (CV_BIG_UINT(1) << 30);\n            CV_CheckLE((int)ncn, 4, \"\");\n            CV_CheckLE((int)bpp, 64, \"\");\n\n            if (dst_bpp == 8)\n            {\n                const int _ncn = 4; // Read RGBA\n                const int _bpp = 8; // Read 8bit\n\n                // if buffer_size(as 32bit RGBA) >= MAX_TILE_SIZE*95%,\n                // we will use TIFFReadScanline function.\n\n                if (\n                    (uint64_t)tile_width0 * tile_height0 * _ncn * std::max(1, (int)(_bpp / bitsPerByte))\n                    >=\n                    ( (uint64_t) MAX_TILE_SIZE * 95 / 100)\n                )\n                {\n                    uint16_t planerConfig = (uint16_t)-1;\n                    CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_PLANARCONFIG, &planerConfig));\n\n                    doReadScanline = (!is_tiled) // no tile\n                                     &&\n                                     ( ( ncn == 1 ) || ( ncn == 3 ) || ( ncn == 4 ) )\n                                     &&\n                                     ( ( bpp == 8 ) || ( bpp == 16 ) )\n                                     &&\n                                     (tile_height0 == (uint32_t) m_height) // single strip\n                                     &&\n                                     (\n                                         (photometric == PHOTOMETRIC_MINISWHITE)\n                                         ||\n                                         (photometric == PHOTOMETRIC_MINISBLACK)\n                                         ||\n                                         (photometric == PHOTOMETRIC_RGB)\n                                     )\n                                     &&\n                                     (planerConfig != PLANARCONFIG_SEPARATE);\n\n                    // Currently only EXTRASAMPLE_ASSOCALPHA is supported.\n                    if ( doReadScanline && ( ncn == 4 ) )\n                    {\n                        uint16_t extra_samples_num;\n                        uint16_t *extra_samples = NULL;\n                        CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_EXTRASAMPLES, &extra_samples_num, &extra_samples ));\n                        doReadScanline = ( extra_samples_num == 1 ) && ( extra_samples[0] == EXTRASAMPLE_ASSOCALPHA );\n                    }\n                }\n\n                if ( !doReadScanline )\n                {\n                    // we will use TIFFReadRGBA* functions, so allocate temporary buffer for 32bit RGBA\n                    bpp = 8;\n                    ncn = 4;\n\n                    char errmsg[1024];\n                    if (!TIFFRGBAImageOK(tif, errmsg))\n                    {\n                        CV_LOG_WARNING(NULL, \"OpenCV TIFF: TIFFRGBAImageOK: \" << errmsg);\n                        close();\n                        return false;\n                    }\n                }\n            }\n            else if (dst_bpp == 16)\n            {\n                // if buffer_size >= MAX_TILE_SIZE*95%,\n                // we will use TIFFReadScanline function.\n                if (\n                    (uint64_t)tile_width0 * tile_height0 * ncn * std::max(1, (int)(bpp / bitsPerByte))\n                    >=\n                    MAX_TILE_SIZE * 95 / 100\n                )\n                {\n                    uint16_t planerConfig = (uint16_t)-1;\n                    CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_PLANARCONFIG, &planerConfig));\n\n                    doReadScanline = (!is_tiled) // no tile\n                                     &&\n                                     ( ( ncn == 1 ) || ( ncn == 3 ) || ( ncn == 4 ) )\n                                     &&\n                                     ( ( bpp == 8 ) || ( bpp == 16 ) )\n                                     &&\n                                     (tile_height0 == (uint32_t) m_height) // single strip\n                                     &&\n                                     (\n                                         (photometric == PHOTOMETRIC_MINISWHITE)\n                                         ||\n                                         (photometric == PHOTOMETRIC_MINISBLACK)\n                                         ||\n                                         (photometric == PHOTOMETRIC_RGB)\n                                     )\n                                     &&\n                                     (planerConfig != PLANARCONFIG_SEPARATE);\n\n                    // Currently only EXTRASAMPLE_ASSOCALPHA is supported.\n                    if ( doReadScanline && ( ncn == 4 ) )\n                    {\n                        uint16_t extra_samples_num;\n                        uint16_t *extra_samples = NULL;\n                        CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_EXTRASAMPLES, &extra_samples_num, &extra_samples ));\n                        doReadScanline = ( extra_samples_num == 1 ) && ( extra_samples[0] == EXTRASAMPLE_ASSOCALPHA );\n                    }\n                }\n            }\n            else if (dst_bpp == 32 || dst_bpp == 64)\n            {\n                CV_Assert(ncn == img.channels());\n                CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP));\n            }\n\n            if ( doReadScanline )\n            {\n                // Read each scanlines.\n                tile_height0 = 1;\n            }\n\n            const size_t src_buffer_bytes_per_row = divUp(static_cast<size_t>(ncn * tile_width0 * bpp), static_cast<size_t>(bitsPerByte));\n            const size_t src_buffer_size = tile_height0 * src_buffer_bytes_per_row;\n            CV_CheckLT(src_buffer_size, MAX_TILE_SIZE, \"buffer_size is too large: >= 1Gb\");\n            const size_t src_buffer_unpacked_bytes_per_row = divUp(static_cast<size_t>(ncn * tile_width0 * dst_bpp), static_cast<size_t>(bitsPerByte));\n            const size_t src_buffer_unpacked_size = tile_height0 * src_buffer_unpacked_bytes_per_row;\n            const bool needsUnpacking = (bpp < dst_bpp);\n            AutoBuffer<uchar> _src_buffer(src_buffer_size);\n            uchar* src_buffer = _src_buffer.data();\n            AutoBuffer<uchar> _src_buffer_unpacked(needsUnpacking ? src_buffer_unpacked_size : 0);\n            uchar* src_buffer_unpacked = needsUnpacking ? _src_buffer_unpacked.data() : nullptr;\n\n            if ( doReadScanline )\n            {\n                CV_CheckGE(src_buffer_size,\n                           static_cast<size_t>(TIFFScanlineSize(tif)),\n                           \"src_buffer_size is smaller than TIFFScanlineSize().\");\n            }\n\n            int tileidx = 0;\n\n            #define MAKE_FLAG(a,b) ( (a << 8) | b )\n            const int  convert_flag = MAKE_FLAG( ncn, wanted_channels );\n            const bool isNeedConvert16to8 = ( doReadScanline ) && ( bpp == 16 ) && ( dst_bpp == 8);\n\n            for (int y = 0; y < m_height; y += (int)tile_height0)\n            {\n                int tile_height = std::min((int)tile_height0, m_height - y);\n\n                const int img_y = vert_flip ? m_height - y - tile_height : y;\n\n                for(int x = 0; x < m_width; x += (int)tile_width0, tileidx++)\n                {\n                    int tile_width = std::min((int)tile_width0, m_width - x);\n\n                    switch (dst_bpp)\n                    {\n                        case 8:\n                        {\n                            uchar* bstart = src_buffer;\n                            if (doReadScanline)\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadScanline(tif, (uint32_t*)src_buffer, y) >= 0);\n\n                                if ( isNeedConvert16to8 )\n                                {\n                                    // Convert buffer image from 16bit to 8bit.\n                                    int ix;\n                                    for ( ix = 0 ; ix < tile_width * ncn - 4; ix += 4 )\n                                    {\n                                        src_buffer[ ix     ] = src_buffer[ ix * 2 + 1 ];\n                                        src_buffer[ ix + 1 ] = src_buffer[ ix * 2 + 3 ];\n                                        src_buffer[ ix + 2 ] = src_buffer[ ix * 2 + 5 ];\n                                        src_buffer[ ix + 3 ] = src_buffer[ ix * 2 + 7 ];\n                                    }\n\n                                    for (        ; ix < tile_width * ncn ; ix ++ )\n                                    {\n                                        src_buffer[ ix ] = src_buffer[ ix * 2 + 1];\n                                    }\n                                }\n                            }\n                            else if (!is_tiled)\n                            {\n                                CV_TIFF_CHECK_CALL(TIFFReadRGBAStrip(tif, y, (uint32_t*)src_buffer));\n                            }\n                            else\n                            {\n                                CV_TIFF_CHECK_CALL(TIFFReadRGBATile(tif, x, y, (uint32_t*)src_buffer));\n                                // Tiles fill the buffer from the bottom up\n                                bstart += (tile_height0 - tile_height) * tile_width0 * 4;\n                            }\n\n                            uchar* img_line_buffer = (uchar*) img.ptr(y, 0);\n\n                            for (int i = 0; i < tile_height; i++)\n                            {\n                                if (doReadScanline)\n                                {\n                                    switch ( convert_flag )\n                                    {\n                                    case MAKE_FLAG( 1, 1 ): // GRAY to GRAY\n                                        std::memcpy( (void*) img_line_buffer,\n                                                     (void*) bstart,\n                                                     tile_width * sizeof(uchar) );\n                                        break;\n\n                                    case MAKE_FLAG( 1, 3 ): // GRAY to BGR\n                                        icvCvt_Gray2BGR_8u_C1C3R( bstart, 0,\n                                                img_line_buffer, 0,\n                                                Size(tile_width, 1) );\n                                        break;\n\n                                    case MAKE_FLAG( 3, 1): // RGB to GRAY\n                                        icvCvt_BGR2Gray_8u_C3C1R( bstart, 0,\n                                                img_line_buffer, 0,\n                                                Size(tile_width, 1) );\n                                        break;\n\n                                    case MAKE_FLAG( 3, 3 ): // RGB to BGR\n                                        if (m_use_rgb)\n                                            std::memcpy( (void*) img_line_buffer,\n                                                         (void*) bstart,\n                                                         tile_width * sizeof(uchar) );\n                                        else\n                                            icvCvt_BGR2RGB_8u_C3R( bstart, 0,\n                                                    img_line_buffer, 0,\n                                                    Size(tile_width, 1) );\n                                        break;\n\n                                    case MAKE_FLAG( 4, 1 ): // RGBA to GRAY\n                                        icvCvt_BGRA2Gray_8u_C4C1R( bstart, 0,\n                                                img_line_buffer, 0,\n                                                Size(tile_width, 1) );\n                                        break;\n\n                                    case MAKE_FLAG( 4, 3 ): // RGBA to BGR\n                                        icvCvt_BGRA2BGR_8u_C4C3R( bstart, 0,\n                                                img_line_buffer, 0,\n                                                Size(tile_width, 1), m_use_rgb ? 0 : 2);\n                                        break;\n\n                                    case MAKE_FLAG( 4, 4 ): // RGBA to BGRA\n                                        icvCvt_BGRA2RGBA_8u_C4R(bstart, 0,\n                                                img_line_buffer, 0,\n                                                Size(tile_width, 1) );\n                                        break;\n\n                                    default:\n                                        CV_LOG_ONCE_ERROR(NULL, \"OpenCV TIFF(line \" << __LINE__ << \"): Unsupported convertion :\"\n                                                               << \" bpp = \" << bpp << \" ncn = \" << (int)ncn\n                                                               << \" wanted_channels =\" << wanted_channels  );\n                                        break;\n                                    }\n                                    #undef MAKE_FLAG\n                                }\n                                else if (color)\n                                {\n                                    if (wanted_channels == 4)\n                                    {\n                                        icvCvt_BGRA2RGBA_8u_C4R(bstart + i*tile_width0*4, 0,\n                                                img.ptr(img_y + tile_height - i - 1, x), 0,\n                                                Size(tile_width, 1) );\n                                    }\n                                    else\n                                    {\n                                        CV_CheckEQ(wanted_channels, 3, \"TIFF-8bpp: BGR/BGRA images are supported only\");\n                                        icvCvt_BGRA2BGR_8u_C4C3R(bstart + i*tile_width0*4, 0,\n                                                img.ptr(img_y + tile_height - i - 1, x), 0,\n                                                Size(tile_width, 1), m_use_rgb ? 0 : 2);\n                                    }\n                                }\n                                else\n                                {\n                                    CV_CheckEQ(wanted_channels, 1, \"\");\n                                    icvCvt_BGRA2Gray_8u_C4C1R( bstart + i*tile_width0*4, 0,\n                                            img.ptr(img_y + tile_height - i - 1, x), 0,\n                                            Size(tile_width, 1), 2);\n                                }\n                            }\n                            break;\n                        }\n\n                        case 16:\n                        {\n                            if (doReadScanline)\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadScanline(tif, (uint32_t*)src_buffer, y) >= 0);\n                            }\n                            else if (!is_tiled)\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedStrip(tif, tileidx, (uint32_t*)src_buffer, src_buffer_size) >= 0);\n                            }\n                            else\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedTile(tif, tileidx, (uint32_t*)src_buffer, src_buffer_size) >= 0);\n                            }\n\n                            for (int i = 0; i < tile_height; i++)\n                            {\n                                ushort* buffer16 = (ushort*)(src_buffer+i*src_buffer_bytes_per_row);\n                                if (needsUnpacking)\n                                {\n                                    const uchar* src_packed = src_buffer+i*src_buffer_bytes_per_row;\n                                    uchar* dst_unpacked = src_buffer_unpacked+i*src_buffer_unpacked_bytes_per_row;\n                                    if (bpp == 10)\n                                        _unpack10To16(src_packed, src_packed+src_buffer_bytes_per_row,\n                                                      (ushort*)dst_unpacked, (ushort*)(dst_unpacked+src_buffer_unpacked_bytes_per_row),\n                                                      ncn * tile_width0);\n                                    else if (bpp == 12)\n                                        _unpack12To16(src_packed, src_packed+src_buffer_bytes_per_row,\n                                                      (ushort*)dst_unpacked, (ushort*)(dst_unpacked+src_buffer_unpacked_bytes_per_row),\n                                                      ncn * tile_width0);\n                                    else if (bpp == 14)\n                                        _unpack14To16(src_packed, src_packed+src_buffer_bytes_per_row,\n                                                      (ushort*)dst_unpacked, (ushort*)(dst_unpacked+src_buffer_unpacked_bytes_per_row),\n                                                      ncn * tile_width0);\n                                    buffer16 = (ushort*)dst_unpacked;\n                                }\n\n                                if (color)\n                                {\n                                    if (ncn == 1)\n                                    {\n                                        CV_CheckEQ(wanted_channels, 3, \"\");\n                                        icvCvt_Gray2BGR_16u_C1C3R(buffer16, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1));\n                                    }\n                                    else if (ncn == 3)\n                                    {\n                                        CV_CheckEQ(wanted_channels, 3, \"\");\n                                        if (m_use_rgb)\n                                            std::memcpy(buffer16, img.ptr<ushort>(img_y + i, x), tile_width * sizeof(ushort));\n                                        else\n                                            icvCvt_RGB2BGR_16u_C3R(buffer16, 0,\n                                                    img.ptr<ushort>(img_y + i, x), 0,\n                                                    Size(tile_width, 1));\n                                    }\n                                    else if (ncn == 4)\n                                    {\n                                        if (wanted_channels == 4)\n                                        {\n                                            icvCvt_BGRA2RGBA_16u_C4R(buffer16, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1));\n                                        }\n                                        else\n                                        {\n                                            CV_CheckEQ(wanted_channels, 3, \"TIFF-16bpp: BGR/BGRA images are supported only\");\n                                            icvCvt_BGRA2BGR_16u_C4C3R(buffer16, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1), m_use_rgb ? 0 : 2);\n                                        }\n                                    }\n                                    else\n                                    {\n                                        CV_Error(Error::StsError, \"Not supported\");\n                                    }\n                                }\n                                else\n                                {\n                                    CV_CheckEQ(wanted_channels, 1, \"\");\n                                    if( ncn == 1 )\n                                    {\n                                        std::memcpy(img.ptr<ushort>(img_y + i, x),\n                                                    buffer16,\n                                                    tile_width*sizeof(ushort));\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2Gray_16u_CnC1R(buffer16, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1), ncn, 2);\n                                    }\n                                }\n                            }\n                            break;\n                        }\n\n                        case 32:\n                        case 64:\n                        {\n                            if( !is_tiled )\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedStrip(tif, tileidx, src_buffer, src_buffer_size) >= 0);\n                            }\n                            else\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedTile(tif, tileidx, src_buffer, src_buffer_size) >= 0);\n                            }\n\n                            Mat m_tile(Size(tile_width0, tile_height0), CV_MAKETYPE((dst_bpp == 32) ? (depth == CV_32S ? CV_32S : CV_32F) : CV_64F, ncn), src_buffer);\n                            Rect roi_tile(0, 0, tile_width, tile_height);\n                            Rect roi_img(x, img_y, tile_width, tile_height);\n                            if (!m_hdr && ncn == 3 && !m_use_rgb)\n                                extend_cvtColor(m_tile(roi_tile), img(roi_img), COLOR_RGB2BGR);\n                            else if (!m_hdr && ncn == 4)\n                                extend_cvtColor(m_tile(roi_tile), img(roi_img), COLOR_RGBA2BGRA);\n                            else\n                                m_tile(roi_tile).copyTo(img(roi_img));\n                            break;\n                        }\n                        default:\n                        {\n                            CV_Assert(0 && \"OpenCV TIFF: unsupported depth\");\n                        }\n                    }  // switch (dst_bpp)\n                }  // for x\n            }  // for y\n        }\n        if (bpp < dst_bpp)\n          img *= (1<<(dst_bpp-bpp));\n\n        // If TIFFReadRGBA* function is used -> fixOrientationPartial().\n        // Otherwise                         -> fixOrientationFull().\n        fixOrientation(img, img_orientation,\n                       ( ( dst_bpp != 8 ) && ( !doReadScanline ) ) );\n    }\n\n    if (m_hdr && depth >= CV_32F)\n    {\n        CV_Assert(photometric == PHOTOMETRIC_LOGLUV);\n        if (m_use_rgb)\n            cvtColor(img, img, COLOR_XYZ2RGB);\n        else\n            cvtColor(img, img, COLOR_XYZ2BGR);\n    }\n    return true;\n}",
    "bool\nTIFFInput::read_native_tile(int subimage, int miplevel, int x, int y, int z,\n                            void* data)\n{\n    lock_guard lock(*this);\n    if (!seek_subimage(subimage, miplevel))\n        return false;\n    x -= m_spec.x;\n    y -= m_spec.y;\n\n    if (m_use_rgba_interface) {\n        // We punted and used the RGBA image interface\n        // libtiff has a call to read just one tile as RGBA. So that's all\n        // we need to do, not buffer the whole image.\n        m_rgbadata.resize(m_spec.tile_pixels());\n        bool ok = TIFFReadRGBATile(m_tif, x, y, m_rgbadata.data());\n        if (!ok) {\n            std::string err = oiio_tiff_last_error();\n            errorfmt(\"Unknown error trying to read TIFF as RGBA ({})\",\n                     err.size() ? err.c_str() : \"unknown error\");\n            return false;\n        }\n        // Copy, and use stride magic to reverse top-to-bottom, because\n        // TIFFReadRGBATile always returns data in bottom-to-top order.\n        int tw = std::min(m_spec.tile_width, m_spec.width - x);\n        int th = std::min(m_spec.tile_height, m_spec.height - y);\n\n        // When the vertical read size is smaller that the tile size\n        // the actual data is in the bottom end of the tile\n        // so copy_image should start from tile_height - read_height.\n        // (Again, because TIFFReadRGBATile reverses the scanline order.)\n        int vert_offset = m_spec.tile_height - th;\n\n        copy_image(m_spec.nchannels, tw, th, 1,\n                   &m_rgbadata[vert_offset * m_spec.tile_width\n                               + (th - 1) * m_spec.tile_width],\n                   m_spec.nchannels, 4, -m_spec.tile_width * 4, AutoStride,\n                   data, m_spec.nchannels,\n                   m_spec.nchannels * imagesize_t(m_spec.tile_width),\n                   AutoStride);\n        return true;\n    }\n\n    imagesize_t tile_pixels = m_spec.tile_pixels();\n    imagesize_t nvals       = tile_pixels * m_inputchannels;\n    if (m_photometric == PHOTOMETRIC_PALETTE && m_bitspersample > 8)\n        m_scratch.resize(nvals * 2);  // special case for 16 bit palette\n    else\n        m_scratch.resize(nvals * m_spec.format.size());\n    bool no_bit_convert = (m_bitspersample == 8 || m_bitspersample == 16\n                           || m_bitspersample == 32);\n    if (m_photometric == PHOTOMETRIC_PALETTE) {\n        // Convert from palette to RGB\n        if (TIFFReadTile(m_tif, &m_scratch[0], x, y, z, 0) < 0) {\n#if OIIO_TIFFLIB_VERSION < 40500\n            errorfmt(\"{}\", oiio_tiff_last_error());\n#endif\n            return false;\n        }\n        if (m_bitspersample <= 8)\n            palette_to_rgb(tile_pixels, &m_scratch[0], (unsigned char*)data);\n        else if (m_bitspersample == 16)\n            palette_to_rgb(tile_pixels, (uint16_t*)&m_scratch[0],\n                           (unsigned char*)data);\n    } else {\n        // Not palette\n        imagesize_t plane_bytes = m_spec.tile_pixels() * m_spec.format.size();\n        int planes              = m_separate ? m_inputchannels : 1;\n        std::vector<unsigned char> scratch2(m_separate ? m_spec.tile_bytes()\n                                                       : 0);\n        // Where to read?  Directly into user data if no channel shuffling\n        // or bit shifting is needed, otherwise into scratch space.\n        unsigned char* readbuf = (no_bit_convert && !m_separate)\n                                     ? (unsigned char*)data\n                                     : &m_scratch[0];\n        // Perform the reads.  Note that for contig, planes==1, so it will\n        // only do one TIFFReadTile.\n        for (int c = 0; c < planes; ++c) /* planes==1 for contig */\n            if (TIFFReadTile(m_tif, &readbuf[plane_bytes * c], x, y, z, c)\n                < 0) {\n#if OIIO_TIFFLIB_VERSION < 40500\n                errorfmt(\"{}\", oiio_tiff_last_error());\n#endif\n                return false;\n            }\n        if (m_bitspersample < 8) {\n            // m_scratch now holds nvals n-bit values, contig or separate\n            std::swap(m_scratch, scratch2);\n            for (int c = 0; c < planes; ++c) /* planes==1 for contig */\n                bit_convert(m_separate ? tile_pixels : nvals,\n                            &scratch2[plane_bytes * c], m_bitspersample,\n                            m_separate ? &m_scratch[plane_bytes * c]\n                                       : (unsigned char*)data + plane_bytes * c,\n                            8);\n        } else if (m_bitspersample > 8 && m_bitspersample < 16) {\n            // m_scratch now holds nvals n-bit values, contig or separate\n            std::swap(m_scratch, scratch2);\n            for (int c = 0; c < planes; ++c) /* planes==1 for contig */\n                bit_convert(m_separate ? tile_pixels : nvals,\n                            &scratch2[plane_bytes * c], m_bitspersample,\n                            m_separate ? &m_scratch[plane_bytes * c]\n                                       : (unsigned char*)data + plane_bytes * c,\n                            16);\n        }\n        if (m_separate) {\n            // Convert from separate (RRRGGGBBB) to contiguous (RGBRGBRGB).\n            // We know the data is in m_scratch at this point, so\n            // contiguize it into the user data area.\n            separate_to_contig(planes, tile_pixels, &m_scratch[0],\n                               (unsigned char*)data);\n        }\n    }\n\n    if (m_photometric == PHOTOMETRIC_MINISWHITE)\n        invert_photometric(nvals, data);\n\n    return true;\n}",
    "HRESULT CImageTIFF::ReadData(void* pData, PIXELFORMAT dataFormat, Size nStride, Size lineWidth)\n{\n\tif (m_state && m_width && m_height) {\n\t\tTIFF* tif = (TIFF*)m_state;\n\t\tuint32_t tile_width0 = m_width, tile_height0 = 0;\n\t\tint is_tiled = TIFFIsTiled(tif);\n\t\tuint16 photometric;\n\t\tTIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric);\n\t\tuint16 bpp = 8, ncn = photometric > 1 ? 3 : 1;\n\t\tTIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bpp);\n\t\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &ncn);\n\t\tconst int bitsPerByte = 8;\n\t\tint dst_bpp = (int)(1 * bitsPerByte);\n\t\tif (dst_bpp == 8) {\n\t\t\tchar errmsg[1024];\n\t\t\tif (!TIFFRGBAImageOK(tif, errmsg)) {\n\t\t\t\tClose();\n\t\t\t\treturn _INVALIDFILE;\n\t\t\t}\n\t\t}\n\n\t\tif ((!is_tiled) ||\n\t\t\t(is_tiled &&\n\t\t\t TIFFGetField(tif, TIFFTAG_TILEWIDTH, &tile_width0) &&\n\t\t\t TIFFGetField(tif, TIFFTAG_TILELENGTH, &tile_height0)))\n\t\t{\n\t\t\tif (!is_tiled)\n\t\t\t\tTIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &tile_height0);\n\n\t\t\tif (tile_width0 <= 0)\n\t\t\t\ttile_width0 = m_width;\n\n\t\t\tif (tile_height0 <= 0 ||\n\t\t\t\t(!is_tiled && tile_height0 == std::numeric_limits<uint32_t>::max()))\n\t\t\t\ttile_height0 = m_height;\n\n\t\t\tuint8_t* data = (uint8_t*)pData;\n\t\t\tif (!is_tiled && tile_height0 == 1 && dataFormat == m_format && nStride == m_stride) {\n\t\t\t\t// read image directly to the data buffer\n\t\t\t\tfor (Size j=0; j<m_height; ++j, data+=lineWidth)\n\t\t\t\t\tif (!TIFFReadRGBAStrip(tif, j, (uint32_t*)data)) {\n\t\t\t\t\t\tClose();\n\t\t\t\t\t\treturn _INVALIDFILE;\n\t\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// read image to a buffer and convert it\n\t\t\t\tconst size_t buffer_size = 4 * tile_height0 * tile_width0;\n\t\t\t\tCLISTDEF0(uint8_t) _buffer(buffer_size);\n\t\t\t\tuint8_t* buffer = _buffer.Begin();\n\n\t\t\t\tfor (uint32_t y = 0; y < m_height; y += tile_height0, data += lineWidth*tile_height0) {\n\t\t\t\t\tuint32_t tile_height = tile_height0;\n\t\t\t\t\tif (y + tile_height > m_height)\n\t\t\t\t\t\ttile_height = m_height - y;\n\n\t\t\t\t\tfor (uint32_t x = 0; x < m_width; x += tile_width0) {\n\t\t\t\t\t\tuint32_t tile_width = tile_width0;\n\t\t\t\t\t\tif (x + tile_width > m_width)\n\t\t\t\t\t\t\ttile_width = m_width - x;\n\n\t\t\t\t\t\tint ok;\n\t\t\t\t\t\tswitch (dst_bpp) {\n\t\t\t\t\t\tcase 8:\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tuint8_t* bstart = buffer;\n\t\t\t\t\t\t\tif (!is_tiled)\n\t\t\t\t\t\t\t\tok = TIFFReadRGBAStrip(tif, y, (uint32_t*)buffer);\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tok = TIFFReadRGBATile(tif, x, y, (uint32_t*)buffer);\n\t\t\t\t\t\t\t\t//Tiles fill the buffer from the bottom up\n\t\t\t\t\t\t\t\tbstart += (tile_height0 - tile_height) * tile_width0 * 4;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!ok) {\n\t\t\t\t\t\t\t\tClose();\n\t\t\t\t\t\t\t\treturn _INVALIDFILE;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tfor (uint32_t i = 0; i < tile_height; ++i) {\n\t\t\t\t\t\t\t\tuint8_t* dst = data + x*3 + lineWidth*(tile_height - i - 1);\n\t\t\t\t\t\t\t\tuint8_t* src = bstart + i*tile_width0*4;\n\t\t\t\t\t\t\t\tif (!FilterFormat(dst, dataFormat, nStride, src, m_format, m_stride, tile_width)) {\n\t\t\t\t\t\t\t\t\tClose();\n\t\t\t\t\t\t\t\t\treturn _FAIL;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tClose();\n\t\t\t\t\t\t\treturn _INVALIDFILE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn _OK;\n\t\t}\n\t}\n\n\tClose();\n\treturn _FAIL;\n}"
]