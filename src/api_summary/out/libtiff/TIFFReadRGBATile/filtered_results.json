{
    "SourcegraphEndpoint": "https://sourcegraph.com",
    "Query": "file:\\.(c|cpp|cc)$ lang:c++ count:all TIFFReadRGBATile",
    "Site": {
        "BuildVersion": "316984_2025-03-18_6.1-1f1695fa27f5"
    },
    "Results": [
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "930db430f912c86cc2bc9a928553c2c818801fee"
                },
                "content": "/*M///////////////////////////////////////////////////////////////////////////////////////\n//\n//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.\n//\n//  By downloading, copying, installing or using the software you agree to this license.\n//  If you do not agree to this license, do not download, install,\n//  copy or use the software.\n//\n//\n//\t\t\t\t\t\tIntel License Agreement\n//\t\t\t\tFor Open Source Computer Vision Library\n//\n// Copyright (C) 2000, Intel Corporation, all rights reserved.\n// Third party copyrights are property of their respective owners.\n//\n// Redistribution and use in source and binary forms, with or without modification,\n// are permitted provided that the following conditions are met:\n//\n//\t* Redistribution's of source code must retain the above copyright notice,\n//\t this list of conditions and the following disclaimer.\n//\n//\t* Redistribution's in binary form must reproduce the above copyright notice,\n//\t this list of conditions and the following disclaimer in the documentation\n//\t and/or other materials provided with the distribution.\n//\n//\t* The name of Intel Corporation may not be used to endorse or promote products\n//\t derived from this software without specific prior written permission.\n//\n// This software is provided by the copyright holders and contributors \"as is\" and\n// any express or implied warranties, including, but not limited to, the implied\n// warranties of merchantability and fitness for a particular purpose are disclaimed.\n// In no event shall the Intel Corporation or contributors be liable for any direct,\n// indirect, incidental, special, exemplary, or consequential damages\n// (including, but not limited to, procurement of substitute goods or services;\n// loss of use, data, or profits; or business interruption) however caused\n// and on any theory of liability, whether in contract, strict liability,\n// or tort (including negligence or otherwise) arising in any way out of\n// the use of this software, even if advised of the possibility of such damage.\n//\n//M*/\n\n/****************************************************************************************\\\n\tA part of the file implements TIFF reader on base of libtiff library\n\t(see otherlibs/_graphics/readme.txt for copyright notice)\n\\****************************************************************************************/\n\n#include \"_highgui.h\"\n#include \"grfmt_tiff.h\"\n\nstatic const char fmtSignTiffII[] = \"II\\x2a\\x00\";\nstatic const char fmtSignTiffMM[] = \"MM\\x00\\x2a\";\n\nGrFmtTiff::GrFmtTiff()\n{\n\tm_sign_len = 4;\n\tm_signature = \"\";\n\tm_description = \"TIFF Files (*.tiff;*.tif)\";\n}\n\nGrFmtTiff::~GrFmtTiff()\n{\n}\n\nbool GrFmtTiff::CheckSignature( const char* signature )\n{\n\treturn memcmp( signature, fmtSignTiffII, 4 ) == 0 ||\n\t\t\tmemcmp( signature, fmtSignTiffMM, 4 ) == 0;\n}\n\n\nGrFmtReader* GrFmtTiff::NewReader( const char* filename )\n{\n\treturn new GrFmtTiffReader( filename );\n}\n\n\nGrFmtWriter* GrFmtTiff::NewWriter( const char* filename )\n{\n\treturn new GrFmtTiffWriter( filename );\n}\n\n\n#ifdef HAVE_TIFF\n\n#include \"tiff.h\"\n#include \"tiffio.h\"\n\nstatic int grfmt_tiff_err_handler_init = 0;\n\nstatic void GrFmtSilentTIFFErrorHandler( const char*, const char*, va_list ) {}\n\nGrFmtTiffReader::GrFmtTiffReader( const char* filename ) : GrFmtReader( filename )\n{\n\tm_tif = 0;\n\n\tif( !grfmt_tiff_err_handler_init )\n\t{\n\t\tgrfmt_tiff_err_handler_init = 1;\n\n\t\tTIFFSetErrorHandler( GrFmtSilentTIFFErrorHandler );\n\t\tTIFFSetWarningHandler( GrFmtSilentTIFFErrorHandler );\n\t}\n}\n\n\nGrFmtTiffReader::~GrFmtTiffReader()\n{\n}\n\n\nvoid  GrFmtTiffReader::Close()\n{\n\tif( m_tif )\n\t{\n\t\tTIFF* tif = (TIFF*)m_tif;\n\t\tTIFFClose( tif );\n\t\tm_tif = 0;\n\t}\n}\n\n\nbool  GrFmtTiffReader::CheckFormat( const char* signature )\n{\n\treturn memcmp( signature, fmtSignTiffII, 4 ) == 0 ||\n\t\t\tmemcmp( signature, fmtSignTiffMM, 4 ) == 0;\n}\n\n\nbool  GrFmtTiffReader::ReadHeader()\n{\n\tchar errmsg[1024];\n\tbool result = false;\n\n\tClose();\n\tTIFF* tif = TIFFOpen( m_filename, \"r\" );\n\n\tif( tif )\n\t{\n\t\tint width = 0, height = 0, photometric = 0, compression = 0;\n\t\tm_tif = tif;\n\n\t\tif( TIFFRGBAImageOK( tif, errmsg ) &&\n\t\t\tTIFFGetField( tif, TIFFTAG_IMAGEWIDTH, &width ) &&\n\t\t\tTIFFGetField( tif, TIFFTAG_IMAGELENGTH, &height ) &&\n\t\t\tTIFFGetField( tif, TIFFTAG_PHOTOMETRIC, &photometric ) &&\n\t\t\t(!TIFFGetField( tif, TIFFTAG_COMPRESSION, &compression ) ||\n\t\t\t(compression != COMPRESSION_LZW &&\n\t\t\t compression != COMPRESSION_OJPEG)))\n\t\t{\n\t\t\tm_width = width;\n\t\t\tm_height = height;\n\t\t\tm_iscolor = photometric > 1;\n\n\t\t\tresult = true;\n\t\t}\n\t}\n\n\tif( !result )\n\t\tClose();\n\n\treturn result;\n}\n\n\nbool  GrFmtTiffReader::ReadData( uchar* data, int step, int color )\n{\n\tbool result = false;\n\tuchar* buffer = 0;\n\n\tcolor = color > 0 || (color < 0 && m_iscolor);\n\n\tif( m_tif && m_width && m_height )\n\t{\n\t\tTIFF* tif = (TIFF*)m_tif;\n\t\tint tile_width0 = m_width, tile_height0 = 0;\n\t\tint x, y, i;\n\t\tint is_tiled = TIFFIsTiled(tif);\n\n\t\tif( !is_tiled &&\n\t\t\tTIFFGetField( tif, TIFFTAG_ROWSPERSTRIP, &tile_height0 ) ||\n\t\t\tis_tiled &&\n\t\t\tTIFFGetField( tif, TIFFTAG_TILEWIDTH, &tile_width0 ) &&\n\t\t\tTIFFGetField( tif, TIFFTAG_TILELENGTH, &tile_height0 ))\n\t\t{\n\t\t\tif( tile_width0 <= 0 )\n\t\t\t\ttile_width0 = m_width;\n\n\t\t\tif( tile_height0 <= 0 )\n\t\t\t\ttile_height0 = m_height;\n\n\t\t\tbuffer = new uchar[tile_height0*tile_width0*4];\n\n\t\t\tfor( y = 0; y < m_height; y += tile_height0, data += step*tile_height0 )\n\t\t\t{\n\t\t\t\tint tile_height = tile_height0;\n\n\t\t\t\tif( y + tile_height > m_height )\n\t\t\t\t\ttile_height = m_height - y;\n\n\t\t\t\tfor( x = 0; x < m_width; x += tile_width0 )\n\t\t\t\t{\n\t\t\t\t\tint tile_width = tile_width0, ok;\n\n\t\t\t\t\tif( x + tile_width > m_width )\n\t\t\t\t\t\ttile_width = m_width - x;\n\n\t\t\t\t\tif( !is_tiled )\n\t\t\t\t\t\tok = TIFFReadRGBAStrip( tif, y, (uint32*)buffer );\n\t\t\t\t\telse\n\t\t\t\t\t\tok = TIFFReadRGBATile( tif, x, y, (uint32*)buffer );\n\n\t\t\t\t\tif( !ok )\n\t\t\t\t\t\tgoto exit_func;\n\n\t\t\t\t\tfor( i = 0; i < tile_height; i++ )\n\t\t\t\t\t\tif( color )\n\t\t\t\t\t\t\ticvCvt_BGRA2BGR_8u_C4C3R( buffer + i*tile_width*4, 0,\n\t\t\t\t\t\t\t\t\t\t  data + x*3 + step*(tile_height - i - 1), 0,\n\t\t\t\t\t\t\t\t\t\t  cvSize(tile_width,1), 2 );\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\ticvCvt_BGRA2Gray_8u_C4C1R( buffer + i*tile_width*4, 0,\n\t\t\t\t\t\t\t\t\t\t\tdata + x + step*(tile_height - i - 1), 0,\n\t\t\t\t\t\t\t\t\t\t\tcvSize(tile_width,1), 2 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresult = true;\n\t\t}\n\t}\n\nexit_func:\n\n\tClose();\n\tdelete[] buffer;\n\n\treturn result;\n}\n\n#else\n\nstatic const int  tiffMask[] = { 0xff, 0xff, 0xffffffff, 0xffff, 0xffffffff };\n\n/************************ TIFF reader *****************************/\n\nGrFmtTiffReader::GrFmtTiffReader( const char* filename ) : GrFmtReader( filename )\n{\n\tm_offsets = 0;\n\tm_maxoffsets = 0;\n\tm_strips = -1;\n\tm_max_pal_length = 0;\n\tm_temp_palette = 0;\n}\n\n\nGrFmtTiffReader::~GrFmtTiffReader()\n{\n\tClose();\n\n\tdelete[] m_offsets;\n\tdelete[] m_temp_palette;\n}\n\nvoid  GrFmtTiffReader::Close()\n{\n\tm_strm.Close();\n}\n\n\nbool  GrFmtTiffReader::CheckFormat( const char* signature )\n{\n\treturn memcmp( signature, fmtSignTiffII, 4 ) == 0 ||\n\t\t\tmemcmp( signature, fmtSignTiffMM, 4 ) == 0;\n}\n\n\nint\tGrFmtTiffReader::GetWordEx()\n{\n\tint val = m_strm.GetWord();\n\tif( m_byteorder == TIFF_ORDER_MM )\n\t\tval = ((val)>>8)|(((val)&0xff)<<8);\n\treturn val;\n}\n\n\nint\tGrFmtTiffReader::GetDWordEx()\n{\n\tint val = m_strm.GetDWord();\n\tif( m_byteorder == TIFF_ORDER_MM )\n\t\tval = BSWAP( val );\n\treturn val;\n}\n\n\nint  GrFmtTiffReader::ReadTable( int offset, int count,\n\t\t\t\t\t\t\t\t TiffFieldType fieldType,\n\t\t\t\t\t\t\t\t int*& array, int& arraysize )\n{\n\tint i;\n\n\tif( count < 0 )\n\t\treturn RBS_BAD_HEADER;\n\n\tif( fieldType != TIFF_TYPE_SHORT &&\n\t\tfieldType != TIFF_TYPE_LONG &&\n\t\tfieldType != TIFF_TYPE_BYTE )\n\t\treturn RBS_BAD_HEADER;\n\n\tif( count > arraysize )\n\t{\n\t\tdelete[] array;\n\t\tarraysize = arraysize*3/2;\n\t\tif( arraysize < count )\n\t\t\tarraysize = count;\n\t\tarray = new int[arraysize];\n\t}\n\n\tif( count > 1 )\n\t{\n\t\tint pos = m_strm.GetPos();\n\t\tm_strm.SetPos( offset );\n\n\t\tif( fieldType == TIFF_TYPE_LONG )\n\t\t{\n\t\t\tif( m_byteorder == TIFF_ORDER_MM )\n\t\t\t\tfor( i = 0; i < count; i++ )\n\t\t\t\t\tarray[i] = ((RMByteStream&)m_strm).GetDWord();\n\t\t\telse\n\t\t\t\tfor( i = 0; i < count; i++ )\n\t\t\t\t\tarray[i] = ((RLByteStream&)m_strm).GetDWord();\n\t\t}\n\t\telse if( fieldType == TIFF_TYPE_SHORT )\n\t\t{\n\t\t\tif( m_byteorder == TIFF_ORDER_MM )\n\t\t\t\tfor( i = 0; i < count; i++ )\n\t\t\t\t\tarray[i] = ((RMByteStream&)m_strm).GetWord();\n\t\t\telse\n\t\t\t\tfor( i = 0; i < count; i++ )\n\t\t\t\t\tarray[i] = ((RLByteStream&)m_strm).GetWord();\n\t\t}\n\t\telse // fieldType == TIFF_TYPE_BYTE\n\t\t\tfor( i = 0; i < count; i++ )\n\t\t\t\tarray[i] = m_strm.GetByte();\n\n\t\tm_strm.SetPos(pos);\n\t}\n\telse\n\t{\n\t\tassert( (offset & ~tiffMask[fieldType]) == 0 );\n\t\tarray[0] = offset;\n\t}\n\n\treturn 0;\n}\n\n\nbool  GrFmtTiffReader::ReadHeader()\n{\n\tbool result = false;\n\tint  photometric = -1;\n\tint  channels = 1;\n\tint  pal_length = -1;\n\n\tconst int MAX_CHANNELS = 4;\n\tint  bpp_arr[MAX_CHANNELS];\n\n\tassert( strlen(m_filename) != 0 );\n\tif( !m_strm.Open( m_filename )) return false;\n\n\tm_width = -1;\n\tm_height = -1;\n\tm_strips = -1;\n\tm_bpp = 1;\n\tm_compression = TIFF_UNCOMP;\n\tm_rows_per_strip = -1;\n\tm_iscolor = false;\n\n\tif( setjmp( m_strm.JmpBuf()) == 0 )\n\t{\n\t\tm_byteorder = (TiffByteOrder)m_strm.GetWord();\n\t\tm_strm.Skip( 2 );\n\t\tint header_offset = GetDWordEx();\n\n\t\tm_strm.SetPos( header_offset );\n\n\t\t// read the first tag directory\n\t\tint i, j, count = GetWordEx();\n\n\t\tfor( i = 0; i < count; i++ )\n\t\t{\n\t\t\t// read tag\n\t\t\tTiffTag tag = (TiffTag)GetWordEx();\n\t\t\tTiffFieldType fieldType = (TiffFieldType)GetWordEx();\n\t\t\tint count = GetDWordEx();\n\t\t\tint value = GetDWordEx();\n\t\t\tif( count == 1 )\n\t\t\t{\n\t\t\t\tif( m_byteorder == TIFF_ORDER_MM )\n\t\t\t\t{\n\t\t\t\t\tif( fieldType == TIFF_TYPE_SHORT )\n\t\t\t\t\t\tvalue = (unsigned)value >> 16;\n\t\t\t\t\telse if( fieldType == TIFF_TYPE_BYTE )\n\t\t\t\t\t\tvalue = (unsigned)value >> 24;\n\t\t\t\t}\n\n\t\t\t\tvalue &= tiffMask[fieldType];\n\t\t\t}\n\n\t\t\tswitch( tag )\n\t\t\t{\n\t\t\tcase  TIFF_TAG_WIDTH:\n\t\t\t\tm_width = value;\n\t\t\t\tbreak;\n\n\t\t\tcase  TIFF_TAG_HEIGHT:\n\t\t\t\tm_height = value;\n\t\t\t\tbreak;\n\n\t\t\tcase  TIFF_TAG_BITS_PER_SAMPLE:\n\t\t\t\t{\n\t\t\t\t\tint* bpp_arr_ref = bpp_arr;\n\n\t\t\t\t\tif( count > MAX_CHANNELS )\n\t\t\t\t\t\tBAD_HEADER_ERR();\n\n\t\t\t\t\tif( ReadTable( value, count, fieldType, bpp_arr_ref, count ) < 0 )\n\t\t\t\t\t\tBAD_HEADER_ERR();\n\n\t\t\t\t\tfor( j = 1; j < count; j++ )\n\t\t\t\t\t{\n\t\t\t\t\t\tif( bpp_arr[j] != bpp_arr[0] )\n\t\t\t\t\t\t\tBAD_HEADER_ERR();\n\t\t\t\t\t}\n\n\t\t\t\t\tm_bpp = bpp_arr[0];\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase  TIFF_TAG_COMPRESSION:\n\t\t\t\tm_compression = (TiffCompression)value;\n\t\t\t\tif( m_compression != TIFF_UNCOMP &&\n\t\t\t\t\tm_compression != TIFF_HUFFMAN &&\n\t\t\t\t\tm_compression != TIFF_PACKBITS )\n\t\t\t\t\tBAD_HEADER_ERR();\n\t\t\t\tbreak;\n\n\t\t\tcase  TIFF_TAG_PHOTOMETRIC:\n\t\t\t\tphotometric = value;\n\t\t\t\tif( (unsigned)photometric > 3 )\n\t\t\t\t\tBAD_HEADER_ERR();\n\t\t\t\tbreak;\n\n\t\t\tcase  TIFF_TAG_STRIP_OFFSETS:\n\t\t\t\tm_strips = count;\n\t\t\t\tif( ReadTable( value, count, fieldType, m_offsets, m_maxoffsets ) < 0 )\n\t\t\t\t\tBAD_HEADER_ERR();\n\t\t\t\tbreak;\n\n\t\t\tcase  TIFF_TAG_SAMPLES_PER_PIXEL:\n\t\t\t\tchannels = value;\n\t\t\t\tif( channels != 1 && channels != 3 && channels != 4 )\n\t\t\t\t\tBAD_HEADER_ERR();\n\t\t\t\tbreak;\n\n\t\t\tcase  TIFF_TAG_ROWS_PER_STRIP:\n\t\t\t\tm_rows_per_strip = value;\n\t\t\t\tbreak;\n\n\t\t\tcase  TIFF_TAG_PLANAR_CONFIG:\n\t\t\t\t{\n\t\t\t\tint planar_config = value;\n\t\t\t\tif( planar_config != 1 )\n\t\t\t\t\tBAD_HEADER_ERR();\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase  TIFF_TAG_COLOR_MAP:\n\t\t\t\tif( fieldType != TIFF_TYPE_SHORT || count < 2 )\n\t\t\t\t\tBAD_HEADER_ERR();\n\t\t\t\tif( ReadTable( value, count, fieldType,\n\t\t\t\t\t\t\t\tm_temp_palette, m_max_pal_length ) < 0 )\n\t\t\t\t\tBAD_HEADER_ERR();\n\t\t\t\tpal_length = count / 3;\n\t\t\t\tif( pal_length > 256 )\n\t\t\t\t\tBAD_HEADER_ERR();\n\t\t\t\tfor( i = 0; i < pal_length; i++ )\n\t\t\t\t{\n\t\t\t\t\tm_palette[i].r = (uchar)(m_temp_palette[i] >> 8);\n\t\t\t\t\tm_palette[i].g = (uchar)(m_temp_palette[i + pal_length] >> 8);\n\t\t\t\t\tm_palette[i].b = (uchar)(m_temp_palette[i + pal_length*2] >> 8);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase  TIFF_TAG_STRIP_COUNTS:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif( m_strips == 1 && m_rows_per_strip == -1 )\n\t\t\tm_rows_per_strip = m_height;\n\n\t\tif( m_width > 0 && m_height > 0 && m_strips > 0 &&\n\t\t\t(m_height + m_rows_per_strip - 1)/m_rows_per_strip == m_strips )\n\t\t{\n\t\t\tswitch( m_bpp )\n\t\t\t{\n\t\t\tcase 1:\n\t\t\t\tif( photometric == 0 || photometric == 1 && channels == 1 )\n\t\t\t\t{\n\t\t\t\t\tFillGrayPalette( m_palette, m_bpp, photometric == 0 );\n\t\t\t\t\tresult = true;\n\t\t\t\t\tm_iscolor = false;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\tcase 8:\n\t\t\t\tif( (photometric == 0 || photometric == 1 ||\n\t\t\t\t\t photometric == 3 && pal_length == (1 << m_bpp)) &&\n\t\t\t\t\tm_compression != TIFF_HUFFMAN && channels == 1 )\n\t\t\t\t{\n\t\t\t\t\tif( pal_length < 0 )\n\t\t\t\t\t{\n\t\t\t\t\t\tFillGrayPalette( m_palette, m_bpp, photometric == 0 );\n\t\t\t\t\t\tm_iscolor = false;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tm_iscolor = IsColorPalette( m_palette, m_bpp );\n\t\t\t\t\t}\n\t\t\t\t\tresult = true;\n\t\t\t\t}\n\t\t\t\telse if( photometric == 2 && pal_length < 0 &&\n\t\t\t\t\t\t (channels == 3 || channels == 4) &&\n\t\t\t\t\t\t m_compression == TIFF_UNCOMP )\n\t\t\t\t{\n\t\t\t\t\tm_bpp = 8*channels;\n\t\t\t\t\tm_iscolor = true;\n\t\t\t\t\tresult = true;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tBAD_HEADER_ERR();\n\t\t\t}\n\t\t}\nbad_header_exit:\n\t\t;\n\t}\n\n\tif( !result )\n\t{\n\t\tm_strips = -1;\n\t\tm_width = m_height = -1;\n\t\tm_strm.Close();\n\t}\n\n\treturn result;\n}\n\n\nbool  GrFmtTiffReader::ReadData( uchar* data, int step, int color )\n{\n\tconst  int buffer_size = 1 << 12;\n\tuchar  buffer[buffer_size];\n\tuchar  gray_palette[256];\n\tbool\tresult = false;\n\tuchar* src = buffer;\n\tint\tsrc_pitch = (m_width*m_bpp + 7)/8;\n\tint\ty = 0;\n\n\tif( m_strips < 0 || !m_strm.IsOpened())\n\t\treturn false;\n\n\tif( src_pitch+32 > buffer_size )\n\t\tsrc = new uchar[src_pitch+32];\n\n\tif( !color )\n\t\tif( m_bpp <= 8 )\n\t\t{\n\t\t\tCvtPaletteToGray( m_palette, gray_palette, 1 << m_bpp );\n\t\t}\n\n\tif( setjmp( m_strm.JmpBuf()) == 0 )\n\t{\n\t\tfor( int s = 0; s < m_strips; s++ )\n\t\t{\n\t\t\tint y_limit = m_rows_per_strip;\n\n\t\t\ty_limit += y;\n\t\t\tif( y_limit > m_height ) y_limit = m_height;\n\n\t\t\tm_strm.SetPos( m_offsets[s] );\n\n\t\t\tif( m_compression == TIFF_UNCOMP )\n\t\t\t{\n\t\t\t\tfor( ; y < y_limit; y++, data += step )\n\t\t\t\t{\n\t\t\t\t\tm_strm.GetBytes( src, src_pitch );\n\t\t\t\t\tif( color )\n\t\t\t\t\t\tswitch( m_bpp )\n\t\t\t\t\t\t{\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tFillColorRow1( data, src, m_width, m_palette );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\tFillColorRow4( data, src, m_width, m_palette );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 8:\n\t\t\t\t\t\t\tFillColorRow8( data, src, m_width, m_palette );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 24:\n\t\t\t\t\t\t\ticvCvt_RGB2BGR_8u_C3R( src, 0, data, 0, cvSize(m_width,1) );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 32:\n\t\t\t\t\t\t\ticvCvt_BGRA2BGR_8u_C4C3R( src, 0, data, 0, cvSize(m_width,1), 2 );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tassert(0);\n\t\t\t\t\t\t\tgoto bad_decoding_end;\n\t\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tswitch( m_bpp )\n\t\t\t\t\t\t{\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tFillGrayRow1( data, src, m_width, gray_palette );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\tFillGrayRow4( data, src, m_width, gray_palette );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 8:\n\t\t\t\t\t\t\tFillGrayRow8( data, src, m_width, gray_palette );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 24:\n\t\t\t\t\t\t\ticvCvt_BGR2Gray_8u_C3C1R( src, 0, data, 0, cvSize(m_width,1), 2 );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 32:\n\t\t\t\t\t\t\ticvCvt_BGRA2Gray_8u_C4C1R( src, 0, data, 0, cvSize(m_width,1), 2 );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tassert(0);\n\t\t\t\t\t\t\tgoto bad_decoding_end;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t}\n\n\t\t\tresult = true;\n\nbad_decoding_end:\n\n\t\t\t;\n\t\t}\n\t}\n\n\tif( src != buffer ) delete[] src;\n\treturn result;\n}\n\n#endif\n\n//////////////////////////////////////////////////////////////////////////////////////////\n\nGrFmtTiffWriter::GrFmtTiffWriter( const char* filename ) : GrFmtWriter( filename )\n{\n}\n\nGrFmtTiffWriter::~GrFmtTiffWriter()\n{\n}\n\nvoid  GrFmtTiffWriter::WriteTag( TiffTag tag, TiffFieldType fieldType,\n\t\t\t\t\t\t\t\t int count, int value )\n{\n\tm_strm.PutWord( tag );\n\tm_strm.PutWord( fieldType );\n\tm_strm.PutDWord( count );\n\tm_strm.PutDWord( value );\n}\n\n\nbool  GrFmtTiffWriter::WriteImage( const uchar* data, int step,\n\t\t\t\t\t\t\t\t\tint width, int height, int /*depth*/, int channels )\n{\n\tbool result = false;\n\tint fileStep = width*channels;\n\n\tassert( data && width > 0 && height > 0 && step >= fileStep);\n\n\tif( m_strm.Open( m_filename ) )\n\t{\n\t\tint rowsPerStrip = (1 << 13)/fileStep;\n\n\t\tif( rowsPerStrip < 1 )\n\t\t\trowsPerStrip = 1;\n\n\t\tif( rowsPerStrip > height )\n\t\t\trowsPerStrip = height;\n\n\t\tint i, stripCount = (height + rowsPerStrip - 1) / rowsPerStrip;\n/*#if defined _DEBUG || !defined WIN32\n\t\tint uncompressedRowSize = rowsPerStrip * fileStep;\n#endif*/\n\t\tint directoryOffset = 0;\n\n\t\tint* stripOffsets = new int[stripCount];\n\t\tshort* stripCounts = new short[stripCount];\n\t\tuchar* buffer = new uchar[fileStep + 32];\n\t\tint  stripOffsetsOffset = 0;\n\t\tint  stripCountsOffset = 0;\n\t\tint  bitsPerSample = 8; // TODO support 16 bit\n\t\tint  y = 0;\n\n\t\tm_strm.PutBytes( fmtSignTiffII, 4 );\n\t\tm_strm.PutDWord( directoryOffset );\n\n\t\t// write an image data first (the most reasonable way\n\t\t// for compressed images)\n\t\tfor( i = 0; i < stripCount; i++ )\n\t\t{\n\t\t\tint limit = y + rowsPerStrip;\n\n\t\t\tif( limit > height )\n\t\t\t\tlimit = height;\n\n\t\t\tstripOffsets[i] = m_strm.GetPos();\n\n\t\t\tfor( ; y < limit; y++, data += step )\n\t\t\t{\n\t\t\t\tif( channels == 3 )\n\t\t\t\t\ticvCvt_BGR2RGB_8u_C3R( data, 0, buffer, 0, cvSize(width,1) );\n\t\t\t\telse if( channels == 4 )\n\t\t\t\t\ticvCvt_BGRA2RGBA_8u_C4R( data, 0, buffer, 0, cvSize(width,1) );\n\n\t\t\t\tm_strm.PutBytes( channels > 1 ? buffer : data, fileStep );\n\t\t\t}\n\n\t\t\tstripCounts[i] = (short)(m_strm.GetPos() - stripOffsets[i]);\n\t\t\t/*assert( stripCounts[i] == uncompressedRowSize ||\n\t\t\t\t\tstripCounts[i] < uncompressedRowSize &&\n\t\t\t\t\ti == stripCount - 1);*/\n\t\t}\n\n\t\tif( stripCount > 2 )\n\t\t{\n\t\t\tstripOffsetsOffset = m_strm.GetPos();\n\t\t\tfor( i = 0; i < stripCount; i++ )\n\t\t\t\tm_strm.PutDWord( stripOffsets[i] );\n\n\t\t\tstripCountsOffset = m_strm.GetPos();\n\t\t\tfor( i = 0; i < stripCount; i++ )\n\t\t\t\tm_strm.PutWord( stripCounts[i] );\n\t\t}\n\t\telse if(stripCount == 2)\n\t\t{\n\t\t\tstripOffsetsOffset = m_strm.GetPos();\n\t\t\tfor (i = 0; i < stripCount; i++)\n\t\t\t{\n\t\t\t\tm_strm.PutDWord (stripOffsets [i]);\n\t\t\t}\n\t\t\tstripCountsOffset = stripCounts [0] + (stripCounts [1] << 16);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstripOffsetsOffset = stripOffsets[0];\n\t\t\tstripCountsOffset = stripCounts[0];\n\t\t}\n\n\t\tif( channels > 1 )\n\t\t{\n\t\t\tbitsPerSample = m_strm.GetPos();\n\t\t\tm_strm.PutWord(8);\n\t\t\tm_strm.PutWord(8);\n\t\t\tm_strm.PutWord(8);\n\t\t\tif( channels == 4 )\n\t\t\t\tm_strm.PutWord(8);\n\t\t}\n\n\t\tdirectoryOffset = m_strm.GetPos();\n\n\t\t// write header\n\t\tm_strm.PutWord( 9 );\n\n\t\t/* warning: specification 5.0 of Tiff want to have tags in\n\t\t\tascending order. This is a non-fatal error, but this cause\n\t\t\twarning with some tools. So, keep this in ascending order */\n\n\t\tWriteTag( TIFF_TAG_WIDTH, TIFF_TYPE_LONG, 1, width );\n\t\tWriteTag( TIFF_TAG_HEIGHT, TIFF_TYPE_LONG, 1, height );\n\t\tWriteTag( TIFF_TAG_BITS_PER_SAMPLE,\n\t\t\t\t  TIFF_TYPE_SHORT, channels, bitsPerSample );\n\t\tWriteTag( TIFF_TAG_COMPRESSION, TIFF_TYPE_LONG, 1, TIFF_UNCOMP );\n\t\tWriteTag( TIFF_TAG_PHOTOMETRIC, TIFF_TYPE_SHORT, 1, channels > 1 ? 2 : 1 );\n\n\t\tWriteTag( TIFF_TAG_STRIP_OFFSETS, TIFF_TYPE_LONG,\n\t\t\t\t  stripCount, stripOffsetsOffset );\n\n\t\tWriteTag( TIFF_TAG_SAMPLES_PER_PIXEL, TIFF_TYPE_SHORT, 1, channels );\n\t\tWriteTag( TIFF_TAG_ROWS_PER_STRIP, TIFF_TYPE_LONG, 1, rowsPerStrip );\n\n\t\tWriteTag( TIFF_TAG_STRIP_COUNTS,\n\t\t\t\t  stripCount > 1 ? TIFF_TYPE_SHORT : TIFF_TYPE_LONG,\n\t\t\t\t  stripCount, stripCountsOffset );\n\n\t\tm_strm.PutDWord(0);\n\t\tm_strm.Close();\n\n\t\t// write directory offset\n\t\tFILE* f = fopen( m_filename, \"r+b\" );\n\t\tbuffer[0] = (uchar)directoryOffset;\n\t\tbuffer[1] = (uchar)(directoryOffset >> 8);\n\t\tbuffer[2] = (uchar)(directoryOffset >> 16);\n\t\tbuffer[3] = (uchar)(directoryOffset >> 24);\n\n\t\tfseek( f, 4, SEEK_SET );\n\t\tfwrite( buffer, 1, 4, f );\n\t\tfclose(f);\n\n\t\tdelete[]  stripOffsets;\n\t\tdelete[]  stripCounts;\n\t\tdelete[] buffer;\n\n\t\tresult = true;\n\t}\n\treturn result;\n}\n\n",
                "name": "grfmt_tiff.cpp",
                "path": "rSDK/OpenCV/otherlibs/highgui/grfmt_tiff.cpp",
                "url": "/github.com/SortaCore/MMF2Exts/-/blob/rSDK/OpenCV/otherlibs/highgui/grfmt_tiff.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 209,
                    "offsetAndLengths": [
                        [
                            11,
                            16
                        ]
                    ],
                    "preview": "\t\t\t\t\t\tok = TIFFReadRGBATile( tif, x, y, (uint32*)buffer );"
                }
            ],
            "repository": {
                "name": "github.com/SortaCore/MMF2Exts",
                "url": "/github.com/SortaCore/MMF2Exts"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "928fc9abcb81703e7e45e8205a451e3b11dd3065"
                },
                "content": "//*******************************************************************\n//\n// License: MIT\n//\n// See LICENSE.txt file in the top level directory for more details.\n//\n// Author:  David Burken\n//          Frank Warmerdam (warmerdam@pobox.com)\n//\n// Description:\n//\n// Contains class definition for TiffTileSource.\n//\n//*******************************************************************\n//  $Id: ossimTiffTileSource.cpp 23548 2015-09-28 21:01:36Z dburken $\n\n#include <ossim/imaging/ossimTiffTileSource.h>\n#include <ossim/support_data/ossimGeoTiff.h>\n#include <ossim/support_data/ossimTiffInfo.h>\n#include <ossim/base/ossimConstants.h>\n#include <ossim/base/ossimCommon.h>\n#include <ossim/base/ossimKeywordNames.h>\n#include <ossim/base/ossimPreferences.h>\n#include <ossim/base/ossimTrace.h>\n#include <ossim/base/ossimIpt.h>\n#include <ossim/base/ossimDpt.h>\n#include <ossim/base/ossimFilename.h>\n#include <ossim/base/ossimIoStream.h> /* for ossimIOMemoryStream */\n#include <ossim/base/ossimKeywordlist.h>\n#include <ossim/base/ossimEllipsoid.h>\n#include <ossim/base/ossimDatum.h>\n#include <ossim/base/ossimBooleanProperty.h>\n#include <ossim/base/ossimStringProperty.h>\n#include <ossim/imaging/ossimImageDataFactory.h>\n#include <ossim/projection/ossimProjectionFactoryRegistry.h>\n#include <xtiffio.h>\n#include <geo_normalize.h>\n#include <cstdlib> /* for abs(int) */\n#include <ossim/base/ossimStreamFactoryRegistry.h>\n#include <ossim/support_data/TiffHandlerState.h>\n\nusing namespace std;\n\nRTTI_DEF1(ossimTiffTileSource, \"ossimTiffTileSource\", ossimImageHandler)\n\nstatic ossimTrace traceDebug(\"ossimTiffTileSource:debug\");\n\n#define OSSIM_TIFF_UNPACK_R4(value) ((value)&0x000000FF)\n#define OSSIM_TIFF_UNPACK_G4(value) (((value) >> 8) & 0x000000FF)\n#define OSSIM_TIFF_UNPACK_B4(value) (((value) >> 16) & 0x000000FF)\n#define OSSIM_TIFF_UNPACK_A4(value) (((value) >> 24) & 0x000000FF)\n\n//---\n// OSSIM_BUFFER_SCAN_LINE_READS:\n// If set to 1 ossimTiffTileSource::loadFromScanLine method will buffer image\n// width by tile height.  If set to 0 one line will be read at a time which\n// conserves memory on wide images or tall tiles.\n//\n// Buffered read is faster but uses more memory. Non-buffered slower less\n// memory.\n//\n// Only affects reading strip tiffs.\n//---\n#define OSSIM_BUFFER_SCAN_LINE_READS 1\n\n//*******************************************************************\n// Public Constructor:\n//*******************************************************************\nossimTiffTileSource::ossimTiffTileSource()\n    : ossimImageHandler(),\n      theTiffPtr(0),\n      theTile(0),\n      theBuffer(0),\n      theBufferSize(0),\n      theBufferRect(0, 0, 0, 0),\n      theBufferRLevel(0),\n      theSamplesPerPixel(0),\n      theBitsPerSample(0),\n      theSampleFormatUnit(0),\n      theMaxSampleValue(ossim::nan()),\n      theMinSampleValue(ossim::nan()),\n      theNullSampleValue(ossim::nan()),\n      theNumberOfDirectories(0),\n      theCurrentDirectory(0),\n      theR0isFullRes(false),\n      theBytesPerPixel(0),\n      theScalarType(OSSIM_SCALAR_UNKNOWN),\n      theApplyColorPaletteFlag(true),\n      theImageWidth(0),\n      theImageLength(0),\n      theReadMethod(0),\n      thePlanarConfig(0),\n      thePhotometric(0),\n      theRowsPerStrip(0),\n      theImageDirectoryList(0),\n      theMaskDirectoryList(0),\n      theCurrentTiffRlevel(0),\n      theCompressionType(0),\n      theOutputBandList(0)\n{\n}\n\nossimTiffTileSource::~ossimTiffTileSource()\n{\n   close();\n}\n\nossimRefPtr<ossimImageData> ossimTiffTileSource::getTile(\n    const ossimIrect &tile_rect, ossim_uint32 resLevel)\n{\n   if (theTile.valid() == false)\n   {\n      allocateTile(); // First time through...\n   }\n\n   if (theTile.valid())\n   {\n      // Image rectangle must be set prior to calling getTile.\n      theTile->setImageRectangle(tile_rect);\n\n      if (getTile(theTile.get(), resLevel) == false)\n      {\n         if (theTile->getDataObjectStatus() != OSSIM_NULL)\n         {\n            theTile->makeBlank();\n         }\n      }\n   }\n\n   return theTile;\n}\n\nbool ossimTiffTileSource::getTile(ossimImageData *result,\n                                  ossim_uint32 resLevel)\n{\n   static const char MODULE[] = \"ossimTiffTileSource::getTile(ossimImageData*, resLevel)\";\n\n   bool status = false;\n\n   //---\n   // Not open, this tile source bypassed, or invalid res level,\n   // return a blank tile.\n   //---\n   if (isOpen() && isSourceEnabled() && isValidRLevel(resLevel) &&\n       result && (result->getNumberOfBands() == getNumberOfOutputBands()))\n   {\n      result->ref(); // Increment ref count.\n\n      //---\n      // Check for overview tile.  Some overviews can contain r0 so always\n      // call even if resLevel is 0.  Method returns true on success, false\n      // on error.\n      //---\n      status = getOverviewTile(resLevel, result);\n\n      if (!status) // Did not get an overview tile.\n      {\n         status = true;\n\n         ossim_uint32 level = resLevel;\n\n         //---\n         // If we have r0 our reslevels are the same as the callers so\n         // no adjustment necessary.\n         //---\n         if (theStartingResLevel && !theR0isFullRes) // Used as overview.\n         {\n            //---\n            // If we have r0 our reslevels are the same as the callers so\n            // no adjustment necessary.\n            //---\n            if (level >= theStartingResLevel)\n            {\n               //---\n               // Adjust the level to be relative to the reader using this\n               // as overview.\n               //---\n               level -= theStartingResLevel;\n            }\n         }\n\n         ossimIrect tile_rect = result->getImageRectangle();\n\n         //---\n         // This should be the zero base image rectangle for this res level.\n         // Note passed the non adjusted resLevel by design.\n         //---\n         ossimIrect image_rect = getImageRectangle(resLevel);\n\n         // See if any point of the requested tile is in the image.\n         if (tile_rect.intersects(image_rect))\n         {\n            // Initialize the tile if needed as we're going to stuff it.\n            if (result->getDataObjectStatus() == OSSIM_NULL)\n            {\n               result->initialize();\n            }\n\n            bool reallocateBuffer = false;\n            if ((tile_rect.width() != (ossim_uint32)theOutputTileSize.x) ||\n                (tile_rect.height() != (ossim_uint32)theOutputTileSize.y))\n            {\n               // Current tile size must be set prior to allocatBuffer call.\n               theOutputTileSize.x = tile_rect.width();\n               theOutputTileSize.y = tile_rect.height();\n\n               reallocateBuffer = true;\n            }\n\n            if (theCurrentDirectory != theImageDirectoryList[level])               \n            {\n               status = setTiffDirectory(theImageDirectoryList[level]);\n               if (status)\n               {\n                  reallocateBuffer = true;\n               }\n            }\n\n            if (status)\n            {\n               if (reallocateBuffer)\n               {\n                  // NOTE: Using this buffer will be a thread issue. (drb)\n                  status = allocateBuffer();\n               }\n            }\n\n            if (status)\n            {\n               ossimIrect clip_rect = tile_rect.clipToRect(image_rect);\n\n               if (!tile_rect.completely_within(clip_rect))\n               {\n                  //---\n                  // We're not going to fill the whole tile so start with a\n                  // blank tile.\n                  //---\n                  result->makeBlank();\n               }\n\n               // Load the tile buffer with data from the tif.\n               if (loadTile(tile_rect, clip_rect, result))\n               {\n                  result->validate();\n                  status = true;\n               }\n               else\n               {\n                  // Would like to change this to throw ossimException.(drb)\n                  status = false;\n                  if (traceDebug())\n                  {\n                     // Error in filling buffer.\n                     ossimNotify(ossimNotifyLevel_WARN)\n                         << MODULE\n                         << \" Error filling buffer. Return status = false...\"\n                         << std::endl;\n                  }\n               }\n\n            } // matches: if (status)\n\n         } // matches:  if ( zeroBasedTileRect.intersects(image_rect) )\n         else\n         {\n            // No part of requested tile within the image rectangle.\n            status = true; // Not an error.\n            result->makeBlank();\n         }\n\n      } // matches: if (!status)\n\n      result->unref(); // Decrement ref count.\n\n   } // matches: if( isOpen() && isSourceEnabled() && isValidRLevel(level) )\n\n   return status;\n}\n\n//*******************************************************************\n// Public method:\n//*******************************************************************\nbool ossimTiffTileSource::saveState(ossimKeywordlist &kwl,\n                                    const char *prefix) const\n{\n   bool result = ossimImageHandler::saveState(kwl, prefix);\n\n   if (result)\n   {\n      if (isBandSelector() && theOutputBandList.size())\n      {\n         if (isIdentityBandList(theOutputBandList) == false)\n         {\n            // If we're not identity output the bands.\n            ossimString bandsString;\n            ossim::toSimpleStringList(bandsString, theOutputBandList);\n            kwl.add(prefix,\n                    ossimKeywordNames::BANDS_KW,\n                    bandsString,\n                    true);\n         }\n      }\n\n      kwl.add(prefix,\n              \"apply_color_palette_flag\",\n              theApplyColorPaletteFlag,\n              true);\n   }\n\n   return result;\n}\n\n//*******************************************************************\n// Public method:\n//*******************************************************************\nbool ossimTiffTileSource::loadState(const ossimKeywordlist &kwl,\n                                    const char *prefix)\n{\n   bool result = false;\n   theOutputBandList.clear();\n\n   if (ossimImageHandler::loadState(kwl, prefix))\n   {\n      std::string pfx = (prefix ? prefix : \"\");\n      std::string key = \"apply_color_palette_flag\";\n      ossimString value;\n\n      value.string() = kwl.findKey(pfx, key);\n      if (value.size())\n      {\n         theApplyColorPaletteFlag = value.toBool();\n      }\n      else\n      {\n         theApplyColorPaletteFlag = true;\n      }\n\n      key = ossimKeywordNames::BANDS_KW;\n      value.string() = kwl.findKey(pfx, key);\n      if (value.size())\n      {\n         ossim::toSimpleVector(theOutputBandList, value);\n      }\n\n      if (open())\n      {\n         // Set the band list after open so that the overview also gets set.\n         result = true;\n      }\n   }\n   return result;\n}\n\nbool ossimTiffTileSource::open(const ossimFilename &image_file)\n{\n   if (theTiffPtr)\n   {\n      close();\n   }\n   theImageFile = image_file;\n   return open();\n}\n\nvoid ossimTiffTileSource::close()\n{\n   if (theTiffPtr)\n   {\n      XTIFFClose(theTiffPtr);\n      theTiffPtr = 0;\n   }\n   if (m_streamAdaptor)\n   {\n      m_streamAdaptor->close();\n      m_streamAdaptor.reset();\n   }\n\n   theImageWidth.clear();\n   theImageLength.clear();\n   theReadMethod.clear();\n   thePlanarConfig.clear();\n   thePhotometric.clear();\n   theRowsPerStrip.clear();\n   theInputTileSize.clear();\n   if (theBuffer)\n   {\n      delete[] theBuffer;\n      theBuffer = 0;\n      theBufferSize = 0;\n   }\n   ossimImageHandler::close();\n}\n\nbool ossimTiffTileSource::open(std::shared_ptr<ossim::istream> &str,\n                               const std::string &connectionString)\n{\n   static const char MODULE[] = \"ossimTiffTileSource::open\";\n   if (isOpen())\n   {\n      close();\n   }\n\n   // Check for empty file name.\n   if (connectionString.empty())\n   {\n      return false;\n   }\n   theImageFile = ossimFilename(connectionString);\n   theImageDirectoryList.clear();\n   theMaskDirectoryList.clear();\n\n   //---\n   // Note:  The 'm' in \"rm\" is to tell TIFFOpen to not memory map the file.\n   //---\n   //theTiffPtr = XTIFFOpen(theImageFile.c_str(), \"rm\");\n   //m_streamAdaptor = std::make_shared<TiffStreamAdaptor>(this);\n   m_streamAdaptor = std::make_shared<ossim::TiffIStreamAdaptor>(str,\n                                                                 connectionString);\n\n   theTiffPtr = XTIFFClientOpen(connectionString.c_str(), \"rm\",\n                                (thandle_t)m_streamAdaptor.get(),\n                                ossim::TiffIStreamAdaptor::tiffRead,\n                                ossim::TiffIStreamAdaptor::tiffWrite,\n                                ossim::TiffIStreamAdaptor::tiffSeek,\n                                ossim::TiffIStreamAdaptor::tiffClose,\n                                ossim::TiffIStreamAdaptor::tiffSize,\n                                ossim::TiffIStreamAdaptor::tiffMap,\n                                ossim::TiffIStreamAdaptor::tiffUnmap);\n   if (!theTiffPtr)\n   {\n      if (traceDebug())\n      {\n         ossimNotify(ossimNotifyLevel_WARN)\n             << MODULE << \" ERROR:\\n\"\n             << \"libtiff could not open...\" << std::endl;\n      }\n      return false;\n   }\n   std::shared_ptr<ossim::TiffHandlerState> state = getStateAs<ossim::TiffHandlerState>();\n   if (!state)\n   {\n      state = std::make_shared<ossim::TiffHandlerState>();\n      setState(state);\n\n      state->loadDefaults(str, connectionString);\n      //state->loadDefaults(theTiffPtr);\n      state->setImageHandlerType(getClassName());\n   }\n   state->setConnectionString(connectionString);\n\n   // Current dir.\n   theCurrentDirectory = TIFFCurrentDirectory(theTiffPtr);\n   ossimString tempValue;\n   theNumberOfDirectories = state->getNumberOfDirectories();\n   // Get the number of directories.\n   if (!theNumberOfDirectories)\n   {\n      if (traceDebug())\n      {\n         ossimNotify(ossimNotifyLevel_WARN)\n             << MODULE << \" ERROR:\\n\"\n             << \"Unable to get the number of directories\\n\";\n      }\n      return false;\n   }\n\n   theCompressionType = state->getCompressionType(theCurrentDirectory);\n\n   //***\n   // Get the general tiff info.\n   //***\n\n   if (!theCompressionType)\n   {\n      theCompressionType = COMPRESSION_NONE;\n   }\n   //***\n   // See if the first directory is of FILETYPE_REDUCEDIMAGE; if not,\n   // the first level is considered to be full resolution data.\n   // Note:  If the tag is not present, consider the first level full\n   // resolution.\n   //***\n   theImageDirectoryList.push_back(0);\n\n   if (state->isReduced(theCurrentDirectory))\n   {\n      theR0isFullRes = false;\n   }\n   else\n   {\n      theR0isFullRes = true;\n   }\n\n   theBitsPerSample = state->getBitsPerSample(theCurrentDirectory);\n   theSamplesPerPixel = state->getSamplesPerPixel(theCurrentDirectory);\n   if (!theSamplesPerPixel)\n      theSamplesPerPixel = 1;\n   theSampleFormatUnit = state->getSampleFormat();\n   if (theSampleFormatUnit == SAMPLEFORMAT_COMPLEXINT)\n   {\n      //---\n      // Override the samples per pixel set above as sample data has set to\n      // one.\n      //---\n      theSamplesPerPixel = 2;\n   }\n\n   if (!state->getMaxSampleValue(theMaxSampleValue, theCurrentDirectory))\n   {\n      theMaxSampleValue = ossim::nan();\n   }\n\n   if (!state->getMinSampleValue(theMinSampleValue, theCurrentDirectory))\n   {\n      theMinSampleValue = ossim::nan();\n   }\n\n   if (traceDebug())\n   {\n      CLOG << \"DEBUG:\"\n           << \"\\ntheMinSampleValue:  \" << theMinSampleValue\n           << \"\\ntheMaxSampleValue:  \" << theMaxSampleValue\n           << endl;\n   }\n\n   theImageWidth.resize(theNumberOfDirectories);\n   theImageLength.resize(theNumberOfDirectories);\n   theReadMethod.resize(theNumberOfDirectories);\n   thePlanarConfig.resize(theNumberOfDirectories);\n   thePhotometric.resize(theNumberOfDirectories);\n   theRowsPerStrip.resize(theNumberOfDirectories);\n   theInputTileSize.resize(theNumberOfDirectories);\n\n   for (ossim_uint32 dir = 0; dir < theNumberOfDirectories; ++dir)\n   {\n      // if (setTiffDirectory(dir) == false)\n      // {\n      //    return false;\n      // }\n\n      // Note: Need lines, samples before acceptAsRrdsLayer check.\n      theImageLength[dir] = state->getImageLength(dir);\n      theImageWidth[dir] = state->getImageWidth(dir);\n      // lines:\n      if (!theImageLength[dir])\n      {\n         theErrorStatus = ossimErrorCodes::OSSIM_ERROR;\n         ossimNotify(ossimNotifyLevel_WARN)\n             << MODULE << \" Cannot determine image length.\"\n             << endl;\n      }\n\n      // samples:\n      if (!theImageWidth[dir])\n      {\n         theErrorStatus = ossimErrorCodes::OSSIM_ERROR;\n         ossimNotify(ossimNotifyLevel_WARN)\n             << MODULE << \" Cannot determine image width.\"\n             << endl;\n      }\n\n      if (dir != 0)\n      {\n         if (state->isReduced(dir))\n         {\n            //---\n            // Check for a thumbnail image.  If present don't use as it will mess with\n            // overviews.  Currently only checking if it's a two directory image, i.e. a full\n            // res and a thumbnail.\n            //\n            // Note this shuts off the thumbnail which someone may want to see.  We could make\n            // this a reader prop if it becomes an issue. drb - 09 Jan. 2012.\n            //---\n            bool acceptAsRrdsLayer = true;\n            if ((theNumberOfDirectories == 2) && (dir == 1))\n            {\n               acceptAsRrdsLayer = isPowerOfTwoDecimation(dir);\n            }\n            \n            if (acceptAsRrdsLayer)\n            {\n               theImageDirectoryList.push_back(dir);\n            }\n         }\n         else if ( (state->getSubFileType(dir) == FILETYPE_MASK) ||\n                   (state->getSubFileType(dir) == 5) )\n         {\n            // sub_file_type of 5(bit mask) is not in tiff.h yet.\n            theMaskDirectoryList.push_back(dir);\n         }\n         else\n         {\n            ossimNotify(ossimNotifyLevel_WARN)\n               << MODULE << \" WARNING:\\nUnhandled sub file type value!\"\n               << \"IFD: \" << dir << \" sub file type: \" << state->getSubFileType(dir)\n               << std::endl;\n         }\n      }\n\n      thePlanarConfig[dir] = state->getPlanarConfig(dir);\n\n      if (!thePlanarConfig[dir])\n      {\n         thePlanarConfig[dir] = PLANARCONFIG_CONTIG;\n      }\n\n      thePhotometric[dir] = state->getPhotoInterpretation(dir);\n      theLut = 0;\n      if (state->hasColorMap(dir))\n      {\n         if (theApplyColorPaletteFlag)\n         {\n            thePhotometric[dir] = PHOTOMETRIC_PALETTE;\n            theSamplesPerPixel = 3;\n         }\n         populateLut();\n      }\n      theRowsPerStrip[dir] = 0;\n      theInputTileSize[dir].x = state->getTileWidth(dir);\n      theInputTileSize[dir].y = state->getTileLength(dir);\n      theOutputTileSize = theInputTileSize[dir];\n\n      if (state->isTiled(dir))\n      {\n         if (!theInputTileSize[dir].x )\n         {\n            theErrorStatus = ossimErrorCodes::OSSIM_ERROR;\n            ossimNotify(ossimNotifyLevel_WARN)\n                << \"ossimTiffTileSource::getTiffTileWidth ERROR:\"\n                << \"\\nCannot determine tile width.\" << endl;\n         }\n         if (!theInputTileSize[dir].y)\n         {\n            theErrorStatus = ossimErrorCodes::OSSIM_ERROR;\n            ossimNotify(ossimNotifyLevel_WARN)\n                << \"ossimTiffTileSource::getTiffTileLength ERROR:\"\n                << \"\\nCannot determine tile length.\" << endl;\n            theInputTileSize[dir].y = 0;\n         }\n      }\n      else\n      {\n         //For strip NITF files let's set to a fixed 256x256 tile size\n         // There is a bug in the TIF to support this.\n         // I am commenting it out for now and will have to address this later\n         // Can't hard coce to 256\n         //\n         //theRowsPerStrip[dir] = 256;\n         // if(theImageTileWidth[dir] < 256)\n         // {\n         //    theImageTileWidth[dir] = 256;\n         // }\n\n         // we get core dumps if this is less so just set it if greater\n         // if (state->getRowsPerStrip(dir) > theRowsPerStrip[dir])\n         //    theRowsPerStrip[dir] = state->getRowsPerStrip(dir);\n\n         theRowsPerStrip[dir] = state->getRowsPerStrip(dir);\n         if (!theRowsPerStrip[dir])\n            theRowsPerStrip[dir] = 1;\n\n         // Let's default the tile size to something efficient.\n         // NOTE: This is not used by the strip reader method.  Only by the getTileWidth\n         // and getTileHeight methods.\n         if (theInputTileSize[dir].x > 256)\n            theOutputTileSize.x = 256;\n         else if (theInputTileSize[dir].x < 64)\n            theOutputTileSize.x = 64;\n         if (theInputTileSize[dir].y > 256)\n            theOutputTileSize.y = 256;\n         else if (theInputTileSize[dir].y < 64)\n            theOutputTileSize.y = 64;\n      }\n   } // End of \"for (ossim_uint32 dir=0; dir<theNumberOfDirectories; dir++)\"\n\n   // Reset the directory back to \"0\".\n   if (setTiffDirectory(0) == false)\n      return false;\n\n   //---\n   // Get the scalar type.\n   //---\n   theScalarType = OSSIM_SCALAR_UNKNOWN;\n   if (theBitsPerSample == 16)\n   {\n      theBytesPerPixel = 2;\n\n      if (theSampleFormatUnit == SAMPLEFORMAT_INT)\n      {\n         // this is currently causing pixel problems.  I am going to comment this out until we figure out a better solution\n         //\n#if 0         \n         if (theMinSampleValue == 0) //  && (theMaxSampleValue > 36535) )\n         {\n            //---\n            // This is a hack for RadarSat data which is has tag 339 set to\n            // signed sixteen bit data with a min sample value of 0 and\n            // sometimes a max sample value greater than 36535.\n            //---\n            theScalarType = OSSIM_UINT16;\n         }\n         else\n         {\n            theScalarType = OSSIM_SINT16;\n         }\n#else\n         theScalarType = OSSIM_SINT16;\n#endif\n      }\n      else if (theSampleFormatUnit == SAMPLEFORMAT_UINT)\n      {\n         // ESH 03/2009 -- Changed \"== 2047\" to \"<= 2047\"\n         if (theMaxSampleValue <= 2047) // 2^11-1\n         {\n            // 11 bit EO, i.e. Ikonos, QuickBird, WorldView, GeoEye.\n            theScalarType = OSSIM_USHORT11; // IKONOS probably...\n         }\n         else if (theMaxSampleValue <= 4095) // 2^12-1\n         {\n            theScalarType = OSSIM_USHORT12;\n         }\n         else if (theMaxSampleValue <= 8191) // 2^13-1\n         {\n            theScalarType = OSSIM_USHORT13;\n         }\n         else if (theMaxSampleValue <= 16383) // 2^14-1\n         {\n            theScalarType = OSSIM_USHORT14;\n         }\n         else if (theMaxSampleValue <= 32767) // 2^15-1\n         {\n            theScalarType = OSSIM_USHORT15;\n         }\n         else\n         {\n            theScalarType = OSSIM_UINT16;\n         }\n      }\n      else\n      {\n         if (theMaxSampleValue <= 2047) // 2^11-1\n         {\n            // 11 bit EO, i.e. Ikonos, QuickBird, WorldView, GeoEye.\n            theScalarType = OSSIM_USHORT11; // IKONOS probably...\n         }\n         else if (theMaxSampleValue <= 4095) // 2^12-1\n         {\n            theScalarType = OSSIM_USHORT12;\n         }\n         else if (theMaxSampleValue <= 8191) // 2^13-1\n         {\n            theScalarType = OSSIM_USHORT13;\n         }\n         else if (theMaxSampleValue <= 16383) // 2^14-1\n         {\n            theScalarType = OSSIM_USHORT14;\n         }\n         else if (theMaxSampleValue <= 32767) // 2^15-1\n         {\n            theScalarType = OSSIM_USHORT15;\n         }\n         else\n            theScalarType = OSSIM_UINT16; // Default to unsigned...\n      }\n   }\n   else if ((theBitsPerSample == 32) &&\n            (theSampleFormatUnit == SAMPLEFORMAT_UINT))\n   {\n      theBytesPerPixel = 4;\n      theScalarType = OSSIM_UINT32;\n   }\n   else if ((theBitsPerSample == 32) &&\n            (theSampleFormatUnit == SAMPLEFORMAT_INT))\n   {\n      theBytesPerPixel = 4;\n      theScalarType = OSSIM_SINT32;\n   }\n   else if ((theBitsPerSample == 32) &&\n            (theSampleFormatUnit == SAMPLEFORMAT_IEEEFP))\n   {\n      theBytesPerPixel = 4;\n      theScalarType = OSSIM_FLOAT32;\n   }\n   else if ((theBitsPerSample == 32) &&\n            (theSampleFormatUnit == SAMPLEFORMAT_COMPLEXINT))\n   {\n      theBytesPerPixel = 2;\n      theScalarType = OSSIM_SINT16;\n   }\n   else if (theBitsPerSample == 64 &&\n            theSampleFormatUnit == SAMPLEFORMAT_IEEEFP)\n   {\n      theBytesPerPixel = 8;\n      theScalarType = OSSIM_FLOAT64;\n   }\n   else if (theBitsPerSample <= 8)\n   {\n      theBytesPerPixel = 1;\n      theScalarType = OSSIM_UINT8;\n   }\n   else\n   {\n      ossimNotify(ossimNotifyLevel_WARN)\n          << MODULE << \" Error:\\nCannot determine scalar type.\\n\"\n          << \"Trace dump follows:\\n\";\n      print(ossimNotify(ossimNotifyLevel_WARN));\n\n      return false;\n   }\n\n   // Sanity check for min, max and null values.\n   validateMinMaxNull();\n\n   setReadMethod();\n\n   ossim_uint16 rasterType = state->getRasterType(theCurrentDirectory);\n\n   if (rasterType == 1)\n   {\n      thePixelType = OSSIM_PIXEL_IS_AREA;\n   }\n   else\n   {\n      thePixelType = OSSIM_PIXEL_IS_POINT;\n   }\n   completeOpen();\n\n   if (isBandSelector() && theOutputBandList.size() && (isIdentityBandList(theOutputBandList) == false))\n   {\n      // This does range checking and will pass to overview if open.\n      setOutputBandList(theOutputBandList);\n   }\n\n   //---\n   // Note: Logic changed to leave theTile and theBuffer uninitialized until first getTile(...)\n   // request. (drb)\n   // NOTE: Put back in\n   //---\n   allocateTile();\n\n   if (traceDebug())\n   {\n      ossimNotify(ossimNotifyLevel_DEBUG) << MODULE << \" Debug:\";\n      print(ossimNotify(ossimNotifyLevel_DEBUG));\n   }\n\n   // Finished...\n   return true;\n}\n\nbool ossimTiffTileSource::open()\n{\n   static const char MODULE[] = \"ossimTiffTileSource::open\";\n   bool result = false;\n   if (traceDebug())\n   {\n      ossimNotify(ossimNotifyLevel_DEBUG)\n          << MODULE << \" Entered...\"\n          << \"\\nFile:  \" << theImageFile.c_str() << std::endl;\n   }\n   std::shared_ptr<std::istream> tiffStream = ossim::StreamFactoryRegistry::instance()->createIstream(theImageFile);\n\n   if (tiffStream)\n   {\n      result = open(tiffStream, theImageFile);\n   }\n\n   return result;\n}\n\nbool ossimTiffTileSource::isImageTiled() const\n{\n   if (theRowsPerStrip.empty())\n      return false;\n\n   if ((theRowsPerStrip[0] == 0) && (theInputTileSize[0].y > 1))\n      return true;\n\n   return false;\n}\n\nossim_uint32 ossimTiffTileSource::getNumberOfLines(ossim_uint32 resLevel) const\n{\n   ossim_uint32 result = 0;\n   if (theImageDirectoryList.size() && theTiffPtr && isValidRLevel(resLevel))\n   {\n      //---\n      // If we have r0 our reslevels are the same as the callers so\n      // no adjustment necessary.\n      //---\n      if (!theStartingResLevel || theR0isFullRes) // not an overview or has r0.\n      {\n         //---\n         // If we have r0 our reslevels are the same as the callers so\n         // no adjustment necessary.\n         //---\n         if (resLevel < theImageDirectoryList.size())\n         {\n            result = theImageLength[theImageDirectoryList[resLevel]];\n         }\n         else if (theOverview.valid())\n         {\n            result = theOverview->getNumberOfLines(resLevel);\n         }\n      }\n      else // this is an overview without r0\n      {\n         if (resLevel >= theStartingResLevel)\n         {\n            //---\n            // Adjust the level to be relative to the reader using this as\n            // overview.\n            //---\n            ossim_uint32 level = resLevel - theStartingResLevel;\n            if (level < theImageDirectoryList.size())\n            {\n               result = theImageLength[theImageDirectoryList[level]];\n            }\n         }\n      }\n   }\n   return result;\n}\n\nossim_uint32 ossimTiffTileSource::getNumberOfSamples(ossim_uint32 resLevel) const\n{\n   ossim_uint32 result = 0;\n   if (theImageDirectoryList.size() && theTiffPtr && isValidRLevel(resLevel))\n   {\n      //---\n      // If we have r0 our reslevels are the same as the callers so\n      // no adjustment necessary.\n      //---\n      if (!theStartingResLevel || theR0isFullRes) // not an overview or has r0.\n      {\n         if (resLevel < theImageDirectoryList.size())\n         {\n            result = theImageWidth[theImageDirectoryList[resLevel]];\n         }\n         else if (theOverview.valid())\n         {\n            result = theOverview->getNumberOfSamples(resLevel);\n         }\n      }\n      else // this is an overview.\n      {\n         if (resLevel >= theStartingResLevel)\n         {\n            //---\n            // Adjust the level to be relative to the reader using this as\n            // overview.\n            //---\n            ossim_uint32 level = resLevel - theStartingResLevel;\n            if (level < theImageDirectoryList.size())\n            {\n               result = theImageWidth[theImageDirectoryList[level]];\n            }\n         }\n      }\n   }\n   return result;\n}\n\nossim_uint32 ossimTiffTileSource::getNumberOfDecimationLevels() const\n{\n   ossim_uint32 result = theImageDirectoryList.size();\n\n   // If starting res level is not 0 then this is an overview.\n   if (theStartingResLevel && theR0isFullRes)\n   {\n      // Don't count r0.\n      --result;\n   }\n   else if (theOverview.valid())\n   {\n      result += theOverview->getNumberOfDecimationLevels();\n   }\n\n   return result;\n}\n\n//*******************************************************************\n// Public method:\n//*******************************************************************\nossimScalarType ossimTiffTileSource::getOutputScalarType() const\n{\n   return theScalarType;\n}\n\nbool ossimTiffTileSource::loadTile(const ossimIrect &tile_rect,\n                                   const ossimIrect &clip_rect,\n                                   ossimImageData *result)\n{\n   static const char MODULE[] = \"ossimTiffTileSource::loadTile\";\n\n   bool status = true;\n\n   if (!theBuffer)\n   {\n      status = allocateBuffer();\n   }\n\n   if (status)\n   {\n      switch (theReadMethod[theCurrentDirectory])\n      {\n      case READ_TILE:\n         status = loadFromTile(clip_rect, result);\n         break;\n\n      case READ_SCAN_LINE:\n         status = loadFromScanLine(clip_rect, result);\n         break;\n\n      case READ_RGBA_U8_TILE:\n         status = loadFromRgbaU8Tile(tile_rect, clip_rect, result);\n         break;\n\n      case READ_RGBA_U8_STRIP:\n         status = loadFromRgbaU8Strip(tile_rect, clip_rect, result);\n         break;\n\n      case READ_RGBA_U8A_STRIP:\n         status = loadFromRgbaU8aStrip(tile_rect, clip_rect, result);\n         break;\n\n      case READ_U16_STRIP:\n         status = loadFromU16Strip(clip_rect, result);\n         break;\n\n      default:\n         ossimNotify(ossimNotifyLevel_WARN)\n             << MODULE << \" Unsupported tiff type!\" << endl;\n         status = false;\n         break;\n      }\n   }\n\n   return status;\n}\n\nbool ossimTiffTileSource::loadFromScanLine(const ossimIrect &clip_rect,\n                                           ossimImageData *result)\n{\n#if OSSIM_BUFFER_SCAN_LINE_READS\n   ossimInterleaveType type =\n       (thePlanarConfig[theCurrentDirectory] == PLANARCONFIG_CONTIG) ? OSSIM_BIP : OSSIM_BIL;\n\n   if (theBufferRLevel != getCurrentTiffRLevel() ||\n       !clip_rect.completely_within(theBufferRect))\n   {\n      //***\n      // Must reload the buffer.  Grab enough lines to fill the depth of the\n      // clip rectangle.\n      //***\n      theBufferRLevel = getCurrentTiffRLevel();\n      theBufferRect = getImageRectangle(theBufferRLevel);\n      theBufferRect.set_uly(clip_rect.ul().y);\n      theBufferRect.set_lry(clip_rect.lr().y);\n      ossim_uint32 startLine = clip_rect.ul().y;\n      ossim_uint32 stopLine = clip_rect.lr().y;\n      ossim_uint8 *buf = theBuffer;\n\n      if (thePlanarConfig[theCurrentDirectory] == PLANARCONFIG_CONTIG)\n      {\n         ossim_uint32 lineSizeInBytes = getNumberOfSamples(theBufferRLevel) *\n                                        theBytesPerPixel * theSamplesPerPixel;\n\n         for (ossim_uint32 line = startLine; line <= stopLine; ++line)\n         {\n            TIFFReadScanline(theTiffPtr, (void *)buf, line, 0);\n            buf += lineSizeInBytes;\n         }\n      }\n      else\n      {\n         ossim_uint32 lineSizeInBytes = getNumberOfSamples(theBufferRLevel) *\n                                        theBytesPerPixel;\n\n         for (ossim_uint32 line = startLine; line <= stopLine; ++line)\n         {\n            for (ossim_uint32 band = 0; band < theSamplesPerPixel; ++band)\n            {\n               TIFFReadScanline(theTiffPtr, (void *)buf, line, band);\n               buf += lineSizeInBytes;\n            }\n         }\n      }\n   }\n\n   //---\n   // Since theTile's internal rectangle is relative to any sub image offset\n   // we must adjust both the zero based \"theBufferRect\" and the zero base\n   // \"clip_rect\" before passing to\n   // theTile->loadTile method.\n   //---\n   result->loadTile(theBuffer, theBufferRect, clip_rect, type);\n   return true;\n\n#else\n   ossimInterleaveType type =\n       (thePlanarConfig[theCurrentDirectory] == PLANARCONFIG_CONTIG) ? OSSIM_BIP : OSSIM_BIL;\n\n   ossim_int32 startLine = clip_rect.ul().y;\n   ossim_int32 stopLine = clip_rect.lr().y;\n   ossim_int32 stopSamp = static_cast<ossim_int32>(getNumberOfSamples(theBufferRLevel) - 1);\n\n   if (thePlanarConfig[theCurrentDirectory] == PLANARCONFIG_CONTIG)\n   {\n      for (ossim_int32 line = startLine; line <= stopLine; ++line)\n      {\n         TIFFReadScanline(theTiffPtr, (void *)theBuffer, line, 0);\n         result->copyLine((void *)theBuffer, line, 0, stopSamp, type);\n      }\n   }\n   else\n   {\n      ossim_uint32 lineSizeInBytes = getNumberOfSamples(theBufferRLevel) * theBytesPerPixel;\n      for (ossim_int32 line = startLine; line <= stopLine; ++line)\n      {\n         ossim_uint8 *buf = theBuffer;\n         for (ossim_uint32 band = 0; band < theSamplesPerPixel; ++band)\n         {\n            TIFFReadScanline(theTiffPtr, (void *)buf, line, band);\n            buf += lineSizeInBytes;\n         }\n         result->copyLine((void *)theBuffer, line, 0, stopSamp, type);\n      }\n   }\n   return true;\n#endif /* #if OSSIM_BUFFER_SCAN_LINE_READS #else - Non buffered scan line reads. */\n}\n\nbool ossimTiffTileSource::loadFromTile(const ossimIrect &clip_rect,\n                                       ossimImageData *result)\n{\n   static const char MODULE[] = \"ossimTiffTileSource::loadFromTile\";\n\n   ossim_int32 tileSizeRead = 0;\n\n   //---\n   // Shift the upper left corner of the \"clip_rect\" to the an even tile\n   // boundary.  Note this will shift in the upper left direction.\n   //---\n   ossimIpt tileOrigin = clip_rect.ul();\n   adjustToStartOfTile(tileOrigin);\n   ossimIpt ulTilePt = tileOrigin;\n   //   ossimIpt subImageOffset = getSubImageOffset(getCurrentTiffRLevel()+theStartingResLevel);\n\n   //---\n   // Calculate the number of tiles needed in the line/sample directions.\n   //---\n   ossim_uint32 tiles_in_v_dir = (clip_rect.lr().x - tileOrigin.x + 1) /\n                                 theInputTileSize[theCurrentDirectory].x;\n   ossim_uint32 tiles_in_u_dir = (clip_rect.lr().y - tileOrigin.y + 1) /\n                                 theInputTileSize[theCurrentDirectory].y;\n\n   if ((clip_rect.lr().x - tileOrigin.x + 1) % theInputTileSize[theCurrentDirectory].x)\n      ++tiles_in_v_dir;\n   if ((clip_rect.lr().y - tileOrigin.y + 1) % theInputTileSize[theCurrentDirectory].y)\n      ++tiles_in_u_dir;\n\n   // Tile loop in line direction.\n   for (ossim_uint32 u = 0; u < tiles_in_u_dir; ++u)\n   {\n      ulTilePt.x = tileOrigin.x;\n\n      // Tile loop in sample direction.\n      for (ossim_uint32 v = 0; v < tiles_in_v_dir; ++v)\n      {\n         ossimIrect tiff_tile_rect(ulTilePt.x,\n                                   ulTilePt.y,\n                                   ulTilePt.x +\n                                       theInputTileSize[theCurrentDirectory].x - 1,\n                                   ulTilePt.y +\n                                       theInputTileSize[theCurrentDirectory].y - 1);\n\n         if (tiff_tile_rect.intersects(clip_rect))\n         {\n            ossimIrect tiff_tile_clip_rect = tiff_tile_rect.clipToRect(clip_rect);\n\n            //---\n            // Since theTile's internal rectangle is relative to any sub\n            // image offset we must adjust both the zero based\n            // \"theBufferRect\" and the zero based \"clip_rect\" before\n            // passing to theTile->loadTile method.\n            //---\n            ossimIrect bufRectWithOffset = tiff_tile_rect;       // + subImageOffset;\n            ossimIrect clipRectWithOffset = tiff_tile_clip_rect; // + subImageOffset;\n\n            if (thePlanarConfig[theCurrentDirectory] == PLANARCONFIG_CONTIG)\n            {\n               tileSizeRead = TIFFReadTile(theTiffPtr,\n                                           theBuffer,\n                                           ulTilePt.x,\n                                           ulTilePt.y,\n                                           0,\n                                           0);\n               if (tileSizeRead > 0)\n               {\n                  result->loadTile(theBuffer,\n                                   bufRectWithOffset,\n                                   clipRectWithOffset,\n                                   OSSIM_BIP);\n               }\n               else if (tileSizeRead < 0)\n               {\n                  if (traceDebug())\n                  {\n                     ossimNotify(ossimNotifyLevel_WARN)\n                         << MODULE << \" Read Error!\"\n                         << \"\\nReturning error...  \" << endl;\n                  }\n                  theErrorStatus = ossimErrorCodes::OSSIM_ERROR;\n                  return false;\n               }\n            }\n            else\n            {\n               if (theOutputBandList.empty())\n               {\n                  // This will set to identity.\n                  ossimImageSource::getOutputBandList(theOutputBandList);\n               }\n\n               // band separate tiles...\n               std::vector<ossim_uint32>::const_iterator bandIter = theOutputBandList.begin();\n               ossim_uint32 destinationBand = 0;\n               while (bandIter != theOutputBandList.end())\n               {\n                  tileSizeRead = TIFFReadTile(theTiffPtr,\n                                              theBuffer,\n                                              ulTilePt.x,\n                                              ulTilePt.y,\n                                              0,\n                                              (*bandIter));\n                  if (tileSizeRead > 0)\n                  {\n                     result->loadBand(theBuffer,\n                                      bufRectWithOffset,\n                                      clipRectWithOffset,\n                                      destinationBand);\n                  }\n                  else if (tileSizeRead < 0)\n                  {\n                     if (traceDebug())\n                     {\n                        ossimNotify(ossimNotifyLevel_WARN)\n                            << MODULE << \" Read Error!\"\n                            << \"\\nReturning error...  \" << endl;\n                     }\n                     theErrorStatus = ossimErrorCodes::OSSIM_ERROR;\n                     return false;\n                  }\n                  ++bandIter; // Next band...\n                  ++destinationBand;\n               }\n            }\n\n         } // End of if (tiff_tile_rect.intersects(clip_rect))\n\n         ulTilePt.x += theInputTileSize[theCurrentDirectory].x;\n\n      } // End of tile loop in the sample direction.\n\n      ulTilePt.y += theInputTileSize[theCurrentDirectory].y;\n\n   } // End of tile loop in the line direction.\n\n   return true;\n}\n\nbool ossimTiffTileSource::loadFromRgbaU8Tile(const ossimIrect &tile_rect,\n                                             const ossimIrect &clip_rect,\n                                             ossimImageData *result)\n{\n   static const char MODULE[] = \"ossimTiffTileSource::loadFromRgbaTile\";\n\n   if (theSamplesPerPixel != 3 || theBytesPerPixel != 1)\n   {\n      ossimNotify(ossimNotifyLevel_WARN)\n          << MODULE << \" Error:\"\n          << \"\\nInvalid number of bands or bytes per pixel!\" << endl;\n   }\n\n   //***\n   // Shift the upper left corner of the \"clip_rect\" to the an even tile\n   // boundary.  Note this will shift in the upper left direction.\n   //***\n   ossimIpt tileOrigin = clip_rect.ul();\n   adjustToStartOfTile(tileOrigin);\n\n   //---\n   // Calculate the number of tiles needed in the line/sample directions\n   // to fill the tile.\n   //---\n   ossim_uint32 tiles_in_v_dir = (clip_rect.lr().x - tileOrigin.x + 1) /\n                                 theInputTileSize[theCurrentDirectory].x;\n   ossim_uint32 tiles_in_u_dir = (clip_rect.lr().y - tileOrigin.y + 1) /\n                                 theInputTileSize[theCurrentDirectory].y;\n\n   if ((clip_rect.lr().x - tileOrigin.x + 1) %\n       theInputTileSize[theCurrentDirectory].x)\n      ++tiles_in_v_dir;\n   if ((clip_rect.lr().y - tileOrigin.y + 1) %\n       theInputTileSize[theCurrentDirectory].y)\n      ++tiles_in_u_dir;\n\n   ossimIpt ulTilePt = tileOrigin;\n\n#if 0\n   if (traceDebug())\n   {\n      CLOG << \"DEBUG:\"\n           << \"\\ntile_rect:  \" << tile_rect\n           << \"\\nclip_rect:  \" << clip_rect\n           << \"\\ntiles_in_v_dir:  \" << tiles_in_v_dir\n           << \"\\ntiles_in_u_dir:  \" << tiles_in_u_dir\n           << endl;\n   }\n#endif\n\n   // Tile loop in line direction.\n   for (ossim_uint32 u = 0; u < tiles_in_u_dir; u++)\n   {\n      ulTilePt.x = tileOrigin.x;\n\n      // Tile loop in sample direction.\n      for (ossim_uint32 v = 0; v < tiles_in_v_dir; v++)\n      {\n         ossimIrect tiff_tile_rect = ossimIrect(ulTilePt.x,\n                                                ulTilePt.y,\n                                                ulTilePt.x +\n                                                    theInputTileSize[theCurrentDirectory].x - 1,\n                                                ulTilePt.y +\n                                                    theInputTileSize[theCurrentDirectory].y - 1);\n\n         if (theBufferRLevel != getCurrentTiffRLevel() ||\n             tiff_tile_rect != theBufferRect)\n         {\n            // Need to grab a new tile.\n            // Read a tile into the buffer.\n            if (!TIFFReadRGBATile(theTiffPtr,\n                                  ulTilePt.x,\n                                  ulTilePt.y,\n                                  (uint32 *)theBuffer)) // use tiff typedef\n            {\n               ossimNotify(ossimNotifyLevel_WARN)\n                   << MODULE << \" Read Error!\"\n                   << \"\\nReturning error...\" << endl;\n               theErrorStatus = ossimErrorCodes::OSSIM_ERROR;\n               return false;\n            }\n\n            // Capture the rectangle.\n            theBufferRect = tiff_tile_rect;\n            theBufferRLevel = getCurrentTiffRLevel();\n         }\n\n         ossimIrect tile_clip_rect = clip_rect.clipToRect(theBufferRect);\n\n         //***\n         // Get the offset to the first valid pixel.\n         //\n         // Note: The data in the tile buffer is organized bottom up.  So the\n         //       coordinate must be negated in the line direction since\n         //       the met assumes an origin of upper left.\n         //***\n         ossim_uint32 in_buf_offset =\n             (tiff_tile_rect.lr().y - tile_clip_rect.ul().y) *\n                 theInputTileSize[theCurrentDirectory].x * 4 +\n             ((tile_clip_rect.ul().x - ulTilePt.x) * 4);\n\n         ossim_uint32 out_buf_offset =\n             (tile_clip_rect.ul().y - tile_rect.ul().y) *\n                 ((ossim_int32)result->getWidth()) +\n             tile_clip_rect.ul().x - tile_rect.ul().x;\n\n         //\n         // Get a pointer positioned at the first valid pixel in buffers.\n         //\n         ossim_uint32 *s = (ossim_uint32 *)(theBuffer + in_buf_offset); // s for source...\n                                                                        //         ossim_uint8* s = theBuffer + in_buf_offset;  // s for source...\n         ossim_uint8 *r = static_cast<ossim_uint8 *>(result->getBuf(0)) +\n                          out_buf_offset;\n         ossim_uint8 *g = static_cast<ossim_uint8 *>(result->getBuf(1)) +\n                          out_buf_offset;\n         ossim_uint8 *b = static_cast<ossim_uint8 *>(result->getBuf(2)) +\n                          out_buf_offset;\n\n         ossim_uint32 lines2copy = tile_clip_rect.lr().y - tile_clip_rect.ul().y + 1;\n         ossim_uint32 samps2copy = tile_clip_rect.lr().x - tile_clip_rect.ul().x + 1;\n\n         // Line loop through valid portion of the tiff tile.\n         for (ossim_uint32 line = 0; line < lines2copy; line++)\n         {\n            // Sample loop through the tiff tile.\n            ossim_uint32 i = 0;\n            ossim_uint32 j = 0;\n\n            // note the bands from the TIFF READ are stored in a, b, g, r ordering.\n            // we must reverse the bands and skip the first byte.\n            for (ossim_uint32 sample = 0; sample < samps2copy; sample++)\n            {\n               r[i] = (ossim_uint8)OSSIM_TIFF_UNPACK_R4(s[j]);\n               g[i] = (ossim_uint8)OSSIM_TIFF_UNPACK_G4(s[j]);\n               b[i] = (ossim_uint8)OSSIM_TIFF_UNPACK_B4(s[j]);\n               i++;\n               ++j;\n            }\n\n            // Increment the pointers by one line.\n            const ossim_uint32 OUTPUT_TILE_WIDTH = result->getWidth();\n            r += OUTPUT_TILE_WIDTH;\n            g += OUTPUT_TILE_WIDTH;\n            b += OUTPUT_TILE_WIDTH;\n            s -= theInputTileSize[theCurrentDirectory].x;\n         }\n\n         ulTilePt.x += theInputTileSize[theCurrentDirectory].x;\n\n      } // End of tile loop in the sample direction.\n\n      ulTilePt.y += theInputTileSize[theCurrentDirectory].y;\n\n   } // End of tile loop in the line direction.\n\n   return true;\n}\n\nbool ossimTiffTileSource::loadFromRgbaU8Strip(const ossimIrect &tile_rect,\n                                              const ossimIrect &clip_rect,\n                                              ossimImageData *result)\n{\n   static const char MODULE[] = \"ossimTiffTileSource::loadFromRgbaU8Strip\";\n\n   if (theSamplesPerPixel > 4 || theBytesPerPixel != 1)\n   {\n      ossimNotify(ossimNotifyLevel_WARN)\n          << MODULE << \" Error:\"\n          << \"\\nInvalid number of bands or bytes per pixel!\" << endl;\n   }\n\n   //***\n   // Calculate the number of strips to read.\n   //***\n   const ossim_uint32 OUTPUT_TILE_WIDTH = result->getWidth();\n\n   ossim_uint32 starting_strip = clip_rect.ul().y /\n                                 theRowsPerStrip[theCurrentDirectory];\n   ossim_uint32 ending_strip = clip_rect.lr().y /\n                               theRowsPerStrip[theCurrentDirectory];\n   ossim_uint32 strip_width = theImageWidth[theCurrentDirectory] * 4;\n   ossim_uint32 output_tile_offset = (clip_rect.ul().y - tile_rect.ul().y) *\n                                         OUTPUT_TILE_WIDTH +\n                                     clip_rect.ul().x -\n                                     tile_rect.ul().x;\n#if 0 /* Please keep for debug: */\n   CLOG << \"DEBUG:\"\n        << \"\\nsamples:         \" << theSamplesPerPixel\n        << \"\\ntile_rect:       \" << tile_rect\n        << \"\\nclip_rect:       \" << clip_rect\n        << \"\\nstarting_strip:  \" << starting_strip\n        << \"\\nending_strip:    \" << ending_strip\n        << \"\\nstrip_width:     \" << strip_width\n        << \"\\noutput_tile_offset:  \" << output_tile_offset\n        << endl;\n#endif\n\n   //***\n   // Get the pointers positioned at the first valid pixel in the buffers.\n   // s = source\n   // d = destination\n   //***\n   ossim_uint32 band;\n\n   ossim_uint8 **d = new ossim_uint8 *[theSamplesPerPixel];\n   for (band = 0; band < theSamplesPerPixel; band++)\n   {\n      d[band] = static_cast<ossim_uint8 *>(result->getBuf(band)) + output_tile_offset;\n   }\n\n   // Loop through strips...\n   for (ossim_uint32 strip = starting_strip; strip <= ending_strip; strip++)\n   {\n      if (theBufferRLevel != getCurrentTiffRLevel() ||\n          !clip_rect.completely_within(theBufferRect))\n      {\n         if (TIFFReadRGBAStrip(theTiffPtr,\n                               (strip * theRowsPerStrip[theCurrentDirectory]),\n                               (uint32 *)theBuffer) == 0) // use tiff typedef\n         {\n            ossimNotify(ossimNotifyLevel_WARN)\n                << MODULE << \" Error reading strip!\" << endl;\n            delete[] d;\n            return false;\n         }\n\n         // Capture rect and rlevel of buffer:\n         theBufferRLevel = getCurrentTiffRLevel();\n         theBufferRect = ossimIrect(\n             0,\n             starting_strip,\n             theImageWidth[theCurrentDirectory] - 1,\n             (ending_strip - starting_strip) ? (ending_strip - starting_strip) *\n                                                       theRowsPerStrip[theCurrentDirectory] -\n                                                   1\n                                             : theRowsPerStrip[theCurrentDirectory] - 1);\n      }\n\n      //***\n      // If the last strip is a partial strip then the first line of the\n      // strip will be the last line of the image.\n      //***\n      ossim_uint32 last_line = theImageLength[theCurrentDirectory] - 1;\n\n      ossim_uint32 strip_offset = ((strip * theRowsPerStrip[theCurrentDirectory]) +\n                                   theRowsPerStrip[theCurrentDirectory] - 1) <\n                                          last_line\n                                      ? 0\n                                      : ((strip * theRowsPerStrip[theCurrentDirectory]) +\n                                         theRowsPerStrip[theCurrentDirectory] - 1) -\n                                            last_line;\n\n      ossim_uint32 total_rows = theRowsPerStrip[theCurrentDirectory] -\n                                strip_offset;\n\n      for (ossim_uint32 row = 0; row < total_rows; row++)\n      {\n         // Write the line if it's in the clip rectangle.\n         ossim_int32 current_line = strip * theRowsPerStrip[theCurrentDirectory] + row;\n         if (current_line >= clip_rect.ul().y &&\n             current_line <= clip_rect.lr().y)\n         {\n            //\n            // Position the stip pointer to the correct spot.\n            //\n            // Note:\n            // A strip is organized from bottom to top and the raster buffer is\n            // orgainized from top to bottom so the lineBuf must be offset\n            // accordingly.\n            //\n            ossim_uint32 *s = (ossim_uint32 *)(theBuffer + ((theRowsPerStrip[theCurrentDirectory] - row -\n                                                             strip_offset - 1) *\n                                                                strip_width +\n                                                            clip_rect.ul().x * 4));\n\n            // Copy the data to the output buffer.\n            ossim_uint32 i = 0;\n\n            for (int32 sample = clip_rect.ul().x;\n                 sample <= clip_rect.lr().x;\n                 sample++)\n            {\n               //We had a single band strip image that is coming into this method\n               // Will add a sanity check on the samples per pixel.  If it's == 1 for now\n               // we will assign the value and if it has atleast the 3 samples then we will\n               // extract as usual.\n               //\n               if (theSamplesPerPixel >= 3)\n               {\n                  d[0][i] = OSSIM_TIFF_UNPACK_R4(*s);\n                  d[1][i] = OSSIM_TIFF_UNPACK_G4(*s);\n                  d[2][i] = OSSIM_TIFF_UNPACK_B4(*s);\n               }\n               else if (theSamplesPerPixel == 1)\n               {\n                  d[0][i] = *s;\n               }\n               ++i;\n               ++s;\n            }\n\n            for (band = 0; band < theSamplesPerPixel; band++)\n            {\n               d[band] += OUTPUT_TILE_WIDTH;\n            }\n         }\n      } // End of loop through rows in a strip.\n\n   } // End of loop through strips.\n\n   delete[] d;\n\n   return true;\n}\n\n//*******************************************************************\n// Private Method:\n//*******************************************************************\nbool ossimTiffTileSource::loadFromRgbaU8aStrip(const ossimIrect &tile_rect,\n                                               const ossimIrect &clip_rect,\n                                               ossimImageData *result)\n{\n   static const char MODULE[] = \"ossimTiffTileSource::loadFromRgbaU8aStrip\";\n\n   //***\n   // Specialized for one bit data to handle null values.\n   //***\n   const ossim_uint32 OUTPUT_TILE_WIDTH = result->getWidth();\n   const ossim_uint8 NULL_PIX = static_cast<ossim_uint8>(result->getNullPix(0));\n   const ossim_uint8 MIN_PIX = static_cast<ossim_uint8>(result->getMinPix(0));\n\n   if (theSamplesPerPixel > 4 || theBytesPerPixel != 1)\n   {\n      ossimNotify(ossimNotifyLevel_WARN)\n          << MODULE << \" Error:\"\n          << \"\\nInvalid number of bands or bytes per pixel!\" << endl;\n   }\n\n   //***\n   // Calculate the number of strips to read.\n   //***\n   ossim_uint32 starting_strip = clip_rect.ul().y /\n                                 theRowsPerStrip[theCurrentDirectory];\n   ossim_uint32 ending_strip = clip_rect.lr().y /\n                               theRowsPerStrip[theCurrentDirectory];\n   ossim_uint32 output_tile_offset = (clip_rect.ul().y - tile_rect.ul().y) *\n                                         OUTPUT_TILE_WIDTH +\n                                     clip_rect.ul().x -\n                                     tile_rect.ul().x;\n\n#if 0\n   if (traceDebug())\n   {\n      CLOG << \"DEBUG:\"\n           << \"\\ntile_rect:       \" << tile_rect\n           << \"\\nclip_rect:       \" << clip_rect\n           << \"\\nstarting_strip:  \" << starting_strip\n           << \"\\nending_strip:    \" << ending_strip\n           << \"\\nstrip_width:     \" << strip_width\n           << \"\\noutput_tile_offset:     \" << output_tile_offset\n           << \"\\nsamples:         \" << theSamplesPerPixel\n           << endl;\n   }\n#endif\n\n   //***\n   // Get the pointers positioned at the first valid pixel in the buffers.\n   // s = source\n   // d = destination\n   //***\n   ossim_uint32 band;\n\n   ossim_uint8 **d = new ossim_uint8 *[theSamplesPerPixel];\n   for (band = 0; band < theSamplesPerPixel; band++)\n   {\n      d[band] = static_cast<ossim_uint8 *>(result->getBuf(band)) + output_tile_offset;\n   }\n\n   // Loop through strips...\n   for (ossim_uint32 strip = starting_strip; strip <= ending_strip; strip++)\n   {\n      if (TIFFReadRGBAStrip(theTiffPtr,\n                            (strip * theRowsPerStrip[theCurrentDirectory]),\n                            (uint32 *)theBuffer) == 0) // use tiff typedef\n      {\n         ossimNotify(ossimNotifyLevel_WARN)\n             << MODULE << \" Error reading strip!\" << endl;\n         delete[] d;\n         return false;\n      }\n\n      //***\n      // If the last strip is a partial strip then the first line of the\n      // strip will be the last line of the image.\n      //***\n      ossim_uint32 last_line = theImageLength[theCurrentDirectory] - 1;\n\n      ossim_uint32 strip_offset = ((strip * theRowsPerStrip[theCurrentDirectory]) +\n                                   theRowsPerStrip[theCurrentDirectory] - 1) < last_line\n                                      ? 0\n                                      : ((strip * theRowsPerStrip[theCurrentDirectory]) +\n                                         theRowsPerStrip[theCurrentDirectory] - 1) -\n                                            last_line;\n\n      ossim_uint32 total_rows = theRowsPerStrip[theCurrentDirectory] -\n                                strip_offset;\n\n      for (ossim_uint32 row = 0; row < total_rows; row++)\n      {\n         // Write the line if it's in the clip rectangle.\n         ossim_int32 current_line = strip * theRowsPerStrip[theCurrentDirectory] + row;\n         if (current_line >= clip_rect.ul().y &&\n             current_line <= clip_rect.lr().y)\n         {\n            //***\n            // Position the stip pointer to the correct spot.\n            //\n            // Note:\n            // A strip is organized from bottom to top and the raster buffer is\n            // orgainized from top to bottom so the lineBuf must be offset\n            // accordingly.\n            //***\n            ossim_uint8 *s = theBuffer;\n            s += (theRowsPerStrip[theCurrentDirectory] - row -\n                  strip_offset - 1) *\n                     theImageWidth[theCurrentDirectory] * 4 +\n                 clip_rect.ul().x * 4;\n\n            // Copy the data to the output buffer.\n            ossim_uint32 i = 0;\n            ossim_uint32 j = 0;\n            for (int32 sample = clip_rect.ul().x;\n                 sample <= clip_rect.lr().x;\n                 sample++)\n            {\n               for (band = 0; band < theSamplesPerPixel; band++)\n               {\n                  ossim_uint8 pix = s[j + band];\n                  d[band][i] = pix != NULL_PIX ? pix : MIN_PIX;\n               }\n               ++i;\n               j += 4;\n            }\n\n            for (band = 0; band < theSamplesPerPixel; band++)\n            {\n               d[band] += OUTPUT_TILE_WIDTH;\n            }\n         }\n      } // End of loop through rows in a strip.\n\n   } // End of loop through strips.\n\n   delete[] d;\n\n   return true;\n\n} // End: ossimTiffTileSource::loadFromRgbaU8aStrip( ... )\n\nbool ossimTiffTileSource::loadFromU16Strip(const ossimIrect &clip_rect, ossimImageData *result)\n{\n   bool status = true;\n\n   // Calculate the strips to read.\n   ossim_uint32 starting_strip = clip_rect.ul().y / theRowsPerStrip[theCurrentDirectory];\n   ossim_uint32 ending_strip = clip_rect.lr().y / theRowsPerStrip[theCurrentDirectory];\n\n   ossim_uint32 stripsPerBand = theImageLength[theCurrentDirectory] /\n                                theRowsPerStrip[theCurrentDirectory];\n   if (theImageLength[theCurrentDirectory] % theRowsPerStrip[theCurrentDirectory])\n   {\n      ++stripsPerBand;\n   }\n\n   // Loop through strips....\n   for (ossim_uint32 strip = starting_strip; strip <= ending_strip; ++strip)\n   {\n      if (theBufferRLevel != getCurrentTiffRLevel() ||\n          !clip_rect.completely_within(theBufferRect))\n      {\n         // Fill buffer block:\n\n         ossim_uint32 linesInStrip = theRowsPerStrip[theCurrentDirectory];\n\n         // If last strip and not filling entirely memset it.\n         if (strip == (stripsPerBand - 1))\n         {\n            // Last strip of image. Strip may be clipped to end of image.\n            linesInStrip = theImageLength[theCurrentDirectory] %\n                           theRowsPerStrip[theCurrentDirectory];\n         }\n\n         ossim_uint32 bytesPerStrip = linesInStrip * theImageWidth[theCurrentDirectory] * 2;\n\n         // TIFFReadEncodedStrip takes signed int32 arg.\n         ossim_int32 bytesToRead = (ossim_int32)bytesPerStrip;\n\n         ossim_uint32 startY = strip * theRowsPerStrip[theCurrentDirectory];\n\n         // Need to read in the strip data:\n         ossim_uint32 bufferOffsetInBytes = 0;\n\n         for (ossim_uint32 band = 0; band < theSamplesPerPixel; ++band)\n         {\n            ossim_uint32 bandStrip = strip + band * stripsPerBand;\n\n            //---\n            // TIFFReadEncodedStrip does byte swapping for us.\n            // -1 says to read entire strip.\n            // Return of -1 is error.\n            //---\n            ossim_int32 bytesRead = TIFFReadEncodedStrip(theTiffPtr,\n                                                         bandStrip,\n                                                         theBuffer + bufferOffsetInBytes,\n                                                         bytesToRead);\n            // std::cout << \"bytesRead\" << bytesRead << \" ?? \" << bytesToRead << \"\\n\";\n            if (bytesRead != bytesToRead)\n            {\n               if (traceDebug())\n               {\n                  ossimNotify(ossimNotifyLevel_WARN)\n                      << \"ossimTiffTileSource::loadFromU16Strip Read Error!\"\n                      << \"\\nReturning error...  \" << endl;\n               }\n               theErrorStatus = ossimErrorCodes::OSSIM_ERROR;\n               status = false;\n               result->makeBlank();\n               break;\n            }\n            bufferOffsetInBytes += bytesPerStrip;\n         }\n\n         if (status)\n         {\n            // Capture rect and rlevel of buffer:\n            theBufferRLevel = getCurrentTiffRLevel();\n            theBufferRect = ossimIrect(0,\n                                       startY,\n                                       theImageWidth[theCurrentDirectory] - 1,\n                                       startY + linesInStrip - 1);\n         }\n\n      } // End: Fill buffer block.\n\n      if (status)\n      {\n         result->loadTile(theBuffer, theBufferRect, OSSIM_BSQ);\n      }\n\n   } // End of strip loop.\n\n   return status;\n\n} // End: ossimTiffTileSource::loadFromU16Strip( ... )\n\nvoid ossimTiffTileSource::adjustToStartOfTile(ossimIpt &pt) const\n{\n   //***\n   // Notes:\n   // - Assumes an origin of (0,0)\n   // - Shifts in to the upper left direction.\n   //***\n   ossim_int32 tw = static_cast<ossim_int32>(theInputTileSize[theCurrentDirectory].x);\n   ossim_int32 th = static_cast<ossim_int32>(theInputTileSize[theCurrentDirectory].y);\n\n   if (pt.x > 0)\n   {\n      pt.x = (pt.x / tw) * tw;\n   }\n   else if (pt.x < 0)\n   {\n      pt.x = std::abs(pt.x) < tw ? -tw : (pt.x / tw) * tw;\n   }\n\n   if (pt.y > 0)\n   {\n      pt.y = (pt.y / th) * th;\n   }\n   else if (pt.y < 0)\n   {\n      pt.y = std::abs(pt.y) < th ? -th : (pt.y / th) * th;\n   }\n}\n\nbool ossimTiffTileSource::isValidRLevel(ossim_uint32 resLevel) const\n{\n   bool result = false;\n\n   const ossim_uint32 LEVELS = getNumberOfDecimationLevels();\n\n   //---\n   // If we have r0 our reslevels are the same as the callers so\n   // no adjustment necessary.\n   //---\n   if (!theStartingResLevel || theR0isFullRes) // Not an overview or has r0.\n   {\n      result = (resLevel < LEVELS);\n   }\n   else if (resLevel >= theStartingResLevel) // Used as overview.\n   {\n      result = ((resLevel - theStartingResLevel) < LEVELS);\n   }\n\n   return result;\n}\n\nossim_uint32 ossimTiffTileSource::getCurrentTiffRLevel() const\n{\n   return theCurrentTiffRlevel;\n   //   return theCurrentDirectory;\n}\n\nbool ossimTiffTileSource::getRgbBandList(std::vector<ossim_uint32> &bandList) const\n{\n   bool result = false;\n   ossimString copyright;\n   std::shared_ptr<const ossim::TiffHandlerState> state = getStateAs<ossim::TiffHandlerState>();\n\n   if (state)\n   {\n      ossimString value;\n\n      if (state->getValue(value, \"tiff.imd.band_name_list\"))\n      {\n         std::vector<ossimString> splitArray;\n         value.split(splitArray, \" \");\n         ossim_uint32 nInputBands = getNumberOfInputBands();\n         if ((splitArray.size() <= nInputBands) &&\n               (nInputBands > 2))\n         {\n            ossim_uint32 idx = 0;\n            bandList.resize(3);\n            bandList[0] = 0;\n            bandList[1] = 1;\n            bandList[2] = 2;\n            result = true;\n            for (idx = 0; idx < splitArray.size(); ++idx)\n            {\n               ossimString tempDowncase = splitArray[idx].trim().downcase();\n               switch (*tempDowncase.begin())\n               {\n                  case 'r':\n                  {\n                     bandList[0] = idx;\n                     break;\n                  }\n                  case 'g':\n                  {\n                     bandList[1] = idx;\n                     break;\n                  }\n                  case 'b':\n                  {\n                     bandList[2] = idx;\n                     break;\n                  }\n                  default:\n                  {\n                     break;\n                  }\n               }\n            }\n         }\n      }\n   }\n   return result;\n}\n\nossimString ossimTiffTileSource::getReadMethod(ossim_uint32 directory) const\n{\n   ossimString result = \"UNKNOWN\";\n   if (directory < theReadMethod.size())\n   {\n      switch (theReadMethod[directory])\n      {\n      case READ_RGBA_U8_TILE:\n         result = \"READ_RGBA_U8_TILE\";\n         break;\n      case READ_RGBA_U8_STRIP:\n         result = \"READ_RGBA_U8_STRIP\";\n         break;\n      case READ_RGBA_U8A_STRIP:\n         result = \"READ_RGBA_U8A_STRIP\";\n         break;\n      case READ_SCAN_LINE:\n         result = \"READ_SCAN_LINE\";\n         break;\n      case READ_TILE:\n         result = \"READ_TILE\";\n         break;\n      case UNKNOWN:\n      default:\n         break;\n      }\n   }\n   return result;\n}\n\nossim_uint32 ossimTiffTileSource::getNumberOfDirectories() const\n{\n   return theNumberOfDirectories;\n}\n\nossim_uint32 ossimTiffTileSource::getImageTileWidth() const\n{\n   ossim_uint32 result = 0;\n   if (isOpen())\n   {\n      if (theCurrentDirectory < theInputTileSize.size())\n      {\n         result = theInputTileSize[theCurrentDirectory].x;\n      }\n   }\n   return result;\n}\n\nossim_uint32 ossimTiffTileSource::getImageTileHeight() const\n{\n   ossim_uint32 result = 0;\n   if (isOpen())\n   {\n      if (theCurrentDirectory < theInputTileSize.size())\n      {\n         result = theInputTileSize[theCurrentDirectory].y;\n      }\n   }\n   return result;\n}\n\nossim_uint32 ossimTiffTileSource::getTileWidth() const\n{\n   ossim_uint32 result = theOutputTileSize.x;\n   if (!result)\n   {\n      ossim::defaultTileSize(theOutputTileSize);\n      result = theOutputTileSize.x;\n   }\n   return result;\n}\n\nossim_uint32 ossimTiffTileSource::getTileHeight() const\n{\n   ossim_uint32 result = theOutputTileSize.y;\n   if (!result)\n   {\n      ossim::defaultTileSize(theOutputTileSize);\n      result = theOutputTileSize.y;\n   }\n   return result;\n}\n\nvoid ossimTiffTileSource::setApplyColorPaletteFlag(bool flag)\n{\n   theApplyColorPaletteFlag = flag;\n\n   if (isColorMapped())\n   {\n      if (theApplyColorPaletteFlag)\n      {\n         thePhotometric[0] = PHOTOMETRIC_PALETTE;\n         theSamplesPerPixel = 3;\n      }\n      else\n      {\n         thePhotometric[0] = PHOTOMETRIC_MINISBLACK;\n         theSamplesPerPixel = 1;\n      }\n\n      setReadMethod();\n\n      theTile = 0;\n      if (theBuffer)\n      {\n         delete[] theBuffer;\n         theBuffer = 0;\n      }\n   }\n}\n\nbool ossimTiffTileSource::getApplyColorPaletteFlag() const\n{\n   return theApplyColorPaletteFlag;\n}\n\nossimString ossimTiffTileSource::getLongName() const\n{\n   return ossimString(\"TIFF Image Handler\");\n}\n\nossimString ossimTiffTileSource::getShortName() const\n{\n   return ossimString(\"ossim_tiff\");\n}\n\nstd::ostream &ossimTiffTileSource::print(std::ostream &os) const\n{\n   //***\n   // Use a keyword format.\n   //***\n   os << \"image_file:                    \" << theImageFile\n      << \"\\nsamples_per_pixel:           \" << theSamplesPerPixel\n      << \"\\nbits_per_sample:             \" << theBitsPerSample\n      << \"\\nsample_format_unit:          \" << theSampleFormatUnit\n      << \"\\nmin_sample_value:            \" << theMinSampleValue\n      << \"\\nmax_sample_value:            \" << theMaxSampleValue\n      << \"\\nnull_sample_value:           \" << theNullSampleValue\n      << \"\\nr0_is_full_res:              \" << theR0isFullRes\n      << \"\\ntheNumberOfDirectories:      \" << theNumberOfDirectories\n      << \"\\nimage_dirs:                  \" << theImageDirectoryList.size();\n         \n   for (ossim_uint32 i = 0; i < theNumberOfDirectories; ++i)\n   {\n      os << \"\\ndirectory[\" << i << \"]\"\n         << \"\\nimage width:     \" << theImageWidth[i]\n         << \"\\nimage_length:    \" << theImageLength[i]\n         << \"\\nread method:     \" << getReadMethod(i).c_str()\n         << \"\\nplanar:          \" << thePlanarConfig[i]\n         << \"\\nphotometric:     \" << thePhotometric[i];\n      if (theRowsPerStrip[i])\n      {\n         os << \"\\nrows per strip:  \" << theRowsPerStrip[i];\n      }\n      if (theInputTileSize[i].x)\n      {\n         os << \"\\ntile_width:      \" << theInputTileSize[i].x;\n      }\n      if (theInputTileSize[i].y)\n      {\n         os << \"\\ntile_length:     \" << theInputTileSize[i].y;\n      }\n      os << endl;\n   }\n\n   os << \"\\nmask_dirs:       \" << theMaskDirectoryList.size();\n   for (ossim_uint32 i=0; i<(ossim_uint32)theMaskDirectoryList.size(); ++i )\n   {\n      ossim_uint32 ifdIndex = theMaskDirectoryList[i];\n      os << \"\\nmask_ifd_index:    \" << ifdIndex\n         << \"\\nmask_width:        \" << theImageWidth[ifdIndex]\n         << \"\\nmask_length:       \" << theImageLength[ifdIndex]\n         << \"\\nmask_read method:  \" << getReadMethod(ifdIndex).c_str()\n         << \"\\nmask_planar:       \" << thePlanarConfig[ifdIndex]\n         << \"\\nmask_photometric:  \" << thePhotometric[ifdIndex];\n      if (theRowsPerStrip[ifdIndex])\n      {\n         os << \"\\nmask_rows_per_strip:  \" << theRowsPerStrip[ifdIndex];\n      }\n      if (theInputTileSize[i].x)\n      {\n         os << \"\\nmask_tile_width:   \" << theInputTileSize[i].x;\n      }\n      if (theInputTileSize[i].y)\n      {\n         os << \"\\nmask_tile_length:  \" << theInputTileSize[i].y;\n      }\n   }\n\n   if (theTile.valid())\n   {\n      os << \"\\nOutput tile dump:\\n\"\n         << *theTile << endl;\n   }\n\n   if (theOverview.valid())\n   {\n      os << \"\\nOverview file:\\n\";\n      theOverview->print(os);\n   }\n\n   os << endl;\n\n   return ossimSource::print(os);\n}\n\nossim_uint32 ossimTiffTileSource::getNumberOfInputBands() const\n{\n   return theSamplesPerPixel;\n}\n\nossim_uint32 ossimTiffTileSource::getNumberOfOutputBands() const\n{\n   ossim_uint32 bands = theOutputBandList.size();\n   if (!bands)\n   {\n      bands = getNumberOfInputBands();\n   }\n   return bands;\n}\n\nbool ossimTiffTileSource::isBandSelector() const\n{\n   bool result = false;\n   if (isOpen() && theReadMethod.size() && (theReadMethod.size() == thePlanarConfig.size()))\n   {\n      // Tiled band separate currently is only coded to be band selector.\n      result = true;\n      for (ossim_uint32 i = 0; i < theReadMethod.size(); ++i)\n      {\n         if ((theReadMethod[i] != READ_TILE) ||\n             (thePlanarConfig[i] == PLANARCONFIG_CONTIG))\n         {\n            result = false;\n            break;\n         }\n      }\n      if (result && theOverview.valid())\n      {\n         result = theOverview->isBandSelector();\n      }\n   }\n   return result;\n}\n\nbool ossimTiffTileSource::setOutputBandList(const std::vector<ossim_uint32> &band_list)\n{\n   bool result = false;\n   if (isBandSelector())\n   {\n      // Making a copy as passed in list could be our m_outputBandList.\n      std::vector<ossim_uint32> inputList = band_list;\n      result = ossimImageHandler::setOutputBandList(inputList, theOutputBandList);\n      if (result && theTile.valid())\n      {\n         if (theTile->getNumberOfBands() != theOutputBandList.size())\n         {\n            theTile = 0; // Force a reinitialize on next getTile.\n         }\n      }\n   }\n   return result;\n}\n\nvoid ossimTiffTileSource::getOutputBandList(std::vector<ossim_uint32> &bandList) const\n{\n   if (theOutputBandList.size())\n   {\n      bandList = theOutputBandList;\n   }\n   else\n   {\n      ossimImageSource::getOutputBandList(bandList);\n   }\n}\n\nbool ossimTiffTileSource::isOpen() const\n{\n   return (theTiffPtr != NULL);\n}\n\nbool ossimTiffTileSource::hasR0() const\n{\n   return theR0isFullRes;\n}\n\nossim_float64 ossimTiffTileSource::getMinPixelValue(ossim_uint32 band) const\n{\n   if (theMetaData.getNumberOfBands())\n   {\n      return ossimImageHandler::getMinPixelValue(band);\n   }\n   return theMinSampleValue;\n}\n\nossim_float64 ossimTiffTileSource::getMaxPixelValue(ossim_uint32 band) const\n{\n   if (theMetaData.getNumberOfBands())\n   {\n      return ossimImageHandler::getMaxPixelValue(band);\n   }\n   return theMaxSampleValue;\n}\n\nossim_float64 ossimTiffTileSource::getNullPixelValue(ossim_uint32 band) const\n{\n   if (theMetaData.getNumberOfBands())\n   {\n      return ossimImageHandler::getNullPixelValue(band);\n   }\n   return theNullSampleValue;\n}\n\nbool ossimTiffTileSource::isColorMapped() const\n{\n   bool result = false;\n\n   std::shared_ptr<const ossim::TiffHandlerState> state = getStateAs<ossim::TiffHandlerState>();\n   if (state)\n   {\n      result = state->hasColorMap(TIFFCurrentDirectory(theTiffPtr));\n   }\n\n   return result;\n}\n\nvoid ossimTiffTileSource::setReadMethod()\n{\n   std::shared_ptr<ossim::TiffHandlerState> state = getStateAs<ossim::TiffHandlerState>();\n\n   if (state)\n   {\n      for (ossim_uint32 dir = 0; dir < theNumberOfDirectories; ++dir)\n      {\n         //---\n         // Establish how this tiff directory will be read.\n         //---\n         if (state->isTiled(dir))\n         {\n            if ((thePhotometric[dir] == PHOTOMETRIC_YCBCR ||\n                 thePhotometric[dir] == PHOTOMETRIC_PALETTE) &&\n                (theSamplesPerPixel <= 3) &&\n                (theBitsPerSample <= 8))\n            {\n               theReadMethod[dir] = READ_RGBA_U8_TILE;\n            }\n            else\n            {\n               theReadMethod[dir] = READ_TILE;\n            }\n         }\n         else // Not tiled...\n         {\n            if ((thePhotometric[dir] == PHOTOMETRIC_PALETTE ||\n                 thePhotometric[dir] == PHOTOMETRIC_YCBCR) &&\n                theSamplesPerPixel <= 3 &&\n                theBitsPerSample <= 8)\n            {\n               theReadMethod[dir] = READ_RGBA_U8_STRIP;\n            }\n            else if ((theBitsPerSample == 16) &&\n                     (theRowsPerStrip[dir] > 1) &&\n                     ((thePlanarConfig[dir] == PLANARCONFIG_SEPARATE) ||\n                      ((thePlanarConfig[dir] == PLANARCONFIG_CONTIG) && (theSamplesPerPixel == 1))))\n            {\n               // Buffer a strip of bands.\n               theReadMethod[dir] = READ_U16_STRIP;\n            }\n            else if (theSamplesPerPixel <= 3 && theBitsPerSample == 1)\n            {\n               //---\n               // Note:  One bit data expands to zeroes and 255's so run it through\n               //        a specialized method to flip zeroes to one's since zeroes\n               //        are usually reserved for null value.\n               //---\n               theReadMethod[dir] = READ_RGBA_U8A_STRIP;\n            }\n            else if ((theCompressionType == COMPRESSION_NONE) ||\n                     (theRowsPerStrip[dir] == 1))\n            {\n               theReadMethod[dir] = READ_SCAN_LINE;\n            }\n            else if ((theCompressionType != COMPRESSION_NONE) &&\n                     (theSamplesPerPixel <= 4) &&\n                     (theBitsPerSample <= 8))\n            {\n               theReadMethod[dir] = READ_RGBA_U8_STRIP;\n            }\n            else\n            {\n               theReadMethod[dir] = UNKNOWN;\n            }\n         }\n\n      } // End of loop through directories.\n   }\n   // Reset the directory back to \"0\".\n   //   setTiffDirectory(0);\n}\n\nvoid ossimTiffTileSource::setProperty(ossimRefPtr<ossimProperty> property)\n{\n   if (!property.valid())\n   {\n      return;\n   }\n   if (property->getName() == \"apply_color_palette_flag\")\n   {\n      // Assuming first directory...\n      setApplyColorPaletteFlag(property->valueToString().toBool());\n   }\n   else\n   {\n      ossimImageHandler::setProperty(property);\n   }\n}\n\nossimRefPtr<ossimProperty> ossimTiffTileSource::getProperty(const ossimString &name) const\n{\n   if (name == \"apply_color_palette_flag\")\n   {\n      ossimBooleanProperty *property = new ossimBooleanProperty(\"apply_color_palette_flag\",\n                                                                theApplyColorPaletteFlag);\n      property->clearChangeType();\n      property->setFullRefreshBit();\n      return property;\n   }\n   else if (name == \"file_type\")\n   {\n      return new ossimStringProperty(name, \"TIFF\");\n   }\n\n   return ossimImageHandler::getProperty(name);\n}\n\nvoid ossimTiffTileSource::getPropertyNames(std::vector<ossimString> &propertyNames) const\n{\n   ossimImageHandler::getPropertyNames(propertyNames);\n   propertyNames.push_back(\"file_type\");\n   propertyNames.push_back(\"apply_color_palette_flag\");\n}\n\nbool ossimTiffTileSource::setTiffDirectory(ossim_uint16 directory)\n{\n   bool status = true;\n   theCurrentTiffRlevel = 0;\n   if (theCurrentDirectory != directory)\n   {\n      status = TIFFSetDirectory(theTiffPtr, directory);\n      if (status == true)\n      {\n         theCurrentDirectory = directory;\n      }\n      else\n      {\n         if (traceDebug())\n         {\n            ossimNotify(ossimNotifyLevel_WARN)\n                << \"ossimTiffTileSource::setTiffDirectory ERROR setting directory \"\n                << directory << \"!\" << endl;\n         }\n      }\n   }\n\n   ossim_uint32 idx = 0;\n   for (idx = 0; idx < theImageDirectoryList.size(); ++idx)\n   {\n      if (theImageDirectoryList[idx] == directory)\n      {\n         theCurrentTiffRlevel = idx;\n         break;\n      }\n   }\n   return status;\n}\n\nvoid ossimTiffTileSource::populateLut()\n{\n   std::shared_ptr<ossim::TiffHandlerState> state = getStateAs<ossim::TiffHandlerState>();\n   ossim_uint32 currentDir = TIFFCurrentDirectory(theTiffPtr);\n   std::vector<ossim_uint16> redValues;\n   std::vector<ossim_uint16> greenValues;\n   std::vector<ossim_uint16> blueValues;\n\n   if (state->getColorMap(redValues, greenValues, blueValues, currentDir))\n   {\n      ossim_uint16 *r = &redValues.front();\n      ossim_uint16 *g = &greenValues.front();\n      ossim_uint16 *b = &blueValues.front();\n      ossim_uint32 numEntries = redValues.size();\n      ossimScalarType scalarType = OSSIM_UINT8;\n      if (theBitsPerSample == 16)\n      {\n         scalarType = OSSIM_UINT16;\n      }\n      theLut = new ossimNBandLutDataObject(numEntries,\n                                           3,\n                                           scalarType,\n                                           0);\n      ossim_uint32 entryIdx = 0;\n      for (entryIdx = 0; entryIdx < numEntries; ++entryIdx)\n      {\n         if (scalarType == OSSIM_UINT8)\n         {\n            (*theLut)[entryIdx][0] = (ossimNBandLutDataObject::LUT_ENTRY_TYPE)(((*r) / 65535.0) * 255.0);\n            (*theLut)[entryIdx][1] = (ossimNBandLutDataObject::LUT_ENTRY_TYPE)(((*g) / 65535.0) * 255.0);\n            (*theLut)[entryIdx][2] = (ossimNBandLutDataObject::LUT_ENTRY_TYPE)(((*b) / 65535.0) * 255.0);\n         }\n         else\n         {\n            (*theLut)[entryIdx][0] = (ossimNBandLutDataObject::LUT_ENTRY_TYPE)(*r);\n            (*theLut)[entryIdx][1] = (ossimNBandLutDataObject::LUT_ENTRY_TYPE)(*g);\n            (*theLut)[entryIdx][2] = (ossimNBandLutDataObject::LUT_ENTRY_TYPE)(*b);\n         }\n         ++r;\n         ++g;\n         ++b;\n      }\n   }\n}\n\nvoid ossimTiffTileSource::validateMinMaxNull()\n{\n   ossim_float64 tempNull = ossim::defaultNull(theScalarType);\n   ossim_float64 tempMax = ossim::defaultMax(theScalarType);\n   ossim_float64 tempMin = ossim::defaultMin(theScalarType);\n\n   if ((theMinSampleValue == tempNull) || ossim::isnan(theMinSampleValue))\n   {\n      theMinSampleValue = tempMin;\n   }\n   if ((theMaxSampleValue == tempNull) || ossim::isnan(theMaxSampleValue))\n   {\n      theMaxSampleValue = tempMax;\n   }\n   if (ossim::isnan(theNullSampleValue))\n   {\n      theNullSampleValue = tempNull;\n   }\n\n   if (theScalarType == OSSIM_FLOAT32)\n   {\n      std::ifstream inStr(theImageFile.c_str(), std::ios::in | std::ios::binary);\n      if (inStr.good())\n      {\n         // Do a print to a memory stream in key:value format.\n         ossimTiffInfo ti;\n         ossimIOMemoryStream memStr;\n         ti.print(inStr, memStr);\n\n         // Make keywordlist with all the tags.\n         ossimKeywordlist gtiffKwl;\n         if (gtiffKwl.parseStream(memStr))\n         {\n#if 0 /* Please keep for debug. (drb) */\n            if ( traceDebug() )\n            {\n               ossimNotify(ossimNotifyLevel_DEBUG)\n                  << \"ossimTiffTileSource::validateMinMaxNull kwl:\\n\" << gtiffKwl\n                  << endl;\n            }\n#endif\n            const char *lookup;\n\n            lookup = gtiffKwl.find(\"tiff.image0.gdal_nodata\");\n            bool nullFound = false;\n            if (lookup)\n            {\n               ossimString os = lookup;\n               theNullSampleValue = os.toFloat32();\n               nullFound = true;\n            }\n            lookup = gtiffKwl.find(\"tiff.image0.vertical_citation\");\n            if (lookup)\n            {\n               //---\n               // Format of string this handles:\n               // \"Null: -9999.000000, Non-Null Min: 12.428605,\n               // Non-Null Avg: 88.944082, Non-Null Max: 165.459558|\"\n               ossimString citation = lookup;\n               std::vector<ossimString> array;\n               citation.split(array, ossimString(\",\"));\n               if (array.size() == 4)\n               {\n                  std::vector<ossimString> array2;\n\n                  if (!nullFound)\n                  {\n                     // null\n                     array[0].split(array2, ossimString(\":\"));\n                     if (array2.size() == 2)\n                     {\n                        ossimString os = array2[0].downcase();\n                        if (os.contains(ossimString(\"null\")))\n                        {\n                           if (array2[1].size())\n                           {\n                              theNullSampleValue = array2[1].toFloat64();\n                              nullFound = true;\n                           }\n                        }\n                     }\n                  }\n\n                  // min\n                  array2.clear();\n                  array[1].split(array2, ossimString(\":\"));\n                  if (array2.size() == 2)\n                  {\n                     ossimString os = array2[0].downcase();\n                     if (os.contains(ossimString(\"min\")))\n                     {\n                        if (array2[1].size())\n                        {\n                           theMinSampleValue = array2[1].toFloat64();\n                        }\n                     }\n                  }\n\n                  // Skipping average.\n\n                  // max\n                  array2.clear();\n                  array[3].split(array2, ossimString(\":\"));\n                  if (array2.size() == 2)\n                  {\n                     ossimString os = array2[0].downcase();\n                     if (os.contains(ossimString(\"max\")))\n                     {\n                        if (array2[1].size())\n                        {\n                           array2[1].trim(ossimString(\"|\"));\n                           theMaxSampleValue = array2[1].toFloat64();\n                        }\n                     }\n                  }\n               }\n            }\n         }\n      }\n   }\n}\n\nbool ossimTiffTileSource::isPowerOfTwoDecimation(ossim_uint32 level) const\n{\n   // Check size of this level against last level to see if it's half the previous.\n   bool result = false;\n   if ((level > 0) && (theImageWidth.size() > level) && (theImageLength.size() > level))\n   {\n      ossim_uint32 i = level - 1; // previous level\n\n      if (((theImageWidth[i] / 2 == theImageWidth[level]) ||\n           ((theImageWidth[i] + 1) / 2 == theImageWidth[level])) &&\n          ((theImageLength[i] / 2 == theImageLength[level]) ||\n           ((theImageLength[i] + 1) / 2 == theImageLength[level])))\n      {\n         result = true;\n      }\n   }\n   return result;\n}\n\nvoid ossimTiffTileSource::allocateTile()\n{\n   theTile = 0;\n   ossim_uint32 bands = 0;\n   if (theOutputBandList.empty())\n   {\n      bands = getNumberOfOutputBands();\n   }\n   else\n   {\n      bands = theOutputBandList.size();\n   }\n\n   if (bands)\n   {\n      theTile = ossimImageDataFactory::instance()->create(this, getOutputScalarType(), bands);\n      if (theTile.valid())\n      {\n         theTile->initialize();\n\n         // The width and height mus be set prior to call to allocateBuffer.\n         theOutputTileSize.x = theTile->getWidth();\n         theOutputTileSize.y = theTile->getHeight();\n      }\n   }\n}\n\nbool ossimTiffTileSource::allocateBuffer()\n{\n   bool bSuccess = true;\n   // Allocate memory for a buffer to hold data grabbed from the tiff file.\n   ossim_uint32 buffer_size = 0;\n   switch (theReadMethod[theCurrentDirectory])\n   {\n   case READ_RGBA_U8_TILE:\n   {\n      buffer_size = theInputTileSize[theCurrentDirectory].x *\n                    theInputTileSize[theCurrentDirectory].x * theBytesPerPixel * 4;\n      break;\n   }\n   case READ_TILE:\n   {\n      if (thePlanarConfig[theCurrentDirectory] == PLANARCONFIG_CONTIG)\n      {\n         buffer_size = theInputTileSize[theCurrentDirectory].x *\n                       theInputTileSize[theCurrentDirectory].y *\n                       theBytesPerPixel * theSamplesPerPixel;\n      }\n      else\n      {\n         buffer_size = theInputTileSize[theCurrentDirectory].x *\n                       theInputTileSize[theCurrentDirectory].y *\n                       theBytesPerPixel;\n      }\n      break;\n   }\n   case READ_RGBA_U8_STRIP:\n   case READ_RGBA_U8A_STRIP:\n   {\n      buffer_size = theImageWidth[0] * theRowsPerStrip[theCurrentDirectory] *\n                    theBytesPerPixel * 4;\n      break;\n   }\n   case READ_U16_STRIP:\n   {\n      // Encountered case where it was multiple rows per strip, yet PLANARCONFIG_CONTIG. The\n      // case was in fact single band so planar config is irrelevant. (OLK July 2015)\n\n      // I put the multiplication back in for the theSamplesPerPixel.  In the read method that is used for this\n      // it populates this buffer with all bands and then uses the load method on the image data object.\n      // so all bands has to be populated for the buffer. (GCP Sept 2015)\n      buffer_size = theImageWidth[0] * theRowsPerStrip[theCurrentDirectory] * theBytesPerPixel *\n                    theSamplesPerPixel;\n      // I commented this out for this is core dumping for one of the tiff images. (GCP Sept 2015)\n      // if (thePlanarConfig[theCurrentDirectory] == PLANARCONFIG_CONTIG)\n      //  buffer_size *= theSamplesPerPixel;\n      break;\n   }\n   case READ_SCAN_LINE:\n   {\n#if OSSIM_BUFFER_SCAN_LINE_READS\n      // Buffer a image width by tile height.\n      buffer_size = theImageWidth[0] * theBytesPerPixel *\n                    theSamplesPerPixel * theOutputTileSize.y;\n#else\n      buffer_size = theImageWidth[0] * theBytesPerPixel * theSamplesPerPixel;\n#endif\n      break;\n   }\n   default:\n   {\n      ossimNotify(ossimNotifyLevel_WARN)\n          << \"Unknown read method!\" << endl;\n      print(ossimNotify(ossimNotifyLevel_WARN));\n      bSuccess = false;\n   }\n   }\n\n   if (traceDebug())\n   {\n      ossimNotify(ossimNotifyLevel_DEBUG)\n          << \"ossimTiffTileSource::allocateBuffer DEBUG:\"\n          << \"\\nbuffer_size:  \" << buffer_size\n          << endl;\n   }\n\n   theBufferRect.makeNan();\n   theBufferRLevel = getCurrentTiffRLevel();\n\n   if (bSuccess && (buffer_size != theBufferSize))\n   {\n      theBufferSize = buffer_size;\n      if (theBuffer)\n      {\n         delete[] theBuffer;\n      }\n\n      // ESH 05/2009 -- Fix for ticket #738:\n      // image_info crashing on aerial_ortho image during ingest\n      try\n      {\n         theBuffer = new ossim_uint8[buffer_size];\n      }\n      catch (...)\n      {\n         theBuffer = 0;\n         bSuccess = false;\n         if (traceDebug())\n         {\n            ossimNotify(ossimNotifyLevel_WARN)\n                << \"ossimTiffTileSource::allocateBuffer WARN:\"\n                << \"\\nNot enough memory: buffer_size:  \" << buffer_size\n                << endl;\n         }\n      }\n   }\n\n   return bSuccess;\n}\n",
                "name": "ossimTiffTileSource.cpp",
                "path": "src/imaging/ossimTiffTileSource.cpp",
                "url": "/github.com/ossimlabs/ossim/-/blob/src/imaging/ossimTiffTileSource.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 1341,
                    "offsetAndLengths": [
                        [
                            17,
                            16
                        ]
                    ],
                    "preview": "            if (!TIFFReadRGBATile(theTiffPtr,"
                }
            ],
            "repository": {
                "name": "github.com/ossimlabs/ossim",
                "url": "/github.com/ossimlabs/ossim"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "aca0b69befb13a72dae848e110b2bd1cc9007516"
                },
                "content": "//\n// Created by beyka on 3.2.17.\n//\n\n#include \"NativeDecoder.h\"\n#include <string>\n\njmp_buf NativeDecoder::tile_buf;\njmp_buf NativeDecoder::strip_buf;\njmp_buf NativeDecoder::image_buf;\njmp_buf NativeDecoder::general_buf;\n\n//Constructor for decoding from file descriptor\nNativeDecoder::NativeDecoder(JNIEnv *e, jclass c, jint fd, jobject opts, jobject listener)\n{\n\n    decodingMode = DECODE_MODE_FILE_DESCRIPTOR;\n\n    availableMemory = 8000*8000*4; // use 244Mb restriction for decoding full image\n    env = e;\n    clazz = c;\n    optionsObject = opts;\n    listenerObject = listener;\n    jFd = fd;\n\n    origwidth = 0;\n    origheight = 0;\n    origorientation = 0;\n    origcompressionscheme = 0;\n    progressTotal = 0;\n    invertRedAndBlue = false;\n\n    boundX = boundY = boundWidth = boundHeight = -1;\n    hasBounds = 0;\n\n    preferedConfig = NULL;\n    image = NULL;\n\n    jBitmapOptionsClass = env->FindClass(\n                        \"org/beyka/tiffbitmapfactory/TiffBitmapFactory$Options\");\n    jIProgressListenerClass = env->FindClass(\"org/beyka/tiffbitmapfactory/IProgressListener\");\n    jThreadClass = env->FindClass(\"java/lang/Thread\");\n}\n\n//Constructor for decoding from file path\nNativeDecoder::NativeDecoder(JNIEnv *e, jclass c, jstring path, jobject opts, jobject listener)\n{\n\n    decodingMode = DECODE_MODE_FILE_PATH;\n\n    availableMemory = 8000*8000*4; // use 244Mb restriction for decoding full image\n    env = e;\n    clazz = c;\n    optionsObject = opts;\n    listenerObject = listener;\n    jPath = path;\n\n    origwidth = 0;\n    origheight = 0;\n    origorientation = 0;\n    origcompressionscheme = 0;\n    progressTotal = 0;\n    invertRedAndBlue = false;\n\n    boundX = boundY = boundWidth = boundHeight = -1;\n    hasBounds = 0;\n\n    preferedConfig = NULL;\n    image = NULL;\n\n    jBitmapOptionsClass = env->FindClass(\n                        \"org/beyka/tiffbitmapfactory/TiffBitmapFactory$Options\");\n    jIProgressListenerClass = env->FindClass(\"org/beyka/tiffbitmapfactory/IProgressListener\");\n    jThreadClass = env->FindClass(\"java/lang/Thread\");\n}\n\nNativeDecoder::~NativeDecoder()\n{\n    LOGI(\"Destructor\");\n    if (image) {\n        TIFFClose(image);\n        image = NULL;\n    }\n\n    //Release global reference for Bitmap.Config\n    if (preferedConfig) {\n        env->DeleteGlobalRef(preferedConfig);\n        preferedConfig = NULL;\n    }\n\n    if (jBitmapOptionsClass) {\n        env->DeleteLocalRef(jBitmapOptionsClass);\n        jBitmapOptionsClass = NULL;\n    }\n\n    if (jIProgressListenerClass) {\n        env->DeleteLocalRef(jIProgressListenerClass);\n        jIProgressListenerClass = NULL;\n    }\n\n    if (jThreadClass) {\n            env->DeleteLocalRef(jThreadClass);\n            jThreadClass = NULL;\n        }\n}\n\njobject NativeDecoder::getBitmap()\n{\n        //init signal handler for catch SIGSEGV error that could be raised in libtiff\n        struct sigaction act;\n        memset(&act, 0, sizeof(act));\n        sigemptyset(&act.sa_mask);\n        act.sa_sigaction = generalErrorHandler;\n        act.sa_flags = SA_SIGINFO | SA_ONSTACK;\n        if(sigaction(SIGSEGV, &act, 0) < 0) {\n            LOGE(\"Can\\'t setup signal handler. Working without errors catching mechanism\");\n        }\n\n        //check for error\n        if (setjmp(NativeDecoder::general_buf)) {\n             const char * err = \"Caught SIGSEGV signal(Segmentation fault or invalid memory reference)\";\n             LOGE(err);\n             if (throwException) {\n                 throwDecodeFileException(err);\n             }\n            return NULL;\n        }\n\n        //Get options from TiffBitmapFactory$Options\n        jfieldID gOptions_ThrowExceptionFieldID = env->GetFieldID(jBitmapOptionsClass,\n                                                                          \"inThrowException\",\n                                                                          \"Z\");\n        throwException = env->GetBooleanField(optionsObject, gOptions_ThrowExceptionFieldID);\n\n        jfieldID gOptions_UseOrientationTagFieldID = env->GetFieldID(jBitmapOptionsClass,\n                                                                                  \"inUseOrientationTag\",\n                                                                                  \"Z\");\n        useOrientationTag = env->GetBooleanField(optionsObject, gOptions_UseOrientationTagFieldID);\n\n        jfieldID gOptions_sampleSizeFieldID = env->GetFieldID(jBitmapOptionsClass, \"inSampleSize\", \"I\");\n        jint inSampleSize = env->GetIntField(optionsObject, gOptions_sampleSizeFieldID);\n        if (inSampleSize != 1 && inSampleSize % 2 != 0) {\n            const char *message = \"inSampleSize should be power of 2\\0\";\n            LOGE(message);\n            if (throwException) {\n                throwDecodeFileException(message);\n            }\n            return NULL;\n        }\n\n        jfieldID gOptions_justDecodeBoundsFieldID = env->GetFieldID(jBitmapOptionsClass,\n                                                                    \"inJustDecodeBounds\", \"Z\");\n        jboolean inJustDecodeBounds = env->GetBooleanField(optionsObject, gOptions_justDecodeBoundsFieldID);\n\n        jfieldID gOptions_invertRedAndBlueFieldID = env->GetFieldID(jBitmapOptionsClass,\n                                                                    \"inSwapRedBlueColors\", \"Z\");\n        invertRedAndBlue = env->GetBooleanField(optionsObject, gOptions_invertRedAndBlueFieldID);\n\n        jfieldID gOptions_DirectoryCountFieldID = env->GetFieldID(jBitmapOptionsClass,\n                                                                  \"inDirectoryNumber\",\n                                                                  \"I\");\n        jint inDirectoryNumber = env->GetIntField(optionsObject, gOptions_DirectoryCountFieldID);\n        LOGII(\"param directoryCount\", inDirectoryNumber);\n\n        jfieldID gOptions_AvailableMemoryFieldID = env->GetFieldID(jBitmapOptionsClass,\n                                                                  \"inAvailableMemory\",\n                                                                  \"J\");\n        unsigned long inAvailableMemory = env->GetLongField(optionsObject, gOptions_AvailableMemoryFieldID);\n\n        jfieldID gOptions_PreferedConfigFieldID = env->GetFieldID(jBitmapOptionsClass,\n                                                                  \"inPreferredConfig\",\n                                                                  \"Lorg/beyka/tiffbitmapfactory/TiffBitmapFactory$ImageConfig;\");\n        jobject config = env->GetObjectField(optionsObject, gOptions_PreferedConfigFieldID);\n\n        if (inAvailableMemory > 0) {\n            availableMemory = inAvailableMemory;\n        }\n\n        if (config == NULL) {\n            LOGI(\"config is NULL, creating default options\");\n            jclass bitmapConfig = env->FindClass(\n                    \"org/beyka/tiffbitmapfactory/TiffBitmapFactory$ImageConfig\");\n            jfieldID argb8888FieldID = env->GetStaticFieldID(bitmapConfig, \"ARGB_8888\",\n                                                             \"Lorg/beyka/tiffbitmapfactory/TiffBitmapFactory$ImageConfig;\");\n            config = env->GetStaticObjectField(bitmapConfig, argb8888FieldID);\n            env->DeleteLocalRef(bitmapConfig);\n        }\n        preferedConfig = env->NewGlobalRef(config);\n        env->DeleteLocalRef(config);\n\n        jfieldID gOptions_DecodeAreaFieldId = env->GetFieldID(jBitmapOptionsClass, \"inDecodeArea\",\n                                                                \"Lorg/beyka/tiffbitmapfactory/DecodeArea;\");\n        jobject decodeArea = env->GetObjectField(optionsObject, gOptions_DecodeAreaFieldId);\n\n        //if directory number < 0 set it to 0\n        if (inDirectoryNumber < 0) inDirectoryNumber = 0;\n\n        //Open tiff file\n        LOGIS(\"nativeTiffOpen\", strPath);\n        const char *strPath = NULL;\n        if (decodingMode == DECODE_MODE_FILE_DESCRIPTOR) {\n            image = TIFFFdOpen(jFd, \"\", \"r\");\n        } else if (decodingMode == DECODE_MODE_FILE_PATH) {\n            strPath = env->GetStringUTFChars(jPath, 0);\n            image = TIFFOpen(strPath, \"r\");\n        }\n\n        if (image == NULL) {\n            if (throwException) {\n                throwCantOpenFileException();\n            }\n\n            if (decodingMode == DECODE_MODE_FILE_PATH) {\n                LOGES(\"Can\\'t open bitmap\", strPath);\n                env->ReleaseStringUTFChars(jPath, strPath);\n            } else {\n                LOGEI(\"Can\\'t open file descriptor\", jFd);\n            }\n            return NULL;\n        } else {\n            if (decodingMode == DECODE_MODE_FILE_PATH) {\n                env->ReleaseStringUTFChars(jPath, strPath);\n            }\n        }\n        LOGI(\"Tiff is open\");\n\n        TIFFSetDirectory(image, inDirectoryNumber);\n        TIFFGetField(image, TIFFTAG_IMAGEWIDTH, &origwidth);\n        TIFFGetField(image, TIFFTAG_IMAGELENGTH, &origheight);\n\n        //Read decode bounds if exists\n        if (decodeArea) {\n            LOGI(\"Decode bounds present\");\n            jclass decodeAreaClass = env->FindClass(\"org/beyka/tiffbitmapfactory/DecodeArea\");\n            jfieldID xFieldID = env->GetFieldID(decodeAreaClass, \"x\", \"I\");\n            jfieldID yFieldID = env->GetFieldID(decodeAreaClass, \"y\", \"I\");\n            jfieldID widthFieldID = env->GetFieldID(decodeAreaClass, \"width\", \"I\");\n            jfieldID heightFieldID = env->GetFieldID(decodeAreaClass, \"height\", \"I\");\n\n            boundX = env->GetIntField(decodeArea, xFieldID);\n            boundY = env->GetIntField(decodeArea, yFieldID);\n            boundWidth = env->GetIntField(decodeArea, widthFieldID);\n            boundHeight = env->GetIntField(decodeArea, heightFieldID);\n            if (boundX >= origwidth-1) {\n                const char *message = \"X of left top corner of decode area should be less than image width\";\n                LOGE(*message);\n                if (throwException) {\n                    throwDecodeFileException(message);\n                }\n                env->DeleteLocalRef(decodeAreaClass);\n                return NULL;\n            }\n            if (boundY >= origheight-1) {\n                const char *message = \"Y of left top corner of decode area should be less than image height\";\n                LOGE(*message);\n                if (throwException) {\n                    throwDecodeFileException(message);\n                }\n                env->DeleteLocalRef(decodeAreaClass);\n                return NULL;\n            }\n\n            if (boundX < 0) boundX = 0;\n            if (boundY < 0) boundY = 0;\n            if (boundX + boundWidth >= origwidth) boundWidth = origwidth - boundX -1;\n            if (boundY + boundHeight >= origheight) boundHeight = origheight - boundY -1;\n\n            if (boundWidth < 1) {\n                const char *message = \"Width of decode area can\\'t be less than 1\";\n                LOGE(*message);\n                if (throwException) {\n                    throwDecodeFileException(message);\n                }\n                env->DeleteLocalRef(decodeAreaClass);\n                return NULL;\n            }\n            if (boundHeight < 1) {\n                const char *message = \"Height of decode area can\\'t be less than 1\";\n                LOGE(*message);\n                if (throwException) {\n                    throwDecodeFileException(message);\n                }\n                env->DeleteLocalRef(decodeAreaClass);\n                return NULL;\n            }\n\n            LOGII(\"Decode X\", boundX);\n            LOGII(\"Decode Y\", boundY);\n            LOGII(\"Decode width\", boundWidth);\n            LOGII(\"Decode height\", boundHeight);\n\n            hasBounds = 1;\n            env->DeleteLocalRef(decodeAreaClass);\n            env->DeleteLocalRef(decodeArea);\n        }\n\n        jobject java_bitmap = NULL;\n\n        writeDataToOptions(inDirectoryNumber);\n\n        if (!inJustDecodeBounds) {\n            progressTotal = origwidth * origheight;\n            sendProgress(0, progressTotal);\n            java_bitmap = createBitmap(inSampleSize, inDirectoryNumber);\n        }\n\n        return java_bitmap;\n}\n\njobject NativeDecoder::createBitmap(int inSampleSize, int directoryNumber)\n{\n//Read Config from options. Use ordinal field from ImageConfig class\n    jint configInt = ARGB_8888;\n    if(preferedConfig) {\n        jclass configClass = env->FindClass(\n            \"org/beyka/tiffbitmapfactory/TiffBitmapFactory$ImageConfig\");\n        jfieldID ordinalFieldID = env->GetFieldID(configClass, \"ordinal\", \"I\");\n        configInt = env->GetIntField(preferedConfig, ordinalFieldID);\n        env->DeleteLocalRef(configClass);\n    }\n\n    int bitdepth = 1;\n    TIFFGetField(image, TIFFTAG_BITSPERSAMPLE, &bitdepth);\n    if (bitdepth != 1 && bitdepth != 4 && bitdepth != 8 && bitdepth != 16) {\n        const char * err = \"Only 1, 4, 8 and 16 bits per sample are supported\";\n        LOGE(err);\n        if (throwException) {\n            throwDecodeFileException(err);\n        }\n        return NULL;\n    }\n\n    int newBitmapWidth = 0;\n    int newBitmapHeight = 0;\n\n    jint *raster = NULL;\n\n    if (!hasBounds) {\n        switch(getDecodeMethod()) {\n            case DECODE_METHOD_IMAGE:\n                raster = getSampledRasterFromImage(inSampleSize, &newBitmapWidth, &newBitmapHeight);\n                break;\n            case DECODE_METHOD_TILE:\n                raster = getSampledRasterFromTile(inSampleSize, &newBitmapWidth, &newBitmapHeight);\n                break;\n            case DECODE_METHOD_STRIP:\n                raster = getSampledRasterFromStrip(inSampleSize,  &newBitmapWidth, &newBitmapHeight);\n                break;\n        }\n    } else {\n        switch(getDecodeMethod()) {\n            case DECODE_METHOD_IMAGE:\n                raster = getSampledRasterFromImageWithBounds(inSampleSize, &newBitmapWidth, &newBitmapHeight);\n                break;\n            case DECODE_METHOD_TILE:\n                raster = getSampledRasterFromTileWithBounds(inSampleSize, &newBitmapWidth, &newBitmapHeight);\n                break;\n            case DECODE_METHOD_STRIP:\n                raster = getSampledRasterFromStripWithBounds(inSampleSize,  &newBitmapWidth, &newBitmapHeight);\n                break;\n        }\n\n    }\n\n    if (raster == NULL) {\n        return NULL;\n    }\n\n    // Convert ABGR to ARGB\n    if (invertRedAndBlue) {\n        int i = 0;\n        int j = 0;\n        int tmp = 0;\n        for (i = 0; i < newBitmapHeight; i++) {\n            for (j = 0; j < newBitmapWidth; j++) {\n                tmp = raster[j + newBitmapWidth * i];\n                raster[j + newBitmapWidth * i] =\n                        (tmp & 0xff000000) | ((tmp & 0x00ff0000) >> 16) | (tmp & 0x0000ff00) |\n                        ((tmp & 0xff) << 16);\n            }\n        }\n    }\n\n    sendProgress(progressTotal, progressTotal);\n\n    if(checkStop()) {\n        if (raster) {\n            free(raster);\n        }\n        LOGI(\"Thread stopped\");\n        return NULL;\n    }\n\n    //Class and field for Bitmap.Config\n    jclass bitmapConfigClass = env->FindClass(\"android/graphics/Bitmap$Config\");\n    jfieldID bitmapConfigField = NULL;\n    void *processedBuffer = NULL;\n    if (configInt == ARGB_8888) {\n        processedBuffer = raster;\n        bitmapConfigField = env->GetStaticFieldID(bitmapConfigClass, \"ARGB_8888\",\n                                                  \"Landroid/graphics/Bitmap$Config;\");\n    } else if (configInt == ALPHA_8) {\n        processedBuffer = createBitmapAlpha8(raster, newBitmapWidth,\n                                             newBitmapHeight);\n        bitmapConfigField = env->GetStaticFieldID(bitmapConfigClass, \"ALPHA_8\",\n                                                  \"Landroid/graphics/Bitmap$Config;\");\n    } else if (configInt == RGB_565) {\n        processedBuffer = createBitmapRGB565(raster, newBitmapWidth,\n                                             newBitmapHeight);\n        bitmapConfigField = env->GetStaticFieldID(bitmapConfigClass, \"RGB_565\",\n                                                  \"Landroid/graphics/Bitmap$Config;\");\n    }\n\n    if (processedBuffer == NULL) {\n        LOGE(\"Error while decoding image\");\n        return NULL;\n    }\n\n    //Create mutable bitmap\n    jclass bitmapClass = env->FindClass(\"android/graphics/Bitmap\");\n    jmethodID methodid = env->GetStaticMethodID(bitmapClass, \"createBitmap\",\n                                                \"(IILandroid/graphics/Bitmap$Config;)Landroid/graphics/Bitmap;\");\n\n    //BitmapConfig\n    jobject config = env->GetStaticObjectField(bitmapConfigClass, bitmapConfigField);\n\n    env->DeleteLocalRef(bitmapConfigClass);\n\n    jobject java_bitmap = NULL;\n\n    if(checkStop()) {\n        env->DeleteLocalRef(config);\n        env->DeleteLocalRef(bitmapClass);\n        if (processedBuffer) {\n            free(processedBuffer);\n        }\n        LOGI(\"Thread stopped\");\n        return NULL;\n    }\n\n    if (!useOrientationTag) {\n        java_bitmap = env->CallStaticObjectMethod(bitmapClass, methodid, newBitmapWidth,\n                                                      newBitmapHeight, config);\n    } else if (origorientation > 4) {\n        java_bitmap = env->CallStaticObjectMethod(bitmapClass, methodid, newBitmapHeight,\n                                                  newBitmapWidth, config);\n    } else {\n        java_bitmap = env->CallStaticObjectMethod(bitmapClass, methodid, newBitmapWidth,\n                                                  newBitmapHeight, config);\n    }\n\n    //remove not used references\n    env->DeleteLocalRef(config);\n    env->DeleteLocalRef(bitmapClass);\n\n    //Copy data to bitmap\n    int ret;\n    void *bitmapPixels;\n    if ((ret = AndroidBitmap_lockPixels(env, java_bitmap, &bitmapPixels)) < 0) {\n        //error\n        LOGE(\"Lock pixels failed\");\n        return NULL;\n    }\n    int pixelsCount = newBitmapWidth * newBitmapHeight;\n\n    if (configInt == ARGB_8888) {\n        memcpy(bitmapPixels, (jint *) processedBuffer, sizeof(jint) * pixelsCount);\n    } else if (configInt == ALPHA_8) {\n        memcpy(bitmapPixels, (jbyte *) processedBuffer, sizeof(jbyte) * pixelsCount);\n    } else if (configInt == RGB_565) {\n        memcpy(bitmapPixels, (unsigned short *) processedBuffer,\n               sizeof(unsigned short) * pixelsCount);\n    }\n\n    AndroidBitmap_unlockPixels(env, java_bitmap);\n\n    //remove array\n    free(processedBuffer);\n\n    return java_bitmap;\n}\n\njint * NativeDecoder::getSampledRasterFromStrip(int inSampleSize, int *bitmapwidth, int *bitmapheight) {\n\n    //init signal handler for catch SIGSEGV error that could be raised in libtiff\n    struct sigaction act;\n    memset(&act, 0, sizeof(act));\n    sigemptyset(&act.sa_mask);\n    act.sa_sigaction = stripErrorHandler;\n    act.sa_flags = SA_SIGINFO | SA_ONSTACK;\n    if(sigaction(SIGSEGV, &act, 0) < 0) {\n        LOGE(\"Can\\'t setup signal handler. Working without errors catching mechanism\");\n    }\n\n    LOGII(\"width\", origwidth);\n    LOGII(\"height\", origheight);\n\n    jint *pixels = NULL;\n    *bitmapwidth = origwidth / inSampleSize;\n    *bitmapheight = origheight / inSampleSize;\n    uint32 pixelsBufferSize = *bitmapwidth * *bitmapheight;\n    int origImageBufferSize = origwidth * origheight;\n\n    LOGII(\"new width\", *bitmapwidth);\n    LOGII(\"new height\", *bitmapheight);\n\n    uint32 stripSize = TIFFStripSize (image);\n    uint32 stripMax = TIFFNumberOfStrips (image);\n    LOGII(\"strip size \", stripSize);\n    LOGII(\"stripMax  \", stripMax);\n    int rowPerStrip = -1;\n    TIFFGetField(image, TIFFTAG_ROWSPERSTRIP, &rowPerStrip);\n    LOGII(\"rowsperstrip\", rowPerStrip);\n\n    unsigned long estimateMem = 0;\n    estimateMem += (sizeof(jint) * pixelsBufferSize); //buffer for decoded pixels\n    estimateMem += (origwidth * sizeof(uint32)); //work line for rotate strip\n    estimateMem += (origwidth * rowPerStrip * sizeof (uint32) * 2); //current and next strips\n    estimateMem += (sizeof(jint) * origwidth * 2); //bottom and top lines for reading pixel(matrixBottomLine, matrixTopLine)\n    LOGII(\"estimateMem\", estimateMem);\n    if (estimateMem > availableMemory) {\n        if (throwException) {\n            throw_not_enought_memory_exception(env, availableMemory, estimateMem);\n        }\n        return NULL;\n    }\n\n    pixels = (jint *) malloc(sizeof(jint) * pixelsBufferSize);\n    if (pixels == NULL) {\n        LOGE(\"Can\\'t allocate memory for temp buffer\");\n        return NULL;\n    }\n\n    uint32* work_line_buf = (uint32 *)_TIFFmalloc(origwidth * sizeof(uint32));\n\n    uint32* raster;\n    uint32* rasterForBottomLine; // in this raster copy next strip for getting bottom line in matrix color selection\n    if (rowPerStrip == -1 && stripMax == 1) {\n            raster = (uint32 *)_TIFFmalloc(origImageBufferSize * sizeof (uint32));\n            rasterForBottomLine = (uint32 *)_TIFFmalloc(origImageBufferSize * sizeof (uint32));\n    } else {\n            raster = (uint32 *)_TIFFmalloc(origwidth * rowPerStrip * sizeof (uint32));\n            rasterForBottomLine = (uint32 *)_TIFFmalloc(origwidth * rowPerStrip * sizeof (uint32));\n    }\n    if (rowPerStrip == -1) {\n            rowPerStrip = origheight;\n    }\n\n    int writedLines = 0;\n    int nextStripOffset = 0;\n    int globalLineCounter = 0;\n\n    unsigned int *matrixTopLine = (uint32 *) malloc(sizeof(jint) * origwidth);\n    unsigned int *matrixBottomLine = (uint32 *) malloc(sizeof(jint) * origwidth);\n\n    int isSecondRasterExist = 0;\n    int ok = 1;\n    uint32 rows_to_write = 0;\n\n    //check for error\n    if (setjmp(NativeDecoder::strip_buf)) {\n        if (raster) {\n            _TIFFfree(raster);\n            raster = NULL;\n        }\n        if (rasterForBottomLine) {\n            _TIFFfree(rasterForBottomLine);\n            rasterForBottomLine = NULL;\n        }\n        if (matrixTopLine) {\n            _TIFFfree(matrixTopLine);\n            matrixTopLine = NULL;\n        }\n        if (matrixBottomLine) {\n            _TIFFfree(matrixBottomLine);\n            matrixBottomLine = NULL;\n        }\n\n        const char * err = \"Caught SIGSEGV signal(Segmentation fault or invalid memory reference)\";\n        LOGE(err);\n        if (throwException) {\n            throwDecodeFileException(err);\n        }\n\n        return NULL;\n    }\n\n    for (int i = 0; i < stripMax*rowPerStrip; i += rowPerStrip) {\n\n            sendProgress(i * origwidth, progressTotal);\n\n            //if second raster is exist - copy it to work raster end decode next strip\n            if (isSecondRasterExist) {\n                _TIFFmemcpy(raster, rasterForBottomLine, origwidth * rowPerStrip * sizeof (uint32));\n\n                //If next strip is exist - decode it, invert lines\n                if (i + rowPerStrip < stripMax*rowPerStrip) {\n                    TIFFReadRGBAStrip(image, i+rowPerStrip, rasterForBottomLine);\n                    isSecondRasterExist = 1;\n\n                    rows_to_write = 0;\n                    if ( i + rowPerStrip * 2 > origheight )\n                        rows_to_write = origheight - i - rowPerStrip;\n                    else\n                        rows_to_write = rowPerStrip;\n\n                    if (origorientation <= 4) {\n                        for (int line = 0; line < rows_to_write / 2; line++) {\n                            unsigned int  *top_line, *bottom_line;\n\n                            top_line = rasterForBottomLine + origwidth * line;\n                            bottom_line = rasterForBottomLine + origwidth * (rows_to_write - line - 1);\n\n                            _TIFFmemcpy(work_line_buf, top_line, sizeof(unsigned int) * origwidth);\n                            _TIFFmemcpy(top_line, bottom_line, sizeof(unsigned int) * origwidth);\n                            _TIFFmemcpy(bottom_line, work_line_buf, sizeof(unsigned int) * origwidth);\n                        }\n                    }\n                } else {\n                    isSecondRasterExist = 0;\n                }\n            } else {\n                //if second raster is not exist - first processing - read first and second raster\n                 TIFFReadRGBAStrip(image, i, raster);\n                 //invert lines, because libtiff origin is bottom left instead of top left\n                 rows_to_write = 0;\n                 if( i + rowPerStrip > origheight )\n                    rows_to_write = origheight - i;\n                 else\n                    rows_to_write = rowPerStrip;\n\n                 if (origorientation <= 4) {\n                     for (int line = 0; line < rows_to_write / 2; line++) {\n                         unsigned int  *top_line, *bottom_line;\n\n                         top_line = raster + origwidth * line;\n                         bottom_line = raster + origwidth * (rows_to_write - line - 1);\n\n                         _TIFFmemcpy(work_line_buf, top_line, sizeof(unsigned int) * origwidth);\n                         _TIFFmemcpy(top_line, bottom_line, sizeof(unsigned int) * origwidth);\n                         _TIFFmemcpy(bottom_line, work_line_buf, sizeof(unsigned int) * origwidth);\n                     }\n                 }\n\n                 //if next strip is exist - read it and invert lines\n                 if (i + rowPerStrip < origheight) {\n                    TIFFReadRGBAStrip(image, i+rowPerStrip, rasterForBottomLine);\n                    isSecondRasterExist = 1;\n\n                    //invert lines, because libtiff origin is bottom left instead of top left\n                    rows_to_write = 0;\n                    if ( i + rowPerStrip * 2 > origheight )\n                        rows_to_write = origheight - i - rowPerStrip;\n                    else\n                        rows_to_write = rowPerStrip;\n                    if (origorientation <= 4) {\n                        for (int line = 0; line < rows_to_write / 2; line++) {\n                            unsigned int  *top_line, *bottom_line;\n\n                            top_line = rasterForBottomLine + origwidth * line;\n                            bottom_line = rasterForBottomLine + origwidth * (rows_to_write - line - 1);\n\n                            _TIFFmemcpy(work_line_buf, top_line, sizeof(unsigned int) * origwidth);\n                            _TIFFmemcpy(top_line, bottom_line, sizeof(unsigned int) * origwidth);\n                            _TIFFmemcpy(bottom_line, work_line_buf, sizeof(unsigned int) * origwidth);\n                        }\n                    }\n                 }\n\n            }\n\n            if (inSampleSize == 1) {\n                int byteToCopy = 0;\n                if (i + rowPerStrip < origheight) {\n                    byteToCopy = sizeof(unsigned int) * rowPerStrip * origwidth;\n                } else {\n                    byteToCopy = sizeof(unsigned int) * rows_to_write * origwidth;\n                }\n                int position = i * origwidth;\n                memcpy(&pixels[position], raster, byteToCopy);\n                //sendProgress(position, progressTotal);\n            } else {\n                if (isSecondRasterExist) {\n                    _TIFFmemcpy(matrixBottomLine, rasterForBottomLine /*+ lineAddrToCopyBottomLine * origwidth*/, sizeof(unsigned int) * origwidth);\n                }\n                 int workWritedLines = writedLines;\n                 for (int resBmpY = workWritedLines, workY = 0; resBmpY < *bitmapheight && workY < rowPerStrip; /*wj++,*/ workY ++/*= inSampleSize*/) {\n\n                 if (checkStop()) {\n                     if (raster) {\n                         _TIFFfree(raster);\n                         raster = NULL;\n                     }\n                     if (rasterForBottomLine) {\n                         _TIFFfree(rasterForBottomLine);\n                         rasterForBottomLine = NULL;\n                     }\n                     if (matrixTopLine) {\n                         _TIFFfree(matrixTopLine);\n                         matrixTopLine = NULL;\n                     }\n                     if (matrixBottomLine) {\n                         _TIFFfree(matrixBottomLine);\n                         matrixBottomLine = NULL;\n                     }\n                     LOGI(\"Thread stopped\");\n                     return NULL;\n                 }\n\n                    // if total line of source image is equal to inSampleSize*N then process this line\n                    if (globalLineCounter % inSampleSize == 0) {\n                        for (int resBmpX = 0, workX = 0; resBmpX < *bitmapwidth; resBmpX++, workX += inSampleSize) {\n\n                            //Apply filter to pixel\n                            jint crPix = raster[workY * origwidth + workX];\n                            int sum = 1;\n\n\n                            int alpha = colorMask & crPix >> 24;\n                            int red = colorMask & crPix >> 16;\n                            int green = colorMask & crPix >> 8;\n                            int blue = colorMask & crPix;\n\n\n                            //topleft\n                            if (workX - 1 >= 0 && workY - 1 >= 0) {\n                                crPix = raster[(workY - 1) * origwidth + workX - 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            } else if (workX - 1 >= 0 && workY - 1 == -1 && globalLineCounter > 0) {\n                                crPix = matrixTopLine[workX - 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            }\n                            //top\n                            if (workY - 1 >= 0) {\n                                crPix = raster[(workY - 1) * origwidth + workX];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            } else if (workY - 1 == -1 && globalLineCounter > 0) {\n                                crPix = matrixTopLine[workX];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            }\n\n                            // topright\n                            if (workX + 1 < origwidth && workY - 1 >= 0) {\n                                crPix = raster[(workY - 1) * origwidth + workX + 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            } else if (workX + 1 < origwidth && workY - 1 == -1 && globalLineCounter > 0) {\n                                crPix = matrixTopLine[workX + 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            }\n\n                            //right\n                            if (workX + 1 < origwidth) {\n                                crPix = raster[workY * origwidth + workX + 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            }\n\n                            //bottomright\n                            if (workX + 1 < origwidth && workY + 1 < rowPerStrip) {\n                                crPix = raster[(workY + 1) * origwidth + workX + 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            } else if (workX + 1 < origwidth && workY + 1 == rowPerStrip && isSecondRasterExist) {\n                                crPix = matrixBottomLine[workX + 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            }\n\n                            //bottom\n                            if (workY + 1 < rowPerStrip) {\n                                crPix = raster[(workY + 1) * origwidth + workX + 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            } else if (workY + 1 == rowPerStrip && isSecondRasterExist) {\n                                crPix = matrixBottomLine[workX + 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            }\n\n                            //bottomleft\n                            if (workX - 1 >= 0 && workY + 1 < rowPerStrip) {\n                                crPix = raster[(workY + 1) * origwidth + workX - 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            } else if (workX - 1 >= 0 && workY + 1 == rowPerStrip  && isSecondRasterExist) {\n                                crPix = matrixBottomLine[workX - 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            }\n\n\n                            //left\n                            if (workX - 1 >= 0) {\n                                crPix = raster[workY * origwidth + workX - 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            }\n\n                            red /= sum;\n                            if (red > 255) red = 255;\n                            if (red < 0) red = 0;\n\n                            green /= sum;\n                            if (green > 255) green = 255;\n                            if (green < 0) green = 0;\n\n                            blue /= sum;\n                            if (blue > 255) blue = 255;\n                            if (blue < 0) blue = 0;\n\n                            alpha /= sum;///= sum;\n                            if (alpha > 255) alpha = 255;\n                            if (alpha < 0) alpha = 0;\n\n                            crPix = (alpha << 24) | (red << 16) | (green << 8) | (blue);\n\n                            pixels[resBmpY * *bitmapwidth + resBmpX] = crPix;\n                        }\n                        //if line was processed - increment counter of lines that was writed to result image\n                        writedLines++;\n                        //and incremetncounter of current Y for writing\n                        resBmpY++;\n                    }\n                    if (workY == rowPerStrip - 1 && i + rowPerStrip < origheight) {\n                        _TIFFmemcpy(matrixTopLine, raster + workY * origwidth, sizeof(unsigned int) * origwidth);\n                    }\n                    //incremetn global source image line counter\n                    globalLineCounter++;\n\n                }\n            }\n        }\n        LOGI(\"Decoding finished. Free memmory\");\n\n        //Close Buffers\n        if (raster) {\n            _TIFFfree(raster);\n            raster = NULL;\n        }\n\n        if (rasterForBottomLine) {\n            _TIFFfree(rasterForBottomLine);\n            rasterForBottomLine = NULL;\n        }\n\n        if (matrixTopLine) {\n            _TIFFfree(matrixTopLine);\n            matrixTopLine = NULL;\n        }\n\n        if (matrixBottomLine) {\n            _TIFFfree(matrixBottomLine);\n            matrixBottomLine = NULL;\n        }\n\n        if (useOrientationTag) {\n            uint32 buf;\n            //fixOrientation(pixels, pixelsBufferSize, *bitmapwidth, *bitmapheight);\n            switch(origorientation) {\n                 case ORIENTATION_TOPLEFT:\n                 case ORIENTATION_TOPRIGHT:\n                    break;\n                 case ORIENTATION_BOTRIGHT:\n                 case ORIENTATION_BOTLEFT:\n                    flipPixelsVertical(*bitmapwidth, *bitmapheight, pixels);\n                    break;\n                 case ORIENTATION_LEFTTOP:\n                    rotateRaster(pixels, 90, bitmapwidth, bitmapheight);\n                    flipPixelsHorizontal(*bitmapwidth, *bitmapheight, pixels);\n                    buf = *bitmapwidth;\n                    *bitmapwidth = *bitmapheight;\n                    *bitmapheight = buf;\n                    break;\n                 case ORIENTATION_RIGHTTOP:\n                    rotateRaster(pixels, 270, bitmapwidth, bitmapheight);\n                    flipPixelsHorizontal(*bitmapwidth, *bitmapheight, pixels);\n                    buf = *bitmapwidth;\n                    *bitmapwidth = *bitmapheight;\n                    *bitmapheight = buf;\n                    break;\n                 case ORIENTATION_RIGHTBOT:\n                    rotateRaster(pixels, 90, bitmapwidth, bitmapheight);\n                    buf= *bitmapwidth;\n                    *bitmapwidth = *bitmapheight;\n                    *bitmapheight = buf;\n                    break;\n                 case ORIENTATION_LEFTBOT:\n                    rotateRaster(pixels, 270, bitmapwidth, bitmapheight);\n                    buf = *bitmapwidth;\n                    *bitmapwidth = *bitmapheight;\n                    *bitmapheight = buf;\n                    break;\n            }\n\n        } else if (origorientation == 2 || origorientation == 3 || origorientation == 6 || origorientation == 7) {\n            flipPixelsHorizontal(*bitmapwidth, *bitmapheight, pixels);\n        }\n\n        return pixels;\n}\n\njint * NativeDecoder::getSampledRasterFromStripWithBounds(int inSampleSize, int *bitmapwidth, int *bitmapheight) {\n\n    //init signal handler for catch SIGSEGV error that could be raised in libtiff\n    struct sigaction act;\n    memset(&act, 0, sizeof(act));\n    sigemptyset(&act.sa_mask);\n    act.sa_sigaction = stripErrorHandler;\n    act.sa_flags = SA_SIGINFO | SA_ONSTACK;\n    if(sigaction(SIGSEGV, &act, 0) < 0) {\n        LOGE(\"Can\\'t setup signal handler. Working without errors catching mechanism\");\n    }\n\n    LOGII(\"width\", origwidth);\n    LOGII(\"height\", origheight);\n\n    jint *pixels = NULL;\n    *bitmapwidth = origwidth / inSampleSize;\n    *bitmapheight = boundHeight / inSampleSize;//origheight / inSampleSize;\n    uint32 pixelsBufferSize = *bitmapwidth * *bitmapheight;\n    int origImageBufferSize = origwidth * origheight;\n\n    LOGII(\"new width\", *bitmapwidth);\n    LOGII(\"new height\", *bitmapheight);\n\n    uint32 stripSize = TIFFStripSize (image);\n    uint32 stripMax = TIFFNumberOfStrips (image);\n    LOGII(\"strip size \", stripSize);\n    LOGII(\"stripMax  \", stripMax);\n    int rowPerStrip = -1;\n    TIFFGetField(image, TIFFTAG_ROWSPERSTRIP, &rowPerStrip);\n    LOGII(\"rowsperstrip\", rowPerStrip);\n\n    unsigned long estimateMem = 0;\n    estimateMem += (sizeof(jint) * pixelsBufferSize); //temp buffer for decoded pixels\n    estimateMem += (sizeof(jint) * (boundWidth / inSampleSize) * (boundHeight/inSampleSize)); //final buffer that will store original image\n    estimateMem += (origwidth * sizeof(uint32)); //work line for rotate strip\n    estimateMem += (origwidth * rowPerStrip * sizeof (uint32) * 2); //current and next strips\n    estimateMem += (sizeof(jint) * origwidth * 2); //bottom and top lines for reading pixel(matrixBottomLine, matrixTopLine)\n    LOGII(\"estimateMem\", estimateMem);\n    if (estimateMem > availableMemory) {\n        if (throwException) {\n            throw_not_enought_memory_exception(env, availableMemory, estimateMem);\n        }\n        return NULL;\n    }\n\n    progressTotal = pixelsBufferSize + (boundWidth/inSampleSize) * (boundHeight / inSampleSize);\n    sendProgress(0, progressTotal);\n    jlong processedProgress = 0;\n\n    pixels = (jint *) malloc(sizeof(jint) * pixelsBufferSize);\n    if (pixels == NULL) {\n        LOGE(\"Can\\'t allocate memory for temp buffer\");\n        return NULL;\n    }\n\n    uint32* work_line_buf = (uint32 *)_TIFFmalloc(origwidth * sizeof(uint32));\n\n    uint32* raster;\n    uint32* rasterForBottomLine; // in this raster copy next strip for getting bottom line in matrix color selection\n    if (rowPerStrip == -1 && stripMax == 1) {\n            raster = (uint32 *)_TIFFmalloc(origImageBufferSize * sizeof (uint32));\n            rasterForBottomLine = (uint32 *)_TIFFmalloc(origImageBufferSize * sizeof (uint32));\n    } else {\n            raster = (uint32 *)_TIFFmalloc(origwidth * rowPerStrip * sizeof (uint32));\n            rasterForBottomLine = (uint32 *)_TIFFmalloc(origwidth * rowPerStrip * sizeof (uint32));\n    }\n    if (rowPerStrip == -1) {\n            rowPerStrip = origheight;\n    }\n\n    int writedLines = 0;\n    int nextStripOffset = 0;\n    int globalLineCounter = 0;\n\n    unsigned int *matrixTopLine = (uint32 *) malloc(sizeof(jint) * origwidth);\n    unsigned int *matrixBottomLine = (uint32 *) malloc(sizeof(jint) * origwidth);\n\n    int isSecondRasterExist = 0;\n    int ok = 1;\n    uint32 rows_to_write = 0;\n\n    //check for error\n    if (setjmp(NativeDecoder::strip_buf)) {\n        if (raster) {\n            _TIFFfree(raster);\n            raster = NULL;\n        }\n        if (rasterForBottomLine) {\n            _TIFFfree(rasterForBottomLine);\n            rasterForBottomLine = NULL;\n        }\n        if (matrixTopLine) {\n            _TIFFfree(matrixTopLine);\n            matrixTopLine = NULL;\n        }\n        if (matrixBottomLine) {\n            _TIFFfree(matrixBottomLine);\n            matrixBottomLine = NULL;\n        }\n\n        const char * err = \"Caught SIGSEGV signal(Segmentation fault or invalid memory reference)\";\n        LOGE(err);\n        if (throwException) {\n            throwDecodeFileException(err);\n        }\n\n        return NULL;\n    }\n\n    for (int i = 0; (i < stripMax*rowPerStrip || i > boundY + boundHeight) ; i += rowPerStrip) {\n\n            if (i + rowPerStrip <= boundY) {\n                continue;\n            }\n            if (i > boundY + boundHeight) {\n                break;\n            }\n\n            sendProgress(processedProgress * *bitmapwidth, progressTotal);\n            processedProgress += rowPerStrip/inSampleSize;\n\n            //if second raster is exist - copy it to work raster end decode next strip\n            if (isSecondRasterExist) {\n                _TIFFmemcpy(raster, rasterForBottomLine, origwidth * rowPerStrip * sizeof (uint32));\n\n                //If next strip is exist - decode it, invert lines\n                if (i + rowPerStrip < stripMax*rowPerStrip) {\n                    TIFFReadRGBAStrip(image, i+rowPerStrip, rasterForBottomLine);\n                    isSecondRasterExist = 1;\n\n                    rows_to_write = 0;\n                    if ( i + rowPerStrip * 2 > origheight )\n                        rows_to_write = origheight - i - rowPerStrip;\n                    else\n                        rows_to_write = rowPerStrip;\n\n                    if (origorientation <= 4) {\n                        for (int line = 0; line < rows_to_write / 2; line++) {\n                            unsigned int  *top_line, *bottom_line;\n\n                            top_line = rasterForBottomLine + origwidth * line;\n                            bottom_line = rasterForBottomLine + origwidth * (rows_to_write - line - 1);\n\n                            _TIFFmemcpy(work_line_buf, top_line, sizeof(unsigned int) * origwidth);\n                            _TIFFmemcpy(top_line, bottom_line, sizeof(unsigned int) * origwidth);\n                            _TIFFmemcpy(bottom_line, work_line_buf, sizeof(unsigned int) * origwidth);\n                        }\n                    }\n                } else {\n                    isSecondRasterExist = 0;\n                }\n            } else {\n                //if second raster is not exist - first processing - read first and second raster\n                 TIFFReadRGBAStrip(image, i, raster);\n                 //invert lines, because libtiff origin is bottom left instead of top left\n                 rows_to_write = 0;\n                 if( i + rowPerStrip > origheight )\n                    rows_to_write = origheight - i;\n                 else\n                    rows_to_write = rowPerStrip;\n\n                 if (origorientation <= 4) {\n                     for (int line = 0; line < rows_to_write / 2; line++) {\n                         unsigned int  *top_line, *bottom_line;\n\n                         top_line = raster + origwidth * line;\n                         bottom_line = raster + origwidth * (rows_to_write - line - 1);\n\n                         _TIFFmemcpy(work_line_buf, top_line, sizeof(unsigned int) * origwidth);\n                         _TIFFmemcpy(top_line, bottom_line, sizeof(unsigned int) * origwidth);\n                         _TIFFmemcpy(bottom_line, work_line_buf, sizeof(unsigned int) * origwidth);\n                     }\n                 }\n\n                 //if next strip is exist - read it and invert lines\n                 if (i + rowPerStrip < origheight) {\n                    TIFFReadRGBAStrip(image, i+rowPerStrip, rasterForBottomLine);\n                    isSecondRasterExist = 1;\n\n                    //invert lines, because libtiff origin is bottom left instead of top left\n                    rows_to_write = 0;\n                    if ( i + rowPerStrip * 2 > origheight )\n                        rows_to_write = origheight - i - rowPerStrip;\n                    else\n                        rows_to_write = rowPerStrip;\n                    if (origorientation <= 4) {\n                        for (int line = 0; line < rows_to_write / 2; line++) {\n                            unsigned int  *top_line, *bottom_line;\n\n                            top_line = rasterForBottomLine + origwidth * line;\n                            bottom_line = rasterForBottomLine + origwidth * (rows_to_write - line - 1);\n\n                            _TIFFmemcpy(work_line_buf, top_line, sizeof(unsigned int) * origwidth);\n                            _TIFFmemcpy(top_line, bottom_line, sizeof(unsigned int) * origwidth);\n                            _TIFFmemcpy(bottom_line, work_line_buf, sizeof(unsigned int) * origwidth);\n                        }\n                    }\n                 }\n\n            }\n\n            /*if (inSampleSize == 1) {\n                int byteToCopy = 0;\n                if (i + rowPerStrip < origheight) {\n                    byteToCopy = sizeof(unsigned int) * rowPerStrip * origwidth;\n                } else {\n                    byteToCopy = sizeof(unsigned int) * rows_to_write * origwidth;\n                }\n                int position = i * origwidth;\n                memcpy(&pixels[position], raster, byteToCopy);\n                //sendProgress(position, progressTotal);\n            } else {*/\n                if (isSecondRasterExist) {\n                    _TIFFmemcpy(matrixBottomLine, rasterForBottomLine /*+ lineAddrToCopyBottomLine * origwidth*/, sizeof(unsigned int) * origwidth);\n                }\n                 int workWritedLines = writedLines;\n                 for (int resBmpY = workWritedLines, workY = 0; resBmpY < *bitmapheight && workY < rowPerStrip; /*wj++,*/ workY ++/*= inSampleSize*/) {\n\n                 if (checkStop()) {\n                     if (raster) {\n                         _TIFFfree(raster);\n                         raster = NULL;\n                     }\n                     if (rasterForBottomLine) {\n                         _TIFFfree(rasterForBottomLine);\n                         rasterForBottomLine = NULL;\n                     }\n                     if (matrixTopLine) {\n                         _TIFFfree(matrixTopLine);\n                         matrixTopLine = NULL;\n                     }\n                     if (matrixBottomLine) {\n                         _TIFFfree(matrixBottomLine);\n                         matrixBottomLine = NULL;\n                     }\n                     LOGI(\"Thread stopped\");\n                     return NULL;\n                 }\n\n                    // if total line of source image is equal to inSampleSize*N then process this line\n                    if (globalLineCounter % inSampleSize == 0) {\n                        for (int resBmpX = 0, workX = 0; resBmpX < *bitmapwidth; workX += inSampleSize) {\n\n                            /*if (workX <= boundX) {\n                                continue;\n                            }\n                            if (workX > boundX + boundWidth) {\n                                break;\n                            }\n                            LOGII(\"J\", workX);*/\n\n                            //Apply filter to pixel\n                            jint crPix = raster[workY * origwidth + workX];\n                            int sum = 1;\n\n\n                            int alpha = colorMask & crPix >> 24;\n                            int red = colorMask & crPix >> 16;\n                            int green = colorMask & crPix >> 8;\n                            int blue = colorMask & crPix;\n\n\n                            //topleft\n                            if (workX - 1 >= 0 && workY - 1 >= 0) {\n                                crPix = raster[(workY - 1) * origwidth + workX - 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            } else if (workX - 1 >= 0 && workY - 1 == -1 && globalLineCounter > 0) {\n                                crPix = matrixTopLine[workX - 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            }\n                            //top\n                            if (workY - 1 >= 0) {\n                                crPix = raster[(workY - 1) * origwidth + workX];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            } else if (workY - 1 == -1 && globalLineCounter > 0) {\n                                crPix = matrixTopLine[workX];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            }\n\n                            // topright\n                            if (workX + 1 < origwidth && workY - 1 >= 0) {\n                                crPix = raster[(workY - 1) * origwidth + workX + 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            } else if (workX + 1 < origwidth && workY - 1 == -1 && globalLineCounter > 0) {\n                                crPix = matrixTopLine[workX + 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            }\n\n                            //right\n                            if (workX + 1 < origwidth) {\n                                crPix = raster[workY * origwidth + workX + 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            }\n\n                            //bottomright\n                            if (workX + 1 < origwidth && workY + 1 < rowPerStrip) {\n                                crPix = raster[(workY + 1) * origwidth + workX + 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            } else if (workX + 1 < origwidth && workY + 1 == rowPerStrip && isSecondRasterExist) {\n                                crPix = matrixBottomLine[workX + 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            }\n\n                            //bottom\n                            if (workY + 1 < rowPerStrip) {\n                                crPix = raster[(workY + 1) * origwidth + workX + 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            } else if (workY + 1 == rowPerStrip && isSecondRasterExist) {\n                                crPix = matrixBottomLine[workX + 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            }\n\n                            //bottomleft\n                            if (workX - 1 >= 0 && workY + 1 < rowPerStrip) {\n                                crPix = raster[(workY + 1) * origwidth + workX - 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            } else if (workX - 1 >= 0 && workY + 1 == rowPerStrip  && isSecondRasterExist) {\n                                crPix = matrixBottomLine[workX - 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            }\n\n\n                            //left\n                            if (workX - 1 >= 0) {\n                                crPix = raster[workY * origwidth + workX - 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            }\n\n                            red /= sum;\n                            if (red > 255) red = 255;\n                            if (red < 0) red = 0;\n\n                            green /= sum;\n                            if (green > 255) green = 255;\n                            if (green < 0) green = 0;\n\n                            blue /= sum;\n                            if (blue > 255) blue = 255;\n                            if (blue < 0) blue = 0;\n\n                            alpha /= sum;///= sum;\n                            if (alpha > 255) alpha = 255;\n                            if (alpha < 0) alpha = 0;\n\n                            crPix = (alpha << 24) | (red << 16) | (green << 8) | (blue);\n\n                            pixels[resBmpY * *bitmapwidth + resBmpX] = crPix;\n\n                            resBmpX++;\n                        }\n                        //if line was processed - increment counter of lines that was writed to result image\n                        writedLines++;\n                        //and incremetncounter of current Y for writing\n                        resBmpY++;\n                    }\n                    if (workY == rowPerStrip - 1 && i + rowPerStrip < origheight) {\n                        _TIFFmemcpy(matrixTopLine, raster + workY * origwidth, sizeof(unsigned int) * origwidth);\n                    }\n                    //incremetn global source image line counter\n                    globalLineCounter++;\n\n                }\n            /*}*/\n        }\n        LOGI(\"Decoding finished. Free memmory\");\n\n        //Close Buffers\n        if (raster) {\n            _TIFFfree(raster);\n            raster = NULL;\n        }\n\n        if (rasterForBottomLine) {\n            _TIFFfree(rasterForBottomLine);\n            rasterForBottomLine = NULL;\n        }\n\n        if (matrixTopLine) {\n            _TIFFfree(matrixTopLine);\n            matrixTopLine = NULL;\n        }\n\n        if (matrixBottomLine) {\n            _TIFFfree(matrixBottomLine);\n            matrixBottomLine = NULL;\n        }\n\n        processedProgress *= *bitmapwidth;\n\n        if (useOrientationTag) {\n            uint32 buf;\n            switch(origorientation) {\n                 case ORIENTATION_TOPLEFT:\n                 case ORIENTATION_TOPRIGHT:\n                    break;\n                 case ORIENTATION_BOTRIGHT:\n                 case ORIENTATION_BOTLEFT:\n                    flipPixelsVertical(*bitmapwidth, *bitmapheight, pixels);\n                    break;\n                 case ORIENTATION_LEFTTOP:\n                    rotateRaster(pixels, 90, bitmapwidth, bitmapheight);\n                    flipPixelsHorizontal(*bitmapwidth, *bitmapheight, pixels);\n                    buf = *bitmapwidth;\n                    *bitmapwidth = *bitmapheight;\n                    *bitmapheight = buf;\n                    break;\n                 case ORIENTATION_RIGHTTOP:\n                    rotateRaster(pixels, 270, bitmapwidth, bitmapheight);\n                    flipPixelsHorizontal(*bitmapwidth, *bitmapheight, pixels);\n                    buf = *bitmapwidth;\n                    *bitmapwidth = *bitmapheight;\n                    *bitmapheight = buf;\n                    break;\n                 case ORIENTATION_RIGHTBOT:\n                    rotateRaster(pixels, 90, bitmapwidth, bitmapheight);\n                    buf= *bitmapwidth;\n                    *bitmapwidth = *bitmapheight;\n                    *bitmapheight = buf;\n                    break;\n                 case ORIENTATION_LEFTBOT:\n                    rotateRaster(pixels, 270, bitmapwidth, bitmapheight);\n                    buf = *bitmapwidth;\n                    *bitmapwidth = *bitmapheight;\n                    *bitmapheight = buf;\n                    break;\n            }\n\n        } else if (origorientation == 2 || origorientation == 3 || origorientation == 6 || origorientation == 7) {\n            flipPixelsHorizontal(*bitmapwidth, *bitmapheight, pixels);\n        }\n\n        uint32 tmpPixelBufferSize = (boundWidth / inSampleSize) * (boundHeight / inSampleSize);\n\n        estimateMem = (sizeof(jint) * pixelsBufferSize); //temp buffer for decoded pixels\n        estimateMem += (sizeof(jint) * tmpPixelBufferSize); //final buffer that will store original image\n        LOGII(\"estimateMem\", estimateMem);\n        if (estimateMem > availableMemory) {\n            if (throwException) {\n                throw_not_enought_memory_exception(env, availableMemory, estimateMem);\n            }\n            return NULL;\n        }\n\n        jint* tmpPixels = (jint *) malloc(sizeof(jint) * tmpPixelBufferSize);\n        uint32 startPosX = 0;\n\n        if (useOrientationTag && (origorientation == ORIENTATION_TOPRIGHT || origorientation == ORIENTATION_BOTRIGHT\n                                    || origorientation == ORIENTATION_LEFTBOT || origorientation == ORIENTATION_RIGHTBOT)) {\n            startPosX = *bitmapwidth - boundX/inSampleSize;\n            for (int ox = startPosX, nx = 0; nx < boundWidth/inSampleSize; ox--, nx++) {\n                sendProgress(processedProgress + nx * boundWidth/inSampleSize, progressTotal);\n                for (int oy = 0, ny = 0; ny < boundHeight/inSampleSize; oy++, ny++) {\n                    if (useOrientationTag && (origorientation > 4)) {\n                        tmpPixels[nx * (boundHeight/inSampleSize) + ny] = pixels[ox * *bitmapheight + oy];\n                    } else {\n                        tmpPixels[ny * (boundWidth/inSampleSize) + nx] = pixels[oy * *bitmapwidth + ox];\n                    }\n                }\n            }\n        } else {\n            startPosX = boundX/inSampleSize;\n            for (int ox = startPosX, nx = 0; nx < boundWidth/inSampleSize; ox++, nx++) {\n                sendProgress(processedProgress + nx * boundWidth/inSampleSize, progressTotal);\n                for (int oy = 0, ny = 0; ny < boundHeight/inSampleSize; oy++, ny++) {\n                    if (useOrientationTag && (origorientation > 4)) {\n                        tmpPixels[nx * (boundHeight/inSampleSize) + ny] = pixels[ox * *bitmapheight + oy];\n                    } else {\n                        tmpPixels[ny * (boundWidth/inSampleSize) + nx] = pixels[oy * *bitmapwidth + ox];\n                    }\n                }\n            }\n        }\n\n        free(pixels);\n        pixels = tmpPixels;\n        *bitmapwidth = boundWidth/inSampleSize;\n        *bitmapheight = boundHeight/inSampleSize;\n\n        return pixels;\n}\n\nvoid NativeDecoder::rotateTileLinesVertical(uint32 tileHeight, uint32 tileWidth, uint32* whatRotate, uint32 *bufferLine) {\n    for (int line = 0; line < tileHeight / 2; line++) {\n        unsigned int  *top_line, *bottom_line;\n        top_line = whatRotate + tileWidth * line;\n        bottom_line = whatRotate + tileWidth * (tileHeight - line -1);\n        _TIFFmemcpy(bufferLine, top_line, sizeof(unsigned int) * tileWidth);\n        _TIFFmemcpy(top_line, bottom_line, sizeof(unsigned int) * tileWidth);\n        _TIFFmemcpy(bottom_line, bufferLine, sizeof(unsigned int) * tileWidth);\n    }\n}\n\nvoid NativeDecoder::rotateTileLinesHorizontal(uint32 tileHeight, uint32 tileWidth, uint32* whatRotate, uint32 *bufferLine) {\n    uint32 buf;\n    for (int y = 0; y < tileHeight; y++) {\n        for (int x = 0; x < tileWidth / 2; x++) {\n            buf = whatRotate[y * tileWidth + x];\n            whatRotate[y * tileWidth + x] = whatRotate[y * tileWidth + tileWidth - x - 1];\n            whatRotate[y * tileWidth + tileWidth - x - 1] = buf;\n        }\n    }\n}\n\njint * NativeDecoder::getSampledRasterFromTile(int inSampleSize, int *bitmapwidth, int *bitmapheight) {\n\n        //init signal handler for catch SIGSEGV error that could be raised in libtiff\n        struct sigaction act;\n        memset(&act, 0, sizeof(act));\n        sigemptyset(&act.sa_mask);\n        act.sa_sigaction = tileErrorHandler;\n        act.sa_flags = SA_SIGINFO | SA_ONSTACK;\n        if(sigaction(SIGSEGV, &act, 0) < 0) {\n            LOGE(\"Can\\'t setup signal handler. Working without errors catching mechanism\");\n        }\n\n        jint *pixels = NULL;\n        *bitmapwidth = origwidth / inSampleSize;\n        *bitmapheight = origheight / inSampleSize;\n        uint32 pixelsBufferSize = *bitmapwidth * *bitmapheight;\n\n        uint32 tileWidth = 0, tileHeight = 0;\n        TIFFGetField(image, TIFFTAG_TILEWIDTH, &tileWidth);\n        TIFFGetField(image, TIFFTAG_TILEWIDTH, &tileHeight);\n\n        unsigned long estimateMem = 0;\n        estimateMem += (sizeof(jint) * pixelsBufferSize); //buffer for decoded pixels\n        estimateMem += (tileWidth * tileHeight * sizeof(uint32)) * 3; //current, left and right tiles buffers\n        estimateMem += (tileWidth * sizeof(uint32)); //work line for rotate tile\n        LOGII(\"estimateMem\", estimateMem);\n        if (estimateMem > availableMemory) {\n            if (throwException) {\n                throw_not_enought_memory_exception(env, availableMemory, estimateMem);\n            }\n            return NULL;\n        }\n\n        pixels = (jint *) malloc(sizeof(jint) * pixelsBufferSize);\n        if (pixels == NULL) {\n            LOGE(\"Can\\'t allocate memory for temp buffer\");\n            return NULL;\n        }\n\n        uint32 row, column;\n\n        //main worker tile\n        uint32 *rasterTile = (uint32 *)_TIFFmalloc(tileWidth * tileHeight * sizeof(uint32));\n        //left tile\n        uint32 *rasterTileLeft = (uint32 *)_TIFFmalloc(tileWidth * tileHeight * sizeof(uint32));\n        //right tile\n        uint32 *rasterTileRight = (uint32 *)_TIFFmalloc(tileWidth * tileHeight * sizeof(uint32));\n\n        uint32 *work_line_buf = (uint32*)_TIFFmalloc(tileWidth * sizeof (uint32));\n\n        //this variable calculate processed pixels for x and y direction to make right offsets at the begining of next tile\n        //offset calculated from condition globalProcessed % inSampleSize should be 0\n        uint32 globalProcessedX = 0;\n        uint32 globalProcessedY = 0;\n\n        //check for error\n        if (setjmp(NativeDecoder::tile_buf)) {\n            if (rasterTile) {\n                _TIFFfree(rasterTile);\n                rasterTile = NULL;\n            }\n            if (rasterTileLeft) {\n                _TIFFfree(rasterTileLeft);\n                rasterTileLeft = NULL;\n            }\n            if (rasterTileRight) {\n                _TIFFfree(rasterTileRight);\n                rasterTileRight = NULL;\n            }\n            if (work_line_buf) {\n                _TIFFfree(work_line_buf);\n                work_line_buf = NULL;\n            }\n\n            const char * err = \"Caught SIGSEGV signal(Segmentation fault or invalid memory reference)\";\n            LOGE(err);\n            if (throwException) {\n                throwDecodeFileException(err);\n            }\n\n            return NULL;\n        }\n\n        for (row = 0; row < origheight; row += tileHeight) {\n            short leftTileExists = 0;\n            short rightTileExists = 0;\n            for (column = 0; column < origwidth; column += tileWidth) {\n                sendProgress(row * origwidth + column, progressTotal);\n\n                //If not first column - we should have previous tile - copy it to left tile buffer\n                if (column != 0) {\n                    _TIFFmemcpy(rasterTileLeft, rasterTile, tileWidth * tileHeight * sizeof(uint32));\n                    leftTileExists = 1;\n                } else {\n                    leftTileExists = 0;\n                }\n\n                //if current column + tile width is less than origin width - we have right tile - copy it to current tile and read next tile to rasterTileRight buffer\n                if (column + tileWidth < origwidth && rightTileExists) {\n                    _TIFFmemcpy(rasterTile, rasterTileRight, tileWidth * tileHeight * sizeof(uint32));\n                    TIFFReadRGBATile(image, column + tileWidth, row, rasterTileRight);\n                    rightTileExists = 1;\n                } else if (column + tileWidth < origwidth) {\n                    //have right tile but this is first tile in row, so need to read raster and right raster\n                    TIFFReadRGBATile(image, column + tileWidth, row, rasterTileRight);\n                    TIFFReadRGBATile(image, column, row, rasterTile);\n                    rightTileExists = 1;\n\n                    //in that case we also need to invert lines in rasterTile\n                    switch(origorientation) {\n                        case 1:\n                        case 5:\n                            rotateTileLinesVertical(tileHeight, tileWidth, rasterTile, work_line_buf);\n                            break;\n                        case 2:\n                        case 6:\n                            rotateTileLinesVertical(tileHeight, tileWidth, rasterTile, work_line_buf);\n                            rotateTileLinesHorizontal(tileHeight, tileWidth, rasterTile, work_line_buf);\n                            break;\n                        case 3:\n                        case 7:\n                            rotateTileLinesHorizontal(tileHeight, tileWidth, rasterTile, work_line_buf);\n                            break;\n                    }\n                } else {\n                    //otherwise we haven't right tile buffer, so we should read tile to current buffer\n                    TIFFReadRGBATile(image, column, row, rasterTile);\n                    rightTileExists = 0;\n                }\n\n                //if we have right tile - current tile already rotated and we need to rotate only right tile\n                if (rightTileExists) {\n                    switch(origorientation) {\n                        case 1:\n                        case 5:\n                            rotateTileLinesVertical(tileHeight, tileWidth, rasterTileRight, work_line_buf);\n                            break;\n                        case 2:\n                        case 6:\n                            rotateTileLinesVertical(tileHeight, tileWidth, rasterTileRight, work_line_buf);\n                            rotateTileLinesHorizontal(tileHeight, tileWidth, rasterTileRight, work_line_buf);\n                            break;\n                        case 3:\n                        case 7:\n                            rotateTileLinesHorizontal(tileHeight, tileWidth, rasterTileRight, work_line_buf);\n                            break;\n                    }\n                } else {\n                    //otherwise - current tile not rotated so rotate it\n                    //tile orig is on bottom left - should change lines\n                     switch(origorientation) {\n                        case 1:\n                        case 5:\n                            rotateTileLinesVertical(tileHeight, tileWidth, rasterTile, work_line_buf);\n                            break;\n                        case 2:\n                        case 6:\n                            rotateTileLinesVertical(tileHeight, tileWidth, rasterTile, work_line_buf);\n                            rotateTileLinesHorizontal(tileHeight, tileWidth, rasterTile, work_line_buf);\n                            break;\n                        case 3:\n                        case 7:\n                            rotateTileLinesHorizontal(tileHeight, tileWidth, rasterTile, work_line_buf);\n                            break;\n                    }\n                }\n\n                if (inSampleSize > 1 )\n                {\n                    //Tile could begin from not filled pixel(pixel[x,y] == 0). This variables allow to calculate begining of filled pixels\n                    int tileStartDataX = -1;\n                    int tileStartDataY = -1;\n\n                    for (int origTileY = 0, pixY = row/inSampleSize; origTileY < tileHeight && pixY < *bitmapheight; origTileY++) {\n\n                        if (checkStop()) {\n                            if (rasterTile) {\n                                _TIFFfree(rasterTile);\n                                rasterTile = NULL;\n                            }\n                            if (rasterTileLeft) {\n                                _TIFFfree(rasterTileLeft);\n                                rasterTileLeft = NULL;\n                            }\n                            if (rasterTileRight) {\n                                _TIFFfree(rasterTileRight);\n                                rasterTileRight = NULL;\n                            }\n                            if (work_line_buf) {\n                                _TIFFfree(work_line_buf);\n                                work_line_buf = NULL;\n                            }\n                            LOGI(\"Thread stopped\");\n                            return NULL;\n                        }\n\n                        if (tileStartDataY != -1 && globalProcessedY % inSampleSize != 0) {\n                            if (tileStartDataY != -1) {\n                                globalProcessedY++;\n                            }\n                        }\n                        else\n                        {\n                            for (int origTileX = 0, pixX = column/inSampleSize; origTileX < tileWidth && pixX < *bitmapwidth; origTileX++) {\n                                if (tileStartDataX != -1 && globalProcessedX % inSampleSize != 0)\n                                {\n                                    if (tileStartDataX != -1) {\n                                        globalProcessedX++;\n                                    }\n                                }\n                                else\n                                {\n                                    uint32 srcPosition = origTileY * tileWidth + origTileX;\n                                    if (rasterTile[srcPosition] != 0) {\n                                        if (tileStartDataX == -1) {\n                                            tileStartDataX = origTileX;\n                                        }\n                                        if (tileStartDataY == -1) {\n                                            tileStartDataY = origTileY;\n                                        }\n\n                                        //Apply filter to pixel\n                                        jint crPix = rasterTile[srcPosition];//origBuffer[j1 * origwidth + i1];\n                                        int sum = 1;\n\n                                        int alpha = colorMask & crPix >> 24;\n                                        int red = colorMask & crPix >> 16;\n                                        int green = colorMask & crPix >> 8;\n                                        int blue = colorMask & crPix;\n\n                                        //using kernel 3x3\n\n                                        //topleft\n                                        if (origTileX - 1 >= 0 && origTileY - 1 >= 0) {\n                                            crPix = rasterTile[(origTileY - 1) * tileWidth + origTileX - 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        } else if (origTileY - 1 >= 0 && leftTileExists) {\n                                            crPix = rasterTileLeft[(origTileY - 1) * tileWidth + tileWidth - 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        }\n\n                                        //top\n                                        if (origTileY - 1 >= 0) {\n                                            crPix = rasterTile[(origTileY - 1) * tileWidth + origTileX];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        }\n\n                                        // topright\n                                        if (origTileX + 1 < tileWidth && origTileY - 1 >= 0) {\n                                            crPix = rasterTile[(origTileY - 1) * tileWidth + origTileX + 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        } else if (origTileY - 1 >= 0 && rightTileExists) {\n                                            crPix = rasterTileRight[(origTileY - 1) * tileWidth];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        }\n\n                                        //right\n                                        if (origTileX + 1 < tileWidth) {\n                                            crPix = rasterTile[origTileY * tileWidth + origTileX + 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        } else if (rightTileExists) {\n                                            crPix = rasterTileRight[origTileY * tileWidth];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        }\n\n                                        //bottomright\n                                        if (origTileX + 1 < tileWidth && origTileY + 1 < tileHeight) {\n                                            crPix = rasterTile[(origTileY + 1) * tileWidth + origTileX + 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        } else if (origTileY + 1 < tileHeight && rightTileExists) {\n                                            crPix = rasterTileRight[(origTileY + 1) * tileWidth];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        }\n\n                                        //bottom\n                                        if (origTileY + 1 < tileHeight) {\n                                            crPix = rasterTile[(origTileY + 1) * tileWidth + origTileX];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        }\n\n                                        //bottomleft\n                                        if (origTileX - 1 >= 0 && origTileY + 1 < tileHeight) {\n                                            crPix = rasterTile[(origTileY + 1) * tileWidth + origTileX - 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        } else if (origTileY + 1 < tileHeight && leftTileExists) {\n                                            crPix = rasterTileLeft[(origTileY + 1) * tileWidth + tileWidth - 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        }\n\n                                        //left\n                                        if (origTileX - 1 >= 0) {\n                                            crPix = rasterTile[origTileY * tileWidth + origTileX - 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        } else if (leftTileExists) {\n                                            crPix = rasterTileLeft[origTileY * tileWidth + tileWidth - 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        }\n\n                                        red /= sum;\n                                        if (red > 255) red = 255;\n                                        if (red < 0) red = 0;\n\n                                        green /= sum;\n                                        if (green > 255) green = 255;\n                                        if (green < 0) green = 0;\n\n                                        blue /= sum;\n                                        if (blue > 255) blue = 255;\n                                        if (blue < 0) blue = 0;\n\n                                        alpha /= sum;///= sum;\n                                        if (alpha > 255) alpha = 255;\n                                        if (alpha < 0) alpha = 0;\n\n                                        crPix = (alpha << 24) | (red << 16) | (green << 8) | (blue);\n\n                                        int position;\n                                        if (origorientation <= 4) {\n                                            position = pixY * *bitmapwidth + pixX;\n                                        } else {\n                                            position = pixX * *bitmapheight + pixY;\n                                        }\n                                        pixels[position] = crPix;\n                                    } else {\n                                        if (tileStartDataX != -1) tileStartDataX = -1;\n                                        if (tileStartDataY != -1) tileStartDataY = -1;\n                                    }\n\n                                    if (tileStartDataX != -1) {\n                                        pixX++;\n                                        globalProcessedX++;\n                                    }\n\n                                }\n                            }\n                            if (tileStartDataY != -1) {\n                                pixY++;\n                                globalProcessedY++;\n                            }\n                        }\n                    }\n                } else {\n                    int rowHasPixels = 0;\n                        for (int th = 0, bh = 0; th < tileHeight; th++) {\n                            for (int tw = 0, bw = 0; tw < tileWidth; tw++) {\n                                uint32 srcPosition = th * tileWidth + tw;\n                                if (rasterTile[srcPosition] != 0) {\n                                    int position = 0;\n                                    if (origorientation <= 4) {\n                                        position = (row + bh) * *bitmapwidth + column + bw;\n                                    } else {\n                                        position = (column + bw) * *bitmapheight + row + bh;\n                                    }\n                                    pixels[position] = rasterTile[srcPosition];\n                                    rowHasPixels = 1;\n                                    bw++;\n                                }\n                            }\n                            if (rowHasPixels) {\n                                bh++;\n                                rowHasPixels = 0;\n                            }\n                        }\n                }\n            }\n        }\n\n        if (rasterTile) {\n            _TIFFfree(rasterTile);\n            rasterTile = NULL;\n        }\n        if (rasterTileLeft) {\n            _TIFFfree(rasterTileLeft);\n            rasterTileLeft = NULL;\n        }\n        if (rasterTileRight) {\n            _TIFFfree(rasterTileRight);\n            rasterTileRight = NULL;\n        }\n        if (work_line_buf) {\n            _TIFFfree(work_line_buf);\n            work_line_buf = NULL;\n        }\n\n        if (useOrientationTag) {\n            switch (origorientation) {\n                case ORIENTATION_TOPLEFT:\n                case ORIENTATION_LEFTTOP:\n                    break;\n                case ORIENTATION_TOPRIGHT:\n                    flipPixelsHorizontal(*bitmapwidth, *bitmapheight, pixels);\n                    break;\n                case ORIENTATION_RIGHTTOP:\n                    flipPixelsHorizontal(*bitmapheight, *bitmapwidth, pixels);\n                    break;\n                case ORIENTATION_BOTRIGHT:\n                case ORIENTATION_RIGHTBOT:\n                    rotateRaster(pixels, 180, bitmapwidth, bitmapheight);\n                    break;\n                case ORIENTATION_BOTLEFT:\n                    flipPixelsVertical(*bitmapwidth, *bitmapheight, pixels);\n                    break;\n                case ORIENTATION_LEFTBOT:\n                    flipPixelsVertical(*bitmapheight, *bitmapwidth, pixels);\n                    break;\n            }\n        } else {\n            if (origorientation > 4) {\n                uint32 buf = *bitmapwidth;\n                *bitmapwidth = *bitmapheight;\n                *bitmapheight = buf;\n                rotateRaster(pixels, 90, bitmapwidth, bitmapheight);\n                flipPixelsHorizontal(*bitmapwidth, *bitmapheight, pixels);\n            }\n        }\n\n        return pixels;\n}\n\njint * NativeDecoder::getSampledRasterFromTileWithBounds(int inSampleSize, int *bitmapwidth, int *bitmapheight) {\n\n        //init signal handler for catch SIGSEGV error that could be raised in libtiff\n        struct sigaction act;\n        memset(&act, 0, sizeof(act));\n        sigemptyset(&act.sa_mask);\n        act.sa_sigaction = tileErrorHandler;\n        act.sa_flags = SA_SIGINFO | SA_ONSTACK;\n        if(sigaction(SIGSEGV, &act, 0) < 0) {\n            LOGE(\"Can\\'t setup signal handler. Working without errors catching mechanism\");\n        }\n\n\n        //First read all tiles that are on necessary area\n\n        uint32 tileWidth = 0, tileHeight = 0;\n        TIFFGetField(image, TIFFTAG_TILEWIDTH, &tileWidth);\n        TIFFGetField(image, TIFFTAG_TILEWIDTH, &tileHeight);\n\n        //find first and last tile to process\n        uint32 firstTileX = (uint32)(boundX / tileWidth);\n        uint32 firstTileY = (uint32)(boundY / tileHeight);\n\n        uint32 lastTileX = (uint32)((boundX + boundWidth) / tileWidth) + 1;\n        uint32 lastTileY = (uint32)((boundY + boundHeight) / tileHeight) + 1;\n\n        jint *pixels = NULL;\n        *bitmapwidth = /*boundWidth*/ (lastTileX - firstTileX) * tileWidth / inSampleSize;//origwidth / inSampleSize;\n        *bitmapheight = /*boundHeight*/ (lastTileY - firstTileY) * tileHeight / inSampleSize;//origheight / inSampleSize;\n        uint32 pixelsBufferSize = *bitmapwidth * *bitmapheight;\n\n         unsigned long estimateMem = 0;\n         estimateMem += (sizeof(jint) * pixelsBufferSize); //buffer for decoded pixels\n         estimateMem += (tileWidth * tileHeight * sizeof(uint32)) * 3; //current, left and right tiles buffers\n         estimateMem += (tileWidth * sizeof(uint32)); //work line for rotate tile\n         LOGII(\"estimateMem\", estimateMem);\n         if (estimateMem > availableMemory) {\n            if (throwException) {\n                throw_not_enought_memory_exception(env, availableMemory, estimateMem);\n            }\n            return NULL;\n         }\n\n        pixels = (jint *) malloc(sizeof(jint) * pixelsBufferSize);\n        if (pixels == NULL) {\n            LOGE(\"Can\\'t allocate memory for temp buffer\");\n            return NULL;\n        }\n\n        progressTotal = pixelsBufferSize + (boundWidth/inSampleSize) * (boundHeight/inSampleSize);\n        sendProgress(0, progressTotal);\n        jlong processedProgress = 0;\n\n        uint32 row, column, rowDest, columnDest;\n\n        //main worker tile\n        uint32 *rasterTile = (uint32 *)_TIFFmalloc(tileWidth * tileHeight * sizeof(uint32));\n        //left tile\n        uint32 *rasterTileLeft = (uint32 *)_TIFFmalloc(tileWidth * tileHeight * sizeof(uint32));\n        //right tile\n        uint32 *rasterTileRight = (uint32 *)_TIFFmalloc(tileWidth * tileHeight * sizeof(uint32));\n\n        uint32 *work_line_buf = (uint32*)_TIFFmalloc(tileWidth * sizeof (uint32));\n\n        //check for error\n        if (setjmp(NativeDecoder::tile_buf)) {\n            if (rasterTile) {\n                _TIFFfree(rasterTile);\n                rasterTile = NULL;\n            }\n            if (rasterTileLeft) {\n                _TIFFfree(rasterTileLeft);\n                rasterTileLeft = NULL;\n            }\n            if (rasterTileRight) {\n                _TIFFfree(rasterTileRight);\n                rasterTileRight = NULL;\n            }\n            if (work_line_buf) {\n                _TIFFfree(work_line_buf);\n                work_line_buf = NULL;\n            }\n\n        const char * err = \"Caught SIGSEGV signal(Segmentation fault or invalid memory reference)\";\n        LOGE(err);\n        if (throwException) {\n            throwDecodeFileException(err);\n        }\n\n            return NULL;\n        }\n\n        //this variable calculate processed pixels for x and y direction to make right offsets at the begining of next tile\n        //offset calculated from condition globalProcessed % inSampleSize should be 0\n        uint32 globalProcessedX = 0;\n        uint32 globalProcessedY = 0;\n\n        uint32 progressRow = 0;\n        uint32 progressColumn = 0;\n\n        rowDest = columnDest = 0;\n        for (row = firstTileY * tileHeight; row < lastTileY * tileHeight; row += tileHeight, progressRow += tileHeight) {\n            columnDest = 0;\n            short leftTileExists = 0;\n            short rightTileExists = 0;\n            for (column = firstTileX * tileWidth; column < lastTileX * tileWidth; column += tileWidth, progressColumn += tileWidth) {\n                processedProgress = progressRow * *bitmapwidth + progressColumn;\n                sendProgress(processedProgress, progressTotal);\n\n                //If not first column - we should have previous tile - copy it to left tile buffer\n                if (column != firstTileY) {\n                    _TIFFmemcpy(rasterTileLeft, rasterTile, tileWidth * tileHeight * sizeof(uint32));\n                    leftTileExists = 1;\n                } else {\n                    leftTileExists = 0;\n                }\n                //if current column + tile width is less than origin width - we have right tile - copy it to current tile and read next tile to rasterTileRight buffer\n                if (column + tileWidth < origwidth && rightTileExists) {\n                    _TIFFmemcpy(rasterTile, rasterTileRight, tileWidth * tileHeight * sizeof(uint32));\n                    TIFFReadRGBATile(image, column + tileWidth, row, rasterTileRight);\n                    rightTileExists = 1;\n                } else if (column + tileWidth < origwidth) {\n                    //have right tile but this is first tile in row, so need to read raster and right raster\n                    TIFFReadRGBATile(image, column + tileWidth, row, rasterTileRight);\n                    TIFFReadRGBATile(image, column, row, rasterTile);\n                    rightTileExists = 1;\n\n                    //in that case we also need to invert lines in rasterTile\n                    switch(origorientation) {\n                        case 1:\n                        case 5:\n                            rotateTileLinesVertical(tileHeight, tileWidth, rasterTile, work_line_buf);\n                            break;\n                        case 2:\n                        case 6:\n                            rotateTileLinesVertical(tileHeight, tileWidth, rasterTile, work_line_buf);\n                            rotateTileLinesHorizontal(tileHeight, tileWidth, rasterTile, work_line_buf);\n                            break;\n                        case 3:\n                        case 7:\n                            rotateTileLinesHorizontal(tileHeight, tileWidth, rasterTile, work_line_buf);\n                            break;\n                    }\n                } else {\n                    //otherwise we haven't right tile buffer, so we should read tile to current buffer\n                    TIFFReadRGBATile(image, column, row, rasterTile);\n                    rightTileExists = 0;\n                }\n\n                //if we have right tile - current tile already rotated and we need to rotate only right tile\n                if (rightTileExists) {\n                    switch(origorientation) {\n                        case 1:\n                        case 5:\n                            rotateTileLinesVertical(tileHeight, tileWidth, rasterTileRight, work_line_buf);\n                            break;\n                        case 2:\n                        case 6:\n                            rotateTileLinesVertical(tileHeight, tileWidth, rasterTileRight, work_line_buf);\n                            rotateTileLinesHorizontal(tileHeight, tileWidth, rasterTileRight, work_line_buf);\n                            break;\n                        case 3:\n                        case 7:\n                            rotateTileLinesHorizontal(tileHeight, tileWidth, rasterTileRight, work_line_buf);\n                            break;\n                    }\n                } else {\n                    //otherwise - current tile not rotated so rotate it\n                    //tile orig is on bottom left - should change lines\n                     switch(origorientation) {\n                        case 1:\n                        case 5:\n                            rotateTileLinesVertical(tileHeight, tileWidth, rasterTile, work_line_buf);\n                            break;\n                        case 2:\n                        case 6:\n                            rotateTileLinesVertical(tileHeight, tileWidth, rasterTile, work_line_buf);\n                            rotateTileLinesHorizontal(tileHeight, tileWidth, rasterTile, work_line_buf);\n                            break;\n                        case 3:\n                        case 7:\n                            rotateTileLinesHorizontal(tileHeight, tileWidth, rasterTile, work_line_buf);\n                            break;\n                    }\n                }\n\n                    //Tile could begin from not filled pixel(pixel[x,y] == 0). This variables allow to calculate begining of filled pixels\n                    int tileStartDataX = -1;\n                    int tileStartDataY = -1;\n\n                    for (int origTileY = 0, pixY = rowDest/inSampleSize; origTileY < tileHeight && pixY < *bitmapheight; origTileY++) {\n                        if (checkStop()) {\n                            if (rasterTile) {\n                                _TIFFfree(rasterTile);\n                                rasterTile = NULL;\n                            }\n                            if (rasterTileLeft) {\n                                _TIFFfree(rasterTileLeft);\n                                rasterTileLeft = NULL;\n                            }\n                            if (rasterTileRight) {\n                                _TIFFfree(rasterTileRight);\n                                rasterTileRight = NULL;\n                            }\n                            if (work_line_buf) {\n                                _TIFFfree(work_line_buf);\n                                work_line_buf = NULL;\n                            }\n                            LOGI(\"Thread stopped\");\n                            return NULL;\n                        }\n\n                        if (tileStartDataY != -1 && globalProcessedY % inSampleSize != 0) {\n                            if (tileStartDataY != -1) {\n                                globalProcessedY++;\n                            }\n                        }\n                        else\n                        {\n\n                            for (int origTileX = 0, pixX = columnDest/inSampleSize; origTileX < tileWidth && pixX < *bitmapwidth; origTileX++) {\n\n\n                                if (tileStartDataX != -1 && globalProcessedX % inSampleSize != 0)\n                                {\n                                    if (tileStartDataX != -1) {\n                                        globalProcessedX++;\n                                    }\n                                }\n                                else\n                                {\n                                    uint32 srcPosition = origTileY * tileWidth + origTileX;\n                                    if (rasterTile[srcPosition] != 0) {\n\n                                        if (tileStartDataX == -1) {\n                                            tileStartDataX = origTileX;\n                                        }\n                                        if (tileStartDataY == -1) {\n                                            tileStartDataY = origTileY;\n                                        }\n\n                                        //Apply filter to pixel\n                                        jint crPix = rasterTile[srcPosition];//origBuffer[j1 * origwidth + i1];\n                                        int sum = 1;\n\n                                        int alpha = colorMask & crPix >> 24;\n                                        int red = colorMask & crPix >> 16;\n                                        int green = colorMask & crPix >> 8;\n                                        int blue = colorMask & crPix;\n\n                                        //using kernel 3x3\n\n                                        //topleft\n                                        if (origTileX - 1 >= 0 && origTileY - 1 >= 0) {\n                                            crPix = rasterTile[(origTileY - 1) * tileWidth + origTileX - 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        } else if (origTileY - 1 >= 0 && leftTileExists) {\n                                            crPix = rasterTileLeft[(origTileY - 1) * tileWidth + tileWidth - 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        }\n\n                                        //top\n                                        if (origTileY - 1 >= 0) {\n                                            crPix = rasterTile[(origTileY - 1) * tileWidth + origTileX];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        }\n\n                                        // topright\n                                        if (origTileX + 1 < tileWidth && origTileY - 1 >= 0) {\n                                            crPix = rasterTile[(origTileY - 1) * tileWidth + origTileX + 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        } else if (origTileY - 1 >= 0 && rightTileExists) {\n                                            crPix = rasterTileRight[(origTileY - 1) * tileWidth];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        }\n\n                                        //right\n                                        if (origTileX + 1 < tileWidth) {\n                                            crPix = rasterTile[origTileY * tileWidth + origTileX + 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        } else if (rightTileExists) {\n                                            crPix = rasterTileRight[origTileY * tileWidth];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        }\n\n                                        //bottomright\n                                        if (origTileX + 1 < tileWidth && origTileY + 1 < tileHeight) {\n                                            crPix = rasterTile[(origTileY + 1) * tileWidth + origTileX + 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        } else if (origTileY + 1 < tileHeight && rightTileExists) {\n                                            crPix = rasterTileRight[(origTileY + 1) * tileWidth];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        }\n\n                                        //bottom\n                                        if (origTileY + 1 < tileHeight) {\n                                            crPix = rasterTile[(origTileY + 1) * tileWidth + origTileX];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        }\n\n                                        //bottomleft\n                                        if (origTileX - 1 >= 0 && origTileY + 1 < tileHeight) {\n                                            crPix = rasterTile[(origTileY + 1) * tileWidth + origTileX - 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        } else if (origTileY + 1 < tileHeight && leftTileExists) {\n                                            crPix = rasterTileLeft[(origTileY + 1) * tileWidth + tileWidth - 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        }\n\n                                        //left\n                                        if (origTileX - 1 >= 0) {\n                                            crPix = rasterTile[origTileY * tileWidth + origTileX - 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        } else if (leftTileExists) {\n                                            crPix = rasterTileLeft[origTileY * tileWidth + tileWidth - 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        }\n\n                                        red /= sum;\n                                        if (red > 255) red = 255;\n                                        if (red < 0) red = 0;\n\n                                        green /= sum;\n                                        if (green > 255) green = 255;\n                                        if (green < 0) green = 0;\n\n                                        blue /= sum;\n                                        if (blue > 255) blue = 255;\n                                        if (blue < 0) blue = 0;\n\n                                        alpha /= sum;///= sum;\n                                        if (alpha > 255) alpha = 255;\n                                        if (alpha < 0) alpha = 0;\n\n                                        crPix = (alpha << 24) | (red << 16) | (green << 8) | (blue);\n\n                                        int position;\n                                        if (origorientation <= 4) {\n                                            position = pixY * *bitmapwidth + pixX;\n                                        } else {\n                                            position = pixX * *bitmapheight + pixY;\n                                        }\n                                        pixels[position] = crPix;\n                                    } else {\n                                        if (tileStartDataX != -1) tileStartDataX = -1;\n                                        if (tileStartDataY != -1) tileStartDataY = -1;\n                                    }\n\n                                    if (tileStartDataX != -1) {\n                                        pixX++;\n                                        globalProcessedX++;\n                                    }\n\n                                }\n                            }\n                            if (tileStartDataY != -1) {\n                                pixY++;\n                                globalProcessedY++;\n                            }\n                        }\n                    }\n                columnDest += tileWidth;\n            }\n            rowDest += tileHeight;\n        }\n\n        if (rasterTile) {\n            _TIFFfree(rasterTile);\n            rasterTile = NULL;\n        }\n        if (rasterTileLeft) {\n            _TIFFfree(rasterTileLeft);\n            rasterTileLeft = NULL;\n        }\n        if (rasterTileRight) {\n            _TIFFfree(rasterTileRight);\n            rasterTileRight = NULL;\n        }\n        if (work_line_buf) {\n            _TIFFfree(work_line_buf);\n            work_line_buf = NULL;\n        }\n\n        //Copy necessary pixels to new array if orientation <=4\n        uint32 tmpPixelBufferSize = (boundWidth / inSampleSize) * (boundHeight / inSampleSize);\n\n        estimateMem = (sizeof(jint) * pixelsBufferSize); //buffer for decoded pixels\n        estimateMem += (sizeof(jint) * tmpPixelBufferSize); //finall buffer\n        LOGII(\"estimateMem\", estimateMem);\n        if (estimateMem > availableMemory) {\n            if (throwException) {\n                throw_not_enought_memory_exception(env, availableMemory, estimateMem);\n            }\n            return NULL;\n        }\n\n        if (origorientation <= 4) {\n\n            jint* tmpPixels = (jint *) malloc(sizeof(jint) * tmpPixelBufferSize);\n            uint32 startPosX = boundX%tileWidth /inSampleSize;//(firstTileX * tileWidth - tileWidth + boundX) / inSampleSize;\n            uint32 startPosY = boundY%tileHeight /inSampleSize;//(firstTileY * tileHeight - tileHeight + boundY) /inSampleSize;\n            for (int ox = startPosX, nx = 0; nx < boundWidth/inSampleSize; ox++, nx++) {\n                sendProgress(processedProgress + nx * (boundHeight/inSampleSize), progressTotal);\n                for (int oy = startPosY, ny = 0; ny < boundHeight/inSampleSize; oy++, ny++) {\n                    tmpPixels[ny * (boundWidth/inSampleSize) + nx] = pixels[oy * *bitmapwidth + ox];\n                }\n            }\n\n            free(pixels);\n            pixels = tmpPixels;\n            *bitmapwidth = boundWidth/inSampleSize;\n            *bitmapheight = boundHeight/inSampleSize;\n        }\n\n        if (useOrientationTag) {\n            switch (origorientation) {\n                case ORIENTATION_TOPLEFT:\n                case ORIENTATION_LEFTTOP:\n                    break;\n                case ORIENTATION_TOPRIGHT:\n                    flipPixelsHorizontal(*bitmapwidth, *bitmapheight, pixels);\n                    break;\n                case ORIENTATION_RIGHTTOP:\n                    flipPixelsHorizontal(*bitmapheight, *bitmapwidth, pixels);\n                    break;\n                case ORIENTATION_BOTRIGHT:\n                case ORIENTATION_RIGHTBOT:\n                    rotateRaster(pixels, 180, bitmapwidth, bitmapheight);\n                    break;\n                case ORIENTATION_BOTLEFT:\n                    flipPixelsVertical(*bitmapwidth, *bitmapheight, pixels);\n                    break;\n                case ORIENTATION_LEFTBOT:\n                    flipPixelsVertical(*bitmapheight, *bitmapwidth, pixels);\n                    break;\n            }\n        } else {\n            if (origorientation > 4) {\n                uint32 buf = *bitmapwidth;\n                *bitmapwidth = *bitmapheight;\n                *bitmapheight = buf;\n                rotateRaster(pixels, 90, bitmapwidth, bitmapheight);\n                flipPixelsHorizontal(*bitmapwidth, *bitmapheight, pixels);\n            }\n        }\n\n        //Copy necessary pixels to new array if orientation >4\n        if (origorientation > 4) {\n            jint* tmpPixels = (jint *) malloc(sizeof(jint) * tmpPixelBufferSize);\n            uint32 startPosX = boundX%tileWidth /inSampleSize;\n            uint32 startPosY = boundY%tileHeight /inSampleSize;\n            for (int ox = startPosX, nx = 0; nx < boundWidth/inSampleSize; ox++, nx++) {\n                sendProgress(processedProgress + nx * (boundHeight/inSampleSize), progressTotal);\n                for (int oy = startPosY, ny = 0; ny < boundHeight/inSampleSize; oy++, ny++) {\n                    if (useOrientationTag) {\n                        tmpPixels[nx * (boundHeight/inSampleSize) + ny] = pixels[ox * *bitmapheight + oy];\n                    } else {\n                        tmpPixels[ny * (boundWidth/inSampleSize) + nx] = pixels[oy * *bitmapwidth + ox];\n                    }\n                }\n            }\n\n            free(pixels);\n            pixels = tmpPixels;\n            *bitmapwidth = boundWidth/inSampleSize;\n            *bitmapheight = boundHeight/inSampleSize;\n        }\n\n        return pixels;\n}\n\n\n\njint * NativeDecoder::getSampledRasterFromImage(int inSampleSize, int *bitmapwidth, int *bitmapheight)\n{\n    //init signal handler for catch SIGSEGV error that could be raised in libtiff\n    struct sigaction act;\n    memset(&act, 0, sizeof(act));\n    sigemptyset(&act.sa_mask);\n    act.sa_sigaction = imageErrorHandler;\n    act.sa_flags = SA_SIGINFO | SA_ONSTACK;\n    if(sigaction(SIGSEGV, &act, 0) < 0) {\n        LOGE(\"Can\\'t setup signal handler. Working without errors catching mechanism\");\n    }\n\n    //buffer size for decoding tiff image in RGBA format\n    int origBufferSize = origwidth * origheight * sizeof(unsigned int);\n\n    *bitmapwidth = origwidth / inSampleSize;\n    *bitmapheight = origheight / inSampleSize;\n    //buffer size for creating scaled image;\n    uint32 pixelsBufferSize = *bitmapwidth * *bitmapheight * sizeof(jint);\n\n    /**Estimate usage of memory for decoding*/\n    unsigned long estimateMem = origBufferSize;//origBufferSize - size of decoded RGBA image\n    if (inSampleSize > 1) {\n        estimateMem += pixelsBufferSize; //if inSmapleSize greater than 1 we need aditional vevory for scaled image\n    }\n    LOGII(\"estimateMem\", estimateMem);\n\n    if (estimateMem > availableMemory) {\n        if (throwException) {\n            throw_not_enought_memory_exception(env, availableMemory, estimateMem);\n        }\n        return NULL;\n    }\n\n    unsigned int *origBuffer = NULL;\n\n    origBuffer = (unsigned int *) _TIFFmalloc(origBufferSize);\n    if (origBuffer == NULL) {\n        LOGE(\"Can\\'t allocate memory for origBuffer\");\n        return NULL;\n    }\n\n    jint *pixels = NULL;\n\n    //check for error\n    if (setjmp(NativeDecoder::image_buf)) {\n        if (origBuffer) {\n            _TIFFfree(origBuffer);\n            origBuffer = NULL;\n        }\n        if (pixels) {\n            free(pixels);\n            pixels = NULL;\n        }\n\n        const char * err = \"Caught SIGSEGV signal(Segmentation fault or invalid memory reference)\";\n        LOGE(err);\n        if (throwException) {\n            throwDecodeFileException(err);\n        }\n\n        return NULL;\n    }\n\n\n\tif (0 ==\n        TIFFReadRGBAImageOriented(image, origwidth, origheight, origBuffer, ORIENTATION_TOPLEFT, 0)) {\n\t    free(origBuffer);\n\t    const char *message = \"Error reading image\";\n        LOGE(*message);\n        if (throwException) {\n            throwDecodeFileException(message);\n        }\n        return NULL;\n    }\n\n    if (inSampleSize == 1) {\n        // Use buffer as is.\n        pixels = (jint*) origBuffer;\n    }\n    else {\n        // Sample the buffer.\n        pixels = (jint *) malloc(pixelsBufferSize);\n        if (pixels == NULL) {\n            LOGE(\"Can\\'t allocate memory for temp buffer\");\n            return NULL;\n        }\n        else {\n            for (int j = 0, j1 = 0; j < *bitmapheight; j++, j1 += inSampleSize) {\n\n                sendProgress(j1 * origwidth, progressTotal);\n\n                if (checkStop()) {\n                    //TODO clear memory\n                    if (origBuffer) {\n                        _TIFFfree(origBuffer);\n                        origBuffer = NULL;\n                    }\n                    if (pixels) {\n                        free(pixels);\n                        pixels = NULL;\n                    }\n                    LOGI(\"Thread stopped\");\n                    return NULL;\n                }\n\n                for (int i = 0, i1 = 0; i < *bitmapwidth; i++, i1 += inSampleSize) {\n                    //Apply filter to pixel\n                    jint crPix = origBuffer[j1 * origwidth + i1];\n                    int sum = 1;\n\n                    int alpha = colorMask & crPix >> 24;\n                    int red = colorMask & crPix >> 16;\n                    int green = colorMask & crPix >> 8;\n                    int blue = colorMask & crPix;\n\n                    //using kernel 3x3\n\n                    //topleft\n                    if (i1 - 1 >= 0 && j1 - 1 >= 0) {\n                        crPix = origBuffer[(j1 - 1) * origwidth + i1 - 1];\n                        red += colorMask & crPix >> 16;\n                        green += colorMask & crPix >> 8;\n                        blue += colorMask & crPix;\n                        alpha += colorMask & crPix >> 24;\n                        sum++;\n                    }\n                    //top\n                    if (j1 - 1 >= 0) {\n                        crPix = origBuffer[(j1 - 1) * origwidth + i1];\n                        red += colorMask & crPix >> 16;\n                        green += colorMask & crPix >> 8;\n                        blue += colorMask & crPix;\n                        alpha += colorMask & crPix >> 24;\n                        sum++;\n                    }\n                    // topright\n                    if (i1 + 1 < origwidth && j1 - 1 >= 0) {\n                        crPix = origBuffer[(j1 - 1) * origwidth + i1 + 1];\n                        red += colorMask & crPix >> 16;\n                        green += colorMask & crPix >> 8;\n                        blue += colorMask & crPix;\n                        alpha += colorMask & crPix >> 24;\n                        sum++;\n                    }\n                    //right\n                    if (i1 + 1 < origwidth) {\n                        crPix = origBuffer[j1 * origwidth + i1 + 1];\n                        red += colorMask & crPix >> 16;\n                        green += colorMask & crPix >> 8;\n                        blue += colorMask & crPix;\n                        alpha += colorMask & crPix >> 24;\n                        sum++;\n                    }\n                    //bottomright\n                    if (i1 + 1 < origwidth && j1 + 1 < origheight) {\n                        crPix = origBuffer[(j1 + 1) * origwidth + i1 + 1];\n                        red += colorMask & crPix >> 16;\n                        green += colorMask & crPix >> 8;\n                        blue += colorMask & crPix;\n                        alpha += colorMask & crPix >> 24;\n                        sum++;\n                    }\n                    //bottom\n                    if (j1 + 1 < origheight) {\n                        crPix = origBuffer[(j1 + 1) * origwidth + i1 + 1];\n                        red += colorMask & crPix >> 16;\n                        green += colorMask & crPix >> 8;\n                        blue += colorMask & crPix;\n                        alpha += colorMask & crPix >> 24;\n                        sum++;\n                    }\n                    //bottomleft\n                    if (i1 - 1 >= 0 && j1 + 1 < origheight) {\n                        crPix = origBuffer[(j1 + 1) * origwidth + i1 - 1];\n                        red += colorMask & crPix >> 16;\n                        green += colorMask & crPix >> 8;\n                        blue += colorMask & crPix;\n                        alpha += colorMask & crPix >> 24;\n                        sum++;\n                    }\n                    //left\n                    if (i1 - 1 >= 0) {\n                        crPix = origBuffer[j1 * origwidth + i1 - 1];\n                        red += colorMask & crPix >> 16;\n                        green += colorMask & crPix >> 8;\n                        blue += colorMask & crPix;\n                        alpha += colorMask & crPix >> 24;\n                        sum++;\n                    }\n\n                    red /= sum;\n                    if (red > 255) red = 255;\n                    if (red < 0) red = 0;\n\n                    green /= sum;\n                    if (green > 255) green = 255;\n                    if (green < 0) green = 0;\n\n                    blue /= sum;\n                    if (blue > 255) blue = 255;\n                    if (blue < 0) blue = 0;\n\n                    alpha /= sum;///= sum;\n                    if (alpha > 255) alpha = 255;\n                    if (alpha < 0) alpha = 0;\n\n                    crPix = (alpha << 24) | (red << 16) | (green << 8) | (blue);\n\n                    pixels[j * *bitmapwidth + i] = crPix;\n                }\n            }\n        }\n\n        //Close Buffer\n        if (origBuffer) {\n            _TIFFfree(origBuffer);\n            origBuffer = NULL;\n        }\n    }\n\n    if (useOrientationTag) {\n        fixOrientation(pixels, pixelsBufferSize, *bitmapwidth, *bitmapheight);\n    } else {\n        uint32 buf;\n        switch(origorientation) {\n                         case ORIENTATION_TOPLEFT:\n                         case ORIENTATION_LEFTTOP:\n                            break;\n                         case ORIENTATION_TOPRIGHT:\n                         case ORIENTATION_RIGHTTOP:\n                            flipPixelsHorizontal(*bitmapwidth, *bitmapheight, pixels);\n                            break;\n                         case ORIENTATION_BOTRIGHT:\n                         case ORIENTATION_RIGHTBOT:\n                            rotateRaster(pixels, 180, bitmapwidth, bitmapheight);\n                            break;\n                         case ORIENTATION_BOTLEFT:\n                         case ORIENTATION_LEFTBOT:\n                            rotateRaster(pixels, 180, bitmapwidth, bitmapheight);\n                            flipPixelsHorizontal(*bitmapwidth, *bitmapheight, pixels);\n                            break;\n                         }\n    }\n\n    return pixels;\n}\n\njint * NativeDecoder::getSampledRasterFromImageWithBounds(int inSampleSize, int *bitmapwidth, int *bitmapheight)\n{\n    //init signal handler for catch SIGSEGV error that could be raised in libtiff\n    struct sigaction act;\n    memset(&act, 0, sizeof(act));\n    sigemptyset(&act.sa_mask);\n    act.sa_sigaction = imageErrorHandler;\n    act.sa_flags = SA_SIGINFO | SA_ONSTACK;\n    if(sigaction(SIGSEGV, &act, 0) < 0) {\n        LOGE(\"Can\\'t setup signal handler. Working without errors catching mechanism\");\n    }\n\n    //buffer size for decoding tiff image in RGBA format\n    int origBufferSize = origwidth * origheight * sizeof(unsigned int);\n\n    *bitmapwidth = boundWidth / inSampleSize;//origwidth / inSampleSize;\n    *bitmapheight = boundHeight / inSampleSize;//origheight / inSampleSize;\n    //buffer size for creating scaled image;\n    uint32 pixelsBufferSize = *bitmapwidth * *bitmapheight * sizeof(jint);\n\n    /**Estimate usage of memory for decoding*/\n    unsigned long estimateMem = origBufferSize;//origBufferSize - size of decoded RGBA image\n    //if (inSampleSize > 1) {\n        estimateMem += pixelsBufferSize; //if inSmapleSize greater than 1 we need aditional vevory for scaled image\n    //}\n    LOGII(\"estimateMem\", estimateMem);\n\n    if (estimateMem > availableMemory) {\n        if (throwException) {\n            throw_not_enought_memory_exception(env, availableMemory, estimateMem);\n        }\n        return NULL;\n    }\n\n    unsigned int *origBuffer = NULL;\n    jint *pixels = NULL;\n\n    //check for error\n    if (setjmp(NativeDecoder::image_buf)) {\n        if (origBuffer) {\n            _TIFFfree(origBuffer);\n            origBuffer = NULL;\n        }\n        if (pixels) {\n            free(pixels);\n            pixels = NULL;\n        }\n\n        const char * err = \"Caught SIGSEGV signal(Segmentation fault or invalid memory reference)\";\n        LOGE(err);\n        if (throwException) {\n            throwDecodeFileException(err);\n        }\n\n        return NULL;\n    }\n\n    origBuffer = (unsigned int *) _TIFFmalloc(origBufferSize);\n    if (origBuffer == NULL) {\n        LOGE(\"Can\\'t allocate memory for origBuffer\");\n        return NULL;\n    }\n\n\tif (0 ==\n        TIFFReadRGBAImageOriented(image, origwidth, origheight, origBuffer, ORIENTATION_TOPLEFT, 0)) {\n\t    free(origBuffer);\n\t    const char *message = \"Error reading image\";\n        LOGE(*message);\n        if (throwException) {\n            throwDecodeFileException(message);\n        }\n        return NULL;\n    }\n\n    progressTotal = boundWidth/inSampleSize * boundHeight/inSampleSize;\n\n    // Sample the buffer.\n    pixels = (jint *) malloc(pixelsBufferSize);\n    if (pixels == NULL) {\n        LOGE(\"Can\\'t allocate memory for temp buffer\");\n        return NULL;\n    } else {\n        for (int y = 0, y1 = boundY; y < *bitmapheight; y++, y1 += inSampleSize) {\n\n            sendProgress(y1 * boundWidth, progressTotal);\n\n                if (checkStop()) {\n                    //TODO clear memory\n                    if (origBuffer) {\n                        _TIFFfree(origBuffer);\n                        origBuffer = NULL;\n                    }\n                    if (pixels) {\n                        free(pixels);\n                        pixels = NULL;\n                    }\n                    LOGI(\"Thread stopped\");\n                    return NULL;\n                }\n\n                for (int x = 0, x1 = boundX; x < *bitmapwidth; x++, x1 += inSampleSize) {\n                    //Apply filter to pixel\n                    jint crPix = origBuffer[y1 * origwidth + x1];\n                    int sum = 1;\n\n                    int alpha = colorMask & crPix >> 24;\n                    int red = colorMask & crPix >> 16;\n                    int green = colorMask & crPix >> 8;\n                    int blue = colorMask & crPix;\n\n                    //using kernel 3x3\n\n                    //topleft\n                    if (x1 - 1 >= 0 && y1 - 1 >= 0) {\n                        crPix = origBuffer[(y1 - 1) * origwidth + x1 - 1];\n                        red += colorMask & crPix >> 16;\n                        green += colorMask & crPix >> 8;\n                        blue += colorMask & crPix;\n                        alpha += colorMask & crPix >> 24;\n                        sum++;\n                    }\n                    //top\n                    if (y1 - 1 >= 0) {\n                        crPix = origBuffer[(y1 - 1) * origwidth + x1];\n                        red += colorMask & crPix >> 16;\n                        green += colorMask & crPix >> 8;\n                        blue += colorMask & crPix;\n                        alpha += colorMask & crPix >> 24;\n                        sum++;\n                    }\n                    // topright\n                    if (x1 + 1 < origwidth && y1 - 1 >= 0) {\n                        crPix = origBuffer[(y1 - 1) * origwidth + x1 + 1];\n                        red += colorMask & crPix >> 16;\n                        green += colorMask & crPix >> 8;\n                        blue += colorMask & crPix;\n                        alpha += colorMask & crPix >> 24;\n                        sum++;\n                    }\n                    //right\n                    if (x1 + 1 < origwidth) {\n                        crPix = origBuffer[y1 * origwidth + x1 + 1];\n                        red += colorMask & crPix >> 16;\n                        green += colorMask & crPix >> 8;\n                        blue += colorMask & crPix;\n                        alpha += colorMask & crPix >> 24;\n                        sum++;\n                    }\n                    //bottomright\n                    if (x1 + 1 < origwidth && y1 + 1 < origheight) {\n                        crPix = origBuffer[(y1 + 1) * origwidth + x1 + 1];\n                        red += colorMask & crPix >> 16;\n                        green += colorMask & crPix >> 8;\n                        blue += colorMask & crPix;\n                        alpha += colorMask & crPix >> 24;\n                        sum++;\n                    }\n                    //bottom\n                    if (y1 + 1 < origheight) {\n                        crPix = origBuffer[(y1 + 1) * origwidth + x1 + 1];\n                        red += colorMask & crPix >> 16;\n                        green += colorMask & crPix >> 8;\n                        blue += colorMask & crPix;\n                        alpha += colorMask & crPix >> 24;\n                        sum++;\n                    }\n                    //bottomleft\n                    if (x1 - 1 >= 0 && y1 + 1 < origheight) {\n                        crPix = origBuffer[(y1 + 1) * origwidth + x1 - 1];\n                        red += colorMask & crPix >> 16;\n                        green += colorMask & crPix >> 8;\n                        blue += colorMask & crPix;\n                        alpha += colorMask & crPix >> 24;\n                        sum++;\n                    }\n                    //left\n                    if (x1 - 1 >= 0) {\n                        crPix = origBuffer[y1 * origwidth + x1 - 1];\n                        red += colorMask & crPix >> 16;\n                        green += colorMask & crPix >> 8;\n                        blue += colorMask & crPix;\n                        alpha += colorMask & crPix >> 24;\n                        sum++;\n                    }\n\n                    red /= sum;\n                    if (red > 255) red = 255;\n                    if (red < 0) red = 0;\n\n                    green /= sum;\n                    if (green > 255) green = 255;\n                    if (green < 0) green = 0;\n\n                    blue /= sum;\n                    if (blue > 255) blue = 255;\n                    if (blue < 0) blue = 0;\n\n                    alpha /= sum;///= sum;\n                    if (alpha > 255) alpha = 255;\n                    if (alpha < 0) alpha = 0;\n\n                    crPix = (alpha << 24) | (red << 16) | (green << 8) | (blue);\n\n                    pixels[y * *bitmapwidth + x] = crPix;\n                }\n            }\n    }\n\n        //Close Buffer\n        if (origBuffer) {\n            _TIFFfree(origBuffer);\n            origBuffer = NULL;\n        }\n\n\n    if (useOrientationTag) {\n        fixOrientation(pixels, pixelsBufferSize, *bitmapwidth, *bitmapheight);\n    } else {\n        uint32 buf;\n        switch(origorientation) {\n                         case ORIENTATION_TOPLEFT:\n                         case ORIENTATION_LEFTTOP:\n                            break;\n                         case ORIENTATION_TOPRIGHT:\n                         case ORIENTATION_RIGHTTOP:\n                            flipPixelsHorizontal(*bitmapwidth, *bitmapheight, pixels);\n                            break;\n                         case ORIENTATION_BOTRIGHT:\n                         case ORIENTATION_RIGHTBOT:\n                            rotateRaster(pixels, 180, bitmapwidth, bitmapheight);\n                            break;\n                         case ORIENTATION_BOTLEFT:\n                         case ORIENTATION_LEFTBOT:\n                            rotateRaster(pixels, 180, bitmapwidth, bitmapheight);\n                            flipPixelsHorizontal(*bitmapwidth, *bitmapheight, pixels);\n                            break;\n                         }\n    }\n\n    return pixels;\n}\n\nint NativeDecoder::getDecodeMethod()\n{\n\tint method = -1;\n\tuint32 tileWidth, tileHeight;\n\tint readTW = 0, readTH = 0;\n    readTW = TIFFGetField(image, TIFFTAG_TILEWIDTH, &tileWidth);\n    readTH = TIFFGetField(image, TIFFTAG_TILELENGTH, &tileHeight);\n    if (tileWidth > 0 && tileHeight > 0 && readTH > 0 && readTW > 0) {\n        method = DECODE_METHOD_TILE;\n    } else {\n        int rowPerStrip = -1;\n    \tTIFFGetField(image, TIFFTAG_ROWSPERSTRIP, &rowPerStrip);\n    \tuint32 stripSize = TIFFStripSize (image);\n    \tuint32 stripMax = TIFFNumberOfStrips (image);\n    \tint estimate = origwidth * 3;\n    \tLOGII(\"RPS\", rowPerStrip);\n    \tLOGII(\"stripSize\", stripSize);\n    \tLOGII(\"stripMax\", stripMax);\n    \tif (rowPerStrip != -1 && stripSize > 0 && stripMax > 1 && rowPerStrip < origheight) {\n    \t    method = DECODE_METHOD_STRIP;\n    \t} else {\n    \tmethod = DECODE_METHOD_IMAGE;\n    \t}\n    }\n\n\tLOGII(\"Decode method\", method);\n\treturn method;\n}\n\nvoid NativeDecoder::flipPixelsVertical(uint32 width, uint32 height, jint* raster) {\n    jint *bufferLine = (jint *) malloc(sizeof(jint) * width);\n    for (int line = 0; line < height / 2; line++) {\n        jint  *top_line, *bottom_line;\n        top_line = raster + width * line;\n        bottom_line = raster + width * (height - line -1);\n        _TIFFmemcpy(bufferLine, top_line, sizeof(jint) * width);\n        _TIFFmemcpy(top_line, bottom_line, sizeof(jint) * width);\n        _TIFFmemcpy(bottom_line, bufferLine, sizeof(jint) * width);\n    }\n    free(bufferLine);\n}\n\nvoid NativeDecoder::flipPixelsHorizontal(uint32 width, uint32 height, jint* raster) {\n    jint buf;\n    for (int y = 0; y < height; y++) {\n        for (int x = 0; x < width / 2; x++) {\n            buf = raster[y * width + x];\n            raster[y * width + x] = raster[y * width + width - x - 1];\n            raster[y * width + width - x - 1] = buf;\n        }\n    }\n}\n\nvoid NativeDecoder::rotateRaster(jint *raster, int angle, int *width, int *height)\n        {\n            int rotatedWidth = *width;\n            int rotatedHeight = *height;\n            int numberOf90s = angle / 90;\n            if (numberOf90s % 2 != 0)\n            {\n                int tmp = rotatedWidth;\n                rotatedWidth = rotatedHeight;\n                rotatedHeight = tmp;\n            }\n\n            jint *rotated = (jint *) malloc(sizeof(jint) * rotatedWidth * rotatedHeight);//new int[rotatedWidth * rotatedHeight];\n\n            for (int h = 0; h < *height; ++h)\n            {\n                for (int w = 0; w < *width; ++w)\n                {\n                    uint32 item = raster[h * *width + w];\n                    int x = 0;\n                    int y = 0;\n                    switch (numberOf90s % 4)\n                    {\n                        case 0:\n                            x = w;\n                            y = h;\n                            break;\n                        case 1:\n                            x = (*height - h - 1);\n                            y = (rotatedHeight - 1) - (*width - w - 1);\n                            break;\n                        case 2:\n                            x = (*width - w - 1);\n                            y = (*height - h - 1);\n                            break;\n                        case 3:\n                            x = (rotatedWidth - 1) - (*height - h - 1);\n                            y = (*width - w - 1);\n                            break;\n                    }\n\n                    rotated[y * rotatedWidth + x] = item;\n                }\n            }\n\n            *width = rotatedWidth;\n            *height = rotatedHeight;\n\n            memcpy(raster, rotated, sizeof(jint) * *width * *height);\n\n            free(rotated);\n\n        }\n\nvoid NativeDecoder::fixOrientation(jint *pixels, uint32 pixelsBufferSize, int bitmapwidth, int bitmapheight)\n{\n\tif (origorientation > 4) {\n        unsigned int size = bitmapheight * bitmapwidth - 1;\n        jint t;\n        unsigned long long next;\n        unsigned long long cycleBegin;\n        bool *barray = (bool *) malloc(sizeof(bool) * pixelsBufferSize);\n\tfor (int x = 0; x < size; x++) { barray[x] = false; }\n        barray[0] = barray[size] = true;\n        unsigned long long k = 1;\n\n        switch (origorientation) {\n            case ORIENTATION_LEFTTOP:\n            case ORIENTATION_RIGHTBOT:\n                while (k < size) {\n                    cycleBegin = k;\n                    t = pixels[k];\n                    do {\n                        next = (k * bitmapheight) % size;\n                        jint buf = pixels[next];\n                        pixels[next] = t;\n                        t = buf;\n                        barray[k] = true;\n                        k = next;\n                    } while (k != cycleBegin);\n                    for (k = 1; k < size && barray[k]; k++);\n                }\n                break;\n            case ORIENTATION_LEFTBOT:\n            case ORIENTATION_RIGHTTOP:\n                while (k < size) {\n                    cycleBegin = k;\n                    t = pixels[k];\n                    do {\n                        next = (k * bitmapheight) % size;\n                        jint buf = pixels[next];\n                        pixels[next] = t;\n                        t = buf;\n                        barray[k] = true;\n                        k = next;\n                    } while (k != cycleBegin);\n                    for (k = 1; k < size && barray[k]; k++);\n                }\n                //flip horizontally\n                for (int j = 0, j1 = bitmapwidth - 1; j < bitmapwidth / 2; j++, j1--) {\n                    for (int i = 0; i < bitmapheight; i++) {\n                        jint tmp = pixels[j * bitmapheight + i];\n                        pixels[j * bitmapheight + i] = pixels[j1 * bitmapheight + i];\n                        pixels[j1 * bitmapheight + i] = tmp;\n                    }\n                }\n                //flip vertically\n                for (int i = 0, i1 = bitmapheight - 1; i < bitmapheight / 2; i++, i1--) {\n                    for (int j = 0; j < bitmapwidth; j++) {\n                        jint tmp = pixels[j * bitmapheight + i];\n                        pixels[j * bitmapheight + i] = pixels[j * bitmapheight + i1];\n                        pixels[j * bitmapheight + i1] = tmp;\n                    }\n                }\n                break;\n        }\n        free(barray);\n    }\n}\n\njbyte * NativeDecoder::createBitmapAlpha8(jint *raster, int bitmapwidth, int bitmapheight)\n{\n    jbyte *pixels = NULL;\n\tint pixelsBufferSize = bitmapwidth * bitmapheight;\n\tpixels = (jbyte *) malloc(sizeof(jbyte) * pixelsBufferSize);\n    if (pixels == NULL) {\n        LOGE(\"Can\\'t allocate memory for temp buffer\");\n        return NULL;\n    }\n\n\tfor (int i = 0; i < bitmapwidth; i++) {\n\n\t    if (checkStop()) {\n            if (pixels) {\n                free(pixels);\n                pixels = NULL;\n            }\n            LOGI(\"Thread stopped\");\n            return NULL;\n        }\n    \t\tfor (int j = 0; j < bitmapheight; j++) {\n    \t\t\tuint32 crPix = raster[j * bitmapwidth + i];\n    \t\t\tint alpha = colorMask & crPix >> 24;\n    \t\t\tpixels[j * bitmapwidth + i] = alpha;\n    \t\t}\n    \t}\n\n    \t//Close Buffer\n        if (raster) {\n            _TIFFfree(raster);\n            raster = NULL;\n        }\n\n\treturn pixels;\n}\n\nunsigned short * NativeDecoder::createBitmapRGB565(jint *buffer, int bitmapwidth, int bitmapheight)\n{\n    unsigned short *pixels = NULL;\n\tint pixelsBufferSize = bitmapwidth * bitmapheight;\n\tpixels = (unsigned short *) malloc(sizeof(unsigned short) * pixelsBufferSize);\n    if (pixels == NULL) {\n        LOGE(\"Can\\'t allocate memory for temp buffer\");\n        return NULL;\n    }\n\n    for (int i = 0; i < bitmapwidth; i++) {\n\n        if (checkStop()) {\n            if (pixels) {\n                free(pixels);\n                pixels = NULL;\n            }\n            LOGI(\"Thread stopped\");\n            return NULL;\n        }\n\n\t\tfor (int j = 0; j < bitmapheight; j++) {\n\n\n\t\t\tjint crPix = buffer[j * bitmapwidth + i];\n\t\t\tint blue = colorMask & crPix >> 16;\n            int green = colorMask & crPix >> 8;\n            int red = colorMask & crPix;\n\n            unsigned char B = (blue >> 3);\n            unsigned char G = (green >> 2);\n            unsigned char R = (red >> 3);\n\n            jint curPix = (R << 11) | (G << 5) | B;\n\n\t\t\tpixels[j * bitmapwidth + i] = curPix;\n\t\t}\n\t}\n\n\t//Close Buffer\n    if (buffer) {\n        _TIFFfree(buffer);\n        buffer = NULL;\n    }\n    return pixels;\n}\n\nint NativeDecoder::getDyrectoryCount()\n{\n    int dircount = 0;\n    do {\n        dircount++;\n    } while (TIFFReadDirectory(image));\n    return dircount;\n}\n\nvoid NativeDecoder::writeDataToOptions(int directoryNumber)\n{\n    TIFFSetDirectory(image, directoryNumber);\n        jfieldID gOptions_outDirectoryCountFieldId = env->GetFieldID(jBitmapOptionsClass,\n            \"outDirectoryCount\", \"I\");\n        int dircount = getDyrectoryCount();\n        env->SetIntField(optionsObject, gOptions_outDirectoryCountFieldId, dircount);\n\n        TIFFSetDirectory(image, directoryNumber);\n        TIFFGetField(image, TIFFTAG_IMAGEWIDTH, & origwidth);\n        TIFFGetField(image, TIFFTAG_IMAGELENGTH, & origheight);\n\n        //Getting image orientation and createing ImageOrientation enum\n        TIFFGetField(image, TIFFTAG_ORIENTATION, & origorientation);\n        //If orientation field is empty - use ORIENTATION_TOPLEFT\n        if (origorientation == 0) {\n            origorientation = ORIENTATION_TOPLEFT;\n        }\n        jclass gOptions_ImageOrientationClass = env->FindClass(\n            \"org/beyka/tiffbitmapfactory/Orientation\");\n        jfieldID gOptions_ImageOrientationFieldId = NULL;\n        bool flipHW = false;\n        LOGII(\"Orientation\", origorientation);\n        switch (origorientation) {\n            case ORIENTATION_TOPLEFT:\n                gOptions_ImageOrientationFieldId = env->GetStaticFieldID(gOptions_ImageOrientationClass,\n                    \"TOP_LEFT\",\n                    \"Lorg/beyka/tiffbitmapfactory/Orientation;\");\n                break;\n            case ORIENTATION_TOPRIGHT:\n                gOptions_ImageOrientationFieldId = env->GetStaticFieldID(gOptions_ImageOrientationClass,\n                    \"TOP_RIGHT\",\n                    \"Lorg/beyka/tiffbitmapfactory/Orientation;\");\n                break;\n            case ORIENTATION_BOTRIGHT:\n                gOptions_ImageOrientationFieldId = env->GetStaticFieldID(gOptions_ImageOrientationClass,\n                    \"BOT_RIGHT\",\n                    \"Lorg/beyka/tiffbitmapfactory/Orientation;\");\n                break;\n            case ORIENTATION_BOTLEFT:\n                gOptions_ImageOrientationFieldId = env->GetStaticFieldID(gOptions_ImageOrientationClass,\n                    \"BOT_LEFT\",\n                    \"Lorg/beyka/tiffbitmapfactory/Orientation;\");\n                break;\n            case ORIENTATION_LEFTTOP:\n                flipHW = true;\n                gOptions_ImageOrientationFieldId = env->GetStaticFieldID(gOptions_ImageOrientationClass,\n                    \"LEFT_TOP\",\n                    \"Lorg/beyka/tiffbitmapfactory/Orientation;\");\n                break;\n            case ORIENTATION_RIGHTTOP:\n                flipHW = true;\n                gOptions_ImageOrientationFieldId = env->GetStaticFieldID(gOptions_ImageOrientationClass,\n                    \"RIGHT_TOP\",\n                    \"Lorg/beyka/tiffbitmapfactory/Orientation;\");\n                break;\n            case ORIENTATION_RIGHTBOT:\n                flipHW = true;\n                gOptions_ImageOrientationFieldId = env->GetStaticFieldID(gOptions_ImageOrientationClass,\n                    \"RIGHT_BOT\",\n                    \"Lorg/beyka/tiffbitmapfactory/Orientation;\");\n                break;\n            case ORIENTATION_LEFTBOT:\n                flipHW = true;\n                gOptions_ImageOrientationFieldId = env->GetStaticFieldID(gOptions_ImageOrientationClass,\n                    \"LEFT_BOT\",\n                    \"Lorg/beyka/tiffbitmapfactory/Orientation;\");\n                break;\n        }\n        if (gOptions_ImageOrientationFieldId != NULL) {\n            jobject gOptions_ImageOrientationObj = env->GetStaticObjectField(\n                gOptions_ImageOrientationClass,\n                gOptions_ImageOrientationFieldId);\n\n            //Set outImageOrientation field to options object\n            jfieldID gOptions_outImageOrientationField = env->GetFieldID(jBitmapOptionsClass,\n                \"outImageOrientation\",\n                \"Lorg/beyka/tiffbitmapfactory/Orientation;\");\n            env->SetObjectField(optionsObject, gOptions_outImageOrientationField,\n                gOptions_ImageOrientationObj);\n        }\n\n        //Get resolution variables\n        /*\n        jfieldID gOptions_outDirectoryCountFieldId = env->GetFieldID(jOptionsClass,\n                    \"outDirectoryCount\", \"I\");\n                int dircount = getDyrectoryCount();\n                env->SetIntField(optionsObject, gOptions_outDirectoryCountFieldId, dircount);\n        */\n        float xresolution, yresolution;\n        uint16 resunit;\n        TIFFGetField(image, TIFFTAG_XRESOLUTION, &xresolution);\n        LOGIF(\"xres\", xresolution);\n        jfieldID gOptions_outXResolutionFieldID = env->GetFieldID(jBitmapOptionsClass, \"outXResolution\", \"F\");\n        env->SetFloatField(optionsObject, gOptions_outXResolutionFieldID, xresolution);\n        TIFFGetField(image, TIFFTAG_YRESOLUTION, &yresolution);\n        LOGIF(\"yres\", yresolution);\n        jfieldID gOptions_outYResolutionFieldID = env->GetFieldID(jBitmapOptionsClass, \"outYResolution\", \"F\");\n        env->SetFloatField(optionsObject, gOptions_outYResolutionFieldID, yresolution);\n        TIFFGetField(image, TIFFTAG_RESOLUTIONUNIT, &resunit);\n        LOGII(\"resunit\", resunit);\n        jclass gOptions_ResolutionUnitClass = env->FindClass(\"org/beyka/tiffbitmapfactory/ResolutionUnit\");\n        jfieldID gOptions_ResolutionUnitFieldId = NULL;\n        switch(resunit) {\n            case RESUNIT_INCH:\n                gOptions_ResolutionUnitFieldId = env->GetStaticFieldID(gOptions_ResolutionUnitClass,\n                            \"INCH\",\n                            \"Lorg/beyka/tiffbitmapfactory/ResolutionUnit;\");\n                break;\n            case RESUNIT_CENTIMETER:\n                gOptions_ResolutionUnitFieldId = env->GetStaticFieldID(gOptions_ResolutionUnitClass,\n                            \"CENTIMETER\",\n                            \"Lorg/beyka/tiffbitmapfactory/ResolutionUnit;\");\n                break;\n            case RESUNIT_NONE:\n            default:\n                gOptions_ResolutionUnitFieldId = env->GetStaticFieldID(gOptions_ResolutionUnitClass,\n                            \"NONE\",\n                            \"Lorg/beyka/tiffbitmapfactory/ResolutionUnit;\");\n                break;\n        }\n        if (gOptions_ResolutionUnitFieldId != NULL) {\n            jobject gOptions_ResolutionUnitObj = env->GetStaticObjectField(\n                        gOptions_ResolutionUnitClass,\n                        gOptions_ResolutionUnitFieldId);\n\n            //Set resolution unit field to options object\n            jfieldID gOptions_outResUnitField = env->GetFieldID(jBitmapOptionsClass,\n                        \"outResolutionUnit\",\n                        \"Lorg/beyka/tiffbitmapfactory/ResolutionUnit;\");\n            env->SetObjectField(optionsObject, gOptions_outResUnitField,\n                        gOptions_ResolutionUnitObj);\n        }\n\n        //Get image planar config\n        int planarConfig = 0;\n        TIFFGetField(image, TIFFTAG_PLANARCONFIG, &planarConfig);\n        LOGII(\"planar config\", planarConfig);\n        jclass gOptions_PlanarConfigClass = env->FindClass(\"org/beyka/tiffbitmapfactory/PlanarConfig\");\n        jfieldID gOptions_PlanarConfigFieldId = NULL;\n        switch(planarConfig) {\n            case PLANARCONFIG_CONTIG:\n                gOptions_PlanarConfigFieldId = env->GetStaticFieldID(gOptions_PlanarConfigClass,\n                \"CONTIG\",\n                \"Lorg/beyka/tiffbitmapfactory/PlanarConfig;\");\n                break;\n            case PLANARCONFIG_SEPARATE:\n                gOptions_PlanarConfigFieldId = env->GetStaticFieldID(gOptions_PlanarConfigClass,\n                \"SEPARATE\",\n                \"Lorg/beyka/tiffbitmapfactory/PlanarConfig;\");\n                break;\n        }\n        if (gOptions_PlanarConfigFieldId != NULL) {\n            jobject gOptions_PlanarConfigObj = env->GetStaticObjectField(\n                    gOptions_PlanarConfigClass,\n                    gOptions_PlanarConfigFieldId);\n\n            jfieldID gOptions_outPlanarConfigField = env->GetFieldID(jBitmapOptionsClass,\n                    \"outPlanarConfig\",\n                    \"Lorg/beyka/tiffbitmapfactory/PlanarConfig;\");\n            env->SetObjectField(optionsObject, gOptions_outPlanarConfigField,\n                    gOptions_PlanarConfigObj);\n        }\n\n        //Getting image compression scheme and createing CompressionScheme enum\n        TIFFGetField(image, TIFFTAG_COMPRESSION, & origcompressionscheme);\n        LOGII(\"compression\", origcompressionscheme);\n\n        jclass gOptions_ImageCompressionClass = env->FindClass(\n            \"org/beyka/tiffbitmapfactory/CompressionScheme\");\n        jfieldID gOptions_ImageCompressionFieldId = NULL;\n        switch (origcompressionscheme) {\n        case COMPRESSION_NONE:\n            gOptions_ImageCompressionFieldId = env->GetStaticFieldID(gOptions_ImageCompressionClass,\n                \"NONE\",\n                \"Lorg/beyka/tiffbitmapfactory/CompressionScheme;\");\n            break;\n        case COMPRESSION_CCITTRLE:\n            gOptions_ImageCompressionFieldId = env->GetStaticFieldID(gOptions_ImageCompressionClass,\n                \"CCITTRLE\",\n                \"Lorg/beyka/tiffbitmapfactory/CompressionScheme;\");\n            break;\n        case COMPRESSION_CCITTFAX3:\n            gOptions_ImageCompressionFieldId = env->GetStaticFieldID(gOptions_ImageCompressionClass,\n                \"CCITTFAX3\",\n                \"Lorg/beyka/tiffbitmapfactory/CompressionScheme;\");\n                break;\n        case COMPRESSION_CCITTFAX4:\n            gOptions_ImageCompressionFieldId = env->GetStaticFieldID(gOptions_ImageCompressionClass,\n            \"CCITTFAX4\",\n            \"Lorg/beyka/tiffbitmapfactory/CompressionScheme;\");\n            break;\n        case COMPRESSION_LZW:\n            gOptions_ImageCompressionFieldId = env->GetStaticFieldID(gOptions_ImageCompressionClass,\n                \"LZW\",\n                \"Lorg/beyka/tiffbitmapfactory/CompressionScheme;\");\n            break;\n        case COMPRESSION_JPEG:\n            gOptions_ImageCompressionFieldId = env->GetStaticFieldID(gOptions_ImageCompressionClass,\n                \"JPEG\",\n                \"Lorg/beyka/tiffbitmapfactory/CompressionScheme;\");\n            break;\n        case COMPRESSION_PACKBITS:\n            gOptions_ImageCompressionFieldId = env->GetStaticFieldID(gOptions_ImageCompressionClass,\n                \"PACKBITS\",\n                \"Lorg/beyka/tiffbitmapfactory/CompressionScheme;\");\n            break;\n        case COMPRESSION_DEFLATE:\n            gOptions_ImageCompressionFieldId = env->GetStaticFieldID(gOptions_ImageCompressionClass,\n                \"DEFLATE\",\n                \"Lorg/beyka/tiffbitmapfactory/CompressionScheme;\");\n            break;\n        case COMPRESSION_ADOBE_DEFLATE:\n            gOptions_ImageCompressionFieldId = env->GetStaticFieldID(gOptions_ImageCompressionClass,\n                \"ADOBE_DEFLATE\",\n                \"Lorg/beyka/tiffbitmapfactory/CompressionScheme;\");\n            break;\n        default:\n            gOptions_ImageCompressionFieldId = env->GetStaticFieldID(gOptions_ImageCompressionClass,\n                \"OTHER\",\n                \"Lorg/beyka/tiffbitmapfactory/CompressionScheme;\");\n\n        }\n        if (gOptions_ImageCompressionFieldId != NULL) {\n            jobject gOptions_ImageCompressionObj = env->GetStaticObjectField(\n                gOptions_ImageCompressionClass,\n                gOptions_ImageCompressionFieldId);\n\n            //Set outImageOrientation field to options object\n            jfieldID gOptions_outCompressionSchemeField = env->GetFieldID(jBitmapOptionsClass,\n                \"outCompressionScheme\",\n                \"Lorg/beyka/tiffbitmapfactory/CompressionScheme;\");\n            env->SetObjectField(optionsObject, gOptions_outCompressionSchemeField,\n                gOptions_ImageCompressionObj);\n        }\n\n        jfieldID gOptions_OutCurDirNumberFieldID = env->GetFieldID(jBitmapOptionsClass,\n            \"outCurDirectoryNumber\",\n            \"I\");\n        env->SetIntField(optionsObject, gOptions_OutCurDirNumberFieldID, directoryNumber);\n        if (!flipHW) {\n            jfieldID gOptions_outWidthFieldId = env->GetFieldID(jBitmapOptionsClass, \"outWidth\", \"I\");\n            env->SetIntField(optionsObject, gOptions_outWidthFieldId, origwidth);\n\n            jfieldID gOptions_outHeightFieldId = env->GetFieldID(jBitmapOptionsClass, \"outHeight\", \"I\");\n            env->SetIntField(optionsObject, gOptions_outHeightFieldId, origheight);\n        } else {\n            jfieldID gOptions_outWidthFieldId = env->GetFieldID(jBitmapOptionsClass, \"outWidth\", \"I\");\n            env->SetIntField(optionsObject, gOptions_outWidthFieldId, origheight);\n\n            jfieldID gOptions_outHeightFieldId = env->GetFieldID(jBitmapOptionsClass, \"outHeight\", \"I\");\n            env->SetIntField(optionsObject, gOptions_outHeightFieldId, origwidth);\n        }\n\n        int tagRead = 0;\n\n        int bitPerSample = 0;\n        tagRead = TIFFGetField(image, TIFFTAG_BITSPERSAMPLE, &bitPerSample);\n        if (tagRead == 1) {\n            LOGII(\"bit per sample\", bitPerSample);\n            jfieldID gOptions_outBitPerSampleFieldID = env->GetFieldID(jBitmapOptionsClass, \"outBitsPerSample\", \"I\");\n            env->SetIntField(optionsObject, gOptions_outBitPerSampleFieldID, bitPerSample);\n        }\n\n        int samplePerPixel = 0;\n        tagRead = TIFFGetField(image, TIFFTAG_SAMPLESPERPIXEL, &samplePerPixel);\n        if (tagRead == 1) {\n            LOGII(\"sample per pixel\", samplePerPixel);\n            jfieldID gOptions_outSamplePerPixelFieldID = env->GetFieldID(jBitmapOptionsClass, \"outSamplePerPixel\", \"I\");\n            env->SetIntField(optionsObject, gOptions_outSamplePerPixelFieldID, samplePerPixel);\n        }\n\n        //Tile size\n        int tileWidth = 0;\n        tagRead = TIFFGetField(image, TIFFTAG_TILEWIDTH, &tileWidth);\n            if (tagRead == 1) {\n            LOGII(\"tile width\", tileWidth);\n            jfieldID gOptions_outTileWidthFieldID = env->GetFieldID(jBitmapOptionsClass, \"outTileWidth\", \"I\");\n            env->SetIntField(optionsObject, gOptions_outTileWidthFieldID, tileWidth);\n        }\n        int tileHeight = 0;\n        tagRead = TIFFGetField(image, TIFFTAG_TILELENGTH, &tileHeight);\n        if (tagRead == 1) {\n            LOGII(\"tile height\", tileHeight);\n            jfieldID gOptions_outTileHeightFieldID = env->GetFieldID(jBitmapOptionsClass, \"outTileHeight\", \"I\");\n            env->SetIntField(optionsObject, gOptions_outTileHeightFieldID, tileHeight);\n        }\n\n        //row per strip\n        int rowPerStrip = 0;\n        tagRead = TIFFGetField(image, TIFFTAG_ROWSPERSTRIP, &rowPerStrip);\n        if (tagRead == 1) {\n            LOGII(\"row per strip\", rowPerStrip);\n            jfieldID gOptions_outRowPerStripFieldID = env->GetFieldID(jBitmapOptionsClass, \"outRowPerStrip\", \"I\");\n            env->SetIntField(optionsObject, gOptions_outRowPerStripFieldID, rowPerStrip);\n        }\n\n        //strip size\n        uint32 stripSize = TIFFStripSize (image);\n        LOGII(\"strip size\", stripSize);\n        jfieldID gOptions_outStripSizeFieldID = env->GetFieldID(jBitmapOptionsClass, \"outStripSize\", \"I\");\n        env->SetIntField(optionsObject, gOptions_outStripSizeFieldID, stripSize);\n\n        //strip max\n        uint32 stripMax = TIFFNumberOfStrips (image);\n        LOGII(\"number of strips\", stripMax);\n        jfieldID gOptions_outStripMaxFieldID = env->GetFieldID(jBitmapOptionsClass, \"outNumberOfStrips\", \"I\");\n        env->SetIntField(optionsObject, gOptions_outStripMaxFieldID, stripMax);\n\n        //photometric\n        int photometric = 0;\n        TIFFGetField(image, TIFFTAG_PHOTOMETRIC, &photometric);\n        LOGII(\"photometric\", photometric);\n        jclass gOptions_PhotometricClass = env->FindClass(\"org/beyka/tiffbitmapfactory/Photometric\");\n        jfieldID gOptions_PhotometricFieldId = NULL;\n                switch(photometric) {\n                    case PHOTOMETRIC_MINISWHITE:\n                        gOptions_PhotometricFieldId = env->GetStaticFieldID(gOptions_PhotometricClass,\n                        \"MINISWHITE\",\n                        \"Lorg/beyka/tiffbitmapfactory/Photometric;\");\n                        break;\n                    case PHOTOMETRIC_MINISBLACK:\n                        gOptions_PhotometricFieldId = env->GetStaticFieldID(gOptions_PhotometricClass,\n                        \"MINISBLACK\",\n                        \"Lorg/beyka/tiffbitmapfactory/Photometric;\");\n                    case PHOTOMETRIC_RGB:\n                         gOptions_PhotometricFieldId = env->GetStaticFieldID(gOptions_PhotometricClass,\n                         \"RGB\",\n                         \"Lorg/beyka/tiffbitmapfactory/Photometric;\");\n                    case PHOTOMETRIC_PALETTE:\n                         gOptions_PhotometricFieldId = env->GetStaticFieldID(gOptions_PhotometricClass,\n                         \"PALETTE\",\n                         \"Lorg/beyka/tiffbitmapfactory/Photometric;\");\n                    case PHOTOMETRIC_MASK:\n                         gOptions_PhotometricFieldId = env->GetStaticFieldID(gOptions_PhotometricClass,\n                         \"MASK\",\n                         \"Lorg/beyka/tiffbitmapfactory/Photometric;\");\n                    case PHOTOMETRIC_SEPARATED:\n                         gOptions_PhotometricFieldId = env->GetStaticFieldID(gOptions_PhotometricClass,\n                         \"SEPARATED\",\n                         \"Lorg/beyka/tiffbitmapfactory/Photometric;\");\n                    case PHOTOMETRIC_YCBCR:\n                         gOptions_PhotometricFieldId = env->GetStaticFieldID(gOptions_PhotometricClass,\n                         \"YCBCR\",\n                         \"Lorg/beyka/tiffbitmapfactory/Photometric;\");\n                    case PHOTOMETRIC_CIELAB:\n                         gOptions_PhotometricFieldId = env->GetStaticFieldID(gOptions_PhotometricClass,\n                         \"CIELAB\",\n                         \"Lorg/beyka/tiffbitmapfactory/Photometric;\");\n                    case PHOTOMETRIC_ICCLAB:\n                         gOptions_PhotometricFieldId = env->GetStaticFieldID(gOptions_PhotometricClass,\n                         \"ICCLAB\",\n                         \"Lorg/beyka/tiffbitmapfactory/Photometric;\");\n                    case PHOTOMETRIC_ITULAB:\n                         gOptions_PhotometricFieldId = env->GetStaticFieldID(gOptions_PhotometricClass,\n                         \"ITULAB\",\n                         \"Lorg/beyka/tiffbitmapfactory/Photometric;\");\n                    case PHOTOMETRIC_LOGL:\n                         gOptions_PhotometricFieldId = env->GetStaticFieldID(gOptions_PhotometricClass,\n                         \"LOGL\",\n                         \"Lorg/beyka/tiffbitmapfactory/Photometric;\");\n                    case PHOTOMETRIC_LOGLUV:\n                         gOptions_PhotometricFieldId = env->GetStaticFieldID(gOptions_PhotometricClass,\n                         \"LOGLUV\",\n                         \"Lorg/beyka/tiffbitmapfactory/Photometric;\");\n                    default:\n                        gOptions_PhotometricFieldId = env->GetStaticFieldID(gOptions_PhotometricClass,\n                        \"OTHER\",\n                        \"Lorg/beyka/tiffbitmapfactory/Photometric;\");\n                }\n        if (gOptions_PhotometricFieldId != NULL) {\n                    jobject gOptions_PhotometricObj = env->GetStaticObjectField(\n                            gOptions_PhotometricClass,\n                            gOptions_PhotometricFieldId);\n\n                    jfieldID gOptions_outPhotometricField = env->GetFieldID(jBitmapOptionsClass,\n                            \"outPhotometric\",\n                            \"Lorg/beyka/tiffbitmapfactory/Photometric;\");\n                    env->SetObjectField(optionsObject, gOptions_outPhotometricField,\n                            gOptions_PhotometricObj);\n        }\n\n        //FillOrder\n        int fillOrder = 0;\n        TIFFGetField(image, TIFFTAG_FILLORDER, &fillOrder);\n        LOGII(\"fill Order\", fillOrder);\n        jclass gOptions_FillOrderClass = env->FindClass(\"org/beyka/tiffbitmapfactory/FillOrder\");\n        jfieldID gOptions_FillOrderFieldId = NULL;\n        switch(fillOrder) {\n        case FILLORDER_MSB2LSB:\n            gOptions_FillOrderFieldId = env->GetStaticFieldID(gOptions_FillOrderClass,\n            \"MSB2LSB\",\n            \"Lorg/beyka/tiffbitmapfactory/FillOrder;\");\n            break;\n        case PLANARCONFIG_SEPARATE:\n            gOptions_FillOrderFieldId = env->GetStaticFieldID(gOptions_FillOrderClass,\n            \"LSB2MSB\",\n            \"Lorg/beyka/tiffbitmapfactory/FillOrder;\");\n            break;\n        }\n        if (gOptions_FillOrderFieldId != NULL) {\n            jobject gOptions_FillOrderObj = env->GetStaticObjectField(\n            gOptions_FillOrderClass,\n            gOptions_FillOrderFieldId);\n\n            jfieldID gOptions_outFillOrderField = env->GetFieldID(jBitmapOptionsClass,\n            \"outFillOrder\",\n            \"Lorg/beyka/tiffbitmapfactory/FillOrder;\");\n            env->SetObjectField(optionsObject, gOptions_outFillOrderField,\n            gOptions_FillOrderObj);\n        }\n\n        //Author\n        const char * artist;\n        tagRead = TIFFGetField(image, TIFFTAG_ARTIST, & artist);\n        if (tagRead == 1) {\n            LOGI(artist);\n            jstring jauthor = charsToJString(artist);//env->NewStringUTF(artist);\n            jfieldID gOptions_outAuthorFieldId = env->GetFieldID(jBitmapOptionsClass, \"outAuthor\", \"Ljava/lang/String;\");\n            env->SetObjectField(optionsObject, gOptions_outAuthorFieldId, jauthor);\n            env->DeleteLocalRef(jauthor);\n            //free(artist);\n        }\n\n        //Copyright\n        const char * copyright;\n        tagRead = TIFFGetField(image, TIFFTAG_COPYRIGHT, & copyright);\n        if (tagRead == 1) {\n            LOGI(copyright);\n            jstring jcopyright = charsToJString(copyright);//env->NewStringUTF(copyright);\n            jfieldID gOptions_outCopyrightFieldId = env->GetFieldID(jBitmapOptionsClass, \"outCopyright\", \"Ljava/lang/String;\");\n            env->SetObjectField(optionsObject, gOptions_outCopyrightFieldId, jcopyright);\n            env->DeleteLocalRef(jcopyright);\n            //free(copyright);\n        }\n\n        //ImageDescription\n        const char * imgDescr;\n        tagRead = TIFFGetField(image, TIFFTAG_IMAGEDESCRIPTION, & imgDescr);\n        if (tagRead == 1) {\n            LOGI(imgDescr);\n            jstring jimgDescr = charsToJString(imgDescr);//env->NewStringUTF(imgDescr);\n            jfieldID gOptions_outimgDescrFieldId = env->GetFieldID(jBitmapOptionsClass, \"outImageDescription\", \"Ljava/lang/String;\");\n            env->SetObjectField(optionsObject, gOptions_outimgDescrFieldId, jimgDescr);\n            env->DeleteLocalRef(jimgDescr);\n            //free(imgDescr);\n        }\n\n        //Software\n        const char * software;\n        tagRead = TIFFGetField(image, TIFFTAG_SOFTWARE, & software);\n        if (tagRead == 1) {\n            LOGI(software);\n            jstring jsoftware = charsToJString(software);//env->NewStringUTF(software);\n            jfieldID gOptions_outsoftwareFieldId = env->GetFieldID(jBitmapOptionsClass, \"outSoftware\", \"Ljava/lang/String;\");\n            env->SetObjectField(optionsObject, gOptions_outsoftwareFieldId, jsoftware);\n            env->DeleteLocalRef(jsoftware);\n            //free(software);\n        }\n\n        //DateTime\n        const char * datetime;\n        tagRead = TIFFGetField(image, TIFFTAG_DATETIME, & datetime);\n        if (tagRead == 1) {\n            LOGI(datetime);\n            jstring jdatetime = charsToJString(datetime);//env->NewStringUTF(datetime);\n            jfieldID gOptions_outdatetimeFieldId = env->GetFieldID(jBitmapOptionsClass, \"outDatetime\", \"Ljava/lang/String;\");\n            env->SetObjectField(optionsObject, gOptions_outdatetimeFieldId, jdatetime);\n            env->DeleteLocalRef(jdatetime);\n            //free(datetime);\n        }\n\n        //Host Computer\n        const char * host;\n        tagRead = TIFFGetField(image, TIFFTAG_HOSTCOMPUTER, & host);\n        if (tagRead == 1) {\n            LOGI(host);\n            jstring jhost = charsToJString(host);//env->NewStringUTF(host);\n            jfieldID gOptions_outhostFieldId = env->GetFieldID(jBitmapOptionsClass, \"outHostComputer\", \"Ljava/lang/String;\");\n            env->SetObjectField(optionsObject, gOptions_outhostFieldId, jhost);\n            env->DeleteLocalRef(jhost);\n            //free(host);\n        }\n}\n\njstring NativeDecoder::charsToJString(const char *chars) {\n    std::string str(chars);\n    jbyteArray array = env->NewByteArray(str.size());\n    env->SetByteArrayRegion(array, 0, str.size(), (const jbyte*)str.c_str());\n    jstring strEncode = env->NewStringUTF(\"UTF-8\");\n    jclass cls = env->FindClass(\"java/lang/String\");\n    jmethodID ctor = env->GetMethodID(cls, \"<init>\", \"([BLjava/lang/String;)V\");\n    jstring object = (jstring) env->NewObject(cls, ctor, array, strEncode);\n    return object;\n //return NULL;\n}\n\njboolean NativeDecoder::checkStop() {\n    jmethodID methodID = env->GetStaticMethodID(jThreadClass, \"interrupted\", \"()Z\");\n    jboolean interupted = env->CallStaticBooleanMethod(jThreadClass, methodID);\n\n    jboolean stop;\n\n    if (optionsObject) {\n        jfieldID stopFieldId = env->GetFieldID(jBitmapOptionsClass,\n                                               \"isStoped\",\n                                               \"Z\");\n        stop = env->GetBooleanField(optionsObject, stopFieldId);\n\n    } else {\n        stop = JNI_FALSE;\n    }\n\n    return interupted || stop;\n}\n\nvoid NativeDecoder::sendProgress(jlong current, jlong total) {\n    if (listenerObject != NULL) {\n        jmethodID methodid = env->GetMethodID(jIProgressListenerClass, \"reportProgress\", \"(JJ)V\");\n        env->CallVoidMethod(listenerObject, methodid, current, total);\n    }\n}\n\nvoid NativeDecoder::tileErrorHandler(int code, siginfo_t *siginfo, void *sc) {\n    LOGE(\"tileErrorHandler\");\n    longjmp(tile_buf, 1);\n}\n\nvoid NativeDecoder::stripErrorHandler(int code, siginfo_t *siginfo, void *sc) {\n    LOGE(\"stripErrorHandler\");\n    longjmp(strip_buf, 1);\n}\n\nvoid NativeDecoder::imageErrorHandler(int code, siginfo_t *siginfo, void *sc) {\n    LOGE(\"imageErrorHandler\");\n    longjmp(image_buf, 1);\n}\n\nvoid NativeDecoder::generalErrorHandler(int code, siginfo_t *siginfo, void *sc) {\n    LOGE(\"generalErrorHandler\");\n    longjmp(general_buf, 1);\n}\n\nvoid NativeDecoder::throwDecodeFileException(const char *message) {\n    jstring adinf = env->NewStringUTF(message);\n    if (decodingMode == DECODE_MODE_FILE_PATH) {\n        throw_decode_file_exception(env, jPath, adinf);\n    } else if (decodingMode == DECODE_MODE_FILE_DESCRIPTOR) {\n        throw_decode_file_exception_fd(env, jFd, adinf);\n    }\n    env->DeleteLocalRef(adinf);\n}\n\nvoid NativeDecoder::throwCantOpenFileException() {\n    if (decodingMode == DECODE_MODE_FILE_PATH) {\n        throw_cant_open_file_exception(env, jPath);\n    } else if (decodingMode == DECODE_MODE_FILE_DESCRIPTOR) {\n        throw_cant_open_file_exception_fd(env, jFd);\n    }\n}\n\n\n\n\n\n\n\n",
                "name": "NativeDecoder.cpp",
                "path": "src/main/jni/NativeDecoder.cpp",
                "url": "/github.com/Beyka/Android-TiffBitmapFactory/-/blob/src/main/jni/NativeDecoder.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 1609,
                    "offsetAndLengths": [
                        [
                            20,
                            16
                        ]
                    ],
                    "preview": "                    TIFFReadRGBATile(image, column + tileWidth, row, rasterTileRight);"
                },
                {
                    "limitHit": false,
                    "lineNumber": 1613,
                    "offsetAndLengths": [
                        [
                            20,
                            16
                        ]
                    ],
                    "preview": "                    TIFFReadRGBATile(image, column + tileWidth, row, rasterTileRight);"
                },
                {
                    "limitHit": false,
                    "lineNumber": 1614,
                    "offsetAndLengths": [
                        [
                            20,
                            16
                        ]
                    ],
                    "preview": "                    TIFFReadRGBATile(image, column, row, rasterTile);"
                },
                {
                    "limitHit": false,
                    "lineNumber": 1635,
                    "offsetAndLengths": [
                        [
                            20,
                            16
                        ]
                    ],
                    "preview": "                    TIFFReadRGBATile(image, column, row, rasterTile);"
                },
                {
                    "limitHit": false,
                    "lineNumber": 2131,
                    "offsetAndLengths": [
                        [
                            20,
                            16
                        ]
                    ],
                    "preview": "                    TIFFReadRGBATile(image, column + tileWidth, row, rasterTileRight);"
                },
                {
                    "limitHit": false,
                    "lineNumber": 2135,
                    "offsetAndLengths": [
                        [
                            20,
                            16
                        ]
                    ],
                    "preview": "                    TIFFReadRGBATile(image, column + tileWidth, row, rasterTileRight);"
                },
                {
                    "limitHit": false,
                    "lineNumber": 2136,
                    "offsetAndLengths": [
                        [
                            20,
                            16
                        ]
                    ],
                    "preview": "                    TIFFReadRGBATile(image, column, row, rasterTile);"
                },
                {
                    "limitHit": false,
                    "lineNumber": 2157,
                    "offsetAndLengths": [
                        [
                            20,
                            16
                        ]
                    ],
                    "preview": "                    TIFFReadRGBATile(image, column, row, rasterTile);"
                }
            ],
            "repository": {
                "name": "github.com/Beyka/Android-TiffBitmapFactory",
                "url": "/github.com/Beyka/Android-TiffBitmapFactory"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "aca0b69befb13a72dae848e110b2bd1cc9007516"
                },
                "content": "//\n// Created by beyka on 5/10/17.\n//\n\n#include \"TiffToPngConverter.h\"\n\nTiffToPngConverter::TiffToPngConverter(JNIEnv *e, jclass clazz, jstring in, jstring out, jobject opts, jobject listener)\n    : BaseTiffConverter(e, clazz, in, out, opts, listener)\n{\n    png_ptr_init = 0;\n    png_info_init = 0;\n}\n\nTiffToPngConverter::TiffToPngConverter(JNIEnv *e, jclass clazz, jint in, jint out, jobject opts, jobject listener)\n    : BaseTiffConverter(e, clazz, in, out, opts, listener)\n{\n    png_ptr_init = 0;\n    png_info_init = 0;\n}\n\nTiffToPngConverter::~TiffToPngConverter()\n{\n    LOGI(\"destructor start\");\n    if (tiffImage) {\n        TIFFClose(tiffImage);\n        tiffImage = NULL;\n    }\n    LOGI(\"tiff free\");\n\n    if (png_info_init) {\n        png_free_data(png_ptr, info_ptr, PNG_FREE_ALL, -1);\n    }\n    LOGI(\"info_ptr free\");\n\n    if (png_ptr_init) {\n        png_destroy_write_struct(&png_ptr, NULL);\n    }\n    LOGI(\"png_ptr free\");\n\n    if (pngFile) {\n        LOGI(\"pngFile != NULL\");\n        fclose(pngFile);\n    }\n    LOGI(\"png file free\");\n}\n\njboolean TiffToPngConverter::convert()\n{\n    readOptions();\n    LOGI(\"Optioons read done\");\n\n    LOGII(\"inFd=\", inFd);\n    if (inFd == -1) {\n        const char *inCPath = NULL;\n        inCPath = env->GetStringUTFChars(inPath, 0);\n        LOGIS(\"IN path\", inCPath);\n        inFd = open(inCPath, O_RDWR, 0666);\n        if (inFd < 0) {\n            if (throwException) {\n                throw_cant_open_file_exception(env, inPath);\n            }\n            LOGES(\"Can\\'t open in file\", inCPath);\n            env->ReleaseStringUTFChars(inPath, inCPath);\n            return JNI_FALSE;\n        }\n        env->ReleaseStringUTFChars(inPath, inCPath);\n    }\n\n    //open tiff image for reading\n    tiffImage = TIFFFdOpen(inFd, \"\", \"r\");\n    if (tiffImage == NULL) {\n        if (throwException) {\n            if (inFd < 0) {\n                throw_cant_open_file_exception(env, inPath);\n            } else {\n                throw_cant_open_file_exception_fd(env, inFd);\n            }\n        }\n        return JNI_FALSE;\n    }\n    LOGI(\"Tiff file opened for reading\");\n\n    //open png file fow writing\n    LOGII(\"outFd=\", outFd);\n    if(outFd == -1) {\n    LOGI(\"Opening png as File\");\n        //open tiff file for writing or appending\n        const char *outCPath = NULL;\n        outCPath = env->GetStringUTFChars(outPath, 0);\n        LOGIS(\"OUT path\", outCPath);\n        LOGIS(\"nativeTiffOpenForSave\", outCPath);\n\n        pngFile = fopen(outCPath, \"w\");\n        if (!pngFile) {\n            throw_cant_open_file_exception(env, outPath);\n            env->ReleaseStringUTFChars(outPath, outCPath);\n            return JNI_FALSE;\n        }\n    } else {\n    LOGI(\"Opening png as FD\");\n        pngFile = fdopen(outFd, \"w\");\n        if (!pngFile) {\n            LOGI(\"PNG file is null\");\n            if (throwException) {\n                throw_cant_open_file_exception_fd(env, inFd);\n            }\n            LOGES(\"Can\\'t open out file descriptor\", inFd);\n            return JNI_FALSE;\n        }\n    }\n    LOGI(\"PNG file opened\");\n\n    //create png structure pointer\n    png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);\n    if (!png_ptr) {\n        const char *message = \"Can\\'t create PNG structure\";\n        LOGE(*message);\n        if (throwException) {\n            jstring er = env->NewStringUTF(message);\n            if (outFd == -1) {\n                throw_decode_file_exception(env, outPath, er);\n            } else {\n                throw_decode_file_exception_fd(env, outFd, er);\n            }\n            env->DeleteLocalRef(er);\n        }\n        return JNI_FALSE;\n    }\n    png_ptr_init = 1;\n\n    //create png info pointer\n    info_ptr = png_create_info_struct(png_ptr);\n    if (!info_ptr) {\n        const char *message = \"Can\\'t create PNG info structure\";\n        LOGE(*message);\n        if (throwException) {\n            jstring er = env->NewStringUTF(message);\n            if  (outFd == -1) {\n                throw_decode_file_exception(env, outPath, er);\n            } else {\n                throw_decode_file_exception_fd(env, outFd, er);\n            }\n            env->DeleteLocalRef(er);\n        }\n        return JNI_FALSE;\n    }\n    png_info_init = 1;\n\n    //png error handler\n    if (setjmp(png_jmpbuf(png_ptr))) {\n        const char *message = \"Error creating PNG\";\n        LOGE(message);\n        if (throwException) {\n            jstring er = env->NewStringUTF(message);\n            if (outFd == -1) {\n                throw_decode_file_exception(env, outPath, er);\n            } else {\n                throw_decode_file_exception_fd(env, outFd, er);\n            }\n            env->DeleteLocalRef(er);\n        }\n        return JNI_FALSE;\n    }\n\n    //Init PNG IO\n    png_init_io(png_ptr, pngFile);\n\n    //set tiff directory and read image dimensions\n    TIFFSetDirectory(tiffImage, tiffDirectory);\n    TIFFGetField(tiffImage, TIFFTAG_IMAGEWIDTH, &width);\n    TIFFGetField(tiffImage, TIFFTAG_IMAGELENGTH, &height);\n    //Getting image orientation and createing ImageOrientation enum\n    TIFFGetField(tiffImage, TIFFTAG_ORIENTATION, &origorientation);\n    //If orientation field is empty - use ORIENTATION_TOPLEFT\n    if (origorientation == 0) {\n        origorientation = ORIENTATION_TOPLEFT;\n    }\n    LOGII(\"image width\", width);\n    LOGII(\"image height\", height);\n\n    if (!normalizeDecodeArea()) {\n        return JNI_FALSE;\n    }\n\n    //set png data\n    png_set_IHDR(png_ptr, info_ptr, outWidth, outHeight, 8, PNG_COLOR_TYPE_RGB_ALPHA,\n                PNG_INTERLACE_NONE, PNG_COMPRESSION_TYPE_DEFAULT,\n                PNG_FILTER_TYPE_DEFAULT);\n\n                LOGI(\"png_set_IHDR done\");\n\n    //write file header\n    png_write_info(png_ptr, info_ptr);\n    LOGI(\"png_write_info done\");\n\n    png_set_flush(png_ptr, 32);\n\n    jboolean result = JNI_FALSE;\n\n    switch(getDecodeMethod()) {\n        case DECODE_METHOD_IMAGE:\n            result = convertFromImage();\n            break;\n        case DECODE_METHOD_TILE:\n            result = convertFromTile();\n            break;\n        case DECODE_METHOD_STRIP:\n            result = convertFromStrip();\n            break;\n    }\n\n    if (result) {\n        png_write_end(png_ptr, info_ptr);\n    }\n    conversion_result = result;\n    return conversion_result;\n}\n\njboolean TiffToPngConverter::convertFromImage() {\n    int origBufferSize = width * height * sizeof(uint32);\n\n    unsigned long estimateMem = origBufferSize;\n    estimateMem += 4 * outWidth * sizeof(png_bytep);//working buf\n    LOGII(\"estimateMem\", estimateMem);\n    if (estimateMem > availableMemory && availableMemory != -1) {\n        LOGEI(\"Not enough memory\", availableMemory);\n        if (throwException) {\n            throw_not_enought_memory_exception(env, availableMemory, estimateMem);\n        }\n        return JNI_FALSE;\n    }\n\n    uint32 *origBuffer = NULL;\n    origBuffer = (uint32 *) _TIFFmalloc(origBufferSize);\n    if (origBuffer == NULL) {\n        const char *message = \"Can\\'t allocate buffer\";\n        LOGE(*message);\n        if (throwException) {\n            throw_not_enought_memory_exception(env, availableMemory, origBufferSize);\n        }\n        return JNI_FALSE;\n    }\n\n    if (0 == TIFFReadRGBAImageOriented(tiffImage, width, height, origBuffer, ORIENTATION_TOPLEFT, 0)) {\n        free(origBuffer);\n        const char *message = \"Can\\'t read tiff\";\n        if (throwException) {\n            jstring er = env->NewStringUTF(message);\n            if (outFd == -1) {\n                throw_decode_file_exception(env, outPath, er);\n            } else {\n                throw_decode_file_exception_fd(env, outFd, er);\n            }\n            env->DeleteLocalRef(er);\n        }\n        LOGE(message);\n        return JNI_FALSE;\n    }\n\n    jlong total = width * height;\n    sendProgress(0, total);\n\n    int outY, outX;\n\n    for (int y = 0; y < height; y++) {\n        if (y < outStartY || y >= outStartY + outHeight) continue;\n        if (checkStop()) {\n            free(origBuffer);\n            return JNI_FALSE;\n        }\n        outY = y - outStartY;\n        sendProgress(y * width, total);\n\n        png_bytep row = (png_bytep)malloc(4 * outWidth * sizeof(png_bytep));\n        memcpy(row, origBuffer + (y * width + outStartX), outWidth * 4);\n        png_write_row(png_ptr, row);\n        delete(row);\n    }\n    free(origBuffer);\n    sendProgress(total, total);\n    return JNI_TRUE;\n}\n\njboolean TiffToPngConverter::convertFromTile() {\n    uint32 tileWidth = 0, tileHeight = 0;\n    TIFFGetField(tiffImage, TIFFTAG_TILEWIDTH, &tileWidth);\n    TIFFGetField(tiffImage, TIFFTAG_TILEWIDTH, &tileHeight);\n    LOGII(\"Tile width\", tileWidth);\n    LOGII(\"Tile height\", tileHeight);\n\n    //uint32 *raster = (uint32 *)_TIFFmalloc(width * tileHeight * sizeof(uint32));\n    uint32 workingWidth = (width/tileWidth + (width%tileWidth == 0 ? 0 : 1)) * tileWidth;\n    LOGII(\"workingWidth \", workingWidth );\n    uint32 rasterSize =  workingWidth  * tileHeight ;\n    LOGII(\"rasterSize \", rasterSize );\n    //uint32 *raster = (uint32 *)_TIFFmalloc(rasterSize * sizeof(uint32));\n\n\n    unsigned long estimateMem = rasterSize * sizeof(uint32); //raster\n    estimateMem += tileWidth * tileHeight * sizeof(uint32); //tile raster\n    estimateMem += tileWidth * sizeof (uint32); //working buf\n    estimateMem += 4 * outWidth * sizeof(png_bytep); //bufer for writing to png\n    LOGII(\"estimateMem\", estimateMem);\n    if (estimateMem > availableMemory && availableMemory != -1) {\n        LOGEI(\"Not enought memory\", availableMemory);\n        if (throwException) {\n            throw_not_enought_memory_exception(env, availableMemory, estimateMem);\n        }\n        return JNI_FALSE;\n    }\n\n    uint32 *rasterTile = (uint32 *)_TIFFmalloc(tileWidth * tileHeight * sizeof(uint32));\n    uint32 *work_line_buf = (uint32*)_TIFFmalloc(tileWidth * sizeof (uint32));\n\n    jlong total = ((width/tileWidth + (width%tileWidth == 0 ? 0 : 1)) * tileWidth)\n                * ((height/tileHeight + (height%tileHeight == 0 ? 0 : 1)) * tileHeight);\n        sendProgress(0, total);\n\n    uint32 row, column;\n\n    int startx = -1, starty = -1, endx = -1, endy = -1;\n    uint32 imageWritedLines = 0;\n\n    for (row = 0; row < height; row += tileHeight) {\n        sendProgress(row * width, total);\n        endy = -1;\n        starty = -1;\n        uint32 *raster = (uint32 *)_TIFFmalloc(rasterSize * sizeof(uint32));\n\n        for (column = 0; column < width; column += tileWidth) {\n            if (checkStop()) {\n                free(raster);\n                raster = NULL;\n                if (rasterTile) {\n                    _TIFFfree(rasterTile);\n                    rasterTile = NULL;\n                }\n                if (work_line_buf) {\n                    _TIFFfree(rasterTile);\n                    work_line_buf = NULL;\n                }\n                return JNI_FALSE;\n            }\n            endx = -1;\n            startx = -1;\n            TIFFReadRGBATile(tiffImage, column , row, rasterTile);\n            switch(origorientation) {\n                case 1:\n                case 5:\n                    rotateTileLinesVertical(tileHeight, tileWidth, rasterTile, work_line_buf);\n                    break;\n                case 2:\n                case 6:\n                    rotateTileLinesVertical(tileHeight, tileWidth, rasterTile, work_line_buf);\n                    rotateTileLinesHorizontal(tileHeight, tileWidth, rasterTile, work_line_buf);\n                    break;\n                case 3:\n                case 7:\n                {\n                    rotateTileLinesHorizontal(tileHeight, tileWidth, rasterTile, work_line_buf);\n\n                    break;\n                    }\n            }\n\n            normalizeTile(tileHeight, tileWidth, rasterTile);\n\n\n            //find start and end position\n            for (int ty = 0; ty < tileHeight; ty++) {\n\n                for (int tx = 0; tx < tileWidth; tx++) {\n                    if (rasterTile[ty * tileWidth + tx] != 0) {\n                        if (startx == -1) {\n                            startx = tx;\n                        }\n                        if (starty == -1) {\n                            starty = ty;\n                        }\n\n                        if (tx > endx)\n                            endx = tx;\n                        if (ty > endy)\n                            endy = ty;\n\n                        uint32 rasterPos = (ty ) * workingWidth + (tx + column);\n                        //LOGII(\"rp\", rasterPos);\n                        raster[rasterPos] = rasterTile[ty * tileWidth + tx];\n                    }\n\n                }\n            }\n        }\n\n        int outY, outX;\n        for (int y = starty; y < tileHeight; y++) {\n            if (imageWritedLines == height) break;\n            if (y + row < outStartY || y + row >= outStartY + outHeight) continue;\n            outY = y + row - outStartY;\n            //create temp raster and write there pixels than not null\n            png_bytep pngrow = (png_bytep)malloc(4 * outWidth * sizeof(png_bytep));\n            memcpy(pngrow, raster + y * workingWidth + outStartX, outWidth * 4);\n            //memcpy(pngrow, rasterLine, width * 4);\n            png_write_row(png_ptr, pngrow);\n            free(pngrow);\n            //delete(rasterLine);\n            imageWritedLines++;\n        }\n        //LOGII(\"imageWritedLines\", imageWritedLines);\n\n        free(raster);\n\n    }\n\n    /*if (raster) {\n        _TIFFfree(raster);\n        raster = NULL;\n    }*/\n\n    if (rasterTile) {\n        _TIFFfree(rasterTile);\n        rasterTile = NULL;\n    }\n\n    if (work_line_buf) {\n        _TIFFfree(rasterTile);\n        work_line_buf = NULL;\n    }\n\n    sendProgress(total, total);\n\n    return JNI_TRUE;\n\n}\n\njboolean TiffToPngConverter::convertFromStrip() {\n    uint32 stripSize = TIFFStripSize (tiffImage);\n    uint32 stripMax = TIFFNumberOfStrips (tiffImage);\n    int rowPerStrip = -1;\n    TIFFGetField(tiffImage, TIFFTAG_ROWSPERSTRIP, &rowPerStrip);\n    LOGII(\"RPS\", rowPerStrip);\n\n    unsigned long estimateMem = width * sizeof(uint32);//working buf\n    estimateMem += width * rowPerStrip * sizeof (uint32);//raster\n    estimateMem += 4 * outWidth * sizeof(png_bytep); //buf for writing to png\n    LOGII(\"estimateMem\", estimateMem);\n    if (estimateMem > availableMemory && availableMemory != -1) {\n        LOGEI(\"Not enought memory\", availableMemory);\n        if (throwException) {\n            throw_not_enought_memory_exception(env, availableMemory, estimateMem);\n        }\n        return JNI_FALSE;\n    }\n\n    jlong total = stripMax * rowPerStrip * width;\n    sendProgress(0, total);\n\n    uint32* work_line_buf = (uint32 *)_TIFFmalloc(width * sizeof(uint32));\n    uint32* raster = (uint32 *)_TIFFmalloc(width * rowPerStrip * sizeof (uint32));\n\n    uint32 rows_to_write = 0;\n\n    for (int i = 0; i < stripMax*rowPerStrip; i += rowPerStrip) {\n        if (checkStop()) {\n            if (raster) {\n                _TIFFfree(raster);\n                raster = NULL;\n            }\n            if (work_line_buf) {\n                _TIFFfree(work_line_buf);\n                work_line_buf = NULL;\n            }\n            return JNI_FALSE;\n        }\n        sendProgress(i * width, total);\n        TIFFReadRGBAStrip(tiffImage, i, raster);\n\n        rows_to_write = 0;\n        if( i + rowPerStrip > height )\n            rows_to_write = height - i;\n        else\n            rows_to_write = rowPerStrip;\n\n        if (origorientation <= 4) {\n            for (int line = 0; line < rows_to_write / 2; line++) {\n                unsigned int  *top_line, *bottom_line;\n                top_line = raster + width * line;\n                bottom_line = raster + width * (rows_to_write - line - 1);\n\n                _TIFFmemcpy(work_line_buf, top_line, sizeof(unsigned int) * width);\n                _TIFFmemcpy(top_line, bottom_line, sizeof(unsigned int) * width);\n                _TIFFmemcpy(bottom_line, work_line_buf, sizeof(unsigned int) * width);\n            }\n        }\n\n        if (origorientation == ORIENTATION_TOPRIGHT || origorientation == ORIENTATION_BOTRIGHT\n                || origorientation == ORIENTATION_RIGHTTOP || origorientation == ORIENTATION_RIGHTBOT) {\n\n                for (int y = 0; y < rows_to_write; y++) {\n                    for (int x = 0; x < width/2; x++) {\n                        uint32 buf = raster[y * width + x];\n                        raster[y * width + x] = raster[y * width + width - 1 - x];\n                        raster[y * width + width - 1 - x] = buf;\n                    }\n                }\n\n        }\n\n        int outY, outX;\n        for (int y = 0; y < rows_to_write; y++) {\n            if (i + y < outStartY || i + y >= outStartY + outHeight) continue;\n            outY = i + y - outStartY;\n            LOGII(\"out Y\", outY);\n            png_bytep pngrow = (png_bytep)malloc(4 * outWidth * sizeof(png_bytep));\n            memcpy(pngrow, raster + y * width + outStartX, outWidth * 4);\n            png_write_row(png_ptr, pngrow);\n            free(pngrow);\n        }\n\n    }\n\n    if (raster) {\n        _TIFFfree(raster);\n        raster = NULL;\n    }\n\n    if (work_line_buf) {\n        _TIFFfree(work_line_buf);\n        work_line_buf = NULL;\n    }\n\n    sendProgress(total, total);\n\n    return JNI_TRUE;\n}\n\nint TiffToPngConverter::getDecodeMethod() {\n    int method = -1;\n\tuint32 tileWidth, tileHeight;\n\tint readTW = 0, readTH = 0;\n    readTW = TIFFGetField(tiffImage, TIFFTAG_TILEWIDTH, &tileWidth);\n    readTH = TIFFGetField(tiffImage, TIFFTAG_TILELENGTH, &tileHeight);\n    if (tileWidth > 0 && tileHeight > 0 && readTH > 0 && readTW > 0) {\n        method = DECODE_METHOD_TILE;\n    } else {\n        int rowPerStrip = -1;\n    \tTIFFGetField(tiffImage, TIFFTAG_ROWSPERSTRIP, &rowPerStrip);\n    \tuint32 stripSize = TIFFStripSize (tiffImage);\n    \tuint32 stripMax = TIFFNumberOfStrips (tiffImage);\n    \tint estimate = width * 3;\n    \tLOGII(\"RPS\", rowPerStrip);\n    \tLOGII(\"stripSize\", stripSize);\n    \tLOGII(\"stripMax\", stripMax);\n    \tif (rowPerStrip != -1 && stripSize > 0 && stripMax > 1 && rowPerStrip < height) {\n    \t    method = DECODE_METHOD_STRIP;\n    \t} else {\n    \tmethod = DECODE_METHOD_IMAGE;\n    \t}\n    }\n\n\tLOGII(\"Decode method\", method);\n\treturn method;\n}\n",
                "name": "TiffToPngConverter.cpp",
                "path": "src/main/jni/TiffToPngConverter.cpp",
                "url": "/github.com/Beyka/Android-TiffBitmapFactory/-/blob/src/main/jni/TiffToPngConverter.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 345,
                    "offsetAndLengths": [
                        [
                            12,
                            16
                        ]
                    ],
                    "preview": "            TIFFReadRGBATile(tiffImage, column , row, rasterTile);"
                }
            ],
            "repository": {
                "name": "github.com/Beyka/Android-TiffBitmapFactory",
                "url": "/github.com/Beyka/Android-TiffBitmapFactory"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "aca0b69befb13a72dae848e110b2bd1cc9007516"
                },
                "content": "//\n// Created by beyka on 9/22/17.\n//\n#include \"TiffToBmpConverter.h\"\n#include \"BMP.h\"\n\nTiffToBmpConverter::TiffToBmpConverter(JNIEnv *e, jclass clazz, jstring in, jstring out, jobject opts, jobject listener)\n    : BaseTiffConverter(e, clazz, in, out, opts, listener)\n{\n    bmpHeader = new BITMAPFILEHEADER;\n    bmpInfo = new BITMAPINFOHEADER;\n}\n\nTiffToBmpConverter::TiffToBmpConverter(JNIEnv *e, jclass clazz, jint in, jint out, jobject opts, jobject listener)\n    : BaseTiffConverter(e, clazz, in, out, opts, listener)\n{\n    bmpHeader = new BITMAPFILEHEADER;\n    bmpInfo = new BITMAPINFOHEADER;\n}\n\nTiffToBmpConverter::~TiffToBmpConverter()\n{\n    if (bmpHeader)\n        free(bmpHeader);\n    if (bmpInfo)\n        free(bmpInfo);\n}\n\njboolean TiffToBmpConverter::convert()\n{\n    readOptions();\n    LOGI(\"Optioons read done\");\n\n    LOGII(\"inFd=\", inFd);\n    if (inFd == -1) {\n        const char *inCPath = NULL;\n        inCPath = env->GetStringUTFChars(inPath, 0);\n        LOGIS(\"IN path\", inCPath);\n        inFd = open(inCPath, O_RDWR, 0666);\n        if (inFd == -1) {\n            if (throwException) {\n                throw_cant_open_file_exception(env, inPath);\n            }\n            LOGES(\"Can\\'t open in file\", inCPath);\n            env->ReleaseStringUTFChars(inPath, inCPath);\n            return JNI_FALSE;\n        }\n        env->ReleaseStringUTFChars(inPath, inCPath);\n    }\n\n    //open tiff image for reading\n    tiffImage = TIFFFdOpen(inFd, \"\", \"r\");\n    if (tiffImage == NULL) {\n        if (throwException) {\n            if (inFd < 0) {\n                throw_cant_open_file_exception(env, inPath);\n            } else {\n                throw_cant_open_file_exception_fd(env, inFd);\n            }\n        }\n        return JNI_FALSE;\n    }\n    LOGI(\"Tiff file opened for reading\");\n\n    //open bmp file for writing\n    LOGII(\"outFd=\", outFd);\n    if(outFd == -1) {\n    LOGI(\"Opening bmp as File\");\n        //open tiff file for writing or appending\n        const char *outCPath = NULL;\n        outCPath = env->GetStringUTFChars(outPath, 0);\n        LOGIS(\"OUT path\", outCPath);\n        outFIle = fopen(outCPath, \"w\");\n        if (!outFIle) {\n            throw_cant_open_file_exception(env, outPath);\n            env->ReleaseStringUTFChars(outPath, outCPath);\n            return JNI_FALSE;\n        }\n    } else {\n    LOGI(\"Opening bmp as FD\");\n        outFIle = fdopen(outFd, \"w\");\n        if (!outFIle) {\n            LOGI(\"BMP file is null\");\n            if (throwException) {\n                throw_cant_open_file_exception_fd(env, inFd);\n            }\n            LOGES(\"Can\\'t open out file descriptor\", inFd);\n            return JNI_FALSE;\n        }\n    }\n    LOGI(\"BMP file opened\");\n\n    //set tiff directory and read image dimensions\n    TIFFSetDirectory(tiffImage, tiffDirectory);\n    TIFFGetField(tiffImage, TIFFTAG_IMAGEWIDTH, &width);\n    TIFFGetField(tiffImage, TIFFTAG_IMAGELENGTH, &height);\n    //Getting image orientation and createing ImageOrientation enum\n    TIFFGetField(tiffImage, TIFFTAG_ORIENTATION, &origorientation);\n    //If orientation field is empty - use ORIENTATION_TOPLEFT\n    if (origorientation == 0) {\n        origorientation = ORIENTATION_TOPLEFT;\n    }\n\n    if (!normalizeDecodeArea()) {\n        fclose(outFIle);\n        return JNI_FALSE;\n    }\n\n    LOGII(\"image width\", width);\n    LOGII(\"image height\", height);\n    LOGII(\"image bound width\", boundWidth);\n    LOGII(\"image bound height\", boundHeight);\n\n    unsigned long long imageDataSize = (outWidth * 3 + outWidth % 4) * outHeight;\n\n    LOGII(\"image out width\", outWidth);\n    LOGII(\"image out height\", outHeight);\n\n\n    LOGII(\"image data size\", imageDataSize);\n\n    LOGII(\"size\", sizeof(BITMAPINFOHEADER));\n\n    //char *bm = \"BM\";\n     //memcpy(&bmpHeader->bfType, bm, sizeof(short));\n    bmpHeader->bfType[0] = 0x42;\n    bmpHeader->bfType[1] = 0x4d;\n    bmpHeader->bfSize = sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER) + imageDataSize;//sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER) + 3 * width * height;\n    bmpHeader->bfOffBits = sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER);//sizeof(BITMAPFILEHEADER) + 108;\n\n    bmpInfo->biSize = 108;\n    bmpInfo->biWidth = outWidth;\n    bmpInfo->biHeight = outHeight;\n    bmpInfo->biBitCount = 24;\n    bmpInfo->biPlanes = 1;\n    bmpInfo->biCompression = 0;\n\n    bmpInfo->biSizeImage = 0;//imageDataSize;\n\n    bmpInfo->biClrUsed = 0;\n    bmpInfo->biClrImportant = 0;\n\n    bmpInfo->biPalete[0] = 0;\n    bmpInfo->biPalete[1] = 0;\n    bmpInfo->biPalete[2] = 0;\n\n    for (int i = 0; i < 55; i++) {\n        bmpInfo->reserved[i] = 0;\n    }\n\n    fwrite(bmpHeader,sizeof(BITMAPFILEHEADER),1,outFIle);\n    fseek(outFIle, sizeof(BITMAPFILEHEADER) , SEEK_SET);\n    fwrite(bmpInfo,sizeof(BITMAPINFOHEADER),1,outFIle);\n    fseek(outFIle, sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER) , SEEK_SET);\n\n    jboolean result = JNI_FALSE;\n\n    switch(getDecodeMethod()) {\n        case DECODE_METHOD_IMAGE:\n            result = convertFromImage();\n            break;\n        case DECODE_METHOD_TILE:\n           result = convertFromTile();\n           break;\n       case DECODE_METHOD_STRIP:\n           result = convertFromStrip();\n           break;\n    }\n\n    fclose(outFIle);\n    if (!result) {\n        //maybe shold delete file?\n    }\n\n    LOGI(\"fille closed\");\n    conversion_result = result;\n    return conversion_result;\n    //return JNI_FALSE;\n}\n\njboolean TiffToBmpConverter::convertFromImage() {\n    int origBufferSize = width * height * sizeof(uint32);\n\n    unsigned long estimateMem = origBufferSize;\n    estimateMem += outWidth * 3 + outWidth % 4; //working buf to write to file\n    LOGII(\"estimateMem\", estimateMem);\n    if (estimateMem > availableMemory && availableMemory != -1) {\n        LOGEI(\"Not enough memory\", availableMemory);\n        if (throwException) {\n            throw_not_enought_memory_exception(env, availableMemory, estimateMem);\n        }\n        return JNI_FALSE;\n    }\n\n    uint32 *origBuffer = NULL;\n    origBuffer = (uint32 *) _TIFFmalloc(origBufferSize);\n    if (origBuffer == NULL) {\n        const char *message = \"Can\\'t allocate buffer\";\n        LOGE(*message);\n        if (throwException) {\n            throw_not_enought_memory_exception(env, availableMemory, origBufferSize);\n        }\n        return JNI_FALSE;\n    }\n\n    if (0 == TIFFReadRGBAImageOriented(tiffImage, width, height, origBuffer, ORIENTATION_TOPLEFT, 0)) {\n        free(origBuffer);\n        const char *message = \"Can\\'t read tiff\";\n        if (throwException) {\n            jstring er = env->NewStringUTF(message);\n            if (outFd == -1) {\n                throw_decode_file_exception(env, outPath, er);\n            } else {\n                throw_decode_file_exception_fd(env, outFd, er);\n            }\n            env->DeleteLocalRef(er);\n        }\n        LOGE(message);\n        return JNI_FALSE;\n    }\n    LOGI(\"tiff read\");\n\n    jlong total = outWidth * outHeight;\n    int outY, outX;\n    sendProgress(0, total);\n\n    //24 bpp bmp should has with multiple 4\n    int rowSize = outWidth * 3 + outWidth % 4;\n    unsigned char *row = new unsigned char[rowSize];\n\n    for (int y = 0; y < height ; y++) {\n        if (y < outStartY || y >= outStartY + outHeight) continue;\n        if (checkStop()) {\n            free(origBuffer);\n            return JNI_FALSE;\n        }\n        outY = y - outStartY;\n        sendProgress(outY * outWidth, total);\n\n        for (int x = 0; x < width * 3; x += 3) {\n            if (x < outStartX * 3 || x >= (outStartX + outWidth) * 3) continue;\n            outX = x - (outStartX*3);\n            uint32 pix = origBuffer[y * width + x/3];\n            unsigned char *vp = (unsigned char *)&pix;\n            //in bmp colors stores as bgr\n            row[outX] = vp[2]; //red\n            row[outX+1] = vp[1]; //green\n            row[outX+2] = vp[0];   //blue\n        }\n\n        //in bmp lines stored fliped verticaly. Write lines from bottom to top\n        fseek(outFIle, 122 + (outHeight - outY - 1) * rowSize , SEEK_SET);\n        fwrite(row,rowSize,1,outFIle);\n    }\n    free(row);\n    LOGI(\"exit for\");\n    if (origBuffer) {\n        _TIFFfree(origBuffer);\n    }\n    LOGI(\"free orig\");\n    sendProgress(total, total);\n    LOGI(\"dend progress\");\n    return JNI_TRUE;\n}\n\njboolean TiffToBmpConverter::convertFromTile() {\n    uint32 tileWidth = 0, tileHeight = 0;\n    TIFFGetField(tiffImage, TIFFTAG_TILEWIDTH, &tileWidth);\n    TIFFGetField(tiffImage, TIFFTAG_TILEWIDTH, &tileHeight);\n    LOGII(\"Tile width\", tileWidth);\n    LOGII(\"Tile height\", tileHeight);\n\n    uint32 workingWidth = (width/tileWidth + (width%tileWidth == 0 ? 0 : 1)) * tileWidth;\n    LOGII(\"workingWidth \", workingWidth );\n    uint32 rasterSize =  workingWidth  * tileHeight ;\n    LOGII(\"rasterSize \", rasterSize );\n\n\n    unsigned long estimateMem = rasterSize * sizeof(uint32); //raster\n    estimateMem += tileWidth * tileHeight * sizeof(uint32); //tile raster\n    estimateMem += tileWidth * sizeof (uint32); //working buf\n    estimateMem += width * 3 + width % 4; //bufer for writing scanline to bmp\n    LOGII(\"estimateMem\", estimateMem);\n    if (estimateMem > availableMemory && availableMemory != -1) {\n        LOGEI(\"Not enought memory\", availableMemory);\n        if (throwException) {\n            throw_not_enought_memory_exception(env, availableMemory, estimateMem);\n        }\n        return JNI_FALSE;\n    }\n\n    uint32 *rasterTile = (uint32 *)_TIFFmalloc(tileWidth * tileHeight * sizeof(uint32));\n    uint32 *work_line_buf = (uint32*)_TIFFmalloc(tileWidth * sizeof (uint32));\n\n     jlong total = ((width/tileWidth + (width%tileWidth == 0 ? 0 : 1)) * tileWidth)\n                * ((height/tileHeight + (height%tileHeight == 0 ? 0 : 1)) * tileHeight);\n        sendProgress(0, total);\n\n    uint32 row, column;\n\n    int startx = -1, starty = -1, endx = -1, endy = -1;\n    uint32 imageWritedLines = 0;\n\n    //24 bpp bmp should has with multiple 4\n    int scanlineSize = outWidth * 3 + outWidth % 4;\n    unsigned char *scanline = new unsigned char[scanlineSize];\n\n    for (row = 0; row < height; row += tileHeight) {\n        sendProgress(row * width, total);\n        endy = -1;\n        starty = -1;\n        uint32 *raster = (uint32 *)_TIFFmalloc(rasterSize * sizeof(uint32));\n\n        for (column = 0; column < width; column += tileWidth) {\n            if (checkStop()) {\n                free(raster);\n                raster = NULL;\n                if (rasterTile) {\n                    _TIFFfree(rasterTile);\n                    rasterTile = NULL;\n                }\n                if (work_line_buf) {\n                    _TIFFfree(rasterTile);\n                    work_line_buf = NULL;\n                }\n                return JNI_FALSE;\n            }\n            endx = -1;\n            startx = -1;\n            TIFFReadRGBATile(tiffImage, column , row, rasterTile);\n            switch(origorientation) {\n                case 1:\n                case 5:\n                    rotateTileLinesVertical(tileHeight, tileWidth, rasterTile, work_line_buf);\n                    break;\n                case 2:\n                case 6:\n                    rotateTileLinesVertical(tileHeight, tileWidth, rasterTile, work_line_buf);\n                    rotateTileLinesHorizontal(tileHeight, tileWidth, rasterTile, work_line_buf);\n                    break;\n                case 3:\n                case 7:\n                    rotateTileLinesHorizontal(tileHeight, tileWidth, rasterTile, work_line_buf);\n                    break;\n            }\n\n            normalizeTile(tileHeight, tileWidth, rasterTile);\n\n            //find start and end position\n            for (int ty = 0; ty < tileHeight; ty++) {\n\n                for (int tx = 0; tx < tileWidth; tx++) {\n                    if (rasterTile[ty * tileWidth + tx] != 0) {\n                        if (startx == -1) {\n                            startx = tx;\n                        }\n                        if (starty == -1) {\n                            starty = ty;\n                        }\n\n                        if (tx > endx)\n                            endx = tx;\n                        if (ty > endy)\n                            endy = ty;\n\n                        uint32 rasterPos = (ty ) * workingWidth + (tx + column);\n                        //LOGII(\"rp\", rasterPos);\n                        raster[rasterPos] = rasterTile[ty * tileWidth + tx];\n                    }\n\n                }\n            }\n        }\n\n        int outY, outX;\n        int tileShift = 0;\n        for (int y = starty; y < tileHeight; y++) {\n            if (imageWritedLines == height) break;\n            if (y + row < outStartY || y + row >= outStartY + outHeight) continue;\n            outY = y + row - outStartY;\n            for (int x = 0; x < width * 3; x += 3) {\n                if (x < outStartX * 3 || x >= (outStartX + outWidth) * 3) continue;\n                outX = x - (outStartX*3);\n                uint32 pix = raster[y * workingWidth + x/3];\n                unsigned char *vp = (unsigned char *)&pix;\n                scanline[outX] = vp[2];\n                scanline[outX+1] = vp[1];\n                scanline[outX+2] = vp[0];\n            }\n\n            //in bmp lines stored fliped verticaly. Write lines from bottom to top\n            fseek(outFIle, 122 + (/*height - tileShift - row*/outHeight - outY - 1) * scanlineSize , SEEK_SET);\n            fwrite(scanline,scanlineSize,1,outFIle);\n            tileShift++;\n            imageWritedLines++;\n        }\n        //LOGII(\"imageWritedLines\", imageWritedLines);\n        free(raster);\n    }\n    free(scanline);\n\n    if (rasterTile) {\n        _TIFFfree(rasterTile);\n        rasterTile = NULL;\n    }\n\n    if (work_line_buf) {\n        _TIFFfree(rasterTile);\n        work_line_buf = NULL;\n    }\n\n    sendProgress(total, total);\n    return JNI_TRUE;\n\n}\n\njboolean TiffToBmpConverter::convertFromStrip() {\n    uint32 stripSize = TIFFStripSize (tiffImage);\n    uint32 stripMax = TIFFNumberOfStrips (tiffImage);\n    int rowPerStrip = -1;\n    TIFFGetField(tiffImage, TIFFTAG_ROWSPERSTRIP, &rowPerStrip);\n\n    unsigned long estimateMem = width * sizeof(uint32);//working buf\n    estimateMem += width * rowPerStrip * sizeof (uint32);//raster\n    estimateMem += outWidth * 3 + outWidth % 4;\n    //estimateMem += 4 * width * sizeof(png_bytep); //buf for writing to png\n    LOGII(\"estimateMem\", estimateMem);\n    if (estimateMem > availableMemory && availableMemory != -1) {\n        LOGEI(\"Not enought memory\", availableMemory);\n        if (throwException) {\n            throw_not_enought_memory_exception(env, availableMemory, estimateMem);\n        }\n        return JNI_FALSE;\n    }\n\n    LOGII(\"rps\", rowPerStrip);\n    LOGII(\"sm\", stripMax);\n\n    jlong total = stripMax * rowPerStrip * width;\n    sendProgress(0, total);\n\n    uint32* work_line_buf = (uint32 *)_TIFFmalloc(width * sizeof(uint32));\n    uint32* raster = (uint32 *)_TIFFmalloc(width * rowPerStrip * sizeof (uint32));\n\n    uint32 rows_to_write = 0;\n\n    //24 bpp bmp should has with multiple 4\n    int rowSize = outWidth * 3 + outWidth % 4;\n    unsigned char *row = new unsigned char[rowSize];\n    for (int i = 0; i < stripMax*rowPerStrip; i += rowPerStrip) {\n        if (checkStop()) {\n            if (raster) {\n                _TIFFfree(raster);\n                raster = NULL;\n            }\n            if (work_line_buf) {\n                _TIFFfree(work_line_buf);\n                work_line_buf = NULL;\n            }\n            return JNI_FALSE;\n        }\n\n        if ((i < outStartY && i + rowPerStrip < outStartY) || (i >= outStartY + outHeight && i + rowPerStrip >= outStartY + outHeight)) continue;\n        LOGII(\"i\", i);\n\n        sendProgress(i * width, total);\n        TIFFReadRGBAStrip(tiffImage, i, raster);\n\n        rows_to_write = 0;\n        if( i + rowPerStrip > height )\n            rows_to_write = height - i;\n        else\n            rows_to_write = rowPerStrip;\n\n        if (origorientation <= 4) {\n            for (int line = 0; line < rows_to_write / 2; line++) {\n                unsigned int  *top_line, *bottom_line;\n                top_line = raster + width * line;\n                bottom_line = raster + width * (rows_to_write - line - 1);\n\n                _TIFFmemcpy(work_line_buf, top_line, sizeof(unsigned int) * width);\n                _TIFFmemcpy(top_line, bottom_line, sizeof(unsigned int) * width);\n                _TIFFmemcpy(bottom_line, work_line_buf, sizeof(unsigned int) * width);\n            }\n        }\n\n        if (origorientation == ORIENTATION_TOPRIGHT || origorientation == ORIENTATION_BOTRIGHT\n                || origorientation == ORIENTATION_RIGHTTOP || origorientation == ORIENTATION_RIGHTBOT) {\n\n                for (int y = 0; y < rows_to_write; y++) {\n                    for (int x = 0; x < width/2; x++) {\n                        uint32 buf = raster[y * width + x];\n                        raster[y * width + x] = raster[y * width + width - 1 - x];\n                        raster[y * width + width - 1 - x] = buf;\n                    }\n                }\n        }\n\n        int outY, outX;\n        for (int y = 0; y < rows_to_write; y++) {\n            if (i + y < outStartY || i + y >= outStartY + outHeight) continue;\n            outY = i + y - outStartY;\n            for (int x = 0; x < width * 3; x += 3) {\n                if (x < outStartX * 3 || x >= (outStartX + outWidth) * 3) continue;\n                outX = x - (outStartX*3);\n                uint32 pix = raster[y * width + x/3];\n                unsigned char *vp = (unsigned char *)&pix;\n                //in bmp colors stores as bgr\n                row[outX] = vp[2]; //red\n                row[outX+1] = vp[1]; //green\n                row[outX+2] = vp[0];   //blue\n            }\n\n            //in bmp lines stored fliped verticaly. Write lines from bottom to top\n            fseek(outFIle, 122 + (outHeight - outY - 1) * rowSize , SEEK_SET);\n            fwrite(row,rowSize,1,outFIle);\n        }\n    }\n    free(row);\n\n    if (raster) {\n        _TIFFfree(raster);\n        raster = NULL;\n    }\n\n    if (work_line_buf) {\n        _TIFFfree(work_line_buf);\n        work_line_buf = NULL;\n    }\n\n    sendProgress(total, total);\n\n    return JNI_TRUE;\n}\n\nint TiffToBmpConverter::getDecodeMethod() {\n    int method = -1;\n\tuint32 tileWidth, tileHeight;\n\tint readTW = 0, readTH = 0;\n    readTW = TIFFGetField(tiffImage, TIFFTAG_TILEWIDTH, &tileWidth);\n    readTH = TIFFGetField(tiffImage, TIFFTAG_TILELENGTH, &tileHeight);\n    if (tileWidth > 0 && tileHeight > 0 && readTH > 0 && readTW > 0) {\n        method = DECODE_METHOD_TILE;\n    } else {\n        int rowPerStrip = -1;\n    \tTIFFGetField(tiffImage, TIFFTAG_ROWSPERSTRIP, &rowPerStrip);\n    \tuint32 stripSize = TIFFStripSize (tiffImage);\n    \tuint32 stripMax = TIFFNumberOfStrips (tiffImage);\n    \tint estimate = width * 3;\n    \tLOGII(\"RPS\", rowPerStrip);\n    \tLOGII(\"stripSize\", stripSize);\n    \tLOGII(\"stripMax\", stripMax);\n    \tif (rowPerStrip != -1 && stripSize > 0 && stripMax > 1 && rowPerStrip < height) {\n    \t    method = DECODE_METHOD_STRIP;\n    \t} else {\n    \tmethod = DECODE_METHOD_IMAGE;\n    \t}\n    }\n\n\tLOGII(\"Decode method\", method);\n\treturn method;\n\n}\n",
                "name": "TiffToBmpConverter.cpp",
                "path": "src/main/jni/TiffToBmpConverter.cpp",
                "url": "/github.com/Beyka/Android-TiffBitmapFactory/-/blob/src/main/jni/TiffToBmpConverter.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 329,
                    "offsetAndLengths": [
                        [
                            12,
                            16
                        ]
                    ],
                    "preview": "            TIFFReadRGBATile(tiffImage, column , row, rasterTile);"
                }
            ],
            "repository": {
                "name": "github.com/Beyka/Android-TiffBitmapFactory",
                "url": "/github.com/Beyka/Android-TiffBitmapFactory"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "aca0b69befb13a72dae848e110b2bd1cc9007516"
                },
                "content": "//\n// Created by beyka on 5/10/17.\n//\n\n#include \"TiffToJpgConverter.h\"\n\nTiffToJpgConverter::TiffToJpgConverter(JNIEnv *e, jclass clazz, jstring in, jstring out, jobject opts, jobject listener)\n    : BaseTiffConverter(e, clazz, in, out, opts, listener)\n{\n    jpeg_struct_init = 0;\n}\n\nTiffToJpgConverter::TiffToJpgConverter(JNIEnv *e, jclass clazz, jint in, jint out, jobject opts, jobject listener)\n    : BaseTiffConverter(e, clazz, in, out, opts, listener)\n{\n    jpeg_struct_init = 0;\n}\n\nTiffToJpgConverter::~TiffToJpgConverter()\n{\n    LOGI(\"destructor\");\n    if (tiffImage) {\n        TIFFClose(tiffImage);\n        tiffImage = NULL;\n    }\n        LOGI(\"tiff\");\n\n    if (jpegFile) {\n        /*if (!conversion_result) {\n            const char *strPngPath = NULL;\n            strPngPath = env->GetStringUTFChars(outPath, 0);\n            remove(strPngPath);\n            env->ReleaseStringUTFChars(outPath, strPngPath);\n        }*/\n        fclose(jpegFile);\n    }\n    LOGI(\"file\");\n    if (jpeg_struct_init) {\n        jpeg_destroy_compress(&cinfo);\n    }\n    LOGI(\"destructor finish\");\n\n}\n\njboolean TiffToJpgConverter::convert()\n{\n    readOptions();\n    LOGI(\"Optioons read done\");\n\n    LOGII(\"inFd=\", inFd);\n    if (inFd == -1) {\n        const char *inCPath = NULL;\n        inCPath = env->GetStringUTFChars(inPath, 0);\n        LOGIS(\"IN path\", inCPath);\n        inFd = open(inCPath, O_RDWR, 0666);\n        if (inFd == -1) {\n            if (throwException) {\n                throw_cant_open_file_exception(env, inPath);\n            }\n            LOGES(\"Can\\'t open in file\", inCPath);\n            env->ReleaseStringUTFChars(inPath, inCPath);\n            return JNI_FALSE;\n        }\n        env->ReleaseStringUTFChars(inPath, inCPath);\n    }\n\n    //open tiff image for reading\n    tiffImage = TIFFFdOpen(inFd, \"\", \"r\");\n    if (tiffImage == NULL) {\n        if (throwException) {\n            if (inFd < 0) {\n                throw_cant_open_file_exception(env, inPath);\n            } else {\n                throw_cant_open_file_exception_fd(env, inFd);\n            }\n        }\n        return JNI_FALSE;\n    }\n    LOGI(\"Tiff file opened for reading\");\n\n\n    //in c++ path\n    /*const char *strTiffPath = NULL;\n    strTiffPath = env->GetStringUTFChars(inPath, 0);\n    LOGIS(\"IN path\", strTiffPath);\n\n    //open tiff image for reading\n    tiffImage = TIFFOpen(strTiffPath, \"r\");\n    if (tiffImage == NULL) {\n        if (throwException) {\n            throw_cant_open_file_exception(env, inPath);\n        }\n        LOGES(\"Can\\'t open in file\", strTiffPath);\n        env->ReleaseStringUTFChars(inPath, strTiffPath);\n        return JNI_FALSE;\n    } else {\n        env->ReleaseStringUTFChars(inPath, strTiffPath);\n    }\n    LOGI(\"Tiff file opened for reading\");*/\n\n    //open jpg file for writing\n    LOGII(\"outFd=\", outFd);\n    if(outFd == -1) {\n    LOGI(\"Opening jpg as File\");\n        //open tiff file for writing or appending\n        const char *outCPath = NULL;\n        outCPath = env->GetStringUTFChars(outPath, 0);\n        LOGIS(\"OUT path\", outCPath);\n        jpegFile = fopen(outCPath, \"w\");\n        if (!jpegFile) {\n            throw_cant_open_file_exception(env, outPath);\n            env->ReleaseStringUTFChars(outPath, outCPath);\n            return JNI_FALSE;\n        }\n    } else {\n    LOGI(\"Opening jpg as FD\");\n        jpegFile = fdopen(outFd, \"w\");\n        if (!jpegFile) {\n            LOGI(\"JPG file is null\");\n            if (throwException) {\n                throw_cant_open_file_exception_fd(env, inFd);\n            }\n            LOGES(\"Can\\'t open out file descriptor\", inFd);\n            return JNI_FALSE;\n        }\n    }\n    LOGI(\"JPG file opened\");\n    /*const char *strPngPath = NULL;\n    strPngPath = env->GetStringUTFChars(outPath, 0);\n    LOGIS(\"OUT path\", strPngPath);\n    jpegFile = fopen(strPngPath, \"wb\");\n    if (!jpegFile) {\n        if (throwException) {\n            throw_cant_open_file_exception(env, outPath);\n        }\n        LOGES(\"Can\\'t open out file\", strPngPath);\n        env->ReleaseStringUTFChars(outPath, strPngPath);\n        return JNI_FALSE;\n    } else {\n        env->ReleaseStringUTFChars(outPath, strPngPath);\n    }*/\n\n\n    LOGI(\"initialize jpeg structure\");\n    //set error handling\n    cinfo.err = jpeg_std_error(&jerr);\n    LOGI(\"initialize error handling done\");\n    //initialize jpeg compression object\n    jpeg_create_compress(&cinfo);\n    jpeg_struct_init = 1;\n    LOGI(\"initialize compress done\");\n    //set phisical file for jpeg\n    jpeg_stdio_dest(&cinfo, jpegFile);\n    LOGI(\"initialize dest file done\");\n\n    //set tiff directory and read image dimensions\n    TIFFSetDirectory(tiffImage, tiffDirectory);\n    TIFFGetField(tiffImage, TIFFTAG_IMAGEWIDTH, &width);\n    TIFFGetField(tiffImage, TIFFTAG_IMAGELENGTH, &height);\n    //Getting image orientation and createing ImageOrientation enum\n    TIFFGetField(tiffImage, TIFFTAG_ORIENTATION, &origorientation);\n    //If orientation field is empty - use ORIENTATION_TOPLEFT\n    if (origorientation == 0) {\n        origorientation = ORIENTATION_TOPLEFT;\n    }\n\n    if (!normalizeDecodeArea()) {\n        return JNI_FALSE;\n    }\n\n    LOGII(\"image width\", width);\n    LOGII(\"image height\", height);\n    LOGII(\"image bound width\", boundWidth);\n    LOGII(\"image bound height\", boundHeight);\n    LOGII(\"image out width\", outWidth);\n    LOGII(\"image out height\", outHeight);\n\n    cinfo.image_width = outWidth;\n    cinfo.image_height = outHeight;\n    cinfo.input_components = 3;\n    cinfo.in_color_space = JCS_RGB;\n\n    LOGI(\"writing img parameters done\");\n\n    jpeg_set_defaults(&cinfo);\n    LOGI(\"set defaults done\");\n    jpeg_set_quality(&cinfo, JPEG_QUALITY, TRUE /* limit to baseline-JPEG values */);\n    LOGI(\"set quality done\");\n\n    //write file header\n    jpeg_start_compress(&cinfo, TRUE);\n    LOGI(\"start compressing\");\n\n    jboolean result = JNI_FALSE;\n\n    switch(getDecodeMethod()) {\n        case DECODE_METHOD_IMAGE:\n            result = convertFromImage();\n            break;\n        case DECODE_METHOD_TILE:\n            result = convertFromTile();\n            break;\n        case DECODE_METHOD_STRIP:\n            result = convertFromStrip();\n            break;\n    }\n\n    if (result) {\n        jpeg_finish_compress(&cinfo);\n    }\n    conversion_result = result;\n    return conversion_result;\n}\n\njboolean TiffToJpgConverter::convertFromImage() {\n    int origBufferSize = width * height * sizeof(uint32);\n\n    unsigned long estimateMem = origBufferSize;\n    estimateMem += outWidth * sizeof(unsigned char) * 3;//working buf\n    LOGII(\"estimateMem\", estimateMem);\n    if (estimateMem > availableMemory && availableMemory != -1) {\n        LOGEI(\"Not enough memory\", availableMemory);\n        if (throwException) {\n            throw_not_enought_memory_exception(env, availableMemory, estimateMem);\n        }\n        return JNI_FALSE;\n    }\n\n    uint32 *origBuffer = NULL;\n    origBuffer = (uint32 *) _TIFFmalloc(origBufferSize);\n    if (origBuffer == NULL) {\n        const char *message = \"Can\\'t allocate buffer\";\n        LOGE(*message);\n        if (throwException) {\n            throw_not_enought_memory_exception(env, availableMemory, origBufferSize);\n        }\n        return JNI_FALSE;\n    }\n\n    if (0 == TIFFReadRGBAImageOriented(tiffImage, width, height, origBuffer, ORIENTATION_TOPLEFT, 0)) {\n        free(origBuffer);\n        const char *message = \"Can\\'t read tiff\";\n        if (throwException) {\n            jstring er = env->NewStringUTF(message);\n            if (outFd == -1) {\n                throw_decode_file_exception(env, outPath, er);\n            } else {\n                throw_decode_file_exception_fd(env, outFd, er);\n            }\n            env->DeleteLocalRef(er);\n        }\n        LOGE(message);\n        return JNI_FALSE;\n    }\n\n    jlong total = width * height;\n    sendProgress(0, total);\n\n    int outY, outX;\n    JSAMPROW row_pointer[1];\n    for (int y = 0; y < height; y++) {\n        if (checkStop()) {\n            free(origBuffer);\n            return JNI_FALSE;\n        }\n        sendProgress(y * width, total);\n        if (y < outStartY || y >= outStartY + outHeight) continue;\n        outY = y - outStartY;\n\n        unsigned char *row = (unsigned char*)malloc(outWidth * sizeof(unsigned char) * 3);\n\n        for (int x = 0; x < width * 3; x += 3) {\n            if (x < outStartX * 3 || x >= (outStartX + outWidth) * 3) continue;\n            outX = x - (outStartX*3);\n            uint32 pix = origBuffer[y * width + x/3];\n            unsigned char *vp = (unsigned char *)&pix;\n            row[outX] = vp[0];\n            row[outX+1] = vp[1];\n            row[outX+2] = vp[2];\n        }\n        row_pointer[0] = row;\n        jpeg_write_scanlines(&cinfo, row_pointer, 1);\n        delete(row);\n    }\n    free(origBuffer);\n    sendProgress(total, total);\n    return JNI_TRUE;\n}\n\njboolean TiffToJpgConverter::convertFromTile() {\n    uint32 tileWidth = 0, tileHeight = 0;\n    TIFFGetField(tiffImage, TIFFTAG_TILEWIDTH, &tileWidth);\n    TIFFGetField(tiffImage, TIFFTAG_TILEWIDTH, &tileHeight);\n    LOGII(\"Tile width\", tileWidth);\n    LOGII(\"Tile height\", tileHeight);\n\n    //uint32 *raster = (uint32 *)_TIFFmalloc(width * tileHeight * sizeof(uint32));\n    uint32 workingWidth = (width/tileWidth + (width%tileWidth == 0 ? 0 : 1)) * tileWidth;\n    LOGII(\"workingWidth \", workingWidth );\n    uint32 rasterSize =  workingWidth  * tileHeight ;\n    LOGII(\"rasterSize \", rasterSize );\n    //uint32 *raster = (uint32 *)_TIFFmalloc(rasterSize * sizeof(uint32));\n\n\n    unsigned long estimateMem = rasterSize * sizeof(uint32); //raster\n    estimateMem += tileWidth * tileHeight * sizeof(uint32); //tile raster\n    estimateMem += tileWidth * sizeof (uint32); //working buf\n    estimateMem += outWidth * sizeof(unsigned char) * 3; //bufer for writing to jpg\n    LOGII(\"estimateMem\", estimateMem);\n    if (estimateMem > availableMemory && availableMemory != -1) {\n        LOGEI(\"Not enought memory\", availableMemory);\n        if (throwException) {\n            throw_not_enought_memory_exception(env, availableMemory, estimateMem);\n        }\n        return JNI_FALSE;\n    }\n\n    uint32 *rasterTile = (uint32 *)_TIFFmalloc(tileWidth * tileHeight * sizeof(uint32));\n    uint32 *work_line_buf = (uint32*)_TIFFmalloc(tileWidth * sizeof (uint32));\n\n     jlong total = ((width/tileWidth + (width%tileWidth == 0 ? 0 : 1)) * tileWidth)\n                * ((height/tileHeight + (height%tileHeight == 0 ? 0 : 1)) * tileHeight);\n        sendProgress(0, total);\n\n    uint32 row, column;\n\n    int startx = -1, starty = -1, endx = -1, endy = -1;\n    uint32 imageWritedLines = 0;\n\n    for (row = 0; row < height; row += tileHeight) {\n        sendProgress(row * width, total);\n        endy = -1;\n        starty = -1;\n        uint32 *raster = (uint32 *)_TIFFmalloc(rasterSize * sizeof(uint32));\n\n        for (column = 0; column < width; column += tileWidth) {\n            if (checkStop()) {\n                free(raster);\n                raster = NULL;\n                if (rasterTile) {\n                    _TIFFfree(rasterTile);\n                    rasterTile = NULL;\n                }\n                if (work_line_buf) {\n                    _TIFFfree(rasterTile);\n                    work_line_buf = NULL;\n                }\n                return JNI_FALSE;\n            }\n            endx = -1;\n            startx = -1;\n            TIFFReadRGBATile(tiffImage, column , row, rasterTile);\n            switch(origorientation) {\n                case 1:\n                case 5:\n                    rotateTileLinesVertical(tileHeight, tileWidth, rasterTile, work_line_buf);\n                    break;\n                case 2:\n                case 6:\n                    rotateTileLinesVertical(tileHeight, tileWidth, rasterTile, work_line_buf);\n                    rotateTileLinesHorizontal(tileHeight, tileWidth, rasterTile, work_line_buf);\n                    break;\n                case 3:\n                case 7:\n                    rotateTileLinesHorizontal(tileHeight, tileWidth, rasterTile, work_line_buf);\n                    break;\n            }\n\n            normalizeTile(tileHeight, tileWidth, rasterTile);\n\n            //find start and end position\n            for (int ty = 0; ty < tileHeight; ty++) {\n\n                for (int tx = 0; tx < tileWidth; tx++) {\n                    if (rasterTile[ty * tileWidth + tx] != 0) {\n                        if (startx == -1) {\n                            startx = tx;\n                        }\n                        if (starty == -1) {\n                            starty = ty;\n                        }\n\n                        if (tx > endx)\n                            endx = tx;\n                        if (ty > endy)\n                            endy = ty;\n\n                        uint32 rasterPos = (ty ) * workingWidth + (tx + column);\n                        //LOGII(\"rp\", rasterPos);\n                        raster[rasterPos] = rasterTile[ty * tileWidth + tx];\n                    }\n\n                }\n            }\n        }\n\n        int outY, outX;\n        JSAMPROW row_pointer[1];\n        for (int y = starty; y < tileHeight; y++) {\n            if (imageWritedLines == height) break;\n            if (y + row < outStartY || y + row >= outStartY + outHeight) continue;\n            outY = y + row - outStartY;\n            unsigned char *jpgrow = (unsigned char*)malloc(outWidth * sizeof(unsigned char) * 3);\n\n           // uint32 *rasterLine = (uint32 *)malloc(width * sizeof(uint32));\n\n            //for (int x = startx, x2 = 0; x2 < width; x++, x2++) {\n            //   rasterLine[x2] = raster[y * workingWidth + x];\n            //}\n\n            for (int x = 0; x < width * 3; x += 3) {\n                if (x < outStartX * 3 || x >= (outStartX + outWidth) * 3) continue;\n                outX = x - (outStartX*3);\n                uint32 pix = raster[y * workingWidth + x/3];\n                unsigned char *vp = (unsigned char *)&pix;\n                jpgrow[outX] = vp[0];\n                jpgrow[outX+1] = vp[1];\n                jpgrow[outX+2] = vp[2];\n            }\n            row_pointer[0] = jpgrow;\n            jpeg_write_scanlines(&cinfo, row_pointer, 1);\n            delete(jpgrow);\n            //delete(rasterLine);\n\n            imageWritedLines++;\n        }\n        //LOGII(\"imageWritedLines\", imageWritedLines);\n        free(raster);\n    }\n\n    /*if (raster) {\n        _TIFFfree(raster);\n        raster = NULL;\n    }*/\n\n    if (rasterTile) {\n        _TIFFfree(rasterTile);\n        rasterTile = NULL;\n    }\n\n    if (work_line_buf) {\n        _TIFFfree(rasterTile);\n        work_line_buf = NULL;\n    }\n\n    sendProgress(total, total);\n    return JNI_TRUE;\n\n}\n\njboolean TiffToJpgConverter::convertFromStrip() {\n    uint32 stripSize = TIFFStripSize (tiffImage);\n    uint32 stripMax = TIFFNumberOfStrips (tiffImage);\n    int rowPerStrip = -1;\n    TIFFGetField(tiffImage, TIFFTAG_ROWSPERSTRIP, &rowPerStrip);\n\n    unsigned long estimateMem = width * sizeof(uint32);//working buf\n    estimateMem += width * rowPerStrip * sizeof (uint32);//raster\n    estimateMem += outWidth * sizeof(unsigned char) * 3; //buf for writing to jpg\n    LOGII(\"estimateMem\", estimateMem);\n    if (estimateMem > availableMemory && availableMemory != -1) {\n        LOGEI(\"Not enought memory\", availableMemory);\n        if (throwException) {\n            throw_not_enought_memory_exception(env, availableMemory, estimateMem);\n        }\n        return JNI_FALSE;\n    }\n\n    jlong total = stripMax * rowPerStrip * width;\n    sendProgress(0, total);\n\n    uint32* work_line_buf = (uint32 *)_TIFFmalloc(width * sizeof(uint32));\n    uint32* raster = (uint32 *)_TIFFmalloc(width * rowPerStrip * sizeof (uint32));\n\n    uint32 rows_to_write = 0;\n\n    for (int i = 0; i < stripMax*rowPerStrip; i += rowPerStrip) {\n        if (checkStop()) {\n            if (raster) {\n                _TIFFfree(raster);\n                raster = NULL;\n            }\n            if (work_line_buf) {\n                _TIFFfree(work_line_buf);\n                work_line_buf = NULL;\n            }\n            return JNI_FALSE;\n        }\n        sendProgress(i * width, total);\n        TIFFReadRGBAStrip(tiffImage, i, raster);\n\n        rows_to_write = 0;\n        if( i + rowPerStrip > height )\n            rows_to_write = height - i;\n        else\n            rows_to_write = rowPerStrip;\n\n        if (origorientation <= 4) {\n            for (int line = 0; line < rows_to_write / 2; line++) {\n                unsigned int  *top_line, *bottom_line;\n                top_line = raster + width * line;\n                bottom_line = raster + width * (rows_to_write - line - 1);\n\n                _TIFFmemcpy(work_line_buf, top_line, sizeof(unsigned int) * width);\n                _TIFFmemcpy(top_line, bottom_line, sizeof(unsigned int) * width);\n                _TIFFmemcpy(bottom_line, work_line_buf, sizeof(unsigned int) * width);\n            }\n        }\n\n        if (origorientation == ORIENTATION_TOPRIGHT || origorientation == ORIENTATION_BOTRIGHT\n                || origorientation == ORIENTATION_RIGHTTOP || origorientation == ORIENTATION_RIGHTBOT) {\n\n                for (int y = 0; y < rows_to_write; y++) {\n                    for (int x = 0; x < width/2; x++) {\n                        uint32 buf = raster[y * width + x];\n                        raster[y * width + x] = raster[y * width + width - 1 - x];\n                        raster[y * width + width - 1 - x] = buf;\n                    }\n                }\n\n        }\n        int outY, outX;\n        JSAMPROW row_pointer[1];\n        for (int y = 0; y < rows_to_write; y++) {\n            if (i + y < outStartY || i + y >= outStartY + outHeight) continue;\n            outY = i + y - outStartY;\n\n            unsigned char *jpgrow = (unsigned char*)malloc(outWidth * sizeof(unsigned char) * 3);\n\n            for (int x = 0; x < width * 3; x += 3) {\n                if (x < outStartX * 3 || x >= (outStartX + outWidth) * 3) continue;\n                outX = x - (outStartX*3);\n                uint32 pix = raster[y * width + x/3];\n                unsigned char *vp = (unsigned char *)&pix;\n                jpgrow[outX] = vp[0];\n                jpgrow[outX+1] = vp[1];\n                jpgrow[outX+2] = vp[2];\n            }\n            row_pointer[0] = jpgrow;\n            jpeg_write_scanlines(&cinfo, row_pointer, 1);\n            delete(jpgrow);\n\n            /*png_bytep row = (png_bytep)malloc(4 * width * sizeof(png_bytep));\n            memcpy(row, raster + (y * width), width * 4);\n            png_write_row(png_ptr, row);\n            delete(row);*/\n        }\n\n    }\n\n    if (raster) {\n        _TIFFfree(raster);\n        raster = NULL;\n    }\n\n    if (work_line_buf) {\n        _TIFFfree(work_line_buf);\n        work_line_buf = NULL;\n    }\n\n    sendProgress(total, total);\n\n    return JNI_TRUE;\n}\n\nint TiffToJpgConverter::getDecodeMethod() {\n    int method = -1;\n\tuint32 tileWidth, tileHeight;\n\tint readTW = 0, readTH = 0;\n    readTW = TIFFGetField(tiffImage, TIFFTAG_TILEWIDTH, &tileWidth);\n    readTH = TIFFGetField(tiffImage, TIFFTAG_TILELENGTH, &tileHeight);\n    if (tileWidth > 0 && tileHeight > 0 && readTH > 0 && readTW > 0) {\n        method = DECODE_METHOD_TILE;\n    } else {\n        int rowPerStrip = -1;\n    \tTIFFGetField(tiffImage, TIFFTAG_ROWSPERSTRIP, &rowPerStrip);\n    \tuint32 stripSize = TIFFStripSize (tiffImage);\n    \tuint32 stripMax = TIFFNumberOfStrips (tiffImage);\n    \tint estimate = width * 3;\n    \tLOGII(\"RPS\", rowPerStrip);\n    \tLOGII(\"stripSize\", stripSize);\n    \tLOGII(\"stripMax\", stripMax);\n    \tif (rowPerStrip != -1 && stripSize > 0 && stripMax > 1 && rowPerStrip < height) {\n    \t    method = DECODE_METHOD_STRIP;\n    \t} else {\n    \tmethod = DECODE_METHOD_IMAGE;\n    \t}\n    }\n\n\tLOGII(\"Decode method\", method);\n\treturn method;\n    /*int method = -1;\n\tuint32 tileWidth, tileHeight;\n\tint readTW = 0, readTH = 0;\n    readTW = TIFFGetField(tiffImage, TIFFTAG_TILEWIDTH, &tileWidth);\n    readTH = TIFFGetField(tiffImage, TIFFTAG_TILELENGTH, &tileHeight);\n    int rowPerStrip = -1;\n    TIFFGetField(tiffImage, TIFFTAG_ROWSPERSTRIP, &rowPerStrip);\n    uint32 stripSize = TIFFStripSize (tiffImage);\n    uint32 stripMax = TIFFNumberOfStrips (tiffImage);\n    int estimate = width * 3;\n    LOGII(\"RPS\", rowPerStrip);\n    LOGII(\"stripSize\", stripSize);\n    LOGII(\"stripMax\", stripMax);\n\n    if (rowPerStrip != -1 && stripSize > 0 && stripMax > 1 && rowPerStrip < height) {\n        method = DECODE_METHOD_STRIP;\n    } else if (tileWidth > 0 && tileHeight > 0 && readTH > 0 && readTW > 0) {\n        method = DECODE_METHOD_TILE;\n    } else {\n        method = DECODE_METHOD_IMAGE;\n    }\n\tLOGII(\"Decode method\", method);\n\treturn method;*/\n}\n",
                "name": "TiffToJpgConverter.cpp",
                "path": "src/main/jni/TiffToJpgConverter.cpp",
                "url": "/github.com/Beyka/Android-TiffBitmapFactory/-/blob/src/main/jni/TiffToJpgConverter.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 351,
                    "offsetAndLengths": [
                        [
                            12,
                            16
                        ]
                    ],
                    "preview": "            TIFFReadRGBATile(tiffImage, column , row, rasterTile);"
                }
            ],
            "repository": {
                "name": "github.com/Beyka/Android-TiffBitmapFactory",
                "url": "/github.com/Beyka/Android-TiffBitmapFactory"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "723c1b75c6f8b27070fec5473f3cb3f02e5a094c"
                },
                "content": "/*M///////////////////////////////////////////////////////////////////////////////////////\n//\n//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.\n//\n//  By downloading, copying, installing or using the software you agree to this license.\n//  If you do not agree to this license, do not download, install,\n//  copy or use the software.\n//\n//\n//                           License Agreement\n//                For Open Source Computer Vision Library\n//\n// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.\n// Copyright (C) 2009, Willow Garage Inc., all rights reserved.\n// Third party copyrights are property of their respective owners.\n//\n// Redistribution and use in source and binary forms, with or without modification,\n// are permitted provided that the following conditions are met:\n//\n//   * Redistribution's of source code must retain the above copyright notice,\n//     this list of conditions and the following disclaimer.\n//\n//   * Redistribution's in binary form must reproduce the above copyright notice,\n//     this list of conditions and the following disclaimer in the documentation\n//     and/or other materials provided with the distribution.\n//\n//   * The name of the copyright holders may not be used to endorse or promote products\n//     derived from this software without specific prior written permission.\n//\n// This software is provided by the copyright holders and contributors \"as is\" and\n// any express or implied warranties, including, but not limited to, the implied\n// warranties of merchantability and fitness for a particular purpose are disclaimed.\n// In no event shall the Intel Corporation or contributors be liable for any direct,\n// indirect, incidental, special, exemplary, or consequential damages\n// (including, but not limited to, procurement of substitute goods or services;\n// loss of use, data, or profits; or business interruption) however caused\n// and on any theory of liability, whether in contract, strict liability,\n// or tort (including negligence or otherwise) arising in any way out of\n// the use of this software, even if advised of the possibility of such damage.\n//\n//M*/\n\n/****************************************************************************************\\\n    A part of the file implements TIFF reader on base of libtiff library\n    (see otherlibs/_graphics/readme.txt for copyright notice)\n\\****************************************************************************************/\n\n#include \"precomp.hpp\"\n\n#ifdef HAVE_TIFF\n#include <opencv2/core/utils/logger.hpp>\n\n#include \"grfmt_tiff.hpp\"\n#include <limits>\n\n// TODO FIXIT Conflict declarations for common types like int64/uint64\nnamespace tiff_dummy_namespace {\n#include \"tiff.h\"\n#include \"tiffio.h\"\n}\nusing namespace tiff_dummy_namespace;\n\nnamespace cv\n{\n\n#define CV_TIFF_CHECK_CALL(call) \\\n    if (0 == (call)) { \\\n        CV_LOG_WARNING(NULL, \"OpenCV TIFF(line \" << __LINE__ << \"): failed \" #call); \\\n        CV_Error(Error::StsError, \"OpenCV TIFF: failed \" #call); \\\n    }\n\n#define CV_TIFF_CHECK_CALL_INFO(call) \\\n    if (0 == (call)) { \\\n        CV_LOG_INFO(NULL, \"OpenCV TIFF(line \" << __LINE__ << \"): failed optional call: \" #call \", ignoring\"); \\\n    }\n\n#define CV_TIFF_CHECK_CALL_DEBUG(call) \\\n    if (0 == (call)) { \\\n        CV_LOG_DEBUG(NULL, \"OpenCV TIFF(line \" << __LINE__ << \"): failed optional call: \" #call \", ignoring\"); \\\n    }\n\nstatic void cv_tiffCloseHandle(void* handle)\n{\n    TIFFClose((TIFF*)handle);\n}\n\nstatic void cv_tiffErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    if (cv::utils::logging::getLogLevel() < cv::utils::logging::LOG_LEVEL_DEBUG)\n        return;\n    // TODO cv::vformat() with va_list parameter\n    fprintf(stderr, \"OpenCV TIFF: \");\n    if (module != NULL)\n        fprintf(stderr, \"%s: \", module);\n    fprintf(stderr, \"Warning, \");\n    vfprintf(stderr, fmt, ap);\n    fprintf(stderr, \".\\n\");\n}\n\nstatic bool cv_tiffSetErrorHandler_()\n{\n    TIFFSetErrorHandler(cv_tiffErrorHandler);\n    TIFFSetWarningHandler(cv_tiffErrorHandler);\n    return true;\n}\n\nstatic bool cv_tiffSetErrorHandler()\n{\n    static bool v = cv_tiffSetErrorHandler_();\n    return v;\n}\n\nstatic const char fmtSignTiffII[] = \"II\\x2a\\x00\";\nstatic const char fmtSignTiffMM[] = \"MM\\x00\\x2a\";\nstatic const char fmtSignBigTiffII[] = \"II\\x2b\\x00\";\nstatic const char fmtSignBigTiffMM[] = \"MM\\x00\\x2b\";\n\nTiffDecoder::TiffDecoder()\n{\n    m_hdr = false;\n    m_buf_supported = true;\n    m_buf_pos = 0;\n}\n\n\nvoid TiffDecoder::close()\n{\n    m_tif.release();\n}\n\nTiffDecoder::~TiffDecoder()\n{\n    close();\n}\n\nsize_t TiffDecoder::signatureLength() const\n{\n    return 4;\n}\n\nbool TiffDecoder::checkSignature( const String& signature ) const\n{\n    return signature.size() >= 4 &&\n        (memcmp(signature.c_str(), fmtSignTiffII, 4) == 0 ||\n        memcmp(signature.c_str(), fmtSignTiffMM, 4) == 0 ||\n        memcmp(signature.c_str(), fmtSignBigTiffII, 4) == 0 ||\n        memcmp(signature.c_str(), fmtSignBigTiffMM, 4) == 0);\n}\n\nint TiffDecoder::normalizeChannelsNumber(int channels) const\n{\n    CV_Check(channels, channels >= 1 && channels <= 4, \"Unsupported number of channels\");\n    return channels;\n}\n\nImageDecoder TiffDecoder::newDecoder() const\n{\n    cv_tiffSetErrorHandler();\n    return makePtr<TiffDecoder>();\n}\n\nclass TiffDecoderBufHelper\n{\n    Mat& m_buf;\n    size_t& m_buf_pos;\npublic:\n    TiffDecoderBufHelper(Mat& buf, size_t& buf_pos) :\n        m_buf(buf), m_buf_pos(buf_pos)\n    {}\n    static tmsize_t read( thandle_t handle, void* buffer, tmsize_t n )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        const Mat& buf = helper->m_buf;\n        const tmsize_t size = buf.cols*buf.rows*buf.elemSize();\n        tmsize_t pos = helper->m_buf_pos;\n        if ( n > (size - pos) )\n        {\n            n = size - pos;\n        }\n        memcpy(buffer, buf.ptr() + pos, n);\n        helper->m_buf_pos += n;\n        return n;\n    }\n\n    static tmsize_t write( thandle_t /*handle*/, void* /*buffer*/, tmsize_t /*n*/ )\n    {\n        // Not used for decoding.\n        return 0;\n    }\n\n    static toff_t seek( thandle_t handle, toff_t offset, int whence )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        const Mat& buf = helper->m_buf;\n        const toff_t size = buf.cols*buf.rows*buf.elemSize();\n        toff_t new_pos = helper->m_buf_pos;\n        switch (whence)\n        {\n            case SEEK_SET:\n                new_pos = offset;\n                break;\n            case SEEK_CUR:\n                new_pos += offset;\n                break;\n            case SEEK_END:\n                new_pos = size + offset;\n                break;\n        }\n        new_pos = std::min(new_pos, size);\n        helper->m_buf_pos = (size_t)new_pos;\n        return new_pos;\n    }\n\n    static int map( thandle_t handle, void** base, toff_t* size )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        Mat& buf = helper->m_buf;\n        *base = buf.ptr();\n        *size = buf.cols*buf.rows*buf.elemSize();\n        return 0;\n    }\n\n    static toff_t size( thandle_t handle )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        const Mat& buf = helper->m_buf;\n        return buf.cols*buf.rows*buf.elemSize();\n    }\n\n    static int close( thandle_t handle )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        delete helper;\n        return 0;\n    }\n};\n\nbool TiffDecoder::readHeader()\n{\n    bool result = false;\n\n    TIFF* tif = static_cast<TIFF*>(m_tif.get());\n    if (!tif)\n    {\n        // TIFFOpen() mode flags are different to fopen().  A 'b' in mode \"rb\" has no effect when reading.\n        // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n        if ( !m_buf.empty() )\n        {\n            m_buf_pos = 0;\n            TiffDecoderBufHelper* buf_helper = new TiffDecoderBufHelper(this->m_buf, this->m_buf_pos);\n            tif = TIFFClientOpen( \"\", \"r\", reinterpret_cast<thandle_t>(buf_helper), &TiffDecoderBufHelper::read,\n                                  &TiffDecoderBufHelper::write, &TiffDecoderBufHelper::seek,\n                                  &TiffDecoderBufHelper::close, &TiffDecoderBufHelper::size,\n                                  &TiffDecoderBufHelper::map, /*unmap=*/0 );\n            if (!tif)\n                delete buf_helper;\n        }\n        else\n        {\n            tif = TIFFOpen(m_filename.c_str(), \"r\");\n        }\n        if (tif)\n            m_tif.reset(tif, cv_tiffCloseHandle);\n        else\n            m_tif.release();\n    }\n\n    if (tif)\n    {\n        uint32 wdth = 0, hght = 0;\n        uint16 photometric = 0;\n\n        CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &wdth));\n        CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &hght));\n        CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric));\n\n        {\n            bool isGrayScale = photometric == PHOTOMETRIC_MINISWHITE || photometric == PHOTOMETRIC_MINISBLACK;\n            uint16 bpp = 8, ncn = isGrayScale ? 1 : 3;\n            if (0 == TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bpp))\n            {\n                // TIFF bi-level images don't require TIFFTAG_BITSPERSAMPLE tag\n                bpp = 1;\n            }\n            CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &ncn));\n\n            m_width = wdth;\n            m_height = hght;\n            if (ncn == 3 && photometric == PHOTOMETRIC_LOGLUV)\n            {\n                m_type = CV_32FC3;\n                m_hdr = true;\n                return true;\n            }\n            m_hdr = false;\n\n            if( bpp > 8 &&\n               ((photometric > 2) ||\n                (ncn != 1 && ncn != 3 && ncn != 4)))\n                bpp = 8;\n\n            uint16 sample_format = SAMPLEFORMAT_UINT;\n            TIFFGetField(tif, TIFFTAG_SAMPLEFORMAT, &sample_format);\n            int wanted_channels = normalizeChannelsNumber(ncn);\n            switch (bpp)\n            {\n            case 1:\n            {\n                CV_Check((int)sample_format, sample_format == SAMPLEFORMAT_UINT || sample_format == SAMPLEFORMAT_INT, \"\");\n                int depth = sample_format == SAMPLEFORMAT_INT ? CV_8S : CV_8U;\n                m_type = CV_MAKETYPE(depth, !isGrayScale ? wanted_channels : 1);\n                result = true;\n                break;\n            }\n            case 4:\n                //support 4-bit palette.\n                if (photometric == PHOTOMETRIC_PALETTE)\n                {\n                    CV_Check((int)sample_format, sample_format == SAMPLEFORMAT_UINT || sample_format == SAMPLEFORMAT_INT, \"\");\n                    int depth = sample_format == SAMPLEFORMAT_INT ? CV_8S : CV_8U;\n                    m_type = CV_MAKETYPE(depth, 3);\n                    result = true;\n                }\n                else\n                    CV_Error(cv::Error::StsError, \"bitsperpixel value is 4 should be palette.\");\n                break;\n            case 8:\n            {\n                //Palette color, the value of the component is used as an index into the red,\n                //green and blue curves in the ColorMap field to retrieve an RGB triplet that defines the color.\n                CV_Check((int)sample_format, sample_format == SAMPLEFORMAT_UINT || sample_format == SAMPLEFORMAT_INT, \"\");\n                int depth = sample_format == SAMPLEFORMAT_INT ? CV_8S : CV_8U;\n                if (photometric == PHOTOMETRIC_PALETTE)\n                    m_type = CV_MAKETYPE(depth, 3);\n                else\n                    m_type = CV_MAKETYPE(depth, !isGrayScale ? wanted_channels : 1);\n                result = true;\n                break;\n            }\n            case 10:\n            case 12:\n            case 14:\n            case 16:\n            {\n                CV_Check((int)sample_format, sample_format == SAMPLEFORMAT_UINT || sample_format == SAMPLEFORMAT_INT, \"\");\n                int depth = sample_format == SAMPLEFORMAT_INT ? CV_16S : CV_16U;\n                m_type = CV_MAKETYPE(depth, !isGrayScale ? wanted_channels : 1);\n                result = true;\n                break;\n            }\n            case 32:\n            {\n                CV_Check((int)sample_format, sample_format == SAMPLEFORMAT_IEEEFP || sample_format == SAMPLEFORMAT_INT, \"\");\n                int depth = sample_format == SAMPLEFORMAT_IEEEFP ? CV_32F : CV_32S;\n                m_type = CV_MAKETYPE(depth, wanted_channels);\n                result = true;\n                break;\n            }\n            case 64:\n                CV_CheckEQ((int)sample_format, SAMPLEFORMAT_IEEEFP, \"\");\n                m_type = CV_MAKETYPE(CV_64F, wanted_channels);\n                result = true;\n                break;\n            default:\n                CV_Error(cv::Error::StsError, \"Invalid bitsperpixel value read from TIFF header! Must be 1, 8, 10, 12, 14, 16, 32 or 64.\");\n            }\n        }\n    }\n\n    if( !result )\n        close();\n\n    return result;\n}\n\nbool TiffDecoder::nextPage()\n{\n    // Prepare the next page, if any.\n    return !m_tif.empty() &&\n           TIFFReadDirectory(static_cast<TIFF*>(m_tif.get())) &&\n           readHeader();\n}\n\nstatic void fixOrientationPartial(Mat &img, uint16 orientation)\n{\n    switch(orientation) {\n        case ORIENTATION_RIGHTTOP:\n        case ORIENTATION_LEFTBOT:\n            flip(img, img, -1);\n            /* fall through */\n\n        case ORIENTATION_LEFTTOP:\n        case ORIENTATION_RIGHTBOT:\n            transpose(img, img);\n            break;\n    }\n}\n\nstatic void fixOrientationFull(Mat &img, int orientation)\n{\n    switch(orientation) {\n        case ORIENTATION_TOPRIGHT:\n            flip(img, img, 1);\n            break;\n\n        case ORIENTATION_BOTRIGHT:\n            flip(img, img, -1);\n            break;\n\n        case ORIENTATION_BOTLEFT:\n            flip(img, img, 0);\n            break;\n\n        case ORIENTATION_LEFTTOP:\n            transpose(img, img);\n            break;\n\n        case ORIENTATION_RIGHTTOP:\n            transpose(img, img);\n            flip(img, img, 1);\n            break;\n\n        case ORIENTATION_RIGHTBOT:\n            transpose(img, img);\n            flip(img, img, -1);\n            break;\n\n        case ORIENTATION_LEFTBOT:\n            transpose(img, img);\n            flip(img, img, 0);\n            break;\n    }\n}\n\n/**\n * Fix orientation defined in tag 274.\n * For 8 bit some corrections are done by TIFFReadRGBAStrip/Tile already.\n * Not so for 16/32/64 bit.\n */\nstatic void fixOrientation(Mat &img, uint16 orientation, int dst_bpp)\n{\n    switch(dst_bpp) {\n        case 8:\n            fixOrientationPartial(img, orientation);\n            break;\n\n        case 16:\n        case 32:\n        case 64:\n            fixOrientationFull(img, orientation);\n            break;\n    }\n}\n\nstatic void _unpack10To16(const uchar* src, const uchar* srcEnd, ushort* dst, ushort* dstEnd, size_t expectedDstElements)\n{\n    //5*8b=4*10b : 5 src for 4 dst\n    constexpr const size_t packedBitsCount = 10;\n    constexpr const size_t packedBitsMask = ((1<<packedBitsCount)-1);\n    constexpr const size_t srcElementsPerPacket = 5;\n    constexpr const size_t dstElementsPerPacket = 4;\n    constexpr const size_t bitsPerPacket = dstElementsPerPacket*packedBitsCount;\n    const size_t fullPacketsCount = std::min({\n      expectedDstElements/dstElementsPerPacket,\n      (static_cast<size_t>(srcEnd-src)/srcElementsPerPacket),\n      (static_cast<size_t>(dstEnd-dst)/dstElementsPerPacket)\n    });\n    union {\n      uint64_t u64;\n      uint8_t  u8[8];\n    } buf = {0};\n    for(size_t i = 0 ; i<fullPacketsCount ; ++i)\n    {\n        for(size_t j = 0 ; j<srcElementsPerPacket ; ++j)\n          buf.u8[srcElementsPerPacket-1-j] = *src++;\n        for(size_t j = 0 ; j<dstElementsPerPacket ; ++j)\n        {\n          dst[dstElementsPerPacket-1-j] = static_cast<ushort>(buf.u64 & packedBitsMask);\n          buf.u64 >>= packedBitsCount;\n        }\n        dst += dstElementsPerPacket;\n    }\n    size_t remainingDstElements = std::min(\n        expectedDstElements-fullPacketsCount*dstElementsPerPacket,\n        static_cast<size_t>(dstEnd-dst)\n    );\n    bool stop = !remainingDstElements;\n    while(!stop)\n    {\n        for(size_t j = 0 ; j<srcElementsPerPacket ; ++j)\n            buf.u8[srcElementsPerPacket-1-j] = (src<srcEnd) ? *src++ : 0;\n        for(size_t j = 0 ; j<dstElementsPerPacket ; ++j)\n        {\n            stop |= !(remainingDstElements--);\n            if (!stop)\n              *dst++ = static_cast<ushort>((buf.u64 >> (bitsPerPacket-(j+1)*packedBitsCount)) & packedBitsMask);\n        }\n    }//end while(!stop)\n}\n//end _unpack10To16()\n\nstatic void _unpack12To16(const uchar* src, const uchar* srcEnd, ushort* dst, ushort* dstEnd, size_t expectedDstElements)\n{\n  //3*8b=2*12b : 3 src for 2 dst\n  constexpr const size_t packedBitsCount = 12;\n  constexpr const size_t packedBitsMask = ((1<<packedBitsCount)-1);\n  constexpr const size_t srcElementsPerPacket = 3;\n  constexpr const size_t dstElementsPerPacket = 2;\n  constexpr const size_t bitsPerPacket = dstElementsPerPacket*packedBitsCount;\n  const size_t fullPacketsCount = std::min({\n    expectedDstElements/dstElementsPerPacket,\n    (static_cast<size_t>(srcEnd-src)/srcElementsPerPacket),\n    (static_cast<size_t>(dstEnd-dst)/dstElementsPerPacket)\n  });\n  union {\n      uint32_t u32;\n      uint8_t  u8[4];\n  } buf = {0};\n  for(size_t i = 0 ; i<fullPacketsCount ; ++i)\n  {\n      for(size_t j = 0 ; j<srcElementsPerPacket ; ++j)\n          buf.u8[srcElementsPerPacket-1-j] = *src++;\n      for(size_t j = 0 ; j<dstElementsPerPacket ; ++j)\n      {\n          dst[dstElementsPerPacket-1-j] = static_cast<ushort>(buf.u32 & packedBitsMask);\n          buf.u32 >>= packedBitsCount;\n      }\n      dst += dstElementsPerPacket;\n  }\n  size_t remainingDstElements = std::min(\n      expectedDstElements-fullPacketsCount*dstElementsPerPacket,\n      static_cast<size_t>(dstEnd-dst)\n  );\n  bool stop = !remainingDstElements;\n  while(!stop)\n  {\n      for(size_t j = 0 ; j<srcElementsPerPacket ; ++j)\n          buf.u8[srcElementsPerPacket-1-j] = (src<srcEnd) ? *src++ : 0;\n      for(size_t j = 0 ; j<dstElementsPerPacket ; ++j)\n      {\n          stop |= !(remainingDstElements--);\n          if (!stop)\n              *dst++ = static_cast<ushort>((buf.u32 >> (bitsPerPacket-(j+1)*packedBitsCount)) & packedBitsMask);\n      }\n  }//end while(!stop)\n}\n//end _unpack12To16()\n\nstatic void _unpack14To16(const uchar* src, const uchar* srcEnd, ushort* dst, ushort* dstEnd, size_t expectedDstElements)\n{\n    //7*8b=4*14b : 7 src for 4 dst\n    constexpr const size_t packedBitsCount = 14;\n    constexpr const size_t packedBitsMask = ((1<<packedBitsCount)-1);\n    constexpr const size_t srcElementsPerPacket = 7;\n    constexpr const size_t dstElementsPerPacket = 4;\n    constexpr const size_t bitsPerPacket = dstElementsPerPacket*packedBitsCount;\n    const size_t fullPacketsCount = std::min({\n      expectedDstElements/dstElementsPerPacket,\n      (static_cast<size_t>(srcEnd-src)/srcElementsPerPacket),\n      (static_cast<size_t>(dstEnd-dst)/dstElementsPerPacket)\n    });\n    union {\n        uint64_t u64;\n        uint8_t  u8[8];\n    } buf = {0};\n    for(size_t i = 0 ; i<fullPacketsCount ; ++i)\n    {\n        for(size_t j = 0 ; j<srcElementsPerPacket ; ++j)\n            buf.u8[srcElementsPerPacket-1-j] = *src++;\n        for(size_t j = 0 ; j<dstElementsPerPacket ; ++j)\n        {\n            dst[dstElementsPerPacket-1-j] = static_cast<ushort>(buf.u64 & packedBitsMask);\n            buf.u64 >>= packedBitsCount;\n        }\n        dst += dstElementsPerPacket;\n    }\n    size_t remainingDstElements = std::min(\n        expectedDstElements-fullPacketsCount*dstElementsPerPacket,\n        static_cast<size_t>(dstEnd-dst)\n    );\n    bool stop = !remainingDstElements;\n    while(!stop)\n    {\n        for(size_t j = 0 ; j<srcElementsPerPacket ; ++j)\n            buf.u8[srcElementsPerPacket-1-j] = (src<srcEnd) ? *src++ : 0;\n        for(size_t j = 0 ; j<dstElementsPerPacket ; ++j)\n        {\n            stop |= !(remainingDstElements--);\n            if (!stop)\n                *dst++ = static_cast<ushort>((buf.u64 >> (bitsPerPacket-(j+1)*packedBitsCount)) & packedBitsMask);\n        }\n    }//end while(!stop)\n}\n//end _unpack14To16()\n\nbool  TiffDecoder::readData( Mat& img )\n{\n    int type = img.type();\n    int depth = CV_MAT_DEPTH(type);\n\n    CV_Assert(!m_tif.empty());\n    TIFF* tif = (TIFF*)m_tif.get();\n\n    uint16 photometric = (uint16)-1;\n    CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric));\n\n    if (m_hdr && depth >= CV_32F)\n    {\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_FLOAT));\n    }\n\n    bool color = img.channels() > 1;\n\n    CV_CheckType(type, depth == CV_8U || depth == CV_8S || depth == CV_16U || depth == CV_16S || depth == CV_32S || depth == CV_32F || depth == CV_64F, \"\");\n\n    if (m_width && m_height)\n    {\n        int is_tiled = TIFFIsTiled(tif) != 0;\n        bool isGrayScale = photometric == PHOTOMETRIC_MINISWHITE || photometric == PHOTOMETRIC_MINISBLACK;\n        uint16 bpp = 8, ncn = isGrayScale ? 1 : 3;\n        if (0 == TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bpp))\n        {\n            // TIFF bi-level images don't require TIFFTAG_BITSPERSAMPLE tag\n            bpp = 1;\n        }\n        CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &ncn));\n        uint16 img_orientation = ORIENTATION_TOPLEFT;\n        CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_ORIENTATION, &img_orientation));\n        constexpr const int bitsPerByte = 8;\n        int dst_bpp = (int)(img.elemSize1() * bitsPerByte);\n        bool vert_flip = dst_bpp == 8 &&\n                        (img_orientation == ORIENTATION_BOTRIGHT || img_orientation == ORIENTATION_RIGHTBOT ||\n                         img_orientation == ORIENTATION_BOTLEFT || img_orientation == ORIENTATION_LEFTBOT);\n        int wanted_channels = normalizeChannelsNumber(img.channels());\n\n        if (dst_bpp == 8)\n        {\n            char errmsg[1024];\n            if (!TIFFRGBAImageOK(tif, errmsg))\n            {\n                CV_LOG_WARNING(NULL, \"OpenCV TIFF: TIFFRGBAImageOK: \" << errmsg);\n                close();\n                return false;\n            }\n        }\n\n        uint32 tile_width0 = m_width, tile_height0 = 0;\n\n        if (is_tiled)\n        {\n            CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_TILEWIDTH, &tile_width0));\n            CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_TILELENGTH, &tile_height0));\n        }\n        else\n        {\n            // optional\n            CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &tile_height0));\n        }\n\n        {\n            if (tile_width0 == 0)\n                tile_width0 = m_width;\n\n            if (tile_height0 == 0 ||\n                    (!is_tiled && tile_height0 == std::numeric_limits<uint32>::max()) )\n                tile_height0 = m_height;\n\n            const int TILE_MAX_WIDTH = (1 << 24);\n            const int TILE_MAX_HEIGHT = (1 << 24);\n            CV_Assert((int)tile_width0 > 0 && (int)tile_width0 <= TILE_MAX_WIDTH);\n            CV_Assert((int)tile_height0 > 0 && (int)tile_height0 <= TILE_MAX_HEIGHT);\n            const uint64_t MAX_TILE_SIZE = (CV_BIG_UINT(1) << 30);\n            CV_CheckLE((int)ncn, 4, \"\");\n            CV_CheckLE((int)bpp, 64, \"\");\n            CV_Assert(((uint64_t)tile_width0 * tile_height0 * ncn * std::max(1, (int)(bpp / bitsPerByte)) < MAX_TILE_SIZE) && \"TIFF tile size is too large: >= 1Gb\");\n\n            if (dst_bpp == 8)\n            {\n                // we will use TIFFReadRGBA* functions, so allocate temporary buffer for 32bit RGBA\n                bpp = 8;\n                ncn = 4;\n            }\n            else if (dst_bpp == 32 || dst_bpp == 64)\n            {\n                CV_Assert(ncn == img.channels());\n                CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP));\n            }\n            const size_t src_buffer_bytes_per_row = divUp(static_cast<size_t>(ncn * tile_width0 * bpp), static_cast<size_t>(bitsPerByte));\n            const size_t src_buffer_size = tile_height0 * src_buffer_bytes_per_row;\n            const size_t src_buffer_unpacked_bytes_per_row = divUp(static_cast<size_t>(ncn * tile_width0 * dst_bpp), static_cast<size_t>(bitsPerByte));\n            const size_t src_buffer_unpacked_size = tile_height0 * src_buffer_unpacked_bytes_per_row;\n            const bool needsUnpacking = (bpp < dst_bpp);\n            AutoBuffer<uchar> _src_buffer(src_buffer_size);\n            uchar* src_buffer = _src_buffer.data();\n            AutoBuffer<uchar> _src_buffer_unpacked(needsUnpacking ? src_buffer_unpacked_size : 0);\n            uchar* src_buffer_unpacked = needsUnpacking ? _src_buffer_unpacked.data() : nullptr;\n            int tileidx = 0;\n\n            for (int y = 0; y < m_height; y += (int)tile_height0)\n            {\n                int tile_height = std::min((int)tile_height0, m_height - y);\n\n                const int img_y = vert_flip ? m_height - y - tile_height : y;\n\n                for(int x = 0; x < m_width; x += (int)tile_width0, tileidx++)\n                {\n                    int tile_width = std::min((int)tile_width0, m_width - x);\n\n                    switch (dst_bpp)\n                    {\n                        case 8:\n                        {\n                            uchar* bstart = src_buffer;\n                            if (!is_tiled)\n                            {\n                                CV_TIFF_CHECK_CALL(TIFFReadRGBAStrip(tif, y, (uint32*)src_buffer));\n                            }\n                            else\n                            {\n                                CV_TIFF_CHECK_CALL(TIFFReadRGBATile(tif, x, y, (uint32*)src_buffer));\n                                // Tiles fill the buffer from the bottom up\n                                bstart += (tile_height0 - tile_height) * tile_width0 * 4;\n                            }\n\n                            for (int i = 0; i < tile_height; i++)\n                            {\n                                if (color)\n                                {\n                                    if (wanted_channels == 4)\n                                    {\n                                        icvCvt_BGRA2RGBA_8u_C4R(bstart + i*tile_width0*4, 0,\n                                                img.ptr(img_y + tile_height - i - 1, x), 0,\n                                                Size(tile_width, 1) );\n                                    }\n                                    else\n                                    {\n                                        CV_CheckEQ(wanted_channels, 3, \"TIFF-8bpp: BGR/BGRA images are supported only\");\n                                        icvCvt_BGRA2BGR_8u_C4C3R(bstart + i*tile_width0*4, 0,\n                                                img.ptr(img_y + tile_height - i - 1, x), 0,\n                                                Size(tile_width, 1), 2);\n                                    }\n                                }\n                                else\n                                {\n                                    CV_CheckEQ(wanted_channels, 1, \"\");\n                                    icvCvt_BGRA2Gray_8u_C4C1R( bstart + i*tile_width0*4, 0,\n                                            img.ptr(img_y + tile_height - i - 1, x), 0,\n                                            Size(tile_width, 1), 2);\n                                }\n                            }\n                            break;\n                        }\n\n                        case 16:\n                        {\n                            if (!is_tiled)\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedStrip(tif, tileidx, (uint32*)src_buffer, src_buffer_size) >= 0);\n                            }\n                            else\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedTile(tif, tileidx, (uint32*)src_buffer, src_buffer_size) >= 0);\n                            }\n\n                            for (int i = 0; i < tile_height; i++)\n                            {\n                                ushort* buffer16 = (ushort*)(src_buffer+i*src_buffer_bytes_per_row);\n                                if (needsUnpacking)\n                                {\n                                    const uchar* src_packed = src_buffer+i*src_buffer_bytes_per_row;\n                                    uchar* dst_unpacked = src_buffer_unpacked+i*src_buffer_unpacked_bytes_per_row;\n                                    if (bpp == 10)\n                                        _unpack10To16(src_packed, src_packed+src_buffer_bytes_per_row,\n                                                      (ushort*)dst_unpacked, (ushort*)(dst_unpacked+src_buffer_unpacked_bytes_per_row),\n                                                      ncn * tile_width0);\n                                    else if (bpp == 12)\n                                        _unpack12To16(src_packed, src_packed+src_buffer_bytes_per_row,\n                                                      (ushort*)dst_unpacked, (ushort*)(dst_unpacked+src_buffer_unpacked_bytes_per_row),\n                                                      ncn * tile_width0);\n                                    else if (bpp == 14)\n                                        _unpack14To16(src_packed, src_packed+src_buffer_bytes_per_row,\n                                                      (ushort*)dst_unpacked, (ushort*)(dst_unpacked+src_buffer_unpacked_bytes_per_row),\n                                                      ncn * tile_width0);\n                                    buffer16 = (ushort*)dst_unpacked;\n                                }\n\n                                if (color)\n                                {\n                                    if (ncn == 1)\n                                    {\n                                        CV_CheckEQ(wanted_channels, 3, \"\");\n                                        icvCvt_Gray2BGR_16u_C1C3R(buffer16, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1));\n                                    }\n                                    else if (ncn == 3)\n                                    {\n                                        CV_CheckEQ(wanted_channels, 3, \"\");\n                                        icvCvt_RGB2BGR_16u_C3R(buffer16, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1));\n                                    }\n                                    else if (ncn == 4)\n                                    {\n                                        if (wanted_channels == 4)\n                                        {\n                                            icvCvt_BGRA2RGBA_16u_C4R(buffer16, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1));\n                                        }\n                                        else\n                                        {\n                                            CV_CheckEQ(wanted_channels, 3, \"TIFF-16bpp: BGR/BGRA images are supported only\");\n                                            icvCvt_BGRA2BGR_16u_C4C3R(buffer16, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1), 2);\n                                        }\n                                    }\n                                    else\n                                    {\n                                        CV_Error(Error::StsError, \"Not supported\");\n                                    }\n                                }\n                                else\n                                {\n                                    CV_CheckEQ(wanted_channels, 1, \"\");\n                                    if( ncn == 1 )\n                                    {\n                                        memcpy(img.ptr<ushort>(img_y + i, x),\n                                               buffer16,\n                                               tile_width*sizeof(ushort));\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2Gray_16u_CnC1R(buffer16, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1), ncn, 2);\n                                    }\n                                }\n                            }\n                            break;\n                        }\n\n                        case 32:\n                        case 64:\n                        {\n                            if( !is_tiled )\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedStrip(tif, tileidx, src_buffer, src_buffer_size) >= 0);\n                            }\n                            else\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedTile(tif, tileidx, src_buffer, src_buffer_size) >= 0);\n                            }\n\n                            Mat m_tile(Size(tile_width0, tile_height0), CV_MAKETYPE((dst_bpp == 32) ? (depth == CV_32S ? CV_32S : CV_32F) : CV_64F, ncn), src_buffer);\n                            Rect roi_tile(0, 0, tile_width, tile_height);\n                            Rect roi_img(x, img_y, tile_width, tile_height);\n                            if (!m_hdr && ncn == 3)\n                                cvtColor(m_tile(roi_tile), img(roi_img), COLOR_RGB2BGR);\n                            else if (!m_hdr && ncn == 4)\n                                cvtColor(m_tile(roi_tile), img(roi_img), COLOR_RGBA2BGRA);\n                            else\n                                m_tile(roi_tile).copyTo(img(roi_img));\n                            break;\n                        }\n                        default:\n                        {\n                            CV_Assert(0 && \"OpenCV TIFF: unsupported depth\");\n                        }\n                    }  // switch (dst_bpp)\n                }  // for x\n            }  // for y\n        }\n        if (bpp < dst_bpp)\n          img *= (1<<(dst_bpp-bpp));\n        fixOrientation(img, img_orientation, dst_bpp);\n    }\n\n    if (m_hdr && depth >= CV_32F)\n    {\n        CV_Assert(photometric == PHOTOMETRIC_LOGLUV);\n        cvtColor(img, img, COLOR_XYZ2BGR);\n    }\n    return true;\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////\n\nTiffEncoder::TiffEncoder()\n{\n    m_description = \"TIFF Files (*.tiff;*.tif)\";\n    m_buf_supported = true;\n}\n\nTiffEncoder::~TiffEncoder()\n{\n}\n\nImageEncoder TiffEncoder::newEncoder() const\n{\n    return makePtr<TiffEncoder>();\n}\n\nbool TiffEncoder::isFormatSupported( int depth ) const\n{\n    return depth == CV_8U || depth == CV_8S || depth == CV_16U || depth == CV_16S || depth == CV_32S || depth == CV_32F || depth == CV_64F;\n}\n\nvoid  TiffEncoder::writeTag( WLByteStream& strm, TiffTag tag,\n                             TiffFieldType fieldType,\n                             int count, int value )\n{\n    strm.putWord( tag );\n    strm.putWord( fieldType );\n    strm.putDWord( count );\n    strm.putDWord( value );\n}\n\nclass TiffEncoderBufHelper\n{\npublic:\n\n    TiffEncoderBufHelper(std::vector<uchar> *buf)\n            : m_buf(buf), m_buf_pos(0)\n    {}\n\n    TIFF* open ()\n    {\n        // do NOT put \"wb\" as the mode, because the b means \"big endian\" mode, not \"binary\" mode.\n        // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n        return TIFFClientOpen( \"\", \"w\", reinterpret_cast<thandle_t>(this), &TiffEncoderBufHelper::read,\n                               &TiffEncoderBufHelper::write, &TiffEncoderBufHelper::seek,\n                               &TiffEncoderBufHelper::close, &TiffEncoderBufHelper::size,\n                               /*map=*/0, /*unmap=*/0 );\n    }\n\n    static tmsize_t read( thandle_t /*handle*/, void* /*buffer*/, tmsize_t /*n*/ )\n    {\n        // Not used for encoding.\n        return 0;\n    }\n\n    static tmsize_t write( thandle_t handle, void* buffer, tmsize_t n )\n    {\n        TiffEncoderBufHelper *helper = reinterpret_cast<TiffEncoderBufHelper*>(handle);\n        size_t begin = (size_t)helper->m_buf_pos;\n        size_t end = begin + n;\n        if ( helper->m_buf->size() < end )\n        {\n            helper->m_buf->resize(end);\n        }\n        memcpy(&(*helper->m_buf)[begin], buffer, n);\n        helper->m_buf_pos = end;\n        return n;\n    }\n\n    static toff_t seek( thandle_t handle, toff_t offset, int whence )\n    {\n        TiffEncoderBufHelper *helper = reinterpret_cast<TiffEncoderBufHelper*>(handle);\n        const toff_t size = helper->m_buf->size();\n        toff_t new_pos = helper->m_buf_pos;\n        switch (whence)\n        {\n            case SEEK_SET:\n                new_pos = offset;\n                break;\n            case SEEK_CUR:\n                new_pos += offset;\n                break;\n            case SEEK_END:\n                new_pos = size + offset;\n                break;\n        }\n        helper->m_buf_pos = new_pos;\n        return new_pos;\n    }\n\n    static toff_t size( thandle_t handle )\n    {\n        TiffEncoderBufHelper *helper = reinterpret_cast<TiffEncoderBufHelper*>(handle);\n        return helper->m_buf->size();\n    }\n\n    static int close( thandle_t /*handle*/ )\n    {\n        // Do nothing.\n        return 0;\n    }\n\nprivate:\n\n    std::vector<uchar>* m_buf;\n    toff_t m_buf_pos;\n};\n\nstatic bool readParam(const std::vector<int>& params, int key, int& value)\n{\n    for (size_t i = 0; i + 1 < params.size(); i += 2)\n    {\n        if (params[i] == key)\n        {\n            value = params[i + 1];\n            return true;\n        }\n    }\n    return false;\n}\n\nbool TiffEncoder::writeLibTiff( const std::vector<Mat>& img_vec, const std::vector<int>& params)\n{\n    // do NOT put \"wb\" as the mode, because the b means \"big endian\" mode, not \"binary\" mode.\n    // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n    TIFF* tif = NULL;\n\n    TiffEncoderBufHelper buf_helper(m_buf);\n    if ( m_buf )\n    {\n        tif = buf_helper.open();\n    }\n    else\n    {\n        tif = TIFFOpen(m_filename.c_str(), \"w\");\n    }\n    if (!tif)\n    {\n        return false;\n    }\n    cv::Ptr<void> tif_cleanup(tif, cv_tiffCloseHandle);\n\n    //Settings that matter to all images\n    int compression = COMPRESSION_LZW;\n    int predictor = PREDICTOR_HORIZONTAL;\n    int resUnit = -1, dpiX = -1, dpiY = -1;\n\n    readParam(params, IMWRITE_TIFF_COMPRESSION, compression);\n    readParam(params, TIFFTAG_PREDICTOR, predictor);\n    readParam(params, IMWRITE_TIFF_RESUNIT, resUnit);\n    readParam(params, IMWRITE_TIFF_XDPI, dpiX);\n    readParam(params, IMWRITE_TIFF_YDPI, dpiY);\n\n    //Iterate through each image in the vector and write them out as Tiff directories\n    for (size_t page = 0; page < img_vec.size(); page++)\n    {\n        const Mat& img = img_vec[page];\n        CV_Assert(!img.empty());\n        int channels = img.channels();\n        int width = img.cols, height = img.rows;\n        int type = img.type();\n        int depth = CV_MAT_DEPTH(type);\n        CV_CheckType(type, depth == CV_8U || depth == CV_8S || depth == CV_16U || depth == CV_16S || depth == CV_32S || depth == CV_32F || depth == CV_64F, \"\");\n        CV_CheckType(type, channels >= 1 && channels <= 4, \"\");\n\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, width));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_IMAGELENGTH, height));\n\n        if (img_vec.size() > 1)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE));\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PAGENUMBER, page, img_vec.size()));\n        }\n\n        int compression_param = -1;  // OPENCV_FUTURE\n        if (type == CV_32FC3 && (!readParam(params, IMWRITE_TIFF_COMPRESSION, compression_param) || compression_param == COMPRESSION_SGILOG))\n        {\n            if (!write_32FC3_SGILOG(img, tif))\n                return false;\n            continue;\n        }\n\n        int page_compression = compression;\n\n        int bitsPerChannel = -1;\n        uint16 sample_format = SAMPLEFORMAT_INT;\n        switch (depth)\n        {\n            case CV_8U:\n                sample_format = SAMPLEFORMAT_UINT;\n                /* FALLTHRU */\n            case CV_8S:\n            {\n                bitsPerChannel = 8;\n                break;\n            }\n\n            case CV_16U:\n                sample_format = SAMPLEFORMAT_UINT;\n                /* FALLTHRU */\n            case CV_16S:\n            {\n                bitsPerChannel = 16;\n                break;\n            }\n\n            case CV_32F:\n                sample_format = SAMPLEFORMAT_IEEEFP;\n                /* FALLTHRU */\n            case CV_32S:\n            {\n                bitsPerChannel = 32;\n                page_compression = COMPRESSION_NONE;\n                break;\n            }\n            case CV_64F:\n            {\n                bitsPerChannel = 64;\n                page_compression = COMPRESSION_NONE;\n                sample_format = SAMPLEFORMAT_IEEEFP;\n                break;\n            }\n            default:\n            {\n                return false;\n            }\n        }\n\n        const int bitsPerByte = 8;\n        size_t fileStep = (width * channels * bitsPerChannel) / bitsPerByte;\n        CV_Assert(fileStep > 0);\n\n        int rowsPerStrip = (int)((1 << 13) / fileStep);\n        readParam(params, TIFFTAG_ROWSPERSTRIP, rowsPerStrip);\n        rowsPerStrip = std::max(1, std::min(height, rowsPerStrip));\n\n        int colorspace = channels > 1 ? PHOTOMETRIC_RGB : PHOTOMETRIC_MINISBLACK;\n\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, bitsPerChannel));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_COMPRESSION, page_compression));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, colorspace));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, channels));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, rowsPerStrip));\n\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, sample_format));\n\n        if (page_compression == COMPRESSION_LZW || page_compression == COMPRESSION_ADOBE_DEFLATE || page_compression == COMPRESSION_DEFLATE)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PREDICTOR, predictor));\n        }\n\n        if (resUnit >= RESUNIT_NONE && resUnit <= RESUNIT_CENTIMETER)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_RESOLUTIONUNIT, resUnit));\n        }\n        if (dpiX >= 0)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_XRESOLUTION, (float)dpiX));\n        }\n        if (dpiY >= 0)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_YRESOLUTION, (float)dpiY));\n        }\n\n        // row buffer, because TIFFWriteScanline modifies the original data!\n        size_t scanlineSize = TIFFScanlineSize(tif);\n        AutoBuffer<uchar> _buffer(scanlineSize + 32);\n        uchar* buffer = _buffer.data(); CV_DbgAssert(buffer);\n        Mat m_buffer(Size(width, 1), CV_MAKETYPE(depth, channels), buffer, (size_t)scanlineSize);\n\n        for (int y = 0; y < height; ++y)\n        {\n            switch (channels)\n            {\n                case 1:\n                {\n                    memcpy(buffer, img.ptr(y), scanlineSize);\n                    break;\n                }\n\n                case 3:\n                {\n                    cvtColor(img(Rect(0, y, width, 1)), (const Mat&)m_buffer, COLOR_BGR2RGB);\n                    break;\n                }\n\n                case 4:\n                {\n                    cvtColor(img(Rect(0, y, width, 1)), (const Mat&)m_buffer, COLOR_BGRA2RGBA);\n                    break;\n                }\n\n                default:\n                {\n                    CV_Assert(0);\n                }\n            }\n\n            CV_TIFF_CHECK_CALL(TIFFWriteScanline(tif, buffer, y, 0) == 1);\n        }\n\n        CV_TIFF_CHECK_CALL(TIFFWriteDirectory(tif));\n    }\n\n    return true;\n}\n\nbool TiffEncoder::write_32FC3_SGILOG(const Mat& _img, void* tif_)\n{\n    TIFF* tif = (TIFF*)tif_;\n    CV_Assert(tif);\n\n    Mat img;\n    cvtColor(_img, img, COLOR_BGR2XYZ);\n\n    //done by caller: CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, img.cols));\n    //done by caller: CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_IMAGELENGTH, img.rows));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 3));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 32));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_SGILOG));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_LOGLUV));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_FLOAT));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, 1));\n    const int strip_size = 3 * img.cols;\n    for (int i = 0; i < img.rows; i++)\n    {\n        CV_TIFF_CHECK_CALL(TIFFWriteEncodedStrip(tif, i, (tdata_t)img.ptr<float>(i), strip_size * sizeof(float)) != (tsize_t)-1);\n    }\n    CV_TIFF_CHECK_CALL(TIFFWriteDirectory(tif));\n    return true;\n}\n\nbool TiffEncoder::writemulti(const std::vector<Mat>& img_vec, const std::vector<int>& params)\n{\n    return writeLibTiff(img_vec, params);\n}\n\nbool  TiffEncoder::write( const Mat& img, const std::vector<int>& params)\n{\n    int type = img.type();\n    int depth = CV_MAT_DEPTH(type);\n\n    CV_CheckType(type, depth == CV_8U || depth == CV_8S || depth == CV_16U || depth == CV_16S || depth == CV_32S || depth == CV_32F || depth == CV_64F, \"\");\n\n    std::vector<Mat> img_vec;\n    img_vec.push_back(img);\n    return writeLibTiff(img_vec, params);\n}\n\n} // namespace\n\n#endif\n",
                "name": "grfmt_tiff.cpp",
                "path": "my_android_opencv/modules/imgcodecs/src/grfmt_tiff.cpp",
                "url": "/github.com/BigWhite666/UE4ImguiDumper/-/blob/my_android_opencv/modules/imgcodecs/src/grfmt_tiff.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 719,
                    "offsetAndLengths": [
                        [
                            51,
                            16
                        ]
                    ],
                    "preview": "                                CV_TIFF_CHECK_CALL(TIFFReadRGBATile(tif, x, y, (uint32*)src_buffer));"
                }
            ],
            "repository": {
                "name": "github.com/BigWhite666/UE4ImguiDumper",
                "url": "/github.com/BigWhite666/UE4ImguiDumper"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "481c2dc02f06ebe12f28b5a1432fa00581104270"
                },
                "content": "/*M///////////////////////////////////////////////////////////////////////////////////////\n//\n//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.\n//\n//  By downloading, copying, installing or using the software you agree to this license.\n//  If you do not agree to this license, do not download, install,\n//  copy or use the software.\n//\n//\n//                           License Agreement\n//                For Open Source Computer Vision Library\n//\n// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.\n// Copyright (C) 2009, Willow Garage Inc., all rights reserved.\n// Third party copyrights are property of their respective owners.\n//\n// Redistribution and use in source and binary forms, with or without modification,\n// are permitted provided that the following conditions are met:\n//\n//   * Redistribution's of source code must retain the above copyright notice,\n//     this list of conditions and the following disclaimer.\n//\n//   * Redistribution's in binary form must reproduce the above copyright notice,\n//     this list of conditions and the following disclaimer in the documentation\n//     and/or other materials provided with the distribution.\n//\n//   * The name of the copyright holders may not be used to endorse or promote products\n//     derived from this software without specific prior written permission.\n//\n// This software is provided by the copyright holders and contributors \"as is\" and\n// any express or implied warranties, including, but not limited to, the implied\n// warranties of merchantability and fitness for a particular purpose are disclaimed.\n// In no event shall the Intel Corporation or contributors be liable for any direct,\n// indirect, incidental, special, exemplary, or consequential damages\n// (including, but not limited to, procurement of substitute goods or services;\n// loss of use, data, or profits; or business interruption) however caused\n// and on any theory of liability, whether in contract, strict liability,\n// or tort (including negligence or otherwise) arising in any way out of\n// the use of this software, even if advised of the possibility of such damage.\n//\n//M*/\n\n/****************************************************************************************\\\n    A part of the file implements TIFF reader on base of libtiff library\n    (see otherlibs/_graphics/readme.txt for copyright notice)\n\\****************************************************************************************/\n\n#include \"precomp.hpp\"\n\n#ifdef HAVE_TIFF\n#include <opencv2/core/utils/logger.hpp>\n\n#include \"grfmt_tiff.hpp\"\n#include <limits>\n\n// TODO FIXIT Conflict declarations for common types like int64/uint64\nnamespace tiff_dummy_namespace {\n#include \"tiff.h\"\n#include \"tiffio.h\"\n}\nusing namespace tiff_dummy_namespace;\n\nnamespace cv\n{\n\n#define CV_TIFF_CHECK_CALL(call) \\\n    if (0 == (call)) { \\\n        CV_LOG_WARNING(NULL, \"OpenCV TIFF(line \" << __LINE__ << \"): failed \" #call); \\\n        CV_Error(Error::StsError, \"OpenCV TIFF: failed \" #call); \\\n    }\n\n#define CV_TIFF_CHECK_CALL_INFO(call) \\\n    if (0 == (call)) { \\\n        CV_LOG_INFO(NULL, \"OpenCV TIFF(line \" << __LINE__ << \"): failed optional call: \" #call \", ignoring\"); \\\n    }\n\n#define CV_TIFF_CHECK_CALL_DEBUG(call) \\\n    if (0 == (call)) { \\\n        CV_LOG_DEBUG(NULL, \"OpenCV TIFF(line \" << __LINE__ << \"): failed optional call: \" #call \", ignoring\"); \\\n    }\n\nstatic void cv_tiffCloseHandle(void* handle)\n{\n    TIFFClose((TIFF*)handle);\n}\n\nstatic void cv_tiffErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    if (cv::utils::logging::getLogLevel() < cv::utils::logging::LOG_LEVEL_DEBUG)\n        return;\n    // TODO cv::vformat() with va_list parameter\n    fprintf(stderr, \"OpenCV TIFF: \");\n    if (module != NULL)\n        fprintf(stderr, \"%s: \", module);\n    fprintf(stderr, \"Warning, \");\n    vfprintf(stderr, fmt, ap);\n    fprintf(stderr, \".\\n\");\n}\n\nstatic bool cv_tiffSetErrorHandler_()\n{\n    TIFFSetErrorHandler(cv_tiffErrorHandler);\n    TIFFSetWarningHandler(cv_tiffErrorHandler);\n    return true;\n}\n\nstatic bool cv_tiffSetErrorHandler()\n{\n    static bool v = cv_tiffSetErrorHandler_();\n    return v;\n}\n\nstatic const char fmtSignTiffII[] = \"II\\x2a\\x00\";\nstatic const char fmtSignTiffMM[] = \"MM\\x00\\x2a\";\n\nTiffDecoder::TiffDecoder()\n{\n    m_hdr = false;\n    m_buf_supported = true;\n    m_buf_pos = 0;\n}\n\n\nvoid TiffDecoder::close()\n{\n    m_tif.release();\n}\n\nTiffDecoder::~TiffDecoder()\n{\n    close();\n}\n\nsize_t TiffDecoder::signatureLength() const\n{\n    return 4;\n}\n\nbool TiffDecoder::checkSignature( const String& signature ) const\n{\n    return signature.size() >= 4 &&\n        (memcmp(signature.c_str(), fmtSignTiffII, 4) == 0 ||\n        memcmp(signature.c_str(), fmtSignTiffMM, 4) == 0);\n}\n\nint TiffDecoder::normalizeChannelsNumber(int channels) const\n{\n    CV_Assert(channels <= 4);\n    return channels > 4 ? 4 : channels;\n}\n\nImageDecoder TiffDecoder::newDecoder() const\n{\n    cv_tiffSetErrorHandler();\n    return makePtr<TiffDecoder>();\n}\n\nclass TiffDecoderBufHelper\n{\n    Mat& m_buf;\n    size_t& m_buf_pos;\npublic:\n    TiffDecoderBufHelper(Mat& buf, size_t& buf_pos) :\n        m_buf(buf), m_buf_pos(buf_pos)\n    {}\n    static tmsize_t read( thandle_t handle, void* buffer, tmsize_t n )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        const Mat& buf = helper->m_buf;\n        const tmsize_t size = buf.cols*buf.rows*buf.elemSize();\n        tmsize_t pos = helper->m_buf_pos;\n        if ( n > (size - pos) )\n        {\n            n = size - pos;\n        }\n        memcpy(buffer, buf.ptr() + pos, n);\n        helper->m_buf_pos += n;\n        return n;\n    }\n\n    static tmsize_t write( thandle_t /*handle*/, void* /*buffer*/, tmsize_t /*n*/ )\n    {\n        // Not used for decoding.\n        return 0;\n    }\n\n    static toff_t seek( thandle_t handle, toff_t offset, int whence )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        const Mat& buf = helper->m_buf;\n        const toff_t size = buf.cols*buf.rows*buf.elemSize();\n        toff_t new_pos = helper->m_buf_pos;\n        switch (whence)\n        {\n            case SEEK_SET:\n                new_pos = offset;\n                break;\n            case SEEK_CUR:\n                new_pos += offset;\n                break;\n            case SEEK_END:\n                new_pos = size + offset;\n                break;\n        }\n        new_pos = std::min(new_pos, size);\n        helper->m_buf_pos = (size_t)new_pos;\n        return new_pos;\n    }\n\n    static int map( thandle_t handle, void** base, toff_t* size )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        Mat& buf = helper->m_buf;\n        *base = buf.ptr();\n        *size = buf.cols*buf.rows*buf.elemSize();\n        return 0;\n    }\n\n    static toff_t size( thandle_t handle )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        const Mat& buf = helper->m_buf;\n        return buf.cols*buf.rows*buf.elemSize();\n    }\n\n    static int close( thandle_t handle )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        delete helper;\n        return 0;\n    }\n};\n\nbool TiffDecoder::readHeader()\n{\n    bool result = false;\n\n    TIFF* tif = static_cast<TIFF*>(m_tif.get());\n    if (!tif)\n    {\n        // TIFFOpen() mode flags are different to fopen().  A 'b' in mode \"rb\" has no effect when reading.\n        // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n        if ( !m_buf.empty() )\n        {\n            m_buf_pos = 0;\n            TiffDecoderBufHelper* buf_helper = new TiffDecoderBufHelper(this->m_buf, this->m_buf_pos);\n            tif = TIFFClientOpen( \"\", \"r\", reinterpret_cast<thandle_t>(buf_helper), &TiffDecoderBufHelper::read,\n                                  &TiffDecoderBufHelper::write, &TiffDecoderBufHelper::seek,\n                                  &TiffDecoderBufHelper::close, &TiffDecoderBufHelper::size,\n                                  &TiffDecoderBufHelper::map, /*unmap=*/0 );\n            if (!tif)\n                delete buf_helper;\n        }\n        else\n        {\n            tif = TIFFOpen(m_filename.c_str(), \"r\");\n        }\n        if (tif)\n            m_tif.reset(tif, cv_tiffCloseHandle);\n        else\n            m_tif.release();\n    }\n\n    if (tif)\n    {\n        uint32 wdth = 0, hght = 0;\n        uint16 photometric = 0;\n\n        CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &wdth));\n        CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &hght));\n        CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric));\n\n        {\n            bool isGrayScale = photometric == PHOTOMETRIC_MINISWHITE || photometric == PHOTOMETRIC_MINISBLACK;\n            uint16 bpp = 8, ncn = isGrayScale ? 1 : 3;\n            CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bpp));\n            CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &ncn));\n\n            m_width = wdth;\n            m_height = hght;\n            if (ncn == 3 && photometric == PHOTOMETRIC_LOGLUV)\n            {\n                m_type = CV_32FC3;\n                m_hdr = true;\n                return true;\n            }\n            m_hdr = false;\n\n            if( bpp > 8 &&\n               ((photometric > 2) ||\n                (ncn != 1 && ncn != 3 && ncn != 4)))\n                bpp = 8;\n\n            int wanted_channels = normalizeChannelsNumber(ncn);\n            switch(bpp)\n            {\n                case 1:\n                    m_type = CV_MAKETYPE(CV_8U, !isGrayScale ? wanted_channels : 1);\n                    result = true;\n                    break;\n                case 8:\n                    m_type = CV_MAKETYPE(CV_8U, !isGrayScale ? wanted_channels : 1);\n                    result = true;\n                    break;\n                case 16:\n                    m_type = CV_MAKETYPE(CV_16U, !isGrayScale ? wanted_channels : 1);\n                    result = true;\n                    break;\n                case 32:\n                    m_type = CV_MAKETYPE(CV_32F, wanted_channels);\n                    result = true;\n                    break;\n                case 64:\n                    m_type = CV_MAKETYPE(CV_64F, wanted_channels);\n                    result = true;\n                    break;\n            default:\n                CV_Error(cv::Error::StsError, \"Invalid bitsperpixel value read from TIFF header! Must be 1, 8, 16, 32 or 64.\");\n            }\n        }\n    }\n\n    if( !result )\n        close();\n\n    return result;\n}\n\nbool TiffDecoder::nextPage()\n{\n    // Prepare the next page, if any.\n    return !m_tif.empty() &&\n           TIFFReadDirectory(static_cast<TIFF*>(m_tif.get())) &&\n           readHeader();\n}\n\nstatic void fixOrientationPartial(Mat &img, uint16 orientation)\n{\n    switch(orientation) {\n        case ORIENTATION_RIGHTTOP:\n        case ORIENTATION_LEFTBOT:\n            flip(img, img, -1);\n            /* fall through */\n\n        case ORIENTATION_LEFTTOP:\n        case ORIENTATION_RIGHTBOT:\n            transpose(img, img);\n            break;\n    }\n}\n\nstatic void fixOrientationFull(Mat &img, int orientation)\n{\n    switch(orientation) {\n        case ORIENTATION_TOPRIGHT:\n            flip(img, img, 1);\n            break;\n\n        case ORIENTATION_BOTRIGHT:\n            flip(img, img, -1);\n            break;\n\n        case ORIENTATION_BOTLEFT:\n            flip(img, img, 0);\n            break;\n\n        case ORIENTATION_LEFTTOP:\n            transpose(img, img);\n            break;\n\n        case ORIENTATION_RIGHTTOP:\n            transpose(img, img);\n            flip(img, img, 1);\n            break;\n\n        case ORIENTATION_RIGHTBOT:\n            transpose(img, img);\n            flip(img, img, -1);\n            break;\n\n        case ORIENTATION_LEFTBOT:\n            transpose(img, img);\n            flip(img, img, 0);\n            break;\n    }\n}\n\n/**\n * Fix orientation defined in tag 274.\n * For 8 bit some corrections are done by TIFFReadRGBAStrip/Tile already.\n * Not so for 16/32/64 bit.\n */\nstatic void fixOrientation(Mat &img, uint16 orientation, int dst_bpp)\n{\n    switch(dst_bpp) {\n        case 8:\n            fixOrientationPartial(img, orientation);\n            break;\n\n        case 16:\n        case 32:\n        case 64:\n            fixOrientationFull(img, orientation);\n            break;\n    }\n}\n\nbool  TiffDecoder::readData( Mat& img )\n{\n    int type = img.type();\n    int depth = CV_MAT_DEPTH(type);\n\n    CV_Assert(!m_tif.empty());\n    TIFF* tif = (TIFF*)m_tif.get();\n\n    uint16 photometric = (uint16)-1;\n    CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric));\n\n    if (m_hdr && depth >= CV_32F)\n    {\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_FLOAT));\n    }\n\n    bool color = img.channels() > 1;\n\n    CV_CheckType(type, depth == CV_8U || depth == CV_16U || depth == CV_32F || depth == CV_64F, \"\");\n\n    if (m_width && m_height)\n    {\n        int is_tiled = TIFFIsTiled(tif) != 0;\n        bool isGrayScale = photometric == PHOTOMETRIC_MINISWHITE || photometric == PHOTOMETRIC_MINISBLACK;\n        uint16 bpp = 8, ncn = isGrayScale ? 1 : 3;\n        CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bpp));\n        CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &ncn));\n        uint16 img_orientation = ORIENTATION_TOPLEFT;\n        CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_ORIENTATION, &img_orientation));\n        const int bitsPerByte = 8;\n        int dst_bpp = (int)(img.elemSize1() * bitsPerByte);\n        bool vert_flip = dst_bpp == 8 &&\n                        (img_orientation == ORIENTATION_BOTRIGHT || img_orientation == ORIENTATION_RIGHTBOT ||\n                         img_orientation == ORIENTATION_BOTLEFT || img_orientation == ORIENTATION_LEFTBOT);\n        int wanted_channels = normalizeChannelsNumber(img.channels());\n\n        if (dst_bpp == 8)\n        {\n            char errmsg[1024];\n            if (!TIFFRGBAImageOK(tif, errmsg))\n            {\n                CV_LOG_WARNING(NULL, \"OpenCV TIFF: TIFFRGBAImageOK: \" << errmsg);\n                close();\n                return false;\n            }\n        }\n\n        uint32 tile_width0 = m_width, tile_height0 = 0;\n\n        if (is_tiled)\n        {\n            CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_TILEWIDTH, &tile_width0));\n            CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_TILELENGTH, &tile_height0));\n        }\n        else\n        {\n            // optional\n            CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &tile_height0));\n        }\n\n        {\n            if (tile_width0 == 0)\n                tile_width0 = m_width;\n\n            if (tile_height0 == 0 ||\n                    (!is_tiled && tile_height0 == std::numeric_limits<uint32>::max()) )\n                tile_height0 = m_height;\n\n            const int TILE_MAX_WIDTH = (1 << 24);\n            const int TILE_MAX_HEIGHT = (1 << 24);\n            CV_Assert((int)tile_width0 > 0 && (int)tile_width0 <= TILE_MAX_WIDTH);\n            CV_Assert((int)tile_height0 > 0 && (int)tile_height0 <= TILE_MAX_HEIGHT);\n            const uint64_t MAX_TILE_SIZE = (CV_BIG_UINT(1) << 30);\n            CV_CheckLE((int)ncn, 4, \"\");\n            CV_CheckLE((int)bpp, 64, \"\");\n            CV_Assert(((uint64_t)tile_width0 * tile_height0 * ncn * std::max(1, (int)(bpp / bitsPerByte)) < MAX_TILE_SIZE) && \"TIFF tile size is too large: >= 1Gb\");\n\n            if (dst_bpp == 8)\n            {\n                // we will use TIFFReadRGBA* functions, so allocate temporary buffer for 32bit RGBA\n                bpp = 8;\n                ncn = 4;\n            }\n            else if (dst_bpp == 32 || dst_bpp == 64)\n            {\n                CV_Assert(ncn == img.channels());\n                CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP));\n            }\n            const size_t buffer_size = (bpp / bitsPerByte) * ncn * tile_height0 * tile_width0;\n            AutoBuffer<uchar> _buffer(buffer_size);\n            uchar* buffer = _buffer.data();\n            ushort* buffer16 = (ushort*)buffer;\n            int tileidx = 0;\n\n            for (int y = 0; y < m_height; y += (int)tile_height0)\n            {\n                int tile_height = std::min((int)tile_height0, m_height - y);\n\n                const int img_y = vert_flip ? m_height - y - tile_height : y;\n\n                for(int x = 0; x < m_width; x += (int)tile_width0, tileidx++)\n                {\n                    int tile_width = std::min((int)tile_width0, m_width - x);\n\n                    switch (dst_bpp)\n                    {\n                        case 8:\n                        {\n                            uchar* bstart = buffer;\n                            if (!is_tiled)\n                            {\n                                CV_TIFF_CHECK_CALL(TIFFReadRGBAStrip(tif, y, (uint32*)buffer));\n                            }\n                            else\n                            {\n                                CV_TIFF_CHECK_CALL(TIFFReadRGBATile(tif, x, y, (uint32*)buffer));\n                                // Tiles fill the buffer from the bottom up\n                                bstart += (tile_height0 - tile_height) * tile_width0 * 4;\n                            }\n\n                            for (int i = 0; i < tile_height; i++)\n                            {\n                                if (color)\n                                {\n                                    if (wanted_channels == 4)\n                                    {\n                                        icvCvt_BGRA2RGBA_8u_C4R(bstart + i*tile_width0*4, 0,\n                                                img.ptr(img_y + tile_height - i - 1, x), 0,\n                                                Size(tile_width, 1) );\n                                    }\n                                    else\n                                    {\n                                        CV_CheckEQ(wanted_channels, 3, \"TIFF-8bpp: BGR/BGRA images are supported only\");\n                                        icvCvt_BGRA2BGR_8u_C4C3R(bstart + i*tile_width0*4, 0,\n                                                img.ptr(img_y + tile_height - i - 1, x), 0,\n                                                Size(tile_width, 1), 2);\n                                    }\n                                }\n                                else\n                                {\n                                    CV_CheckEQ(wanted_channels, 1, \"\");\n                                    icvCvt_BGRA2Gray_8u_C4C1R( bstart + i*tile_width0*4, 0,\n                                            img.ptr(img_y + tile_height - i - 1, x), 0,\n                                            Size(tile_width, 1), 2);\n                                }\n                            }\n                            break;\n                        }\n\n                        case 16:\n                        {\n                            if (!is_tiled)\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedStrip(tif, tileidx, (uint32*)buffer, buffer_size) >= 0);\n                            }\n                            else\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedTile(tif, tileidx, (uint32*)buffer, buffer_size) >= 0);\n                            }\n\n                            for (int i = 0; i < tile_height; i++)\n                            {\n                                if (color)\n                                {\n                                    if (ncn == 1)\n                                    {\n                                        CV_CheckEQ(wanted_channels, 3, \"\");\n                                        icvCvt_Gray2BGR_16u_C1C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1));\n                                    }\n                                    else if (ncn == 3)\n                                    {\n                                        CV_CheckEQ(wanted_channels, 3, \"\");\n                                        icvCvt_RGB2BGR_16u_C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1));\n                                    }\n                                    else if (ncn == 4)\n                                    {\n                                        if (wanted_channels == 4)\n                                        {\n                                            icvCvt_BGRA2RGBA_16u_C4R(buffer16 + i*tile_width0*ncn, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1));\n                                        }\n                                        else\n                                        {\n                                            CV_CheckEQ(wanted_channels, 3, \"TIFF-16bpp: BGR/BGRA images are supported only\");\n                                            icvCvt_BGRA2BGR_16u_C4C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1), 2);\n                                        }\n                                    }\n                                    else\n                                    {\n                                        CV_Error(Error::StsError, \"Not supported\");\n                                    }\n                                }\n                                else\n                                {\n                                    CV_CheckEQ(wanted_channels, 1, \"\");\n                                    if( ncn == 1 )\n                                    {\n                                        memcpy(img.ptr<ushort>(img_y + i, x),\n                                               buffer16 + i*tile_width0*ncn,\n                                               tile_width*sizeof(ushort));\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2Gray_16u_CnC1R(buffer16 + i*tile_width0*ncn, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1), ncn, 2);\n                                    }\n                                }\n                            }\n                            break;\n                        }\n\n                        case 32:\n                        case 64:\n                        {\n                            if( !is_tiled )\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedStrip(tif, tileidx, buffer, buffer_size) >= 0);\n                            }\n                            else\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedTile(tif, tileidx, buffer, buffer_size) >= 0);\n                            }\n\n                            Mat m_tile(Size(tile_width0, tile_height0), CV_MAKETYPE((dst_bpp == 32) ? CV_32F : CV_64F, ncn), buffer);\n                            Rect roi_tile(0, 0, tile_width, tile_height);\n                            Rect roi_img(x, img_y, tile_width, tile_height);\n                            if (!m_hdr && ncn == 3)\n                                cvtColor(m_tile(roi_tile), img(roi_img), COLOR_RGB2BGR);\n                            else if (!m_hdr && ncn == 4)\n                                cvtColor(m_tile(roi_tile), img(roi_img), COLOR_RGBA2BGRA);\n                            else\n                                m_tile(roi_tile).copyTo(img(roi_img));\n                            break;\n                        }\n                        default:\n                        {\n                            CV_Assert(0 && \"OpenCV TIFF: unsupported depth\");\n                        }\n                    }  // switch (dst_bpp)\n                }  // for x\n            }  // for y\n        }\n        fixOrientation(img, img_orientation, dst_bpp);\n    }\n\n    if (m_hdr && depth >= CV_32F)\n    {\n        CV_Assert(photometric == PHOTOMETRIC_LOGLUV);\n        cvtColor(img, img, COLOR_XYZ2BGR);\n    }\n    return true;\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////\n\nTiffEncoder::TiffEncoder()\n{\n    m_description = \"TIFF Files (*.tiff;*.tif)\";\n    m_buf_supported = true;\n}\n\nTiffEncoder::~TiffEncoder()\n{\n}\n\nImageEncoder TiffEncoder::newEncoder() const\n{\n    return makePtr<TiffEncoder>();\n}\n\nbool TiffEncoder::isFormatSupported( int depth ) const\n{\n    return depth == CV_8U || depth == CV_16U || depth == CV_32F || depth == CV_64F;\n}\n\nvoid  TiffEncoder::writeTag( WLByteStream& strm, TiffTag tag,\n                             TiffFieldType fieldType,\n                             int count, int value )\n{\n    strm.putWord( tag );\n    strm.putWord( fieldType );\n    strm.putDWord( count );\n    strm.putDWord( value );\n}\n\nclass TiffEncoderBufHelper\n{\npublic:\n\n    TiffEncoderBufHelper(std::vector<uchar> *buf)\n            : m_buf(buf), m_buf_pos(0)\n    {}\n\n    TIFF* open ()\n    {\n        // do NOT put \"wb\" as the mode, because the b means \"big endian\" mode, not \"binary\" mode.\n        // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n        return TIFFClientOpen( \"\", \"w\", reinterpret_cast<thandle_t>(this), &TiffEncoderBufHelper::read,\n                               &TiffEncoderBufHelper::write, &TiffEncoderBufHelper::seek,\n                               &TiffEncoderBufHelper::close, &TiffEncoderBufHelper::size,\n                               /*map=*/0, /*unmap=*/0 );\n    }\n\n    static tmsize_t read( thandle_t /*handle*/, void* /*buffer*/, tmsize_t /*n*/ )\n    {\n        // Not used for encoding.\n        return 0;\n    }\n\n    static tmsize_t write( thandle_t handle, void* buffer, tmsize_t n )\n    {\n        TiffEncoderBufHelper *helper = reinterpret_cast<TiffEncoderBufHelper*>(handle);\n        size_t begin = (size_t)helper->m_buf_pos;\n        size_t end = begin + n;\n        if ( helper->m_buf->size() < end )\n        {\n            helper->m_buf->resize(end);\n        }\n        memcpy(&(*helper->m_buf)[begin], buffer, n);\n        helper->m_buf_pos = end;\n        return n;\n    }\n\n    static toff_t seek( thandle_t handle, toff_t offset, int whence )\n    {\n        TiffEncoderBufHelper *helper = reinterpret_cast<TiffEncoderBufHelper*>(handle);\n        const toff_t size = helper->m_buf->size();\n        toff_t new_pos = helper->m_buf_pos;\n        switch (whence)\n        {\n            case SEEK_SET:\n                new_pos = offset;\n                break;\n            case SEEK_CUR:\n                new_pos += offset;\n                break;\n            case SEEK_END:\n                new_pos = size + offset;\n                break;\n        }\n        helper->m_buf_pos = new_pos;\n        return new_pos;\n    }\n\n    static toff_t size( thandle_t handle )\n    {\n        TiffEncoderBufHelper *helper = reinterpret_cast<TiffEncoderBufHelper*>(handle);\n        return helper->m_buf->size();\n    }\n\n    static int close( thandle_t /*handle*/ )\n    {\n        // Do nothing.\n        return 0;\n    }\n\nprivate:\n\n    std::vector<uchar>* m_buf;\n    toff_t m_buf_pos;\n};\n\nstatic bool readParam(const std::vector<int>& params, int key, int& value)\n{\n    for (size_t i = 0; i + 1 < params.size(); i += 2)\n    {\n        if (params[i] == key)\n        {\n            value = params[i + 1];\n            return true;\n        }\n    }\n    return false;\n}\n\nbool TiffEncoder::writeLibTiff( const std::vector<Mat>& img_vec, const std::vector<int>& params)\n{\n    // do NOT put \"wb\" as the mode, because the b means \"big endian\" mode, not \"binary\" mode.\n    // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n    TIFF* tif = NULL;\n\n    TiffEncoderBufHelper buf_helper(m_buf);\n    if ( m_buf )\n    {\n        tif = buf_helper.open();\n    }\n    else\n    {\n        tif = TIFFOpen(m_filename.c_str(), \"w\");\n    }\n    if (!tif)\n    {\n        return false;\n    }\n    cv::Ptr<void> tif_cleanup(tif, cv_tiffCloseHandle);\n\n    //Settings that matter to all images\n    int compression = COMPRESSION_LZW;\n    int predictor = PREDICTOR_HORIZONTAL;\n    int resUnit = -1, dpiX = -1, dpiY = -1;\n\n    readParam(params, IMWRITE_TIFF_COMPRESSION, compression);\n    readParam(params, TIFFTAG_PREDICTOR, predictor);\n    readParam(params, IMWRITE_TIFF_RESUNIT, resUnit);\n    readParam(params, IMWRITE_TIFF_XDPI, dpiX);\n    readParam(params, IMWRITE_TIFF_YDPI, dpiY);\n\n    //Iterate through each image in the vector and write them out as Tiff directories\n    for (size_t page = 0; page < img_vec.size(); page++)\n    {\n        const Mat& img = img_vec[page];\n        CV_Assert(!img.empty());\n        int channels = img.channels();\n        int width = img.cols, height = img.rows;\n        int type = img.type();\n        int depth = CV_MAT_DEPTH(type);\n        CV_CheckType(type, depth == CV_8U || depth == CV_16U || depth == CV_32F || depth == CV_64F, \"\");\n        CV_CheckType(type, channels >= 1 && channels <= 4, \"\");\n\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, width));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_IMAGELENGTH, height));\n\n        if (img_vec.size() > 1)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE));\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PAGENUMBER, page, img_vec.size()));\n        }\n\n        int compression_param = -1;  // OPENCV_FUTURE\n        if (type == CV_32FC3 && (!readParam(params, IMWRITE_TIFF_COMPRESSION, compression_param) || compression_param == COMPRESSION_SGILOG))\n        {\n            if (!write_32FC3_SGILOG(img, tif))\n                return false;\n            continue;\n        }\n\n        int page_compression = compression;\n\n        int bitsPerChannel = -1;\n        switch (depth)\n        {\n            case CV_8U:\n            {\n                bitsPerChannel = 8;\n                break;\n            }\n            case CV_16U:\n            {\n                bitsPerChannel = 16;\n                break;\n            }\n            case CV_32F:\n            {\n                bitsPerChannel = 32;\n                page_compression = COMPRESSION_NONE;\n                break;\n            }\n            case CV_64F:\n            {\n                bitsPerChannel = 64;\n                page_compression = COMPRESSION_NONE;\n                break;\n            }\n            default:\n            {\n                return false;\n            }\n        }\n\n        const int bitsPerByte = 8;\n        size_t fileStep = (width * channels * bitsPerChannel) / bitsPerByte;\n        CV_Assert(fileStep > 0);\n\n        int rowsPerStrip = (int)((1 << 13) / fileStep);\n        readParam(params, TIFFTAG_ROWSPERSTRIP, rowsPerStrip);\n        rowsPerStrip = std::max(1, std::min(height, rowsPerStrip));\n\n        int colorspace = channels > 1 ? PHOTOMETRIC_RGB : PHOTOMETRIC_MINISBLACK;\n\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, bitsPerChannel));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_COMPRESSION, page_compression));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, colorspace));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, channels));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, rowsPerStrip));\n\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, depth >= CV_32F ? SAMPLEFORMAT_IEEEFP : SAMPLEFORMAT_UINT));\n\n        if (page_compression != COMPRESSION_NONE)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PREDICTOR, predictor));\n        }\n\n        if (resUnit >= RESUNIT_NONE && resUnit <= RESUNIT_CENTIMETER)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_RESOLUTIONUNIT, resUnit));\n        }\n        if (dpiX >= 0)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_XRESOLUTION, (float)dpiX));\n        }\n        if (dpiY >= 0)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_YRESOLUTION, (float)dpiY));\n        }\n\n        // row buffer, because TIFFWriteScanline modifies the original data!\n        size_t scanlineSize = TIFFScanlineSize(tif);\n        AutoBuffer<uchar> _buffer(scanlineSize + 32);\n        uchar* buffer = _buffer.data(); CV_DbgAssert(buffer);\n        Mat m_buffer(Size(width, 1), CV_MAKETYPE(depth, channels), buffer, (size_t)scanlineSize);\n\n        for (int y = 0; y < height; ++y)\n        {\n            switch (channels)\n            {\n                case 1:\n                {\n                    memcpy(buffer, img.ptr(y), scanlineSize);\n                    break;\n                }\n\n                case 3:\n                {\n                    cvtColor(img(Rect(0, y, width, 1)), (const Mat&)m_buffer, COLOR_BGR2RGB);\n                    break;\n                }\n\n                case 4:\n                {\n                    cvtColor(img(Rect(0, y, width, 1)), (const Mat&)m_buffer, COLOR_BGRA2RGBA);\n                    break;\n                }\n\n                default:\n                {\n                    CV_Assert(0);\n                }\n            }\n\n            CV_TIFF_CHECK_CALL(TIFFWriteScanline(tif, buffer, y, 0) == 1);\n        }\n\n        CV_TIFF_CHECK_CALL(TIFFWriteDirectory(tif));\n    }\n\n    return true;\n}\n\nbool TiffEncoder::write_32FC3_SGILOG(const Mat& _img, void* tif_)\n{\n    TIFF* tif = (TIFF*)tif_;\n    CV_Assert(tif);\n\n    Mat img;\n    cvtColor(_img, img, COLOR_BGR2XYZ);\n\n    //done by caller: CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, img.cols));\n    //done by caller: CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_IMAGELENGTH, img.rows));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 3));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 32));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_SGILOG));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_LOGLUV));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_FLOAT));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, 1));\n    const int strip_size = 3 * img.cols;\n    for (int i = 0; i < img.rows; i++)\n    {\n        CV_TIFF_CHECK_CALL(TIFFWriteEncodedStrip(tif, i, (tdata_t)img.ptr<float>(i), strip_size * sizeof(float)) != (tsize_t)-1);\n    }\n    CV_TIFF_CHECK_CALL(TIFFWriteDirectory(tif));\n    return true;\n}\n\nbool TiffEncoder::writemulti(const std::vector<Mat>& img_vec, const std::vector<int>& params)\n{\n    return writeLibTiff(img_vec, params);\n}\n\nbool  TiffEncoder::write( const Mat& img, const std::vector<int>& params)\n{\n    int type = img.type();\n    int depth = CV_MAT_DEPTH(type);\n\n    CV_CheckType(type, depth == CV_8U || depth == CV_16U || depth == CV_32F || depth == CV_64F, \"\");\n\n    std::vector<Mat> img_vec;\n    img_vec.push_back(img);\n    return writeLibTiff(img_vec, params);\n}\n\n} // namespace\n\n#endif\n",
                "name": "grfmt_tiff.cpp",
                "path": "Lib/opencv/sources/modules/imgcodecs/src/grfmt_tiff.cpp",
                "url": "/github.com/Tang1705/Happy-Reconstruction/-/blob/Lib/opencv/sources/modules/imgcodecs/src/grfmt_tiff.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 522,
                    "offsetAndLengths": [
                        [
                            51,
                            16
                        ]
                    ],
                    "preview": "                                CV_TIFF_CHECK_CALL(TIFFReadRGBATile(tif, x, y, (uint32*)buffer));"
                }
            ],
            "repository": {
                "name": "github.com/Tang1705/Happy-Reconstruction",
                "url": "/github.com/Tang1705/Happy-Reconstruction"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "11b51c00f4c413713944ceacd102f40d145bc744"
                },
                "content": "/*M///////////////////////////////////////////////////////////////////////////////////////\n//\n//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.\n//\n//  By downloading, copying, installing or using the software you agree to this license.\n//  If you do not agree to this license, do not download, install,\n//  copy or use the software.\n//\n//\n//                           License Agreement\n//                For Open Source Computer Vision Library\n//\n// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.\n// Copyright (C) 2009, Willow Garage Inc., all rights reserved.\n// Third party copyrights are property of their respective owners.\n//\n// Redistribution and use in source and binary forms, with or without modification,\n// are permitted provided that the following conditions are met:\n//\n//   * Redistribution's of source code must retain the above copyright notice,\n//     this list of conditions and the following disclaimer.\n//\n//   * Redistribution's in binary form must reproduce the above copyright notice,\n//     this list of conditions and the following disclaimer in the documentation\n//     and/or other materials provided with the distribution.\n//\n//   * The name of the copyright holders may not be used to endorse or promote products\n//     derived from this software without specific prior written permission.\n//\n// This software is provided by the copyright holders and contributors \"as is\" and\n// any express or implied warranties, including, but not limited to, the implied\n// warranties of merchantability and fitness for a particular purpose are disclaimed.\n// In no event shall the Intel Corporation or contributors be liable for any direct,\n// indirect, incidental, special, exemplary, or consequential damages\n// (including, but not limited to, procurement of substitute goods or services;\n// loss of use, data, or profits; or business interruption) however caused\n// and on any theory of liability, whether in contract, strict liability,\n// or tort (including negligence or otherwise) arising in any way out of\n// the use of this software, even if advised of the possibility of such damage.\n//\n//M*/\n\n/****************************************************************************************\\\n    A part of the file implements TIFF reader on base of libtiff library\n    (see otherlibs/_graphics/readme.txt for copyright notice)\n\\****************************************************************************************/\n\n#include \"precomp.hpp\"\n\n#ifdef HAVE_TIFF\n#include <opencv2/core/utils/logger.hpp>\n\n#include \"grfmt_tiff.hpp\"\n#include <limits>\n\n// TODO FIXIT Conflict declarations for common types like int64/uint64\nnamespace tiff_dummy_namespace {\n#include \"tiff.h\"\n#include \"tiffio.h\"\n}\nusing namespace tiff_dummy_namespace;\n\nnamespace cv\n{\n\n#define CV_TIFF_CHECK_CALL(call) \\\n    if (0 == (call)) { \\\n        CV_LOG_WARNING(NULL, \"OpenCV TIFF(line \" << __LINE__ << \"): failed \" #call); \\\n        CV_Error(Error::StsError, \"OpenCV TIFF: failed \" #call); \\\n    }\n\n#define CV_TIFF_CHECK_CALL_INFO(call) \\\n    if (0 == (call)) { \\\n        CV_LOG_INFO(NULL, \"OpenCV TIFF(line \" << __LINE__ << \"): failed optional call: \" #call \", ignoring\"); \\\n    }\n\n#define CV_TIFF_CHECK_CALL_DEBUG(call) \\\n    if (0 == (call)) { \\\n        CV_LOG_DEBUG(NULL, \"OpenCV TIFF(line \" << __LINE__ << \"): failed optional call: \" #call \", ignoring\"); \\\n    }\n\nstatic void cv_tiffCloseHandle(void* handle)\n{\n    TIFFClose((TIFF*)handle);\n}\n\nstatic void cv_tiffErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    if (cv::utils::logging::getLogLevel() < cv::utils::logging::LOG_LEVEL_DEBUG)\n        return;\n    // TODO cv::vformat() with va_list parameter\n    fprintf(stderr, \"OpenCV TIFF: \");\n    if (module != NULL)\n        fprintf(stderr, \"%s: \", module);\n    fprintf(stderr, \"Warning, \");\n    vfprintf(stderr, fmt, ap);\n    fprintf(stderr, \".\\n\");\n}\n\nstatic bool cv_tiffSetErrorHandler_()\n{\n    TIFFSetErrorHandler(cv_tiffErrorHandler);\n    TIFFSetWarningHandler(cv_tiffErrorHandler);\n    return true;\n}\n\nstatic bool cv_tiffSetErrorHandler()\n{\n    static bool v = cv_tiffSetErrorHandler_();\n    return v;\n}\n\nstatic const char fmtSignTiffII[] = \"II\\x2a\\x00\";\nstatic const char fmtSignTiffMM[] = \"MM\\x00\\x2a\";\nstatic const char fmtSignBigTiffII[] = \"II\\x2b\\x00\";\nstatic const char fmtSignBigTiffMM[] = \"MM\\x00\\x2b\";\n\nTiffDecoder::TiffDecoder()\n{\n    m_hdr = false;\n    m_buf_supported = true;\n    m_buf_pos = 0;\n}\n\n\nvoid TiffDecoder::close()\n{\n    m_tif.release();\n}\n\nTiffDecoder::~TiffDecoder()\n{\n    close();\n}\n\nsize_t TiffDecoder::signatureLength() const\n{\n    return 4;\n}\n\nbool TiffDecoder::checkSignature( const String& signature ) const\n{\n    return signature.size() >= 4 &&\n        (memcmp(signature.c_str(), fmtSignTiffII, 4) == 0 ||\n        memcmp(signature.c_str(), fmtSignTiffMM, 4) == 0 ||\n        memcmp(signature.c_str(), fmtSignBigTiffII, 4) == 0 ||\n        memcmp(signature.c_str(), fmtSignBigTiffMM, 4) == 0);\n}\n\nint TiffDecoder::normalizeChannelsNumber(int channels) const\n{\n    CV_Check(channels, channels >= 1 && channels <= 4, \"Unsupported number of channels\");\n    return channels;\n}\n\nImageDecoder TiffDecoder::newDecoder() const\n{\n    cv_tiffSetErrorHandler();\n    return makePtr<TiffDecoder>();\n}\n\nclass TiffDecoderBufHelper\n{\n    Mat& m_buf;\n    size_t& m_buf_pos;\npublic:\n    TiffDecoderBufHelper(Mat& buf, size_t& buf_pos) :\n        m_buf(buf), m_buf_pos(buf_pos)\n    {}\n    static tmsize_t read( thandle_t handle, void* buffer, tmsize_t n )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        const Mat& buf = helper->m_buf;\n        const tmsize_t size = buf.cols*buf.rows*buf.elemSize();\n        tmsize_t pos = helper->m_buf_pos;\n        if ( n > (size - pos) )\n        {\n            n = size - pos;\n        }\n        memcpy(buffer, buf.ptr() + pos, n);\n        helper->m_buf_pos += n;\n        return n;\n    }\n\n    static tmsize_t write( thandle_t /*handle*/, void* /*buffer*/, tmsize_t /*n*/ )\n    {\n        // Not used for decoding.\n        return 0;\n    }\n\n    static toff_t seek( thandle_t handle, toff_t offset, int whence )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        const Mat& buf = helper->m_buf;\n        const toff_t size = buf.cols*buf.rows*buf.elemSize();\n        toff_t new_pos = helper->m_buf_pos;\n        switch (whence)\n        {\n            case SEEK_SET:\n                new_pos = offset;\n                break;\n            case SEEK_CUR:\n                new_pos += offset;\n                break;\n            case SEEK_END:\n                new_pos = size + offset;\n                break;\n        }\n        new_pos = std::min(new_pos, size);\n        helper->m_buf_pos = (size_t)new_pos;\n        return new_pos;\n    }\n\n    static int map( thandle_t handle, void** base, toff_t* size )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        Mat& buf = helper->m_buf;\n        *base = buf.ptr();\n        *size = buf.cols*buf.rows*buf.elemSize();\n        return 0;\n    }\n\n    static toff_t size( thandle_t handle )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        const Mat& buf = helper->m_buf;\n        return buf.cols*buf.rows*buf.elemSize();\n    }\n\n    static int close( thandle_t handle )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        delete helper;\n        return 0;\n    }\n};\n\nbool TiffDecoder::readHeader()\n{\n    bool result = false;\n\n    TIFF* tif = static_cast<TIFF*>(m_tif.get());\n    if (!tif)\n    {\n        // TIFFOpen() mode flags are different to fopen().  A 'b' in mode \"rb\" has no effect when reading.\n        // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n        if ( !m_buf.empty() )\n        {\n            m_buf_pos = 0;\n            TiffDecoderBufHelper* buf_helper = new TiffDecoderBufHelper(this->m_buf, this->m_buf_pos);\n            tif = TIFFClientOpen( \"\", \"r\", reinterpret_cast<thandle_t>(buf_helper), &TiffDecoderBufHelper::read,\n                                  &TiffDecoderBufHelper::write, &TiffDecoderBufHelper::seek,\n                                  &TiffDecoderBufHelper::close, &TiffDecoderBufHelper::size,\n                                  &TiffDecoderBufHelper::map, /*unmap=*/0 );\n            if (!tif)\n                delete buf_helper;\n        }\n        else\n        {\n            tif = TIFFOpen(m_filename.c_str(), \"r\");\n        }\n        if (tif)\n            m_tif.reset(tif, cv_tiffCloseHandle);\n        else\n            m_tif.release();\n    }\n\n    if (tif)\n    {\n        uint32 wdth = 0, hght = 0;\n        uint16 photometric = 0;\n\n        CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &wdth));\n        CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &hght));\n        CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric));\n\n        {\n            bool isGrayScale = photometric == PHOTOMETRIC_MINISWHITE || photometric == PHOTOMETRIC_MINISBLACK;\n            uint16 bpp = 8, ncn = isGrayScale ? 1 : 3;\n            if (0 == TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bpp))\n            {\n                // TIFF bi-level images don't require TIFFTAG_BITSPERSAMPLE tag\n                bpp = 1;\n            }\n            CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &ncn));\n\n            m_width = wdth;\n            m_height = hght;\n            if (ncn == 3 && photometric == PHOTOMETRIC_LOGLUV)\n            {\n                m_type = CV_32FC3;\n                m_hdr = true;\n                return true;\n            }\n            m_hdr = false;\n\n            if( bpp > 8 &&\n               ((photometric > 2) ||\n                (ncn != 1 && ncn != 3 && ncn != 4)))\n                bpp = 8;\n\n            uint16 sample_format = SAMPLEFORMAT_UINT;\n            TIFFGetField(tif, TIFFTAG_SAMPLEFORMAT, &sample_format);\n            int wanted_channels = normalizeChannelsNumber(ncn);\n            switch (bpp)\n            {\n            case 1:\n            {\n                CV_Check((int)sample_format, sample_format == SAMPLEFORMAT_UINT || sample_format == SAMPLEFORMAT_INT, \"\");\n                int depth = sample_format == SAMPLEFORMAT_INT ? CV_8S : CV_8U;\n                m_type = CV_MAKETYPE(depth, !isGrayScale ? wanted_channels : 1);\n                result = true;\n                break;\n            }\n            case 4:\n                //support 4-bit palette.\n                if (photometric == PHOTOMETRIC_PALETTE)\n                {\n                    CV_Check((int)sample_format, sample_format == SAMPLEFORMAT_UINT || sample_format == SAMPLEFORMAT_INT, \"\");\n                    int depth = sample_format == SAMPLEFORMAT_INT ? CV_8S : CV_8U;\n                    m_type = CV_MAKETYPE(depth, 3);\n                    result = true;\n                }\n                else\n                    CV_Error(cv::Error::StsError, \"bitsperpixel value is 4 should be palette.\");\n                break;\n            case 8:\n            {\n                //Palette color, the value of the component is used as an index into the red,\n                //green and blue curves in the ColorMap field to retrieve an RGB triplet that defines the color.\n                CV_Check((int)sample_format, sample_format == SAMPLEFORMAT_UINT || sample_format == SAMPLEFORMAT_INT, \"\");\n                int depth = sample_format == SAMPLEFORMAT_INT ? CV_8S : CV_8U;\n                if (photometric == PHOTOMETRIC_PALETTE)\n                    m_type = CV_MAKETYPE(depth, 3);\n                else\n                    m_type = CV_MAKETYPE(depth, !isGrayScale ? wanted_channels : 1);\n                result = true;\n                break;\n            }\n            case 10:\n            case 12:\n            case 14:\n            case 16:\n            {\n                CV_Check((int)sample_format, sample_format == SAMPLEFORMAT_UINT || sample_format == SAMPLEFORMAT_INT, \"\");\n                int depth = sample_format == SAMPLEFORMAT_INT ? CV_16S : CV_16U;\n                m_type = CV_MAKETYPE(depth, !isGrayScale ? wanted_channels : 1);\n                result = true;\n                break;\n            }\n            case 32:\n            {\n                CV_Check((int)sample_format, sample_format == SAMPLEFORMAT_IEEEFP || sample_format == SAMPLEFORMAT_INT, \"\");\n                int depth = sample_format == SAMPLEFORMAT_IEEEFP ? CV_32F : CV_32S;\n                m_type = CV_MAKETYPE(depth, wanted_channels);\n                result = true;\n                break;\n            }\n            case 64:\n                CV_CheckEQ((int)sample_format, SAMPLEFORMAT_IEEEFP, \"\");\n                m_type = CV_MAKETYPE(CV_64F, wanted_channels);\n                result = true;\n                break;\n            default:\n                CV_Error(cv::Error::StsError, \"Invalid bitsperpixel value read from TIFF header! Must be 1, 8, 10, 12, 14, 16, 32 or 64.\");\n            }\n        }\n    }\n\n    if( !result )\n        close();\n\n    return result;\n}\n\nbool TiffDecoder::nextPage()\n{\n    // Prepare the next page, if any.\n    return !m_tif.empty() &&\n           TIFFReadDirectory(static_cast<TIFF*>(m_tif.get())) &&\n           readHeader();\n}\n\nstatic void fixOrientationPartial(Mat &img, uint16 orientation)\n{\n    switch(orientation) {\n        case ORIENTATION_RIGHTTOP:\n        case ORIENTATION_LEFTBOT:\n            flip(img, img, -1);\n            /* fall through */\n\n        case ORIENTATION_LEFTTOP:\n        case ORIENTATION_RIGHTBOT:\n            transpose(img, img);\n            break;\n    }\n}\n\nstatic void fixOrientationFull(Mat &img, int orientation)\n{\n    switch(orientation) {\n        case ORIENTATION_TOPRIGHT:\n            flip(img, img, 1);\n            break;\n\n        case ORIENTATION_BOTRIGHT:\n            flip(img, img, -1);\n            break;\n\n        case ORIENTATION_BOTLEFT:\n            flip(img, img, 0);\n            break;\n\n        case ORIENTATION_LEFTTOP:\n            transpose(img, img);\n            break;\n\n        case ORIENTATION_RIGHTTOP:\n            transpose(img, img);\n            flip(img, img, 1);\n            break;\n\n        case ORIENTATION_RIGHTBOT:\n            transpose(img, img);\n            flip(img, img, -1);\n            break;\n\n        case ORIENTATION_LEFTBOT:\n            transpose(img, img);\n            flip(img, img, 0);\n            break;\n    }\n}\n\n/**\n * Fix orientation defined in tag 274.\n * For 8 bit some corrections are done by TIFFReadRGBAStrip/Tile already.\n * Not so for 16/32/64 bit.\n */\nstatic void fixOrientation(Mat &img, uint16 orientation, int dst_bpp)\n{\n    switch(dst_bpp) {\n        case 8:\n            fixOrientationPartial(img, orientation);\n            break;\n\n        case 16:\n        case 32:\n        case 64:\n            fixOrientationFull(img, orientation);\n            break;\n    }\n}\n\nstatic void _unpack10To16(const uchar* src, const uchar* srcEnd, ushort* dst, ushort* dstEnd, size_t expectedDstElements)\n{\n    //5*8b=4*10b : 5 src for 4 dst\n    constexpr const size_t packedBitsCount = 10;\n    constexpr const size_t packedBitsMask = ((1<<packedBitsCount)-1);\n    constexpr const size_t srcElementsPerPacket = 5;\n    constexpr const size_t dstElementsPerPacket = 4;\n    constexpr const size_t bitsPerPacket = dstElementsPerPacket*packedBitsCount;\n    const size_t fullPacketsCount = std::min({\n      expectedDstElements/dstElementsPerPacket,\n      (static_cast<size_t>(srcEnd-src)/srcElementsPerPacket),\n      (static_cast<size_t>(dstEnd-dst)/dstElementsPerPacket)\n    });\n    union {\n      uint64_t u64;\n      uint8_t  u8[8];\n    } buf = {0};\n    for(size_t i = 0 ; i<fullPacketsCount ; ++i)\n    {\n        for(size_t j = 0 ; j<srcElementsPerPacket ; ++j)\n          buf.u8[srcElementsPerPacket-1-j] = *src++;\n        for(size_t j = 0 ; j<dstElementsPerPacket ; ++j)\n        {\n          dst[dstElementsPerPacket-1-j] = static_cast<ushort>(buf.u64 & packedBitsMask);\n          buf.u64 >>= packedBitsCount;\n        }\n        dst += dstElementsPerPacket;\n    }\n    size_t remainingDstElements = std::min(\n        expectedDstElements-fullPacketsCount*dstElementsPerPacket,\n        static_cast<size_t>(dstEnd-dst)\n    );\n    bool stop = !remainingDstElements;\n    while(!stop)\n    {\n        for(size_t j = 0 ; j<srcElementsPerPacket ; ++j)\n            buf.u8[srcElementsPerPacket-1-j] = (src<srcEnd) ? *src++ : 0;\n        for(size_t j = 0 ; j<dstElementsPerPacket ; ++j)\n        {\n            stop |= !(remainingDstElements--);\n            if (!stop)\n              *dst++ = static_cast<ushort>((buf.u64 >> (bitsPerPacket-(j+1)*packedBitsCount)) & packedBitsMask);\n        }\n    }//end while(!stop)\n}\n//end _unpack10To16()\n\nstatic void _unpack12To16(const uchar* src, const uchar* srcEnd, ushort* dst, ushort* dstEnd, size_t expectedDstElements)\n{\n  //3*8b=2*12b : 3 src for 2 dst\n  constexpr const size_t packedBitsCount = 12;\n  constexpr const size_t packedBitsMask = ((1<<packedBitsCount)-1);\n  constexpr const size_t srcElementsPerPacket = 3;\n  constexpr const size_t dstElementsPerPacket = 2;\n  constexpr const size_t bitsPerPacket = dstElementsPerPacket*packedBitsCount;\n  const size_t fullPacketsCount = std::min({\n    expectedDstElements/dstElementsPerPacket,\n    (static_cast<size_t>(srcEnd-src)/srcElementsPerPacket),\n    (static_cast<size_t>(dstEnd-dst)/dstElementsPerPacket)\n  });\n  union {\n      uint32_t u32;\n      uint8_t  u8[4];\n  } buf = {0};\n  for(size_t i = 0 ; i<fullPacketsCount ; ++i)\n  {\n      for(size_t j = 0 ; j<srcElementsPerPacket ; ++j)\n          buf.u8[srcElementsPerPacket-1-j] = *src++;\n      for(size_t j = 0 ; j<dstElementsPerPacket ; ++j)\n      {\n          dst[dstElementsPerPacket-1-j] = static_cast<ushort>(buf.u32 & packedBitsMask);\n          buf.u32 >>= packedBitsCount;\n      }\n      dst += dstElementsPerPacket;\n  }\n  size_t remainingDstElements = std::min(\n      expectedDstElements-fullPacketsCount*dstElementsPerPacket,\n      static_cast<size_t>(dstEnd-dst)\n  );\n  bool stop = !remainingDstElements;\n  while(!stop)\n  {\n      for(size_t j = 0 ; j<srcElementsPerPacket ; ++j)\n          buf.u8[srcElementsPerPacket-1-j] = (src<srcEnd) ? *src++ : 0;\n      for(size_t j = 0 ; j<dstElementsPerPacket ; ++j)\n      {\n          stop |= !(remainingDstElements--);\n          if (!stop)\n              *dst++ = static_cast<ushort>((buf.u32 >> (bitsPerPacket-(j+1)*packedBitsCount)) & packedBitsMask);\n      }\n  }//end while(!stop)\n}\n//end _unpack12To16()\n\nstatic void _unpack14To16(const uchar* src, const uchar* srcEnd, ushort* dst, ushort* dstEnd, size_t expectedDstElements)\n{\n    //7*8b=4*14b : 7 src for 4 dst\n    constexpr const size_t packedBitsCount = 14;\n    constexpr const size_t packedBitsMask = ((1<<packedBitsCount)-1);\n    constexpr const size_t srcElementsPerPacket = 7;\n    constexpr const size_t dstElementsPerPacket = 4;\n    constexpr const size_t bitsPerPacket = dstElementsPerPacket*packedBitsCount;\n    const size_t fullPacketsCount = std::min({\n      expectedDstElements/dstElementsPerPacket,\n      (static_cast<size_t>(srcEnd-src)/srcElementsPerPacket),\n      (static_cast<size_t>(dstEnd-dst)/dstElementsPerPacket)\n    });\n    union {\n        uint64_t u64;\n        uint8_t  u8[8];\n    } buf = {0};\n    for(size_t i = 0 ; i<fullPacketsCount ; ++i)\n    {\n        for(size_t j = 0 ; j<srcElementsPerPacket ; ++j)\n            buf.u8[srcElementsPerPacket-1-j] = *src++;\n        for(size_t j = 0 ; j<dstElementsPerPacket ; ++j)\n        {\n            dst[dstElementsPerPacket-1-j] = static_cast<ushort>(buf.u64 & packedBitsMask);\n            buf.u64 >>= packedBitsCount;\n        }\n        dst += dstElementsPerPacket;\n    }\n    size_t remainingDstElements = std::min(\n        expectedDstElements-fullPacketsCount*dstElementsPerPacket,\n        static_cast<size_t>(dstEnd-dst)\n    );\n    bool stop = !remainingDstElements;\n    while(!stop)\n    {\n        for(size_t j = 0 ; j<srcElementsPerPacket ; ++j)\n            buf.u8[srcElementsPerPacket-1-j] = (src<srcEnd) ? *src++ : 0;\n        for(size_t j = 0 ; j<dstElementsPerPacket ; ++j)\n        {\n            stop |= !(remainingDstElements--);\n            if (!stop)\n                *dst++ = static_cast<ushort>((buf.u64 >> (bitsPerPacket-(j+1)*packedBitsCount)) & packedBitsMask);\n        }\n    }//end while(!stop)\n}\n//end _unpack14To16()\n\nbool  TiffDecoder::readData( Mat& img )\n{\n    int type = img.type();\n    int depth = CV_MAT_DEPTH(type);\n\n    CV_Assert(!m_tif.empty());\n    TIFF* tif = (TIFF*)m_tif.get();\n\n    uint16 photometric = (uint16)-1;\n    CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric));\n\n    if (m_hdr && depth >= CV_32F)\n    {\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_FLOAT));\n    }\n\n    bool color = img.channels() > 1;\n\n    CV_CheckType(type, depth == CV_8U || depth == CV_8S || depth == CV_16U || depth == CV_16S || depth == CV_32S || depth == CV_32F || depth == CV_64F, \"\");\n\n    if (m_width && m_height)\n    {\n        int is_tiled = TIFFIsTiled(tif) != 0;\n        bool isGrayScale = photometric == PHOTOMETRIC_MINISWHITE || photometric == PHOTOMETRIC_MINISBLACK;\n        uint16 bpp = 8, ncn = isGrayScale ? 1 : 3;\n        if (0 == TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bpp))\n        {\n            // TIFF bi-level images don't require TIFFTAG_BITSPERSAMPLE tag\n            bpp = 1;\n        }\n        CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &ncn));\n        uint16 img_orientation = ORIENTATION_TOPLEFT;\n        CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_ORIENTATION, &img_orientation));\n        constexpr const int bitsPerByte = 8;\n        int dst_bpp = (int)(img.elemSize1() * bitsPerByte);\n        bool vert_flip = dst_bpp == 8 &&\n                        (img_orientation == ORIENTATION_BOTRIGHT || img_orientation == ORIENTATION_RIGHTBOT ||\n                         img_orientation == ORIENTATION_BOTLEFT || img_orientation == ORIENTATION_LEFTBOT);\n        int wanted_channels = normalizeChannelsNumber(img.channels());\n\n        if (dst_bpp == 8)\n        {\n            char errmsg[1024];\n            if (!TIFFRGBAImageOK(tif, errmsg))\n            {\n                CV_LOG_WARNING(NULL, \"OpenCV TIFF: TIFFRGBAImageOK: \" << errmsg);\n                close();\n                return false;\n            }\n        }\n\n        uint32 tile_width0 = m_width, tile_height0 = 0;\n\n        if (is_tiled)\n        {\n            CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_TILEWIDTH, &tile_width0));\n            CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_TILELENGTH, &tile_height0));\n        }\n        else\n        {\n            // optional\n            CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &tile_height0));\n        }\n\n        {\n            if (tile_width0 == 0)\n                tile_width0 = m_width;\n\n            if (tile_height0 == 0 ||\n                    (!is_tiled && tile_height0 == std::numeric_limits<uint32>::max()) )\n                tile_height0 = m_height;\n\n            const int TILE_MAX_WIDTH = (1 << 24);\n            const int TILE_MAX_HEIGHT = (1 << 24);\n            CV_Assert((int)tile_width0 > 0 && (int)tile_width0 <= TILE_MAX_WIDTH);\n            CV_Assert((int)tile_height0 > 0 && (int)tile_height0 <= TILE_MAX_HEIGHT);\n            const uint64_t MAX_TILE_SIZE = (CV_BIG_UINT(1) << 30);\n            CV_CheckLE((int)ncn, 4, \"\");\n            CV_CheckLE((int)bpp, 64, \"\");\n            CV_Assert(((uint64_t)tile_width0 * tile_height0 * ncn * std::max(1, (int)(bpp / bitsPerByte)) < MAX_TILE_SIZE) && \"TIFF tile size is too large: >= 1Gb\");\n\n            if (dst_bpp == 8)\n            {\n                // we will use TIFFReadRGBA* functions, so allocate temporary buffer for 32bit RGBA\n                bpp = 8;\n                ncn = 4;\n            }\n            else if (dst_bpp == 32 || dst_bpp == 64)\n            {\n                CV_Assert(ncn == img.channels());\n                CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP));\n            }\n            const size_t src_buffer_bytes_per_row = divUp(static_cast<size_t>(ncn * tile_width0 * bpp), static_cast<size_t>(bitsPerByte));\n            const size_t src_buffer_size = tile_height0 * src_buffer_bytes_per_row;\n            const size_t src_buffer_unpacked_bytes_per_row = divUp(static_cast<size_t>(ncn * tile_width0 * dst_bpp), static_cast<size_t>(bitsPerByte));\n            const size_t src_buffer_unpacked_size = tile_height0 * src_buffer_unpacked_bytes_per_row;\n            const bool needsUnpacking = (bpp < dst_bpp);\n            AutoBuffer<uchar> _src_buffer(src_buffer_size);\n            uchar* src_buffer = _src_buffer.data();\n            AutoBuffer<uchar> _src_buffer_unpacked(needsUnpacking ? src_buffer_unpacked_size : 0);\n            uchar* src_buffer_unpacked = needsUnpacking ? _src_buffer_unpacked.data() : nullptr;\n            int tileidx = 0;\n\n            for (int y = 0; y < m_height; y += (int)tile_height0)\n            {\n                int tile_height = std::min((int)tile_height0, m_height - y);\n\n                const int img_y = vert_flip ? m_height - y - tile_height : y;\n\n                for(int x = 0; x < m_width; x += (int)tile_width0, tileidx++)\n                {\n                    int tile_width = std::min((int)tile_width0, m_width - x);\n\n                    switch (dst_bpp)\n                    {\n                        case 8:\n                        {\n                            uchar* bstart = src_buffer;\n                            if (!is_tiled)\n                            {\n                                CV_TIFF_CHECK_CALL(TIFFReadRGBAStrip(tif, y, (uint32*)src_buffer));\n                            }\n                            else\n                            {\n                                CV_TIFF_CHECK_CALL(TIFFReadRGBATile(tif, x, y, (uint32*)src_buffer));\n                                // Tiles fill the buffer from the bottom up\n                                bstart += (tile_height0 - tile_height) * tile_width0 * 4;\n                            }\n\n                            for (int i = 0; i < tile_height; i++)\n                            {\n                                if (color)\n                                {\n                                    if (wanted_channels == 4)\n                                    {\n                                        icvCvt_BGRA2RGBA_8u_C4R(bstart + i*tile_width0*4, 0,\n                                                img.ptr(img_y + tile_height - i - 1, x), 0,\n                                                Size(tile_width, 1) );\n                                    }\n                                    else\n                                    {\n                                        CV_CheckEQ(wanted_channels, 3, \"TIFF-8bpp: BGR/BGRA images are supported only\");\n                                        icvCvt_BGRA2BGR_8u_C4C3R(bstart + i*tile_width0*4, 0,\n                                                img.ptr(img_y + tile_height - i - 1, x), 0,\n                                                Size(tile_width, 1), 2);\n                                    }\n                                }\n                                else\n                                {\n                                    CV_CheckEQ(wanted_channels, 1, \"\");\n                                    icvCvt_BGRA2Gray_8u_C4C1R( bstart + i*tile_width0*4, 0,\n                                            img.ptr(img_y + tile_height - i - 1, x), 0,\n                                            Size(tile_width, 1), 2);\n                                }\n                            }\n                            break;\n                        }\n\n                        case 16:\n                        {\n                            if (!is_tiled)\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedStrip(tif, tileidx, (uint32*)src_buffer, src_buffer_size) >= 0);\n                            }\n                            else\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedTile(tif, tileidx, (uint32*)src_buffer, src_buffer_size) >= 0);\n                            }\n\n                            for (int i = 0; i < tile_height; i++)\n                            {\n                                ushort* buffer16 = (ushort*)(src_buffer+i*src_buffer_bytes_per_row);\n                                if (needsUnpacking)\n                                {\n                                    const uchar* src_packed = src_buffer+i*src_buffer_bytes_per_row;\n                                    uchar* dst_unpacked = src_buffer_unpacked+i*src_buffer_unpacked_bytes_per_row;\n                                    if (bpp == 10)\n                                        _unpack10To16(src_packed, src_packed+src_buffer_bytes_per_row,\n                                                      (ushort*)dst_unpacked, (ushort*)(dst_unpacked+src_buffer_unpacked_bytes_per_row),\n                                                      ncn * tile_width0);\n                                    else if (bpp == 12)\n                                        _unpack12To16(src_packed, src_packed+src_buffer_bytes_per_row,\n                                                      (ushort*)dst_unpacked, (ushort*)(dst_unpacked+src_buffer_unpacked_bytes_per_row),\n                                                      ncn * tile_width0);\n                                    else if (bpp == 14)\n                                        _unpack14To16(src_packed, src_packed+src_buffer_bytes_per_row,\n                                                      (ushort*)dst_unpacked, (ushort*)(dst_unpacked+src_buffer_unpacked_bytes_per_row),\n                                                      ncn * tile_width0);\n                                    buffer16 = (ushort*)dst_unpacked;\n                                }\n\n                                if (color)\n                                {\n                                    if (ncn == 1)\n                                    {\n                                        CV_CheckEQ(wanted_channels, 3, \"\");\n                                        icvCvt_Gray2BGR_16u_C1C3R(buffer16, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1));\n                                    }\n                                    else if (ncn == 3)\n                                    {\n                                        CV_CheckEQ(wanted_channels, 3, \"\");\n                                        icvCvt_RGB2BGR_16u_C3R(buffer16, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1));\n                                    }\n                                    else if (ncn == 4)\n                                    {\n                                        if (wanted_channels == 4)\n                                        {\n                                            icvCvt_BGRA2RGBA_16u_C4R(buffer16, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1));\n                                        }\n                                        else\n                                        {\n                                            CV_CheckEQ(wanted_channels, 3, \"TIFF-16bpp: BGR/BGRA images are supported only\");\n                                            icvCvt_BGRA2BGR_16u_C4C3R(buffer16, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1), 2);\n                                        }\n                                    }\n                                    else\n                                    {\n                                        CV_Error(Error::StsError, \"Not supported\");\n                                    }\n                                }\n                                else\n                                {\n                                    CV_CheckEQ(wanted_channels, 1, \"\");\n                                    if( ncn == 1 )\n                                    {\n                                        memcpy(img.ptr<ushort>(img_y + i, x),\n                                               buffer16,\n                                               tile_width*sizeof(ushort));\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2Gray_16u_CnC1R(buffer16, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1), ncn, 2);\n                                    }\n                                }\n                            }\n                            break;\n                        }\n\n                        case 32:\n                        case 64:\n                        {\n                            if( !is_tiled )\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedStrip(tif, tileidx, src_buffer, src_buffer_size) >= 0);\n                            }\n                            else\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedTile(tif, tileidx, src_buffer, src_buffer_size) >= 0);\n                            }\n\n                            Mat m_tile(Size(tile_width0, tile_height0), CV_MAKETYPE((dst_bpp == 32) ? (depth == CV_32S ? CV_32S : CV_32F) : CV_64F, ncn), src_buffer);\n                            Rect roi_tile(0, 0, tile_width, tile_height);\n                            Rect roi_img(x, img_y, tile_width, tile_height);\n                            if (!m_hdr && ncn == 3)\n                                cvtColor(m_tile(roi_tile), img(roi_img), COLOR_RGB2BGR);\n                            else if (!m_hdr && ncn == 4)\n                                cvtColor(m_tile(roi_tile), img(roi_img), COLOR_RGBA2BGRA);\n                            else\n                                m_tile(roi_tile).copyTo(img(roi_img));\n                            break;\n                        }\n                        default:\n                        {\n                            CV_Assert(0 && \"OpenCV TIFF: unsupported depth\");\n                        }\n                    }  // switch (dst_bpp)\n                }  // for x\n            }  // for y\n        }\n        if (bpp < dst_bpp)\n          img *= (1<<(dst_bpp-bpp));\n        fixOrientation(img, img_orientation, dst_bpp);\n    }\n\n    if (m_hdr && depth >= CV_32F)\n    {\n        CV_Assert(photometric == PHOTOMETRIC_LOGLUV);\n        cvtColor(img, img, COLOR_XYZ2BGR);\n    }\n    return true;\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////\n\nTiffEncoder::TiffEncoder()\n{\n    m_description = \"TIFF Files (*.tiff;*.tif)\";\n    m_buf_supported = true;\n}\n\nTiffEncoder::~TiffEncoder()\n{\n}\n\nImageEncoder TiffEncoder::newEncoder() const\n{\n    return makePtr<TiffEncoder>();\n}\n\nbool TiffEncoder::isFormatSupported( int depth ) const\n{\n    return depth == CV_8U || depth == CV_8S || depth == CV_16U || depth == CV_16S || depth == CV_32S || depth == CV_32F || depth == CV_64F;\n}\n\nvoid  TiffEncoder::writeTag( WLByteStream& strm, TiffTag tag,\n                             TiffFieldType fieldType,\n                             int count, int value )\n{\n    strm.putWord( tag );\n    strm.putWord( fieldType );\n    strm.putDWord( count );\n    strm.putDWord( value );\n}\n\nclass TiffEncoderBufHelper\n{\npublic:\n\n    TiffEncoderBufHelper(std::vector<uchar> *buf)\n            : m_buf(buf), m_buf_pos(0)\n    {}\n\n    TIFF* open ()\n    {\n        // do NOT put \"wb\" as the mode, because the b means \"big endian\" mode, not \"binary\" mode.\n        // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n        return TIFFClientOpen( \"\", \"w\", reinterpret_cast<thandle_t>(this), &TiffEncoderBufHelper::read,\n                               &TiffEncoderBufHelper::write, &TiffEncoderBufHelper::seek,\n                               &TiffEncoderBufHelper::close, &TiffEncoderBufHelper::size,\n                               /*map=*/0, /*unmap=*/0 );\n    }\n\n    static tmsize_t read( thandle_t /*handle*/, void* /*buffer*/, tmsize_t /*n*/ )\n    {\n        // Not used for encoding.\n        return 0;\n    }\n\n    static tmsize_t write( thandle_t handle, void* buffer, tmsize_t n )\n    {\n        TiffEncoderBufHelper *helper = reinterpret_cast<TiffEncoderBufHelper*>(handle);\n        size_t begin = (size_t)helper->m_buf_pos;\n        size_t end = begin + n;\n        if ( helper->m_buf->size() < end )\n        {\n            helper->m_buf->resize(end);\n        }\n        memcpy(&(*helper->m_buf)[begin], buffer, n);\n        helper->m_buf_pos = end;\n        return n;\n    }\n\n    static toff_t seek( thandle_t handle, toff_t offset, int whence )\n    {\n        TiffEncoderBufHelper *helper = reinterpret_cast<TiffEncoderBufHelper*>(handle);\n        const toff_t size = helper->m_buf->size();\n        toff_t new_pos = helper->m_buf_pos;\n        switch (whence)\n        {\n            case SEEK_SET:\n                new_pos = offset;\n                break;\n            case SEEK_CUR:\n                new_pos += offset;\n                break;\n            case SEEK_END:\n                new_pos = size + offset;\n                break;\n        }\n        helper->m_buf_pos = new_pos;\n        return new_pos;\n    }\n\n    static toff_t size( thandle_t handle )\n    {\n        TiffEncoderBufHelper *helper = reinterpret_cast<TiffEncoderBufHelper*>(handle);\n        return helper->m_buf->size();\n    }\n\n    static int close( thandle_t /*handle*/ )\n    {\n        // Do nothing.\n        return 0;\n    }\n\nprivate:\n\n    std::vector<uchar>* m_buf;\n    toff_t m_buf_pos;\n};\n\nstatic bool readParam(const std::vector<int>& params, int key, int& value)\n{\n    for (size_t i = 0; i + 1 < params.size(); i += 2)\n    {\n        if (params[i] == key)\n        {\n            value = params[i + 1];\n            return true;\n        }\n    }\n    return false;\n}\n\nbool TiffEncoder::writeLibTiff( const std::vector<Mat>& img_vec, const std::vector<int>& params)\n{\n    // do NOT put \"wb\" as the mode, because the b means \"big endian\" mode, not \"binary\" mode.\n    // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n    TIFF* tif = NULL;\n\n    TiffEncoderBufHelper buf_helper(m_buf);\n    if ( m_buf )\n    {\n        tif = buf_helper.open();\n    }\n    else\n    {\n        tif = TIFFOpen(m_filename.c_str(), \"w\");\n    }\n    if (!tif)\n    {\n        return false;\n    }\n    cv::Ptr<void> tif_cleanup(tif, cv_tiffCloseHandle);\n\n    //Settings that matter to all images\n    int compression = COMPRESSION_LZW;\n    int predictor = PREDICTOR_HORIZONTAL;\n    int resUnit = -1, dpiX = -1, dpiY = -1;\n\n    readParam(params, IMWRITE_TIFF_COMPRESSION, compression);\n    readParam(params, TIFFTAG_PREDICTOR, predictor);\n    readParam(params, IMWRITE_TIFF_RESUNIT, resUnit);\n    readParam(params, IMWRITE_TIFF_XDPI, dpiX);\n    readParam(params, IMWRITE_TIFF_YDPI, dpiY);\n\n    //Iterate through each image in the vector and write them out as Tiff directories\n    for (size_t page = 0; page < img_vec.size(); page++)\n    {\n        const Mat& img = img_vec[page];\n        CV_Assert(!img.empty());\n        int channels = img.channels();\n        int width = img.cols, height = img.rows;\n        int type = img.type();\n        int depth = CV_MAT_DEPTH(type);\n        CV_CheckType(type, depth == CV_8U || depth == CV_8S || depth == CV_16U || depth == CV_16S || depth == CV_32S || depth == CV_32F || depth == CV_64F, \"\");\n        CV_CheckType(type, channels >= 1 && channels <= 4, \"\");\n\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, width));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_IMAGELENGTH, height));\n\n        if (img_vec.size() > 1)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE));\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PAGENUMBER, page, img_vec.size()));\n        }\n\n        int compression_param = -1;  // OPENCV_FUTURE\n        if (type == CV_32FC3 && (!readParam(params, IMWRITE_TIFF_COMPRESSION, compression_param) || compression_param == COMPRESSION_SGILOG))\n        {\n            if (!write_32FC3_SGILOG(img, tif))\n                return false;\n            continue;\n        }\n\n        int page_compression = compression;\n\n        int bitsPerChannel = -1;\n        uint16 sample_format = SAMPLEFORMAT_INT;\n        switch (depth)\n        {\n            case CV_8U:\n                sample_format = SAMPLEFORMAT_UINT;\n                /* FALLTHRU */\n            case CV_8S:\n            {\n                bitsPerChannel = 8;\n                break;\n            }\n\n            case CV_16U:\n                sample_format = SAMPLEFORMAT_UINT;\n                /* FALLTHRU */\n            case CV_16S:\n            {\n                bitsPerChannel = 16;\n                break;\n            }\n\n            case CV_32F:\n                sample_format = SAMPLEFORMAT_IEEEFP;\n                /* FALLTHRU */\n            case CV_32S:\n            {\n                bitsPerChannel = 32;\n                page_compression = COMPRESSION_NONE;\n                break;\n            }\n            case CV_64F:\n            {\n                bitsPerChannel = 64;\n                page_compression = COMPRESSION_NONE;\n                sample_format = SAMPLEFORMAT_IEEEFP;\n                break;\n            }\n            default:\n            {\n                return false;\n            }\n        }\n\n        const int bitsPerByte = 8;\n        size_t fileStep = (width * channels * bitsPerChannel) / bitsPerByte;\n        CV_Assert(fileStep > 0);\n\n        int rowsPerStrip = (int)((1 << 13) / fileStep);\n        readParam(params, TIFFTAG_ROWSPERSTRIP, rowsPerStrip);\n        rowsPerStrip = std::max(1, std::min(height, rowsPerStrip));\n\n        int colorspace = channels > 1 ? PHOTOMETRIC_RGB : PHOTOMETRIC_MINISBLACK;\n\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, bitsPerChannel));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_COMPRESSION, page_compression));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, colorspace));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, channels));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, rowsPerStrip));\n\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, sample_format));\n\n        if (page_compression == COMPRESSION_LZW || page_compression == COMPRESSION_ADOBE_DEFLATE || page_compression == COMPRESSION_DEFLATE)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PREDICTOR, predictor));\n        }\n\n        if (resUnit >= RESUNIT_NONE && resUnit <= RESUNIT_CENTIMETER)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_RESOLUTIONUNIT, resUnit));\n        }\n        if (dpiX >= 0)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_XRESOLUTION, (float)dpiX));\n        }\n        if (dpiY >= 0)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_YRESOLUTION, (float)dpiY));\n        }\n\n        // row buffer, because TIFFWriteScanline modifies the original data!\n        size_t scanlineSize = TIFFScanlineSize(tif);\n        AutoBuffer<uchar> _buffer(scanlineSize + 32);\n        uchar* buffer = _buffer.data(); CV_DbgAssert(buffer);\n        Mat m_buffer(Size(width, 1), CV_MAKETYPE(depth, channels), buffer, (size_t)scanlineSize);\n\n        for (int y = 0; y < height; ++y)\n        {\n            switch (channels)\n            {\n                case 1:\n                {\n                    memcpy(buffer, img.ptr(y), scanlineSize);\n                    break;\n                }\n\n                case 3:\n                {\n                    cvtColor(img(Rect(0, y, width, 1)), (const Mat&)m_buffer, COLOR_BGR2RGB);\n                    break;\n                }\n\n                case 4:\n                {\n                    cvtColor(img(Rect(0, y, width, 1)), (const Mat&)m_buffer, COLOR_BGRA2RGBA);\n                    break;\n                }\n\n                default:\n                {\n                    CV_Assert(0);\n                }\n            }\n\n            CV_TIFF_CHECK_CALL(TIFFWriteScanline(tif, buffer, y, 0) == 1);\n        }\n\n        CV_TIFF_CHECK_CALL(TIFFWriteDirectory(tif));\n    }\n\n    return true;\n}\n\nbool TiffEncoder::write_32FC3_SGILOG(const Mat& _img, void* tif_)\n{\n    TIFF* tif = (TIFF*)tif_;\n    CV_Assert(tif);\n\n    Mat img;\n    cvtColor(_img, img, COLOR_BGR2XYZ);\n\n    //done by caller: CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, img.cols));\n    //done by caller: CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_IMAGELENGTH, img.rows));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 3));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 32));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_SGILOG));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_LOGLUV));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_FLOAT));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, 1));\n    const int strip_size = 3 * img.cols;\n    for (int i = 0; i < img.rows; i++)\n    {\n        CV_TIFF_CHECK_CALL(TIFFWriteEncodedStrip(tif, i, (tdata_t)img.ptr<float>(i), strip_size * sizeof(float)) != (tsize_t)-1);\n    }\n    CV_TIFF_CHECK_CALL(TIFFWriteDirectory(tif));\n    return true;\n}\n\nbool TiffEncoder::writemulti(const std::vector<Mat>& img_vec, const std::vector<int>& params)\n{\n    return writeLibTiff(img_vec, params);\n}\n\nbool  TiffEncoder::write( const Mat& img, const std::vector<int>& params)\n{\n    int type = img.type();\n    int depth = CV_MAT_DEPTH(type);\n\n    CV_CheckType(type, depth == CV_8U || depth == CV_8S || depth == CV_16U || depth == CV_16S || depth == CV_32S || depth == CV_32F || depth == CV_64F, \"\");\n\n    std::vector<Mat> img_vec;\n    img_vec.push_back(img);\n    return writeLibTiff(img_vec, params);\n}\n\n} // namespace\n\n#endif\n",
                "name": "grfmt_tiff.cpp",
                "path": "my_android_opencv/modules/imgcodecs/src/grfmt_tiff.cpp",
                "url": "/github.com/SsageParuders/Android_Native_Surface/-/blob/my_android_opencv/modules/imgcodecs/src/grfmt_tiff.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 719,
                    "offsetAndLengths": [
                        [
                            51,
                            16
                        ]
                    ],
                    "preview": "                                CV_TIFF_CHECK_CALL(TIFFReadRGBATile(tif, x, y, (uint32*)src_buffer));"
                }
            ],
            "repository": {
                "name": "github.com/SsageParuders/Android_Native_Surface",
                "url": "/github.com/SsageParuders/Android_Native_Surface"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "c83e7858a9ec566cc91d65db74fd07b99789c0f0"
                },
                "content": "/******************************************************************************\n *\n * Project:  GeoTIFF Driver\n * Purpose:  GDAL GeoTIFF support.\n * Author:   Frank Warmerdam, warmerdam@pobox.com\n *\n ******************************************************************************\n * Copyright (c) 1998, 2002, Frank Warmerdam <warmerdam@pobox.com>\n * Copyright (c) 2007-2015, Even Rouault <even dot rouault at spatialys dot com>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n ****************************************************************************/\n\n// If we use sunpro compiler on linux. Weird idea indeed!\n#if defined(__SUNPRO_CC) && defined(__linux__)\n#define _GNU_SOURCE\n#elif defined(__GNUC__) && !defined(_GNU_SOURCE)\n// Required to use RTLD_DEFAULT of dlfcn.h.\n#define _GNU_SOURCE\n#endif\n\n#include \"cpl_port.h\"  // Must be first.\n#include \"gtiff.h\"\n\n#include <cassert>\n#include <cerrno>\n#include <climits>\n#include <cmath>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#if HAVE_FCNTL_H\n#include <fcntl.h>\n#endif\n#if HAVE_SYS_STAT_H\n#  include <sys/stat.h>\n#endif\n\n#include <algorithm>\n#include <memory>\n#include <mutex>\n#include <set>\n#include <string>\n#include <vector>\n\n#include \"cpl_config.h\"\n#include \"cpl_conv.h\"\n#include \"cpl_csv.h\"\n#include \"cpl_error.h\"\n#include \"cpl_minixml.h\"\n#include \"cpl_multiproc.h\"\n#include \"cpl_port.h\"\n#include \"cpl_progress.h\"\n#include \"cpl_string.h\"\n#include \"cpl_virtualmem.h\"\n#include \"cpl_vsi.h\"\n#include \"cpl_vsi_virtual.h\"\n#include \"cpl_worker_thread_pool.h\"\n#include \"cplkeywordparser.h\"\n#include \"gdal.h\"\n#include \"gdal_csv.h\"\n#include \"gdal_frmts.h\"\n#include \"gdal_mdreader.h\"\n#include \"gdal_pam.h\"\n#include \"gdal_priv.h\"\n#include \"gdal_priv_templates.hpp\"\n#include \"geo_normalize.h\"\n#include \"geotiff.h\"\n#include \"geovalues.h\"\n#include \"gt_jpeg_copy.h\"\n#include \"gt_overview.h\"\n#include \"gt_wkt_srs.h\"\n#include \"gt_wkt_srs_priv.h\"\n#include \"ogr_spatialref.h\"\n#include \"tiff.h\"\n#include \"tif_float.h\"\n#include \"tiffio.h\"\n#ifdef INTERNAL_LIBTIFF\n#  include \"tiffiop.h\"\n#  include \"tif_lerc.h\"\n#    ifdef WEBP_SUPPORT\n#      include \"webp/encode.h\"\n#    endif\n#endif\n#include \"tiffvers.h\"\n#include \"tifvsi.h\"\n#include \"xtiffio.h\"\n\n\nCPL_CVSID(\"$Id: geotiff.cpp 327f91335ae848e9c94bac0c8451522410e5064e 2019-09-11 00:45:29 +0200 Even Rouault $\")\n\nstatic bool bGlobalInExternalOvr = false;\nstatic std::mutex gMutexThreadPool;\nCPLWorkerThreadPool *gpoCompressThreadPool = nullptr;\n\n// Only libtiff 4.0.4 can handle between 32768 and 65535 directories.\n#if TIFFLIB_VERSION >= 20120922\n#define SUPPORTS_MORE_THAN_32768_DIRECTORIES\n#endif\n\nconst char* const szJPEGGTiffDatasetTmpPrefix = \"/vsimem/gtiffdataset_jpg_tmp_\";\n\ntypedef enum\n{\n    GTIFFTAGTYPE_STRING,\n    GTIFFTAGTYPE_SHORT,\n    GTIFFTAGTYPE_FLOAT,\n    GTIFFTAGTYPE_BYTE_STRING\n} GTIFFTagTypes;\n\ntypedef struct\n{\n    const char    *pszTagName;\n    int            nTagVal;\n    GTIFFTagTypes  eType;\n} GTIFFTags;\n\nstatic const GTIFFTags asTIFFTags[] =\n{\n    { \"TIFFTAG_DOCUMENTNAME\", TIFFTAG_DOCUMENTNAME, GTIFFTAGTYPE_STRING },\n    { \"TIFFTAG_IMAGEDESCRIPTION\", TIFFTAG_IMAGEDESCRIPTION,\n        GTIFFTAGTYPE_STRING },\n    { \"TIFFTAG_SOFTWARE\", TIFFTAG_SOFTWARE, GTIFFTAGTYPE_STRING },\n    { \"TIFFTAG_DATETIME\", TIFFTAG_DATETIME, GTIFFTAGTYPE_STRING },\n    { \"TIFFTAG_ARTIST\", TIFFTAG_ARTIST, GTIFFTAGTYPE_STRING },\n    { \"TIFFTAG_HOSTCOMPUTER\", TIFFTAG_HOSTCOMPUTER, GTIFFTAGTYPE_STRING },\n    { \"TIFFTAG_COPYRIGHT\", TIFFTAG_COPYRIGHT, GTIFFTAGTYPE_STRING },\n    { \"TIFFTAG_XRESOLUTION\", TIFFTAG_XRESOLUTION, GTIFFTAGTYPE_FLOAT },\n    { \"TIFFTAG_YRESOLUTION\", TIFFTAG_YRESOLUTION, GTIFFTAGTYPE_FLOAT },\n    // Dealt as special case.\n    { \"TIFFTAG_RESOLUTIONUNIT\", TIFFTAG_RESOLUTIONUNIT, GTIFFTAGTYPE_SHORT },\n    { \"TIFFTAG_MINSAMPLEVALUE\", TIFFTAG_MINSAMPLEVALUE, GTIFFTAGTYPE_SHORT },\n    { \"TIFFTAG_MAXSAMPLEVALUE\", TIFFTAG_MAXSAMPLEVALUE, GTIFFTAGTYPE_SHORT },\n\n    // GeoTIFF DGIWG tags\n    { \"GEO_METADATA\", TIFFTAG_GEO_METADATA, GTIFFTAGTYPE_BYTE_STRING },\n    { \"TIFF_RSID\", TIFFTAG_TIFF_RSID, GTIFFTAGTYPE_STRING },\n};\n\nconst char szPROFILE_BASELINE[] = \"BASELINE\";\nconst char szPROFILE_GeoTIFF[] = \"GeoTIFF\";\nconst char szPROFILE_GDALGeoTIFF[] = \"GDALGeoTIFF\";\n\n/************************************************************************/\n/*                          GTIFFSetInExternalOvr()                     */\n/************************************************************************/\n\nvoid GTIFFSetInExternalOvr( bool b )\n{\n    bGlobalInExternalOvr = b;\n}\n\n/************************************************************************/\n/*                     GTIFFGetOverviewBlockSize()                      */\n/************************************************************************/\n\nvoid GTIFFGetOverviewBlockSize( int* pnBlockXSize, int* pnBlockYSize )\n{\n    const char* pszVal = CPLGetConfigOption(\"GDAL_TIFF_OVR_BLOCKSIZE\", \"128\");\n    int nOvrBlockSize = atoi(pszVal);\n    if( nOvrBlockSize < 64 || nOvrBlockSize > 4096 ||\n        !CPLIsPowerOfTwo(nOvrBlockSize) )\n    {\n        static bool bHasWarned = false;\n        if( !bHasWarned )\n        {\n            CPLError( CE_Warning, CPLE_NotSupported,\n                      \"Wrong value for GDAL_TIFF_OVR_BLOCKSIZE : %s. \"\n                      \"Should be a power of 2 between 64 and 4096. \"\n                      \"Defaulting to 128\",\n                      pszVal );\n            bHasWarned = true;\n        }\n        nOvrBlockSize = 128;\n    }\n\n    *pnBlockXSize = nOvrBlockSize;\n    *pnBlockYSize = nOvrBlockSize;\n}\n\nenum\n{\n    ENDIANNESS_NATIVE,\n    ENDIANNESS_LITTLE,\n    ENDIANNESS_BIG\n};\n\n/************************************************************************/\n/* ==================================================================== */\n/*                          GTiffDataset                                */\n/* ==================================================================== */\n/************************************************************************/\n\nclass GTiffBitmapBand;\nclass GTiffDataset;\nclass GTiffJPEGOverviewBand;\nclass GTiffJPEGOverviewDS;\nclass GTiffRasterBand;\nclass GTiffRGBABand;\n\ntypedef enum\n{\n    VIRTUAL_MEM_IO_NO,\n    VIRTUAL_MEM_IO_YES,\n    VIRTUAL_MEM_IO_IF_ENOUGH_RAM\n} VirtualMemIOEnum;\n\n#if !defined(__MINGW32__)\nnamespace {\n#endif\ntypedef struct\n{\n    GTiffDataset *poDS;\n    bool          bTIFFIsBigEndian;\n    char         *pszTmpFilename;\n    int           nHeight;\n    uint16        nPredictor;\n    GByte        *pabyBuffer;\n    int           nBufferSize;\n    int           nStripOrTile;\n\n    GByte        *pabyCompressedBuffer;  // Owned by pszTmpFilename.\n    int           nCompressedBufferSize;\n    bool          bReady;\n} GTiffCompressionJob;\n#if !defined(__MINGW32__)\n}\n#endif\n\nclass GTiffDataset final : public GDALPamDataset\n{\n    CPL_DISALLOW_COPY_ASSIGN(GTiffDataset)\n\n    friend class GTiffBitmapBand;\n    friend class GTiffJPEGOverviewDS;\n    friend class GTiffJPEGOverviewBand;\n    friend class GTiffOddBitsBand;\n    friend class GTiffRasterBand;\n    friend class GTiffRGBABand;\n    friend class GTiffSplitBand;\n    friend class GTiffSplitBitmapBand;\n\n    friend void  GTIFFSetJpegQuality( GDALDatasetH hGTIFFDS, int nJpegQuality );\n    friend void  GTIFFSetJpegTablesMode( GDALDatasetH hGTIFFDS, int nJpegTablesMode );\n\n    TIFF       *hTIFF;\n    VSILFILE   *fpL;\n#if defined(INTERNAL_LIBTIFF) && defined(DEFER_STRILE_LOAD)\n    uint32      nStripArrayAlloc;\n    vsi_l_offset m_nFileSize; // 0 when unknown, only valid in GA_ReadOnly mode\n#endif\n\n    bool        bStreamingIn;\n\n    bool        bStreamingOut;\n    CPLString   osTmpFilename{};\n    VSILFILE*   fpToWrite;\n    int         nLastWrittenBlockId;\n\n    GTiffDataset **ppoActiveDSRef;\n    GTiffDataset *poActiveDS;  // Only used in actual base.\n\n    bool        bScanDeferred;\n    void        ScanDirectories();\n\n    toff_t      nDirOffset;\n    bool        bBase;\n    // Useful for closing TIFF handle opened by GTIFF_DIR:\n    bool        bCloseTIFFHandle;\n\n    uint16      nPlanarConfig;\n    uint16      nSamplesPerPixel;\n    uint16      nBitsPerSample;\n    uint32      nRowsPerStrip;\n    uint16      nPhotometric;\n    uint16      nSampleFormat;\n    uint16      nCompression;\n\n    int         nBlocksPerBand;\n\n    int         nBlockXSize;\n    int         nBlockYSize;\n\n    int         nLoadedBlock;  // Or tile.\n    bool        bLoadedBlockDirty;\n    GByte       *pabyBlockBuf;\n\n    CPLErr      LoadBlockBuf( int nBlockId, bool bReadFromDisk = true );\n    CPLErr      FlushBlockBuf();\n    bool        bWriteErrorInFlushBlockBuf;\n\n    char        *pszProjection;\n    CPLString   m_osVertUnit{};\n    bool        bLookedForProjection;\n    bool        bLookedForMDAreaOrPoint;\n\n    void        LoadMDAreaOrPoint();\n    void        LookForProjection();\n#ifdef ESRI_BUILD\n    void        AdjustLinearUnit( short UOMLength );\n#endif\n\n    double      adfGeoTransform[6];\n    bool        bGeoTransformValid;\n\n    bool        bTreatAsRGBA;\n    bool        bCrystalized;\n\n    void        Crystalize();  // TODO: Spelling.\n    void        RestoreVolatileParameters(TIFF* l_hTIFF);\n\n    GDALColorTable *poColorTable;\n\n    void        WriteGeoTIFFInfo();\n    bool        SetDirectory( toff_t nDirOffset = 0 );\n\n    int         nOverviewCount;\n    GTiffDataset **papoOverviewDS;\n\n    // If > 0, the implicit JPEG overviews are visible through\n    // GetOverviewCount().\n    int         nJPEGOverviewVisibilityCounter;\n    // Currently visible overviews. Generally == nJPEGOverviewCountOri.\n    int         nJPEGOverviewCount;\n    int         nJPEGOverviewCountOri;  // Size of papoJPEGOverviewDS.\n    GTiffJPEGOverviewDS **papoJPEGOverviewDS;\n    int         GetJPEGOverviewCount();\n\n    int         nGCPCount;\n    GDAL_GCP    *pasGCPList;\n\n    bool        IsBlockAvailable( int nBlockId,\n                                  vsi_l_offset* pnOffset = nullptr,\n                                  vsi_l_offset* pnSize = nullptr,\n                                  bool *pbErrOccurred = nullptr );\n\n    bool        bGeoTIFFInfoChanged;\n    bool        bForceUnsetGTOrGCPs;\n    bool        bForceUnsetProjection;\n\n    bool        bNoDataChanged;\n    bool        bNoDataSet;\n    double      dfNoDataValue;\n\n    bool        bMetadataChanged;\n    bool        bColorProfileMetadataChanged;\n    bool        m_bForceUnsetRPC = false;\n\n    bool        bNeedsRewrite;\n\n    void        ApplyPamInfo();\n    void        PushMetadataToPam();\n\n    GDALMultiDomainMetadata oGTiffMDMD{};\n\n    CPLString   osProfile{};\n    char      **papszCreationOptions;\n\n    bool        bLoadingOtherBands;\n\n    void*        pabyTempWriteBuffer;\n    int          nTempWriteBufferSize;\n    bool         WriteEncodedTile( uint32 tile, GByte* pabyData,\n                                   int bPreserveDataBuffer );\n    bool         WriteEncodedStrip( uint32 strip, GByte* pabyData,\n                                    int bPreserveDataBuffer );\n    template<class T>\n    bool         HasOnlyNoDataT( const T* pBuffer, int nWidth, int nHeight,\n                                int nLineStride, int nComponents ) const;\n    bool         HasOnlyNoData( const void* pBuffer, int nWidth, int nHeight,\n                                int nLineStride, int nComponents );\n    inline bool  IsFirstPixelEqualToNoData( const void* pBuffer );\n\n    GTiffDataset* poMaskDS;\n    GTiffDataset* poBaseDS;\n    bool          bIsOverview_ = false;\n\n    CPLString    osFilename{};\n\n    bool         bWriteEmptyTiles;\n    bool         bFillEmptyTilesAtClosing;\n    void         FillEmptyTiles();\n\n    void         FlushDirectory();\n    CPLErr       CleanOverviews();\n\n    // Used for the all-in-on-strip case.\n    int           nLastLineRead;\n    int           nLastBandRead;\n    bool          bTreatAsSplit;\n    bool          bTreatAsSplitBitmap;\n\n    bool          bClipWarn;\n\n    bool          bIMDRPCMetadataLoaded;\n    char**        papszMetadataFiles;\n    void          LoadMetadata();\n\n    bool          bEXIFMetadataLoaded;\n    void          LoadEXIFMetadata();\n\n    bool          bICCMetadataLoaded;\n    void          LoadICCProfile();\n\n    bool          bHasWarnedDisableAggressiveBandCaching;\n\n    bool          bDontReloadFirstBlock;  // Hack for libtiff 3.X and #3633.\n\n    int           nZLevel;\n    int           nLZMAPreset;\n    int           nZSTDLevel;\n    int           nWebPLevel;\n    bool          bWebPLossless;\n    int           nJpegQuality;\n    int           nJpegTablesMode;\n#if HAVE_LERC\n    double        dfMaxZError = 0.0;\n    uint32        anLercAddCompressionAndVersion[2]{0,0};\n#endif\n\n    bool          bPromoteTo8Bits;\n\n    bool          bDebugDontWriteBlocks;\n\n    CPLErr        RegisterNewOverviewDataset( toff_t nOverviewOffset, int l_nJpegQuality );\n    CPLErr        CreateOverviewsFromSrcOverviews( GDALDataset* poSrcDS );\n    CPLErr        CreateInternalMaskOverviews( int nOvrBlockXSize,\n                                               int nOvrBlockYSize );\n\n    bool          bIsFinalized;\n    int           Finalize();\n\n    bool          bIgnoreReadErrors;\n\n    CPLString     osGeorefFilename{};\n\n    bool          bDirectIO;\n\n    VirtualMemIOEnum eVirtualMemIOUsage;\n    CPLVirtualMem* psVirtualMemIOMapping;\n\n    GTIFFKeysFlavorEnum eGeoTIFFKeysFlavor;\n\n    CPLVirtualMem *pBaseMapping;\n    int            nRefBaseMapping;\n\n    bool           bHasDiscardedLsb;\n    std::vector<int> anMaskLsb{};\n    std::vector<int> anOffsetLsb{};\n    void           DiscardLsb(GByte* pabyBuffer, int nBytes, int iBand) const;\n    void           GetDiscardLsbOption( char** papszOptions );\n\n    CPLWorkerThreadPool *poCompressThreadPool;\n    std::vector<GTiffCompressionJob> asCompressionJobs{};\n    CPLMutex      *hCompressThreadPoolMutex;\n    void           InitCompressionThreads( char** papszOptions );\n    void           InitCreationOrOpenOptions( char** papszOptions );\n    static void    ThreadCompressionFunc( void* pData );\n    void           WaitCompletionForBlock( int nBlockId );\n    void           WriteRawStripOrTile( int nStripOrTile,\n                                        GByte* pabyCompressedBuffer,\n                                        int nCompressedBufferSize );\n    bool           SubmitCompressionJob( int nStripOrTile, GByte* pabyData,\n                                         int cc, int nHeight) ;\n\n    int            GuessJPEGQuality( bool& bOutHasQuantizationTable,\n                                     bool& bOutHasHuffmanTable );\n\n    void           SetJPEGQualityAndTablesModeFromFile();\n\n    int            DirectIO( GDALRWFlag eRWFlag,\n                             int nXOff, int nYOff, int nXSize, int nYSize,\n                             void * pData, int nBufXSize, int nBufYSize,\n                             GDALDataType eBufType,\n                             int nBandCount, int *panBandMap,\n                             GSpacing nPixelSpace, GSpacing nLineSpace,\n                             GSpacing nBandSpace,\n                             GDALRasterIOExtraArg* psExtraArg );\n\n    int            VirtualMemIO( GDALRWFlag eRWFlag,\n                                 int nXOff, int nYOff, int nXSize, int nYSize,\n                                 void * pData, int nBufXSize, int nBufYSize,\n                                 GDALDataType eBufType,\n                                 int nBandCount, int *panBandMap,\n                                 GSpacing nPixelSpace, GSpacing nLineSpace,\n                                 GSpacing nBandSpace,\n                                 GDALRasterIOExtraArg* psExtraArg );\n\n    GByte          *m_pTempBufferForCommonDirectIO;\n    size_t          m_nTempBufferForCommonDirectIOSize;\n    template<class FetchBuffer> CPLErr CommonDirectIO(\n        FetchBuffer& oFetcher,\n        int nXOff, int nYOff, int nXSize, int nYSize,\n        void * pData, int nBufXSize, int nBufYSize,\n        GDALDataType eBufType,\n        int nBandCount, int *panBandMap,\n        GSpacing nPixelSpace, GSpacing nLineSpace,\n        GSpacing nBandSpace );\n\n    bool        m_bReadGeoTransform;\n    bool        m_bLoadPam;\n    void        LoadGeoreferencingAndPamIfNeeded();\n\n    bool        m_bHasGotSiblingFiles;\n    char      **GetSiblingFiles();\n\n    void        IdentifyAuthorizedGeoreferencingSources();\n    bool        m_bHasIdentifiedAuthorizedGeoreferencingSources;\n    int         m_nPAMGeorefSrcIndex;\n    int         m_nINTERNALGeorefSrcIndex;\n    int         m_nTABFILEGeorefSrcIndex;\n    int         m_nWORLDFILEGeorefSrcIndex;\n    int         m_nGeoTransformGeorefSrcIndex;\n\n    void        FlushCacheInternal( bool bFlushDirectory );\n\n    int         m_nHasOptimizedReadMultiRange = -1;\n    int         HasOptimizedReadMultiRange();\n\n  protected:\n    virtual int         CloseDependentDatasets() override;\n\n  public:\n             GTiffDataset();\n    virtual ~GTiffDataset();\n\n    virtual const char *GetProjectionRef() override;\n    virtual CPLErr SetProjection( const char * ) override;\n    virtual CPLErr GetGeoTransform( double * ) override;\n    virtual CPLErr SetGeoTransform( double * ) override;\n\n    virtual int    GetGCPCount() override;\n    virtual const char *GetGCPProjection() override;\n    virtual const GDAL_GCP *GetGCPs() override;\n    CPLErr         SetGCPs( int, const GDAL_GCP *, const char * ) override;\n\n    virtual CPLErr IRasterIO( GDALRWFlag eRWFlag,\n                              int nXOff, int nYOff, int nXSize, int nYSize,\n                              void * pData, int nBufXSize, int nBufYSize,\n                              GDALDataType eBufType,\n                              int nBandCount, int *panBandMap,\n                              GSpacing nPixelSpace, GSpacing nLineSpace,\n                              GSpacing nBandSpace,\n                              GDALRasterIOExtraArg* psExtraArg ) override;\n    virtual char **GetFileList() override;\n\n    virtual CPLErr IBuildOverviews( const char *, int, int *, int, int *,\n                                    GDALProgressFunc, void * ) override;\n\n    CPLErr         OpenOffset( TIFF *, GTiffDataset **ppoActiveDSRef,\n                               toff_t nDirOffset, bool bBaseIn, GDALAccess,\n                               bool bAllowRGBAInterface = true,\n                               bool bReadGeoTransform = false );\n\n    static GDALDataset *OpenDir( GDALOpenInfo * );\n    static GDALDataset *Open( GDALOpenInfo * );\n    static int          Identify( GDALOpenInfo * );\n    static GDALDataset *Create( const char * pszFilename,\n                                int nXSize, int nYSize, int nBands,\n                                GDALDataType eType, char ** papszParmList );\n    static GDALDataset *CreateCopy( const char * pszFilename,\n                                    GDALDataset *poSrcDS,\n                                    int bStrict, char ** papszOptions,\n                                    GDALProgressFunc pfnProgress,\n                                    void * pProgressData );\n    virtual void    FlushCache() override;\n\n    virtual char  **GetMetadataDomainList() override;\n    virtual CPLErr  SetMetadata( char **, const char * = \"\" ) override;\n    virtual char  **GetMetadata( const char * pszDomain = \"\" ) override;\n    virtual CPLErr  SetMetadataItem( const char*, const char*,\n                                     const char* = \"\" ) override;\n    virtual const char *GetMetadataItem( const char * pszName,\n                                         const char * pszDomain = \"\" ) override;\n    virtual void   *GetInternalHandle( const char * ) override;\n\n    virtual CPLErr          CreateMaskBand( int nFlags ) override;\n\n    // Only needed by createcopy and close code.\n    static void     WriteRPC( GDALDataset *, TIFF *, int, const char *,\n                              const char *, char **,\n                              bool bWriteOnlyInPAMIfNeeded = false );\n    static bool     WriteMetadata( GDALDataset *, TIFF *, bool, const char *,\n                                   const char *, char **,\n                                   bool bExcludeRPBandIMGFileWriting = false );\n    static void     WriteNoDataValue( TIFF *, double );\n    static void     UnsetNoDataValue( TIFF * );\n\n    static TIFF *   CreateLL( const char * pszFilename,\n                              int nXSize, int nYSize, int nBands,\n                              GDALDataType eType,\n                              double dfExtraSpaceForOverviews,\n                              char **papszParmList,\n                              VSILFILE** pfpL,\n                              CPLString& osTmpFilename );\n\n    CPLErr   WriteEncodedTileOrStrip( uint32 tile_or_strip, void* data,\n                                      int bPreserveDataBuffer );\n\n    static void SaveICCProfile( GTiffDataset *pDS, TIFF *hTIFF,\n                                char **papszParmList, uint32 nBitsPerSample );\n\n    static bool HasVerticalCS(const char* pszProjectionIn);\n};\n\n/************************************************************************/\n/* ==================================================================== */\n/*                        GTiffJPEGOverviewDS                           */\n/* ==================================================================== */\n/************************************************************************/\n\nclass GTiffJPEGOverviewDS final : public GDALDataset\n{\n    CPL_DISALLOW_COPY_ASSIGN(GTiffJPEGOverviewDS)\n\n    friend class GTiffJPEGOverviewBand;\n    GTiffDataset* poParentDS;\n    int nOverviewLevel;\n\n    int        nJPEGTableSize;\n    GByte     *pabyJPEGTable;\n    CPLString  osTmpFilenameJPEGTable{};\n\n    CPLString    osTmpFilename{};\n    GDALDataset* poJPEGDS;\n    // Valid block id of the parent DS that match poJPEGDS.\n    int          nBlockId;\n\n  public:\n    GTiffJPEGOverviewDS( GTiffDataset* poParentDS, int nOverviewLevel,\n                         const void* pJPEGTable, int nJPEGTableSize );\n    virtual ~GTiffJPEGOverviewDS();\n\n    virtual CPLErr IRasterIO( GDALRWFlag eRWFlag,\n                              int nXOff, int nYOff, int nXSize, int nYSize,\n                              void * pData, int nBufXSize, int nBufYSize,\n                              GDALDataType eBufType,\n                              int nBandCount, int *panBandMap,\n                              GSpacing nPixelSpace, GSpacing nLineSpace,\n                              GSpacing nBandSpace,\n                              GDALRasterIOExtraArg* psExtraArg ) override;\n};\n\nclass GTiffJPEGOverviewBand final : public GDALRasterBand\n{\n  public:\n    GTiffJPEGOverviewBand( GTiffJPEGOverviewDS* poDS, int nBand );\n    virtual ~GTiffJPEGOverviewBand() {}\n\n    virtual CPLErr IReadBlock( int, int, void * ) override;\n};\n\n/************************************************************************/\n/*                        GTiffJPEGOverviewDS()                         */\n/************************************************************************/\n\nGTiffJPEGOverviewDS::GTiffJPEGOverviewDS( GTiffDataset* poParentDSIn,\n                                          int nOverviewLevelIn,\n                                          const void* pJPEGTable,\n                                          int nJPEGTableSizeIn ) :\n    poParentDS(poParentDSIn),\n    nOverviewLevel(nOverviewLevelIn),\n    nJPEGTableSize(nJPEGTableSizeIn),\n    pabyJPEGTable(nullptr),\n    poJPEGDS(nullptr),\n    nBlockId(-1)\n{\n    osTmpFilenameJPEGTable.Printf(\"/vsimem/jpegtable_%p\", this);\n\n    const GByte abyAdobeAPP14RGB[] = {\n        0xFF, 0xEE, 0x00, 0x0E, 0x41, 0x64, 0x6F, 0x62, 0x65, 0x00,\n        0x64, 0x00, 0x00, 0x00, 0x00, 0x00 };\n    const bool bAddAdobe =\n        poParentDS->nPlanarConfig == PLANARCONFIG_CONTIG &&\n        poParentDS->nPhotometric != PHOTOMETRIC_YCBCR &&\n        poParentDS->nBands == 3;\n    pabyJPEGTable =\n        static_cast<GByte*>( CPLMalloc(\n            nJPEGTableSize + (bAddAdobe ? sizeof(abyAdobeAPP14RGB) : 0)) );\n    memcpy(pabyJPEGTable, pJPEGTable, nJPEGTableSize);\n    if( bAddAdobe )\n    {\n        memcpy( pabyJPEGTable + nJPEGTableSize, abyAdobeAPP14RGB,\n                sizeof(abyAdobeAPP14RGB) );\n        nJPEGTableSize += sizeof(abyAdobeAPP14RGB);\n    }\n    CPL_IGNORE_RET_VAL(\n        VSIFCloseL(\n            VSIFileFromMemBuffer(\n                osTmpFilenameJPEGTable, pabyJPEGTable, nJPEGTableSize, TRUE )));\n\n    const int nScaleFactor = 1 << nOverviewLevel;\n    nRasterXSize = (poParentDS->nRasterXSize + nScaleFactor - 1) / nScaleFactor;\n    nRasterYSize = (poParentDS->nRasterYSize + nScaleFactor - 1) / nScaleFactor;\n\n    for( int i = 1; i <= poParentDS->nBands; ++i )\n        SetBand(i, new GTiffJPEGOverviewBand(this, i));\n\n    SetMetadataItem( \"INTERLEAVE\", \"PIXEL\", \"IMAGE_STRUCTURE\" );\n    if( poParentDS->nPhotometric == PHOTOMETRIC_YCBCR )\n        SetMetadataItem( \"COMPRESSION\", \"YCbCr JPEG\", \"IMAGE_STRUCTURE\" );\n    else\n        SetMetadataItem( \"COMPRESSION\", \"JPEG\", \"IMAGE_STRUCTURE\" );\n}\n\n/************************************************************************/\n/*                       ~GTiffJPEGOverviewDS()                         */\n/************************************************************************/\n\nGTiffJPEGOverviewDS::~GTiffJPEGOverviewDS()\n{\n    if( poJPEGDS != nullptr )\n        GDALClose( poJPEGDS );\n    VSIUnlink(osTmpFilenameJPEGTable);\n    if( !osTmpFilename.empty() )\n        VSIUnlink(osTmpFilename);\n}\n\n/************************************************************************/\n/*                            IRasterIO()                               */\n/************************************************************************/\n\nCPLErr GTiffJPEGOverviewDS::IRasterIO(\n    GDALRWFlag eRWFlag,\n    int nXOff, int nYOff, int nXSize, int nYSize,\n    void * pData, int nBufXSize, int nBufYSize,\n    GDALDataType eBufType,\n    int nBandCount, int *panBandMap,\n    GSpacing nPixelSpace, GSpacing nLineSpace,\n    GSpacing nBandSpace,\n    GDALRasterIOExtraArg* psExtraArg )\n\n{\n    // For non-single strip JPEG-IN-TIFF, the block based strategy will\n    // be the most efficient one, to avoid decompressing the JPEG content\n    // for each requested band.\n    if( nBandCount > 1 && poParentDS->nPlanarConfig == PLANARCONFIG_CONTIG &&\n        (poParentDS->nBlockXSize < poParentDS->nRasterXSize ||\n         poParentDS->nBlockYSize > 1) )\n    {\n        return BlockBasedRasterIO( eRWFlag, nXOff, nYOff, nXSize, nYSize,\n                                   pData, nBufXSize, nBufYSize,\n                                   eBufType, nBandCount, panBandMap,\n                                   nPixelSpace, nLineSpace, nBandSpace,\n                                   psExtraArg );\n    }\n\n    return GDALDataset::IRasterIO(\n        eRWFlag, nXOff, nYOff, nXSize, nYSize,\n        pData, nBufXSize, nBufYSize, eBufType,\n        nBandCount, panBandMap, nPixelSpace, nLineSpace, nBandSpace,\n        psExtraArg );\n}\n\n/************************************************************************/\n/*                        GTiffJPEGOverviewBand()                       */\n/************************************************************************/\n\nGTiffJPEGOverviewBand::GTiffJPEGOverviewBand( GTiffJPEGOverviewDS* poDSIn,\n                                              int nBandIn )\n{\n    poDS = poDSIn;\n    nBand = nBandIn;\n    eDataType =\n        poDSIn->poParentDS->GetRasterBand(nBandIn)->GetRasterDataType();\n    poDSIn->poParentDS->GetRasterBand(nBandIn)->\n        GetBlockSize(&nBlockXSize, &nBlockYSize);\n    const int nScaleFactor = 1 << poDSIn->nOverviewLevel;\n    nBlockXSize = (nBlockXSize + nScaleFactor - 1) / nScaleFactor;\n    nBlockYSize = (nBlockYSize + nScaleFactor - 1) / nScaleFactor;\n}\n\n/************************************************************************/\n/*                          IReadBlock()                                */\n/************************************************************************/\n\nCPLErr GTiffJPEGOverviewBand::IReadBlock( int nBlockXOff, int nBlockYOff,\n                                          void *pImage )\n{\n    GTiffJPEGOverviewDS* poGDS = cpl::down_cast<GTiffJPEGOverviewDS *>(poDS);\n\n    // Compute the source block ID.\n    int nBlockId = 0;\n    int nParentBlockXSize, nParentBlockYSize;\n    poGDS->poParentDS->GetRasterBand(1)->\n        GetBlockSize(&nParentBlockXSize, &nParentBlockYSize);\n    const bool bIsSingleStripAsSplit = (nParentBlockYSize == 1 &&\n                           poGDS->poParentDS->nBlockYSize != nParentBlockYSize);\n    if( !bIsSingleStripAsSplit )\n    {\n        int l_nBlocksPerRow = DIV_ROUND_UP(poGDS->poParentDS->nRasterXSize,\n                                               poGDS->poParentDS->nBlockXSize);\n        nBlockId = nBlockYOff * l_nBlocksPerRow + nBlockXOff;\n    }\n    if( poGDS->poParentDS->nPlanarConfig == PLANARCONFIG_SEPARATE )\n    {\n        nBlockId += (nBand-1) * poGDS->poParentDS->nBlocksPerBand;\n    }\n\n    if( !poGDS->poParentDS->SetDirectory() )\n        return CE_Failure;\n\n    // Make sure it is available.\n    const int nDataTypeSize = GDALGetDataTypeSizeBytes(eDataType);\n    vsi_l_offset nOffset = 0;\n    vsi_l_offset nByteCount = 0;\n    bool bErrOccurred = false;\n    if( !poGDS->poParentDS->IsBlockAvailable(nBlockId, &nOffset, &nByteCount, &bErrOccurred) )\n    {\n        memset(pImage, 0, nBlockXSize * nBlockYSize * nDataTypeSize );\n        if( bErrOccurred )\n            return CE_Failure;\n        return CE_None;\n    }\n\n    const int nScaleFactor = 1 << poGDS->nOverviewLevel;\n    if( poGDS->poJPEGDS == nullptr || nBlockId != poGDS->nBlockId )\n    {\n        if( nByteCount < 2 )\n            return CE_Failure;\n        nOffset += 2;  // Skip leading 0xFF 0xF8.\n        nByteCount -= 2;\n\n        // Special case for last strip that might be smaller than other strips\n        // In which case we must invalidate the dataset.\n        TIFF* hTIFF = poGDS->poParentDS->hTIFF;\n        if( !TIFFIsTiled( hTIFF ) && !bIsSingleStripAsSplit &&\n            (nBlockYOff + 1 ==\n                 DIV_ROUND_UP( poGDS->poParentDS->nRasterYSize,\n                               poGDS->poParentDS->nBlockYSize ) ||\n             (poGDS->poJPEGDS != nullptr &&\n              poGDS->poJPEGDS->GetRasterYSize() !=\n              nBlockYSize * nScaleFactor)) )\n        {\n            if( poGDS->poJPEGDS != nullptr )\n                GDALClose( poGDS->poJPEGDS );\n            poGDS->poJPEGDS = nullptr;\n        }\n\n        CPLString osFileToOpen;\n        poGDS->osTmpFilename.Printf(\"/vsimem/sparse_%p\", poGDS);\n        VSILFILE* fp = VSIFOpenL(poGDS->osTmpFilename, \"wb+\");\n\n        // If the size of the JPEG strip/tile is small enough, we will\n        // read it from the TIFF file and forge a in-memory JPEG file with\n        // the JPEG table followed by the JPEG data.\n        const bool bInMemoryJPEGFile = nByteCount < 256 * 256;\n        if( bInMemoryJPEGFile )\n        {\n            // If the previous file was opened as a /vsisparse/, must re-open.\n            if( poGDS->poJPEGDS != nullptr &&\n                STARTS_WITH(poGDS->poJPEGDS->GetDescription(), \"/vsisparse/\") )\n            {\n                GDALClose( poGDS->poJPEGDS );\n                poGDS->poJPEGDS = nullptr;\n            }\n            osFileToOpen = poGDS->osTmpFilename;\n\n            bool bError = false;\n            if( VSIFSeekL(fp, poGDS->nJPEGTableSize + nByteCount - 1, SEEK_SET)\n                != 0 )\n                bError = true;\n            char ch = 0;\n            if( !bError && VSIFWriteL(&ch, 1, 1, fp) != 1 )\n                bError = true;\n            GByte* pabyBuffer =\n                VSIGetMemFileBuffer( poGDS->osTmpFilename, nullptr, FALSE);\n            memcpy(pabyBuffer, poGDS->pabyJPEGTable, poGDS->nJPEGTableSize);\n            VSILFILE* fpTIF = VSI_TIFFGetVSILFile(TIFFClientdata( hTIFF ));\n            if( !bError && VSIFSeekL(fpTIF, nOffset, SEEK_SET) != 0 )\n                bError = true;\n            if( VSIFReadL( pabyBuffer + poGDS->nJPEGTableSize,\n                           static_cast<size_t>(nByteCount), 1, fpTIF) != 1 )\n                bError = true;\n            if( bError )\n            {\n                CPL_IGNORE_RET_VAL(VSIFCloseL(fp));\n                return CE_Failure;\n            }\n        }\n        else\n        {\n            // If the JPEG strip/tile is too big (e.g. a single-strip\n            // JPEG-in-TIFF), we will use /vsisparse mechanism to make a\n            // fake JPEG file.\n\n            // Always re-open.\n            GDALClose( poGDS->poJPEGDS );\n            poGDS->poJPEGDS = nullptr;\n\n            osFileToOpen =\n                CPLSPrintf(\"/vsisparse/%s\", poGDS->osTmpFilename.c_str());\n\n            if( VSIFPrintfL(\n                    fp,\n                    \"<VSISparseFile><SubfileRegion>\"\n                    \"<Filename relative='0'>%s</Filename>\"\n                    \"<DestinationOffset>0</DestinationOffset>\"\n                    \"<SourceOffset>0</SourceOffset>\"\n                    \"<RegionLength>%d</RegionLength>\"\n                    \"</SubfileRegion>\"\n                    \"<SubfileRegion>\"\n                    \"<Filename relative='0'>%s</Filename>\"\n                    \"<DestinationOffset>%d</DestinationOffset>\"\n                    \"<SourceOffset>\" CPL_FRMT_GUIB \"</SourceOffset>\"\n                    \"<RegionLength>\" CPL_FRMT_GUIB \"</RegionLength>\"\n                    \"</SubfileRegion></VSISparseFile>\",\n                    poGDS->osTmpFilenameJPEGTable.c_str(),\n                    static_cast<int>(poGDS->nJPEGTableSize),\n                    poGDS->poParentDS->GetDescription(),\n                    static_cast<int>(poGDS->nJPEGTableSize),\n                    nOffset,\n                    nByteCount) < 0 )\n            {\n                CPL_IGNORE_RET_VAL(VSIFCloseL(fp));\n                return CE_Failure;\n            }\n        }\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fp));\n\n        if( poGDS->poJPEGDS == nullptr )\n        {\n            const char* apszDrivers[] = { \"JPEG\", nullptr };\n\n            CPLString osOldVal;\n            if( poGDS->poParentDS->nPlanarConfig == PLANARCONFIG_CONTIG &&\n                poGDS->nBands == 4 )\n            {\n                osOldVal =\n                    CPLGetThreadLocalConfigOption(\"GDAL_JPEG_TO_RGB\", \"\");\n                CPLSetThreadLocalConfigOption(\"GDAL_JPEG_TO_RGB\", \"NO\");\n            }\n\n            poGDS->poJPEGDS =\n                static_cast<GDALDataset *>( GDALOpenEx(\n                    osFileToOpen,\n                    GDAL_OF_RASTER | GDAL_OF_INTERNAL,\n                    apszDrivers, nullptr, nullptr) );\n\n            if( poGDS->poJPEGDS != nullptr )\n            {\n                // Force all implicit overviews to be available, even for\n                // small tiles.\n                CPLSetThreadLocalConfigOption( \"JPEG_FORCE_INTERNAL_OVERVIEWS\",\n                                               \"YES\");\n                GDALGetOverviewCount(GDALGetRasterBand(poGDS->poJPEGDS, 1));\n                CPLSetThreadLocalConfigOption( \"JPEG_FORCE_INTERNAL_OVERVIEWS\",\n                                               nullptr);\n\n                poGDS->nBlockId = nBlockId;\n            }\n\n            if( poGDS->poParentDS->nPlanarConfig == PLANARCONFIG_CONTIG &&\n                poGDS->nBands == 4 )\n            {\n                CPLSetThreadLocalConfigOption(\n                    \"GDAL_JPEG_TO_RGB\",\n                    !osOldVal.empty() ? osOldVal.c_str() : nullptr );\n            }\n        }\n        else\n        {\n            // Trick: we invalidate the JPEG dataset to force a reload\n            // of the new content.\n            CPLErrorReset();\n            poGDS->poJPEGDS->FlushCache();\n            if( CPLGetLastErrorNo() != 0 )\n            {\n                GDALClose( poGDS->poJPEGDS );\n                poGDS->poJPEGDS = nullptr;\n                return CE_Failure;\n            }\n            poGDS->nBlockId = nBlockId;\n        }\n    }\n\n    CPLErr eErr = CE_Failure;\n    if( poGDS->poJPEGDS )\n    {\n        GDALDataset* l_poDS = poGDS->poJPEGDS;\n\n        int nReqXOff = 0;\n        int nReqYOff = 0;\n        int nReqXSize = 0;\n        int nReqYSize = 0;\n        if( bIsSingleStripAsSplit )\n        {\n            nReqYOff = nBlockYOff * nScaleFactor;\n            nReqXSize = l_poDS->GetRasterXSize();\n            nReqYSize = nScaleFactor;\n        }\n        else\n        {\n            if( nBlockXSize == poGDS->GetRasterXSize() )\n            {\n                nReqXSize = l_poDS->GetRasterXSize();\n            }\n            else\n            {\n                nReqXSize = nBlockXSize * nScaleFactor;\n            }\n            nReqYSize = nBlockYSize * nScaleFactor;\n        }\n        int nBufXSize = nBlockXSize;\n        int nBufYSize = nBlockYSize;\n        if( nBlockXOff == DIV_ROUND_UP(poGDS->poParentDS->nRasterXSize,\n                                       poGDS->poParentDS->nBlockXSize) - 1 )\n        {\n            nReqXSize = poGDS->poParentDS->nRasterXSize -\n                                nBlockXOff * poGDS->poParentDS->nBlockXSize;\n        }\n        if( nReqXOff + nReqXSize > l_poDS->GetRasterXSize() )\n        {\n            nReqXSize = l_poDS->GetRasterXSize() - nReqXOff;\n        }\n        if( !bIsSingleStripAsSplit &&\n            nBlockYOff == DIV_ROUND_UP(poGDS->poParentDS->nRasterYSize,\n                                       poGDS->poParentDS->nBlockYSize) - 1 )\n        {\n            nReqYSize = poGDS->poParentDS->nRasterYSize -\n                                nBlockYOff * poGDS->poParentDS->nBlockYSize;\n        }\n        if( nReqYOff + nReqYSize > l_poDS->GetRasterYSize() )\n        {\n            nReqYSize = l_poDS->GetRasterYSize() - nReqYOff;\n        }\n        if( nBlockXOff * nBlockXSize > poGDS->GetRasterXSize() - nBufXSize )\n        {\n            memset(pImage, 0, nBlockXSize * nBlockYSize * nDataTypeSize);\n            nBufXSize = poGDS->GetRasterXSize() - nBlockXOff * nBlockXSize;\n        }\n        if( nBlockYOff * nBlockYSize > poGDS->GetRasterYSize() - nBufYSize )\n        {\n            memset(pImage, 0, nBlockXSize * nBlockYSize * nDataTypeSize);\n            nBufYSize = poGDS->GetRasterYSize() - nBlockYOff * nBlockYSize;\n        }\n\n        const int nSrcBand =\n            poGDS->poParentDS->nPlanarConfig == PLANARCONFIG_SEPARATE ?\n            1 : nBand;\n        if( nSrcBand <= l_poDS->GetRasterCount() )\n        {\n            eErr = l_poDS->GetRasterBand(nSrcBand)->RasterIO(GF_Read,\n                                 nReqXOff, nReqYOff, nReqXSize, nReqYSize,\n                                 pImage,\n                                 nBufXSize, nBufYSize, eDataType,\n                                 0, nBlockXSize * nDataTypeSize, nullptr );\n        }\n    }\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                        GTIFFSetJpegQuality()                         */\n/* Called by GTIFFBuildOverviews() to set the jpeg quality on the IFD   */\n/* of the .ovr file.                                                    */\n/************************************************************************/\n\nvoid GTIFFSetJpegQuality( GDALDatasetH hGTIFFDS, int nJpegQuality )\n{\n    CPLAssert(\n        EQUAL(GDALGetDriverShortName(GDALGetDatasetDriver(hGTIFFDS)), \"GTIFF\"));\n\n    GTiffDataset* const poDS = static_cast<GTiffDataset *>(hGTIFFDS);\n    poDS->nJpegQuality = nJpegQuality;\n\n    poDS->ScanDirectories();\n\n    for( int i = 0; i < poDS->nOverviewCount; ++i )\n        poDS->papoOverviewDS[i]->nJpegQuality = nJpegQuality;\n}\n\n/************************************************************************/\n/*                     GTIFFSetJpegTablesMode()                         */\n/* Called by GTIFFBuildOverviews() to set the jpeg tables mode on the   */\n/* of the .ovr file.                                                    */\n/************************************************************************/\n\nvoid GTIFFSetJpegTablesMode( GDALDatasetH hGTIFFDS, int nJpegTablesMode )\n{\n    CPLAssert(\n        EQUAL(GDALGetDriverShortName(GDALGetDatasetDriver(hGTIFFDS)), \"GTIFF\"));\n\n    GTiffDataset* const poDS = static_cast<GTiffDataset *>(hGTIFFDS);\n    poDS->nJpegTablesMode = nJpegTablesMode;\n\n    poDS->ScanDirectories();\n\n    for( int i = 0; i < poDS->nOverviewCount; ++i )\n        poDS->papoOverviewDS[i]->nJpegTablesMode = nJpegTablesMode;\n}\n\n/************************************************************************/\n/* ==================================================================== */\n/*                            GTiffRasterBand                           */\n/* ==================================================================== */\n/************************************************************************/\n\nclass GTiffRasterBand : public GDALPamRasterBand\n{\n    CPL_DISALLOW_COPY_ASSIGN(GTiffRasterBand)\n\n    friend class GTiffDataset;\n\n    GDALColorInterp    eBandInterp;\n\n    bool               bHaveOffsetScale;\n    double             dfOffset;\n    double             dfScale;\n    CPLString          osUnitType{};\n    CPLString          osDescription{};\n\n    int                DirectIO( GDALRWFlag eRWFlag,\n                                 int nXOff, int nYOff, int nXSize, int nYSize,\n                                 void * pData, int nBufXSize, int nBufYSize,\n                                 GDALDataType eBufType,\n                                 GSpacing nPixelSpace, GSpacing nLineSpace,\n                                 GDALRasterIOExtraArg* psExtraArg );\n\n    std::set<GTiffRasterBand **> aSetPSelf{};\n    static void     DropReferenceVirtualMem( void* pUserData );\n    CPLVirtualMem * GetVirtualMemAutoInternal( GDALRWFlag eRWFlag,\n                                               int *pnPixelSpace,\n                                               GIntBig *pnLineSpace,\n                                               char **papszOptions );\n\n    void*           CacheMultiRange( int nXOff, int nYOff,\n                                     int nXSize, int nYSize,\n                                     int nBufXSize, int nBufYSize,\n                                     GDALRasterIOExtraArg* psExtraArg );\n\nprotected:\n    GTiffDataset       *poGDS;\n    GDALMultiDomainMetadata oGTiffMDMD{};\n\n    bool               bNoDataSet;\n    double             dfNoDataValue;\n\n    void NullBlock( void *pData );\n    CPLErr FillCacheForOtherBands( int nBlockXOff, int nBlockYOff );\n\npublic:\n             GTiffRasterBand( GTiffDataset *, int );\n    virtual ~GTiffRasterBand();\n\n    virtual CPLErr IReadBlock( int, int, void * ) override;\n    virtual CPLErr IWriteBlock( int, int, void * ) override;\n\n    virtual int IGetDataCoverageStatus( int nXOff, int nYOff,\n                                        int nXSize, int nYSize,\n                                        int nMaskFlagStop,\n                                        double* pdfDataPct) override;\n\n    virtual CPLErr IRasterIO( GDALRWFlag eRWFlag,\n                              int nXOff, int nYOff, int nXSize, int nYSize,\n                              void * pData, int nBufXSize, int nBufYSize,\n                              GDALDataType eBufType,\n                              GSpacing nPixelSpace, GSpacing nLineSpace,\n                              GDALRasterIOExtraArg* psExtraArg ) override final;\n\n    virtual const char *GetDescription() const override final;\n    virtual void        SetDescription( const char * ) override final;\n\n    virtual GDALColorInterp GetColorInterpretation() override /*final*/;\n    virtual GDALColorTable *GetColorTable() override /*final*/;\n    virtual CPLErr          SetColorTable( GDALColorTable * ) override final;\n    virtual double          GetNoDataValue( int * ) override final;\n    virtual CPLErr          SetNoDataValue( double ) override final;\n    virtual CPLErr DeleteNoDataValue() override final;\n\n    virtual double GetOffset( int *pbSuccess = nullptr ) override final;\n    virtual CPLErr SetOffset( double dfNewValue ) override final;\n    virtual double GetScale( int *pbSuccess = nullptr ) override final;\n    virtual CPLErr SetScale( double dfNewValue ) override final;\n    virtual const char* GetUnitType() override final;\n    virtual CPLErr SetUnitType( const char *pszNewValue ) override final;\n    virtual CPLErr SetColorInterpretation( GDALColorInterp ) override final;\n\n    virtual char      **GetMetadataDomainList() override final;\n    virtual CPLErr  SetMetadata( char **, const char * = \"\" ) override final;\n    virtual char  **GetMetadata( const char * pszDomain = \"\" ) override final;\n    virtual CPLErr  SetMetadataItem( const char*, const char*,\n                                     const char* = \"\" ) override final;\n    virtual const char *GetMetadataItem(\n        const char * pszName, const char * pszDomain = \"\" ) override final;\n    virtual int    GetOverviewCount()  override final;\n    virtual GDALRasterBand *GetOverview( int ) override final;\n\n    virtual GDALRasterBand *GetMaskBand() override final;\n    virtual int             GetMaskFlags() override final;\n    virtual CPLErr          CreateMaskBand( int nFlags )  override final;\n\n    virtual CPLVirtualMem  *GetVirtualMemAuto( GDALRWFlag eRWFlag,\n                                               int *pnPixelSpace,\n                                               GIntBig *pnLineSpace,\n                                               char **papszOptions )  override final;\n\n    GDALRasterAttributeTable* GetDefaultRAT() override final;\n    virtual CPLErr  GetHistogram(\n        double dfMin, double dfMax,\n        int nBuckets, GUIntBig * panHistogram,\n        int bIncludeOutOfRange, int bApproxOK,\n        GDALProgressFunc, void *pProgressData )  override final;\n\n    virtual CPLErr GetDefaultHistogram( double *pdfMin, double *pdfMax,\n                                        int *pnBuckets,\n                                        GUIntBig ** ppanHistogram,\n                                        int bForce,\n                                        GDALProgressFunc,\n                                        void *pProgressData)  override final;\n};\n\n/************************************************************************/\n/*                           GTiffRasterBand()                          */\n/************************************************************************/\n\nGTiffRasterBand::GTiffRasterBand( GTiffDataset *poDSIn, int nBandIn ) :\n    eBandInterp(GCI_Undefined),\n    bHaveOffsetScale(false),\n    dfOffset(0.0),\n    dfScale(1.0),\n    poGDS(poDSIn),\n    bNoDataSet(false),\n    dfNoDataValue(-9999.0)\n{\n    poDS = poDSIn;\n    nBand = nBandIn;\n\n/* -------------------------------------------------------------------- */\n/*      Get the GDAL data type.                                         */\n/* -------------------------------------------------------------------- */\n    const uint16 nBitsPerSample = poGDS->nBitsPerSample;\n    const uint16 nSampleFormat = poGDS->nSampleFormat;\n\n    eDataType = GDT_Unknown;\n\n    if( nBitsPerSample <= 8 )\n    {\n        eDataType = GDT_Byte;\n        if( nSampleFormat == SAMPLEFORMAT_INT )\n            oGTiffMDMD.SetMetadataItem( \"PIXELTYPE\", \"SIGNEDBYTE\",\n                                        \"IMAGE_STRUCTURE\" );\n    }\n    else if( nBitsPerSample <= 16 )\n    {\n        if( nSampleFormat == SAMPLEFORMAT_INT )\n            eDataType = GDT_Int16;\n        else\n            eDataType = GDT_UInt16;\n    }\n    else if( nBitsPerSample == 32 )\n    {\n        if( nSampleFormat == SAMPLEFORMAT_COMPLEXINT )\n            eDataType = GDT_CInt16;\n        else if( nSampleFormat == SAMPLEFORMAT_IEEEFP )\n            eDataType = GDT_Float32;\n        else if( nSampleFormat == SAMPLEFORMAT_INT )\n            eDataType = GDT_Int32;\n        else\n            eDataType = GDT_UInt32;\n    }\n    else if( nBitsPerSample == 64 )\n    {\n        if( nSampleFormat == SAMPLEFORMAT_IEEEFP )\n            eDataType = GDT_Float64;\n        else if( nSampleFormat == SAMPLEFORMAT_COMPLEXIEEEFP )\n            eDataType = GDT_CFloat32;\n        else if( nSampleFormat == SAMPLEFORMAT_COMPLEXINT )\n            eDataType = GDT_CInt32;\n    }\n    else if( nBitsPerSample == 128 )\n    {\n        if( nSampleFormat == SAMPLEFORMAT_COMPLEXIEEEFP )\n            eDataType = GDT_CFloat64;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Try to work out band color interpretation.                      */\n/* -------------------------------------------------------------------- */\n    bool bLookForExtraSamples = false;\n\n    if( poGDS->poColorTable != nullptr && nBand == 1 )\n    {\n        eBandInterp = GCI_PaletteIndex;\n    }\n    else if( poGDS->nPhotometric == PHOTOMETRIC_RGB\n             || (poGDS->nPhotometric == PHOTOMETRIC_YCBCR\n                 && poGDS->nCompression == COMPRESSION_JPEG\n                 && CPLTestBool( CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\",\n                                                    \"YES\") )) )\n    {\n        if( nBand == 1 )\n            eBandInterp = GCI_RedBand;\n        else if( nBand == 2 )\n            eBandInterp = GCI_GreenBand;\n        else if( nBand == 3 )\n            eBandInterp = GCI_BlueBand;\n        else\n            bLookForExtraSamples = true;\n    }\n    else if( poGDS->nPhotometric == PHOTOMETRIC_YCBCR )\n    {\n        if( nBand == 1 )\n            eBandInterp = GCI_YCbCr_YBand;\n        else if( nBand == 2 )\n            eBandInterp = GCI_YCbCr_CbBand;\n        else if( nBand == 3 )\n            eBandInterp = GCI_YCbCr_CrBand;\n        else\n            bLookForExtraSamples = true;\n    }\n    else if( poGDS->nPhotometric == PHOTOMETRIC_SEPARATED )\n    {\n        if( nBand == 1 )\n            eBandInterp = GCI_CyanBand;\n        else if( nBand == 2 )\n            eBandInterp = GCI_MagentaBand;\n        else if( nBand == 3 )\n            eBandInterp = GCI_YellowBand;\n        else if( nBand == 4 )\n            eBandInterp = GCI_BlackBand;\n        else\n            bLookForExtraSamples = true;\n    }\n    else if( poGDS->nPhotometric == PHOTOMETRIC_MINISBLACK && nBand == 1 )\n    {\n        eBandInterp = GCI_GrayIndex;\n    }\n    else\n    {\n        bLookForExtraSamples = true;\n    }\n\n    if( bLookForExtraSamples )\n    {\n        uint16 *v = nullptr;\n        uint16 count = 0;\n\n        if( TIFFGetField( poGDS->hTIFF, TIFFTAG_EXTRASAMPLES, &count, &v ) )\n        {\n            const int nBaseSamples = poGDS->nSamplesPerPixel - count;\n            const int nExpectedBaseSamples =\n                (poGDS->nPhotometric == PHOTOMETRIC_MINISBLACK) ? 1 :\n                (poGDS->nPhotometric == PHOTOMETRIC_MINISWHITE) ? 1 :\n                (poGDS->nPhotometric == PHOTOMETRIC_RGB) ? 3 :\n                (poGDS->nPhotometric == PHOTOMETRIC_YCBCR) ? 3 :\n                (poGDS->nPhotometric == PHOTOMETRIC_SEPARATED) ? 4 : 0;\n\n            if( nExpectedBaseSamples > 0 &&\n                nBand == nExpectedBaseSamples + 1 &&\n                nBaseSamples != nExpectedBaseSamples )\n            {\n                CPLError(CE_Warning, CPLE_AppDefined,\n                         \"Wrong number of ExtraSamples : %d. %d were expected\",\n                         count, poGDS->nSamplesPerPixel - nExpectedBaseSamples);\n            }\n\n            if( nBand > nBaseSamples\n                && nBand-nBaseSamples-1 < count\n                && (v[nBand-nBaseSamples-1] == EXTRASAMPLE_ASSOCALPHA\n                    || v[nBand-nBaseSamples-1] == EXTRASAMPLE_UNASSALPHA) )\n                eBandInterp = GCI_AlphaBand;\n            else\n                eBandInterp = GCI_Undefined;\n        }\n        else\n        {\n            eBandInterp = GCI_Undefined;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Establish block size for strip or tiles.                        */\n/* -------------------------------------------------------------------- */\n    nBlockXSize = poGDS->nBlockXSize;\n    nBlockYSize = poGDS->nBlockYSize;\n}\n\n/************************************************************************/\n/*                          ~GTiffRasterBand()                          */\n/************************************************************************/\n\nGTiffRasterBand::~GTiffRasterBand()\n{\n    // So that any future DropReferenceVirtualMem() will not try to access the\n    // raster band object, but this would not conform to the advertised\n    // contract.\n    if( !aSetPSelf.empty() )\n    {\n        CPLError( CE_Warning, CPLE_AppDefined,\n                  \"Virtual memory objects still exist at GTiffRasterBand \"\n                  \"destruction\" );\n        std::set<GTiffRasterBand**>::iterator oIter = aSetPSelf.begin();\n        for( ; oIter != aSetPSelf.end(); ++oIter )\n            *(*oIter) = nullptr;\n    }\n}\n\n/************************************************************************/\n/*                        FetchBufferDirectIO                           */\n/************************************************************************/\n\nclass FetchBufferDirectIO final\n{\n    VSILFILE*    fp;\n    GByte       *pTempBuffer;\n    size_t       nTempBufferSize;\n\npublic:\n            FetchBufferDirectIO( VSILFILE* fpIn,\n                                 GByte* pTempBufferIn,\n                                 size_t nTempBufferSizeIn ) :\n                fp(fpIn),\n                pTempBuffer(pTempBufferIn),\n                nTempBufferSize(nTempBufferSizeIn) {}\n\n    const GByte* FetchBytes( vsi_l_offset nOffset,\n                             int nPixels, int nDTSize,\n                             bool bIsByteSwapped, bool bIsComplex,\n                             int nBlockId )\n    {\n        if( !FetchBytes(pTempBuffer, nOffset, nPixels, nDTSize, bIsByteSwapped,\n                        bIsComplex, nBlockId) )\n        {\n            return nullptr;\n        }\n        return pTempBuffer;\n    }\n\n    bool FetchBytes( GByte* pabyDstBuffer,\n                     vsi_l_offset nOffset,\n                     int nPixels, int nDTSize,\n                     bool bIsByteSwapped, bool bIsComplex,\n                     int nBlockId )\n    {\n        vsi_l_offset nSeekForward = 0;\n        if( nOffset <= VSIFTellL(fp) ||\n            (nSeekForward = nOffset - VSIFTellL(fp)) > nTempBufferSize )\n        {\n            if( VSIFSeekL(fp, nOffset, SEEK_SET) != 0 )\n            {\n                CPLError(CE_Failure, CPLE_FileIO,\n                         \"Cannot seek to block %d\", nBlockId);\n                return false;\n            }\n        }\n        else\n        {\n            while( nSeekForward > 0 )\n            {\n                vsi_l_offset nToRead = nSeekForward;\n                if( nToRead > nTempBufferSize )\n                    nToRead = nTempBufferSize;\n                if( VSIFReadL(pTempBuffer, static_cast<size_t>(nToRead),\n                              1, fp) != 1 )\n                {\n                    CPLError(CE_Failure, CPLE_FileIO,\n                             \"Cannot seek to block %d\", nBlockId);\n                    return false;\n                }\n                nSeekForward -= nToRead;\n            }\n        }\n        if( VSIFReadL(pabyDstBuffer, nPixels * nDTSize, 1, fp) != 1 )\n        {\n            CPLError(CE_Failure, CPLE_FileIO,\n                     \"Missing data for block %d\", nBlockId);\n            return false;\n        }\n\n        if( bIsByteSwapped )\n        {\n            if( bIsComplex )\n                GDALSwapWords( pabyDstBuffer, nDTSize / 2, 2 * nPixels,\n                               nDTSize / 2 );\n            else\n                GDALSwapWords( pabyDstBuffer, nDTSize, nPixels, nDTSize);\n        }\n        return true;\n    }\n\n    static const EMULATED_BOOL bMinimizeIO = true;\n};\n\n/************************************************************************/\n/*                           DirectIO()                                 */\n/************************************************************************/\n\n// Reads directly bytes from the file using ReadMultiRange(), and by-pass\n// block reading. Restricted to simple TIFF configurations\n// (uncompressed data, standard data types). Particularly useful to extract\n// sub-windows of data on a large /vsicurl dataset).\n// Returns -1 if DirectIO() can't be supported on that file.\n\nint GTiffRasterBand::DirectIO( GDALRWFlag eRWFlag,\n                               int nXOff, int nYOff, int nXSize, int nYSize,\n                               void * pData, int nBufXSize, int nBufYSize,\n                               GDALDataType eBufType,\n                               GSpacing nPixelSpace, GSpacing nLineSpace,\n                               GDALRasterIOExtraArg* psExtraArg )\n{\n    const int nDTSizeBits = GDALGetDataTypeSizeBits(eDataType);\n    if( !(eRWFlag == GF_Read &&\n          poGDS->nCompression == COMPRESSION_NONE &&\n          (poGDS->nPhotometric == PHOTOMETRIC_MINISBLACK ||\n           poGDS->nPhotometric == PHOTOMETRIC_RGB ||\n           poGDS->nPhotometric == PHOTOMETRIC_PALETTE) &&\n          poGDS->nBitsPerSample == nDTSizeBits &&\n          poGDS->SetDirectory() /* very important to make hTIFF uptodate! */) )\n    {\n        return -1;\n    }\n\n    // Only know how to deal with nearest neighbour in this optimized routine.\n    if( (nXSize != nBufXSize || nYSize != nBufYSize) &&\n        psExtraArg != nullptr &&\n        psExtraArg->eResampleAlg != GRIORA_NearestNeighbour )\n    {\n        return -1;\n    }\n\n#if DEBUG_VERBOSE\n    CPLDebug( \"GTiff\", \"DirectIO(%d,%d,%d,%d -> %dx%d)\",\n              nXOff, nYOff, nXSize, nYSize,\n              nBufXSize, nBufYSize );\n#endif\n\n    // Make sure that TIFFTAG_STRIPOFFSETS is up-to-date.\n    if( poGDS->GetAccess() == GA_Update )\n    {\n        poGDS->FlushCache();\n        VSI_TIFFFlushBufferedWrite( TIFFClientdata( poGDS->hTIFF ) );\n    }\n\n    if( TIFFIsTiled( poGDS->hTIFF ) )\n    {\n        if( poGDS->m_pTempBufferForCommonDirectIO == nullptr )\n        {\n            const int nDTSize = nDTSizeBits / 8;\n            poGDS->m_nTempBufferForCommonDirectIOSize =\n                static_cast<size_t>(\n                    nBlockXSize * nBlockYSize * nDTSize *\n                    (poGDS->nPlanarConfig == PLANARCONFIG_CONTIG ?\n                     poGDS->nBands : 1) );\n\n            poGDS->m_pTempBufferForCommonDirectIO =\n                static_cast<GByte *>( VSI_MALLOC_VERBOSE(\n                    poGDS->m_nTempBufferForCommonDirectIOSize ) );\n            if( poGDS->m_pTempBufferForCommonDirectIO == nullptr )\n                return CE_Failure;\n        }\n\n        VSILFILE* fp = VSI_TIFFGetVSILFile(TIFFClientdata( poGDS->hTIFF ));\n        FetchBufferDirectIO oFetcher(fp, poGDS->m_pTempBufferForCommonDirectIO,\n                                     poGDS->m_nTempBufferForCommonDirectIOSize);\n\n        return poGDS->CommonDirectIO(\n            oFetcher,\n            nXOff, nYOff, nXSize, nYSize,\n            pData, nBufXSize, nBufYSize,\n            eBufType,\n            1, &nBand,\n            nPixelSpace, nLineSpace,\n            0 );\n    }\n\n    // Get strip offsets.\n    toff_t *panTIFFOffsets = nullptr;\n    if( !TIFFGetField( poGDS->hTIFF, TIFFTAG_STRIPOFFSETS, &panTIFFOffsets ) ||\n        panTIFFOffsets == nullptr )\n    {\n        return CE_Failure;\n    }\n\n    // Sub-sampling or over-sampling can only be done at last stage.\n    int nReqXSize = nXSize;\n    // Can do sub-sampling at the extraction stage.\n    const int nReqYSize = std::min(nBufYSize, nYSize);\n    // TODO(schwehr): Make ppData be GByte**.\n    void** ppData = static_cast<void **>(\n        VSI_MALLOC_VERBOSE(nReqYSize * sizeof(void*)) );\n    vsi_l_offset* panOffsets = static_cast<vsi_l_offset *>(\n        VSI_MALLOC_VERBOSE(nReqYSize * sizeof(vsi_l_offset)) );\n    size_t* panSizes = static_cast<size_t *>(\n        VSI_MALLOC_VERBOSE(nReqYSize * sizeof(size_t)) );\n    const int nDTSize = GDALGetDataTypeSizeBytes(eDataType);\n    void* pTmpBuffer = nullptr;\n    int eErr = CE_None;\n    int nContigBands =\n        poGDS->nPlanarConfig == PLANARCONFIG_CONTIG ? poGDS->nBands : 1;\n    int nSrcPixelSize = nDTSize * nContigBands;\n\n    if( ppData == nullptr || panOffsets == nullptr || panSizes == nullptr )\n        eErr = CE_Failure;\n    else if( nXSize != nBufXSize || nYSize != nBufYSize ||\n             eBufType != eDataType ||\n             nPixelSpace != GDALGetDataTypeSizeBytes(eBufType) ||\n             nContigBands > 1 )\n    {\n        // We need a temporary buffer for over-sampling/sub-sampling\n        // and/or data type conversion.\n        pTmpBuffer = VSI_MALLOC_VERBOSE(nReqXSize * nReqYSize * nSrcPixelSize);\n        if( pTmpBuffer == nullptr )\n            eErr = CE_Failure;\n    }\n\n    // Prepare data extraction.\n    const double dfSrcYInc = nYSize / static_cast<double>( nBufYSize );\n\n    for( int iLine = 0; eErr == CE_None && iLine < nReqYSize; ++iLine )\n    {\n        if( pTmpBuffer == nullptr )\n            ppData[iLine] = static_cast<GByte *>(pData) + iLine * nLineSpace;\n        else\n            ppData[iLine] =\n                static_cast<GByte *>(pTmpBuffer) +\n                iLine * nReqXSize * nSrcPixelSize;\n        int nSrcLine = 0;\n        if( nBufYSize < nYSize )  // Sub-sampling in y.\n            nSrcLine = nYOff + static_cast<int>((iLine + 0.5) * dfSrcYInc);\n        else\n            nSrcLine = nYOff + iLine;\n\n        const int nBlockXOff = 0;\n        const int nBlockYOff = nSrcLine / nBlockYSize;\n        const int nYOffsetInBlock = nSrcLine % nBlockYSize;\n        nBlocksPerRow = DIV_ROUND_UP(nRasterXSize, nBlockXSize);\n        int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n        if( poGDS->nPlanarConfig == PLANARCONFIG_SEPARATE )\n        {\n            nBlockId += (nBand-1) * poGDS->nBlocksPerBand;\n        }\n\n        panOffsets[iLine] = panTIFFOffsets[nBlockId];\n        if( panOffsets[iLine] == 0 )  // We don't support sparse files.\n            eErr = -1;\n\n        panOffsets[iLine] +=\n            (nXOff + nYOffsetInBlock * nBlockXSize) * nSrcPixelSize;\n        panSizes[iLine] = nReqXSize * nSrcPixelSize;\n    }\n\n    // Extract data from the file.\n    if( eErr == CE_None )\n    {\n        VSILFILE* fp = VSI_TIFFGetVSILFile(TIFFClientdata( poGDS->hTIFF ));\n        const int nRet =\n            VSIFReadMultiRangeL( nReqYSize, ppData, panOffsets, panSizes, fp );\n        if( nRet != 0 )\n            eErr = CE_Failure;\n    }\n\n    // Byte-swap if necessary.\n    if( eErr == CE_None && TIFFIsByteSwapped(poGDS->hTIFF) )\n    {\n        for( int iLine = 0; iLine < nReqYSize; ++iLine )\n        {\n            if( GDALDataTypeIsComplex(eDataType) )\n                GDALSwapWords( ppData[iLine], nDTSize / 2,\n                               2 * nReqXSize * nContigBands, nDTSize / 2 );\n            else\n                GDALSwapWords( ppData[iLine], nDTSize,\n                               nReqXSize * nContigBands, nDTSize );\n        }\n    }\n\n    // Over-sampling/sub-sampling and/or data type conversion.\n    const double dfSrcXInc = nXSize / static_cast<double>( nBufXSize );\n    if( eErr == CE_None && pTmpBuffer != nullptr )\n    {\n        for( int iY=0; iY < nBufYSize; ++iY )\n        {\n            const int iSrcY =\n                nBufYSize <= nYSize ?\n                iY : static_cast<int>((iY + 0.5) * dfSrcYInc);\n\n            GByte* pabySrcData =\n                static_cast<GByte*>(ppData[iSrcY]) +\n                (nContigBands > 1 ? (nBand-1) : 0) * nDTSize;\n            GByte* pabyDstData =\n                static_cast<GByte *>(pData) + iY * nLineSpace;\n            if( nBufXSize == nXSize )\n            {\n                GDALCopyWords( pabySrcData,\n                               eDataType,\n                               nSrcPixelSize,\n                               pabyDstData,\n                               eBufType,\n                               static_cast<int>(nPixelSpace),\n                               nBufXSize );\n            }\n            else\n            {\n                if( eDataType == GDT_Byte && eBufType == GDT_Byte )\n                {\n                    double dfSrcX = 0.5 * dfSrcXInc;\n                    for( int iX = 0; iX < nBufXSize; ++iX, dfSrcX += dfSrcXInc )\n                    {\n                        const int iSrcX = static_cast<int>(dfSrcX);\n                        pabyDstData[iX * nPixelSpace] =\n                            pabySrcData[iSrcX * nSrcPixelSize];\n                    }\n                }\n                else\n                {\n                    double dfSrcX = 0.5 * dfSrcXInc;\n                    for( int iX = 0; iX < nBufXSize; ++iX, dfSrcX += dfSrcXInc )\n                    {\n                        const int iSrcX = static_cast<int>(dfSrcX);\n                        GDALCopyWords( pabySrcData + iSrcX * nSrcPixelSize,\n                                       eDataType, 0,\n                                       pabyDstData + iX * nPixelSpace,\n                                       eBufType, 0, 1 );\n                    }\n                }\n            }\n        }\n    }\n\n    // Cleanup.\n    CPLFree(pTmpBuffer);\n    CPLFree(ppData);\n    CPLFree(panOffsets);\n    CPLFree(panSizes);\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                           GetVirtualMemAuto()                        */\n/************************************************************************/\n\nCPLVirtualMem* GTiffRasterBand::GetVirtualMemAuto( GDALRWFlag eRWFlag,\n                                                   int *pnPixelSpace,\n                                                   GIntBig *pnLineSpace,\n                                                   char **papszOptions )\n{\n    const char* pszImpl = CSLFetchNameValueDef(\n            papszOptions, \"USE_DEFAULT_IMPLEMENTATION\", \"AUTO\");\n    if( EQUAL(pszImpl, \"YES\") || EQUAL(pszImpl, \"ON\") ||\n        EQUAL(pszImpl, \"1\") || EQUAL(pszImpl, \"TRUE\") )\n    {\n        return GDALRasterBand::GetVirtualMemAuto( eRWFlag, pnPixelSpace,\n                                                  pnLineSpace, papszOptions );\n    }\n\n    CPLVirtualMem *psRet =\n        GetVirtualMemAutoInternal( eRWFlag, pnPixelSpace, pnLineSpace,\n                                   papszOptions );\n    if( psRet != nullptr )\n    {\n        CPLDebug(\"GTiff\", \"GetVirtualMemAuto(): Using memory file mapping\");\n        return psRet;\n    }\n\n    if( EQUAL(pszImpl, \"NO\") || EQUAL(pszImpl, \"OFF\") ||\n        EQUAL(pszImpl, \"0\") || EQUAL(pszImpl, \"FALSE\") )\n    {\n        return nullptr;\n    }\n\n    CPLDebug(\"GTiff\", \"GetVirtualMemAuto(): Defaulting to base implementation\");\n    return GDALRasterBand::GetVirtualMemAuto( eRWFlag, pnPixelSpace,\n                                              pnLineSpace, papszOptions );\n}\n\n\n/************************************************************************/\n/*                           GetDefaultRAT()                            */\n/************************************************************************/\n\nGDALRasterAttributeTable *GTiffRasterBand::GetDefaultRAT()\n\n{\n    poGDS->LoadGeoreferencingAndPamIfNeeded();\n    return GDALPamRasterBand::GetDefaultRAT();\n}\n\n/************************************************************************/\n/*                           GetHistogram()                             */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::GetHistogram(\n    double dfMin, double dfMax,\n    int nBuckets, GUIntBig * panHistogram,\n    int bIncludeOutOfRange, int bApproxOK,\n    GDALProgressFunc pfnProgress, void *pProgressData )\n{\n    poGDS->LoadGeoreferencingAndPamIfNeeded();\n    return GDALPamRasterBand::GetHistogram( dfMin, dfMax,\n                                            nBuckets, panHistogram,\n                                            bIncludeOutOfRange, bApproxOK,\n                                            pfnProgress, pProgressData );\n}\n\n/************************************************************************/\n/*                       GetDefaultHistogram()                          */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::GetDefaultHistogram( double *pdfMin, double *pdfMax,\n                                             int *pnBuckets,\n                                             GUIntBig ** ppanHistogram,\n                                             int bForce,\n                                             GDALProgressFunc pfnProgress,\n                                             void *pProgressData )\n{\n    poGDS->LoadGeoreferencingAndPamIfNeeded();\n    return GDALPamRasterBand::GetDefaultHistogram( pdfMin, pdfMax,\n                                                   pnBuckets, ppanHistogram,\n                                                   bForce,\n                                                   pfnProgress, pProgressData );\n}\n\n/************************************************************************/\n/*                     DropReferenceVirtualMem()                        */\n/************************************************************************/\n\nvoid GTiffRasterBand::DropReferenceVirtualMem( void* pUserData )\n{\n    // This function may also be called when the dataset and rasterband\n    // objects have been destroyed.\n    // If they are still alive, it updates the reference counter of the\n    // base mapping to invalidate the pointer to it if needed.\n\n    GTiffRasterBand** ppoSelf = static_cast<GTiffRasterBand **>( pUserData );\n    GTiffRasterBand* poSelf = *ppoSelf;\n\n    if( poSelf != nullptr )\n    {\n        if( --(poSelf->poGDS->nRefBaseMapping) == 0 )\n        {\n            poSelf->poGDS->pBaseMapping = nullptr;\n        }\n        poSelf->aSetPSelf.erase(ppoSelf);\n    }\n    CPLFree(pUserData);\n}\n\n/************************************************************************/\n/*                     GetVirtualMemAutoInternal()                      */\n/************************************************************************/\n\nCPLVirtualMem* GTiffRasterBand::GetVirtualMemAutoInternal( GDALRWFlag eRWFlag,\n                                                           int *pnPixelSpace,\n                                                           GIntBig *pnLineSpace,\n                                                           char **papszOptions )\n{\n    int nLineSize = nBlockXSize * GDALGetDataTypeSizeBytes(eDataType);\n    if( poGDS->nPlanarConfig == PLANARCONFIG_CONTIG )\n        nLineSize *= poGDS->nBands;\n\n    if( poGDS->nPlanarConfig == PLANARCONFIG_CONTIG )\n    {\n        // In case of a pixel interleaved file, we save virtual memory space\n        // by reusing a base mapping that embraces the whole imagery.\n        if( poGDS->pBaseMapping != nullptr )\n        {\n            // Offset between the base mapping and the requested mapping.\n            vsi_l_offset nOffset =\n                static_cast<vsi_l_offset>(nBand - 1) *\n                GDALGetDataTypeSizeBytes(eDataType);\n\n            GTiffRasterBand** ppoSelf =\n                static_cast<GTiffRasterBand** >(\n                    CPLCalloc(1, sizeof(GTiffRasterBand*)) );\n            *ppoSelf = this;\n\n            CPLVirtualMem* pVMem = CPLVirtualMemDerivedNew(\n                poGDS->pBaseMapping,\n                nOffset,\n                CPLVirtualMemGetSize(poGDS->pBaseMapping) - nOffset,\n                GTiffRasterBand::DropReferenceVirtualMem,\n                ppoSelf);\n            if( pVMem == nullptr )\n            {\n                CPLFree(ppoSelf);\n                return nullptr;\n            }\n\n            // Mechanism used so that the memory mapping object can be\n            // destroyed after the raster band.\n            aSetPSelf.insert(ppoSelf);\n            ++poGDS->nRefBaseMapping;\n            *pnPixelSpace = GDALGetDataTypeSizeBytes(eDataType);\n            if( poGDS->nPlanarConfig == PLANARCONFIG_CONTIG )\n                *pnPixelSpace *= poGDS->nBands;\n            *pnLineSpace = nLineSize;\n            return pVMem;\n        }\n    }\n\n    if( !poGDS->SetDirectory() )  // Very important to make hTIFF up-to-date.\n        return nullptr;\n    VSILFILE* fp = VSI_TIFFGetVSILFile(TIFFClientdata( poGDS->hTIFF ));\n\n    vsi_l_offset nLength = static_cast<vsi_l_offset>(nRasterYSize) * nLineSize;\n\n    if( !(CPLIsVirtualMemFileMapAvailable() &&\n          VSIFGetNativeFileDescriptorL(fp) != nullptr &&\n#if SIZEOF_VOIDP == 4\n          nLength == static_cast<size_t>(nLength) &&\n#endif\n          poGDS->nCompression == COMPRESSION_NONE &&\n          (poGDS->nPhotometric == PHOTOMETRIC_MINISBLACK ||\n           poGDS->nPhotometric == PHOTOMETRIC_RGB ||\n           poGDS->nPhotometric == PHOTOMETRIC_PALETTE) &&\n          poGDS->nBitsPerSample == GDALGetDataTypeSizeBits(eDataType) &&\n          !TIFFIsTiled( poGDS->hTIFF ) && !TIFFIsByteSwapped(poGDS->hTIFF)) )\n    {\n        return nullptr;\n    }\n\n    // Make sure that TIFFTAG_STRIPOFFSETS is up-to-date.\n    if( poGDS->GetAccess() == GA_Update )\n    {\n        poGDS->FlushCache();\n        VSI_TIFFFlushBufferedWrite( TIFFClientdata( poGDS->hTIFF ) );\n    }\n\n    // Get strip offsets.\n    toff_t *panTIFFOffsets = nullptr;\n    if( !TIFFGetField( poGDS->hTIFF, TIFFTAG_STRIPOFFSETS, &panTIFFOffsets ) ||\n        panTIFFOffsets == nullptr )\n    {\n        return nullptr;\n    }\n\n    int nBlockSize =\n        nBlockXSize * nBlockYSize * GDALGetDataTypeSizeBytes(eDataType);\n    if( poGDS->nPlanarConfig == PLANARCONFIG_CONTIG )\n        nBlockSize *= poGDS->nBands;\n\n    int nBlocks = poGDS->nBlocksPerBand;\n    if( poGDS->nPlanarConfig == PLANARCONFIG_SEPARATE )\n        nBlocks *= poGDS->nBands;\n    int i = 0;  // Used after for.\n    for( ; i < nBlocks; ++i )\n    {\n        if( panTIFFOffsets[i] != 0 )\n            break;\n    }\n    if( i == nBlocks )\n    {\n        // All zeroes.\n        if( poGDS->eAccess == GA_Update )\n        {\n            // Initialize the file with empty blocks so that the file has\n            // the appropriate size.\n\n            toff_t* panByteCounts = nullptr;\n            if( !TIFFGetField( poGDS->hTIFF, TIFFTAG_STRIPBYTECOUNTS,\n                               &panByteCounts ) ||\n                panByteCounts == nullptr )\n            {\n                return nullptr;\n            }\n            if( VSIFSeekL(fp, 0, SEEK_END) != 0 )\n                return nullptr;\n            vsi_l_offset nBaseOffset = VSIFTellL(fp);\n\n            // Just write one tile with libtiff to put it in appropriate state.\n            GByte* pabyData =\n                static_cast<GByte*>(VSI_CALLOC_VERBOSE(1, nBlockSize));\n            if( pabyData == nullptr )\n            {\n                return nullptr;\n            }\n            int ret =\n                static_cast<int>(\n                    TIFFWriteEncodedStrip( poGDS->hTIFF, 0, pabyData,\n                                           nBlockSize ) );\n            VSI_TIFFFlushBufferedWrite( TIFFClientdata( poGDS->hTIFF ) );\n            VSIFree(pabyData);\n            if( ret != nBlockSize )\n            {\n                return nullptr;\n            }\n            CPLAssert(panTIFFOffsets[0] == nBaseOffset);\n            CPLAssert(panByteCounts[0] == static_cast<toff_t>(nBlockSize));\n\n            // Now simulate the writing of other blocks.\n            const vsi_l_offset nDataSize =\n                static_cast<vsi_l_offset>(nBlockSize) * nBlocks;\n            if( VSIFTruncateL(fp, nBaseOffset + nDataSize) != 0 )\n                return nullptr;\n\n            for( i = 1; i < nBlocks; ++i)\n            {\n                panTIFFOffsets[i] =\n                    nBaseOffset + i * static_cast<toff_t>(nBlockSize);\n                panByteCounts[i] = nBlockSize;\n            }\n        }\n        else\n        {\n            CPLDebug( \"GTiff\", \"Sparse files not supported in file mapping\" );\n            return nullptr;\n        }\n    }\n\n    GIntBig nBlockSpacing = 0;\n    bool bCompatibleSpacing = true;\n    toff_t nPrevOffset = 0;\n    for( i = 0; i < poGDS->nBlocksPerBand; ++i )\n    {\n        toff_t nCurOffset = 0;\n        if( poGDS->nPlanarConfig == PLANARCONFIG_SEPARATE )\n            nCurOffset =\n                panTIFFOffsets[poGDS->nBlocksPerBand * (nBand - 1) + i];\n        else\n            nCurOffset = panTIFFOffsets[i];\n        if( nCurOffset == 0 )\n        {\n            bCompatibleSpacing = false;\n            break;\n        }\n        if( i > 0 )\n        {\n            const GIntBig nCurSpacing = nCurOffset - nPrevOffset;\n            if( i == 1 )\n            {\n                if( nCurSpacing !=\n                    static_cast<GIntBig>(nBlockYSize) * nLineSize )\n                {\n                    bCompatibleSpacing = false;\n                    break;\n                }\n                nBlockSpacing = nCurSpacing;\n            }\n            else if( nBlockSpacing != nCurSpacing )\n            {\n                bCompatibleSpacing = false;\n                break;\n            }\n        }\n        nPrevOffset = nCurOffset;\n    }\n\n    if( !bCompatibleSpacing )\n    {\n        return nullptr;\n    }\n\n    vsi_l_offset nOffset = 0;\n    if( poGDS->nPlanarConfig == PLANARCONFIG_CONTIG )\n    {\n        CPLAssert( poGDS->pBaseMapping == nullptr );\n        nOffset = panTIFFOffsets[0];\n    }\n    else\n    {\n        nOffset = panTIFFOffsets[poGDS->nBlocksPerBand * (nBand - 1)];\n    }\n    CPLVirtualMem* pVMem = CPLVirtualMemFileMapNew(\n        fp, nOffset, nLength,\n        eRWFlag == GF_Write ? VIRTUALMEM_READWRITE : VIRTUALMEM_READONLY,\n        nullptr, nullptr);\n    if( pVMem == nullptr )\n    {\n        return nullptr;\n    }\n\n    if( poGDS->nPlanarConfig == PLANARCONFIG_CONTIG )\n    {\n        // TODO(schwehr): Revisit this block.\n        poGDS->pBaseMapping = pVMem;\n        pVMem = GetVirtualMemAutoInternal( eRWFlag,\n                                           pnPixelSpace,\n                                           pnLineSpace,\n                                           papszOptions );\n        // Drop ref on base mapping.\n        CPLVirtualMemFree(poGDS->pBaseMapping);\n        if( pVMem == nullptr )\n            poGDS->pBaseMapping = nullptr;\n    }\n    else\n    {\n        *pnPixelSpace = GDALGetDataTypeSizeBytes(eDataType);\n        if( poGDS->nPlanarConfig == PLANARCONFIG_CONTIG )\n            *pnPixelSpace *= poGDS->nBands;\n        *pnLineSpace = nLineSize;\n    }\n    return pVMem;\n}\n\n/************************************************************************/\n/*                     HasOptimizedReadMultiRange()                     */\n/************************************************************************/\n\nint GTiffDataset::HasOptimizedReadMultiRange()\n{\n    if( m_nHasOptimizedReadMultiRange >= 0 )\n        return m_nHasOptimizedReadMultiRange;\n    m_nHasOptimizedReadMultiRange =\n        VSIHasOptimizedReadMultiRange(osFilename);\n    return m_nHasOptimizedReadMultiRange;\n}\n\n/************************************************************************/\n/*                            IRasterIO()                               */\n/************************************************************************/\n\nCPLErr GTiffDataset::IRasterIO( GDALRWFlag eRWFlag,\n                                int nXOff, int nYOff, int nXSize, int nYSize,\n                                void * pData, int nBufXSize, int nBufYSize,\n                                GDALDataType eBufType,\n                                int nBandCount, int *panBandMap,\n                                GSpacing nPixelSpace, GSpacing nLineSpace,\n                                GSpacing nBandSpace,\n                                GDALRasterIOExtraArg* psExtraArg )\n\n{\n    // Try to pass the request to the most appropriate overview dataset.\n    if( nBufXSize < nXSize && nBufYSize < nYSize )\n    {\n        int bTried = FALSE;\n        ++nJPEGOverviewVisibilityCounter;\n        const CPLErr eErr =\n            TryOverviewRasterIO( eRWFlag,\n                                 nXOff, nYOff, nXSize, nYSize,\n                                 pData, nBufXSize, nBufYSize,\n                                 eBufType,\n                                 nBandCount, panBandMap,\n                                 nPixelSpace, nLineSpace,\n                                 nBandSpace,\n                                 psExtraArg,\n                                 &bTried );\n        --nJPEGOverviewVisibilityCounter;\n        if( bTried )\n            return eErr;\n    }\n\n    if( eVirtualMemIOUsage != VIRTUAL_MEM_IO_NO )\n    {\n        const int nErr = VirtualMemIO(\n            eRWFlag, nXOff, nYOff, nXSize, nYSize,\n            pData, nBufXSize, nBufYSize, eBufType,\n            nBandCount, panBandMap, nPixelSpace, nLineSpace,\n            nBandSpace, psExtraArg );\n        if( nErr >= 0 )\n            return static_cast<CPLErr>(nErr);\n    }\n    if( bDirectIO )\n    {\n        const int nErr = DirectIO(\n            eRWFlag, nXOff, nYOff, nXSize, nYSize,\n            pData, nBufXSize, nBufYSize, eBufType,\n            nBandCount, panBandMap, nPixelSpace, nLineSpace,\n            nBandSpace, psExtraArg );\n        if( nErr >= 0 )\n            return static_cast<CPLErr>(nErr);\n    }\n\n    void* pBufferedData = nullptr;\n    if( eAccess == GA_ReadOnly &&\n        eRWFlag == GF_Read &&\n        nPlanarConfig == PLANARCONFIG_CONTIG &&\n        HasOptimizedReadMultiRange() )\n    {\n        pBufferedData = cpl::down_cast<GTiffRasterBand *>(\n            GetRasterBand(1))->CacheMultiRange(nXOff, nYOff,\n                                               nXSize, nYSize,\n                                               nBufXSize, nBufYSize,\n                                               psExtraArg);\n    }\n\n    ++nJPEGOverviewVisibilityCounter;\n    const CPLErr eErr =\n        GDALPamDataset::IRasterIO(\n            eRWFlag, nXOff, nYOff, nXSize, nYSize,\n            pData, nBufXSize, nBufYSize, eBufType,\n            nBandCount, panBandMap, nPixelSpace, nLineSpace,\n            nBandSpace, psExtraArg);\n    nJPEGOverviewVisibilityCounter--;\n\n    if( pBufferedData )\n    {\n        VSIFree( pBufferedData );\n        VSI_TIFFSetCachedRanges( TIFFClientdata( hTIFF ),\n                                 0, nullptr, nullptr, nullptr );\n    }\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                        FetchBufferVirtualMemIO                       */\n/************************************************************************/\n\nclass FetchBufferVirtualMemIO final\n{\n    const GByte* pabySrcData;\n    size_t       nMappingSize;\n    GByte       *pTempBuffer;\n\npublic:\n            FetchBufferVirtualMemIO( const GByte* pabySrcDataIn,\n                                     size_t nMappingSizeIn,\n                                     GByte* pTempBufferIn ) :\n                pabySrcData(pabySrcDataIn),\n                nMappingSize(nMappingSizeIn),\n                pTempBuffer(pTempBufferIn) {}\n\n    const GByte* FetchBytes( vsi_l_offset nOffset,\n                             int nPixels, int nDTSize,\n                             bool bIsByteSwapped, bool bIsComplex,\n                             int nBlockId )\n    {\n        if( nOffset + nPixels * nDTSize > nMappingSize )\n        {\n            CPLError(CE_Failure, CPLE_FileIO,\n                     \"Missing data for block %d\", nBlockId);\n            return nullptr;\n        }\n        if( !bIsByteSwapped )\n            return pabySrcData + nOffset;\n        memcpy(pTempBuffer, pabySrcData + nOffset, nPixels * nDTSize);\n        if( bIsComplex )\n            GDALSwapWords( pTempBuffer, nDTSize / 2, 2 * nPixels, nDTSize / 2);\n        else\n            GDALSwapWords( pTempBuffer, nDTSize, nPixels, nDTSize);\n        return pTempBuffer;\n    }\n\n    bool FetchBytes( GByte* pabyDstBuffer,\n                     vsi_l_offset nOffset,\n                     int nPixels, int nDTSize,\n                     bool bIsByteSwapped, bool bIsComplex,\n                     int nBlockId )\n    {\n        if( nOffset + nPixels * nDTSize > nMappingSize )\n        {\n            CPLError(CE_Failure, CPLE_FileIO,\n                     \"Missing data for block %d\", nBlockId);\n            return false;\n        }\n        memcpy(pabyDstBuffer, pabySrcData + nOffset, nPixels * nDTSize);\n        if( bIsByteSwapped )\n        {\n            if( bIsComplex )\n                GDALSwapWords( pabyDstBuffer, nDTSize / 2, 2 * nPixels,\n                               nDTSize / 2);\n            else\n                GDALSwapWords( pabyDstBuffer, nDTSize, nPixels, nDTSize);\n        }\n        return true;\n    }\n\n    static const EMULATED_BOOL bMinimizeIO = false;\n};\n\n/************************************************************************/\n/*                         VirtualMemIO()                               */\n/************************************************************************/\n\nint GTiffDataset::VirtualMemIO( GDALRWFlag eRWFlag,\n                                int nXOff, int nYOff, int nXSize, int nYSize,\n                                void * pData, int nBufXSize, int nBufYSize,\n                                GDALDataType eBufType,\n                                int nBandCount, int *panBandMap,\n                                GSpacing nPixelSpace, GSpacing nLineSpace,\n                                GSpacing nBandSpace,\n                                GDALRasterIOExtraArg* psExtraArg )\n{\n    if( eAccess == GA_Update || eRWFlag == GF_Write || bStreamingIn )\n        return -1;\n\n    // Only know how to deal with nearest neighbour in this optimized routine.\n    if( (nXSize != nBufXSize || nYSize != nBufYSize) &&\n        psExtraArg != nullptr &&\n        psExtraArg->eResampleAlg != GRIORA_NearestNeighbour )\n    {\n        return -1;\n    }\n\n    if( !SetDirectory() )\n        return CE_Failure;\n\n    const GDALDataType eDataType = GetRasterBand(1)->GetRasterDataType();\n    const int nDTSizeBits = GDALGetDataTypeSizeBits(eDataType);\n    if( !(nCompression == COMPRESSION_NONE &&\n        (nPhotometric == PHOTOMETRIC_MINISBLACK ||\n        nPhotometric == PHOTOMETRIC_RGB ||\n        nPhotometric == PHOTOMETRIC_PALETTE) &&\n        nBitsPerSample == nDTSizeBits) )\n    {\n        eVirtualMemIOUsage = VIRTUAL_MEM_IO_NO;\n        return -1;\n    }\n\n    size_t nMappingSize = 0;\n    GByte* pabySrcData = nullptr;\n    if( STARTS_WITH(osFilename, \"/vsimem/\") )\n    {\n        vsi_l_offset nDataLength = 0;\n        pabySrcData =\n            VSIGetMemFileBuffer(osFilename, &nDataLength, FALSE);\n        nMappingSize = static_cast<size_t>(nDataLength);\n        if( pabySrcData == nullptr )\n            return -1;\n    }\n    else if( psVirtualMemIOMapping == nullptr )\n    {\n        VSILFILE* fp = VSI_TIFFGetVSILFile(TIFFClientdata( hTIFF ));\n        if( !CPLIsVirtualMemFileMapAvailable() ||\n            VSIFGetNativeFileDescriptorL(fp) == nullptr )\n        {\n            eVirtualMemIOUsage = VIRTUAL_MEM_IO_NO;\n            return -1;\n        }\n        if( VSIFSeekL(fp, 0, SEEK_END) != 0 )\n        {\n            eVirtualMemIOUsage = VIRTUAL_MEM_IO_NO;\n            return -1;\n        }\n        const vsi_l_offset nLength = VSIFTellL(fp);\n        if( static_cast<size_t>(nLength) != nLength )\n        {\n            eVirtualMemIOUsage = VIRTUAL_MEM_IO_NO;\n            return -1;\n        }\n        if( eVirtualMemIOUsage == VIRTUAL_MEM_IO_IF_ENOUGH_RAM )\n        {\n            GIntBig nRAM = CPLGetUsablePhysicalRAM();\n            if( static_cast<GIntBig>(nLength) > nRAM )\n            {\n                CPLDebug( \"GTiff\",\n                          \"Not enough RAM to map whole file into memory.\" );\n                eVirtualMemIOUsage = VIRTUAL_MEM_IO_NO;\n                return -1;\n            }\n        }\n        psVirtualMemIOMapping = CPLVirtualMemFileMapNew(\n            fp, 0, nLength, VIRTUALMEM_READONLY, nullptr, nullptr);\n        if( psVirtualMemIOMapping == nullptr )\n        {\n            eVirtualMemIOUsage = VIRTUAL_MEM_IO_NO;\n            return -1;\n        }\n        eVirtualMemIOUsage = VIRTUAL_MEM_IO_YES;\n    }\n\n    if( psVirtualMemIOMapping )\n    {\n#ifdef DEBUG\n        CPLDebug(\"GTiff\", \"Using VirtualMemIO\");\n#endif\n        nMappingSize = CPLVirtualMemGetSize(psVirtualMemIOMapping);\n        pabySrcData = static_cast<GByte *>(\n            CPLVirtualMemGetAddr(psVirtualMemIOMapping) );\n    }\n\n    if( TIFFIsByteSwapped(hTIFF) && m_pTempBufferForCommonDirectIO == nullptr )\n    {\n        const int nDTSize = nDTSizeBits / 8;\n        m_nTempBufferForCommonDirectIOSize =\n            static_cast<size_t>(nBlockXSize * nDTSize *\n                (nPlanarConfig == PLANARCONFIG_CONTIG ? nBands : 1));\n        if( TIFFIsTiled(hTIFF) )\n            m_nTempBufferForCommonDirectIOSize *= nBlockYSize;\n\n        m_pTempBufferForCommonDirectIO =\n            static_cast<GByte *>(\n                VSI_MALLOC_VERBOSE(m_nTempBufferForCommonDirectIOSize) );\n        if( m_pTempBufferForCommonDirectIO == nullptr )\n            return CE_Failure;\n    }\n    FetchBufferVirtualMemIO oFetcher( pabySrcData, nMappingSize,\n                                      m_pTempBufferForCommonDirectIO );\n\n    return CommonDirectIO( oFetcher,\n                           nXOff, nYOff, nXSize, nYSize,\n                           pData, nBufXSize, nBufYSize,\n                           eBufType,\n                           nBandCount, panBandMap,\n                           nPixelSpace, nLineSpace,\n                           nBandSpace );\n}\n\n/************************************************************************/\n/*                   CopyContigByteMultiBand()                          */\n/************************************************************************/\n\nstatic inline void CopyContigByteMultiBand(\n    const GByte* CPL_RESTRICT pabySrc, int nSrcStride,\n    GByte* CPL_RESTRICT pabyDest, int nDestStride,\n    int nIters, int nBandCount )\n{\n    if( nBandCount == 3 )\n    {\n        if( nSrcStride == 3 && nDestStride == 4 )\n        {\n            while( nIters >= 8 )\n            {\n                pabyDest[4*0+0] = pabySrc[3*0+0];\n                pabyDest[4*0+1] = pabySrc[3*0+1];\n                pabyDest[4*0+2] = pabySrc[3*0+2];\n                pabyDest[4*1+0] = pabySrc[3*1+0];\n                pabyDest[4*1+1] = pabySrc[3*1+1];\n                pabyDest[4*1+2] = pabySrc[3*1+2];\n                pabyDest[4*2+0] = pabySrc[3*2+0];\n                pabyDest[4*2+1] = pabySrc[3*2+1];\n                pabyDest[4*2+2] = pabySrc[3*2+2];\n                pabyDest[4*3+0] = pabySrc[3*3+0];\n                pabyDest[4*3+1] = pabySrc[3*3+1];\n                pabyDest[4*3+2] = pabySrc[3*3+2];\n                pabyDest[4*4+0] = pabySrc[3*4+0];\n                pabyDest[4*4+1] = pabySrc[3*4+1];\n                pabyDest[4*4+2] = pabySrc[3*4+2];\n                pabyDest[4*5+0] = pabySrc[3*5+0];\n                pabyDest[4*5+1] = pabySrc[3*5+1];\n                pabyDest[4*5+2] = pabySrc[3*5+2];\n                pabyDest[4*6+0] = pabySrc[3*6+0];\n                pabyDest[4*6+1] = pabySrc[3*6+1];\n                pabyDest[4*6+2] = pabySrc[3*6+2];\n                pabyDest[4*7+0] = pabySrc[3*7+0];\n                pabyDest[4*7+1] = pabySrc[3*7+1];\n                pabyDest[4*7+2] = pabySrc[3*7+2];\n                pabySrc += 3 * 8;\n                pabyDest += 4 * 8;\n                nIters -= 8;\n            }\n            while( nIters-- > 0 )\n            {\n                pabyDest[0] = pabySrc[0];\n                pabyDest[1] = pabySrc[1];\n                pabyDest[2] = pabySrc[2];\n                pabySrc += 3;\n                pabyDest += 4;\n            }\n        }\n        else\n        {\n            while( nIters-- > 0 )\n            {\n                pabyDest[0] = pabySrc[0];\n                pabyDest[1] = pabySrc[1];\n                pabyDest[2] = pabySrc[2];\n                pabySrc += nSrcStride;\n                pabyDest += nDestStride;\n            }\n        }\n    }\n    else\n    {\n        while( nIters-- > 0 )\n        {\n            for( int iBand = 0; iBand < nBandCount; ++iBand )\n                pabyDest[iBand] = pabySrc[iBand];\n            pabySrc += nSrcStride;\n            pabyDest += nDestStride;\n        }\n    }\n}\n\n/************************************************************************/\n/*                         CommonDirectIO()                             */\n/************************************************************************/\n\n// #define DEBUG_REACHED_VIRTUAL_MEM_IO\n#ifdef DEBUG_REACHED_VIRTUAL_MEM_IO\nstatic int anReachedVirtualMemIO[52] = { 0 };\n#define REACHED(x) anReachedVirtualMemIO[x] = 1\n#else\n#define REACHED(x)\n#endif\n\ntemplate<class FetchBuffer> CPLErr GTiffDataset::CommonDirectIO(\n    FetchBuffer& oFetcher,\n    int nXOff, int nYOff, int nXSize, int nYSize,\n    void * pData, int nBufXSize, int nBufYSize,\n    GDALDataType eBufType,\n    int nBandCount, int *panBandMap,\n    GSpacing nPixelSpace, GSpacing nLineSpace,\n    GSpacing nBandSpace )\n{\n    const GDALDataType eDataType = GetRasterBand(1)->GetRasterDataType();\n    const int nDTSize = GDALGetDataTypeSizeBytes(eDataType);\n    const bool bIsComplex = CPL_TO_BOOL(GDALDataTypeIsComplex(eDataType));\n    const int nBufDTSize = GDALGetDataTypeSizeBytes(eBufType);\n\n    // Get strip offsets.\n    toff_t *panOffsets = nullptr;\n    if( !TIFFGetField( hTIFF, (TIFFIsTiled( hTIFF )) ?\n                       TIFFTAG_TILEOFFSETS : TIFFTAG_STRIPOFFSETS,\n                       &panOffsets ) ||\n        panOffsets == nullptr )\n    {\n        return CE_Failure;\n    }\n\n    bool bUseContigImplementation =\n        nPlanarConfig == PLANARCONFIG_CONTIG &&\n        nBandCount > 1 &&\n        nBandSpace == nBufDTSize;\n    if( bUseContigImplementation )\n    {\n        for( int iBand = 0; iBand < nBandCount; ++iBand )\n        {\n            const int nBand = panBandMap[iBand];\n            if( nBand != iBand + 1 )\n            {\n                bUseContigImplementation = false;\n                break;\n            }\n        }\n    }\n\n    const int nBandsPerBlock =\n        nPlanarConfig == PLANARCONFIG_SEPARATE ? 1 : nBands;\n    const int nBandsPerBlockDTSize = nBandsPerBlock * nDTSize;\n    const int nBlocksPerRow = DIV_ROUND_UP(nRasterXSize, nBlockXSize);\n    const bool bNoTypeChange = (eDataType == eBufType);\n    const bool bNoXResampling = (nXSize == nBufXSize );\n    const bool bNoXResamplingNoTypeChange = (bNoTypeChange && bNoXResampling);\n    const bool bByteOnly = (bNoTypeChange && nDTSize == 1 );\n    const bool bByteNoXResampling = ( bByteOnly && bNoXResamplingNoTypeChange );\n    const bool bIsByteSwapped = CPL_TO_BOOL(TIFFIsByteSwapped(hTIFF));\n    const double dfSrcXInc = nXSize / static_cast<double>( nBufXSize );\n    const double dfSrcYInc = nYSize / static_cast<double>( nBufYSize );\n\n    int bNoDataSetIn = FALSE;\n    double dfNoData = GetRasterBand(1)->GetNoDataValue( &bNoDataSetIn );\n    GByte abyNoData = 0;\n    if( !bNoDataSetIn )\n        dfNoData = 0;\n    else if( dfNoData >= 0 && dfNoData <= 255 )\n        abyNoData = static_cast<GByte>(dfNoData + 0.5);\n\n    if( FetchBuffer::bMinimizeIO &&\n             TIFFIsTiled( hTIFF ) && bNoXResampling && (nYSize == nBufYSize ) &&\n             nPlanarConfig == PLANARCONFIG_CONTIG && nBandCount > 1 )\n    {\n        GByte* pabyData = static_cast<GByte *>(pData);\n        for( int y = 0; y < nBufYSize; )\n        {\n            const int nSrcLine = nYOff + y;\n            const int nBlockYOff = nSrcLine / nBlockYSize;\n            const int nYOffsetInBlock = nSrcLine % nBlockYSize;\n            const int nUsedBlockHeight =\n                std::min( nBufYSize - y,\n                          nBlockYSize - nYOffsetInBlock );\n\n            int nBlockXOff = nXOff / nBlockXSize;\n            int nXOffsetInBlock = nXOff % nBlockXSize;\n            int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n\n            int x = 0;\n            while( x < nBufXSize )\n            {\n                const toff_t nCurOffset = panOffsets[nBlockId];\n                const int nUsedBlockWidth =\n                    std::min( nBlockXSize - nXOffsetInBlock,\n                              nBufXSize - x );\n\n                if( nCurOffset == 0 )\n                {\n                    REACHED(30);\n                    for( int k = 0; k < nUsedBlockHeight; ++k )\n                    {\n                        GByte* pabyLocalData =\n                            pabyData + (y + k) * nLineSpace + x * nPixelSpace;\n                        for( int iBand = 0; iBand < nBandCount; ++iBand )\n                        {\n                            GByte* pabyLocalDataBand =\n                                pabyLocalData + iBand * nBandSpace;\n\n                            GDALCopyWords(\n                                &dfNoData, GDT_Float64, 0,\n                                pabyLocalDataBand, eBufType,\n                                static_cast<int>(nPixelSpace),\n                                nUsedBlockWidth );\n                        }\n                    }\n                }\n                else\n                {\n                    const int nByteOffsetInBlock =\n                        nYOffsetInBlock * nBlockXSize * nBandsPerBlockDTSize;\n                    const GByte* pabyLocalSrcDataK0 = oFetcher.FetchBytes(\n                            nCurOffset + nByteOffsetInBlock,\n                            nBlockXSize *\n                            nUsedBlockHeight * nBandsPerBlock,\n                            nDTSize, bIsByteSwapped, bIsComplex, nBlockId);\n                    if( pabyLocalSrcDataK0 == nullptr )\n                        return CE_Failure;\n\n                    for( int k = 0; k < nUsedBlockHeight; ++k )\n                    {\n                        GByte* pabyLocalData =\n                            pabyData + (y + k) * nLineSpace + x * nPixelSpace;\n                        const GByte* pabyLocalSrcData =\n                            pabyLocalSrcDataK0 +\n                            (k * nBlockXSize + nXOffsetInBlock) *\n                            nBandsPerBlockDTSize;\n\n                        if( bUseContigImplementation && nBands == nBandCount &&\n                            nPixelSpace == nBandsPerBlockDTSize )\n                        {\n                            REACHED(31);\n                            GDALCopyWords( pabyLocalSrcData,\n                                           eDataType, nDTSize,\n                                           pabyLocalData,\n                                           eBufType, nBufDTSize,\n                                           nUsedBlockWidth * nBands );\n                        }\n                        else\n                        {\n                            REACHED(32);\n                            for( int iBand = 0; iBand < nBandCount; ++iBand )\n                            {\n                                GByte* pabyLocalDataBand =\n                                    pabyLocalData + iBand * nBandSpace;\n                                const GByte* pabyLocalSrcDataBand =\n                                    pabyLocalSrcData +\n                                    (panBandMap[iBand]-1) * nDTSize;\n\n                                GDALCopyWords(\n                                    pabyLocalSrcDataBand,\n                                    eDataType, nBandsPerBlockDTSize,\n                                    pabyLocalDataBand,\n                                    eBufType, static_cast<int>(nPixelSpace),\n                                    nUsedBlockWidth );\n                            }\n                        }\n                    }\n                }\n\n                nXOffsetInBlock = 0;\n                ++nBlockXOff;\n                ++nBlockId;\n                x += nUsedBlockWidth;\n            }\n\n            y += nUsedBlockHeight;\n        }\n    }\n    else if( FetchBuffer::bMinimizeIO &&\n             TIFFIsTiled( hTIFF ) && bNoXResampling &&\n             (nYSize == nBufYSize ) )\n             // && (nPlanarConfig == PLANARCONFIG_SEPARATE || nBandCount == 1) )\n    {\n        for( int iBand = 0; iBand < nBandCount; ++iBand )\n        {\n            GByte* pabyData = static_cast<GByte *>(pData) + iBand * nBandSpace;\n            const int nBand = panBandMap[iBand];\n            for( int y = 0; y < nBufYSize; )\n            {\n                const int nSrcLine = nYOff + y;\n                const int nBlockYOff = nSrcLine / nBlockYSize;\n                const int nYOffsetInBlock = nSrcLine % nBlockYSize;\n                const int nUsedBlockHeight =\n                    std::min( nBufYSize - y,\n                              nBlockYSize - nYOffsetInBlock);\n\n                int nBlockXOff = nXOff / nBlockXSize;\n                int nXOffsetInBlock = nXOff % nBlockXSize;\n                int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n                if( nPlanarConfig == PLANARCONFIG_SEPARATE )\n                {\n                    REACHED(33);\n                    nBlockId += nBlocksPerBand * (nBand - 1);\n                }\n                else\n                {\n                    REACHED(34);\n                }\n\n                int x = 0;\n                while( x < nBufXSize )\n                {\n                    const toff_t nCurOffset = panOffsets[nBlockId];\n                    const int nUsedBlockWidth =\n                        std::min(\n                            nBlockXSize - nXOffsetInBlock,\n                            nBufXSize - x);\n\n                    if( nCurOffset == 0 )\n                    {\n                        REACHED(35);\n                        for( int k = 0; k < nUsedBlockHeight; ++k )\n                        {\n                            GByte* pabyLocalData =\n                                pabyData + (y + k) * nLineSpace + x * nPixelSpace;\n\n                            GDALCopyWords(\n                                &dfNoData, GDT_Float64, 0,\n                                pabyLocalData, eBufType,\n                                static_cast<int>(nPixelSpace),\n                                nUsedBlockWidth );\n                        }\n                    }\n                    else\n                    {\n                        const int nByteOffsetInBlock =\n                            nYOffsetInBlock * nBlockXSize *\n                            nBandsPerBlockDTSize;\n                        const GByte* pabyLocalSrcDataK0 =\n                            oFetcher.FetchBytes(\n                                nCurOffset + nByteOffsetInBlock,\n                                nBlockXSize *\n                                nUsedBlockHeight * nBandsPerBlock,\n                                nDTSize, bIsByteSwapped, bIsComplex, nBlockId);\n                        if( pabyLocalSrcDataK0 == nullptr )\n                            return CE_Failure;\n\n                        if( nPlanarConfig == PLANARCONFIG_CONTIG )\n                        {\n                            REACHED(36);\n                            pabyLocalSrcDataK0 += (nBand - 1) * nDTSize;\n                        }\n                        else\n                        {\n                            REACHED(37);\n                        }\n\n                        for( int k = 0; k < nUsedBlockHeight; ++k )\n                        {\n                            GByte* pabyLocalData =\n                                pabyData + (y + k) * nLineSpace +\n                                x * nPixelSpace;\n                            const GByte* pabyLocalSrcData =\n                                pabyLocalSrcDataK0 +\n                                (k * nBlockXSize + nXOffsetInBlock) *\n                                nBandsPerBlockDTSize;\n\n                            GDALCopyWords(\n                                pabyLocalSrcData,\n                                eDataType, nBandsPerBlockDTSize,\n                                pabyLocalData,\n                                eBufType, static_cast<int>(nPixelSpace),\n                                nUsedBlockWidth);\n                        }\n                    }\n\n                    nXOffsetInBlock = 0;\n                    ++nBlockXOff;\n                    ++nBlockId;\n                    x += nUsedBlockWidth;\n                }\n\n                y += nUsedBlockHeight;\n            }\n        }\n    }\n    else if( FetchBuffer::bMinimizeIO &&\n             TIFFIsTiled( hTIFF ) &&\n             nPlanarConfig == PLANARCONFIG_CONTIG && nBandCount > 1 )\n    {\n        GByte* pabyData = static_cast<GByte *>(pData);\n        int anSrcYOffset[256] = { 0 };\n        for( int y = 0; y < nBufYSize; )\n        {\n            const double dfYOffStart = nYOff + (y + 0.5) * dfSrcYInc;\n            const int nSrcLine = static_cast<int>(dfYOffStart);\n            const int nYOffsetInBlock = nSrcLine % nBlockYSize;\n            const int nBlockYOff = nSrcLine / nBlockYSize;\n            const int nBaseByteOffsetInBlock =\n                nYOffsetInBlock * nBlockXSize * nBandsPerBlockDTSize;\n            int ychunk = 1;\n            int nLastSrcLineK = nSrcLine;\n            anSrcYOffset[0] = 0;\n            for( int k = 1; k < nBufYSize - y; ++k )\n            {\n                int nSrcLineK =\n                    nYOff + static_cast<int>((y + k + 0.5) * dfSrcYInc);\n                const int nBlockYOffK = nSrcLineK / nBlockYSize;\n                if( k < 256)\n                    anSrcYOffset[k] =\n                        ((nSrcLineK % nBlockYSize) - nYOffsetInBlock) *\n                        nBlockXSize * nBandsPerBlockDTSize;\n                if( nBlockYOffK != nBlockYOff )\n                {\n                    break;\n                }\n                ++ychunk;\n                nLastSrcLineK = nSrcLineK;\n            }\n            const int nUsedBlockHeight = nLastSrcLineK - nSrcLine + 1;\n            // CPLAssert(nUsedBlockHeight <= nBlockYSize);\n\n            double dfSrcX = nXOff + 0.5 * dfSrcXInc;\n            int nCurBlockXOff = 0;\n            int nNextBlockXOff = 0;\n            toff_t nCurOffset = 0;\n            const GByte* pabyLocalSrcDataStartLine = nullptr;\n            for( int x = 0; x < nBufXSize; ++x, dfSrcX += dfSrcXInc)\n            {\n                const int nSrcPixel = static_cast<int>(dfSrcX);\n                if( nSrcPixel >= nNextBlockXOff )\n                {\n                    const int nBlockXOff = nSrcPixel / nBlockXSize;\n                    nCurBlockXOff = nBlockXOff * nBlockXSize;\n                    nNextBlockXOff = nCurBlockXOff + nBlockXSize;\n                    const int nBlockId =\n                        nBlockXOff + nBlockYOff * nBlocksPerRow;\n                    nCurOffset = panOffsets[nBlockId];\n                    if( nCurOffset != 0 )\n                    {\n                        pabyLocalSrcDataStartLine =\n                            oFetcher.FetchBytes(\n                                nCurOffset + nBaseByteOffsetInBlock,\n                                nBlockXSize *\n                                nBandsPerBlock * nUsedBlockHeight,\n                                nDTSize,\n                                bIsByteSwapped, bIsComplex, nBlockId);\n                        if( pabyLocalSrcDataStartLine == nullptr )\n                            return CE_Failure;\n                    }\n                }\n\n                if( nCurOffset == 0 )\n                {\n                    REACHED(38);\n\n                    for( int k = 0; k < ychunk; ++k )\n                    {\n                        GByte* const pabyLocalData =\n                            pabyData + (y + k) * nLineSpace + x * nPixelSpace;\n                        for( int iBand = 0; iBand < nBandCount; ++iBand )\n                        {\n                            GDALCopyWords(\n                                &dfNoData, GDT_Float64, 0,\n                                pabyLocalData + nBandSpace * iBand, eBufType, 0,\n                                1);\n                        }\n                    }\n                }\n                else\n                {\n                    const int nXOffsetInBlock = nSrcPixel - nCurBlockXOff;\n                    double dfYOff = dfYOffStart;\n                    const GByte* const pabyLocalSrcDataK0 =\n                        pabyLocalSrcDataStartLine +\n                        nXOffsetInBlock * nBandsPerBlockDTSize;\n                    GByte* pabyLocalData =\n                        pabyData + y * nLineSpace + x * nPixelSpace;\n                    for( int k = 0;\n                         k < ychunk;\n                         ++k, pabyLocalData += nLineSpace )\n                    {\n                        const GByte* pabyLocalSrcData = nullptr;\n                        if( ychunk <= 256 )\n                        {\n                            REACHED(39);\n                            pabyLocalSrcData =\n                                pabyLocalSrcDataK0 + anSrcYOffset[k];\n                        }\n                        else\n                        {\n                            REACHED(40);\n                            const int nYOffsetInBlockK =\n                                static_cast<int>(dfYOff) % nBlockYSize;\n                            // CPLAssert(\n                            //     nYOffsetInBlockK - nYOffsetInBlock <=\n                            //     nUsedBlockHeight);\n                            pabyLocalSrcData =\n                                pabyLocalSrcDataK0 +\n                                (nYOffsetInBlockK - nYOffsetInBlock) *\n                                nBlockXSize * nBandsPerBlockDTSize;\n                            dfYOff += dfSrcYInc;\n                        }\n\n                        if( bByteOnly )\n                        {\n                            REACHED(41);\n                            for( int iBand=0; iBand < nBandCount; ++iBand )\n                            {\n                                GByte* pabyLocalDataBand =\n                                    pabyLocalData + iBand * nBandSpace;\n                                const GByte* pabyLocalSrcDataBand =\n                                    pabyLocalSrcData + (panBandMap[iBand]-1);\n                                *pabyLocalDataBand = *pabyLocalSrcDataBand;\n                            }\n                        }\n                        else\n                        {\n                            REACHED(42);\n                            for( int iBand = 0; iBand < nBandCount; ++iBand )\n                            {\n                                GByte* pabyLocalDataBand =\n                                    pabyLocalData + iBand * nBandSpace;\n                                const GByte* pabyLocalSrcDataBand =\n                                    pabyLocalSrcData +\n                                    (panBandMap[iBand]-1) * nDTSize;\n\n                                GDALCopyWords( pabyLocalSrcDataBand,\n                                               eDataType, 0,\n                                               pabyLocalDataBand,\n                                               eBufType, 0,\n                                               1 );\n                            }\n                        }\n                    }\n                }\n            }\n\n            y += ychunk;\n        }\n    }\n    else if( FetchBuffer::bMinimizeIO &&\n             TIFFIsTiled( hTIFF ) )\n             // && (nPlanarConfig == PLANARCONFIG_SEPARATE || nBandCount == 1) )\n    {\n        for( int iBand = 0; iBand < nBandCount; ++iBand )\n        {\n            GByte* pabyData = static_cast<GByte*>(pData) + iBand * nBandSpace;\n            const int nBand = panBandMap[iBand];\n            int anSrcYOffset[256] = { 0 };\n            for( int y = 0; y < nBufYSize; )\n            {\n                const double dfYOffStart = nYOff + (y + 0.5) * dfSrcYInc;\n                const int nSrcLine = static_cast<int>(dfYOffStart);\n                const int nYOffsetInBlock = nSrcLine % nBlockYSize;\n                const int nBlockYOff = nSrcLine / nBlockYSize;\n                const int nBaseByteOffsetInBlock =\n                    nYOffsetInBlock * nBlockXSize * nBandsPerBlockDTSize;\n                int ychunk = 1;\n                int nLastSrcLineK = nSrcLine;\n                anSrcYOffset[0] = 0;\n                for( int k = 1; k < nBufYSize - y; ++k )\n                {\n                    const int nSrcLineK =\n                        nYOff + static_cast<int>((y + k + 0.5) * dfSrcYInc);\n                    const int nBlockYOffK = nSrcLineK / nBlockYSize;\n                    if( k < 256)\n                        anSrcYOffset[k] =\n                            ((nSrcLineK % nBlockYSize) - nYOffsetInBlock) *\n                            nBlockXSize * nBandsPerBlockDTSize;\n                    if( nBlockYOffK != nBlockYOff )\n                    {\n                        break;\n                    }\n                    ++ychunk;\n                    nLastSrcLineK = nSrcLineK;\n                }\n                const int nUsedBlockHeight = nLastSrcLineK - nSrcLine + 1;\n                // CPLAssert(nUsedBlockHeight <= nBlockYSize);\n\n                double dfSrcX = nXOff + 0.5 * dfSrcXInc;\n                int nCurBlockXOff = 0;\n                int nNextBlockXOff = 0;\n                toff_t nCurOffset = 0;\n                const GByte* pabyLocalSrcDataStartLine = nullptr;\n                for( int x = 0; x < nBufXSize; ++x, dfSrcX += dfSrcXInc )\n                {\n                    int nSrcPixel = static_cast<int>(dfSrcX);\n                    if( nSrcPixel >= nNextBlockXOff )\n                    {\n                        const int nBlockXOff = nSrcPixel / nBlockXSize;\n                        nCurBlockXOff = nBlockXOff * nBlockXSize;\n                        nNextBlockXOff = nCurBlockXOff + nBlockXSize;\n                        int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n                        if( nPlanarConfig == PLANARCONFIG_SEPARATE )\n                        {\n                            REACHED(43);\n                            nBlockId += nBlocksPerBand * (nBand - 1);\n                        }\n                        else\n                        {\n                            REACHED(44);\n                        }\n                        nCurOffset = panOffsets[nBlockId];\n                        if( nCurOffset != 0 )\n                        {\n                            pabyLocalSrcDataStartLine =\n                                oFetcher.FetchBytes(\n                                    nCurOffset + nBaseByteOffsetInBlock,\n                                    nBlockXSize *\n                                    nBandsPerBlock * nUsedBlockHeight,\n                                    nDTSize,\n                                    bIsByteSwapped, bIsComplex, nBlockId);\n                            if( pabyLocalSrcDataStartLine == nullptr )\n                                return CE_Failure;\n\n                            if( nPlanarConfig == PLANARCONFIG_CONTIG )\n                            {\n                                REACHED(45);\n                                pabyLocalSrcDataStartLine +=\n                                    (nBand - 1) * nDTSize;\n                            }\n                            else\n                            {\n                                REACHED(46);\n                            }\n                        }\n                    }\n\n                    if( nCurOffset == 0 )\n                    {\n                        REACHED(47);\n\n                        for( int k = 0; k < ychunk; ++k )\n                        {\n                            GByte* const pabyLocalData =\n                                pabyData + (y + k) * nLineSpace + x * nPixelSpace;\n\n                            GDALCopyWords( &dfNoData, GDT_Float64, 0,\n                                           pabyLocalData, eBufType, 0,\n                                           1 );\n                        }\n                    }\n                    else\n                    {\n                        const int nXOffsetInBlock = nSrcPixel - nCurBlockXOff;\n                        double dfYOff = dfYOffStart;\n                        const GByte* const pabyLocalSrcDataK0 =\n                            pabyLocalSrcDataStartLine +\n                            nXOffsetInBlock * nBandsPerBlockDTSize;\n                        GByte* pabyLocalData =\n                            pabyData + y * nLineSpace + x * nPixelSpace;\n                        for( int k = 0;\n                             k < ychunk;\n                             ++k, pabyLocalData += nLineSpace )\n                        {\n                            const GByte* pabyLocalSrcData = nullptr;\n                            if( ychunk <= 256 )\n                            {\n                                REACHED(48);\n                                pabyLocalSrcData =\n                                    pabyLocalSrcDataK0 + anSrcYOffset[k];\n                            }\n                            else\n                            {\n                                REACHED(49);\n                                const int nYOffsetInBlockK =\n                                    static_cast<int>(dfYOff) % nBlockYSize;\n                                // CPLAssert(\n                                //     nYOffsetInBlockK - nYOffsetInBlock <=\n                                //     nUsedBlockHeight);\n                                pabyLocalSrcData = pabyLocalSrcDataK0 +\n                                    (nYOffsetInBlockK - nYOffsetInBlock) *\n                                    nBlockXSize * nBandsPerBlockDTSize;\n                                dfYOff += dfSrcYInc;\n                            }\n\n                            if( bByteOnly )\n                            {\n                                REACHED(50);\n\n                                *pabyLocalData = *pabyLocalSrcData;\n                            }\n                            else\n                            {\n                                REACHED(51);\n\n                                GDALCopyWords( pabyLocalSrcData,\n                                               eDataType, 0,\n                                               pabyLocalData,\n                                               eBufType, 0,\n                                               1 );\n                            }\n                        }\n                    }\n                }\n\n                y += ychunk;\n            }\n        }\n    }\n    else if( bUseContigImplementation )\n    {\n        if( !FetchBuffer::bMinimizeIO && TIFFIsTiled( hTIFF ) )\n        {\n            GByte* pabyData = static_cast<GByte *>(pData);\n            for( int y = 0; y < nBufYSize; ++y )\n            {\n                const int nSrcLine =\n                    nYOff + static_cast<int>((y + 0.5) * dfSrcYInc);\n                const int nBlockYOff = nSrcLine / nBlockYSize;\n                const int nYOffsetInBlock = nSrcLine % nBlockYSize;\n                const int nBaseByteOffsetInBlock =\n                    nYOffsetInBlock * nBlockXSize * nBandsPerBlockDTSize;\n\n                if( bNoXResampling )\n                {\n                    GByte* pabyLocalData = pabyData + y * nLineSpace;\n                    int nBlockXOff = nXOff / nBlockXSize;\n                    int nXOffsetInBlock = nXOff % nBlockXSize;\n                    int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n\n                    int x = 0;\n                    while( x < nBufXSize )\n                    {\n                        const int nByteOffsetInBlock = nBaseByteOffsetInBlock +\n                                        nXOffsetInBlock * nBandsPerBlockDTSize;\n                        const toff_t nCurOffset = panOffsets[nBlockId];\n                        const int nUsedBlockWidth =\n                            std::min(\n                                nBlockXSize - nXOffsetInBlock,\n                                nBufXSize - x);\n\n                        int nIters = nUsedBlockWidth;\n                        if( nCurOffset == 0 )\n                        {\n                            if( bByteNoXResampling )\n                            {\n                                REACHED(0);\n                                while( nIters-- > 0 )\n                                {\n                                    for( int iBand = 0;\n                                         iBand < nBandCount;\n                                         ++iBand )\n                                    {\n                                        pabyLocalData[iBand] = abyNoData;\n                                    }\n                                    pabyLocalData += nPixelSpace;\n                                }\n                            }\n                            else\n                            {\n                                REACHED(1);\n                                while( nIters-- > 0 )\n                                {\n                                    GDALCopyWords(\n                                        &dfNoData, GDT_Float64, 0,\n                                        pabyLocalData, eBufType,\n                                        static_cast<int>(nBandSpace),\n                                        nBandCount);\n                                    pabyLocalData += nPixelSpace;\n                                }\n                            }\n                        }\n                        else\n                        {\n                            if( bNoTypeChange && nBands == nBandCount &&\n                                nPixelSpace == nBandsPerBlockDTSize )\n                            {\n                                REACHED(2);\n                                if( !oFetcher.FetchBytes(\n                                        pabyLocalData,\n                                        nCurOffset + nByteOffsetInBlock,\n                                        nIters * nBandsPerBlock, nDTSize,\n                                        bIsByteSwapped, bIsComplex, nBlockId) )\n                                {\n                                    return CE_Failure;\n                                }\n                                pabyLocalData +=\n                                    nIters * nBandsPerBlock * nDTSize;\n                            }\n                            else\n                            {\n                                const GByte* pabyLocalSrcData =\n                                    oFetcher.FetchBytes(\n                                        nCurOffset + nByteOffsetInBlock,\n                                        nIters * nBandsPerBlock, nDTSize,\n                                        bIsByteSwapped, bIsComplex, nBlockId);\n                                if( pabyLocalSrcData == nullptr )\n                                    return CE_Failure;\n                                if( bByteNoXResampling )\n                                {\n                                    REACHED(3);\n                                    CopyContigByteMultiBand(\n                                        pabyLocalSrcData,\n                                        nBandsPerBlockDTSize,\n                                        pabyLocalData,\n                                        static_cast<int>(nPixelSpace),\n                                        nIters,\n                                        nBandCount);\n                                    pabyLocalData += nIters * nPixelSpace;\n                                }\n                                else\n                                {\n                                    REACHED(4);\n                                    while( nIters-- > 0 )\n                                    {\n                                        GDALCopyWords(\n                                            pabyLocalSrcData,\n                                            eDataType, nDTSize,\n                                            pabyLocalData,\n                                            eBufType,\n                                            static_cast<int>(nBandSpace),\n                                            nBandCount);\n                                        pabyLocalSrcData +=\n                                            nBandsPerBlockDTSize;\n                                        pabyLocalData += nPixelSpace;\n                                    }\n                                }\n                            }\n                        }\n\n                        nXOffsetInBlock = 0;\n                        ++nBlockXOff;\n                        ++nBlockId;\n                        x += nUsedBlockWidth;\n                    }\n                }\n                else  // Contig, tiled, potential resampling & data type change.\n                {\n                    const GByte* pabyLocalSrcDataStartLine = nullptr;\n                    GByte* pabyLocalData = pabyData + y * nLineSpace;\n                    double dfSrcX = nXOff + 0.5 * dfSrcXInc;\n                    int nCurBlockXOff = 0;\n                    int nNextBlockXOff = 0;\n                    toff_t nCurOffset = 0;\n                    for( int x = 0; x < nBufXSize; ++x, dfSrcX += dfSrcXInc )\n                    {\n                        int nSrcPixel = static_cast<int>(dfSrcX);\n                        if( nSrcPixel >= nNextBlockXOff )\n                        {\n                            const int nBlockXOff = nSrcPixel / nBlockXSize;\n                            nCurBlockXOff = nBlockXOff * nBlockXSize;\n                            nNextBlockXOff = nCurBlockXOff + nBlockXSize;\n                            const int nBlockId =\n                                nBlockXOff + nBlockYOff * nBlocksPerRow;\n                            nCurOffset = panOffsets[nBlockId];\n                            if( nCurOffset != 0 )\n                            {\n                                pabyLocalSrcDataStartLine =\n                                    oFetcher.FetchBytes(\n                                        nCurOffset + nBaseByteOffsetInBlock,\n                                        nBlockXSize *\n                                        nBandsPerBlock,\n                                        nDTSize,\n                                        bIsByteSwapped, bIsComplex, nBlockId);\n                                if( pabyLocalSrcDataStartLine == nullptr )\n                                    return CE_Failure;\n                            }\n                        }\n                        const int nXOffsetInBlock = nSrcPixel - nCurBlockXOff;\n\n                        if( nCurOffset == 0 )\n                        {\n                            REACHED(5);\n                            GDALCopyWords(\n                                &dfNoData, GDT_Float64, 0,\n                                pabyLocalData,\n                                eBufType,\n                                static_cast<int>(nBandSpace),\n                                nBandCount );\n                            pabyLocalData += nPixelSpace;\n                        }\n                        else\n                        {\n                            const GByte* pabyLocalSrcData =\n                                pabyLocalSrcDataStartLine +\n                                nXOffsetInBlock * nBandsPerBlockDTSize;\n\n                            REACHED(6);\n                            if( bByteOnly )\n                            {\n                                for( int iBand = 0; iBand < nBands; ++iBand )\n                                    pabyLocalData[iBand] =\n                                        pabyLocalSrcData[iBand];\n                            }\n                            else\n                            {\n                                GDALCopyWords(\n                                    pabyLocalSrcData,\n                                    eDataType, nDTSize,\n                                    pabyLocalData,\n                                    eBufType,\n                                    static_cast<int>(nBandSpace),\n                                    nBandCount );\n                            }\n                            pabyLocalData += nPixelSpace;\n                        }\n                    }\n                }\n            }\n        }\n        else  // Contig, stripped organized.\n        {\n            GByte* pabyData = static_cast<GByte*>(pData);\n            for( int y = 0; y < nBufYSize; ++y )\n            {\n                const int nSrcLine =\n                    nYOff + static_cast<int>((y + 0.5) * dfSrcYInc);\n                const int nBlockYOff = nSrcLine / nBlockYSize;\n                const int nYOffsetInBlock = nSrcLine % nBlockYSize;\n                const int nBlockId = nBlockYOff;\n                const toff_t nCurOffset = panOffsets[nBlockId];\n                if( nCurOffset == 0 )\n                {\n                    REACHED(7);\n                    for( int x = 0; x < nBufXSize; ++x )\n                    {\n                        GDALCopyWords(\n                            &dfNoData, GDT_Float64, 0,\n                            pabyData + y * nLineSpace + x * nPixelSpace,\n                            eBufType, static_cast<int>(nBandSpace),\n                            nBandCount);\n                    }\n                }\n                else\n                {\n                    GByte* pabyLocalData = pabyData + y * nLineSpace;\n                    const int nBaseByteOffsetInBlock =\n                        (nYOffsetInBlock * nBlockXSize + nXOff) *\n                        nBandsPerBlockDTSize;\n\n                    if( bNoXResamplingNoTypeChange && nBands == nBandCount &&\n                        nPixelSpace == nBandsPerBlockDTSize )\n                    {\n                        REACHED(8);\n                        if( !oFetcher.FetchBytes(\n                               pabyLocalData,\n                               nCurOffset + nBaseByteOffsetInBlock,\n                               nXSize * nBandsPerBlock, nDTSize, bIsByteSwapped,\n                               bIsComplex, nBlockId) )\n                        {\n                            return CE_Failure;\n                        }\n                    }\n                    else\n                    {\n                        const GByte* pabyLocalSrcData = oFetcher.FetchBytes(\n                            nCurOffset + nBaseByteOffsetInBlock,\n                            nXSize * nBandsPerBlock, nDTSize, bIsByteSwapped,\n                            bIsComplex, nBlockId);\n                        if( pabyLocalSrcData == nullptr )\n                            return CE_Failure;\n\n                        if( bByteNoXResampling )\n                        {\n                            REACHED(9);\n                            CopyContigByteMultiBand(\n                                pabyLocalSrcData,\n                                nBandsPerBlockDTSize,\n                                pabyLocalData,\n                                static_cast<int>(nPixelSpace),\n                                nBufXSize,\n                                nBandCount);\n                        }\n                        else if( bByteOnly )\n                        {\n                            REACHED(10);\n                            double dfSrcX = 0.5 * dfSrcXInc;\n                            for( int x = 0;\n                                 x < nBufXSize;\n                                 ++x, dfSrcX += dfSrcXInc )\n                            {\n                                const int nSrcPixelMinusXOff =\n                                    static_cast<int>(dfSrcX);\n                                for( int iBand = 0;\n                                     iBand < nBandCount;\n                                     ++iBand )\n                                {\n                                    pabyLocalData[x * nPixelSpace + iBand] =\n                                        pabyLocalSrcData[nSrcPixelMinusXOff *\n                                                         nBandsPerBlockDTSize +\n                                                         iBand];\n                                }\n                            }\n                        }\n                        else\n                        {\n                            REACHED(11);\n                            double dfSrcX = 0.5 * dfSrcXInc;\n                            for( int x = 0;\n                                 x < nBufXSize;\n                                 ++x, dfSrcX += dfSrcXInc )\n                            {\n                                int nSrcPixelMinusXOff =\n                                    static_cast<int>(dfSrcX);\n                                GDALCopyWords(\n                                    pabyLocalSrcData +\n                                    nSrcPixelMinusXOff * nBandsPerBlockDTSize,\n                                    eDataType, nDTSize,\n                                    pabyLocalData + x * nPixelSpace,\n                                    eBufType,\n                                    static_cast<int>(nBandSpace),\n                                    nBandCount );\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    else  // Non-contig reading case.\n    {\n        if( !FetchBuffer::bMinimizeIO && TIFFIsTiled( hTIFF ) )\n        {\n            for( int iBand = 0; iBand < nBandCount; ++iBand )\n            {\n                const int nBand = panBandMap[iBand];\n                GByte* const pabyData =\n                    static_cast<GByte*>(pData) + iBand * nBandSpace;\n                for( int y = 0; y < nBufYSize; ++y )\n                {\n                    const int nSrcLine =\n                        nYOff + static_cast<int>((y + 0.5) * dfSrcYInc);\n                    const int nBlockYOff = nSrcLine / nBlockYSize;\n                    const int nYOffsetInBlock = nSrcLine % nBlockYSize;\n\n                    int nBaseByteOffsetInBlock =\n                        nYOffsetInBlock * nBlockXSize * nBandsPerBlockDTSize;\n                    if( nPlanarConfig == PLANARCONFIG_CONTIG )\n                    {\n                        REACHED(12);\n                        nBaseByteOffsetInBlock += (nBand - 1) * nDTSize;\n                    }\n                    else\n                    {\n                        REACHED(13);\n                    }\n\n                    if( bNoXResampling )\n                    {\n                        GByte* pabyLocalData = pabyData + y * nLineSpace;\n                        int nBlockXOff = nXOff / nBlockXSize;\n                        int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n                        if( nPlanarConfig == PLANARCONFIG_SEPARATE )\n                        {\n                            REACHED(14);\n                            nBlockId += nBlocksPerBand * (nBand - 1);\n                        }\n                        else\n                        {\n                            REACHED(15);\n                        }\n                        int nXOffsetInBlock = nXOff % nBlockXSize;\n\n                        int x = 0;\n                        while( x < nBufXSize )\n                        {\n                            const int nByteOffsetInBlock =\n                                nBaseByteOffsetInBlock +\n                                nXOffsetInBlock * nBandsPerBlockDTSize;\n                            const toff_t nCurOffset = panOffsets[nBlockId];\n                            const int nUsedBlockWidth =\n                                std::min(\n                                    nBlockXSize - nXOffsetInBlock,\n                                    nBufXSize - x );\n                            int nIters = nUsedBlockWidth;\n\n                            if( nCurOffset == 0 )\n                            {\n                                REACHED(16);\n                                GDALCopyWords(\n                                    &dfNoData, GDT_Float64, 0,\n                                    pabyLocalData, eBufType,\n                                    static_cast<int>(nPixelSpace),\n                                    nIters);\n                                pabyLocalData += nIters * nPixelSpace;\n                            }\n                            else\n                            {\n                                if( bNoTypeChange &&\n                                    nPixelSpace == nBandsPerBlockDTSize )\n                                {\n                                    REACHED(17);\n                                    if( !oFetcher.FetchBytes(\n                                           pabyLocalData,\n                                           nCurOffset + nByteOffsetInBlock,\n                                           (nIters - 1) * nBandsPerBlock + 1,\n                                           nDTSize,\n                                           bIsByteSwapped, bIsComplex,\n                                           nBlockId) )\n                                    {\n                                        return CE_Failure;\n                                    }\n                                    pabyLocalData += nIters * nPixelSpace;\n                                }\n                                else\n                                {\n                                    const GByte* pabyLocalSrcData =\n                                        oFetcher.FetchBytes(\n                                            nCurOffset + nByteOffsetInBlock,\n                                            (nIters - 1) * nBandsPerBlock + 1,\n                                            nDTSize,\n                                            bIsByteSwapped,\n                                            bIsComplex,\n                                            nBlockId );\n                                    if( pabyLocalSrcData == nullptr )\n                                        return CE_Failure;\n\n                                    REACHED(18);\n                                    GDALCopyWords(\n                                        pabyLocalSrcData, eDataType,\n                                        nBandsPerBlockDTSize,\n                                        pabyLocalData, eBufType,\n                                        static_cast<int>(nPixelSpace),\n                                        nIters );\n                                    pabyLocalData += nIters * nPixelSpace;\n                                }\n                            }\n\n                            nXOffsetInBlock = 0;\n                            ++nBlockXOff;\n                            ++nBlockId;\n                            x += nUsedBlockWidth;\n                        }\n                    }\n                    else\n                    {\n                        // Non-contig reading, tiled, potential resampling and\n                        // data type change.\n\n                        const GByte* pabyLocalSrcDataStartLine = nullptr;\n                        GByte* pabyLocalData = pabyData + y * nLineSpace;\n                        double dfSrcX = nXOff + 0.5 * dfSrcXInc;\n                        int nCurBlockXOff = 0;\n                        int nNextBlockXOff = 0;\n                        toff_t nCurOffset = 0;\n                        for( int x = 0; x < nBufXSize; ++x, dfSrcX += dfSrcXInc)\n                        {\n                            const int nSrcPixel = static_cast<int>(dfSrcX);\n                            if( nSrcPixel >= nNextBlockXOff )\n                            {\n                                const int nBlockXOff = nSrcPixel / nBlockXSize;\n                                nCurBlockXOff = nBlockXOff * nBlockXSize;\n                                nNextBlockXOff = nCurBlockXOff + nBlockXSize;\n                                int nBlockId =\n                                    nBlockXOff + nBlockYOff * nBlocksPerRow;\n                                if( nPlanarConfig == PLANARCONFIG_SEPARATE )\n                                {\n                                    REACHED(19);\n                                    nBlockId += nBlocksPerBand * (nBand - 1);\n                                }\n                                else\n                                {\n                                    REACHED(20);\n                                }\n                                nCurOffset = panOffsets[nBlockId];\n                                if( nCurOffset != 0 )\n                                {\n                                    pabyLocalSrcDataStartLine =\n                                        oFetcher.FetchBytes(\n                                            nCurOffset + nBaseByteOffsetInBlock,\n                                            nBlockXSize * nBandsPerBlock,\n                                            nDTSize,\n                                            bIsByteSwapped,\n                                            bIsComplex,\n                                            nBlockId);\n                                    if( pabyLocalSrcDataStartLine == nullptr )\n                                        return CE_Failure;\n                                }\n                            }\n                            const int nXOffsetInBlock =\n                                nSrcPixel - nCurBlockXOff;\n\n                            if( nCurOffset == 0 )\n                            {\n                                REACHED(21);\n                                GDALCopyWords( &dfNoData, GDT_Float64, 0,\n                                               pabyLocalData,\n                                               eBufType, 0,\n                                               1 );\n                                pabyLocalData += nPixelSpace;\n                            }\n                            else\n                            {\n                                const GByte* pabyLocalSrcData =\n                                    pabyLocalSrcDataStartLine +\n                                    nXOffsetInBlock * nBandsPerBlockDTSize;\n\n                                REACHED(22);\n                                if( bByteOnly )\n                                {\n                                    *pabyLocalData = *pabyLocalSrcData;\n                                }\n                                else\n                                {\n                                    GDALCopyWords(pabyLocalSrcData,\n                                                eDataType, 0,\n                                                pabyLocalData,\n                                                eBufType, 0,\n                                                1);\n                                }\n                                pabyLocalData += nPixelSpace;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        else  // Non-contig reading, stripped.\n        {\n            for( int iBand = 0; iBand < nBandCount; ++iBand )\n            {\n                const int nBand = panBandMap[iBand];\n                GByte* pabyData =\n                    static_cast<GByte *>(pData) + iBand * nBandSpace;\n                for( int y = 0; y < nBufYSize; ++y )\n                {\n                    const int nSrcLine =\n                        nYOff + static_cast<int>((y + 0.5) * dfSrcYInc);\n                    const int nBlockYOff = nSrcLine / nBlockYSize;\n                    const int nYOffsetInBlock = nSrcLine % nBlockYSize;\n                    int nBlockId = nBlockYOff;\n                    if( nPlanarConfig == PLANARCONFIG_SEPARATE )\n                    {\n                        REACHED(23);\n                        nBlockId += nBlocksPerBand * (nBand - 1);\n                    }\n                    else\n                    {\n                        REACHED(24);\n                    }\n                    const toff_t nCurOffset = panOffsets[nBlockId];\n                    if( nCurOffset == 0 )\n                    {\n                        REACHED(25);\n                        GDALCopyWords(\n                            &dfNoData, GDT_Float64, 0,\n                            pabyData + y * nLineSpace,\n                            eBufType,\n                            static_cast<int>(nPixelSpace),\n                            nBufXSize);\n                    }\n                    else\n                    {\n                        int nBaseByteOffsetInBlock =\n                            (nYOffsetInBlock * nBlockXSize + nXOff) *\n                            nBandsPerBlockDTSize;\n                        if( nPlanarConfig == PLANARCONFIG_CONTIG )\n                            nBaseByteOffsetInBlock += (nBand - 1) * nDTSize;\n\n                        GByte* pabyLocalData = pabyData + y * nLineSpace;\n                        if( bNoXResamplingNoTypeChange &&\n                            nPixelSpace == nBandsPerBlockDTSize )\n                        {\n                            REACHED(26);\n                            if( !oFetcher.FetchBytes(\n                                pabyLocalData,\n                                nCurOffset + nBaseByteOffsetInBlock,\n                                (nXSize - 1) * nBandsPerBlock + 1, nDTSize,\n                                bIsByteSwapped, bIsComplex, nBlockId) )\n                            {\n                                return CE_Failure;\n                            }\n                        }\n                        else\n                        {\n                            const GByte* pabyLocalSrcData = oFetcher.FetchBytes(\n                                nCurOffset + nBaseByteOffsetInBlock,\n                                (nXSize - 1) * nBandsPerBlock + 1, nDTSize,\n                                bIsByteSwapped, bIsComplex, nBlockId);\n                            if( pabyLocalSrcData == nullptr )\n                                return CE_Failure;\n\n                            if( bNoXResamplingNoTypeChange )\n                            {\n                                REACHED(27);\n                                GDALCopyWords(pabyLocalSrcData,\n                                              eDataType, nBandsPerBlockDTSize,\n                                              pabyLocalData, eBufType,\n                                              static_cast<int>(nPixelSpace),\n                                              nBufXSize);\n                            }\n                            else if( bByteOnly )\n                            {\n                                REACHED(28);\n                                double dfSrcX = 0.5 * dfSrcXInc;\n                                for( int x = 0;\n                                     x < nBufXSize;\n                                     ++x, dfSrcX += dfSrcXInc )\n                                {\n                                    const int nSrcPixelMinusXOff =\n                                        static_cast<int>(dfSrcX);\n                                    pabyLocalData[x * nPixelSpace] =\n                                        pabyLocalSrcData[nSrcPixelMinusXOff *\n                                                         nBandsPerBlockDTSize];\n                                }\n                            }\n                            else\n                            {\n                                REACHED(29);\n                                double dfSrcX = 0.5 * dfSrcXInc;\n                                for( int x = 0;\n                                     x < nBufXSize;\n                                     ++x, dfSrcX += dfSrcXInc )\n                                {\n                                    const int nSrcPixelMinusXOff =\n                                        static_cast<int>(dfSrcX);\n                                    GDALCopyWords(\n                                        pabyLocalSrcData +\n                                        nSrcPixelMinusXOff *\n                                        nBandsPerBlockDTSize,\n                                        eDataType, 0,\n                                        pabyLocalData + x * nPixelSpace,\n                                        eBufType, 0,\n                                        1 );\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                           DirectIO()                                 */\n/************************************************************************/\n\n// Reads directly bytes from the file using ReadMultiRange(), and by-pass\n// block reading. Restricted to simple TIFF configurations\n// (uncompressed data, standard data types). Particularly useful to extract\n// sub-windows of data on a large /vsicurl dataset).\n// Returns -1 if DirectIO() can't be supported on that file.\n\nint GTiffDataset::DirectIO( GDALRWFlag eRWFlag,\n                            int nXOff, int nYOff, int nXSize, int nYSize,\n                            void * pData, int nBufXSize, int nBufYSize,\n                            GDALDataType eBufType,\n                            int nBandCount, int *panBandMap,\n                            GSpacing nPixelSpace, GSpacing nLineSpace,\n                            GSpacing nBandSpace,\n                            GDALRasterIOExtraArg* psExtraArg )\n{\n    const GDALDataType eDataType = GetRasterBand(1)->GetRasterDataType();\n    const int nDTSizeBits = GDALGetDataTypeSizeBits(eDataType);\n    if( !(eRWFlag == GF_Read &&\n          nCompression == COMPRESSION_NONE &&\n          (nPhotometric == PHOTOMETRIC_MINISBLACK ||\n           nPhotometric == PHOTOMETRIC_RGB ||\n           nPhotometric == PHOTOMETRIC_PALETTE) &&\n          nBitsPerSample == nDTSizeBits &&\n          SetDirectory() /* Very important to make hTIFF uptodate! */ ) )\n    {\n        return -1;\n    }\n\n    // Only know how to deal with nearest neighbour in this optimized routine.\n    if( (nXSize != nBufXSize || nYSize != nBufYSize) &&\n        psExtraArg != nullptr &&\n        psExtraArg->eResampleAlg != GRIORA_NearestNeighbour )\n    {\n        return -1;\n    }\n\n    // If the file is band interleave or only one band is requested, then\n    // fallback to band DirectIO.\n    bool bUseBandRasterIO = false;\n    if( nPlanarConfig == PLANARCONFIG_SEPARATE || nBandCount == 1 )\n    {\n        bUseBandRasterIO = true;\n    }\n    else\n    {\n        // For simplicity, only deals with \"naturally ordered\" bands.\n        for( int iBand = 0; iBand < nBandCount; ++iBand )\n        {\n            if( panBandMap[iBand] != iBand + 1)\n            {\n                bUseBandRasterIO = true;\n                break;\n            }\n        }\n    }\n    if( bUseBandRasterIO )\n    {\n        CPLErr eErr = CE_None;\n        for( int iBand = 0; eErr == CE_None && iBand < nBandCount; ++iBand )\n        {\n            eErr = GetRasterBand(panBandMap[iBand])->RasterIO(\n                eRWFlag, nXOff, nYOff, nXSize, nYSize,\n                static_cast<GByte *>(pData) + iBand * nBandSpace,\n                nBufXSize, nBufYSize,\n                eBufType,\n                nPixelSpace, nLineSpace,\n                psExtraArg );\n        }\n        return eErr;\n    }\n\n#if DEBUG_VERBOSE\n    CPLDebug( \"GTiff\", \"DirectIO(%d,%d,%d,%d -> %dx%d)\",\n              nXOff, nYOff, nXSize, nYSize,\n              nBufXSize, nBufYSize );\n#endif\n\n    // No need to look if overviews can satisfy the request as it has already */\n    // been done in GTiffDataset::IRasterIO().\n\n    // Make sure that TIFFTAG_STRIPOFFSETS is up-to-date.\n    if( GetAccess() == GA_Update )\n    {\n        FlushCache();\n        VSI_TIFFFlushBufferedWrite( TIFFClientdata( hTIFF ) );\n    }\n\n    if( TIFFIsTiled( hTIFF ) )\n    {\n        if( m_pTempBufferForCommonDirectIO == nullptr )\n        {\n            const int nDTSize = nDTSizeBits / 8;\n            m_nTempBufferForCommonDirectIOSize =\n                static_cast<size_t>(nBlockXSize * nBlockYSize * nDTSize *\n                ((nPlanarConfig == PLANARCONFIG_CONTIG) ? nBands : 1));\n\n            m_pTempBufferForCommonDirectIO =\n                static_cast<GByte *>(\n                    VSI_MALLOC_VERBOSE(m_nTempBufferForCommonDirectIOSize) );\n            if( m_pTempBufferForCommonDirectIO == nullptr )\n                return CE_Failure;\n        }\n\n        VSILFILE* fp = VSI_TIFFGetVSILFile(TIFFClientdata( hTIFF ));\n        FetchBufferDirectIO oFetcher(fp, m_pTempBufferForCommonDirectIO,\n                                     m_nTempBufferForCommonDirectIOSize);\n\n        return CommonDirectIO( oFetcher,\n                               nXOff, nYOff, nXSize, nYSize,\n                               pData, nBufXSize, nBufYSize,\n                               eBufType,\n                               nBandCount, panBandMap,\n                               nPixelSpace, nLineSpace,\n                              nBandSpace );\n    }\n\n    // Get strip offsets.\n    toff_t *panTIFFOffsets = nullptr;\n    if( !TIFFGetField( hTIFF, TIFFTAG_STRIPOFFSETS, &panTIFFOffsets ) ||\n        panTIFFOffsets == nullptr )\n    {\n        return CE_Failure;\n    }\n\n    // Sub-sampling or over-sampling can only be done at last stage.\n    int nReqXSize = nXSize;\n    // Can do sub-sampling at the extraction stage.\n    const int nReqYSize = std::min(nBufYSize, nYSize);\n    void** ppData =\n        static_cast<void **>( VSI_MALLOC_VERBOSE(nReqYSize * sizeof(void*)) );\n    vsi_l_offset* panOffsets =\n        static_cast<vsi_l_offset *>(\n            VSI_MALLOC_VERBOSE(nReqYSize * sizeof(vsi_l_offset)) );\n    size_t* panSizes =\n        static_cast<size_t *>( VSI_MALLOC_VERBOSE(nReqYSize * sizeof(size_t)) );\n    const int nDTSize = GDALGetDataTypeSizeBytes(eDataType);\n    void* pTmpBuffer = nullptr;\n    int eErr = CE_None;\n    int nContigBands = nBands;\n    const int nSrcPixelSize = nDTSize * nContigBands;\n\n    if( ppData == nullptr || panOffsets == nullptr || panSizes == nullptr )\n    {\n        eErr = CE_Failure;\n    }\n    // For now we always allocate a temp buffer as it is easier.\n    else\n        // if( nXSize != nBufXSize || nYSize != nBufYSize ||\n        //   eBufType != eDataType ||\n        //   nPixelSpace != GDALGetDataTypeSizeBytes(eBufType) ||\n        //   check if the user buffer is large enough )\n    {\n        // We need a temporary buffer for over-sampling/sub-sampling\n        // and/or data type conversion.\n        pTmpBuffer = VSI_MALLOC_VERBOSE(nReqXSize * nReqYSize * nSrcPixelSize);\n        if( pTmpBuffer == nullptr )\n            eErr = CE_Failure;\n    }\n\n    // Prepare data extraction.\n    const double dfSrcYInc = nYSize / static_cast<double>( nBufYSize );\n\n    for( int iLine = 0; eErr == CE_None && iLine < nReqYSize; ++iLine )\n    {\n        ppData[iLine] =\n            static_cast<GByte *>(pTmpBuffer) +\n            iLine * nReqXSize * nSrcPixelSize;\n        int nSrcLine = 0;\n        if( nBufYSize < nYSize )  // Sub-sampling in y.\n            nSrcLine = nYOff + static_cast<int>((iLine + 0.5) * dfSrcYInc);\n        else\n            nSrcLine = nYOff + iLine;\n\n        const int nBlockXOff = 0;\n        const int nBlockYOff = nSrcLine / nBlockYSize;\n        const int nYOffsetInBlock = nSrcLine % nBlockYSize;\n        const int nBlocksPerRow = DIV_ROUND_UP(nRasterXSize, nBlockXSize);\n        const int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n\n        panOffsets[iLine] = panTIFFOffsets[nBlockId];\n        if( panOffsets[iLine] == 0)  // We don't support sparse files.\n            eErr = -1;\n\n        panOffsets[iLine] +=\n            (nXOff + nYOffsetInBlock * nBlockXSize) * nSrcPixelSize;\n        panSizes[iLine] = nReqXSize * nSrcPixelSize;\n    }\n\n    // Extract data from the file.\n    if( eErr == CE_None )\n    {\n        VSILFILE* fp = VSI_TIFFGetVSILFile(TIFFClientdata( hTIFF ));\n        const int nRet =\n            VSIFReadMultiRangeL(nReqYSize, ppData, panOffsets, panSizes, fp);\n        if( nRet != 0 )\n            eErr = CE_Failure;\n    }\n\n    // Byte-swap if necessary.\n    if( eErr == CE_None && TIFFIsByteSwapped(hTIFF) )\n    {\n        for( int iLine = 0; iLine < nReqYSize; ++iLine )\n        {\n            if( GDALDataTypeIsComplex(eDataType) )\n                GDALSwapWords( ppData[iLine], nDTSize / 2,\n                               2 * nReqXSize * nContigBands, nDTSize / 2);\n            else\n                GDALSwapWords( ppData[iLine], nDTSize,\n                               nReqXSize * nContigBands, nDTSize);\n        }\n    }\n\n    // Over-sampling/sub-sampling and/or data type conversion.\n    const double dfSrcXInc = nXSize / static_cast<double>( nBufXSize );\n    if( eErr == CE_None && pTmpBuffer != nullptr )\n    {\n        for( int iY = 0; iY < nBufYSize; ++iY )\n        {\n            const int iSrcY =\n                nBufYSize <= nYSize ?\n                iY : static_cast<int>((iY + 0.5) * dfSrcYInc);\n            // Optimization: no resampling, no data type change, number of\n            // bands requested == number of bands and buffer is packed\n            // pixel-interleaved.\n            if( nBufXSize == nXSize && nContigBands == nBandCount &&\n                eDataType == eBufType &&\n                nBandSpace == nDTSize &&\n                nPixelSpace == nBandCount * nBandSpace )\n            {\n                memcpy(\n                    static_cast<GByte *>(pData) + iY * nLineSpace,\n                    ppData[iSrcY],\n                    static_cast<size_t>(nReqXSize * nPixelSpace) );\n            }\n            // Other optimization: no resampling, no data type change,\n            // data type is Byte.\n            else if( nBufXSize == nXSize &&\n                     eDataType == eBufType && eDataType == GDT_Byte )\n            {\n                GByte* pabySrcData = static_cast<GByte *>(ppData[iSrcY]);\n                GByte* pabyDstData =\n                    static_cast<GByte *>(pData) + iY * nLineSpace;\n                if( nBandSpace == 1 && nPixelSpace > nBandCount )\n                {\n                    // Buffer is pixel-interleaved (with some stridding\n                    // between pixels).\n                    CopyContigByteMultiBand( pabySrcData, nSrcPixelSize,\n                                             pabyDstData,\n                                             static_cast<int>(nPixelSpace),\n                                             nBufXSize, nBandCount );\n                }\n                else\n                {\n                    for( int iBand = 0; iBand < nBandCount; ++iBand )\n                    {\n                        GDALCopyWords(\n                            pabySrcData + iBand, GDT_Byte, nSrcPixelSize,\n                            pabyDstData + iBand * nBandSpace,\n                            GDT_Byte, static_cast<int>(nPixelSpace),\n                            nBufXSize );\n                    }\n                }\n            }\n            else  // General case.\n            {\n                for( int iBand = 0; iBand < nBandCount; ++iBand )\n                {\n                    GByte* pabySrcData =\n                        static_cast<GByte *>(ppData[iSrcY]) + iBand * nDTSize;\n                    GByte* pabyDstData =\n                        static_cast<GByte *>(pData) +\n                        iBand * nBandSpace + iY * nLineSpace;\n                    if( eDataType == GDT_Byte && eBufType == GDT_Byte )\n                    {\n                        double dfSrcX = 0.5 * dfSrcXInc;\n                        for( int iX = 0;\n                             iX < nBufXSize;\n                             ++iX, dfSrcX += dfSrcXInc)\n                        {\n                            int iSrcX = static_cast<int>(dfSrcX);\n                            pabyDstData[iX * nPixelSpace] =\n                                pabySrcData[iSrcX * nSrcPixelSize];\n                        }\n                    }\n                    else\n                    {\n                        double dfSrcX = 0.5 * dfSrcXInc;\n                        for( int iX = 0;\n                             iX < nBufXSize;\n                             ++iX, dfSrcX += dfSrcXInc)\n                        {\n                            int iSrcX = static_cast<int>(dfSrcX);\n                            GDALCopyWords( pabySrcData + iSrcX * nSrcPixelSize,\n                                        eDataType, 0,\n                                        pabyDstData + iX * nPixelSpace,\n                                        eBufType, 0, 1);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    CPLFree(pTmpBuffer);\n    CPLFree(ppData);\n    CPLFree(panOffsets);\n    CPLFree(panSizes);\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                         CacheMultiRange()                            */\n/************************************************************************/\n\nvoid* GTiffRasterBand::CacheMultiRange( int nXOff, int nYOff,\n                                        int nXSize, int nYSize,\n                                        int nBufXSize, int nBufYSize,\n                                        GDALRasterIOExtraArg* psExtraArg )\n{\n    void* pBufferedData = nullptr;\n    // Same logic as in GDALRasterBand::IRasterIO()\n    double dfXOff = nXOff;\n    double dfYOff = nYOff;\n    double dfXSize = nXSize;\n    double dfYSize = nYSize;\n    if( psExtraArg->bFloatingPointWindowValidity )\n    {\n        dfXOff = psExtraArg->dfXOff;\n        dfYOff = psExtraArg->dfYOff;\n        dfXSize = psExtraArg->dfXSize;\n        dfYSize = psExtraArg->dfYSize;\n    }\n    const double dfSrcXInc = dfXSize / static_cast<double>( nBufXSize );\n    const double dfSrcYInc = dfYSize / static_cast<double>( nBufYSize );\n    const double EPS = 1e-10;\n    const int nBlockX1 = static_cast<int>(std::max(0.0, (0+0.5) * dfSrcXInc + dfXOff + EPS)) / nBlockXSize;\n    const int nBlockY1 = static_cast<int>(std::max(0.0, (0+0.5) * dfSrcYInc + dfYOff + EPS)) / nBlockYSize;\n    const int nBlockX2 = static_cast<int>(std::min(static_cast<double>(nRasterXSize - 1), (nBufXSize-1+0.5) * dfSrcXInc + dfXOff + EPS)) / nBlockXSize;\n    const int nBlockY2 = static_cast<int>(std::min(static_cast<double>(nRasterYSize - 1), (nBufYSize-1+0.5) * dfSrcYInc + dfYOff + EPS)) / nBlockYSize;\n\n    thandle_t th = TIFFClientdata( poGDS->hTIFF );\n    if( poGDS->SetDirectory() && !VSI_TIFFHasCachedRanges(th) )\n    {\n        std::vector< std::pair<vsi_l_offset, size_t> > aOffsetSize;\n        size_t nTotalSize = 0;\n        nBlocksPerRow = DIV_ROUND_UP(nRasterXSize, nBlockXSize);\n        const unsigned int nMaxRawBlockCacheSize =\n            atoi(CPLGetConfigOption(\"GDAL_MAX_RAW_BLOCK_CACHE_SIZE\",\n                                    \"10485760\"));\n        for( int iY = nBlockY1; iY <= nBlockY2; iY ++)\n        {\n            for( int iX = nBlockX1; iX <= nBlockX2; iX ++)\n            {\n                GDALRasterBlock* poBlock = TryGetLockedBlockRef(iX, iY);\n                if( poBlock != nullptr )\n                {\n                    poBlock->DropLock();\n                    continue;\n                }\n                int nBlockId = iX + iY * nBlocksPerRow;\n                if( poGDS->nPlanarConfig == PLANARCONFIG_SEPARATE )\n                    nBlockId += (nBand - 1) * poGDS->nBlocksPerBand;\n                vsi_l_offset nOffset = 0;\n                vsi_l_offset nSize = 0;\n                if( poGDS->IsBlockAvailable(nBlockId, &nOffset, &nSize) )\n                {\n                    if( nTotalSize + nSize < nMaxRawBlockCacheSize )\n                    {\n#ifdef DEBUG_VERBOSE\n                        CPLDebug(\"GTiff\",\n                                 \"Precaching for block (%d, %d), \"\n                                 CPL_FRMT_GUIB \"-\" CPL_FRMT_GUIB,\n                                 iX, iY,\n                                 nOffset,\n                                 nOffset + static_cast<size_t>(nSize) - 1);\n#endif\n                        aOffsetSize.push_back(\n                            std::pair<vsi_l_offset, size_t>\n                                (nOffset, static_cast<size_t>(nSize)) );\n                        nTotalSize += static_cast<size_t>(nSize);\n                    }\n                }\n            }\n        }\n\n        std::sort(aOffsetSize.begin(), aOffsetSize.end());\n\n        if( nTotalSize > 0 )\n        {\n            pBufferedData = VSI_MALLOC_VERBOSE(nTotalSize);\n            if( pBufferedData )\n            {\n                std::vector<vsi_l_offset> anOffsets;\n                std::vector<size_t> anSizes;\n                std::vector<void*> apData;\n                size_t nAccOffset = 0;\n                for( size_t i = 0; i < aOffsetSize.size(); i++ )\n                {\n                    anOffsets.push_back(aOffsetSize[i].first);\n                    anSizes.push_back(aOffsetSize[i].second);\n                    apData.push_back(static_cast<GByte*>(pBufferedData) + nAccOffset);\n                    nAccOffset += aOffsetSize[i].second;\n                }\n                VSILFILE* fp = VSI_TIFFGetVSILFile(th);\n                if( VSIFReadMultiRangeL(\n                                    static_cast<int>(aOffsetSize.size()),\n                                    &apData[0],\n                                    &anOffsets[0],\n                                    &anSizes[0],\n                                    fp ) == 0 )\n                {\n                    VSI_TIFFSetCachedRanges( th,\n                                             static_cast<int>(aOffsetSize.size()),\n                                             &apData[0],\n                                             &anOffsets[0],\n                                             &anSizes[0] );\n                }\n            }\n        }\n    }\n    return pBufferedData;\n}\n\n/************************************************************************/\n/*                            IRasterIO()                               */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::IRasterIO( GDALRWFlag eRWFlag,\n                                   int nXOff, int nYOff, int nXSize, int nYSize,\n                                   void * pData, int nBufXSize, int nBufYSize,\n                                   GDALDataType eBufType,\n                                   GSpacing nPixelSpace, GSpacing nLineSpace,\n                                   GDALRasterIOExtraArg* psExtraArg )\n{\n#if DEBUG_VERBOSE\n    CPLDebug( \"GTiff\", \"RasterIO(%d, %d, %d, %d, %d, %d)\",\n              nXOff, nYOff, nXSize, nYSize, nBufXSize, nBufYSize );\n#endif\n\n    // Try to pass the request to the most appropriate overview dataset.\n    if( nBufXSize < nXSize && nBufYSize < nYSize )\n    {\n        int bTried = FALSE;\n        ++poGDS->nJPEGOverviewVisibilityCounter;\n        const CPLErr eErr =\n            TryOverviewRasterIO( eRWFlag,\n                                 nXOff, nYOff, nXSize, nYSize,\n                                 pData, nBufXSize, nBufYSize,\n                                 eBufType,\n                                 nPixelSpace, nLineSpace,\n                                 psExtraArg,\n                                 &bTried );\n        --poGDS->nJPEGOverviewVisibilityCounter;\n        if( bTried )\n            return eErr;\n    }\n\n    if( poGDS->eVirtualMemIOUsage != VIRTUAL_MEM_IO_NO )\n    {\n        const int nErr = poGDS->VirtualMemIO(\n            eRWFlag, nXOff, nYOff, nXSize, nYSize,\n            pData, nBufXSize, nBufYSize, eBufType,\n            1, &nBand, nPixelSpace, nLineSpace, 0, psExtraArg);\n        if( nErr >= 0 )\n            return static_cast<CPLErr>(nErr);\n    }\n    if( poGDS->bDirectIO )\n    {\n        int nErr = DirectIO(eRWFlag, nXOff, nYOff, nXSize, nYSize,\n                            pData, nBufXSize, nBufYSize, eBufType,\n                            nPixelSpace, nLineSpace, psExtraArg);\n        if( nErr >= 0 )\n            return static_cast<CPLErr>(nErr);\n    }\n\n    void* pBufferedData = nullptr;\n    if( poGDS->eAccess == GA_ReadOnly &&\n        eRWFlag == GF_Read &&\n        poGDS->HasOptimizedReadMultiRange() )\n    {\n        pBufferedData = CacheMultiRange(nXOff, nYOff, nXSize, nYSize,\n                                        nBufXSize, nBufYSize,\n                                        psExtraArg);\n    }\n\n    if( poGDS->nBands != 1 &&\n        poGDS->nPlanarConfig == PLANARCONFIG_CONTIG &&\n        eRWFlag == GF_Read &&\n        nXSize == nBufXSize && nYSize == nBufYSize )\n    {\n        const int nBlockX1 = nXOff / nBlockXSize;\n        const int nBlockY1 = nYOff / nBlockYSize;\n        const int nBlockX2 = (nXOff + nXSize - 1) / nBlockXSize;\n        const int nBlockY2 = (nYOff + nYSize - 1) / nBlockYSize;\n        const int nXBlocks = nBlockX2 - nBlockX1 + 1;\n        const int nYBlocks = nBlockY2 - nBlockY1 + 1;\n        const GIntBig nRequiredMem =\n            static_cast<GIntBig>(poGDS->nBands) * nXBlocks * nYBlocks *\n            nBlockXSize * nBlockYSize *\n            GDALGetDataTypeSizeBytes(eDataType);\n        if( nRequiredMem > GDALGetCacheMax64() )\n        {\n            if( !poGDS->bHasWarnedDisableAggressiveBandCaching )\n            {\n                CPLDebug( \"GTiff\",\n                          \"Disable aggressive band caching. \"\n                          \"Cache not big enough. \"\n                          \"At least \" CPL_FRMT_GIB \" bytes necessary\",\n                          nRequiredMem );\n                poGDS->bHasWarnedDisableAggressiveBandCaching = true;\n            }\n            poGDS->bLoadingOtherBands = true;\n        }\n    }\n\n    ++poGDS->nJPEGOverviewVisibilityCounter;\n    const CPLErr eErr =\n        GDALPamRasterBand::IRasterIO( eRWFlag, nXOff, nYOff, nXSize, nYSize,\n                                      pData, nBufXSize, nBufYSize, eBufType,\n                                      nPixelSpace, nLineSpace, psExtraArg );\n    --poGDS->nJPEGOverviewVisibilityCounter;\n\n    poGDS->bLoadingOtherBands = false;\n\n    if( pBufferedData )\n    {\n        VSIFree( pBufferedData );\n        VSI_TIFFSetCachedRanges( TIFFClientdata( poGDS->hTIFF ),\n                                 0, nullptr, nullptr, nullptr );\n    }\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                       IGetDataCoverageStatus()                       */\n/************************************************************************/\n\nint GTiffRasterBand::IGetDataCoverageStatus( int nXOff, int nYOff,\n                                             int nXSize, int nYSize,\n                                             int nMaskFlagStop,\n                                             double* pdfDataPct)\n{\n    if( eAccess == GA_Update )\n        poGDS->FlushCache();\n\n    if( !poGDS->SetDirectory() )\n    {\n        return GDAL_DATA_COVERAGE_STATUS_UNIMPLEMENTED |\n               GDAL_DATA_COVERAGE_STATUS_DATA;\n    }\n\n    const int iXBlockStart = nXOff / nBlockXSize;\n    const int iXBlockEnd = (nXOff + nXSize - 1) / nBlockXSize;\n    const int iYBlockStart = nYOff / nBlockYSize;\n    const int iYBlockEnd = (nYOff + nYSize - 1) / nBlockYSize;\n    int nStatus = 0;\n    VSILFILE* fp = VSI_TIFFGetVSILFile(TIFFClientdata( poGDS->hTIFF ));\n    GIntBig nPixelsData = 0;\n    // We need to compute this here as it might not have been computed\n    // previously (which sucks...)\n    nBlocksPerRow = DIV_ROUND_UP(nRasterXSize, nBlockXSize);\n    for( int iY = iYBlockStart; iY <= iYBlockEnd; ++iY )\n    {\n        for( int iX = iXBlockStart; iX <= iXBlockEnd; ++iX )\n        {\n            const int nBlockIdBand0 =\n                iX + iY * nBlocksPerRow;\n            int nBlockId = nBlockIdBand0;\n            if( poGDS->nPlanarConfig == PLANARCONFIG_SEPARATE )\n                nBlockId = nBlockIdBand0 + (nBand - 1) * poGDS->nBlocksPerBand;\n            vsi_l_offset nOffset = 0;\n            vsi_l_offset nLength = 0;\n            bool bHasData = false;\n            if( !poGDS->IsBlockAvailable(nBlockId,&nOffset,&nLength) )\n            {\n                nStatus |= GDAL_DATA_COVERAGE_STATUS_EMPTY;\n            }\n            else\n            {\n                if( poGDS->nCompression == COMPRESSION_NONE &&\n                    poGDS->eAccess == GA_ReadOnly &&\n                    (!bNoDataSet || dfNoDataValue == 0.0) )\n                {\n                    VSIRangeStatus eStatus =\n                          VSIFGetRangeStatusL( fp, nOffset, nLength );\n                    if( eStatus == VSI_RANGE_STATUS_HOLE )\n                    {\n                        nStatus |= GDAL_DATA_COVERAGE_STATUS_EMPTY;\n                    }\n                    else\n                    {\n                        bHasData = true;\n                    }\n                }\n                else\n                {\n                    bHasData = true;\n                }\n            }\n            if( bHasData )\n            {\n                const int nXBlockRight =\n                    ( iX * nBlockXSize > INT_MAX - nBlockXSize ) ? INT_MAX :\n                    (iX + 1) * nBlockXSize;\n                const int nYBlockBottom =\n                    ( iY * nBlockYSize > INT_MAX - nBlockYSize ) ? INT_MAX :\n                    (iY + 1) * nBlockYSize;\n\n                nPixelsData +=\n                    (std::min( nXBlockRight, nXOff + nXSize ) -\n                     std::max( iX * nBlockXSize, nXOff )) *\n                    (std::min( nYBlockBottom, nYOff + nYSize ) -\n                     std::max( iY * nBlockYSize, nYOff ));\n                nStatus |= GDAL_DATA_COVERAGE_STATUS_DATA;\n            }\n            if( nMaskFlagStop != 0 && (nMaskFlagStop & nStatus) != 0 )\n            {\n                if( pdfDataPct )\n                    *pdfDataPct = -1.0;\n                return nStatus;\n            }\n        }\n    }\n    if( pdfDataPct )\n        *pdfDataPct =\n          100.0 * nPixelsData /\n          (static_cast<GIntBig>(nXSize) * nYSize);\n    return nStatus;\n}\n\n/************************************************************************/\n/*                             IReadBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::IReadBlock( int nBlockXOff, int nBlockYOff,\n                                    void * pImage )\n\n{\n    if( !poGDS->SetDirectory() )\n        return CE_Failure;\n\n    int nBlockBufSize = 0;\n    if( TIFFIsTiled(poGDS->hTIFF) )\n    {\n        nBlockBufSize = static_cast<int>(TIFFTileSize( poGDS->hTIFF ));\n    }\n    else\n    {\n        CPLAssert( nBlockXOff == 0 );\n        nBlockBufSize = static_cast<int>(TIFFStripSize( poGDS->hTIFF ));\n    }\n\n    CPLAssert(nBlocksPerRow != 0);\n    const int nBlockIdBand0 =\n        nBlockXOff + nBlockYOff * nBlocksPerRow;\n    int nBlockId = nBlockIdBand0;\n    if( poGDS->nPlanarConfig == PLANARCONFIG_SEPARATE )\n        nBlockId = nBlockIdBand0 + (nBand - 1) * poGDS->nBlocksPerBand;\n\n/* -------------------------------------------------------------------- */\n/*      The bottom most partial tiles and strips are sometimes only     */\n/*      partially encoded.  This code reduces the requested data so     */\n/*      an error won't be reported in this case. (#1179)                */\n/* -------------------------------------------------------------------- */\n    int nBlockReqSize = nBlockBufSize;\n\n    if( nBlockYOff * nBlockYSize > nRasterYSize - nBlockYSize )\n    {\n        nBlockReqSize = (nBlockBufSize / nBlockYSize)\n            * (nBlockYSize - static_cast<int>(\n                (static_cast<GIntBig>(nBlockYOff + 1) * nBlockYSize)\n                    % nRasterYSize));\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Handle the case of a strip or tile that doesn't exist yet.      */\n/*      Just set to zeros and return.                                   */\n/* -------------------------------------------------------------------- */\n    vsi_l_offset nOffset = 0;\n    bool bErrOccurred = false;\n    if( nBlockId != poGDS->nLoadedBlock &&\n        !poGDS->IsBlockAvailable(nBlockId, &nOffset, nullptr, &bErrOccurred) )\n    {\n        NullBlock( pImage );\n        if( bErrOccurred )\n            return CE_Failure;\n        return CE_None;\n    }\n\n    if( poGDS->bStreamingIn &&\n        !(poGDS->nBands > 1 &&\n          poGDS->nPlanarConfig == PLANARCONFIG_CONTIG &&\n          nBlockId == poGDS->nLoadedBlock) )\n    {\n        if( nOffset < VSIFTellL(poGDS->fpL) )\n        {\n            CPLError( CE_Failure, CPLE_NotSupported,\n                      \"Trying to load block %d at offset \" CPL_FRMT_GUIB\n                      \" whereas current pos is \" CPL_FRMT_GUIB\n                      \" (backward read not supported)\",\n                      nBlockId, static_cast<GUIntBig>(nOffset),\n                      static_cast<GUIntBig>(VSIFTellL(poGDS->fpL)) );\n            return CE_Failure;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Handle simple case (separate, onesampleperpixel)                */\n/* -------------------------------------------------------------------- */\n    if( poGDS->nBands == 1\n        || poGDS->nPlanarConfig == PLANARCONFIG_SEPARATE )\n    {\n        if( nBlockReqSize < nBlockBufSize )\n            memset( pImage, 0, nBlockBufSize );\n\n        CPLErr eErr = CE_None;\n        if( TIFFIsTiled( poGDS->hTIFF ) )\n        {\n            if( TIFFReadEncodedTile( poGDS->hTIFF, nBlockId, pImage,\n                                     nBlockReqSize ) == -1\n                && !poGDS->bIgnoreReadErrors )\n            {\n                memset( pImage, 0, nBlockBufSize );\n                CPLError( CE_Failure, CPLE_AppDefined,\n                          \"TIFFReadEncodedTile() failed.\" );\n\n                eErr = CE_Failure;\n            }\n        }\n        else\n        {\n            if( TIFFReadEncodedStrip( poGDS->hTIFF, nBlockId, pImage,\n                                      nBlockReqSize ) == -1\n                && !poGDS->bIgnoreReadErrors )\n            {\n                memset( pImage, 0, nBlockBufSize );\n                CPLError( CE_Failure, CPLE_AppDefined,\n                        \"TIFFReadEncodedStrip() failed.\" );\n\n                eErr = CE_Failure;\n            }\n        }\n\n        return eErr;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Load desired block                                              */\n/* -------------------------------------------------------------------- */\n    {\n        const CPLErr eErr = poGDS->LoadBlockBuf( nBlockId );\n        if( eErr != CE_None )\n        {\n            memset( pImage, 0,\n                    nBlockXSize * nBlockYSize\n                    * GDALGetDataTypeSizeBytes(eDataType) );\n            return eErr;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Special case for YCbCr subsampled data.                         */\n/* -------------------------------------------------------------------- */\n\n    // Removed \"Special case for YCbCr\" added in r9432; disabled in r9470\n\n    const int nWordBytes = poGDS->nBitsPerSample / 8;\n    GByte* pabyImage = poGDS->pabyBlockBuf + (nBand - 1) * nWordBytes;\n\n    GDALCopyWords(pabyImage, eDataType, poGDS->nBands * nWordBytes,\n                  pImage, eDataType, nWordBytes,\n                  nBlockXSize * nBlockYSize);\n\n    const CPLErr eErr = FillCacheForOtherBands(nBlockXOff, nBlockYOff);\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                       FillCacheForOtherBands()                       */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::FillCacheForOtherBands( int nBlockXOff, int nBlockYOff )\n\n{\n/* -------------------------------------------------------------------- */\n/*      In the fairly common case of pixel interleaved 8bit data        */\n/*      that is multi-band, lets push the rest of the data into the     */\n/*      block cache too, to avoid (hopefully) having to redecode it.    */\n/*                                                                      */\n/*      Our following logic actually depends on the fact that the       */\n/*      this block is already loaded, so subsequent calls will end      */\n/*      up back in this method and pull from the loaded block.          */\n/*                                                                      */\n/*      Be careful not entering this portion of code from               */\n/*      the other bands, otherwise we'll get very deep nested calls     */\n/*      and O(nBands^2) performance !                                   */\n/*                                                                      */\n/*      If there are many bands and the block cache size is not big     */\n/*      enough to accommodate the size of all the blocks, don't enter   */\n/* -------------------------------------------------------------------- */\n    CPLErr eErr = CE_None;\n    if( poGDS->nBands != 1 &&\n        poGDS->nBands < 128 && // avoid caching for datasets with too many bands\n        !poGDS->bLoadingOtherBands &&\n        nBlockXSize * nBlockYSize * GDALGetDataTypeSizeBytes(eDataType) <\n        GDALGetCacheMax64() / poGDS->nBands )\n    {\n        poGDS->bLoadingOtherBands = true;\n\n        for( int iOtherBand = 1; iOtherBand <= poGDS->nBands; ++iOtherBand )\n        {\n            if( iOtherBand == nBand )\n                continue;\n\n            GDALRasterBlock *poBlock = poGDS->GetRasterBand(iOtherBand)->\n                GetLockedBlockRef(nBlockXOff,nBlockYOff);\n            if( poBlock == nullptr )\n            {\n                eErr = CE_Failure;\n                break;\n            }\n            poBlock->DropLock();\n        }\n\n        poGDS->bLoadingOtherBands = false;\n    }\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                            IWriteBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::IWriteBlock( int nBlockXOff, int nBlockYOff,\n                                     void * pImage )\n\n{\n    if( poGDS->bDebugDontWriteBlocks )\n        return CE_None;\n\n    if( poGDS->bWriteErrorInFlushBlockBuf )\n    {\n        // Report as an error if a previously loaded block couldn't be written\n        // correctly.\n        poGDS->bWriteErrorInFlushBlockBuf = false;\n        return CE_Failure;\n    }\n\n    if( !poGDS->SetDirectory() )\n        return CE_Failure;\n\n    CPLAssert( poGDS != nullptr\n               && nBlockXOff >= 0\n               && nBlockYOff >= 0\n               && pImage != nullptr );\n    CPLAssert(nBlocksPerRow != 0);\n\n/* -------------------------------------------------------------------- */\n/*      Handle case of \"separate\" images                                */\n/* -------------------------------------------------------------------- */\n    if( poGDS->nPlanarConfig == PLANARCONFIG_SEPARATE\n        || poGDS->nBands == 1 )\n    {\n        const int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow\n            + (nBand - 1) * poGDS->nBlocksPerBand;\n\n        const CPLErr eErr =\n            poGDS->WriteEncodedTileOrStrip(nBlockId, pImage, true);\n\n        return eErr;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Handle case of pixel interleaved (PLANARCONFIG_CONTIG) images.  */\n/* -------------------------------------------------------------------- */\n    const int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n     // Why 10 ? Somewhat arbitrary\n    constexpr int MAX_BANDS_FOR_DIRTY_CHECK = 10;\n    GDALRasterBlock* apoBlocks[MAX_BANDS_FOR_DIRTY_CHECK] = {};\n    const int nBands = poGDS->nBands;\n    bool bAllBlocksDirty = false;\n\n/* -------------------------------------------------------------------- */\n/*     If all blocks are cached and dirty then we do not need to reload */\n/*     the tile/strip from disk                                         */\n/* -------------------------------------------------------------------- */\n    if( nBands <= MAX_BANDS_FOR_DIRTY_CHECK )\n    {\n        bAllBlocksDirty = true;\n        for( int iBand = 0; iBand < nBands; ++iBand )\n        {\n            if( iBand + 1 != nBand )\n            {\n                apoBlocks[iBand] =\n                    cpl::down_cast<GTiffRasterBand *>(\n                        poGDS->GetRasterBand( iBand + 1 ))\n                            ->TryGetLockedBlockRef( nBlockXOff, nBlockYOff );\n\n                if( apoBlocks[iBand] == nullptr )\n                {\n                    bAllBlocksDirty = false;\n                }\n                else if( !apoBlocks[iBand]->GetDirty() )\n                {\n                    apoBlocks[iBand]->DropLock();\n                    apoBlocks[iBand] = nullptr;\n                    bAllBlocksDirty = false;\n                }\n            }\n            else\n                apoBlocks[iBand] = nullptr;\n        }\n#if DEBUG_VERBOSE\n        if( bAllBlocksDirty )\n            CPLDebug(\"GTIFF\", \"Saved reloading block %d\", nBlockId);\n        else\n            CPLDebug(\"GTIFF\", \"Must reload block %d\", nBlockId);\n#endif\n    }\n\n    {\n        const CPLErr eErr = poGDS->LoadBlockBuf( nBlockId, !bAllBlocksDirty );\n        if( eErr != CE_None )\n        {\n            if( nBands <= MAX_BANDS_FOR_DIRTY_CHECK )\n            {\n                for( int iBand = 0; iBand < nBands; ++iBand )\n                {\n                    if( apoBlocks[iBand] != nullptr )\n                        apoBlocks[iBand]->DropLock();\n                }\n            }\n            return eErr;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      On write of pixel interleaved data, we might as well flush      */\n/*      out any other bands that are dirty in our cache.  This is       */\n/*      especially helpful when writing compressed blocks.              */\n/* -------------------------------------------------------------------- */\n    const int nWordBytes = poGDS->nBitsPerSample / 8;\n\n    for( int iBand = 0; iBand < nBands; ++iBand )\n    {\n        const GByte *pabyThisImage = nullptr;\n        GDALRasterBlock *poBlock = nullptr;\n\n        if( iBand + 1 == nBand )\n        {\n            pabyThisImage = static_cast<GByte *>( pImage );\n        }\n        else\n        {\n            if( nBands <= MAX_BANDS_FOR_DIRTY_CHECK )\n                poBlock = apoBlocks[iBand];\n            else\n                poBlock = cpl::down_cast<GTiffRasterBand *>(\n                    poGDS->GetRasterBand( iBand + 1 ))\n                        ->TryGetLockedBlockRef( nBlockXOff, nBlockYOff );\n\n            if( poBlock == nullptr )\n                continue;\n\n            if( !poBlock->GetDirty() )\n            {\n                poBlock->DropLock();\n                continue;\n            }\n\n            pabyThisImage = static_cast<GByte *>( poBlock->GetDataRef() );\n        }\n\n        GByte *pabyOut = poGDS->pabyBlockBuf + iBand*nWordBytes;\n\n        GDALCopyWords(pabyThisImage, eDataType, nWordBytes,\n                      pabyOut, eDataType, nWordBytes * nBands,\n                      nBlockXSize * nBlockYSize);\n\n        if( poBlock != nullptr )\n        {\n            poBlock->MarkClean();\n            poBlock->DropLock();\n        }\n    }\n\n    if( bAllBlocksDirty )\n    {\n        // We can synchronously write the block now.\n        const CPLErr eErr =\n            poGDS->WriteEncodedTileOrStrip(nBlockId, poGDS->pabyBlockBuf, true);\n        poGDS->bLoadedBlockDirty = false;\n        return eErr;\n    }\n\n    poGDS->bLoadedBlockDirty = true;\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                           SetDescription()                           */\n/************************************************************************/\n\nvoid GTiffRasterBand::SetDescription( const char *pszDescription )\n\n{\n    poGDS->LoadGeoreferencingAndPamIfNeeded();\n\n    if( pszDescription == nullptr )\n        pszDescription = \"\";\n\n    if( osDescription != pszDescription )\n        poGDS->bMetadataChanged = true;\n\n    osDescription = pszDescription;\n}\n\n/************************************************************************/\n/*                           GetDescription()                           */\n/************************************************************************/\n\nconst char *GTiffRasterBand::GetDescription() const\n{\n    poGDS->LoadGeoreferencingAndPamIfNeeded();\n\n    return osDescription;\n}\n\n/************************************************************************/\n/*                             GetOffset()                              */\n/************************************************************************/\n\ndouble GTiffRasterBand::GetOffset( int *pbSuccess )\n\n{\n    poGDS->LoadGeoreferencingAndPamIfNeeded();\n\n    if( pbSuccess )\n        *pbSuccess = bHaveOffsetScale;\n    return dfOffset;\n}\n\n/************************************************************************/\n/*                             SetOffset()                              */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::SetOffset( double dfNewValue )\n\n{\n    poGDS->LoadGeoreferencingAndPamIfNeeded();\n\n    if( !bHaveOffsetScale || dfNewValue != dfOffset )\n        poGDS->bMetadataChanged = true;\n\n    bHaveOffsetScale = true;\n    dfOffset = dfNewValue;\n    return CE_None;\n}\n\n/************************************************************************/\n/*                              GetScale()                              */\n/************************************************************************/\n\ndouble GTiffRasterBand::GetScale( int *pbSuccess )\n\n{\n    poGDS->LoadGeoreferencingAndPamIfNeeded();\n\n    if( pbSuccess )\n        *pbSuccess = bHaveOffsetScale;\n    return dfScale;\n}\n\n/************************************************************************/\n/*                              SetScale()                              */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::SetScale( double dfNewValue )\n\n{\n    poGDS->LoadGeoreferencingAndPamIfNeeded();\n\n    if( !bHaveOffsetScale || dfNewValue != dfScale )\n        poGDS->bMetadataChanged = true;\n\n    bHaveOffsetScale = true;\n    dfScale = dfNewValue;\n    return CE_None;\n}\n\n/************************************************************************/\n/*                            GetUnitType()                             */\n/************************************************************************/\n\nconst char* GTiffRasterBand::GetUnitType()\n\n{\n    poGDS->LoadGeoreferencingAndPamIfNeeded();\n    if( osUnitType.empty() )\n    {\n        poGDS->LookForProjection();\n        return poGDS->m_osVertUnit.c_str();\n    }\n\n    return osUnitType.c_str();\n}\n\n/************************************************************************/\n/*                           SetUnitType()                              */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::SetUnitType( const char* pszNewValue )\n\n{\n    poGDS->LoadGeoreferencingAndPamIfNeeded();\n\n    CPLString osNewValue(pszNewValue ? pszNewValue : \"\");\n    if( osNewValue.compare(osUnitType) != 0 )\n        poGDS->bMetadataChanged = true;\n\n    osUnitType = osNewValue;\n    return CE_None;\n}\n\n/************************************************************************/\n/*                      GetMetadataDomainList()                         */\n/************************************************************************/\n\nchar **GTiffRasterBand::GetMetadataDomainList()\n{\n    poGDS->LoadGeoreferencingAndPamIfNeeded();\n\n    return CSLDuplicate(oGTiffMDMD.GetDomainList());\n}\n\n/************************************************************************/\n/*                            GetMetadata()                             */\n/************************************************************************/\n\nchar **GTiffRasterBand::GetMetadata( const char * pszDomain )\n\n{\n    if( pszDomain == nullptr || !EQUAL(pszDomain, \"IMAGE_STRUCTURE\") )\n    {\n        poGDS->LoadGeoreferencingAndPamIfNeeded();\n    }\n\n    return oGTiffMDMD.GetMetadata( pszDomain );\n}\n\n/************************************************************************/\n/*                            SetMetadata()                             */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::SetMetadata( char ** papszMD, const char *pszDomain )\n\n{\n    poGDS->LoadGeoreferencingAndPamIfNeeded();\n\n    if( poGDS->bStreamingOut && poGDS->bCrystalized )\n    {\n        CPLError( CE_Failure, CPLE_NotSupported,\n                  \"Cannot modify metadata at that point in a streamed \"\n                  \"output file\" );\n        return CE_Failure;\n    }\n\n    if( pszDomain == nullptr || !EQUAL(pszDomain,\"_temporary_\") )\n    {\n        if( papszMD != nullptr || GetMetadata(pszDomain) != nullptr )\n        {\n            poGDS->bMetadataChanged = true;\n            // Cancel any existing metadata from PAM file.\n            if( eAccess == GA_Update &&\n                GDALPamRasterBand::GetMetadata(pszDomain) != nullptr )\n                GDALPamRasterBand::SetMetadata(nullptr, pszDomain);\n        }\n    }\n\n    return oGTiffMDMD.SetMetadata( papszMD, pszDomain );\n}\n\n/************************************************************************/\n/*                          GetMetadataItem()                           */\n/************************************************************************/\n\nconst char *GTiffRasterBand::GetMetadataItem( const char * pszName,\n                                              const char * pszDomain )\n\n{\n    if( pszDomain == nullptr || !EQUAL(pszDomain, \"IMAGE_STRUCTURE\") )\n    {\n        poGDS->LoadGeoreferencingAndPamIfNeeded();\n    }\n\n    if( pszName != nullptr && pszDomain != nullptr && EQUAL(pszDomain, \"TIFF\") )\n    {\n        int nBlockXOff = 0;\n        int nBlockYOff = 0;\n\n        if( EQUAL(pszName, \"JPEGTABLES\") )\n        {\n            if( !poGDS->SetDirectory() )\n                return nullptr;\n\n            uint32 nJPEGTableSize = 0;\n            void* pJPEGTable = nullptr;\n            if( TIFFGetField( poGDS->hTIFF, TIFFTAG_JPEGTABLES,\n                              &nJPEGTableSize, &pJPEGTable ) != 1 ||\n                pJPEGTable == nullptr || nJPEGTableSize > INT_MAX )\n            {\n                return nullptr;\n            }\n            char* const pszHex =\n                CPLBinaryToHex( nJPEGTableSize, static_cast<const GByte*>(pJPEGTable) );\n            const char* pszReturn = CPLSPrintf(\"%s\", pszHex);\n            CPLFree(pszHex);\n\n            return pszReturn;\n        }\n\n        if( EQUAL(pszName, \"IFD_OFFSET\") )\n        {\n            if( !poGDS->SetDirectory() )\n                return nullptr;\n\n            return CPLSPrintf( CPL_FRMT_GUIB,\n                               static_cast<GUIntBig>(poGDS->nDirOffset) );\n        }\n\n        if( sscanf( pszName, \"BLOCK_OFFSET_%d_%d\",\n                         &nBlockXOff, &nBlockYOff ) == 2 )\n        {\n            if( !poGDS->SetDirectory() )\n                return nullptr;\n\n            nBlocksPerRow =\n                DIV_ROUND_UP(poGDS->nRasterXSize, poGDS->nBlockXSize);\n            nBlocksPerColumn =\n                DIV_ROUND_UP(poGDS->nRasterYSize, poGDS->nBlockYSize);\n            if( nBlockXOff < 0 || nBlockXOff >= nBlocksPerRow ||\n                nBlockYOff < 0 || nBlockYOff >= nBlocksPerColumn )\n                return nullptr;\n\n            int nBlockId = nBlockYOff * nBlocksPerRow + nBlockXOff;\n            if( poGDS->nPlanarConfig == PLANARCONFIG_SEPARATE )\n            {\n                nBlockId += (nBand - 1) * poGDS->nBlocksPerBand;\n            }\n\n            vsi_l_offset nOffset = 0;\n            if( !poGDS->IsBlockAvailable(nBlockId, &nOffset) )\n            {\n                return nullptr;\n            }\n\n            return CPLSPrintf( CPL_FRMT_GUIB, static_cast<GUIntBig>(nOffset) );\n        }\n\n        if( sscanf( pszName, \"BLOCK_SIZE_%d_%d\",\n                    &nBlockXOff, &nBlockYOff ) == 2 )\n        {\n            if( !poGDS->SetDirectory() )\n                return nullptr;\n\n            nBlocksPerRow =\n                DIV_ROUND_UP(poGDS->nRasterXSize, poGDS->nBlockXSize);\n            nBlocksPerColumn =\n                DIV_ROUND_UP(poGDS->nRasterYSize, poGDS->nBlockYSize);\n            if( nBlockXOff < 0 || nBlockXOff >= nBlocksPerRow ||\n                nBlockYOff < 0 || nBlockYOff >= nBlocksPerColumn )\n                return nullptr;\n\n            int nBlockId = nBlockYOff * nBlocksPerRow + nBlockXOff;\n            if( poGDS->nPlanarConfig == PLANARCONFIG_SEPARATE )\n            {\n                nBlockId += (nBand - 1) * poGDS->nBlocksPerBand;\n            }\n\n            vsi_l_offset nByteCount = 0;\n            if( !poGDS->IsBlockAvailable(nBlockId, nullptr, &nByteCount) )\n            {\n                return nullptr;\n            }\n\n            return CPLSPrintf(CPL_FRMT_GUIB, static_cast<GUIntBig>(nByteCount));\n        }\n    }\n    return oGTiffMDMD.GetMetadataItem( pszName, pszDomain );\n}\n\n/************************************************************************/\n/*                          SetMetadataItem()                           */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::SetMetadataItem( const char *pszName,\n                                         const char *pszValue,\n                                         const char *pszDomain )\n\n{\n    poGDS->LoadGeoreferencingAndPamIfNeeded();\n\n    if( poGDS->bStreamingOut && poGDS->bCrystalized )\n    {\n        CPLError( CE_Failure, CPLE_NotSupported,\n                  \"Cannot modify metadata at that point in a streamed \"\n                  \"output file\" );\n        return CE_Failure;\n    }\n\n    if( pszDomain == nullptr || !EQUAL(pszDomain,\"_temporary_\") )\n    {\n        poGDS->bMetadataChanged = true;\n        // Cancel any existing metadata from PAM file.\n        if( eAccess == GA_Update &&\n            GDALPamRasterBand::GetMetadataItem(pszName, pszDomain) != nullptr )\n            GDALPamRasterBand::SetMetadataItem(pszName, nullptr, pszDomain);\n    }\n\n    return oGTiffMDMD.SetMetadataItem( pszName, pszValue, pszDomain );\n}\n\n/************************************************************************/\n/*                       GetColorInterpretation()                       */\n/************************************************************************/\n\nGDALColorInterp GTiffRasterBand::GetColorInterpretation()\n\n{\n    poGDS->LoadGeoreferencingAndPamIfNeeded();\n\n    return eBandInterp;\n}\n\n/************************************************************************/\n/*                         GTiffGetAlphaValue()                         */\n/************************************************************************/\n\nuint16 GTiffGetAlphaValue(const char* pszValue, uint16 nDefault)\n{\n    if( pszValue == nullptr )\n        return nDefault;\n    if( EQUAL(pszValue, \"YES\") )\n        return DEFAULT_ALPHA_TYPE;\n    if( EQUAL(pszValue, \"PREMULTIPLIED\") )\n        return EXTRASAMPLE_ASSOCALPHA;\n    if( EQUAL(pszValue, \"NON-PREMULTIPLIED\") )\n        return EXTRASAMPLE_UNASSALPHA;\n    if( EQUAL(pszValue, \"NO\") ||\n        EQUAL(pszValue, \"UNSPECIFIED\") )\n        return EXTRASAMPLE_UNSPECIFIED;\n\n    return nDefault;\n}\n\n/************************************************************************/\n/*                       SetColorInterpretation()                       */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::SetColorInterpretation( GDALColorInterp eInterp )\n\n{\n    poGDS->LoadGeoreferencingAndPamIfNeeded();\n\n    if( eInterp == eBandInterp )\n        return CE_None;\n\n    eBandInterp = eInterp;\n\n    if( eAccess != GA_Update )\n    {\n        CPLDebug( \"GTIFF\", \"ColorInterpretation %s for band %d goes to PAM \"\n                  \"instead of TIFF tag\",\n                  GDALGetColorInterpretationName(eInterp), nBand );\n        return GDALPamRasterBand::SetColorInterpretation( eInterp );\n    }\n\n    if( poGDS->bCrystalized )\n    {\n        if( !poGDS->SetDirectory() )\n            return CE_Failure;\n    }\n\n    poGDS->bNeedsRewrite = true;\n    poGDS->bMetadataChanged = true;\n\n    // Try to autoset TIFFTAG_PHOTOMETRIC = PHOTOMETRIC_RGB if possible.\n    if( poGDS->nBands >= 3 &&\n        poGDS->nCompression != COMPRESSION_JPEG &&\n        poGDS->nPhotometric != PHOTOMETRIC_RGB &&\n        CSLFetchNameValue( poGDS->papszCreationOptions,\n                           \"PHOTOMETRIC\" ) == nullptr &&\n        ((nBand == 1 && eInterp == GCI_RedBand) ||\n         (nBand == 2 && eInterp == GCI_GreenBand) ||\n         (nBand == 3 && eInterp == GCI_BlueBand)) )\n    {\n        if( poGDS->GetRasterBand(1)->GetColorInterpretation() == GCI_RedBand &&\n            poGDS->GetRasterBand(2)->GetColorInterpretation() == GCI_GreenBand &&\n            poGDS->GetRasterBand(3)->GetColorInterpretation() == GCI_BlueBand )\n        {\n            poGDS->nPhotometric = PHOTOMETRIC_RGB;\n            TIFFSetField( poGDS->hTIFF, TIFFTAG_PHOTOMETRIC,\n                          poGDS->nPhotometric );\n\n            // We need to update the number of extra samples.\n            uint16 *v = nullptr;\n            uint16 count = 0;\n            const uint16 nNewExtraSamplesCount =\n                static_cast<uint16>(poGDS->nBands - 3);\n            if( poGDS->nBands >= 4 &&\n                TIFFGetField( poGDS->hTIFF, TIFFTAG_EXTRASAMPLES,\n                              &count, &v ) &&\n                count > nNewExtraSamplesCount )\n            {\n                uint16 * const pasNewExtraSamples =\n                    static_cast<uint16 *>( CPLMalloc(\n                        nNewExtraSamplesCount * sizeof(uint16) ) );\n                memcpy( pasNewExtraSamples, v + count - nNewExtraSamplesCount,\n                        nNewExtraSamplesCount * sizeof(uint16) );\n\n                TIFFSetField( poGDS->hTIFF, TIFFTAG_EXTRASAMPLES,\n                              nNewExtraSamplesCount, pasNewExtraSamples );\n\n                CPLFree(pasNewExtraSamples);\n            }\n        }\n        return CE_None;\n    }\n\n    // On the contrary, cancel the above if needed\n    if( poGDS->nCompression != COMPRESSION_JPEG &&\n        poGDS->nPhotometric == PHOTOMETRIC_RGB &&\n        CSLFetchNameValue( poGDS->papszCreationOptions,\n                           \"PHOTOMETRIC\") == nullptr &&\n        ((nBand == 1 && eInterp != GCI_RedBand) ||\n         (nBand == 2 && eInterp != GCI_GreenBand) ||\n         (nBand == 3 && eInterp != GCI_BlueBand)) )\n    {\n        poGDS->nPhotometric = PHOTOMETRIC_MINISBLACK;\n        TIFFSetField(poGDS->hTIFF, TIFFTAG_PHOTOMETRIC, poGDS->nPhotometric);\n\n        // We need to update the number of extra samples.\n        uint16 *v = nullptr;\n        uint16 count = 0;\n        const uint16 nNewExtraSamplesCount =\n            static_cast<uint16>(poGDS->nBands - 1);\n        if( poGDS->nBands >= 2 )\n        {\n            TIFFGetField( poGDS->hTIFF, TIFFTAG_EXTRASAMPLES, &count, &v );\n            if( nNewExtraSamplesCount > count )\n            {\n                uint16 * const pasNewExtraSamples =\n                    static_cast<uint16 *>( CPLMalloc(\n                        nNewExtraSamplesCount * sizeof(uint16) ) );\n                for( int i = 0;\n                     i < static_cast<int>(nNewExtraSamplesCount - count);\n                     ++i )\n                    pasNewExtraSamples[i] = EXTRASAMPLE_UNSPECIFIED;\n                if( count > 0 )\n                {\n                    memcpy( pasNewExtraSamples + nNewExtraSamplesCount - count,\n                            v,\n                            count * sizeof(uint16) );\n                }\n\n                TIFFSetField( poGDS->hTIFF, TIFFTAG_EXTRASAMPLES,\n                              nNewExtraSamplesCount, pasNewExtraSamples );\n\n                CPLFree(pasNewExtraSamples);\n            }\n        }\n    }\n\n    // Mark alpha band / undefined in extrasamples.\n    if( eInterp == GCI_AlphaBand || eInterp == GCI_Undefined )\n    {\n        uint16 *v = nullptr;\n        uint16 count = 0;\n        if( TIFFGetField( poGDS->hTIFF, TIFFTAG_EXTRASAMPLES, &count, &v ) )\n        {\n            const int nBaseSamples = poGDS->nSamplesPerPixel - count;\n\n            if( eInterp == GCI_AlphaBand )\n            {\n                for( int i = 1; i <= poGDS->nBands; ++i )\n                {\n                    if( i != nBand &&\n                        poGDS->GetRasterBand(i)->GetColorInterpretation() ==\n                        GCI_AlphaBand )\n                    {\n                        if( i == nBaseSamples + 1 &&\n                            CSLFetchNameValue( poGDS->papszCreationOptions,\n                                            \"ALPHA\" ) != nullptr )\n                        {\n                            CPLError(\n                                CE_Warning, CPLE_AppDefined,\n                                \"Band %d was already identified as alpha band, \"\n                                \"and band %d is now marked as alpha too. \"\n                                \"Presumably ALPHA creation option is not needed\",\n                                i, nBand );\n                        }\n                        else\n                        {\n                            CPLError(\n                                CE_Warning, CPLE_AppDefined,\n                                \"Band %d was already identified as alpha band, \"\n                                \"and band %d is now marked as alpha too\",\n                                i, nBand );\n                        }\n                    }\n                }\n            }\n\n            if( nBand > nBaseSamples && nBand - nBaseSamples - 1 < count )\n            {\n                // We need to allocate a new array as (current) libtiff\n                // versions will not like that we reuse the array we got from\n                // TIFFGetField().\n\n                uint16* pasNewExtraSamples =\n                    static_cast<uint16 *>(\n                        CPLMalloc( count * sizeof(uint16) ) );\n                memcpy( pasNewExtraSamples, v, count * sizeof(uint16) );\n                if( eInterp == GCI_AlphaBand )\n                {\n                    pasNewExtraSamples[nBand - nBaseSamples - 1] =\n                        GTiffGetAlphaValue(CPLGetConfigOption(\"GTIFF_ALPHA\", nullptr),\n                                            DEFAULT_ALPHA_TYPE);\n                }\n                else\n                {\n                    pasNewExtraSamples[nBand - nBaseSamples - 1] =\n                        EXTRASAMPLE_UNSPECIFIED;\n                }\n\n                TIFFSetField( poGDS->hTIFF, TIFFTAG_EXTRASAMPLES,\n                              count, pasNewExtraSamples);\n\n                CPLFree(pasNewExtraSamples);\n\n                return CE_None;\n            }\n        }\n    }\n\n    if( poGDS->nPhotometric != PHOTOMETRIC_MINISBLACK &&\n        CSLFetchNameValue( poGDS->papszCreationOptions, \"PHOTOMETRIC\") == nullptr )\n    {\n        poGDS->nPhotometric = PHOTOMETRIC_MINISBLACK;\n        TIFFSetField(poGDS->hTIFF, TIFFTAG_PHOTOMETRIC, poGDS->nPhotometric);\n    }\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                           GetColorTable()                            */\n/************************************************************************/\n\nGDALColorTable *GTiffRasterBand::GetColorTable()\n\n{\n    poGDS->LoadGeoreferencingAndPamIfNeeded();\n\n    if( nBand == 1 )\n        return poGDS->poColorTable;\n\n    return nullptr;\n}\n\n/************************************************************************/\n/*                           SetColorTable()                            */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::SetColorTable( GDALColorTable * poCT )\n\n{\n    poGDS->LoadGeoreferencingAndPamIfNeeded();\n\n/* -------------------------------------------------------------------- */\n/*      Check if this is even a candidate for applying a PCT.           */\n/* -------------------------------------------------------------------- */\n    if( nBand != 1)\n    {\n        CPLError( CE_Failure, CPLE_NotSupported,\n                  \"SetColorTable() can only be called on band 1.\" );\n        return CE_Failure;\n    }\n\n    if( poGDS->nSamplesPerPixel != 1 && poGDS->nSamplesPerPixel != 2)\n    {\n        CPLError( CE_Failure, CPLE_NotSupported,\n                  \"SetColorTable() not supported for multi-sample TIFF \"\n                  \"files.\" );\n        return CE_Failure;\n    }\n\n    if( eDataType != GDT_Byte && eDataType != GDT_UInt16 )\n    {\n        CPLError( CE_Failure, CPLE_NotSupported,\n                  \"SetColorTable() only supported for Byte or UInt16 bands \"\n                  \"in TIFF format.\" );\n        return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      We are careful about calling SetDirectory() to avoid            */\n/*      prematurely crystallizing the directory.  (#2820)               */\n/* -------------------------------------------------------------------- */\n    if( poGDS->bCrystalized )\n    {\n        if( !poGDS->SetDirectory() )\n            return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Is this really a request to clear the color table?              */\n/* -------------------------------------------------------------------- */\n    if( poCT == nullptr || poCT->GetColorEntryCount() == 0 )\n    {\n        TIFFSetField( poGDS->hTIFF, TIFFTAG_PHOTOMETRIC,\n                      PHOTOMETRIC_MINISBLACK );\n\n#ifdef HAVE_UNSETFIELD\n        TIFFUnsetField( poGDS->hTIFF, TIFFTAG_COLORMAP );\n#else\n        CPLDebug(\n            \"GTiff\",\n            \"TIFFUnsetField() not supported, colormap may not be cleared.\" );\n#endif\n\n        if( poGDS->poColorTable )\n        {\n            delete poGDS->poColorTable;\n            poGDS->poColorTable = nullptr;\n        }\n\n        return CE_None;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Write out the colortable, and update the configuration.         */\n/* -------------------------------------------------------------------- */\n    int nColors = 65536;\n\n    if( eDataType == GDT_Byte )\n        nColors = 256;\n\n    unsigned short *panTRed = static_cast<unsigned short *>(\n        CPLMalloc(sizeof(unsigned short)*nColors) );\n    unsigned short *panTGreen = static_cast<unsigned short *>(\n        CPLMalloc(sizeof(unsigned short)*nColors) );\n    unsigned short *panTBlue = static_cast<unsigned short *>(\n        CPLMalloc(sizeof(unsigned short)*nColors) );\n\n    for( int iColor = 0; iColor < nColors; ++iColor )\n    {\n        if( iColor < poCT->GetColorEntryCount() )\n        {\n            GDALColorEntry sRGB;\n            poCT->GetColorEntryAsRGB( iColor, &sRGB );\n\n            panTRed[iColor] = static_cast<unsigned short>(257 * sRGB.c1);\n            panTGreen[iColor] = static_cast<unsigned short>(257 * sRGB.c2);\n            panTBlue[iColor] = static_cast<unsigned short>(257 * sRGB.c3);\n        }\n        else\n        {\n            panTRed[iColor] = 0;\n            panTGreen[iColor] = 0;\n            panTBlue[iColor] = 0;\n        }\n    }\n\n    TIFFSetField( poGDS->hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_PALETTE );\n    TIFFSetField( poGDS->hTIFF, TIFFTAG_COLORMAP,\n                  panTRed, panTGreen, panTBlue );\n\n    CPLFree( panTRed );\n    CPLFree( panTGreen );\n    CPLFree( panTBlue );\n\n    if( poGDS->poColorTable )\n        delete poGDS->poColorTable;\n\n    // libtiff 3.X needs setting this in all cases (creation or update)\n    // whereas libtiff 4.X would just need it if there\n    // was no color table before.\n    poGDS->bNeedsRewrite = true;\n\n    poGDS->poColorTable = poCT->Clone();\n    eBandInterp = GCI_PaletteIndex;\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                           GetNoDataValue()                           */\n/************************************************************************/\n\ndouble GTiffRasterBand::GetNoDataValue( int * pbSuccess )\n\n{\n    poGDS->LoadGeoreferencingAndPamIfNeeded();\n\n    if( bNoDataSet )\n    {\n        if( pbSuccess )\n            *pbSuccess = TRUE;\n\n        return dfNoDataValue;\n    }\n\n    if( poGDS->bNoDataSet )\n    {\n        if( pbSuccess )\n            *pbSuccess = TRUE;\n\n        return poGDS->dfNoDataValue;\n    }\n\n    return GDALPamRasterBand::GetNoDataValue( pbSuccess );\n}\n\n/************************************************************************/\n/*                           SetNoDataValue()                           */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::SetNoDataValue( double dfNoData )\n\n{\n    poGDS->LoadGeoreferencingAndPamIfNeeded();\n\n    if( poGDS->bNoDataSet && poGDS->dfNoDataValue == dfNoData )\n    {\n        bNoDataSet = true;\n        dfNoDataValue = dfNoData;\n        return CE_None;\n    }\n\n    if( poGDS->nBands > 1 && poGDS->osProfile == szPROFILE_GDALGeoTIFF )\n    {\n        int bOtherBandHasNoData = FALSE;\n        const int nOtherBand = nBand > 1 ? 1 : 2;\n        double dfOtherNoData = poGDS->GetRasterBand(nOtherBand)->\n                                    GetNoDataValue(&bOtherBandHasNoData);\n        if( bOtherBandHasNoData && dfOtherNoData != dfNoData )\n        {\n            CPLError(CE_Warning, CPLE_AppDefined,\n                 \"Setting nodata to %.18g on band %d, but band %d has nodata \"\n                 \"at %.18g. The TIFFTAG_GDAL_NODATA only support one value \"\n                 \"per dataset. This value of %.18g will be used for all bands \"\n                 \"on re-opening\",\n                 dfNoData, nBand, nOtherBand, dfOtherNoData, dfNoData);\n        }\n    }\n\n    if( poGDS->bStreamingOut && poGDS->bCrystalized )\n    {\n        CPLError(\n            CE_Failure, CPLE_NotSupported,\n            \"Cannot modify nodata at that point in a streamed output file\" );\n        return CE_Failure;\n    }\n\n    poGDS->bNoDataSet = true;\n    poGDS->dfNoDataValue = dfNoData;\n\n    poGDS->bNoDataChanged = true;\n\n    bNoDataSet = true;\n    dfNoDataValue = dfNoData;\n    return CE_None;\n}\n\n/************************************************************************/\n/*                        DeleteNoDataValue()                           */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::DeleteNoDataValue()\n\n{\n    poGDS->LoadGeoreferencingAndPamIfNeeded();\n\n    if( !poGDS->bNoDataSet )\n        return CE_None;\n\n    if( poGDS->bStreamingOut && poGDS->bCrystalized )\n    {\n        CPLError(\n            CE_Failure, CPLE_NotSupported,\n            \"Cannot modify nodata at that point in a streamed output file\" );\n        return CE_Failure;\n    }\n\n    poGDS->bNoDataSet = false;\n    poGDS->dfNoDataValue = -9999.0;\n\n    poGDS->bNoDataChanged = true;\n\n    bNoDataSet = false;\n    dfNoDataValue = -9999.0;\n    return CE_None;\n}\n\n/************************************************************************/\n/*                             NullBlock()                              */\n/*                                                                      */\n/*      Set the block data to the null value if it is set, or zero      */\n/*      if there is no null data value.                                 */\n/************************************************************************/\n\nvoid GTiffRasterBand::NullBlock( void *pData )\n\n{\n    const int nWords = nBlockXSize * nBlockYSize;\n    const int nChunkSize = std::max(1, GDALGetDataTypeSizeBytes(eDataType));\n\n    int bNoDataSetIn = FALSE;\n    const double dfNoData = GetNoDataValue( &bNoDataSetIn );\n    if( !bNoDataSetIn )\n    {\n#ifdef ESRI_BUILD\n        if( poGDS->nBitsPerSample >= 2 )\n            memset( pData, 0, nWords * nChunkSize );\n        else\n            memset( pData, 1, nWords * nChunkSize );\n#else\n        memset( pData, 0, nWords * nChunkSize );\n#endif\n    }\n    else\n    {\n        // Will convert nodata value to the right type and copy efficiently.\n        GDALCopyWords( &dfNoData, GDT_Float64, 0,\n                       pData, eDataType, nChunkSize, nWords);\n    }\n}\n\n/************************************************************************/\n/*                          GetOverviewCount()                          */\n/************************************************************************/\n\nint GTiffRasterBand::GetOverviewCount()\n\n{\n    poGDS->ScanDirectories();\n\n    if( poGDS->nOverviewCount > 0 )\n    {\n        return poGDS->nOverviewCount;\n    }\n\n    const int nOverviewCount = GDALRasterBand::GetOverviewCount();\n    if( nOverviewCount > 0 )\n        return nOverviewCount;\n\n    // Implicit JPEG overviews are normally hidden, except when doing\n    // IRasterIO() operations.\n    if( poGDS->nJPEGOverviewVisibilityCounter )\n        return poGDS->GetJPEGOverviewCount();\n\n    return 0;\n}\n\n/************************************************************************/\n/*                            GetOverview()                             */\n/************************************************************************/\n\nGDALRasterBand *GTiffRasterBand::GetOverview( int i )\n\n{\n    poGDS->ScanDirectories();\n\n    if( poGDS->nOverviewCount > 0 )\n    {\n        // Do we have internal overviews?\n        if( i < 0 || i >= poGDS->nOverviewCount )\n            return nullptr;\n\n        return poGDS->papoOverviewDS[i]->GetRasterBand(nBand);\n    }\n\n    GDALRasterBand* const poOvrBand = GDALRasterBand::GetOverview( i );\n    if( poOvrBand != nullptr )\n        return poOvrBand;\n\n    // For consistency with GetOverviewCount(), we should also test\n    // nJPEGOverviewVisibilityCounter, but it is also convenient to be able\n    // to query them for testing purposes.\n    if( i >= 0 && i < poGDS->GetJPEGOverviewCount() )\n        return poGDS->papoJPEGOverviewDS[i]->GetRasterBand(nBand);\n\n    return nullptr;\n}\n\n/************************************************************************/\n/*                           GetMaskFlags()                             */\n/************************************************************************/\n\nint GTiffRasterBand::GetMaskFlags()\n{\n    poGDS->ScanDirectories();\n\n    if( poGDS->poMaskDS != nullptr )\n    {\n        if( poGDS->poMaskDS->GetRasterCount() == 1)\n        {\n            return GMF_PER_DATASET;\n        }\n\n        return 0;\n    }\n\n    if( poGDS->bIsOverview_ )\n    {\n        return poGDS->poBaseDS->GetRasterBand(nBand)->GetMaskFlags();\n    }\n\n    return GDALPamRasterBand::GetMaskFlags();\n}\n\n/************************************************************************/\n/*                            GetMaskBand()                             */\n/************************************************************************/\n\nGDALRasterBand *GTiffRasterBand::GetMaskBand()\n{\n    poGDS->ScanDirectories();\n\n    if( poGDS->poMaskDS != nullptr )\n    {\n        if( poGDS->poMaskDS->GetRasterCount() == 1 )\n            return poGDS->poMaskDS->GetRasterBand(1);\n\n        return poGDS->poMaskDS->GetRasterBand(nBand);\n    }\n\n    if( poGDS->bIsOverview_ )\n    {\n        GDALRasterBand* poBaseMask =\n            poGDS->poBaseDS->GetRasterBand(nBand)->GetMaskBand();\n        if( poBaseMask )\n        {\n            const int nOverviews = poBaseMask->GetOverviewCount();\n            for( int i = 0; i < nOverviews; i++ )\n            {\n                GDALRasterBand* poOvr = poBaseMask->GetOverview(i);\n                if( poOvr &&\n                    poOvr->GetXSize() == GetXSize() &&\n                    poOvr->GetYSize() == GetYSize() )\n                {\n                    return poOvr;\n                }\n            }\n        }\n    }\n\n    return GDALPamRasterBand::GetMaskBand();\n}\n\n/************************************************************************/\n/* ==================================================================== */\n/*                             GTiffSplitBand                           */\n/* ==================================================================== */\n/************************************************************************/\n\nclass GTiffSplitBand final : public GTiffRasterBand\n{\n    friend class GTiffDataset;\n\n  public:\n             GTiffSplitBand( GTiffDataset *, int );\n    virtual ~GTiffSplitBand() {}\n\n    virtual int IGetDataCoverageStatus( int nXOff, int nYOff,\n                                        int nXSize, int nYSize,\n                                        int nMaskFlagStop,\n                                        double* pdfDataPct) override;\n\n    virtual CPLErr IReadBlock( int, int, void * ) override;\n    virtual CPLErr IWriteBlock( int, int, void * ) override;\n};\n\n/************************************************************************/\n/*                           GTiffSplitBand()                           */\n/************************************************************************/\n\nGTiffSplitBand::GTiffSplitBand( GTiffDataset *poDSIn, int nBandIn ) :\n    GTiffRasterBand( poDSIn, nBandIn )\n{\n    nBlockXSize = poDS->GetRasterXSize();\n    nBlockYSize = 1;\n}\n\n/************************************************************************/\n/*                       IGetDataCoverageStatus()                       */\n/************************************************************************/\n\nint GTiffSplitBand::IGetDataCoverageStatus( int , int ,\n                                             int , int ,\n                                             int ,\n                                             double* )\n{\n     return GDAL_DATA_COVERAGE_STATUS_UNIMPLEMENTED |\n            GDAL_DATA_COVERAGE_STATUS_DATA;\n}\n\n/************************************************************************/\n/*                             IReadBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffSplitBand::IReadBlock( int /* nBlockXOff */, int nBlockYOff,\n                                   void * pImage )\n\n{\n    // Optimization when reading the same line in a contig multi-band TIFF.\n    if( poGDS->nPlanarConfig == PLANARCONFIG_CONTIG && poGDS->nBands > 1 &&\n        poGDS->nLastLineRead == nBlockYOff )\n    {\n        goto extract_band_data;\n    }\n\n    if( !poGDS->SetDirectory() )\n        return CE_Failure;\n\n    if( poGDS->nPlanarConfig == PLANARCONFIG_CONTIG &&\n        poGDS->nBands > 1 )\n    {\n        if( poGDS->pabyBlockBuf == nullptr )\n        {\n            poGDS->pabyBlockBuf =\n                static_cast<GByte *>(\n                    VSI_MALLOC_VERBOSE(TIFFScanlineSize(poGDS->hTIFF)) );\n            if( poGDS->pabyBlockBuf == nullptr )\n            {\n                return CE_Failure;\n            }\n        }\n    }\n    else\n    {\n        CPLAssert(TIFFScanlineSize(poGDS->hTIFF) == nBlockXSize);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Read through to target scanline.                                */\n/* -------------------------------------------------------------------- */\n    if( poGDS->nLastLineRead >= nBlockYOff )\n        poGDS->nLastLineRead = -1;\n\n    if( poGDS->nPlanarConfig == PLANARCONFIG_SEPARATE && poGDS->nBands > 1 )\n    {\n        // If we change of band, we must start reading the\n        // new strip from its beginning.\n        if( poGDS->nLastBandRead != nBand )\n            poGDS->nLastLineRead = -1;\n        poGDS->nLastBandRead = nBand;\n    }\n\n    while( poGDS->nLastLineRead < nBlockYOff )\n    {\n        ++poGDS->nLastLineRead;\n        if( TIFFReadScanline(\n                poGDS->hTIFF,\n                poGDS->pabyBlockBuf ? poGDS->pabyBlockBuf : pImage,\n                poGDS->nLastLineRead,\n                (poGDS->nPlanarConfig == PLANARCONFIG_SEPARATE) ?\n                 static_cast<uint16>(nBand - 1) : 0 ) == -1\n            && !poGDS->bIgnoreReadErrors )\n        {\n            CPLError( CE_Failure, CPLE_AppDefined,\n                      \"TIFFReadScanline() failed.\" );\n            poGDS->nLastLineRead = -1;\n            return CE_Failure;\n        }\n    }\n\nextract_band_data:\n/* -------------------------------------------------------------------- */\n/*      Extract band data from contig buffer.                           */\n/* -------------------------------------------------------------------- */\n    if( poGDS->pabyBlockBuf != nullptr )\n    {\n        for( int iPixel = 0, iSrcOffset= nBand - 1, iDstOffset = 0;\n             iPixel < nBlockXSize;\n             ++iPixel, iSrcOffset += poGDS->nBands, ++iDstOffset )\n        {\n            static_cast<GByte *>(pImage)[iDstOffset] =\n                poGDS->pabyBlockBuf[iSrcOffset];\n        }\n    }\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                            IWriteBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffSplitBand::IWriteBlock( int /* nBlockXOff */, int /* nBlockYOff */,\n                                    void * /* pImage */ )\n\n{\n    CPLError( CE_Failure, CPLE_AppDefined,\n              \"Split bands are read-only.\" );\n    return CE_Failure;\n}\n\n/************************************************************************/\n/* ==================================================================== */\n/*                             GTiffRGBABand                            */\n/* ==================================================================== */\n/************************************************************************/\n\nclass GTiffRGBABand final : public GTiffRasterBand\n{\n    friend class GTiffDataset;\n\n  public:\n                   GTiffRGBABand( GTiffDataset *, int );\n    virtual ~GTiffRGBABand() {}\n\n    virtual int IGetDataCoverageStatus( int nXOff, int nYOff,\n                                        int nXSize, int nYSize,\n                                        int nMaskFlagStop,\n                                        double* pdfDataPct) override;\n\n    virtual CPLErr IReadBlock( int, int, void * ) override;\n    virtual CPLErr IWriteBlock( int, int, void * ) override;\n\n    virtual GDALColorInterp GetColorInterpretation() override;\n};\n\n/************************************************************************/\n/*                           GTiffRGBABand()                            */\n/************************************************************************/\n\nGTiffRGBABand::GTiffRGBABand( GTiffDataset *poDSIn, int nBandIn ) :\n    GTiffRasterBand( poDSIn, nBandIn )\n{\n    eDataType = GDT_Byte;\n}\n\n/************************************************************************/\n/*                       IGetDataCoverageStatus()                       */\n/************************************************************************/\n\nint GTiffRGBABand::IGetDataCoverageStatus( int , int ,\n                                             int , int ,\n                                             int ,\n                                             double* )\n{\n     return GDAL_DATA_COVERAGE_STATUS_UNIMPLEMENTED |\n            GDAL_DATA_COVERAGE_STATUS_DATA;\n}\n\n/************************************************************************/\n/*                            IWriteBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffRGBABand::IWriteBlock( int, int, void * )\n\n{\n    CPLError( CE_Failure, CPLE_AppDefined,\n              \"RGBA interpreted raster bands are read-only.\" );\n    return CE_Failure;\n}\n\n/************************************************************************/\n/*                             IReadBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffRGBABand::IReadBlock( int nBlockXOff, int nBlockYOff,\n                                  void * pImage )\n\n{\n    if( !poGDS->SetDirectory() )\n        return CE_Failure;\n\n    CPLAssert( nBlocksPerRow != 0 );\n    const int nBlockBufSize = 4 * nBlockXSize * nBlockYSize;\n    const int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n\n#ifdef INTERNAL_LIBTIFF\n    if( poGDS->nCompression == COMPRESSION_OJPEG )\n    {\n        // Need to fetch all offsets for Old-JPEG compression\n        if( poGDS->pabyBlockBuf == nullptr )\n        {\n            toff_t *panByteCounts = nullptr;\n            toff_t *panOffsets = nullptr;\n            const bool bIsTiled = CPL_TO_BOOL( TIFFIsTiled(poGDS->hTIFF) );\n\n            if( bIsTiled )\n            {\n                TIFFGetField( poGDS->hTIFF, TIFFTAG_TILEBYTECOUNTS, &panByteCounts );\n                TIFFGetField( poGDS->hTIFF, TIFFTAG_TILEOFFSETS, &panOffsets );\n            }\n            else\n            {\n                TIFFGetField( poGDS->hTIFF, TIFFTAG_STRIPBYTECOUNTS, &panByteCounts );\n                TIFFGetField( poGDS->hTIFF, TIFFTAG_STRIPOFFSETS, &panOffsets );\n            }\n        }\n    }\n#endif\n\n    if( poGDS->nPlanarConfig == PLANARCONFIG_SEPARATE )\n    {\n        for( int iBand = 0; iBand < poGDS->nSamplesPerPixel; iBand ++ )\n        {\n            int nBlockIdBand = nBlockId + iBand * poGDS->nBlocksPerBand;\n            if( !poGDS->IsBlockAvailable(nBlockIdBand) )\n                return CE_Failure;\n        }\n    }\n    else\n    {\n        if( !poGDS->IsBlockAvailable(nBlockId) )\n            return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Allocate a temporary buffer for this strip.                     */\n/* -------------------------------------------------------------------- */\n    if( poGDS->pabyBlockBuf == nullptr )\n    {\n        poGDS->pabyBlockBuf =\n            static_cast<GByte *>(\n                VSI_MALLOC3_VERBOSE( 4, nBlockXSize, nBlockYSize ) );\n        if( poGDS->pabyBlockBuf == nullptr )\n            return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Read the strip                                                  */\n/* -------------------------------------------------------------------- */\n    CPLErr eErr = CE_None;\n\n    if( poGDS->nLoadedBlock != nBlockId )\n    {\n        if( TIFFIsTiled( poGDS->hTIFF ) )\n        {\n#if defined(INTERNAL_LIBTIFF) || TIFFLIB_VERSION > 20161119\n            if( TIFFReadRGBATileExt(\n                   poGDS->hTIFF,\n                   nBlockXOff * nBlockXSize,\n                   nBlockYOff * nBlockYSize,\n                   reinterpret_cast<uint32 *>(poGDS->pabyBlockBuf),\n                   !poGDS->bIgnoreReadErrors) == 0\n                && !poGDS->bIgnoreReadErrors )\n#else\n            if( TIFFReadRGBATile(\n                   poGDS->hTIFF,\n                   nBlockXOff * nBlockXSize,\n                   nBlockYOff * nBlockYSize,\n                   reinterpret_cast<uint32 *>(poGDS->pabyBlockBuf)) == 0\n                && !poGDS->bIgnoreReadErrors )\n#endif\n            {\n                // Once TIFFError() is properly hooked, this can go away.\n                CPLError( CE_Failure, CPLE_AppDefined,\n                          \"TIFFReadRGBATile() failed.\" );\n\n                memset( poGDS->pabyBlockBuf, 0, nBlockBufSize );\n\n                eErr = CE_Failure;\n            }\n        }\n        else\n        {\n#if defined(INTERNAL_LIBTIFF) || TIFFLIB_VERSION > 20161119\n            if( TIFFReadRGBAStripExt(\n                   poGDS->hTIFF,\n                   nBlockId * nBlockYSize,\n                   reinterpret_cast<uint32 *>(poGDS->pabyBlockBuf),\n                   !poGDS->bIgnoreReadErrors) == 0\n                && !poGDS->bIgnoreReadErrors )\n#else\n            if( TIFFReadRGBAStrip(\n                   poGDS->hTIFF,\n                   nBlockId * nBlockYSize,\n                   reinterpret_cast<uint32 *>(poGDS->pabyBlockBuf)) == 0\n                && !poGDS->bIgnoreReadErrors )\n#endif\n            {\n                // Once TIFFError() is properly hooked, this can go away.\n                CPLError( CE_Failure, CPLE_AppDefined,\n                          \"TIFFReadRGBAStrip() failed.\" );\n\n                memset( poGDS->pabyBlockBuf, 0, nBlockBufSize );\n\n                eErr = CE_Failure;\n            }\n        }\n    }\n\n    poGDS->nLoadedBlock = nBlockId;\n\n/* -------------------------------------------------------------------- */\n/*      Handle simple case of eight bit data, and pixel interleaving.   */\n/* -------------------------------------------------------------------- */\n    int nThisBlockYSize = nBlockYSize;\n\n    if( nBlockYOff * nBlockYSize > GetYSize() - nBlockYSize\n        && !TIFFIsTiled( poGDS->hTIFF ) )\n        nThisBlockYSize = GetYSize() - nBlockYOff * nBlockYSize;\n\n#ifdef CPL_LSB\n    const int nBO = nBand - 1;\n#else\n    const int nBO = 4 - nBand;\n#endif\n\n    for( int iDestLine = 0; iDestLine < nThisBlockYSize; ++iDestLine )\n    {\n        const int nSrcOffset =\n            (nThisBlockYSize - iDestLine - 1) * nBlockXSize * 4;\n\n        GDALCopyWords(\n            poGDS->pabyBlockBuf + nBO + nSrcOffset, GDT_Byte, 4,\n            static_cast<GByte *>(pImage)+iDestLine*nBlockXSize, GDT_Byte, 1,\n            nBlockXSize );\n    }\n\n    if( eErr == CE_None )\n        eErr = FillCacheForOtherBands(nBlockXOff, nBlockYOff);\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                       GetColorInterpretation()                       */\n/************************************************************************/\n\nGDALColorInterp GTiffRGBABand::GetColorInterpretation()\n\n{\n    if( nBand == 1 )\n        return GCI_RedBand;\n    if( nBand == 2 )\n        return GCI_GreenBand;\n    if( nBand == 3 )\n        return GCI_BlueBand;\n\n    return GCI_AlphaBand;\n}\n\n/************************************************************************/\n/* ==================================================================== */\n/*                             GTiffOddBitsBand                         */\n/* ==================================================================== */\n/************************************************************************/\n\nclass GTiffOddBitsBand : public GTiffRasterBand\n{\n    friend class GTiffDataset;\n  public:\n\n                   GTiffOddBitsBand( GTiffDataset *, int );\n    virtual ~GTiffOddBitsBand() {}\n\n    virtual CPLErr IReadBlock( int, int, void * ) override;\n    virtual CPLErr IWriteBlock( int, int, void * ) override;\n};\n\n/************************************************************************/\n/*                           GTiffOddBitsBand()                         */\n/************************************************************************/\n\nGTiffOddBitsBand::GTiffOddBitsBand( GTiffDataset *poGDSIn, int nBandIn )\n        : GTiffRasterBand( poGDSIn, nBandIn )\n\n{\n    eDataType = GDT_Unknown;\n    if( (poGDS->nBitsPerSample == 16 || poGDS->nBitsPerSample == 24) &&\n        poGDS->nSampleFormat == SAMPLEFORMAT_IEEEFP )\n        eDataType = GDT_Float32;\n    // FIXME ? in autotest we currently open gcore/data/int24.tif\n    // which is declared as signed, but we consider it as unsigned\n    else if( (poGDS->nSampleFormat == SAMPLEFORMAT_UINT ||\n              poGDS->nSampleFormat == SAMPLEFORMAT_INT) &&\n             poGDS->nBitsPerSample < 8 )\n        eDataType = GDT_Byte;\n    else if( (poGDS->nSampleFormat == SAMPLEFORMAT_UINT ||\n              poGDS->nSampleFormat == SAMPLEFORMAT_INT) &&\n             poGDS->nBitsPerSample > 8 && poGDS->nBitsPerSample < 16 )\n        eDataType = GDT_UInt16;\n    else if( (poGDS->nSampleFormat == SAMPLEFORMAT_UINT ||\n              poGDS->nSampleFormat == SAMPLEFORMAT_INT) &&\n             poGDS->nBitsPerSample > 16 && poGDS->nBitsPerSample < 32 )\n        eDataType = GDT_UInt32;\n}\n\n/************************************************************************/\n/*                            FloatToHalf()                             */\n/************************************************************************/\n\nstatic GUInt16 FloatToHalf( GUInt32 iFloat32, bool& bHasWarned )\n{\n    GUInt32 iSign =     (iFloat32 >> 31) & 0x00000001;\n    GUInt32 iExponent = (iFloat32 >> 23) & 0x000000ff;\n    GUInt32 iMantissa = iFloat32         & 0x007fffff;\n\n    if (iExponent == 255)\n    {\n        if (iMantissa == 0)\n        {\n/* -------------------------------------------------------------------- */\n/*       Positive or negative infinity.                                 */\n/* -------------------------------------------------------------------- */\n\n            return static_cast<GUInt16>((iSign << 15) | 0x7C00);\n        }\n        else\n        {\n/* -------------------------------------------------------------------- */\n/*       NaN -- preserve sign and significand bits.                     */\n/* -------------------------------------------------------------------- */\n            if( iMantissa >> 13 )\n                return static_cast<GUInt16>((iSign << 15) | 0x7C00 |\n                                                            (iMantissa >> 13));\n\n            return static_cast<GUInt16>((iSign << 15) | 0x7E00);\n        }\n    }\n\n    if( iExponent <= 127 - 15 )\n    {\n        // Zero, float32 denormalized number or float32 too small normalized\n        // number\n        if( 13 + 1 + 127 - 15 - iExponent >= 32 )\n            return static_cast<GUInt16>(iSign << 15);\n\n        // Return a denormalized number\n        return static_cast<GUInt16>((iSign << 15) |\n                ((iMantissa | 0x00800000) >> (13 + 1 + 127 - 15 - iExponent)));\n    }\n    if( iExponent - (127 - 15) >= 31 )\n    {\n        if( !bHasWarned )\n        {\n            bHasWarned = true;\n            float fVal = 0.0f;\n            memcpy(&fVal, &iFloat32, 4);\n            CPLError(\n                CE_Failure, CPLE_AppDefined,\n                \"Value %.8g is beyond range of float16. Converted to %sinf\",\n                fVal, (fVal > 0) ? \"+\" : \"-\");\n        }\n        return static_cast<GUInt16>((iSign << 15) | 0x7C00);  // Infinity\n    }\n\n/* -------------------------------------------------------------------- */\n/*       Normalized number.                                             */\n/* -------------------------------------------------------------------- */\n\n    iExponent = iExponent - (127 - 15);\n    iMantissa = iMantissa >> 13;\n\n/* -------------------------------------------------------------------- */\n/*       Assemble sign, exponent and mantissa.                          */\n/* -------------------------------------------------------------------- */\n\n    // coverity[overflow_sink]\n    return static_cast<GUInt16>((iSign << 15) | (iExponent << 10) | iMantissa);\n}\n\n/************************************************************************/\n/*                            IWriteBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffOddBitsBand::IWriteBlock( int nBlockXOff, int nBlockYOff,\n                                      void *pImage )\n\n{\n    if( poGDS->bWriteErrorInFlushBlockBuf )\n    {\n        // Report as an error if a previously loaded block couldn't be written\n        // correctly.\n        poGDS->bWriteErrorInFlushBlockBuf = false;\n        return CE_Failure;\n    }\n\n    if( !poGDS->SetDirectory() )\n        return CE_Failure;\n\n    CPLAssert( poGDS != nullptr\n               && nBlockXOff >= 0\n               && nBlockYOff >= 0\n               && pImage != nullptr );\n\n    if( eDataType == GDT_Float32 && poGDS->nBitsPerSample != 16 )\n    {\n        CPLError(CE_Failure, CPLE_NotSupported,\n                 \"Writing float data with nBitsPerSample = %d is unsupported\",\n                 poGDS->nBitsPerSample);\n        return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Load the block buffer.                                          */\n/* -------------------------------------------------------------------- */\n    CPLAssert(nBlocksPerRow != 0);\n    int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n\n    if( poGDS->nPlanarConfig == PLANARCONFIG_SEPARATE )\n        nBlockId += (nBand - 1) * poGDS->nBlocksPerBand;\n\n    // Only read content from disk in the CONTIG case.\n    {\n        const CPLErr eErr =\n            poGDS->LoadBlockBuf( nBlockId,\n                                 poGDS->nPlanarConfig == PLANARCONFIG_CONTIG &&\n                                 poGDS->nBands > 1 );\n        if( eErr != CE_None )\n            return eErr;\n    }\n\n    const GUInt32 nMaxVal = (1U << poGDS->nBitsPerSample) - 1;\n\n/* -------------------------------------------------------------------- */\n/*      Handle case of \"separate\" images or single band images where    */\n/*      no interleaving with other data is required.                    */\n/* -------------------------------------------------------------------- */\n    if( poGDS->nPlanarConfig == PLANARCONFIG_SEPARATE\n        || poGDS->nBands == 1 )\n    {\n        // TODO(schwehr): Create a CplNumBits8Aligned.\n        // Bits per line rounds up to next byte boundary.\n        int nBitsPerLine = nBlockXSize * poGDS->nBitsPerSample;\n        if( (nBitsPerLine & 7) != 0 )\n            nBitsPerLine = (nBitsPerLine + 7) & (~7);\n\n        int iPixel = 0;\n\n        // Small optimization in 1 bit case.\n        if( poGDS->nBitsPerSample == 1 )\n        {\n            for( int iY = 0; iY < nBlockYSize; ++iY, iPixel += nBlockXSize )\n            {\n                int iBitOffset = iY * nBitsPerLine;\n\n                const GByte* pabySrc =\n                    static_cast<const GByte*>(pImage) + iPixel;\n                int iByteOffset = iBitOffset / 8;\n                int iX = 0;  // Used after for.\n                for( ; iX + 7 < nBlockXSize; iX += 8, iByteOffset++ )\n                {\n                    int nRes = (!(!pabySrc[iX+0])) << 7;\n                    nRes |= (!(!pabySrc[iX+1])) << 6;\n                    nRes |= (!(!pabySrc[iX+2])) << 5;\n                    nRes |= (!(!pabySrc[iX+3])) << 4;\n                    nRes |= (!(!pabySrc[iX+4])) << 3;\n                    nRes |= (!(!pabySrc[iX+5])) << 2;\n                    nRes |= (!(!pabySrc[iX+6])) << 1;\n                    nRes |= (!(!pabySrc[iX+7])) << 0;\n                    poGDS->pabyBlockBuf[iByteOffset] = static_cast<GByte>(nRes);\n                }\n                iBitOffset = iByteOffset * 8;\n                if( iX < nBlockXSize )\n                {\n                    int nRes = 0;\n                    for( ; iX < nBlockXSize; ++iX )\n                    {\n                        if( pabySrc[iX] )\n                            nRes |= (0x80 >>(iBitOffset & 7) );\n                        ++iBitOffset;\n                    }\n                    poGDS->pabyBlockBuf[iBitOffset>>3] =\n                        static_cast<GByte>(nRes);\n                }\n            }\n\n            poGDS->bLoadedBlockDirty = true;\n\n            return CE_None;\n        }\n\n        if( eDataType == GDT_Float32 && poGDS->nBitsPerSample == 16 )\n        {\n            for( ; iPixel < nBlockYSize * nBlockXSize; iPixel++ )\n            {\n                GUInt32 nInWord = static_cast<GUInt32 *>(pImage)[iPixel];\n                GUInt16 nHalf = FloatToHalf(nInWord, poGDS->bClipWarn);\n                reinterpret_cast<GUInt16*>(poGDS->pabyBlockBuf)[iPixel] = nHalf;\n            }\n\n            poGDS->bLoadedBlockDirty = true;\n\n            return CE_None;\n        }\n\n        // Initialize to zero as we set the buffer with binary or operations.\n        if( poGDS->nBitsPerSample != 24 )\n            memset(poGDS->pabyBlockBuf, 0, (nBitsPerLine / 8) * nBlockYSize);\n\n        for( int iY = 0; iY < nBlockYSize; ++iY )\n        {\n            int iBitOffset = iY * nBitsPerLine;\n\n            if( poGDS->nBitsPerSample == 12 )\n            {\n                for( int iX = 0; iX < nBlockXSize; ++iX )\n                {\n                    GUInt32 nInWord = static_cast<GUInt16 *>(pImage)[iPixel++];\n                    if( nInWord > nMaxVal )\n                    {\n                        nInWord = nMaxVal;\n                        if( !poGDS->bClipWarn )\n                        {\n                            poGDS->bClipWarn = true;\n                            CPLError(\n                                CE_Warning, CPLE_AppDefined,\n                                \"One or more pixels clipped to fit %d bit \"\n                                \"domain.\", poGDS->nBitsPerSample );\n                        }\n                    }\n\n                    if( (iBitOffset % 8) == 0 )\n                    {\n                        poGDS->pabyBlockBuf[iBitOffset>>3] =\n                            static_cast<GByte>(nInWord >> 4);\n                        // Let 4 lower bits to zero as they're going to be\n                        // overridden by the next word.\n                        poGDS->pabyBlockBuf[(iBitOffset>>3)+1] =\n                            static_cast<GByte>((nInWord & 0xf) << 4);\n                    }\n                    else\n                    {\n                        // Must or to preserve the 4 upper bits written\n                        // for the previous word.\n                        poGDS->pabyBlockBuf[iBitOffset>>3] |=\n                            static_cast<GByte>(nInWord >> 8);\n                        poGDS->pabyBlockBuf[(iBitOffset>>3)+1] =\n                            static_cast<GByte>(nInWord & 0xff);\n                    }\n\n                    iBitOffset += poGDS->nBitsPerSample;\n                }\n                continue;\n            }\n\n            for( int iX = 0; iX < nBlockXSize; ++iX )\n            {\n                GUInt32 nInWord = 0;\n                if( eDataType == GDT_Byte )\n                {\n                    nInWord = static_cast<GByte *>(pImage)[iPixel++];\n                }\n                else if( eDataType == GDT_UInt16 )\n                {\n                    nInWord = static_cast<GUInt16 *>(pImage)[iPixel++];\n                }\n                else if( eDataType == GDT_UInt32 )\n                {\n                    nInWord = static_cast<GUInt32 *>(pImage)[iPixel++];\n                }\n                else\n                {\n                    CPLAssert(false);\n                }\n\n                if( nInWord > nMaxVal )\n                {\n                    nInWord = nMaxVal;\n                    if( !poGDS->bClipWarn )\n                    {\n                        poGDS->bClipWarn = true;\n                        CPLError(\n                            CE_Warning, CPLE_AppDefined,\n                            \"One or more pixels clipped to fit %d bit domain.\",\n                            poGDS->nBitsPerSample );\n                    }\n                }\n\n                if( poGDS->nBitsPerSample == 24 )\n                {\n/* -------------------------------------------------------------------- */\n/*      Special case for 24bit data which is pre-byteswapped since      */\n/*      the size falls on a byte boundary ... ugh (#2361).              */\n/* -------------------------------------------------------------------- */\n#ifdef CPL_MSB\n                    poGDS->pabyBlockBuf[(iBitOffset>>3) + 0] =\n                        static_cast<GByte>( nInWord );\n                    poGDS->pabyBlockBuf[(iBitOffset>>3) + 1] =\n                        static_cast<GByte>( nInWord >> 8 );\n                    poGDS->pabyBlockBuf[(iBitOffset>>3) + 2] =\n                        static_cast<GByte>( nInWord >> 16 );\n#else\n                    poGDS->pabyBlockBuf[(iBitOffset>>3) + 0] =\n                        static_cast<GByte>( nInWord >> 16 );\n                    poGDS->pabyBlockBuf[(iBitOffset>>3) + 1] =\n                        static_cast<GByte>( nInWord >> 8 );\n                    poGDS->pabyBlockBuf[(iBitOffset>>3) + 2] =\n                        static_cast<GByte>( nInWord );\n#endif\n                    iBitOffset += 24;\n                }\n                else\n                {\n                    for( int iBit = 0; iBit < poGDS->nBitsPerSample; ++iBit )\n                    {\n                        if( nInWord &\n                            (1 << (poGDS->nBitsPerSample - 1 - iBit)) )\n                            poGDS->pabyBlockBuf[iBitOffset>>3] |=\n                                ( 0x80 >> (iBitOffset & 7) );\n                        ++iBitOffset;\n                    }\n                }\n            }\n        }\n\n        poGDS->bLoadedBlockDirty = true;\n\n        return CE_None;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Handle case of pixel interleaved (PLANARCONFIG_CONTIG) images.  */\n/* -------------------------------------------------------------------- */\n\n/* -------------------------------------------------------------------- */\n/*      On write of pixel interleaved data, we might as well flush      */\n/*      out any other bands that are dirty in our cache.  This is       */\n/*      especially helpful when writing compressed blocks.              */\n/* -------------------------------------------------------------------- */\n    for( int iBand = 0; iBand < poGDS->nBands; ++iBand )\n    {\n        const GByte *pabyThisImage = nullptr;\n        GDALRasterBlock *poBlock = nullptr;\n\n        if( iBand + 1 == nBand )\n        {\n            pabyThisImage = static_cast<GByte *>( pImage );\n        }\n        else\n        {\n            poBlock =\n                cpl::down_cast<GTiffOddBitsBand *>(\n                    poGDS->GetRasterBand( iBand + 1 ))\n                        ->TryGetLockedBlockRef( nBlockXOff, nBlockYOff );\n\n            if( poBlock == nullptr )\n                continue;\n\n            if( !poBlock->GetDirty() )\n            {\n                poBlock->DropLock();\n                continue;\n            }\n\n            pabyThisImage = static_cast<GByte *>(poBlock->GetDataRef());\n        }\n\n        const int iPixelBitSkip = poGDS->nBitsPerSample * poGDS->nBands;\n        const int iBandBitOffset = iBand * poGDS->nBitsPerSample;\n\n        // Bits per line rounds up to next byte boundary.\n        int nBitsPerLine = nBlockXSize * iPixelBitSkip;\n        if( (nBitsPerLine & 7) != 0 )\n            nBitsPerLine = (nBitsPerLine + 7) & (~7);\n\n        int iPixel = 0;\n\n        if( eDataType == GDT_Float32 && poGDS->nBitsPerSample == 16 )\n        {\n            for( ; iPixel < nBlockYSize * nBlockXSize; iPixel++ )\n            {\n                GUInt32 nInWord = reinterpret_cast<const GUInt32 *>(\n                                                        pabyThisImage)[iPixel];\n                GUInt16 nHalf = FloatToHalf(nInWord, poGDS->bClipWarn);\n                reinterpret_cast<GUInt16*>(poGDS->pabyBlockBuf)[\n                                    iPixel * poGDS->nBands + iBand] = nHalf;\n            }\n\n            if( poBlock != nullptr )\n            {\n                poBlock->MarkClean();\n                poBlock->DropLock();\n            }\n            continue;\n        }\n\n        for( int iY = 0; iY < nBlockYSize; ++iY )\n        {\n            int iBitOffset = iBandBitOffset + iY * nBitsPerLine;\n\n            if( poGDS->nBitsPerSample == 12 )\n            {\n                for( int iX = 0; iX < nBlockXSize; ++iX )\n                {\n                    GUInt32 nInWord =\n                        reinterpret_cast<const GUInt16 *>(\n                            pabyThisImage)[iPixel++];\n                    if( nInWord > nMaxVal )\n                    {\n                        nInWord = nMaxVal;\n                        if( !poGDS->bClipWarn )\n                        {\n                            poGDS->bClipWarn = true;\n                            CPLError(\n                                CE_Warning, CPLE_AppDefined,\n                                \"One or more pixels clipped to fit %d bit \"\n                                \"domain.\", poGDS->nBitsPerSample );\n                        }\n                    }\n\n                    if( (iBitOffset % 8) == 0 )\n                    {\n                        poGDS->pabyBlockBuf[iBitOffset>>3] =\n                            static_cast<GByte>( nInWord >> 4 );\n                        poGDS->pabyBlockBuf[(iBitOffset>>3)+1] =\n                            static_cast<GByte>(\n                                ((nInWord & 0xf) << 4) |\n                                (poGDS->pabyBlockBuf[(iBitOffset>>3)+1] &\n                                 0xf) );\n                    }\n                    else\n                    {\n                        poGDS->pabyBlockBuf[iBitOffset>>3] =\n                            static_cast<GByte>(\n                                (poGDS->pabyBlockBuf[iBitOffset>>3] &\n                                 0xf0) |\n                                (nInWord >> 8));\n                        poGDS->pabyBlockBuf[(iBitOffset>>3)+1] =\n                            static_cast<GByte>(nInWord & 0xff);\n                    }\n\n                    iBitOffset += iPixelBitSkip;\n                }\n                continue;\n            }\n\n            for( int iX = 0; iX < nBlockXSize; ++iX )\n            {\n                GUInt32 nInWord = 0;\n                if( eDataType == GDT_Byte )\n                {\n                    nInWord =\n                        static_cast<const GByte *>(pabyThisImage)[iPixel++];\n                }\n                else if( eDataType == GDT_UInt16 )\n                {\n                    nInWord = reinterpret_cast<const GUInt16 *>(\n                        pabyThisImage)[iPixel++];\n                }\n                else if( eDataType == GDT_UInt32 )\n                {\n                    nInWord = reinterpret_cast<const GUInt32 *>(\n                        pabyThisImage)[iPixel++];\n                }\n                else\n                {\n                    CPLAssert(false);\n                }\n\n                if( nInWord > nMaxVal )\n                {\n                    nInWord = nMaxVal;\n                    if( !poGDS->bClipWarn )\n                    {\n                        poGDS->bClipWarn = true;\n                        CPLError(\n                            CE_Warning, CPLE_AppDefined,\n                            \"One or more pixels clipped to fit %d bit domain.\",\n                            poGDS->nBitsPerSample );\n                    }\n                }\n\n                if( poGDS->nBitsPerSample == 24 )\n                {\n/* -------------------------------------------------------------------- */\n/*      Special case for 24bit data which is pre-byteswapped since      */\n/*      the size falls on a byte boundary ... ugh (#2361).              */\n/* -------------------------------------------------------------------- */\n#ifdef CPL_MSB\n                    poGDS->pabyBlockBuf[(iBitOffset>>3) + 0] =\n                        static_cast<GByte>(nInWord);\n                    poGDS->pabyBlockBuf[(iBitOffset>>3) + 1] =\n                        static_cast<GByte>(nInWord >> 8);\n                    poGDS->pabyBlockBuf[(iBitOffset>>3) + 2] =\n                        static_cast<GByte>(nInWord >> 16);\n#else\n                    poGDS->pabyBlockBuf[(iBitOffset>>3) + 0] =\n                        static_cast<GByte>(nInWord >> 16);\n                    poGDS->pabyBlockBuf[(iBitOffset>>3) + 1] =\n                        static_cast<GByte>(nInWord >> 8);\n                    poGDS->pabyBlockBuf[(iBitOffset>>3) + 2] =\n                        static_cast<GByte>(nInWord);\n#endif\n                    iBitOffset += 24;\n                }\n                else\n                {\n                    for( int iBit = 0; iBit < poGDS->nBitsPerSample; ++iBit )\n                    {\n                        // TODO(schwehr): Revisit this block.\n                        if( nInWord &\n                            (1 << (poGDS->nBitsPerSample - 1 - iBit)) )\n                        {\n                            poGDS->pabyBlockBuf[iBitOffset>>3] |=\n                                ( 0x80 >> (iBitOffset & 7) );\n                        }\n                        else\n                        {\n                            // We must explicitly unset the bit as we\n                            // may update an existing block.\n                            poGDS->pabyBlockBuf[iBitOffset>>3] &=\n                                ~(0x80 >>(iBitOffset & 7));\n                        }\n\n                        ++iBitOffset;\n                    }\n                }\n\n                iBitOffset = iBitOffset + iPixelBitSkip - poGDS->nBitsPerSample;\n            }\n        }\n\n        if( poBlock != nullptr )\n        {\n            poBlock->MarkClean();\n            poBlock->DropLock();\n        }\n    }\n\n    poGDS->bLoadedBlockDirty = true;\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                             IReadBlock()                             */\n/************************************************************************/\n\nstatic void ExpandPacked8ToByte1( const GByte * const CPL_RESTRICT pabySrc,\n                                  GByte* const CPL_RESTRICT pabyDest,\n                                  int nBytes )\n{\n    for( int i = 0, j = 0; i < nBytes; i++, j+= 8 )\n    {\n        const GByte byVal = pabySrc[i];\n        pabyDest[j+0] = (byVal >> 7) & 0x1;\n        pabyDest[j+1] = (byVal >> 6) & 0x1;\n        pabyDest[j+2] = (byVal >> 5) & 0x1;\n        pabyDest[j+3] = (byVal >> 4) & 0x1;\n        pabyDest[j+4] = (byVal >> 3) & 0x1;\n        pabyDest[j+5] = (byVal >> 2) & 0x1;\n        pabyDest[j+6] = (byVal >> 1) & 0x1;\n        pabyDest[j+7] = (byVal >> 0) & 0x1;\n    }\n}\n\n#if defined(__GNUC__) || defined(_MSC_VER)\n// Signedness of char implementation dependent, so be explicit.\n// Assumes 2-complement integer types and sign extension of right shifting\n// GCC guarantees such:\n// https://gcc.gnu.org/onlinedocs/gcc/Integers-implementation.html#Integers-implementation\nstatic inline GByte ExtractBitAndConvertTo255(GByte byVal, int nBit)\n{\n    return\n        static_cast<GByte>(static_cast<signed char>(byVal << (7 - nBit)) >> 7);\n}\n#else\n// Portable way\nstatic inline GByte ExtractBitAndConvertTo255(GByte byVal, int nBit)\n{\n    return (byVal & (1 << nBit)) ? 255 : 0;\n}\n#endif\n\nstatic void ExpandPacked8ToByte255( const GByte * const CPL_RESTRICT pabySrc,\n                                    GByte* const CPL_RESTRICT pabyDest,\n                                    int nBytes )\n{\n    for( int i = 0, j = 0; i < nBytes; i++, j += 8 )\n    {\n        const GByte byVal = pabySrc[i];\n        pabyDest[j+0] = ExtractBitAndConvertTo255(byVal, 7);\n        pabyDest[j+1] = ExtractBitAndConvertTo255(byVal, 6);\n        pabyDest[j+2] = ExtractBitAndConvertTo255(byVal, 5);\n        pabyDest[j+3] = ExtractBitAndConvertTo255(byVal, 4);\n        pabyDest[j+4] = ExtractBitAndConvertTo255(byVal, 3);\n        pabyDest[j+5] = ExtractBitAndConvertTo255(byVal, 2);\n        pabyDest[j+6] = ExtractBitAndConvertTo255(byVal, 1);\n        pabyDest[j+7] = ExtractBitAndConvertTo255(byVal, 0);\n    }\n}\n\nCPLErr GTiffOddBitsBand::IReadBlock( int nBlockXOff, int nBlockYOff,\n                                     void * pImage )\n\n{\n    if( !poGDS->SetDirectory() )\n        return CE_Failure;\n\n    CPLAssert(nBlocksPerRow != 0);\n    int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n\n    if( poGDS->nPlanarConfig == PLANARCONFIG_SEPARATE )\n        nBlockId += (nBand - 1) * poGDS->nBlocksPerBand;\n\n/* -------------------------------------------------------------------- */\n/*      Handle the case of a strip in a writable file that doesn't      */\n/*      exist yet, but that we want to read.  Just set to zeros and     */\n/*      return.                                                         */\n/* -------------------------------------------------------------------- */\n    if( nBlockId != poGDS->nLoadedBlock )\n    {\n        bool bErrOccurred = false;\n        if( !poGDS->IsBlockAvailable(nBlockId, nullptr, nullptr, &bErrOccurred) )\n        {\n            NullBlock( pImage );\n            if( bErrOccurred )\n                return CE_Failure;\n            return CE_None;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Load the block buffer.                                          */\n/* -------------------------------------------------------------------- */\n    {\n        const CPLErr eErr = poGDS->LoadBlockBuf( nBlockId );\n        if( eErr != CE_None )\n            return eErr;\n    }\n\n    if( poGDS->nBitsPerSample == 1 &&\n        (poGDS->nBands == 1 || poGDS->nPlanarConfig == PLANARCONFIG_SEPARATE ) )\n    {\n/* -------------------------------------------------------------------- */\n/*      Translate 1bit data to eight bit.                               */\n/* -------------------------------------------------------------------- */\n        int iDstOffset = 0;\n        const GByte * const CPL_RESTRICT pabyBlockBuf = poGDS->pabyBlockBuf;\n        GByte* CPL_RESTRICT pabyDest = static_cast<GByte *>(pImage);\n\n        for( int iLine = 0; iLine < nBlockYSize; ++iLine )\n        {\n            int iSrcOffsetByte = ((nBlockXSize + 7) >> 3) * iLine;\n\n            if( !poGDS->bPromoteTo8Bits )\n            {\n                ExpandPacked8ToByte1( pabyBlockBuf + iSrcOffsetByte,\n                                      pabyDest + iDstOffset,\n                                      nBlockXSize / 8 );\n            }\n            else\n            {\n                ExpandPacked8ToByte255( pabyBlockBuf + iSrcOffsetByte,\n                                        pabyDest + iDstOffset,\n                                        nBlockXSize / 8 );\n            }\n            int iSrcOffsetBit = (iSrcOffsetByte + nBlockXSize / 8) * 8;\n            iDstOffset += nBlockXSize & ~0x7;\n            const GByte bSetVal = poGDS->bPromoteTo8Bits ? 255 : 1;\n            for( int iPixel = nBlockXSize & ~0x7 ;\n                 iPixel < nBlockXSize;\n                 ++iPixel, ++iSrcOffsetBit )\n            {\n                if( pabyBlockBuf[iSrcOffsetBit >>3] &\n                    (0x80 >> (iSrcOffsetBit & 0x7)) )\n                    static_cast<GByte *>(pImage)[iDstOffset++] = bSetVal;\n                else\n                    static_cast<GByte *>(pImage)[iDstOffset++] = 0;\n            }\n        }\n    }\n/* -------------------------------------------------------------------- */\n/*      Handle the case of 16- and 24-bit floating point data as per    */\n/*      TIFF Technical Note 3.                                          */\n/* -------------------------------------------------------------------- */\n    else if( eDataType == GDT_Float32 )\n    {\n        const int nWordBytes = poGDS->nBitsPerSample / 8;\n        const GByte *pabyImage = poGDS->pabyBlockBuf +\n            ( ( poGDS->nPlanarConfig == PLANARCONFIG_SEPARATE ) ? 0 :\n              (nBand - 1) * nWordBytes );\n        const int iSkipBytes =\n            ( poGDS->nPlanarConfig == PLANARCONFIG_SEPARATE ) ?\n            nWordBytes : poGDS->nBands * nWordBytes;\n\n        const int nBlockPixels = nBlockXSize * nBlockYSize;\n        if( poGDS->nBitsPerSample == 16 )\n        {\n            for( int i = 0; i < nBlockPixels; ++i )\n            {\n                static_cast<GUInt32 *>(pImage)[i] =\n                    HalfToFloat( *reinterpret_cast<const GUInt16 *>(pabyImage) );\n                pabyImage += iSkipBytes;\n            }\n        }\n        else if( poGDS->nBitsPerSample == 24 )\n        {\n            for( int i = 0; i < nBlockPixels; ++i )\n            {\n#ifdef CPL_MSB\n                static_cast<GUInt32 *>(pImage)[i] =\n                    TripleToFloat(\n                        ( static_cast<GUInt32>(*(pabyImage + 0)) << 16)\n                        | (static_cast<GUInt32>(*(pabyImage + 1)) << 8)\n                        | static_cast<GUInt32>(*(pabyImage + 2)) );\n#else\n                static_cast<GUInt32 *>(pImage)[i] =\n                    TripleToFloat(\n                        ( static_cast<GUInt32>(*(pabyImage + 2)) << 16)\n                        | (static_cast<GUInt32>(*(pabyImage + 1)) << 8)\n                        | static_cast<GUInt32>(*pabyImage) );\n#endif\n                pabyImage += iSkipBytes;\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Special case for moving 12bit data somewhat more efficiently.   */\n/* -------------------------------------------------------------------- */\n    else if( poGDS->nBitsPerSample == 12 )\n    {\n        int iPixelBitSkip = 0;\n        int iBandBitOffset = 0;\n\n        if( poGDS->nPlanarConfig == PLANARCONFIG_CONTIG )\n        {\n            iPixelBitSkip = poGDS->nBands * poGDS->nBitsPerSample;\n            iBandBitOffset = (nBand - 1) * poGDS->nBitsPerSample;\n        }\n        else\n        {\n            iPixelBitSkip = poGDS->nBitsPerSample;\n        }\n\n        // Bits per line rounds up to next byte boundary.\n        int nBitsPerLine = nBlockXSize * iPixelBitSkip;\n        if( (nBitsPerLine & 7) != 0 )\n            nBitsPerLine = (nBitsPerLine + 7) & (~7);\n\n        int iPixel = 0;\n        for( int iY = 0; iY < nBlockYSize; ++iY )\n        {\n            int iBitOffset = iBandBitOffset + iY * nBitsPerLine;\n\n            for( int iX = 0; iX < nBlockXSize; ++iX )\n            {\n                const int iByte = iBitOffset >> 3;\n\n                if( (iBitOffset & 0x7) == 0 )\n                {\n                    // Starting on byte boundary.\n\n                    static_cast<GUInt16 *>(pImage)[iPixel++] =\n                        (poGDS->pabyBlockBuf[iByte] << 4)\n                        | (poGDS->pabyBlockBuf[iByte+1] >> 4);\n                }\n                else\n                {\n                    // Starting off byte boundary.\n\n                    static_cast<GUInt16 *>(pImage)[iPixel++] =\n                        ((poGDS->pabyBlockBuf[iByte] & 0xf) << 8)\n                        | (poGDS->pabyBlockBuf[iByte+1]);\n                }\n                iBitOffset += iPixelBitSkip;\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Special case for 24bit data which is pre-byteswapped since      */\n/*      the size falls on a byte boundary ... ugh (#2361).              */\n/* -------------------------------------------------------------------- */\n    else if( poGDS->nBitsPerSample == 24 )\n    {\n        int iPixelByteSkip = 0;\n        int iBandByteOffset = 0;\n\n        if( poGDS->nPlanarConfig == PLANARCONFIG_CONTIG )\n        {\n            iPixelByteSkip = (poGDS->nBands * poGDS->nBitsPerSample) / 8;\n            iBandByteOffset = ((nBand - 1) * poGDS->nBitsPerSample) / 8;\n        }\n        else\n        {\n            iPixelByteSkip = poGDS->nBitsPerSample / 8;\n        }\n\n        const int nBytesPerLine = nBlockXSize * iPixelByteSkip;\n\n        int iPixel = 0;\n        for( int iY = 0; iY < nBlockYSize; ++iY )\n        {\n            GByte *pabyImage =\n                poGDS->pabyBlockBuf + iBandByteOffset + iY * nBytesPerLine;\n\n            for( int iX = 0; iX < nBlockXSize; ++iX )\n            {\n#ifdef CPL_MSB\n                static_cast<GUInt32 *>(pImage)[iPixel++] =\n                    ( static_cast<GUInt32>(*(pabyImage + 2)) << 16)\n                    | (static_cast<GUInt32>(*(pabyImage + 1)) << 8)\n                    | static_cast<GUInt32>(*(pabyImage + 0));\n#else\n                static_cast<GUInt32 *>(pImage)[iPixel++] =\n                    ( static_cast<GUInt32>(*(pabyImage + 0)) << 16)\n                    | (static_cast<GUInt32>(*(pabyImage + 1)) << 8)\n                    | static_cast<GUInt32>(*(pabyImage + 2));\n#endif\n                pabyImage += iPixelByteSkip;\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Handle 1-32 bit integer data.                                   */\n/* -------------------------------------------------------------------- */\n    else\n    {\n        unsigned iPixelBitSkip = 0;\n        unsigned iBandBitOffset = 0;\n\n        if( poGDS->nPlanarConfig == PLANARCONFIG_CONTIG )\n        {\n            iPixelBitSkip = poGDS->nBands * poGDS->nBitsPerSample;\n            iBandBitOffset = (nBand - 1) * poGDS->nBitsPerSample;\n        }\n        else\n        {\n            iPixelBitSkip = poGDS->nBitsPerSample;\n        }\n\n        // Bits per line rounds up to next byte boundary.\n        GUIntBig nBitsPerLine = static_cast<GUIntBig>(nBlockXSize) * iPixelBitSkip;\n        if( (nBitsPerLine & 7) != 0 )\n            nBitsPerLine = (nBitsPerLine + 7) & (~7);\n\n        const GByte * const pabyBlockBuf = poGDS->pabyBlockBuf;\n        const unsigned nBitsPerSample = poGDS->nBitsPerSample;\n        unsigned iPixel = 0;\n\n        if( nBitsPerSample == 1 && eDataType == GDT_Byte )\n        {\n          for( unsigned iY = 0; iY < static_cast<unsigned>(nBlockYSize); ++iY )\n          {\n            GUIntBig iBitOffset = iBandBitOffset + iY * nBitsPerLine;\n\n            for( unsigned iX = 0; iX < static_cast<unsigned>(nBlockXSize); ++iX )\n            {\n                if( pabyBlockBuf[iBitOffset>>3] & (0x80 >>(iBitOffset & 7)) )\n                    static_cast<GByte *>(pImage)[iPixel] = 1;\n                else\n                    static_cast<GByte *>(pImage)[iPixel] = 0;\n                iBitOffset += iPixelBitSkip;\n                iPixel++;\n            }\n          }\n        }\n        else\n        {\n          for( unsigned iY = 0; iY < static_cast<unsigned>(nBlockYSize); ++iY )\n          {\n            GUIntBig iBitOffset = iBandBitOffset + iY * nBitsPerLine;\n\n            for( unsigned iX = 0; iX < static_cast<unsigned>(nBlockXSize); ++iX )\n            {\n                unsigned nOutWord = 0;\n\n                for( unsigned iBit = 0; iBit < nBitsPerSample; ++iBit )\n                {\n                    if( pabyBlockBuf[iBitOffset>>3]\n                        & (0x80 >>(iBitOffset & 7)) )\n                        nOutWord |= (1 << (nBitsPerSample - 1 - iBit));\n                    ++iBitOffset;\n                }\n\n                iBitOffset = iBitOffset + iPixelBitSkip - nBitsPerSample;\n\n                if( eDataType == GDT_Byte )\n                {\n                    static_cast<GByte *>(pImage)[iPixel++] =\n                        static_cast<GByte>(nOutWord);\n                }\n                else if( eDataType == GDT_UInt16 )\n                {\n                  static_cast<GUInt16 *>(pImage)[iPixel++] =\n                      static_cast<GUInt16>(nOutWord);\n                }\n                else if( eDataType == GDT_UInt32 )\n                {\n                  static_cast<GUInt32 *>(pImage)[iPixel++] = nOutWord;\n                }\n                else\n                {\n                    CPLAssert(false);\n                }\n            }\n          }\n        }\n    }\n\n    return CE_None;\n}\n\n/************************************************************************/\n/* ==================================================================== */\n/*                             GTiffBitmapBand                          */\n/* ==================================================================== */\n/************************************************************************/\n\nclass GTiffBitmapBand : public GTiffOddBitsBand\n{\n    friend class GTiffDataset;\n\n    GDALColorTable *poColorTable = nullptr;\n\n    CPL_DISALLOW_COPY_ASSIGN(GTiffBitmapBand)\n\n  public:\n\n                   GTiffBitmapBand( GTiffDataset *, int );\n    virtual       ~GTiffBitmapBand();\n\n    virtual GDALColorInterp GetColorInterpretation() override;\n    virtual GDALColorTable *GetColorTable() override;\n};\n\n/************************************************************************/\n/*                           GTiffBitmapBand()                          */\n/************************************************************************/\n\nGTiffBitmapBand::GTiffBitmapBand( GTiffDataset *poDSIn, int nBandIn )\n        : GTiffOddBitsBand( poDSIn, nBandIn )\n\n{\n    eDataType = GDT_Byte;\n\n    if( poDSIn->poColorTable != nullptr )\n    {\n        poColorTable = poDSIn->poColorTable->Clone();\n    }\n    else\n    {\n#ifdef ESRI_BUILD\n        poColorTable = nullptr;\n#else\n        const GDALColorEntry oWhite = { 255, 255, 255, 255 };\n        const GDALColorEntry oBlack = { 0, 0, 0, 255 };\n\n        poColorTable = new GDALColorTable();\n\n        if( poDSIn->nPhotometric == PHOTOMETRIC_MINISWHITE )\n        {\n            poColorTable->SetColorEntry( 0, &oWhite );\n            poColorTable->SetColorEntry( 1, &oBlack );\n        }\n        else\n        {\n            poColorTable->SetColorEntry( 0, &oBlack );\n            poColorTable->SetColorEntry( 1, &oWhite );\n        }\n#endif  // not defined ESRI_BUILD.\n    }\n}\n\n/************************************************************************/\n/*                          ~GTiffBitmapBand()                          */\n/************************************************************************/\n\nGTiffBitmapBand::~GTiffBitmapBand()\n\n{\n    delete poColorTable;\n}\n\n/************************************************************************/\n/*                       GetColorInterpretation()                       */\n/************************************************************************/\n\nGDALColorInterp GTiffBitmapBand::GetColorInterpretation()\n\n{\n    if( poGDS->bPromoteTo8Bits )\n        return GCI_Undefined;\n\n    return GCI_PaletteIndex;\n}\n\n/************************************************************************/\n/*                           GetColorTable()                            */\n/************************************************************************/\n\nGDALColorTable *GTiffBitmapBand::GetColorTable()\n\n{\n    if( poGDS->bPromoteTo8Bits )\n        return nullptr;\n\n    return poColorTable;\n}\n\n/************************************************************************/\n/* ==================================================================== */\n/*                          GTiffSplitBitmapBand                        */\n/* ==================================================================== */\n/************************************************************************/\n\nclass GTiffSplitBitmapBand final : public GTiffBitmapBand\n{\n    friend class GTiffDataset;\n    int nLastLineValid;\n\n  public:\n\n                   GTiffSplitBitmapBand( GTiffDataset *, int );\n    virtual       ~GTiffSplitBitmapBand();\n\n    virtual int IGetDataCoverageStatus( int nXOff, int nYOff,\n                                        int nXSize, int nYSize,\n                                        int nMaskFlagStop,\n                                        double* pdfDataPct) override;\n\n    virtual CPLErr IReadBlock( int, int, void * ) override;\n    virtual CPLErr IWriteBlock( int, int, void * ) override;\n};\n\n/************************************************************************/\n/*                       GTiffSplitBitmapBand()                         */\n/************************************************************************/\n\nGTiffSplitBitmapBand::GTiffSplitBitmapBand( GTiffDataset *poDSIn, int nBandIn )\n        : GTiffBitmapBand( poDSIn, nBandIn )\n        , nLastLineValid( -1 )\n\n{\n    nBlockXSize = poDS->GetRasterXSize();\n    nBlockYSize = 1;\n}\n\n/************************************************************************/\n/*                      ~GTiffSplitBitmapBand()                         */\n/************************************************************************/\n\nGTiffSplitBitmapBand::~GTiffSplitBitmapBand() {}\n\n\n/************************************************************************/\n/*                       IGetDataCoverageStatus()                       */\n/************************************************************************/\n\nint GTiffSplitBitmapBand::IGetDataCoverageStatus( int , int ,\n                                             int , int ,\n                                             int ,\n                                             double* )\n{\n     return GDAL_DATA_COVERAGE_STATUS_UNIMPLEMENTED |\n            GDAL_DATA_COVERAGE_STATUS_DATA;\n}\n\n/************************************************************************/\n/*                            GTIFFErrorHandler()                       */\n/************************************************************************/\n\nnamespace {\nclass GTIFFErrorStruct final\n{\n  public:\n    CPLErr type;\n    CPLErrorNum no;\n    CPLString msg{};\n\n    GTIFFErrorStruct() : type(CE_None), no(CPLE_None) {}\n    GTIFFErrorStruct(CPLErr eErrIn, CPLErrorNum noIn, const char* msgIn) :\n        type(eErrIn), no(noIn), msg(msgIn) {}\n};\n}\n\nstatic void CPL_STDCALL GTIFFErrorHandler( CPLErr eErr, CPLErrorNum no,\n                                           const char* msg )\n{\n    std::vector<GTIFFErrorStruct>* paoErrors =\n        static_cast<std::vector<GTIFFErrorStruct> *>(\n            CPLGetErrorHandlerUserData());\n    paoErrors->push_back(GTIFFErrorStruct(eErr, no, msg));\n}\n\n/************************************************************************/\n/*                             IReadBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffSplitBitmapBand::IReadBlock( int /* nBlockXOff */, int nBlockYOff,\n                                         void * pImage )\n\n{\n    if( nLastLineValid >= 0 && nBlockYOff > nLastLineValid )\n        return CE_Failure;\n\n    if( !poGDS->SetDirectory() )\n        return CE_Failure;\n\n    if( poGDS->pabyBlockBuf == nullptr )\n    {\n        poGDS->pabyBlockBuf =\n            static_cast<GByte *>(\n                VSI_MALLOC_VERBOSE(TIFFScanlineSize(poGDS->hTIFF)) );\n        if( poGDS->pabyBlockBuf == nullptr )\n        {\n            return CE_Failure;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Read through to target scanline.                                */\n/* -------------------------------------------------------------------- */\n    if( poGDS->nLastLineRead >= nBlockYOff )\n        poGDS->nLastLineRead = -1;\n\n    while( poGDS->nLastLineRead < nBlockYOff )\n    {\n        ++poGDS->nLastLineRead;\n\n        std::vector<GTIFFErrorStruct> aoErrors;\n        CPLPushErrorHandlerEx(GTIFFErrorHandler, &aoErrors);\n        int nRet = TIFFReadScanline( poGDS->hTIFF, poGDS->pabyBlockBuf,\n                                     poGDS->nLastLineRead, 0 );\n        CPLPopErrorHandler();\n\n        for( size_t iError = 0; iError < aoErrors.size(); ++iError )\n        {\n            CPLError( aoErrors[iError].type,\n                      aoErrors[iError].no,\n                      \"%s\",\n                      aoErrors[iError].msg.c_str() );\n            // FAX decoding only handles EOF condition as a warning, so\n            // catch it so as to turn on error when attempting to read\n            // following lines, to avoid performance issues.\n            if(  !poGDS->bIgnoreReadErrors &&\n                    aoErrors[iError].msg.find(\"Premature EOF\") !=\n                                                    std::string::npos )\n            {\n                nLastLineValid = nBlockYOff;\n                nRet = -1;\n            }\n        }\n\n        if( nRet == -1\n            && !poGDS->bIgnoreReadErrors )\n        {\n            CPLError( CE_Failure, CPLE_AppDefined,\n                      \"TIFFReadScanline() failed.\" );\n            poGDS->nLastLineRead = -1;\n            return CE_Failure;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Translate 1bit data to eight bit.                               */\n/* -------------------------------------------------------------------- */\n    int iSrcOffset = 0;\n    int iDstOffset = 0;\n\n    for( int iPixel = 0; iPixel < nBlockXSize; ++iPixel, ++iSrcOffset )\n    {\n        if( poGDS->pabyBlockBuf[iSrcOffset >>3] & (0x80 >> (iSrcOffset & 0x7)) )\n            static_cast<GByte *>(pImage)[iDstOffset++] = 1;\n        else\n            static_cast<GByte *>(pImage)[iDstOffset++] = 0;\n    }\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                            IWriteBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffSplitBitmapBand::IWriteBlock( int /* nBlockXOff */,\n                                          int /* nBlockYOff */,\n                                          void * /* pImage */ )\n\n{\n    CPLError( CE_Failure, CPLE_AppDefined,\n              \"Split bitmap bands are read-only.\" );\n    return CE_Failure;\n}\n\n/************************************************************************/\n/* ==================================================================== */\n/*                            GTiffDataset                              */\n/* ==================================================================== */\n/************************************************************************/\n\n/************************************************************************/\n/*                            GTiffDataset()                            */\n/************************************************************************/\n\nGTiffDataset::GTiffDataset() :\n    hTIFF(nullptr),\n    fpL(nullptr),\n#if defined(INTERNAL_LIBTIFF) && defined(DEFER_STRILE_LOAD)\n    nStripArrayAlloc(0),\n    m_nFileSize(0),\n#endif\n    bStreamingIn(false),\n    bStreamingOut(false),\n    fpToWrite(nullptr),\n    nLastWrittenBlockId(-1),\n    ppoActiveDSRef(nullptr),\n    poActiveDS(nullptr),\n    bScanDeferred(true),\n    nDirOffset(0),\n    bBase(true),\n    bCloseTIFFHandle(false),\n    nPlanarConfig(0),\n    nSamplesPerPixel(0),\n    nBitsPerSample(0),\n    nRowsPerStrip(0),\n    nPhotometric(0),\n    nSampleFormat(0),\n    nCompression(0),\n    nBlocksPerBand(0),\n    nBlockXSize(0),\n    nBlockYSize(0),\n    nLoadedBlock(-1),\n    bLoadedBlockDirty(false),\n    pabyBlockBuf(nullptr),\n    bWriteErrorInFlushBlockBuf(false),\n    pszProjection(CPLStrdup(\"\")),\n    bLookedForProjection(false),\n    bLookedForMDAreaOrPoint(false),\n    bGeoTransformValid(false),\n    bTreatAsRGBA(false),\n    bCrystalized(true),\n    poColorTable(nullptr),\n    nOverviewCount(0),\n    papoOverviewDS(nullptr),\n    nJPEGOverviewVisibilityCounter(0),\n    nJPEGOverviewCount(-1),\n    nJPEGOverviewCountOri(0),\n    papoJPEGOverviewDS(nullptr),\n    nGCPCount(0),\n    pasGCPList(nullptr),\n    bGeoTIFFInfoChanged(false),\n    bForceUnsetGTOrGCPs(false),\n    bForceUnsetProjection(false),\n    bNoDataChanged(false),\n    bNoDataSet(false),\n    dfNoDataValue(-9999.0),\n    bMetadataChanged(false),\n    bColorProfileMetadataChanged(false),\n    bNeedsRewrite(false),\n    osProfile(szPROFILE_GDALGeoTIFF),\n    papszCreationOptions(nullptr),\n    bLoadingOtherBands(false),\n    pabyTempWriteBuffer(nullptr),\n    nTempWriteBufferSize(0),\n    poMaskDS(nullptr),\n    poBaseDS(nullptr),\n    bWriteEmptyTiles(true),\n    bFillEmptyTilesAtClosing(false),\n    nLastLineRead(-1),\n    nLastBandRead(-1),\n    bTreatAsSplit(false),\n    bTreatAsSplitBitmap(false),\n    bClipWarn(false),\n    bIMDRPCMetadataLoaded(false),\n    papszMetadataFiles(nullptr),\n    bEXIFMetadataLoaded(false),\n    bICCMetadataLoaded(false),\n    bHasWarnedDisableAggressiveBandCaching(false),\n    bDontReloadFirstBlock(false),\n    nZLevel(-1),\n    nLZMAPreset(-1),\n    nZSTDLevel(-1),\n    nWebPLevel(-1),\n    bWebPLossless(false),\n    nJpegQuality(-1),\n    nJpegTablesMode(-1),\n    bPromoteTo8Bits(false),\n    bDebugDontWriteBlocks(false),\n    bIsFinalized(false),\n    bIgnoreReadErrors(false),\n    bDirectIO(false),\n    eVirtualMemIOUsage(VIRTUAL_MEM_IO_NO),\n    psVirtualMemIOMapping(nullptr),\n    eGeoTIFFKeysFlavor(GEOTIFF_KEYS_STANDARD),\n    pBaseMapping(nullptr),\n    nRefBaseMapping(0),\n    bHasDiscardedLsb(false),\n    poCompressThreadPool(nullptr),\n    hCompressThreadPoolMutex(nullptr),\n    m_pTempBufferForCommonDirectIO(nullptr),\n    m_nTempBufferForCommonDirectIOSize(0),\n    m_bReadGeoTransform(false),\n    m_bLoadPam(false),\n    m_bHasGotSiblingFiles(false),\n    m_bHasIdentifiedAuthorizedGeoreferencingSources(false),\n    m_nPAMGeorefSrcIndex(-1),\n    m_nINTERNALGeorefSrcIndex(-1),\n    m_nTABFILEGeorefSrcIndex(-1),\n    m_nWORLDFILEGeorefSrcIndex(-1),\n    m_nGeoTransformGeorefSrcIndex(-1)\n{\n    adfGeoTransform[0] = 0.0;\n    adfGeoTransform[1] = 1.0;\n    adfGeoTransform[2] = 0.0;\n    adfGeoTransform[3] = 0.0;\n    adfGeoTransform[4] = 0.0;\n    adfGeoTransform[5] = 1.0;\n\n    bDebugDontWriteBlocks =\n        CPLTestBool(CPLGetConfigOption(\"GTIFF_DONT_WRITE_BLOCKS\", \"NO\"));\n\n    bIgnoreReadErrors =\n        CPLTestBool(CPLGetConfigOption(\"GTIFF_IGNORE_READ_ERRORS\", \"NO\"));\n\n    bDirectIO = CPLTestBool(CPLGetConfigOption(\"GTIFF_DIRECT_IO\", \"NO\"));\n\n    const char* pszVirtualMemIO =\n        CPLGetConfigOption(\"GTIFF_VIRTUAL_MEM_IO\", \"NO\");\n    if( EQUAL(pszVirtualMemIO, \"IF_ENOUGH_RAM\") )\n        eVirtualMemIOUsage = VIRTUAL_MEM_IO_IF_ENOUGH_RAM;\n    else if( CPLTestBool(pszVirtualMemIO) )\n        eVirtualMemIOUsage = VIRTUAL_MEM_IO_YES;\n}\n\n/************************************************************************/\n/*                           ~GTiffDataset()                            */\n/************************************************************************/\n\nGTiffDataset::~GTiffDataset()\n\n{\n    Finalize();\n    if( !osTmpFilename.empty() )\n        VSIUnlink(osTmpFilename);\n}\n\n/************************************************************************/\n/*                             Finalize()                               */\n/************************************************************************/\n\nint GTiffDataset::Finalize()\n{\n    if( bIsFinalized )\n        return FALSE;\n\n    bool bHasDroppedRef = false;\n\n    Crystalize();\n\n    if( bColorProfileMetadataChanged )\n    {\n        SaveICCProfile(this, nullptr, nullptr, 0);\n        bColorProfileMetadataChanged = false;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Handle forcing xml:ESRI data to be written to PAM.              */\n/* -------------------------------------------------------------------- */\n    if( CPLTestBool(CPLGetConfigOption( \"ESRI_XML_PAM\", \"NO\" )) )\n    {\n        char **papszESRIMD = GTiffDataset::GetMetadata(\"xml:ESRI\");\n        if( papszESRIMD )\n        {\n            GDALPamDataset::SetMetadata( papszESRIMD, \"xml:ESRI\");\n        }\n    }\n\n    if( psVirtualMemIOMapping )\n        CPLVirtualMemFree( psVirtualMemIOMapping );\n    psVirtualMemIOMapping = nullptr;\n\n/* -------------------------------------------------------------------- */\n/*      Fill in missing blocks with empty data.                         */\n/* -------------------------------------------------------------------- */\n    if( bFillEmptyTilesAtClosing )\n    {\n/* -------------------------------------------------------------------- */\n/*  Ensure any blocks write cached by GDAL gets pushed through libtiff. */\n/* -------------------------------------------------------------------- */\n        FlushCacheInternal( false /* do not call FlushDirectory */ );\n\n        FillEmptyTiles();\n        bFillEmptyTilesAtClosing = false;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Force a complete flush, including either rewriting(moving)      */\n/*      of writing in place the current directory.                      */\n/* -------------------------------------------------------------------- */\n    FlushCacheInternal( true );\n\n    // Destroy compression pool.\n    if( poCompressThreadPool )\n    {\n        poCompressThreadPool->WaitCompletion();\n\n        // Save thread pool for later reuse.\n        {\n            std::lock_guard<std::mutex> oLock(gMutexThreadPool);\n            delete gpoCompressThreadPool;\n            gpoCompressThreadPool = poCompressThreadPool;\n            poCompressThreadPool = nullptr;\n        }\n\n        for( int i = 0; i < static_cast<int>(asCompressionJobs.size()); ++i )\n        {\n            CPLFree(asCompressionJobs[i].pabyBuffer);\n            if( asCompressionJobs[i].pszTmpFilename )\n            {\n                VSIUnlink(asCompressionJobs[i].pszTmpFilename);\n                CPLFree(asCompressionJobs[i].pszTmpFilename);\n            }\n        }\n        CPLDestroyMutex(hCompressThreadPoolMutex);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If there is still changed metadata, then presumably we want     */\n/*      to push it into PAM.                                            */\n/* -------------------------------------------------------------------- */\n    if( bMetadataChanged )\n    {\n        PushMetadataToPam();\n        bMetadataChanged = false;\n        GDALPamDataset::FlushCache();\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Cleanup overviews.                                              */\n/* -------------------------------------------------------------------- */\n    if( bBase )\n    {\n        for( int i = 0; i < nOverviewCount; ++i )\n        {\n            delete papoOverviewDS[i];\n            bHasDroppedRef = true;\n        }\n        nOverviewCount = 0;\n\n        for( int i = 0; i < nJPEGOverviewCountOri; ++i )\n        {\n            delete papoJPEGOverviewDS[i];\n            bHasDroppedRef = true;\n        }\n        nJPEGOverviewCount = 0;\n        nJPEGOverviewCountOri = 0;\n        CPLFree( papoJPEGOverviewDS );\n        papoJPEGOverviewDS = nullptr;\n    }\n\n    // If we are a mask dataset, we can have overviews, but we don't\n    // own them. We can only free the array, not the overviews themselves.\n    CPLFree( papoOverviewDS );\n    papoOverviewDS = nullptr;\n\n    // poMaskDS is owned by the main image and the overviews\n    // so because of the latter case, we can delete it even if\n    // we are not the base image.\n    if( poMaskDS )\n    {\n        delete poMaskDS;\n        poMaskDS = nullptr;\n        bHasDroppedRef = true;\n    }\n\n    if( poColorTable != nullptr )\n        delete poColorTable;\n    poColorTable = nullptr;\n\n    if( bBase || bCloseTIFFHandle )\n    {\n        XTIFFClose( hTIFF );\n        hTIFF = nullptr;\n        if( fpL != nullptr )\n        {\n            if( VSIFCloseL( fpL ) != 0 )\n            {\n                CPLError(CE_Failure, CPLE_FileIO, \"I/O error\");\n            }\n            fpL = nullptr;\n        }\n    }\n\n    if( fpToWrite != nullptr )\n    {\n        if( VSIFCloseL( fpToWrite ) != 0 )\n        {\n            CPLError(CE_Failure, CPLE_FileIO, \"I/O error\");\n        }\n        fpToWrite = nullptr;\n    }\n\n    if( nGCPCount > 0 )\n    {\n        GDALDeinitGCPs( nGCPCount, pasGCPList );\n        CPLFree( pasGCPList );\n        pasGCPList = nullptr;\n        nGCPCount = 0;\n    }\n\n    CPLFree( pszProjection );\n    pszProjection = nullptr;\n\n    CSLDestroy( papszCreationOptions );\n    papszCreationOptions = nullptr;\n\n    CPLFree(pabyTempWriteBuffer);\n    pabyTempWriteBuffer = nullptr;\n\n    if( ppoActiveDSRef != nullptr && *ppoActiveDSRef == this )\n        *ppoActiveDSRef = nullptr;\n    ppoActiveDSRef = nullptr;\n\n    bIMDRPCMetadataLoaded = false;\n    CSLDestroy(papszMetadataFiles);\n    papszMetadataFiles = nullptr;\n\n    VSIFree(m_pTempBufferForCommonDirectIO);\n    m_pTempBufferForCommonDirectIO = nullptr;\n\n    bIsFinalized = true;\n\n    return bHasDroppedRef;\n}\n\n/************************************************************************/\n/*                        CloseDependentDatasets()                      */\n/************************************************************************/\n\nint GTiffDataset::CloseDependentDatasets()\n{\n    if( !bBase )\n        return FALSE;\n\n    int bHasDroppedRef = GDALPamDataset::CloseDependentDatasets();\n\n    bHasDroppedRef |= Finalize();\n\n    return bHasDroppedRef;\n}\n\n/************************************************************************/\n/*                        GetJPEGOverviewCount()                        */\n/************************************************************************/\n\nint GTiffDataset::GetJPEGOverviewCount()\n{\n    if( nJPEGOverviewCount >= 0 )\n        return nJPEGOverviewCount;\n\n    nJPEGOverviewCount = 0;\n    if( !bBase || eAccess != GA_ReadOnly || nCompression != COMPRESSION_JPEG ||\n        (nRasterXSize < 256 && nRasterYSize < 256) ||\n        !CPLTestBool(CPLGetConfigOption(\"GTIFF_IMPLICIT_JPEG_OVR\", \"YES\")) ||\n        GDALGetDriverByName(\"JPEG\") == nullptr )\n    {\n        return 0;\n    }\n    const char* pszSourceColorSpace =\n        oGTiffMDMD.GetMetadataItem( \"SOURCE_COLOR_SPACE\", \"IMAGE_STRUCTURE\" );\n    if( pszSourceColorSpace != nullptr && EQUAL(pszSourceColorSpace, \"CMYK\") )\n    {\n        // We cannot handle implicit overviews on JPEG CMYK datasets converted\n        // to RGBA This would imply doing the conversion in\n        // GTiffJPEGOverviewBand.\n        return 0;\n    }\n\n    // libjpeg-6b only supports 2, 4 and 8 scale denominators.\n    // TODO: Later versions support more.\n    for( int i = 2; i >= 0; i-- )\n    {\n        if( nRasterXSize >= (256 << i) || nRasterYSize >= (256 << i) )\n        {\n            nJPEGOverviewCount = i + 1;\n            break;\n        }\n    }\n    if( nJPEGOverviewCount == 0 )\n        return 0;\n\n    if( !SetDirectory() )\n    {\n        nJPEGOverviewCount = 0;\n        return 0;\n    }\n\n    // Get JPEG tables.\n    uint32 nJPEGTableSize = 0;\n    void* pJPEGTable = nullptr;\n    GByte abyFFD8[] = { 0xFF, 0xD8 };\n    if( TIFFGetField(hTIFF, TIFFTAG_JPEGTABLES, &nJPEGTableSize, &pJPEGTable) )\n    {\n        if( pJPEGTable == nullptr ||\n            nJPEGTableSize > INT_MAX ||\n            static_cast<GByte*>(pJPEGTable)[nJPEGTableSize-1] != 0xD9 )\n        {\n            nJPEGOverviewCount = 0;\n            return 0;\n        }\n        nJPEGTableSize--;  // Remove final 0xD9.\n    }\n    else\n    {\n        pJPEGTable = abyFFD8;\n        nJPEGTableSize = 2;\n    }\n\n    papoJPEGOverviewDS =\n        static_cast<GTiffJPEGOverviewDS **>(\n            CPLMalloc( sizeof(GTiffJPEGOverviewDS*) * nJPEGOverviewCount ) );\n    for( int i = 0; i < nJPEGOverviewCount; ++i )\n    {\n        papoJPEGOverviewDS[i] =\n            new GTiffJPEGOverviewDS(\n                this, i + 1,\n                pJPEGTable, static_cast<int>(nJPEGTableSize) );\n    }\n\n    nJPEGOverviewCountOri = nJPEGOverviewCount;\n\n    return nJPEGOverviewCount;\n}\n\n/************************************************************************/\n/*                           FillEmptyTiles()                           */\n/************************************************************************/\n\nvoid GTiffDataset::FillEmptyTiles()\n\n{\n    if( !SetDirectory() )\n        return;\n\n/* -------------------------------------------------------------------- */\n/*      How many blocks are there in this file?                         */\n/* -------------------------------------------------------------------- */\n    const int nBlockCount =\n        nPlanarConfig == PLANARCONFIG_SEPARATE ?\n        nBlocksPerBand * nBands :\n        nBlocksPerBand;\n\n/* -------------------------------------------------------------------- */\n/*      Fetch block maps.                                               */\n/* -------------------------------------------------------------------- */\n    toff_t *panByteCounts = nullptr;\n\n    if( TIFFIsTiled( hTIFF ) )\n        TIFFGetField( hTIFF, TIFFTAG_TILEBYTECOUNTS, &panByteCounts );\n    else\n        TIFFGetField( hTIFF, TIFFTAG_STRIPBYTECOUNTS, &panByteCounts );\n\n    if( panByteCounts == nullptr )\n    {\n        // Got here with libtiff 3.9.3 and tiff_write_8 test.\n        CPLError( CE_Failure, CPLE_AppDefined,\n                  \"FillEmptyTiles() failed because panByteCounts == NULL\" );\n        return;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Prepare a blank data buffer to write for uninitialized blocks.  */\n/* -------------------------------------------------------------------- */\n    const int nBlockBytes =\n        TIFFIsTiled( hTIFF ) ?\n        static_cast<int>(TIFFTileSize(hTIFF)) :\n        static_cast<int>(TIFFStripSize(hTIFF));\n\n    GByte *pabyData =\n        static_cast<GByte *>( VSI_CALLOC_VERBOSE(nBlockBytes, 1) );\n    if( pabyData == nullptr )\n    {\n        return;\n    }\n\n    // Force tiles completely filled with the nodata value to be written.\n    bWriteEmptyTiles = true;\n\n/* -------------------------------------------------------------------- */\n/*      If set, fill data buffer with no data value.                    */\n/* -------------------------------------------------------------------- */\n    if( bNoDataSet && dfNoDataValue != 0.0 )\n    {\n        const GDALDataType eDataType = GetRasterBand( 1 )->GetRasterDataType();\n        const int nDataTypeSize = GDALGetDataTypeSizeBytes( eDataType );\n        if( nDataTypeSize &&\n            nDataTypeSize * 8 == static_cast<int>(nBitsPerSample) )\n        {\n            GDALCopyWords( &dfNoDataValue, GDT_Float64, 0,\n                           pabyData, eDataType,\n                           nDataTypeSize,\n                           nBlockBytes / nDataTypeSize );\n        }\n        else if( nDataTypeSize )\n        {\n            // Handle non power-of-two depths.\n            // Ideally make a packed buffer, but that is a bit tedious,\n            // so use the normal I/O interfaces.\n\n            CPLFree( pabyData );\n\n            pabyData = static_cast<GByte *>(\n                VSI_MALLOC3_VERBOSE(nBlockXSize, nBlockYSize, nDataTypeSize) );\n            if( pabyData == nullptr )\n                return;\n            GDALCopyWords( &dfNoDataValue, GDT_Float64, 0,\n                           pabyData, eDataType,\n                           nDataTypeSize,\n                           nBlockXSize * nBlockYSize );\n            const int nBlocksPerRow = DIV_ROUND_UP(nRasterXSize, nBlockXSize);\n            for( int iBlock = 0; iBlock < nBlockCount; ++iBlock )\n            {\n                if( panByteCounts[iBlock] == 0 )\n                {\n                    if( nPlanarConfig == PLANARCONFIG_SEPARATE || nBands == 1 )\n                    {\n                        CPL_IGNORE_RET_VAL( GetRasterBand(\n                            1 + iBlock / nBlocksPerBand )->WriteBlock(\n                                (iBlock % nBlocksPerBand) % nBlocksPerRow,\n                                (iBlock % nBlocksPerBand) / nBlocksPerRow,\n                                pabyData ) );\n                    }\n                    else\n                    {\n                        // In contig case, don't directly call WriteBlock(), as\n                        // it could cause useless decompression-recompression.\n                        const int nXOff =\n                            (iBlock % nBlocksPerRow) * nBlockXSize;\n                        const int nYOff =\n                            (iBlock / nBlocksPerRow) * nBlockYSize;\n                        const int nXSize =\n                            (nXOff + nBlockXSize <= nRasterXSize) ?\n                            nBlockXSize : nRasterXSize - nXOff;\n                        const int nYSize =\n                            (nYOff + nBlockYSize <= nRasterYSize) ?\n                            nBlockYSize : nRasterYSize - nYOff;\n                        for( int iBand = 1; iBand <= nBands; ++iBand )\n                        {\n                            CPL_IGNORE_RET_VAL( GetRasterBand( iBand )->\n                                RasterIO(\n                                    GF_Write, nXOff, nYOff, nXSize, nYSize,\n                                    pabyData, nXSize, nYSize,\n                                    eDataType, 0, 0, nullptr ) );\n                        }\n                    }\n                }\n            }\n            CPLFree( pabyData );\n            return;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      When we must fill with zeroes, try to create non-sparse file    */\n/*      w.r.t TIFF spec ... as a sparse file w.r.t filesystem, ie by    */\n/*      seeking to end of file instead of writing zero blocks.          */\n/* -------------------------------------------------------------------- */\n    else if( nCompression == COMPRESSION_NONE && (nBitsPerSample % 8) == 0 )\n    {\n        // Only use libtiff to write the first sparse block to ensure that it\n        // will serialize offset and count arrays back to disk.\n        int nCountBlocksToZero = 0;\n        for( int iBlock = 0; iBlock < nBlockCount; ++iBlock )\n        {\n            if( panByteCounts[iBlock] == 0 )\n            {\n                if( nCountBlocksToZero == 0 )\n                {\n                    const bool bWriteEmptyTilesBak = bWriteEmptyTiles;\n                    bWriteEmptyTiles = true;\n                    const bool bOK =\n                        WriteEncodedTileOrStrip( iBlock, pabyData,\n                                                 FALSE ) == CE_None;\n                    bWriteEmptyTiles = bWriteEmptyTilesBak;\n                    if( !bOK )\n                        break;\n                }\n                nCountBlocksToZero++;\n            }\n        }\n        CPLFree( pabyData );\n\n        --nCountBlocksToZero;\n\n        // And then seek to end of file for other ones.\n        if( nCountBlocksToZero > 0 )\n        {\n            toff_t *panByteOffsets = nullptr;\n\n            if( TIFFIsTiled( hTIFF ) )\n                TIFFGetField( hTIFF, TIFFTAG_TILEOFFSETS, &panByteOffsets );\n            else\n                TIFFGetField( hTIFF, TIFFTAG_STRIPOFFSETS, &panByteOffsets );\n\n            if( panByteOffsets == nullptr )\n            {\n                CPLError(\n                    CE_Failure, CPLE_AppDefined,\n                    \"FillEmptyTiles() failed because panByteOffsets == NULL\");\n                return;\n            }\n\n            VSILFILE* fpTIF = VSI_TIFFGetVSILFile(TIFFClientdata( hTIFF ));\n            VSIFSeekL( fpTIF, 0, SEEK_END );\n            const vsi_l_offset nOffset = VSIFTellL(fpTIF);\n\n            vsi_l_offset iBlockToZero = 0;\n            for( int iBlock = 0; iBlock < nBlockCount; ++iBlock )\n            {\n                if( panByteCounts[iBlock] == 0 )\n                {\n                    panByteOffsets[iBlock] = static_cast<toff_t>(\n                                        nOffset + iBlockToZero * nBlockBytes);\n                    panByteCounts[iBlock] = nBlockBytes;\n                    iBlockToZero++;\n                }\n            }\n            CPLAssert( iBlockToZero ==\n                       static_cast<vsi_l_offset>(nCountBlocksToZero) );\n\n            if( VSIFTruncateL( fpTIF,\n                               nOffset + iBlockToZero * nBlockBytes ) != 0 )\n            {\n                CPLError(CE_Failure, CPLE_FileIO,\n                         \"Cannot initialize empty blocks\");\n            }\n        }\n\n        return;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Check all blocks, writing out data for uninitialized blocks.    */\n/* -------------------------------------------------------------------- */\n\n    GByte* pabyRaw = nullptr;\n    vsi_l_offset nRawSize = 0;\n    for( int iBlock = 0; iBlock < nBlockCount; ++iBlock )\n    {\n        if( panByteCounts[iBlock] == 0 )\n        {\n            if( pabyRaw == nullptr )\n            {\n                if( WriteEncodedTileOrStrip( iBlock, pabyData, FALSE\n                                                                ) != CE_None )\n                    break;\n\n                vsi_l_offset nOffset = 0;\n                bool b = IsBlockAvailable( iBlock, &nOffset, &nRawSize);\n#ifdef DEBUG\n                CPLAssert(b);\n#else\n                CPL_IGNORE_RET_VAL(b);\n#endif\n                // When using compression, get back the compressed block\n                // so we can use the raw API to write it faster.\n                if( nCompression != COMPRESSION_NONE )\n                {\n                    pabyRaw = static_cast<GByte*>(\n                            VSI_MALLOC_VERBOSE(static_cast<int>(nRawSize)));\n                    if( pabyRaw )\n                    {\n                        VSILFILE* fp = VSI_TIFFGetVSILFile(\n                                                    TIFFClientdata( hTIFF ));\n                        const vsi_l_offset nCurOffset = VSIFTellL(fp);\n                        VSIFSeekL(fp, nOffset, SEEK_SET);\n                        VSIFReadL(pabyRaw, 1, static_cast<int>(nRawSize), fp);\n                        VSIFSeekL(fp, nCurOffset, SEEK_SET);\n                    }\n                }\n            }\n            else\n            {\n                WriteRawStripOrTile( iBlock, pabyRaw,\n                                     static_cast<int>(nRawSize) );\n            }\n        }\n    }\n\n    CPLFree( pabyData );\n    VSIFree( pabyRaw );\n}\n\n/************************************************************************/\n/*                         HasOnlyNoData()                              */\n/************************************************************************/\n\ntemplate<class T>\nstatic inline bool IsEqualToNoData( T value, T noDataValue )\n{\n    return value == noDataValue;\n}\n\ntemplate<> bool IsEqualToNoData<float>( float value, float noDataValue )\n{\n    return\n        CPLIsNan(noDataValue) ?\n        CPL_TO_BOOL(CPLIsNan(value)) : value == noDataValue;\n}\n\ntemplate<> bool IsEqualToNoData<double>( double value, double noDataValue )\n{\n    return\n        CPLIsNan(noDataValue) ?\n        CPL_TO_BOOL(CPLIsNan(value)) : value == noDataValue;\n}\n\ntemplate<class T>\nbool GTiffDataset::HasOnlyNoDataT( const T* pBuffer, int nWidth, int nHeight,\n                                   int nLineStride, int nComponents ) const\n{\n    const T noDataValue = static_cast<T>((bNoDataSet) ? dfNoDataValue : 0.0);\n    // Fast test: check the 4 corners and the middle pixel.\n    for( int iBand = 0; iBand < nComponents; iBand++ )\n    {\n        if( !(IsEqualToNoData(pBuffer[iBand], noDataValue) &&\n              IsEqualToNoData(\n                  pBuffer[static_cast<size_t>(nWidth - 1) * nComponents +\n                          iBand],\n                  noDataValue) &&\n              IsEqualToNoData(\n                  pBuffer[(static_cast<size_t>(nHeight-1)/2 * nLineStride +\n                           (nWidth - 1)/2) * nComponents + iBand],\n                  noDataValue) &&\n              IsEqualToNoData(\n                  pBuffer[static_cast<size_t>(nHeight - 1) * nLineStride *\n                          nComponents + iBand], noDataValue) &&\n              IsEqualToNoData(\n                  pBuffer[(static_cast<size_t>(nHeight - 1) * nLineStride +\n                           nWidth - 1) * nComponents + iBand], noDataValue) ) )\n        {\n            return false;\n        }\n    }\n\n    // Test all pixels.\n    for( int iY = 0; iY < nHeight; iY++ )\n    {\n        for( int iX = 0; iX < nWidth * nComponents; iX++ )\n        {\n            if( !IsEqualToNoData(\n                   pBuffer[iY * static_cast<size_t>(nLineStride) * nComponents +\n                           iX], noDataValue) )\n            {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nbool GTiffDataset::HasOnlyNoData( const void* pBuffer, int nWidth, int nHeight,\n                                  int nLineStride, int nComponents )\n{\n    const GDALDataType eDT = GetRasterBand(1)->GetRasterDataType();\n\n    // In the case where the nodata is 0, we can compare several bytes at\n    // once. Select the largest natural integer type for the architecture.\n#if SIZEOF_VOIDP == 8 || defined(__x86_64__)\n    // We test __x86_64__ for x32 arch where SIZEOF_VOIDP == 4\n    typedef GUInt64 WordType;\n#else\n    typedef unsigned int WordType;\n#endif\n    if( (!bNoDataSet || dfNoDataValue == 0.0) && nWidth == nLineStride\n#ifdef CPL_CPU_REQUIRES_ALIGNED_ACCESS\n        && CPL_IS_ALIGNED(pBuffer, sizeof(WordType))\n#endif\n        )\n    {\n        const GByte* pabyBuffer = static_cast<const GByte*>(pBuffer);\n        const size_t nSize = static_cast<size_t>(nWidth) * nHeight *\n                             nComponents * GDALGetDataTypeSizeBytes(eDT);\n        size_t i = 0;\n        for( ; i + sizeof(WordType) - 1 < nSize; i += sizeof(WordType) )\n        {\n            if( *(reinterpret_cast<const WordType*>(pabyBuffer + i)) )\n                return false;\n        }\n        for( ; i < nSize; i++ )\n        {\n            if( pabyBuffer[i] )\n                return false;\n        }\n        return true;\n    }\n\n    if( nBitsPerSample == 8 )\n    {\n        if( nSampleFormat == SAMPLEFORMAT_INT )\n        {\n            return HasOnlyNoDataT(static_cast<const signed char*>(pBuffer),\n                                  nWidth, nHeight, nLineStride, nComponents);\n        }\n        return HasOnlyNoDataT(static_cast<const GByte*>(pBuffer),\n                              nWidth, nHeight, nLineStride, nComponents);\n    }\n    if( nBitsPerSample == 16 && eDT == GDT_UInt16 )\n    {\n        return HasOnlyNoDataT(static_cast<const GUInt16*>(pBuffer),\n                              nWidth, nHeight, nLineStride, nComponents);\n    }\n    if( nBitsPerSample == 16 && eDT== GDT_Int16 )\n    {\n        return HasOnlyNoDataT(static_cast<const GInt16*>(pBuffer),\n                              nWidth, nHeight, nLineStride, nComponents);\n    }\n    if( nBitsPerSample == 32 && eDT == GDT_UInt32 )\n    {\n        return HasOnlyNoDataT(static_cast<const GUInt32*>(pBuffer),\n                              nWidth, nHeight, nLineStride, nComponents);\n    }\n    if( nBitsPerSample == 32 && eDT == GDT_Int32 )\n    {\n        return HasOnlyNoDataT(static_cast<const GInt32*>(pBuffer),\n                              nWidth, nHeight, nLineStride, nComponents);\n    }\n    if( nBitsPerSample == 32 && eDT == GDT_Float32 )\n    {\n        return HasOnlyNoDataT(static_cast<const float*>(pBuffer),\n                              nWidth, nHeight, nLineStride, nComponents);\n    }\n    if( nBitsPerSample == 64 && eDT == GDT_Float64 )\n    {\n        return HasOnlyNoDataT(static_cast<const double*>(pBuffer),\n                              nWidth, nHeight, nLineStride, nComponents);\n    }\n    return false;\n}\n\n/************************************************************************/\n/*                     IsFirstPixelEqualToNoData()                      */\n/************************************************************************/\n\ninline bool GTiffDataset::IsFirstPixelEqualToNoData( const void* pBuffer )\n{\n    const GDALDataType eDT = GetRasterBand(1)->GetRasterDataType();\n    const double dfEffectiveNoData = (bNoDataSet) ? dfNoDataValue : 0.0;\n    if( nBitsPerSample == 8 )\n    {\n        if( nSampleFormat == SAMPLEFORMAT_INT )\n        {\n            return GDALIsValueInRange<signed char>(dfEffectiveNoData) &&\n                   *(static_cast<const signed char*>(pBuffer)) ==\n                        static_cast<signed char>(dfEffectiveNoData);\n        }\n        return GDALIsValueInRange<GByte>(dfEffectiveNoData) &&\n               *(static_cast<const GByte*>(pBuffer)) ==\n                        static_cast<GByte>(dfEffectiveNoData);\n    }\n    if( nBitsPerSample == 16 && eDT == GDT_UInt16 )\n    {\n        return GDALIsValueInRange<GUInt16>(dfEffectiveNoData) &&\n               *(static_cast<const GUInt16*>(pBuffer)) ==\n                        static_cast<GUInt16>(dfEffectiveNoData);\n    }\n    if( nBitsPerSample == 16 && eDT == GDT_Int16 )\n    {\n        return GDALIsValueInRange<GInt16>(dfEffectiveNoData) &&\n               *(static_cast<const GInt16*>(pBuffer)) ==\n                        static_cast<GInt16>(dfEffectiveNoData);\n    }\n    if( nBitsPerSample == 32 && eDT == GDT_UInt32 )\n    {\n        return GDALIsValueInRange<GUInt32>(dfEffectiveNoData) &&\n               *(static_cast<const GUInt32*>(pBuffer)) ==\n                        static_cast<GUInt32>(dfEffectiveNoData);\n    }\n    if( nBitsPerSample == 32 && eDT == GDT_Int32 )\n    {\n        return GDALIsValueInRange<GInt32>(dfEffectiveNoData) &&\n               *(static_cast<const GInt32*>(pBuffer)) ==\n                        static_cast<GInt32>(dfEffectiveNoData);\n    }\n    if( nBitsPerSample == 32 && eDT == GDT_Float32 )\n    {\n        if( CPLIsNan(dfNoDataValue) )\n            return CPL_TO_BOOL(\n                CPLIsNan(*(static_cast<const float*>(pBuffer))));\n        return GDALIsValueInRange<float>(dfEffectiveNoData) &&\n               *(static_cast<const float*>(pBuffer)) ==\n                        static_cast<float>(dfEffectiveNoData);\n    }\n    if( nBitsPerSample == 64 && eDT == GDT_Float64 )\n    {\n        if( CPLIsNan(dfEffectiveNoData) )\n            return CPL_TO_BOOL(\n                CPLIsNan(*(static_cast<const double*>(pBuffer))));\n        return *(static_cast<const double*>(pBuffer)) == dfEffectiveNoData;\n    }\n    return false;\n}\n\n/************************************************************************/\n/*                        WriteEncodedTile()                            */\n/************************************************************************/\n\nbool GTiffDataset::WriteEncodedTile( uint32 tile, GByte *pabyData,\n                                     int bPreserveDataBuffer )\n{\n    int iRow = 0;\n    int iColumn = 0;\n    int nBlocksPerRow = 1;\n    int nBlocksPerColumn = 1;\n\n/* -------------------------------------------------------------------- */\n/*      Don't write empty blocks in some cases.                         */\n/* -------------------------------------------------------------------- */\n    if( !bWriteEmptyTiles && IsFirstPixelEqualToNoData(pabyData) )\n    {\n        if( !IsBlockAvailable(tile) )\n        {\n            const int nComponents =\n                nPlanarConfig == PLANARCONFIG_CONTIG ? nBands : 1;\n            nBlocksPerRow = DIV_ROUND_UP(nRasterXSize, nBlockXSize);\n            nBlocksPerColumn = DIV_ROUND_UP(nRasterYSize, nBlockYSize);\n\n            iColumn = (tile % nBlocksPerBand) % nBlocksPerRow;\n            iRow = (tile % nBlocksPerBand) / nBlocksPerRow;\n\n            const int nActualBlockWidth =\n                ( iColumn == nBlocksPerRow - 1 ) ?\n                nRasterXSize - iColumn * nBlockXSize : nBlockXSize;\n            const int nActualBlockHeight =\n                ( iRow == nBlocksPerColumn - 1 ) ?\n                nRasterYSize - iRow * nBlockYSize : nBlockYSize;\n\n            if( HasOnlyNoData(pabyData,\n                              nActualBlockWidth, nActualBlockHeight,\n                              nBlockXSize, nComponents ) )\n            {\n                return true;\n            }\n        }\n    }\n\n    // Do we need to spread edge values right or down for a partial\n    // JPEG encoded tile?  We do this to avoid edge artifacts.\n    bool bNeedTileFill = false;\n    if( nCompression == COMPRESSION_JPEG )\n    {\n        nBlocksPerRow = DIV_ROUND_UP(nRasterXSize, nBlockXSize);\n        nBlocksPerColumn = DIV_ROUND_UP(nRasterYSize, nBlockYSize);\n\n        iColumn = (tile % nBlocksPerBand) % nBlocksPerRow;\n        iRow = (tile % nBlocksPerBand) / nBlocksPerRow;\n\n        // Is this a partial right edge tile?\n        if( iRow == nBlocksPerRow - 1\n            && nRasterXSize % nBlockXSize != 0 )\n            bNeedTileFill = true;\n\n        // Is this a partial bottom edge tile?\n        if( iColumn == nBlocksPerColumn - 1\n            && nRasterYSize % nBlockYSize != 0 )\n            bNeedTileFill = true;\n    }\n\n    // If we need to fill out the tile, or if we want to prevent\n    // TIFFWriteEncodedTile from altering the buffer as part of\n    // byte swapping the data on write then we will need a temporary\n    // working buffer.  If not, we can just do a direct write.\n    const int cc = static_cast<int>(TIFFTileSize( hTIFF ));\n\n    if( bPreserveDataBuffer\n        && (TIFFIsByteSwapped(hTIFF) || bNeedTileFill || bHasDiscardedLsb) )\n    {\n        if( cc != nTempWriteBufferSize )\n        {\n            pabyTempWriteBuffer = CPLRealloc(pabyTempWriteBuffer, cc);\n            nTempWriteBufferSize = cc;\n        }\n        memcpy(pabyTempWriteBuffer, pabyData, cc);\n\n        pabyData = static_cast<GByte *>( pabyTempWriteBuffer );\n    }\n\n    // Perform tile fill if needed.\n    // TODO: we should also handle the case of nBitsPerSample == 12\n    // but this is more involved.\n    if( bNeedTileFill && nBitsPerSample == 8 )\n    {\n        const int nComponents =\n            nPlanarConfig == PLANARCONFIG_CONTIG ? nBands : 1;\n\n        CPLDebug( \"GTiff\", \"Filling out jpeg edge tile on write.\" );\n\n        const int nRightPixelsToFill =\n            iColumn == nBlocksPerRow - 1 ?\n            nBlockXSize * (iColumn + 1) - nRasterXSize :\n            0;\n        const int nBottomPixelsToFill =\n            iRow == nBlocksPerColumn - 1 ?\n            nBlockYSize * (iRow + 1) - nRasterYSize :\n            0;\n\n        // Fill out to the right.\n        const int iSrcX = nBlockXSize - nRightPixelsToFill - 1;\n\n        for( int iX = iSrcX + 1; iX < nBlockXSize; ++iX )\n        {\n            for( int iY = 0; iY < nBlockYSize; ++iY )\n            {\n                memcpy( pabyData + (nBlockXSize * iY + iX) * nComponents,\n                        pabyData + (nBlockXSize * iY + iSrcX) * nComponents,\n                        nComponents );\n            }\n        }\n\n        // Now fill out the bottom.\n        const int iSrcY = nBlockYSize - nBottomPixelsToFill - 1;\n        for( int iY = iSrcY + 1; iY < nBlockYSize; ++iY )\n        {\n            memcpy( pabyData + nBlockXSize * nComponents * iY,\n                    pabyData + nBlockXSize * nComponents * iSrcY,\n                    nBlockXSize * nComponents );\n        }\n    }\n\n    if( bHasDiscardedLsb )\n    {\n        const int iBand =\n            nPlanarConfig == PLANARCONFIG_SEPARATE ?\n            static_cast<int>(tile) / nBlocksPerBand : -1;\n        DiscardLsb(pabyData, cc, iBand);\n    }\n\n    if( bStreamingOut )\n    {\n        if( tile != static_cast<uint32>(nLastWrittenBlockId + 1) )\n        {\n            CPLError(CE_Failure, CPLE_NotSupported,\n                     \"Attempt to write block %d whereas %d was expected\",\n                     tile, nLastWrittenBlockId + 1);\n            return false;\n        }\n        if( static_cast<int>( VSIFWriteL(pabyData, 1, cc, fpToWrite) ) != cc )\n        {\n            CPLError( CE_Failure, CPLE_FileIO, \"Could not write %d bytes\",\n                      cc );\n            return false;\n        }\n        nLastWrittenBlockId = tile;\n        return true;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Should we do compression in a worker thread ?                   */\n/* -------------------------------------------------------------------- */\n    if( SubmitCompressionJob(tile, pabyData, cc, nBlockYSize) )\n        return true;\n\n    // libtiff 4.0.6 or older do not always properly report write errors.\n#if !defined(INTERNAL_LIBTIFF) && (!defined(TIFFLIB_VERSION) || (TIFFLIB_VERSION <= 20150912))\n    const CPLErr eBefore = CPLGetLastErrorType();\n#endif\n    const bool bRet =\n        static_cast<int>(TIFFWriteEncodedTile(hTIFF, tile, pabyData, cc)) == cc;\n#if !defined(INTERNAL_LIBTIFF) && (!defined(TIFFLIB_VERSION) || (TIFFLIB_VERSION <= 20150912))\n    if( eBefore == CE_None && CPLGetLastErrorType() == CE_Failure )\n        return false;\n#endif\n    return bRet;\n}\n\n/************************************************************************/\n/*                        WriteEncodedStrip()                           */\n/************************************************************************/\n\nbool GTiffDataset::WriteEncodedStrip( uint32 strip, GByte* pabyData,\n                                      int bPreserveDataBuffer )\n{\n    int cc = static_cast<int>(TIFFStripSize( hTIFF ));\n\n/* -------------------------------------------------------------------- */\n/*      If this is the last strip in the image, and is partial, then    */\n/*      we need to trim the number of scanlines written to the          */\n/*      amount of valid data we have. (#2748)                           */\n/* -------------------------------------------------------------------- */\n    const int nStripWithinBand = strip % nBlocksPerBand;\n    int nStripHeight = nRowsPerStrip;\n\n    if( nStripWithinBand * nStripHeight > GetRasterYSize() - nStripHeight )\n    {\n        nStripHeight = GetRasterYSize() - nStripWithinBand * nRowsPerStrip;\n        cc = (cc / nRowsPerStrip) * nStripHeight;\n        CPLDebug( \"GTiff\", \"Adjusted bytes to write from %d to %d.\",\n                  static_cast<int>(TIFFStripSize(hTIFF)), cc );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Don't write empty blocks in some cases.                         */\n/* -------------------------------------------------------------------- */\n    if( !bWriteEmptyTiles && IsFirstPixelEqualToNoData(pabyData) )\n    {\n        if( !IsBlockAvailable(strip) )\n        {\n            const int nComponents =\n                nPlanarConfig == PLANARCONFIG_CONTIG ? nBands : 1;\n\n            if( HasOnlyNoData(pabyData,\n                              nBlockXSize, nStripHeight,\n                              nBlockXSize, nComponents ) )\n            {\n                return true;\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      TIFFWriteEncodedStrip can alter the passed buffer if            */\n/*      byte-swapping is necessary so we use a temporary buffer         */\n/*      before calling it.                                              */\n/* -------------------------------------------------------------------- */\n    if( bPreserveDataBuffer && (TIFFIsByteSwapped(hTIFF) || bHasDiscardedLsb) )\n    {\n        if( cc != nTempWriteBufferSize )\n        {\n            pabyTempWriteBuffer = CPLRealloc(pabyTempWriteBuffer, cc);\n            nTempWriteBufferSize = cc;\n        }\n        memcpy(pabyTempWriteBuffer, pabyData, cc);\n        pabyData = static_cast<GByte *>( pabyTempWriteBuffer );\n    }\n\n    if( bHasDiscardedLsb )\n    {\n        int iBand =\n            nPlanarConfig == PLANARCONFIG_SEPARATE ?\n            static_cast<int>(strip) / nBlocksPerBand : -1;\n        DiscardLsb(pabyData, cc, iBand);\n    }\n\n    if( bStreamingOut )\n    {\n        if( strip != static_cast<uint32>(nLastWrittenBlockId + 1) )\n        {\n            CPLError(CE_Failure, CPLE_NotSupported,\n                     \"Attempt to write block %d whereas %d was expected\",\n                     strip, nLastWrittenBlockId + 1);\n            return false;\n        }\n        if( static_cast<int>( VSIFWriteL(pabyData, 1, cc, fpToWrite) ) != cc )\n        {\n            CPLError(CE_Failure, CPLE_FileIO, \"Could not write %d bytes\",\n                     cc);\n            return false;\n        }\n        nLastWrittenBlockId = strip;\n        return true;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Should we do compression in a worker thread ?                   */\n/* -------------------------------------------------------------------- */\n    if( SubmitCompressionJob(strip, pabyData, cc, nStripHeight) )\n        return true;\n\n    // libtiff 4.0.6 or older do not always properly report write errors.\n#if !defined(INTERNAL_LIBTIFF) && (!defined(TIFFLIB_VERSION) || (TIFFLIB_VERSION <= 20150912))\n    CPLErr eBefore = CPLGetLastErrorType();\n#endif\n    bool bRet =\n        static_cast<int>(TIFFWriteEncodedStrip( hTIFF, strip,\n                                                pabyData, cc)) == cc;\n#if !defined(INTERNAL_LIBTIFF) && (!defined(TIFFLIB_VERSION) || (TIFFLIB_VERSION <= 20150912))\n    if( eBefore == CE_None && CPLGetLastErrorType() == CE_Failure )\n        bRet = FALSE;\n#endif\n    return bRet;\n}\n\n/************************************************************************/\n/*                        InitCompressionThreads()                      */\n/************************************************************************/\n\nvoid GTiffDataset::InitCompressionThreads( char** papszOptions )\n{\n    // Raster == tile, then no need for threads\n    if( nBlockXSize == nRasterXSize && nBlockYSize == nRasterYSize )\n        return;\n\n    const char* pszValue = CSLFetchNameValue( papszOptions, \"NUM_THREADS\" );\n    if( pszValue == nullptr )\n        pszValue = CPLGetConfigOption(\"GDAL_NUM_THREADS\", nullptr);\n    if( pszValue )\n    {\n        const int nThreads =\n            EQUAL(pszValue, \"ALL_CPUS\") ? CPLGetNumCPUs() : atoi(pszValue);\n        if( nThreads > 1 )\n        {\n            if( nCompression == COMPRESSION_NONE ||\n                nCompression == COMPRESSION_JPEG )\n            {\n                CPLDebug( \"GTiff\",\n                          \"NUM_THREADS ignored with uncompressed or JPEG\" );\n            }\n            else\n            {\n                CPLDebug(\"GTiff\", \"Using %d threads for compression\", nThreads);\n\n                // Try to reuse previously created thread pool\n                {\n                    std::lock_guard<std::mutex> oLock(gMutexThreadPool);\n                    if( gpoCompressThreadPool &&\n                        gpoCompressThreadPool->GetThreadCount() == nThreads )\n                    {\n                        poCompressThreadPool = gpoCompressThreadPool;\n                    }\n                    else\n                    {\n                        delete gpoCompressThreadPool;\n                    }\n                    gpoCompressThreadPool = nullptr;\n                }\n\n                if( poCompressThreadPool == nullptr )\n                {\n                    poCompressThreadPool = new CPLWorkerThreadPool();\n                    if( !poCompressThreadPool->Setup(nThreads, nullptr, nullptr) )\n                    {\n                        delete poCompressThreadPool;\n                        poCompressThreadPool = nullptr;\n                    }\n                }\n                if( poCompressThreadPool != nullptr )\n                {\n                    // Add a margin of an extra job w.r.t thread number\n                    // so as to optimize compression time (enables the main\n                    // thread to do boring I/O while all CPUs are working).\n                    asCompressionJobs.resize(nThreads + 1);\n                    memset(&asCompressionJobs[0], 0,\n                           asCompressionJobs.size() *\n                           sizeof(GTiffCompressionJob));\n                    for( int i = 0;\n                         i < static_cast<int>(asCompressionJobs.size());\n                         ++i )\n                    {\n                        asCompressionJobs[i].pszTmpFilename =\n                            CPLStrdup(CPLSPrintf(\"/vsimem/gtiff/thread/job/%p\",\n                                                 &asCompressionJobs[i]));\n                        asCompressionJobs[i].nStripOrTile = -1;\n                    }\n                    hCompressThreadPoolMutex = CPLCreateMutex();\n                    CPLReleaseMutex(hCompressThreadPoolMutex);\n\n                    // This is kind of a hack, but basically using\n                    // TIFFWriteRawStrip/Tile and then TIFFReadEncodedStrip/Tile\n                    // does not work on a newly created file, because\n                    // TIFF_MYBUFFER is not set in tif_flags\n                    // (if using TIFFWriteEncodedStrip/Tile first,\n                    // TIFFWriteBufferSetup() is automatically called).\n                    // This should likely rather fixed in libtiff itself.\n                    TIFFWriteBufferSetup(hTIFF, nullptr, -1);\n                }\n            }\n        }\n        else if( nThreads < 0 ||\n                 (!EQUAL(pszValue, \"0\") &&\n                  !EQUAL(pszValue, \"1\") &&\n                  !EQUAL(pszValue, \"ALL_CPUS\")) )\n        {\n            CPLError(CE_Warning, CPLE_AppDefined,\n                     \"Invalid value for NUM_THREADS: %s\", pszValue);\n        }\n    }\n}\n\n/************************************************************************/\n/*                       GetGTIFFKeysFlavor()                           */\n/************************************************************************/\n\nstatic GTIFFKeysFlavorEnum GetGTIFFKeysFlavor( char** papszOptions )\n{\n    const char* pszGeoTIFFKeysFlavor =\n        CSLFetchNameValueDef( papszOptions, \"GEOTIFF_KEYS_FLAVOR\", \"STANDARD\" );\n    if( EQUAL(pszGeoTIFFKeysFlavor, \"ESRI_PE\") )\n        return GEOTIFF_KEYS_ESRI_PE;\n    return GEOTIFF_KEYS_STANDARD;\n}\n\n/************************************************************************/\n/*                      InitCreationOrOpenOptions()                     */\n/************************************************************************/\n\nvoid GTiffDataset::InitCreationOrOpenOptions( char** papszOptions )\n{\n    InitCompressionThreads(papszOptions);\n\n    eGeoTIFFKeysFlavor = GetGTIFFKeysFlavor(papszOptions);\n}\n\n/************************************************************************/\n/*                      ThreadCompressionFunc()                         */\n/************************************************************************/\n\nvoid GTiffDataset::ThreadCompressionFunc( void* pData )\n{\n    GTiffCompressionJob* psJob = static_cast<GTiffCompressionJob *>(pData);\n    GTiffDataset* poDS = psJob->poDS;\n\n    VSILFILE* fpTmp = VSIFOpenL(psJob->pszTmpFilename, \"wb+\");\n    TIFF* hTIFFTmp = VSI_TIFFOpen(psJob->pszTmpFilename,\n        psJob->bTIFFIsBigEndian ? \"wb+\" : \"wl+\", fpTmp);\n    CPLAssert( hTIFFTmp != nullptr );\n    TIFFSetField(hTIFFTmp, TIFFTAG_IMAGEWIDTH, poDS->nBlockXSize);\n    TIFFSetField(hTIFFTmp, TIFFTAG_IMAGELENGTH, psJob->nHeight);\n    TIFFSetField(hTIFFTmp, TIFFTAG_BITSPERSAMPLE, poDS->nBitsPerSample);\n    TIFFSetField(hTIFFTmp, TIFFTAG_COMPRESSION, poDS->nCompression);\n    if( psJob->nPredictor != PREDICTOR_NONE )\n        TIFFSetField(hTIFFTmp, TIFFTAG_PREDICTOR, psJob->nPredictor);\n\n    TIFFSetField(hTIFFTmp, TIFFTAG_PHOTOMETRIC, poDS->nPhotometric);\n    TIFFSetField(hTIFFTmp, TIFFTAG_SAMPLEFORMAT, poDS->nSampleFormat);\n    TIFFSetField(hTIFFTmp, TIFFTAG_SAMPLESPERPIXEL, poDS->nSamplesPerPixel);\n    TIFFSetField(hTIFFTmp, TIFFTAG_ROWSPERSTRIP, poDS->nBlockYSize);\n    TIFFSetField(hTIFFTmp, TIFFTAG_PLANARCONFIG, poDS->nPlanarConfig);\n\n    poDS->RestoreVolatileParameters(hTIFFTmp);\n\n    bool bOK =\n        TIFFWriteEncodedStrip(hTIFFTmp, 0, psJob->pabyBuffer,\n                              psJob->nBufferSize) == psJob->nBufferSize;\n\n    int nOffset = 0;\n    if( bOK )\n    {\n        toff_t* panOffsets = nullptr;\n        toff_t* panByteCounts = nullptr;\n        TIFFGetField(hTIFFTmp, TIFFTAG_STRIPOFFSETS, &panOffsets);\n        TIFFGetField(hTIFFTmp, TIFFTAG_STRIPBYTECOUNTS, &panByteCounts);\n\n        nOffset = static_cast<int>( panOffsets[0]);\n        psJob->nCompressedBufferSize = static_cast<int>( panByteCounts[0] );\n    }\n    else\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                  \"Error when compressing strip/tile %d\",\n                  psJob->nStripOrTile);\n    }\n\n    XTIFFClose(hTIFFTmp);\n    if( VSIFCloseL(fpTmp) != 0 )\n    {\n        if( bOK )\n        {\n            bOK = false;\n            CPLError( CE_Failure, CPLE_AppDefined,\n                      \"Error when compressing strip/tile %d\",\n                      psJob->nStripOrTile);\n        }\n    }\n\n    if( bOK )\n    {\n        vsi_l_offset nFileSize = 0;\n        GByte* pabyCompressedBuffer = VSIGetMemFileBuffer(psJob->pszTmpFilename,\n                                                          &nFileSize,\n                                                          FALSE);\n        CPLAssert( nOffset + psJob->nCompressedBufferSize <=\n                   static_cast<int>(nFileSize) );\n        psJob->pabyCompressedBuffer = pabyCompressedBuffer + nOffset;\n    }\n    else\n    {\n        psJob->pabyCompressedBuffer = nullptr;\n        psJob->nCompressedBufferSize = 0;\n    }\n\n    CPLAcquireMutex(poDS->hCompressThreadPoolMutex, 1000.0);\n    psJob->bReady = true;\n    CPLReleaseMutex(poDS->hCompressThreadPoolMutex);\n}\n\n/************************************************************************/\n/*                        WriteRawStripOrTile()                         */\n/************************************************************************/\n\nvoid GTiffDataset::WriteRawStripOrTile( int nStripOrTile,\n                                        GByte* pabyCompressedBuffer,\n                                        int nCompressedBufferSize )\n{\n#ifdef DEBUG_VERBOSE\n    CPLDebug(\"GTIFF\", \"Writing raw strip/tile %d, size %d\",\n             nStripOrTile, nCompressedBufferSize);\n#endif\n    toff_t *panOffsets = nullptr;\n    if( TIFFGetField(\n            hTIFF,\n            TIFFIsTiled( hTIFF ) ?\n            TIFFTAG_TILEOFFSETS : TIFFTAG_STRIPOFFSETS, &panOffsets ) &&\n            panOffsets[nStripOrTile] != 0 )\n    {\n        // Make sure that if the tile/strip already exists,\n        // we write at end of file.\n        TIFFSetWriteOffset(hTIFF, 0);\n    }\n    if( TIFFIsTiled( hTIFF ) )\n        TIFFWriteRawTile( hTIFF, nStripOrTile, pabyCompressedBuffer,\n                          nCompressedBufferSize );\n    else\n        TIFFWriteRawStrip( hTIFF, nStripOrTile, pabyCompressedBuffer,\n                           nCompressedBufferSize );\n}\n\n/************************************************************************/\n/*                        WaitCompletionForBlock()                      */\n/************************************************************************/\n\nvoid GTiffDataset::WaitCompletionForBlock(int nBlockId)\n{\n    if( poCompressThreadPool != nullptr )\n    {\n        for( int i = 0; i < static_cast<int>(asCompressionJobs.size()); ++i )\n        {\n            if( asCompressionJobs[i].nStripOrTile == nBlockId )\n            {\n                CPLDebug(\"GTIFF\",\n                         \"Waiting for worker job to finish handling block %d\",\n                         nBlockId);\n\n                CPLAcquireMutex(hCompressThreadPoolMutex, 1000.0);\n                const bool bReady = asCompressionJobs[i].bReady;\n                CPLReleaseMutex(hCompressThreadPoolMutex);\n                if( !bReady )\n                {\n                    poCompressThreadPool->WaitCompletion(0);\n                    CPLAssert( asCompressionJobs[i].bReady );\n                }\n\n                if( asCompressionJobs[i].nCompressedBufferSize )\n                {\n                    WriteRawStripOrTile(asCompressionJobs[i].nStripOrTile,\n                                  asCompressionJobs[i].pabyCompressedBuffer,\n                                  asCompressionJobs[i].nCompressedBufferSize);\n                }\n                asCompressionJobs[i].pabyCompressedBuffer = nullptr;\n                asCompressionJobs[i].nBufferSize = 0;\n                asCompressionJobs[i].bReady = false;\n                asCompressionJobs[i].nStripOrTile = -1;\n                return;\n            }\n        }\n    }\n}\n\n/************************************************************************/\n/*                      SubmitCompressionJob()                          */\n/************************************************************************/\n\nbool GTiffDataset::SubmitCompressionJob( int nStripOrTile, GByte* pabyData,\n                                         int cc, int nHeight )\n{\n/* -------------------------------------------------------------------- */\n/*      Should we do compression in a worker thread ?                   */\n/* -------------------------------------------------------------------- */\n    if( !( poCompressThreadPool != nullptr &&\n           (nCompression == COMPRESSION_ADOBE_DEFLATE ||\n            nCompression == COMPRESSION_LZW ||\n            nCompression == COMPRESSION_PACKBITS ||\n            nCompression == COMPRESSION_LZMA ||\n            nCompression == COMPRESSION_ZSTD ||\n            nCompression == COMPRESSION_LERC ||\n            nCompression == COMPRESSION_WEBP) ) )\n        return false;\n\n    int nNextCompressionJobAvail = -1;\n    // Wait that at least one job is finished.\n    poCompressThreadPool->WaitCompletion(\n        static_cast<int>(asCompressionJobs.size() - 1) );\n    for( int i = 0; i < static_cast<int>(asCompressionJobs.size()); ++i )\n    {\n        CPLAcquireMutex(hCompressThreadPoolMutex, 1000.0);\n        const bool bReady = asCompressionJobs[i].bReady;\n        CPLReleaseMutex(hCompressThreadPoolMutex);\n        if( bReady )\n        {\n            if( asCompressionJobs[i].nCompressedBufferSize )\n            {\n                WriteRawStripOrTile( asCompressionJobs[i].nStripOrTile,\n                                asCompressionJobs[i].pabyCompressedBuffer,\n                                asCompressionJobs[i].nCompressedBufferSize );\n            }\n            asCompressionJobs[i].pabyCompressedBuffer = nullptr;\n            asCompressionJobs[i].nBufferSize = 0;\n            asCompressionJobs[i].bReady = false;\n            asCompressionJobs[i].nStripOrTile = -1;\n        }\n        if( asCompressionJobs[i].nBufferSize == 0 )\n        {\n            if( nNextCompressionJobAvail < 0 )\n                nNextCompressionJobAvail = i;\n        }\n    }\n    CPLAssert(nNextCompressionJobAvail >= 0);\n\n    GTiffCompressionJob* psJob = &asCompressionJobs[nNextCompressionJobAvail];\n    psJob->poDS = this;\n    psJob->bTIFFIsBigEndian = CPL_TO_BOOL( TIFFIsBigEndian(hTIFF) );\n    psJob->pabyBuffer =\n        static_cast<GByte*>( CPLRealloc(psJob->pabyBuffer, cc) );\n    memcpy(psJob->pabyBuffer, pabyData, cc);\n    psJob->nBufferSize = cc;\n    psJob->nHeight = nHeight;\n    psJob->nStripOrTile = nStripOrTile;\n    psJob->nPredictor = PREDICTOR_NONE;\n    if( nCompression == COMPRESSION_LZW ||\n        nCompression == COMPRESSION_ADOBE_DEFLATE ||\n        nCompression == COMPRESSION_ZSTD )\n    {\n        TIFFGetField( hTIFF, TIFFTAG_PREDICTOR, &psJob->nPredictor );\n    }\n\n    poCompressThreadPool->SubmitJob(ThreadCompressionFunc, psJob);\n    return true;\n}\n\n/************************************************************************/\n/*                          DiscardLsb()                                */\n/************************************************************************/\n\nvoid GTiffDataset::DiscardLsb( GByte* pabyBuffer, int nBytes, int iBand ) const\n{\n    if( nBitsPerSample == 8 )\n    {\n        if( nPlanarConfig == PLANARCONFIG_SEPARATE )\n        {\n            const int nMask = anMaskLsb[iBand];\n            const int nOffset = anOffsetLsb[iBand];\n            for( int i = 0; i < nBytes; ++i )\n            {\n                // Keep 255 in case it is alpha.\n                if( pabyBuffer[i] != 255 )\n                    pabyBuffer[i] =\n                        static_cast<GByte>((pabyBuffer[i] & nMask) | nOffset);\n            }\n        }\n        else\n        {\n            for( int i = 0; i < nBytes; i += nBands )\n            {\n                for( int j = 0; j < nBands; ++j )\n                {\n                    // Keep 255 in case it is alpha.\n                    if( pabyBuffer[i + j] != 255 )\n                        pabyBuffer[i + j] =\n                            static_cast<GByte>((pabyBuffer[i + j] &\n                                                anMaskLsb[j]) | anOffsetLsb[j]);\n                }\n            }\n        }\n    }\n    else if( nBitsPerSample == 16 )\n    {\n        if( nPlanarConfig == PLANARCONFIG_SEPARATE )\n        {\n            const int nMask = anMaskLsb[iBand];\n            const int nOffset = anOffsetLsb[iBand];\n            for( int i = 0; i < nBytes/2; ++i )\n            {\n                reinterpret_cast<GUInt16*>(pabyBuffer)[i] =\n                    static_cast<GUInt16>(\n                        (reinterpret_cast<GUInt16 *>(pabyBuffer)[i] & nMask) |\n                        nOffset);\n            }\n        }\n        else\n        {\n            for( int i = 0; i < nBytes/2; i += nBands )\n            {\n                for( int j = 0; j < nBands; ++j )\n                {\n                    reinterpret_cast<GUInt16*>(pabyBuffer)[i + j] =\n                        static_cast<GUInt16>(\n                            (reinterpret_cast<GUInt16*>(pabyBuffer)[i + j] &\n                             anMaskLsb[j]) |\n                            anOffsetLsb[j]);\n                }\n            }\n        }\n    }\n    else if( nBitsPerSample == 32 )\n    {\n        if( nPlanarConfig == PLANARCONFIG_SEPARATE )\n        {\n            const int nMask = anMaskLsb[iBand];\n            const int nOffset = anOffsetLsb[iBand];\n            for( int i = 0; i < nBytes/4; ++i )\n            {\n                reinterpret_cast<GUInt32 *>(pabyBuffer)[i] =\n                    (reinterpret_cast<GUInt32*>(pabyBuffer)[i] & nMask) |\n                    nOffset;\n            }\n        }\n        else\n        {\n            for( int i = 0; i < nBytes/4; i += nBands )\n            {\n                for( int j = 0; j < nBands; ++j )\n                {\n                    reinterpret_cast<GUInt32 *>(pabyBuffer)[i + j] =\n                        (reinterpret_cast<GUInt32 *>(pabyBuffer)[i + j] &\n                         anMaskLsb[j]) |\n                        anOffsetLsb[j];\n                }\n            }\n        }\n    }\n}\n\n/************************************************************************/\n/*                  WriteEncodedTileOrStrip()                           */\n/************************************************************************/\n\nCPLErr GTiffDataset::WriteEncodedTileOrStrip( uint32 tile_or_strip, void* data,\n                                              int bPreserveDataBuffer )\n{\n    CPLErr eErr = CE_None;\n\n    if( TIFFIsTiled( hTIFF ) )\n    {\n        if( !(WriteEncodedTile(\n               tile_or_strip,\n               static_cast<GByte *>(data),\n               bPreserveDataBuffer)) )\n        {\n            eErr = CE_Failure;\n        }\n    }\n    else\n    {\n        if( !(WriteEncodedStrip(\n               tile_or_strip,\n               static_cast<GByte *>(data),\n               bPreserveDataBuffer)) )\n        {\n            eErr = CE_Failure;\n        }\n    }\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                           FlushBlockBuf()                            */\n/************************************************************************/\n\nCPLErr GTiffDataset::FlushBlockBuf()\n\n{\n    if( nLoadedBlock < 0 || !bLoadedBlockDirty )\n        return CE_None;\n\n    bLoadedBlockDirty = false;\n\n    if( !SetDirectory() )\n        return CE_Failure;\n\n    const CPLErr eErr =\n        WriteEncodedTileOrStrip(nLoadedBlock, pabyBlockBuf, true);\n    if( eErr != CE_None )\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                    \"WriteEncodedTile/Strip() failed.\" );\n        bWriteErrorInFlushBlockBuf = true;\n    }\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                            LoadBlockBuf()                            */\n/*                                                                      */\n/*      Load working block buffer with request block (tile/strip).      */\n/************************************************************************/\n\nCPLErr GTiffDataset::LoadBlockBuf( int nBlockId, bool bReadFromDisk )\n\n{\n    if( nLoadedBlock == nBlockId )\n        return CE_None;\n\n/* -------------------------------------------------------------------- */\n/*      If we have a dirty loaded block, flush it out first.            */\n/* -------------------------------------------------------------------- */\n    if( nLoadedBlock != -1 && bLoadedBlockDirty )\n    {\n        const CPLErr eErr = FlushBlockBuf();\n        if( eErr != CE_None )\n            return eErr;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Get block size.                                                 */\n/* -------------------------------------------------------------------- */\n    const int nBlockBufSize =\n        static_cast<int>(\n            TIFFIsTiled(hTIFF) ? TIFFTileSize(hTIFF) : TIFFStripSize(hTIFF));\n    if( !nBlockBufSize )\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                  \"Bogus block size; unable to allocate a buffer.\" );\n        return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Allocate a temporary buffer for this strip.                     */\n/* -------------------------------------------------------------------- */\n    if( pabyBlockBuf == nullptr )\n    {\n        pabyBlockBuf =\n            static_cast<GByte *>( VSI_CALLOC_VERBOSE( 1, nBlockBufSize ) );\n        if( pabyBlockBuf == nullptr )\n        {\n            return CE_Failure;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*  When called from ::IWriteBlock in separate cases (or in single band */\n/*  geotiffs), the ::IWriteBlock will override the content of the buffer*/\n/*  with pImage, so we don't need to read data from disk                */\n/* -------------------------------------------------------------------- */\n    if( !bReadFromDisk || bStreamingOut )\n    {\n        nLoadedBlock = nBlockId;\n        return CE_None;\n    }\n\n    // libtiff 3.X doesn't like mixing read&write of JPEG compressed blocks\n    // The below hack is necessary due to another hack that consist in\n    // writing zero block to force creation of JPEG tables.\n    if( nBlockId == 0 && bDontReloadFirstBlock )\n    {\n        bDontReloadFirstBlock = false;\n        memset( pabyBlockBuf, 0, nBlockBufSize );\n        nLoadedBlock = nBlockId;\n        return CE_None;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      The bottom most partial tiles and strips are sometimes only     */\n/*      partially encoded.  This code reduces the requested data so     */\n/*      an error won't be reported in this case. (#1179)                */\n/* -------------------------------------------------------------------- */\n    int nBlockReqSize = nBlockBufSize;\n    const int nBlocksPerRow = DIV_ROUND_UP(nRasterXSize, nBlockXSize);\n    const int nBlockYOff = (nBlockId % nBlocksPerBand) / nBlocksPerRow;\n\n    if( nBlockYOff * nBlockYSize > nRasterYSize - nBlockYSize )\n    {\n        nBlockReqSize = (nBlockBufSize / nBlockYSize)\n            * (nBlockYSize - static_cast<int>(\n                (static_cast<GIntBig>(nBlockYOff + 1) * nBlockYSize) %\n                    nRasterYSize));\n        memset( pabyBlockBuf, 0, nBlockBufSize );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If we don't have this block already loaded, and we know it      */\n/*      doesn't yet exist on disk, just zero the memory buffer and      */\n/*      pretend we loaded it.                                           */\n/* -------------------------------------------------------------------- */\n    bool bErrOccurred = false;\n    if( !IsBlockAvailable( nBlockId, nullptr, nullptr, &bErrOccurred ) )\n    {\n        memset( pabyBlockBuf, 0, nBlockBufSize );\n        nLoadedBlock = nBlockId;\n        if( bErrOccurred )\n            return CE_Failure;\n        return CE_None;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Load the block, if it isn't our current block.                  */\n/* -------------------------------------------------------------------- */\n    CPLErr eErr = CE_None;\n    if( TIFFIsTiled( hTIFF ) )\n    {\n        if( TIFFReadEncodedTile(hTIFF, nBlockId, pabyBlockBuf,\n                                nBlockReqSize) == -1\n            && !bIgnoreReadErrors )\n        {\n            // Once TIFFError() is properly hooked, this can go away.\n            CPLError( CE_Failure, CPLE_AppDefined,\n                      \"TIFFReadEncodedTile() failed.\" );\n\n            memset( pabyBlockBuf, 0, nBlockBufSize );\n\n            eErr = CE_Failure;\n        }\n    }\n    else\n    {\n        if( TIFFReadEncodedStrip(hTIFF, nBlockId, pabyBlockBuf,\n                                 nBlockReqSize) == -1\n            && !bIgnoreReadErrors )\n        {\n            // Once TIFFError() is properly hooked, this can go away.\n            CPLError( CE_Failure, CPLE_AppDefined,\n                      \"TIFFReadEncodedStrip() failed.\" );\n\n            memset( pabyBlockBuf, 0, nBlockBufSize );\n\n            eErr = CE_Failure;\n        }\n    }\n\n    if( eErr == CE_None )\n    {\n        nLoadedBlock = nBlockId;\n    }\n    else\n    {\n        nLoadedBlock = -1;\n    }\n    bLoadedBlockDirty = false;\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                   GTiffFillStreamableOffsetAndCount()                */\n/************************************************************************/\n\nstatic void GTiffFillStreamableOffsetAndCount( TIFF* hTIFF, int nSize )\n{\n    uint32 nXSize = 0;\n    uint32 nYSize = 0;\n    TIFFGetField( hTIFF, TIFFTAG_IMAGEWIDTH, &nXSize );\n    TIFFGetField( hTIFF, TIFFTAG_IMAGELENGTH, &nYSize );\n    const bool bIsTiled = CPL_TO_BOOL( TIFFIsTiled(hTIFF) );\n    const int nBlockCount =\n        bIsTiled ? TIFFNumberOfTiles(hTIFF) : TIFFNumberOfStrips(hTIFF);\n\n    toff_t *panOffset = nullptr;\n    TIFFGetField( hTIFF, bIsTiled ? TIFFTAG_TILEOFFSETS : TIFFTAG_STRIPOFFSETS,\n                  &panOffset );\n    toff_t *panSize = nullptr;\n    TIFFGetField( hTIFF,\n                  bIsTiled ? TIFFTAG_TILEBYTECOUNTS : TIFFTAG_STRIPBYTECOUNTS,\n                  &panSize );\n    toff_t nOffset = nSize;\n    // Trick to avoid clang static analyzer raising false positive about\n    // divide by zero later.\n    int nBlocksPerBand = 1;\n    uint32 nRowsPerStrip = 0;\n    if( !bIsTiled )\n    {\n        TIFFGetField( hTIFF, TIFFTAG_ROWSPERSTRIP, &nRowsPerStrip);\n        if( nRowsPerStrip > static_cast<uint32>(nYSize) )\n            nRowsPerStrip = nYSize;\n        nBlocksPerBand = DIV_ROUND_UP(nYSize, nRowsPerStrip);\n    }\n    for( int i = 0; i < nBlockCount; ++i )\n    {\n        int cc = bIsTiled ? static_cast<int>(TIFFTileSize(hTIFF)) :\n                            static_cast<int>(TIFFStripSize(hTIFF));\n        if( !bIsTiled )\n        {\n/* -------------------------------------------------------------------- */\n/*      If this is the last strip in the image, and is partial, then    */\n/*      we need to trim the number of scanlines written to the          */\n/*      amount of valid data we have. (#2748)                           */\n/* -------------------------------------------------------------------- */\n            int nStripWithinBand = i % nBlocksPerBand;\n            if( nStripWithinBand * nRowsPerStrip > nYSize - nRowsPerStrip )\n            {\n                cc = (cc / nRowsPerStrip)\n                    * (nYSize - nStripWithinBand * nRowsPerStrip);\n            }\n        }\n        panOffset[i] = nOffset;\n        panSize[i] = cc;\n        nOffset += cc;\n    }\n}\n\n/************************************************************************/\n/*                             Crystalize()                             */\n/*                                                                      */\n/*      Make sure that the directory information is written out for     */\n/*      a new file, require before writing any imagery data.            */\n/************************************************************************/\n\nvoid GTiffDataset::Crystalize()\n\n{\n    if( bCrystalized )\n        return;\n\n    // TODO: libtiff writes extended tags in the order they are specified\n    // and not in increasing order.\n    WriteMetadata( this, hTIFF, true, osProfile, osFilename,\n                   papszCreationOptions );\n    WriteGeoTIFFInfo();\n    if( bNoDataSet )\n        WriteNoDataValue( hTIFF, dfNoDataValue );\n\n    bMetadataChanged = false;\n    bGeoTIFFInfoChanged = false;\n    bNoDataChanged = false;\n    bNeedsRewrite = false;\n\n    bCrystalized = true;\n\n    TIFFWriteCheck( hTIFF, TIFFIsTiled(hTIFF), \"GTiffDataset::Crystalize\");\n\n    TIFFWriteDirectory( hTIFF );\n    if( bStreamingOut )\n    {\n        // We need to write twice the directory to be sure that custom\n        // TIFF tags are correctly sorted and that padding bytes have been\n        // added.\n        TIFFSetDirectory( hTIFF, 0 );\n        TIFFWriteDirectory( hTIFF );\n\n        if( VSIFSeekL( fpL, 0, SEEK_END ) != 0 )\n        {\n            CPLError(CE_Failure, CPLE_FileIO, \"Could not seek\");\n        }\n        const int nSize = static_cast<int>( VSIFTellL(fpL) );\n\n        TIFFSetDirectory( hTIFF, 0 );\n        GTiffFillStreamableOffsetAndCount( hTIFF, nSize );\n        TIFFWriteDirectory( hTIFF );\n\n        vsi_l_offset nDataLength = 0;\n        void* pabyBuffer =\n            VSIGetMemFileBuffer( osTmpFilename, &nDataLength, FALSE);\n        if( static_cast<int>(\n                VSIFWriteL( pabyBuffer, 1,\n                            static_cast<int>(nDataLength), fpToWrite ) ) !=\n            static_cast<int>(nDataLength) )\n        {\n            CPLError( CE_Failure, CPLE_FileIO, \"Could not write %d bytes\",\n                      static_cast<int>(nDataLength) );\n        }\n        // In case of single strip file, there's a libtiff check that would\n        // issue a warning since the file hasn't the required size.\n        CPLPushErrorHandler(CPLQuietErrorHandler);\n        TIFFSetDirectory( hTIFF, 0 );\n        CPLPopErrorHandler();\n    }\n    else\n    {\n        TIFFSetDirectory( hTIFF, 0 );\n    }\n\n    RestoreVolatileParameters( hTIFF );\n\n    nDirOffset = TIFFCurrentDirOffset( hTIFF );\n}\n\n#if defined(INTERNAL_LIBTIFF) && defined(DEFER_STRILE_LOAD)\n\nstatic\nbool GTiffCacheOffsetOrCount( VSILFILE* fp,\n                              bool bSwab,\n                              vsi_l_offset nBaseOffset,\n                              int nBlockId,\n                              uint32 nstrips,\n                              uint64* panVals,\n                              size_t sizeofval )\n{\n    constexpr vsi_l_offset IO_CACHE_PAGE_SIZE = 4096;\n\n    const int sizeofvalint = static_cast<int>(sizeofval);\n    const vsi_l_offset nOffset = nBaseOffset + sizeofval * nBlockId;\n    const vsi_l_offset nOffsetStartPage =\n        (nOffset / IO_CACHE_PAGE_SIZE) * IO_CACHE_PAGE_SIZE;\n    vsi_l_offset nOffsetEndPage = nOffsetStartPage + IO_CACHE_PAGE_SIZE;\n\n    if( nOffset + sizeofval > nOffsetEndPage )\n        nOffsetEndPage += IO_CACHE_PAGE_SIZE;\n    vsi_l_offset nLastStripOffset = nBaseOffset + nstrips * sizeofval;\n    if( nLastStripOffset < nOffsetEndPage )\n        nOffsetEndPage = nLastStripOffset;\n    if( nOffsetStartPage >= nOffsetEndPage )\n    {\n        CPLError(CE_Failure, CPLE_AppDefined,\n                 \"Cannot read offset/size for strile %d\", nBlockId);\n        panVals[nBlockId] = 0;\n        return false;\n    }\n    if( VSIFSeekL(fp, nOffsetStartPage, SEEK_SET) != 0 )\n    {\n        panVals[nBlockId] = 0;\n        return false;\n    }\n\n    const size_t nToRead =\n        static_cast<size_t>(nOffsetEndPage - nOffsetStartPage);\n    GByte buffer[2 * IO_CACHE_PAGE_SIZE] = {};  // TODO(schwehr): Off the stack.\n    const size_t nRead = VSIFReadL(buffer, 1, nToRead, fp);\n    if( nRead < nToRead )\n    {\n        CPLError(CE_Failure, CPLE_AppDefined,\n                 \"Cannot read offset/size for strile around ~%d\", nBlockId);\n        return false;\n    }\n    int iStartBefore =\n        - static_cast<int>((nOffset - nOffsetStartPage) / sizeofval);\n    if( nBlockId + iStartBefore < 0 )\n        iStartBefore = -nBlockId;\n    for( int i = iStartBefore;\n         static_cast<uint32>(nBlockId + i) < nstrips &&\n         static_cast<GIntBig>(nOffset) + (i + 1) * sizeofvalint <=\n         static_cast<GIntBig>(nOffsetEndPage);\n         ++i )\n    {\n        if( sizeofval == 2 )\n        {\n            uint16 val;\n            memcpy(&val,\n                   buffer + (nOffset - nOffsetStartPage) + i * sizeofvalint,\n                   sizeof(val));\n            if( bSwab )\n                CPL_SWAP16PTR(&val);\n            panVals[nBlockId + i] = val;\n        }\n        else if( sizeofval == 4 )\n        {\n            uint32 val;\n            memcpy(&val,\n                   buffer + (nOffset - nOffsetStartPage) + i * sizeofvalint,\n                   sizeof(val));\n            if( bSwab )\n                CPL_SWAP32PTR(&val);\n            panVals[nBlockId + i] = val;\n        }\n        else\n        {\n            uint64 val;\n            memcpy(&val,\n                   buffer + (nOffset - nOffsetStartPage) + i * sizeofvalint,\n                   sizeof(val));\n            if( bSwab )\n                CPL_SWAP64PTR(&val);\n            panVals[nBlockId + i] = val;\n        }\n    }\n    return true;\n}\n\nstatic bool ReadStripArray( VSILFILE* fp,\n                            TIFF* hTIFF,\n                            const TIFFDirEntry* psEntry,\n                            int nBlockId,\n                            uint32 nStripArrayAlloc,\n                            uint64* panOffsetOrCountArray )\n{\n    const bool bSwab = (hTIFF->tif_flags & TIFF_SWAB) != 0;\n    if( (hTIFF->tif_flags&TIFF_BIGTIFF) &&\n        psEntry->tdir_type == TIFF_SHORT &&\n        psEntry->tdir_count <= 4 )\n    {\n        uint16 offset;\n        const GByte* src = reinterpret_cast<const GByte*>(\n                                    &(psEntry->tdir_offset.toff_long8));\n        for( size_t i = 0; i < 4 && i < nStripArrayAlloc; i++ )\n        {\n            memcpy(&offset, src + sizeof(offset) * i, sizeof(offset));\n            if( bSwab )\n                CPL_SWAP16PTR(&offset);\n            panOffsetOrCountArray[i] = offset;\n        }\n        return true;\n    }\n    else if( (hTIFF->tif_flags&TIFF_BIGTIFF) &&\n        psEntry->tdir_type == TIFF_LONG &&\n        psEntry->tdir_count <= 2 )\n    {\n        uint32 offset;\n        const GByte* src = reinterpret_cast<const GByte*>(\n                                    &(psEntry->tdir_offset.toff_long8));\n        for( size_t i = 0; i < 2 && i < nStripArrayAlloc; i++ )\n        {\n            memcpy(&offset, src + sizeof(offset) * i, sizeof(offset));\n            if( bSwab )\n                CPL_SWAP32PTR(&offset);\n            panOffsetOrCountArray[i] = offset;\n        }\n        return true;\n    }\n    else if( (hTIFF->tif_flags&TIFF_BIGTIFF) &&\n        psEntry->tdir_type == TIFF_LONG8 &&\n        psEntry->tdir_count <= 1 )\n    {\n        uint64 offset = psEntry->tdir_offset.toff_long8;\n        if( bSwab )\n            CPL_SWAP64PTR(&offset);\n        panOffsetOrCountArray[0] = offset;\n        return true;\n    }\n    else if( !(hTIFF->tif_flags&TIFF_BIGTIFF) &&\n        psEntry->tdir_type == TIFF_SHORT &&\n        psEntry->tdir_count <= 2 )\n    {\n        uint16 offset;\n        const GByte* src = reinterpret_cast<const GByte*>(\n                                    &(psEntry->tdir_offset.toff_long));\n\n        for( size_t i = 0; i < 2 && i < nStripArrayAlloc; i++ )\n        {\n            memcpy(&offset, src + sizeof(offset) * i, sizeof(offset));\n            if( bSwab )\n                CPL_SWAP16PTR(&offset);\n            panOffsetOrCountArray[i] = offset;\n        }\n        return true;\n    }\n    else if( !(hTIFF->tif_flags&TIFF_BIGTIFF) &&\n        psEntry->tdir_type == TIFF_LONG &&\n        psEntry->tdir_count <= 1 )\n    {\n        uint32 offset = psEntry->tdir_offset.toff_long;\n        if( bSwab )\n            CPL_SWAP32PTR(&offset);\n        panOffsetOrCountArray[0] = offset;\n        return true;\n    }\n    else\n    {\n        vsi_l_offset l_nDirOffset = 0;\n        if( hTIFF->tif_flags&TIFF_BIGTIFF )\n        {\n            uint64 offset = psEntry->tdir_offset.toff_long8;\n            if( bSwab )\n                CPL_SWAP64PTR(&offset);\n            l_nDirOffset = offset;\n        }\n        else\n        {\n            uint32 offset = psEntry->tdir_offset.toff_long;\n            if( bSwab )\n                CPL_SWAP32PTR(&offset);\n            l_nDirOffset = offset;\n        }\n\n        if( psEntry->tdir_type == TIFF_SHORT )\n        {\n            return GTiffCacheOffsetOrCount(fp,\n                                    bSwab,\n                                    l_nDirOffset,\n                                    nBlockId,\n                                    nStripArrayAlloc,\n                                    panOffsetOrCountArray,\n                                    sizeof(uint16));\n        }\n        else if( psEntry->tdir_type == TIFF_LONG )\n        {\n            return GTiffCacheOffsetOrCount(fp,\n                                    bSwab,\n                                    l_nDirOffset,\n                                    nBlockId,\n                                    nStripArrayAlloc,\n                                    panOffsetOrCountArray,\n                                    sizeof(uint32));\n        }\n        else\n        {\n            return GTiffCacheOffsetOrCount(fp,\n                                    bSwab,\n                                    l_nDirOffset,\n                                    nBlockId,\n                                    nStripArrayAlloc,\n                                    panOffsetOrCountArray,\n                                    sizeof(uint64));\n        }\n    }\n}\n\n#endif  // #if defined(INTERNAL_LIBTIFF) && defined(DEFER_STRILE_LOAD)\n\n/************************************************************************/\n/*                          IsBlockAvailable()                          */\n/*                                                                      */\n/*      Return true if the indicated strip/tile is available.  We       */\n/*      establish this by testing if the stripbytecount is zero.  If    */\n/*      zero then the block has never been committed to disk.           */\n/************************************************************************/\n\nbool GTiffDataset::IsBlockAvailable( int nBlockId,\n                                     vsi_l_offset* pnOffset,\n                                     vsi_l_offset* pnSize,\n                                     bool *pbErrOccurred )\n\n{\n    if( pbErrOccurred )\n        *pbErrOccurred = false;\n\n    WaitCompletionForBlock(nBlockId);\n\n#if defined(INTERNAL_LIBTIFF) && defined(DEFER_STRILE_LOAD)\n    // Optimization to avoid fetching the whole Strip/TileCounts and\n    // Strip/TileOffsets arrays.\n\n    // Note: if strip choping is in effect, _TIFFFillStrilesInternal()\n    // will have 0-memset td_stripoffset_entry/td_stripbytecount_entry, so\n    // we won't enter the below block\n\n    if( eAccess == GA_ReadOnly &&\n        hTIFF->tif_dir.td_stripoffset_entry.tdir_tag != 0 &&\n        hTIFF->tif_dir.td_stripbytecount_entry.tdir_tag != 0 &&\n        !bStreamingIn )\n    {\n        if( !((hTIFF->tif_dir.td_stripoffset_entry.tdir_type == TIFF_SHORT ||\n               hTIFF->tif_dir.td_stripoffset_entry.tdir_type == TIFF_LONG ||\n               hTIFF->tif_dir.td_stripoffset_entry.tdir_type == TIFF_LONG8) &&\n              (hTIFF->tif_dir.td_stripbytecount_entry.tdir_type == TIFF_SHORT ||\n               hTIFF->tif_dir.td_stripbytecount_entry.tdir_type == TIFF_LONG ||\n               hTIFF->tif_dir.td_stripbytecount_entry.tdir_type == TIFF_LONG8)) )\n        {\n            if( nStripArrayAlloc == 0 )\n            {\n                CPLError(CE_Failure, CPLE_NotSupported,\n                         \"Unhandled type for StripOffset/StripByteCount\");\n                nStripArrayAlloc = ~nStripArrayAlloc;\n            }\n            if( pnOffset )\n                *pnOffset = 0;\n            if( pnSize )\n                *pnSize = 0;\n            if( pbErrOccurred )\n                *pbErrOccurred = true;\n            return false;\n        }\n\n        // The size of tags can be actually lesser than the number of strips\n        // (libtiff accepts such files)\n        if( static_cast<uint32>(nBlockId) >=\n                hTIFF->tif_dir.td_stripoffset_entry.tdir_count ||\n            static_cast<uint32>(nBlockId) >=\n                hTIFF->tif_dir.td_stripbytecount_entry.tdir_count )\n        {\n            // In case the tags aren't large enough.\n            if( pnOffset )\n                *pnOffset = 0;\n            if( pnSize )\n                *pnSize = 0;\n            if( pbErrOccurred )\n                *pbErrOccurred = true;\n            return false;\n        }\n\n        if( hTIFF->tif_dir.td_stripoffset == nullptr )\n        {\n            nStripArrayAlloc = 0;\n        }\n        if( static_cast<uint32>(nBlockId) >= nStripArrayAlloc )\n        {\n            if( nBlockId > 1000000 )\n            {\n                // Avoid excessive memory allocation attempt\n                if( m_nFileSize == 0 )\n                {\n                    VSILFILE* fp = VSI_TIFFGetVSILFile(TIFFClientdata( hTIFF ));\n                    const vsi_l_offset nCurOffset = VSIFTellL(fp);\n                    CPL_IGNORE_RET_VAL( VSIFSeekL(fp, 0, SEEK_END) );\n                    m_nFileSize = VSIFTellL(fp);\n                    CPL_IGNORE_RET_VAL( VSIFSeekL(fp, nCurOffset, SEEK_SET) );\n                }\n                // For such a big blockid we need at least a TIFF_LONG\n                if( static_cast<vsi_l_offset>(nBlockId) >\n                                        m_nFileSize / (2 * sizeof(GUInt32)) )\n                {\n                    CPLError(CE_Failure, CPLE_AppDefined, \"File too short\");\n                    if( pnOffset )\n                        *pnOffset = 0;\n                    if( pnSize )\n                        *pnSize = 0;\n                    if( pbErrOccurred )\n                        *pbErrOccurred = true;\n                    return false;\n                }\n            }\n\n            uint32 nStripArrayAllocBefore = nStripArrayAlloc;\n            uint32 nStripArrayAllocNew;\n            if( nStripArrayAlloc == 0 &&\n                hTIFF->tif_dir.td_nstrips < 1024 * 1024 )\n            {\n                nStripArrayAllocNew = hTIFF->tif_dir.td_nstrips;\n            }\n            else\n            {\n                nStripArrayAllocNew = std::max(\n                    static_cast<uint32>(nBlockId) + 1, 1024U * 512U );\n                if( nStripArrayAllocNew < UINT_MAX / 2  )\n                    nStripArrayAllocNew *= 2;\n                nStripArrayAllocNew = std::min(\n                    nStripArrayAllocNew, hTIFF->tif_dir.td_nstrips);\n            }\n            CPLAssert( static_cast<uint32>(nBlockId) < nStripArrayAllocNew );\n            const uint64 nArraySize64 =\n                static_cast<uint64>(sizeof(uint64)) * nStripArrayAllocNew;\n            const size_t nArraySize = static_cast<size_t>(nArraySize64);\n#if SIZEOF_VOIDP == 4\n            if( nArraySize != nArraySize64 )\n            {\n                CPLError(CE_Failure, CPLE_OutOfMemory,\n                         \"Cannot allocate strip offset and bytecount arrays\");\n                if( pbErrOccurred )\n                    *pbErrOccurred = true;\n                return false;\n            }\n#endif\n            uint64* offsetArray = static_cast<uint64 *>(\n                _TIFFrealloc( hTIFF->tif_dir.td_stripoffset, nArraySize ) );\n            uint64* bytecountArray = static_cast<uint64 *>(\n                _TIFFrealloc( hTIFF->tif_dir.td_stripbytecount, nArraySize ) );\n            if( offsetArray )\n                hTIFF->tif_dir.td_stripoffset = offsetArray;\n            if( bytecountArray )\n                hTIFF->tif_dir.td_stripbytecount = bytecountArray;\n            if( offsetArray && bytecountArray )\n            {\n                nStripArrayAlloc = nStripArrayAllocNew;\n                memset(hTIFF->tif_dir.td_stripoffset + nStripArrayAllocBefore,\n                    0xFF,\n                    (nStripArrayAlloc - nStripArrayAllocBefore) * sizeof(uint64) );\n                memset(hTIFF->tif_dir.td_stripbytecount + nStripArrayAllocBefore,\n                    0xFF,\n                    (nStripArrayAlloc - nStripArrayAllocBefore) * sizeof(uint64) );\n            }\n            else\n            {\n                CPLError(CE_Failure, CPLE_OutOfMemory,\n                         \"Cannot allocate strip offset and bytecount arrays\");\n                _TIFFfree(hTIFF->tif_dir.td_stripoffset);\n                hTIFF->tif_dir.td_stripoffset = nullptr;\n                _TIFFfree(hTIFF->tif_dir.td_stripbytecount);\n                hTIFF->tif_dir.td_stripbytecount = nullptr;\n                nStripArrayAlloc = 0;\n            }\n        }\n        if( hTIFF->tif_dir.td_stripbytecount == nullptr )\n        {\n            if( pbErrOccurred )\n                *pbErrOccurred = true;\n            return false;\n        }\n        if( ~(hTIFF->tif_dir.td_stripoffset[nBlockId]) == 0 ||\n            ~(hTIFF->tif_dir.td_stripbytecount[nBlockId]) == 0 )\n        {\n            VSILFILE* fp = VSI_TIFFGetVSILFile(TIFFClientdata( hTIFF ));\n            const vsi_l_offset nCurOffset = VSIFTellL(fp);\n            if( ~(hTIFF->tif_dir.td_stripoffset[nBlockId]) == 0 )\n            {\n                if( !ReadStripArray( fp,\n                                hTIFF,\n                                &hTIFF->tif_dir.td_stripoffset_entry,\n                                nBlockId,\n                                nStripArrayAlloc,\n                                hTIFF->tif_dir.td_stripoffset ) )\n                {\n                    if( pbErrOccurred )\n                        *pbErrOccurred = true;\n                    return false;\n                }\n            }\n\n            if( ~(hTIFF->tif_dir.td_stripbytecount[nBlockId]) == 0 )\n            {\n                if( !ReadStripArray( fp,\n                                hTIFF,\n                                &hTIFF->tif_dir.td_stripbytecount_entry,\n                                nBlockId,\n                                nStripArrayAlloc,\n                                hTIFF->tif_dir.td_stripbytecount ) )\n                {\n                    if( pbErrOccurred )\n                        *pbErrOccurred = true;\n                    return false;\n                }\n            }\n            if( VSIFSeekL(fp, nCurOffset, SEEK_SET) != 0 )\n            {\n                // For some reason Coverity reports:\n                // Value of non-local \"this->hTIFF->tif_dir.td_stripoffset\"\n                // that was verified to be \"NULL\" is not restored as it was\n                // along other paths.\n                // coverity[end_of_path]\n                if( pbErrOccurred )\n                    *pbErrOccurred = true;\n                return false;\n            }\n        }\n        if( pnOffset )\n            *pnOffset = hTIFF->tif_dir.td_stripoffset[nBlockId];\n        if( pnSize )\n            *pnSize = hTIFF->tif_dir.td_stripbytecount[nBlockId];\n        return hTIFF->tif_dir.td_stripbytecount[nBlockId] != 0;\n    }\n#endif  // defined(INTERNAL_LIBTIFF) && defined(DEFER_STRILE_LOAD)\n    toff_t *panByteCounts = nullptr;\n    toff_t *panOffsets = nullptr;\n    const bool bIsTiled = CPL_TO_BOOL( TIFFIsTiled(hTIFF) );\n\n    if( ( bIsTiled\n          && TIFFGetField( hTIFF, TIFFTAG_TILEBYTECOUNTS, &panByteCounts )\n          && (pnOffset == nullptr ||\n              TIFFGetField( hTIFF, TIFFTAG_TILEOFFSETS, &panOffsets )) )\n        || ( !bIsTiled\n          && TIFFGetField( hTIFF, TIFFTAG_STRIPBYTECOUNTS, &panByteCounts )\n          && (pnOffset == nullptr ||\n              TIFFGetField( hTIFF, TIFFTAG_STRIPOFFSETS, &panOffsets )) ) )\n    {\n        if( panByteCounts == nullptr || (pnOffset != nullptr && panOffsets == nullptr) )\n        {\n            if( pbErrOccurred )\n                *pbErrOccurred = true;\n            return false;\n        }\n        const int nBlockCount =\n            bIsTiled ? TIFFNumberOfTiles(hTIFF) : TIFFNumberOfStrips(hTIFF);\n        if( nBlockId >= nBlockCount )\n        {\n            if( pbErrOccurred )\n                *pbErrOccurred = true;\n            return false;\n        }\n\n        if( pnOffset )\n            *pnOffset = panOffsets[nBlockId];\n        if( pnSize )\n            *pnSize = panByteCounts[nBlockId];\n        return panByteCounts[nBlockId] != 0;\n    }\n    else\n    {\n        if( pbErrOccurred )\n            *pbErrOccurred = true;\n    }\n\n    return false;\n}\n\n/************************************************************************/\n/*                             FlushCache()                             */\n/*                                                                      */\n/*      We override this so we can also flush out local tiff strip      */\n/*      cache if need be.                                               */\n/************************************************************************/\n\nvoid GTiffDataset::FlushCache()\n\n{\n    FlushCacheInternal( true );\n}\n\nvoid GTiffDataset::FlushCacheInternal( bool bFlushDirectory )\n{\n    if( bIsFinalized || ppoActiveDSRef == nullptr )\n        return;\n\n    GDALPamDataset::FlushCache();\n\n    if( bLoadedBlockDirty && nLoadedBlock != -1 )\n        FlushBlockBuf();\n\n    CPLFree( pabyBlockBuf );\n    pabyBlockBuf = nullptr;\n    nLoadedBlock = -1;\n    bLoadedBlockDirty = false;\n\n    // Finish compression\n    if( poCompressThreadPool )\n    {\n        poCompressThreadPool->WaitCompletion();\n\n        // Flush remaining data\n        for( int i = 0; i < static_cast<int>(asCompressionJobs.size()); ++i )\n        {\n            if( asCompressionJobs[i].bReady )\n            {\n                if( asCompressionJobs[i].nCompressedBufferSize )\n                {\n                    WriteRawStripOrTile( asCompressionJobs[i].nStripOrTile,\n                                   asCompressionJobs[i].pabyCompressedBuffer,\n                                   asCompressionJobs[i].nCompressedBufferSize );\n                }\n                asCompressionJobs[i].pabyCompressedBuffer = nullptr;\n                asCompressionJobs[i].nBufferSize = 0;\n                asCompressionJobs[i].bReady = false;\n                asCompressionJobs[i].nStripOrTile = -1;\n            }\n        }\n    }\n\n    if( bFlushDirectory && GetAccess() == GA_Update )\n    {\n        if( !SetDirectory() )\n            return;\n        FlushDirectory();\n    }\n}\n\n/************************************************************************/\n/*                           FlushDirectory()                           */\n/************************************************************************/\n\nvoid GTiffDataset::FlushDirectory()\n\n{\n    if( GetAccess() == GA_Update )\n    {\n        if( bMetadataChanged )\n        {\n            if( !SetDirectory() )\n                return;\n            bNeedsRewrite =\n                    WriteMetadata( this, hTIFF, true, osProfile, osFilename,\n                                   papszCreationOptions );\n            bMetadataChanged = false;\n\n            if( m_bForceUnsetRPC )\n            {\n#ifdef HAVE_UNSETFIELD\n                double *padfRPCTag = nullptr;\n                uint16 nCount;\n                if( TIFFGetField( hTIFF, TIFFTAG_RPCCOEFFICIENT, &nCount, &padfRPCTag ) )\n                {\n                    std::vector<double> zeroes(92);\n                    TIFFSetField( hTIFF, TIFFTAG_RPCCOEFFICIENT, 92, zeroes.data() );\n                    TIFFUnsetField( hTIFF, TIFFTAG_RPCCOEFFICIENT );\n                    bNeedsRewrite = true;\n                }\n#endif\n                GDALWriteRPCTXTFile( osFilename, nullptr );\n                GDALWriteRPBFile( osFilename, nullptr );\n            }\n        }\n\n        if( bGeoTIFFInfoChanged )\n        {\n            if( !SetDirectory() )\n                return;\n            WriteGeoTIFFInfo();\n        }\n\n        if( bNoDataChanged )\n        {\n            if( !SetDirectory() )\n                return;\n            if( bNoDataSet )\n            {\n                WriteNoDataValue( hTIFF, dfNoDataValue );\n            }\n            else\n            {\n                UnsetNoDataValue( hTIFF );\n            }\n            bNeedsRewrite = true;\n            bNoDataChanged = false;\n        }\n\n        if( bNeedsRewrite )\n        {\n#if defined(TIFFLIB_VERSION)\n#if defined(HAVE_TIFFGETSIZEPROC)\n            if( !SetDirectory() )\n                return;\n\n            const TIFFSizeProc pfnSizeProc = TIFFGetSizeProc( hTIFF );\n\n            nDirOffset = pfnSizeProc( TIFFClientdata( hTIFF ) );\n            if( (nDirOffset % 2) == 1 )\n                ++nDirOffset;\n\n            TIFFRewriteDirectory( hTIFF );\n\n            TIFFSetSubDirectory( hTIFF, nDirOffset );\n#elif TIFFLIB_VERSION > 20010925 && TIFFLIB_VERSION != 20011807\n            if( !SetDirectory() )\n                return;\n\n            TIFFRewriteDirectory( hTIFF );\n#endif\n#endif\n            bNeedsRewrite = false;\n        }\n    }\n\n    // There are some circumstances in which we can reach this point\n    // without having made this our directory (SetDirectory()) in which\n    // case we should not risk a flush.\n    if( GetAccess() == GA_Update && TIFFCurrentDirOffset(hTIFF) == nDirOffset )\n    {\n#if defined(BIGTIFF_SUPPORT)\n        const TIFFSizeProc pfnSizeProc = TIFFGetSizeProc( hTIFF );\n\n        toff_t nNewDirOffset = pfnSizeProc( TIFFClientdata( hTIFF ) );\n        if( (nNewDirOffset % 2) == 1 )\n            ++nNewDirOffset;\n\n        TIFFFlush( hTIFF );\n\n        if( nDirOffset != TIFFCurrentDirOffset( hTIFF ) )\n        {\n            nDirOffset = nNewDirOffset;\n            CPLDebug( \"GTiff\",\n                      \"directory moved during flush in FlushDirectory()\" );\n        }\n#else\n        // For libtiff 3.X, the above causes regressions and crashes in\n        // tiff_write.py and tiff_ovr.py.\n        TIFFFlush( hTIFF );\n#endif\n    }\n}\n\n/************************************************************************/\n/*                           CleanOverviews()                           */\n/************************************************************************/\n\nCPLErr GTiffDataset::CleanOverviews()\n\n{\n    CPLAssert( bBase );\n\n    ScanDirectories();\n\n    FlushDirectory();\n    *ppoActiveDSRef = nullptr;\n\n/* -------------------------------------------------------------------- */\n/*      Cleanup overviews objects, and get offsets to all overview      */\n/*      directories.                                                    */\n/* -------------------------------------------------------------------- */\n    std::vector<toff_t> anOvDirOffsets;\n\n    for( int i = 0; i < nOverviewCount; ++i )\n    {\n        anOvDirOffsets.push_back( papoOverviewDS[i]->nDirOffset );\n        delete papoOverviewDS[i];\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Loop through all the directories, translating the offsets       */\n/*      into indexes we can use with TIFFUnlinkDirectory().             */\n/* -------------------------------------------------------------------- */\n    std::vector<uint16> anOvDirIndexes;\n    int iThisOffset = 1;\n\n    TIFFSetDirectory( hTIFF, 0 );\n\n    while( true )\n    {\n        for( int i = 0; i < nOverviewCount; ++i )\n        {\n            if( anOvDirOffsets[i] == TIFFCurrentDirOffset( hTIFF ) )\n            {\n                CPLDebug( \"GTiff\", \"%d -> %d\",\n                          static_cast<int>(anOvDirOffsets[i]), iThisOffset );\n                anOvDirIndexes.push_back( static_cast<uint16>(iThisOffset) );\n            }\n        }\n\n        if( TIFFLastDirectory( hTIFF ) )\n            break;\n\n        TIFFReadDirectory( hTIFF );\n        ++iThisOffset;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Actually unlink the target directories.  Note that we do        */\n/*      this from last to first so as to avoid renumbering any of       */\n/*      the earlier directories we need to remove.                      */\n/* -------------------------------------------------------------------- */\n    while( !anOvDirIndexes.empty() )\n    {\n        TIFFUnlinkDirectory( hTIFF, anOvDirIndexes.back() );\n        anOvDirIndexes.pop_back();\n    }\n\n    CPLFree( papoOverviewDS );\n\n    nOverviewCount = 0;\n    papoOverviewDS = nullptr;\n\n    if( !SetDirectory() )\n        return CE_Failure;\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                   RegisterNewOverviewDataset()                       */\n/************************************************************************/\n\nCPLErr GTiffDataset::RegisterNewOverviewDataset(toff_t nOverviewOffset,\n                                                int l_nJpegQuality)\n{\n    GTiffDataset* poODS = new GTiffDataset();\n    poODS->osFilename = osFilename;\n    poODS->nJpegQuality = l_nJpegQuality;\n    poODS->nZLevel = nZLevel;\n    poODS->nLZMAPreset = nLZMAPreset;\n    poODS->nZSTDLevel = nZSTDLevel;\n    poODS->nWebPLevel = nWebPLevel;\n    poODS->bWebPLossless = bWebPLossless;\n    poODS->nJpegTablesMode = nJpegTablesMode;\n#if HAVE_LERC\n    poODS->dfMaxZError = dfMaxZError;\n    memcpy(poODS->anLercAddCompressionAndVersion, anLercAddCompressionAndVersion,\n           sizeof(anLercAddCompressionAndVersion));\n#endif\n\n    if( poODS->OpenOffset( hTIFF, ppoActiveDSRef, nOverviewOffset, false,\n                            GA_Update ) != CE_None )\n    {\n        delete poODS;\n        return CE_Failure;\n    }\n\n    ++nOverviewCount;\n    papoOverviewDS = static_cast<GTiffDataset **>(\n        CPLRealloc( papoOverviewDS,\n                    nOverviewCount * (sizeof(void*))) );\n    papoOverviewDS[nOverviewCount-1] = poODS;\n    poODS->poBaseDS = this;\n    poODS->bIsOverview_ = true;\n    return CE_None;\n}\n\n/************************************************************************/\n/*                     CreateTIFFColorTable()                           */\n/************************************************************************/\n\nstatic void CreateTIFFColorTable(GDALColorTable* poColorTable,\n                                 int nBits,\n                                 std::vector<unsigned short>& anTRed,\n                                 std::vector<unsigned short>& anTGreen,\n                                 std::vector<unsigned short>& anTBlue,\n                                 unsigned short*& panRed,\n                                 unsigned short*& panGreen,\n                                 unsigned short*& panBlue)\n{\n    int nColors;\n\n    if( nBits == 8 )\n        nColors = 256;\n    else if( nBits < 8 )\n        nColors = 1 << nBits;\n    else\n        nColors = 65536;\n\n    anTRed.resize(nColors,0);\n    anTGreen.resize(nColors,0);\n    anTBlue.resize(nColors,0);\n\n    for( int iColor = 0; iColor < nColors; ++iColor )\n    {\n        if( iColor < poColorTable->GetColorEntryCount() )\n        {\n            GDALColorEntry sRGB;\n\n            poColorTable->GetColorEntryAsRGB( iColor, &sRGB );\n\n            anTRed[iColor] = static_cast<unsigned short>(257 * sRGB.c1);\n            anTGreen[iColor] = static_cast<unsigned short>(257 * sRGB.c2);\n            anTBlue[iColor] = static_cast<unsigned short>(257 * sRGB.c3);\n        }\n        else\n        {\n            anTRed[iColor] = 0;\n            anTGreen[iColor] = 0;\n            anTBlue[iColor] = 0;\n        }\n    }\n\n    panRed = &(anTRed[0]);\n    panGreen = &(anTGreen[0]);\n    panBlue = &(anTBlue[0]);\n}\n\n/************************************************************************/\n/*                  CreateOverviewsFromSrcOverviews()                   */\n/************************************************************************/\n\nCPLErr GTiffDataset::CreateOverviewsFromSrcOverviews(GDALDataset* poSrcDS)\n{\n    CPLAssert(poSrcDS->GetRasterCount() != 0);\n    CPLAssert(nOverviewCount == 0);\n\n    ScanDirectories();\n\n/* -------------------------------------------------------------------- */\n/*      Move to the directory for this dataset.                         */\n/* -------------------------------------------------------------------- */\n    if( !SetDirectory() )\n        return CE_Failure;\n    FlushDirectory();\n\n    int nOvBitsPerSample = nBitsPerSample;\n\n/* -------------------------------------------------------------------- */\n/*      Do we have a palette?  If so, create a TIFF compatible version. */\n/* -------------------------------------------------------------------- */\n    std::vector<unsigned short> anTRed;\n    std::vector<unsigned short> anTGreen;\n    std::vector<unsigned short> anTBlue;\n    unsigned short *panRed = nullptr;\n    unsigned short *panGreen = nullptr;\n    unsigned short *panBlue = nullptr;\n\n    if( nPhotometric == PHOTOMETRIC_PALETTE && poColorTable != nullptr )\n    {\n        CreateTIFFColorTable(poColorTable, nOvBitsPerSample,\n                             anTRed, anTGreen, anTBlue,\n                             panRed, panGreen, panBlue);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Do we need some metadata for the overviews?                     */\n/* -------------------------------------------------------------------- */\n    CPLString osMetadata;\n\n    GTIFFBuildOverviewMetadata( \"NONE\", this, osMetadata );\n\n/* -------------------------------------------------------------------- */\n/*      Fetch extra sample tag                                          */\n/* -------------------------------------------------------------------- */\n    uint16 *panExtraSampleValues = nullptr;\n    uint16 nExtraSamples = 0;\n\n    if( TIFFGetField( hTIFF, TIFFTAG_EXTRASAMPLES, &nExtraSamples,\n                      &panExtraSampleValues) )\n    {\n        uint16* panExtraSampleValuesNew =\n            static_cast<uint16*>(\n                CPLMalloc(nExtraSamples * sizeof(uint16)) );\n        memcpy( panExtraSampleValuesNew, panExtraSampleValues,\n                nExtraSamples * sizeof(uint16));\n        panExtraSampleValues = panExtraSampleValuesNew;\n    }\n    else\n    {\n        panExtraSampleValues = nullptr;\n        nExtraSamples = 0;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Fetch predictor tag                                             */\n/* -------------------------------------------------------------------- */\n    uint16 nPredictor = PREDICTOR_NONE;\n    if( nCompression == COMPRESSION_LZW ||\n        nCompression == COMPRESSION_ADOBE_DEFLATE ||\n        nCompression == COMPRESSION_ZSTD )\n        TIFFGetField( hTIFF, TIFFTAG_PREDICTOR, &nPredictor );\n    int nOvrBlockXSize = 0;\n    int nOvrBlockYSize = 0;\n    GTIFFGetOverviewBlockSize(&nOvrBlockXSize, &nOvrBlockYSize);\n\n    int nSrcOverviews = poSrcDS->GetRasterBand(1)->GetOverviewCount();\n    CPLErr eErr = CE_None;\n\n    for( int i = 0; i < nSrcOverviews && eErr == CE_None; ++i )\n    {\n        GDALRasterBand* poOvrBand = poSrcDS->GetRasterBand(1)->GetOverview(i);\n\n        int nOXSize = poOvrBand->GetXSize();\n        int nOYSize = poOvrBand->GetYSize();\n\n        int nOvrJpegQuality = nJpegQuality;\n        if( nCompression == COMPRESSION_JPEG &&\n            CPLGetConfigOption( \"JPEG_QUALITY_OVERVIEW\", nullptr ) != nullptr )\n        {\n            nOvrJpegQuality =\n                atoi(CPLGetConfigOption(\"JPEG_QUALITY_OVERVIEW\",\"75\"));\n        }\n\n        CPLString osNoData; // don't move this in inner scope\n        const char* pszNoData = nullptr;\n        if( bNoDataSet )\n        {\n            osNoData = GTiffFormatGDALNoDataTagValue(dfNoDataValue);\n            pszNoData = osNoData.c_str();\n        }\n\n        toff_t nOverviewOffset =\n                GTIFFWriteDirectory(hTIFF, FILETYPE_REDUCEDIMAGE,\n                                    nOXSize, nOYSize,\n                                    nOvBitsPerSample, nPlanarConfig,\n                                    nSamplesPerPixel,\n                                    nOvrBlockXSize,\n                                    nOvrBlockYSize,\n                                    TRUE,\n                                    nCompression, nPhotometric, nSampleFormat,\n                                    nPredictor,\n                                    panRed, panGreen, panBlue,\n                                    nExtraSamples, panExtraSampleValues,\n                                    osMetadata,\n                                    nOvrJpegQuality >= 0 ?\n                                        CPLSPrintf(\"%d\", nOvrJpegQuality) : nullptr,\n                                    CPLSPrintf(\"%d\", nJpegTablesMode),\n                                    pszNoData,\n#ifdef HAVE_LERC\n                                    anLercAddCompressionAndVersion\n#else\n                                    nullptr\n#endif\n                                   );\n\n        if( nOverviewOffset == 0 )\n            eErr = CE_Failure;\n        else\n            eErr = RegisterNewOverviewDataset(nOverviewOffset, nOvrJpegQuality);\n    }\n\n    CPLFree(panExtraSampleValues);\n    panExtraSampleValues = nullptr;\n\n/* -------------------------------------------------------------------- */\n/*      Create overviews for the mask.                                  */\n/* -------------------------------------------------------------------- */\n    if( eErr == CE_None )\n        eErr = CreateInternalMaskOverviews(nOvrBlockXSize, nOvrBlockYSize);\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                       CreateInternalMaskOverviews()                  */\n/************************************************************************/\n\nCPLErr GTiffDataset::CreateInternalMaskOverviews(int nOvrBlockXSize,\n                                                 int nOvrBlockYSize)\n{\n    ScanDirectories();\n\n/* -------------------------------------------------------------------- */\n/*      Create overviews for the mask.                                  */\n/* -------------------------------------------------------------------- */\n    CPLErr eErr = CE_None;\n\n    const char* pszInternalMask =\n        CPLGetConfigOption(\"GDAL_TIFF_INTERNAL_MASK\", nullptr);\n    if( poMaskDS != nullptr &&\n        poMaskDS->GetRasterCount() == 1 &&\n        (pszInternalMask == nullptr || CPLTestBool(pszInternalMask)) )\n    {\n        int nMaskOvrCompression;\n        if( strstr(GDALGetMetadataItem(GDALGetDriverByName( \"GTiff\" ),\n                                       GDAL_DMD_CREATIONOPTIONLIST, nullptr ),\n                   \"<Value>DEFLATE</Value>\") != nullptr )\n            nMaskOvrCompression = COMPRESSION_ADOBE_DEFLATE;\n        else\n            nMaskOvrCompression = COMPRESSION_PACKBITS;\n\n        for( int i = 0; i < nOverviewCount; ++i )\n        {\n            if( papoOverviewDS[i]->poMaskDS == nullptr )\n            {\n                const toff_t nOverviewOffset =\n                    GTIFFWriteDirectory(\n                        hTIFF, FILETYPE_REDUCEDIMAGE | FILETYPE_MASK,\n                        papoOverviewDS[i]->nRasterXSize,\n                        papoOverviewDS[i]->nRasterYSize,\n                        1, PLANARCONFIG_CONTIG,\n                        1, nOvrBlockXSize, nOvrBlockYSize, TRUE,\n                        nMaskOvrCompression, PHOTOMETRIC_MASK,\n                        SAMPLEFORMAT_UINT, PREDICTOR_NONE,\n                        nullptr, nullptr, nullptr, 0, nullptr,\n                        \"\",\n                        nullptr, nullptr, nullptr, nullptr );\n\n                if( nOverviewOffset == 0 )\n                {\n                    eErr = CE_Failure;\n                    continue;\n                }\n\n                GTiffDataset *poODS = new GTiffDataset();\n                poODS->osFilename = osFilename;\n                if( poODS->OpenOffset( hTIFF, ppoActiveDSRef,\n                                       nOverviewOffset, false,\n                                       GA_Update ) != CE_None )\n                {\n                    delete poODS;\n                    eErr = CE_Failure;\n                }\n                else\n                {\n                    poODS->bPromoteTo8Bits =\n                        CPLTestBool(\n                            CPLGetConfigOption(\n                                \"GDAL_TIFF_INTERNAL_MASK_TO_8BIT\", \"YES\" ) );\n                    poODS->poBaseDS = this;\n                    papoOverviewDS[i]->poMaskDS = poODS;\n                    ++poMaskDS->nOverviewCount;\n                    poMaskDS->papoOverviewDS = static_cast<GTiffDataset **>(\n                        CPLRealloc(\n                            poMaskDS->papoOverviewDS,\n                            poMaskDS->nOverviewCount * (sizeof(void*))) );\n                    poMaskDS->papoOverviewDS[poMaskDS->nOverviewCount-1] =\n                        poODS;\n                }\n            }\n        }\n    }\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                          IBuildOverviews()                           */\n/************************************************************************/\n\nCPLErr GTiffDataset::IBuildOverviews(\n    const char * pszResampling,\n    int nOverviews, int * panOverviewList,\n    int nBandsIn, int * panBandList,\n    GDALProgressFunc pfnProgress, void * pProgressData )\n\n{\n    ScanDirectories();\n\n    // Make implicit JPEG overviews invisible, but do not destroy\n    // them in case they are already used (not sure that the client\n    // has the right to do that.  Behaviour maybe undefined in GDAL API.\n    nJPEGOverviewCount = 0;\n\n/* -------------------------------------------------------------------- */\n/*      If RRD or external OVR overviews requested, then invoke         */\n/*      generic handling.                                               */\n/* -------------------------------------------------------------------- */\n    bool bUseGenericHandling = false;\n\n    if( CPLTestBool(CPLGetConfigOption( \"USE_RRD\", \"NO\" ))\n        || CPLTestBool(CPLGetConfigOption( \"TIFF_USE_OVR\", \"NO\" )) )\n    {\n        bUseGenericHandling = true;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If we don't have read access, then create the overviews         */\n/*      externally.                                                     */\n/* -------------------------------------------------------------------- */\n    if( GetAccess() != GA_Update )\n    {\n        CPLDebug( \"GTiff\",\n                  \"File open for read-only accessing, \"\n                  \"creating overviews externally.\" );\n\n        bUseGenericHandling = true;\n    }\n\n    if( bUseGenericHandling )\n    {\n        if( nOverviewCount != 0 )\n        {\n            CPLError(\n                CE_Failure, CPLE_NotSupported,\n                \"Cannot add external overviews when there are already \"\n                \"internal overviews\" );\n            return CE_Failure;\n        }\n\n        return GDALDataset::IBuildOverviews(\n            pszResampling, nOverviews, panOverviewList,\n            nBandsIn, panBandList, pfnProgress, pProgressData );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Our TIFF overview support currently only works safely if all    */\n/*      bands are handled at the same time.                             */\n/* -------------------------------------------------------------------- */\n    if( nBandsIn != GetRasterCount() )\n    {\n        CPLError( CE_Failure, CPLE_NotSupported,\n                  \"Generation of overviews in TIFF currently only \"\n                  \"supported when operating on all bands.  \"\n                  \"Operation failed.\" );\n        return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If zero overviews were requested, we need to clear all          */\n/*      existing overviews.                                             */\n/* -------------------------------------------------------------------- */\n    if( nOverviews == 0 )\n    {\n        if( nOverviewCount == 0 )\n            return GDALDataset::IBuildOverviews(\n                pszResampling, nOverviews, panOverviewList,\n                nBandsIn, panBandList, pfnProgress, pProgressData );\n\n        return CleanOverviews();\n    }\n\n/* -------------------------------------------------------------------- */\n/*      libtiff 3.X has issues when generating interleaved overviews.   */\n/*      so generate them one after another one.                         */\n/* -------------------------------------------------------------------- */\n\n    CPLErr eErr = CE_None;\n\n#ifndef BIGTIFF_SUPPORT\n    if( nOverviews > 1 )\n    {\n        double* padfOvrRasterFactor =\n            static_cast<double*>( CPLMalloc(sizeof(double) * nOverviews) );\n        double dfTotal = 0;\n        for( int i = 0; i < nOverviews; ++i )\n        {\n            if( panOverviewList[i] <= 0 )\n            {\n                CPLError(CE_Failure, CPLE_AppDefined,\n                         \"Invalid overview factor : %d\", panOverviewList[i]);\n                eErr = CE_Failure;\n                break;\n            }\n            padfOvrRasterFactor[i] =\n                1.0 / (panOverviewList[i] * panOverviewList[i]);\n            dfTotal += padfOvrRasterFactor[i];\n        }\n\n        double dfAcc = 0.0;\n        for( int i = 0; i < nOverviews && eErr == CE_None; ++i )\n        {\n            void *pScaledProgressData =\n                GDALCreateScaledProgress(\n                    dfAcc / dfTotal,\n                    (dfAcc + padfOvrRasterFactor[i]) / dfTotal,\n                    pfnProgress, pProgressData );\n            dfAcc += padfOvrRasterFactor[i];\n\n            eErr = IBuildOverviews(\n                pszResampling, 1, &panOverviewList[i],\n                nBandsIn, panBandList, GDALScaledProgress,\n                pScaledProgressData );\n\n            GDALDestroyScaledProgress(pScaledProgressData);\n        }\n\n        CPLFree(padfOvrRasterFactor);\n\n        return eErr;\n    }\n#endif\n\n/* -------------------------------------------------------------------- */\n/*      Initialize progress counter.                                    */\n/* -------------------------------------------------------------------- */\n    if( !pfnProgress( 0.0, nullptr, pProgressData ) )\n    {\n        CPLError( CE_Failure, CPLE_UserInterrupt, \"User terminated\" );\n        return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Move to the directory for this dataset.                         */\n/* -------------------------------------------------------------------- */\n    if( !SetDirectory() )\n        return CE_Failure;\n    FlushDirectory();\n\n/* -------------------------------------------------------------------- */\n/*      If we are averaging bit data to grayscale we need to create     */\n/*      8bit overviews.                                                 */\n/* -------------------------------------------------------------------- */\n    int nOvBitsPerSample = nBitsPerSample;\n\n    if( STARTS_WITH_CI(pszResampling, \"AVERAGE_BIT2\") )\n        nOvBitsPerSample = 8;\n\n/* -------------------------------------------------------------------- */\n/*      Do we have a palette?  If so, create a TIFF compatible version. */\n/* -------------------------------------------------------------------- */\n    std::vector<unsigned short> anTRed;\n    std::vector<unsigned short> anTGreen;\n    std::vector<unsigned short> anTBlue;\n    unsigned short *panRed = nullptr;\n    unsigned short *panGreen = nullptr;\n    unsigned short *panBlue = nullptr;\n\n    if( nPhotometric == PHOTOMETRIC_PALETTE && poColorTable != nullptr )\n    {\n        CreateTIFFColorTable(poColorTable, nOvBitsPerSample,\n                             anTRed, anTGreen, anTBlue,\n                             panRed, panGreen, panBlue);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Do we need some metadata for the overviews?                     */\n/* -------------------------------------------------------------------- */\n    CPLString osMetadata;\n\n    GTIFFBuildOverviewMetadata( pszResampling, this, osMetadata );\n\n/* -------------------------------------------------------------------- */\n/*      Fetch extra sample tag                                          */\n/* -------------------------------------------------------------------- */\n    uint16 *panExtraSampleValues = nullptr;\n    uint16 nExtraSamples = 0;\n\n    if( TIFFGetField( hTIFF, TIFFTAG_EXTRASAMPLES, &nExtraSamples,\n                      &panExtraSampleValues) )\n    {\n        uint16* panExtraSampleValuesNew =\n            static_cast<uint16*>( CPLMalloc(nExtraSamples * sizeof(uint16)) );\n        memcpy( panExtraSampleValuesNew, panExtraSampleValues,\n                nExtraSamples * sizeof(uint16) );\n        panExtraSampleValues = panExtraSampleValuesNew;\n    }\n    else\n    {\n        panExtraSampleValues = nullptr;\n        nExtraSamples = 0;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Fetch predictor tag                                             */\n/* -------------------------------------------------------------------- */\n    uint16 nPredictor = PREDICTOR_NONE;\n    if( nCompression == COMPRESSION_LZW ||\n        nCompression == COMPRESSION_ADOBE_DEFLATE ||\n        nCompression == COMPRESSION_ZSTD )\n        TIFFGetField( hTIFF, TIFFTAG_PREDICTOR, &nPredictor );\n\n/* -------------------------------------------------------------------- */\n/*      Establish which of the overview levels we already have, and     */\n/*      which are new.  We assume that band 1 of the file is            */\n/*      representative.                                                 */\n/* -------------------------------------------------------------------- */\n    int nOvrBlockXSize = 0;\n    int nOvrBlockYSize = 0;\n    GTIFFGetOverviewBlockSize(&nOvrBlockXSize, &nOvrBlockYSize);\n    std::vector<bool> abRequireNewOverview(nOverviews, true);\n    for( int i = 0; i < nOverviews && eErr == CE_None; ++i )\n    {\n        for( int j = 0; j < nOverviewCount && eErr == CE_None; ++j )\n        {\n            GTiffDataset *poODS = papoOverviewDS[j];\n\n            const int nOvFactor =\n                GDALComputeOvFactor(poODS->GetRasterXSize(),\n                                    GetRasterXSize(),\n                                    poODS->GetRasterYSize(),\n                                    GetRasterYSize());\n\n            // If we already have a 1x1 overview and this new one would result\n            // in it too, then don't create it.\n            if( poODS->GetRasterXSize() == 1 &&\n                poODS->GetRasterYSize() == 1 &&\n                (GetRasterXSize() + panOverviewList[i] - 1)\n                    / panOverviewList[i] == 1 &&\n                (GetRasterYSize() + panOverviewList[i] - 1)\n                    / panOverviewList[i] == 1 )\n            {\n                abRequireNewOverview[i] = false;\n                break;\n            }\n\n            if( nOvFactor == panOverviewList[i]\n                || nOvFactor == GDALOvLevelAdjust2( panOverviewList[i],\n                                                    GetRasterXSize(),\n                                                    GetRasterYSize() ) )\n            {\n                abRequireNewOverview[i] = false;\n                break;\n            }\n        }\n\n        if( abRequireNewOverview[i] )\n        {\n            const int nOXSize =\n                (GetRasterXSize() + panOverviewList[i] - 1)\n                / panOverviewList[i];\n            const int nOYSize =\n                (GetRasterYSize() + panOverviewList[i] - 1)\n                / panOverviewList[i];\n\n            int nOvrJpegQuality = nJpegQuality;\n            if( nCompression == COMPRESSION_JPEG &&\n                CPLGetConfigOption( \"JPEG_QUALITY_OVERVIEW\", nullptr ) != nullptr )\n            {\n                nOvrJpegQuality =\n                    atoi(CPLGetConfigOption(\"JPEG_QUALITY_OVERVIEW\",\"75\"));\n            }\n\n            CPLString osNoData; // don't move this in inner scope\n            const char* pszNoData = nullptr;\n            if( bNoDataSet )\n            {\n                osNoData = GTiffFormatGDALNoDataTagValue(dfNoDataValue);\n                pszNoData = osNoData.c_str();\n            }\n\n            const toff_t nOverviewOffset =\n                GTIFFWriteDirectory(\n                    hTIFF, FILETYPE_REDUCEDIMAGE,\n                    nOXSize, nOYSize,\n                    nOvBitsPerSample, nPlanarConfig,\n                    nSamplesPerPixel, nOvrBlockXSize, nOvrBlockYSize, TRUE,\n                    nCompression, nPhotometric, nSampleFormat,\n                    nPredictor,\n                    panRed, panGreen, panBlue,\n                    nExtraSamples, panExtraSampleValues,\n                    osMetadata,\n                    nOvrJpegQuality >= 0 ?\n                                CPLSPrintf(\"%d\", nOvrJpegQuality) : nullptr,\n                    CPLSPrintf(\"%d\", nJpegTablesMode),\n                    pszNoData,\n#ifdef HAVE_LERC\n                    anLercAddCompressionAndVersion\n#else\n                    nullptr\n#endif\n            );\n\n            if( nOverviewOffset == 0 )\n                eErr = CE_Failure;\n            else\n                eErr = RegisterNewOverviewDataset(nOverviewOffset,\n                                                  nOvrJpegQuality);\n        }\n    }\n\n    CPLFree(panExtraSampleValues);\n    panExtraSampleValues = nullptr;\n\n/* -------------------------------------------------------------------- */\n/*      Create overviews for the mask.                                  */\n/* -------------------------------------------------------------------- */\n    if( eErr != CE_None )\n        return eErr;\n\n    eErr = CreateInternalMaskOverviews(nOvrBlockXSize, nOvrBlockYSize);\n\n/* -------------------------------------------------------------------- */\n/*      Refresh overviews for the mask                                  */\n/* -------------------------------------------------------------------- */\n    if( poMaskDS != nullptr &&\n        poMaskDS->GetRasterCount() == 1 )\n    {\n        int nMaskOverviews = 0;\n\n        GDALRasterBand **papoOverviewBands = static_cast<GDALRasterBand **>(\n            CPLCalloc(sizeof(void*),nOverviewCount) );\n        for( int i = 0; i < nOverviewCount; ++i )\n        {\n            if( papoOverviewDS[i]->poMaskDS != nullptr )\n            {\n                papoOverviewBands[nMaskOverviews++] =\n                        papoOverviewDS[i]->poMaskDS->GetRasterBand(1);\n            }\n        }\n        eErr = GDALRegenerateOverviews(\n            poMaskDS->GetRasterBand(1),\n            nMaskOverviews,\n            reinterpret_cast<GDALRasterBandH *>( papoOverviewBands ),\n            pszResampling, GDALDummyProgress, nullptr );\n        CPLFree(papoOverviewBands);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Refresh old overviews that were listed.                         */\n/* -------------------------------------------------------------------- */\n    if( nPlanarConfig == PLANARCONFIG_CONTIG &&\n        GDALDataTypeIsComplex(GetRasterBand( panBandList[0] )->\n                              GetRasterDataType()) == FALSE &&\n        GetRasterBand( panBandList[0] )->GetColorTable() == nullptr &&\n        (STARTS_WITH_CI(pszResampling, \"NEAR\") ||\n         EQUAL(pszResampling, \"AVERAGE\") ||\n         EQUAL(pszResampling, \"GAUSS\") ||\n         EQUAL(pszResampling, \"CUBIC\") ||\n         EQUAL(pszResampling, \"CUBICSPLINE\") ||\n         EQUAL(pszResampling, \"LANCZOS\") ||\n         EQUAL(pszResampling, \"BILINEAR\")) )\n    {\n        // In the case of pixel interleaved compressed overviews, we want to\n        // generate the overviews for all the bands block by block, and not\n        // band after band, in order to write the block once and not loose\n        // space in the TIFF file.  We also use that logic for uncompressed\n        // overviews, since GDALRegenerateOverviewsMultiBand() will be able to\n        // trigger cascading overview regeneration even in the presence\n        // of an alpha band.\n\n        int nNewOverviews = 0;\n\n        GDALRasterBand ***papapoOverviewBands =\n            static_cast<GDALRasterBand ***>(CPLCalloc(sizeof(void*),nBandsIn));\n        GDALRasterBand **papoBandList =\n            static_cast<GDALRasterBand **>(CPLCalloc(sizeof(void*),nBandsIn));\n        for( int iBand = 0; iBand < nBandsIn; ++iBand )\n        {\n            GDALRasterBand* poBand = GetRasterBand( panBandList[iBand] );\n\n            papoBandList[iBand] = poBand;\n            papapoOverviewBands[iBand] =\n                static_cast<GDALRasterBand **>( CPLCalloc(\n                    sizeof(void*), poBand->GetOverviewCount()) );\n\n            int iCurOverview = 0;\n            std::vector<bool> abAlreadyUsedOverviewBand(\n                poBand->GetOverviewCount(), false);\n\n            for( int i = 0; i < nOverviews; ++i )\n            {\n                for( int j = 0; j < poBand->GetOverviewCount(); ++j )\n                {\n                    if( abAlreadyUsedOverviewBand[j] )\n                        continue;\n\n                    int    nOvFactor;\n                    GDALRasterBand * poOverview = poBand->GetOverview( j );\n\n                    nOvFactor = GDALComputeOvFactor(poOverview->GetXSize(),\n                                                     poBand->GetXSize(),\n                                                     poOverview->GetYSize(),\n                                                     poBand->GetYSize());\n\n                    int bHasNoData = FALSE;\n                    double noDataValue = poBand->GetNoDataValue(&bHasNoData);\n\n                    if( bHasNoData )\n                        poOverview->SetNoDataValue(noDataValue);\n\n                    if( nOvFactor == panOverviewList[i]\n                        || nOvFactor == GDALOvLevelAdjust2(\n                                            panOverviewList[i],\n                                            poBand->GetXSize(),\n                                            poBand->GetYSize() ) )\n                    {\n                        abAlreadyUsedOverviewBand[j] = true;\n                        CPLAssert(iCurOverview < poBand->GetOverviewCount());\n                        papapoOverviewBands[iBand][iCurOverview] = poOverview;\n                        ++iCurOverview ;\n                        break;\n                    }\n                }\n            }\n\n            if( nNewOverviews == 0 )\n            {\n                nNewOverviews = iCurOverview;\n            }\n            else if( nNewOverviews != iCurOverview )\n            {\n                CPLAssert(false);\n                return CE_Failure;\n            }\n        }\n\n        GDALRegenerateOverviewsMultiBand( nBandsIn, papoBandList,\n                                          nNewOverviews, papapoOverviewBands,\n                                          pszResampling, pfnProgress,\n                                          pProgressData );\n\n        for( int iBand = 0; iBand < nBandsIn; ++iBand )\n        {\n            CPLFree(papapoOverviewBands[iBand]);\n        }\n        CPLFree(papapoOverviewBands);\n        CPLFree(papoBandList);\n    }\n    else\n    {\n        GDALRasterBand **papoOverviewBands = static_cast<GDALRasterBand **>(\n            CPLCalloc(sizeof(void*), nOverviews) );\n\n        for( int iBand = 0; iBand < nBandsIn && eErr == CE_None; ++iBand )\n        {\n            GDALRasterBand *poBand = GetRasterBand( panBandList[iBand] );\n            if( poBand == nullptr )\n            {\n                eErr = CE_Failure;\n                break;\n            }\n\n            std::vector<bool> abAlreadyUsedOverviewBand(\n                poBand->GetOverviewCount(), false);\n\n            int nNewOverviews = 0;\n            for( int i = 0; i < nOverviews; ++i )\n            {\n                for( int j = 0; j < poBand->GetOverviewCount(); ++j )\n                {\n                    if( abAlreadyUsedOverviewBand[j] )\n                        continue;\n\n                    GDALRasterBand * poOverview = poBand->GetOverview( j );\n\n                    int bHasNoData = FALSE;\n                    double noDataValue = poBand->GetNoDataValue(&bHasNoData);\n\n                    if( bHasNoData )\n                        poOverview->SetNoDataValue(noDataValue);\n\n                    const int nOvFactor =\n                        GDALComputeOvFactor(poOverview->GetXSize(),\n                                            poBand->GetXSize(),\n                                            poOverview->GetYSize(),\n                                            poBand->GetYSize());\n\n                    if( nOvFactor == panOverviewList[i]\n                        || nOvFactor == GDALOvLevelAdjust2(\n                                            panOverviewList[i],\n                                            poBand->GetXSize(),\n                                            poBand->GetYSize() ) )\n                    {\n                        abAlreadyUsedOverviewBand[j] = true;\n                        CPLAssert(nNewOverviews < poBand->GetOverviewCount());\n                        papoOverviewBands[nNewOverviews++] = poOverview;\n                        break;\n                    }\n                }\n            }\n\n            void *pScaledProgressData =\n                GDALCreateScaledProgress(\n                    iBand / static_cast<double>( nBandsIn ),\n                    (iBand + 1) / static_cast<double>( nBandsIn ),\n                    pfnProgress, pProgressData );\n\n            eErr = GDALRegenerateOverviews(\n                poBand,\n                nNewOverviews,\n                reinterpret_cast<GDALRasterBandH *>( papoOverviewBands ),\n                pszResampling,\n                GDALScaledProgress,\n                pScaledProgressData );\n\n            GDALDestroyScaledProgress( pScaledProgressData );\n        }\n\n    /* -------------------------------------------------------------------- */\n    /*      Cleanup                                                         */\n    /* -------------------------------------------------------------------- */\n        CPLFree( papoOverviewBands );\n    }\n\n    pfnProgress( 1.0, nullptr, pProgressData );\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                      GTiffWriteDummyGeokeyDirectory()                */\n/************************************************************************/\n\nstatic void GTiffWriteDummyGeokeyDirectory( TIFF* hTIFF )\n{\n    // If we have existing geokeys, try to wipe them\n    // by writing a dummy geokey directory. (#2546)\n    uint16 *panVI = nullptr;\n    uint16 nKeyCount = 0;\n\n    if( TIFFGetField( hTIFF, TIFFTAG_GEOKEYDIRECTORY,\n                        &nKeyCount, &panVI ) )\n    {\n        GUInt16 anGKVersionInfo[4] = { 1, 1, 0, 0 };\n        double adfDummyDoubleParams[1] = { 0.0 };\n        TIFFSetField( hTIFF, TIFFTAG_GEOKEYDIRECTORY,\n                        4, anGKVersionInfo );\n        TIFFSetField( hTIFF, TIFFTAG_GEODOUBLEPARAMS,\n                        1, adfDummyDoubleParams );\n        TIFFSetField( hTIFF, TIFFTAG_GEOASCIIPARAMS, \"\" );\n    }\n}\n\n#if LIBGEOTIFF_VERSION >= 1430\n\n/************************************************************************/\n/*               GTiffDatasetLibGeotiffErrorCallback()                  */\n/************************************************************************/\n\nstatic void GTiffDatasetLibGeotiffErrorCallback(GTIF*,\n                                                int level,\n                                                const char* pszMsg, ...)\n{\n    va_list ap;\n    va_start(ap, pszMsg);\n    CPLErrorV( (level == LIBGEOTIFF_WARNING ) ? CE_Warning : CE_Failure,\n               CPLE_AppDefined, pszMsg, ap );\n    va_end(ap);\n}\n\n/************************************************************************/\n/*                           GTiffDatasetGTIFNew()                      */\n/************************************************************************/\n\nstatic GTIF* GTiffDatasetGTIFNew( TIFF* hTIFF )\n{\n    return GTIFNewEx(hTIFF, GTiffDatasetLibGeotiffErrorCallback, nullptr);\n}\n#else\n\n/************************************************************************/\n/*                           GTiffDatasetGTIFNew()                      */\n/************************************************************************/\n\nstatic GTIF* GTiffDatasetGTIFNew( TIFF* hTIFF )\n{\n    return GTIFNew(hTIFF);\n}\n#endif\n\n\n/************************************************************************/\n/*                          WriteGeoTIFFInfo()                          */\n/************************************************************************/\n\nvoid GTiffDataset::WriteGeoTIFFInfo()\n\n{\n    bool bPixelIsPoint = false;\n    bool bPointGeoIgnore = false;\n\n    const char* pszAreaOrPoint =\n        GTiffDataset::GetMetadataItem( GDALMD_AREA_OR_POINT );\n    if( pszAreaOrPoint && EQUAL(pszAreaOrPoint, GDALMD_AOP_POINT) )\n    {\n        bPixelIsPoint = true;\n        bPointGeoIgnore =\n            CPLTestBool( CPLGetConfigOption( \"GTIFF_POINT_GEO_IGNORE\",\n                                             \"FALSE\") );\n    }\n\n    if( bForceUnsetGTOrGCPs )\n    {\n        bNeedsRewrite = true;\n        bForceUnsetGTOrGCPs = false;\n\n#ifdef HAVE_UNSETFIELD\n        TIFFUnsetField( hTIFF, TIFFTAG_GEOPIXELSCALE );\n        TIFFUnsetField( hTIFF, TIFFTAG_GEOTIEPOINTS );\n        TIFFUnsetField( hTIFF, TIFFTAG_GEOTRANSMATRIX );\n#endif\n    }\n\n    if( bForceUnsetProjection )\n    {\n        bNeedsRewrite = true;\n        bForceUnsetProjection = false;\n\n#ifdef HAVE_UNSETFIELD\n        TIFFUnsetField( hTIFF, TIFFTAG_GEOKEYDIRECTORY );\n        TIFFUnsetField( hTIFF, TIFFTAG_GEODOUBLEPARAMS );\n        TIFFUnsetField( hTIFF, TIFFTAG_GEOASCIIPARAMS );\n#else\n        GTiffWriteDummyGeokeyDirectory(hTIFF);\n#endif\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Write geotransform if valid.                                    */\n/* -------------------------------------------------------------------- */\n    if( bGeoTransformValid )\n    {\n        bNeedsRewrite = true;\n\n/* -------------------------------------------------------------------- */\n/*      Clear old tags to ensure we don't end up with conflicting       */\n/*      information. (#2625)                                            */\n/* -------------------------------------------------------------------- */\n#ifdef HAVE_UNSETFIELD\n        TIFFUnsetField( hTIFF, TIFFTAG_GEOPIXELSCALE );\n        TIFFUnsetField( hTIFF, TIFFTAG_GEOTIEPOINTS );\n        TIFFUnsetField( hTIFF, TIFFTAG_GEOTRANSMATRIX );\n#endif\n\n/* -------------------------------------------------------------------- */\n/*      Write the transform.  If we have a normal north-up image we     */\n/*      use the tiepoint plus pixelscale otherwise we use a matrix.     */\n/* -------------------------------------------------------------------- */\n        if( adfGeoTransform[2] == 0.0 && adfGeoTransform[4] == 0.0\n                && adfGeoTransform[5] < 0.0 )\n        {\n            double dfOffset = 0.0;\n            if( !EQUAL(osProfile,szPROFILE_BASELINE) )\n            {\n                // In the case the SRS has a vertical component and we have\n                // a single band, encode its scale/offset in the GeoTIFF tags\n                int bHasScale = FALSE;\n                double dfScale = GetRasterBand(1)->GetScale(&bHasScale);\n                int bHasOffset = FALSE;\n                dfOffset = GetRasterBand(1)->GetOffset(&bHasOffset);\n                const bool bApplyScaleOffset =\n                    HasVerticalCS(GetProjectionRef()) &&\n                    GetRasterCount() == 1;\n                if( bApplyScaleOffset && !bHasScale )\n                    dfScale = 1.0;\n                if( !bApplyScaleOffset || !bHasOffset )\n                    dfOffset = 0.0;\n                const double adfPixelScale[3] = {\n                    adfGeoTransform[1], fabs(adfGeoTransform[5]),\n                    bApplyScaleOffset ? dfScale  : 0.0 };\n                TIFFSetField( hTIFF, TIFFTAG_GEOPIXELSCALE, 3, adfPixelScale );\n            }\n\n            double adfTiePoints[6] = {\n                0.0, 0.0, 0.0, adfGeoTransform[0], adfGeoTransform[3], dfOffset };\n\n            if( bPixelIsPoint && !bPointGeoIgnore )\n            {\n                adfTiePoints[3] +=\n                    adfGeoTransform[1] * 0.5 + adfGeoTransform[2] * 0.5;\n                adfTiePoints[4] +=\n                    adfGeoTransform[4] * 0.5 + adfGeoTransform[5] * 0.5;\n            }\n\n            if( !EQUAL(osProfile,szPROFILE_BASELINE) )\n                TIFFSetField( hTIFF, TIFFTAG_GEOTIEPOINTS, 6, adfTiePoints );\n        }\n        else\n        {\n            double adfMatrix[16] = {};\n\n            adfMatrix[0] = adfGeoTransform[1];\n            adfMatrix[1] = adfGeoTransform[2];\n            adfMatrix[3] = adfGeoTransform[0];\n            adfMatrix[4] = adfGeoTransform[4];\n            adfMatrix[5] = adfGeoTransform[5];\n            adfMatrix[7] = adfGeoTransform[3];\n            adfMatrix[15] = 1.0;\n\n            if( bPixelIsPoint && !bPointGeoIgnore )\n            {\n                adfMatrix[3] +=\n                    adfGeoTransform[1] * 0.5 + adfGeoTransform[2] * 0.5;\n                adfMatrix[7] +=\n                    adfGeoTransform[4] * 0.5 + adfGeoTransform[5] * 0.5;\n            }\n\n            if( !EQUAL(osProfile,szPROFILE_BASELINE) )\n                TIFFSetField( hTIFF, TIFFTAG_GEOTRANSMATRIX, 16, adfMatrix );\n        }\n\n        // Do we need a world file?\n        if( CPLFetchBool( papszCreationOptions, \"TFW\", false ) )\n            GDALWriteWorldFile( osFilename, \"tfw\", adfGeoTransform );\n        else if( CPLFetchBool( papszCreationOptions, \"WORLDFILE\", false ) )\n            GDALWriteWorldFile( osFilename, \"wld\", adfGeoTransform );\n    }\n    else if( GetGCPCount() > 0 )\n    {\n        bNeedsRewrite = true;\n\n        double *padfTiePoints = static_cast<double *>(\n            CPLMalloc( 6 * sizeof(double) * GetGCPCount() ) );\n\n        for( int iGCP = 0; iGCP < GetGCPCount(); ++iGCP )\n        {\n\n            padfTiePoints[iGCP*6+0] = pasGCPList[iGCP].dfGCPPixel;\n            padfTiePoints[iGCP*6+1] = pasGCPList[iGCP].dfGCPLine;\n            padfTiePoints[iGCP*6+2] = 0;\n            padfTiePoints[iGCP*6+3] = pasGCPList[iGCP].dfGCPX;\n            padfTiePoints[iGCP*6+4] = pasGCPList[iGCP].dfGCPY;\n            padfTiePoints[iGCP*6+5] = pasGCPList[iGCP].dfGCPZ;\n\n            if( bPixelIsPoint && !bPointGeoIgnore )\n            {\n                padfTiePoints[iGCP*6+0] += 0.5;\n                padfTiePoints[iGCP*6+1] += 0.5;\n            }\n        }\n\n        if( !EQUAL(osProfile,szPROFILE_BASELINE) )\n            TIFFSetField( hTIFF, TIFFTAG_GEOTIEPOINTS,\n                          6 * GetGCPCount(), padfTiePoints );\n        CPLFree( padfTiePoints );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Write out projection definition.                                */\n/* -------------------------------------------------------------------- */\n    const bool bHasProjection =\n        pszProjection != nullptr && strlen(pszProjection) > 0;\n    if( (bHasProjection || bPixelIsPoint)\n        && !EQUAL(osProfile,szPROFILE_BASELINE) )\n    {\n        bNeedsRewrite = true;\n\n        // If we have existing geokeys, try to wipe them\n        // by writing a dummy geokey directory. (#2546)\n        GTiffWriteDummyGeokeyDirectory(hTIFF);\n\n        GTIF *psGTIF = GTiffDatasetGTIFNew( hTIFF );\n\n        // Set according to coordinate system.\n        if( bHasProjection )\n        {\n            GTIFSetFromOGISDefnEx( psGTIF, pszProjection, eGeoTIFFKeysFlavor );\n        }\n\n        if( bPixelIsPoint )\n        {\n            GTIFKeySet(psGTIF, GTRasterTypeGeoKey, TYPE_SHORT, 1,\n                       RasterPixelIsPoint);\n        }\n\n        GTIFWriteKeys( psGTIF );\n        GTIFFree( psGTIF );\n    }\n}\n\n/************************************************************************/\n/*                         AppendMetadataItem()                         */\n/************************************************************************/\n\nstatic void AppendMetadataItem( CPLXMLNode **ppsRoot, CPLXMLNode **ppsTail,\n                                const char *pszKey, const char *pszValue,\n                                int nBand, const char *pszRole,\n                                const char *pszDomain )\n\n{\n/* -------------------------------------------------------------------- */\n/*      Create the Item element, and subcomponents.                     */\n/* -------------------------------------------------------------------- */\n    CPLXMLNode *psItem = CPLCreateXMLNode( nullptr, CXT_Element, \"Item\" );\n    CPLCreateXMLNode( CPLCreateXMLNode( psItem, CXT_Attribute, \"name\"),\n                      CXT_Text, pszKey );\n\n    if( nBand > 0 )\n    {\n        char szBandId[32] = {};\n        snprintf( szBandId, sizeof(szBandId), \"%d\", nBand - 1 );\n        CPLCreateXMLNode( CPLCreateXMLNode( psItem,CXT_Attribute,\"sample\"),\n                          CXT_Text, szBandId );\n    }\n\n    if( pszRole != nullptr )\n        CPLCreateXMLNode( CPLCreateXMLNode( psItem,CXT_Attribute,\"role\"),\n                          CXT_Text, pszRole );\n\n    if( pszDomain != nullptr && strlen(pszDomain) > 0 )\n        CPLCreateXMLNode( CPLCreateXMLNode( psItem,CXT_Attribute,\"domain\"),\n                          CXT_Text, pszDomain );\n\n    char *pszEscapedItemValue = CPLEscapeString(pszValue,-1,CPLES_XML);\n    CPLCreateXMLNode( psItem, CXT_Text, pszEscapedItemValue );\n    CPLFree( pszEscapedItemValue );\n\n/* -------------------------------------------------------------------- */\n/*      Create root, if missing.                                        */\n/* -------------------------------------------------------------------- */\n    if( *ppsRoot == nullptr )\n        *ppsRoot = CPLCreateXMLNode( nullptr, CXT_Element, \"GDALMetadata\" );\n\n/* -------------------------------------------------------------------- */\n/*      Append item to tail.  We keep track of the tail to avoid        */\n/*      O(nsquared) time as the list gets longer.                       */\n/* -------------------------------------------------------------------- */\n    if( *ppsTail == nullptr )\n        CPLAddXMLChild( *ppsRoot, psItem );\n    else\n        CPLAddXMLSibling( *ppsTail, psItem );\n\n    *ppsTail = psItem;\n}\n\n/************************************************************************/\n/*                         WriteMDMetadata()                            */\n/************************************************************************/\n\nstatic void WriteMDMetadata( GDALMultiDomainMetadata *poMDMD, TIFF *hTIFF,\n                             CPLXMLNode **ppsRoot, CPLXMLNode **ppsTail,\n                             int nBand, const char * pszProfile )\n\n{\n\n/* ==================================================================== */\n/*      Process each domain.                                            */\n/* ==================================================================== */\n    char **papszDomainList = poMDMD->GetDomainList();\n    for( int iDomain = 0;\n         papszDomainList && papszDomainList[iDomain];\n         ++iDomain )\n    {\n        char **papszMD = poMDMD->GetMetadata( papszDomainList[iDomain] );\n        bool bIsXML = false;\n\n        if( EQUAL(papszDomainList[iDomain], \"IMAGE_STRUCTURE\") )\n            continue;  // Ignored.\n        if( EQUAL(papszDomainList[iDomain], \"COLOR_PROFILE\") )\n            continue;  // Ignored.\n        if( EQUAL(papszDomainList[iDomain], MD_DOMAIN_RPC) )\n            continue;  // Handled elsewhere.\n        if( EQUAL(papszDomainList[iDomain], \"xml:ESRI\")\n            && CPLTestBool(CPLGetConfigOption( \"ESRI_XML_PAM\", \"NO\" )) )\n            continue;  // Handled elsewhere.\n        if( EQUAL(papszDomainList[iDomain], \"xml:XMP\") )\n            continue;  // Handled in SetMetadata.\n\n        if( STARTS_WITH_CI(papszDomainList[iDomain], \"xml:\") )\n            bIsXML = true;\n\n/* -------------------------------------------------------------------- */\n/*      Process each item in this domain.                               */\n/* -------------------------------------------------------------------- */\n        for( int iItem = 0; papszMD && papszMD[iItem]; ++iItem )\n        {\n            const char *pszItemValue = nullptr;\n            char *pszItemName = nullptr;\n\n            if( bIsXML )\n            {\n                pszItemName = CPLStrdup(\"doc\");\n                pszItemValue = papszMD[iItem];\n            }\n            else\n            {\n                pszItemValue = CPLParseNameValue( papszMD[iItem], &pszItemName);\n                if( pszItemName == nullptr )\n                {\n                    CPLDebug( \"GTiff\",\n                              \"Invalid metadata item : %s\", papszMD[iItem] );\n                    continue;\n                }\n            }\n\n/* -------------------------------------------------------------------- */\n/*      Convert into XML item or handle as a special TIFF tag.          */\n/* -------------------------------------------------------------------- */\n            if( strlen(papszDomainList[iDomain]) == 0\n                && nBand == 0 &&\n                (STARTS_WITH_CI(pszItemName, \"TIFFTAG_\") ||\n                 (EQUAL(pszItemName, \"GEO_METADATA\") &&\n                  EQUAL(pszProfile, szPROFILE_GDALGeoTIFF)) ||\n                 (EQUAL(pszItemName, \"TIFF_RSID\") &&\n                  EQUAL(pszProfile, szPROFILE_GDALGeoTIFF))) )\n            {\n                if( EQUAL(pszItemName, \"TIFFTAG_RESOLUTIONUNIT\") )\n                {\n                    // ResolutionUnit can't be 0, which is the default if\n                    // atoi() fails.  Set to 1=Unknown.\n                    int v = atoi(pszItemValue);\n                    if( !v ) v = RESUNIT_NONE;\n                    TIFFSetField( hTIFF, TIFFTAG_RESOLUTIONUNIT, v);\n                }\n                else\n                {\n                    bool bFoundTag = false;\n                    size_t iTag = 0;  // Used after for.\n                    for( ;\n                         iTag < sizeof(asTIFFTags) / sizeof(asTIFFTags[0]);\n                         ++iTag )\n                    {\n                        if( EQUAL(pszItemName, asTIFFTags[iTag].pszTagName) )\n                        {\n                            bFoundTag = true;\n                            break;\n                        }\n                    }\n\n                    if( bFoundTag &&\n                        asTIFFTags[iTag].eType == GTIFFTAGTYPE_STRING )\n                        TIFFSetField( hTIFF, asTIFFTags[iTag].nTagVal,\n                                      pszItemValue );\n                    else if( bFoundTag &&\n                             asTIFFTags[iTag].eType == GTIFFTAGTYPE_FLOAT )\n                        TIFFSetField( hTIFF, asTIFFTags[iTag].nTagVal,\n                                      CPLAtof(pszItemValue) );\n                    else if( bFoundTag &&\n                             asTIFFTags[iTag].eType == GTIFFTAGTYPE_SHORT )\n                        TIFFSetField( hTIFF, asTIFFTags[iTag].nTagVal,\n                                      atoi(pszItemValue) );\n                    else if( bFoundTag &&\n                             asTIFFTags[iTag].eType == GTIFFTAGTYPE_BYTE_STRING )\n                    {\n                        int nLen = static_cast<int>(strlen(pszItemValue));\n                        if( nLen )\n                        {\n                            TIFFSetField( hTIFF, asTIFFTags[iTag].nTagVal,\n                                          nLen,\n                                          pszItemValue );\n                        }\n                    }\n                    else\n                        CPLError(\n                            CE_Warning, CPLE_NotSupported,\n                            \"%s metadata item is unhandled and \"\n                            \"will not be written\",\n                            pszItemName);\n                }\n            }\n            else if( nBand == 0 && EQUAL(pszItemName,GDALMD_AREA_OR_POINT) )\n            {\n                /* Do nothing, handled elsewhere. */;\n            }\n            else\n            {\n                AppendMetadataItem( ppsRoot, ppsTail,\n                                    pszItemName, pszItemValue,\n                                    nBand, nullptr, papszDomainList[iDomain] );\n            }\n\n            CPLFree( pszItemName );\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Remove TIFFTAG_xxxxxx that are already set but no longer in     */\n/*      the metadata list (#5619)                                       */\n/* -------------------------------------------------------------------- */\n        if( strlen(papszDomainList[iDomain]) == 0 && nBand == 0 )\n        {\n            for( size_t iTag = 0;\n                 iTag < sizeof(asTIFFTags) / sizeof(asTIFFTags[0]);\n                 ++iTag )\n            {\n                uint32 nCount = 0;\n                char* pszText = nullptr;\n                int16 nVal = 0;\n                float fVal = 0.0f;\n                const char* pszVal =\n                    CSLFetchNameValue(papszMD, asTIFFTags[iTag].pszTagName);\n                if( pszVal == nullptr &&\n                    ((asTIFFTags[iTag].eType == GTIFFTAGTYPE_STRING &&\n                      TIFFGetField( hTIFF, asTIFFTags[iTag].nTagVal,\n                                    &pszText )) ||\n                     (asTIFFTags[iTag].eType == GTIFFTAGTYPE_SHORT &&\n                      TIFFGetField( hTIFF, asTIFFTags[iTag].nTagVal, &nVal )) ||\n                     (asTIFFTags[iTag].eType == GTIFFTAGTYPE_FLOAT &&\n                      TIFFGetField( hTIFF, asTIFFTags[iTag].nTagVal, &fVal )) ||\n                     (asTIFFTags[iTag].eType == GTIFFTAGTYPE_BYTE_STRING &&\n                      TIFFGetField( hTIFF, asTIFFTags[iTag].nTagVal, &nCount, &pszText ))) )\n                {\n#ifdef HAVE_UNSETFIELD\n                    TIFFUnsetField( hTIFF, asTIFFTags[iTag].nTagVal );\n#else\n                    if( asTIFFTags[iTag].eType == GTIFFTAGTYPE_STRING )\n                    {\n                        TIFFSetField( hTIFF, asTIFFTags[iTag].nTagVal, \"\" );\n                    }\n#endif\n                }\n            }\n        }\n    }\n}\n\n/************************************************************************/\n/*                           WriteRPC()                                 */\n/************************************************************************/\n\nvoid GTiffDataset::WriteRPC( GDALDataset *poSrcDS, TIFF *l_hTIFF,\n                             int bSrcIsGeoTIFF,\n                             const char *pszProfile,\n                             const char *pszTIFFFilename,\n                             char **l_papszCreationOptions,\n                             bool bWriteOnlyInPAMIfNeeded )\n{\n/* -------------------------------------------------------------------- */\n/*      Handle RPC data written to TIFF RPCCoefficient tag, RPB file,   */\n/*      RPCTEXT file or PAM.                                            */\n/* -------------------------------------------------------------------- */\n    char **papszRPCMD = poSrcDS->GetMetadata(MD_DOMAIN_RPC);\n    if( papszRPCMD != nullptr )\n    {\n        bool bRPCSerializedOtherWay = false;\n\n        if( EQUAL(pszProfile,szPROFILE_GDALGeoTIFF) )\n        {\n            if( !bWriteOnlyInPAMIfNeeded )\n                GTiffDatasetWriteRPCTag( l_hTIFF, papszRPCMD );\n            bRPCSerializedOtherWay = true;\n        }\n\n        // Write RPB file if explicitly asked, or if a non GDAL specific\n        // profile is selected and RPCTXT is not asked.\n        bool bRPBExplicitlyAsked =\n            CPLFetchBool( l_papszCreationOptions, \"RPB\", false );\n        bool bRPBExplicitlyDenied =\n            !CPLFetchBool( l_papszCreationOptions, \"RPB\", true );\n        if( (!EQUAL(pszProfile,szPROFILE_GDALGeoTIFF) &&\n             !CPLFetchBool( l_papszCreationOptions, \"RPCTXT\", false ) &&\n             !bRPBExplicitlyDenied )\n            || bRPBExplicitlyAsked )\n        {\n            if( !bWriteOnlyInPAMIfNeeded )\n                GDALWriteRPBFile( pszTIFFFilename, papszRPCMD );\n            bRPCSerializedOtherWay = true;\n        }\n\n        if( CPLFetchBool( l_papszCreationOptions, \"RPCTXT\", false ) )\n        {\n            if( !bWriteOnlyInPAMIfNeeded )\n                GDALWriteRPCTXTFile( pszTIFFFilename, papszRPCMD );\n            bRPCSerializedOtherWay = true;\n        }\n\n        if( !bRPCSerializedOtherWay && bWriteOnlyInPAMIfNeeded &&\n            bSrcIsGeoTIFF )\n            cpl::down_cast<GTiffDataset*>(poSrcDS)->\n                GDALPamDataset::SetMetadata( papszRPCMD, MD_DOMAIN_RPC );\n    }\n}\n\n/************************************************************************/\n/*                  IsStandardColorInterpretation()                     */\n/************************************************************************/\n\nstatic bool IsStandardColorInterpretation(GDALDataset* poSrcDS,\n                                          uint16 nPhotometric,\n                                          char** papszCreationOptions)\n{\n    bool bStardardColorInterp = true;\n    if( nPhotometric == PHOTOMETRIC_MINISBLACK )\n    {\n        for( int i = 0; i < poSrcDS->GetRasterCount(); ++i )\n        {\n            const GDALColorInterp eInterp =\n                poSrcDS->GetRasterBand(i + 1)->GetColorInterpretation();\n            if( !(eInterp == GCI_GrayIndex || eInterp == GCI_Undefined ||\n                    (i > 0 && eInterp == GCI_AlphaBand)) )\n            {\n                bStardardColorInterp = false;\n                break;\n            }\n        }\n    }\n    else if( nPhotometric == PHOTOMETRIC_PALETTE )\n    {\n        bStardardColorInterp =\n            poSrcDS->GetRasterBand(1)->GetColorInterpretation() ==\n                GCI_PaletteIndex;\n    }\n    else if( nPhotometric == PHOTOMETRIC_RGB )\n    {\n        int iStart = 0;\n        if( EQUAL(CSLFetchNameValueDef(papszCreationOptions,\n                                       \"PHOTOMETRIC\", \"\"), \"RGB\") )\n        {\n            iStart = 3;\n            if( poSrcDS->GetRasterCount() == 4 &&\n                CSLFetchNameValue(papszCreationOptions, \"ALPHA\") != nullptr )\n            {\n                iStart = 4;\n            }\n        }\n        for( int i = iStart; i < poSrcDS->GetRasterCount(); ++i )\n        {\n            const GDALColorInterp eInterp =\n                poSrcDS->GetRasterBand(i+1)->GetColorInterpretation();\n            if( !((i == 0 && eInterp == GCI_RedBand) ||\n                    (i == 1 && eInterp == GCI_GreenBand) ||\n                    (i == 2 && eInterp == GCI_BlueBand) ||\n                    (i >= 3 && (eInterp == GCI_Undefined ||\n                                eInterp == GCI_AlphaBand))) )\n            {\n                bStardardColorInterp = false;\n                break;\n            }\n        }\n    }\n    else if( nPhotometric == PHOTOMETRIC_YCBCR &&\n             poSrcDS->GetRasterCount() == 3 )\n    {\n        // do nothing\n    }\n    else\n    {\n        bStardardColorInterp = false;\n    }\n    return bStardardColorInterp;\n}\n\n/************************************************************************/\n/*                           WriteMetadata()                            */\n/************************************************************************/\n\nbool GTiffDataset::WriteMetadata( GDALDataset *poSrcDS, TIFF *l_hTIFF,\n                                  bool bSrcIsGeoTIFF,\n                                  const char *pszProfile,\n                                  const char *pszTIFFFilename,\n                                  char **l_papszCreationOptions,\n                                  bool bExcludeRPBandIMGFileWriting)\n\n{\n/* -------------------------------------------------------------------- */\n/*      Convert all the remaining metadata into a simple XML            */\n/*      format.                                                         */\n/* -------------------------------------------------------------------- */\n    CPLXMLNode *psRoot = nullptr;\n    CPLXMLNode *psTail = nullptr;\n\n    if( bSrcIsGeoTIFF )\n    {\n        GTiffDataset* poSrcDSGTiff = cpl::down_cast<GTiffDataset *>(poSrcDS);\n        assert(poSrcDSGTiff);\n        WriteMDMetadata(\n            &poSrcDSGTiff->oGTiffMDMD,\n            l_hTIFF, &psRoot, &psTail, 0, pszProfile );\n    }\n    else\n    {\n        char **papszMD = poSrcDS->GetMetadata();\n\n        if( CSLCount(papszMD) > 0 )\n        {\n            GDALMultiDomainMetadata l_oMDMD;\n            l_oMDMD.SetMetadata( papszMD );\n\n            WriteMDMetadata( &l_oMDMD, l_hTIFF, &psRoot, &psTail,\n                             0, pszProfile );\n        }\n    }\n\n    if( !bExcludeRPBandIMGFileWriting )\n    {\n        WriteRPC(poSrcDS, l_hTIFF, bSrcIsGeoTIFF,\n                 pszProfile, pszTIFFFilename,\n                 l_papszCreationOptions);\n\n/* -------------------------------------------------------------------- */\n/*      Handle metadata data written to an IMD file.                    */\n/* -------------------------------------------------------------------- */\n        char **papszIMDMD = poSrcDS->GetMetadata(MD_DOMAIN_IMD);\n        if( papszIMDMD != nullptr )\n        {\n            GDALWriteIMDFile( pszTIFFFilename, papszIMDMD );\n        }\n    }\n\n    uint16 nPhotometric = 0;\n    if( !TIFFGetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, &(nPhotometric) ) )\n        nPhotometric = PHOTOMETRIC_MINISBLACK;\n\n    const bool bStardardColorInterp =\n        IsStandardColorInterpretation(poSrcDS, nPhotometric,\n                                      l_papszCreationOptions);\n\n/* -------------------------------------------------------------------- */\n/*      We also need to address band specific metadata, and special     */\n/*      \"role\" metadata.                                                */\n/* -------------------------------------------------------------------- */\n    for( int nBand = 1; nBand <= poSrcDS->GetRasterCount(); ++nBand )\n    {\n        GDALRasterBand *poBand = poSrcDS->GetRasterBand( nBand );\n\n        if( bSrcIsGeoTIFF )\n        {\n            GTiffRasterBand* poSrcBandGTiff = cpl::down_cast<GTiffRasterBand *>(poBand);\n            assert(poSrcBandGTiff);\n            WriteMDMetadata(\n                &poSrcBandGTiff->oGTiffMDMD,\n                l_hTIFF, &psRoot, &psTail, nBand, pszProfile );\n        }\n        else\n        {\n            char **papszMD = poBand->GetMetadata();\n\n            if( CSLCount(papszMD) > 0 )\n            {\n                GDALMultiDomainMetadata l_oMDMD;\n                l_oMDMD.SetMetadata( papszMD );\n\n                WriteMDMetadata( &l_oMDMD, l_hTIFF, &psRoot, &psTail, nBand,\n                                 pszProfile );\n            }\n        }\n\n        const double dfOffset = poBand->GetOffset();\n        const double dfScale = poBand->GetScale();\n        bool bGeoTIFFScaleOffsetInZ = false;\n        double adfGeoTransform[6];\n        // Check if we have already encoded scale/offset in the GeoTIFF tags\n        if( poSrcDS->GetGeoTransform(adfGeoTransform) == CE_None &&\n            adfGeoTransform[2] == 0.0 && adfGeoTransform[4] == 0.0\n            && adfGeoTransform[5] < 0.0 &&\n            HasVerticalCS(poSrcDS->GetProjectionRef()) &&\n            poSrcDS->GetRasterCount() == 1 )\n        {\n            bGeoTIFFScaleOffsetInZ = true;\n        }\n\n        if( (dfOffset != 0.0 || dfScale != 1.0) && !bGeoTIFFScaleOffsetInZ )\n        {\n            char szValue[128] = {};\n\n            CPLsnprintf( szValue, sizeof(szValue), \"%.18g\", dfOffset );\n            AppendMetadataItem( &psRoot, &psTail, \"OFFSET\", szValue, nBand,\n                                \"offset\", \"\" );\n            CPLsnprintf( szValue, sizeof(szValue), \"%.18g\", dfScale );\n            AppendMetadataItem( &psRoot, &psTail, \"SCALE\", szValue, nBand,\n                                \"scale\", \"\" );\n        }\n\n        const char* pszUnitType = poBand->GetUnitType();\n        if( pszUnitType != nullptr && pszUnitType[0] != '\\0' )\n            AppendMetadataItem( &psRoot, &psTail, \"UNITTYPE\",\n                                pszUnitType, nBand,\n                                \"unittype\", \"\" );\n\n        if( strlen(poBand->GetDescription()) > 0 )\n        {\n            AppendMetadataItem( &psRoot, &psTail, \"DESCRIPTION\",\n                                poBand->GetDescription(), nBand,\n                                \"description\", \"\" );\n        }\n\n        if( !bStardardColorInterp &&\n            !(nBand <= 3 &&  EQUAL(CSLFetchNameValueDef(\n                l_papszCreationOptions, \"PHOTOMETRIC\", \"\"), \"RGB\") ) )\n        {\n            AppendMetadataItem( &psRoot, &psTail, \"COLORINTERP\",\n                                GDALGetColorInterpretationName(\n                                    poBand->GetColorInterpretation()),\n                                nBand,\n                                \"colorinterp\", \"\" );\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Write out the generic XML metadata if there is any.             */\n/* -------------------------------------------------------------------- */\n    if( psRoot != nullptr )\n    {\n        bool bRet = true;\n\n        if( EQUAL(pszProfile,szPROFILE_GDALGeoTIFF) )\n        {\n            char *pszXML_MD = CPLSerializeXMLTree( psRoot );\n            if( strlen(pszXML_MD) > 32000 )\n            {\n                if( bSrcIsGeoTIFF )\n                {\n                    if( cpl::down_cast<GTiffDataset *>(\n                           poSrcDS)->GetPamFlags() & GPF_DISABLED )\n                    {\n                        CPLError(\n                            CE_Warning, CPLE_AppDefined,\n                            \"Metadata exceeding 32000 bytes cannot be written \"\n                            \"into GeoTIFF.\" );\n                    }\n                    else\n                    {\n                        cpl::down_cast<GTiffDataset *>(poSrcDS)->\n                            PushMetadataToPam();\n                        CPLError(\n                            CE_Warning, CPLE_AppDefined,\n                            \"Metadata exceeding 32000 bytes cannot be written \"\n                            \"into GeoTIFF. Transferred to PAM instead.\" );\n                    }\n                }\n                else\n                {\n                    bRet = false;\n                }\n            }\n            else\n            {\n                TIFFSetField( l_hTIFF, TIFFTAG_GDAL_METADATA, pszXML_MD );\n            }\n            CPLFree( pszXML_MD );\n        }\n        else\n        {\n            if( bSrcIsGeoTIFF )\n                cpl::down_cast<GTiffDataset *>(poSrcDS)->PushMetadataToPam();\n            else\n                bRet = false;\n        }\n\n        CPLDestroyXMLNode( psRoot );\n\n        return bRet;\n    }\n\n    // If we have no more metadata but it existed before,\n    // remove the GDAL_METADATA tag.\n    if( EQUAL(pszProfile,szPROFILE_GDALGeoTIFF) )\n    {\n        char* pszText = nullptr;\n        if( TIFFGetField( l_hTIFF, TIFFTAG_GDAL_METADATA, &pszText ) )\n        {\n#ifdef HAVE_UNSETFIELD\n            TIFFUnsetField( l_hTIFF, TIFFTAG_GDAL_METADATA );\n#else\n            TIFFSetField( l_hTIFF, TIFFTAG_GDAL_METADATA, \"\" );\n#endif\n        }\n    }\n\n    return true;\n}\n\n/************************************************************************/\n/*                         PushMetadataToPam()                          */\n/*                                                                      */\n/*      When producing a strict profile TIFF or if our aggregate        */\n/*      metadata is too big for a single tiff tag we may end up         */\n/*      needing to write it via the PAM mechanisms.  This method        */\n/*      copies all the appropriate metadata into the PAM level          */\n/*      metadata object but with special care to avoid copying          */\n/*      metadata handled in other ways in TIFF format.                  */\n/************************************************************************/\n\nvoid GTiffDataset::PushMetadataToPam()\n\n{\n    if( GetPamFlags() & GPF_DISABLED )\n        return;\n\n    const bool bStardardColorInterp =\n        IsStandardColorInterpretation(this, nPhotometric, papszCreationOptions);\n\n    for( int nBand = 0; nBand <= GetRasterCount(); ++nBand )\n    {\n        GDALMultiDomainMetadata *poSrcMDMD = nullptr;\n        GTiffRasterBand *poBand = nullptr;\n\n        if( nBand == 0 )\n        {\n            poSrcMDMD = &(this->oGTiffMDMD);\n        }\n        else\n        {\n            poBand = cpl::down_cast<GTiffRasterBand *>(GetRasterBand(nBand));\n            poSrcMDMD = &(poBand->oGTiffMDMD);\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Loop over the available domains.                                */\n/* -------------------------------------------------------------------- */\n        char **papszDomainList = poSrcMDMD->GetDomainList();\n        for( int iDomain = 0;\n             papszDomainList && papszDomainList[iDomain];\n             ++iDomain )\n        {\n            char **papszMD = poSrcMDMD->GetMetadata( papszDomainList[iDomain] );\n\n            if( EQUAL(papszDomainList[iDomain],MD_DOMAIN_RPC)\n                || EQUAL(papszDomainList[iDomain],MD_DOMAIN_IMD)\n                || EQUAL(papszDomainList[iDomain],\"_temporary_\")\n                || EQUAL(papszDomainList[iDomain],\"IMAGE_STRUCTURE\")\n                || EQUAL(papszDomainList[iDomain],\"COLOR_PROFILE\") )\n                continue;\n\n            papszMD = CSLDuplicate(papszMD);\n\n            for( int i = CSLCount(papszMD)-1; i >= 0; --i )\n            {\n                if( STARTS_WITH_CI(papszMD[i], \"TIFFTAG_\")\n                    || EQUALN(papszMD[i],GDALMD_AREA_OR_POINT,\n                              strlen(GDALMD_AREA_OR_POINT)) )\n                    papszMD = CSLRemoveStrings( papszMD, i, 1, nullptr );\n            }\n\n            if( nBand == 0 )\n                GDALPamDataset::SetMetadata( papszMD, papszDomainList[iDomain]);\n            else\n                poBand->\n                    GDALPamRasterBand::SetMetadata( papszMD,\n                                                    papszDomainList[iDomain]);\n\n            CSLDestroy( papszMD );\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Handle some \"special domain\" stuff.                             */\n/* -------------------------------------------------------------------- */\n        if( poBand != nullptr )\n        {\n            poBand->GDALPamRasterBand::SetOffset( poBand->GetOffset() );\n            poBand->GDALPamRasterBand::SetScale( poBand->GetScale() );\n            poBand->GDALPamRasterBand::SetUnitType( poBand->GetUnitType() );\n            poBand->\n                GDALPamRasterBand::SetDescription( poBand->GetDescription() );\n            if( !bStardardColorInterp )\n            {\n                poBand->GDALPamRasterBand::SetColorInterpretation(\n                                        poBand->GetColorInterpretation() );\n            }\n        }\n    }\n    MarkPamDirty();\n}\n\n/************************************************************************/\n/*                     GTiffDatasetWriteRPCTag()                        */\n/*                                                                      */\n/*      Format a TAG according to:                                      */\n/*                                                                      */\n/*      http://geotiff.maptools.org/rpc_prop.html                       */\n/************************************************************************/\n\nvoid GTiffDatasetWriteRPCTag( TIFF *hTIFF, char **papszRPCMD )\n\n{\n    GDALRPCInfo sRPC;\n\n    if( !GDALExtractRPCInfo( papszRPCMD, &sRPC ) )\n        return;\n\n    double adfRPCTag[92] = {};\n    adfRPCTag[0] = -1.0;  // Error Bias\n    adfRPCTag[1] = -1.0;  // Error Random\n\n    adfRPCTag[2] = sRPC.dfLINE_OFF;\n    adfRPCTag[3] = sRPC.dfSAMP_OFF;\n    adfRPCTag[4] = sRPC.dfLAT_OFF;\n    adfRPCTag[5] = sRPC.dfLONG_OFF;\n    adfRPCTag[6] = sRPC.dfHEIGHT_OFF;\n    adfRPCTag[7] = sRPC.dfLINE_SCALE;\n    adfRPCTag[8] = sRPC.dfSAMP_SCALE;\n    adfRPCTag[9] = sRPC.dfLAT_SCALE;\n    adfRPCTag[10] = sRPC.dfLONG_SCALE;\n    adfRPCTag[11] = sRPC.dfHEIGHT_SCALE;\n\n    memcpy( adfRPCTag + 12, sRPC.adfLINE_NUM_COEFF, sizeof(double) * 20 );\n    memcpy( adfRPCTag + 32, sRPC.adfLINE_DEN_COEFF, sizeof(double) * 20 );\n    memcpy( adfRPCTag + 52, sRPC.adfSAMP_NUM_COEFF, sizeof(double) * 20 );\n    memcpy( adfRPCTag + 72, sRPC.adfSAMP_DEN_COEFF, sizeof(double) * 20 );\n\n    TIFFSetField( hTIFF, TIFFTAG_RPCCOEFFICIENT, 92, adfRPCTag );\n}\n\n/************************************************************************/\n/*                             ReadRPCTag()                             */\n/*                                                                      */\n/*      Format a TAG according to:                                      */\n/*                                                                      */\n/*      http://geotiff.maptools.org/rpc_prop.html                       */\n/************************************************************************/\n\nchar** GTiffDatasetReadRPCTag(TIFF* hTIFF)\n\n{\n    double *padfRPCTag = nullptr;\n    uint16 nCount;\n\n    if( !TIFFGetField( hTIFF, TIFFTAG_RPCCOEFFICIENT, &nCount, &padfRPCTag )\n        || nCount != 92 )\n        return nullptr;\n\n    CPLStringList asMD;\n    asMD.SetNameValue(RPC_LINE_OFF, CPLOPrintf(\"%.15g\", padfRPCTag[2]));\n    asMD.SetNameValue(RPC_SAMP_OFF, CPLOPrintf(\"%.15g\", padfRPCTag[3]));\n    asMD.SetNameValue(RPC_LAT_OFF, CPLOPrintf(\"%.15g\", padfRPCTag[4]));\n    asMD.SetNameValue(RPC_LONG_OFF, CPLOPrintf(\"%.15g\", padfRPCTag[5]));\n    asMD.SetNameValue(RPC_HEIGHT_OFF, CPLOPrintf(\"%.15g\", padfRPCTag[6]));\n    asMD.SetNameValue(RPC_LINE_SCALE, CPLOPrintf(\"%.15g\", padfRPCTag[7]));\n    asMD.SetNameValue(RPC_SAMP_SCALE, CPLOPrintf(\"%.15g\", padfRPCTag[8]));\n    asMD.SetNameValue(RPC_LAT_SCALE, CPLOPrintf(\"%.15g\", padfRPCTag[9]));\n    asMD.SetNameValue(RPC_LONG_SCALE, CPLOPrintf(\"%.15g\", padfRPCTag[10]));\n    asMD.SetNameValue(RPC_HEIGHT_SCALE, CPLOPrintf(\"%.15g\", padfRPCTag[11]));\n\n    CPLString osField;\n    CPLString osMultiField;\n\n    for( int i = 0; i < 20; ++i )\n    {\n        osField.Printf( \"%.15g\", padfRPCTag[12+i] );\n        if( i > 0 )\n            osMultiField += \" \";\n        else\n            osMultiField = \"\";\n        osMultiField += osField;\n    }\n    asMD.SetNameValue(RPC_LINE_NUM_COEFF, osMultiField );\n\n    for( int i = 0; i < 20; ++i )\n    {\n        osField.Printf( \"%.15g\", padfRPCTag[32+i] );\n        if( i > 0 )\n            osMultiField += \" \";\n        else\n            osMultiField = \"\";\n        osMultiField += osField;\n    }\n    asMD.SetNameValue( RPC_LINE_DEN_COEFF, osMultiField );\n\n    for( int i = 0; i < 20; ++i )\n    {\n        osField.Printf( \"%.15g\", padfRPCTag[52+i] );\n        if( i > 0 )\n            osMultiField += \" \";\n        else\n            osMultiField = \"\";\n        osMultiField += osField;\n    }\n    asMD.SetNameValue( RPC_SAMP_NUM_COEFF, osMultiField );\n\n    for( int i = 0; i < 20; ++i )\n    {\n        osField.Printf( \"%.15g\", padfRPCTag[72+i] );\n        if( i > 0 )\n            osMultiField += \" \";\n        else\n            osMultiField = \"\";\n        osMultiField += osField;\n    }\n    asMD.SetNameValue( RPC_SAMP_DEN_COEFF, osMultiField );\n\n    return asMD.StealList();\n}\n\n/************************************************************************/\n/*                  GTiffFormatGDALNoDataTagValue()                     */\n/************************************************************************/\n\nCPLString GTiffFormatGDALNoDataTagValue( double dfNoData )\n{\n    CPLString osVal;\n    if( CPLIsNan(dfNoData) )\n        osVal = \"nan\";\n    else\n        osVal.Printf(\"%.18g\", dfNoData);\n    return osVal;\n}\n\n/************************************************************************/\n/*                         WriteNoDataValue()                           */\n/************************************************************************/\n\nvoid GTiffDataset::WriteNoDataValue( TIFF *l_hTIFF, double dfNoData )\n\n{\n    CPLString osVal( GTiffFormatGDALNoDataTagValue(dfNoData) );\n    TIFFSetField( l_hTIFF, TIFFTAG_GDAL_NODATA, osVal.c_str() );\n}\n\n/************************************************************************/\n/*                         UnsetNoDataValue()                           */\n/************************************************************************/\n\nvoid GTiffDataset::UnsetNoDataValue( TIFF *l_hTIFF )\n\n{\n#ifdef HAVE_UNSETFIELD\n    TIFFUnsetField( l_hTIFF, TIFFTAG_GDAL_NODATA );\n#else\n    TIFFSetField( l_hTIFF, TIFFTAG_GDAL_NODATA, \"\" );\n#endif\n}\n\n/************************************************************************/\n/*                            SetDirectory()                            */\n/************************************************************************/\n\nbool GTiffDataset::SetDirectory( toff_t nNewOffset )\n\n{\n    Crystalize();\n\n    if( nNewOffset == 0 )\n        nNewOffset = nDirOffset;\n\n    if( TIFFCurrentDirOffset(hTIFF) == nNewOffset )\n    {\n        CPLAssert( *ppoActiveDSRef == this || *ppoActiveDSRef == nullptr );\n        *ppoActiveDSRef = this;\n        return true;\n    }\n\n    if( GetAccess() == GA_Update )\n    {\n        if( *ppoActiveDSRef != nullptr )\n            (*ppoActiveDSRef)->FlushDirectory();\n    }\n\n    if( nNewOffset == 0)\n        return true;\n\n    (*ppoActiveDSRef) = this;\n\n    const int nSetDirResult = TIFFSetSubDirectory( hTIFF, nNewOffset );\n    if( !nSetDirResult )\n        return false;\n\n    RestoreVolatileParameters( hTIFF );\n\n    return true;\n}\n\n/************************************************************************/\n/*                     RestoreVolatileParameters()                      */\n/************************************************************************/\n\nvoid GTiffDataset::RestoreVolatileParameters(TIFF* l_hTIFF)\n{\n\n/* -------------------------------------------------------------------- */\n/*      YCbCr JPEG compressed images should be translated on the fly    */\n/*      to RGB by libtiff/libjpeg unless specifically requested         */\n/*      otherwise.                                                      */\n/* -------------------------------------------------------------------- */\n    if( nCompression == COMPRESSION_JPEG\n        && nPhotometric == PHOTOMETRIC_YCBCR\n        && CPLTestBool( CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\",\n                                              \"YES\") ) )\n    {\n        int nColorMode = JPEGCOLORMODE_RAW;  // Initialize to 0;\n\n        TIFFGetField( l_hTIFF, TIFFTAG_JPEGCOLORMODE, &nColorMode );\n        if( nColorMode != JPEGCOLORMODE_RGB )\n        {\n            TIFFSetField(l_hTIFF, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Propagate any quality settings.                                 */\n/* -------------------------------------------------------------------- */\n    if( GetAccess() == GA_Update )\n    {\n        // Now, reset zip and jpeg quality.\n        if(nJpegQuality > 0 && nCompression == COMPRESSION_JPEG)\n        {\n#ifdef DEBUG_VERBOSE\n            CPLDebug( \"GTiff\", \"Propagate JPEG_QUALITY(%d) in SetDirectory()\",\n                      nJpegQuality );\n#endif\n            TIFFSetField(l_hTIFF, TIFFTAG_JPEGQUALITY, nJpegQuality);\n        }\n        if(nJpegTablesMode >= 0 && nCompression == COMPRESSION_JPEG)\n            TIFFSetField(l_hTIFF, TIFFTAG_JPEGTABLESMODE, nJpegTablesMode);\n        if(nZLevel > 0 && (nCompression == COMPRESSION_ADOBE_DEFLATE ||\n                           nCompression == COMPRESSION_LERC) )\n            TIFFSetField(l_hTIFF, TIFFTAG_ZIPQUALITY, nZLevel);\n        if(nLZMAPreset > 0 && nCompression == COMPRESSION_LZMA)\n            TIFFSetField(l_hTIFF, TIFFTAG_LZMAPRESET, nLZMAPreset);\n        if( nZSTDLevel > 0 && (nCompression == COMPRESSION_ZSTD ||\n                               nCompression == COMPRESSION_LERC) )\n            TIFFSetField(l_hTIFF, TIFFTAG_ZSTD_LEVEL, nZSTDLevel);\n#if HAVE_LERC\n        if( nCompression == COMPRESSION_LERC )\n        {\n            TIFFSetField(l_hTIFF, TIFFTAG_LERC_MAXZERROR, dfMaxZError);\n            TIFFSetField(l_hTIFF, TIFFTAG_LERC_PARAMETERS, 2,\n                         anLercAddCompressionAndVersion);\n        }\n#endif\n        if( nWebPLevel > 0 && nCompression == COMPRESSION_WEBP)\n            TIFFSetField(l_hTIFF, TIFFTAG_WEBP_LEVEL, nWebPLevel);\n        if( bWebPLossless && nCompression == COMPRESSION_WEBP)\n            TIFFSetField(l_hTIFF, TIFFTAG_WEBP_LOSSLESS, 1);\n    }\n}\n\n/************************************************************************/\n/*                              Identify()                              */\n/************************************************************************/\n\nint GTiffDataset::Identify( GDALOpenInfo *poOpenInfo )\n\n{\n    const char *pszFilename = poOpenInfo->pszFilename;\n    if( STARTS_WITH_CI(pszFilename, \"GTIFF_RAW:\") )\n    {\n        pszFilename += strlen(\"GTIFF_RAW:\");\n        GDALOpenInfo oOpenInfo( pszFilename, poOpenInfo->eAccess );\n        return Identify(&oOpenInfo);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      We have a special hook for handling opening a specific          */\n/*      directory of a TIFF file.                                       */\n/* -------------------------------------------------------------------- */\n    if( STARTS_WITH_CI(pszFilename, \"GTIFF_DIR:\") )\n        return TRUE;\n\n/* -------------------------------------------------------------------- */\n/*      First we check to see if the file has the expected header       */\n/*      bytes.                                                          */\n/* -------------------------------------------------------------------- */\n    if( poOpenInfo->fpL == nullptr || poOpenInfo->nHeaderBytes < 2 )\n        return FALSE;\n\n    if( (poOpenInfo->pabyHeader[0] != 'I' || poOpenInfo->pabyHeader[1] != 'I')\n        && (poOpenInfo->pabyHeader[0] != 'M'\n        || poOpenInfo->pabyHeader[1] != 'M'))\n        return FALSE;\n\n#ifndef BIGTIFF_SUPPORT\n    if( (poOpenInfo->pabyHeader[2] == 0x2B && poOpenInfo->pabyHeader[3] == 0) ||\n        (poOpenInfo->pabyHeader[2] == 0 && poOpenInfo->pabyHeader[3] == 0x2B) )\n    {\n        CPLError( CE_Failure, CPLE_OpenFailed,\n                  \"This is a BigTIFF file.  BigTIFF is not supported by this \"\n                  \"version of GDAL and libtiff.\" );\n        return FALSE;\n    }\n#endif\n\n    if( (poOpenInfo->pabyHeader[2] != 0x2A || poOpenInfo->pabyHeader[3] != 0)\n        && (poOpenInfo->pabyHeader[3] != 0x2A || poOpenInfo->pabyHeader[2] != 0)\n        && (poOpenInfo->pabyHeader[2] != 0x2B || poOpenInfo->pabyHeader[3] != 0)\n        && (poOpenInfo->pabyHeader[3] != 0x2B ||\n            poOpenInfo->pabyHeader[2] != 0))\n        return FALSE;\n\n    return TRUE;\n}\n\n/************************************************************************/\n/*                          GTIFFExtendMemoryFile()                     */\n/************************************************************************/\n\nstatic bool GTIFFExtendMemoryFile( const CPLString& osTmpFilename,\n                                   VSILFILE* fpTemp,\n                                   VSILFILE* fpL,\n                                   int nNewLength,\n                                   GByte*& pabyBuffer,\n                                   vsi_l_offset& nDataLength )\n{\n    if( nNewLength <= static_cast<int>(nDataLength) )\n        return true;\n    if( VSIFSeekL(fpTemp, nNewLength - 1, SEEK_SET) != 0 )\n        return false;\n    char ch = 0;\n    if( VSIFWriteL(&ch, 1, 1, fpTemp) != 1 )\n        return false;\n    const int nOldDataLength = static_cast<int>(nDataLength);\n    pabyBuffer = static_cast<GByte*>(\n        VSIGetMemFileBuffer( osTmpFilename, &nDataLength, FALSE) );\n    const int nToRead = nNewLength - nOldDataLength;\n    const int nRead = static_cast<int>(\n        VSIFReadL( pabyBuffer + nOldDataLength, 1, nToRead, fpL) );\n    if( nRead != nToRead )\n    {\n        CPLError(CE_Failure, CPLE_FileIO,\n                 \"Needed to read %d bytes. Only %d got\", nToRead, nRead);\n        return false;\n    }\n    return true;\n}\n\n/************************************************************************/\n/*                         GTIFFMakeBufferedStream()                    */\n/************************************************************************/\n\nstatic bool GTIFFMakeBufferedStream(GDALOpenInfo* poOpenInfo)\n{\n    CPLString osTmpFilename;\n    static int nCounter = 0;\n    osTmpFilename.Printf(\"/vsimem/stream_%d.tif\", ++nCounter);\n    VSILFILE* fpTemp = VSIFOpenL(osTmpFilename, \"wb+\");\n    if( fpTemp == nullptr )\n        return false;\n    // The seek is needed for /vsistdin/ that has some rewind capabilities.\n    if( VSIFSeekL(poOpenInfo->fpL, poOpenInfo->nHeaderBytes, SEEK_SET) != 0 )\n    {\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n        return false;\n    }\n    CPLAssert( static_cast<int>( VSIFTellL(poOpenInfo->fpL) ) ==\n               poOpenInfo->nHeaderBytes );\n    if( VSIFWriteL(poOpenInfo->pabyHeader, poOpenInfo->nHeaderBytes,\n                   1, fpTemp) != 1 )\n    {\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n        return false;\n    }\n    vsi_l_offset nDataLength = 0;\n    GByte* pabyBuffer =\n        static_cast<GByte*>(\n            VSIGetMemFileBuffer( osTmpFilename, &nDataLength, FALSE) );\n    const bool bLittleEndian = (pabyBuffer[0] == 'I');\n#if CPL_IS_LSB\n    const bool bSwap = !bLittleEndian;\n#else\n    const bool bSwap = bLittleEndian;\n#endif\n    const bool bBigTIFF = pabyBuffer[2] == 43 || pabyBuffer[3] == 43;\n    vsi_l_offset nMaxOffset = 0;\n    if( bBigTIFF )\n    {\n        GUInt64 nTmp = 0;\n        memcpy(&nTmp, pabyBuffer + 8, 8);\n        if( bSwap ) CPL_SWAP64PTR(&nTmp);\n        if( nTmp != 16 )\n        {\n            CPLError(CE_Failure, CPLE_NotSupported,\n                     \"IFD start should be at offset 16 for a streamed BigTIFF\");\n            CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n            VSIUnlink(osTmpFilename);\n            return false;\n        }\n        memcpy(&nTmp, pabyBuffer + 16, 8);\n        if( bSwap ) CPL_SWAP64PTR(&nTmp);\n        if( nTmp > 1024 )\n        {\n            CPLError(CE_Failure, CPLE_NotSupported,\n                     \"Too many tags : \" CPL_FRMT_GIB, nTmp);\n            CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n            VSIUnlink(osTmpFilename);\n            return false;\n        }\n        const int nTags = static_cast<int>(nTmp);\n        const int nSpaceForTags = nTags * 20;\n        if( !GTIFFExtendMemoryFile(osTmpFilename, fpTemp, poOpenInfo->fpL,\n                                    24 + nSpaceForTags,\n                                    pabyBuffer, nDataLength) )\n        {\n            CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n            VSIUnlink(osTmpFilename);\n            return false;\n        }\n        nMaxOffset = 24 + nSpaceForTags + 8;\n        for( int i = 0; i < nTags; ++i )\n        {\n            GUInt16 nTmp16 = 0;\n            memcpy(&nTmp16, pabyBuffer + 24 + i * 20, 2);\n            if( bSwap ) CPL_SWAP16PTR(&nTmp16);\n            const int nTag = nTmp16;\n            memcpy(&nTmp16, pabyBuffer + 24 + i * 20 + 2, 2);\n            if( bSwap ) CPL_SWAP16PTR(&nTmp16);\n            const int nDataType = nTmp16;\n            memcpy(&nTmp, pabyBuffer + 24 + i * 20 + 4, 8);\n            if( bSwap ) CPL_SWAP64PTR(&nTmp);\n            if( nTmp >= 16 * 1024 * 1024 )\n            {\n                CPLError(\n                    CE_Failure, CPLE_NotSupported,\n                    \"Too many elements for tag %d : \" CPL_FRMT_GUIB,\n                    nTag, nTmp );\n                CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n                VSIUnlink(osTmpFilename);\n                return false;\n            }\n            const GUInt32 nCount = static_cast<GUInt32>(nTmp);\n            const GUInt32 nTagSize =\n                TIFFDataWidth(static_cast<TIFFDataType>(nDataType)) * nCount;\n            if( nTagSize > 8 )\n            {\n                memcpy(&nTmp, pabyBuffer + 24 + i * 20 + 12, 8);\n                if( bSwap ) CPL_SWAP64PTR(&nTmp);\n                if( nTmp > GUINT64_MAX - nTagSize )\n                {\n                    CPLError(CE_Failure, CPLE_NotSupported,\n                             \"Overflow with tag %d\", nTag);\n                    CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n                    VSIUnlink(osTmpFilename);\n                    return false;\n                }\n                if( static_cast<vsi_l_offset>(nTmp + nTagSize) > nMaxOffset )\n                    nMaxOffset = nTmp + nTagSize;\n            }\n        }\n    }\n    else\n    {\n        GUInt32 nTmp = 0;\n        memcpy(&nTmp, pabyBuffer + 4, 4);\n        if( bSwap ) CPL_SWAP32PTR(&nTmp);\n        if( nTmp != 8 )\n        {\n            CPLError(CE_Failure, CPLE_NotSupported,\n                     \"IFD start should be at offset 8 for a streamed TIFF\");\n            CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n            VSIUnlink(osTmpFilename);\n            return false;\n        }\n        GUInt16 nTmp16 = 0;\n        memcpy(&nTmp16, pabyBuffer + 8, 2);\n        if( bSwap ) CPL_SWAP16PTR(&nTmp16);\n        if( nTmp16 > 1024 )\n        {\n            CPLError(CE_Failure, CPLE_NotSupported,\n                     \"Too many tags : %d\", nTmp16);\n            CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n            VSIUnlink(osTmpFilename);\n            return false;\n        }\n        const int nTags = nTmp16;\n        const int nSpaceForTags = nTags * 12;\n        if( !GTIFFExtendMemoryFile(osTmpFilename, fpTemp, poOpenInfo->fpL,\n                                   10 + nSpaceForTags,\n                                   pabyBuffer, nDataLength) )\n        {\n            CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n            VSIUnlink(osTmpFilename);\n            return false;\n        }\n        nMaxOffset = 10 + nSpaceForTags + 4;\n        for( int i = 0; i < nTags; ++i )\n        {\n            memcpy(&nTmp16, pabyBuffer + 10 + i * 12, 2);\n            if( bSwap ) CPL_SWAP16PTR(&nTmp16);\n            const int nTag = nTmp16;\n            memcpy(&nTmp16, pabyBuffer + 10 + i * 12 + 2, 2);\n            if( bSwap ) CPL_SWAP16PTR(&nTmp16);\n            const int nDataType = nTmp16;\n            memcpy(&nTmp, pabyBuffer + 10 + i * 12 + 4, 4);\n            if( bSwap ) CPL_SWAP32PTR(&nTmp);\n            if( nTmp >= 16 * 1024 * 1024 )\n            {\n                CPLError(CE_Failure, CPLE_NotSupported,\n                         \"Too many elements for tag %d : %u\", nTag, nTmp);\n                CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n                VSIUnlink(osTmpFilename);\n                return false;\n            }\n            const GUInt32 nCount = nTmp;\n            const GUInt32 nTagSize =\n                TIFFDataWidth(static_cast<TIFFDataType>(nDataType)) * nCount;\n            if( nTagSize > 4 )\n            {\n                memcpy(&nTmp, pabyBuffer + 10 + i * 12 + 8, 4);\n                if( bSwap ) CPL_SWAP32PTR(&nTmp);\n                if( nTmp > static_cast<GUInt32>(UINT_MAX - nTagSize) )\n                {\n                    CPLError(CE_Failure, CPLE_NotSupported,\n                             \"Overflow with tag %d\", nTag);\n                    CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n                    VSIUnlink(osTmpFilename);\n                    return false;\n                }\n                if( nTmp + nTagSize > nMaxOffset )\n                    nMaxOffset = nTmp + nTagSize;\n            }\n        }\n    }\n    if( nMaxOffset > 10 * 1024 * 1024 )\n    {\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n        VSIUnlink(osTmpFilename);\n        return false;\n    }\n    if( !GTIFFExtendMemoryFile(\n           osTmpFilename, fpTemp, poOpenInfo->fpL,\n           static_cast<int>(nMaxOffset), pabyBuffer, nDataLength) )\n    {\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n        VSIUnlink(osTmpFilename);\n        return false;\n    }\n    CPLAssert(nDataLength == VSIFTellL(poOpenInfo->fpL));\n    poOpenInfo->fpL = reinterpret_cast<VSILFILE *>(\n        VSICreateBufferedReaderHandle(\n            reinterpret_cast<VSIVirtualHandle*>(poOpenInfo->fpL),\n            pabyBuffer,\n            static_cast<vsi_l_offset>(INT_MAX) << 32 ) );\n    if( VSIFCloseL(fpTemp) != 0 )\n        return false;\n    VSIUnlink(osTmpFilename);\n\n    return true;\n}\n\n/************************************************************************/\n/*                                Open()                                */\n/************************************************************************/\n\nGDALDataset *GTiffDataset::Open( GDALOpenInfo * poOpenInfo )\n\n{\n    const char *pszFilename = poOpenInfo->pszFilename;\n\n/* -------------------------------------------------------------------- */\n/*      Check if it looks like a TIFF file.                             */\n/* -------------------------------------------------------------------- */\n    if( !Identify(poOpenInfo) )\n        return nullptr;\n\n    bool bAllowRGBAInterface = true;\n    if( STARTS_WITH_CI(pszFilename, \"GTIFF_RAW:\") )\n    {\n        bAllowRGBAInterface = false;\n        pszFilename += strlen(\"GTIFF_RAW:\");\n    }\n\n/* -------------------------------------------------------------------- */\n/*      We have a special hook for handling opening a specific          */\n/*      directory of a TIFF file.                                       */\n/* -------------------------------------------------------------------- */\n    if( STARTS_WITH_CI(pszFilename, \"GTIFF_DIR:\") )\n        return OpenDir( poOpenInfo );\n\n    if( !GTiffOneTimeInit() )\n        return nullptr;\n\n/* -------------------------------------------------------------------- */\n/*      Try opening the dataset.                                        */\n/* -------------------------------------------------------------------- */\n    // Disable strip chop for now.\n    bool bStreaming = false;\n    const char* pszReadStreaming =\n        CPLGetConfigOption(\"TIFF_READ_STREAMING\", nullptr);\n    if( poOpenInfo->fpL == nullptr )\n    {\n        poOpenInfo->fpL =\n            VSIFOpenL( pszFilename,\n                       poOpenInfo->eAccess == GA_ReadOnly ? \"rb\" : \"r+b\" );\n        if( poOpenInfo->fpL == nullptr )\n            return nullptr;\n    }\n    else if( !(pszReadStreaming && !CPLTestBool(pszReadStreaming)) &&\n             poOpenInfo->nHeaderBytes >= 24 &&\n             // A pipe has no seeking capability, so its position is 0 despite\n             // having read bytes.\n             (static_cast<int>( VSIFTellL(poOpenInfo->fpL) ) ==\n              poOpenInfo->nHeaderBytes ||\n              strcmp(pszFilename, \"/vsistdin/\") == 0 ||\n              // STARTS_WITH(pszFilename, \"/vsicurl_streaming/\") ||\n              (pszReadStreaming && CPLTestBool(pszReadStreaming))) )\n    {\n        bStreaming = true;\n        if( !GTIFFMakeBufferedStream(poOpenInfo) )\n            return nullptr;\n    }\n\n    // Store errors/warnings and emit them later.\n    std::vector<GTIFFErrorStruct> aoErrors;\n    CPLPushErrorHandlerEx(GTIFFErrorHandler, &aoErrors);\n    CPLSetCurrentErrorHandlerCatchDebug( FALSE );\n    // Open and disable \"strip chopping\" (c option)\n    TIFF *l_hTIFF =\n        VSI_TIFFOpen( pszFilename,\n                      poOpenInfo->eAccess == GA_ReadOnly ? \"r\" : \"r+\",\n                      poOpenInfo->fpL );\n    CPLPopErrorHandler();\n\n    // Now emit errors and change their criticality if needed\n    // We only emit failures if we didn't manage to open the file.\n    // Otherwise it makes Python bindings unhappy (#5616).\n    for( size_t iError = 0; iError < aoErrors.size(); ++iError )\n    {\n        CPLError( (l_hTIFF == nullptr && aoErrors[iError].type == CE_Failure) ?\n                  CE_Failure : CE_Warning,\n                  aoErrors[iError].no,\n                  \"%s\",\n                  aoErrors[iError].msg.c_str() );\n    }\n    aoErrors.resize(0);\n\n    if( l_hTIFF == nullptr )\n        return nullptr;\n\n    uint32 nXSize = 0;\n    TIFFGetField( l_hTIFF, TIFFTAG_IMAGEWIDTH, &nXSize );\n    uint32 nYSize = 0;\n    TIFFGetField( l_hTIFF, TIFFTAG_IMAGELENGTH, &nYSize );\n\n    if( nXSize > INT_MAX || nYSize > INT_MAX )\n    {\n        // GDAL only supports signed 32bit dimensions.\n        CPLError(CE_Failure, CPLE_NotSupported,\n                 \"Too large image size: %u x %u\",\n                 nXSize, nYSize);\n        XTIFFClose( l_hTIFF );\n        return nullptr;\n    }\n\n    uint16 l_nCompression = 0;\n    if( !TIFFGetField( l_hTIFF, TIFFTAG_COMPRESSION, &(l_nCompression) ) )\n        l_nCompression = COMPRESSION_NONE;\n\n/* -------------------------------------------------------------------- */\n/*      Create a corresponding GDALDataset.                             */\n/* -------------------------------------------------------------------- */\n    GTiffDataset *poDS = new GTiffDataset();\n    poDS->SetDescription( pszFilename );\n    poDS->osFilename = pszFilename;\n    poDS->poActiveDS = poDS;\n    poDS->fpL = poOpenInfo->fpL;\n    poOpenInfo->fpL = nullptr;\n    poDS->bStreamingIn = bStreaming;\n    poDS->nCompression = l_nCompression;\n\n    // In the case of GDAL_DISABLE_READDIR_ON_OPEN = NO / EMPTY_DIR\n    if( poOpenInfo->AreSiblingFilesLoaded() &&\n        CSLCount( poOpenInfo->GetSiblingFiles() ) <= 1 )\n    {\n        poDS->oOvManager.TransferSiblingFiles( CSLDuplicate(\n                                            poOpenInfo->GetSiblingFiles() ) );\n        poDS->m_bHasGotSiblingFiles = true;\n    }\n\n    if( poDS->OpenOffset( l_hTIFF, &(poDS->poActiveDS),\n                          TIFFCurrentDirOffset(l_hTIFF), true,\n                          poOpenInfo->eAccess,\n                          bAllowRGBAInterface, true) != CE_None )\n    {\n        delete poDS;\n        return nullptr;\n    }\n\n    // Do we want blocks that are set to zero and that haven't yet being\n    // allocated as tile/strip to remain implicit?\n    if( CPLFetchBool( poOpenInfo->papszOpenOptions, \"SPARSE_OK\", false ) )\n        poDS->bWriteEmptyTiles = false;\n\n    if( poOpenInfo->eAccess == GA_Update )\n    {\n        poDS->InitCreationOrOpenOptions(poOpenInfo->papszOpenOptions);\n    }\n\n    poDS->m_bLoadPam = true;\n    poDS->bColorProfileMetadataChanged = false;\n    poDS->bMetadataChanged = false;\n    poDS->bGeoTIFFInfoChanged = false;\n    poDS->bNoDataChanged = false;\n    poDS->bForceUnsetGTOrGCPs = false;\n    poDS->bForceUnsetProjection = false;\n\n/* -------------------------------------------------------------------- */\n/*      Initialize info for external overviews.                         */\n/* -------------------------------------------------------------------- */\n    poDS->oOvManager.Initialize( poDS, pszFilename );\n    if( poOpenInfo->AreSiblingFilesLoaded() )\n        poDS->oOvManager.TransferSiblingFiles(\n            poOpenInfo->StealSiblingFiles() );\n\n    // For backward compatibility, in case GTIFF_POINT_GEO_IGNORE is defined\n    // load georeferencing right now so as to not require it to be defined\n    // at the GetGeoTransform() time.\n    if( CPLGetConfigOption(\"GTIFF_POINT_GEO_IGNORE\", nullptr) != nullptr )\n    {\n        poDS->LoadGeoreferencingAndPamIfNeeded();\n    }\n\n    return poDS;\n}\n\n/************************************************************************/\n/*                      GTiffDatasetSetAreaOrPointMD()                  */\n/************************************************************************/\n\nstatic void GTiffDatasetSetAreaOrPointMD( GTIF* hGTIF,\n                                          GDALMultiDomainMetadata& oGTiffMDMD )\n{\n    // Is this a pixel-is-point dataset?\n    short nRasterType = 0;\n\n    if( GDALGTIFKeyGetSHORT(hGTIF, GTRasterTypeGeoKey, &nRasterType,\n                    0, 1 ) == 1 )\n    {\n        if( nRasterType == static_cast<short>(RasterPixelIsPoint) )\n            oGTiffMDMD.SetMetadataItem(GDALMD_AREA_OR_POINT, GDALMD_AOP_POINT);\n        else\n            oGTiffMDMD.SetMetadataItem(GDALMD_AREA_OR_POINT, GDALMD_AOP_AREA);\n    }\n}\n\n/************************************************************************/\n/*                         LoadMDAreaOrPoint()                          */\n/************************************************************************/\n\n// This is a light version of LookForProjection(), which saves the\n// potential costly cost of GTIFGetOGISDefn(), since we just need to\n// access to a raw GeoTIFF key, and not build the full projection object.\n\nvoid GTiffDataset::LoadMDAreaOrPoint()\n{\n    if( bLookedForProjection || bLookedForMDAreaOrPoint ||\n        oGTiffMDMD.GetMetadataItem( GDALMD_AREA_OR_POINT ) != nullptr )\n        return;\n\n    bLookedForMDAreaOrPoint = true;\n\n    if( !SetDirectory() )\n        return;\n\n    GTIF* hGTIF = GTiffDatasetGTIFNew(hTIFF);\n\n    if( !hGTIF )\n    {\n        CPLError( CE_Warning, CPLE_AppDefined,\n                  \"GeoTIFF tags apparently corrupt, they are being ignored.\" );\n    }\n    else\n    {\n        GTiffDatasetSetAreaOrPointMD( hGTIF, oGTiffMDMD );\n\n        GTIFFree( hGTIF );\n    }\n}\n\n/************************************************************************/\n/*                         LookForProjection()                          */\n/************************************************************************/\n\nvoid GTiffDataset::LookForProjection()\n\n{\n    if( bLookedForProjection )\n        return;\n\n    bLookedForProjection = true;\n\n    IdentifyAuthorizedGeoreferencingSources();\n    if( m_nINTERNALGeorefSrcIndex < 0 )\n        return;\n\n    if( !SetDirectory() )\n        return;\n\n/* -------------------------------------------------------------------- */\n/*      Capture the GeoTIFF projection, if available.                   */\n/* -------------------------------------------------------------------- */\n    CPLFree( pszProjection );\n    pszProjection = nullptr;\n\n    GTIF *hGTIF = GTiffDatasetGTIFNew(hTIFF);\n\n    if( !hGTIF )\n    {\n        CPLError( CE_Warning, CPLE_AppDefined,\n                  \"GeoTIFF tags apparently corrupt, they are being ignored.\" );\n    }\n    else\n    {\n#if LIBGEOTIFF_VERSION >= 1410\n        GTIFDefn *psGTIFDefn = GTIFAllocDefn();\n#else\n        GTIFDefn *psGTIFDefn =\n            static_cast<GTIFDefn *>(CPLCalloc(1, sizeof(GTIFDefn)));\n#endif\n\n        if( GTIFGetDefn( hGTIF, psGTIFDefn ) )\n        {\n            pszProjection = GTIFGetOGISDefn( hGTIF, psGTIFDefn );\n\n            if( STARTS_WITH_CI(pszProjection, \"COMPD_CS\") )\n            {\n                OGRSpatialReference oSRS;\n\n                oSRS.importFromWkt( pszProjection );\n\n                const char* pszVertUnit = nullptr;\n                oSRS.GetTargetLinearUnits(\"COMPD_CS|VERT_CS\", &pszVertUnit);\n                if( pszVertUnit && !EQUAL(pszVertUnit, \"unknown\") )\n                {\n                    m_osVertUnit = pszVertUnit;\n                }\n\n                // Should we simplify away vertical CS stuff?\n                if( !CPLTestBool( CPLGetConfigOption(\"GTIFF_REPORT_COMPD_CS\",\n                                                    \"NO\") ) )\n                {\n                    CPLDebug( \"GTiff\", \"Got COMPD_CS, but stripping it.\" );\n\n                    oSRS.StripVertical();\n                    CPLFree( pszProjection );\n                    oSRS.exportToWkt( &pszProjection );\n                }\n            }\n        }\n\n        // Check the tif linear unit and the CS linear unit.\n#ifdef ESRI_BUILD\n        AdjustLinearUnit(psGTIFDefn.UOMLength);\n#endif\n\n#if LIBGEOTIFF_VERSION >= 1410\n        GTIFFreeDefn(psGTIFDefn);\n#else\n        CPLFree(psGTIFDefn);\n#endif\n\n        GTiffDatasetSetAreaOrPointMD( hGTIF, oGTiffMDMD );\n\n        GTIFFree( hGTIF );\n    }\n\n    if( pszProjection == nullptr )\n    {\n        pszProjection = CPLStrdup( \"\" );\n    }\n    // else if( !EQUAL(pszProjection, \"\") )\n    // {\n    //     m_nProjectionGeorefSrcIndex = m_nINTERNALGeorefSrcIndex;\n    // }\n\n    bGeoTIFFInfoChanged = false;\n    bForceUnsetGTOrGCPs = false;\n    bForceUnsetProjection = false;\n}\n\n/************************************************************************/\n/*                          AdjustLinearUnit()                          */\n/*                                                                      */\n/*      The following code is only used in ESRI Builds and there is     */\n/*      outstanding discussion on whether it is even appropriate        */\n/*      then.                                                           */\n/************************************************************************/\n#ifdef ESRI_BUILD\n\nvoid GTiffDataset::AdjustLinearUnit( short UOMLength )\n{\n    if( !pszProjection || strlen(pszProjection) == 0 )\n        return;\n    if( UOMLength == 9001 )\n    {\n        char* pstr = strstr(pszProjection, \"PARAMETER\");\n        if( !pstr )\n            return;\n        pstr = strstr(pstr, \"UNIT[\");\n        if( !pstr )\n            return;\n        pstr = strchr(pstr, ',') + 1;\n        if( !pstr )\n            return;\n        char* pstr1 = strchr(pstr, ']');\n        if( !pstr1 || pstr1 - pstr >= 128 )\n            return;\n        char csUnitStr[128];\n        strncpy(csUnitStr, pstr, pstr1 - pstr);\n        csUnitStr[pstr1-pstr] = '\\0';\n        const double csUnit = CPLAtof(csUnitStr);\n        if( fabs(csUnit - 1.0) > 0.000001 )\n        {\n            for( long i = 0; i < 6; ++i )\n                adfGeoTransform[i] /= csUnit;\n        }\n    }\n}\n\n#endif  // def ESRI_BUILD\n\n/************************************************************************/\n/*                            ApplyPamInfo()                            */\n/*                                                                      */\n/*      PAM Information, if available, overrides the GeoTIFF            */\n/*      geotransform and projection definition.  Check for them         */\n/*      now.                                                            */\n/************************************************************************/\n\nvoid GTiffDataset::ApplyPamInfo()\n\n{\n    if( m_nPAMGeorefSrcIndex >= 0 &&\n        ((bGeoTransformValid &&\n          m_nPAMGeorefSrcIndex < m_nGeoTransformGeorefSrcIndex) ||\n          m_nGeoTransformGeorefSrcIndex < 0 || !bGeoTransformValid) )\n    {\n        double adfPamGeoTransform[6] = { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 };\n        if( GDALPamDataset::GetGeoTransform( adfPamGeoTransform ) == CE_None )\n        {\n            if( m_nGeoTransformGeorefSrcIndex == m_nWORLDFILEGeorefSrcIndex )\n                osGeorefFilename.clear();\n            memcpy(adfGeoTransform, adfPamGeoTransform, sizeof(double) * 6);\n            bGeoTransformValid = true;\n        }\n    }\n\n    if( m_nPAMGeorefSrcIndex >= 0 )\n    {\n        if( (m_nTABFILEGeorefSrcIndex < 0 ||\n             m_nPAMGeorefSrcIndex < m_nTABFILEGeorefSrcIndex) &&\n            (m_nINTERNALGeorefSrcIndex < 0 ||\n             m_nPAMGeorefSrcIndex < m_nINTERNALGeorefSrcIndex) )\n        {\n            const char *pszPamSRS = GDALPamDataset::GetProjectionRef();\n            if( pszPamSRS != nullptr && strlen(pszPamSRS) > 0 )\n            {\n                CPLFree( pszProjection );\n                pszProjection = CPLStrdup( pszPamSRS );\n                bLookedForProjection = true;\n                // m_nProjectionGeorefSrcIndex = m_nPAMGeorefSrcIndex;\n            }\n        }\n        else\n        {\n            if( m_nINTERNALGeorefSrcIndex >= 0 )\n                LookForProjection();\n            if( pszProjection == nullptr || strlen(pszProjection) == 0 )\n            {\n                const char *pszPamSRS = GDALPamDataset::GetProjectionRef();\n                if( pszPamSRS != nullptr && strlen(pszPamSRS) > 0 )\n                {\n                    CPLFree( pszProjection );\n                    pszProjection = CPLStrdup( pszPamSRS );\n                    bLookedForProjection = true;\n                    // m_nProjectionGeorefSrcIndex = m_nPAMGeorefSrcIndex;\n                }\n            }\n        }\n    }\n\n    int nPamGCPCount;\n    if( m_nPAMGeorefSrcIndex >= 0 &&\n        (nPamGCPCount = GDALPamDataset::GetGCPCount()) > 0 &&\n        ( (nGCPCount > 0 &&\n           m_nPAMGeorefSrcIndex < m_nGeoTransformGeorefSrcIndex) ||\n          m_nGeoTransformGeorefSrcIndex < 0 || nGCPCount == 0 ) )\n    {\n        if( nGCPCount > 0 )\n        {\n            GDALDeinitGCPs( nGCPCount, pasGCPList );\n            CPLFree( pasGCPList );\n            pasGCPList = nullptr;\n        }\n\n        nGCPCount = nPamGCPCount;\n        pasGCPList = GDALDuplicateGCPs(nGCPCount, GDALPamDataset::GetGCPs());\n\n        CPLFree( pszProjection );\n        pszProjection = nullptr;\n        // m_nProjectionGeorefSrcIndex = m_nPAMGeorefSrcIndex;\n\n        const char *pszPamGCPProjection = GDALPamDataset::GetGCPProjection();\n        if( pszPamGCPProjection != nullptr && strlen(pszPamGCPProjection) > 0 )\n            pszProjection = CPLStrdup(pszPamGCPProjection);\n        else\n            pszProjection = CPLStrdup(\"\");\n\n        bLookedForProjection = true;\n    }\n\n    if( m_nPAMGeorefSrcIndex >= 0 && nGCPCount == 0 )\n    {\n        CPLXMLNode *psValueAsXML = nullptr;\n        CPLXMLNode *psGeodataXform = nullptr;\n        char** papszXML = oMDMD.GetMetadata( \"xml:ESRI\" );\n        if (CSLCount(papszXML) == 1)\n        {\n            psValueAsXML = CPLParseXMLString( papszXML[0] );\n            if( psValueAsXML )\n                psGeodataXform = CPLGetXMLNode(psValueAsXML, \"=GeodataXform\");\n        }\n\n        const char* pszTIFFTagResUnit = GetMetadataItem(\"TIFFTAG_RESOLUTIONUNIT\");\n        const char* pszTIFFTagXRes = GetMetadataItem(\"TIFFTAG_XRESOLUTION\");\n        const char* pszTIFFTagYRes = GetMetadataItem(\"TIFFTAG_YRESOLUTION\");\n        if (psGeodataXform && pszTIFFTagResUnit &&pszTIFFTagXRes &&\n            pszTIFFTagYRes && atoi(pszTIFFTagResUnit) == 2 )\n        {\n            CPLXMLNode* psSourceGCPs = CPLGetXMLNode(psGeodataXform,\n                                                        \"SourceGCPs\");\n            CPLXMLNode* psTargetGCPs = CPLGetXMLNode(psGeodataXform,\n                                                        \"TargetGCPs\");\n            if( psSourceGCPs && psTargetGCPs )\n            {\n                std::vector<double> adfSourceGCPs, adfTargetGCPs;\n                for( CPLXMLNode* psIter = psSourceGCPs->psChild;\n                                    psIter != nullptr;\n                                    psIter = psIter->psNext )\n                {\n                    if( psIter->eType == CXT_Element &&\n                        EQUAL(psIter->pszValue, \"Double\") )\n                    {\n                        adfSourceGCPs.push_back(\n                            CPLAtof( CPLGetXMLValue(psIter, nullptr, \"\") ) );\n                    }\n                }\n                for( CPLXMLNode* psIter = psTargetGCPs->psChild;\n                                    psIter != nullptr;\n                                    psIter = psIter->psNext )\n                {\n                    if( psIter->eType == CXT_Element &&\n                        EQUAL(psIter->pszValue, \"Double\") )\n                    {\n                        adfTargetGCPs.push_back(\n                            CPLAtof( CPLGetXMLValue(psIter, nullptr, \"\") ) );\n                    }\n                }\n                if( adfSourceGCPs.size() == adfTargetGCPs.size() &&\n                    (adfSourceGCPs.size() % 2) == 0 )\n                {\n                    nGCPCount = static_cast<int>(\n                                            adfSourceGCPs.size() / 2);\n                    pasGCPList = static_cast<GDAL_GCP *>(\n                            CPLCalloc(sizeof(GDAL_GCP), nGCPCount) );\n                    for( int i = 0; i < nGCPCount; ++i )\n                    {\n                        pasGCPList[i].pszId = CPLStrdup(\"\");\n                        pasGCPList[i].pszInfo = CPLStrdup(\"\");\n                        // The origin used is the bottom left corner,\n                        // and raw values are in inches!\n                        pasGCPList[i].dfGCPPixel = adfSourceGCPs[2*i] *\n                                                        CPLAtof(pszTIFFTagXRes);\n                        pasGCPList[i].dfGCPLine = nRasterYSize -\n                                adfSourceGCPs[2*i+1] * CPLAtof(pszTIFFTagYRes);\n                        pasGCPList[i].dfGCPX = adfTargetGCPs[2*i];\n                        pasGCPList[i].dfGCPY = adfTargetGCPs[2*i+1];\n                    }\n                }\n            }\n        }\n        if( psValueAsXML )\n            CPLDestroyXMLNode(psValueAsXML);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Copy any PAM metadata into our GeoTIFF context, and with        */\n/*      the PAM info overriding the GeoTIFF context.                    */\n/* -------------------------------------------------------------------- */\n    char **papszPamDomains = oMDMD.GetDomainList();\n\n    for( int iDomain = 0;\n         papszPamDomains && papszPamDomains[iDomain] != nullptr;\n         ++iDomain )\n    {\n        const char *pszDomain = papszPamDomains[iDomain];\n        char **papszGT_MD = CSLDuplicate(oGTiffMDMD.GetMetadata( pszDomain ));\n        char **papszPAM_MD = oMDMD.GetMetadata( pszDomain );\n\n        papszGT_MD = CSLMerge( papszGT_MD, papszPAM_MD );\n\n        oGTiffMDMD.SetMetadata( papszGT_MD, pszDomain );\n        CSLDestroy( papszGT_MD );\n    }\n\n    for( int i = 1; i <= GetRasterCount(); ++i )\n    {\n        GTiffRasterBand* poBand =\n            cpl::down_cast<GTiffRasterBand *>(GetRasterBand(i));\n        papszPamDomains = poBand->oMDMD.GetDomainList();\n\n        for( int iDomain = 0;\n             papszPamDomains && papszPamDomains[iDomain] != nullptr;\n             ++iDomain )\n        {\n            const char *pszDomain = papszPamDomains[iDomain];\n            char **papszGT_MD =\n                CSLDuplicate(poBand->oGTiffMDMD.GetMetadata( pszDomain ));\n            char **papszPAM_MD = poBand->oMDMD.GetMetadata( pszDomain );\n\n            papszGT_MD = CSLMerge( papszGT_MD, papszPAM_MD );\n\n            poBand->oGTiffMDMD.SetMetadata( papszGT_MD, pszDomain );\n            CSLDestroy( papszGT_MD );\n        }\n    }\n}\n\n/************************************************************************/\n/*                              OpenDir()                               */\n/*                                                                      */\n/*      Open a specific directory as encoded into a filename.           */\n/************************************************************************/\n\nGDALDataset *GTiffDataset::OpenDir( GDALOpenInfo * poOpenInfo )\n\n{\n    bool bAllowRGBAInterface = true;\n    const char* pszFilename = poOpenInfo->pszFilename;\n    if( STARTS_WITH_CI(pszFilename, \"GTIFF_RAW:\") )\n    {\n        bAllowRGBAInterface = false;\n        pszFilename += strlen(\"GTIFF_RAW:\");\n    }\n\n    if( !STARTS_WITH_CI(pszFilename, \"GTIFF_DIR:\") ||\n        pszFilename[strlen(\"GTIFF_DIR:\")] == '\\0' )\n    {\n        return nullptr;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Split out filename, and dir#/offset.                            */\n/* -------------------------------------------------------------------- */\n    pszFilename += strlen(\"GTIFF_DIR:\");\n    bool bAbsolute = false;\n\n    if( STARTS_WITH_CI(pszFilename, \"off:\") )\n    {\n        bAbsolute = true;\n        pszFilename += 4;\n    }\n\n    toff_t nOffset = atol(pszFilename);\n    pszFilename += 1;\n\n    while( *pszFilename != '\\0' && pszFilename[-1] != ':' )\n        ++pszFilename;\n\n    if( *pszFilename == '\\0' || nOffset == 0 )\n    {\n        CPLError(\n            CE_Failure, CPLE_OpenFailed,\n            \"Unable to extract offset or filename, should take the form:\\n\"\n            \"GTIFF_DIR:<dir>:filename or GTIFF_DIR:off:<dir_offset>:filename\" );\n        return nullptr;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Try opening the dataset.                                        */\n/* -------------------------------------------------------------------- */\n    if( !GTiffOneTimeInit() )\n        return nullptr;\n\n    VSILFILE* l_fpL = VSIFOpenL(pszFilename, \"r\");\n    if( l_fpL == nullptr )\n        return nullptr;\n    TIFF *l_hTIFF = VSI_TIFFOpen( pszFilename, \"r\", l_fpL );\n    if( l_hTIFF == nullptr )\n    {\n        CPL_IGNORE_RET_VAL(VSIFCloseL(l_fpL));\n        return nullptr;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If a directory was requested by index, advance to it now.       */\n/* -------------------------------------------------------------------- */\n    if( !bAbsolute )\n    {\n        const toff_t nOffsetRequested = nOffset;\n        while( nOffset > 1 )\n        {\n            if( TIFFReadDirectory( l_hTIFF ) == 0 )\n            {\n                XTIFFClose( l_hTIFF );\n                CPLError(\n                    CE_Failure, CPLE_OpenFailed,\n                    \"Requested directory %lu not found.\",\n                    static_cast<long unsigned int>(nOffsetRequested));\n                CPL_IGNORE_RET_VAL(VSIFCloseL(l_fpL));\n                return nullptr;\n            }\n            nOffset--;\n        }\n\n        nOffset = TIFFCurrentDirOffset( l_hTIFF );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Create a corresponding GDALDataset.                             */\n/* -------------------------------------------------------------------- */\n    GTiffDataset *poDS = new GTiffDataset();\n    poDS->SetDescription( poOpenInfo->pszFilename );\n    poDS->osFilename = poOpenInfo->pszFilename;\n    poDS->poActiveDS = poDS;\n    poDS->fpL = l_fpL;\n    poDS->hTIFF = l_hTIFF;\n    poDS->bCloseTIFFHandle = true;\n\n    if( !EQUAL(pszFilename,poOpenInfo->pszFilename)\n        && !STARTS_WITH_CI(poOpenInfo->pszFilename, \"GTIFF_RAW:\") )\n    {\n        poDS->SetPhysicalFilename( pszFilename );\n        poDS->SetSubdatasetName( poOpenInfo->pszFilename );\n        poDS->osFilename = pszFilename;\n    }\n\n    if( poOpenInfo->eAccess == GA_Update )\n    {\n        CPLError(\n            CE_Warning, CPLE_AppDefined,\n            \"Opening a specific TIFF directory is not supported in \"\n            \"update mode. Switching to read-only\" );\n    }\n\n    if( poOpenInfo->AreSiblingFilesLoaded() )\n        poDS->oOvManager.TransferSiblingFiles(\n            poOpenInfo->StealSiblingFiles() );\n\n    if( poDS->OpenOffset( l_hTIFF, &(poDS->poActiveDS),\n                          nOffset, false, GA_ReadOnly,\n                          bAllowRGBAInterface, true ) != CE_None )\n    {\n        delete poDS;\n        return nullptr;\n    }\n\n    return poDS;\n}\n\n/************************************************************************/\n/*                   ConvertTransferFunctionToString()                  */\n/*                                                                      */\n/*      Convert a transfer function table into a string.                */\n/*      Used by LoadICCProfile().                                       */\n/************************************************************************/\nstatic CPLString ConvertTransferFunctionToString( const uint16 *pTable,\n                                                  uint32 nTableEntries )\n{\n    CPLString sValue;\n\n    for( uint32 i = 0; i < nTableEntries; ++i )\n    {\n        if( i == 0 )\n            sValue = sValue.Printf(\"%d\", static_cast<uint32>(pTable[i]));\n        else\n            sValue = sValue.Printf( \"%s, %d\",\n                                    sValue.c_str(),\n                                    static_cast<uint32>(pTable[i]));\n    }\n\n    return sValue;\n}\n\n/************************************************************************/\n/*                             LoadICCProfile()                         */\n/*                                                                      */\n/*      Load ICC Profile or colorimetric data into metadata             */\n/************************************************************************/\n\nvoid GTiffDataset::LoadICCProfile()\n{\n    if( bICCMetadataLoaded )\n        return;\n    bICCMetadataLoaded = true;\n\n    if( !SetDirectory() )\n        return;\n\n    uint32 nEmbedLen = 0;\n    uint8* pEmbedBuffer = nullptr;\n\n\n    if( TIFFGetField(hTIFF, TIFFTAG_ICCPROFILE, &nEmbedLen, &pEmbedBuffer) )\n    {\n        char *pszBase64Profile =\n            CPLBase64Encode(nEmbedLen, reinterpret_cast<const GByte*>(pEmbedBuffer));\n\n        oGTiffMDMD.SetMetadataItem( \"SOURCE_ICC_PROFILE\", pszBase64Profile,\n                                    \"COLOR_PROFILE\" );\n\n        CPLFree(pszBase64Profile);\n\n        return;\n    }\n\n    // Check for colorimetric tiff.\n    float* pCHR = nullptr;\n    float* pWP = nullptr;\n    uint16 *pTFR = nullptr;\n    uint16 *pTFG = nullptr;\n    uint16 *pTFB = nullptr;\n    uint16 *pTransferRange = nullptr;\n\n    if( TIFFGetField(hTIFF, TIFFTAG_PRIMARYCHROMATICITIES, &pCHR) )\n    {\n        if( TIFFGetField(hTIFF, TIFFTAG_WHITEPOINT, &pWP) )\n        {\n            if( !TIFFGetFieldDefaulted( hTIFF, TIFFTAG_TRANSFERFUNCTION, &pTFR,\n                                        &pTFG, &pTFB) )\n                return;\n\n            const int TIFFTAG_TRANSFERRANGE = 0x0156;\n            TIFFGetFieldDefaulted( hTIFF, TIFFTAG_TRANSFERRANGE,\n                                   &pTransferRange);\n\n            // Set all the colorimetric metadata.\n            oGTiffMDMD.SetMetadataItem(\n                \"SOURCE_PRIMARIES_RED\",\n                CPLString().Printf( \"%.9f, %.9f, 1.0\",\n                                    static_cast<double>(pCHR[0]),\n                                    static_cast<double>(pCHR[1]) ),\n                \"COLOR_PROFILE\" );\n            oGTiffMDMD.SetMetadataItem(\n                \"SOURCE_PRIMARIES_GREEN\",\n                CPLString().Printf( \"%.9f, %.9f, 1.0\",\n                                    static_cast<double>(pCHR[2]),\n                                    static_cast<double>(pCHR[3]) ),\n                \"COLOR_PROFILE\" );\n            oGTiffMDMD.SetMetadataItem(\n                \"SOURCE_PRIMARIES_BLUE\",\n                CPLString().Printf( \"%.9f, %.9f, 1.0\",\n                                    static_cast<double>(pCHR[4]),\n                                    static_cast<double>(pCHR[5]) ),\n                \"COLOR_PROFILE\" );\n\n            oGTiffMDMD.SetMetadataItem(\n                \"SOURCE_WHITEPOINT\",\n                CPLString().Printf( \"%.9f, %.9f, 1.0\",\n                                    static_cast<double>(pWP[0]),\n                                    static_cast<double>(pWP[1]) ),\n                \"COLOR_PROFILE\" );\n\n            // Set transfer function metadata.\n\n            // Get length of table.\n            const uint32 nTransferFunctionLength = 1 << nBitsPerSample;\n\n            oGTiffMDMD.SetMetadataItem(\n                \"TIFFTAG_TRANSFERFUNCTION_RED\",\n                ConvertTransferFunctionToString( pTFR, nTransferFunctionLength),\n                \"COLOR_PROFILE\" );\n\n            oGTiffMDMD.SetMetadataItem(\n                \"TIFFTAG_TRANSFERFUNCTION_GREEN\",\n                ConvertTransferFunctionToString( pTFG, nTransferFunctionLength),\n                \"COLOR_PROFILE\" );\n\n            oGTiffMDMD.SetMetadataItem(\n                \"TIFFTAG_TRANSFERFUNCTION_BLUE\",\n                ConvertTransferFunctionToString( pTFB, nTransferFunctionLength),\n                \"COLOR_PROFILE\" );\n\n            // Set transfer range.\n            if( pTransferRange )\n            {\n                oGTiffMDMD.SetMetadataItem(\n                    \"TIFFTAG_TRANSFERRANGE_BLACK\",\n                    CPLString().Printf( \"%d, %d, %d\",\n                                        static_cast<int>(pTransferRange[0]),\n                                        static_cast<int>(pTransferRange[2]),\n                                        static_cast<int>(pTransferRange[4])),\n                    \"COLOR_PROFILE\" );\n                oGTiffMDMD.SetMetadataItem(\n                    \"TIFFTAG_TRANSFERRANGE_WHITE\",\n                    CPLString().Printf( \"%d, %d, %d\",\n                                        static_cast<int>(pTransferRange[1]),\n                                        static_cast<int>(pTransferRange[3]),\n                                        static_cast<int>(pTransferRange[5])),\n                    \"COLOR_PROFILE\" );\n            }\n        }\n    }\n}\n\n/************************************************************************/\n/*                             SaveICCProfile()                         */\n/*                                                                      */\n/*      Save ICC Profile or colorimetric data into file                 */\n/* pDS:                                                                 */\n/*      Dataset that contains the metadata with the ICC or colorimetric */\n/*      data. If this argument is specified, all other arguments are    */\n/*      ignored. Set them to NULL or 0.                                 */\n/* hTIFF:                                                               */\n/*      Pointer to TIFF handle. Only needed if pDS is NULL or           */\n/*      pDS->hTIFF is NULL.                                             */\n/* papszParmList:                                                       */\n/*      Options containing the ICC profile or colorimetric metadata.    */\n/*      Ignored if pDS is not NULL.                                     */\n/* nBitsPerSample:                                                      */\n/*      Bits per sample. Ignored if pDS is not NULL.                    */\n/************************************************************************/\n\nvoid GTiffDataset::SaveICCProfile( GTiffDataset *pDS, TIFF *l_hTIFF,\n                                   char **papszParmList,\n                                   uint32 l_nBitsPerSample )\n{\n    if( (pDS != nullptr) && (pDS->eAccess != GA_Update) )\n        return;\n\n    if( l_hTIFF == nullptr )\n    {\n        if( pDS == nullptr )\n            return;\n\n        l_hTIFF = pDS->hTIFF;\n        if( l_hTIFF == nullptr )\n            return;\n    }\n\n    if( (papszParmList == nullptr) && (pDS == nullptr) )\n        return;\n\n    const char *pszValue = nullptr;\n    if( pDS != nullptr )\n        pszValue = pDS->GetMetadataItem(\"SOURCE_ICC_PROFILE\", \"COLOR_PROFILE\");\n    else\n        pszValue = CSLFetchNameValue(papszParmList, \"SOURCE_ICC_PROFILE\");\n    if( pszValue != nullptr )\n    {\n        char *pEmbedBuffer = CPLStrdup(pszValue);\n        int32 nEmbedLen =\n            CPLBase64DecodeInPlace(reinterpret_cast<GByte *>(pEmbedBuffer));\n\n        TIFFSetField(l_hTIFF, TIFFTAG_ICCPROFILE, nEmbedLen, pEmbedBuffer);\n\n        CPLFree(pEmbedBuffer);\n    }\n    else\n    {\n        // Output colorimetric data.\n        float pCHR[6] = {};  // Primaries.\n        uint16 pTXR[6] = {};  // Transfer range.\n        const char* pszCHRNames[] = {\n            \"SOURCE_PRIMARIES_RED\",\n            \"SOURCE_PRIMARIES_GREEN\",\n            \"SOURCE_PRIMARIES_BLUE\"\n        };\n        const char* pszTXRNames[] = {\n            \"TIFFTAG_TRANSFERRANGE_BLACK\",\n            \"TIFFTAG_TRANSFERRANGE_WHITE\"\n        };\n\n        // Output chromacities.\n        bool bOutputCHR = true;\n        for( int i = 0; i < 3 && bOutputCHR; ++i )\n        {\n            if( pDS != nullptr )\n                pszValue =\n                    pDS->GetMetadataItem(pszCHRNames[i], \"COLOR_PROFILE\");\n            else\n                pszValue = CSLFetchNameValue(papszParmList, pszCHRNames[i]);\n            if( pszValue == nullptr )\n            {\n                bOutputCHR = false;\n                break;\n            }\n\n            char** papszTokens =\n                CSLTokenizeString2(\n                    pszValue, \",\",\n                    CSLT_ALLOWEMPTYTOKENS | CSLT_STRIPLEADSPACES |\n                    CSLT_STRIPENDSPACES );\n\n            if( CSLCount( papszTokens ) != 3 )\n            {\n                bOutputCHR = false;\n                CSLDestroy( papszTokens );\n                break;\n            }\n\n            for( int j = 0; j < 3; ++j )\n            {\n                float v = static_cast<float>(CPLAtof(papszTokens[j]));\n\n                if( j == 2 )\n                {\n                    // Last term of xyY color must be 1.0.\n                    if( v != 1.0 )\n                    {\n                        bOutputCHR = false;\n                        break;\n                    }\n                }\n                else\n                {\n                    pCHR[i * 2 + j] = v;\n                }\n            }\n\n            CSLDestroy( papszTokens );\n        }\n\n        if( bOutputCHR )\n        {\n            TIFFSetField(l_hTIFF, TIFFTAG_PRIMARYCHROMATICITIES, pCHR);\n        }\n\n        // Output whitepoint.\n        if( pDS != nullptr )\n            pszValue =\n                pDS->GetMetadataItem(\"SOURCE_WHITEPOINT\", \"COLOR_PROFILE\");\n        else\n            pszValue = CSLFetchNameValue(papszParmList, \"SOURCE_WHITEPOINT\");\n        if( pszValue != nullptr )\n        {\n            char** papszTokens =\n                CSLTokenizeString2(\n                    pszValue, \",\",\n                    CSLT_ALLOWEMPTYTOKENS | CSLT_STRIPLEADSPACES |\n                    CSLT_STRIPENDSPACES );\n\n            bool bOutputWhitepoint = true;\n            float pWP[2] = { 0.0f, 0.0f };  // Whitepoint\n            if( CSLCount( papszTokens ) != 3 )\n            {\n                bOutputWhitepoint = false;\n            }\n            else\n            {\n                for( int j = 0; j < 3; ++j )\n                {\n                    const float v = static_cast<float>(CPLAtof(papszTokens[j]));\n\n                    if( j == 2 )\n                    {\n                        // Last term of xyY color must be 1.0.\n                        if( v != 1.0 )\n                        {\n                            bOutputWhitepoint = false;\n                            break;\n                        }\n                    }\n                    else\n                    {\n                        pWP[j] = v;\n                    }\n                }\n            }\n            CSLDestroy( papszTokens );\n\n            if( bOutputWhitepoint )\n            {\n                TIFFSetField(l_hTIFF, TIFFTAG_WHITEPOINT, pWP);\n            }\n        }\n\n        // Set transfer function metadata.\n        char const *pszTFRed = nullptr;\n        if( pDS != nullptr )\n            pszTFRed =\n                pDS->GetMetadataItem( \"TIFFTAG_TRANSFERFUNCTION_RED\",\n                                      \"COLOR_PROFILE\" );\n        else\n            pszTFRed =\n                CSLFetchNameValue( papszParmList,\n                                   \"TIFFTAG_TRANSFERFUNCTION_RED\" );\n\n        char const *pszTFGreen = nullptr;\n        if( pDS != nullptr )\n            pszTFGreen =\n                pDS->GetMetadataItem( \"TIFFTAG_TRANSFERFUNCTION_GREEN\",\n                                      \"COLOR_PROFILE\" );\n        else\n            pszTFGreen =\n                CSLFetchNameValue( papszParmList,\n                                   \"TIFFTAG_TRANSFERFUNCTION_GREEN\" );\n\n        char const *pszTFBlue = nullptr;\n        if( pDS != nullptr )\n            pszTFBlue =\n                pDS->GetMetadataItem( \"TIFFTAG_TRANSFERFUNCTION_BLUE\",\n                                      \"COLOR_PROFILE\" );\n        else\n            pszTFBlue =\n                CSLFetchNameValue( papszParmList,\n                                   \"TIFFTAG_TRANSFERFUNCTION_BLUE\" );\n\n        if( (pszTFRed != nullptr) && (pszTFGreen != nullptr) && (pszTFBlue != nullptr) )\n        {\n            // Get length of table.\n            const int nTransferFunctionLength =\n                1 << ((pDS!=nullptr)?pDS->nBitsPerSample:l_nBitsPerSample);\n\n            char** papszTokensRed =\n                CSLTokenizeString2(\n                    pszTFRed, \",\",\n                    CSLT_ALLOWEMPTYTOKENS | CSLT_STRIPLEADSPACES |\n                    CSLT_STRIPENDSPACES );\n            char** papszTokensGreen =\n                CSLTokenizeString2(\n                    pszTFGreen, \",\",\n                    CSLT_ALLOWEMPTYTOKENS | CSLT_STRIPLEADSPACES |\n                    CSLT_STRIPENDSPACES );\n            char** papszTokensBlue =\n                CSLTokenizeString2(\n                    pszTFBlue, \",\",\n                    CSLT_ALLOWEMPTYTOKENS | CSLT_STRIPLEADSPACES |\n                    CSLT_STRIPENDSPACES );\n\n            if( (CSLCount( papszTokensRed ) == nTransferFunctionLength) &&\n                (CSLCount( papszTokensGreen ) == nTransferFunctionLength) &&\n                (CSLCount( papszTokensBlue ) == nTransferFunctionLength) )\n            {\n                uint16 *pTransferFuncRed =\n                    static_cast<uint16*>( CPLMalloc(\n                        sizeof(uint16) * nTransferFunctionLength ) );\n                uint16 *pTransferFuncGreen =\n                    static_cast<uint16*>( CPLMalloc(\n                        sizeof(uint16) * nTransferFunctionLength ) );\n                uint16 *pTransferFuncBlue =\n                    static_cast<uint16*>( CPLMalloc(\n                        sizeof(uint16) * nTransferFunctionLength ) );\n\n                // Convert our table in string format into int16 format.\n                for( int i = 0; i < nTransferFunctionLength; ++i )\n                {\n                    pTransferFuncRed[i] =\n                        static_cast<uint16>(atoi(papszTokensRed[i]));\n                    pTransferFuncGreen[i] =\n                        static_cast<uint16>(atoi(papszTokensGreen[i]));\n                    pTransferFuncBlue[i] =\n                        static_cast<uint16>(atoi(papszTokensBlue[i]));\n                }\n\n                TIFFSetField(l_hTIFF, TIFFTAG_TRANSFERFUNCTION,\n                    pTransferFuncRed, pTransferFuncGreen, pTransferFuncBlue);\n\n                CPLFree(pTransferFuncRed);\n                CPLFree(pTransferFuncGreen);\n                CPLFree(pTransferFuncBlue);\n            }\n\n            CSLDestroy( papszTokensRed );\n            CSLDestroy( papszTokensGreen );\n            CSLDestroy( papszTokensBlue );\n        }\n\n        // Output transfer range.\n        bool bOutputTransferRange = true;\n        for( int i = 0; (i < 2) && bOutputTransferRange; ++i )\n        {\n            if( pDS != nullptr )\n                pszValue = pDS->GetMetadataItem( pszTXRNames[i],\n                                                 \"COLOR_PROFILE\" );\n            else\n                pszValue = CSLFetchNameValue(papszParmList, pszTXRNames[i]);\n            if( pszValue == nullptr )\n            {\n                bOutputTransferRange = false;\n                break;\n            }\n\n            char** papszTokens =\n                CSLTokenizeString2(\n                    pszValue, \",\",\n                    CSLT_ALLOWEMPTYTOKENS | CSLT_STRIPLEADSPACES |\n                    CSLT_STRIPENDSPACES );\n\n            if( CSLCount( papszTokens ) != 3 )\n            {\n                bOutputTransferRange = false;\n                CSLDestroy( papszTokens );\n                break;\n            }\n\n            for( int j = 0; j < 3; ++j )\n            {\n                pTXR[i + j * 2] = static_cast<uint16>(atoi(papszTokens[j]));\n            }\n\n            CSLDestroy( papszTokens );\n        }\n\n        if( bOutputTransferRange )\n        {\n            const int TIFFTAG_TRANSFERRANGE = 0x0156;\n            TIFFSetField(l_hTIFF, TIFFTAG_TRANSFERRANGE, pTXR);\n        }\n    }\n}\n\n/************************************************************************/\n/*                             OpenOffset()                             */\n/*                                                                      */\n/*      Initialize the GTiffDataset based on a passed in file           */\n/*      handle, and directory offset to utilize.  This is called for    */\n/*      full res, and overview pages.                                   */\n/************************************************************************/\n\nCPLErr GTiffDataset::OpenOffset( TIFF *hTIFFIn,\n                                 GTiffDataset **ppoActiveDSRefIn,\n                                 toff_t nDirOffsetIn,\n                                 bool bBaseIn, GDALAccess eAccessIn,\n                                 bool bAllowRGBAInterface,\n                                 bool bReadGeoTransform )\n\n{\n    eAccess = eAccessIn;\n\n    hTIFF = hTIFFIn;\n    ppoActiveDSRef = ppoActiveDSRefIn;\n\n    nDirOffset = nDirOffsetIn;\n\n    if( !SetDirectory( nDirOffsetIn ) )\n        return CE_Failure;\n\n    bBase = bBaseIn;\n\n/* -------------------------------------------------------------------- */\n/*      Capture some information from the file that is of interest.     */\n/* -------------------------------------------------------------------- */\n    uint32 nXSize = 0;\n    uint32 nYSize = 0;\n    TIFFGetField( hTIFF, TIFFTAG_IMAGEWIDTH, &nXSize );\n    TIFFGetField( hTIFF, TIFFTAG_IMAGELENGTH, &nYSize );\n    if( nXSize > INT_MAX || nYSize > INT_MAX )\n    {\n        // GDAL only supports signed 32bit dimensions.\n        CPLError(CE_Failure, CPLE_NotSupported,\n                 \"Too large image size: %u x %u\",\n                 nXSize, nYSize);\n        return CE_Failure;\n    }\n    nRasterXSize = nXSize;\n    nRasterYSize = nYSize;\n\n    if( !TIFFGetField(hTIFF, TIFFTAG_SAMPLESPERPIXEL, &nSamplesPerPixel ) )\n        nBands = 1;\n    else\n        nBands = nSamplesPerPixel;\n\n    if( !TIFFGetField(hTIFF, TIFFTAG_BITSPERSAMPLE, &(nBitsPerSample)) )\n        nBitsPerSample = 1;\n\n    if( !TIFFGetField( hTIFF, TIFFTAG_PLANARCONFIG, &(nPlanarConfig) ) )\n        nPlanarConfig = PLANARCONFIG_CONTIG;\n\n    if( !TIFFGetField( hTIFF, TIFFTAG_PHOTOMETRIC, &(nPhotometric) ) )\n        nPhotometric = PHOTOMETRIC_MINISBLACK;\n\n    if( !TIFFGetField( hTIFF, TIFFTAG_SAMPLEFORMAT, &(nSampleFormat) ) )\n        nSampleFormat = SAMPLEFORMAT_UINT;\n\n    if( !TIFFGetField( hTIFF, TIFFTAG_COMPRESSION, &(nCompression) ) )\n        nCompression = COMPRESSION_NONE;\n\n#if defined(TIFFLIB_VERSION) && TIFFLIB_VERSION > 20031007 // 3.6.0\n    if( nCompression != COMPRESSION_NONE &&\n        !TIFFIsCODECConfigured(nCompression) )\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                  \"Cannot open TIFF file due to missing codec.\" );\n        return CE_Failure;\n    }\n#endif\n\n/* -------------------------------------------------------------------- */\n/*      YCbCr JPEG compressed images should be translated on the fly    */\n/*      to RGB by libtiff/libjpeg unless specifically requested         */\n/*      otherwise.                                                      */\n/* -------------------------------------------------------------------- */\n    if( nCompression == COMPRESSION_JPEG\n        && nPhotometric == PHOTOMETRIC_YCBCR\n        && CPLTestBool( CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\", \"YES\") ) )\n    {\n        oGTiffMDMD.SetMetadataItem( \"SOURCE_COLOR_SPACE\", \"YCbCr\",\n                                    \"IMAGE_STRUCTURE\" );\n        int nColorMode = 0;\n        if( !TIFFGetField( hTIFF, TIFFTAG_JPEGCOLORMODE, &nColorMode ) ||\n            nColorMode != JPEGCOLORMODE_RGB )\n            TIFFSetField(hTIFF, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Get strip/tile layout.                                          */\n/* -------------------------------------------------------------------- */\n    if( TIFFIsTiled(hTIFF) )\n    {\n        uint32 l_nBlockXSize = 0;\n        uint32 l_nBlockYSize = 0;\n        TIFFGetField( hTIFF, TIFFTAG_TILEWIDTH, &(l_nBlockXSize) );\n        TIFFGetField( hTIFF, TIFFTAG_TILELENGTH, &(l_nBlockYSize) );\n        if( l_nBlockXSize > INT_MAX || l_nBlockYSize > INT_MAX )\n        {\n            CPLError(CE_Failure, CPLE_NotSupported,\n                     \"Too large block size: %u x %u\",\n                     l_nBlockXSize, l_nBlockYSize);\n            return CE_Failure;\n        }\n        nBlockXSize = static_cast<int>(l_nBlockXSize);\n        nBlockYSize = static_cast<int>(l_nBlockYSize);\n    }\n    else\n    {\n        if( !TIFFGetField( hTIFF, TIFFTAG_ROWSPERSTRIP,\n                           &(nRowsPerStrip) ) )\n        {\n            CPLError( CE_Warning, CPLE_AppDefined,\n                      \"RowsPerStrip not defined ... assuming all one strip.\" );\n            nRowsPerStrip = nYSize;  // Dummy value.\n        }\n\n        // If the rows per strip is larger than the file we will get\n        // confused.  libtiff internally will treat the rowsperstrip as\n        // the image height and it is best if we do too. (#4468)\n        if( nRowsPerStrip > static_cast<uint32>(nRasterYSize) )\n            nRowsPerStrip = nRasterYSize;\n\n        nBlockXSize = nRasterXSize;\n        nBlockYSize = nRowsPerStrip;\n    }\n\n    const int l_nBlocksPerColumn = DIV_ROUND_UP(nRasterYSize, nBlockYSize);\n    const int l_nBlocksPerRow = DIV_ROUND_UP(nRasterXSize, nBlockXSize);\n    if( l_nBlocksPerColumn > INT_MAX / l_nBlocksPerRow )\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                  \"Too many blocks: %d x %d\",\n                  l_nBlocksPerRow, l_nBlocksPerColumn );\n        return CE_Failure;\n    }\n\n    // Note: we could potentially go up to UINT_MAX blocks, but currently\n    // we use a int nBlockId\n    nBlocksPerBand = l_nBlocksPerColumn * l_nBlocksPerRow;\n    if( nPlanarConfig == PLANARCONFIG_SEPARATE &&\n        nBlocksPerBand > INT_MAX / nBands )\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                  \"Too many blocks: %d x %d x %d bands\",\n                  l_nBlocksPerRow, l_nBlocksPerColumn, nBands );\n        return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Should we handle this using the GTiffBitmapBand?                */\n/* -------------------------------------------------------------------- */\n    bool bTreatAsBitmap = false;\n\n    if( nBitsPerSample == 1 && nBands == 1 )\n    {\n        bTreatAsBitmap = true;\n\n        // Lets treat large \"one row\" bitmaps using the scanline api.\n        if( !TIFFIsTiled(hTIFF)\n            && nBlockYSize == nRasterYSize\n            && nRasterYSize > 2000\n            // libtiff does not support reading JBIG files with\n            // TIFFReadScanline().\n            && nCompression != COMPRESSION_JBIG )\n        {\n            bTreatAsSplitBitmap = true;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Should we treat this via the RGBA interface?                    */\n/* -------------------------------------------------------------------- */\n    if(\n#ifdef DEBUG\n        CPLTestBool(CPLGetConfigOption(\"GTIFF_FORCE_RGBA\", \"NO\")) ||\n#endif\n        (bAllowRGBAInterface &&\n        !bTreatAsBitmap && !(nBitsPerSample > 8)\n        && (nPhotometric == PHOTOMETRIC_CIELAB ||\n            nPhotometric == PHOTOMETRIC_LOGL ||\n            nPhotometric == PHOTOMETRIC_LOGLUV ||\n            nPhotometric == PHOTOMETRIC_SEPARATED ||\n            ( nPhotometric == PHOTOMETRIC_YCBCR\n              && nCompression != COMPRESSION_JPEG ))) )\n    {\n        char szMessage[1024] = {};\n\n        if( TIFFRGBAImageOK( hTIFF, szMessage ) == 1 )\n        {\n            const char* pszSourceColorSpace = nullptr;\n            nBands = 4;\n            switch( nPhotometric )\n            {\n                case PHOTOMETRIC_CIELAB:\n                    pszSourceColorSpace = \"CIELAB\";\n                    break;\n                case PHOTOMETRIC_LOGL:\n                    pszSourceColorSpace = \"LOGL\";\n                    break;\n                case PHOTOMETRIC_LOGLUV:\n                    pszSourceColorSpace = \"LOGLUV\";\n                    break;\n                case PHOTOMETRIC_SEPARATED:\n                    pszSourceColorSpace = \"CMYK\";\n                    break;\n                case PHOTOMETRIC_YCBCR:\n                    pszSourceColorSpace = \"YCbCr\";\n                    nBands = 3; // probably true for other photometric values\n                    break;\n            }\n            if( pszSourceColorSpace )\n                oGTiffMDMD.SetMetadataItem( \"SOURCE_COLOR_SPACE\",\n                                            pszSourceColorSpace,\n                                            \"IMAGE_STRUCTURE\" );\n            bTreatAsRGBA = true;\n\n        }\n        else\n        {\n            CPLDebug( \"GTiff\", \"TIFFRGBAImageOK says:\\n%s\", szMessage );\n        }\n    }\n\n    // libtiff has various issues with OJPEG compression and chunky-strip\n    // support with the \"classic\" scanline/strip/tile interfaces, and that\n    // wouldn't work either, so better bail out.\n    if( nCompression == COMPRESSION_OJPEG &&\n        !bTreatAsRGBA )\n    {\n        CPLError(CE_Failure, CPLE_NotSupported,\n                 \"Old-JPEG compression only supported through RGBA interface, \"\n                 \"which cannot be used probably because the file is corrupted\");\n        return CE_Failure;\n    }\n\n    // If photometric is YCbCr, scanline/strip/tile interfaces assumes that\n    // we are ready with downsampled data. And we are not.\n    if( nCompression != COMPRESSION_JPEG &&\n        nCompression != COMPRESSION_OJPEG &&\n        nPhotometric == PHOTOMETRIC_YCBCR &&\n        nPlanarConfig == PLANARCONFIG_CONTIG &&\n        !bTreatAsRGBA )\n    {\n        uint16 nF1, nF2;\n        TIFFGetFieldDefaulted(hTIFF,TIFFTAG_YCBCRSUBSAMPLING,&nF1,&nF2);\n        if( nF1 != 1 || nF2 != 1 )\n        {\n            CPLError( CE_Failure, CPLE_AppDefined,\n                      \"Cannot open TIFF file with YCbCr, subsampling and \"\n                      \"BitsPerSample > 8 that is not JPEG compressed\" );\n            return CE_Failure;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Should we treat this via the split interface?                   */\n/* -------------------------------------------------------------------- */\n    if( !TIFFIsTiled(hTIFF)\n        && nBitsPerSample == 8\n        && nBlockYSize == nRasterYSize\n        && nRasterYSize > 2000\n        && !bTreatAsRGBA\n        && CPLTestBool(CPLGetConfigOption(\"GDAL_ENABLE_TIFF_SPLIT\", \"YES\")) )\n    {\n        // libtiff 3.9.2 (20091104) and older, libtiff 4.0.0beta5 (also\n        // 20091104) and older will crash when trying to open a\n        // all-in-one-strip YCbCr JPEG compressed TIFF (see #3259).\n#if (TIFFLIB_VERSION <= 20091104 && !defined(BIGTIFF_SUPPORT)) || \\\n    (TIFFLIB_VERSION <= 20091104 && defined(BIGTIFF_SUPPORT))\n        if( nPhotometric == PHOTOMETRIC_YCBCR &&\n            nCompression == COMPRESSION_JPEG )\n        {\n            CPLDebug(\n                \"GTiff\",\n                \"Avoid using split band to open all-in-one-strip \"\n                \"YCbCr JPEG compressed TIFF because of older libtiff\" );\n        }\n        else\n#endif\n        {\n            bTreatAsSplit = true;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Should we treat this via the odd bits interface?                */\n/* -------------------------------------------------------------------- */\n    bool bTreatAsOdd = false;\n    if( nSampleFormat == SAMPLEFORMAT_IEEEFP )\n    {\n        if( nBitsPerSample == 16 || nBitsPerSample == 24 )\n            bTreatAsOdd = true;\n    }\n    else if( !bTreatAsRGBA && !bTreatAsBitmap\n             && nBitsPerSample != 8\n             && nBitsPerSample != 16\n             && nBitsPerSample != 32\n             && nBitsPerSample != 64\n             && nBitsPerSample != 128 )\n    {\n        bTreatAsOdd = true;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      We don't support 'chunks' bigger than 2GB although libtiff v4   */\n/*      can.                                                            */\n/* -------------------------------------------------------------------- */\n#if defined(BIGTIFF_SUPPORT)\n    uint64 nChunkSize = 0;\n    if( bTreatAsSplit || bTreatAsSplitBitmap )\n    {\n        nChunkSize = TIFFScanlineSize64( hTIFF );\n    }\n    else\n    {\n        if( TIFFIsTiled(hTIFF) )\n            nChunkSize = TIFFTileSize64( hTIFF );\n        else\n            nChunkSize = TIFFStripSize64( hTIFF );\n    }\n    if( bTreatAsRGBA )\n    {\n        nChunkSize = std::max(nChunkSize,\n                        4 * static_cast<uint64>(nBlockXSize) * nBlockYSize);\n    }\n    if( nChunkSize > static_cast<uint64>(INT_MAX) )\n    {\n        CPLError( CE_Failure, CPLE_NotSupported,\n                  \"Scanline/tile/strip size bigger than 2GB.\" );\n        return CE_Failure;\n    }\n#endif\n\n    const bool bMinIsWhite = nPhotometric == PHOTOMETRIC_MINISWHITE;\n\n/* -------------------------------------------------------------------- */\n/*      Check for NODATA                                                */\n/* -------------------------------------------------------------------- */\n    char *pszText = nullptr;\n    if( TIFFGetField( hTIFF, TIFFTAG_GDAL_NODATA, &pszText ) &&\n        !EQUAL(pszText, \"\") )\n    {\n        bNoDataSet = true;\n        dfNoDataValue = CPLAtofM( pszText );\n        if( nBitsPerSample == 32 && nSampleFormat == SAMPLEFORMAT_IEEEFP )\n        {\n            dfNoDataValue = GDALAdjustNoDataCloseToFloatMax(dfNoDataValue);\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Capture the color table if there is one.                        */\n/* -------------------------------------------------------------------- */\n    unsigned short *panRed = nullptr;\n    unsigned short *panGreen = nullptr;\n    unsigned short *panBlue = nullptr;\n\n    if( bTreatAsRGBA || nBitsPerSample > 16\n        || TIFFGetField( hTIFF, TIFFTAG_COLORMAP,\n                         &panRed, &panGreen, &panBlue) == 0 )\n    {\n        // Build inverted palette if we have inverted photometric.\n        // Pixel values remains unchanged.  Avoid doing this for *deep*\n        // data types (per #1882)\n        if( nBitsPerSample <= 16 && nPhotometric == PHOTOMETRIC_MINISWHITE )\n        {\n            poColorTable = new GDALColorTable();\n            const int nColorCount = 1 << nBitsPerSample;\n\n            for( int iColor = 0; iColor < nColorCount; ++iColor )\n            {\n                const short nValue =\n                    static_cast<short>(((255 * (nColorCount - 1 - iColor)) /\n                                        (nColorCount - 1)));\n                const GDALColorEntry oEntry =\n                    { nValue, nValue, nValue, static_cast<short>(255) };\n                poColorTable->SetColorEntry( iColor, &oEntry );\n            }\n\n            nPhotometric = PHOTOMETRIC_PALETTE;\n        }\n        else\n        {\n            poColorTable = nullptr;\n        }\n    }\n    else\n    {\n        unsigned short nMaxColor = 0;\n\n        poColorTable = new GDALColorTable();\n\n        const int nColorCount = 1 << nBitsPerSample;\n\n        for( int iColor = nColorCount - 1; iColor >= 0; iColor-- )\n        {\n            // TODO(schwehr): Ensure the color entries are never negative?\n            const unsigned short divisor = 257;\n            const GDALColorEntry oEntry = {\n                static_cast<short>(panRed[iColor] / divisor),\n                static_cast<short>(panGreen[iColor] / divisor),\n                static_cast<short>(panBlue[iColor] / divisor),\n                static_cast<short>(\n                    bNoDataSet && static_cast<int>(dfNoDataValue) == iColor\n                    ? 0\n                    : 255)\n            };\n\n            poColorTable->SetColorEntry( iColor, &oEntry );\n\n            nMaxColor = std::max(nMaxColor, panRed[iColor]);\n            nMaxColor = std::max(nMaxColor, panGreen[iColor]);\n            nMaxColor = std::max(nMaxColor, panBlue[iColor]);\n        }\n\n        // Bug 1384 - Some TIFF files are generated with color map entry\n        // values in range 0-255 instead of 0-65535 - try to handle these\n        // gracefully.\n        if( nMaxColor > 0 && nMaxColor < 256 )\n        {\n            CPLDebug(\n                \"GTiff\",\n                \"TIFF ColorTable seems to be improperly scaled, fixing up.\" );\n\n            for( int iColor = nColorCount - 1; iColor >= 0; iColor-- )\n            {\n                // TODO(schwehr): Ensure the color entries are never negative?\n                const GDALColorEntry oEntry = {\n                    static_cast<short>(panRed[iColor]),\n                    static_cast<short>(panGreen[iColor]),\n                    static_cast<short>(panBlue[iColor]),\n                    bNoDataSet &&\n                    static_cast<int>(dfNoDataValue) == iColor\n                    ? static_cast<short>(0)\n                    : static_cast<short>(255)\n                };\n\n                poColorTable->SetColorEntry( iColor, &oEntry );\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Create band information objects.                                */\n/* -------------------------------------------------------------------- */\n    for( int iBand = 0; iBand < nBands; ++iBand )\n    {\n        if( bTreatAsRGBA )\n            SetBand( iBand + 1, new GTiffRGBABand( this, iBand + 1 ) );\n        else if( bTreatAsSplitBitmap )\n            SetBand( iBand + 1, new GTiffSplitBitmapBand( this, iBand + 1 ) );\n        else if( bTreatAsSplit )\n            SetBand( iBand + 1, new GTiffSplitBand( this, iBand + 1 ) );\n        else if( bTreatAsBitmap )\n            SetBand( iBand + 1, new GTiffBitmapBand( this, iBand + 1 ) );\n        else if( bTreatAsOdd )\n            SetBand( iBand + 1, new GTiffOddBitsBand( this, iBand + 1 ) );\n        else\n            SetBand( iBand + 1, new GTiffRasterBand( this, iBand + 1 ) );\n    }\n\n    if( GetRasterBand(1)->GetRasterDataType() == GDT_Unknown )\n    {\n        CPLError(CE_Failure, CPLE_NotSupported,\n                 \"Unsupported TIFF configuration: BitsPerSample(=%d) and \"\n                 \"SampleType(=%d)\",\n                 nBitsPerSample,\n                 nSampleFormat);\n        return CE_Failure;\n    }\n\n    m_bReadGeoTransform = bReadGeoTransform;\n\n/* -------------------------------------------------------------------- */\n/*      Capture some other potentially interesting information.         */\n/* -------------------------------------------------------------------- */\n    char szWorkMDI[200] = {};\n    uint16 nShort = 0;\n\n    for( size_t iTag = 0;\n         iTag < sizeof(asTIFFTags) / sizeof(asTIFFTags[0]);\n         ++iTag )\n    {\n        if( asTIFFTags[iTag].eType == GTIFFTAGTYPE_STRING )\n        {\n            if( TIFFGetField( hTIFF, asTIFFTags[iTag].nTagVal, &pszText ) )\n                oGTiffMDMD.SetMetadataItem( asTIFFTags[iTag].pszTagName,\n                                            pszText );\n        }\n        else if( asTIFFTags[iTag].eType == GTIFFTAGTYPE_FLOAT )\n        {\n            float fVal = 0.0;\n            if( TIFFGetField( hTIFF, asTIFFTags[iTag].nTagVal, &fVal ) )\n            {\n                CPLsnprintf( szWorkMDI, sizeof(szWorkMDI), \"%.8g\", fVal );\n                oGTiffMDMD.SetMetadataItem( asTIFFTags[iTag].pszTagName,\n                                            szWorkMDI );\n            }\n        }\n        else if( asTIFFTags[iTag].eType == GTIFFTAGTYPE_SHORT &&\n                 asTIFFTags[iTag].nTagVal != TIFFTAG_RESOLUTIONUNIT )\n        {\n            if( TIFFGetField( hTIFF, asTIFFTags[iTag].nTagVal, &nShort ) )\n            {\n                snprintf( szWorkMDI, sizeof(szWorkMDI), \"%d\", nShort );\n                oGTiffMDMD.SetMetadataItem( asTIFFTags[iTag].pszTagName,\n                                            szWorkMDI );\n            }\n        }\n        else if( asTIFFTags[iTag].eType == GTIFFTAGTYPE_BYTE_STRING )\n        {\n            uint32 nCount = 0;\n            if( TIFFGetField( hTIFF, asTIFFTags[iTag].nTagVal,\n                              &nCount, &pszText ) )\n            {\n                std::string osStr;\n                osStr.assign(pszText, nCount);\n                oGTiffMDMD.SetMetadataItem( asTIFFTags[iTag].pszTagName,\n                                            osStr.c_str() );\n            }\n        }\n    }\n\n    if( TIFFGetField( hTIFF, TIFFTAG_RESOLUTIONUNIT, &nShort ) )\n    {\n        if( nShort == RESUNIT_NONE )\n            snprintf( szWorkMDI, sizeof(szWorkMDI), \"%d (unitless)\", nShort );\n        else if( nShort == RESUNIT_INCH )\n            snprintf( szWorkMDI, sizeof(szWorkMDI),\n                      \"%d (pixels/inch)\", nShort );\n        else if( nShort == RESUNIT_CENTIMETER )\n            snprintf( szWorkMDI, sizeof(szWorkMDI), \"%d (pixels/cm)\", nShort );\n        else\n            snprintf( szWorkMDI, sizeof(szWorkMDI), \"%d\", nShort );\n        oGTiffMDMD.SetMetadataItem( \"TIFFTAG_RESOLUTIONUNIT\", szWorkMDI );\n    }\n\n    int nTagSize = 0;\n    void* pData = nullptr;\n    if( TIFFGetField( hTIFF, TIFFTAG_XMLPACKET, &nTagSize, &pData ) )\n    {\n        char* pszXMP =\n            static_cast<char *>( VSI_MALLOC_VERBOSE(nTagSize + 1) );\n        if( pszXMP )\n        {\n            memcpy(pszXMP, pData, nTagSize);\n            pszXMP[nTagSize] = '\\0';\n\n            char *apszMDList[2] = { pszXMP, nullptr };\n            oGTiffMDMD.SetMetadata(apszMDList, \"xml:XMP\");\n\n            CPLFree(pszXMP);\n        }\n    }\n\n    if( nCompression == COMPRESSION_NONE )\n        /* no compression tag */;\n    else if( nCompression == COMPRESSION_CCITTRLE )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"CCITTRLE\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_CCITTFAX3 )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"CCITTFAX3\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_CCITTFAX4 )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"CCITTFAX4\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_LZW )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"LZW\", \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_OJPEG )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"OJPEG\", \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_JPEG )\n    {\n        if( nPhotometric == PHOTOMETRIC_YCBCR )\n            oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"YCbCr JPEG\",\n                                        \"IMAGE_STRUCTURE\" );\n        else\n            oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"JPEG\",\n                                        \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_NEXT )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"NEXT\", \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_CCITTRLEW )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"CCITTRLEW\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_PACKBITS )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"PACKBITS\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_THUNDERSCAN )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"THUNDERSCAN\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_PIXARFILM )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"PIXARFILM\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_PIXARLOG )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"PIXARLOG\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_DEFLATE )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"DEFLATE\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_ADOBE_DEFLATE )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"DEFLATE\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_DCS )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"DCS\", \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_JBIG )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"JBIG\", \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_SGILOG )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"SGILOG\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_SGILOG24 )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"SGILOG24\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_JP2000 )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"JP2000\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_LZMA )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"LZMA\", \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_ZSTD )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"ZSTD\", \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_LERC )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"LERC\", \"IMAGE_STRUCTURE\" );\n#if HAVE_LERC\n        uint32 nLercParamCount = 0;\n        uint32* panLercParms = nullptr;\n        if( TIFFGetField( hTIFF, TIFFTAG_LERC_PARAMETERS, &nLercParamCount,\n                          &panLercParms ) &&\n            nLercParamCount == 2 )\n        {\n            memcpy( anLercAddCompressionAndVersion, panLercParms,\n                    sizeof(anLercAddCompressionAndVersion) );\n        }\n\n        uint32 nAddVersion = LERC_ADD_COMPRESSION_NONE;\n        if( TIFFGetField( hTIFF, TIFFTAG_LERC_ADD_COMPRESSION, &nAddVersion ) &&\n            nAddVersion != LERC_ADD_COMPRESSION_NONE )\n        {\n            if( nAddVersion == LERC_ADD_COMPRESSION_DEFLATE )\n            {\n                oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"LERC_DEFLATE\",\n                                            \"IMAGE_STRUCTURE\" );\n            }\n            else if( nAddVersion == LERC_ADD_COMPRESSION_ZSTD )\n            {\n                oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"LERC_ZSTD\",\n                                            \"IMAGE_STRUCTURE\" );\n            }\n        }\n        uint32 nLercVersion = LERC_VERSION_2_4;\n        if( TIFFGetField( hTIFF, TIFFTAG_LERC_VERSION, &nLercVersion) )\n        {\n            if( nLercVersion == LERC_VERSION_2_4 )\n            {\n                oGTiffMDMD.SetMetadataItem( \"LERC_VERSION\", \"2.4\",\n                                            \"IMAGE_STRUCTURE\" );\n            }\n            else\n            {\n                CPLError(CE_Warning, CPLE_AppDefined,\n                         \"Unknown Lerc version: %d\", nLercVersion);\n            }\n        }\n#endif\n    }\n    else if( nCompression == COMPRESSION_WEBP )\n    {\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"WEBP\", \"IMAGE_STRUCTURE\" );\n    }\n    else\n    {\n        CPLString oComp;\n        oComp.Printf( \"%d\", nCompression);\n        oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", oComp.c_str());\n    }\n\n    if( nPlanarConfig == PLANARCONFIG_CONTIG && nBands != 1 )\n        oGTiffMDMD.SetMetadataItem( \"INTERLEAVE\", \"PIXEL\", \"IMAGE_STRUCTURE\" );\n    else\n        oGTiffMDMD.SetMetadataItem( \"INTERLEAVE\", \"BAND\", \"IMAGE_STRUCTURE\" );\n\n    if( (GetRasterBand(1)->GetRasterDataType() == GDT_Byte &&\n         nBitsPerSample != 8 ) ||\n        (GetRasterBand(1)->GetRasterDataType() == GDT_UInt16 &&\n         nBitsPerSample != 16) ||\n        ((GetRasterBand(1)->GetRasterDataType() == GDT_UInt32 ||\n          GetRasterBand(1)->GetRasterDataType() == GDT_Float32) &&\n         nBitsPerSample != 32) )\n    {\n        for( int i = 0; i < nBands; ++i )\n            cpl::down_cast<GTiffRasterBand*>(GetRasterBand(i + 1))->\n                oGTiffMDMD.SetMetadataItem(\n                    \"NBITS\",\n                    CPLString().Printf(\n                        \"%d\", static_cast<int>(nBitsPerSample) ),\n                    \"IMAGE_STRUCTURE\" );\n    }\n\n    if( bMinIsWhite )\n        oGTiffMDMD.SetMetadataItem( \"MINISWHITE\", \"YES\", \"IMAGE_STRUCTURE\" );\n\n    if( TIFFGetField( hTIFF, TIFFTAG_GDAL_METADATA, &pszText ) )\n    {\n        CPLXMLNode *psRoot = CPLParseXMLString( pszText );\n        CPLXMLNode *psItem = nullptr;\n\n        if( psRoot != nullptr && psRoot->eType == CXT_Element\n            && EQUAL(psRoot->pszValue,\"GDALMetadata\") )\n            psItem = psRoot->psChild;\n\n        for( ; psItem != nullptr; psItem = psItem->psNext )\n        {\n\n            if( psItem->eType != CXT_Element\n                || !EQUAL(psItem->pszValue,\"Item\") )\n                continue;\n\n            const char *pszKey = CPLGetXMLValue( psItem, \"name\", nullptr );\n            const char *pszValue = CPLGetXMLValue( psItem, nullptr, nullptr );\n            int nBand =\n                atoi(CPLGetXMLValue( psItem, \"sample\", \"-1\" ));\n            if( nBand < -1 || nBand > 65535 )\n                continue;\n            nBand ++;\n            const char *pszRole = CPLGetXMLValue( psItem, \"role\", \"\" );\n            const char *pszDomain = CPLGetXMLValue( psItem, \"domain\", \"\" );\n\n            if( pszKey == nullptr || pszValue == nullptr )\n                continue;\n            if( EQUAL(pszDomain, \"IMAGE_STRUCTURE\") )\n                continue;\n\n            bool bIsXML = false;\n\n            if( STARTS_WITH_CI(pszDomain, \"xml:\") )\n                bIsXML = TRUE;\n\n            char *pszUnescapedValue =\n                CPLUnescapeString( pszValue, nullptr, CPLES_XML );\n            if( nBand == 0 )\n            {\n                if( bIsXML )\n                {\n                    char *apszMD[2] = { pszUnescapedValue, nullptr };\n                    oGTiffMDMD.SetMetadata( apszMD, pszDomain );\n                }\n                else\n                {\n                    oGTiffMDMD.SetMetadataItem( pszKey, pszUnescapedValue,\n                                                pszDomain );\n                }\n            }\n            else\n            {\n                GTiffRasterBand *poBand =\n                    cpl::down_cast<GTiffRasterBand*>(GetRasterBand(nBand));\n                if( poBand != nullptr )\n                {\n                    if( EQUAL(pszRole,\"scale\") )\n                    {\n                        poBand->bHaveOffsetScale = true;\n                        poBand->dfScale = CPLAtofM(pszUnescapedValue);\n                    }\n                    else if( EQUAL(pszRole,\"offset\") )\n                    {\n                        poBand->bHaveOffsetScale = true;\n                        poBand->dfOffset = CPLAtofM(pszUnescapedValue);\n                    }\n                    else if( EQUAL(pszRole,\"unittype\") )\n                    {\n                        poBand->osUnitType = pszUnescapedValue;\n                    }\n                    else if( EQUAL(pszRole,\"description\") )\n                    {\n                        poBand->osDescription = pszUnescapedValue;\n                    }\n                    else if( EQUAL(pszRole, \"colorinterp\") )\n                    {\n                        poBand->eBandInterp =\n                            GDALGetColorInterpretationByName(pszUnescapedValue);\n                    }\n                    else\n                    {\n                        if( bIsXML )\n                        {\n                            char *apszMD[2] = { pszUnescapedValue, nullptr };\n                            poBand->oGTiffMDMD.SetMetadata( apszMD, pszDomain );\n                        }\n                        else\n                        {\n                            poBand->oGTiffMDMD.SetMetadataItem(\n                                pszKey,\n                                pszUnescapedValue,\n                                pszDomain );\n                        }\n                    }\n                }\n            }\n            CPLFree( pszUnescapedValue );\n        }\n\n        CPLDestroyXMLNode( psRoot );\n    }\n\n    if( bStreamingIn )\n    {\n        toff_t* panOffsets = nullptr;\n        TIFFGetField( hTIFF,\n                      TIFFIsTiled( hTIFF ) ?\n                      TIFFTAG_TILEOFFSETS : TIFFTAG_STRIPOFFSETS,\n                      &panOffsets );\n        if( panOffsets )\n        {\n            int nBlockCount =\n                TIFFIsTiled(hTIFF) ?\n                TIFFNumberOfTiles(hTIFF) : TIFFNumberOfStrips(hTIFF);\n            for( int i = 1; i < nBlockCount; ++i )\n            {\n                if( panOffsets[i] < panOffsets[i-1] )\n                {\n                    oGTiffMDMD.SetMetadataItem( \"UNORDERED_BLOCKS\", \"YES\",\n                                                \"TIFF\");\n                    CPLDebug(\n                        \"GTIFF\",\n                        \"Offset of block %d is lower than previous block. \"\n                        \"Reader must be careful\",\n                        i );\n                    break;\n                }\n            }\n        }\n    }\n\n    if( nCompression == COMPRESSION_JPEG && eAccess == GA_Update )\n    {\n        SetJPEGQualityAndTablesModeFromFile();\n    }\n\n    CPLAssert(m_bReadGeoTransform == bReadGeoTransform);\n    CPLAssert(!bMetadataChanged);\n    bMetadataChanged = false;\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                         GetSiblingFiles()                            */\n/************************************************************************/\n\nchar** GTiffDataset::GetSiblingFiles()\n{\n    if( m_bHasGotSiblingFiles )\n    {\n        return oOvManager.GetSiblingFiles();\n    }\n\n    m_bHasGotSiblingFiles = true;\n    const int nMaxFiles =\n        atoi(CPLGetConfigOption(\"GDAL_READDIR_LIMIT_ON_OPEN\", \"1000\"));\n    char** papszSiblingFiles =\n        VSIReadDirEx(CPLGetDirname(osFilename), nMaxFiles);\n    if( nMaxFiles > 0 && CSLCount(papszSiblingFiles) > nMaxFiles )\n    {\n        CPLDebug(\"GTiff\", \"GDAL_READDIR_LIMIT_ON_OPEN reached on %s\",\n                 CPLGetDirname(osFilename));\n        CSLDestroy(papszSiblingFiles);\n        papszSiblingFiles = nullptr;\n    }\n    oOvManager.TransferSiblingFiles( papszSiblingFiles );\n\n    return papszSiblingFiles;\n}\n\n/************************************************************************/\n/*                   IdentifyAuthorizedGeoreferencingSources()          */\n/************************************************************************/\n\nvoid GTiffDataset::IdentifyAuthorizedGeoreferencingSources()\n{\n    if( m_bHasIdentifiedAuthorizedGeoreferencingSources )\n        return;\n    m_bHasIdentifiedAuthorizedGeoreferencingSources = true;\n    CPLString osGeorefSources = CSLFetchNameValueDef( papszOpenOptions,\n        \"GEOREF_SOURCES\",\n        CPLGetConfigOption(\"GDAL_GEOREF_SOURCES\",\n                           \"PAM,INTERNAL,TABFILE,WORLDFILE\") );\n    char** papszTokens = CSLTokenizeString2(osGeorefSources, \",\", 0);\n    m_nPAMGeorefSrcIndex = CSLFindString(papszTokens, \"PAM\");\n    m_nINTERNALGeorefSrcIndex = CSLFindString(papszTokens, \"INTERNAL\");\n    m_nTABFILEGeorefSrcIndex = CSLFindString(papszTokens, \"TABFILE\");\n    m_nWORLDFILEGeorefSrcIndex = CSLFindString(papszTokens, \"WORLDFILE\");\n    CSLDestroy(papszTokens);\n}\n\n/************************************************************************/\n/*                     LoadGeoreferencingAndPamIfNeeded()               */\n/************************************************************************/\n\nvoid GTiffDataset::LoadGeoreferencingAndPamIfNeeded()\n\n{\n    if( !m_bReadGeoTransform && !m_bLoadPam )\n        return;\n\n    IdentifyAuthorizedGeoreferencingSources();\n\n/* -------------------------------------------------------------------- */\n/*      Get the transform or gcps from the GeoTIFF file.                */\n/* -------------------------------------------------------------------- */\n    if( m_bReadGeoTransform )\n    {\n        m_bReadGeoTransform = false;\n\n        if( !SetDirectory() )\n            return;\n\n        char *pszTabWKT = nullptr;\n        double *padfTiePoints = nullptr;\n        double *padfScale = nullptr;\n        double *padfMatrix = nullptr;\n        uint16 nCount = 0;\n        bool bPixelIsPoint = false;\n        short nRasterType = 0;\n        bool bPointGeoIgnore = false;\n\n        std::set<int> aoSetPriorities;\n        if( m_nINTERNALGeorefSrcIndex >= 0 )\n            aoSetPriorities.insert(m_nINTERNALGeorefSrcIndex);\n        if( m_nTABFILEGeorefSrcIndex >= 0 )\n            aoSetPriorities.insert(m_nTABFILEGeorefSrcIndex);\n        if( m_nWORLDFILEGeorefSrcIndex >= 0 )\n            aoSetPriorities.insert(m_nWORLDFILEGeorefSrcIndex);\n        std::set<int>::iterator oIter = aoSetPriorities.begin();\n        for( ; oIter != aoSetPriorities.end(); ++oIter )\n        {\n            int nIndex = *oIter;\n            if( m_nINTERNALGeorefSrcIndex == nIndex )\n            {\n                GTIF *psGTIF = GTiffDatasetGTIFNew( hTIFF );  // How expensive this is?\n\n                if( psGTIF )\n                {\n                    if( GDALGTIFKeyGetSHORT(psGTIF, GTRasterTypeGeoKey,\n                                            &nRasterType, 0, 1 ) == 1\n                        && nRasterType ==\n                           static_cast<short>(RasterPixelIsPoint) )\n                    {\n                        bPixelIsPoint = true;\n                        bPointGeoIgnore =\n                            CPLTestBool(\n                                CPLGetConfigOption(\"GTIFF_POINT_GEO_IGNORE\",\n                                                   \"FALSE\") );\n                    }\n\n                    GTIFFree( psGTIF );\n                }\n\n                adfGeoTransform[0] = 0.0;\n                adfGeoTransform[1] = 1.0;\n                adfGeoTransform[2] = 0.0;\n                adfGeoTransform[3] = 0.0;\n                adfGeoTransform[4] = 0.0;\n                adfGeoTransform[5] = 1.0;\n\n                uint16 nCountScale = 0;\n                if( TIFFGetField(hTIFF, TIFFTAG_GEOPIXELSCALE,\n                                 &nCountScale, &padfScale )\n                    && nCountScale >= 2\n                    && padfScale[0] != 0.0 && padfScale[1] != 0.0 )\n                {\n                    adfGeoTransform[1] = padfScale[0];\n                    if( padfScale[1] < 0 )\n                    {\n                        const char* pszOptionVal =\n                            CPLGetConfigOption(\"GTIFF_HONOUR_NEGATIVE_SCALEY\",\n                                               nullptr);\n                        if( pszOptionVal == nullptr )\n                        {\n                            CPLError(CE_Warning, CPLE_AppDefined,\n                                \"File with negative value for ScaleY in \"\n                                \"GeoPixelScale tag. This is rather \"\n                                \"unusual. GDAL, contrary to the GeoTIFF \"\n                                \"specification, assumes that the file \"\n                                \"was intended to be north-up, and will \"\n                                \"treat this file as if ScaleY was \"\n                                \"positive. You may override this behaviour \"\n                                \"by setting the GTIFF_HONOUR_NEGATIVE_SCALEY \"\n                                \"configuration option to YES\");\n                            adfGeoTransform[5] = padfScale[1];\n                        }\n                        else if( CPLTestBool(pszOptionVal) )\n                        {\n                            adfGeoTransform[5] = -padfScale[1];\n                        }\n                        else\n                        {\n                            adfGeoTransform[5] = padfScale[1];\n                        }\n                    }\n                    else\n                    {\n                        adfGeoTransform[5] = -padfScale[1];\n                    }\n\n                    if( TIFFGetField(hTIFF, TIFFTAG_GEOTIEPOINTS,\n                                     &nCount, &padfTiePoints )\n                        && nCount >= 6 )\n                    {\n                        adfGeoTransform[0] =\n                            padfTiePoints[3] -\n                            padfTiePoints[0] * adfGeoTransform[1];\n                        adfGeoTransform[3] =\n                            padfTiePoints[4] -\n                            padfTiePoints[1] * adfGeoTransform[5];\n\n                        if( bPixelIsPoint && !bPointGeoIgnore )\n                        {\n                            adfGeoTransform[0] -=\n                                (adfGeoTransform[1] * 0.5 +\n                                 adfGeoTransform[2] * 0.5);\n                            adfGeoTransform[3] -=\n                                (adfGeoTransform[4] * 0.5 +\n                                 adfGeoTransform[5] * 0.5);\n                        }\n\n                        bGeoTransformValid = true;\n                        m_nGeoTransformGeorefSrcIndex = nIndex;\n\n                        if( nCountScale >= 3 && GetRasterCount() == 1 &&\n                            (padfScale[2] != 0.0 ||\n                             padfTiePoints[2] != 0.0 ||\n                             padfTiePoints[5] != 0.0) )\n                        {\n                            LookForProjection();\n                            if( pszProjection && HasVerticalCS(pszProjection) )\n                            {\n                                /* modelTiePointTag = (pixel, line, z0, X, Y, Z0) */\n                                /* thus Z(some_point) = (z(some_point) - z0) * scaleZ + Z0 */\n                                /* equivalently written as */\n                                /* Z(some_point) = z(some_point) * scaleZ + offsetZ with */\n                                /* offsetZ = - z0 * scaleZ + Z0 */\n                                double dfScale = padfScale[2];\n                                double dfOffset =\n                                    -padfTiePoints[2] * dfScale + padfTiePoints[5];\n                                GTiffRasterBand* poBand =\n                                    cpl::down_cast<GTiffRasterBand*>(GetRasterBand(1));\n                                poBand->bHaveOffsetScale = true;\n                                poBand->dfScale = dfScale;\n                                poBand->dfOffset = dfOffset;\n                            }\n                        }\n                    }\n                }\n\n                else if( TIFFGetField(hTIFF, TIFFTAG_GEOTRANSMATRIX,\n                                      &nCount, &padfMatrix )\n                        && nCount == 16 )\n                {\n                    adfGeoTransform[0] = padfMatrix[3];\n                    adfGeoTransform[1] = padfMatrix[0];\n                    adfGeoTransform[2] = padfMatrix[1];\n                    adfGeoTransform[3] = padfMatrix[7];\n                    adfGeoTransform[4] = padfMatrix[4];\n                    adfGeoTransform[5] = padfMatrix[5];\n\n                    if( bPixelIsPoint && !bPointGeoIgnore )\n                    {\n                        adfGeoTransform[0] -=\n                            adfGeoTransform[1] * 0.5 + adfGeoTransform[2] * 0.5;\n                        adfGeoTransform[3] -=\n                            adfGeoTransform[4] * 0.5 + adfGeoTransform[5] * 0.5;\n                    }\n\n                    bGeoTransformValid = true;\n                    m_nGeoTransformGeorefSrcIndex = nIndex;\n                }\n                if( bGeoTransformValid )\n                    break;\n            }\n\n/* -------------------------------------------------------------------- */\n/*      Otherwise try looking for a .tab, .tfw, .tifw or .wld file.     */\n/* -------------------------------------------------------------------- */\n            if( m_nTABFILEGeorefSrcIndex == nIndex )\n            {\n                char* pszGeorefFilename = nullptr;\n\n                char** papszSiblingFiles = GetSiblingFiles();\n\n                // Begin with .tab since it can also have projection info.\n                const int bTabFileOK =\n                    GDALReadTabFile2( osFilename, adfGeoTransform,\n                                        &pszTabWKT, &nGCPCount, &pasGCPList,\n                                        papszSiblingFiles, &pszGeorefFilename );\n\n                if( bTabFileOK )\n                {\n                    m_nGeoTransformGeorefSrcIndex = nIndex;\n                    // if( pszTabWKT )\n                    // {\n                    //     m_nProjectionGeorefSrcIndex = nIndex;\n                    // }\n                    if( nGCPCount == 0 )\n                    {\n                        bGeoTransformValid = true;\n                    }\n                }\n\n                if( pszGeorefFilename )\n                {\n                    osGeorefFilename = pszGeorefFilename;\n                    CPLFree(pszGeorefFilename);\n                }\n                if( bGeoTransformValid )\n                    break;\n            }\n\n            if( m_nWORLDFILEGeorefSrcIndex == nIndex )\n            {\n                char* pszGeorefFilename = nullptr;\n\n                char** papszSiblingFiles = GetSiblingFiles();\n\n                bGeoTransformValid = CPL_TO_BOOL( GDALReadWorldFile2(\n                                osFilename, nullptr, adfGeoTransform,\n                                papszSiblingFiles, &pszGeorefFilename) );\n\n                if( !bGeoTransformValid )\n                {\n                    bGeoTransformValid =\n                        CPL_TO_BOOL( GDALReadWorldFile2(\n                            osFilename, \"wld\", adfGeoTransform,\n                            papszSiblingFiles, &pszGeorefFilename ) );\n                }\n                if( bGeoTransformValid )\n                    m_nGeoTransformGeorefSrcIndex = nIndex;\n\n                if( pszGeorefFilename )\n                {\n                    osGeorefFilename = pszGeorefFilename;\n                    CPLFree(pszGeorefFilename);\n                }\n                if( bGeoTransformValid )\n                    break;\n            }\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Check for GCPs.                                                 */\n/* -------------------------------------------------------------------- */\n        if( m_nINTERNALGeorefSrcIndex >= 0 &&\n            TIFFGetField(hTIFF,TIFFTAG_GEOTIEPOINTS,&nCount,&padfTiePoints )\n            && !bGeoTransformValid )\n        {\n            if( nGCPCount > 0 )\n            {\n                GDALDeinitGCPs( nGCPCount, pasGCPList );\n                CPLFree( pasGCPList );\n            }\n            nGCPCount = nCount / 6;\n            pasGCPList =\n                static_cast<GDAL_GCP *>(CPLCalloc(sizeof(GDAL_GCP), nGCPCount));\n\n            for( int iGCP = 0; iGCP < nGCPCount; ++iGCP )\n            {\n                char szID[32] = {};\n\n                snprintf( szID, sizeof(szID), \"%d\", iGCP + 1 );\n                pasGCPList[iGCP].pszId = CPLStrdup( szID );\n                pasGCPList[iGCP].pszInfo = CPLStrdup(\"\");\n                pasGCPList[iGCP].dfGCPPixel = padfTiePoints[iGCP*6+0];\n                pasGCPList[iGCP].dfGCPLine = padfTiePoints[iGCP*6+1];\n                pasGCPList[iGCP].dfGCPX = padfTiePoints[iGCP*6+3];\n                pasGCPList[iGCP].dfGCPY = padfTiePoints[iGCP*6+4];\n                pasGCPList[iGCP].dfGCPZ = padfTiePoints[iGCP*6+5];\n\n                if( bPixelIsPoint && !bPointGeoIgnore )\n                {\n                    pasGCPList[iGCP].dfGCPPixel -= 0.5;\n                    pasGCPList[iGCP].dfGCPLine -= 0.5;\n                }\n            }\n            m_nGeoTransformGeorefSrcIndex = m_nINTERNALGeorefSrcIndex;\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Did we find a tab file?  If so we will use its coordinate       */\n/*      system and give it precedence.                                  */\n/* -------------------------------------------------------------------- */\n        if( pszTabWKT != nullptr\n            && (pszProjection == nullptr || pszProjection[0] == '\\0') )\n        {\n            CPLFree( pszProjection );\n            pszProjection = pszTabWKT;\n            pszTabWKT = nullptr;\n            bLookedForProjection = true;\n        }\n\n        CPLFree( pszTabWKT );\n    }\n\n    if( m_bLoadPam && m_nPAMGeorefSrcIndex >= 0 )\n    {\n/* -------------------------------------------------------------------- */\n/*      Initialize any PAM information.                                 */\n/* -------------------------------------------------------------------- */\n        CPLAssert(!bColorProfileMetadataChanged);\n        CPLAssert(!bMetadataChanged);\n        CPLAssert(!bGeoTIFFInfoChanged);\n        CPLAssert(!bNoDataChanged);\n\n        // We must absolutely unset m_bLoadPam now, otherwise calling\n        // GetFileList() on a .tif with a .aux will result in an (almost)\n        // endless sequence of calls.\n        m_bLoadPam = false;\n\n        TryLoadXML( GetSiblingFiles() );\n        ApplyPamInfo();\n\n        bColorProfileMetadataChanged = false;\n        bMetadataChanged = false;\n        bGeoTIFFInfoChanged = false;\n        bNoDataChanged = false;\n\n        for( int i = 1; i <= nBands; ++i )\n        {\n            GTiffRasterBand* poBand =\n                cpl::down_cast<GTiffRasterBand *>(GetRasterBand(i));\n\n            /* Load scale, offset and unittype from PAM if available */\n            if( !poBand->bHaveOffsetScale )\n            {\n                int nHaveOffsetScale = FALSE;\n                poBand->dfScale =\n                    poBand->GDALPamRasterBand::GetScale( &nHaveOffsetScale );\n                poBand->bHaveOffsetScale = CPL_TO_BOOL(nHaveOffsetScale);\n                poBand->dfOffset = poBand->GDALPamRasterBand::GetOffset();\n            }\n            if( poBand->osUnitType.empty() )\n            {\n                const char* pszUnitType =\n                    poBand->GDALPamRasterBand::GetUnitType();\n                if( pszUnitType )\n                    poBand->osUnitType = pszUnitType;\n            }\n            if( poBand->osDescription.empty() )\n                poBand->osDescription =\n                    poBand->GDALPamRasterBand::GetDescription();\n\n            GDALColorInterp ePAMColorInterp =\n                poBand->GDALPamRasterBand::GetColorInterpretation();\n            if( ePAMColorInterp != GCI_Undefined )\n                poBand->eBandInterp = ePAMColorInterp;\n        }\n    }\n    m_bLoadPam = false;\n}\n\n/************************************************************************/\n/*                          ScanDirectories()                           */\n/*                                                                      */\n/*      Scan through all the directories finding overviews, masks       */\n/*      and subdatasets.                                                */\n/************************************************************************/\n\nvoid GTiffDataset::ScanDirectories()\n\n{\n/* -------------------------------------------------------------------- */\n/*      We only scan once.  We do not scan for non-base datasets.       */\n/* -------------------------------------------------------------------- */\n    if( !bScanDeferred )\n        return;\n\n    bScanDeferred = false;\n\n    if( !bBase )\n        return;\n\n    if( TIFFLastDirectory( hTIFF ) )\n        return;\n\n    CPLDebug( \"GTiff\", \"ScanDirectories()\" );\n\n/* ==================================================================== */\n/*      Scan all directories.                                           */\n/* ==================================================================== */\n    CPLStringList aosSubdatasets;\n    int iDirIndex = 0;\n\n    FlushDirectory();\n    while( !TIFFLastDirectory( hTIFF )\n           && (iDirIndex == 0 || TIFFReadDirectory( hTIFF ) != 0) )\n    {\n        // Only libtiff 4.0.4 can handle between 32768 and 65535 directories.\n#if !defined(SUPPORTS_MORE_THAN_32768_DIRECTORIES)\n        if( iDirIndex == 32768 )\n            break;\n#endif\n        toff_t nThisDir = TIFFCurrentDirOffset(hTIFF);\n        uint32 nSubType = 0;\n\n        *ppoActiveDSRef = nullptr; // Our directory no longer matches this ds.\n\n        ++iDirIndex;\n\n        if( !TIFFGetField(hTIFF, TIFFTAG_SUBFILETYPE, &nSubType) )\n            nSubType = 0;\n\n        /* Embedded overview of the main image */\n        if( (nSubType & FILETYPE_REDUCEDIMAGE) != 0 &&\n            (nSubType & FILETYPE_MASK) == 0 &&\n            iDirIndex != 1 &&\n            nOverviewCount < 30 /* to avoid DoS */ )\n        {\n            GTiffDataset *poODS = new GTiffDataset();\n            poODS->osFilename = osFilename;\n            if( poODS->OpenOffset( hTIFF, ppoActiveDSRef, nThisDir, false,\n                                   eAccess ) != CE_None\n                || poODS->GetRasterCount() != GetRasterCount() )\n            {\n                delete poODS;\n            }\n            else\n            {\n                CPLDebug( \"GTiff\", \"Opened %dx%d overview.\",\n                          poODS->GetRasterXSize(), poODS->GetRasterYSize());\n                ++nOverviewCount;\n                papoOverviewDS = static_cast<GTiffDataset **>(\n                    CPLRealloc(papoOverviewDS,\n                               nOverviewCount * (sizeof(void*))) );\n                papoOverviewDS[nOverviewCount-1] = poODS;\n                poODS->poBaseDS = this;\n                poODS->bIsOverview_ = true;\n            }\n        }\n        // Embedded mask of the main image.\n        else if( (nSubType & FILETYPE_MASK) != 0 &&\n                 (nSubType & FILETYPE_REDUCEDIMAGE) == 0 &&\n                 iDirIndex != 1 &&\n                 poMaskDS == nullptr )\n        {\n            poMaskDS = new GTiffDataset();\n            poMaskDS->osFilename = osFilename;\n\n            // The TIFF6 specification - page 37 - only allows 1\n            // SamplesPerPixel and 1 BitsPerSample Here we support either 1 or\n            // 8 bit per sample and we support either 1 sample per pixel or as\n            // many samples as in the main image We don't check the value of\n            // the PhotometricInterpretation tag, which should be set to\n            // \"Transparency mask\" (4) according to the specification (page\n            // 36).  However, the TIFF6 specification allows image masks to\n            // have a higher resolution than the main image, what we don't\n            // support here.\n\n            if( poMaskDS->OpenOffset( hTIFF, ppoActiveDSRef, nThisDir,\n                                      false, eAccess ) != CE_None\n                || poMaskDS->GetRasterCount() == 0\n                || !(poMaskDS->GetRasterCount() == 1\n                     || poMaskDS->GetRasterCount() == GetRasterCount())\n                || poMaskDS->GetRasterXSize() != GetRasterXSize()\n                || poMaskDS->GetRasterYSize() != GetRasterYSize()\n                || poMaskDS->GetRasterBand(1)->GetRasterDataType() != GDT_Byte)\n            {\n                delete poMaskDS;\n                poMaskDS = nullptr;\n            }\n            else\n            {\n                CPLDebug( \"GTiff\", \"Opened band mask.\");\n                poMaskDS->poBaseDS = this;\n\n                poMaskDS->bPromoteTo8Bits =\n                    CPLTestBool(\n                        CPLGetConfigOption( \"GDAL_TIFF_INTERNAL_MASK_TO_8BIT\",\n                                            \"YES\" ) );\n            }\n        }\n\n        // Embedded mask of an overview.  The TIFF6 specification allows the\n        // combination of the FILETYPE_xxxx masks.\n        else if( (nSubType & FILETYPE_REDUCEDIMAGE) != 0 &&\n                 (nSubType & FILETYPE_MASK) != 0 &&\n                 iDirIndex != 1 )\n        {\n            GTiffDataset* poDS = new GTiffDataset();\n            poDS->osFilename = osFilename;\n            if( poDS->OpenOffset( hTIFF, ppoActiveDSRef, nThisDir, FALSE,\n                                  eAccess ) != CE_None\n                || poDS->GetRasterCount() == 0\n                || poDS->GetRasterBand(1)->GetRasterDataType() != GDT_Byte)\n            {\n                delete poDS;\n            }\n            else\n            {\n                int i = 0;  // Used after for.\n                for( ; i < nOverviewCount; ++i )\n                {\n                    if( cpl::down_cast<GTiffDataset *>(GDALDataset::FromHandle(\n                           papoOverviewDS[i]))->poMaskDS == nullptr &&\n                        poDS->GetRasterXSize() ==\n                        papoOverviewDS[i]->GetRasterXSize() &&\n                        poDS->GetRasterYSize() ==\n                        papoOverviewDS[i]->GetRasterYSize() &&\n                        (poDS->GetRasterCount() == 1 ||\n                         poDS->GetRasterCount() == GetRasterCount()))\n                    {\n                        CPLDebug(\n                            \"GTiff\", \"Opened band mask for %dx%d overview.\",\n                            poDS->GetRasterXSize(), poDS->GetRasterYSize());\n                        cpl::down_cast<GTiffDataset*>(GDALDataset::FromHandle(\n                            papoOverviewDS[i]))->\n                            poMaskDS = poDS;\n                        poDS->bPromoteTo8Bits =\n                            CPLTestBool(\n                                CPLGetConfigOption(\n                                    \"GDAL_TIFF_INTERNAL_MASK_TO_8BIT\",\n                                    \"YES\" ) );\n                        poDS->poBaseDS = this;\n                        break;\n                    }\n                }\n                if( i == nOverviewCount )\n                {\n                    delete poDS;\n                }\n            }\n        }\n        else if( nSubType == 0 || nSubType == FILETYPE_PAGE )\n        {\n            uint32 nXSize = 0;\n            uint32 nYSize = 0;\n\n            TIFFGetField( hTIFF, TIFFTAG_IMAGEWIDTH, &nXSize );\n            TIFFGetField( hTIFF, TIFFTAG_IMAGELENGTH, &nYSize );\n\n            if( nXSize > INT_MAX || nYSize > INT_MAX )\n            {\n                CPLDebug(\"GTiff\",\n                         \"Skipping directory with too large image: %u x %u\",\n                         nXSize, nYSize);\n            }\n            else\n            {\n                uint16 nSPP = 0;\n                if( !TIFFGetField(hTIFF, TIFFTAG_SAMPLESPERPIXEL, &nSPP ) )\n                    nSPP = 1;\n\n                CPLString osName, osDesc;\n                osName.Printf( \"SUBDATASET_%d_NAME=GTIFF_DIR:%d:%s\",\n                            iDirIndex, iDirIndex, osFilename.c_str() );\n                osDesc.Printf( \"SUBDATASET_%d_DESC=Page %d (%dP x %dL x %dB)\",\n                            iDirIndex, iDirIndex,\n                            static_cast<int>(nXSize),\n                            static_cast<int>(nYSize),\n                            nSPP );\n\n                aosSubdatasets.AddString(osName);\n                aosSubdatasets.AddString(osDesc);\n            }\n        }\n\n        // Make sure we are stepping from the expected directory regardless\n        // of churn done processing the above.\n        if( TIFFCurrentDirOffset(hTIFF) != nThisDir )\n            TIFFSetSubDirectory( hTIFF, nThisDir );\n        *ppoActiveDSRef = nullptr;\n    }\n\n    // Nasty hack. Probably something that should be fixed in libtiff\n    // In case the last directory cycles to the first directory, we have\n    // TIFFCurrentDirOffset(hTIFF) == nDirOffset, but the TIFFReadDirectory()\n    // hasn't done its job, so SetDirectory() would be confused and think it\n    // has nothing to do. To avoid that reset to a fake offset before calling\n    // SetDirectory()\n    // This can also occur if the last directory cycles to the IFD of the\n    // mask dataset and we activate this mask dataset.\n    // So always completely reset\n    TIFFSetSubDirectory( hTIFF, 0 );\n    *ppoActiveDSRef = nullptr;\n    CPL_IGNORE_RET_VAL( SetDirectory() );\n\n    // If we have a mask for the main image, loop over the overviews, and if\n    // they have a mask, let's set this mask as an overview of the main mask.\n    if( poMaskDS != nullptr )\n    {\n        for( int i = 0; i < nOverviewCount; ++i )\n        {\n            if( cpl::down_cast<GTiffDataset *>(GDALDataset::FromHandle(\n                   papoOverviewDS[i]))->poMaskDS != nullptr)\n            {\n                ++poMaskDS->nOverviewCount;\n                poMaskDS->papoOverviewDS = static_cast<GTiffDataset **>(\n                    CPLRealloc(poMaskDS->papoOverviewDS,\n                               poMaskDS->nOverviewCount * (sizeof(void*))) );\n                poMaskDS->papoOverviewDS[poMaskDS->nOverviewCount-1] =\n                    cpl::down_cast<GTiffDataset*>(GDALDataset::FromHandle(\n                        papoOverviewDS[i]))->poMaskDS;\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Only keep track of subdatasets if we have more than one         */\n/*      subdataset (pair).                                              */\n/* -------------------------------------------------------------------- */\n    if( aosSubdatasets.size() > 2 )\n    {\n        oGTiffMDMD.SetMetadata( aosSubdatasets.List(), \"SUBDATASETS\" );\n    }\n}\n\nstatic int GTiffGetLZMAPreset(char** papszOptions)\n{\n    int nLZMAPreset = -1;\n    const char* pszValue = CSLFetchNameValue( papszOptions, \"LZMA_PRESET\" );\n    if( pszValue != nullptr )\n    {\n        nLZMAPreset = atoi( pszValue );\n        if( !(nLZMAPreset >= 0 && nLZMAPreset <= 9) )\n        {\n            CPLError( CE_Warning, CPLE_IllegalArg,\n                      \"LZMA_PRESET=%s value not recognised, ignoring.\",\n                      pszValue );\n            nLZMAPreset = -1;\n        }\n    }\n    return nLZMAPreset;\n}\n\nstatic int GTiffGetZSTDPreset(char** papszOptions)\n{\n    int nZSTDLevel = -1;\n    const char* pszValue = CSLFetchNameValue( papszOptions, \"ZSTD_LEVEL\" );\n    if( pszValue != nullptr )\n    {\n        nZSTDLevel = atoi( pszValue );\n        if( !(nZSTDLevel >= 1 && nZSTDLevel <= 22) )\n        {\n            CPLError( CE_Warning, CPLE_IllegalArg,\n                      \"ZSTD_LEVEL=%s value not recognised, ignoring.\",\n                      pszValue );\n            nZSTDLevel = -1;\n        }\n    }\n    return nZSTDLevel;\n}\n\n#if HAVE_LERC\nstatic double GTiffGetLERCMaxZError(char** papszOptions)\n{\n    return CPLAtof(CSLFetchNameValueDef( papszOptions, \"MAX_Z_ERROR\", \"0.0\") );\n}\n#endif\n\nstatic int GTiffGetWebPLevel(char** papszOptions)\n{\n    int nWebPLevel = -1;\n    const char* pszValue = CSLFetchNameValue( papszOptions, \"WEBP_LEVEL\" );\n    if( pszValue != nullptr )\n    {\n        nWebPLevel = atoi( pszValue );\n        if( !(nWebPLevel >= 1 && nWebPLevel <= 100) )\n        {\n            CPLError( CE_Warning, CPLE_IllegalArg,\n                      \"WEBP_LEVEL=%s value not recognised, ignoring.\",\n                      pszValue );\n            nWebPLevel = -1;\n        }\n    }\n    return nWebPLevel;\n}\n\nstatic bool GTiffGetWebPLossless(char** papszOptions)\n{\n    return CPLFetchBool( papszOptions, \"WEBP_LOSSLESS\", false);\n}\n\nstatic int GTiffGetZLevel(char** papszOptions)\n{\n    int nZLevel = -1;\n    const char* pszValue = CSLFetchNameValue( papszOptions, \"ZLEVEL\" );\n    if( pszValue != nullptr )\n    {\n        nZLevel = atoi( pszValue );\n        if( nZLevel < 1 || nZLevel > 9 )\n        {\n            CPLError( CE_Warning, CPLE_IllegalArg,\n                      \"ZLEVEL=%s value not recognised, ignoring.\",\n                      pszValue );\n            nZLevel = -1;\n        }\n    }\n    return nZLevel;\n}\n\nstatic int GTiffGetJpegQuality(char** papszOptions)\n{\n    int nJpegQuality = -1;\n    const char* pszValue = CSLFetchNameValue( papszOptions, \"JPEG_QUALITY\" );\n    if( pszValue != nullptr )\n    {\n        nJpegQuality = atoi( pszValue );\n        if( nJpegQuality < 1 || nJpegQuality > 100 )\n        {\n            CPLError( CE_Warning, CPLE_IllegalArg,\n                      \"JPEG_QUALITY=%s value not recognised, ignoring.\",\n                      pszValue );\n            nJpegQuality = -1;\n        }\n    }\n    return nJpegQuality;\n}\n\nstatic int GTiffGetJpegTablesMode(char** papszOptions)\n{\n    return atoi(CSLFetchNameValueDef( papszOptions, \"JPEGTABLESMODE\",\n                                      CPLSPrintf(\"%d\",\n                                                knGTIFFJpegTablesModeDefault)));\n}\n\n/************************************************************************/\n/*                        GetDiscardLsbOption()                         */\n/************************************************************************/\n\nvoid GTiffDataset::GetDiscardLsbOption(char** papszOptions)\n{\n    const char* pszBits = CSLFetchNameValue( papszOptions, \"DISCARD_LSB\" );\n    if( pszBits == nullptr)\n        return;\n\n    if( nPhotometric == PHOTOMETRIC_PALETTE )\n    {\n        CPLError(CE_Warning, CPLE_AppDefined,\n                 \"DISCARD_LSB ignored on a paletted image\");\n        return;\n    }\n    if( !(nBitsPerSample == 8 || nBitsPerSample == 16 || nBitsPerSample == 32) )\n    {\n        CPLError(CE_Warning, CPLE_AppDefined,\n                 \"DISCARD_LSB ignored on non 8, 16 or 32 bits integer images\");\n        return;\n    }\n\n    char** papszTokens = CSLTokenizeString2( pszBits, \",\", 0 );\n    if( CSLCount(papszTokens) == 1 )\n    {\n        bHasDiscardedLsb = true;\n        for( int i = 0; i < nBands; ++i )\n        {\n            int nBits = atoi(papszTokens[0]);\n            anMaskLsb.push_back(~((1 << nBits)-1));\n            if( nBits > 1 )\n                anOffsetLsb.push_back(1 << (nBits - 1));\n            else\n                anOffsetLsb.push_back(0);\n        }\n    }\n    else if( CSLCount(papszTokens) == nBands )\n    {\n        bHasDiscardedLsb = true;\n        for( int i = 0; i < nBands; ++i )\n        {\n            int nBits = atoi(papszTokens[i]);\n            anMaskLsb.push_back(~((1 << nBits)-1));\n            if( nBits > 1 )\n                anOffsetLsb.push_back(1 << (nBits - 1));\n            else\n                anOffsetLsb.push_back(0);\n        }\n    }\n    else\n    {\n        CPLError(CE_Warning, CPLE_AppDefined,\n                 \"DISCARD_LSB ignored: wrong number of components\");\n    }\n    CSLDestroy(papszTokens);\n}\n\n/************************************************************************/\n/*                            GTiffCreate()                             */\n/*                                                                      */\n/*      Shared functionality between GTiffDataset::Create() and         */\n/*      GTiffCreateCopy() for creating TIFF file based on a set of      */\n/*      options and a configuration.                                    */\n/************************************************************************/\n\nTIFF *GTiffDataset::CreateLL( const char * pszFilename,\n                              int nXSize, int nYSize, int l_nBands,\n                              GDALDataType eType,\n                              double dfExtraSpaceForOverviews,\n                              char **papszParmList,\n                              VSILFILE** pfpL,\n                              CPLString& l_osTmpFilename )\n\n{\n    if( !GTiffOneTimeInit() )\n        return nullptr;\n\n/* -------------------------------------------------------------------- */\n/*      Blow on a few errors.                                           */\n/* -------------------------------------------------------------------- */\n    if( nXSize < 1 || nYSize < 1 || l_nBands < 1 )\n    {\n        CPLError(\n            CE_Failure, CPLE_AppDefined,\n            \"Attempt to create %dx%dx%d TIFF file, but width, height and bands\"\n            \"must be positive.\",\n            nXSize, nYSize, l_nBands );\n\n        return nullptr;\n    }\n\n    if( l_nBands > 65535 )\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                  \"Attempt to create %dx%dx%d TIFF file, but bands \"\n                  \"must be lesser or equal to 65535.\",\n                  nXSize, nYSize, l_nBands );\n\n        return nullptr;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Setup values based on options.                                  */\n/* -------------------------------------------------------------------- */\n    const char *pszProfile = CSLFetchNameValue(papszParmList, \"PROFILE\");\n    if( pszProfile == nullptr )\n        pszProfile = szPROFILE_GDALGeoTIFF;\n\n    const bool bTiled = CPLFetchBool( papszParmList, \"TILED\", false );\n\n    int l_nBlockXSize = 0;\n    const char *pszValue = CSLFetchNameValue(papszParmList, \"BLOCKXSIZE\");\n    if( pszValue != nullptr )\n        l_nBlockXSize = atoi( pszValue );\n\n    int l_nBlockYSize = 0;\n    pszValue = CSLFetchNameValue(papszParmList, \"BLOCKYSIZE\");\n    if( pszValue != nullptr )\n        l_nBlockYSize = atoi( pszValue );\n\n    int nPlanar = 0;\n    pszValue = CSLFetchNameValue(papszParmList, \"INTERLEAVE\");\n    if( pszValue != nullptr )\n    {\n        if( EQUAL( pszValue, \"PIXEL\" ) )\n            nPlanar = PLANARCONFIG_CONTIG;\n        else if( EQUAL( pszValue, \"BAND\" ) )\n        {\n            nPlanar = PLANARCONFIG_SEPARATE;\n        }\n        else\n        {\n            CPLError( CE_Failure, CPLE_AppDefined,\n                      \"INTERLEAVE=%s unsupported, value must be PIXEL or BAND.\",\n                      pszValue );\n            return nullptr;\n        }\n    }\n    else\n    {\n        nPlanar = PLANARCONFIG_CONTIG;\n    }\n\n    int l_nCompression = COMPRESSION_NONE;\n    pszValue = CSLFetchNameValue( papszParmList, \"COMPRESS\" );\n    if( pszValue != nullptr )\n    {\n        l_nCompression = GTIFFGetCompressionMethod(pszValue, \"COMPRESS\");\n        if( l_nCompression < 0 )\n            return nullptr;\n    }\n\n    int nPredictor = PREDICTOR_NONE;\n    pszValue = CSLFetchNameValue( papszParmList, \"PREDICTOR\" );\n    if( pszValue != nullptr )\n        nPredictor = atoi( pszValue );\n\n    const int l_nZLevel = GTiffGetZLevel(papszParmList);\n    const int l_nLZMAPreset = GTiffGetLZMAPreset(papszParmList);\n    const int l_nZSTDLevel = GTiffGetZSTDPreset(papszParmList);\n    const int l_nWebPLevel = GTiffGetWebPLevel(papszParmList);\n    const bool l_bWebPLossless = GTiffGetWebPLossless(papszParmList);\n    const int l_nJpegQuality = GTiffGetJpegQuality(papszParmList);\n    const int l_nJpegTablesMode = GTiffGetJpegTablesMode(papszParmList);\n#if HAVE_LERC\n    const double l_dfMaxZError = GTiffGetLERCMaxZError(papszParmList);\n#endif\n\n/* -------------------------------------------------------------------- */\n/*      Streaming related code                                          */\n/* -------------------------------------------------------------------- */\n    const CPLString osOriFilename(pszFilename);\n    bool bStreaming =\n        strcmp(pszFilename, \"/vsistdout/\") == 0 ||\n        CPLFetchBool(papszParmList, \"STREAMABLE_OUTPUT\", false);\n#ifdef S_ISFIFO\n    if( !bStreaming )\n    {\n        VSIStatBufL sStat;\n        if( VSIStatExL( pszFilename, &sStat,\n                        VSI_STAT_EXISTS_FLAG | VSI_STAT_NATURE_FLAG) == 0 &&\n             S_ISFIFO(sStat.st_mode) )\n        {\n            bStreaming = true;\n        }\n    }\n#endif\n    if( bStreaming &&\n        !EQUAL( \"NONE\",\n                CSLFetchNameValueDef(papszParmList, \"COMPRESS\", \"NONE\")) )\n    {\n        CPLError(\n            CE_Failure, CPLE_NotSupported,\n            \"Streaming only supported to uncompressed TIFF\" );\n        return nullptr;\n    }\n    if( bStreaming && CPLFetchBool(papszParmList, \"SPARSE_OK\", false) )\n    {\n        CPLError(\n            CE_Failure, CPLE_NotSupported,\n            \"Streaming not supported with SPARSE_OK\" );\n        return nullptr;\n    }\n    if( bStreaming && CPLFetchBool(papszParmList, \"COPY_SRC_OVERVIEWS\", false) )\n    {\n        CPLError(\n            CE_Failure, CPLE_NotSupported,\n            \"Streaming not supported with COPY_SRC_OVERVIEWS\" );\n        return nullptr;\n    }\n    if( bStreaming )\n    {\n        static int nCounter = 0;\n        l_osTmpFilename = CPLSPrintf(\"/vsimem/vsistdout_%d.tif\", ++nCounter);\n        pszFilename = l_osTmpFilename.c_str();\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Compute the uncompressed size.                                  */\n/* -------------------------------------------------------------------- */\n    const double dfUncompressedImageSize =\n        nXSize * static_cast<double>(nYSize) * l_nBands *\n        GDALGetDataTypeSizeBytes(eType)\n        + dfExtraSpaceForOverviews;\n\n    if( l_nCompression == COMPRESSION_NONE\n        && dfUncompressedImageSize > 4200000000.0 )\n    {\n#ifndef BIGTIFF_SUPPORT\n        CPLError(\n            CE_Failure, CPLE_NotSupported,\n            \"A %d pixels x %d lines x %d bands %s image would be larger than \"\n            \"4GB but this is the largest size a TIFF can be, and BigTIFF \"\n            \"is unavailable.  Creation failed.\",\n            nXSize, nYSize, l_nBands, GDALGetDataTypeName(eType) );\n        return nullptr;\n#endif\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Check free space (only for big, non sparse, uncompressed)       */\n/* -------------------------------------------------------------------- */\n    if( l_nCompression == COMPRESSION_NONE &&\n        dfUncompressedImageSize >= 1e9 &&\n        !CPLFetchBool(papszParmList, \"SPARSE_OK\", false) &&\n        osOriFilename != \"/vsistdout/\" &&\n        osOriFilename != \"/vsistdout_redirect/\" &&\n        CPLTestBool(CPLGetConfigOption(\"CHECK_DISK_FREE_SPACE\", \"TRUE\")) )\n    {\n        GIntBig nFreeDiskSpace =\n            VSIGetDiskFreeSpace(CPLGetDirname(pszFilename));\n        if( nFreeDiskSpace >= 0 &&\n            nFreeDiskSpace < dfUncompressedImageSize )\n        {\n            CPLError( CE_Failure, CPLE_FileIO,\n                      \"Free disk space available is \" CPL_FRMT_GIB \" bytes, \"\n                      \"whereas \" CPL_FRMT_GIB \" are at least necessary. \"\n                      \"You can disable this check by defining the \"\n                      \"CHECK_DISK_FREE_SPACE configuration option to FALSE.\",\n                      nFreeDiskSpace,\n                      static_cast<GIntBig>(dfUncompressedImageSize) );\n            return nullptr;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Should the file be created as a bigtiff file?                   */\n/* -------------------------------------------------------------------- */\n    const char *pszBIGTIFF = CSLFetchNameValue(papszParmList, \"BIGTIFF\");\n\n    if( pszBIGTIFF == nullptr )\n        pszBIGTIFF = \"IF_NEEDED\";\n\n    bool bCreateBigTIFF = false;\n    if( EQUAL(pszBIGTIFF, \"IF_NEEDED\") )\n    {\n        if( l_nCompression == COMPRESSION_NONE\n            && dfUncompressedImageSize > 4200000000.0 )\n            bCreateBigTIFF = true;\n    }\n    else if( EQUAL(pszBIGTIFF, \"IF_SAFER\") )\n    {\n        if( dfUncompressedImageSize > 2000000000.0 )\n            bCreateBigTIFF = true;\n    }\n    else\n    {\n        bCreateBigTIFF = CPLTestBool( pszBIGTIFF );\n        if( !bCreateBigTIFF && l_nCompression == COMPRESSION_NONE &&\n             dfUncompressedImageSize > 4200000000.0 )\n        {\n            CPLError(\n                CE_Failure, CPLE_NotSupported,\n                \"The TIFF file will be larger than 4GB, so BigTIFF is \"\n                \"necessary.  Creation failed.\");\n            return nullptr;\n        }\n    }\n\n#ifndef BIGTIFF_SUPPORT\n    if( bCreateBigTIFF )\n    {\n        CPLError( CE_Warning, CPLE_NotSupported,\n                  \"BigTIFF requested, but GDAL built without BigTIFF \"\n                  \"enabled libtiff, request ignored.\" );\n        bCreateBigTIFF = false;\n    }\n#endif\n\n    if( bCreateBigTIFF )\n        CPLDebug( \"GTiff\", \"File being created as a BigTIFF.\" );\n\n/* -------------------------------------------------------------------- */\n/*      Check if the user wishes a particular endianness                */\n/* -------------------------------------------------------------------- */\n\n    int eEndianness = ENDIANNESS_NATIVE;\n    pszValue = CSLFetchNameValue(papszParmList, \"ENDIANNESS\");\n    if( pszValue == nullptr )\n        pszValue = CPLGetConfigOption( \"GDAL_TIFF_ENDIANNESS\", nullptr );\n    if( pszValue != nullptr )\n    {\n        if( EQUAL(pszValue, \"LITTLE\") )\n        {\n            eEndianness = ENDIANNESS_LITTLE;\n        }\n        else if( EQUAL(pszValue, \"BIG\") )\n        {\n            eEndianness = ENDIANNESS_BIG;\n        }\n        else if( EQUAL(pszValue, \"INVERTED\") )\n        {\n#ifdef CPL_LSB\n            eEndianness = ENDIANNESS_BIG;\n#else\n            eEndianness = ENDIANNESS_LITTLE;\n#endif\n        }\n        else if( !EQUAL(pszValue, \"NATIVE\") )\n        {\n            CPLError(\n                CE_Warning, CPLE_NotSupported,\n                \"ENDIANNESS=%s not supported. Defaulting to NATIVE\", pszValue );\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Try opening the dataset.                                        */\n/* -------------------------------------------------------------------- */\n\n    char szOpeningFlag[5] = {};\n    strcpy(szOpeningFlag, \"w+\");\n    if( bCreateBigTIFF )\n        strcat(szOpeningFlag, \"8\");\n    if( eEndianness == ENDIANNESS_BIG )\n        strcat(szOpeningFlag, \"b\");\n    else if( eEndianness == ENDIANNESS_LITTLE )\n        strcat(szOpeningFlag, \"l\");\n\n    VSILFILE* l_fpL = VSIFOpenL( pszFilename, \"w+b\" );\n    if( l_fpL == nullptr )\n    {\n        CPLError( CE_Failure, CPLE_OpenFailed,\n                  \"Attempt to create new tiff file `%s' failed: %s\",\n                  pszFilename, VSIStrerror(errno) );\n        return nullptr;\n    }\n    TIFF *l_hTIFF = VSI_TIFFOpen( pszFilename, szOpeningFlag, l_fpL );\n    if( l_hTIFF == nullptr )\n    {\n        if( CPLGetLastErrorNo() == 0 )\n            CPLError( CE_Failure, CPLE_OpenFailed,\n                      \"Attempt to create new tiff file `%s' \"\n                      \"failed in XTIFFOpen().\",\n                      pszFilename );\n        CPL_IGNORE_RET_VAL(VSIFCloseL(l_fpL));\n        return nullptr;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      How many bits per sample?  We have a special case if NBITS      */\n/*      specified for GDT_Byte, GDT_UInt16, GDT_UInt32.                 */\n/* -------------------------------------------------------------------- */\n    int l_nBitsPerSample = GDALGetDataTypeSizeBits(eType);\n    if( CSLFetchNameValue(papszParmList, \"NBITS\") != nullptr )\n    {\n        int nMinBits = 0;\n        int nMaxBits = 0;\n        l_nBitsPerSample = atoi(CSLFetchNameValue(papszParmList, \"NBITS\"));\n        if( eType == GDT_Byte )\n        {\n            nMinBits = 1;\n            nMaxBits = 8;\n        }\n        else if( eType == GDT_UInt16 )\n        {\n            nMinBits = 9;\n            nMaxBits = 16;\n        }\n        else if( eType == GDT_UInt32 )\n        {\n            nMinBits = 17;\n            nMaxBits = 32;\n        }\n        else if( eType == GDT_Float32 )\n        {\n            if( l_nBitsPerSample != 16 && l_nBitsPerSample != 32 )\n            {\n                CPLError(CE_Warning, CPLE_NotSupported,\n                     \"NBITS is not supported for data type %s\",\n                     GDALGetDataTypeName(eType));\n                l_nBitsPerSample = GDALGetDataTypeSizeBits(eType);\n            }\n        }\n        else\n        {\n            CPLError(CE_Warning, CPLE_NotSupported,\n                     \"NBITS is not supported for data type %s\",\n                     GDALGetDataTypeName(eType));\n            l_nBitsPerSample = GDALGetDataTypeSizeBits(eType);\n        }\n\n        if( nMinBits != 0 )\n        {\n            if( l_nBitsPerSample < nMinBits )\n            {\n                CPLError(CE_Warning, CPLE_AppDefined,\n                         \"NBITS=%d is invalid for data type %s. Using NBITS=%d\",\n                         l_nBitsPerSample, GDALGetDataTypeName(eType),\n                         nMinBits);\n                l_nBitsPerSample = nMinBits;\n            }\n            else if( l_nBitsPerSample > nMaxBits )\n            {\n                CPLError(CE_Warning, CPLE_AppDefined,\n                         \"NBITS=%d is invalid for data type %s. Using NBITS=%d\",\n                         l_nBitsPerSample, GDALGetDataTypeName(eType),\n                         nMaxBits);\n                l_nBitsPerSample = nMaxBits;\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Do we have a custom pixel type (just used for signed byte now). */\n/* -------------------------------------------------------------------- */\n    const char *pszPixelType = CSLFetchNameValue( papszParmList, \"PIXELTYPE\" );\n    if( pszPixelType == nullptr )\n        pszPixelType = \"\";\n\n/* -------------------------------------------------------------------- */\n/*      Setup some standard flags.                                      */\n/* -------------------------------------------------------------------- */\n    TIFFSetField( l_hTIFF, TIFFTAG_IMAGEWIDTH, nXSize );\n    TIFFSetField( l_hTIFF, TIFFTAG_IMAGELENGTH, nYSize );\n    TIFFSetField( l_hTIFF, TIFFTAG_BITSPERSAMPLE, l_nBitsPerSample );\n\n    uint16 l_nSampleFormat = 0;\n    if( (eType == GDT_Byte && EQUAL(pszPixelType,\"SIGNEDBYTE\"))\n        || eType == GDT_Int16 || eType == GDT_Int32 )\n        l_nSampleFormat = SAMPLEFORMAT_INT;\n    else if( eType == GDT_CInt16 || eType == GDT_CInt32 )\n        l_nSampleFormat = SAMPLEFORMAT_COMPLEXINT;\n    else if( eType == GDT_Float32 || eType == GDT_Float64 )\n        l_nSampleFormat = SAMPLEFORMAT_IEEEFP;\n    else if( eType == GDT_CFloat32 || eType == GDT_CFloat64 )\n        l_nSampleFormat = SAMPLEFORMAT_COMPLEXIEEEFP;\n    else\n        l_nSampleFormat = SAMPLEFORMAT_UINT;\n\n    TIFFSetField( l_hTIFF, TIFFTAG_SAMPLEFORMAT, l_nSampleFormat );\n    TIFFSetField( l_hTIFF, TIFFTAG_SAMPLESPERPIXEL, l_nBands );\n    TIFFSetField( l_hTIFF, TIFFTAG_PLANARCONFIG, nPlanar );\n\n/* -------------------------------------------------------------------- */\n/*      Setup Photometric Interpretation. Take this value from the user */\n/*      passed option or guess correct value otherwise.                 */\n/* -------------------------------------------------------------------- */\n    int nSamplesAccountedFor = 1;\n    bool bForceColorTable = false;\n\n    pszValue = CSLFetchNameValue(papszParmList,\"PHOTOMETRIC\");\n    if( pszValue != nullptr )\n    {\n        if( EQUAL( pszValue, \"MINISBLACK\" ) )\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC,\n                          PHOTOMETRIC_MINISBLACK );\n        else if( EQUAL( pszValue, \"MINISWHITE\" ) )\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC,\n                          PHOTOMETRIC_MINISWHITE );\n        }\n        else if( EQUAL( pszValue, \"PALETTE\" ))\n        {\n            if( eType == GDT_Byte || eType == GDT_UInt16 )\n            {\n                TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC,\n                              PHOTOMETRIC_PALETTE );\n                nSamplesAccountedFor = 1;\n                bForceColorTable = true;\n            }\n            else\n            {\n                CPLError(\n                    CE_Warning, CPLE_AppDefined,\n                    \"PHOTOMETRIC=PALETTE only compatible with Byte or UInt16\" );\n            }\n        }\n        else if( EQUAL( pszValue, \"RGB\" ))\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB );\n            nSamplesAccountedFor = 3;\n        }\n        else if( EQUAL( pszValue, \"CMYK\" ))\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_SEPARATED );\n            nSamplesAccountedFor = 4;\n        }\n        else if( EQUAL( pszValue, \"YCBCR\" ))\n        {\n            // Because of subsampling, setting YCBCR without JPEG compression\n            // leads to a crash currently. Would need to make\n            // GTiffRasterBand::IWriteBlock() aware of subsampling so that it\n            // doesn't overrun buffer size returned by libtiff.\n            if( l_nCompression != COMPRESSION_JPEG )\n            {\n                CPLError(CE_Failure, CPLE_NotSupported,\n                         \"Currently, PHOTOMETRIC=YCBCR requires COMPRESS=JPEG\");\n                XTIFFClose(l_hTIFF);\n                CPL_IGNORE_RET_VAL(VSIFCloseL(l_fpL));\n                return nullptr;\n            }\n\n            if( nPlanar == PLANARCONFIG_SEPARATE )\n            {\n                CPLError(CE_Failure, CPLE_NotSupported,\n                         \"PHOTOMETRIC=YCBCR requires INTERLEAVE=PIXEL\");\n                XTIFFClose(l_hTIFF);\n                CPL_IGNORE_RET_VAL(VSIFCloseL(l_fpL));\n                return nullptr;\n            }\n\n            // YCBCR strictly requires 3 bands. Not less, not more Issue an\n            // explicit error message as libtiff one is a bit cryptic:\n            // TIFFVStripSize64:Invalid td_samplesperpixel value.\n            if( l_nBands != 3 )\n            {\n                CPLError(\n                    CE_Failure, CPLE_NotSupported,\n                    \"PHOTOMETRIC=YCBCR not supported on a %d-band raster: \"\n                    \"only compatible of a 3-band (RGB) raster\", l_nBands );\n                XTIFFClose(l_hTIFF);\n                CPL_IGNORE_RET_VAL(VSIFCloseL(l_fpL));\n                return nullptr;\n            }\n\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR );\n            nSamplesAccountedFor = 3;\n\n            // Explicitly register the subsampling so that JPEGFixupTags\n            // is a no-op (helps for cloud optimized geotiffs)\n            TIFFSetField( l_hTIFF, TIFFTAG_YCBCRSUBSAMPLING, 2, 2 );\n        }\n        else if( EQUAL( pszValue, \"CIELAB\" ))\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_CIELAB );\n            nSamplesAccountedFor = 3;\n        }\n        else if( EQUAL( pszValue, \"ICCLAB\" ))\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_ICCLAB );\n            nSamplesAccountedFor = 3;\n        }\n        else if( EQUAL( pszValue, \"ITULAB\" ))\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_ITULAB );\n            nSamplesAccountedFor = 3;\n        }\n        else\n        {\n            CPLError( CE_Warning, CPLE_IllegalArg,\n                      \"PHOTOMETRIC=%s value not recognised, ignoring.  \"\n                      \"Set the Photometric Interpretation as MINISBLACK.\",\n                      pszValue );\n            TIFFSetField(l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n        }\n\n        if( l_nBands < nSamplesAccountedFor )\n        {\n            CPLError( CE_Warning, CPLE_IllegalArg,\n                      \"PHOTOMETRIC=%s value does not correspond to number \"\n                      \"of bands (%d), ignoring.  \"\n                      \"Set the Photometric Interpretation as MINISBLACK.\",\n                      pszValue, l_nBands );\n            TIFFSetField(l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n        }\n    }\n    else\n    {\n        // If image contains 3 or 4 bands and datatype is Byte then we will\n        // assume it is RGB. In all other cases assume it is MINISBLACK.\n        if( l_nBands == 3 && eType == GDT_Byte )\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB );\n            nSamplesAccountedFor = 3;\n        }\n        else if( l_nBands == 4 && eType == GDT_Byte )\n        {\n            uint16 v[1] = {\n                GTiffGetAlphaValue(CSLFetchNameValue(papszParmList, \"ALPHA\"),\n                                   DEFAULT_ALPHA_TYPE)\n            };\n\n            TIFFSetField( l_hTIFF, TIFFTAG_EXTRASAMPLES, 1, v);\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB );\n            nSamplesAccountedFor = 4;\n        }\n        else\n        {\n            TIFFSetField(l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n            nSamplesAccountedFor = 1;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If there are extra samples, we need to mark them with an        */\n/*      appropriate extrasamples definition here.                       */\n/* -------------------------------------------------------------------- */\n    if( l_nBands > nSamplesAccountedFor )\n    {\n        const int nExtraSamples = l_nBands - nSamplesAccountedFor;\n\n        uint16 *v = static_cast<uint16 *>(\n            CPLMalloc( sizeof(uint16) * nExtraSamples ) );\n\n        v[0] = GTiffGetAlphaValue( CSLFetchNameValue(papszParmList, \"ALPHA\"),\n                                   EXTRASAMPLE_UNSPECIFIED );\n\n        for( int i = 1; i < nExtraSamples; ++i )\n            v[i] = EXTRASAMPLE_UNSPECIFIED;\n\n        TIFFSetField(l_hTIFF, TIFFTAG_EXTRASAMPLES, nExtraSamples, v );\n\n        CPLFree(v);\n    }\n\n    // Set the ICC color profile.\n    if( !EQUAL(pszProfile,szPROFILE_BASELINE) )\n    {\n        SaveICCProfile(nullptr, l_hTIFF, papszParmList, l_nBitsPerSample);\n    }\n\n    // Set the compression method before asking the default strip size\n    // This is useful when translating to a JPEG-In-TIFF file where\n    // the default strip size is 8 or 16 depending on the photometric value.\n    TIFFSetField( l_hTIFF, TIFFTAG_COMPRESSION, l_nCompression );\n\n#if HAVE_LERC\n    if( l_nCompression == COMPRESSION_LERC )\n    {\n        const char* pszCompress =\n            CSLFetchNameValueDef( papszParmList, \"COMPRESS\", \"\" );\n        if( EQUAL(pszCompress , \"LERC_DEFLATE\" ) )\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_LERC_ADD_COMPRESSION,\n                        LERC_ADD_COMPRESSION_DEFLATE );\n        }\n        else if( EQUAL(pszCompress, \"LERC_ZSTD\" ) )\n        {\n            if( TIFFSetField( l_hTIFF, TIFFTAG_LERC_ADD_COMPRESSION,\n                            LERC_ADD_COMPRESSION_ZSTD ) != 1 )\n            {\n                XTIFFClose(l_hTIFF);\n                CPL_IGNORE_RET_VAL(VSIFCloseL(l_fpL));\n                return nullptr;\n            }\n        }\n    }\n    // TODO later: take into account LERC version\n#endif\n\n/* -------------------------------------------------------------------- */\n/*      Setup tiling/stripping flags.                                   */\n/* -------------------------------------------------------------------- */\n    if( bTiled )\n    {\n        if( l_nBlockXSize == 0 )\n            l_nBlockXSize = 256;\n\n        if( l_nBlockYSize == 0 )\n            l_nBlockYSize = 256;\n\n        if( !TIFFSetField( l_hTIFF, TIFFTAG_TILEWIDTH, l_nBlockXSize ) ||\n            !TIFFSetField( l_hTIFF, TIFFTAG_TILELENGTH, l_nBlockYSize ) )\n        {\n            XTIFFClose(l_hTIFF);\n            CPL_IGNORE_RET_VAL(VSIFCloseL(l_fpL));\n            return nullptr;\n        }\n    }\n    else\n    {\n        const uint32 l_nRowsPerStrip = std::min(nYSize,\n            l_nBlockYSize == 0\n            ? static_cast<int>(TIFFDefaultStripSize(l_hTIFF,0))\n            : l_nBlockYSize );\n\n        TIFFSetField( l_hTIFF, TIFFTAG_ROWSPERSTRIP, l_nRowsPerStrip );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Set compression related tags.                                   */\n/* -------------------------------------------------------------------- */\n    if( l_nCompression == COMPRESSION_LZW ||\n         l_nCompression == COMPRESSION_ADOBE_DEFLATE ||\n         l_nCompression == COMPRESSION_ZSTD )\n        TIFFSetField( l_hTIFF, TIFFTAG_PREDICTOR, nPredictor );\n    if( (l_nCompression == COMPRESSION_ADOBE_DEFLATE ||\n         l_nCompression == COMPRESSION_LERC) && l_nZLevel != -1 )\n        TIFFSetField( l_hTIFF, TIFFTAG_ZIPQUALITY, l_nZLevel );\n    if( l_nCompression == COMPRESSION_JPEG && l_nJpegQuality != -1 )\n        TIFFSetField( l_hTIFF, TIFFTAG_JPEGQUALITY, l_nJpegQuality );\n    if( l_nCompression == COMPRESSION_LZMA && l_nLZMAPreset != -1)\n        TIFFSetField( l_hTIFF, TIFFTAG_LZMAPRESET, l_nLZMAPreset );\n    if( (l_nCompression == COMPRESSION_ZSTD ||\n         l_nCompression == COMPRESSION_LERC) && l_nZSTDLevel != -1)\n        TIFFSetField( l_hTIFF, TIFFTAG_ZSTD_LEVEL, l_nZSTDLevel);\n#if HAVE_LERC\n    if( l_nCompression == COMPRESSION_LERC )\n    {\n        TIFFSetField( l_hTIFF, TIFFTAG_LERC_MAXZERROR, l_dfMaxZError );\n    }\n#endif\n    if( l_nCompression == COMPRESSION_WEBP && l_nWebPLevel != -1)\n        TIFFSetField( l_hTIFF, TIFFTAG_WEBP_LEVEL, l_nWebPLevel);\n    if( l_nCompression == COMPRESSION_WEBP && l_bWebPLossless)\n        TIFFSetField( l_hTIFF, TIFFTAG_WEBP_LOSSLESS, 1);\n\n    if( l_nCompression == COMPRESSION_JPEG )\n        TIFFSetField( l_hTIFF, TIFFTAG_JPEGTABLESMODE, l_nJpegTablesMode );\n\n/* -------------------------------------------------------------------- */\n/*      If we forced production of a file with photometric=palette,     */\n/*      we need to push out a default color table.                      */\n/* -------------------------------------------------------------------- */\n    if( bForceColorTable )\n    {\n        const int nColors = eType == GDT_Byte ? 256 : 65536;\n\n        unsigned short *panTRed = static_cast<unsigned short *>(\n            CPLMalloc(sizeof(unsigned short)*nColors) );\n        unsigned short *panTGreen = static_cast<unsigned short *>(\n            CPLMalloc(sizeof(unsigned short)*nColors) );\n        unsigned short *panTBlue = static_cast<unsigned short *>(\n            CPLMalloc(sizeof(unsigned short)*nColors) );\n\n        for( int iColor = 0; iColor < nColors; ++iColor )\n        {\n            if( eType == GDT_Byte )\n            {\n                panTRed[iColor] = static_cast<unsigned short>(257 * iColor);\n                panTGreen[iColor] = static_cast<unsigned short>(257 * iColor);\n                panTBlue[iColor] = static_cast<unsigned short>(257 * iColor);\n            }\n            else\n            {\n                panTRed[iColor] = static_cast<unsigned short>(iColor);\n                panTGreen[iColor] = static_cast<unsigned short>(iColor);\n                panTBlue[iColor] = static_cast<unsigned short>(iColor);\n            }\n        }\n\n        TIFFSetField( l_hTIFF, TIFFTAG_COLORMAP,\n                      panTRed, panTGreen, panTBlue );\n\n        CPLFree( panTRed );\n        CPLFree( panTGreen );\n        CPLFree( panTBlue );\n    }\n\n    // Would perhaps works with libtiff 3.X but didn't bother trying This trick\n    // creates a temporary in-memory file and fetches its JPEG tables so that\n    // we can directly set them, before tif_jpeg.c compute them at the first\n    // strip/tile writing, which is too late, since we have already crystalized\n    // the directory. This way we avoid a directory rewriting.\n#if defined(BIGTIFF_SUPPORT)\n    if( l_nCompression == COMPRESSION_JPEG &&\n        !STARTS_WITH(pszFilename, szJPEGGTiffDatasetTmpPrefix) &&\n        CPLTestBool(\n            CSLFetchNameValueDef(papszParmList, \"WRITE_JPEGTABLE_TAG\", \"YES\")) )\n    {\n        GTiffWriteJPEGTables( l_hTIFF,\n                              CSLFetchNameValue(papszParmList, \"PHOTOMETRIC\"),\n                              CSLFetchNameValue(papszParmList, \"JPEG_QUALITY\"),\n                              CSLFetchNameValue(papszParmList,\n                                                \"JPEGTABLESMODE\") );\n    }\n#endif\n\n    *pfpL = l_fpL;\n\n    return l_hTIFF;\n}\n\n/************************************************************************/\n/*                      GTiffWriteJPEGTables()                          */\n/*                                                                      */\n/*      Sets the TIFFTAG_JPEGTABLES (and TIFFTAG_REFERENCEBLACKWHITE)   */\n/*      tags immediately, instead of relying on the TIFF JPEG codec     */\n/*      to write them when it starts compressing imagery. This avoids   */\n/*      an IFD rewrite at the end of the file.                          */\n/*      Must be used after having set TIFFTAG_SAMPLESPERPIXEL,          */\n/*      TIFFTAG_BITSPERSAMPLE.                                          */\n/************************************************************************/\n\nvoid GTiffWriteJPEGTables( TIFF* hTIFF,\n                           const char* pszPhotometric,\n                           const char* pszJPEGQuality,\n                           const char* pszJPEGTablesMode )\n{\n    // Would perhaps works with libtiff 3.X but didn't bother trying This trick\n    // creates a temporary in-memory file and fetches its JPEG tables so that\n    // we can directly set them, before tif_jpeg.c compute them at the first\n    // strip/tile writing, which is too late, since we have already crystalized\n    // the directory. This way we avoid a directory rewriting.\n#if defined(BIGTIFF_SUPPORT)\n    uint16 nBands = 0;\n    if( !TIFFGetField( hTIFF, TIFFTAG_SAMPLESPERPIXEL,\n                        &nBands ) )\n        nBands = 1;\n\n    uint16 l_nBitsPerSample = 0;\n    if( !TIFFGetField(hTIFF, TIFFTAG_BITSPERSAMPLE,\n                        &(l_nBitsPerSample)) )\n        l_nBitsPerSample = 1;\n\n    CPLString osTmpFilenameIn;\n    osTmpFilenameIn.Printf(\"%s%p\", szJPEGGTiffDatasetTmpPrefix, hTIFF);\n    VSILFILE* fpTmp = nullptr;\n    CPLString osTmp;\n    char** papszLocalParameters = nullptr;\n    const int nInMemImageWidth = 16;\n    const int nInMemImageHeight = 16;\n    papszLocalParameters = CSLSetNameValue( papszLocalParameters,\n                                            \"COMPRESS\", \"JPEG\" );\n    papszLocalParameters = CSLSetNameValue( papszLocalParameters,\n                                            \"JPEG_QUALITY\",\n                                            pszJPEGQuality );\n    papszLocalParameters = CSLSetNameValue( papszLocalParameters,\n                                            \"PHOTOMETRIC\", pszPhotometric );\n    papszLocalParameters = CSLSetNameValue( papszLocalParameters,\n                                            \"BLOCKYSIZE\",\n                                            CPLSPrintf(\"%u\", nInMemImageHeight)\n                                          );\n    papszLocalParameters = CSLSetNameValue( papszLocalParameters,\n                                            \"NBITS\",\n                                            CPLSPrintf(\"%u\", l_nBitsPerSample));\n    papszLocalParameters = CSLSetNameValue( papszLocalParameters,\n                                            \"JPEGTABLESMODE\",\n                                            pszJPEGTablesMode );\n\n    TIFF* hTIFFTmp = GTiffDataset::CreateLL(\n                    osTmpFilenameIn, nInMemImageWidth, nInMemImageHeight,\n                    (nBands <= 4) ? nBands : 1,\n                    (l_nBitsPerSample <= 8) ? GDT_Byte : GDT_UInt16, 0.0,\n                    papszLocalParameters, &fpTmp, osTmp );\n    CSLDestroy(papszLocalParameters);\n    if( hTIFFTmp )\n    {\n        uint16 l_nPhotometric = 0;\n        int nJpegTablesModeIn = 0;\n        TIFFGetField( hTIFFTmp, TIFFTAG_PHOTOMETRIC, &(l_nPhotometric) );\n        TIFFGetField( hTIFFTmp, TIFFTAG_JPEGTABLESMODE,\n                        &nJpegTablesModeIn );\n        TIFFWriteCheck( hTIFFTmp, FALSE, \"CreateLL\" );\n        TIFFWriteDirectory( hTIFFTmp );\n        TIFFSetDirectory( hTIFFTmp, 0 );\n        // Now, reset quality and jpegcolormode.\n        const int l_nJpegQuality = pszJPEGQuality ? atoi(pszJPEGQuality) : 0;\n        if(l_nJpegQuality > 0)\n            TIFFSetField(hTIFFTmp, TIFFTAG_JPEGQUALITY, l_nJpegQuality);\n        if( l_nPhotometric == PHOTOMETRIC_YCBCR\n            && CPLTestBool( CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\",\n                                                \"YES\") ) )\n        {\n            TIFFSetField( hTIFFTmp, TIFFTAG_JPEGCOLORMODE,\n                            JPEGCOLORMODE_RGB);\n        }\n        if( nJpegTablesModeIn >= 0 )\n            TIFFSetField( hTIFFTmp, TIFFTAG_JPEGTABLESMODE,\n                            nJpegTablesModeIn);\n\n        int nBlockSize = nInMemImageWidth * nInMemImageHeight *\n                                        ((nBands <= 4) ? nBands : 1);\n        if( l_nBitsPerSample == 12 )\n            nBlockSize = (nBlockSize * 3) / 2;\n        std::vector<GByte> abyZeroData( nBlockSize, 0 );\n        TIFFWriteEncodedStrip( hTIFFTmp, 0, &abyZeroData[0], nBlockSize);\n\n        uint32 nJPEGTableSize = 0;\n        void* pJPEGTable = nullptr;\n        if( TIFFGetField( hTIFFTmp, TIFFTAG_JPEGTABLES, &nJPEGTableSize,\n                            &pJPEGTable) )\n            TIFFSetField( hTIFF, TIFFTAG_JPEGTABLES, nJPEGTableSize,\n                            pJPEGTable);\n\n        float *ref = nullptr;\n        if( TIFFGetField(hTIFFTmp, TIFFTAG_REFERENCEBLACKWHITE, &ref) )\n            TIFFSetField(hTIFF, TIFFTAG_REFERENCEBLACKWHITE, ref);\n\n        XTIFFClose(hTIFFTmp);\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fpTmp));\n    }\n    VSIUnlink(osTmpFilenameIn);\n#endif\n}\n\n/************************************************************************/\n/*                            GuessJPEGQuality()                        */\n/*                                                                      */\n/*      Guess JPEG quality from JPEGTABLES tag.                         */\n/************************************************************************/\n\nstatic const GByte* GTIFFFindNextTable( const GByte* paby, GByte byMarker,\n                                        int nLen, int* pnLenTable )\n{\n    for( int i = 0; i + 1 < nLen; )\n    {\n        if( paby[i] != 0xFF )\n            return nullptr;\n        ++i;\n        if( paby[i] == 0xD8 )\n        {\n            ++i;\n            continue;\n        }\n        if( i + 2 >= nLen )\n            return nullptr;\n        int nMarkerLen = paby[i+1] * 256 + paby[i+2];\n        if( i+1+nMarkerLen >= nLen )\n            return nullptr;\n        if( paby[i] == byMarker )\n        {\n            if( pnLenTable ) *pnLenTable = nMarkerLen;\n            return paby + i + 1;\n        }\n        i += 1 + nMarkerLen;\n    }\n    return nullptr;\n}\n\n// We assume that if there are several quantization tables, they are\n// in the same order. Which is a reasonable assumption for updating\n// a file generated by ourselves.\nstatic bool GTIFFQuantizationTablesEqual( const GByte* paby1, int nLen1,\n                                          const GByte* paby2, int nLen2 )\n{\n    bool bFound = false;\n    while( true )\n    {\n        int nLenTable1 = 0;\n        int nLenTable2 = 0;\n        const GByte* paby1New =\n            GTIFFFindNextTable(paby1, 0xDB, nLen1, &nLenTable1);\n        const GByte* paby2New =\n            GTIFFFindNextTable(paby2, 0xDB, nLen2, &nLenTable2);\n        if( paby1New == nullptr && paby2New == nullptr )\n            return bFound;\n        if( paby1New == nullptr || paby2New == nullptr )\n            return false;\n        if( nLenTable1 != nLenTable2 )\n            return false;\n        if( memcmp(paby1New, paby2New, nLenTable1) != 0 )\n            return false;\n        paby1New += nLenTable1;\n        paby2New += nLenTable2;\n        nLen1 -= static_cast<int>(paby1New - paby1);\n        nLen2 -= static_cast<int>(paby2New - paby2);\n        paby1 = paby1New;\n        paby2 = paby2New;\n        bFound = true;\n    }\n}\n\nint GTiffDataset::GuessJPEGQuality( bool& bOutHasQuantizationTable,\n                                    bool& bOutHasHuffmanTable )\n{\n    CPLAssert( nCompression == COMPRESSION_JPEG );\n    uint32 nJPEGTableSize = 0;\n    void* pJPEGTable = nullptr;\n    if( !TIFFGetField(hTIFF, TIFFTAG_JPEGTABLES, &nJPEGTableSize, &pJPEGTable) )\n    {\n        bOutHasQuantizationTable = false;\n        bOutHasHuffmanTable = false;\n        return -1;\n    }\n\n    bOutHasQuantizationTable =\n        GTIFFFindNextTable( static_cast<const GByte*>(pJPEGTable), 0xDB,\n                            nJPEGTableSize, nullptr) != nullptr;\n    bOutHasHuffmanTable =\n        GTIFFFindNextTable( static_cast<const GByte*>(pJPEGTable), 0xC4,\n                            nJPEGTableSize, nullptr) != nullptr;\n    if( !bOutHasQuantizationTable )\n        return -1;\n\n    char** papszLocalParameters = nullptr;\n    papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                            \"COMPRESS\", \"JPEG\");\n    if( nPhotometric == PHOTOMETRIC_YCBCR )\n        papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                            \"PHOTOMETRIC\", \"YCBCR\");\n    else if( nPhotometric == PHOTOMETRIC_SEPARATED )\n        papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                            \"PHOTOMETRIC\", \"CMYK\");\n    papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                            \"BLOCKYSIZE\", \"16\");\n    if( nBitsPerSample == 12 )\n        papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                                \"NBITS\", \"12\");\n\n    CPLString osTmpFilenameIn;\n    osTmpFilenameIn.Printf( \"/vsimem/gtiffdataset_guess_jpeg_quality_tmp_%p\",\n                            this );\n\n    int nRet = -1;\n    for( int nQuality = 0; nQuality <= 100 && nRet < 0; ++nQuality )\n    {\n        VSILFILE* fpTmp = nullptr;\n        if( nQuality == 0 )\n            papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                                   \"JPEG_QUALITY\", \"75\");\n        else\n            papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                \"JPEG_QUALITY\", CPLSPrintf(\"%d\", nQuality));\n\n        CPLPushErrorHandler(CPLQuietErrorHandler);\n        CPLString osTmp;\n        TIFF* hTIFFTmp =\n            CreateLL( osTmpFilenameIn, 16, 16, (nBands <= 4) ? nBands : 1,\n                      GetRasterBand(1)->GetRasterDataType(), 0.0,\n                      papszLocalParameters, &fpTmp, osTmp );\n        CPLPopErrorHandler();\n        if( !hTIFFTmp )\n        {\n            break;\n        }\n\n        TIFFWriteCheck( hTIFFTmp, FALSE, \"CreateLL\" );\n        TIFFWriteDirectory( hTIFFTmp );\n        TIFFSetDirectory( hTIFFTmp, 0 );\n        // Now reset jpegcolormode.\n        if( nPhotometric == PHOTOMETRIC_YCBCR\n            && CPLTestBool( CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\",\n                                                \"YES\") ) )\n        {\n            TIFFSetField(hTIFFTmp, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n        }\n\n        GByte abyZeroData[(16*16*4*3)/2] = {};\n        const int nBlockSize =\n            (16 * 16 * ((nBands <= 4) ? nBands : 1) * nBitsPerSample) / 8;\n        TIFFWriteEncodedStrip( hTIFFTmp, 0, abyZeroData, nBlockSize);\n\n        uint32 nJPEGTableSizeTry = 0;\n        void* pJPEGTableTry = nullptr;\n        if( TIFFGetField(hTIFFTmp, TIFFTAG_JPEGTABLES,\n                         &nJPEGTableSizeTry, &pJPEGTableTry) )\n        {\n            if( GTIFFQuantizationTablesEqual(\n                   static_cast<GByte *>(pJPEGTable), nJPEGTableSize,\n                   static_cast<GByte *>(pJPEGTableTry), nJPEGTableSizeTry) )\n            {\n                nRet = (nQuality == 0 ) ? 75 : nQuality;\n            }\n        }\n\n        XTIFFClose(hTIFFTmp);\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fpTmp));\n    }\n\n    CSLDestroy(papszLocalParameters);\n    VSIUnlink(osTmpFilenameIn);\n\n    return nRet;\n}\n\n/************************************************************************/\n/*               SetJPEGQualityAndTablesModeFromFile()                  */\n/************************************************************************/\n\nvoid GTiffDataset::SetJPEGQualityAndTablesModeFromFile()\n{\n    bool bHasQuantizationTable = false;\n    bool bHasHuffmanTable = false;\n    int nQuality = GuessJPEGQuality( bHasQuantizationTable,\n                                     bHasHuffmanTable );\n    if( nQuality > 0 )\n    {\n        CPLDebug(\"GTiff\", \"Guessed JPEG quality to be %d\", nQuality);\n        nJpegQuality = nQuality;\n        TIFFSetField( hTIFF, TIFFTAG_JPEGQUALITY, nQuality );\n\n        // This means we will use the quantization tables from the\n        // JpegTables tag.\n        nJpegTablesMode = JPEGTABLESMODE_QUANT;\n    }\n    else\n    {\n        uint32 nJPEGTableSize = 0;\n        void* pJPEGTable = nullptr;\n        if( !TIFFGetField( hTIFF, TIFFTAG_JPEGTABLES,\n                            &nJPEGTableSize, &pJPEGTable) )\n        {\n            toff_t *panByteCounts = nullptr;\n            const int nBlockCount =\n                nPlanarConfig == PLANARCONFIG_SEPARATE\n                ? nBlocksPerBand * nBands\n                : nBlocksPerBand;\n            if( TIFFIsTiled( hTIFF ) )\n                TIFFGetField( hTIFF, TIFFTAG_TILEBYTECOUNTS,\n                                &panByteCounts );\n            else\n                TIFFGetField( hTIFF, TIFFTAG_STRIPBYTECOUNTS,\n                                &panByteCounts );\n\n            bool bFoundNonEmptyBlock = false;\n            if( panByteCounts != nullptr )\n            {\n                for( int iBlock = 0; iBlock < nBlockCount; ++iBlock )\n                {\n                    if( panByteCounts[iBlock] != 0 )\n                    {\n                        bFoundNonEmptyBlock = true;\n                        break;\n                    }\n                }\n            }\n            if( bFoundNonEmptyBlock )\n            {\n                CPLDebug(\"GTiff\", \"Could not guess JPEG quality. \"\n                            \"JPEG tables are missing, so going in \"\n                            \"TIFFTAG_JPEGTABLESMODE = 0/2 mode\");\n                // Write quantization tables in each strile.\n                nJpegTablesMode = 0;\n            }\n        }\n        else\n        {\n            if( bHasQuantizationTable )\n            {\n                // FIXME in libtiff: this is likely going to cause issues\n                // since libtiff will reuse in each strile the number of\n                // the global quantization table, which is invalid.\n                CPLDebug(\n                    \"GTiff\", \"Could not guess JPEG quality although JPEG \"\n                    \"quantization tables are present, so going in \"\n                    \"TIFFTAG_JPEGTABLESMODE = 0/2 mode\" );\n            }\n            else\n            {\n                CPLDebug(\"GTiff\", \"Could not guess JPEG quality since JPEG \"\n                        \"quantization tables are not present, so going in \"\n                        \"TIFFTAG_JPEGTABLESMODE = 0/2 mode\");\n            }\n\n            // Write quantization tables in each strile.\n            nJpegTablesMode = 0;\n        }\n    }\n    if( bHasHuffmanTable )\n    {\n        // If there are Huffman tables in header use them, otherwise\n        // if we use optimized tables, libtiff will currently reuse\n        // the number of the Huffman tables of the header for the\n        // optimized version of each strile, which is illegal.\n        nJpegTablesMode |= JPEGTABLESMODE_HUFF;\n    }\n    if( nJpegTablesMode >= 0 )\n        TIFFSetField( hTIFF, TIFFTAG_JPEGTABLESMODE,\n                        nJpegTablesMode);\n}\n\n/************************************************************************/\n/*                               Create()                               */\n/*                                                                      */\n/*      Create a new GeoTIFF or TIFF file.                              */\n/************************************************************************/\n\nGDALDataset *GTiffDataset::Create( const char * pszFilename,\n                                   int nXSize, int nYSize, int l_nBands,\n                                   GDALDataType eType,\n                                   char **papszParmList )\n\n{\n    VSILFILE* l_fpL = nullptr;\n    CPLString l_osTmpFilename;\n\n/* -------------------------------------------------------------------- */\n/*      Create the underlying TIFF file.                                */\n/* -------------------------------------------------------------------- */\n    TIFF *l_hTIFF = CreateLL(\n        pszFilename,\n        nXSize, nYSize, l_nBands,\n        eType, 0, papszParmList, &l_fpL, l_osTmpFilename );\n    const bool bStreaming = !l_osTmpFilename.empty();\n\n    if( l_hTIFF == nullptr )\n        return nullptr;\n\n/* -------------------------------------------------------------------- */\n/*      Create the new GTiffDataset object.                             */\n/* -------------------------------------------------------------------- */\n    GTiffDataset *poDS = new GTiffDataset();\n    poDS->hTIFF = l_hTIFF;\n    poDS->fpL = l_fpL;\n    if( bStreaming )\n    {\n        poDS->bStreamingOut = true;\n        poDS->osTmpFilename = l_osTmpFilename;\n        poDS->fpToWrite = VSIFOpenL( pszFilename, \"wb\" );\n        if( poDS->fpToWrite == nullptr )\n        {\n            VSIUnlink(l_osTmpFilename);\n            delete poDS;\n            return nullptr;\n        }\n    }\n    poDS->poActiveDS = poDS;\n    poDS->ppoActiveDSRef = &(poDS->poActiveDS);\n\n    poDS->nRasterXSize = nXSize;\n    poDS->nRasterYSize = nYSize;\n    poDS->eAccess = GA_Update;\n    poDS->bCrystalized = false;\n    poDS->nSamplesPerPixel = static_cast<uint16>(l_nBands);\n    poDS->osFilename = pszFilename;\n\n    // Don't try to load external metadata files (#6597).\n    poDS->bIMDRPCMetadataLoaded = true;\n\n    // Avoid premature crystalization that will cause directory re-writing if\n    // GetProjectionRef() or GetGeoTransform() are called on the newly created\n    // GeoTIFF.\n    poDS->bLookedForProjection = true;\n\n    TIFFGetField( l_hTIFF, TIFFTAG_SAMPLEFORMAT, &(poDS->nSampleFormat) );\n    TIFFGetField( l_hTIFF, TIFFTAG_PLANARCONFIG, &(poDS->nPlanarConfig) );\n    // Weird that we need this, but otherwise we get a Valgrind warning on\n    // tiff_write_124.\n    if( !TIFFGetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, &(poDS->nPhotometric) ) )\n        poDS->nPhotometric = PHOTOMETRIC_MINISBLACK;\n    TIFFGetField( l_hTIFF, TIFFTAG_BITSPERSAMPLE, &(poDS->nBitsPerSample) );\n    TIFFGetField( l_hTIFF, TIFFTAG_COMPRESSION, &(poDS->nCompression) );\n\n    if( TIFFIsTiled(l_hTIFF) )\n    {\n        TIFFGetField( l_hTIFF, TIFFTAG_TILEWIDTH, &(poDS->nBlockXSize) );\n        TIFFGetField( l_hTIFF, TIFFTAG_TILELENGTH, &(poDS->nBlockYSize) );\n    }\n    else\n    {\n        if( !TIFFGetField( l_hTIFF, TIFFTAG_ROWSPERSTRIP,\n                           &(poDS->nRowsPerStrip) ) )\n            poDS->nRowsPerStrip = 1;  // Dummy value.\n\n        poDS->nBlockXSize = nXSize;\n        poDS->nBlockYSize =\n            std::min( static_cast<int>(poDS->nRowsPerStrip) , nYSize );\n    }\n\n    poDS->nBlocksPerBand =\n        DIV_ROUND_UP(nYSize, poDS->nBlockYSize)\n        * DIV_ROUND_UP(nXSize, poDS->nBlockXSize);\n\n    if( CSLFetchNameValue( papszParmList, \"PROFILE\" ) != nullptr )\n        poDS->osProfile = CSLFetchNameValue( papszParmList, \"PROFILE\" );\n\n/* -------------------------------------------------------------------- */\n/*      YCbCr JPEG compressed images should be translated on the fly    */\n/*      to RGB by libtiff/libjpeg unless specifically requested         */\n/*      otherwise.                                                      */\n/* -------------------------------------------------------------------- */\n    if( poDS->nCompression == COMPRESSION_JPEG\n        && poDS->nPhotometric == PHOTOMETRIC_YCBCR\n        && CPLTestBool( CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\", \"YES\") ) )\n    {\n        int nColorMode = 0;\n\n        poDS->SetMetadataItem(\"SOURCE_COLOR_SPACE\", \"YCbCr\", \"IMAGE_STRUCTURE\");\n        if( !TIFFGetField( l_hTIFF, TIFFTAG_JPEGCOLORMODE, &nColorMode ) ||\n            nColorMode != JPEGCOLORMODE_RGB )\n            TIFFSetField(l_hTIFF, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n    }\n\n#ifdef HAVE_LERC\n    if( poDS->nCompression == COMPRESSION_LERC )\n    {\n        uint32 nLercParamCount = 0;\n        uint32* panLercParms = nullptr;\n        if( TIFFGetField( l_hTIFF, TIFFTAG_LERC_PARAMETERS, &nLercParamCount,\n                          &panLercParms ) &&\n            nLercParamCount == 2 )\n        {\n            memcpy( poDS->anLercAddCompressionAndVersion, panLercParms,\n                    sizeof(poDS->anLercAddCompressionAndVersion) );\n        }\n    }\n#endif\n\n/* -------------------------------------------------------------------- */\n/*      Read palette back as a color table if it has one.               */\n/* -------------------------------------------------------------------- */\n    unsigned short *panRed = nullptr;\n    unsigned short *panGreen = nullptr;\n    unsigned short *panBlue = nullptr;\n\n    if( poDS->nPhotometric == PHOTOMETRIC_PALETTE\n        && TIFFGetField( l_hTIFF, TIFFTAG_COLORMAP,\n                         &panRed, &panGreen, &panBlue) )\n    {\n\n        poDS->poColorTable = new GDALColorTable();\n\n        const int nColorCount = 1 << poDS->nBitsPerSample;\n\n        for( int iColor = nColorCount - 1; iColor >= 0; iColor-- )\n        {\n            const unsigned short divisor = 257;\n            const GDALColorEntry oEntry = {\n                static_cast<short>(panRed[iColor] / divisor),\n                static_cast<short>(panGreen[iColor] / divisor),\n                static_cast<short>(panBlue[iColor] / divisor),\n                static_cast<short>(255)\n            };\n\n            poDS->poColorTable->SetColorEntry( iColor, &oEntry );\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Do we want to ensure all blocks get written out on close to     */\n/*      avoid sparse files?                                             */\n/* -------------------------------------------------------------------- */\n    if( !CPLFetchBool( papszParmList, \"SPARSE_OK\", false ) )\n        poDS->bFillEmptyTilesAtClosing = true;\n\n    poDS->bWriteEmptyTiles = bStreaming ||\n        (poDS->nCompression != COMPRESSION_NONE &&\n         poDS->bFillEmptyTilesAtClosing);\n    // Only required for people writing non-compressed stripped files in the\n    // right order and wanting all tstrips to be written in the same order\n    // so that the end result can be memory mapped without knowledge of each\n    // strip offset.\n    if( CPLTestBool( CSLFetchNameValueDef( papszParmList,\n                              \"WRITE_EMPTY_TILES_SYNCHRONOUSLY\", \"FALSE\" )) ||\n         CPLTestBool( CSLFetchNameValueDef( papszParmList,\n                              \"@WRITE_EMPTY_TILES_SYNCHRONOUSLY\", \"FALSE\" )) )\n    {\n        poDS->bWriteEmptyTiles = true;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Preserve creation options for consulting later (for instance    */\n/*      to decide if a TFW file should be written).                     */\n/* -------------------------------------------------------------------- */\n    poDS->papszCreationOptions = CSLDuplicate( papszParmList );\n\n    poDS->nZLevel = GTiffGetZLevel(papszParmList);\n    poDS->nLZMAPreset = GTiffGetLZMAPreset(papszParmList);\n    poDS->nZSTDLevel = GTiffGetZSTDPreset(papszParmList);\n    poDS->nWebPLevel = GTiffGetWebPLevel(papszParmList);\n    poDS->bWebPLossless = GTiffGetWebPLossless(papszParmList);\n    poDS->nJpegQuality = GTiffGetJpegQuality(papszParmList);\n    poDS->nJpegTablesMode = GTiffGetJpegTablesMode(papszParmList);\n#if HAVE_LERC\n    poDS->dfMaxZError = GTiffGetLERCMaxZError(papszParmList);\n#endif\n    poDS->InitCreationOrOpenOptions(papszParmList);\n\n#if !defined(BIGTIFF_SUPPORT)\n/* -------------------------------------------------------------------- */\n/*      If we are writing jpeg compression we need to write some        */\n/*      imagery to force the jpegtables to get created.  This is,       */\n/*      likely only needed with libtiff >= 3.9.3 (#3633)                */\n/* -------------------------------------------------------------------- */\n    if( poDS->nCompression == COMPRESSION_JPEG\n        && strstr(TIFFLIB_VERSION_STR, \"Version 3.9\") != nullptr )\n    {\n        CPLDebug( \"GDAL\",\n                  \"Writing zero block to force creation of JPEG tables.\" );\n        if( TIFFIsTiled( l_hTIFF ) )\n        {\n            const int cc = TIFFTileSize( l_hTIFF );\n            unsigned char *pabyZeros =\n                static_cast<unsigned char *>(CPLCalloc(cc, 1));\n            TIFFWriteEncodedTile(l_hTIFF, 0, pabyZeros, cc);\n            CPLFree( pabyZeros );\n        }\n        else\n        {\n            const int cc = TIFFStripSize( l_hTIFF );\n            unsigned char *pabyZeros =\n                static_cast<unsigned char *>(CPLCalloc(cc, 1));\n            TIFFWriteEncodedStrip(l_hTIFF, 0, pabyZeros, cc);\n            CPLFree( pabyZeros );\n        }\n        poDS->bDontReloadFirstBlock = true;\n    }\n#endif\n\n/* -------------------------------------------------------------------- */\n/*      Create band information objects.                                */\n/* -------------------------------------------------------------------- */\n    for( int iBand = 0; iBand < l_nBands; ++iBand )\n    {\n        if( poDS->nBitsPerSample == 8 ||\n            (poDS->nBitsPerSample == 16 && eType != GDT_Float32) ||\n            poDS->nBitsPerSample == 32 ||\n            poDS->nBitsPerSample == 64 ||\n            poDS->nBitsPerSample == 128)\n        {\n            poDS->SetBand( iBand + 1, new GTiffRasterBand( poDS, iBand + 1 ) );\n        }\n        else\n        {\n            poDS->SetBand( iBand + 1, new GTiffOddBitsBand( poDS, iBand + 1 ) );\n            poDS->GetRasterBand( iBand + 1 )->\n                SetMetadataItem( \"NBITS\",\n                                 CPLString().Printf(\"%d\",poDS->nBitsPerSample),\n                                 \"IMAGE_STRUCTURE\" );\n        }\n    }\n\n    poDS->GetDiscardLsbOption(papszParmList);\n\n    if( poDS->nPlanarConfig == PLANARCONFIG_CONTIG && l_nBands != 1 )\n        poDS->SetMetadataItem( \"INTERLEAVE\", \"PIXEL\", \"IMAGE_STRUCTURE\" );\n    else\n        poDS->SetMetadataItem( \"INTERLEAVE\", \"BAND\", \"IMAGE_STRUCTURE\" );\n\n    poDS->oOvManager.Initialize( poDS, pszFilename );\n\n    return poDS;\n}\n\n/************************************************************************/\n/*                             CreateCopy()                             */\n/************************************************************************/\n\nGDALDataset *\nGTiffDataset::CreateCopy( const char * pszFilename, GDALDataset *poSrcDS,\n                          int bStrict, char ** papszOptions,\n                          GDALProgressFunc pfnProgress, void * pProgressData )\n\n{\n    if( poSrcDS->GetRasterCount() == 0 )\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                  \"Unable to export GeoTIFF files with zero bands.\" );\n        return nullptr;\n    }\n\n    GDALRasterBand * const poPBand = poSrcDS->GetRasterBand(1);\n    const GDALDataType eType = poPBand->GetRasterDataType();\n\n/* -------------------------------------------------------------------- */\n/*      Check, whether all bands in input dataset has the same type.    */\n/* -------------------------------------------------------------------- */\n    const int l_nBands = poSrcDS->GetRasterCount();\n    for( int iBand = 2; iBand <= l_nBands; ++iBand )\n    {\n        if( eType != poSrcDS->GetRasterBand(iBand)->GetRasterDataType() )\n        {\n            if( bStrict )\n            {\n                CPLError(\n                    CE_Failure, CPLE_AppDefined,\n                    \"Unable to export GeoTIFF file with different datatypes \"\n                    \"per different bands. All bands should have the same \"\n                    \"types in TIFF.\" );\n                return nullptr;\n            }\n            else\n            {\n                CPLError(\n                    CE_Warning, CPLE_AppDefined,\n                    \"Unable to export GeoTIFF file with different datatypes \"\n                    \"per different bands. All bands should have the same \"\n                    \"types in TIFF.\" );\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Capture the profile.                                            */\n/* -------------------------------------------------------------------- */\n    const char *pszProfile = CSLFetchNameValue(papszOptions, \"PROFILE\");\n    if( pszProfile == nullptr )\n        pszProfile = szPROFILE_GDALGeoTIFF;\n\n    if( !EQUAL(pszProfile, szPROFILE_BASELINE)\n        && !EQUAL(pszProfile, szPROFILE_GeoTIFF)\n        && !EQUAL(pszProfile, szPROFILE_GDALGeoTIFF) )\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                  \"PROFILE=%s not supported in GTIFF driver.\",\n                  pszProfile );\n        return nullptr;\n    }\n\n    const bool bGeoTIFF = !EQUAL(pszProfile, szPROFILE_BASELINE);\n\n/* -------------------------------------------------------------------- */\n/*      Special handling for NBITS.  Copy from band metadata if found.  */\n/* -------------------------------------------------------------------- */\n    char **papszCreateOptions = CSLDuplicate( papszOptions );\n\n    if( poPBand->GetMetadataItem( \"NBITS\", \"IMAGE_STRUCTURE\" ) != nullptr\n        && atoi(poPBand->GetMetadataItem( \"NBITS\", \"IMAGE_STRUCTURE\" )) > 0\n        && CSLFetchNameValue( papszCreateOptions, \"NBITS\") == nullptr )\n    {\n        papszCreateOptions =\n            CSLSetNameValue( papszCreateOptions, \"NBITS\",\n                             poPBand->GetMetadataItem( \"NBITS\",\n                                                       \"IMAGE_STRUCTURE\" ) );\n    }\n\n    if( CSLFetchNameValue( papszOptions, \"PIXELTYPE\" ) == nullptr\n        && eType == GDT_Byte\n        && poPBand->GetMetadataItem( \"PIXELTYPE\", \"IMAGE_STRUCTURE\" ) )\n    {\n        papszCreateOptions =\n            CSLSetNameValue( papszCreateOptions, \"PIXELTYPE\",\n                             poPBand->GetMetadataItem(\n                                 \"PIXELTYPE\", \"IMAGE_STRUCTURE\" ) );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Color profile.  Copy from band metadata if found.              */\n/* -------------------------------------------------------------------- */\n    if( bGeoTIFF )\n    {\n        const char* pszOptionsMD[] = {\n            \"SOURCE_ICC_PROFILE\",\n            \"SOURCE_PRIMARIES_RED\",\n            \"SOURCE_PRIMARIES_GREEN\",\n            \"SOURCE_PRIMARIES_BLUE\",\n            \"SOURCE_WHITEPOINT\",\n            \"TIFFTAG_TRANSFERFUNCTION_RED\",\n            \"TIFFTAG_TRANSFERFUNCTION_GREEN\",\n            \"TIFFTAG_TRANSFERFUNCTION_BLUE\",\n            \"TIFFTAG_TRANSFERRANGE_BLACK\",\n            \"TIFFTAG_TRANSFERRANGE_WHITE\",\n            nullptr\n        };\n\n        // Copy all the tags.  Options will override tags in the source.\n        int i = 0;\n        while(pszOptionsMD[i] != nullptr)\n        {\n            char const *pszMD =\n                CSLFetchNameValue(papszOptions, pszOptionsMD[i]);\n            if( pszMD == nullptr )\n                pszMD = poSrcDS->GetMetadataItem( pszOptionsMD[i],\n                                                  \"COLOR_PROFILE\" );\n\n            if( (pszMD != nullptr) && !EQUAL(pszMD, \"\") )\n            {\n                papszCreateOptions =\n                    CSLSetNameValue( papszCreateOptions, pszOptionsMD[i],\n                                     pszMD );\n\n                // If an ICC profile exists, other tags are not needed.\n                if( EQUAL(pszOptionsMD[i], \"SOURCE_ICC_PROFILE\") )\n                    break;\n            }\n\n            ++i;\n        }\n    }\n\n    double dfExtraSpaceForOverviews = 0;\n    if( CPLFetchBool(papszOptions, \"COPY_SRC_OVERVIEWS\", false) )\n    {\n        const int nSrcOverviews = poSrcDS->GetRasterBand(1)->GetOverviewCount();\n        if( nSrcOverviews )\n        {\n            for( int j = 1; j <= l_nBands; ++j )\n            {\n                if( poSrcDS->GetRasterBand(j)->GetOverviewCount() !=\n                                                        nSrcOverviews )\n                {\n                    CPLError(\n                        CE_Failure, CPLE_NotSupported,\n                        \"COPY_SRC_OVERVIEWS cannot be used when the bands have \"\n                        \"not the same number of overview levels.\" );\n                    CSLDestroy(papszCreateOptions);\n                    return nullptr;\n                }\n                for( int i = 0; i < nSrcOverviews; ++i )\n                {\n                    GDALRasterBand* poOvrBand =\n                        poSrcDS->GetRasterBand(j)->GetOverview(i);\n                    if( poOvrBand == nullptr )\n                    {\n                        CPLError(\n                            CE_Failure, CPLE_NotSupported,\n                            \"COPY_SRC_OVERVIEWS cannot be used when one \"\n                            \"overview band is NULL.\" );\n                        CSLDestroy(papszCreateOptions);\n                        return nullptr;\n                    }\n                    GDALRasterBand* poOvrFirstBand =\n                        poSrcDS->GetRasterBand(1)->GetOverview(i);\n                    if( poOvrBand->GetXSize() != poOvrFirstBand->GetXSize() ||\n                        poOvrBand->GetYSize() != poOvrFirstBand->GetYSize() )\n                    {\n                        CPLError(\n                            CE_Failure, CPLE_NotSupported,\n                            \"COPY_SRC_OVERVIEWS cannot be used when the \"\n                            \"overview bands have not the same dimensions \"\n                            \"among bands.\" );\n                        CSLDestroy(papszCreateOptions);\n                        return nullptr;\n                    }\n                }\n            }\n\n            for( int i = 0; i < nSrcOverviews; ++i )\n            {\n                dfExtraSpaceForOverviews +=\n                    static_cast<double>(\n                      poSrcDS->GetRasterBand(1)->GetOverview(i)->GetXSize() ) *\n                      poSrcDS->GetRasterBand(1)->GetOverview(i)->GetYSize();\n            }\n            dfExtraSpaceForOverviews *=\n                                l_nBands * GDALGetDataTypeSizeBytes(eType);\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Should we use optimized way of copying from an input JPEG       */\n/*      dataset?                                                        */\n/* -------------------------------------------------------------------- */\n\n// TODO(schwehr): Refactor bDirectCopyFromJPEG to be a const.\n#if defined(HAVE_LIBJPEG) || defined(JPEG_DIRECT_COPY)\n    bool bDirectCopyFromJPEG = false;\n#endif\n\n    // Note: JPEG_DIRECT_COPY is not defined by default, because it is mainly\n    // useful for debugging purposes.\n#ifdef JPEG_DIRECT_COPY\n    if( CPLFetchBool(papszCreateOptions, \"JPEG_DIRECT_COPY\", false) &&\n        GTIFF_CanDirectCopyFromJPEG(poSrcDS, papszCreateOptions) )\n    {\n        CPLDebug(\"GTiff\", \"Using special direct copy mode from a JPEG dataset\");\n\n        bDirectCopyFromJPEG = true;\n    }\n#endif\n\n#ifdef HAVE_LIBJPEG\n    bool bCopyFromJPEG = false;\n\n    // When CreateCopy'ing() from a JPEG dataset, and asking for COMPRESS=JPEG,\n    // use DCT coefficients (unless other options are incompatible, like\n    // strip/tile dimensions, specifying JPEG_QUALITY option, incompatible\n    // PHOTOMETRIC with the source colorspace, etc.) to avoid the lossy steps\n    // involved by decompression/recompression.\n    if( !bDirectCopyFromJPEG &&\n        GTIFF_CanCopyFromJPEG(poSrcDS, papszCreateOptions) )\n    {\n        CPLDebug( \"GTiff\", \"Using special copy mode from a JPEG dataset\" );\n\n        bCopyFromJPEG = true;\n    }\n#endif\n\n/* -------------------------------------------------------------------- */\n/*      If the source is RGB, then set the PHOTOMETRIC=RGB value        */\n/* -------------------------------------------------------------------- */\n\n    const bool bForcePhotometric =\n        CSLFetchNameValue(papszOptions, \"PHOTOMETRIC\") != nullptr;\n\n    if( l_nBands >= 3 && !bForcePhotometric &&\n#ifdef HAVE_LIBJPEG\n        !bCopyFromJPEG &&\n#endif\n        poSrcDS->GetRasterBand(1)->GetColorInterpretation() == GCI_RedBand &&\n        poSrcDS->GetRasterBand(2)->GetColorInterpretation() == GCI_GreenBand &&\n        poSrcDS->GetRasterBand(3)->GetColorInterpretation() == GCI_BlueBand )\n    {\n        papszCreateOptions =\n            CSLSetNameValue( papszCreateOptions, \"PHOTOMETRIC\", \"RGB\" );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Create the file.                                                */\n/* -------------------------------------------------------------------- */\n    VSILFILE* l_fpL = nullptr;\n    CPLString l_osTmpFilename;\n\n    const int nXSize = poSrcDS->GetRasterXSize();\n    const int nYSize = poSrcDS->GetRasterYSize();\n    TIFF *l_hTIFF =\n        CreateLL( pszFilename, nXSize, nYSize, l_nBands,\n                  eType, dfExtraSpaceForOverviews, papszCreateOptions, &l_fpL,\n                  l_osTmpFilename );\n    const bool bStreaming = !l_osTmpFilename.empty();\n\n    CSLDestroy( papszCreateOptions );\n    papszCreateOptions = nullptr;\n\n    if( l_hTIFF == nullptr )\n    {\n        if( bStreaming ) VSIUnlink(l_osTmpFilename);\n        return nullptr;\n    }\n\n    uint16 l_nPlanarConfig = 0;\n    TIFFGetField( l_hTIFF, TIFFTAG_PLANARCONFIG, &l_nPlanarConfig );\n\n    uint16 l_nBitsPerSample = 0;\n    TIFFGetField(l_hTIFF, TIFFTAG_BITSPERSAMPLE, &l_nBitsPerSample );\n\n    uint16 l_nCompression = 0;\n\n    if( !TIFFGetField( l_hTIFF, TIFFTAG_COMPRESSION, &(l_nCompression) ) )\n        l_nCompression = COMPRESSION_NONE;\n\n/* -------------------------------------------------------------------- */\n/*      Set the alpha channel if it is the last one.                    */\n/* -------------------------------------------------------------------- */\n    if( poSrcDS->GetRasterBand(l_nBands)->GetColorInterpretation() ==\n        GCI_AlphaBand )\n    {\n        uint16 *v = nullptr;\n        uint16 count = 0;\n        if( TIFFGetField( l_hTIFF, TIFFTAG_EXTRASAMPLES, &count, &v ) )\n        {\n            const int nBaseSamples = l_nBands - count;\n            if( l_nBands > nBaseSamples && l_nBands - nBaseSamples - 1 < count )\n            {\n                // We need to allocate a new array as (current) libtiff\n                // versions will not like that we reuse the array we got from\n                // TIFFGetField().\n\n                uint16* pasNewExtraSamples =\n                    static_cast<uint16 *>(\n                        CPLMalloc( count * sizeof(uint16) ) );\n                memcpy( pasNewExtraSamples, v, count * sizeof(uint16) );\n                pasNewExtraSamples[l_nBands - nBaseSamples - 1] =\n                    GTiffGetAlphaValue(\n                        CPLGetConfigOption(\n                            \"GTIFF_ALPHA\",\n                            CSLFetchNameValue(papszOptions,\"ALPHA\") ),\n                        DEFAULT_ALPHA_TYPE);\n\n                TIFFSetField( l_hTIFF, TIFFTAG_EXTRASAMPLES, count,\n                              pasNewExtraSamples);\n\n                CPLFree(pasNewExtraSamples);\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If the output is jpeg compressed, and the input is RGB make     */\n/*      sure we note that.                                              */\n/* -------------------------------------------------------------------- */\n\n    if( l_nCompression == COMPRESSION_JPEG )\n    {\n        if( l_nBands >= 3\n            && (poSrcDS->GetRasterBand(1)->GetColorInterpretation()\n                == GCI_YCbCr_YBand)\n            && (poSrcDS->GetRasterBand(2)->GetColorInterpretation()\n                == GCI_YCbCr_CbBand)\n            && (poSrcDS->GetRasterBand(3)->GetColorInterpretation()\n                == GCI_YCbCr_CrBand) )\n        {\n            // Do nothing.\n        }\n        else\n        {\n            // Assume RGB if it is not explicitly YCbCr.\n            CPLDebug( \"GTiff\", \"Setting JPEGCOLORMODE_RGB\" );\n            TIFFSetField( l_hTIFF, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB );\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Does the source image consist of one band, with a palette?      */\n/*      If so, copy over.                                               */\n/* -------------------------------------------------------------------- */\n    if( (l_nBands == 1 || l_nBands == 2) &&\n        poSrcDS->GetRasterBand(1)->GetColorTable() != nullptr\n        && eType == GDT_Byte )\n    {\n        unsigned short anTRed[256] = { 0 };\n        unsigned short anTGreen[256] = { 0 };\n        unsigned short anTBlue[256] = { 0 };\n        GDALColorTable *poCT = poSrcDS->GetRasterBand(1)->GetColorTable();\n\n        for( int iColor = 0; iColor < 256; ++iColor )\n        {\n            if( iColor < poCT->GetColorEntryCount() )\n            {\n                GDALColorEntry sRGB = { 0, 0, 0, 0 };\n\n                poCT->GetColorEntryAsRGB( iColor, &sRGB );\n\n                anTRed[iColor] = static_cast<unsigned short>(257 * sRGB.c1);\n                anTGreen[iColor] = static_cast<unsigned short>(257 * sRGB.c2);\n                anTBlue[iColor] = static_cast<unsigned short>(257 * sRGB.c3);\n            }\n            else\n            {\n                anTRed[iColor] = 0;\n                anTGreen[iColor] = 0;\n                anTBlue[iColor] = 0;\n            }\n        }\n\n        if( !bForcePhotometric )\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_PALETTE );\n        TIFFSetField( l_hTIFF, TIFFTAG_COLORMAP, anTRed, anTGreen, anTBlue );\n    }\n    else if( (l_nBands == 1 || l_nBands == 2)\n             && poSrcDS->GetRasterBand(1)->GetColorTable() != nullptr\n             && eType == GDT_UInt16 )\n    {\n        unsigned short *panTRed = static_cast<unsigned short *>(\n            CPLMalloc(65536 * sizeof(unsigned short)) );\n        unsigned short *panTGreen = static_cast<unsigned short *>(\n            CPLMalloc(65536 * sizeof(unsigned short)) );\n        unsigned short *panTBlue = static_cast<unsigned short *>(\n            CPLMalloc(65536 * sizeof(unsigned short)) );\n\n        GDALColorTable *poCT = poSrcDS->GetRasterBand(1)->GetColorTable();\n\n        for( int iColor = 0; iColor < 65536; ++iColor )\n        {\n            if( iColor < poCT->GetColorEntryCount() )\n            {\n                GDALColorEntry sRGB = { 0, 0, 0, 0 };\n\n                poCT->GetColorEntryAsRGB( iColor, &sRGB );\n\n                panTRed[iColor] = static_cast<unsigned short>(257 * sRGB.c1);\n                panTGreen[iColor] = static_cast<unsigned short>(257 * sRGB.c2);\n                panTBlue[iColor] = static_cast<unsigned short>(257 * sRGB.c3);\n            }\n            else\n            {\n                panTRed[iColor] = 0;\n                panTGreen[iColor] = 0;\n                panTBlue[iColor] = 0;\n            }\n        }\n\n        if( !bForcePhotometric )\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_PALETTE );\n        TIFFSetField( l_hTIFF, TIFFTAG_COLORMAP, panTRed, panTGreen, panTBlue );\n\n        CPLFree( panTRed );\n        CPLFree( panTGreen );\n        CPLFree( panTBlue );\n    }\n    else if( poSrcDS->GetRasterBand(1)->GetColorTable() != nullptr )\n        CPLError(\n            CE_Warning, CPLE_AppDefined,\n            \"Unable to export color table to GeoTIFF file.  Color tables \"\n            \"can only be written to 1 band or 2 bands Byte or \"\n            \"UInt16 GeoTIFF files.\" );\n\n    if( l_nBands == 2\n        && poSrcDS->GetRasterBand(1)->GetColorTable() != nullptr\n        && (eType == GDT_Byte || eType == GDT_UInt16) )\n    {\n        uint16 v[1] = { EXTRASAMPLE_UNASSALPHA };\n\n        TIFFSetField(l_hTIFF, TIFFTAG_EXTRASAMPLES, 1, v );\n    }\n\n    // FIXME? libtiff writes extended tags in the order they are specified\n    // and not in increasing order.\n\n/* -------------------------------------------------------------------- */\n/*      Transfer some TIFF specific metadata, if available.             */\n/*      The return value will tell us if we need to try again later with*/\n/*      PAM because the profile doesn't allow to write some metadata    */\n/*      as TIFF tag                                                     */\n/* -------------------------------------------------------------------- */\n    const bool bHasWrittenMDInGeotiffTAG =\n            GTiffDataset::WriteMetadata( poSrcDS, l_hTIFF, false, pszProfile,\n                                         pszFilename, papszOptions );\n\n/* -------------------------------------------------------------------- */\n/*      Write NoData value, if exist.                                   */\n/* -------------------------------------------------------------------- */\n    if( EQUAL(pszProfile,szPROFILE_GDALGeoTIFF) )\n    {\n        int bSuccess = FALSE;\n        const double dfNoData =\n            poSrcDS->GetRasterBand(1)->GetNoDataValue( &bSuccess );\n        if( bSuccess )\n            GTiffDataset::WriteNoDataValue( l_hTIFF, dfNoData );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Are we addressing PixelIsPoint mode?                            */\n/* -------------------------------------------------------------------- */\n    bool bPixelIsPoint = false;\n    bool bPointGeoIgnore = false;\n\n    if( poSrcDS->GetMetadataItem( GDALMD_AREA_OR_POINT )\n        && EQUAL(poSrcDS->GetMetadataItem(GDALMD_AREA_OR_POINT),\n                 GDALMD_AOP_POINT) )\n    {\n        bPixelIsPoint = true;\n        bPointGeoIgnore =\n            CPLTestBool( CPLGetConfigOption( \"GTIFF_POINT_GEO_IGNORE\",\n                                             \"FALSE\") );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Write affine transform if it is meaningful.                     */\n/* -------------------------------------------------------------------- */\n    const char *l_pszProjection = nullptr;\n    double l_adfGeoTransform[6] = { 0.0 };\n\n    if( poSrcDS->GetGeoTransform( l_adfGeoTransform ) == CE_None )\n    {\n        if( bGeoTIFF )\n        {\n            l_pszProjection = poSrcDS->GetProjectionRef();\n\n            if( l_adfGeoTransform[2] == 0.0 && l_adfGeoTransform[4] == 0.0\n                && l_adfGeoTransform[5] < 0.0 )\n            {\n                double dfOffset = 0.0;\n                {\n                    // In the case the SRS has a vertical component and we have\n                    // a single band, encode its scale/offset in the GeoTIFF tags\n                    int bHasScale = FALSE;\n                    double dfScale =\n                        poSrcDS->GetRasterBand(1)->GetScale(&bHasScale);\n                    int bHasOffset = FALSE;\n                    dfOffset =\n                        poSrcDS->GetRasterBand(1)->GetOffset(&bHasOffset);\n                    const bool bApplyScaleOffset =\n                        HasVerticalCS(l_pszProjection) &&\n                        poSrcDS->GetRasterCount() == 1;\n                    if( bApplyScaleOffset && !bHasScale )\n                        dfScale = 1.0;\n                    if( !bApplyScaleOffset || !bHasOffset )\n                        dfOffset = 0.0;\n                    const double adfPixelScale[3] = {\n                        l_adfGeoTransform[1], fabs(l_adfGeoTransform[5]),\n                        bApplyScaleOffset ? dfScale : 0.0 };\n\n                    TIFFSetField( l_hTIFF, TIFFTAG_GEOPIXELSCALE, 3,\n                                  adfPixelScale );\n                }\n\n                double adfTiePoints[6] = {\n                    0.0,\n                    0.0,\n                    0.0,\n                    l_adfGeoTransform[0],\n                    l_adfGeoTransform[3],\n                    dfOffset\n                };\n\n                if( bPixelIsPoint && !bPointGeoIgnore )\n                {\n                    adfTiePoints[3] +=\n                        l_adfGeoTransform[1] * 0.5 + l_adfGeoTransform[2] * 0.5;\n                    adfTiePoints[4] +=\n                        l_adfGeoTransform[4] * 0.5 + l_adfGeoTransform[5] * 0.5;\n                }\n\n                TIFFSetField( l_hTIFF, TIFFTAG_GEOTIEPOINTS, 6, adfTiePoints );\n            }\n            else\n            {\n                double adfMatrix[16] = { 0.0 };\n\n                adfMatrix[0] = l_adfGeoTransform[1];\n                adfMatrix[1] = l_adfGeoTransform[2];\n                adfMatrix[3] = l_adfGeoTransform[0];\n                adfMatrix[4] = l_adfGeoTransform[4];\n                adfMatrix[5] = l_adfGeoTransform[5];\n                adfMatrix[7] = l_adfGeoTransform[3];\n                adfMatrix[15] = 1.0;\n\n                if( bPixelIsPoint && !bPointGeoIgnore )\n                {\n                    adfMatrix[3] +=\n                        l_adfGeoTransform[1] * 0.5 + l_adfGeoTransform[2] * 0.5;\n                    adfMatrix[7] +=\n                        l_adfGeoTransform[4] * 0.5 + l_adfGeoTransform[5] * 0.5;\n                }\n\n                TIFFSetField( l_hTIFF, TIFFTAG_GEOTRANSMATRIX, 16, adfMatrix );\n            }\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Do we need a TFW file?                                          */\n/* -------------------------------------------------------------------- */\n        if( CPLFetchBool( papszOptions, \"TFW\", false ) )\n            GDALWriteWorldFile( pszFilename, \"tfw\", l_adfGeoTransform );\n        else if( CPLFetchBool( papszOptions, \"WORLDFILE\", false ) )\n            GDALWriteWorldFile( pszFilename, \"wld\", l_adfGeoTransform );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Otherwise write tiepoints if they are available.                */\n/* -------------------------------------------------------------------- */\n    else if( poSrcDS->GetGCPCount() > 0 && bGeoTIFF )\n    {\n        const GDAL_GCP *pasGCPs = poSrcDS->GetGCPs();\n        double *padfTiePoints = static_cast<double *>(\n            CPLMalloc(6 * sizeof(double) * poSrcDS->GetGCPCount()) );\n\n        for( int iGCP = 0; iGCP < poSrcDS->GetGCPCount(); ++iGCP )\n        {\n\n            padfTiePoints[iGCP*6+0] = pasGCPs[iGCP].dfGCPPixel;\n            padfTiePoints[iGCP*6+1] = pasGCPs[iGCP].dfGCPLine;\n            padfTiePoints[iGCP*6+2] = 0;\n            padfTiePoints[iGCP*6+3] = pasGCPs[iGCP].dfGCPX;\n            padfTiePoints[iGCP*6+4] = pasGCPs[iGCP].dfGCPY;\n            padfTiePoints[iGCP*6+5] = pasGCPs[iGCP].dfGCPZ;\n\n            if( bPixelIsPoint && !bPointGeoIgnore )\n            {\n                padfTiePoints[iGCP*6+0] += 0.5;\n                padfTiePoints[iGCP*6+1] += 0.5;\n            }\n        }\n\n        TIFFSetField( l_hTIFF, TIFFTAG_GEOTIEPOINTS,\n                      6*poSrcDS->GetGCPCount(), padfTiePoints );\n        CPLFree( padfTiePoints );\n\n        l_pszProjection = poSrcDS->GetGCPProjection();\n\n        if( CPLFetchBool( papszOptions, \"TFW\", false )\n            || CPLFetchBool( papszOptions, \"WORLDFILE\", false ) )\n        {\n            CPLError(\n                CE_Warning, CPLE_AppDefined,\n                \"TFW=ON or WORLDFILE=ON creation options are ignored when \"\n                \"GCPs are available\" );\n        }\n    }\n    else\n    {\n        l_pszProjection = poSrcDS->GetProjectionRef();\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Write the projection information, if possible.                  */\n/* -------------------------------------------------------------------- */\n    const bool bHasProjection =\n        l_pszProjection != nullptr && strlen(l_pszProjection) > 0;\n    if( (bHasProjection || bPixelIsPoint) && bGeoTIFF )\n    {\n        GTIF *psGTIF = GTiffDatasetGTIFNew( l_hTIFF );\n\n        if( bHasProjection )\n        {\n            GTIFSetFromOGISDefnEx( psGTIF, l_pszProjection,\n                                   GetGTIFFKeysFlavor(papszOptions) );\n        }\n\n        if( bPixelIsPoint )\n        {\n            GTIFKeySet( psGTIF, GTRasterTypeGeoKey, TYPE_SHORT, 1,\n                        RasterPixelIsPoint );\n        }\n\n        GTIFWriteKeys( psGTIF );\n        GTIFFree( psGTIF );\n    }\n\n    bool l_bDontReloadFirstBlock = false;\n\n#ifdef HAVE_LIBJPEG\n    if( bCopyFromJPEG )\n    {\n        GTIFF_CopyFromJPEG_WriteAdditionalTags(l_hTIFF,\n                                               poSrcDS);\n    }\n#endif\n\n#if defined(HAVE_LIBJPEG) && !defined(BIGTIFF_SUPPORT)\n    else\n#endif\n\n#if !defined(BIGTIFF_SUPPORT)\n    /* -------------------------------------------------------------------- */\n    /*      If we are writing jpeg compression we need to write some        */\n    /*      imagery to force the jpegtables to get created.  This is,       */\n    /*      likely only needed with libtiff >= 3.9.3 (#3633)                */\n    /* -------------------------------------------------------------------- */\n    if( l_nCompression == COMPRESSION_JPEG\n            && strstr(TIFFLIB_VERSION_STR, \"Version 3.9\") != nullptr )\n    {\n        CPLDebug( \"GDAL\",\n                  \"Writing zero block to force creation of JPEG tables.\" );\n        if( TIFFIsTiled( l_hTIFF ) )\n        {\n            const int cc = TIFFTileSize( l_hTIFF );\n            unsigned char *pabyZeros =\n                static_cast<unsigned char *>( CPLCalloc(cc, 1) );\n            TIFFWriteEncodedTile( l_hTIFF, 0, pabyZeros, cc );\n            CPLFree( pabyZeros );\n        }\n        else\n        {\n            int cc = TIFFStripSize( l_hTIFF );\n            unsigned char *pabyZeros =\n                static_cast<unsigned char *>( CPLCalloc(cc,1) );\n            TIFFWriteEncodedStrip( l_hTIFF, 0, pabyZeros, cc );\n            CPLFree( pabyZeros );\n        }\n        l_bDontReloadFirstBlock = true;\n    }\n#endif\n\n/* -------------------------------------------------------------------- */\n/*      Cleanup                                                         */\n/* -------------------------------------------------------------------- */\n\n    TIFFWriteCheck( l_hTIFF, TIFFIsTiled(l_hTIFF), \"GTiffCreateCopy()\" );\n    TIFFWriteDirectory( l_hTIFF );\n    if( bStreaming )\n    {\n        // We need to write twice the directory to be sure that custom\n        // TIFF tags are correctly sorted and that padding bytes have been\n        // added.\n        TIFFSetDirectory( l_hTIFF, 0 );\n        TIFFWriteDirectory( l_hTIFF );\n\n        if( VSIFSeekL( l_fpL, 0, SEEK_END ) != 0 )\n            CPLError(CE_Failure, CPLE_FileIO, \"Cannot seek\");\n        const int nSize = static_cast<int>( VSIFTellL(l_fpL) );\n\n        vsi_l_offset nDataLength = 0;\n        VSIGetMemFileBuffer( l_osTmpFilename, &nDataLength, FALSE);\n        TIFFSetDirectory( l_hTIFF, 0 );\n        GTiffFillStreamableOffsetAndCount( l_hTIFF, nSize );\n        TIFFWriteDirectory( l_hTIFF );\n    }\n    TIFFFlush( l_hTIFF );\n    XTIFFClose( l_hTIFF );\n    l_hTIFF = nullptr;\n\n    {\n        const CPLErr eErr = VSIFCloseL(l_fpL) == 0 ? CE_None : CE_Failure;\n        l_fpL = nullptr;\n\n        if( eErr != CE_None )\n        {\n            VSIUnlink( bStreaming ? l_osTmpFilename.c_str() : pszFilename );\n            return nullptr;\n        }\n    }\n\n    // fpStreaming will assigned to the instance and not closed here.\n    VSILFILE *fpStreaming = nullptr;\n    if( bStreaming )\n    {\n        vsi_l_offset nDataLength = 0;\n        void* pabyBuffer =\n            VSIGetMemFileBuffer( l_osTmpFilename, &nDataLength, FALSE);\n        fpStreaming = VSIFOpenL( pszFilename, \"wb\" );\n        if( fpStreaming == nullptr )\n        {\n            VSIUnlink(l_osTmpFilename);\n            return nullptr;\n        }\n        if( static_cast<vsi_l_offset>(\n                VSIFWriteL( pabyBuffer, 1, static_cast<int>(nDataLength),\n                            fpStreaming ) ) != nDataLength )\n        {\n            CPLError( CE_Failure, CPLE_FileIO, \"Could not write %d bytes\",\n                      static_cast<int>(nDataLength) );\n            CPL_IGNORE_RET_VAL(VSIFCloseL( fpStreaming ));\n            VSIUnlink(l_osTmpFilename);\n            return nullptr;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Re-open as a dataset and copy over missing metadata using       */\n/*      PAM facilities.                                                 */\n/* -------------------------------------------------------------------- */\n    CPLString osFileName(\"GTIFF_RAW:\");\n\n    osFileName += bStreaming ? l_osTmpFilename.c_str() : pszFilename;\n\n    GDALOpenInfo oOpenInfo( osFileName, GA_Update );\n    if( bStreaming )\n    {\n        // In case of single strip file, there's a libtiff check that would\n        // issue a warning since the file hasn't the required size.\n        CPLPushErrorHandler(CPLQuietErrorHandler);\n    }\n    GTiffDataset *poDS = cpl::down_cast<GTiffDataset *>( Open(&oOpenInfo) );\n    if( bStreaming )\n        CPLPopErrorHandler();\n    if( poDS == nullptr )\n    {\n        oOpenInfo.eAccess = GA_ReadOnly;\n        poDS = cpl::down_cast<GTiffDataset *>( Open(&oOpenInfo) );\n    }\n\n    if( poDS == nullptr )\n    {\n        VSIUnlink( bStreaming ? l_osTmpFilename.c_str() : pszFilename );\n        return nullptr;\n    }\n    poDS->osFilename = pszFilename;\n\n    if( bStreaming )\n    {\n        VSIUnlink(l_osTmpFilename);\n        poDS->fpToWrite = fpStreaming;\n    }\n    poDS->osProfile = pszProfile;\n\n    int nCloneInfoFlags = GCIF_PAM_DEFAULT & ~GCIF_MASK;\n\n    // If we explicitly asked not to tag the alpha band as such, do not\n    // reintroduce this alpha color interpretation in PAM.\n    if( poSrcDS->GetRasterBand(l_nBands)->GetColorInterpretation() ==\n        GCI_AlphaBand &&\n        GTiffGetAlphaValue(\n            CPLGetConfigOption(\n                \"GTIFF_ALPHA\",\n                CSLFetchNameValue(papszOptions,\"ALPHA\") ),\n            DEFAULT_ALPHA_TYPE) == EXTRASAMPLE_UNSPECIFIED )\n    {\n        nCloneInfoFlags &= ~GCIF_COLORINTERP;\n    }\n    // Ignore source band color interpretation if requesting PHOTOMETRIC=RGB\n    else if( l_nBands >= 3 &&\n        EQUAL(CSLFetchNameValueDef(papszOptions, \"PHOTOMETRIC\", \"\"), \"RGB\") )\n    {\n        for( int i = 1; i <= 3; i++)\n        {\n            poDS->GetRasterBand(i)->SetColorInterpretation(\n                static_cast<GDALColorInterp>(GCI_RedBand + (i-1)));\n        }\n        nCloneInfoFlags &= ~GCIF_COLORINTERP;\n        if( !(l_nBands == 4 && CSLFetchNameValue(papszOptions, \"ALPHA\") != nullptr) )\n        {\n            for( int i = 4; i <= l_nBands; i++)\n            {\n                poDS->GetRasterBand(i)->SetColorInterpretation(\n                    poSrcDS->GetRasterBand(i)->GetColorInterpretation());\n            }\n        }\n    }\n\n    CPLString osOldGTIFF_REPORT_COMPD_CSVal(\n        CPLGetConfigOption(\"GTIFF_REPORT_COMPD_CS\", \"\"));\n    CPLSetThreadLocalConfigOption(\"GTIFF_REPORT_COMPD_CS\", \"YES\");\n    poDS->CloneInfo( poSrcDS, nCloneInfoFlags );\n    CPLSetThreadLocalConfigOption(\"GTIFF_REPORT_COMPD_CS\",\n        osOldGTIFF_REPORT_COMPD_CSVal.empty() ? nullptr :\n        osOldGTIFF_REPORT_COMPD_CSVal.c_str());\n\n    if( !bGeoTIFF && (poDS->GetPamFlags() & GPF_DISABLED) == 0 )\n    {\n        // Copy georeferencing info to PAM if the profile is not GeoTIFF\n        poDS->GDALPamDataset::SetProjection(poDS->GetProjectionRef());\n        double adfGeoTransform[6];\n        if( poDS->GetGeoTransform(adfGeoTransform) == CE_None )\n        {\n            poDS->GDALPamDataset::SetGeoTransform(adfGeoTransform);\n        }\n        poDS->GDALPamDataset::SetGCPs(poDS->GetGCPCount(),\n                                      poDS->GetGCPs(),\n                                      poDS->GetGCPProjection());\n    }\n\n    poDS->papszCreationOptions = CSLDuplicate( papszOptions );\n    poDS->bDontReloadFirstBlock = l_bDontReloadFirstBlock;\n\n/* -------------------------------------------------------------------- */\n/*      CloneInfo() does not merge metadata, it just replaces it        */\n/*      totally.  So we have to merge it.                               */\n/* -------------------------------------------------------------------- */\n\n    char **papszSRC_MD = poSrcDS->GetMetadata();\n    char **papszDST_MD = CSLDuplicate(poDS->GetMetadata());\n\n    papszDST_MD = CSLMerge( papszDST_MD, papszSRC_MD );\n\n    poDS->SetMetadata( papszDST_MD );\n    CSLDestroy( papszDST_MD );\n\n    // Depending on the PHOTOMETRIC tag, the TIFF file may not have the same\n    // band count as the source. Will fail later in GDALDatasetCopyWholeRaster\n    // anyway.\n    for( int nBand = 1;\n         nBand <= std::min(poDS->GetRasterCount(), poSrcDS->GetRasterCount()) ;\n         ++nBand )\n    {\n        GDALRasterBand* poSrcBand = poSrcDS->GetRasterBand(nBand);\n        GDALRasterBand* poDstBand = poDS->GetRasterBand(nBand);\n        papszSRC_MD = poSrcBand->GetMetadata();\n        papszDST_MD = CSLDuplicate(poDstBand->GetMetadata());\n\n        papszDST_MD = CSLMerge( papszDST_MD, papszSRC_MD );\n\n        poDstBand->SetMetadata( papszDST_MD );\n        CSLDestroy( papszDST_MD );\n\n        char** papszCatNames = poSrcBand->GetCategoryNames();\n        if( nullptr != papszCatNames )\n            poDstBand->SetCategoryNames( papszCatNames );\n    }\n\n    l_hTIFF = static_cast<TIFF *>( poDS->GetInternalHandle(nullptr) );\n\n/* -------------------------------------------------------------------- */\n/*      Handle forcing xml:ESRI data to be written to PAM.              */\n/* -------------------------------------------------------------------- */\n    if( CPLTestBool(CPLGetConfigOption( \"ESRI_XML_PAM\", \"NO\" )) )\n    {\n        char **papszESRIMD = poSrcDS->GetMetadata(\"xml:ESRI\");\n        if( papszESRIMD )\n        {\n            poDS->SetMetadata( papszESRIMD, \"xml:ESRI\");\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Second chance: now that we have a PAM dataset, it is possible   */\n/*      to write metadata that we could not write as a TIFF tag.        */\n/* -------------------------------------------------------------------- */\n    if( !bHasWrittenMDInGeotiffTAG && !bStreaming )\n        GTiffDataset::WriteMetadata(\n            poDS, l_hTIFF, true, pszProfile,\n            pszFilename, papszOptions,\n            true /* don't write RPC and IMD file again */ );\n\n    if( !bStreaming )\n        GTiffDataset::WriteRPC(\n            poDS, l_hTIFF, true, pszProfile,\n            pszFilename, papszOptions,\n            true /* write only in PAM AND if needed */ );\n\n    // To avoid unnecessary directory rewriting.\n    poDS->bMetadataChanged = false;\n    poDS->bGeoTIFFInfoChanged = false;\n    poDS->bNoDataChanged = false;\n    poDS->bForceUnsetGTOrGCPs = false;\n    poDS->bForceUnsetProjection = false;\n    poDS->bStreamingOut = bStreaming;\n\n    // Don't try to load external metadata files (#6597).\n    poDS->bIMDRPCMetadataLoaded = true;\n\n    // We must re-set the compression level at this point, since it has been\n    // lost a few lines above when closing the newly create TIFF file The\n    // TIFFTAG_ZIPQUALITY & TIFFTAG_JPEGQUALITY are not store in the TIFF file.\n    // They are just TIFF session parameters.\n\n    poDS->nZLevel = GTiffGetZLevel(papszOptions);\n    poDS->nLZMAPreset = GTiffGetLZMAPreset(papszOptions);\n    poDS->nZSTDLevel = GTiffGetZSTDPreset(papszOptions);\n    poDS->nWebPLevel = GTiffGetWebPLevel(papszOptions);\n    poDS->bWebPLossless = GTiffGetWebPLossless(papszOptions);\n    poDS->nJpegQuality = GTiffGetJpegQuality(papszOptions);\n    poDS->nJpegTablesMode = GTiffGetJpegTablesMode(papszOptions);\n    poDS->GetDiscardLsbOption(papszOptions);\n#if HAVE_LERC\n    poDS->dfMaxZError = GTiffGetLERCMaxZError(papszOptions);\n#endif\n    poDS->InitCreationOrOpenOptions(papszOptions);\n\n    if( l_nCompression == COMPRESSION_ADOBE_DEFLATE ||\n        l_nCompression == COMPRESSION_LERC )\n    {\n        if( poDS->nZLevel != -1 )\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_ZIPQUALITY, poDS->nZLevel );\n        }\n    }\n    if( l_nCompression == COMPRESSION_JPEG )\n    {\n        if( poDS->nJpegQuality != -1 )\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_JPEGQUALITY, poDS->nJpegQuality );\n        }\n        TIFFSetField( l_hTIFF, TIFFTAG_JPEGTABLESMODE, poDS->nJpegTablesMode );\n    }\n    if( l_nCompression == COMPRESSION_LZMA )\n    {\n        if( poDS->nLZMAPreset != -1 )\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_LZMAPRESET, poDS->nLZMAPreset );\n        }\n    }\n    if( l_nCompression == COMPRESSION_ZSTD ||\n        l_nCompression == COMPRESSION_LERC )\n    {\n        if( poDS->nZSTDLevel != -1 )\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_ZSTD_LEVEL, poDS->nZSTDLevel );\n        }\n    }\n#if HAVE_LERC\n    if( l_nCompression == COMPRESSION_LERC )\n    {\n        TIFFSetField( l_hTIFF, TIFFTAG_LERC_MAXZERROR, poDS->dfMaxZError );\n    }\n#endif\n    if( l_nCompression == COMPRESSION_WEBP )\n    {\n        if( poDS->nWebPLevel != -1 )\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_WEBP_LEVEL, poDS->nWebPLevel );\n        }\n\n        if( poDS->bWebPLossless)\n        {\n          TIFFSetField( l_hTIFF, TIFFTAG_WEBP_LOSSLESS, poDS->bWebPLossless );\n        }\n    }\n\n    // Precreate (internal) mask, so that the IBuildOverviews() below\n    // has a chance to create also the overviews of the mask.\n    CPLErr eErr = CE_None;\n\n    const int nMaskFlags = poSrcDS->GetRasterBand(1)->GetMaskFlags();\n    bool bMask = false;\n    if( !(nMaskFlags & (GMF_ALL_VALID|GMF_ALPHA|GMF_NODATA) )\n        && (nMaskFlags & GMF_PER_DATASET) && !bStreaming )\n    {\n        bMask = true;\n        eErr = poDS->CreateMaskBand( nMaskFlags );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Create and then copy existing overviews if requested            */\n/*  We do it such that all the IFDs are at the beginning of the file,   */\n/*  and that the imagery data for the smallest overview is written      */\n/*  first, that way the file is more usable when embedded in a          */\n/*  compressed stream.                                                  */\n/* -------------------------------------------------------------------- */\n\n    // For scaled progress due to overview copying.\n    const int nBandsWidthMask = l_nBands +  (bMask ? 1 : 0);\n    double dfTotalPixels =\n        static_cast<double>(nXSize) * nYSize * nBandsWidthMask;\n    double dfCurPixels = 0;\n\n    if( eErr == CE_None &&\n        CPLFetchBool(papszOptions, \"COPY_SRC_OVERVIEWS\", false) )\n    {\n        const int nSrcOverviews = poSrcDS->GetRasterBand(1)->GetOverviewCount();\n        if( nSrcOverviews )\n        {\n            eErr = poDS->CreateOverviewsFromSrcOverviews(poSrcDS);\n\n            if( poDS->nOverviewCount != nSrcOverviews )\n            {\n                CPLError( CE_Failure, CPLE_AppDefined,\n                        \"Did only manage to instantiate %d overview levels, \"\n                        \"whereas source contains %d\",\n                        poDS->nOverviewCount, nSrcOverviews);\n                eErr = CE_Failure;\n            }\n\n            for( int i = 0; i < nSrcOverviews; ++i )\n            {\n                GDALRasterBand* poOvrBand =\n                    poSrcDS->GetRasterBand(1)->GetOverview(i);\n                dfTotalPixels += static_cast<double>(poOvrBand->GetXSize()) *\n                                poOvrBand->GetYSize() * nBandsWidthMask;\n            }\n\n            char* papszCopyWholeRasterOptions[2] = { nullptr, nullptr };\n            if( l_nCompression != COMPRESSION_NONE )\n                papszCopyWholeRasterOptions[0] =\n                    const_cast<char*>( \"COMPRESSED=YES\" );\n            // Now copy the imagery.\n            for( int i = 0; eErr == CE_None && i < nSrcOverviews; ++i )\n            {\n                // Begin with the smallest overview.\n                const int iOvrLevel = nSrcOverviews - 1 - i;\n\n                // Create a fake dataset with the source overview level so that\n                // GDALDatasetCopyWholeRaster can cope with it.\n                GDALDataset* poSrcOvrDS =\n                    GDALCreateOverviewDataset(poSrcDS, iOvrLevel, TRUE);\n\n                GDALRasterBand* poOvrBand =\n                        poSrcDS->GetRasterBand(1)->GetOverview(iOvrLevel);\n                double dfNextCurPixels =\n                    dfCurPixels +\n                    static_cast<double>(poOvrBand->GetXSize()) *\n                    poOvrBand->GetYSize() * l_nBands;\n\n                void* pScaledData =\n                    GDALCreateScaledProgress( dfCurPixels / dfTotalPixels,\n                                            dfNextCurPixels / dfTotalPixels,\n                                            pfnProgress, pProgressData );\n\n                eErr =\n                    GDALDatasetCopyWholeRaster(\n                        GDALDataset::ToHandle(poSrcOvrDS),\n                        GDALDataset::ToHandle(poDS->papoOverviewDS[iOvrLevel]),\n                        papszCopyWholeRasterOptions,\n                        GDALScaledProgress, pScaledData );\n\n                dfCurPixels = dfNextCurPixels;\n                GDALDestroyScaledProgress(pScaledData);\n\n                delete poSrcOvrDS;\n                poSrcOvrDS = nullptr;\n                poDS->papoOverviewDS[iOvrLevel]->FlushCache();\n\n                // Copy mask of the overview.\n                if( eErr == CE_None && poDS->poMaskDS != nullptr )\n                {\n                    dfNextCurPixels +=\n                        static_cast<double>(poOvrBand->GetXSize()) *\n                                            poOvrBand->GetYSize();\n                    pScaledData =\n                        GDALCreateScaledProgress( dfCurPixels / dfTotalPixels,\n                                            dfNextCurPixels / dfTotalPixels,\n                                            pfnProgress, pProgressData );\n                    eErr =\n                        GDALRasterBandCopyWholeRaster(\n                            poOvrBand->GetMaskBand(),\n                            poDS->papoOverviewDS[iOvrLevel]->\n                            poMaskDS->GetRasterBand(1),\n                            papszCopyWholeRasterOptions,\n                            GDALScaledProgress, pScaledData );\n                    dfCurPixels = dfNextCurPixels;\n                    GDALDestroyScaledProgress(pScaledData);\n                    poDS->papoOverviewDS[iOvrLevel]->poMaskDS->FlushCache();\n                }\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Copy actual imagery.                                            */\n/* -------------------------------------------------------------------- */\n    double dfNextCurPixels =\n        dfCurPixels + static_cast<double>(nXSize) * nYSize * l_nBands;\n    void* pScaledData = GDALCreateScaledProgress(\n        dfCurPixels / dfTotalPixels,\n        dfNextCurPixels / dfTotalPixels,\n        pfnProgress, pProgressData);\n\n#if defined(HAVE_LIBJPEG) || defined(JPEG_DIRECT_COPY)\n    bool bTryCopy = true;\n#endif\n\n#ifdef HAVE_LIBJPEG\n    if( bCopyFromJPEG )\n    {\n        eErr = GTIFF_CopyFromJPEG( poDS, poSrcDS,\n                                   pfnProgress, pProgressData,\n                                   bTryCopy );\n\n        // In case of failure in the decompression step, try normal copy.\n        if( bTryCopy )\n            eErr = CE_None;\n    }\n#endif\n\n#ifdef JPEG_DIRECT_COPY\n    if( bDirectCopyFromJPEG )\n    {\n        eErr = GTIFF_DirectCopyFromJPEG(poDS, poSrcDS,\n                                        pfnProgress, pProgressData,\n                                        bTryCopy);\n\n        // In case of failure in the reading step, try normal copy.\n        if( bTryCopy )\n            eErr = CE_None;\n    }\n#endif\n\n    if( \n#if defined(HAVE_LIBJPEG) || defined(JPEG_DIRECT_COPY)\n        bTryCopy &&\n#endif\n        (poDS->bTreatAsSplit || poDS->bTreatAsSplitBitmap) )\n    {\n        // For split bands, we use TIFFWriteScanline() interface.\n        CPLAssert(poDS->nBitsPerSample == 8 || poDS->nBitsPerSample == 1);\n\n        if( poDS->nPlanarConfig == PLANARCONFIG_CONTIG && poDS->nBands > 1 )\n        {\n            GByte* pabyScanline =\n                static_cast<GByte *>(\n                    VSI_MALLOC_VERBOSE(TIFFScanlineSize(l_hTIFF)) );\n            if( pabyScanline == nullptr )\n                eErr = CE_Failure;\n            for( int j = 0; j < nYSize && eErr == CE_None; ++j )\n            {\n                eErr =\n                    poSrcDS->RasterIO(\n                        GF_Read, 0, j, nXSize, 1,\n                        pabyScanline, nXSize, 1,\n                        GDT_Byte, l_nBands, nullptr, poDS->nBands, 0, 1,\n                        nullptr );\n                if( eErr == CE_None &&\n                    TIFFWriteScanline( l_hTIFF, pabyScanline, j, 0) == -1 )\n                {\n                    CPLError( CE_Failure, CPLE_AppDefined,\n                              \"TIFFWriteScanline() failed.\" );\n                    eErr = CE_Failure;\n                }\n                if( !GDALScaledProgress( (j + 1) * 1.0 / nYSize,\n                                         nullptr, pScaledData ) )\n                    eErr = CE_Failure;\n            }\n            CPLFree( pabyScanline );\n        }\n        else\n        {\n            GByte* pabyScanline = static_cast<GByte *>(\n                VSI_MALLOC_VERBOSE(nXSize) );\n            if( pabyScanline == nullptr )\n                eErr = CE_Failure;\n            else\n                eErr = CE_None;\n            for( int iBand = 1; iBand <= l_nBands && eErr == CE_None; ++iBand )\n            {\n                for( int j = 0; j < nYSize && eErr == CE_None; ++j )\n                {\n                    eErr = poSrcDS->GetRasterBand(iBand)->RasterIO(\n                        GF_Read, 0, j, nXSize, 1,\n                        pabyScanline, nXSize, 1,\n                        GDT_Byte, 0, 0, nullptr );\n                    if( poDS->bTreatAsSplitBitmap )\n                    {\n                        for( int i = 0; i < nXSize; ++i )\n                        {\n                            const GByte byVal = pabyScanline[i];\n                            if( (i & 0x7) == 0 )\n                                pabyScanline[i >> 3] = 0;\n                            if( byVal )\n                                pabyScanline[i >> 3] |= 0x80 >> (i & 0x7);\n                        }\n                    }\n                    if( eErr == CE_None &&\n                        TIFFWriteScanline(\n                            l_hTIFF, pabyScanline, j,\n                            static_cast<uint16>(iBand - 1)) == -1 )\n                    {\n                        CPLError( CE_Failure, CPLE_AppDefined,\n                                  \"TIFFWriteScanline() failed.\" );\n                        eErr = CE_Failure;\n                    }\n                    if( !GDALScaledProgress(\n                           (j + 1 + (iBand - 1) * nYSize) * 1.0 /\n                           (l_nBands * nYSize),\n                           nullptr, pScaledData ) )\n                        eErr = CE_Failure;\n                }\n            }\n            CPLFree(pabyScanline);\n        }\n\n        // Necessary to be able to read the file without re-opening.\n#if defined(HAVE_TIFFGETSIZEPROC)\n        TIFFSizeProc pfnSizeProc = TIFFGetSizeProc( l_hTIFF );\n\n        TIFFFlushData( l_hTIFF );\n\n        toff_t nNewDirOffset = pfnSizeProc( TIFFClientdata( l_hTIFF ) );\n        if( (nNewDirOffset % 2) == 1 )\n            ++nNewDirOffset;\n#endif\n\n        TIFFFlush( l_hTIFF );\n\n#if defined(HAVE_TIFFGETSIZEPROC)\n        if( poDS->nDirOffset != TIFFCurrentDirOffset( l_hTIFF ) )\n        {\n            poDS->nDirOffset = nNewDirOffset;\n            CPLDebug( \"GTiff\", \"directory moved during flush.\" );\n        }\n#endif\n    }\n    else if( \n#if defined(HAVE_LIBJPEG) || defined(JPEG_DIRECT_COPY)\n        bTryCopy &&\n#endif\n        eErr == CE_None )\n    {\n        char* papszCopyWholeRasterOptions[3] = { nullptr, nullptr, nullptr };\n        int iNextOption = 0;\n        papszCopyWholeRasterOptions[iNextOption++] =\n                const_cast<char *>( \"SKIP_HOLES=YES\" );\n        if( l_nCompression != COMPRESSION_NONE )\n        {\n            papszCopyWholeRasterOptions[iNextOption++] =\n                const_cast<char *>( \"COMPRESSED=YES\" );\n        }\n        // For streaming with separate, we really want that bands are written\n        // after each other, even if the source is pixel interleaved.\n        else if( bStreaming && poDS->nPlanarConfig == PLANARCONFIG_SEPARATE )\n        {\n            papszCopyWholeRasterOptions[iNextOption++] =\n                const_cast<char *>(\"INTERLEAVE=BAND\");\n        }\n\n    /* -------------------------------------------------------------------- */\n    /*      Do we want to ensure all blocks get written out on close to     */\n    /*      avoid sparse files?                                             */\n    /* -------------------------------------------------------------------- */\n        if( !CPLFetchBool( papszOptions, \"SPARSE_OK\", false ) )\n            poDS->bFillEmptyTilesAtClosing = true;\n\n        poDS->bWriteEmptyTiles =\n            bStreaming ||\n            (poDS->nCompression != COMPRESSION_NONE &&\n             poDS->bFillEmptyTilesAtClosing);\n        // Only required for people writing non-compressed stripped files in the\n        // rightorder and wanting all tstrips to be written in the same order\n        // so that the end result can be memory mapped without knowledge of each\n        // strip offset\n        if( CPLTestBool( CSLFetchNameValueDef(\n                             papszOptions,\n                             \"WRITE_EMPTY_TILES_SYNCHRONOUSLY\", \"FALSE\" )) ||\n           CPLTestBool( CSLFetchNameValueDef(\n                             papszOptions,\n                             \"@WRITE_EMPTY_TILES_SYNCHRONOUSLY\", \"FALSE\" )) )\n        {\n            poDS->bWriteEmptyTiles = true;\n        }\n\n        eErr = GDALDatasetCopyWholeRaster(\n            /* (GDALDatasetH) */ poSrcDS,\n            /* (GDALDatasetH) */ poDS,\n            papszCopyWholeRasterOptions,\n            GDALScaledProgress, pScaledData );\n    }\n\n    GDALDestroyScaledProgress(pScaledData);\n\n    if( eErr == CE_None && !bStreaming )\n    {\n        pScaledData = GDALCreateScaledProgress(\n            dfNextCurPixels / dfTotalPixels,\n            1.0,\n            pfnProgress, pProgressData);\n        if( poDS->poMaskDS )\n        {\n            const char* l_papszOptions[2] = { \"COMPRESSED=YES\", nullptr };\n            eErr = GDALRasterBandCopyWholeRaster(\n                                    poSrcDS->GetRasterBand(1)->GetMaskBand(),\n                                    poDS->GetRasterBand(1)->GetMaskBand(),\n                                    const_cast<char **>(l_papszOptions),\n                                    GDALScaledProgress, pScaledData );\n        }\n        else\n        {\n            eErr = GDALDriver::DefaultCopyMasks( poSrcDS, poDS, bStrict,\n                                                 nullptr,\n                                                 GDALScaledProgress, pScaledData );\n        }\n        GDALDestroyScaledProgress(pScaledData);\n    }\n\n    if( eErr == CE_Failure )\n    {\n        delete poDS;\n        poDS = nullptr;\n\n        if( CPLTestBool(CPLGetConfigOption(\"GTIFF_DELETE_ON_ERROR\", \"YES\")) )\n        {\n            if( !bStreaming )\n            {\n                // Should really delete more carefully.\n                VSIUnlink( pszFilename );\n            }\n        }\n    }\n\n    return poDS;\n}\n\n/************************************************************************/\n/*                          GetProjectionRef()                          */\n/************************************************************************/\n\nconst char *GTiffDataset::GetProjectionRef()\n\n{\n    if( nGCPCount == 0 )\n    {\n        LoadGeoreferencingAndPamIfNeeded();\n        LookForProjection();\n\n        return pszProjection;\n    }\n\n    return \"\";\n}\n\n\n/************************************************************************/\n/*                           HasVerticalCS()                            */\n/************************************************************************/\n\nbool GTiffDataset::HasVerticalCS(const char *pszProjectionIn)\n{\n    if( pszProjectionIn != nullptr && pszProjectionIn[0] != '\\0' )\n    {\n        OGRSpatialReference oSRS;\n        oSRS.SetFromUserInput(pszProjectionIn);\n        return CPL_TO_BOOL(oSRS.IsVertical());\n    }\n    else\n    {\n        return false;\n    }\n}\n\n/************************************************************************/\n/*                           SetProjection()                            */\n/************************************************************************/\n\nCPLErr GTiffDataset::SetProjection( const char * pszNewProjection )\n\n{\n    if( bStreamingOut && bCrystalized )\n    {\n        CPLError(\n            CE_Failure, CPLE_NotSupported,\n            \"Cannot modify projection at that point in \"\n            \"a streamed output file\" );\n        return CE_Failure;\n    }\n\n    LoadGeoreferencingAndPamIfNeeded();\n    LookForProjection();\n\n    if( !STARTS_WITH_CI(pszNewProjection, \"GEOGCS\")\n        && !STARTS_WITH_CI(pszNewProjection, \"PROJCS\")\n        && !STARTS_WITH_CI(pszNewProjection, \"LOCAL_CS\")\n        && !STARTS_WITH_CI(pszNewProjection, \"COMPD_CS\")\n        && !STARTS_WITH_CI(pszNewProjection, \"GEOCCS\")\n        && !EQUAL(pszNewProjection,\"\") )\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                \"Only OGC WKT Projections supported for writing to GeoTIFF.  \"\n                \"%s not supported.\",\n                  pszNewProjection );\n\n        return CE_Failure;\n    }\n\n    if( EQUAL(pszNewProjection, \"\") &&\n        pszProjection != nullptr &&\n        !EQUAL(pszProjection, \"\") )\n    {\n        bForceUnsetProjection = true;\n    }\n\n    CPLFree( pszProjection );\n    pszProjection = CPLStrdup( pszNewProjection );\n\n    bGeoTIFFInfoChanged = true;\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                          GetGeoTransform()                           */\n/************************************************************************/\n\nCPLErr GTiffDataset::GetGeoTransform( double * padfTransform )\n\n{\n    LoadGeoreferencingAndPamIfNeeded();\n\n    memcpy( padfTransform, adfGeoTransform, sizeof(double) * 6 );\n\n    if( !bGeoTransformValid )\n        return CE_Failure;\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                          SetGeoTransform()                           */\n/************************************************************************/\n\nCPLErr GTiffDataset::SetGeoTransform( double * padfTransform )\n\n{\n    if( bStreamingOut && bCrystalized )\n    {\n        CPLError(\n            CE_Failure, CPLE_NotSupported,\n            \"Cannot modify geotransform at that point in a \"\n            \"streamed output file\" );\n        return CE_Failure;\n    }\n\n    LoadGeoreferencingAndPamIfNeeded();\n\n    if( GetAccess() == GA_Update )\n    {\n        if( nGCPCount > 0 )\n        {\n            CPLError(CE_Warning, CPLE_AppDefined,\n                     \"GCPs previously set are going to be cleared \"\n                     \"due to the setting of a geotransform.\");\n            bForceUnsetGTOrGCPs = true;\n            GDALDeinitGCPs( nGCPCount, pasGCPList );\n            CPLFree( pasGCPList );\n            nGCPCount = 0;\n            pasGCPList = nullptr;\n        }\n        else if( padfTransform[0] == 0.0 &&\n                 padfTransform[1] == 0.0 &&\n                 padfTransform[2] == 0.0 &&\n                 padfTransform[3] == 0.0 &&\n                 padfTransform[4] == 0.0 &&\n                 padfTransform[5] == 0.0 )\n        {\n            if( bGeoTransformValid )\n            {\n                bForceUnsetGTOrGCPs = true;\n                bGeoTIFFInfoChanged = true;\n            }\n            bGeoTransformValid = false;\n            memcpy( adfGeoTransform, padfTransform, sizeof(double)*6 );\n            return CE_None;\n        }\n\n        memcpy( adfGeoTransform, padfTransform, sizeof(double)*6 );\n        bGeoTransformValid = true;\n        bGeoTIFFInfoChanged = true;\n\n        return CE_None;\n    }\n    else\n    {\n        CPLError(\n            CE_Failure, CPLE_NotSupported,\n            \"Attempt to call SetGeoTransform() on a read-only GeoTIFF file.\" );\n        return CE_Failure;\n    }\n}\n\n/************************************************************************/\n/*                            GetGCPCount()                             */\n/************************************************************************/\n\nint GTiffDataset::GetGCPCount()\n\n{\n    LoadGeoreferencingAndPamIfNeeded();\n\n    return nGCPCount;\n}\n\n/************************************************************************/\n/*                          GetGCPProjection()                          */\n/************************************************************************/\n\nconst char *GTiffDataset::GetGCPProjection()\n\n{\n    LoadGeoreferencingAndPamIfNeeded();\n\n    if( nGCPCount > 0 )\n    {\n        LookForProjection();\n    }\n    if( pszProjection != nullptr )\n        return pszProjection;\n\n    return \"\";\n}\n\n/************************************************************************/\n/*                               GetGCPs()                              */\n/************************************************************************/\n\nconst GDAL_GCP *GTiffDataset::GetGCPs()\n\n{\n    LoadGeoreferencingAndPamIfNeeded();\n\n    return pasGCPList;\n}\n\n/************************************************************************/\n/*                               SetGCPs()                              */\n/************************************************************************/\n\nCPLErr GTiffDataset::SetGCPs( int nGCPCountIn, const GDAL_GCP *pasGCPListIn,\n                              const char *pszGCPProjection )\n{\n    LoadGeoreferencingAndPamIfNeeded();\n\n    if( GetAccess() == GA_Update )\n    {\n        LookForProjection();\n\n        if( nGCPCount > 0 && nGCPCountIn == 0 )\n        {\n            bForceUnsetGTOrGCPs = true;\n        }\n        else if( nGCPCountIn > 0 &&\n                 bGeoTransformValid )\n        {\n            CPLError(CE_Warning, CPLE_AppDefined,\n                     \"A geotransform previously set is going to be cleared \"\n                     \"due to the setting of GCPs.\");\n            adfGeoTransform[0] = 0.0;\n            adfGeoTransform[1] = 1.0;\n            adfGeoTransform[2] = 0.0;\n            adfGeoTransform[3] = 0.0;\n            adfGeoTransform[4] = 0.0;\n            adfGeoTransform[5] = 1.0;\n            bGeoTransformValid = false;\n            bForceUnsetGTOrGCPs = true;\n        }\n\n        if( pszProjection != nullptr &&\n            !EQUAL(pszProjection, \"\") &&\n                   (pszGCPProjection == nullptr ||\n                   pszGCPProjection[0] == '\\0') )\n            bForceUnsetProjection = true;\n\n        if( nGCPCount > 0 )\n        {\n            GDALDeinitGCPs( nGCPCount, pasGCPList );\n            CPLFree( pasGCPList );\n        }\n\n        nGCPCount = nGCPCountIn;\n        pasGCPList = GDALDuplicateGCPs(nGCPCount, pasGCPListIn);\n\n        CPLFree( pszProjection );\n        pszProjection = CPLStrdup( pszGCPProjection );\n        bGeoTIFFInfoChanged = true;\n\n        return CE_None;\n    }\n    else\n    {\n        CPLError(CE_Failure, CPLE_NotSupported,\n                 \"SetGCPs() is only supported on newly created GeoTIFF files.\");\n        return CE_Failure;\n    }\n}\n\n/************************************************************************/\n/*                      GetMetadataDomainList()                         */\n/************************************************************************/\n\nchar **GTiffDataset::GetMetadataDomainList()\n{\n    LoadGeoreferencingAndPamIfNeeded();\n\n    char **papszDomainList = CSLDuplicate(oGTiffMDMD.GetDomainList());\n    char **papszBaseList = GDALDataset::GetMetadataDomainList();\n\n    const int nbBaseDomains = CSLCount(papszBaseList);\n\n    for( int domainId = 0; domainId < nbBaseDomains; ++domainId )\n        papszDomainList = CSLAddString(papszDomainList,papszBaseList[domainId]);\n\n    CSLDestroy(papszBaseList);\n\n    return BuildMetadataDomainList(\n        papszDomainList,\n        TRUE,\n        \"\", \"ProxyOverviewRequest\", MD_DOMAIN_RPC, MD_DOMAIN_IMD,\n        \"SUBDATASETS\", \"EXIF\",\n        \"xml:XMP\", \"COLOR_PROFILE\", nullptr);\n}\n\n/************************************************************************/\n/*                            GetMetadata()                             */\n/************************************************************************/\n\nchar **GTiffDataset::GetMetadata( const char * pszDomain )\n\n{\n    if( pszDomain == nullptr || !EQUAL(pszDomain, \"IMAGE_STRUCTURE\") )\n    {\n        LoadGeoreferencingAndPamIfNeeded();\n    }\n\n    if( pszDomain != nullptr && EQUAL(pszDomain, \"ProxyOverviewRequest\") )\n        return GDALPamDataset::GetMetadata( pszDomain );\n\n    if( pszDomain != nullptr && EQUAL(pszDomain, \"DERIVED_SUBDATASETS\"))\n    {\n        return GDALDataset::GetMetadata(pszDomain);\n    }\n\n    else if( pszDomain != nullptr && (EQUAL(pszDomain, MD_DOMAIN_RPC) ||\n                                   EQUAL(pszDomain, MD_DOMAIN_IMD) ||\n                                   EQUAL(pszDomain, MD_DOMAIN_IMAGERY)) )\n        LoadMetadata();\n\n    else if( pszDomain != nullptr && EQUAL(pszDomain, \"SUBDATASETS\") )\n        ScanDirectories();\n\n    else if( pszDomain != nullptr && EQUAL(pszDomain, \"EXIF\") )\n        LoadEXIFMetadata();\n\n    else if( pszDomain != nullptr && EQUAL(pszDomain, \"COLOR_PROFILE\") )\n        LoadICCProfile();\n\n    else if( pszDomain == nullptr || EQUAL(pszDomain, \"\") )\n        LoadMDAreaOrPoint();  // To set GDALMD_AREA_OR_POINT.\n\n    return oGTiffMDMD.GetMetadata( pszDomain );\n}\n\n/************************************************************************/\n/*                            SetMetadata()                             */\n/************************************************************************/\nCPLErr GTiffDataset::SetMetadata( char ** papszMD, const char *pszDomain )\n\n{\n    LoadGeoreferencingAndPamIfNeeded();\n\n    if( bStreamingOut && bCrystalized )\n    {\n        CPLError(\n            CE_Failure, CPLE_NotSupported,\n            \"Cannot modify metadata at that point in a streamed output file\" );\n        return CE_Failure;\n    }\n\n    if( pszDomain != nullptr && EQUAL(pszDomain, MD_DOMAIN_RPC) )\n    {\n        // So that a subsequent GetMetadata() wouldn't override our new values\n        LoadMetadata();\n        m_bForceUnsetRPC = (CSLCount(papszMD) == 0);\n    }\n\n    if( (papszMD != nullptr) &&\n        (pszDomain != nullptr) &&\n        EQUAL(pszDomain, \"COLOR_PROFILE\") )\n    {\n        bColorProfileMetadataChanged = true;\n    }\n    else if( pszDomain == nullptr || !EQUAL(pszDomain,\"_temporary_\") )\n    {\n        bMetadataChanged = true;\n        // Cancel any existing metadata from PAM file.\n        if( eAccess == GA_Update &&\n            GDALPamDataset::GetMetadata(pszDomain) != nullptr )\n            GDALPamDataset::SetMetadata(nullptr, pszDomain);\n    }\n\n    if( (pszDomain == nullptr || EQUAL(pszDomain, \"\")) &&\n        CSLFetchNameValue(papszMD, GDALMD_AREA_OR_POINT) != nullptr )\n    {\n        const char* pszPrevValue =\n                GetMetadataItem(GDALMD_AREA_OR_POINT);\n        const char* pszNewValue =\n                CSLFetchNameValue(papszMD, GDALMD_AREA_OR_POINT);\n        if( pszPrevValue == nullptr || pszNewValue == nullptr ||\n            !EQUAL(pszPrevValue, pszNewValue) )\n        {\n            LookForProjection();\n            bGeoTIFFInfoChanged = true;\n        }\n    }\n\n    if( pszDomain != nullptr && EQUAL(pszDomain, \"xml:XMP\") )\n    {\n        if( papszMD != nullptr && *papszMD != nullptr )\n        {\n            int nTagSize = static_cast<int>(strlen(*papszMD));\n            TIFFSetField( hTIFF, TIFFTAG_XMLPACKET, nTagSize, *papszMD );\n        }\n        else\n        {\n#ifdef HAVE_UNSETFIELD\n            TIFFUnsetField( hTIFF, TIFFTAG_XMLPACKET );\n#else\n            CPLDebug(\n                \"GTiff\",\n                \"TIFFUnsetField() not supported, xml:XMP may not be cleared.\" );\n#endif\n        }\n    }\n\n    return oGTiffMDMD.SetMetadata( papszMD, pszDomain );\n}\n\n/************************************************************************/\n/*                          GetMetadataItem()                           */\n/************************************************************************/\n\nconst char *GTiffDataset::GetMetadataItem( const char *pszName,\n                                           const char *pszDomain )\n\n{\n    if( pszDomain == nullptr || !EQUAL(pszDomain, \"IMAGE_STRUCTURE\") )\n    {\n        LoadGeoreferencingAndPamIfNeeded();\n    }\n\n    if( pszDomain != nullptr && EQUAL(pszDomain,\"ProxyOverviewRequest\") )\n    {\n        return GDALPamDataset::GetMetadataItem( pszName, pszDomain );\n    }\n    else if( pszDomain != nullptr && (EQUAL(pszDomain, MD_DOMAIN_RPC) ||\n                                   EQUAL(pszDomain, MD_DOMAIN_IMD) ||\n                                   EQUAL(pszDomain, MD_DOMAIN_IMAGERY)) )\n    {\n        LoadMetadata();\n    }\n    else if( pszDomain != nullptr && EQUAL(pszDomain, \"SUBDATASETS\") )\n    {\n        ScanDirectories();\n    }\n    else if( pszDomain != nullptr && EQUAL(pszDomain, \"EXIF\") )\n    {\n        LoadEXIFMetadata();\n    }\n    else if( pszDomain != nullptr && EQUAL(pszDomain, \"COLOR_PROFILE\") )\n    {\n        LoadICCProfile();\n    }\n    else if( (pszDomain == nullptr || EQUAL(pszDomain, \"\")) &&\n        pszName != nullptr && EQUAL(pszName, GDALMD_AREA_OR_POINT) )\n    {\n        LoadMDAreaOrPoint();  // To set GDALMD_AREA_OR_POINT.\n    }\n\n#ifdef DEBUG_REACHED_VIRTUAL_MEM_IO\n    else if( pszDomain != nullptr && EQUAL(pszDomain, \"_DEBUG_\") &&\n             pszName != nullptr &&\n             EQUAL(pszName, \"UNREACHED_VIRTUALMEMIO_CODE_PATH\") )\n    {\n        CPLString osMissing;\n        for( int i = 0; i < static_cast<int>(\n                                CPL_ARRAYSIZE(anReachedVirtualMemIO)); ++i )\n        {\n            if( !anReachedVirtualMemIO[i] )\n            {\n                if( !osMissing.empty() ) osMissing += \",\";\n                osMissing += CPLSPrintf(\"%d\", i);\n            }\n        }\n        return (osMissing.size()) ? CPLSPrintf(\"%s\", osMissing.c_str()) : nullptr;\n    }\n#endif\n    else if( pszDomain != nullptr && EQUAL(pszDomain, \"_DEBUG_\") &&\n             pszName != nullptr && EQUAL(pszName, \"TIFFTAG_EXTRASAMPLES\") )\n    {\n        CPLString osRet;\n        uint16 *v = nullptr;\n        uint16 count = 0;\n\n        if( TIFFGetField( hTIFF, TIFFTAG_EXTRASAMPLES, &count, &v ) )\n        {\n            for( int i = 0; i < static_cast<int>(count); ++i )\n            {\n                if( i > 0 ) osRet += \",\";\n                osRet += CPLSPrintf(\"%d\", v[i]);\n            }\n        }\n        return (osRet.size()) ? CPLSPrintf(\"%s\", osRet.c_str()) : nullptr;\n    }\n    else if( pszDomain != nullptr && EQUAL(pszDomain, \"_DEBUG_\") &&\n             pszName != nullptr && EQUAL(pszName, \"TIFFTAG_PHOTOMETRIC\") )\n    {\n        return CPLSPrintf(\"%d\", nPhotometric);\n    }\n\n    else if( pszDomain != nullptr && EQUAL(pszDomain, \"_DEBUG_\") &&\n             pszName != nullptr && EQUAL( pszName, \"TIFFTAG_GDAL_METADATA\") )\n    {\n        char* pszText = nullptr;\n        if( !TIFFGetField( hTIFF, TIFFTAG_GDAL_METADATA, &pszText ) )\n            return nullptr;\n\n        return CPLSPrintf(\"%s\", pszText);\n    }\n\n    return oGTiffMDMD.GetMetadataItem( pszName, pszDomain );\n}\n\n/************************************************************************/\n/*                          SetMetadataItem()                           */\n/************************************************************************/\n\nCPLErr GTiffDataset::SetMetadataItem( const char *pszName,\n                                      const char *pszValue,\n                                      const char *pszDomain )\n\n{\n    LoadGeoreferencingAndPamIfNeeded();\n\n    if( bStreamingOut && bCrystalized )\n    {\n        CPLError(\n            CE_Failure, CPLE_NotSupported,\n            \"Cannot modify metadata at that point in a streamed output file\" );\n        return CE_Failure;\n    }\n\n    if( (pszDomain != nullptr) && EQUAL(pszDomain, \"COLOR_PROFILE\") )\n    {\n        bColorProfileMetadataChanged = true;\n    }\n    else if( pszDomain == nullptr || !EQUAL(pszDomain,\"_temporary_\") )\n    {\n        bMetadataChanged = true;\n        // Cancel any existing metadata from PAM file.\n        if( eAccess == GA_Update &&\n            GDALPamDataset::GetMetadataItem(pszName, pszDomain) != nullptr )\n            GDALPamDataset::SetMetadataItem(pszName, nullptr, pszDomain);\n    }\n\n    if( (pszDomain == nullptr || EQUAL(pszDomain, \"\")) &&\n        pszName != nullptr && EQUAL(pszName, GDALMD_AREA_OR_POINT) )\n    {\n        LookForProjection();\n        bGeoTIFFInfoChanged = true;\n    }\n\n    return oGTiffMDMD.SetMetadataItem( pszName, pszValue, pszDomain );\n}\n\n/************************************************************************/\n/*                         GetInternalHandle()                          */\n/************************************************************************/\n\nvoid *GTiffDataset::GetInternalHandle( const char * /* pszHandleName */ )\n\n{\n    return hTIFF;\n}\n\n/************************************************************************/\n/*                         LoadEXIFMetadata()                           */\n/************************************************************************/\n\nvoid GTiffDataset::LoadEXIFMetadata()\n{\n    if( bEXIFMetadataLoaded )\n        return;\n    bEXIFMetadataLoaded = true;\n\n    if( !SetDirectory() )\n        return;\n\n    VSILFILE* fp = VSI_TIFFGetVSILFile(TIFFClientdata( hTIFF ));\n\n    GByte abyHeader[2] = { 0 };\n    if( VSIFSeekL(fp, 0, SEEK_SET) != 0 ||\n        VSIFReadL(abyHeader, 1, 2, fp) != 2 )\n        return;\n\n    const bool bLittleEndian = abyHeader[0] == 'I' && abyHeader[1] == 'I';\n    const bool bLeastSignificantBit = CPL_IS_LSB != 0;\n    const bool bSwabflag = bLittleEndian != bLeastSignificantBit;  // != is XOR.\n\n    char** papszMetadata = nullptr;\n    toff_t nOffset = 0;  // TODO(b/28199387): Refactor to simplify casting.\n\n    if( TIFFGetField(hTIFF, TIFFTAG_EXIFIFD, &nOffset) )\n    {\n        int nExifOffset = static_cast<int>(nOffset);\n        int nInterOffset = 0;\n        int nGPSOffset = 0;\n        EXIFExtractMetadata( papszMetadata,\n                             fp, static_cast<int>(nOffset),\n                             bSwabflag, 0,\n                             nExifOffset, nInterOffset, nGPSOffset);\n    }\n\n    if( TIFFGetField(hTIFF, TIFFTAG_GPSIFD, &nOffset) )\n    {\n        int nExifOffset = 0;  // TODO(b/28199387): Refactor to simplify casting.\n        int nInterOffset = 0;\n        int nGPSOffset = static_cast<int>(nOffset);\n        EXIFExtractMetadata( papszMetadata,\n                             fp, static_cast<int>(nOffset),\n                             bSwabflag, 0,\n                             nExifOffset, nInterOffset, nGPSOffset );\n    }\n\n    if( papszMetadata )\n    {\n        oGTiffMDMD.SetMetadata( papszMetadata, \"EXIF\" );\n        CSLDestroy( papszMetadata );\n    }\n}\n\n/************************************************************************/\n/*                           LoadMetadata()                             */\n/************************************************************************/\nvoid GTiffDataset::LoadMetadata()\n{\n    if( bIMDRPCMetadataLoaded )\n        return;\n    bIMDRPCMetadataLoaded = true;\n\n    GDALMDReaderManager mdreadermanager;\n    GDALMDReaderBase* mdreader =\n        mdreadermanager.GetReader(osFilename,\n                                  oOvManager.GetSiblingFiles(), MDR_ANY);\n\n    if( nullptr != mdreader )\n    {\n        mdreader->FillMetadata(&oGTiffMDMD);\n\n        if(mdreader->GetMetadataDomain(MD_DOMAIN_RPC) == nullptr)\n        {\n            char** papszRPCMD = GTiffDatasetReadRPCTag(hTIFF);\n            if( papszRPCMD )\n            {\n                oGTiffMDMD.SetMetadata( papszRPCMD, MD_DOMAIN_RPC );\n                CSLDestroy( papszRPCMD );\n            }\n        }\n\n        papszMetadataFiles = mdreader->GetMetadataFiles();\n    }\n    else\n    {\n        char** papszRPCMD = GTiffDatasetReadRPCTag(hTIFF);\n        if( papszRPCMD )\n        {\n            oGTiffMDMD.SetMetadata( papszRPCMD, MD_DOMAIN_RPC );\n            CSLDestroy( papszRPCMD );\n        }\n    }\n}\n\n/************************************************************************/\n/*                            GetFileList()                             */\n/************************************************************************/\n\nchar **GTiffDataset::GetFileList()\n\n{\n    LoadGeoreferencingAndPamIfNeeded();\n\n    char **papszFileList = GDALPamDataset::GetFileList();\n\n    LoadMetadata();\n    if(nullptr != papszMetadataFiles)\n    {\n        for( int i = 0; papszMetadataFiles[i] != nullptr; ++i )\n        {\n            if( CSLFindString( papszFileList, papszMetadataFiles[i] ) < 0 )\n            {\n                papszFileList =\n                    CSLAddString( papszFileList, papszMetadataFiles[i] );\n            }\n        }\n    }\n\n    if( !osGeorefFilename.empty() &&\n        CSLFindString(papszFileList, osGeorefFilename) == -1 )\n    {\n        papszFileList = CSLAddString( papszFileList, osGeorefFilename );\n    }\n\n    return papszFileList;\n}\n\n/************************************************************************/\n/*                         CreateMaskBand()                             */\n/************************************************************************/\n\nCPLErr GTiffDataset::CreateMaskBand(int nFlagsIn)\n{\n    ScanDirectories();\n\n    if( poMaskDS != nullptr )\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                  \"This TIFF dataset has already an internal mask band\" );\n        return CE_Failure;\n    }\n    else if( CPLTestBool(CPLGetConfigOption(\"GDAL_TIFF_INTERNAL_MASK\", \"NO\")) )\n    {\n        if( nFlagsIn != GMF_PER_DATASET )\n        {\n            CPLError(\n                CE_Failure, CPLE_AppDefined,\n                \"The only flag value supported for internal mask is \"\n                \"GMF_PER_DATASET\" );\n            return CE_Failure;\n        }\n\n        int l_nCompression = COMPRESSION_PACKBITS;\n        if( strstr(GDALGetMetadataItem(GDALGetDriverByName( \"GTiff\" ),\n                                       GDAL_DMD_CREATIONOPTIONLIST, nullptr ),\n                   \"<Value>DEFLATE</Value>\") != nullptr )\n            l_nCompression = COMPRESSION_ADOBE_DEFLATE;\n\n    /* -------------------------------------------------------------------- */\n    /*      If we don't have read access, then create the mask externally.  */\n    /* -------------------------------------------------------------------- */\n        if( GetAccess() != GA_Update )\n        {\n            CPLError( CE_Warning, CPLE_AppDefined,\n                      \"File open for read-only accessing, \"\n                      \"creating mask externally.\" );\n\n            return GDALPamDataset::CreateMaskBand(nFlagsIn);\n        }\n\n        if( poBaseDS && !poBaseDS->SetDirectory() )\n            return CE_Failure;\n\n        if( !SetDirectory() )\n            return CE_Failure;\n\n        bool bIsOverview = false;\n        uint32 nSubType = 0;\n        if( TIFFGetField(hTIFF, TIFFTAG_SUBFILETYPE, &nSubType) )\n        {\n            bIsOverview = (nSubType & FILETYPE_REDUCEDIMAGE) != 0;\n\n            if( (nSubType & FILETYPE_MASK) != 0 )\n            {\n                CPLError( CE_Failure, CPLE_AppDefined,\n                          \"Cannot create a mask on a TIFF mask IFD !\" );\n                return CE_Failure;\n            }\n        }\n\n        const int bIsTiled = TIFFIsTiled(hTIFF);\n\n        FlushDirectory();\n\n        const toff_t nOffset =\n            GTIFFWriteDirectory(\n                hTIFF,\n                bIsOverview ?\n                FILETYPE_REDUCEDIMAGE | FILETYPE_MASK : FILETYPE_MASK,\n                nRasterXSize, nRasterYSize,\n                1, PLANARCONFIG_CONTIG, 1,\n                nBlockXSize, nBlockYSize,\n                bIsTiled, l_nCompression,\n                PHOTOMETRIC_MASK, PREDICTOR_NONE,\n                SAMPLEFORMAT_UINT, nullptr, nullptr, nullptr, 0, nullptr, \"\", nullptr, nullptr,\n                nullptr, nullptr );\n        if( nOffset == 0 )\n            return CE_Failure;\n\n        poMaskDS = new GTiffDataset();\n        poMaskDS->bPromoteTo8Bits =\n            CPLTestBool(\n                CPLGetConfigOption(\"GDAL_TIFF_INTERNAL_MASK_TO_8BIT\", \"YES\"));\n        if( poMaskDS->OpenOffset( hTIFF, ppoActiveDSRef, nOffset,\n                                  false, GA_Update ) != CE_None)\n        {\n            delete poMaskDS;\n            poMaskDS = nullptr;\n            return CE_Failure;\n        }\n\n        return CE_None;\n    }\n\n    return GDALPamDataset::CreateMaskBand(nFlagsIn);\n}\n\n/************************************************************************/\n/*                         CreateMaskBand()                             */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::CreateMaskBand( int nFlagsIn )\n{\n    poGDS->ScanDirectories();\n\n    if( poGDS->poMaskDS != nullptr )\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                  \"This TIFF dataset has already an internal mask band\" );\n        return CE_Failure;\n    }\n\n    if( CPLTestBool( CPLGetConfigOption(\"GDAL_TIFF_INTERNAL_MASK\", \"NO\") ) )\n    {\n        return poGDS->CreateMaskBand(nFlagsIn);\n    }\n\n    return GDALPamRasterBand::CreateMaskBand(nFlagsIn);\n}\n\n/************************************************************************/\n/*                       PrepareTIFFErrorFormat()                       */\n/*                                                                      */\n/*      sometimes the \"module\" has stuff in it that has special         */\n/*      meaning in a printf() style format, so we try to escape it.     */\n/*      For now we hope the only thing we have to escape is %'s.        */\n/************************************************************************/\n\nstatic char *PrepareTIFFErrorFormat( const char *module, const char *fmt )\n\n{\n    const size_t nModuleSize = strlen(module);\n    const size_t nModFmtSize = nModuleSize * 2 + strlen(fmt) + 2;\n    char *pszModFmt = static_cast<char *>( CPLMalloc( nModFmtSize ) );\n\n    size_t iOut = 0;  // Used after for.\n\n    for( size_t iIn = 0; iIn < nModuleSize; ++iIn )\n    {\n        if( module[iIn] == '%' )\n        {\n            CPLAssert(iOut < nModFmtSize - 2);\n            pszModFmt[iOut++] = '%';\n            pszModFmt[iOut++] = '%';\n        }\n        else\n        {\n            CPLAssert(iOut < nModFmtSize - 1);\n            pszModFmt[iOut++] = module[iIn];\n        }\n    }\n    CPLAssert(iOut < nModFmtSize);\n    pszModFmt[iOut] = '\\0';\n    strcat( pszModFmt, \":\" );\n    strcat( pszModFmt, fmt );\n\n    return pszModFmt;\n}\n\n/************************************************************************/\n/*                        GTiffWarningHandler()                         */\n/************************************************************************/\nstatic void\nGTiffWarningHandler(const char* module, const char* fmt, va_list ap )\n{\n    if( strstr(fmt,\"nknown field\") != nullptr )\n        return;\n\n    char *pszModFmt = PrepareTIFFErrorFormat( module, fmt );\n    if( strstr(fmt, \"does not end in null byte\") != nullptr )\n    {\n        CPLString osMsg;\n        osMsg.vPrintf(pszModFmt, ap);\n        CPLDebug( \"GTiff\", \"%s\", osMsg.c_str() );\n    }\n    else\n    {\n        CPLErrorV( CE_Warning, CPLE_AppDefined, pszModFmt, ap );\n    }\n    CPLFree( pszModFmt );\n}\n\n/************************************************************************/\n/*                         GTiffErrorHandler()                          */\n/************************************************************************/\nstatic void\nGTiffErrorHandler( const char* module, const char* fmt, va_list ap )\n{\n#ifdef BIGTIFF_SUPPORT\n    if( strcmp(fmt, \"Maximum TIFF file size exceeded\") == 0 )\n    {\n        // Ideally there would be a thread-safe way of setting this flag,\n        // but we cannot really use the extended error handler, since the\n        // handler is for all TIFF handles, and not necessarily the ones of\n        // this driver.\n        if( bGlobalInExternalOvr )\n            fmt =\n                \"Maximum TIFF file size exceeded. \"\n                \"Use --config BIGTIFF_OVERVIEW YES configuration option.\";\n        else\n            fmt =\n                \"Maximum TIFF file size exceeded. \"\n                \"Use BIGTIFF=YES creation option.\";\n    }\n#endif\n\n    char* pszModFmt = PrepareTIFFErrorFormat( module, fmt );\n    CPLErrorV( CE_Failure, CPLE_AppDefined, pszModFmt, ap );\n    CPLFree( pszModFmt );\n}\n\n/************************************************************************/\n/*                          GTiffTagExtender()                          */\n/*                                                                      */\n/*      Install tags specially known to GDAL.                           */\n/************************************************************************/\n\nstatic TIFFExtendProc _ParentExtender = nullptr;\n\nstatic void GTiffTagExtender(TIFF *tif)\n\n{\n    const TIFFFieldInfo xtiffFieldInfo[] = {\n        { TIFFTAG_GDAL_METADATA, -1, -1, TIFF_ASCII, FIELD_CUSTOM,\n          TRUE, FALSE, const_cast<char *>( \"GDALMetadata\" ) },\n        { TIFFTAG_GDAL_NODATA, -1, -1, TIFF_ASCII, FIELD_CUSTOM,\n          TRUE, FALSE, const_cast<char*>( \"GDALNoDataValue\" ) },\n        { TIFFTAG_RPCCOEFFICIENT, -1, -1, TIFF_DOUBLE, FIELD_CUSTOM,\n          TRUE, TRUE, const_cast<char *>( \"RPCCoefficient\" ) },\n        { TIFFTAG_TIFF_RSID, -1, -1, TIFF_ASCII, FIELD_CUSTOM,\n          TRUE, FALSE, const_cast<char *>( \"TIFF_RSID\" ) },\n        { TIFFTAG_GEO_METADATA, -1, -1, TIFF_BYTE, FIELD_CUSTOM,\n          TRUE, TRUE, const_cast<char *>( \"GEO_METADATA\" ) }\n    };\n\n    if( _ParentExtender )\n        (*_ParentExtender)(tif);\n\n    TIFFMergeFieldInfo( tif, xtiffFieldInfo,\n                        sizeof(xtiffFieldInfo) / sizeof(xtiffFieldInfo[0]) );\n}\n\n/************************************************************************/\n/*                          GTiffOneTimeInit()                          */\n/*                                                                      */\n/*      This is stuff that is initialized for the TIFF library just     */\n/*      once.  We deliberately defer the initialization till the        */\n/*      first time we are likely to call into libtiff to avoid          */\n/*      unnecessary paging in of the library for GDAL apps that         */\n/*      don't use it.                                                   */\n/************************************************************************/\n#if defined(HAVE_DLFCN_H) && !defined(WIN32)\n#include <dlfcn.h>\n#endif\n\nstatic std::mutex oDeleteMutex;\n#ifdef HAVE_LERC\nstatic TIFFCodec* pLercCodec = nullptr;\n#endif\n\nint GTiffOneTimeInit()\n\n{\n    std::lock_guard<std::mutex> oLock(oDeleteMutex);\n \n#ifdef HAVE_LERC\n    if( pLercCodec == nullptr )\n    {\n        pLercCodec = TIFFRegisterCODEC(COMPRESSION_LERC, \"LERC\", TIFFInitLERC);\n    }\n#endif\n\n    static bool bOneTimeInitDone = false;\n    if( bOneTimeInitDone )\n        return TRUE;\n\n    bOneTimeInitDone = true;\n\n    // This is a frequent configuration error that is difficult to track down\n    // for people unaware of the issue : GDAL built against internal libtiff\n    // (4.X), but used by an application that links with external libtiff (3.X)\n    // Note: on my conf, the order that cause GDAL to crash - and that is\n    // detected by the following code - is \"-ltiff -lgdal\". \"-lgdal -ltiff\"\n    // works for the GTiff driver but probably breaks the application that\n    // believes it uses libtiff 3.X but we cannot detect that.\n#if defined(BIGTIFF_SUPPORT) && !defined(RENAME_INTERNAL_LIBTIFF_SYMBOLS)\n#if defined(HAVE_DLFCN_H) && !defined(WIN32)\n    const char* (*pfnVersion)(void);\n#ifdef HAVE_GCC_WARNING_ZERO_AS_NULL_POINTER_CONSTANT\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wzero-as-null-pointer-constant\"\n#endif\n    pfnVersion = reinterpret_cast<const char* (*)(void)>(dlsym(RTLD_DEFAULT, \"TIFFGetVersion\"));\n#ifdef HAVE_GCC_WARNING_ZERO_AS_NULL_POINTER_CONSTANT\n#pragma GCC diagnostic pop\n#endif\n    if( pfnVersion )\n    {\n        const char* pszVersion = pfnVersion();\n        if( pszVersion && strstr(pszVersion, \"Version 3.\") != nullptr )\n        {\n            CPLError(\n                CE_Warning, CPLE_AppDefined,\n                \"libtiff version mismatch: You're linking against libtiff 3.X, \"\n                \"but GDAL has been compiled against libtiff >= 4.0.0\" );\n        }\n    }\n#endif  // HAVE_DLFCN_H\n#endif  // BIGTIFF_SUPPORT\n\n    _ParentExtender = TIFFSetTagExtender(GTiffTagExtender);\n\n    TIFFSetWarningHandler( GTiffWarningHandler );\n    TIFFSetErrorHandler( GTiffErrorHandler );\n\n    LibgeotiffOneTimeInit();\n\n    return TRUE;\n}\n\n/************************************************************************/\n/*                        GDALDeregister_GTiff()                        */\n/************************************************************************/\n\nstatic\nvoid GDALDeregister_GTiff( GDALDriver * )\n\n{\n    CSVDeaccess( nullptr );\n\n#if defined(LIBGEOTIFF_VERSION) && LIBGEOTIFF_VERSION > 1150\n    GTIFDeaccessCSV();\n#endif\n \n#ifdef HAVE_LERC\n    if( pLercCodec )\n        TIFFUnRegisterCODEC(pLercCodec);\n    pLercCodec = nullptr;\n#endif\n\n    delete gpoCompressThreadPool;\n    gpoCompressThreadPool = nullptr;\n}\n\n/************************************************************************/\n/*                   GTIFFGetCompressionMethod()                        */\n/************************************************************************/\n\nint GTIFFGetCompressionMethod(const char* pszValue, const char* pszVariableName)\n{\n    int nCompression = COMPRESSION_NONE;\n    if( EQUAL( pszValue, \"NONE\" ) )\n        nCompression = COMPRESSION_NONE;\n    else if( EQUAL( pszValue, \"JPEG\" ) )\n        nCompression = COMPRESSION_JPEG;\n    else if( EQUAL( pszValue, \"LZW\" ) )\n        nCompression = COMPRESSION_LZW;\n    else if( EQUAL( pszValue, \"PACKBITS\" ))\n        nCompression = COMPRESSION_PACKBITS;\n    else if( EQUAL( pszValue, \"DEFLATE\" ) || EQUAL( pszValue, \"ZIP\" ))\n        nCompression = COMPRESSION_ADOBE_DEFLATE;\n    else if( EQUAL( pszValue, \"FAX3\" )\n             || EQUAL( pszValue, \"CCITTFAX3\" ))\n        nCompression = COMPRESSION_CCITTFAX3;\n    else if( EQUAL( pszValue, \"FAX4\" )\n             || EQUAL( pszValue, \"CCITTFAX4\" ))\n        nCompression = COMPRESSION_CCITTFAX4;\n    else if( EQUAL( pszValue, \"CCITTRLE\" ) )\n        nCompression = COMPRESSION_CCITTRLE;\n    else if( EQUAL( pszValue, \"LZMA\" ) )\n        nCompression = COMPRESSION_LZMA;\n    else if( EQUAL( pszValue, \"ZSTD\" ) )\n        nCompression = COMPRESSION_ZSTD;\n#ifdef HAVE_LERC\n    else if( EQUAL( pszValue, \"LERC\" ) ||\n             EQUAL( pszValue, \"LERC_DEFLATE\" ) ||\n             EQUAL( pszValue, \"LERC_ZSTD\" ) )\n    {\n        nCompression = COMPRESSION_LERC;\n    }\n#endif\n    else if( EQUAL( pszValue, \"WEBP\" ) )\n        nCompression = COMPRESSION_WEBP;\n    else\n        CPLError( CE_Warning, CPLE_IllegalArg,\n                  \"%s=%s value not recognised, ignoring.\",\n                  pszVariableName,pszValue );\n\n#if defined(TIFFLIB_VERSION) && TIFFLIB_VERSION > 20031007  // 3.6.0\n    if( nCompression != COMPRESSION_NONE &&\n        !TIFFIsCODECConfigured(static_cast<uint16>(nCompression)) )\n    {\n        CPLError(\n            CE_Failure, CPLE_AppDefined,\n            \"Cannot create TIFF file due to missing codec for %s.\", pszValue );\n        return -1;\n    }\n#endif\n\n    return nCompression;\n}\n\n/************************************************************************/\n/*                          GDALRegister_GTiff()                        */\n/************************************************************************/\n\nvoid GDALRegister_GTiff()\n\n{\n    if( GDALGetDriverByName( \"GTiff\" ) != nullptr )\n        return;\n\n    CPLString osOptions;\n    CPLString osCompressValues;\n    bool bHasJPEG = false;\n    bool bHasLZMA = false;\n    bool bHasZSTD = false;\n    bool bHasWebP = false;\n\n    GDALDriver *poDriver = new GDALDriver();\n\n/* -------------------------------------------------------------------- */\n/*      Determine which compression codecs are available that we        */\n/*      want to advertise.  If we are using an old libtiff we won't     */\n/*      be able to find out so we just assume all are available.        */\n/* -------------------------------------------------------------------- */\n    osCompressValues = \"       <Value>NONE</Value>\";\n\n#if TIFFLIB_VERSION <= 20040919\n    osCompressValues +=\n            \"       <Value>PACKBITS</Value>\"\n            \"       <Value>JPEG</Value>\"\n            \"       <Value>LZW</Value>\"\n            \"       <Value>DEFLATE</Value>\";\n    bool bHasLZW = true;\n    bool bHasDEFLATE = true;\n#else\n    bool bHasLZW = false;\n    bool bHasDEFLATE = false;\n    TIFFCodec *codecs = TIFFGetConfiguredCODECs();\n\n    for( TIFFCodec *c = codecs; c->name; ++c )\n    {\n        if( c->scheme == COMPRESSION_PACKBITS )\n        {\n            osCompressValues +=\n                    \"       <Value>PACKBITS</Value>\";\n        }\n        else if( c->scheme == COMPRESSION_JPEG )\n        {\n            bHasJPEG = true;\n            osCompressValues +=\n                    \"       <Value>JPEG</Value>\";\n        }\n        else if( c->scheme == COMPRESSION_LZW )\n        {\n            bHasLZW = true;\n            osCompressValues +=\n                    \"       <Value>LZW</Value>\";\n        }\n        else if( c->scheme == COMPRESSION_ADOBE_DEFLATE )\n        {\n            bHasDEFLATE = true;\n            osCompressValues +=\n                    \"       <Value>DEFLATE</Value>\";\n        }\n        else if( c->scheme == COMPRESSION_CCITTRLE )\n        {\n            osCompressValues +=\n                    \"       <Value>CCITTRLE</Value>\";\n        }\n        else if( c->scheme == COMPRESSION_CCITTFAX3 )\n        {\n            osCompressValues +=\n                    \"       <Value>CCITTFAX3</Value>\";\n        }\n        else if( c->scheme == COMPRESSION_CCITTFAX4 )\n        {\n            osCompressValues +=\n                    \"       <Value>CCITTFAX4</Value>\";\n        }\n        else if( c->scheme == COMPRESSION_LZMA )\n        {\n            bHasLZMA = true;\n            osCompressValues +=\n                    \"       <Value>LZMA</Value>\";\n        }\n        else if( c->scheme == COMPRESSION_ZSTD )\n        {\n            bHasZSTD = true;\n            osCompressValues +=\n                    \"       <Value>ZSTD</Value>\";\n        }\n        else if( c->scheme == COMPRESSION_WEBP )\n        {\n            bHasWebP = true;\n            osCompressValues +=\n                    \"       <Value>WEBP</Value>\";\n        }\n    }\n#ifdef HAVE_LERC\n    osCompressValues +=\n                    \"       <Value>LERC</Value>\";\n    osCompressValues +=\n                    \"       <Value>LERC_DEFLATE</Value>\";\n    if( bHasZSTD )\n    {\n        osCompressValues +=\n                    \"       <Value>LERC_ZSTD</Value>\";\n    }\n#endif\n    _TIFFfree( codecs );\n#endif\n\n/* -------------------------------------------------------------------- */\n/*      Build full creation option list.                                */\n/* -------------------------------------------------------------------- */\n    osOptions = \"<CreationOptionList>\"\n              \"   <Option name='COMPRESS' type='string-select'>\";\n    osOptions += osCompressValues;\n    osOptions += \"   </Option>\";\n    if( bHasLZW || bHasDEFLATE || bHasZSTD )\n        osOptions += \"\"\n\"   <Option name='PREDICTOR' type='int' description='Predictor Type (1=default, 2=horizontal differencing, 3=floating point prediction)'/>\";\n    osOptions += \"\"\n\"   <Option name='DISCARD_LSB' type='string' description='Number of least-significant bits to set to clear as a single value or comma-separated list of values for per-band values'/>\";\n    if( bHasJPEG )\n    {\n        osOptions += \"\"\n\"   <Option name='JPEG_QUALITY' type='int' description='JPEG quality 1-100' default='75'/>\"\n\"   <Option name='JPEGTABLESMODE' type='int' description='Content of JPEGTABLES tag. 0=no JPEGTABLES tag, 1=Quantization tables only, 2=Huffman tables only, 3=Both' default='1'/>\";\n#ifdef JPEG_DIRECT_COPY\n        osOptions += \"\"\n\"   <Option name='JPEG_DIRECT_COPY' type='boolean' description='To copy without any decompression/recompression a JPEG source file' default='NO'/>\";\n#endif\n    }\n    if( bHasDEFLATE )\n        osOptions += \"\"\n\"   <Option name='ZLEVEL' type='int' description='DEFLATE compression level 1-9' default='6'/>\";\n    if( bHasLZMA )\n        osOptions += \"\"\n\"   <Option name='LZMA_PRESET' type='int' description='LZMA compression level 0(fast)-9(slow)' default='6'/>\";\n    if( bHasZSTD )\n        osOptions += \"\"\n\"   <Option name='ZSTD_LEVEL' type='int' description='ZSTD compression level 1(fast)-22(slow)' default='9'/>\";\n#ifdef HAVE_LERC\n    osOptions += \"\"\n\"   <Option name='MAX_Z_ERROR' type='float' description='Maximum error for LERC compression' default='0'/>\";\n#endif\n    if ( bHasWebP )\n    {\n      osOptions += \"\"\n#if WEBP_ENCODER_ABI_VERSION >= 0x0100\n\"   <Option name='WEBP_LOSSLESS' type='boolean' description='Whether lossless compression should be used' default='FALSE'/>\"\n#endif\n\"   <Option name='WEBP_LEVEL' type='int' description='WEBP quality level. Low values result in higher compression ratios' default='75'/>\";\n    }\n    osOptions += \"\"\n\"   <Option name='NUM_THREADS' type='string' description='Number of worker threads for compression. Can be set to ALL_CPUS' default='1'/>\"\n\"   <Option name='NBITS' type='int' description='BITS for sub-byte files (1-7), sub-uint16 (9-15), sub-uint32 (17-31), or float32 (16)'/>\"\n\"   <Option name='INTERLEAVE' type='string-select' default='PIXEL'>\"\n\"       <Value>BAND</Value>\"\n\"       <Value>PIXEL</Value>\"\n\"   </Option>\"\n\"   <Option name='TILED' type='boolean' description='Switch to tiled format'/>\"\n\"   <Option name='TFW' type='boolean' description='Write out world file'/>\"\n\"   <Option name='RPB' type='boolean' description='Write out .RPB (RPC) file'/>\"\n\"   <Option name='RPCTXT' type='boolean' description='Write out _RPC.TXT file'/>\"\n\"   <Option name='BLOCKXSIZE' type='int' description='Tile Width'/>\"\n\"   <Option name='BLOCKYSIZE' type='int' description='Tile/Strip Height'/>\"\n\"   <Option name='PHOTOMETRIC' type='string-select'>\"\n\"       <Value>MINISBLACK</Value>\"\n\"       <Value>MINISWHITE</Value>\"\n\"       <Value>PALETTE</Value>\"\n\"       <Value>RGB</Value>\"\n\"       <Value>CMYK</Value>\"\n\"       <Value>YCBCR</Value>\"\n\"       <Value>CIELAB</Value>\"\n\"       <Value>ICCLAB</Value>\"\n\"       <Value>ITULAB</Value>\"\n\"   </Option>\"\n\"   <Option name='SPARSE_OK' type='boolean' description='Should empty blocks be omitted on disk?' default='FALSE'/>\"\n\"   <Option name='ALPHA' type='string-select' description='Mark first extrasample as being alpha'>\"\n\"       <Value>NON-PREMULTIPLIED</Value>\"\n\"       <Value>PREMULTIPLIED</Value>\"\n\"       <Value>UNSPECIFIED</Value>\"\n\"       <Value aliasOf='NON-PREMULTIPLIED'>YES</Value>\"\n\"       <Value aliasOf='UNSPECIFIED'>NO</Value>\"\n\"   </Option>\"\n\"   <Option name='PROFILE' type='string-select' default='GDALGeoTIFF'>\"\n\"       <Value>GDALGeoTIFF</Value>\"\n\"       <Value>GeoTIFF</Value>\"\n\"       <Value>BASELINE</Value>\"\n\"   </Option>\"\n\"   <Option name='PIXELTYPE' type='string-select'>\"\n\"       <Value>DEFAULT</Value>\"\n\"       <Value>SIGNEDBYTE</Value>\"\n\"   </Option>\"\n#ifdef BIGTIFF_SUPPORT\n\"   <Option name='BIGTIFF' type='string-select' description='Force creation of BigTIFF file'>\"\n\"     <Value>YES</Value>\"\n\"     <Value>NO</Value>\"\n\"     <Value>IF_NEEDED</Value>\"\n\"     <Value>IF_SAFER</Value>\"\n\"   </Option>\"\n#endif\n\"   <Option name='ENDIANNESS' type='string-select' default='NATIVE' description='Force endianness of created file. For DEBUG purpose mostly'>\"\n\"       <Value>NATIVE</Value>\"\n\"       <Value>INVERTED</Value>\"\n\"       <Value>LITTLE</Value>\"\n\"       <Value>BIG</Value>\"\n\"   </Option>\"\n\"   <Option name='COPY_SRC_OVERVIEWS' type='boolean' default='NO' description='Force copy of overviews of source dataset (CreateCopy())'/>\"\n\"   <Option name='SOURCE_ICC_PROFILE' type='string' description='ICC profile'/>\"\n\"   <Option name='SOURCE_PRIMARIES_RED' type='string' description='x,y,1.0 (xyY) red chromaticity'/>\"\n\"   <Option name='SOURCE_PRIMARIES_GREEN' type='string' description='x,y,1.0 (xyY) green chromaticity'/>\"\n\"   <Option name='SOURCE_PRIMARIES_BLUE' type='string' description='x,y,1.0 (xyY) blue chromaticity'/>\"\n\"   <Option name='SOURCE_WHITEPOINT' type='string' description='x,y,1.0 (xyY) whitepoint'/>\"\n\"   <Option name='TIFFTAG_TRANSFERFUNCTION_RED' type='string' description='Transfer function for red'/>\"\n\"   <Option name='TIFFTAG_TRANSFERFUNCTION_GREEN' type='string' description='Transfer function for green'/>\"\n\"   <Option name='TIFFTAG_TRANSFERFUNCTION_BLUE' type='string' description='Transfer function for blue'/>\"\n\"   <Option name='TIFFTAG_TRANSFERRANGE_BLACK' type='string' description='Transfer range for black'/>\"\n\"   <Option name='TIFFTAG_TRANSFERRANGE_WHITE' type='string' description='Transfer range for white'/>\"\n\"   <Option name='STREAMABLE_OUTPUT' type='boolean' default='NO' description='Enforce a mode compatible with a streamable file'/>\"\n\"   <Option name='GEOTIFF_KEYS_FLAVOR' type='string-select' default='STANDARD' description='Which flavor of GeoTIFF keys must be used'>\"\n\"       <Value>STANDARD</Value>\"\n\"       <Value>ESRI_PE</Value>\"\n\"   </Option>\"\n\"</CreationOptionList>\";\n\n/* -------------------------------------------------------------------- */\n/*      Set the driver details.                                         */\n/* -------------------------------------------------------------------- */\n    poDriver->SetDescription( \"GTiff\" );\n    poDriver->SetMetadataItem( GDAL_DCAP_RASTER, \"YES\" );\n    poDriver->SetMetadataItem( GDAL_DMD_LONGNAME, \"GeoTIFF\" );\n    poDriver->SetMetadataItem( GDAL_DMD_HELPTOPIC, \"frmt_gtiff.html\" );\n    poDriver->SetMetadataItem( GDAL_DMD_MIMETYPE, \"image/tiff\" );\n    poDriver->SetMetadataItem( GDAL_DMD_EXTENSION, \"tif\" );\n    poDriver->SetMetadataItem( GDAL_DMD_EXTENSIONS, \"tif tiff\" );\n    poDriver->SetMetadataItem( GDAL_DMD_CREATIONDATATYPES,\n                               \"Byte UInt16 Int16 UInt32 Int32 Float32 \"\n                               \"Float64 CInt16 CInt32 CFloat32 CFloat64\" );\n    poDriver->SetMetadataItem( GDAL_DMD_CREATIONOPTIONLIST, osOptions );\n    poDriver->SetMetadataItem( GDAL_DMD_OPENOPTIONLIST,\n\"<OpenOptionList>\"\n\"   <Option name='NUM_THREADS' type='string' description='Number of worker threads for compression. Can be set to ALL_CPUS' default='1'/>\"\n\"   <Option name='GEOTIFF_KEYS_FLAVOR' type='string-select' default='STANDARD' description='Which flavor of GeoTIFF keys must be used (for writing)'>\"\n\"       <Value>STANDARD</Value>\"\n\"       <Value>ESRI_PE</Value>\"\n\"   </Option>\"\n\"   <Option name='GEOREF_SOURCES' type='string' description='Comma separated list made with values INTERNAL/TABFILE/WORLDFILE/PAM/NONE that describe the priority order for georeferencing' default='PAM,INTERNAL,TABFILE,WORLDFILE'/>\"\n\"   <Option name='SPARSE_OK' type='boolean' description='Should empty blocks be omitted on disk?' default='FALSE'/>\"\n\"</OpenOptionList>\" );\n    poDriver->SetMetadataItem( GDAL_DMD_SUBDATASETS, \"YES\" );\n    poDriver->SetMetadataItem( GDAL_DCAP_VIRTUALIO, \"YES\" );\n\n#ifdef INTERNAL_LIBTIFF\n    poDriver->SetMetadataItem( \"LIBTIFF\", \"INTERNAL\" );\n#else\n    poDriver->SetMetadataItem( \"LIBTIFF\", TIFFLIB_VERSION_STR );\n#endif\n\n    poDriver->pfnOpen = GTiffDataset::Open;\n    poDriver->pfnCreate = GTiffDataset::Create;\n    poDriver->pfnCreateCopy = GTiffDataset::CreateCopy;\n    poDriver->pfnUnloadDriver = GDALDeregister_GTiff;\n    poDriver->pfnIdentify = GTiffDataset::Identify;\n\n    GetGDALDriverManager()->RegisterDriver( poDriver );\n}\n",
                "name": "geotiff.cpp",
                "path": "deps/libgdal/gdal/frmts/gtiff/geotiff.cpp",
                "url": "/github.com/naturalatlas/node-gdal/-/blob/deps/libgdal/gdal/frmts/gtiff/geotiff.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 5960,
                    "offsetAndLengths": [
                        [
                            16,
                            16
                        ]
                    ],
                    "preview": "            if( TIFFReadRGBATileExt("
                },
                {
                    "limitHit": false,
                    "lineNumber": 5968,
                    "offsetAndLengths": [
                        [
                            16,
                            16
                        ]
                    ],
                    "preview": "            if( TIFFReadRGBATile("
                },
                {
                    "limitHit": false,
                    "lineNumber": 5978,
                    "offsetAndLengths": [
                        [
                            27,
                            16
                        ]
                    ],
                    "preview": "                          \"TIFFReadRGBATile() failed.\" );"
                }
            ],
            "repository": {
                "name": "github.com/naturalatlas/node-gdal",
                "url": "/github.com/naturalatlas/node-gdal"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "f485b59d7b43b0a2f77a5ab547e2597929f7094a"
                },
                "content": "/*M///////////////////////////////////////////////////////////////////////////////////////\n//\n//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.\n//\n//  By downloading, copying, installing or using the software you agree to this license.\n//  If you do not agree to this license, do not download, install,\n//  copy or use the software.\n//\n//\n//                           License Agreement\n//                For Open Source Computer Vision Library\n//\n// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.\n// Copyright (C) 2009, Willow Garage Inc., all rights reserved.\n// Third party copyrights are property of their respective owners.\n//\n// Redistribution and use in source and binary forms, with or without modification,\n// are permitted provided that the following conditions are met:\n//\n//   * Redistribution's of source code must retain the above copyright notice,\n//     this list of conditions and the following disclaimer.\n//\n//   * Redistribution's in binary form must reproduce the above copyright notice,\n//     this list of conditions and the following disclaimer in the documentation\n//     and/or other materials provided with the distribution.\n//\n//   * The name of the copyright holders may not be used to endorse or promote products\n//     derived from this software without specific prior written permission.\n//\n// This software is provided by the copyright holders and contributors \"as is\" and\n// any express or implied warranties, including, but not limited to, the implied\n// warranties of merchantability and fitness for a particular purpose are disclaimed.\n// In no event shall the Intel Corporation or contributors be liable for any direct,\n// indirect, incidental, special, exemplary, or consequential damages\n// (including, but not limited to, procurement of substitute goods or services;\n// loss of use, data, or profits; or business interruption) however caused\n// and on any theory of liability, whether in contract, strict liability,\n// or tort (including negligence or otherwise) arising in any way out of\n// the use of this software, even if advised of the possibility of such damage.\n//\n//M*/\n\n/****************************************************************************************\\\n    A part of the file implements TIFF reader on base of libtiff library\n    (see otherlibs/_graphics/readme.txt for copyright notice)\n\\****************************************************************************************/\n\n#include \"precomp.hpp\"\n\n#ifdef HAVE_TIFF\n#include <opencv2/core/utils/logger.hpp>\n\n#include \"grfmt_tiff.hpp\"\n#include <limits>\n\n// TODO FIXIT Conflict declarations for common types like int64/uint64\nnamespace tiff_dummy_namespace {\n#include \"tiff.h\"\n#include \"tiffio.h\"\n}\nusing namespace tiff_dummy_namespace;\n\nnamespace cv\n{\n\n#define CV_TIFF_CHECK_CALL(call) \\\n    if (0 == (call)) { \\\n        CV_LOG_WARNING(NULL, \"OpenCV TIFF(line \" << __LINE__ << \"): failed \" #call); \\\n        CV_Error(Error::StsError, \"OpenCV TIFF: failed \" #call); \\\n    }\n\n#define CV_TIFF_CHECK_CALL_INFO(call) \\\n    if (0 == (call)) { \\\n        CV_LOG_INFO(NULL, \"OpenCV TIFF(line \" << __LINE__ << \"): failed optional call: \" #call \", ignoring\"); \\\n    }\n\n#define CV_TIFF_CHECK_CALL_DEBUG(call) \\\n    if (0 == (call)) { \\\n        CV_LOG_DEBUG(NULL, \"OpenCV TIFF(line \" << __LINE__ << \"): failed optional call: \" #call \", ignoring\"); \\\n    }\n\nstatic void cv_tiffCloseHandle(void* handle)\n{\n    TIFFClose((TIFF*)handle);\n}\n\nstatic void cv_tiffErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    if (cv::utils::logging::getLogLevel() < cv::utils::logging::LOG_LEVEL_DEBUG)\n        return;\n    // TODO cv::vformat() with va_list parameter\n    fprintf(stderr, \"OpenCV TIFF: \");\n    if (module != NULL)\n        fprintf(stderr, \"%s: \", module);\n    fprintf(stderr, \"Warning, \");\n    vfprintf(stderr, fmt, ap);\n    fprintf(stderr, \".\\n\");\n}\n\nstatic bool cv_tiffSetErrorHandler_()\n{\n    TIFFSetErrorHandler(cv_tiffErrorHandler);\n    TIFFSetWarningHandler(cv_tiffErrorHandler);\n    return true;\n}\n\nstatic bool cv_tiffSetErrorHandler()\n{\n    static bool v = cv_tiffSetErrorHandler_();\n    return v;\n}\n\nstatic const char fmtSignTiffII[] = \"II\\x2a\\x00\";\nstatic const char fmtSignTiffMM[] = \"MM\\x00\\x2a\";\n\nTiffDecoder::TiffDecoder()\n{\n    m_hdr = false;\n    m_buf_supported = true;\n    m_buf_pos = 0;\n}\n\n\nvoid TiffDecoder::close()\n{\n    m_tif.release();\n}\n\nTiffDecoder::~TiffDecoder()\n{\n    close();\n}\n\nsize_t TiffDecoder::signatureLength() const\n{\n    return 4;\n}\n\nbool TiffDecoder::checkSignature( const String& signature ) const\n{\n    return signature.size() >= 4 &&\n        (memcmp(signature.c_str(), fmtSignTiffII, 4) == 0 ||\n        memcmp(signature.c_str(), fmtSignTiffMM, 4) == 0);\n}\n\nint TiffDecoder::normalizeChannelsNumber(int channels) const\n{\n    CV_Assert(channels <= 4);\n    return channels > 4 ? 4 : channels;\n}\n\nImageDecoder TiffDecoder::newDecoder() const\n{\n    cv_tiffSetErrorHandler();\n    return makePtr<TiffDecoder>();\n}\n\nclass TiffDecoderBufHelper\n{\n    Mat& m_buf;\n    size_t& m_buf_pos;\npublic:\n    TiffDecoderBufHelper(Mat& buf, size_t& buf_pos) :\n        m_buf(buf), m_buf_pos(buf_pos)\n    {}\n    static tmsize_t read( thandle_t handle, void* buffer, tmsize_t n )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        const Mat& buf = helper->m_buf;\n        const tmsize_t size = buf.cols*buf.rows*buf.elemSize();\n        tmsize_t pos = helper->m_buf_pos;\n        if ( n > (size - pos) )\n        {\n            n = size - pos;\n        }\n        memcpy(buffer, buf.ptr() + pos, n);\n        helper->m_buf_pos += n;\n        return n;\n    }\n\n    static tmsize_t write( thandle_t /*handle*/, void* /*buffer*/, tmsize_t /*n*/ )\n    {\n        // Not used for decoding.\n        return 0;\n    }\n\n    static toff_t seek( thandle_t handle, toff_t offset, int whence )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        const Mat& buf = helper->m_buf;\n        const toff_t size = buf.cols*buf.rows*buf.elemSize();\n        toff_t new_pos = helper->m_buf_pos;\n        switch (whence)\n        {\n            case SEEK_SET:\n                new_pos = offset;\n                break;\n            case SEEK_CUR:\n                new_pos += offset;\n                break;\n            case SEEK_END:\n                new_pos = size + offset;\n                break;\n        }\n        new_pos = std::min(new_pos, size);\n        helper->m_buf_pos = (size_t)new_pos;\n        return new_pos;\n    }\n\n    static int map( thandle_t handle, void** base, toff_t* size )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        Mat& buf = helper->m_buf;\n        *base = buf.ptr();\n        *size = buf.cols*buf.rows*buf.elemSize();\n        return 0;\n    }\n\n    static toff_t size( thandle_t handle )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        const Mat& buf = helper->m_buf;\n        return buf.cols*buf.rows*buf.elemSize();\n    }\n\n    static int close( thandle_t handle )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        delete helper;\n        return 0;\n    }\n};\n\nbool TiffDecoder::readHeader()\n{\n    bool result = false;\n\n    TIFF* tif = static_cast<TIFF*>(m_tif.get());\n    if (!tif)\n    {\n        // TIFFOpen() mode flags are different to fopen().  A 'b' in mode \"rb\" has no effect when reading.\n        // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n        if ( !m_buf.empty() )\n        {\n            m_buf_pos = 0;\n            TiffDecoderBufHelper* buf_helper = new TiffDecoderBufHelper(this->m_buf, this->m_buf_pos);\n            tif = TIFFClientOpen( \"\", \"r\", reinterpret_cast<thandle_t>(buf_helper), &TiffDecoderBufHelper::read,\n                                  &TiffDecoderBufHelper::write, &TiffDecoderBufHelper::seek,\n                                  &TiffDecoderBufHelper::close, &TiffDecoderBufHelper::size,\n                                  &TiffDecoderBufHelper::map, /*unmap=*/0 );\n            if (!tif)\n                delete buf_helper;\n        }\n        else\n        {\n            tif = TIFFOpen(m_filename.c_str(), \"r\");\n        }\n        if (tif)\n            m_tif.reset(tif, cv_tiffCloseHandle);\n        else\n            m_tif.release();\n    }\n\n    if (tif)\n    {\n        uint32 wdth = 0, hght = 0;\n        uint16 photometric = 0;\n\n        CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &wdth));\n        CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &hght));\n        CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric));\n\n        {\n            bool isGrayScale = photometric == PHOTOMETRIC_MINISWHITE || photometric == PHOTOMETRIC_MINISBLACK;\n            uint16 bpp = 8, ncn = isGrayScale ? 1 : 3;\n            CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bpp));\n            CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &ncn));\n\n            m_width = wdth;\n            m_height = hght;\n            if (ncn == 3 && photometric == PHOTOMETRIC_LOGLUV)\n            {\n                m_type = CV_32FC3;\n                m_hdr = true;\n                return true;\n            }\n            m_hdr = false;\n\n            if( bpp > 8 &&\n               ((photometric > 2) ||\n                (ncn != 1 && ncn != 3 && ncn != 4)))\n                bpp = 8;\n\n            int wanted_channels = normalizeChannelsNumber(ncn);\n            switch(bpp)\n            {\n                case 1:\n                    m_type = CV_MAKETYPE(CV_8U, !isGrayScale ? wanted_channels : 1);\n                    result = true;\n                    break;\n                case 8:\n                    m_type = CV_MAKETYPE(CV_8U, !isGrayScale ? wanted_channels : 1);\n                    result = true;\n                    break;\n                case 16:\n                    m_type = CV_MAKETYPE(CV_16U, !isGrayScale ? wanted_channels : 1);\n                    result = true;\n                    break;\n                case 32:\n                    m_type = CV_MAKETYPE(CV_32F, wanted_channels);\n                    result = true;\n                    break;\n                case 64:\n                    m_type = CV_MAKETYPE(CV_64F, wanted_channels);\n                    result = true;\n                    break;\n            default:\n                CV_Error(cv::Error::StsError, \"Invalid bitsperpixel value read from TIFF header! Must be 1, 8, 16, 32 or 64.\");\n            }\n        }\n    }\n\n    if( !result )\n        close();\n\n    return result;\n}\n\nbool TiffDecoder::nextPage()\n{\n    // Prepare the next page, if any.\n    return !m_tif.empty() &&\n           TIFFReadDirectory(static_cast<TIFF*>(m_tif.get())) &&\n           readHeader();\n}\n\nstatic void fixOrientationPartial(Mat &img, uint16 orientation)\n{\n    switch(orientation) {\n        case ORIENTATION_RIGHTTOP:\n        case ORIENTATION_LEFTBOT:\n            flip(img, img, -1);\n            /* fall through */\n\n        case ORIENTATION_LEFTTOP:\n        case ORIENTATION_RIGHTBOT:\n            transpose(img, img);\n            break;\n    }\n}\n\nstatic void fixOrientationFull(Mat &img, int orientation)\n{\n    switch(orientation) {\n        case ORIENTATION_TOPRIGHT:\n            flip(img, img, 1);\n            break;\n\n        case ORIENTATION_BOTRIGHT:\n            flip(img, img, -1);\n            break;\n\n        case ORIENTATION_BOTLEFT:\n            flip(img, img, 0);\n            break;\n\n        case ORIENTATION_LEFTTOP:\n            transpose(img, img);\n            break;\n\n        case ORIENTATION_RIGHTTOP:\n            transpose(img, img);\n            flip(img, img, 1);\n            break;\n\n        case ORIENTATION_RIGHTBOT:\n            transpose(img, img);\n            flip(img, img, -1);\n            break;\n\n        case ORIENTATION_LEFTBOT:\n            transpose(img, img);\n            flip(img, img, 0);\n            break;\n    }\n}\n\n/**\n * Fix orientation defined in tag 274.\n * For 8 bit some corrections are done by TIFFReadRGBAStrip/Tile already.\n * Not so for 16/32/64 bit.\n */\nstatic void fixOrientation(Mat &img, uint16 orientation, int dst_bpp)\n{\n    switch(dst_bpp) {\n        case 8:\n            fixOrientationPartial(img, orientation);\n            break;\n\n        case 16:\n        case 32:\n        case 64:\n            fixOrientationFull(img, orientation);\n            break;\n    }\n}\n\nbool  TiffDecoder::readData( Mat& img )\n{\n    int type = img.type();\n    int depth = CV_MAT_DEPTH(type);\n\n    CV_Assert(!m_tif.empty());\n    TIFF* tif = (TIFF*)m_tif.get();\n\n    uint16 photometric = (uint16)-1;\n    CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric));\n\n    if (m_hdr && depth >= CV_32F)\n    {\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_FLOAT));\n    }\n\n    bool color = img.channels() > 1;\n\n    CV_CheckType(type, depth == CV_8U || depth == CV_16U || depth == CV_32F || depth == CV_64F, \"\");\n\n    if (m_width && m_height)\n    {\n        int is_tiled = TIFFIsTiled(tif) != 0;\n        bool isGrayScale = photometric == PHOTOMETRIC_MINISWHITE || photometric == PHOTOMETRIC_MINISBLACK;\n        uint16 bpp = 8, ncn = isGrayScale ? 1 : 3;\n        CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bpp));\n        CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &ncn));\n        uint16 img_orientation = ORIENTATION_TOPLEFT;\n        CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_ORIENTATION, &img_orientation));\n        const int bitsPerByte = 8;\n        int dst_bpp = (int)(img.elemSize1() * bitsPerByte);\n        bool vert_flip = dst_bpp == 8 &&\n                        (img_orientation == ORIENTATION_BOTRIGHT || img_orientation == ORIENTATION_RIGHTBOT ||\n                         img_orientation == ORIENTATION_BOTLEFT || img_orientation == ORIENTATION_LEFTBOT);\n        int wanted_channels = normalizeChannelsNumber(img.channels());\n\n        if (dst_bpp == 8)\n        {\n            char errmsg[1024];\n            if (!TIFFRGBAImageOK(tif, errmsg))\n            {\n                CV_LOG_WARNING(NULL, \"OpenCV TIFF: TIFFRGBAImageOK: \" << errmsg);\n                close();\n                return false;\n            }\n        }\n\n        uint32 tile_width0 = m_width, tile_height0 = 0;\n\n        if (is_tiled)\n        {\n            CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_TILEWIDTH, &tile_width0));\n            CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_TILELENGTH, &tile_height0));\n        }\n        else\n        {\n            // optional\n            CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &tile_height0));\n        }\n\n        {\n            if (tile_width0 == 0)\n                tile_width0 = m_width;\n\n            if (tile_height0 == 0 ||\n                    (!is_tiled && tile_height0 == std::numeric_limits<uint32>::max()) )\n                tile_height0 = m_height;\n\n            const int TILE_MAX_WIDTH = (1 << 24);\n            const int TILE_MAX_HEIGHT = (1 << 24);\n            CV_Assert((int)tile_width0 > 0 && (int)tile_width0 <= TILE_MAX_WIDTH);\n            CV_Assert((int)tile_height0 > 0 && (int)tile_height0 <= TILE_MAX_HEIGHT);\n            const uint64_t MAX_TILE_SIZE = (CV_BIG_UINT(1) << 30);\n            CV_CheckLE((int)ncn, 4, \"\");\n            CV_CheckLE((int)bpp, 64, \"\");\n            CV_Assert(((uint64_t)tile_width0 * tile_height0 * ncn * std::max(1, (int)(bpp / bitsPerByte)) < MAX_TILE_SIZE) && \"TIFF tile size is too large: >= 1Gb\");\n\n            if (dst_bpp == 8)\n            {\n                // we will use TIFFReadRGBA* functions, so allocate temporary buffer for 32bit RGBA\n                bpp = 8;\n                ncn = 4;\n            }\n            else if (dst_bpp == 32 || dst_bpp == 64)\n            {\n                CV_Assert(ncn == img.channels());\n                CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP));\n            }\n            const size_t buffer_size = (bpp / bitsPerByte) * ncn * tile_height0 * tile_width0;\n            AutoBuffer<uchar> _buffer(buffer_size);\n            uchar* buffer = _buffer.data();\n            ushort* buffer16 = (ushort*)buffer;\n            int tileidx = 0;\n\n            for (int y = 0; y < m_height; y += (int)tile_height0)\n            {\n                int tile_height = std::min((int)tile_height0, m_height - y);\n\n                const int img_y = vert_flip ? m_height - y - tile_height : y;\n\n                for(int x = 0; x < m_width; x += (int)tile_width0, tileidx++)\n                {\n                    int tile_width = std::min((int)tile_width0, m_width - x);\n\n                    switch (dst_bpp)\n                    {\n                        case 8:\n                        {\n                            uchar* bstart = buffer;\n                            if (!is_tiled)\n                            {\n                                CV_TIFF_CHECK_CALL(TIFFReadRGBAStrip(tif, y, (uint32*)buffer));\n                            }\n                            else\n                            {\n                                CV_TIFF_CHECK_CALL(TIFFReadRGBATile(tif, x, y, (uint32*)buffer));\n                                // Tiles fill the buffer from the bottom up\n                                bstart += (tile_height0 - tile_height) * tile_width0 * 4;\n                            }\n\n                            for (int i = 0; i < tile_height; i++)\n                            {\n                                if (color)\n                                {\n                                    if (wanted_channels == 4)\n                                    {\n                                        icvCvt_BGRA2RGBA_8u_C4R(bstart + i*tile_width0*4, 0,\n                                                img.ptr(img_y + tile_height - i - 1, x), 0,\n                                                Size(tile_width, 1) );\n                                    }\n                                    else\n                                    {\n                                        CV_CheckEQ(wanted_channels, 3, \"TIFF-8bpp: BGR/BGRA images are supported only\");\n                                        icvCvt_BGRA2BGR_8u_C4C3R(bstart + i*tile_width0*4, 0,\n                                                img.ptr(img_y + tile_height - i - 1, x), 0,\n                                                Size(tile_width, 1), 2);\n                                    }\n                                }\n                                else\n                                {\n                                    CV_CheckEQ(wanted_channels, 1, \"\");\n                                    icvCvt_BGRA2Gray_8u_C4C1R( bstart + i*tile_width0*4, 0,\n                                            img.ptr(img_y + tile_height - i - 1, x), 0,\n                                            Size(tile_width, 1), 2);\n                                }\n                            }\n                            break;\n                        }\n\n                        case 16:\n                        {\n                            if (!is_tiled)\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedStrip(tif, tileidx, (uint32*)buffer, buffer_size) >= 0);\n                            }\n                            else\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedTile(tif, tileidx, (uint32*)buffer, buffer_size) >= 0);\n                            }\n\n                            for (int i = 0; i < tile_height; i++)\n                            {\n                                if (color)\n                                {\n                                    if (ncn == 1)\n                                    {\n                                        CV_CheckEQ(wanted_channels, 3, \"\");\n                                        icvCvt_Gray2BGR_16u_C1C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1));\n                                    }\n                                    else if (ncn == 3)\n                                    {\n                                        CV_CheckEQ(wanted_channels, 3, \"\");\n                                        icvCvt_RGB2BGR_16u_C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1));\n                                    }\n                                    else if (ncn == 4)\n                                    {\n                                        if (wanted_channels == 4)\n                                        {\n                                            icvCvt_BGRA2RGBA_16u_C4R(buffer16 + i*tile_width0*ncn, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1));\n                                        }\n                                        else\n                                        {\n                                            CV_CheckEQ(wanted_channels, 3, \"TIFF-16bpp: BGR/BGRA images are supported only\");\n                                            icvCvt_BGRA2BGR_16u_C4C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1), 2);\n                                        }\n                                    }\n                                    else\n                                    {\n                                        CV_Error(Error::StsError, \"Not supported\");\n                                    }\n                                }\n                                else\n                                {\n                                    CV_CheckEQ(wanted_channels, 1, \"\");\n                                    if( ncn == 1 )\n                                    {\n                                        memcpy(img.ptr<ushort>(img_y + i, x),\n                                               buffer16 + i*tile_width0*ncn,\n                                               tile_width*sizeof(ushort));\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2Gray_16u_CnC1R(buffer16 + i*tile_width0*ncn, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1), ncn, 2);\n                                    }\n                                }\n                            }\n                            break;\n                        }\n\n                        case 32:\n                        case 64:\n                        {\n                            if( !is_tiled )\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedStrip(tif, tileidx, buffer, buffer_size) >= 0);\n                            }\n                            else\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedTile(tif, tileidx, buffer, buffer_size) >= 0);\n                            }\n\n                            Mat m_tile(Size(tile_width0, tile_height0), CV_MAKETYPE((dst_bpp == 32) ? CV_32F : CV_64F, ncn), buffer);\n                            Rect roi_tile(0, 0, tile_width, tile_height);\n                            Rect roi_img(x, img_y, tile_width, tile_height);\n                            if (!m_hdr && ncn == 3)\n                                cvtColor(m_tile(roi_tile), img(roi_img), COLOR_RGB2BGR);\n                            else if (!m_hdr && ncn == 4)\n                                cvtColor(m_tile(roi_tile), img(roi_img), COLOR_RGBA2BGRA);\n                            else\n                                m_tile(roi_tile).copyTo(img(roi_img));\n                            break;\n                        }\n                        default:\n                        {\n                            CV_Assert(0 && \"OpenCV TIFF: unsupported depth\");\n                        }\n                    }  // switch (dst_bpp)\n                }  // for x\n            }  // for y\n        }\n        fixOrientation(img, img_orientation, dst_bpp);\n    }\n\n    if (m_hdr && depth >= CV_32F)\n    {\n        CV_Assert(photometric == PHOTOMETRIC_LOGLUV);\n        cvtColor(img, img, COLOR_XYZ2BGR);\n    }\n    return true;\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////\n\nTiffEncoder::TiffEncoder()\n{\n    m_description = \"TIFF Files (*.tiff;*.tif)\";\n    m_buf_supported = true;\n}\n\nTiffEncoder::~TiffEncoder()\n{\n}\n\nImageEncoder TiffEncoder::newEncoder() const\n{\n    return makePtr<TiffEncoder>();\n}\n\nbool TiffEncoder::isFormatSupported( int depth ) const\n{\n    return depth == CV_8U || depth == CV_16U || depth == CV_32F || depth == CV_64F;\n}\n\nvoid  TiffEncoder::writeTag( WLByteStream& strm, TiffTag tag,\n                             TiffFieldType fieldType,\n                             int count, int value )\n{\n    strm.putWord( tag );\n    strm.putWord( fieldType );\n    strm.putDWord( count );\n    strm.putDWord( value );\n}\n\nclass TiffEncoderBufHelper\n{\npublic:\n\n    TiffEncoderBufHelper(std::vector<uchar> *buf)\n            : m_buf(buf), m_buf_pos(0)\n    {}\n\n    TIFF* open ()\n    {\n        // do NOT put \"wb\" as the mode, because the b means \"big endian\" mode, not \"binary\" mode.\n        // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n        return TIFFClientOpen( \"\", \"w\", reinterpret_cast<thandle_t>(this), &TiffEncoderBufHelper::read,\n                               &TiffEncoderBufHelper::write, &TiffEncoderBufHelper::seek,\n                               &TiffEncoderBufHelper::close, &TiffEncoderBufHelper::size,\n                               /*map=*/0, /*unmap=*/0 );\n    }\n\n    static tmsize_t read( thandle_t /*handle*/, void* /*buffer*/, tmsize_t /*n*/ )\n    {\n        // Not used for encoding.\n        return 0;\n    }\n\n    static tmsize_t write( thandle_t handle, void* buffer, tmsize_t n )\n    {\n        TiffEncoderBufHelper *helper = reinterpret_cast<TiffEncoderBufHelper*>(handle);\n        size_t begin = (size_t)helper->m_buf_pos;\n        size_t end = begin + n;\n        if ( helper->m_buf->size() < end )\n        {\n            helper->m_buf->resize(end);\n        }\n        memcpy(&(*helper->m_buf)[begin], buffer, n);\n        helper->m_buf_pos = end;\n        return n;\n    }\n\n    static toff_t seek( thandle_t handle, toff_t offset, int whence )\n    {\n        TiffEncoderBufHelper *helper = reinterpret_cast<TiffEncoderBufHelper*>(handle);\n        const toff_t size = helper->m_buf->size();\n        toff_t new_pos = helper->m_buf_pos;\n        switch (whence)\n        {\n            case SEEK_SET:\n                new_pos = offset;\n                break;\n            case SEEK_CUR:\n                new_pos += offset;\n                break;\n            case SEEK_END:\n                new_pos = size + offset;\n                break;\n        }\n        helper->m_buf_pos = new_pos;\n        return new_pos;\n    }\n\n    static toff_t size( thandle_t handle )\n    {\n        TiffEncoderBufHelper *helper = reinterpret_cast<TiffEncoderBufHelper*>(handle);\n        return helper->m_buf->size();\n    }\n\n    static int close( thandle_t /*handle*/ )\n    {\n        // Do nothing.\n        return 0;\n    }\n\nprivate:\n\n    std::vector<uchar>* m_buf;\n    toff_t m_buf_pos;\n};\n\nstatic bool readParam(const std::vector<int>& params, int key, int& value)\n{\n    for (size_t i = 0; i + 1 < params.size(); i += 2)\n    {\n        if (params[i] == key)\n        {\n            value = params[i + 1];\n            return true;\n        }\n    }\n    return false;\n}\n\nbool TiffEncoder::writeLibTiff( const std::vector<Mat>& img_vec, const std::vector<int>& params)\n{\n    // do NOT put \"wb\" as the mode, because the b means \"big endian\" mode, not \"binary\" mode.\n    // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n    TIFF* tif = NULL;\n\n    TiffEncoderBufHelper buf_helper(m_buf);\n    if ( m_buf )\n    {\n        tif = buf_helper.open();\n    }\n    else\n    {\n        tif = TIFFOpen(m_filename.c_str(), \"w\");\n    }\n    if (!tif)\n    {\n        return false;\n    }\n    cv::Ptr<void> tif_cleanup(tif, cv_tiffCloseHandle);\n\n    //Settings that matter to all images\n    int compression = COMPRESSION_LZW;\n    int predictor = PREDICTOR_HORIZONTAL;\n    int resUnit = -1, dpiX = -1, dpiY = -1;\n\n    readParam(params, IMWRITE_TIFF_COMPRESSION, compression);\n    readParam(params, TIFFTAG_PREDICTOR, predictor);\n    readParam(params, IMWRITE_TIFF_RESUNIT, resUnit);\n    readParam(params, IMWRITE_TIFF_XDPI, dpiX);\n    readParam(params, IMWRITE_TIFF_YDPI, dpiY);\n\n    //Iterate through each image in the vector and write them out as Tiff directories\n    for (size_t page = 0; page < img_vec.size(); page++)\n    {\n        const Mat& img = img_vec[page];\n        CV_Assert(!img.empty());\n        int channels = img.channels();\n        int width = img.cols, height = img.rows;\n        int type = img.type();\n        int depth = CV_MAT_DEPTH(type);\n        CV_CheckType(type, depth == CV_8U || depth == CV_16U || depth == CV_32F || depth == CV_64F, \"\");\n        CV_CheckType(type, channels >= 1 && channels <= 4, \"\");\n\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, width));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_IMAGELENGTH, height));\n\n        if (img_vec.size() > 1)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE));\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PAGENUMBER, page, img_vec.size()));\n        }\n\n        int compression_param = -1;  // OPENCV_FUTURE\n        if (type == CV_32FC3 && (!readParam(params, IMWRITE_TIFF_COMPRESSION, compression_param) || compression_param == COMPRESSION_SGILOG))\n        {\n            if (!write_32FC3_SGILOG(img, tif))\n                return false;\n            continue;\n        }\n\n        int page_compression = compression;\n\n        int bitsPerChannel = -1;\n        switch (depth)\n        {\n            case CV_8U:\n            {\n                bitsPerChannel = 8;\n                break;\n            }\n            case CV_16U:\n            {\n                bitsPerChannel = 16;\n                break;\n            }\n            case CV_32F:\n            {\n                bitsPerChannel = 32;\n                page_compression = COMPRESSION_NONE;\n                break;\n            }\n            case CV_64F:\n            {\n                bitsPerChannel = 64;\n                page_compression = COMPRESSION_NONE;\n                break;\n            }\n            default:\n            {\n                return false;\n            }\n        }\n\n        const int bitsPerByte = 8;\n        size_t fileStep = (width * channels * bitsPerChannel) / bitsPerByte;\n        CV_Assert(fileStep > 0);\n\n        int rowsPerStrip = (int)((1 << 13) / fileStep);\n        readParam(params, TIFFTAG_ROWSPERSTRIP, rowsPerStrip);\n        rowsPerStrip = std::max(1, std::min(height, rowsPerStrip));\n\n        int colorspace = channels > 1 ? PHOTOMETRIC_RGB : PHOTOMETRIC_MINISBLACK;\n\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, bitsPerChannel));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_COMPRESSION, page_compression));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, colorspace));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, channels));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, rowsPerStrip));\n\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, depth >= CV_32F ? SAMPLEFORMAT_IEEEFP : SAMPLEFORMAT_UINT));\n\n        if (page_compression != COMPRESSION_NONE)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PREDICTOR, predictor));\n        }\n\n        if (resUnit >= RESUNIT_NONE && resUnit <= RESUNIT_CENTIMETER)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_RESOLUTIONUNIT, resUnit));\n        }\n        if (dpiX >= 0)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_XRESOLUTION, (float)dpiX));\n        }\n        if (dpiY >= 0)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_YRESOLUTION, (float)dpiY));\n        }\n\n        // row buffer, because TIFFWriteScanline modifies the original data!\n        size_t scanlineSize = TIFFScanlineSize(tif);\n        AutoBuffer<uchar> _buffer(scanlineSize + 32);\n        uchar* buffer = _buffer.data(); CV_DbgAssert(buffer);\n        Mat m_buffer(Size(width, 1), CV_MAKETYPE(depth, channels), buffer, (size_t)scanlineSize);\n\n        for (int y = 0; y < height; ++y)\n        {\n            switch (channels)\n            {\n                case 1:\n                {\n                    memcpy(buffer, img.ptr(y), scanlineSize);\n                    break;\n                }\n\n                case 3:\n                {\n                    cvtColor(img(Rect(0, y, width, 1)), (const Mat&)m_buffer, COLOR_BGR2RGB);\n                    break;\n                }\n\n                case 4:\n                {\n                    cvtColor(img(Rect(0, y, width, 1)), (const Mat&)m_buffer, COLOR_BGRA2RGBA);\n                    break;\n                }\n\n                default:\n                {\n                    CV_Assert(0);\n                }\n            }\n\n            CV_TIFF_CHECK_CALL(TIFFWriteScanline(tif, buffer, y, 0) == 1);\n        }\n\n        CV_TIFF_CHECK_CALL(TIFFWriteDirectory(tif));\n    }\n\n    return true;\n}\n\nbool TiffEncoder::write_32FC3_SGILOG(const Mat& _img, void* tif_)\n{\n    TIFF* tif = (TIFF*)tif_;\n    CV_Assert(tif);\n\n    Mat img;\n    cvtColor(_img, img, COLOR_BGR2XYZ);\n\n    //done by caller: CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, img.cols));\n    //done by caller: CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_IMAGELENGTH, img.rows));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 3));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 32));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_SGILOG));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_LOGLUV));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_FLOAT));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, 1));\n    const int strip_size = 3 * img.cols;\n    for (int i = 0; i < img.rows; i++)\n    {\n        CV_TIFF_CHECK_CALL(TIFFWriteEncodedStrip(tif, i, (tdata_t)img.ptr<float>(i), strip_size * sizeof(float)) != (tsize_t)-1);\n    }\n    CV_TIFF_CHECK_CALL(TIFFWriteDirectory(tif));\n    return true;\n}\n\nbool TiffEncoder::writemulti(const std::vector<Mat>& img_vec, const std::vector<int>& params)\n{\n    return writeLibTiff(img_vec, params);\n}\n\nbool  TiffEncoder::write( const Mat& img, const std::vector<int>& params)\n{\n    int type = img.type();\n    int depth = CV_MAT_DEPTH(type);\n\n    CV_CheckType(type, depth == CV_8U || depth == CV_16U || depth == CV_32F || depth == CV_64F, \"\");\n\n    std::vector<Mat> img_vec;\n    img_vec.push_back(img);\n    return writeLibTiff(img_vec, params);\n}\n\n} // namespace\n\n#endif\n",
                "name": "grfmt_tiff.cpp",
                "path": "modules/imgcodecs/src/grfmt_tiff.cpp",
                "url": "/github.com/joachimBurket/esp32-opencv/-/blob/modules/imgcodecs/src/grfmt_tiff.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 522,
                    "offsetAndLengths": [
                        [
                            51,
                            16
                        ]
                    ],
                    "preview": "                                CV_TIFF_CHECK_CALL(TIFFReadRGBATile(tif, x, y, (uint32*)buffer));"
                }
            ],
            "repository": {
                "name": "github.com/joachimBurket/esp32-opencv",
                "url": "/github.com/joachimBurket/esp32-opencv"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "26dcffe7940b682132dc651fce038a56cacdeae3"
                },
                "content": "/*M///////////////////////////////////////////////////////////////////////////////////////\n//\n//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.\n//\n//  By downloading, copying, installing or using the software you agree to this license.\n//  If you do not agree to this license, do not download, install,\n//  copy or use the software.\n//\n//\n//                           License Agreement\n//                For Open Source Computer Vision Library\n//\n// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.\n// Copyright (C) 2009, Willow Garage Inc., all rights reserved.\n// Third party copyrights are property of their respective owners.\n//\n// Redistribution and use in source and binary forms, with or without modification,\n// are permitted provided that the following conditions are met:\n//\n//   * Redistribution's of source code must retain the above copyright notice,\n//     this list of conditions and the following disclaimer.\n//\n//   * Redistribution's in binary form must reproduce the above copyright notice,\n//     this list of conditions and the following disclaimer in the documentation\n//     and/or other materials provided with the distribution.\n//\n//   * The name of the copyright holders may not be used to endorse or promote products\n//     derived from this software without specific prior written permission.\n//\n// This software is provided by the copyright holders and contributors \"as is\" and\n// any express or implied warranties, including, but not limited to, the implied\n// warranties of merchantability and fitness for a particular purpose are disclaimed.\n// In no event shall the Intel Corporation or contributors be liable for any direct,\n// indirect, incidental, special, exemplary, or consequential damages\n// (including, but not limited to, procurement of substitute goods or services;\n// loss of use, data, or profits; or business interruption) however caused\n// and on any theory of liability, whether in contract, strict liability,\n// or tort (including negligence or otherwise) arising in any way out of\n// the use of this software, even if advised of the possibility of such damage.\n//\n//M*/\n\n/****************************************************************************************\\\n    A part of the file implements TIFF reader on base of libtiff library\n    (see otherlibs/_graphics/readme.txt for copyright notice)\n\\****************************************************************************************/\n\n#include \"precomp.hpp\"\n\n#ifdef HAVE_TIFF\n#include \"grfmt_tiff.hpp\"\n#include <limits>\n\n// TODO FIXIT Conflict declarations for common types like int64/uint64\nnamespace tiff_dummy_namespace {\n#include \"tiff.h\"\n#include \"tiffio.h\"\n}\nusing namespace tiff_dummy_namespace;\n\nnamespace cv\n{\n\n\nstatic const char fmtSignTiffII[] = \"II\\x2a\\x00\";\nstatic const char fmtSignTiffMM[] = \"MM\\x00\\x2a\";\n\nstatic int grfmt_tiff_err_handler_init = 0;\nstatic void GrFmtSilentTIFFErrorHandler( const char*, const char*, va_list ) {}\n\nTiffDecoder::TiffDecoder()\n{\n    m_tif = 0;\n    if( !grfmt_tiff_err_handler_init )\n    {\n        grfmt_tiff_err_handler_init = 1;\n\n        TIFFSetErrorHandler( GrFmtSilentTIFFErrorHandler );\n        TIFFSetWarningHandler( GrFmtSilentTIFFErrorHandler );\n    }\n    m_hdr = false;\n    m_buf_supported = true;\n    m_buf_pos = 0;\n}\n\n\nvoid TiffDecoder::close()\n{\n    if( m_tif )\n    {\n        TIFF* tif = (TIFF*)m_tif;\n        TIFFClose( tif );\n        m_tif = 0;\n    }\n}\n\nTiffDecoder::~TiffDecoder()\n{\n    close();\n}\n\nsize_t TiffDecoder::signatureLength() const\n{\n    return 4;\n}\n\nbool TiffDecoder::checkSignature( const String& signature ) const\n{\n    return signature.size() >= 4 &&\n        (memcmp(signature.c_str(), fmtSignTiffII, 4) == 0 ||\n        memcmp(signature.c_str(), fmtSignTiffMM, 4) == 0);\n}\n\nint TiffDecoder::normalizeChannelsNumber(int channels) const\n{\n    return channels > 4 ? 4 : channels;\n}\n\nImageDecoder TiffDecoder::newDecoder() const\n{\n    return makePtr<TiffDecoder>();\n}\n\nclass TiffDecoderBufHelper\n{\n    Mat& m_buf;\n    size_t& m_buf_pos;\npublic:\n    TiffDecoderBufHelper(Mat& buf, size_t& buf_pos) :\n        m_buf(buf), m_buf_pos(buf_pos)\n    {}\n    static tmsize_t read( thandle_t handle, void* buffer, tmsize_t n )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        const Mat& buf = helper->m_buf;\n        const tmsize_t size = buf.cols*buf.rows*buf.elemSize();\n        tmsize_t pos = helper->m_buf_pos;\n        if ( n > (size - pos) )\n        {\n            n = size - pos;\n        }\n        memcpy(buffer, buf.ptr() + pos, n);\n        helper->m_buf_pos += n;\n        return n;\n    }\n\n    static tmsize_t write( thandle_t /*handle*/, void* /*buffer*/, tmsize_t /*n*/ )\n    {\n        // Not used for decoding.\n        return 0;\n    }\n\n    static toff_t seek( thandle_t handle, toff_t offset, int whence )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        const Mat& buf = helper->m_buf;\n        const toff_t size = buf.cols*buf.rows*buf.elemSize();\n        toff_t new_pos = helper->m_buf_pos;\n        switch (whence)\n        {\n            case SEEK_SET:\n                new_pos = offset;\n                break;\n            case SEEK_CUR:\n                new_pos += offset;\n                break;\n            case SEEK_END:\n                new_pos = size + offset;\n                break;\n        }\n        new_pos = std::min(new_pos, size);\n        helper->m_buf_pos = (size_t)new_pos;\n        return new_pos;\n    }\n\n    static int map( thandle_t handle, void** base, toff_t* size )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        Mat& buf = helper->m_buf;\n        *base = buf.ptr();\n        *size = buf.cols*buf.rows*buf.elemSize();\n        return 0;\n    }\n\n    static toff_t size( thandle_t handle )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        const Mat& buf = helper->m_buf;\n        return buf.cols*buf.rows*buf.elemSize();\n    }\n\n    static int close( thandle_t handle )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        delete helper;\n        return 0;\n    }\n};\n\nbool TiffDecoder::readHeader()\n{\n    bool result = false;\n\n    TIFF* tif = static_cast<TIFF*>(m_tif);\n    if (!m_tif)\n    {\n        // TIFFOpen() mode flags are different to fopen().  A 'b' in mode \"rb\" has no effect when reading.\n        // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n        if ( !m_buf.empty() )\n        {\n            m_buf_pos = 0;\n            TiffDecoderBufHelper* buf_helper = new TiffDecoderBufHelper(this->m_buf, this->m_buf_pos);\n            tif = TIFFClientOpen( \"\", \"r\", reinterpret_cast<thandle_t>(buf_helper), &TiffDecoderBufHelper::read,\n                                  &TiffDecoderBufHelper::write, &TiffDecoderBufHelper::seek,\n                                  &TiffDecoderBufHelper::close, &TiffDecoderBufHelper::size,\n                                  &TiffDecoderBufHelper::map, /*unmap=*/0 );\n        }\n        else\n        {\n            tif = TIFFOpen(m_filename.c_str(), \"r\");\n        }\n    }\n\n    if( tif )\n    {\n        uint32 wdth = 0, hght = 0;\n        uint16 photometric = 0;\n        m_tif = tif;\n\n        if( TIFFGetField( tif, TIFFTAG_IMAGEWIDTH, &wdth ) &&\n            TIFFGetField( tif, TIFFTAG_IMAGELENGTH, &hght ) &&\n            TIFFGetField( tif, TIFFTAG_PHOTOMETRIC, &photometric ))\n        {\n            uint16 bpp=8, ncn = photometric > 1 ? 3 : 1;\n            TIFFGetField( tif, TIFFTAG_BITSPERSAMPLE, &bpp );\n            TIFFGetField( tif, TIFFTAG_SAMPLESPERPIXEL, &ncn );\n\n            m_width = wdth;\n            m_height = hght;\n            if((bpp == 32 && ncn == 3) || photometric == PHOTOMETRIC_LOGLUV)\n            {\n                m_type = CV_32FC3;\n                m_hdr = true;\n                return true;\n            }\n            m_hdr = false;\n\n            if( bpp > 8 &&\n               ((photometric > 2) ||\n                (ncn != 1 && ncn != 3 && ncn != 4)))\n                bpp = 8;\n\n            int wanted_channels = normalizeChannelsNumber(ncn);\n            switch(bpp)\n            {\n                case 1:\n                    m_type = CV_MAKETYPE(CV_8U, photometric > 1 ? wanted_channels : 1);\n                    result = true;\n                    break;\n                case 8:\n                    m_type = CV_MAKETYPE(CV_8U, photometric > 1 ? wanted_channels : 1);\n                    result = true;\n                    break;\n                case 16:\n                    m_type = CV_MAKETYPE(CV_16U, photometric > 1 ? wanted_channels : 1);\n                    result = true;\n                    break;\n                case 32:\n                    m_type = CV_MAKETYPE(CV_32F, photometric > 1 ? 3 : 1);\n                    result = true;\n                    break;\n                case 64:\n                    m_type = CV_MAKETYPE(CV_64F, photometric > 1 ? 3 : 1);\n                    result = true;\n                    break;\n            default:\n                CV_Error(cv::Error::StsError, \"Invalid bitsperpixel value read from TIFF header! Must be 1, 8, 16, 32 or 64.\");\n            }\n        }\n    }\n\n    if( !result )\n        close();\n\n    return result;\n}\n\nbool TiffDecoder::nextPage()\n{\n    // Prepare the next page, if any.\n    return m_tif &&\n           TIFFReadDirectory(static_cast<TIFF*>(m_tif)) &&\n           readHeader();\n}\n\nbool  TiffDecoder::readData( Mat& img )\n{\n    if(m_hdr && img.type() == CV_32FC3)\n    {\n        return readData_32FC3(img);\n    }\n    if(img.type() == CV_32FC1)\n    {\n        return readData_32FC1(img);\n    }\n    bool result = false;\n    bool color = img.channels() > 1;\n\n    if( img.depth() != CV_8U && img.depth() != CV_16U && img.depth() != CV_32F && img.depth() != CV_64F )\n        return false;\n\n    if( m_tif && m_width && m_height )\n    {\n        TIFF* tif = (TIFF*)m_tif;\n        uint32 tile_width0 = m_width, tile_height0 = 0;\n        int x, y, i;\n        int is_tiled = TIFFIsTiled(tif);\n        uint16 photometric;\n        TIFFGetField( tif, TIFFTAG_PHOTOMETRIC, &photometric );\n        uint16 bpp = 8, ncn = photometric > 1 ? 3 : 1;\n        TIFFGetField( tif, TIFFTAG_BITSPERSAMPLE, &bpp );\n        TIFFGetField( tif, TIFFTAG_SAMPLESPERPIXEL, &ncn );\n        uint16 img_orientation = ORIENTATION_TOPLEFT;\n        TIFFGetField( tif, TIFFTAG_ORIENTATION, &img_orientation);\n        bool vert_flip = (img_orientation == ORIENTATION_BOTRIGHT) || (img_orientation == ORIENTATION_RIGHTBOT) ||\n                         (img_orientation == ORIENTATION_BOTLEFT) || (img_orientation == ORIENTATION_LEFTBOT);\n        const int bitsPerByte = 8;\n        int dst_bpp = (int)(img.elemSize1() * bitsPerByte);\n        int wanted_channels = normalizeChannelsNumber(img.channels());\n\n        if(dst_bpp == 8)\n        {\n            char errmsg[1024];\n            if(!TIFFRGBAImageOK( tif, errmsg ))\n            {\n                close();\n                return false;\n            }\n        }\n\n        if( (!is_tiled) ||\n            (is_tiled &&\n            TIFFGetField( tif, TIFFTAG_TILEWIDTH, &tile_width0 ) &&\n            TIFFGetField( tif, TIFFTAG_TILELENGTH, &tile_height0 )))\n        {\n            if(!is_tiled)\n                TIFFGetField( tif, TIFFTAG_ROWSPERSTRIP, &tile_height0 );\n\n            if( tile_width0 <= 0 )\n                tile_width0 = m_width;\n\n            if( tile_height0 <= 0 ||\n               (!is_tiled && tile_height0 == std::numeric_limits<uint32>::max()) )\n                tile_height0 = m_height;\n\n            if(dst_bpp == 8) {\n                // we will use TIFFReadRGBA* functions, so allocate temporary buffer for 32bit RGBA\n                bpp = 8;\n                ncn = 4;\n            }\n            const size_t buffer_size = (bpp/bitsPerByte) * ncn * tile_height0 * tile_width0;\n            AutoBuffer<uchar> _buffer( buffer_size );\n            uchar* buffer = _buffer.data();\n            ushort* buffer16 = (ushort*)buffer;\n            float* buffer32 = (float*)buffer;\n            double* buffer64 = (double*)buffer;\n            int tileidx = 0;\n\n            for( y = 0; y < m_height; y += tile_height0 )\n            {\n                int tile_height = tile_height0;\n\n                if( y + tile_height > m_height )\n                    tile_height = m_height - y;\n\n                uchar* data = img.ptr(vert_flip ? m_height - y - tile_height : y);\n\n                for( x = 0; x < m_width; x += tile_width0, tileidx++ )\n                {\n                    int tile_width = tile_width0, ok;\n\n                    if( x + tile_width > m_width )\n                        tile_width = m_width - x;\n\n                    switch(dst_bpp)\n                    {\n                        case 8:\n                        {\n                            uchar * bstart = buffer;\n                            if( !is_tiled )\n                                ok = TIFFReadRGBAStrip( tif, y, (uint32*)buffer );\n                            else\n                            {\n                                ok = TIFFReadRGBATile( tif, x, y, (uint32*)buffer );\n                                //Tiles fill the buffer from the bottom up\n                                bstart += (tile_height0 - tile_height) * tile_width0 * 4;\n                            }\n                            if( !ok )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                                if( color )\n                                {\n                                    if (wanted_channels == 4)\n                                    {\n                                        icvCvt_BGRA2RGBA_8u_C4R( bstart + i*tile_width0*4, 0,\n                                                             data + x*4 + img.step*(tile_height - i - 1), 0,\n                                                             Size(tile_width,1) );\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2BGR_8u_C4C3R( bstart + i*tile_width0*4, 0,\n                                                             data + x*3 + img.step*(tile_height - i - 1), 0,\n                                                             Size(tile_width,1), 2 );\n                                    }\n                                }\n                                else\n                                    icvCvt_BGRA2Gray_8u_C4C1R( bstart + i*tile_width0*4, 0,\n                                                              data + x + img.step*(tile_height - i - 1), 0,\n                                                              Size(tile_width,1), 2 );\n                            break;\n                        }\n\n                        case 16:\n                        {\n                            if( !is_tiled )\n                                ok = (int)TIFFReadEncodedStrip( tif, tileidx, (uint32*)buffer, buffer_size ) >= 0;\n                            else\n                                ok = (int)TIFFReadEncodedTile( tif, tileidx, (uint32*)buffer, buffer_size ) >= 0;\n\n                            if( !ok )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                            {\n                                if( color )\n                                {\n                                    if( ncn == 1 )\n                                    {\n                                        icvCvt_Gray2BGR_16u_C1C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                                  (ushort*)(data + img.step*i) + x*3, 0,\n                                                                  Size(tile_width,1) );\n                                    }\n                                    else if( ncn == 3 )\n                                    {\n                                        icvCvt_RGB2BGR_16u_C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                               (ushort*)(data + img.step*i) + x*3, 0,\n                                                               Size(tile_width,1) );\n                                    }\n                                    else if (ncn == 4)\n                                    {\n                                        if (wanted_channels == 4)\n                                        {\n                                            icvCvt_BGRA2RGBA_16u_C4R(buffer16 + i*tile_width0*ncn, 0,\n                                                (ushort*)(data + img.step*i) + x * 4, 0,\n                                                Size(tile_width, 1));\n                                        }\n                                        else\n                                        {\n                                            icvCvt_BGRA2BGR_16u_C4C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                (ushort*)(data + img.step*i) + x * 3, 0,\n                                                Size(tile_width, 1), 2);\n                                        }\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2BGR_16u_C4C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                               (ushort*)(data + img.step*i) + x*3, 0,\n                                                               Size(tile_width,1), 2 );\n                                    }\n                                }\n                                else\n                                {\n                                    if( ncn == 1 )\n                                    {\n                                        memcpy((ushort*)(data + img.step*i)+x,\n                                               buffer16 + i*tile_width0*ncn,\n                                               tile_width*sizeof(buffer16[0]));\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2Gray_16u_CnC1R(buffer16 + i*tile_width0*ncn, 0,\n                                                               (ushort*)(data + img.step*i) + x, 0,\n                                                               Size(tile_width,1), ncn, 2 );\n                                    }\n                                }\n                            }\n                            break;\n                        }\n\n                        case 32:\n                        case 64:\n                        {\n                            if( !is_tiled )\n                                ok = (int)TIFFReadEncodedStrip( tif, tileidx, buffer, buffer_size ) >= 0;\n                            else\n                                ok = (int)TIFFReadEncodedTile( tif, tileidx, buffer, buffer_size ) >= 0;\n\n                            if( !ok || ncn != 1 )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                            {\n                                if(dst_bpp == 32)\n                                {\n                                    memcpy((float*)(data + img.step*i)+x,\n                                           buffer32 + i*tile_width0*ncn,\n                                           tile_width*sizeof(buffer32[0]));\n                                }\n                                else\n                                {\n                                    memcpy((double*)(data + img.step*i)+x,\n                                         buffer64 + i*tile_width0*ncn,\n                                         tile_width*sizeof(buffer64[0]));\n                                }\n                            }\n\n                            break;\n                        }\n                        default:\n                        {\n                            close();\n                            return false;\n                        }\n                    }\n                }\n            }\n\n            result = true;\n        }\n    }\n\n    return result;\n}\n\nbool TiffDecoder::readData_32FC3(Mat& img)\n{\n    int rows_per_strip = 0, photometric = 0;\n    if(!m_tif)\n    {\n        return false;\n    }\n    TIFF *tif = static_cast<TIFF*>(m_tif);\n    TIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &rows_per_strip);\n    TIFFGetField( tif, TIFFTAG_PHOTOMETRIC, &photometric );\n    TIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_FLOAT);\n    int size = 3 * m_width * m_height * sizeof (float);\n    tstrip_t strip_size = 3 * m_width * rows_per_strip;\n    float *ptr = img.ptr<float>();\n    for (tstrip_t i = 0; i < TIFFNumberOfStrips(tif); i++, ptr += strip_size)\n    {\n        TIFFReadEncodedStrip(tif, i, ptr, size);\n        size -= strip_size * sizeof(float);\n    }\n    close();\n    if(photometric == PHOTOMETRIC_LOGLUV)\n    {\n        cvtColor(img, img, COLOR_XYZ2BGR);\n    }\n    else\n    {\n        cvtColor(img, img, COLOR_RGB2BGR);\n    }\n    return true;\n}\n\nbool TiffDecoder::readData_32FC1(Mat& img)\n{\n    if(!m_tif)\n    {\n        return false;\n    }\n    TIFF *tif = static_cast<TIFF*>(m_tif);\n\n    uint32 img_width, img_height;\n    TIFFGetField(tif,TIFFTAG_IMAGEWIDTH, &img_width);\n    TIFFGetField(tif,TIFFTAG_IMAGELENGTH, &img_height);\n    if(img.size() != Size(img_width,img_height))\n    {\n        close();\n        return false;\n    }\n    tsize_t scanlength = TIFFScanlineSize(tif);\n    tdata_t buf = _TIFFmalloc(scanlength);\n    float* data;\n    bool result = true;\n    for (uint32 row = 0; row < img_height; row++)\n    {\n        if (TIFFReadScanline(tif, buf, row) != 1)\n        {\n            result = false;\n            break;\n        }\n        data=(float*)buf;\n        for (uint32 i=0; i<img_width; i++)\n        {\n            img.at<float>(row,i) = data[i];\n        }\n    }\n    _TIFFfree(buf);\n    close();\n\n    return result;\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////\n\nTiffEncoder::TiffEncoder()\n{\n    m_description = \"TIFF Files (*.tiff;*.tif)\";\n    m_buf_supported = true;\n}\n\nTiffEncoder::~TiffEncoder()\n{\n}\n\nImageEncoder TiffEncoder::newEncoder() const\n{\n    return makePtr<TiffEncoder>();\n}\n\nbool TiffEncoder::isFormatSupported( int depth ) const\n{\n    return depth == CV_8U || depth == CV_16U || depth == CV_32F;\n}\n\nvoid  TiffEncoder::writeTag( WLByteStream& strm, TiffTag tag,\n                             TiffFieldType fieldType,\n                             int count, int value )\n{\n    strm.putWord( tag );\n    strm.putWord( fieldType );\n    strm.putDWord( count );\n    strm.putDWord( value );\n}\n\nclass TiffEncoderBufHelper\n{\npublic:\n\n    TiffEncoderBufHelper(std::vector<uchar> *buf)\n            : m_buf(buf), m_buf_pos(0)\n    {}\n\n    TIFF* open ()\n    {\n        return TIFFClientOpen( \"\", \"w\", reinterpret_cast<thandle_t>(this), &TiffEncoderBufHelper::read,\n                               &TiffEncoderBufHelper::write, &TiffEncoderBufHelper::seek,\n                               &TiffEncoderBufHelper::close, &TiffEncoderBufHelper::size,\n                               /*map=*/0, /*unmap=*/0 );\n    }\n\n    static tmsize_t read( thandle_t /*handle*/, void* /*buffer*/, tmsize_t /*n*/ )\n    {\n        // Not used for encoding.\n        return 0;\n    }\n\n    static tmsize_t write( thandle_t handle, void* buffer, tmsize_t n )\n    {\n        TiffEncoderBufHelper *helper = reinterpret_cast<TiffEncoderBufHelper*>(handle);\n        size_t begin = (size_t)helper->m_buf_pos;\n        size_t end = begin + n;\n        if ( helper->m_buf->size() < end )\n        {\n            helper->m_buf->resize(end);\n        }\n        memcpy(&(*helper->m_buf)[begin], buffer, n);\n        helper->m_buf_pos = end;\n        return n;\n    }\n\n    static toff_t seek( thandle_t handle, toff_t offset, int whence )\n    {\n        TiffEncoderBufHelper *helper = reinterpret_cast<TiffEncoderBufHelper*>(handle);\n        const toff_t size = helper->m_buf->size();\n        toff_t new_pos = helper->m_buf_pos;\n        switch (whence)\n        {\n            case SEEK_SET:\n                new_pos = offset;\n                break;\n            case SEEK_CUR:\n                new_pos += offset;\n                break;\n            case SEEK_END:\n                new_pos = size + offset;\n                break;\n        }\n        helper->m_buf_pos = new_pos;\n        return new_pos;\n    }\n\n    static toff_t size( thandle_t handle )\n    {\n        TiffEncoderBufHelper *helper = reinterpret_cast<TiffEncoderBufHelper*>(handle);\n        return helper->m_buf->size();\n    }\n\n    static int close( thandle_t /*handle*/ )\n    {\n        // Do nothing.\n        return 0;\n    }\n\nprivate:\n\n    std::vector<uchar>* m_buf;\n    toff_t m_buf_pos;\n};\n\nstatic void readParam(const std::vector<int>& params, int key, int& value)\n{\n    for(size_t i = 0; i + 1 < params.size(); i += 2)\n        if(params[i] == key)\n        {\n            value = params[i+1];\n            break;\n        }\n}\n\nbool TiffEncoder::writeLibTiff( const std::vector<Mat>& img_vec, const std::vector<int>& params)\n{\n    // do NOT put \"wb\" as the mode, because the b means \"big endian\" mode, not \"binary\" mode.\n    // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n    TIFF* pTiffHandle;\n\n    TiffEncoderBufHelper buf_helper(m_buf);\n    if ( m_buf )\n    {\n        pTiffHandle = buf_helper.open();\n    }\n    else\n    {\n        pTiffHandle = TIFFOpen(m_filename.c_str(), \"w\");\n    }\n    if (!pTiffHandle)\n    {\n        return false;\n    }\n\n    //Settings that matter to all images\n    // defaults for now, maybe base them on params in the future\n    int compression = COMPRESSION_LZW;\n    int predictor = PREDICTOR_HORIZONTAL;\n    int resUnit = -1, dpiX = -1, dpiY = -1;\n\n    readParam(params, TIFFTAG_COMPRESSION, compression);\n    readParam(params, TIFFTAG_PREDICTOR, predictor);\n    readParam(params, IMWRITE_TIFF_RESUNIT, resUnit);\n    readParam(params, IMWRITE_TIFF_XDPI, dpiX);\n    readParam(params, IMWRITE_TIFF_YDPI, dpiY);\n\n    //Iterate through each image in the vector and write them out as Tiff directories\n    for (size_t page = 0; page < img_vec.size(); page++)\n    {\n        const Mat& img = img_vec[page];\n        int channels = img.channels();\n        int width = img.cols, height = img.rows;\n        int depth = img.depth();\n\n        int bitsPerChannel = -1;\n        switch (depth)\n        {\n            case CV_8U:\n            {\n                bitsPerChannel = 8;\n                break;\n            }\n            case CV_16U:\n            {\n                bitsPerChannel = 16;\n                break;\n            }\n            default:\n            {\n                TIFFClose(pTiffHandle);\n                return false;\n            }\n        }\n\n        const int bitsPerByte = 8;\n        size_t fileStep = (width * channels * bitsPerChannel) / bitsPerByte;\n\n        int rowsPerStrip = (int)((1 << 13) / fileStep);\n        readParam(params, TIFFTAG_ROWSPERSTRIP, rowsPerStrip);\n\n        if (rowsPerStrip < 1)\n            rowsPerStrip = 1;\n\n        if (rowsPerStrip > height)\n            rowsPerStrip = height;\n\n        int   colorspace = channels > 1 ? PHOTOMETRIC_RGB : PHOTOMETRIC_MINISBLACK;\n\n        if (!TIFFSetField(pTiffHandle, TIFFTAG_IMAGEWIDTH, width)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_IMAGELENGTH, height)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_BITSPERSAMPLE, bitsPerChannel)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_COMPRESSION, compression)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_PHOTOMETRIC, colorspace)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_SAMPLESPERPIXEL, channels)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_ROWSPERSTRIP, rowsPerStrip)\n            || (img_vec.size() > 1 && (\n               !TIFFSetField(pTiffHandle, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_PAGENUMBER, page, img_vec.size() )))\n            )\n        {\n            TIFFClose(pTiffHandle);\n            return false;\n        }\n\n        if (compression != COMPRESSION_NONE && !TIFFSetField(pTiffHandle, TIFFTAG_PREDICTOR, predictor))\n        {\n            TIFFClose(pTiffHandle);\n            return false;\n        }\n\n        if (((resUnit >= RESUNIT_NONE && resUnit <= RESUNIT_CENTIMETER) && !TIFFSetField(pTiffHandle, TIFFTAG_RESOLUTIONUNIT, resUnit))\n            || (dpiX >= 0 && !TIFFSetField(pTiffHandle, TIFFTAG_XRESOLUTION, (float)dpiX))\n            || (dpiY >= 0 && !TIFFSetField(pTiffHandle, TIFFTAG_YRESOLUTION, (float)dpiY))\n            )\n        {\n            TIFFClose(pTiffHandle);\n            return false;\n        }\n\n\n        // row buffer, because TIFFWriteScanline modifies the original data!\n        size_t scanlineSize = TIFFScanlineSize(pTiffHandle);\n        AutoBuffer<uchar> _buffer(scanlineSize + 32);\n        uchar* buffer = _buffer.data();\n        if (!buffer)\n        {\n            TIFFClose(pTiffHandle);\n            return false;\n        }\n\n        for (int y = 0; y < height; ++y)\n        {\n            switch (channels)\n            {\n                case 1:\n                {\n                    memcpy(buffer, img.ptr(y), scanlineSize);\n                    break;\n                }\n\n                case 3:\n                {\n                    if (depth == CV_8U)\n                        icvCvt_BGR2RGB_8u_C3R( img.ptr(y), 0, buffer, 0, Size(width, 1));\n                    else\n                        icvCvt_BGR2RGB_16u_C3R( img.ptr<ushort>(y), 0, (ushort*)buffer, 0, Size(width, 1));\n                    break;\n                }\n\n                case 4:\n                {\n                    if (depth == CV_8U)\n                        icvCvt_BGRA2RGBA_8u_C4R( img.ptr(y), 0, buffer, 0, Size(width, 1));\n                    else\n                        icvCvt_BGRA2RGBA_16u_C4R( img.ptr<ushort>(y), 0, (ushort*)buffer, 0, Size(width, 1));\n                    break;\n                }\n\n                default:\n                {\n                    TIFFClose(pTiffHandle);\n                    return false;\n                }\n            }\n\n            int writeResult = TIFFWriteScanline(pTiffHandle, buffer, y, 0);\n            if (writeResult != 1)\n            {\n                TIFFClose(pTiffHandle);\n                return false;\n            }\n        }\n\n        TIFFWriteDirectory(pTiffHandle);\n\n    }\n\n    TIFFClose(pTiffHandle);\n    return true;\n}\n\nbool TiffEncoder::write_32FC3(const Mat& _img)\n{\n    Mat img;\n    cvtColor(_img, img, COLOR_BGR2XYZ);\n\n    TIFF* tif;\n\n    TiffEncoderBufHelper buf_helper(m_buf);\n    if ( m_buf )\n    {\n        tif = buf_helper.open();\n    }\n    else\n    {\n        tif = TIFFOpen(m_filename.c_str(), \"w\");\n    }\n\n    if (!tif)\n    {\n        return false;\n    }\n    TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, img.cols);\n    TIFFSetField(tif, TIFFTAG_IMAGELENGTH, img.rows);\n    TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 3);\n    TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_SGILOG);\n    TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_LOGLUV);\n    TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    TIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_FLOAT);\n    TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, 1);\n    int strip_size = 3 * img.cols;\n    float *ptr = const_cast<float*>(img.ptr<float>());\n    for (int i = 0; i < img.rows; i++, ptr += strip_size)\n    {\n        TIFFWriteEncodedStrip(tif, i, ptr, strip_size * sizeof(float));\n    }\n    TIFFClose(tif);\n    return true;\n}\n\nbool TiffEncoder::write_32FC1(const Mat& _img)\n{\n\n    TIFF* tif;\n\n    TiffEncoderBufHelper buf_helper(m_buf);\n    if ( m_buf )\n    {\n        tif = buf_helper.open();\n    }\n    else\n    {\n        tif = TIFFOpen(m_filename.c_str(), \"w\");\n    }\n\n    if (!tif)\n    {\n        return false;\n    }\n\n    TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, _img.cols);\n    TIFFSetField(tif, TIFFTAG_IMAGELENGTH, _img.rows);\n    TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 1);\n    TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 32);\n    TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n    TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);\n    TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n    for (uint32 row = 0; row < (uint32)_img.rows; row++)\n    {\n        if (TIFFWriteScanline(tif, (tdata_t)_img.ptr<float>(row), row, 1) != 1)\n        {\n            TIFFClose(tif);\n            return false;\n        }\n    }\n    TIFFWriteDirectory(tif);\n    TIFFClose(tif);\n\n    return true;\n}\n\nbool TiffEncoder::writemulti(const std::vector<Mat>& img_vec, const std::vector<int>& params)\n{\n    return writeLibTiff(img_vec, params);\n}\n\nbool  TiffEncoder::write( const Mat& img, const std::vector<int>& params)\n{\n    int depth = img.depth();\n\n    if(img.type() == CV_32FC3)\n    {\n        return write_32FC3(img);\n    }\n    if(img.type() == CV_32FC1)\n    {\n        return write_32FC1(img);\n    }\n\n    CV_Assert(depth == CV_8U || depth == CV_16U);\n\n    std::vector<Mat> img_vec;\n    img_vec.push_back(img);\n    return writeLibTiff(img_vec, params);\n}\n\n} // namespace\n\n#endif\n",
                "name": "grfmt_tiff.cpp",
                "path": "opencv_src/modules/imgcodecs/src/grfmt_tiff.cpp",
                "url": "/github.com/vinissimus/opencv-js-webworker/-/blob/opencv_src/modules/imgcodecs/src/grfmt_tiff.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 393,
                    "offsetAndLengths": [
                        [
                            37,
                            16
                        ]
                    ],
                    "preview": "                                ok = TIFFReadRGBATile( tif, x, y, (uint32*)buffer );"
                }
            ],
            "repository": {
                "name": "github.com/vinissimus/opencv-js-webworker",
                "url": "/github.com/vinissimus/opencv-js-webworker"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "123c2fbef73b431e42d3d0294f94ed862bbc83d9"
                },
                "content": "/******************************************************************************\n *\n * Project:  GeoTIFF Driver\n * Purpose:  GDAL GeoTIFF support.\n * Author:   Frank Warmerdam, warmerdam@pobox.com\n *\n ******************************************************************************\n * Copyright (c) 1998, 2002, Frank Warmerdam <warmerdam@pobox.com>\n * Copyright (c) 2007-2015, Even Rouault <even dot rouault at spatialys dot com>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n ****************************************************************************/\n\n// If we use sunpro compiler on linux. Weird idea indeed!\n#if defined(__SUNPRO_CC) && defined(__linux__)\n#define _GNU_SOURCE\n#elif defined(__GNUC__) && !defined(_GNU_SOURCE)\n// Required to use RTLD_DEFAULT of dlfcn.h.\n#define _GNU_SOURCE\n#endif\n\n#include \"cpl_port.h\"  // Must be first.\n#include \"gtiff.h\"\n\n#include <cassert>\n#include <cerrno>\n#include <climits>\n#include <cmath>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#if HAVE_FCNTL_H\n#include <fcntl.h>\n#endif\n#if HAVE_SYS_STAT_H\n#  include <sys/stat.h>\n#endif\n\n#include <algorithm>\n#include <map>\n#include <memory>\n#include <mutex>\n#include <set>\n#include <string>\n#include <queue>\n#include <utility>\n#include <vector>\n\n#include \"cpl_config.h\"\n#include \"cpl_conv.h\"\n#include \"cpl_error.h\"\n#include \"cpl_error_internal.h\"\n#include \"cpl_mem_cache.h\"\n#include \"cpl_minixml.h\"\n#include \"cpl_multiproc.h\"\n#include \"cpl_port.h\"\n#include \"cpl_progress.h\"\n#include \"cpl_string.h\"\n#include \"cpl_virtualmem.h\"\n#include \"cpl_vsi.h\"\n#include \"cpl_vsi_virtual.h\"\n#include \"cpl_worker_thread_pool.h\"\n#include \"cplkeywordparser.h\"\n#include \"gdal.h\"\n#include \"gdal_frmts.h\"\n#include \"gdal_mdreader.h\"\n#include \"gdal_pam.h\"\n#include \"gdal_priv.h\"\n#include \"gdal_priv_templates.hpp\"\n#include \"gdal_thread_pool.h\"\n#include \"geo_normalize.h\"\n#include \"geotiff.h\"\n#include \"geovalues.h\"\n#include \"gt_jpeg_copy.h\"\n#include \"gt_overview.h\"\n#include \"gt_wkt_srs.h\"\n#include \"gt_wkt_srs_priv.h\"\n#include \"ogr_spatialref.h\"\n#include \"ogr_proj_p.h\"\n#include \"tiff.h\"\n#include \"tif_float.h\"\n#include \"tiffio.h\"\n#ifdef INTERNAL_LIBTIFF\n#  include \"tif_lerc.h\"\n#endif\n#include \"tiffvers.h\"\n#include \"tifvsi.h\"\n#include \"xtiffio.h\"\n\nCPL_CVSID(\"$Id: geotiff.cpp 9e52ad241bade9e0b989281f186f01e8a17106de 2020-10-19 14:27:54 +0200 Even Rouault $\")\n\nstatic bool bGlobalInExternalOvr = false;\n\n// Only libtiff 4.0.4 can handle between 32768 and 65535 directories.\n#if TIFFLIB_VERSION >= 20120922\n#define SUPPORTS_MORE_THAN_32768_DIRECTORIES\n#endif\n\n#if TIFFLIB_VERSION > 20181110 // > 4.0.10\n#define SUPPORTS_GET_OFFSET_BYTECOUNT\n#endif\n\nconst char* const szJPEGGTiffDatasetTmpPrefix = \"/vsimem/gtiffdataset_jpg_tmp_\";\n\ntypedef enum\n{\n    GTIFFTAGTYPE_STRING,\n    GTIFFTAGTYPE_SHORT,\n    GTIFFTAGTYPE_FLOAT,\n    GTIFFTAGTYPE_BYTE_STRING\n} GTIFFTagTypes;\n\ntypedef struct\n{\n    const char    *pszTagName;\n    int            nTagVal;\n    GTIFFTagTypes  eType;\n} GTIFFTags;\n\nstatic const GTIFFTags asTIFFTags[] =\n{\n    { \"TIFFTAG_DOCUMENTNAME\", TIFFTAG_DOCUMENTNAME, GTIFFTAGTYPE_STRING },\n    { \"TIFFTAG_IMAGEDESCRIPTION\", TIFFTAG_IMAGEDESCRIPTION,\n        GTIFFTAGTYPE_STRING },\n    { \"TIFFTAG_SOFTWARE\", TIFFTAG_SOFTWARE, GTIFFTAGTYPE_STRING },\n    { \"TIFFTAG_DATETIME\", TIFFTAG_DATETIME, GTIFFTAGTYPE_STRING },\n    { \"TIFFTAG_ARTIST\", TIFFTAG_ARTIST, GTIFFTAGTYPE_STRING },\n    { \"TIFFTAG_HOSTCOMPUTER\", TIFFTAG_HOSTCOMPUTER, GTIFFTAGTYPE_STRING },\n    { \"TIFFTAG_COPYRIGHT\", TIFFTAG_COPYRIGHT, GTIFFTAGTYPE_STRING },\n    { \"TIFFTAG_XRESOLUTION\", TIFFTAG_XRESOLUTION, GTIFFTAGTYPE_FLOAT },\n    { \"TIFFTAG_YRESOLUTION\", TIFFTAG_YRESOLUTION, GTIFFTAGTYPE_FLOAT },\n    // Dealt as special case.\n    { \"TIFFTAG_RESOLUTIONUNIT\", TIFFTAG_RESOLUTIONUNIT, GTIFFTAGTYPE_SHORT },\n    { \"TIFFTAG_MINSAMPLEVALUE\", TIFFTAG_MINSAMPLEVALUE, GTIFFTAGTYPE_SHORT },\n    { \"TIFFTAG_MAXSAMPLEVALUE\", TIFFTAG_MAXSAMPLEVALUE, GTIFFTAGTYPE_SHORT },\n\n    // GeoTIFF DGIWG tags\n    { \"GEO_METADATA\", TIFFTAG_GEO_METADATA, GTIFFTAGTYPE_BYTE_STRING },\n    { \"TIFF_RSID\", TIFFTAG_TIFF_RSID, GTIFFTAGTYPE_STRING },\n};\n\nconst char szPROFILE_BASELINE[] = \"BASELINE\";\nconst char szPROFILE_GeoTIFF[] = \"GeoTIFF\";\nconst char szPROFILE_GDALGeoTIFF[] = \"GDALGeoTIFF\";\n\n/************************************************************************/\n/*                          GTIFFSetInExternalOvr()                     */\n/************************************************************************/\n\nvoid GTIFFSetInExternalOvr( bool b )\n{\n    bGlobalInExternalOvr = b;\n}\n\n/************************************************************************/\n/*                     GTIFFGetOverviewBlockSize()                      */\n/************************************************************************/\n\nvoid GTIFFGetOverviewBlockSize( GDALRasterBandH hBand, int* pnBlockXSize, int* pnBlockYSize )\n{\n    const char* pszVal = CPLGetConfigOption(\"GDAL_TIFF_OVR_BLOCKSIZE\", nullptr);\n    if( ! pszVal )\n    {\n        GDALRasterBand* const poBand = GDALRasterBand::FromHandle(hBand);\n        poBand->GetBlockSize(pnBlockXSize,pnBlockYSize);\n        if ( *pnBlockXSize != *pnBlockYSize ||\n             *pnBlockXSize < 64 || *pnBlockXSize > 4096 ||\n             !CPLIsPowerOfTwo(*pnBlockXSize) )\n        {\n            *pnBlockXSize=*pnBlockYSize=128;\n        }\n    }\n    else\n    {\n        int nOvrBlockSize = atoi(pszVal);\n        if( nOvrBlockSize < 64 || nOvrBlockSize > 4096 ||\n            !CPLIsPowerOfTwo(nOvrBlockSize) )\n        {\n            static bool bHasWarned = false;\n            if( !bHasWarned )\n            {\n                CPLError( CE_Warning, CPLE_NotSupported,\n                          \"Wrong value for GDAL_TIFF_OVR_BLOCKSIZE : %s. \"\n                          \"Should be a power of 2 between 64 and 4096. \"\n                          \"Defaulting to 128\",\n                          pszVal );\n                bHasWarned = true;\n            }\n            nOvrBlockSize = 128;\n        }\n\n        *pnBlockXSize = nOvrBlockSize;\n        *pnBlockYSize = nOvrBlockSize;\n    }\n}\n\nenum\n{\n    ENDIANNESS_NATIVE,\n    ENDIANNESS_LITTLE,\n    ENDIANNESS_BIG\n};\n\n/************************************************************************/\n/* ==================================================================== */\n/*                          GTiffDataset                                */\n/* ==================================================================== */\n/************************************************************************/\n\nclass GTiffBitmapBand;\nclass GTiffDataset;\nclass GTiffJPEGOverviewBand;\nclass GTiffJPEGOverviewDS;\nclass GTiffRasterBand;\nclass GTiffRGBABand;\n\n#if !defined(__MINGW32__)\nnamespace {\n#endif\ntypedef struct\n{\n    GTiffDataset *poDS;\n    char         *pszTmpFilename;\n    GByte        *pabyBuffer;\n    GByte        *pabyCompressedBuffer;  // Owned by pszTmpFilename.\n    GPtrDiff_t    nBufferSize;\n    GPtrDiff_t    nCompressedBufferSize;\n    int           nHeight;\n    int           nStripOrTile;\n    uint16        nPredictor;\n    bool          bTIFFIsBigEndian;\n    bool          bReady;\n} GTiffCompressionJob;\n#if !defined(__MINGW32__)\n}\n#endif\n\nenum class GTiffProfile: GByte\n{\n    BASELINE,\n    GEOTIFF,\n    GDALGEOTIFF\n};\n\nclass GTiffDataset final : public GDALPamDataset\n{\npublic:\n    struct MaskOffset\n    {\n        int nMask;\n        int nOffset;\n    };\n\nprivate:\n    CPL_DISALLOW_COPY_ASSIGN(GTiffDataset)\n\n    friend class GTiffBitmapBand;\n    friend class GTiffJPEGOverviewDS;\n    friend class GTiffJPEGOverviewBand;\n    friend class GTiffOddBitsBand;\n    friend class GTiffRasterBand;\n    friend class GTiffRGBABand;\n    friend class GTiffSplitBand;\n    friend class GTiffSplitBitmapBand;\n\n    friend void  GTIFFSetJpegQuality( GDALDatasetH hGTIFFDS, int nJpegQuality );\n    friend void  GTIFFSetJpegTablesMode( GDALDatasetH hGTIFFDS, int nJpegTablesMode );\n    friend void  GTIFFSetWebPLevel( GDALDatasetH hGTIFFDS, int nWebPLevel );\n\n    TIFF                 *m_hTIFF = nullptr;\n    VSILFILE             *m_fpL = nullptr;\n    VSILFILE             *m_fpToWrite = nullptr;\n    GTiffDataset        **m_papoOverviewDS = nullptr;\n    GTiffDataset         *m_poMaskDS = nullptr; // For a non-mask dataset, points to the corresponding (internal) mask\n    GDALDataset          *m_poExternalMaskDS = nullptr; // Points to a dataset within m_poMaskExtOvrDS\n    GTiffDataset         *m_poImageryDS = nullptr; // For a mask dataset, points to the corresponding imagery dataset\n    GTiffDataset         *m_poBaseDS = nullptr; // For an overview or mask dataset, points to the root dataset\n    std::unique_ptr<GDALDataset> m_poMaskExtOvrDS{}; // Used with MASK_OVERVIEW_DATASET open option\n    GTiffJPEGOverviewDS **m_papoJPEGOverviewDS = nullptr;\n    GDAL_GCP             *m_pasGCPList = nullptr;\n    GDALColorTable       *m_poColorTable = nullptr;\n    char                **m_papszMetadataFiles = nullptr;\n    GByte                *m_pabyBlockBuf = nullptr;\n    char                **m_papszCreationOptions = nullptr;\n    void                 *m_pabyTempWriteBuffer = nullptr;\n    CPLVirtualMem        *m_pBaseMapping = nullptr;\n    GByte                *m_pTempBufferForCommonDirectIO = nullptr;\n    CPLVirtualMem        *m_psVirtualMemIOMapping = nullptr;\n    std::unique_ptr<CPLJobQueue> m_poCompressQueue{};\n    CPLMutex             *m_hCompressThreadPoolMutex = nullptr;\n\n#ifdef SUPPORTS_GET_OFFSET_BYTECOUNT\n    lru11::Cache<int, std::pair<vsi_l_offset, vsi_l_offset>> m_oCacheStrileToOffsetByteCount{1024};\n#endif\n\n    MaskOffset* m_panMaskOffsetLsb = nullptr;\n    char       *m_pszVertUnit = nullptr;\n    char       *m_pszFilename = nullptr;\n    char       *m_pszTmpFilename = nullptr;\n    char       *m_pszGeorefFilename = nullptr;\n\n    double      m_adfGeoTransform[6]{0,1,0,0,0,1};\n#if HAVE_LERC\n    double      m_dfMaxZError = 0.0;\n    uint32      m_anLercAddCompressionAndVersion[2]{0,0};\n#endif\n    double      m_dfNoDataValue = -9999.0;\n\n    toff_t      m_nDirOffset = 0;\n\n    int         m_nBlocksPerBand = 0;\n    int         m_nBlockXSize = 0;\n    int         m_nBlockYSize = 0;\n    int         m_nLoadedBlock = -1;  // Or tile, or scanline\n    uint32      m_nRowsPerStrip = 0;\n    int         m_nLastBandRead = -1; // Used for the all-in-on-strip case.\n    int         m_nLastWrittenBlockId = -1; // used for m_bStreamingOut\n    int         m_nRefBaseMapping = 0;\n    int         m_nGCPCount = 0;\n\n    GTIFFKeysFlavorEnum m_eGeoTIFFKeysFlavor = GEOTIFF_KEYS_STANDARD;\n    GeoTIFFVersionEnum m_eGeoTIFFVersion = GEOTIFF_VERSION_AUTO;\n\n    uint16      m_nPlanarConfig = 0;\n    uint16      m_nSamplesPerPixel = 0;\n    uint16      m_nBitsPerSample = 0;\n    uint16      m_nPhotometric = 0;\n    uint16      m_nSampleFormat = 0;\n    uint16      m_nCompression = 0;\n\n    signed char m_nOverviewCount = 0;\n\n    // If > 0, the implicit JPEG overviews are visible through\n    // GetOverviewCount().\n    signed char m_nJPEGOverviewVisibilityCounter = 0;\n    // Currently visible overviews. Generally == nJPEGOverviewCountOri.\n    signed char m_nJPEGOverviewCount = -1;\n    signed char m_nJPEGOverviewCountOri = 0;  // Size of papoJPEGOverviewDS.\n    signed char m_nPAMGeorefSrcIndex = -1;\n    signed char m_nINTERNALGeorefSrcIndex = -1;\n    signed char m_nTABFILEGeorefSrcIndex = -1;\n    signed char m_nWORLDFILEGeorefSrcIndex = -1;\n    signed char m_nGeoTransformGeorefSrcIndex = -1;\n\n    signed char m_nHasOptimizedReadMultiRange = -1;\n\n    signed char m_nZLevel = -1;\n    signed char m_nLZMAPreset = -1;\n    signed char m_nZSTDLevel = -1;\n    signed char m_nWebPLevel = -1;\n    signed char m_nJpegQuality = -1;\n    signed char m_nJpegTablesMode = -1;\n\n    enum class VirtualMemIOEnum: GByte\n    {\n        NO,\n        YES,\n        IF_ENOUGH_RAM\n    };\n\n    VirtualMemIOEnum m_eVirtualMemIOUsage = VirtualMemIOEnum::NO;\n\n    GTiffProfile m_eProfile = GTiffProfile::GDALGEOTIFF;\n\n    OGRSpatialReference m_oSRS{};\n\n    GDALMultiDomainMetadata m_oGTiffMDMD{};\n\n    std::vector<GTiffCompressionJob> m_asCompressionJobs{};\n    std::queue<int> m_asQueueJobIdx{}; // queue of index of m_asCompressionJobs being compressed in worker threads\n\n    bool        m_bStreamingIn:1;\n    bool        m_bStreamingOut:1;\n    bool        m_bScanDeferred:1;\n    bool        m_bSingleIFDOpened = false;\n    bool        m_bLoadedBlockDirty:1;\n    bool        m_bWriteError:1;\n    bool        m_bLookedForProjection:1;\n    bool        m_bLookedForMDAreaOrPoint:1;\n    bool        m_bGeoTransformValid:1;\n    bool        m_bCrystalized:1;\n    bool        m_bGeoTIFFInfoChanged:1;\n    bool        m_bForceUnsetGTOrGCPs:1;\n    bool        m_bForceUnsetProjection:1;\n    bool        m_bNoDataChanged:1;\n    bool        m_bNoDataSet:1;\n    bool        m_bMetadataChanged:1;\n    bool        m_bColorProfileMetadataChanged:1;\n    bool        m_bForceUnsetRPC:1;\n    bool        m_bNeedsRewrite:1;\n    bool        m_bLoadingOtherBands:1;\n    bool        m_bIsOverview:1;\n    bool        m_bWriteEmptyTiles:1;\n    bool        m_bFillEmptyTilesAtClosing:1;\n    bool        m_bTreatAsSplit:1;\n    bool        m_bTreatAsSplitBitmap:1;\n    bool        m_bClipWarn:1;\n    bool        m_bIMDRPCMetadataLoaded:1;\n    bool        m_bEXIFMetadataLoaded:1;\n    bool        m_bICCMetadataLoaded:1;\n    bool        m_bHasWarnedDisableAggressiveBandCaching:1;\n    bool        m_bDontReloadFirstBlock:1;  // Hack for libtiff 3.X and #3633.\n    bool        m_bWebPLossless:1;\n    bool        m_bPromoteTo8Bits:1;\n    bool        m_bDebugDontWriteBlocks:1;\n    bool        m_bIsFinalized:1;\n    bool        m_bIgnoreReadErrors:1;\n    bool        m_bDirectIO:1;\n    bool        m_bReadGeoTransform:1;\n    bool        m_bLoadPam:1;\n    bool        m_bHasGotSiblingFiles:1;\n    bool        m_bHasIdentifiedAuthorizedGeoreferencingSources:1;\n    bool        m_bLayoutIFDSBeforeData:1;\n    bool        m_bBlockOrderRowMajor:1;\n    bool        m_bLeaderSizeAsUInt4:1;\n    bool        m_bTrailerRepeatedLast4BytesRepeated:1;\n    bool        m_bMaskInterleavedWithImagery:1;\n    bool        m_bKnownIncompatibleEdition:1;\n    bool        m_bWriteKnownIncompatibleEdition:1;\n    bool        m_bHasUsedReadEncodedAPI:1; // for debugging\n    bool        m_bWriteCOGLayout:1;\n\n    void        ScanDirectories();\n    bool        ReadStrile(int nBlockId,\n                           void* pOutputBuffer, GPtrDiff_t nBlockReqSize);\n    CPLErr      LoadBlockBuf( int nBlockId, bool bReadFromDisk = true );\n    CPLErr      FlushBlockBuf();\n\n    void        LoadMDAreaOrPoint();\n    void        LookForProjection();\n#ifdef ESRI_BUILD\n    void        AdjustLinearUnit( short UOMLength );\n#endif\n\n    void        Crystalize();  // TODO: Spelling.\n    void        RestoreVolatileParameters(TIFF* hTIFF);\n\n    void        WriteGeoTIFFInfo();\n    bool        SetDirectory();\n    void        ReloadDirectory();\n\n    int         GetJPEGOverviewCount();\n\n    bool        IsBlockAvailable( int nBlockId,\n                                  vsi_l_offset* pnOffset = nullptr,\n                                  vsi_l_offset* pnSize = nullptr,\n                                  bool *pbErrOccurred = nullptr );\n\n    void        ApplyPamInfo();\n    void        PushMetadataToPam();\n\n    bool         WriteEncodedTile( uint32 tile, GByte* pabyData,\n                                   int bPreserveDataBuffer );\n    bool         WriteEncodedStrip( uint32 strip, GByte* pabyData,\n                                    int bPreserveDataBuffer );\n    template<class T>\n    bool         HasOnlyNoDataT( const T* pBuffer, int nWidth, int nHeight,\n                                int nLineStride, int nComponents ) const;\n    bool         HasOnlyNoData( const void* pBuffer, int nWidth, int nHeight,\n                                int nLineStride, int nComponents );\n    inline bool  IsFirstPixelEqualToNoData( const void* pBuffer );\n\n    void         FillEmptyTiles();\n\n    void         FlushDirectory();\n    CPLErr       CleanOverviews();\n\n    void          LoadMetadata();\n    void          LoadEXIFMetadata();\n    void          LoadICCProfile();\n\n    CPLErr        RegisterNewOverviewDataset( toff_t nOverviewOffset, int l_nJpegQuality,\n                                              int l_nWebPLevel );\n    CPLErr        CreateOverviewsFromSrcOverviews( GDALDataset* poSrcDS,\n                                                   GDALDataset* poOvrDS );\n    CPLErr        CreateInternalMaskOverviews( int nOvrBlockXSize,\n                                               int nOvrBlockYSize );\n    int           Finalize();\n\n    void           DiscardLsb(GByte* pabyBuffer, GPtrDiff_t nBytes, int iBand) const;\n    void           GetDiscardLsbOption( char** papszOptions );\n    void           InitCompressionThreads( char** papszOptions );\n    void           InitCreationOrOpenOptions( char** papszOptions );\n    static void    ThreadCompressionFunc( void* pData );\n    void           WaitCompletionForJobIdx( int i );\n    void           WaitCompletionForBlock( int nBlockId );\n    void           WriteRawStripOrTile( int nStripOrTile,\n                                        GByte* pabyCompressedBuffer,\n                                        GPtrDiff_t nCompressedBufferSize );\n    bool           SubmitCompressionJob( int nStripOrTile, GByte* pabyData,\n                                         GPtrDiff_t cc, int nHeight) ;\n\n    int            GuessJPEGQuality( bool& bOutHasQuantizationTable,\n                                     bool& bOutHasHuffmanTable );\n\n    void           SetJPEGQualityAndTablesModeFromFile();\n\n    int            DirectIO( GDALRWFlag eRWFlag,\n                             int nXOff, int nYOff, int nXSize, int nYSize,\n                             void * pData, int nBufXSize, int nBufYSize,\n                             GDALDataType eBufType,\n                             int nBandCount, int *panBandMap,\n                             GSpacing nPixelSpace, GSpacing nLineSpace,\n                             GSpacing nBandSpace,\n                             GDALRasterIOExtraArg* psExtraArg );\n\n    int            VirtualMemIO( GDALRWFlag eRWFlag,\n                                 int nXOff, int nYOff, int nXSize, int nYSize,\n                                 void * pData, int nBufXSize, int nBufYSize,\n                                 GDALDataType eBufType,\n                                 int nBandCount, int *panBandMap,\n                                 GSpacing nPixelSpace, GSpacing nLineSpace,\n                                 GSpacing nBandSpace,\n                                 GDALRasterIOExtraArg* psExtraArg );\n\n    void            SetStructuralMDFromParent(GTiffDataset* poParentDS);\n\n    template<class FetchBuffer> CPLErr CommonDirectIO(\n        FetchBuffer& oFetcher,\n        int nXOff, int nYOff, int nXSize, int nYSize,\n        void * pData, int nBufXSize, int nBufYSize,\n        GDALDataType eBufType,\n        int nBandCount, int *panBandMap,\n        GSpacing nPixelSpace, GSpacing nLineSpace,\n        GSpacing nBandSpace );\n\n    void        LoadGeoreferencingAndPamIfNeeded();\n\n    char      **GetSiblingFiles();\n\n    void        IdentifyAuthorizedGeoreferencingSources();\n\n    void        FlushCacheInternal( bool bFlushDirectory );\n    bool        HasOptimizedReadMultiRange();\n\n    bool        AssociateExternalMask();\n\n    static bool MustCreateInternalMask();\n\n    static CPLErr CopyImageryAndMask(GTiffDataset* poDstDS,\n                                     GDALDataset* poSrcDS,\n                                     GDALRasterBand* poSrcMaskBand,\n                                     GDALProgressFunc pfnProgress,\n                                     void * pProgressData);\n\n  protected:\n    virtual int         CloseDependentDatasets() override;\n\n  public:\n             GTiffDataset();\n    virtual ~GTiffDataset();\n\n    const OGRSpatialReference* GetSpatialRef() const override;\n    CPLErr SetSpatialRef(const OGRSpatialReference* poSRS) override;\n\n    virtual CPLErr GetGeoTransform( double * ) override;\n    virtual CPLErr SetGeoTransform( double * ) override;\n\n    virtual int    GetGCPCount() override;\n    const OGRSpatialReference* GetGCPSpatialRef() const override;\n    virtual const GDAL_GCP *GetGCPs() override;\n    CPLErr SetGCPs( int nGCPCountIn, const GDAL_GCP *pasGCPListIn,\n                    const OGRSpatialReference* poSRS ) override;\n\n    virtual CPLErr IRasterIO( GDALRWFlag eRWFlag,\n                              int nXOff, int nYOff, int nXSize, int nYSize,\n                              void * pData, int nBufXSize, int nBufYSize,\n                              GDALDataType eBufType,\n                              int nBandCount, int *panBandMap,\n                              GSpacing nPixelSpace, GSpacing nLineSpace,\n                              GSpacing nBandSpace,\n                              GDALRasterIOExtraArg* psExtraArg ) override;\n    virtual char **GetFileList() override;\n\n    virtual CPLErr IBuildOverviews( const char *, int, int *, int, int *,\n                                    GDALProgressFunc, void * ) override;\n\n    CPLErr         OpenOffset( TIFF *,\n                               toff_t nDirOffset, GDALAccess,\n                               bool bAllowRGBAInterface = true,\n                               bool bReadGeoTransform = false );\n\n    static GDALDataset *OpenDir( GDALOpenInfo * );\n    static GDALDataset *Open( GDALOpenInfo * );\n    static int          Identify( GDALOpenInfo * );\n    static GDALDataset *Create( const char * pszFilename,\n                                int nXSize, int nYSize, int nBands,\n                                GDALDataType eType, char ** papszParmList );\n    static GDALDataset *CreateCopy( const char * pszFilename,\n                                    GDALDataset *poSrcDS,\n                                    int bStrict, char ** papszOptions,\n                                    GDALProgressFunc pfnProgress,\n                                    void * pProgressData );\n    virtual void    FlushCache() override;\n\n    virtual char  **GetMetadataDomainList() override;\n    virtual CPLErr  SetMetadata( char **, const char * = \"\" ) override;\n    virtual char  **GetMetadata( const char * pszDomain = \"\" ) override;\n    virtual CPLErr  SetMetadataItem( const char*, const char*,\n                                     const char* = \"\" ) override;\n    virtual const char *GetMetadataItem( const char * pszName,\n                                         const char * pszDomain = \"\" ) override;\n    virtual void   *GetInternalHandle( const char * ) override;\n\n    virtual CPLErr          CreateMaskBand( int nFlags ) override;\n\n    bool GetRawBinaryLayout(GDALDataset::RawBinaryLayout&) override;\n\n    // Only needed by createcopy and close code.\n    static void     WriteRPC( GDALDataset *, TIFF *, int, GTiffProfile, \n                              const char *, char **,\n                              bool bWriteOnlyInPAMIfNeeded = false );\n    static bool     WriteMetadata( GDALDataset *, TIFF *, bool, GTiffProfile,\n                                   const char *, char **,\n                                   bool bExcludeRPBandIMGFileWriting = false );\n    static void     WriteNoDataValue( TIFF *, double );\n    static void     UnsetNoDataValue( TIFF * );\n\n    static TIFF *   CreateLL( const char * pszFilename,\n                              int nXSize, int nYSize, int nBands,\n                              GDALDataType eType,\n                              double dfExtraSpaceForOverviews,\n                              char **papszParmList,\n                              VSILFILE** pfpL,\n                              CPLString& osTmpFilename );\n\n    CPLErr   WriteEncodedTileOrStrip( uint32 tile_or_strip, void* data,\n                                      int bPreserveDataBuffer );\n\n    static void SaveICCProfile( GTiffDataset *pDS, TIFF *hTIFF,\n                                char **papszParmList, uint32 nBitsPerSample );\n};\n\n/************************************************************************/\n/* ==================================================================== */\n/*                        GTiffJPEGOverviewDS                           */\n/* ==================================================================== */\n/************************************************************************/\n\nclass GTiffJPEGOverviewDS final : public GDALDataset\n{\n    CPL_DISALLOW_COPY_ASSIGN(GTiffJPEGOverviewDS)\n\n    friend class GTiffJPEGOverviewBand;\n    GTiffDataset* m_poParentDS = nullptr;\n    int           m_nOverviewLevel = 0;\n\n    int        m_nJPEGTableSize = 0;\n    GByte     *m_pabyJPEGTable = nullptr;\n    CPLString  m_osTmpFilenameJPEGTable{};\n\n    CPLString    m_osTmpFilename{};\n    GDALDataset* m_poJPEGDS = nullptr;\n    // Valid block id of the parent DS that match poJPEGDS.\n    int          m_nBlockId = -1;\n\n  public:\n    GTiffJPEGOverviewDS( GTiffDataset* poParentDS, int nOverviewLevel,\n                         const void* pJPEGTable, int nJPEGTableSize );\n    virtual ~GTiffJPEGOverviewDS();\n\n    virtual CPLErr IRasterIO( GDALRWFlag eRWFlag,\n                              int nXOff, int nYOff, int nXSize, int nYSize,\n                              void * pData, int nBufXSize, int nBufYSize,\n                              GDALDataType eBufType,\n                              int nBandCount, int *panBandMap,\n                              GSpacing nPixelSpace, GSpacing nLineSpace,\n                              GSpacing nBandSpace,\n                              GDALRasterIOExtraArg* psExtraArg ) override;\n};\n\nclass GTiffJPEGOverviewBand final : public GDALRasterBand\n{\n  public:\n    GTiffJPEGOverviewBand( GTiffJPEGOverviewDS* poDS, int nBand );\n    virtual ~GTiffJPEGOverviewBand() {}\n\n    virtual CPLErr IReadBlock( int, int, void * ) override;\n};\n\n/************************************************************************/\n/*                        GTiffJPEGOverviewDS()                         */\n/************************************************************************/\n\nGTiffJPEGOverviewDS::GTiffJPEGOverviewDS( GTiffDataset* poParentDSIn,\n                                          int nOverviewLevelIn,\n                                          const void* pJPEGTable,\n                                          int nJPEGTableSizeIn ) :\n    m_poParentDS(poParentDSIn),\n    m_nOverviewLevel(nOverviewLevelIn),\n    m_nJPEGTableSize(nJPEGTableSizeIn)\n{\n    ShareLockWithParentDataset(poParentDSIn);\n\n    m_osTmpFilenameJPEGTable.Printf(\"/vsimem/jpegtable_%p\", this);\n\n    const GByte abyAdobeAPP14RGB[] = {\n        0xFF, 0xEE, 0x00, 0x0E, 0x41, 0x64, 0x6F, 0x62, 0x65, 0x00,\n        0x64, 0x00, 0x00, 0x00, 0x00, 0x00 };\n    const bool bAddAdobe =\n        m_poParentDS->m_nPlanarConfig == PLANARCONFIG_CONTIG &&\n        m_poParentDS->m_nPhotometric != PHOTOMETRIC_YCBCR &&\n        m_poParentDS->nBands == 3;\n    m_pabyJPEGTable =\n        static_cast<GByte*>( CPLMalloc(\n            m_nJPEGTableSize + (bAddAdobe ? sizeof(abyAdobeAPP14RGB) : 0)) );\n    memcpy(m_pabyJPEGTable, pJPEGTable, m_nJPEGTableSize);\n    if( bAddAdobe )\n    {\n        memcpy( m_pabyJPEGTable + m_nJPEGTableSize, abyAdobeAPP14RGB,\n                sizeof(abyAdobeAPP14RGB) );\n        m_nJPEGTableSize += sizeof(abyAdobeAPP14RGB);\n    }\n    CPL_IGNORE_RET_VAL(\n        VSIFCloseL(\n            VSIFileFromMemBuffer(\n                m_osTmpFilenameJPEGTable, m_pabyJPEGTable, m_nJPEGTableSize, TRUE )));\n\n    const int nScaleFactor = 1 << m_nOverviewLevel;\n    nRasterXSize = (m_poParentDS->nRasterXSize + nScaleFactor - 1) / nScaleFactor;\n    nRasterYSize = (m_poParentDS->nRasterYSize + nScaleFactor - 1) / nScaleFactor;\n\n    for( int i = 1; i <= m_poParentDS->nBands; ++i )\n        SetBand(i, new GTiffJPEGOverviewBand(this, i));\n\n    SetMetadataItem( \"INTERLEAVE\", \"PIXEL\", \"IMAGE_STRUCTURE\" );\n    if( m_poParentDS->m_nPhotometric == PHOTOMETRIC_YCBCR )\n        SetMetadataItem( \"COMPRESSION\", \"YCbCr JPEG\", \"IMAGE_STRUCTURE\" );\n    else\n        SetMetadataItem( \"COMPRESSION\", \"JPEG\", \"IMAGE_STRUCTURE\" );\n}\n\n/************************************************************************/\n/*                       ~GTiffJPEGOverviewDS()                         */\n/************************************************************************/\n\nGTiffJPEGOverviewDS::~GTiffJPEGOverviewDS()\n{\n    if( m_poJPEGDS != nullptr )\n        GDALClose( m_poJPEGDS );\n    VSIUnlink(m_osTmpFilenameJPEGTable);\n    if( !m_osTmpFilename.empty() )\n        VSIUnlink(m_osTmpFilename);\n}\n\n/************************************************************************/\n/*                            IRasterIO()                               */\n/************************************************************************/\n\nCPLErr GTiffJPEGOverviewDS::IRasterIO(\n    GDALRWFlag eRWFlag,\n    int nXOff, int nYOff, int nXSize, int nYSize,\n    void * pData, int nBufXSize, int nBufYSize,\n    GDALDataType eBufType,\n    int nBandCount, int *panBandMap,\n    GSpacing nPixelSpace, GSpacing nLineSpace,\n    GSpacing nBandSpace,\n    GDALRasterIOExtraArg* psExtraArg )\n\n{\n    // For non-single strip JPEG-IN-TIFF, the block based strategy will\n    // be the most efficient one, to avoid decompressing the JPEG content\n    // for each requested band.\n    if( nBandCount > 1 && m_poParentDS->m_nPlanarConfig == PLANARCONFIG_CONTIG &&\n        (m_poParentDS->m_nBlockXSize < m_poParentDS->nRasterXSize ||\n         m_poParentDS->m_nBlockYSize > 1) )\n    {\n        return BlockBasedRasterIO( eRWFlag, nXOff, nYOff, nXSize, nYSize,\n                                   pData, nBufXSize, nBufYSize,\n                                   eBufType, nBandCount, panBandMap,\n                                   nPixelSpace, nLineSpace, nBandSpace,\n                                   psExtraArg );\n    }\n\n    return GDALDataset::IRasterIO(\n        eRWFlag, nXOff, nYOff, nXSize, nYSize,\n        pData, nBufXSize, nBufYSize, eBufType,\n        nBandCount, panBandMap, nPixelSpace, nLineSpace, nBandSpace,\n        psExtraArg );\n}\n\n/************************************************************************/\n/*                        GTiffJPEGOverviewBand()                       */\n/************************************************************************/\n\nGTiffJPEGOverviewBand::GTiffJPEGOverviewBand( GTiffJPEGOverviewDS* poDSIn,\n                                              int nBandIn )\n{\n    poDS = poDSIn;\n    nBand = nBandIn;\n    eDataType =\n        poDSIn->m_poParentDS->GetRasterBand(nBandIn)->GetRasterDataType();\n    poDSIn->m_poParentDS->GetRasterBand(nBandIn)->\n        GetBlockSize(&nBlockXSize, &nBlockYSize);\n    const int nScaleFactor = 1 << poDSIn->m_nOverviewLevel;\n    nBlockXSize = (nBlockXSize + nScaleFactor - 1) / nScaleFactor;\n    nBlockYSize = (nBlockYSize + nScaleFactor - 1) / nScaleFactor;\n}\n\n/************************************************************************/\n/*                          IReadBlock()                                */\n/************************************************************************/\n\nCPLErr GTiffJPEGOverviewBand::IReadBlock( int nBlockXOff, int nBlockYOff,\n                                          void *pImage )\n{\n    GTiffJPEGOverviewDS* m_poGDS = cpl::down_cast<GTiffJPEGOverviewDS *>(poDS);\n\n    // Compute the source block ID.\n    int nBlockId = 0;\n    int nParentBlockXSize, nParentBlockYSize;\n    m_poGDS->m_poParentDS->GetRasterBand(1)->\n        GetBlockSize(&nParentBlockXSize, &nParentBlockYSize);\n    const bool bIsSingleStripAsSplit = (nParentBlockYSize == 1 &&\n                           m_poGDS->m_poParentDS->m_nBlockYSize != nParentBlockYSize);\n    if( !bIsSingleStripAsSplit )\n    {\n        int l_nBlocksPerRow = DIV_ROUND_UP(m_poGDS->m_poParentDS->nRasterXSize,\n                                               m_poGDS->m_poParentDS->m_nBlockXSize);\n        nBlockId = nBlockYOff * l_nBlocksPerRow + nBlockXOff;\n    }\n    if( m_poGDS->m_poParentDS->m_nPlanarConfig == PLANARCONFIG_SEPARATE )\n    {\n        nBlockId += (nBand-1) * m_poGDS->m_poParentDS->m_nBlocksPerBand;\n    }\n\n    // Make sure it is available.\n    const int nDataTypeSize = GDALGetDataTypeSizeBytes(eDataType);\n    vsi_l_offset nOffset = 0;\n    vsi_l_offset nByteCount = 0;\n    bool bErrOccurred = false;\n    if( !m_poGDS->m_poParentDS->IsBlockAvailable(nBlockId, &nOffset, &nByteCount, &bErrOccurred) )\n    {\n        memset(pImage, 0, static_cast<GPtrDiff_t>(nBlockXSize) * nBlockYSize * nDataTypeSize );\n        if( bErrOccurred )\n            return CE_Failure;\n        return CE_None;\n    }\n\n    const int nScaleFactor = 1 << m_poGDS->m_nOverviewLevel;\n    if( m_poGDS->m_poJPEGDS == nullptr || nBlockId != m_poGDS->m_nBlockId )\n    {\n        if( nByteCount < 2 )\n            return CE_Failure;\n        nOffset += 2;  // Skip leading 0xFF 0xF8.\n        nByteCount -= 2;\n\n        // Special case for last strip that might be smaller than other strips\n        // In which case we must invalidate the dataset.\n        TIFF* hTIFF = m_poGDS->m_poParentDS->m_hTIFF;\n        if( !TIFFIsTiled( hTIFF ) && !bIsSingleStripAsSplit &&\n            (nBlockYOff + 1 ==\n                 DIV_ROUND_UP( m_poGDS->m_poParentDS->nRasterYSize,\n                               m_poGDS->m_poParentDS->m_nBlockYSize ) ||\n             (m_poGDS->m_poJPEGDS != nullptr &&\n              m_poGDS->m_poJPEGDS->GetRasterYSize() !=\n              nBlockYSize * nScaleFactor)) )\n        {\n            if( m_poGDS->m_poJPEGDS != nullptr )\n                GDALClose( m_poGDS->m_poJPEGDS );\n            m_poGDS->m_poJPEGDS = nullptr;\n        }\n\n        CPLString osFileToOpen;\n        m_poGDS->m_osTmpFilename.Printf(\"/vsimem/sparse_%p\", m_poGDS);\n        VSILFILE* fp = VSIFOpenL(m_poGDS->m_osTmpFilename, \"wb+\");\n\n        // If the size of the JPEG strip/tile is small enough, we will\n        // read it from the TIFF file and forge a in-memory JPEG file with\n        // the JPEG table followed by the JPEG data.\n        const bool bInMemoryJPEGFile = nByteCount < 256 * 256;\n        if( bInMemoryJPEGFile )\n        {\n            // If the previous file was opened as a /vsisparse/, must re-open.\n            if( m_poGDS->m_poJPEGDS != nullptr &&\n                STARTS_WITH(m_poGDS->m_poJPEGDS->GetDescription(), \"/vsisparse/\") )\n            {\n                GDALClose( m_poGDS->m_poJPEGDS );\n                m_poGDS->m_poJPEGDS = nullptr;\n            }\n            osFileToOpen = m_poGDS->m_osTmpFilename;\n\n            bool bError = false;\n            if( VSIFSeekL(fp, m_poGDS->m_nJPEGTableSize + nByteCount - 1, SEEK_SET)\n                != 0 )\n                bError = true;\n            char ch = 0;\n            if( !bError && VSIFWriteL(&ch, 1, 1, fp) != 1 )\n                bError = true;\n            GByte* pabyBuffer =\n                VSIGetMemFileBuffer( m_poGDS->m_osTmpFilename, nullptr, FALSE);\n            memcpy(pabyBuffer, m_poGDS->m_pabyJPEGTable, m_poGDS->m_nJPEGTableSize);\n            VSILFILE* fpTIF = VSI_TIFFGetVSILFile(TIFFClientdata( hTIFF ));\n            if( !bError && VSIFSeekL(fpTIF, nOffset, SEEK_SET) != 0 )\n                bError = true;\n            if( VSIFReadL( pabyBuffer + m_poGDS->m_nJPEGTableSize,\n                           static_cast<size_t>(nByteCount), 1, fpTIF) != 1 )\n                bError = true;\n            if( bError )\n            {\n                CPL_IGNORE_RET_VAL(VSIFCloseL(fp));\n                return CE_Failure;\n            }\n        }\n        else\n        {\n            // If the JPEG strip/tile is too big (e.g. a single-strip\n            // JPEG-in-TIFF), we will use /vsisparse mechanism to make a\n            // fake JPEG file.\n\n            // Always re-open.\n            GDALClose( m_poGDS->m_poJPEGDS );\n            m_poGDS->m_poJPEGDS = nullptr;\n\n            osFileToOpen =\n                CPLSPrintf(\"/vsisparse/%s\", m_poGDS->m_osTmpFilename.c_str());\n\n            if( VSIFPrintfL(\n                    fp,\n                    \"<VSISparseFile><SubfileRegion>\"\n                    \"<Filename relative='0'>%s</Filename>\"\n                    \"<DestinationOffset>0</DestinationOffset>\"\n                    \"<SourceOffset>0</SourceOffset>\"\n                    \"<RegionLength>%d</RegionLength>\"\n                    \"</SubfileRegion>\"\n                    \"<SubfileRegion>\"\n                    \"<Filename relative='0'>%s</Filename>\"\n                    \"<DestinationOffset>%d</DestinationOffset>\"\n                    \"<SourceOffset>\" CPL_FRMT_GUIB \"</SourceOffset>\"\n                    \"<RegionLength>\" CPL_FRMT_GUIB \"</RegionLength>\"\n                    \"</SubfileRegion></VSISparseFile>\",\n                    m_poGDS->m_osTmpFilenameJPEGTable.c_str(),\n                    static_cast<int>(m_poGDS->m_nJPEGTableSize),\n                    m_poGDS->m_poParentDS->GetDescription(),\n                    static_cast<int>(m_poGDS->m_nJPEGTableSize),\n                    nOffset,\n                    nByteCount) < 0 )\n            {\n                CPL_IGNORE_RET_VAL(VSIFCloseL(fp));\n                return CE_Failure;\n            }\n        }\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fp));\n\n        if( m_poGDS->m_poJPEGDS == nullptr )\n        {\n            const char* apszDrivers[] = { \"JPEG\", nullptr };\n\n            CPLString osOldVal;\n            if( m_poGDS->m_poParentDS->m_nPlanarConfig == PLANARCONFIG_CONTIG &&\n                m_poGDS->nBands == 4 )\n            {\n                osOldVal =\n                    CPLGetThreadLocalConfigOption(\"GDAL_JPEG_TO_RGB\", \"\");\n                CPLSetThreadLocalConfigOption(\"GDAL_JPEG_TO_RGB\", \"NO\");\n            }\n\n            m_poGDS->m_poJPEGDS =\n                static_cast<GDALDataset *>( GDALOpenEx(\n                    osFileToOpen,\n                    GDAL_OF_RASTER | GDAL_OF_INTERNAL,\n                    apszDrivers, nullptr, nullptr) );\n\n            if( m_poGDS->m_poJPEGDS != nullptr )\n            {\n                // Force all implicit overviews to be available, even for\n                // small tiles.\n                CPLSetThreadLocalConfigOption( \"JPEG_FORCE_INTERNAL_OVERVIEWS\",\n                                               \"YES\");\n                GDALGetOverviewCount(GDALGetRasterBand(m_poGDS->m_poJPEGDS, 1));\n                CPLSetThreadLocalConfigOption( \"JPEG_FORCE_INTERNAL_OVERVIEWS\",\n                                               nullptr);\n\n                m_poGDS->m_nBlockId = nBlockId;\n            }\n\n            if( m_poGDS->m_poParentDS->m_nPlanarConfig == PLANARCONFIG_CONTIG &&\n                m_poGDS->nBands == 4 )\n            {\n                CPLSetThreadLocalConfigOption(\n                    \"GDAL_JPEG_TO_RGB\",\n                    !osOldVal.empty() ? osOldVal.c_str() : nullptr );\n            }\n        }\n        else\n        {\n            // Trick: we invalidate the JPEG dataset to force a reload\n            // of the new content.\n            CPLErrorReset();\n            m_poGDS->m_poJPEGDS->FlushCache();\n            if( CPLGetLastErrorNo() != 0 )\n            {\n                GDALClose( m_poGDS->m_poJPEGDS );\n                m_poGDS->m_poJPEGDS = nullptr;\n                return CE_Failure;\n            }\n            m_poGDS->m_nBlockId = nBlockId;\n        }\n    }\n\n    CPLErr eErr = CE_Failure;\n    if( m_poGDS->m_poJPEGDS )\n    {\n        GDALDataset* l_poDS = m_poGDS->m_poJPEGDS;\n\n        int nReqXOff = 0;\n        int nReqYOff = 0;\n        int nReqXSize = 0;\n        int nReqYSize = 0;\n        if( bIsSingleStripAsSplit )\n        {\n            nReqYOff = nBlockYOff * nScaleFactor;\n            nReqXSize = l_poDS->GetRasterXSize();\n            nReqYSize = nScaleFactor;\n        }\n        else\n        {\n            if( nBlockXSize == m_poGDS->GetRasterXSize() )\n            {\n                nReqXSize = l_poDS->GetRasterXSize();\n            }\n            else\n            {\n                nReqXSize = nBlockXSize * nScaleFactor;\n            }\n            nReqYSize = nBlockYSize * nScaleFactor;\n        }\n        int nBufXSize = nBlockXSize;\n        int nBufYSize = nBlockYSize;\n        if( nBlockXOff == DIV_ROUND_UP(m_poGDS->m_poParentDS->nRasterXSize,\n                                       m_poGDS->m_poParentDS->m_nBlockXSize) - 1 )\n        {\n            nReqXSize = m_poGDS->m_poParentDS->nRasterXSize -\n                                nBlockXOff * m_poGDS->m_poParentDS->m_nBlockXSize;\n        }\n        if( nReqXOff + nReqXSize > l_poDS->GetRasterXSize() )\n        {\n            nReqXSize = l_poDS->GetRasterXSize() - nReqXOff;\n        }\n        if( !bIsSingleStripAsSplit &&\n            nBlockYOff == DIV_ROUND_UP(m_poGDS->m_poParentDS->nRasterYSize,\n                                       m_poGDS->m_poParentDS->m_nBlockYSize) - 1 )\n        {\n            nReqYSize = m_poGDS->m_poParentDS->nRasterYSize -\n                                nBlockYOff * m_poGDS->m_poParentDS->m_nBlockYSize;\n        }\n        if( nReqYOff + nReqYSize > l_poDS->GetRasterYSize() )\n        {\n            nReqYSize = l_poDS->GetRasterYSize() - nReqYOff;\n        }\n        if( nBlockXOff * nBlockXSize > m_poGDS->GetRasterXSize() - nBufXSize )\n        {\n            memset(pImage, 0, static_cast<GPtrDiff_t>(nBlockXSize) * nBlockYSize * nDataTypeSize);\n            nBufXSize = m_poGDS->GetRasterXSize() - nBlockXOff * nBlockXSize;\n        }\n        if( nBlockYOff * nBlockYSize > m_poGDS->GetRasterYSize() - nBufYSize )\n        {\n            memset(pImage, 0, static_cast<GPtrDiff_t>(nBlockXSize) * nBlockYSize * nDataTypeSize);\n            nBufYSize = m_poGDS->GetRasterYSize() - nBlockYOff * nBlockYSize;\n        }\n\n        const int nSrcBand =\n            m_poGDS->m_poParentDS->m_nPlanarConfig == PLANARCONFIG_SEPARATE ?\n            1 : nBand;\n        if( nSrcBand <= l_poDS->GetRasterCount() )\n        {\n            eErr = l_poDS->GetRasterBand(nSrcBand)->RasterIO(GF_Read,\n                                 nReqXOff, nReqYOff, nReqXSize, nReqYSize,\n                                 pImage,\n                                 nBufXSize, nBufYSize, eDataType,\n                                 0, static_cast<GPtrDiff_t>(nBlockXSize) * nDataTypeSize, nullptr );\n        }\n    }\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                        GTIFFSetJpegQuality()                         */\n/* Called by GTIFFBuildOverviews() to set the jpeg quality on the IFD   */\n/* of the .ovr file.                                                    */\n/************************************************************************/\n\nvoid GTIFFSetJpegQuality( GDALDatasetH hGTIFFDS, int nJpegQuality )\n{\n    CPLAssert(\n        EQUAL(GDALGetDriverShortName(GDALGetDatasetDriver(hGTIFFDS)), \"GTIFF\"));\n\n    GTiffDataset* const poDS = static_cast<GTiffDataset *>(hGTIFFDS);\n    poDS->m_nJpegQuality = static_cast<signed char>(nJpegQuality);\n\n    poDS->ScanDirectories();\n\n    for( int i = 0; i < poDS->m_nOverviewCount; ++i )\n        poDS->m_papoOverviewDS[i]->m_nJpegQuality = poDS->m_nJpegQuality;\n}\n\n/************************************************************************/\n/*                        GTIFFSetWebPLevel()                         */\n/* Called by GTIFFBuildOverviews() to set the jpeg quality on the IFD   */\n/* of the .ovr file.                                                    */\n/************************************************************************/\n\nvoid GTIFFSetWebPLevel( GDALDatasetH hGTIFFDS, int nWebpLevel )\n{\n    CPLAssert(\n        EQUAL(GDALGetDriverShortName(GDALGetDatasetDriver(hGTIFFDS)), \"GTIFF\"));\n\n    GTiffDataset* const poDS = static_cast<GTiffDataset *>(hGTIFFDS);\n    poDS->m_nWebPLevel = static_cast<signed char>(nWebpLevel);\n\n    poDS->ScanDirectories();\n\n    for( int i = 0; i < poDS->m_nOverviewCount; ++i )\n        poDS->m_papoOverviewDS[i]->m_nWebPLevel = poDS->m_nWebPLevel;\n}\n\n/************************************************************************/\n/*                     GTIFFSetJpegTablesMode()                         */\n/* Called by GTIFFBuildOverviews() to set the jpeg tables mode on the   */\n/* of the .ovr file.                                                    */\n/************************************************************************/\n\nvoid GTIFFSetJpegTablesMode( GDALDatasetH hGTIFFDS, int nJpegTablesMode )\n{\n    CPLAssert(\n        EQUAL(GDALGetDriverShortName(GDALGetDatasetDriver(hGTIFFDS)), \"GTIFF\"));\n\n    GTiffDataset* const poDS = static_cast<GTiffDataset *>(hGTIFFDS);\n    poDS->m_nJpegTablesMode = static_cast<signed char>(nJpegTablesMode);\n\n    poDS->ScanDirectories();\n\n    for( int i = 0; i < poDS->m_nOverviewCount; ++i )\n        poDS->m_papoOverviewDS[i]->m_nJpegTablesMode = poDS->m_nJpegTablesMode;\n}\n\n/************************************************************************/\n/* ==================================================================== */\n/*                            GTiffRasterBand                           */\n/* ==================================================================== */\n/************************************************************************/\n\nclass GTiffRasterBand CPL_NON_FINAL: public GDALPamRasterBand\n{\n    CPL_DISALLOW_COPY_ASSIGN(GTiffRasterBand)\n\n    friend class GTiffDataset;\n\n    double             m_dfOffset = 0;\n    double             m_dfScale = 1;\n    CPLString          m_osUnitType{};\n    CPLString          m_osDescription{};\n    GDALColorInterp    m_eBandInterp = GCI_Undefined;\n    std::set<GTiffRasterBand **> m_aSetPSelf{};\n    bool               m_bHaveOffsetScale = false;\n\n    int                DirectIO( GDALRWFlag eRWFlag,\n                                 int nXOff, int nYOff, int nXSize, int nYSize,\n                                 void * pData, int nBufXSize, int nBufYSize,\n                                 GDALDataType eBufType,\n                                 GSpacing nPixelSpace, GSpacing nLineSpace,\n                                 GDALRasterIOExtraArg* psExtraArg );\n\n    static void     DropReferenceVirtualMem( void* pUserData );\n    CPLVirtualMem * GetVirtualMemAutoInternal( GDALRWFlag eRWFlag,\n                                               int *pnPixelSpace,\n                                               GIntBig *pnLineSpace,\n                                               char **papszOptions );\n\n    void*           CacheMultiRange( int nXOff, int nYOff,\n                                     int nXSize, int nYSize,\n                                     int nBufXSize, int nBufYSize,\n                                     GDALRasterIOExtraArg* psExtraArg );\n\nprotected:\n    GTiffDataset       *m_poGDS = nullptr;\n    GDALMultiDomainMetadata m_oGTiffMDMD{};\n\n    double             m_dfNoDataValue = -9999.0;\n    bool               m_bNoDataSet = false;\n\n    void NullBlock( void *pData );\n    CPLErr FillCacheForOtherBands( int nBlockXOff, int nBlockYOff );\n#ifdef SUPPORTS_GET_OFFSET_BYTECOUNT\n    void CacheMaskForBlock( int nBlockXOff, int nBlockYOff );\n#endif\n\npublic:\n             GTiffRasterBand( GTiffDataset *, int );\n    virtual ~GTiffRasterBand();\n\n    virtual CPLErr IReadBlock( int, int, void * ) override;\n    virtual CPLErr IWriteBlock( int, int, void * ) override;\n\n    virtual int IGetDataCoverageStatus( int nXOff, int nYOff,\n                                        int nXSize, int nYSize,\n                                        int nMaskFlagStop,\n                                        double* pdfDataPct) override;\n\n    virtual CPLErr IRasterIO( GDALRWFlag eRWFlag,\n                              int nXOff, int nYOff, int nXSize, int nYSize,\n                              void * pData, int nBufXSize, int nBufYSize,\n                              GDALDataType eBufType,\n                              GSpacing nPixelSpace, GSpacing nLineSpace,\n                              GDALRasterIOExtraArg* psExtraArg ) override final;\n\n    virtual const char *GetDescription() const override final;\n    virtual void        SetDescription( const char * ) override final;\n\n    virtual GDALColorInterp GetColorInterpretation() override /*final*/;\n    virtual GDALColorTable *GetColorTable() override /*final*/;\n    virtual CPLErr          SetColorTable( GDALColorTable * ) override final;\n    virtual double          GetNoDataValue( int * ) override final;\n    virtual CPLErr          SetNoDataValue( double ) override final;\n    virtual CPLErr DeleteNoDataValue() override final;\n\n    virtual double GetOffset( int *pbSuccess = nullptr ) override final;\n    virtual CPLErr SetOffset( double dfNewValue ) override final;\n    virtual double GetScale( int *pbSuccess = nullptr ) override final;\n    virtual CPLErr SetScale( double dfNewValue ) override final;\n    virtual const char* GetUnitType() override final;\n    virtual CPLErr SetUnitType( const char *pszNewValue ) override final;\n    virtual CPLErr SetColorInterpretation( GDALColorInterp ) override final;\n\n    virtual char      **GetMetadataDomainList() override final;\n    virtual CPLErr  SetMetadata( char **, const char * = \"\" ) override final;\n    virtual char  **GetMetadata( const char * pszDomain = \"\" ) override final;\n    virtual CPLErr  SetMetadataItem( const char*, const char*,\n                                     const char* = \"\" ) override final;\n    virtual const char *GetMetadataItem(\n        const char * pszName, const char * pszDomain = \"\" ) override final;\n    virtual int    GetOverviewCount()  override final;\n    virtual GDALRasterBand *GetOverview( int ) override final;\n\n    virtual GDALRasterBand *GetMaskBand() override final;\n    virtual int             GetMaskFlags() override final;\n    virtual CPLErr          CreateMaskBand( int nFlags )  override final;\n\n    virtual CPLVirtualMem  *GetVirtualMemAuto( GDALRWFlag eRWFlag,\n                                               int *pnPixelSpace,\n                                               GIntBig *pnLineSpace,\n                                               char **papszOptions )  override final;\n\n    GDALRasterAttributeTable* GetDefaultRAT() override final;\n    virtual CPLErr  GetHistogram(\n        double dfMin, double dfMax,\n        int nBuckets, GUIntBig * panHistogram,\n        int bIncludeOutOfRange, int bApproxOK,\n        GDALProgressFunc, void *pProgressData )  override final;\n\n    virtual CPLErr GetDefaultHistogram( double *pdfMin, double *pdfMax,\n                                        int *pnBuckets,\n                                        GUIntBig ** ppanHistogram,\n                                        int bForce,\n                                        GDALProgressFunc,\n                                        void *pProgressData)  override final;\n};\n\n/************************************************************************/\n/*                           GTiffRasterBand()                          */\n/************************************************************************/\n\nGTiffRasterBand::GTiffRasterBand( GTiffDataset *poDSIn, int nBandIn ):\n    m_poGDS(poDSIn)\n{\n    poDS = poDSIn;\n    nBand = nBandIn;\n\n/* -------------------------------------------------------------------- */\n/*      Get the GDAL data type.                                         */\n/* -------------------------------------------------------------------- */\n    const uint16 nBitsPerSample = m_poGDS->m_nBitsPerSample;\n    const uint16 nSampleFormat = m_poGDS->m_nSampleFormat;\n\n    eDataType = GDT_Unknown;\n\n    if( nBitsPerSample <= 8 )\n    {\n        eDataType = GDT_Byte;\n        if( nSampleFormat == SAMPLEFORMAT_INT )\n            m_oGTiffMDMD.SetMetadataItem( \"PIXELTYPE\", \"SIGNEDBYTE\",\n                                        \"IMAGE_STRUCTURE\" );\n    }\n    else if( nBitsPerSample <= 16 )\n    {\n        if( nSampleFormat == SAMPLEFORMAT_INT )\n            eDataType = GDT_Int16;\n        else\n            eDataType = GDT_UInt16;\n    }\n    else if( nBitsPerSample == 32 )\n    {\n        if( nSampleFormat == SAMPLEFORMAT_COMPLEXINT )\n            eDataType = GDT_CInt16;\n        else if( nSampleFormat == SAMPLEFORMAT_IEEEFP )\n            eDataType = GDT_Float32;\n        else if( nSampleFormat == SAMPLEFORMAT_INT )\n            eDataType = GDT_Int32;\n        else\n            eDataType = GDT_UInt32;\n    }\n    else if( nBitsPerSample == 64 )\n    {\n        if( nSampleFormat == SAMPLEFORMAT_IEEEFP )\n            eDataType = GDT_Float64;\n        else if( nSampleFormat == SAMPLEFORMAT_COMPLEXIEEEFP )\n            eDataType = GDT_CFloat32;\n        else if( nSampleFormat == SAMPLEFORMAT_COMPLEXINT )\n            eDataType = GDT_CInt32;\n    }\n    else if( nBitsPerSample == 128 )\n    {\n        if( nSampleFormat == SAMPLEFORMAT_COMPLEXIEEEFP )\n            eDataType = GDT_CFloat64;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Try to work out band color interpretation.                      */\n/* -------------------------------------------------------------------- */\n    bool bLookForExtraSamples = false;\n\n    if( m_poGDS->m_poColorTable != nullptr && nBand == 1 )\n    {\n        m_eBandInterp = GCI_PaletteIndex;\n    }\n    else if( m_poGDS->m_nPhotometric == PHOTOMETRIC_RGB\n             || (m_poGDS->m_nPhotometric == PHOTOMETRIC_YCBCR\n                 && m_poGDS->m_nCompression == COMPRESSION_JPEG\n                 && CPLTestBool( CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\",\n                                                    \"YES\") )) )\n    {\n        if( nBand == 1 )\n            m_eBandInterp = GCI_RedBand;\n        else if( nBand == 2 )\n            m_eBandInterp = GCI_GreenBand;\n        else if( nBand == 3 )\n            m_eBandInterp = GCI_BlueBand;\n        else\n            bLookForExtraSamples = true;\n    }\n    else if( m_poGDS->m_nPhotometric == PHOTOMETRIC_YCBCR )\n    {\n        if( nBand == 1 )\n            m_eBandInterp = GCI_YCbCr_YBand;\n        else if( nBand == 2 )\n            m_eBandInterp = GCI_YCbCr_CbBand;\n        else if( nBand == 3 )\n            m_eBandInterp = GCI_YCbCr_CrBand;\n        else\n            bLookForExtraSamples = true;\n    }\n    else if( m_poGDS->m_nPhotometric == PHOTOMETRIC_SEPARATED )\n    {\n        if( nBand == 1 )\n            m_eBandInterp = GCI_CyanBand;\n        else if( nBand == 2 )\n            m_eBandInterp = GCI_MagentaBand;\n        else if( nBand == 3 )\n            m_eBandInterp = GCI_YellowBand;\n        else if( nBand == 4 )\n            m_eBandInterp = GCI_BlackBand;\n        else\n            bLookForExtraSamples = true;\n    }\n    else if( m_poGDS->m_nPhotometric == PHOTOMETRIC_MINISBLACK && nBand == 1 )\n    {\n        m_eBandInterp = GCI_GrayIndex;\n    }\n    else\n    {\n        bLookForExtraSamples = true;\n    }\n\n    if( bLookForExtraSamples )\n    {\n        uint16 *v = nullptr;\n        uint16 count = 0;\n\n        if( TIFFGetField( m_poGDS->m_hTIFF, TIFFTAG_EXTRASAMPLES, &count, &v ) )\n        {\n            const int nBaseSamples = m_poGDS->m_nSamplesPerPixel - count;\n            const int nExpectedBaseSamples =\n                (m_poGDS->m_nPhotometric == PHOTOMETRIC_MINISBLACK) ? 1 :\n                (m_poGDS->m_nPhotometric == PHOTOMETRIC_MINISWHITE) ? 1 :\n                (m_poGDS->m_nPhotometric == PHOTOMETRIC_RGB) ? 3 :\n                (m_poGDS->m_nPhotometric == PHOTOMETRIC_YCBCR) ? 3 :\n                (m_poGDS->m_nPhotometric == PHOTOMETRIC_SEPARATED) ? 4 : 0;\n\n            if( nExpectedBaseSamples > 0 &&\n                nBand == nExpectedBaseSamples + 1 &&\n                nBaseSamples != nExpectedBaseSamples )\n            {\n                ReportError(CE_Warning, CPLE_AppDefined,\n                         \"Wrong number of ExtraSamples : %d. %d were expected\",\n                         count, m_poGDS->m_nSamplesPerPixel - nExpectedBaseSamples);\n            }\n\n            if( nBand > nBaseSamples\n                && nBand-nBaseSamples-1 < count\n                && (v[nBand-nBaseSamples-1] == EXTRASAMPLE_ASSOCALPHA\n                    || v[nBand-nBaseSamples-1] == EXTRASAMPLE_UNASSALPHA) )\n                m_eBandInterp = GCI_AlphaBand;\n            else\n                m_eBandInterp = GCI_Undefined;\n        }\n        else\n        {\n            m_eBandInterp = GCI_Undefined;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Establish block size for strip or tiles.                        */\n/* -------------------------------------------------------------------- */\n    nBlockXSize = m_poGDS->m_nBlockXSize;\n    nBlockYSize = m_poGDS->m_nBlockYSize;\n}\n\n/************************************************************************/\n/*                          ~GTiffRasterBand()                          */\n/************************************************************************/\n\nGTiffRasterBand::~GTiffRasterBand()\n{\n    // So that any future DropReferenceVirtualMem() will not try to access the\n    // raster band object, but this would not conform to the advertised\n    // contract.\n    if( !m_aSetPSelf.empty() )\n    {\n        ReportError( CE_Warning, CPLE_AppDefined,\n                  \"Virtual memory objects still exist at GTiffRasterBand \"\n                  \"destruction\" );\n        std::set<GTiffRasterBand**>::iterator oIter = m_aSetPSelf.begin();\n        for( ; oIter != m_aSetPSelf.end(); ++oIter )\n            *(*oIter) = nullptr;\n    }\n}\n\n/************************************************************************/\n/*                        FetchBufferDirectIO                           */\n/************************************************************************/\n\nclass FetchBufferDirectIO final\n{\n    VSILFILE*    fp;\n    GByte       *pTempBuffer;\n    size_t       nTempBufferSize;\n\npublic:\n            FetchBufferDirectIO( VSILFILE* fpIn,\n                                 GByte* pTempBufferIn,\n                                 size_t nTempBufferSizeIn ) :\n                fp(fpIn),\n                pTempBuffer(pTempBufferIn),\n                nTempBufferSize(nTempBufferSizeIn) {}\n\n    const GByte* FetchBytes( vsi_l_offset nOffset,\n                             int nPixels, int nDTSize,\n                             bool bIsByteSwapped, bool bIsComplex,\n                             int nBlockId )\n    {\n        if( !FetchBytes(pTempBuffer, nOffset, nPixels, nDTSize, bIsByteSwapped,\n                        bIsComplex, nBlockId) )\n        {\n            return nullptr;\n        }\n        return pTempBuffer;\n    }\n\n    bool FetchBytes( GByte* pabyDstBuffer,\n                     vsi_l_offset nOffset,\n                     int nPixels, int nDTSize,\n                     bool bIsByteSwapped, bool bIsComplex,\n                     int nBlockId )\n    {\n        vsi_l_offset nSeekForward = 0;\n        if( nOffset <= VSIFTellL(fp) ||\n            (nSeekForward = nOffset - VSIFTellL(fp)) > nTempBufferSize )\n        {\n            if( VSIFSeekL(fp, nOffset, SEEK_SET) != 0 )\n            {\n                CPLError(CE_Failure, CPLE_FileIO,\n                         \"Cannot seek to block %d\", nBlockId);\n                return false;\n            }\n        }\n        else\n        {\n            while( nSeekForward > 0 )\n            {\n                vsi_l_offset nToRead = nSeekForward;\n                if( nToRead > nTempBufferSize )\n                    nToRead = nTempBufferSize;\n                if( VSIFReadL(pTempBuffer, static_cast<size_t>(nToRead),\n                              1, fp) != 1 )\n                {\n                    CPLError(CE_Failure, CPLE_FileIO,\n                             \"Cannot seek to block %d\", nBlockId);\n                    return false;\n                }\n                nSeekForward -= nToRead;\n            }\n        }\n        if( VSIFReadL(pabyDstBuffer, nPixels * nDTSize, 1, fp) != 1 )\n        {\n            CPLError(CE_Failure, CPLE_FileIO,\n                     \"Missing data for block %d\", nBlockId);\n            return false;\n        }\n\n        if( bIsByteSwapped )\n        {\n            if( bIsComplex )\n                GDALSwapWords( pabyDstBuffer, nDTSize / 2, 2 * nPixels,\n                               nDTSize / 2 );\n            else\n                GDALSwapWords( pabyDstBuffer, nDTSize, nPixels, nDTSize);\n        }\n        return true;\n    }\n\n    static const EMULATED_BOOL bMinimizeIO = true;\n};\n\n/************************************************************************/\n/*                           DirectIO()                                 */\n/************************************************************************/\n\n// Reads directly bytes from the file using ReadMultiRange(), and by-pass\n// block reading. Restricted to simple TIFF configurations\n// (uncompressed data, standard data types). Particularly useful to extract\n// sub-windows of data on a large /vsicurl dataset).\n// Returns -1 if DirectIO() can't be supported on that file.\n\nint GTiffRasterBand::DirectIO( GDALRWFlag eRWFlag,\n                               int nXOff, int nYOff, int nXSize, int nYSize,\n                               void * pData, int nBufXSize, int nBufYSize,\n                               GDALDataType eBufType,\n                               GSpacing nPixelSpace, GSpacing nLineSpace,\n                               GDALRasterIOExtraArg* psExtraArg )\n{\n    const int nDTSizeBits = GDALGetDataTypeSizeBits(eDataType);\n    if( !(eRWFlag == GF_Read &&\n          m_poGDS->m_nCompression == COMPRESSION_NONE &&\n          (m_poGDS->m_nPhotometric == PHOTOMETRIC_MINISBLACK ||\n           m_poGDS->m_nPhotometric == PHOTOMETRIC_RGB ||\n           m_poGDS->m_nPhotometric == PHOTOMETRIC_PALETTE) &&\n          m_poGDS->m_nBitsPerSample == nDTSizeBits) )\n    {\n        return -1;\n    }\n    m_poGDS->Crystalize();\n\n    // Only know how to deal with nearest neighbour in this optimized routine.\n    if( (nXSize != nBufXSize || nYSize != nBufYSize) &&\n        psExtraArg != nullptr &&\n        psExtraArg->eResampleAlg != GRIORA_NearestNeighbour )\n    {\n        return -1;\n    }\n\n#if DEBUG_VERBOSE\n    CPLDebug( \"GTiff\", \"DirectIO(%d,%d,%d,%d -> %dx%d)\",\n              nXOff, nYOff, nXSize, nYSize,\n              nBufXSize, nBufYSize );\n#endif\n\n    // Make sure that TIFFTAG_STRIPOFFSETS is up-to-date.\n    if( m_poGDS->GetAccess() == GA_Update )\n    {\n        m_poGDS->FlushCache();\n        VSI_TIFFFlushBufferedWrite( TIFFClientdata( m_poGDS->m_hTIFF ) );\n    }\n\n    if( TIFFIsTiled( m_poGDS->m_hTIFF ) )\n    {\n        const int nDTSize = nDTSizeBits / 8;\n        const size_t nTempBufferForCommonDirectIOSize =\n                static_cast<size_t>(\n                    static_cast<GPtrDiff_t>(nBlockXSize) * nBlockYSize * nDTSize *\n                    (m_poGDS->m_nPlanarConfig == PLANARCONFIG_CONTIG ?\n                     m_poGDS->nBands : 1) );\n        if( m_poGDS->m_pTempBufferForCommonDirectIO == nullptr )\n        {\n            m_poGDS->m_pTempBufferForCommonDirectIO =\n                static_cast<GByte *>( VSI_MALLOC_VERBOSE(\n                    nTempBufferForCommonDirectIOSize ) );\n            if( m_poGDS->m_pTempBufferForCommonDirectIO == nullptr )\n                return CE_Failure;\n        }\n\n        VSILFILE* fp = VSI_TIFFGetVSILFile(TIFFClientdata( m_poGDS->m_hTIFF ));\n        FetchBufferDirectIO oFetcher(fp, m_poGDS->m_pTempBufferForCommonDirectIO,\n                                     nTempBufferForCommonDirectIOSize);\n\n        return m_poGDS->CommonDirectIO(\n            oFetcher,\n            nXOff, nYOff, nXSize, nYSize,\n            pData, nBufXSize, nBufYSize,\n            eBufType,\n            1, &nBand,\n            nPixelSpace, nLineSpace,\n            0 );\n    }\n\n    // Get strip offsets.\n    toff_t *panTIFFOffsets = nullptr;\n    if( !TIFFGetField( m_poGDS->m_hTIFF, TIFFTAG_STRIPOFFSETS, &panTIFFOffsets ) ||\n        panTIFFOffsets == nullptr )\n    {\n        return CE_Failure;\n    }\n\n    // Sub-sampling or over-sampling can only be done at last stage.\n    int nReqXSize = nXSize;\n    // Can do sub-sampling at the extraction stage.\n    const int nReqYSize = std::min(nBufYSize, nYSize);\n    // TODO(schwehr): Make ppData be GByte**.\n    void** ppData = static_cast<void **>(\n        VSI_MALLOC_VERBOSE(nReqYSize * sizeof(void*)) );\n    vsi_l_offset* panOffsets = static_cast<vsi_l_offset *>(\n        VSI_MALLOC_VERBOSE(nReqYSize * sizeof(vsi_l_offset)) );\n    size_t* panSizes = static_cast<size_t *>(\n        VSI_MALLOC_VERBOSE(nReqYSize * sizeof(size_t)) );\n    const int nDTSize = GDALGetDataTypeSizeBytes(eDataType);\n    void* pTmpBuffer = nullptr;\n    int eErr = CE_None;\n    int nContigBands =\n        m_poGDS->m_nPlanarConfig == PLANARCONFIG_CONTIG ? m_poGDS->nBands : 1;\n    int nSrcPixelSize = nDTSize * nContigBands;\n\n    if( ppData == nullptr || panOffsets == nullptr || panSizes == nullptr )\n        eErr = CE_Failure;\n    else if( nXSize != nBufXSize || nYSize != nBufYSize ||\n             eBufType != eDataType ||\n             nPixelSpace != GDALGetDataTypeSizeBytes(eBufType) ||\n             nContigBands > 1 )\n    {\n        // We need a temporary buffer for over-sampling/sub-sampling\n        // and/or data type conversion.\n        pTmpBuffer = VSI_MALLOC_VERBOSE(nReqXSize * nReqYSize * nSrcPixelSize);\n        if( pTmpBuffer == nullptr )\n            eErr = CE_Failure;\n    }\n\n    // Prepare data extraction.\n    const double dfSrcYInc = nYSize / static_cast<double>( nBufYSize );\n\n    for( int iLine = 0; eErr == CE_None && iLine < nReqYSize; ++iLine )\n    {\n        if( pTmpBuffer == nullptr )\n            ppData[iLine] = static_cast<GByte *>(pData) + iLine * nLineSpace;\n        else\n            ppData[iLine] =\n                static_cast<GByte *>(pTmpBuffer) +\n                iLine * nReqXSize * nSrcPixelSize;\n        int nSrcLine = 0;\n        if( nBufYSize < nYSize )  // Sub-sampling in y.\n            nSrcLine = nYOff + static_cast<int>((iLine + 0.5) * dfSrcYInc);\n        else\n            nSrcLine = nYOff + iLine;\n\n        const int nBlockXOff = 0;\n        const int nBlockYOff = nSrcLine / nBlockYSize;\n        const int nYOffsetInBlock = nSrcLine % nBlockYSize;\n        nBlocksPerRow = DIV_ROUND_UP(nRasterXSize, nBlockXSize);\n        int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n        if( m_poGDS->m_nPlanarConfig == PLANARCONFIG_SEPARATE )\n        {\n            nBlockId += (nBand-1) * m_poGDS->m_nBlocksPerBand;\n        }\n\n        panOffsets[iLine] = panTIFFOffsets[nBlockId];\n        if( panOffsets[iLine] == 0 )  // We don't support sparse files.\n            eErr = -1;\n\n        panOffsets[iLine] +=\n            (nXOff + nYOffsetInBlock * nBlockXSize) * nSrcPixelSize;\n        panSizes[iLine] = nReqXSize * nSrcPixelSize;\n    }\n\n    // Extract data from the file.\n    if( eErr == CE_None )\n    {\n        VSILFILE* fp = VSI_TIFFGetVSILFile(TIFFClientdata( m_poGDS->m_hTIFF ));\n        const int nRet =\n            VSIFReadMultiRangeL( nReqYSize, ppData, panOffsets, panSizes, fp );\n        if( nRet != 0 )\n            eErr = CE_Failure;\n    }\n\n    // Byte-swap if necessary.\n    if( eErr == CE_None && TIFFIsByteSwapped(m_poGDS->m_hTIFF) )\n    {\n        for( int iLine = 0; iLine < nReqYSize; ++iLine )\n        {\n            if( GDALDataTypeIsComplex(eDataType) )\n                GDALSwapWords( ppData[iLine], nDTSize / 2,\n                               2 * nReqXSize * nContigBands, nDTSize / 2 );\n            else\n                GDALSwapWords( ppData[iLine], nDTSize,\n                               nReqXSize * nContigBands, nDTSize );\n        }\n    }\n\n    // Over-sampling/sub-sampling and/or data type conversion.\n    const double dfSrcXInc = nXSize / static_cast<double>( nBufXSize );\n    if( eErr == CE_None && pTmpBuffer != nullptr )\n    {\n        for( int iY=0; iY < nBufYSize; ++iY )\n        {\n            const int iSrcY =\n                nBufYSize <= nYSize ?\n                iY : static_cast<int>((iY + 0.5) * dfSrcYInc);\n\n            GByte* pabySrcData =\n                static_cast<GByte*>(ppData[iSrcY]) +\n                (nContigBands > 1 ? (nBand-1) : 0) * nDTSize;\n            GByte* pabyDstData =\n                static_cast<GByte *>(pData) + iY * nLineSpace;\n            if( nBufXSize == nXSize )\n            {\n                GDALCopyWords( pabySrcData,\n                               eDataType,\n                               nSrcPixelSize,\n                               pabyDstData,\n                               eBufType,\n                               static_cast<int>(nPixelSpace),\n                               nBufXSize );\n            }\n            else\n            {\n                if( eDataType == GDT_Byte && eBufType == GDT_Byte )\n                {\n                    double dfSrcX = 0.5 * dfSrcXInc;\n                    for( int iX = 0; iX < nBufXSize; ++iX, dfSrcX += dfSrcXInc )\n                    {\n                        const int iSrcX = static_cast<int>(dfSrcX);\n                        pabyDstData[iX * nPixelSpace] =\n                            pabySrcData[iSrcX * nSrcPixelSize];\n                    }\n                }\n                else\n                {\n                    double dfSrcX = 0.5 * dfSrcXInc;\n                    for( int iX = 0; iX < nBufXSize; ++iX, dfSrcX += dfSrcXInc )\n                    {\n                        const int iSrcX = static_cast<int>(dfSrcX);\n                        GDALCopyWords( pabySrcData + iSrcX * nSrcPixelSize,\n                                       eDataType, 0,\n                                       pabyDstData + iX * nPixelSpace,\n                                       eBufType, 0, 1 );\n                    }\n                }\n            }\n        }\n    }\n\n    // Cleanup.\n    CPLFree(pTmpBuffer);\n    CPLFree(ppData);\n    CPLFree(panOffsets);\n    CPLFree(panSizes);\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                           GetVirtualMemAuto()                        */\n/************************************************************************/\n\nCPLVirtualMem* GTiffRasterBand::GetVirtualMemAuto( GDALRWFlag eRWFlag,\n                                                   int *pnPixelSpace,\n                                                   GIntBig *pnLineSpace,\n                                                   char **papszOptions )\n{\n    const char* pszImpl = CSLFetchNameValueDef(\n            papszOptions, \"USE_DEFAULT_IMPLEMENTATION\", \"AUTO\");\n    if( EQUAL(pszImpl, \"YES\") || EQUAL(pszImpl, \"ON\") ||\n        EQUAL(pszImpl, \"1\") || EQUAL(pszImpl, \"TRUE\") )\n    {\n        return GDALRasterBand::GetVirtualMemAuto( eRWFlag, pnPixelSpace,\n                                                  pnLineSpace, papszOptions );\n    }\n\n    CPLVirtualMem *psRet =\n        GetVirtualMemAutoInternal( eRWFlag, pnPixelSpace, pnLineSpace,\n                                   papszOptions );\n    if( psRet != nullptr )\n    {\n        CPLDebug(\"GTiff\", \"GetVirtualMemAuto(): Using memory file mapping\");\n        return psRet;\n    }\n\n    if( EQUAL(pszImpl, \"NO\") || EQUAL(pszImpl, \"OFF\") ||\n        EQUAL(pszImpl, \"0\") || EQUAL(pszImpl, \"FALSE\") )\n    {\n        return nullptr;\n    }\n\n    CPLDebug(\"GTiff\", \"GetVirtualMemAuto(): Defaulting to base implementation\");\n    return GDALRasterBand::GetVirtualMemAuto( eRWFlag, pnPixelSpace,\n                                              pnLineSpace, papszOptions );\n}\n\n\n/************************************************************************/\n/*                           GetDefaultRAT()                            */\n/************************************************************************/\n\nGDALRasterAttributeTable *GTiffRasterBand::GetDefaultRAT()\n\n{\n    m_poGDS->LoadGeoreferencingAndPamIfNeeded();\n    return GDALPamRasterBand::GetDefaultRAT();\n}\n\n/************************************************************************/\n/*                           GetHistogram()                             */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::GetHistogram(\n    double dfMin, double dfMax,\n    int nBuckets, GUIntBig * panHistogram,\n    int bIncludeOutOfRange, int bApproxOK,\n    GDALProgressFunc pfnProgress, void *pProgressData )\n{\n    m_poGDS->LoadGeoreferencingAndPamIfNeeded();\n    return GDALPamRasterBand::GetHistogram( dfMin, dfMax,\n                                            nBuckets, panHistogram,\n                                            bIncludeOutOfRange, bApproxOK,\n                                            pfnProgress, pProgressData );\n}\n\n/************************************************************************/\n/*                       GetDefaultHistogram()                          */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::GetDefaultHistogram( double *pdfMin, double *pdfMax,\n                                             int *pnBuckets,\n                                             GUIntBig ** ppanHistogram,\n                                             int bForce,\n                                             GDALProgressFunc pfnProgress,\n                                             void *pProgressData )\n{\n    m_poGDS->LoadGeoreferencingAndPamIfNeeded();\n    return GDALPamRasterBand::GetDefaultHistogram( pdfMin, pdfMax,\n                                                   pnBuckets, ppanHistogram,\n                                                   bForce,\n                                                   pfnProgress, pProgressData );\n}\n\n/************************************************************************/\n/*                     DropReferenceVirtualMem()                        */\n/************************************************************************/\n\nvoid GTiffRasterBand::DropReferenceVirtualMem( void* pUserData )\n{\n    // This function may also be called when the dataset and rasterband\n    // objects have been destroyed.\n    // If they are still alive, it updates the reference counter of the\n    // base mapping to invalidate the pointer to it if needed.\n\n    GTiffRasterBand** ppoSelf = static_cast<GTiffRasterBand **>( pUserData );\n    GTiffRasterBand* poSelf = *ppoSelf;\n\n    if( poSelf != nullptr )\n    {\n        if( --(poSelf->m_poGDS->m_nRefBaseMapping) == 0 )\n        {\n            poSelf->m_poGDS->m_pBaseMapping = nullptr;\n        }\n        poSelf->m_aSetPSelf.erase(ppoSelf);\n    }\n    CPLFree(pUserData);\n}\n\n/************************************************************************/\n/*                     GetVirtualMemAutoInternal()                      */\n/************************************************************************/\n\nCPLVirtualMem* GTiffRasterBand::GetVirtualMemAutoInternal( GDALRWFlag eRWFlag,\n                                                           int *pnPixelSpace,\n                                                           GIntBig *pnLineSpace,\n                                                           char **papszOptions )\n{\n    int nLineSize = nBlockXSize * GDALGetDataTypeSizeBytes(eDataType);\n    if( m_poGDS->m_nPlanarConfig == PLANARCONFIG_CONTIG )\n        nLineSize *= m_poGDS->nBands;\n\n    if( m_poGDS->m_nPlanarConfig == PLANARCONFIG_CONTIG )\n    {\n        // In case of a pixel interleaved file, we save virtual memory space\n        // by reusing a base mapping that embraces the whole imagery.\n        if( m_poGDS->m_pBaseMapping != nullptr )\n        {\n            // Offset between the base mapping and the requested mapping.\n            vsi_l_offset nOffset =\n                static_cast<vsi_l_offset>(nBand - 1) *\n                GDALGetDataTypeSizeBytes(eDataType);\n\n            GTiffRasterBand** ppoSelf =\n                static_cast<GTiffRasterBand** >(\n                    CPLCalloc(1, sizeof(GTiffRasterBand*)) );\n            *ppoSelf = this;\n\n            CPLVirtualMem* pVMem = CPLVirtualMemDerivedNew(\n                m_poGDS->m_pBaseMapping,\n                nOffset,\n                CPLVirtualMemGetSize(m_poGDS->m_pBaseMapping) - nOffset,\n                GTiffRasterBand::DropReferenceVirtualMem,\n                ppoSelf);\n            if( pVMem == nullptr )\n            {\n                CPLFree(ppoSelf);\n                return nullptr;\n            }\n\n            // Mechanism used so that the memory mapping object can be\n            // destroyed after the raster band.\n            m_aSetPSelf.insert(ppoSelf);\n            ++m_poGDS->m_nRefBaseMapping;\n            *pnPixelSpace = GDALGetDataTypeSizeBytes(eDataType);\n            if( m_poGDS->m_nPlanarConfig == PLANARCONFIG_CONTIG )\n                *pnPixelSpace *= m_poGDS->nBands;\n            *pnLineSpace = nLineSize;\n            return pVMem;\n        }\n    }\n\n    VSILFILE* fp = VSI_TIFFGetVSILFile(TIFFClientdata( m_poGDS->m_hTIFF ));\n\n    vsi_l_offset nLength = static_cast<vsi_l_offset>(nRasterYSize) * nLineSize;\n\n    if( !(CPLIsVirtualMemFileMapAvailable() &&\n          VSIFGetNativeFileDescriptorL(fp) != nullptr &&\n#if SIZEOF_VOIDP == 4\n          nLength == static_cast<size_t>(nLength) &&\n#endif\n          m_poGDS->m_nCompression == COMPRESSION_NONE &&\n          (m_poGDS->m_nPhotometric == PHOTOMETRIC_MINISBLACK ||\n           m_poGDS->m_nPhotometric == PHOTOMETRIC_RGB ||\n           m_poGDS->m_nPhotometric == PHOTOMETRIC_PALETTE) &&\n          m_poGDS->m_nBitsPerSample == GDALGetDataTypeSizeBits(eDataType) &&\n          !TIFFIsTiled( m_poGDS->m_hTIFF ) && !TIFFIsByteSwapped(m_poGDS->m_hTIFF)) )\n    {\n        return nullptr;\n    }\n\n    // Make sure that TIFFTAG_STRIPOFFSETS is up-to-date.\n    if( m_poGDS->GetAccess() == GA_Update )\n    {\n        m_poGDS->FlushCache();\n        VSI_TIFFFlushBufferedWrite( TIFFClientdata( m_poGDS->m_hTIFF ) );\n    }\n\n    // Get strip offsets.\n    toff_t *panTIFFOffsets = nullptr;\n    if( !TIFFGetField( m_poGDS->m_hTIFF, TIFFTAG_STRIPOFFSETS, &panTIFFOffsets ) ||\n        panTIFFOffsets == nullptr )\n    {\n        return nullptr;\n    }\n\n    GPtrDiff_t nBlockSize =\n        static_cast<GPtrDiff_t>(nBlockXSize) * nBlockYSize * GDALGetDataTypeSizeBytes(eDataType);\n    if( m_poGDS->m_nPlanarConfig == PLANARCONFIG_CONTIG )\n        nBlockSize *= m_poGDS->nBands;\n\n    int nBlocks = m_poGDS->m_nBlocksPerBand;\n    if( m_poGDS->m_nPlanarConfig == PLANARCONFIG_SEPARATE )\n        nBlocks *= m_poGDS->nBands;\n    int i = 0;  // Used after for.\n    for( ; i < nBlocks; ++i )\n    {\n        if( panTIFFOffsets[i] != 0 )\n            break;\n    }\n    if( i == nBlocks )\n    {\n        // All zeroes.\n        if( m_poGDS->eAccess == GA_Update )\n        {\n            // Initialize the file with empty blocks so that the file has\n            // the appropriate size.\n\n            toff_t* panByteCounts = nullptr;\n            if( !TIFFGetField( m_poGDS->m_hTIFF, TIFFTAG_STRIPBYTECOUNTS,\n                               &panByteCounts ) ||\n                panByteCounts == nullptr )\n            {\n                return nullptr;\n            }\n            if( VSIFSeekL(fp, 0, SEEK_END) != 0 )\n                return nullptr;\n            vsi_l_offset nBaseOffset = VSIFTellL(fp);\n\n            // Just write one tile with libtiff to put it in appropriate state.\n            GByte* pabyData =\n                static_cast<GByte*>(VSI_CALLOC_VERBOSE(1, nBlockSize));\n            if( pabyData == nullptr )\n            {\n                return nullptr;\n            }\n            const auto ret =\n                    TIFFWriteEncodedStrip( m_poGDS->m_hTIFF, 0, pabyData,\n                                           nBlockSize );\n            VSI_TIFFFlushBufferedWrite( TIFFClientdata( m_poGDS->m_hTIFF ) );\n            VSIFree(pabyData);\n            if( ret != nBlockSize )\n            {\n                return nullptr;\n            }\n            CPLAssert(panTIFFOffsets[0] == nBaseOffset);\n            CPLAssert(panByteCounts[0] == static_cast<toff_t>(nBlockSize));\n\n            // Now simulate the writing of other blocks.\n            const vsi_l_offset nDataSize =\n                static_cast<vsi_l_offset>(nBlockSize) * nBlocks;\n            if( VSIFTruncateL(fp, nBaseOffset + nDataSize) != 0 )\n                return nullptr;\n\n            for( i = 1; i < nBlocks; ++i)\n            {\n                panTIFFOffsets[i] =\n                    nBaseOffset + i * static_cast<toff_t>(nBlockSize);\n                panByteCounts[i] = nBlockSize;\n            }\n        }\n        else\n        {\n            CPLDebug( \"GTiff\", \"Sparse files not supported in file mapping\" );\n            return nullptr;\n        }\n    }\n\n    GIntBig nBlockSpacing = 0;\n    bool bCompatibleSpacing = true;\n    toff_t nPrevOffset = 0;\n    for( i = 0; i < m_poGDS->m_nBlocksPerBand; ++i )\n    {\n        toff_t nCurOffset = 0;\n        if( m_poGDS->m_nPlanarConfig == PLANARCONFIG_SEPARATE )\n            nCurOffset =\n                panTIFFOffsets[m_poGDS->m_nBlocksPerBand * (nBand - 1) + i];\n        else\n            nCurOffset = panTIFFOffsets[i];\n        if( nCurOffset == 0 )\n        {\n            bCompatibleSpacing = false;\n            break;\n        }\n        if( i > 0 )\n        {\n            const GIntBig nCurSpacing = nCurOffset - nPrevOffset;\n            if( i == 1 )\n            {\n                if( nCurSpacing !=\n                    static_cast<GIntBig>(nBlockYSize) * nLineSize )\n                {\n                    bCompatibleSpacing = false;\n                    break;\n                }\n                nBlockSpacing = nCurSpacing;\n            }\n            else if( nBlockSpacing != nCurSpacing )\n            {\n                bCompatibleSpacing = false;\n                break;\n            }\n        }\n        nPrevOffset = nCurOffset;\n    }\n\n    if( !bCompatibleSpacing )\n    {\n        return nullptr;\n    }\n\n    vsi_l_offset nOffset = 0;\n    if( m_poGDS->m_nPlanarConfig == PLANARCONFIG_CONTIG )\n    {\n        CPLAssert( m_poGDS->m_pBaseMapping == nullptr );\n        nOffset = panTIFFOffsets[0];\n    }\n    else\n    {\n        nOffset = panTIFFOffsets[m_poGDS->m_nBlocksPerBand * (nBand - 1)];\n    }\n    CPLVirtualMem* pVMem = CPLVirtualMemFileMapNew(\n        fp, nOffset, nLength,\n        eRWFlag == GF_Write ? VIRTUALMEM_READWRITE : VIRTUALMEM_READONLY,\n        nullptr, nullptr);\n    if( pVMem == nullptr )\n    {\n        return nullptr;\n    }\n\n    if( m_poGDS->m_nPlanarConfig == PLANARCONFIG_CONTIG )\n    {\n        // TODO(schwehr): Revisit this block.\n        m_poGDS->m_pBaseMapping = pVMem;\n        pVMem = GetVirtualMemAutoInternal( eRWFlag,\n                                           pnPixelSpace,\n                                           pnLineSpace,\n                                           papszOptions );\n        // Drop ref on base mapping.\n        CPLVirtualMemFree(m_poGDS->m_pBaseMapping);\n        if( pVMem == nullptr )\n            m_poGDS->m_pBaseMapping = nullptr;\n    }\n    else\n    {\n        *pnPixelSpace = GDALGetDataTypeSizeBytes(eDataType);\n        if( m_poGDS->m_nPlanarConfig == PLANARCONFIG_CONTIG )\n            *pnPixelSpace *= m_poGDS->nBands;\n        *pnLineSpace = nLineSize;\n    }\n    return pVMem;\n}\n\n/************************************************************************/\n/*                     HasOptimizedReadMultiRange()                     */\n/************************************************************************/\n\nbool GTiffDataset::HasOptimizedReadMultiRange()\n{\n    if( m_nHasOptimizedReadMultiRange >= 0 )\n        return m_nHasOptimizedReadMultiRange != 0;\n    m_nHasOptimizedReadMultiRange = static_cast<signed char>(\n        VSIHasOptimizedReadMultiRange(m_pszFilename)\n        // Config option for debug and testing purposes only\n        || CPLTestBool(CPLGetConfigOption(\"GTIFF_HAS_OPTIMIZED_READ_MULTI_RANGE\", \"NO\"))\n    );\n    return m_nHasOptimizedReadMultiRange != 0;\n}\n\n/************************************************************************/\n/*                            IRasterIO()                               */\n/************************************************************************/\n\nCPLErr GTiffDataset::IRasterIO( GDALRWFlag eRWFlag,\n                                int nXOff, int nYOff, int nXSize, int nYSize,\n                                void * pData, int nBufXSize, int nBufYSize,\n                                GDALDataType eBufType,\n                                int nBandCount, int *panBandMap,\n                                GSpacing nPixelSpace, GSpacing nLineSpace,\n                                GSpacing nBandSpace,\n                                GDALRasterIOExtraArg* psExtraArg )\n\n{\n    // Try to pass the request to the most appropriate overview dataset.\n    if( nBufXSize < nXSize && nBufYSize < nYSize )\n    {\n        int bTried = FALSE;\n        ++m_nJPEGOverviewVisibilityCounter;\n        const CPLErr eErr =\n            TryOverviewRasterIO( eRWFlag,\n                                 nXOff, nYOff, nXSize, nYSize,\n                                 pData, nBufXSize, nBufYSize,\n                                 eBufType,\n                                 nBandCount, panBandMap,\n                                 nPixelSpace, nLineSpace,\n                                 nBandSpace,\n                                 psExtraArg,\n                                 &bTried );\n        --m_nJPEGOverviewVisibilityCounter;\n        if( bTried )\n            return eErr;\n    }\n\n    if( m_eVirtualMemIOUsage != VirtualMemIOEnum::NO )\n    {\n        const int nErr = VirtualMemIO(\n            eRWFlag, nXOff, nYOff, nXSize, nYSize,\n            pData, nBufXSize, nBufYSize, eBufType,\n            nBandCount, panBandMap, nPixelSpace, nLineSpace,\n            nBandSpace, psExtraArg );\n        if( nErr >= 0 )\n            return static_cast<CPLErr>(nErr);\n    }\n    if( m_bDirectIO )\n    {\n        const int nErr = DirectIO(\n            eRWFlag, nXOff, nYOff, nXSize, nYSize,\n            pData, nBufXSize, nBufYSize, eBufType,\n            nBandCount, panBandMap, nPixelSpace, nLineSpace,\n            nBandSpace, psExtraArg );\n        if( nErr >= 0 )\n            return static_cast<CPLErr>(nErr);\n    }\n\n    void* pBufferedData = nullptr;\n    if( eAccess == GA_ReadOnly &&\n        eRWFlag == GF_Read &&\n        m_nPlanarConfig == PLANARCONFIG_CONTIG &&\n        HasOptimizedReadMultiRange() )\n    {\n        pBufferedData = cpl::down_cast<GTiffRasterBand *>(\n            GetRasterBand(1))->CacheMultiRange(nXOff, nYOff,\n                                               nXSize, nYSize,\n                                               nBufXSize, nBufYSize,\n                                               psExtraArg);\n    }\n\n    ++m_nJPEGOverviewVisibilityCounter;\n    const CPLErr eErr =\n        GDALPamDataset::IRasterIO(\n            eRWFlag, nXOff, nYOff, nXSize, nYSize,\n            pData, nBufXSize, nBufYSize, eBufType,\n            nBandCount, panBandMap, nPixelSpace, nLineSpace,\n            nBandSpace, psExtraArg);\n    m_nJPEGOverviewVisibilityCounter--;\n\n    if( pBufferedData )\n    {\n        VSIFree( pBufferedData );\n        VSI_TIFFSetCachedRanges( TIFFClientdata( m_hTIFF ),\n                                 0, nullptr, nullptr, nullptr );\n    }\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                        FetchBufferVirtualMemIO                       */\n/************************************************************************/\n\nclass FetchBufferVirtualMemIO final\n{\n    const GByte* pabySrcData;\n    size_t       nMappingSize;\n    GByte       *pTempBuffer;\n\npublic:\n            FetchBufferVirtualMemIO( const GByte* pabySrcDataIn,\n                                     size_t nMappingSizeIn,\n                                     GByte* pTempBufferIn ) :\n                pabySrcData(pabySrcDataIn),\n                nMappingSize(nMappingSizeIn),\n                pTempBuffer(pTempBufferIn) {}\n\n    const GByte* FetchBytes( vsi_l_offset nOffset,\n                             int nPixels, int nDTSize,\n                             bool bIsByteSwapped, bool bIsComplex,\n                             int nBlockId )\n    {\n        if( nOffset + nPixels * nDTSize > nMappingSize )\n        {\n            CPLError(CE_Failure, CPLE_FileIO,\n                     \"Missing data for block %d\", nBlockId);\n            return nullptr;\n        }\n        if( !bIsByteSwapped )\n            return pabySrcData + nOffset;\n        memcpy(pTempBuffer, pabySrcData + nOffset, nPixels * nDTSize);\n        if( bIsComplex )\n            GDALSwapWords( pTempBuffer, nDTSize / 2, 2 * nPixels, nDTSize / 2);\n        else\n            GDALSwapWords( pTempBuffer, nDTSize, nPixels, nDTSize);\n        return pTempBuffer;\n    }\n\n    bool FetchBytes( GByte* pabyDstBuffer,\n                     vsi_l_offset nOffset,\n                     int nPixels, int nDTSize,\n                     bool bIsByteSwapped, bool bIsComplex,\n                     int nBlockId )\n    {\n        if( nOffset + nPixels * nDTSize > nMappingSize )\n        {\n            CPLError(CE_Failure, CPLE_FileIO,\n                     \"Missing data for block %d\", nBlockId);\n            return false;\n        }\n        memcpy(pabyDstBuffer, pabySrcData + nOffset, nPixels * nDTSize);\n        if( bIsByteSwapped )\n        {\n            if( bIsComplex )\n                GDALSwapWords( pabyDstBuffer, nDTSize / 2, 2 * nPixels,\n                               nDTSize / 2);\n            else\n                GDALSwapWords( pabyDstBuffer, nDTSize, nPixels, nDTSize);\n        }\n        return true;\n    }\n\n    static const EMULATED_BOOL bMinimizeIO = false;\n};\n\n/************************************************************************/\n/*                         VirtualMemIO()                               */\n/************************************************************************/\n\nint GTiffDataset::VirtualMemIO( GDALRWFlag eRWFlag,\n                                int nXOff, int nYOff, int nXSize, int nYSize,\n                                void * pData, int nBufXSize, int nBufYSize,\n                                GDALDataType eBufType,\n                                int nBandCount, int *panBandMap,\n                                GSpacing nPixelSpace, GSpacing nLineSpace,\n                                GSpacing nBandSpace,\n                                GDALRasterIOExtraArg* psExtraArg )\n{\n    if( eAccess == GA_Update || eRWFlag == GF_Write || m_bStreamingIn )\n        return -1;\n\n    // Only know how to deal with nearest neighbour in this optimized routine.\n    if( (nXSize != nBufXSize || nYSize != nBufYSize) &&\n        psExtraArg != nullptr &&\n        psExtraArg->eResampleAlg != GRIORA_NearestNeighbour )\n    {\n        return -1;\n    }\n\n    const GDALDataType eDataType = GetRasterBand(1)->GetRasterDataType();\n    const int nDTSizeBits = GDALGetDataTypeSizeBits(eDataType);\n    if( !(m_nCompression == COMPRESSION_NONE &&\n        (m_nPhotometric == PHOTOMETRIC_MINISBLACK ||\n        m_nPhotometric == PHOTOMETRIC_RGB ||\n        m_nPhotometric == PHOTOMETRIC_PALETTE) &&\n        m_nBitsPerSample == nDTSizeBits) )\n    {\n        m_eVirtualMemIOUsage = VirtualMemIOEnum::NO;\n        return -1;\n    }\n\n    size_t nMappingSize = 0;\n    GByte* pabySrcData = nullptr;\n    if( STARTS_WITH(m_pszFilename, \"/vsimem/\") )\n    {\n        vsi_l_offset nDataLength = 0;\n        pabySrcData =\n            VSIGetMemFileBuffer(m_pszFilename, &nDataLength, FALSE);\n        nMappingSize = static_cast<size_t>(nDataLength);\n        if( pabySrcData == nullptr )\n            return -1;\n    }\n    else if( m_psVirtualMemIOMapping == nullptr )\n    {\n        VSILFILE* fp = VSI_TIFFGetVSILFile(TIFFClientdata( m_hTIFF ));\n        if( !CPLIsVirtualMemFileMapAvailable() ||\n            VSIFGetNativeFileDescriptorL(fp) == nullptr )\n        {\n            m_eVirtualMemIOUsage = VirtualMemIOEnum::NO;\n            return -1;\n        }\n        if( VSIFSeekL(fp, 0, SEEK_END) != 0 )\n        {\n            m_eVirtualMemIOUsage = VirtualMemIOEnum::NO;\n            return -1;\n        }\n        const vsi_l_offset nLength = VSIFTellL(fp);\n        if( static_cast<size_t>(nLength) != nLength )\n        {\n            m_eVirtualMemIOUsage = VirtualMemIOEnum::NO;\n            return -1;\n        }\n        if( m_eVirtualMemIOUsage == VirtualMemIOEnum::IF_ENOUGH_RAM )\n        {\n            GIntBig nRAM = CPLGetUsablePhysicalRAM();\n            if( static_cast<GIntBig>(nLength) > nRAM )\n            {\n                CPLDebug( \"GTiff\",\n                          \"Not enough RAM to map whole file into memory.\" );\n                m_eVirtualMemIOUsage = VirtualMemIOEnum::NO;\n                return -1;\n            }\n        }\n        m_psVirtualMemIOMapping = CPLVirtualMemFileMapNew(\n            fp, 0, nLength, VIRTUALMEM_READONLY, nullptr, nullptr);\n        if( m_psVirtualMemIOMapping == nullptr )\n        {\n            m_eVirtualMemIOUsage = VirtualMemIOEnum::NO;\n            return -1;\n        }\n        m_eVirtualMemIOUsage = VirtualMemIOEnum::YES;\n    }\n\n    if( m_psVirtualMemIOMapping )\n    {\n#ifdef DEBUG\n        CPLDebug(\"GTiff\", \"Using VirtualMemIO\");\n#endif\n        nMappingSize = CPLVirtualMemGetSize(m_psVirtualMemIOMapping);\n        pabySrcData = static_cast<GByte *>(\n            CPLVirtualMemGetAddr(m_psVirtualMemIOMapping) );\n    }\n\n    if( TIFFIsByteSwapped(m_hTIFF) && m_pTempBufferForCommonDirectIO == nullptr )\n    {\n        const int nDTSize = nDTSizeBits / 8;\n        size_t nTempBufferForCommonDirectIOSize =\n            static_cast<size_t>(m_nBlockXSize * nDTSize *\n                (m_nPlanarConfig == PLANARCONFIG_CONTIG ? nBands : 1));\n        if( TIFFIsTiled(m_hTIFF) )\n            nTempBufferForCommonDirectIOSize *= m_nBlockYSize;\n\n        m_pTempBufferForCommonDirectIO =\n            static_cast<GByte *>(\n                VSI_MALLOC_VERBOSE(nTempBufferForCommonDirectIOSize) );\n        if( m_pTempBufferForCommonDirectIO == nullptr )\n            return CE_Failure;\n    }\n    FetchBufferVirtualMemIO oFetcher( pabySrcData, nMappingSize,\n                                      m_pTempBufferForCommonDirectIO );\n\n    return CommonDirectIO( oFetcher,\n                           nXOff, nYOff, nXSize, nYSize,\n                           pData, nBufXSize, nBufYSize,\n                           eBufType,\n                           nBandCount, panBandMap,\n                           nPixelSpace, nLineSpace,\n                           nBandSpace );\n}\n\n/************************************************************************/\n/*                   CopyContigByteMultiBand()                          */\n/************************************************************************/\n\nstatic inline void CopyContigByteMultiBand(\n    const GByte* CPL_RESTRICT pabySrc, int nSrcStride,\n    GByte* CPL_RESTRICT pabyDest, int nDestStride,\n    int nIters, int nBandCount )\n{\n    if( nBandCount == 3 )\n    {\n        if( nSrcStride == 3 && nDestStride == 4 )\n        {\n            while( nIters >= 8 )\n            {\n                pabyDest[4*0+0] = pabySrc[3*0+0];\n                pabyDest[4*0+1] = pabySrc[3*0+1];\n                pabyDest[4*0+2] = pabySrc[3*0+2];\n                pabyDest[4*1+0] = pabySrc[3*1+0];\n                pabyDest[4*1+1] = pabySrc[3*1+1];\n                pabyDest[4*1+2] = pabySrc[3*1+2];\n                pabyDest[4*2+0] = pabySrc[3*2+0];\n                pabyDest[4*2+1] = pabySrc[3*2+1];\n                pabyDest[4*2+2] = pabySrc[3*2+2];\n                pabyDest[4*3+0] = pabySrc[3*3+0];\n                pabyDest[4*3+1] = pabySrc[3*3+1];\n                pabyDest[4*3+2] = pabySrc[3*3+2];\n                pabyDest[4*4+0] = pabySrc[3*4+0];\n                pabyDest[4*4+1] = pabySrc[3*4+1];\n                pabyDest[4*4+2] = pabySrc[3*4+2];\n                pabyDest[4*5+0] = pabySrc[3*5+0];\n                pabyDest[4*5+1] = pabySrc[3*5+1];\n                pabyDest[4*5+2] = pabySrc[3*5+2];\n                pabyDest[4*6+0] = pabySrc[3*6+0];\n                pabyDest[4*6+1] = pabySrc[3*6+1];\n                pabyDest[4*6+2] = pabySrc[3*6+2];\n                pabyDest[4*7+0] = pabySrc[3*7+0];\n                pabyDest[4*7+1] = pabySrc[3*7+1];\n                pabyDest[4*7+2] = pabySrc[3*7+2];\n                pabySrc += 3 * 8;\n                pabyDest += 4 * 8;\n                nIters -= 8;\n            }\n            while( nIters-- > 0 )\n            {\n                pabyDest[0] = pabySrc[0];\n                pabyDest[1] = pabySrc[1];\n                pabyDest[2] = pabySrc[2];\n                pabySrc += 3;\n                pabyDest += 4;\n            }\n        }\n        else\n        {\n            while( nIters-- > 0 )\n            {\n                pabyDest[0] = pabySrc[0];\n                pabyDest[1] = pabySrc[1];\n                pabyDest[2] = pabySrc[2];\n                pabySrc += nSrcStride;\n                pabyDest += nDestStride;\n            }\n        }\n    }\n    else\n    {\n        while( nIters-- > 0 )\n        {\n            for( int iBand = 0; iBand < nBandCount; ++iBand )\n                pabyDest[iBand] = pabySrc[iBand];\n            pabySrc += nSrcStride;\n            pabyDest += nDestStride;\n        }\n    }\n}\n\n/************************************************************************/\n/*                         CommonDirectIO()                             */\n/************************************************************************/\n\n// #define DEBUG_REACHED_VIRTUAL_MEM_IO\n#ifdef DEBUG_REACHED_VIRTUAL_MEM_IO\nstatic int anReachedVirtualMemIO[52] = { 0 };\n#define REACHED(x) anReachedVirtualMemIO[x] = 1\n#else\n#define REACHED(x)\n#endif\n\ntemplate<class FetchBuffer> CPLErr GTiffDataset::CommonDirectIO(\n    FetchBuffer& oFetcher,\n    int nXOff, int nYOff, int nXSize, int nYSize,\n    void * pData, int nBufXSize, int nBufYSize,\n    GDALDataType eBufType,\n    int nBandCount, int *panBandMap,\n    GSpacing nPixelSpace, GSpacing nLineSpace,\n    GSpacing nBandSpace )\n{\n    const GDALDataType eDataType = GetRasterBand(1)->GetRasterDataType();\n    const int nDTSize = GDALGetDataTypeSizeBytes(eDataType);\n    const bool bIsComplex = CPL_TO_BOOL(GDALDataTypeIsComplex(eDataType));\n    const int nBufDTSize = GDALGetDataTypeSizeBytes(eBufType);\n\n    // Get strip offsets.\n    toff_t *panOffsets = nullptr;\n    if( !TIFFGetField( m_hTIFF, (TIFFIsTiled( m_hTIFF )) ?\n                       TIFFTAG_TILEOFFSETS : TIFFTAG_STRIPOFFSETS,\n                       &panOffsets ) ||\n        panOffsets == nullptr )\n    {\n        return CE_Failure;\n    }\n\n    bool bUseContigImplementation =\n        m_nPlanarConfig == PLANARCONFIG_CONTIG &&\n        nBandCount > 1 &&\n        nBandSpace == nBufDTSize;\n    if( bUseContigImplementation )\n    {\n        for( int iBand = 0; iBand < nBandCount; ++iBand )\n        {\n            const int nBand = panBandMap[iBand];\n            if( nBand != iBand + 1 )\n            {\n                bUseContigImplementation = false;\n                break;\n            }\n        }\n    }\n\n    const int nBandsPerBlock =\n        m_nPlanarConfig == PLANARCONFIG_SEPARATE ? 1 : nBands;\n    const int nBandsPerBlockDTSize = nBandsPerBlock * nDTSize;\n    const int nBlocksPerRow = DIV_ROUND_UP(nRasterXSize, m_nBlockXSize);\n    const bool bNoTypeChange = (eDataType == eBufType);\n    const bool bNoXResampling = (nXSize == nBufXSize );\n    const bool bNoXResamplingNoTypeChange = (bNoTypeChange && bNoXResampling);\n    const bool bByteOnly = (bNoTypeChange && nDTSize == 1 );\n    const bool bByteNoXResampling = ( bByteOnly && bNoXResamplingNoTypeChange );\n    const bool bIsByteSwapped = CPL_TO_BOOL(TIFFIsByteSwapped(m_hTIFF));\n    const double dfSrcXInc = nXSize / static_cast<double>( nBufXSize );\n    const double dfSrcYInc = nYSize / static_cast<double>( nBufYSize );\n\n    int bNoDataSetIn = FALSE;\n    double dfNoData = GetRasterBand(1)->GetNoDataValue( &bNoDataSetIn );\n    GByte abyNoData = 0;\n    if( !bNoDataSetIn )\n        dfNoData = 0;\n    else if( dfNoData >= 0 && dfNoData <= 255 )\n        abyNoData = static_cast<GByte>(dfNoData + 0.5);\n\n    if( FetchBuffer::bMinimizeIO &&\n             TIFFIsTiled( m_hTIFF ) && bNoXResampling && (nYSize == nBufYSize ) &&\n             m_nPlanarConfig == PLANARCONFIG_CONTIG && nBandCount > 1 )\n    {\n        GByte* pabyData = static_cast<GByte *>(pData);\n        for( int y = 0; y < nBufYSize; )\n        {\n            const int nSrcLine = nYOff + y;\n            const int nBlockYOff = nSrcLine / m_nBlockYSize;\n            const int nYOffsetInBlock = nSrcLine % m_nBlockYSize;\n            const int nUsedBlockHeight =\n                std::min( nBufYSize - y,\n                          m_nBlockYSize - nYOffsetInBlock );\n\n            int nBlockXOff = nXOff / m_nBlockXSize;\n            int nXOffsetInBlock = nXOff % m_nBlockXSize;\n            int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n\n            int x = 0;\n            while( x < nBufXSize )\n            {\n                const toff_t nCurOffset = panOffsets[nBlockId];\n                const int nUsedBlockWidth =\n                    std::min( m_nBlockXSize - nXOffsetInBlock,\n                              nBufXSize - x );\n\n                if( nCurOffset == 0 )\n                {\n                    REACHED(30);\n                    for( int k = 0; k < nUsedBlockHeight; ++k )\n                    {\n                        GByte* pabyLocalData =\n                            pabyData + (y + k) * nLineSpace + x * nPixelSpace;\n                        for( int iBand = 0; iBand < nBandCount; ++iBand )\n                        {\n                            GByte* pabyLocalDataBand =\n                                pabyLocalData + iBand * nBandSpace;\n\n                            GDALCopyWords(\n                                &dfNoData, GDT_Float64, 0,\n                                pabyLocalDataBand, eBufType,\n                                static_cast<int>(nPixelSpace),\n                                nUsedBlockWidth );\n                        }\n                    }\n                }\n                else\n                {\n                    const int nByteOffsetInBlock =\n                        nYOffsetInBlock * m_nBlockXSize * nBandsPerBlockDTSize;\n                    const GByte* pabyLocalSrcDataK0 = oFetcher.FetchBytes(\n                            nCurOffset + nByteOffsetInBlock,\n                            m_nBlockXSize *\n                            nUsedBlockHeight * nBandsPerBlock,\n                            nDTSize, bIsByteSwapped, bIsComplex, nBlockId);\n                    if( pabyLocalSrcDataK0 == nullptr )\n                        return CE_Failure;\n\n                    for( int k = 0; k < nUsedBlockHeight; ++k )\n                    {\n                        GByte* pabyLocalData =\n                            pabyData + (y + k) * nLineSpace + x * nPixelSpace;\n                        const GByte* pabyLocalSrcData =\n                            pabyLocalSrcDataK0 +\n                            (k * m_nBlockXSize + nXOffsetInBlock) *\n                            nBandsPerBlockDTSize;\n\n                        if( bUseContigImplementation && nBands == nBandCount &&\n                            nPixelSpace == nBandsPerBlockDTSize )\n                        {\n                            REACHED(31);\n                            GDALCopyWords( pabyLocalSrcData,\n                                           eDataType, nDTSize,\n                                           pabyLocalData,\n                                           eBufType, nBufDTSize,\n                                           nUsedBlockWidth * nBands );\n                        }\n                        else\n                        {\n                            REACHED(32);\n                            for( int iBand = 0; iBand < nBandCount; ++iBand )\n                            {\n                                GByte* pabyLocalDataBand =\n                                    pabyLocalData + iBand * nBandSpace;\n                                const GByte* pabyLocalSrcDataBand =\n                                    pabyLocalSrcData +\n                                    (panBandMap[iBand]-1) * nDTSize;\n\n                                GDALCopyWords(\n                                    pabyLocalSrcDataBand,\n                                    eDataType, nBandsPerBlockDTSize,\n                                    pabyLocalDataBand,\n                                    eBufType, static_cast<int>(nPixelSpace),\n                                    nUsedBlockWidth );\n                            }\n                        }\n                    }\n                }\n\n                nXOffsetInBlock = 0;\n                ++nBlockXOff;\n                ++nBlockId;\n                x += nUsedBlockWidth;\n            }\n\n            y += nUsedBlockHeight;\n        }\n    }\n    else if( FetchBuffer::bMinimizeIO &&\n             TIFFIsTiled( m_hTIFF ) && bNoXResampling &&\n             (nYSize == nBufYSize ) )\n             // && (m_nPlanarConfig == PLANARCONFIG_SEPARATE || nBandCount == 1) )\n    {\n        for( int iBand = 0; iBand < nBandCount; ++iBand )\n        {\n            GByte* pabyData = static_cast<GByte *>(pData) + iBand * nBandSpace;\n            const int nBand = panBandMap[iBand];\n            for( int y = 0; y < nBufYSize; )\n            {\n                const int nSrcLine = nYOff + y;\n                const int m_nBlockYOff = nSrcLine / m_nBlockYSize;\n                const int nYOffsetIm_nBlock = nSrcLine % m_nBlockYSize;\n                const int nUsedBlockHeight =\n                    std::min( nBufYSize - y,\n                              m_nBlockYSize - nYOffsetIm_nBlock);\n\n                int nBlockXOff = nXOff / m_nBlockXSize;\n                int nXOffsetInBlock = nXOff % m_nBlockXSize;\n                int nBlockId = nBlockXOff + m_nBlockYOff * nBlocksPerRow;\n                if( m_nPlanarConfig == PLANARCONFIG_SEPARATE )\n                {\n                    REACHED(33);\n                    nBlockId += m_nBlocksPerBand * (nBand - 1);\n                }\n                else\n                {\n                    REACHED(34);\n                }\n\n                int x = 0;\n                while( x < nBufXSize )\n                {\n                    const toff_t nCurOffset = panOffsets[nBlockId];\n                    const int nUsedBlockWidth =\n                        std::min(\n                            m_nBlockXSize - nXOffsetInBlock,\n                            nBufXSize - x);\n\n                    if( nCurOffset == 0 )\n                    {\n                        REACHED(35);\n                        for( int k = 0; k < nUsedBlockHeight; ++k )\n                        {\n                            GByte* pabyLocalData =\n                                pabyData + (y + k) * nLineSpace + x * nPixelSpace;\n\n                            GDALCopyWords(\n                                &dfNoData, GDT_Float64, 0,\n                                pabyLocalData, eBufType,\n                                static_cast<int>(nPixelSpace),\n                                nUsedBlockWidth );\n                        }\n                    }\n                    else\n                    {\n                        const int nByteOffsetIm_nBlock =\n                            nYOffsetIm_nBlock * m_nBlockXSize *\n                            nBandsPerBlockDTSize;\n                        const GByte* pabyLocalSrcDataK0 =\n                            oFetcher.FetchBytes(\n                                nCurOffset + nByteOffsetIm_nBlock,\n                                m_nBlockXSize *\n                                nUsedBlockHeight * nBandsPerBlock,\n                                nDTSize, bIsByteSwapped, bIsComplex, nBlockId);\n                        if( pabyLocalSrcDataK0 == nullptr )\n                            return CE_Failure;\n\n                        if( m_nPlanarConfig == PLANARCONFIG_CONTIG )\n                        {\n                            REACHED(36);\n                            pabyLocalSrcDataK0 += (nBand - 1) * nDTSize;\n                        }\n                        else\n                        {\n                            REACHED(37);\n                        }\n\n                        for( int k = 0; k < nUsedBlockHeight; ++k )\n                        {\n                            GByte* pabyLocalData =\n                                pabyData + (y + k) * nLineSpace +\n                                x * nPixelSpace;\n                            const GByte* pabyLocalSrcData =\n                                pabyLocalSrcDataK0 +\n                                (k * m_nBlockXSize + nXOffsetInBlock) *\n                                nBandsPerBlockDTSize;\n\n                            GDALCopyWords(\n                                pabyLocalSrcData,\n                                eDataType, nBandsPerBlockDTSize,\n                                pabyLocalData,\n                                eBufType, static_cast<int>(nPixelSpace),\n                                nUsedBlockWidth);\n                        }\n                    }\n\n                    nXOffsetInBlock = 0;\n                    ++nBlockXOff;\n                    ++nBlockId;\n                    x += nUsedBlockWidth;\n                }\n\n                y += nUsedBlockHeight;\n            }\n        }\n    }\n    else if( FetchBuffer::bMinimizeIO &&\n             TIFFIsTiled( m_hTIFF ) &&\n             m_nPlanarConfig == PLANARCONFIG_CONTIG && nBandCount > 1 )\n    {\n        GByte* pabyData = static_cast<GByte *>(pData);\n        int anSrcYOffset[256] = { 0 };\n        for( int y = 0; y < nBufYSize; )\n        {\n            const double dfYOffStart = nYOff + (y + 0.5) * dfSrcYInc;\n            const int nSrcLine = static_cast<int>(dfYOffStart);\n            const int nYOffsetIm_nBlock = nSrcLine % m_nBlockYSize;\n            const int m_nBlockYOff = nSrcLine / m_nBlockYSize;\n            const int nBaseByteOffsetIm_nBlock =\n                nYOffsetIm_nBlock * m_nBlockXSize * nBandsPerBlockDTSize;\n            int ychunk = 1;\n            int nLastSrcLineK = nSrcLine;\n            anSrcYOffset[0] = 0;\n            for( int k = 1; k < nBufYSize - y; ++k )\n            {\n                int nSrcLineK =\n                    nYOff + static_cast<int>((y + k + 0.5) * dfSrcYInc);\n                const int nBlockYOffK = nSrcLineK / m_nBlockYSize;\n                if( k < 256)\n                    anSrcYOffset[k] =\n                        ((nSrcLineK % m_nBlockYSize) - nYOffsetIm_nBlock) *\n                        m_nBlockXSize * nBandsPerBlockDTSize;\n                if( nBlockYOffK != m_nBlockYOff )\n                {\n                    break;\n                }\n                ++ychunk;\n                nLastSrcLineK = nSrcLineK;\n            }\n            const int nUsedBlockHeight = nLastSrcLineK - nSrcLine + 1;\n            // CPLAssert(nUsedBlockHeight <= m_nBlockYSize);\n\n            double dfSrcX = nXOff + 0.5 * dfSrcXInc;\n            int nCurBlockXOff = 0;\n            int nNextBlockXOff = 0;\n            toff_t nCurOffset = 0;\n            const GByte* pabyLocalSrcDataStartLine = nullptr;\n            for( int x = 0; x < nBufXSize; ++x, dfSrcX += dfSrcXInc)\n            {\n                const int nSrcPixel = static_cast<int>(dfSrcX);\n                if( nSrcPixel >= nNextBlockXOff )\n                {\n                    const int nBlockXOff = nSrcPixel / m_nBlockXSize;\n                    nCurBlockXOff = nBlockXOff * m_nBlockXSize;\n                    nNextBlockXOff = nCurBlockXOff + m_nBlockXSize;\n                    const int nBlockId =\n                        nBlockXOff + m_nBlockYOff * nBlocksPerRow;\n                    nCurOffset = panOffsets[nBlockId];\n                    if( nCurOffset != 0 )\n                    {\n                        pabyLocalSrcDataStartLine =\n                            oFetcher.FetchBytes(\n                                nCurOffset + nBaseByteOffsetIm_nBlock,\n                                m_nBlockXSize *\n                                nBandsPerBlock * nUsedBlockHeight,\n                                nDTSize,\n                                bIsByteSwapped, bIsComplex, nBlockId);\n                        if( pabyLocalSrcDataStartLine == nullptr )\n                            return CE_Failure;\n                    }\n                }\n\n                if( nCurOffset == 0 )\n                {\n                    REACHED(38);\n\n                    for( int k = 0; k < ychunk; ++k )\n                    {\n                        GByte* const pabyLocalData =\n                            pabyData + (y + k) * nLineSpace + x * nPixelSpace;\n                        for( int iBand = 0; iBand < nBandCount; ++iBand )\n                        {\n                            GDALCopyWords(\n                                &dfNoData, GDT_Float64, 0,\n                                pabyLocalData + nBandSpace * iBand, eBufType, 0,\n                                1);\n                        }\n                    }\n                }\n                else\n                {\n                    const int nXOffsetInBlock = nSrcPixel - nCurBlockXOff;\n                    double dfYOff = dfYOffStart;\n                    const GByte* const pabyLocalSrcDataK0 =\n                        pabyLocalSrcDataStartLine +\n                        nXOffsetInBlock * nBandsPerBlockDTSize;\n                    GByte* pabyLocalData =\n                        pabyData + y * nLineSpace + x * nPixelSpace;\n                    for( int k = 0;\n                         k < ychunk;\n                         ++k, pabyLocalData += nLineSpace )\n                    {\n                        const GByte* pabyLocalSrcData = nullptr;\n                        if( ychunk <= 256 )\n                        {\n                            REACHED(39);\n                            pabyLocalSrcData =\n                                pabyLocalSrcDataK0 + anSrcYOffset[k];\n                        }\n                        else\n                        {\n                            REACHED(40);\n                            const int nYOffsetIm_nBlockK =\n                                static_cast<int>(dfYOff) % m_nBlockYSize;\n                            // CPLAssert(\n                            //     nYOffsetIm_nBlockK - nYOffsetIm_nBlock <=\n                            //     nUsedBlockHeight);\n                            pabyLocalSrcData =\n                                pabyLocalSrcDataK0 +\n                                (nYOffsetIm_nBlockK - nYOffsetIm_nBlock) *\n                                m_nBlockXSize * nBandsPerBlockDTSize;\n                            dfYOff += dfSrcYInc;\n                        }\n\n                        if( bByteOnly )\n                        {\n                            REACHED(41);\n                            for( int iBand=0; iBand < nBandCount; ++iBand )\n                            {\n                                GByte* pabyLocalDataBand =\n                                    pabyLocalData + iBand * nBandSpace;\n                                const GByte* pabyLocalSrcDataBand =\n                                    pabyLocalSrcData + (panBandMap[iBand]-1);\n                                *pabyLocalDataBand = *pabyLocalSrcDataBand;\n                            }\n                        }\n                        else\n                        {\n                            REACHED(42);\n                            for( int iBand = 0; iBand < nBandCount; ++iBand )\n                            {\n                                GByte* pabyLocalDataBand =\n                                    pabyLocalData + iBand * nBandSpace;\n                                const GByte* pabyLocalSrcDataBand =\n                                    pabyLocalSrcData +\n                                    (panBandMap[iBand]-1) * nDTSize;\n\n                                GDALCopyWords( pabyLocalSrcDataBand,\n                                               eDataType, 0,\n                                               pabyLocalDataBand,\n                                               eBufType, 0,\n                                               1 );\n                            }\n                        }\n                    }\n                }\n            }\n\n            y += ychunk;\n        }\n    }\n    else if( FetchBuffer::bMinimizeIO &&\n             TIFFIsTiled( m_hTIFF ) )\n             // && (m_nPlanarConfig == PLANARCONFIG_SEPARATE || nBandCount == 1) )\n    {\n        for( int iBand = 0; iBand < nBandCount; ++iBand )\n        {\n            GByte* pabyData = static_cast<GByte*>(pData) + iBand * nBandSpace;\n            const int nBand = panBandMap[iBand];\n            int anSrcYOffset[256] = { 0 };\n            for( int y = 0; y < nBufYSize; )\n            {\n                const double dfYOffStart = nYOff + (y + 0.5) * dfSrcYInc;\n                const int nSrcLine = static_cast<int>(dfYOffStart);\n                const int nYOffsetIm_nBlock = nSrcLine % m_nBlockYSize;\n                const int m_nBlockYOff = nSrcLine / m_nBlockYSize;\n                const int nBaseByteOffsetIm_nBlock =\n                    nYOffsetIm_nBlock * m_nBlockXSize * nBandsPerBlockDTSize;\n                int ychunk = 1;\n                int nLastSrcLineK = nSrcLine;\n                anSrcYOffset[0] = 0;\n                for( int k = 1; k < nBufYSize - y; ++k )\n                {\n                    const int nSrcLineK =\n                        nYOff + static_cast<int>((y + k + 0.5) * dfSrcYInc);\n                    const int nBlockYOffK = nSrcLineK / m_nBlockYSize;\n                    if( k < 256)\n                        anSrcYOffset[k] =\n                            ((nSrcLineK % m_nBlockYSize) - nYOffsetIm_nBlock) *\n                            m_nBlockXSize * nBandsPerBlockDTSize;\n                    if( nBlockYOffK != m_nBlockYOff )\n                    {\n                        break;\n                    }\n                    ++ychunk;\n                    nLastSrcLineK = nSrcLineK;\n                }\n                const int nUsedBlockHeight = nLastSrcLineK - nSrcLine + 1;\n                // CPLAssert(nUsedBlockHeight <= m_nBlockYSize);\n\n                double dfSrcX = nXOff + 0.5 * dfSrcXInc;\n                int nCurBlockXOff = 0;\n                int nNextBlockXOff = 0;\n                toff_t nCurOffset = 0;\n                const GByte* pabyLocalSrcDataStartLine = nullptr;\n                for( int x = 0; x < nBufXSize; ++x, dfSrcX += dfSrcXInc )\n                {\n                    int nSrcPixel = static_cast<int>(dfSrcX);\n                    if( nSrcPixel >= nNextBlockXOff )\n                    {\n                        const int nBlockXOff = nSrcPixel / m_nBlockXSize;\n                        nCurBlockXOff = nBlockXOff * m_nBlockXSize;\n                        nNextBlockXOff = nCurBlockXOff + m_nBlockXSize;\n                        int nBlockId = nBlockXOff + m_nBlockYOff * nBlocksPerRow;\n                        if( m_nPlanarConfig == PLANARCONFIG_SEPARATE )\n                        {\n                            REACHED(43);\n                            nBlockId += m_nBlocksPerBand * (nBand - 1);\n                        }\n                        else\n                        {\n                            REACHED(44);\n                        }\n                        nCurOffset = panOffsets[nBlockId];\n                        if( nCurOffset != 0 )\n                        {\n                            pabyLocalSrcDataStartLine =\n                                oFetcher.FetchBytes(\n                                    nCurOffset + nBaseByteOffsetIm_nBlock,\n                                    m_nBlockXSize *\n                                    nBandsPerBlock * nUsedBlockHeight,\n                                    nDTSize,\n                                    bIsByteSwapped, bIsComplex, nBlockId);\n                            if( pabyLocalSrcDataStartLine == nullptr )\n                                return CE_Failure;\n\n                            if( m_nPlanarConfig == PLANARCONFIG_CONTIG )\n                            {\n                                REACHED(45);\n                                pabyLocalSrcDataStartLine +=\n                                    (nBand - 1) * nDTSize;\n                            }\n                            else\n                            {\n                                REACHED(46);\n                            }\n                        }\n                    }\n\n                    if( nCurOffset == 0 )\n                    {\n                        REACHED(47);\n\n                        for( int k = 0; k < ychunk; ++k )\n                        {\n                            GByte* const pabyLocalData =\n                                pabyData + (y + k) * nLineSpace + x * nPixelSpace;\n\n                            GDALCopyWords( &dfNoData, GDT_Float64, 0,\n                                           pabyLocalData, eBufType, 0,\n                                           1 );\n                        }\n                    }\n                    else\n                    {\n                        const int nXOffsetInBlock = nSrcPixel - nCurBlockXOff;\n                        double dfYOff = dfYOffStart;\n                        const GByte* const pabyLocalSrcDataK0 =\n                            pabyLocalSrcDataStartLine +\n                            nXOffsetInBlock * nBandsPerBlockDTSize;\n                        GByte* pabyLocalData =\n                            pabyData + y * nLineSpace + x * nPixelSpace;\n                        for( int k = 0;\n                             k < ychunk;\n                             ++k, pabyLocalData += nLineSpace )\n                        {\n                            const GByte* pabyLocalSrcData = nullptr;\n                            if( ychunk <= 256 )\n                            {\n                                REACHED(48);\n                                pabyLocalSrcData =\n                                    pabyLocalSrcDataK0 + anSrcYOffset[k];\n                            }\n                            else\n                            {\n                                REACHED(49);\n                                const int nYOffsetIm_nBlockK =\n                                    static_cast<int>(dfYOff) % m_nBlockYSize;\n                                // CPLAssert(\n                                //     nYOffsetIm_nBlockK - nYOffsetIm_nBlock <=\n                                //     nUsedBlockHeight);\n                                pabyLocalSrcData = pabyLocalSrcDataK0 +\n                                    (nYOffsetIm_nBlockK - nYOffsetIm_nBlock) *\n                                    m_nBlockXSize * nBandsPerBlockDTSize;\n                                dfYOff += dfSrcYInc;\n                            }\n\n                            if( bByteOnly )\n                            {\n                                REACHED(50);\n\n                                *pabyLocalData = *pabyLocalSrcData;\n                            }\n                            else\n                            {\n                                REACHED(51);\n\n                                GDALCopyWords( pabyLocalSrcData,\n                                               eDataType, 0,\n                                               pabyLocalData,\n                                               eBufType, 0,\n                                               1 );\n                            }\n                        }\n                    }\n                }\n\n                y += ychunk;\n            }\n        }\n    }\n    else if( bUseContigImplementation )\n    {\n        if( !FetchBuffer::bMinimizeIO && TIFFIsTiled( m_hTIFF ) )\n        {\n            GByte* pabyData = static_cast<GByte *>(pData);\n            for( int y = 0; y < nBufYSize; ++y )\n            {\n                const int nSrcLine =\n                    nYOff + static_cast<int>((y + 0.5) * dfSrcYInc);\n                const int m_nBlockYOff = nSrcLine / m_nBlockYSize;\n                const int nYOffsetIm_nBlock = nSrcLine % m_nBlockYSize;\n                const int nBaseByteOffsetIm_nBlock =\n                    nYOffsetIm_nBlock * m_nBlockXSize * nBandsPerBlockDTSize;\n\n                if( bNoXResampling )\n                {\n                    GByte* pabyLocalData = pabyData + y * nLineSpace;\n                    int nBlockXOff = nXOff / m_nBlockXSize;\n                    int nXOffsetInBlock = nXOff % m_nBlockXSize;\n                    int nBlockId = nBlockXOff + m_nBlockYOff * nBlocksPerRow;\n\n                    int x = 0;\n                    while( x < nBufXSize )\n                    {\n                        const int nByteOffsetIm_nBlock = nBaseByteOffsetIm_nBlock +\n                                        nXOffsetInBlock * nBandsPerBlockDTSize;\n                        const toff_t nCurOffset = panOffsets[nBlockId];\n                        const int nUsedBlockWidth =\n                            std::min(\n                                m_nBlockXSize - nXOffsetInBlock,\n                                nBufXSize - x);\n\n                        int nIters = nUsedBlockWidth;\n                        if( nCurOffset == 0 )\n                        {\n                            if( bByteNoXResampling )\n                            {\n                                REACHED(0);\n                                while( nIters-- > 0 )\n                                {\n                                    for( int iBand = 0;\n                                         iBand < nBandCount;\n                                         ++iBand )\n                                    {\n                                        pabyLocalData[iBand] = abyNoData;\n                                    }\n                                    pabyLocalData += nPixelSpace;\n                                }\n                            }\n                            else\n                            {\n                                REACHED(1);\n                                while( nIters-- > 0 )\n                                {\n                                    GDALCopyWords(\n                                        &dfNoData, GDT_Float64, 0,\n                                        pabyLocalData, eBufType,\n                                        static_cast<int>(nBandSpace),\n                                        nBandCount);\n                                    pabyLocalData += nPixelSpace;\n                                }\n                            }\n                        }\n                        else\n                        {\n                            if( bNoTypeChange && nBands == nBandCount &&\n                                nPixelSpace == nBandsPerBlockDTSize )\n                            {\n                                REACHED(2);\n                                if( !oFetcher.FetchBytes(\n                                        pabyLocalData,\n                                        nCurOffset + nByteOffsetIm_nBlock,\n                                        nIters * nBandsPerBlock, nDTSize,\n                                        bIsByteSwapped, bIsComplex, nBlockId) )\n                                {\n                                    return CE_Failure;\n                                }\n                                pabyLocalData +=\n                                    nIters * nBandsPerBlock * nDTSize;\n                            }\n                            else\n                            {\n                                const GByte* pabyLocalSrcData =\n                                    oFetcher.FetchBytes(\n                                        nCurOffset + nByteOffsetIm_nBlock,\n                                        nIters * nBandsPerBlock, nDTSize,\n                                        bIsByteSwapped, bIsComplex, nBlockId);\n                                if( pabyLocalSrcData == nullptr )\n                                    return CE_Failure;\n                                if( bByteNoXResampling )\n                                {\n                                    REACHED(3);\n                                    CopyContigByteMultiBand(\n                                        pabyLocalSrcData,\n                                        nBandsPerBlockDTSize,\n                                        pabyLocalData,\n                                        static_cast<int>(nPixelSpace),\n                                        nIters,\n                                        nBandCount);\n                                    pabyLocalData += nIters * nPixelSpace;\n                                }\n                                else\n                                {\n                                    REACHED(4);\n                                    while( nIters-- > 0 )\n                                    {\n                                        GDALCopyWords(\n                                            pabyLocalSrcData,\n                                            eDataType, nDTSize,\n                                            pabyLocalData,\n                                            eBufType,\n                                            static_cast<int>(nBandSpace),\n                                            nBandCount);\n                                        pabyLocalSrcData +=\n                                            nBandsPerBlockDTSize;\n                                        pabyLocalData += nPixelSpace;\n                                    }\n                                }\n                            }\n                        }\n\n                        nXOffsetInBlock = 0;\n                        ++nBlockXOff;\n                        ++nBlockId;\n                        x += nUsedBlockWidth;\n                    }\n                }\n                else  // Contig, tiled, potential resampling & data type change.\n                {\n                    const GByte* pabyLocalSrcDataStartLine = nullptr;\n                    GByte* pabyLocalData = pabyData + y * nLineSpace;\n                    double dfSrcX = nXOff + 0.5 * dfSrcXInc;\n                    int nCurBlockXOff = 0;\n                    int nNextBlockXOff = 0;\n                    toff_t nCurOffset = 0;\n                    for( int x = 0; x < nBufXSize; ++x, dfSrcX += dfSrcXInc )\n                    {\n                        int nSrcPixel = static_cast<int>(dfSrcX);\n                        if( nSrcPixel >= nNextBlockXOff )\n                        {\n                            const int nBlockXOff = nSrcPixel / m_nBlockXSize;\n                            nCurBlockXOff = nBlockXOff * m_nBlockXSize;\n                            nNextBlockXOff = nCurBlockXOff + m_nBlockXSize;\n                            const int nBlockId =\n                                nBlockXOff + m_nBlockYOff * nBlocksPerRow;\n                            nCurOffset = panOffsets[nBlockId];\n                            if( nCurOffset != 0 )\n                            {\n                                pabyLocalSrcDataStartLine =\n                                    oFetcher.FetchBytes(\n                                        nCurOffset + nBaseByteOffsetIm_nBlock,\n                                        m_nBlockXSize *\n                                        nBandsPerBlock,\n                                        nDTSize,\n                                        bIsByteSwapped, bIsComplex, nBlockId);\n                                if( pabyLocalSrcDataStartLine == nullptr )\n                                    return CE_Failure;\n                            }\n                        }\n                        const int nXOffsetInBlock = nSrcPixel - nCurBlockXOff;\n\n                        if( nCurOffset == 0 )\n                        {\n                            REACHED(5);\n                            GDALCopyWords(\n                                &dfNoData, GDT_Float64, 0,\n                                pabyLocalData,\n                                eBufType,\n                                static_cast<int>(nBandSpace),\n                                nBandCount );\n                            pabyLocalData += nPixelSpace;\n                        }\n                        else\n                        {\n                            const GByte* pabyLocalSrcData =\n                                pabyLocalSrcDataStartLine +\n                                nXOffsetInBlock * nBandsPerBlockDTSize;\n\n                            REACHED(6);\n                            if( bByteOnly )\n                            {\n                                for( int iBand = 0; iBand < nBands; ++iBand )\n                                    pabyLocalData[iBand] =\n                                        pabyLocalSrcData[iBand];\n                            }\n                            else\n                            {\n                                GDALCopyWords(\n                                    pabyLocalSrcData,\n                                    eDataType, nDTSize,\n                                    pabyLocalData,\n                                    eBufType,\n                                    static_cast<int>(nBandSpace),\n                                    nBandCount );\n                            }\n                            pabyLocalData += nPixelSpace;\n                        }\n                    }\n                }\n            }\n        }\n        else  // Contig, striped organized.\n        {\n            GByte* pabyData = static_cast<GByte*>(pData);\n            for( int y = 0; y < nBufYSize; ++y )\n            {\n                const int nSrcLine =\n                    nYOff + static_cast<int>((y + 0.5) * dfSrcYInc);\n                const int m_nBlockYOff = nSrcLine / m_nBlockYSize;\n                const int nYOffsetIm_nBlock = nSrcLine % m_nBlockYSize;\n                const int nBlockId = m_nBlockYOff;\n                const toff_t nCurOffset = panOffsets[nBlockId];\n                if( nCurOffset == 0 )\n                {\n                    REACHED(7);\n                    for( int x = 0; x < nBufXSize; ++x )\n                    {\n                        GDALCopyWords(\n                            &dfNoData, GDT_Float64, 0,\n                            pabyData + y * nLineSpace + x * nPixelSpace,\n                            eBufType, static_cast<int>(nBandSpace),\n                            nBandCount);\n                    }\n                }\n                else\n                {\n                    GByte* pabyLocalData = pabyData + y * nLineSpace;\n                    const int nBaseByteOffsetIm_nBlock =\n                        (nYOffsetIm_nBlock * m_nBlockXSize + nXOff) *\n                        nBandsPerBlockDTSize;\n\n                    if( bNoXResamplingNoTypeChange && nBands == nBandCount &&\n                        nPixelSpace == nBandsPerBlockDTSize )\n                    {\n                        REACHED(8);\n                        if( !oFetcher.FetchBytes(\n                               pabyLocalData,\n                               nCurOffset + nBaseByteOffsetIm_nBlock,\n                               nXSize * nBandsPerBlock, nDTSize, bIsByteSwapped,\n                               bIsComplex, nBlockId) )\n                        {\n                            return CE_Failure;\n                        }\n                    }\n                    else\n                    {\n                        const GByte* pabyLocalSrcData = oFetcher.FetchBytes(\n                            nCurOffset + nBaseByteOffsetIm_nBlock,\n                            nXSize * nBandsPerBlock, nDTSize, bIsByteSwapped,\n                            bIsComplex, nBlockId);\n                        if( pabyLocalSrcData == nullptr )\n                            return CE_Failure;\n\n                        if( bByteNoXResampling )\n                        {\n                            REACHED(9);\n                            CopyContigByteMultiBand(\n                                pabyLocalSrcData,\n                                nBandsPerBlockDTSize,\n                                pabyLocalData,\n                                static_cast<int>(nPixelSpace),\n                                nBufXSize,\n                                nBandCount);\n                        }\n                        else if( bByteOnly )\n                        {\n                            REACHED(10);\n                            double dfSrcX = 0.5 * dfSrcXInc;\n                            for( int x = 0;\n                                 x < nBufXSize;\n                                 ++x, dfSrcX += dfSrcXInc )\n                            {\n                                const int nSrcPixelMinusXOff =\n                                    static_cast<int>(dfSrcX);\n                                for( int iBand = 0;\n                                     iBand < nBandCount;\n                                     ++iBand )\n                                {\n                                    pabyLocalData[x * nPixelSpace + iBand] =\n                                        pabyLocalSrcData[nSrcPixelMinusXOff *\n                                                         nBandsPerBlockDTSize +\n                                                         iBand];\n                                }\n                            }\n                        }\n                        else\n                        {\n                            REACHED(11);\n                            double dfSrcX = 0.5 * dfSrcXInc;\n                            for( int x = 0;\n                                 x < nBufXSize;\n                                 ++x, dfSrcX += dfSrcXInc )\n                            {\n                                int nSrcPixelMinusXOff =\n                                    static_cast<int>(dfSrcX);\n                                GDALCopyWords(\n                                    pabyLocalSrcData +\n                                    nSrcPixelMinusXOff * nBandsPerBlockDTSize,\n                                    eDataType, nDTSize,\n                                    pabyLocalData + x * nPixelSpace,\n                                    eBufType,\n                                    static_cast<int>(nBandSpace),\n                                    nBandCount );\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    else  // Non-contig reading case.\n    {\n        if( !FetchBuffer::bMinimizeIO && TIFFIsTiled( m_hTIFF ) )\n        {\n            for( int iBand = 0; iBand < nBandCount; ++iBand )\n            {\n                const int nBand = panBandMap[iBand];\n                GByte* const pabyData =\n                    static_cast<GByte*>(pData) + iBand * nBandSpace;\n                for( int y = 0; y < nBufYSize; ++y )\n                {\n                    const int nSrcLine =\n                        nYOff + static_cast<int>((y + 0.5) * dfSrcYInc);\n                    const int m_nBlockYOff = nSrcLine / m_nBlockYSize;\n                    const int nYOffsetIm_nBlock = nSrcLine % m_nBlockYSize;\n\n                    int nBaseByteOffsetIm_nBlock =\n                        nYOffsetIm_nBlock * m_nBlockXSize * nBandsPerBlockDTSize;\n                    if( m_nPlanarConfig == PLANARCONFIG_CONTIG )\n                    {\n                        REACHED(12);\n                        nBaseByteOffsetIm_nBlock += (nBand - 1) * nDTSize;\n                    }\n                    else\n                    {\n                        REACHED(13);\n                    }\n\n                    if( bNoXResampling )\n                    {\n                        GByte* pabyLocalData = pabyData + y * nLineSpace;\n                        int nBlockXOff = nXOff / m_nBlockXSize;\n                        int nBlockId = nBlockXOff + m_nBlockYOff * nBlocksPerRow;\n                        if( m_nPlanarConfig == PLANARCONFIG_SEPARATE )\n                        {\n                            REACHED(14);\n                            nBlockId += m_nBlocksPerBand * (nBand - 1);\n                        }\n                        else\n                        {\n                            REACHED(15);\n                        }\n                        int nXOffsetInBlock = nXOff % m_nBlockXSize;\n\n                        int x = 0;\n                        while( x < nBufXSize )\n                        {\n                            const int nByteOffsetIm_nBlock =\n                                nBaseByteOffsetIm_nBlock +\n                                nXOffsetInBlock * nBandsPerBlockDTSize;\n                            const toff_t nCurOffset = panOffsets[nBlockId];\n                            const int nUsedBlockWidth =\n                                std::min(\n                                    m_nBlockXSize - nXOffsetInBlock,\n                                    nBufXSize - x );\n                            int nIters = nUsedBlockWidth;\n\n                            if( nCurOffset == 0 )\n                            {\n                                REACHED(16);\n                                GDALCopyWords(\n                                    &dfNoData, GDT_Float64, 0,\n                                    pabyLocalData, eBufType,\n                                    static_cast<int>(nPixelSpace),\n                                    nIters);\n                                pabyLocalData += nIters * nPixelSpace;\n                            }\n                            else\n                            {\n                                if( bNoTypeChange &&\n                                    nPixelSpace == nBandsPerBlockDTSize )\n                                {\n                                    REACHED(17);\n                                    if( !oFetcher.FetchBytes(\n                                           pabyLocalData,\n                                           nCurOffset + nByteOffsetIm_nBlock,\n                                           (nIters - 1) * nBandsPerBlock + 1,\n                                           nDTSize,\n                                           bIsByteSwapped, bIsComplex,\n                                           nBlockId) )\n                                    {\n                                        return CE_Failure;\n                                    }\n                                    pabyLocalData += nIters * nPixelSpace;\n                                }\n                                else\n                                {\n                                    const GByte* pabyLocalSrcData =\n                                        oFetcher.FetchBytes(\n                                            nCurOffset + nByteOffsetIm_nBlock,\n                                            (nIters - 1) * nBandsPerBlock + 1,\n                                            nDTSize,\n                                            bIsByteSwapped,\n                                            bIsComplex,\n                                            nBlockId );\n                                    if( pabyLocalSrcData == nullptr )\n                                        return CE_Failure;\n\n                                    REACHED(18);\n                                    GDALCopyWords(\n                                        pabyLocalSrcData, eDataType,\n                                        nBandsPerBlockDTSize,\n                                        pabyLocalData, eBufType,\n                                        static_cast<int>(nPixelSpace),\n                                        nIters );\n                                    pabyLocalData += nIters * nPixelSpace;\n                                }\n                            }\n\n                            nXOffsetInBlock = 0;\n                            ++nBlockXOff;\n                            ++nBlockId;\n                            x += nUsedBlockWidth;\n                        }\n                    }\n                    else\n                    {\n                        // Non-contig reading, tiled, potential resampling and\n                        // data type change.\n\n                        const GByte* pabyLocalSrcDataStartLine = nullptr;\n                        GByte* pabyLocalData = pabyData + y * nLineSpace;\n                        double dfSrcX = nXOff + 0.5 * dfSrcXInc;\n                        int nCurBlockXOff = 0;\n                        int nNextBlockXOff = 0;\n                        toff_t nCurOffset = 0;\n                        for( int x = 0; x < nBufXSize; ++x, dfSrcX += dfSrcXInc)\n                        {\n                            const int nSrcPixel = static_cast<int>(dfSrcX);\n                            if( nSrcPixel >= nNextBlockXOff )\n                            {\n                                const int nBlockXOff = nSrcPixel / m_nBlockXSize;\n                                nCurBlockXOff = nBlockXOff * m_nBlockXSize;\n                                nNextBlockXOff = nCurBlockXOff + m_nBlockXSize;\n                                int nBlockId =\n                                    nBlockXOff + m_nBlockYOff * nBlocksPerRow;\n                                if( m_nPlanarConfig == PLANARCONFIG_SEPARATE )\n                                {\n                                    REACHED(19);\n                                    nBlockId += m_nBlocksPerBand * (nBand - 1);\n                                }\n                                else\n                                {\n                                    REACHED(20);\n                                }\n                                nCurOffset = panOffsets[nBlockId];\n                                if( nCurOffset != 0 )\n                                {\n                                    pabyLocalSrcDataStartLine =\n                                        oFetcher.FetchBytes(\n                                            nCurOffset + nBaseByteOffsetIm_nBlock,\n                                            m_nBlockXSize * nBandsPerBlock,\n                                            nDTSize,\n                                            bIsByteSwapped,\n                                            bIsComplex,\n                                            nBlockId);\n                                    if( pabyLocalSrcDataStartLine == nullptr )\n                                        return CE_Failure;\n                                }\n                            }\n                            const int nXOffsetInBlock =\n                                nSrcPixel - nCurBlockXOff;\n\n                            if( nCurOffset == 0 )\n                            {\n                                REACHED(21);\n                                GDALCopyWords( &dfNoData, GDT_Float64, 0,\n                                               pabyLocalData,\n                                               eBufType, 0,\n                                               1 );\n                                pabyLocalData += nPixelSpace;\n                            }\n                            else\n                            {\n                                const GByte* pabyLocalSrcData =\n                                    pabyLocalSrcDataStartLine +\n                                    nXOffsetInBlock * nBandsPerBlockDTSize;\n\n                                REACHED(22);\n                                if( bByteOnly )\n                                {\n                                    *pabyLocalData = *pabyLocalSrcData;\n                                }\n                                else\n                                {\n                                    GDALCopyWords(pabyLocalSrcData,\n                                                eDataType, 0,\n                                                pabyLocalData,\n                                                eBufType, 0,\n                                                1);\n                                }\n                                pabyLocalData += nPixelSpace;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        else  // Non-contig reading, striped.\n        {\n            for( int iBand = 0; iBand < nBandCount; ++iBand )\n            {\n                const int nBand = panBandMap[iBand];\n                GByte* pabyData =\n                    static_cast<GByte *>(pData) + iBand * nBandSpace;\n                for( int y = 0; y < nBufYSize; ++y )\n                {\n                    const int nSrcLine =\n                        nYOff + static_cast<int>((y + 0.5) * dfSrcYInc);\n                    const int m_nBlockYOff = nSrcLine / m_nBlockYSize;\n                    const int nYOffsetIm_nBlock = nSrcLine % m_nBlockYSize;\n                    int nBlockId = m_nBlockYOff;\n                    if( m_nPlanarConfig == PLANARCONFIG_SEPARATE )\n                    {\n                        REACHED(23);\n                        nBlockId += m_nBlocksPerBand * (nBand - 1);\n                    }\n                    else\n                    {\n                        REACHED(24);\n                    }\n                    const toff_t nCurOffset = panOffsets[nBlockId];\n                    if( nCurOffset == 0 )\n                    {\n                        REACHED(25);\n                        GDALCopyWords(\n                            &dfNoData, GDT_Float64, 0,\n                            pabyData + y * nLineSpace,\n                            eBufType,\n                            static_cast<int>(nPixelSpace),\n                            nBufXSize);\n                    }\n                    else\n                    {\n                        int nBaseByteOffsetIm_nBlock =\n                            (nYOffsetIm_nBlock * m_nBlockXSize + nXOff) *\n                            nBandsPerBlockDTSize;\n                        if( m_nPlanarConfig == PLANARCONFIG_CONTIG )\n                            nBaseByteOffsetIm_nBlock += (nBand - 1) * nDTSize;\n\n                        GByte* pabyLocalData = pabyData + y * nLineSpace;\n                        if( bNoXResamplingNoTypeChange &&\n                            nPixelSpace == nBandsPerBlockDTSize )\n                        {\n                            REACHED(26);\n                            if( !oFetcher.FetchBytes(\n                                pabyLocalData,\n                                nCurOffset + nBaseByteOffsetIm_nBlock,\n                                (nXSize - 1) * nBandsPerBlock + 1, nDTSize,\n                                bIsByteSwapped, bIsComplex, nBlockId) )\n                            {\n                                return CE_Failure;\n                            }\n                        }\n                        else\n                        {\n                            const GByte* pabyLocalSrcData = oFetcher.FetchBytes(\n                                nCurOffset + nBaseByteOffsetIm_nBlock,\n                                (nXSize - 1) * nBandsPerBlock + 1, nDTSize,\n                                bIsByteSwapped, bIsComplex, nBlockId);\n                            if( pabyLocalSrcData == nullptr )\n                                return CE_Failure;\n\n                            if( bNoXResamplingNoTypeChange )\n                            {\n                                REACHED(27);\n                                GDALCopyWords(pabyLocalSrcData,\n                                              eDataType, nBandsPerBlockDTSize,\n                                              pabyLocalData, eBufType,\n                                              static_cast<int>(nPixelSpace),\n                                              nBufXSize);\n                            }\n                            else if( bByteOnly )\n                            {\n                                REACHED(28);\n                                double dfSrcX = 0.5 * dfSrcXInc;\n                                for( int x = 0;\n                                     x < nBufXSize;\n                                     ++x, dfSrcX += dfSrcXInc )\n                                {\n                                    const int nSrcPixelMinusXOff =\n                                        static_cast<int>(dfSrcX);\n                                    pabyLocalData[x * nPixelSpace] =\n                                        pabyLocalSrcData[nSrcPixelMinusXOff *\n                                                         nBandsPerBlockDTSize];\n                                }\n                            }\n                            else\n                            {\n                                REACHED(29);\n                                double dfSrcX = 0.5 * dfSrcXInc;\n                                for( int x = 0;\n                                     x < nBufXSize;\n                                     ++x, dfSrcX += dfSrcXInc )\n                                {\n                                    const int nSrcPixelMinusXOff =\n                                        static_cast<int>(dfSrcX);\n                                    GDALCopyWords(\n                                        pabyLocalSrcData +\n                                        nSrcPixelMinusXOff *\n                                        nBandsPerBlockDTSize,\n                                        eDataType, 0,\n                                        pabyLocalData + x * nPixelSpace,\n                                        eBufType, 0,\n                                        1 );\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                           DirectIO()                                 */\n/************************************************************************/\n\n// Reads directly bytes from the file using ReadMultiRange(), and by-pass\n// block reading. Restricted to simple TIFF configurations\n// (uncompressed data, standard data types). Particularly useful to extract\n// sub-windows of data on a large /vsicurl dataset).\n// Returns -1 if DirectIO() can't be supported on that file.\n\nint GTiffDataset::DirectIO( GDALRWFlag eRWFlag,\n                            int nXOff, int nYOff, int nXSize, int nYSize,\n                            void * pData, int nBufXSize, int nBufYSize,\n                            GDALDataType eBufType,\n                            int nBandCount, int *panBandMap,\n                            GSpacing nPixelSpace, GSpacing nLineSpace,\n                            GSpacing nBandSpace,\n                            GDALRasterIOExtraArg* psExtraArg )\n{\n    const GDALDataType eDataType = GetRasterBand(1)->GetRasterDataType();\n    const int nDTSizeBits = GDALGetDataTypeSizeBits(eDataType);\n    if( !(eRWFlag == GF_Read &&\n          m_nCompression == COMPRESSION_NONE &&\n          (m_nPhotometric == PHOTOMETRIC_MINISBLACK ||\n           m_nPhotometric == PHOTOMETRIC_RGB ||\n           m_nPhotometric == PHOTOMETRIC_PALETTE) &&\n          m_nBitsPerSample == nDTSizeBits) )\n    {\n        return -1;\n    }\n    Crystalize();\n\n    // Only know how to deal with nearest neighbour in this optimized routine.\n    if( (nXSize != nBufXSize || nYSize != nBufYSize) &&\n        psExtraArg != nullptr &&\n        psExtraArg->eResampleAlg != GRIORA_NearestNeighbour )\n    {\n        return -1;\n    }\n\n    // If the file is band interleave or only one band is requested, then\n    // fallback to band DirectIO.\n    bool bUseBandRasterIO = false;\n    if( m_nPlanarConfig == PLANARCONFIG_SEPARATE || nBandCount == 1 )\n    {\n        bUseBandRasterIO = true;\n    }\n    else\n    {\n        // For simplicity, only deals with \"naturally ordered\" bands.\n        for( int iBand = 0; iBand < nBandCount; ++iBand )\n        {\n            if( panBandMap[iBand] != iBand + 1)\n            {\n                bUseBandRasterIO = true;\n                break;\n            }\n        }\n    }\n    if( bUseBandRasterIO )\n    {\n        CPLErr eErr = CE_None;\n        for( int iBand = 0; eErr == CE_None && iBand < nBandCount; ++iBand )\n        {\n            eErr = GetRasterBand(panBandMap[iBand])->RasterIO(\n                eRWFlag, nXOff, nYOff, nXSize, nYSize,\n                static_cast<GByte *>(pData) + iBand * nBandSpace,\n                nBufXSize, nBufYSize,\n                eBufType,\n                nPixelSpace, nLineSpace,\n                psExtraArg );\n        }\n        return eErr;\n    }\n\n#if DEBUG_VERBOSE\n    CPLDebug( \"GTiff\", \"DirectIO(%d,%d,%d,%d -> %dx%d)\",\n              nXOff, nYOff, nXSize, nYSize,\n              nBufXSize, nBufYSize );\n#endif\n\n    // No need to look if overviews can satisfy the request as it has already */\n    // been done in GTiffDataset::IRasterIO().\n\n    // Make sure that TIFFTAG_STRIPOFFSETS is up-to-date.\n    if( GetAccess() == GA_Update )\n    {\n        FlushCache();\n        VSI_TIFFFlushBufferedWrite( TIFFClientdata( m_hTIFF ) );\n    }\n\n    if( TIFFIsTiled( m_hTIFF ) )\n    {\n        const int nDTSize = nDTSizeBits / 8;\n        const size_t nTempBufferForCommonDirectIOSize =\n            static_cast<size_t>(static_cast<GPtrDiff_t>(m_nBlockXSize) * m_nBlockYSize * nDTSize *\n            ((m_nPlanarConfig == PLANARCONFIG_CONTIG) ? nBands : 1));\n        if( m_pTempBufferForCommonDirectIO == nullptr )\n        {\n            m_pTempBufferForCommonDirectIO =\n                static_cast<GByte *>(\n                    VSI_MALLOC_VERBOSE(nTempBufferForCommonDirectIOSize) );\n            if( m_pTempBufferForCommonDirectIO == nullptr )\n                return CE_Failure;\n        }\n\n        VSILFILE* fp = VSI_TIFFGetVSILFile(TIFFClientdata( m_hTIFF ));\n        FetchBufferDirectIO oFetcher(fp, m_pTempBufferForCommonDirectIO,\n                                     nTempBufferForCommonDirectIOSize);\n\n        return CommonDirectIO( oFetcher,\n                               nXOff, nYOff, nXSize, nYSize,\n                               pData, nBufXSize, nBufYSize,\n                               eBufType,\n                               nBandCount, panBandMap,\n                               nPixelSpace, nLineSpace,\n                              nBandSpace );\n    }\n\n    // Get strip offsets.\n    toff_t *panTIFFOffsets = nullptr;\n    if( !TIFFGetField( m_hTIFF, TIFFTAG_STRIPOFFSETS, &panTIFFOffsets ) ||\n        panTIFFOffsets == nullptr )\n    {\n        return CE_Failure;\n    }\n\n    // Sub-sampling or over-sampling can only be done at last stage.\n    int nReqXSize = nXSize;\n    // Can do sub-sampling at the extraction stage.\n    const int nReqYSize = std::min(nBufYSize, nYSize);\n    void** ppData =\n        static_cast<void **>( VSI_MALLOC_VERBOSE(nReqYSize * sizeof(void*)) );\n    vsi_l_offset* panOffsets =\n        static_cast<vsi_l_offset *>(\n            VSI_MALLOC_VERBOSE(nReqYSize * sizeof(vsi_l_offset)) );\n    size_t* panSizes =\n        static_cast<size_t *>( VSI_MALLOC_VERBOSE(nReqYSize * sizeof(size_t)) );\n    const int nDTSize = GDALGetDataTypeSizeBytes(eDataType);\n    void* pTmpBuffer = nullptr;\n    int eErr = CE_None;\n    int nContigBands = nBands;\n    const int nSrcPixelSize = nDTSize * nContigBands;\n\n    if( ppData == nullptr || panOffsets == nullptr || panSizes == nullptr )\n    {\n        eErr = CE_Failure;\n    }\n    // For now we always allocate a temp buffer as it is easier.\n    else\n        // if( nXSize != nBufXSize || nYSize != nBufYSize ||\n        //   eBufType != eDataType ||\n        //   nPixelSpace != GDALGetDataTypeSizeBytes(eBufType) ||\n        //   check if the user buffer is large enough )\n    {\n        // We need a temporary buffer for over-sampling/sub-sampling\n        // and/or data type conversion.\n        pTmpBuffer = VSI_MALLOC_VERBOSE(nReqXSize * nReqYSize * nSrcPixelSize);\n        if( pTmpBuffer == nullptr )\n            eErr = CE_Failure;\n    }\n\n    // Prepare data extraction.\n    const double dfSrcYInc = nYSize / static_cast<double>( nBufYSize );\n\n    for( int iLine = 0; eErr == CE_None && iLine < nReqYSize; ++iLine )\n    {\n        ppData[iLine] =\n            static_cast<GByte *>(pTmpBuffer) +\n            iLine * nReqXSize * nSrcPixelSize;\n        int nSrcLine = 0;\n        if( nBufYSize < nYSize )  // Sub-sampling in y.\n            nSrcLine = nYOff + static_cast<int>((iLine + 0.5) * dfSrcYInc);\n        else\n            nSrcLine = nYOff + iLine;\n\n        const int nBlockXOff = 0;\n        const int nBlockYOff = nSrcLine / m_nBlockYSize;\n        const int nYOffsetInBlock = nSrcLine % m_nBlockYSize;\n        const int nBlocksPerRow = DIV_ROUND_UP(nRasterXSize, m_nBlockXSize);\n        const int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n\n        panOffsets[iLine] = panTIFFOffsets[nBlockId];\n        if( panOffsets[iLine] == 0)  // We don't support sparse files.\n            eErr = -1;\n\n        panOffsets[iLine] +=\n            (nXOff + nYOffsetInBlock * m_nBlockXSize) * nSrcPixelSize;\n        panSizes[iLine] = nReqXSize * nSrcPixelSize;\n    }\n\n    // Extract data from the file.\n    if( eErr == CE_None )\n    {\n        VSILFILE* fp = VSI_TIFFGetVSILFile(TIFFClientdata( m_hTIFF ));\n        const int nRet =\n            VSIFReadMultiRangeL(nReqYSize, ppData, panOffsets, panSizes, fp);\n        if( nRet != 0 )\n            eErr = CE_Failure;\n    }\n\n    // Byte-swap if necessary.\n    if( eErr == CE_None && TIFFIsByteSwapped(m_hTIFF) )\n    {\n        for( int iLine = 0; iLine < nReqYSize; ++iLine )\n        {\n            if( GDALDataTypeIsComplex(eDataType) )\n                GDALSwapWords( ppData[iLine], nDTSize / 2,\n                               2 * nReqXSize * nContigBands, nDTSize / 2);\n            else\n                GDALSwapWords( ppData[iLine], nDTSize,\n                               nReqXSize * nContigBands, nDTSize);\n        }\n    }\n\n    // Over-sampling/sub-sampling and/or data type conversion.\n    const double dfSrcXInc = nXSize / static_cast<double>( nBufXSize );\n    if( eErr == CE_None && pTmpBuffer != nullptr )\n    {\n        for( int iY = 0; iY < nBufYSize; ++iY )\n        {\n            const int iSrcY =\n                nBufYSize <= nYSize ?\n                iY : static_cast<int>((iY + 0.5) * dfSrcYInc);\n            // Optimization: no resampling, no data type change, number of\n            // bands requested == number of bands and buffer is packed\n            // pixel-interleaved.\n            if( nBufXSize == nXSize && nContigBands == nBandCount &&\n                eDataType == eBufType &&\n                nBandSpace == nDTSize &&\n                nPixelSpace == nBandCount * nBandSpace )\n            {\n                memcpy(\n                    static_cast<GByte *>(pData) + iY * nLineSpace,\n                    ppData[iSrcY],\n                    static_cast<size_t>(nReqXSize * nPixelSpace) );\n            }\n            // Other optimization: no resampling, no data type change,\n            // data type is Byte.\n            else if( nBufXSize == nXSize &&\n                     eDataType == eBufType && eDataType == GDT_Byte )\n            {\n                GByte* pabySrcData = static_cast<GByte *>(ppData[iSrcY]);\n                GByte* pabyDstData =\n                    static_cast<GByte *>(pData) + iY * nLineSpace;\n                if( nBandSpace == 1 && nPixelSpace > nBandCount )\n                {\n                    // Buffer is pixel-interleaved (with some stridding\n                    // between pixels).\n                    CopyContigByteMultiBand( pabySrcData, nSrcPixelSize,\n                                             pabyDstData,\n                                             static_cast<int>(nPixelSpace),\n                                             nBufXSize, nBandCount );\n                }\n                else\n                {\n                    for( int iBand = 0; iBand < nBandCount; ++iBand )\n                    {\n                        GDALCopyWords(\n                            pabySrcData + iBand, GDT_Byte, nSrcPixelSize,\n                            pabyDstData + iBand * nBandSpace,\n                            GDT_Byte, static_cast<int>(nPixelSpace),\n                            nBufXSize );\n                    }\n                }\n            }\n            else  // General case.\n            {\n                for( int iBand = 0; iBand < nBandCount; ++iBand )\n                {\n                    GByte* pabySrcData =\n                        static_cast<GByte *>(ppData[iSrcY]) + iBand * nDTSize;\n                    GByte* pabyDstData =\n                        static_cast<GByte *>(pData) +\n                        iBand * nBandSpace + iY * nLineSpace;\n                    if( eDataType == GDT_Byte && eBufType == GDT_Byte )\n                    {\n                        double dfSrcX = 0.5 * dfSrcXInc;\n                        for( int iX = 0;\n                             iX < nBufXSize;\n                             ++iX, dfSrcX += dfSrcXInc)\n                        {\n                            int iSrcX = static_cast<int>(dfSrcX);\n                            pabyDstData[iX * nPixelSpace] =\n                                pabySrcData[iSrcX * nSrcPixelSize];\n                        }\n                    }\n                    else\n                    {\n                        double dfSrcX = 0.5 * dfSrcXInc;\n                        for( int iX = 0;\n                             iX < nBufXSize;\n                             ++iX, dfSrcX += dfSrcXInc)\n                        {\n                            int iSrcX = static_cast<int>(dfSrcX);\n                            GDALCopyWords( pabySrcData + iSrcX * nSrcPixelSize,\n                                        eDataType, 0,\n                                        pabyDstData + iX * nPixelSpace,\n                                        eBufType, 0, 1);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    CPLFree(pTmpBuffer);\n    CPLFree(ppData);\n    CPLFree(panOffsets);\n    CPLFree(panSizes);\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                         CacheMultiRange()                            */\n/************************************************************************/\n\n#ifdef SUPPORTS_GET_OFFSET_BYTECOUNT\nstatic bool CheckTrailer(const GByte* strileData, vsi_l_offset nStrileSize)\n{\n    GByte abyTrailer[4];\n    memcpy(abyTrailer,strileData + nStrileSize, 4);\n    GByte abyLastBytes[4] = {};\n    if( nStrileSize >= 4 )\n        memcpy(abyLastBytes, strileData + nStrileSize - 4, 4);\n    else\n    {\n        // The last bytes will be zero due to the above {} initialization,\n        // and that's what should be in abyTrailer too when the trailer is\n        // correct.\n        memcpy(abyLastBytes, strileData, static_cast<size_t>(nStrileSize));\n    }\n    return memcmp(abyTrailer, abyLastBytes, 4) == 0;\n}\n#endif\n\nvoid* GTiffRasterBand::CacheMultiRange( int nXOff, int nYOff,\n                                        int nXSize, int nYSize,\n                                        int nBufXSize, int nBufYSize,\n                                        GDALRasterIOExtraArg* psExtraArg )\n{\n    void* pBufferedData = nullptr;\n    // Same logic as in GDALRasterBand::IRasterIO()\n    double dfXOff = nXOff;\n    double dfYOff = nYOff;\n    double dfXSize = nXSize;\n    double dfYSize = nYSize;\n    if( psExtraArg->bFloatingPointWindowValidity )\n    {\n        dfXOff = psExtraArg->dfXOff;\n        dfYOff = psExtraArg->dfYOff;\n        dfXSize = psExtraArg->dfXSize;\n        dfYSize = psExtraArg->dfYSize;\n    }\n    const double dfSrcXInc = dfXSize / static_cast<double>( nBufXSize );\n    const double dfSrcYInc = dfYSize / static_cast<double>( nBufYSize );\n    const double EPS = 1e-10;\n    const int nBlockX1 = static_cast<int>(std::max(0.0, (0+0.5) * dfSrcXInc + dfXOff + EPS)) / nBlockXSize;\n    const int nBlockY1 = static_cast<int>(std::max(0.0, (0+0.5) * dfSrcYInc + dfYOff + EPS)) / nBlockYSize;\n    const int nBlockX2 = static_cast<int>(std::min(static_cast<double>(nRasterXSize - 1), (nBufXSize-1+0.5) * dfSrcXInc + dfXOff + EPS)) / nBlockXSize;\n    const int nBlockY2 = static_cast<int>(std::min(static_cast<double>(nRasterYSize - 1), (nBufYSize-1+0.5) * dfSrcYInc + dfYOff + EPS)) / nBlockYSize;\n#ifdef SUPPORTS_GET_OFFSET_BYTECOUNT\n    const int nBlockXCount = DIV_ROUND_UP(nRasterXSize, nBlockXSize);\n    const int nBlockYCount = DIV_ROUND_UP(nRasterYSize, nBlockYSize);\n    const int nBlockCount = nBlockXCount * nBlockYCount;\n    struct StrileData\n    {\n        vsi_l_offset nOffset;\n        vsi_l_offset nByteCount;\n        bool         bTryMask;\n    };\n    std::map<int, StrileData> oMapStrileToOffsetByteCount;\n\n    // Dedicated method to retrieved the offset and size in an efficient way\n    // when m_bBlockOrderRowMajor and m_bLeaderSizeAsUInt4 conditions are\n    // met.\n    // Except for the last block, we just read the offset from the TIFF offset\n    // array, and retrieve the size in the leader 4 bytes that come before the\n    // payload.\n    auto OptimizedRetrievalOfOffsetSize = [&](int nBlockId,\n                                               vsi_l_offset& nOffset,\n                                               vsi_l_offset& nSize,\n                                               size_t nTotalSize,\n                                               size_t nMaxRawBlockCacheSize)\n    {\n        bool bTryMask = m_poGDS->m_bMaskInterleavedWithImagery;\n        nOffset = TIFFGetStrileOffset(m_poGDS->m_hTIFF, nBlockId);\n        if( nOffset >= 4 )\n        {\n            if( nBlockId == nBlockCount - 1 )\n            {\n                // Special case for the last block. As there is no next block\n                // from which to retrieve an offset, use the good old method\n                // that consists in reading the ByteCount array.\n                if( bTryMask &&\n                    m_poGDS->GetRasterBand(1)->GetMaskBand() &&\n                    m_poGDS->m_poMaskDS )\n                {\n                    auto nMaskOffset = TIFFGetStrileOffset(m_poGDS->m_poMaskDS->m_hTIFF, nBlockId);\n                    if( nMaskOffset )\n                    {\n                        nSize = nMaskOffset + TIFFGetStrileByteCount(m_poGDS->m_poMaskDS->m_hTIFF, nBlockId) - nOffset;\n                    }\n                    else\n                    {\n                        bTryMask = false;\n                    }\n                }\n                if( nSize == 0 )\n                {\n                    nSize = TIFFGetStrileByteCount(m_poGDS->m_hTIFF, nBlockId);\n                }\n                if( nSize && m_poGDS->m_bTrailerRepeatedLast4BytesRepeated )\n                {\n                    nSize += 4;\n                }\n            }\n            else\n            {\n                auto nOffsetNext = TIFFGetStrileOffset(m_poGDS->m_hTIFF, nBlockId + 1);\n                if( nOffsetNext > nOffset )\n                {\n                    nSize = nOffsetNext - nOffset;\n                }\n                else\n                {\n                    // Shouldn't happen for a compliant file\n                    if( nOffsetNext != 0 )\n                    {\n                        CPLDebug(\"GTiff\",\n                                    \"Tile %d is not located after %d\", nBlockId + 1, nBlockId);\n                    }\n                    bTryMask = false;\n                    nSize = TIFFGetStrileByteCount(m_poGDS->m_hTIFF, nBlockId);\n                    if( m_poGDS->m_bTrailerRepeatedLast4BytesRepeated )\n                        nSize += 4;\n                }\n            }\n            if( nSize )\n            {\n                nOffset -= 4;\n                nSize += 4;\n                if( nTotalSize + nSize < nMaxRawBlockCacheSize )\n                {\n                    StrileData data;\n                    data.nOffset = nOffset;\n                    data.nByteCount = nSize;\n                    data.bTryMask = bTryMask;\n                    oMapStrileToOffsetByteCount[nBlockId] = data;\n                }\n            }\n        }\n        else\n        {\n            // Sparse tile\n            StrileData data;\n            data.nOffset = 0;\n            data.nByteCount = 0;\n            data.bTryMask = false;\n            oMapStrileToOffsetByteCount[nBlockId] = data;\n        }\n    };\n\n    // This lambda fills m_poDS->m_oCacheStrileToOffsetByteCount (and\n    // m_poDS->m_poMaskDS->m_oCacheStrileToOffsetByteCount, when there is a mask)\n    // from the temporary oMapStrileToOffsetByteCount.\n    auto FillCacheStrileToOffsetByteCount = [&](\n        const std::vector<vsi_l_offset>& anOffsets,\n        const std::vector<size_t>& anSizes,\n        const std::vector<void*> apData)\n    {\n        CPLAssert( m_poGDS->m_bLeaderSizeAsUInt4 );\n        size_t i = 0;\n        vsi_l_offset nLastOffset = 0;\n        for( const auto& entry: oMapStrileToOffsetByteCount )\n        {\n            const auto nBlockId = entry.first;\n            const auto nOffset = entry.second.nOffset;\n            const auto nSize = entry.second.nByteCount;\n            if( nOffset == 0 )\n            {\n                // Sparse tile\n                m_poGDS->m_oCacheStrileToOffsetByteCount.insert(\n                    nBlockId,\n                    std::pair<vsi_l_offset, vsi_l_offset>(0, 0));\n                continue;\n            }\n\n            if( nOffset < nLastOffset )\n            {\n                // shouldn't happen normally if tiles are sorted\n                i = 0;\n            }\n            nLastOffset = nOffset;\n            while( i < anOffsets.size() && !(\n                    nOffset >= anOffsets[i] &&\n                    nOffset + nSize <= anOffsets[i] + anSizes[i]) )\n            {\n                i++;\n            }\n            CPLAssert( i < anOffsets.size() );\n            CPLAssert( nOffset >= anOffsets[i] );\n            CPLAssert( nOffset + nSize <= anOffsets[i] + anSizes[i] );\n            GUInt32 nSizeFromLeader;\n            memcpy(&nSizeFromLeader,\n                    static_cast<GByte*>(apData[i]) + nOffset - anOffsets[i],\n                    sizeof(nSizeFromLeader));\n            CPL_LSBPTR32(&nSizeFromLeader);\n            bool bOK = true;\n            constexpr int nLeaderSize = 4;\n            const int nTrailerSize =\n                (m_poGDS->m_bTrailerRepeatedLast4BytesRepeated ? 4 : 0);\n            if( nSizeFromLeader > nSize - nLeaderSize - nTrailerSize )\n            {\n                CPLDebug(\"GTiff\",\n                            \"Inconsistent block size from in leader of block %d\", nBlockId);\n                bOK = false;\n            }\n            else if( m_poGDS->m_bTrailerRepeatedLast4BytesRepeated )\n            {\n                // Check trailer consistency\n                const GByte* strileData = static_cast<GByte*>(\n                    apData[i]) + nOffset - anOffsets[i] + nLeaderSize;\n                if( !CheckTrailer(strileData, nSizeFromLeader) )\n                {\n                    CPLDebug(\"GTiff\",\n                            \"Inconsistent trailer of block %d\", nBlockId);\n                    bOK = false;\n                }\n            }\n            if( !bOK )\n            {\n                return false;\n            }\n\n            {\n                const vsi_l_offset nRealOffset = nOffset + nLeaderSize;\n                const vsi_l_offset nRealSize = nSizeFromLeader;\n#ifdef DEBUG_VERBOSE\n                CPLDebug(\"GTiff\", \"Block %d found at offset \"\n                            CPL_FRMT_GUIB \" with size \" CPL_FRMT_GUIB,\n                            nBlockId, nRealOffset, nRealSize);\n#endif\n                m_poGDS->m_oCacheStrileToOffsetByteCount.insert(\n                    nBlockId,\n                    std::pair<vsi_l_offset, vsi_l_offset>(nRealOffset, nRealSize));\n            }\n\n            // Processing of mask\n            if( !(entry.second.bTryMask &&\n                  m_poGDS->m_bMaskInterleavedWithImagery &&\n                  m_poGDS->GetRasterBand(1)->GetMaskBand() &&\n                  m_poGDS->m_poMaskDS ) )\n            {\n                continue;\n            }\n\n            bOK = false;\n            const vsi_l_offset nMaskOffsetWithLeader =\n                nOffset + nLeaderSize + nSizeFromLeader + nTrailerSize;\n            if( nMaskOffsetWithLeader + nLeaderSize <= anOffsets[i] + anSizes[i] )\n            {\n                GUInt32 nMaskSizeFromLeader;\n                memcpy(&nMaskSizeFromLeader,\n                        static_cast<GByte*>(apData[i]) + nMaskOffsetWithLeader - anOffsets[i],\n                        sizeof(nMaskSizeFromLeader));\n                CPL_LSBPTR32(&nMaskSizeFromLeader);\n                if( nMaskOffsetWithLeader + nLeaderSize + nMaskSizeFromLeader + nTrailerSize <= anOffsets[i] + anSizes[i] )\n                {\n                    bOK = true;\n                    if( m_poGDS->m_bTrailerRepeatedLast4BytesRepeated )\n                    {\n                        // Check trailer consistency\n                        const GByte* strileMaskData = static_cast<GByte*>(\n                            apData[i]) + nOffset - anOffsets[i] + nLeaderSize + nSizeFromLeader + nTrailerSize + nLeaderSize;\n                        if( !CheckTrailer(strileMaskData, nMaskSizeFromLeader) )\n                        {\n                            CPLDebug(\"GTiff\",\n                                \"Inconsistent trailer of mask of block %d\", nBlockId);\n                            bOK = false;\n                        }\n                    }\n                }\n                if( bOK )\n                {\n                    const vsi_l_offset nRealOffset = nOffset + nLeaderSize + nSizeFromLeader + nTrailerSize + nLeaderSize;\n                    const vsi_l_offset nRealSize = nMaskSizeFromLeader;\n#ifdef DEBUG_VERBOSE\n                    CPLDebug(\"GTiff\", \"Mask of block %d found at offset \"\n                            CPL_FRMT_GUIB \" with size \" CPL_FRMT_GUIB,\n                            nBlockId, nRealOffset, nRealSize);\n#endif\n\n                    m_poGDS->m_poMaskDS->m_oCacheStrileToOffsetByteCount.insert(\n                        nBlockId,\n                        std::pair<vsi_l_offset, vsi_l_offset>(nRealOffset, nRealSize));\n                }\n            }\n            if( !bOK )\n            {\n                CPLDebug(\"GTiff\",\n                          \"Mask for block %d is not properly interleaved with imagery block\",\n                          nBlockId);\n            }\n        }\n        return true;\n    };\n#endif\n\n    thandle_t th = TIFFClientdata( m_poGDS->m_hTIFF );\n    if( !VSI_TIFFHasCachedRanges(th) )\n    {\n        std::vector< std::pair<vsi_l_offset, size_t> > aOffsetSize;\n        size_t nTotalSize = 0;\n        nBlocksPerRow = DIV_ROUND_UP(nRasterXSize, nBlockXSize);\n        const unsigned int nMaxRawBlockCacheSize =\n            atoi(CPLGetConfigOption(\"GDAL_MAX_RAW_BLOCK_CACHE_SIZE\",\n                                    \"10485760\"));\n        bool bGoOn = true;\n        for( int iY = nBlockY1; bGoOn && iY <= nBlockY2; iY ++)\n        {\n            for( int iX = nBlockX1; bGoOn && iX <= nBlockX2; iX ++)\n            {\n                GDALRasterBlock* poBlock = TryGetLockedBlockRef(iX, iY);\n                if( poBlock != nullptr )\n                {\n                    poBlock->DropLock();\n                    continue;\n                }\n                int nBlockId = iX + iY * nBlocksPerRow;\n                if( m_poGDS->m_nPlanarConfig == PLANARCONFIG_SEPARATE )\n                    nBlockId += (nBand - 1) * m_poGDS->m_nBlocksPerBand;\n                vsi_l_offset nOffset = 0;\n                vsi_l_offset nSize = 0;\n\n#ifdef SUPPORTS_GET_OFFSET_BYTECOUNT\n                if( (m_poGDS->m_nPlanarConfig == PLANARCONFIG_CONTIG || m_poGDS->nBands == 1) &&\n                    !m_poGDS->m_bStreamingIn &&\n                    m_poGDS->m_bBlockOrderRowMajor && m_poGDS->m_bLeaderSizeAsUInt4 )\n                {\n                    OptimizedRetrievalOfOffsetSize(nBlockId, nOffset, nSize, nTotalSize, nMaxRawBlockCacheSize);\n                }\n                else\n#endif\n                {\n                    CPL_IGNORE_RET_VAL(m_poGDS->IsBlockAvailable(nBlockId, &nOffset, &nSize));\n                }\n                if( nSize )\n                {\n                    if( nTotalSize + nSize < nMaxRawBlockCacheSize )\n                    {\n#ifdef DEBUG_VERBOSE\n                        CPLDebug(\"GTiff\",\n                                 \"Precaching for block (%d, %d), \"\n                                 CPL_FRMT_GUIB \"-\" CPL_FRMT_GUIB,\n                                 iX, iY,\n                                 nOffset,\n                                 nOffset + static_cast<size_t>(nSize) - 1);\n#endif\n                        aOffsetSize.push_back(\n                            std::pair<vsi_l_offset, size_t>\n                                (nOffset, static_cast<size_t>(nSize)) );\n                        nTotalSize += static_cast<size_t>(nSize);\n                    }\n                    else\n                    {\n                        bGoOn = false;\n                    }\n                }\n            }\n        }\n\n        std::sort(aOffsetSize.begin(), aOffsetSize.end());\n\n        if( nTotalSize > 0 )\n        {\n            pBufferedData = VSI_MALLOC_VERBOSE(nTotalSize);\n            if( pBufferedData )\n            {\n                std::vector<vsi_l_offset> anOffsets;\n                std::vector<size_t> anSizes;\n                std::vector<void*> apData;\n                anOffsets.push_back(aOffsetSize[0].first);\n                apData.push_back(static_cast<GByte *>(pBufferedData));\n                size_t nChunkSize = aOffsetSize[0].second;\n                size_t nAccOffset = 0;\n                // Try to merge contiguous or slightly overlapping ranges\n                for( size_t i = 0; i < aOffsetSize.size()-1; i++ )\n                {\n                    if ( aOffsetSize[i].first < aOffsetSize[i+1].first &&\n                         aOffsetSize[i].first + aOffsetSize[i].second >= aOffsetSize[i+1].first )\n                    {\n                        const auto overlap = aOffsetSize[i].first + aOffsetSize[i].second - aOffsetSize[i+1].first;\n                        // That should always be the case for well behaved\n                        // TIFF files.\n                        if( aOffsetSize[i+1].second > overlap )\n                        {\n                            nChunkSize += static_cast<size_t>(\n                                aOffsetSize[i+1].second - overlap);\n                        }\n                    }\n                    else \n                    {\n                        //terminate current block\n                        anSizes.push_back(nChunkSize);\n#ifdef DEBUG_VERBOSE\n                        CPLDebug(\"GTiff\", \"Requesting range [\" CPL_FRMT_GUIB \"-\" CPL_FRMT_GUIB \"]\",\n                                 anOffsets.back(), anOffsets.back() + anSizes.back() - 1);\n#endif\n                        nAccOffset += nChunkSize;\n                        //start a new range\n                        anOffsets.push_back(aOffsetSize[i+1].first);\n                        apData.push_back(static_cast<GByte*>(pBufferedData) + nAccOffset);\n                        nChunkSize = aOffsetSize[i+1].second;\n                    }\n                }\n                //terminate last block \n                anSizes.push_back(nChunkSize);\n#ifdef DEBUG_VERBOSE\n                CPLDebug(\"GTiff\", \"Requesting range [\" CPL_FRMT_GUIB \"-\" CPL_FRMT_GUIB \"]\",\n                            anOffsets.back(), anOffsets.back() + anSizes.back() - 1);\n#endif\n\n                VSILFILE* fp = VSI_TIFFGetVSILFile(th);\n\n\n                if( VSIFReadMultiRangeL(\n                                    static_cast<int>(anSizes.size()),\n                                    &apData[0],\n                                    &anOffsets[0],\n                                    &anSizes[0],\n                                    fp ) == 0 )\n                {\n#ifdef SUPPORTS_GET_OFFSET_BYTECOUNT\n                    if( !oMapStrileToOffsetByteCount.empty() &&\n                        !FillCacheStrileToOffsetByteCount(\n                                                anOffsets, anSizes, apData) )\n                    {\n                        // Retry without optimization\n                        CPLFree(pBufferedData);\n                        m_poGDS->m_bLeaderSizeAsUInt4 = false;\n                        void* pRet = CacheMultiRange(\n                            nXOff, nYOff, nXSize, nYSize,\n                            nBufXSize, nBufYSize, psExtraArg );\n                        m_poGDS->m_bLeaderSizeAsUInt4 = true;\n                        return pRet;\n                    }\n\n#endif\n                    VSI_TIFFSetCachedRanges( th,\n                                             static_cast<int>(anSizes.size()),\n                                             &apData[0],\n                                             &anOffsets[0],\n                                             &anSizes[0] );\n                }\n            }\n        }\n    }\n    return pBufferedData;\n}\n\n/************************************************************************/\n/*                            IRasterIO()                               */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::IRasterIO( GDALRWFlag eRWFlag,\n                                   int nXOff, int nYOff, int nXSize, int nYSize,\n                                   void * pData, int nBufXSize, int nBufYSize,\n                                   GDALDataType eBufType,\n                                   GSpacing nPixelSpace, GSpacing nLineSpace,\n                                   GDALRasterIOExtraArg* psExtraArg )\n{\n#if DEBUG_VERBOSE\n    CPLDebug( \"GTiff\", \"RasterIO(%d, %d, %d, %d, %d, %d)\",\n              nXOff, nYOff, nXSize, nYSize, nBufXSize, nBufYSize );\n#endif\n\n    // Try to pass the request to the most appropriate overview dataset.\n    if( nBufXSize < nXSize && nBufYSize < nYSize )\n    {\n        int bTried = FALSE;\n        ++m_poGDS->m_nJPEGOverviewVisibilityCounter;\n        const CPLErr eErr =\n            TryOverviewRasterIO( eRWFlag,\n                                 nXOff, nYOff, nXSize, nYSize,\n                                 pData, nBufXSize, nBufYSize,\n                                 eBufType,\n                                 nPixelSpace, nLineSpace,\n                                 psExtraArg,\n                                 &bTried );\n        --m_poGDS->m_nJPEGOverviewVisibilityCounter;\n        if( bTried )\n            return eErr;\n    }\n\n    if( m_poGDS->m_eVirtualMemIOUsage != GTiffDataset::VirtualMemIOEnum::NO )\n    {\n        const int nErr = m_poGDS->VirtualMemIO(\n            eRWFlag, nXOff, nYOff, nXSize, nYSize,\n            pData, nBufXSize, nBufYSize, eBufType,\n            1, &nBand, nPixelSpace, nLineSpace, 0, psExtraArg);\n        if( nErr >= 0 )\n            return static_cast<CPLErr>(nErr);\n    }\n    if( m_poGDS->m_bDirectIO )\n    {\n        int nErr = DirectIO(eRWFlag, nXOff, nYOff, nXSize, nYSize,\n                            pData, nBufXSize, nBufYSize, eBufType,\n                            nPixelSpace, nLineSpace, psExtraArg);\n        if( nErr >= 0 )\n            return static_cast<CPLErr>(nErr);\n    }\n\n    void* pBufferedData = nullptr;\n    if( m_poGDS->eAccess == GA_ReadOnly &&\n        eRWFlag == GF_Read &&\n        m_poGDS->HasOptimizedReadMultiRange() )\n    {\n        GTiffRasterBand* poBandForCache = this;\n\n#ifdef SUPPORTS_GET_OFFSET_BYTECOUNT\n        if( !m_poGDS->m_bStreamingIn &&\n            m_poGDS->m_bBlockOrderRowMajor &&\n            m_poGDS->m_bLeaderSizeAsUInt4 &&\n            m_poGDS->m_bMaskInterleavedWithImagery &&\n            m_poGDS->m_poImageryDS )\n        {\n            poBandForCache = cpl::down_cast<GTiffRasterBand*>(\n                m_poGDS->m_poImageryDS->GetRasterBand(1));\n        }\n#endif\n        pBufferedData = poBandForCache->CacheMultiRange(\n                                        nXOff, nYOff, nXSize, nYSize,\n                                        nBufXSize, nBufYSize,\n                                        psExtraArg);\n    }\n\n    if( m_poGDS->nBands != 1 &&\n        m_poGDS->m_nPlanarConfig == PLANARCONFIG_CONTIG &&\n        eRWFlag == GF_Read &&\n        nXSize == nBufXSize && nYSize == nBufYSize )\n    {\n        const int nBlockX1 = nXOff / nBlockXSize;\n        const int nBlockY1 = nYOff / nBlockYSize;\n        const int nBlockX2 = (nXOff + nXSize - 1) / nBlockXSize;\n        const int nBlockY2 = (nYOff + nYSize - 1) / nBlockYSize;\n        const int nXBlocks = nBlockX2 - nBlockX1 + 1;\n        const int nYBlocks = nBlockY2 - nBlockY1 + 1;\n        const GIntBig nRequiredMem =\n            static_cast<GIntBig>(m_poGDS->nBands) * nXBlocks * nYBlocks *\n            nBlockXSize * nBlockYSize *\n            GDALGetDataTypeSizeBytes(eDataType);\n        if( nRequiredMem > GDALGetCacheMax64() )\n        {\n            if( !m_poGDS->m_bHasWarnedDisableAggressiveBandCaching )\n            {\n                CPLDebug( \"GTiff\",\n                          \"Disable aggressive band caching. \"\n                          \"Cache not big enough. \"\n                          \"At least \" CPL_FRMT_GIB \" bytes necessary\",\n                          nRequiredMem );\n                m_poGDS->m_bHasWarnedDisableAggressiveBandCaching = true;\n            }\n            m_poGDS->m_bLoadingOtherBands = true;\n        }\n    }\n\n    ++m_poGDS->m_nJPEGOverviewVisibilityCounter;\n    const CPLErr eErr =\n        GDALPamRasterBand::IRasterIO( eRWFlag, nXOff, nYOff, nXSize, nYSize,\n                                      pData, nBufXSize, nBufYSize, eBufType,\n                                      nPixelSpace, nLineSpace, psExtraArg );\n    --m_poGDS->m_nJPEGOverviewVisibilityCounter;\n\n    m_poGDS->m_bLoadingOtherBands = false;\n\n    if( pBufferedData )\n    {\n        VSIFree( pBufferedData );\n        VSI_TIFFSetCachedRanges( TIFFClientdata( m_poGDS->m_hTIFF ),\n                                 0, nullptr, nullptr, nullptr );\n    }\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                       IGetDataCoverageStatus()                       */\n/************************************************************************/\n\nint GTiffRasterBand::IGetDataCoverageStatus( int nXOff, int nYOff,\n                                             int nXSize, int nYSize,\n                                             int nMaskFlagStop,\n                                             double* pdfDataPct)\n{\n    if( eAccess == GA_Update )\n        m_poGDS->FlushCache();\n\n    const int iXBlockStart = nXOff / nBlockXSize;\n    const int iXBlockEnd = (nXOff + nXSize - 1) / nBlockXSize;\n    const int iYBlockStart = nYOff / nBlockYSize;\n    const int iYBlockEnd = (nYOff + nYSize - 1) / nBlockYSize;\n    int nStatus = 0;\n    VSILFILE* fp = VSI_TIFFGetVSILFile(TIFFClientdata( m_poGDS->m_hTIFF ));\n    GIntBig nPixelsData = 0;\n    // We need to compute this here as it might not have been computed\n    // previously (which sucks...)\n    nBlocksPerRow = DIV_ROUND_UP(nRasterXSize, nBlockXSize);\n    for( int iY = iYBlockStart; iY <= iYBlockEnd; ++iY )\n    {\n        for( int iX = iXBlockStart; iX <= iXBlockEnd; ++iX )\n        {\n            const int nBlockIdBand0 =\n                iX + iY * nBlocksPerRow;\n            int nBlockId = nBlockIdBand0;\n            if( m_poGDS->m_nPlanarConfig == PLANARCONFIG_SEPARATE )\n                nBlockId = nBlockIdBand0 + (nBand - 1) * m_poGDS->m_nBlocksPerBand;\n            vsi_l_offset nOffset = 0;\n            vsi_l_offset nLength = 0;\n            bool bHasData = false;\n            if( !m_poGDS->IsBlockAvailable(nBlockId,&nOffset,&nLength) )\n            {\n                nStatus |= GDAL_DATA_COVERAGE_STATUS_EMPTY;\n            }\n            else\n            {\n                if( m_poGDS->m_nCompression == COMPRESSION_NONE &&\n                    m_poGDS->eAccess == GA_ReadOnly &&\n                    (!m_bNoDataSet || m_dfNoDataValue == 0.0) )\n                {\n                    VSIRangeStatus eStatus =\n                          VSIFGetRangeStatusL( fp, nOffset, nLength );\n                    if( eStatus == VSI_RANGE_STATUS_HOLE )\n                    {\n                        nStatus |= GDAL_DATA_COVERAGE_STATUS_EMPTY;\n                    }\n                    else\n                    {\n                        bHasData = true;\n                    }\n                }\n                else\n                {\n                    bHasData = true;\n                }\n            }\n            if( bHasData )\n            {\n                const int nXBlockRight =\n                    ( iX * nBlockXSize > INT_MAX - nBlockXSize ) ? INT_MAX :\n                    (iX + 1) * nBlockXSize;\n                const int nYBlockBottom =\n                    ( iY * nBlockYSize > INT_MAX - nBlockYSize ) ? INT_MAX :\n                    (iY + 1) * nBlockYSize;\n\n                nPixelsData +=\n                    (std::min( nXBlockRight, nXOff + nXSize ) -\n                     std::max( iX * nBlockXSize, nXOff )) *\n                    (std::min( nYBlockBottom, nYOff + nYSize ) -\n                     std::max( iY * nBlockYSize, nYOff ));\n                nStatus |= GDAL_DATA_COVERAGE_STATUS_DATA;\n            }\n            if( nMaskFlagStop != 0 && (nMaskFlagStop & nStatus) != 0 )\n            {\n                if( pdfDataPct )\n                    *pdfDataPct = -1.0;\n                return nStatus;\n            }\n        }\n    }\n    if( pdfDataPct )\n        *pdfDataPct =\n          100.0 * nPixelsData /\n          (static_cast<GIntBig>(nXSize) * nYSize);\n    return nStatus;\n}\n\n/************************************************************************/\n/*                             ReadStrile()                             */\n/************************************************************************/\n\nbool GTiffDataset::ReadStrile(int nBlockId,\n                              void* pOutputBuffer,\n                              GPtrDiff_t nBlockReqSize)\n{\n#ifdef SUPPORTS_GET_OFFSET_BYTECOUNT\n    std::pair<vsi_l_offset, vsi_l_offset> oPair;\n    if( m_oCacheStrileToOffsetByteCount.tryGet(nBlockId, oPair) )\n    {\n        // For the mask, use the parent TIFF handle to get cached ranges\n        auto th = TIFFClientdata(\n            m_poImageryDS && m_bMaskInterleavedWithImagery ?\n                m_poImageryDS->m_hTIFF : m_hTIFF);\n        void* pInputBuffer = VSI_TIFFGetCachedRange( th, oPair.first,\n                                                static_cast<size_t>(oPair.second) );\n        if( pInputBuffer &&\n            TIFFReadFromUserBuffer( m_hTIFF, nBlockId,\n                                    pInputBuffer, static_cast<size_t>(oPair.second),\n                                    pOutputBuffer, nBlockReqSize ) )\n        {\n            return true;\n        }\n    }\n#endif\n\n    // For debugging\n    if( m_poBaseDS )\n        m_poBaseDS->m_bHasUsedReadEncodedAPI = true;\n    else\n        m_bHasUsedReadEncodedAPI = true;\n\n    if( TIFFIsTiled( m_hTIFF ) )\n    {\n        if( TIFFReadEncodedTile( m_hTIFF, nBlockId, pOutputBuffer,\n                                    nBlockReqSize ) == -1\n            && !m_bIgnoreReadErrors )\n        {\n            CPLError( CE_Failure, CPLE_AppDefined,\n                        \"TIFFReadEncodedTile() failed.\" );\n\n            return false;\n        }\n    }\n    else\n    {\n        if( TIFFReadEncodedStrip( m_hTIFF, nBlockId, pOutputBuffer,\n                                    nBlockReqSize ) == -1\n            && !m_bIgnoreReadErrors )\n        {\n            CPLError( CE_Failure, CPLE_AppDefined,\n                    \"TIFFReadEncodedStrip() failed.\" );\n\n            return false;\n        }\n    }\n    return true;\n}\n\n/************************************************************************/\n/*                             IReadBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::IReadBlock( int nBlockXOff, int nBlockYOff,\n                                    void * pImage )\n\n{\n    m_poGDS->Crystalize();\n\n    GPtrDiff_t nBlockBufSize = 0;\n    if( TIFFIsTiled(m_poGDS->m_hTIFF) )\n    {\n        nBlockBufSize = static_cast<GPtrDiff_t>(TIFFTileSize( m_poGDS->m_hTIFF ));\n    }\n    else\n    {\n        CPLAssert( nBlockXOff == 0 );\n        nBlockBufSize = static_cast<GPtrDiff_t>(TIFFStripSize( m_poGDS->m_hTIFF ));\n    }\n\n    CPLAssert(nBlocksPerRow != 0);\n    const int nBlockIdBand0 =\n        nBlockXOff + nBlockYOff * nBlocksPerRow;\n    int nBlockId = nBlockIdBand0;\n    if( m_poGDS->m_nPlanarConfig == PLANARCONFIG_SEPARATE )\n        nBlockId = nBlockIdBand0 + (nBand - 1) * m_poGDS->m_nBlocksPerBand;\n\n/* -------------------------------------------------------------------- */\n/*      The bottom most partial tiles and strips are sometimes only     */\n/*      partially encoded.  This code reduces the requested data so     */\n/*      an error won't be reported in this case. (#1179)                */\n/* -------------------------------------------------------------------- */\n    auto nBlockReqSize = nBlockBufSize;\n\n    if( nBlockYOff * nBlockYSize > nRasterYSize - nBlockYSize )\n    {\n        nBlockReqSize = (nBlockBufSize / nBlockYSize)\n            * (nBlockYSize - static_cast<int>(\n                (static_cast<GIntBig>(nBlockYOff + 1) * nBlockYSize)\n                    % nRasterYSize));\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Handle the case of a strip or tile that doesn't exist yet.      */\n/*      Just set to zeros and return.                                   */\n/* -------------------------------------------------------------------- */\n    vsi_l_offset nOffset = 0;\n    bool bErrOccurred = false;\n    if( nBlockId != m_poGDS->m_nLoadedBlock &&\n        !m_poGDS->IsBlockAvailable(nBlockId, &nOffset, nullptr, &bErrOccurred) )\n    {\n        NullBlock( pImage );\n        if( bErrOccurred )\n            return CE_Failure;\n        return CE_None;\n    }\n\n    if( m_poGDS->m_bStreamingIn &&\n        !(m_poGDS->nBands > 1 &&\n          m_poGDS->m_nPlanarConfig == PLANARCONFIG_CONTIG &&\n          nBlockId == m_poGDS->m_nLoadedBlock) )\n    {\n        if( nOffset < VSIFTellL(m_poGDS->m_fpL) )\n        {\n            ReportError( CE_Failure, CPLE_NotSupported,\n                      \"Trying to load block %d at offset \" CPL_FRMT_GUIB\n                      \" whereas current pos is \" CPL_FRMT_GUIB\n                      \" (backward read not supported)\",\n                      nBlockId, static_cast<GUIntBig>(nOffset),\n                      static_cast<GUIntBig>(VSIFTellL(m_poGDS->m_fpL)) );\n            return CE_Failure;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Handle simple case (separate, onesampleperpixel)                */\n/* -------------------------------------------------------------------- */\n    CPLErr eErr = CE_None;\n    if( m_poGDS->nBands == 1\n        || m_poGDS->m_nPlanarConfig == PLANARCONFIG_SEPARATE )\n    {\n        if( nBlockReqSize < nBlockBufSize )\n            memset( pImage, 0, nBlockBufSize );\n\n        if( !m_poGDS->ReadStrile(nBlockId, pImage, nBlockReqSize) )\n        {\n            memset( pImage, 0, nBlockBufSize );\n            return CE_Failure;\n        }\n    }\n    else\n    {\n/* -------------------------------------------------------------------- */\n/*      Load desired block                                              */\n/* -------------------------------------------------------------------- */\n        eErr = m_poGDS->LoadBlockBuf( nBlockId );\n        if( eErr != CE_None )\n        {\n            memset( pImage, 0,\n                    static_cast<GPtrDiff_t>(nBlockXSize) * nBlockYSize\n                    * GDALGetDataTypeSizeBytes(eDataType) );\n            return eErr;\n        }\n\n        const int nWordBytes = m_poGDS->m_nBitsPerSample / 8;\n        GByte* pabyImage = m_poGDS->m_pabyBlockBuf + (nBand - 1) * nWordBytes;\n\n        GDALCopyWords64(pabyImage, eDataType, m_poGDS->nBands * nWordBytes,\n                    pImage, eDataType, nWordBytes,\n                    static_cast<GPtrDiff_t>(nBlockXSize) * nBlockYSize);\n\n        eErr = FillCacheForOtherBands(nBlockXOff, nBlockYOff);\n    }\n\n#ifdef SUPPORTS_GET_OFFSET_BYTECOUNT\n    CacheMaskForBlock(nBlockXOff,nBlockYOff);\n#endif\n    return eErr;\n}\n\n/************************************************************************/\n/*                           CacheMaskForBlock()                       */\n/************************************************************************/\n\n#ifdef SUPPORTS_GET_OFFSET_BYTECOUNT\nvoid GTiffRasterBand::CacheMaskForBlock( int nBlockXOff, int nBlockYOff )\n\n{\n    // Preload mask data if layout compatible and we have cached ranges\n    if( m_poGDS->m_bMaskInterleavedWithImagery &&\n        m_poGDS->GetRasterBand(1)->GetMaskBand() &&\n        m_poGDS->m_poMaskDS &&\n        VSI_TIFFHasCachedRanges( TIFFClientdata(m_poGDS->m_hTIFF) ) &&\n        m_poGDS->m_poMaskDS->m_oCacheStrileToOffsetByteCount.contains(\n            nBlockXOff + nBlockYOff * nBlocksPerRow) )\n    {\n        GDALRasterBlock *poBlock = m_poGDS->m_poMaskDS->GetRasterBand(1)->\n            GetLockedBlockRef(nBlockXOff,nBlockYOff);\n        if( poBlock )\n            poBlock->DropLock();\n    }\n}\n#endif\n\n/************************************************************************/\n/*                       FillCacheForOtherBands()                       */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::FillCacheForOtherBands( int nBlockXOff, int nBlockYOff )\n\n{\n/* -------------------------------------------------------------------- */\n/*      In the fairly common case of pixel interleaved 8bit data        */\n/*      that is multi-band, lets push the rest of the data into the     */\n/*      block cache too, to avoid (hopefully) having to redecode it.    */\n/*                                                                      */\n/*      Our following logic actually depends on the fact that the       */\n/*      this block is already loaded, so subsequent calls will end      */\n/*      up back in this method and pull from the loaded block.          */\n/*                                                                      */\n/*      Be careful not entering this portion of code from               */\n/*      the other bands, otherwise we'll get very deep nested calls     */\n/*      and O(nBands^2) performance !                                   */\n/*                                                                      */\n/*      If there are many bands and the block cache size is not big     */\n/*      enough to accommodate the size of all the blocks, don't enter   */\n/* -------------------------------------------------------------------- */\n    CPLErr eErr = CE_None;\n    if( m_poGDS->nBands != 1 &&\n        m_poGDS->nBands < 128 && // avoid caching for datasets with too many bands\n        !m_poGDS->m_bLoadingOtherBands &&\n        static_cast<GPtrDiff_t>(nBlockXSize) * nBlockYSize * GDALGetDataTypeSizeBytes(eDataType) <\n        GDALGetCacheMax64() / m_poGDS->nBands )\n    {\n        m_poGDS->m_bLoadingOtherBands = true;\n\n        for( int iOtherBand = 1; iOtherBand <= m_poGDS->nBands; ++iOtherBand )\n        {\n            if( iOtherBand == nBand )\n                continue;\n\n            GDALRasterBlock *poBlock = m_poGDS->GetRasterBand(iOtherBand)->\n                GetLockedBlockRef(nBlockXOff,nBlockYOff);\n            if( poBlock == nullptr )\n            {\n                eErr = CE_Failure;\n                break;\n            }\n            poBlock->DropLock();\n        }\n\n        m_poGDS->m_bLoadingOtherBands = false;\n    }\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                            IWriteBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::IWriteBlock( int nBlockXOff, int nBlockYOff,\n                                     void * pImage )\n\n{\n    m_poGDS->Crystalize();\n\n    if( m_poGDS->m_bDebugDontWriteBlocks )\n        return CE_None;\n\n    if( m_poGDS->m_bWriteError )\n    {\n        // Report as an error if a previously loaded block couldn't be written\n        // correctly.\n        return CE_Failure;\n    }\n\n    CPLAssert(nBlocksPerRow != 0);\n\n/* -------------------------------------------------------------------- */\n/*      Handle case of \"separate\" images                                */\n/* -------------------------------------------------------------------- */\n    if( m_poGDS->m_nPlanarConfig == PLANARCONFIG_SEPARATE\n        || m_poGDS->nBands == 1 )\n    {\n        const int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow\n            + (nBand - 1) * m_poGDS->m_nBlocksPerBand;\n\n        const CPLErr eErr =\n            m_poGDS->WriteEncodedTileOrStrip(nBlockId, pImage, true);\n\n        return eErr;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Handle case of pixel interleaved (PLANARCONFIG_CONTIG) images.  */\n/* -------------------------------------------------------------------- */\n    const int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n     // Why 10 ? Somewhat arbitrary\n    constexpr int MAX_BANDS_FOR_DIRTY_CHECK = 10;\n    GDALRasterBlock* apoBlocks[MAX_BANDS_FOR_DIRTY_CHECK] = {};\n    const int nBands = m_poGDS->nBands;\n    bool bAllBlocksDirty = false;\n\n/* -------------------------------------------------------------------- */\n/*     If all blocks are cached and dirty then we do not need to reload */\n/*     the tile/strip from disk                                         */\n/* -------------------------------------------------------------------- */\n    if( nBands <= MAX_BANDS_FOR_DIRTY_CHECK )\n    {\n        bAllBlocksDirty = true;\n        for( int iBand = 0; iBand < nBands; ++iBand )\n        {\n            if( iBand + 1 != nBand )\n            {\n                apoBlocks[iBand] =\n                    cpl::down_cast<GTiffRasterBand *>(\n                        m_poGDS->GetRasterBand( iBand + 1 ))\n                            ->TryGetLockedBlockRef( nBlockXOff, nBlockYOff );\n\n                if( apoBlocks[iBand] == nullptr )\n                {\n                    bAllBlocksDirty = false;\n                }\n                else if( !apoBlocks[iBand]->GetDirty() )\n                {\n                    apoBlocks[iBand]->DropLock();\n                    apoBlocks[iBand] = nullptr;\n                    bAllBlocksDirty = false;\n                }\n            }\n            else\n                apoBlocks[iBand] = nullptr;\n        }\n#if DEBUG_VERBOSE\n        if( bAllBlocksDirty )\n            CPLDebug(\"GTIFF\", \"Saved reloading block %d\", nBlockId);\n        else\n            CPLDebug(\"GTIFF\", \"Must reload block %d\", nBlockId);\n#endif\n    }\n\n    {\n        const CPLErr eErr = m_poGDS->LoadBlockBuf( nBlockId, !bAllBlocksDirty );\n        if( eErr != CE_None )\n        {\n            if( nBands <= MAX_BANDS_FOR_DIRTY_CHECK )\n            {\n                for( int iBand = 0; iBand < nBands; ++iBand )\n                {\n                    if( apoBlocks[iBand] != nullptr )\n                        apoBlocks[iBand]->DropLock();\n                }\n            }\n            return eErr;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      On write of pixel interleaved data, we might as well flush      */\n/*      out any other bands that are dirty in our cache.  This is       */\n/*      especially helpful when writing compressed blocks.              */\n/* -------------------------------------------------------------------- */\n    const int nWordBytes = m_poGDS->m_nBitsPerSample / 8;\n\n    for( int iBand = 0; iBand < nBands; ++iBand )\n    {\n        const GByte *pabyThisImage = nullptr;\n        GDALRasterBlock *poBlock = nullptr;\n\n        if( iBand + 1 == nBand )\n        {\n            pabyThisImage = static_cast<GByte *>( pImage );\n        }\n        else\n        {\n            if( nBands <= MAX_BANDS_FOR_DIRTY_CHECK )\n                poBlock = apoBlocks[iBand];\n            else\n                poBlock = cpl::down_cast<GTiffRasterBand *>(\n                    m_poGDS->GetRasterBand( iBand + 1 ))\n                        ->TryGetLockedBlockRef( nBlockXOff, nBlockYOff );\n\n            if( poBlock == nullptr )\n                continue;\n\n            if( !poBlock->GetDirty() )\n            {\n                poBlock->DropLock();\n                continue;\n            }\n\n            pabyThisImage = static_cast<GByte *>( poBlock->GetDataRef() );\n        }\n\n        GByte *pabyOut = m_poGDS->m_pabyBlockBuf + iBand*nWordBytes;\n\n        GDALCopyWords64(pabyThisImage, eDataType, nWordBytes,\n                      pabyOut, eDataType, nWordBytes * nBands,\n                      static_cast<GPtrDiff_t>(nBlockXSize) * nBlockYSize);\n\n        if( poBlock != nullptr )\n        {\n            poBlock->MarkClean();\n            poBlock->DropLock();\n        }\n    }\n\n    if( bAllBlocksDirty )\n    {\n        // We can synchronously write the block now.\n        const CPLErr eErr =\n            m_poGDS->WriteEncodedTileOrStrip(nBlockId, m_poGDS->m_pabyBlockBuf, true);\n        m_poGDS->m_bLoadedBlockDirty = false;\n        return eErr;\n    }\n\n    m_poGDS->m_bLoadedBlockDirty = true;\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                           SetDescription()                           */\n/************************************************************************/\n\nvoid GTiffRasterBand::SetDescription( const char *pszDescription )\n\n{\n    m_poGDS->LoadGeoreferencingAndPamIfNeeded();\n\n    if( pszDescription == nullptr )\n        pszDescription = \"\";\n\n    if( m_osDescription != pszDescription )\n        m_poGDS->m_bMetadataChanged = true;\n\n    m_osDescription = pszDescription;\n}\n\n/************************************************************************/\n/*                           GetDescription()                           */\n/************************************************************************/\n\nconst char *GTiffRasterBand::GetDescription() const\n{\n    m_poGDS->LoadGeoreferencingAndPamIfNeeded();\n\n    return m_osDescription;\n}\n\n/************************************************************************/\n/*                             GetOffset()                              */\n/************************************************************************/\n\ndouble GTiffRasterBand::GetOffset( int *pbSuccess )\n\n{\n    m_poGDS->LoadGeoreferencingAndPamIfNeeded();\n\n    if( pbSuccess )\n        *pbSuccess = m_bHaveOffsetScale;\n    return m_dfOffset;\n}\n\n/************************************************************************/\n/*                             SetOffset()                              */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::SetOffset( double dfNewValue )\n\n{\n    m_poGDS->LoadGeoreferencingAndPamIfNeeded();\n\n    if( !m_bHaveOffsetScale || dfNewValue != m_dfOffset )\n        m_poGDS->m_bMetadataChanged = true;\n\n    m_bHaveOffsetScale = true;\n    m_dfOffset = dfNewValue;\n    return CE_None;\n}\n\n/************************************************************************/\n/*                              GetScale()                              */\n/************************************************************************/\n\ndouble GTiffRasterBand::GetScale( int *pbSuccess )\n\n{\n    m_poGDS->LoadGeoreferencingAndPamIfNeeded();\n\n    if( pbSuccess )\n        *pbSuccess = m_bHaveOffsetScale;\n    return m_dfScale;\n}\n\n/************************************************************************/\n/*                              SetScale()                              */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::SetScale( double dfNewValue )\n\n{\n    m_poGDS->LoadGeoreferencingAndPamIfNeeded();\n\n    if( !m_bHaveOffsetScale || dfNewValue != m_dfScale )\n        m_poGDS->m_bMetadataChanged = true;\n\n    m_bHaveOffsetScale = true;\n    m_dfScale = dfNewValue;\n    return CE_None;\n}\n\n/************************************************************************/\n/*                            GetUnitType()                             */\n/************************************************************************/\n\nconst char* GTiffRasterBand::GetUnitType()\n\n{\n    m_poGDS->LoadGeoreferencingAndPamIfNeeded();\n    if( m_osUnitType.empty() )\n    {\n        m_poGDS->LookForProjection();\n        if( m_poGDS->m_pszVertUnit )\n            return m_poGDS->m_pszVertUnit;\n    }\n\n    return m_osUnitType.c_str();\n}\n\n/************************************************************************/\n/*                           SetUnitType()                              */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::SetUnitType( const char* pszNewValue )\n\n{\n    m_poGDS->LoadGeoreferencingAndPamIfNeeded();\n\n    CPLString osNewValue(pszNewValue ? pszNewValue : \"\");\n    if( osNewValue.compare(m_osUnitType) != 0 )\n        m_poGDS->m_bMetadataChanged = true;\n\n    m_osUnitType = osNewValue;\n    return CE_None;\n}\n\n/************************************************************************/\n/*                      GetMetadataDomainList()                         */\n/************************************************************************/\n\nchar **GTiffRasterBand::GetMetadataDomainList()\n{\n    m_poGDS->LoadGeoreferencingAndPamIfNeeded();\n\n    return CSLDuplicate(m_oGTiffMDMD.GetDomainList());\n}\n\n/************************************************************************/\n/*                            GetMetadata()                             */\n/************************************************************************/\n\nchar **GTiffRasterBand::GetMetadata( const char * pszDomain )\n\n{\n    if( pszDomain == nullptr || !EQUAL(pszDomain, \"IMAGE_STRUCTURE\") )\n    {\n        m_poGDS->LoadGeoreferencingAndPamIfNeeded();\n    }\n\n    return m_oGTiffMDMD.GetMetadata( pszDomain );\n}\n\n/************************************************************************/\n/*                            SetMetadata()                             */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::SetMetadata( char ** papszMD, const char *pszDomain )\n\n{\n    m_poGDS->LoadGeoreferencingAndPamIfNeeded();\n\n    if( m_poGDS->m_bStreamingOut && m_poGDS->m_bCrystalized )\n    {\n        ReportError( CE_Failure, CPLE_NotSupported,\n                  \"Cannot modify metadata at that point in a streamed \"\n                  \"output file\" );\n        return CE_Failure;\n    }\n\n    if( pszDomain == nullptr || !EQUAL(pszDomain,\"_temporary_\") )\n    {\n        if( papszMD != nullptr || GetMetadata(pszDomain) != nullptr )\n        {\n            m_poGDS->m_bMetadataChanged = true;\n            // Cancel any existing metadata from PAM file.\n            if( eAccess == GA_Update &&\n                GDALPamRasterBand::GetMetadata(pszDomain) != nullptr )\n                GDALPamRasterBand::SetMetadata(nullptr, pszDomain);\n        }\n    }\n\n    return m_oGTiffMDMD.SetMetadata( papszMD, pszDomain );\n}\n\n/************************************************************************/\n/*                          GetMetadataItem()                           */\n/************************************************************************/\n\nconst char *GTiffRasterBand::GetMetadataItem( const char * pszName,\n                                              const char * pszDomain )\n\n{\n    if( pszDomain == nullptr || !EQUAL(pszDomain, \"IMAGE_STRUCTURE\") )\n    {\n        m_poGDS->LoadGeoreferencingAndPamIfNeeded();\n    }\n\n    if( pszName != nullptr && pszDomain != nullptr && EQUAL(pszDomain, \"TIFF\") )\n    {\n        int nBlockXOff = 0;\n        int nBlockYOff = 0;\n\n        if( EQUAL(pszName, \"JPEGTABLES\") )\n        {\n            uint32 nJPEGTableSize = 0;\n            void* pJPEGTable = nullptr;\n            if( TIFFGetField( m_poGDS->m_hTIFF, TIFFTAG_JPEGTABLES,\n                              &nJPEGTableSize, &pJPEGTable ) != 1 ||\n                pJPEGTable == nullptr || nJPEGTableSize > INT_MAX )\n            {\n                return nullptr;\n            }\n            char* const pszHex =\n                CPLBinaryToHex( nJPEGTableSize, static_cast<const GByte*>(pJPEGTable) );\n            const char* pszReturn = CPLSPrintf(\"%s\", pszHex);\n            CPLFree(pszHex);\n\n            return pszReturn;\n        }\n\n        if( EQUAL(pszName, \"IFD_OFFSET\") )\n        {\n            return CPLSPrintf( CPL_FRMT_GUIB,\n                               static_cast<GUIntBig>(m_poGDS->m_nDirOffset) );\n        }\n\n        if( sscanf( pszName, \"BLOCK_OFFSET_%d_%d\",\n                         &nBlockXOff, &nBlockYOff ) == 2 )\n        {\n            nBlocksPerRow =\n                DIV_ROUND_UP(m_poGDS->nRasterXSize, m_poGDS->m_nBlockXSize);\n            nBlocksPerColumn =\n                DIV_ROUND_UP(m_poGDS->nRasterYSize, m_poGDS->m_nBlockYSize);\n            if( nBlockXOff < 0 || nBlockXOff >= nBlocksPerRow ||\n                nBlockYOff < 0 || nBlockYOff >= nBlocksPerColumn )\n                return nullptr;\n\n            int nBlockId = nBlockYOff * nBlocksPerRow + nBlockXOff;\n            if( m_poGDS->m_nPlanarConfig == PLANARCONFIG_SEPARATE )\n            {\n                nBlockId += (nBand - 1) * m_poGDS->m_nBlocksPerBand;\n            }\n\n            vsi_l_offset nOffset = 0;\n            if( !m_poGDS->IsBlockAvailable(nBlockId, &nOffset) )\n            {\n                return nullptr;\n            }\n\n            return CPLSPrintf( CPL_FRMT_GUIB, static_cast<GUIntBig>(nOffset) );\n        }\n\n        if( sscanf( pszName, \"BLOCK_SIZE_%d_%d\",\n                    &nBlockXOff, &nBlockYOff ) == 2 )\n        {\n            nBlocksPerRow =\n                DIV_ROUND_UP(m_poGDS->nRasterXSize, m_poGDS->m_nBlockXSize);\n            nBlocksPerColumn =\n                DIV_ROUND_UP(m_poGDS->nRasterYSize, m_poGDS->m_nBlockYSize);\n            if( nBlockXOff < 0 || nBlockXOff >= nBlocksPerRow ||\n                nBlockYOff < 0 || nBlockYOff >= nBlocksPerColumn )\n                return nullptr;\n\n            int nBlockId = nBlockYOff * nBlocksPerRow + nBlockXOff;\n            if( m_poGDS->m_nPlanarConfig == PLANARCONFIG_SEPARATE )\n            {\n                nBlockId += (nBand - 1) * m_poGDS->m_nBlocksPerBand;\n            }\n\n            vsi_l_offset nByteCount = 0;\n            if( !m_poGDS->IsBlockAvailable(nBlockId, nullptr, &nByteCount) )\n            {\n                return nullptr;\n            }\n\n            return CPLSPrintf(CPL_FRMT_GUIB, static_cast<GUIntBig>(nByteCount));\n        }\n    }\n    return m_oGTiffMDMD.GetMetadataItem( pszName, pszDomain );\n}\n\n/************************************************************************/\n/*                          SetMetadataItem()                           */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::SetMetadataItem( const char *pszName,\n                                         const char *pszValue,\n                                         const char *pszDomain )\n\n{\n    m_poGDS->LoadGeoreferencingAndPamIfNeeded();\n\n    if( m_poGDS->m_bStreamingOut && m_poGDS->m_bCrystalized )\n    {\n        ReportError( CE_Failure, CPLE_NotSupported,\n                  \"Cannot modify metadata at that point in a streamed \"\n                  \"output file\" );\n        return CE_Failure;\n    }\n\n    if( pszDomain == nullptr || !EQUAL(pszDomain,\"_temporary_\") )\n    {\n        m_poGDS->m_bMetadataChanged = true;\n        // Cancel any existing metadata from PAM file.\n        if( eAccess == GA_Update &&\n            GDALPamRasterBand::GetMetadataItem(pszName, pszDomain) != nullptr )\n            GDALPamRasterBand::SetMetadataItem(pszName, nullptr, pszDomain);\n    }\n\n    return m_oGTiffMDMD.SetMetadataItem( pszName, pszValue, pszDomain );\n}\n\n/************************************************************************/\n/*                       GetColorInterpretation()                       */\n/************************************************************************/\n\nGDALColorInterp GTiffRasterBand::GetColorInterpretation()\n\n{\n    m_poGDS->LoadGeoreferencingAndPamIfNeeded();\n\n    return m_eBandInterp;\n}\n\n/************************************************************************/\n/*                         GTiffGetAlphaValue()                         */\n/************************************************************************/\n\nuint16 GTiffGetAlphaValue(const char* pszValue, uint16 nDefault)\n{\n    if( pszValue == nullptr )\n        return nDefault;\n    if( EQUAL(pszValue, \"YES\") )\n        return DEFAULT_ALPHA_TYPE;\n    if( EQUAL(pszValue, \"PREMULTIPLIED\") )\n        return EXTRASAMPLE_ASSOCALPHA;\n    if( EQUAL(pszValue, \"NON-PREMULTIPLIED\") )\n        return EXTRASAMPLE_UNASSALPHA;\n    if( EQUAL(pszValue, \"NO\") ||\n        EQUAL(pszValue, \"UNSPECIFIED\") )\n        return EXTRASAMPLE_UNSPECIFIED;\n\n    return nDefault;\n}\n\n/************************************************************************/\n/*                       SetColorInterpretation()                       */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::SetColorInterpretation( GDALColorInterp eInterp )\n\n{\n    m_poGDS->LoadGeoreferencingAndPamIfNeeded();\n\n    if( eInterp == m_eBandInterp )\n        return CE_None;\n\n    m_eBandInterp = eInterp;\n\n    if( eAccess != GA_Update )\n    {\n        CPLDebug( \"GTIFF\", \"ColorInterpretation %s for band %d goes to PAM \"\n                  \"instead of TIFF tag\",\n                  GDALGetColorInterpretationName(eInterp), nBand );\n        return GDALPamRasterBand::SetColorInterpretation( eInterp );\n    }\n\n    m_poGDS->m_bNeedsRewrite = true;\n    m_poGDS->m_bMetadataChanged = true;\n\n    // Try to autoset TIFFTAG_PHOTOMETRIC = PHOTOMETRIC_RGB if possible.\n    if( m_poGDS->nBands >= 3 &&\n        m_poGDS->m_nCompression != COMPRESSION_JPEG &&\n        m_poGDS->m_nPhotometric != PHOTOMETRIC_RGB &&\n        CSLFetchNameValue( m_poGDS->m_papszCreationOptions,\n                           \"PHOTOMETRIC\" ) == nullptr &&\n        ((nBand == 1 && eInterp == GCI_RedBand) ||\n         (nBand == 2 && eInterp == GCI_GreenBand) ||\n         (nBand == 3 && eInterp == GCI_BlueBand)) )\n    {\n        if( m_poGDS->GetRasterBand(1)->GetColorInterpretation() == GCI_RedBand &&\n            m_poGDS->GetRasterBand(2)->GetColorInterpretation() == GCI_GreenBand &&\n            m_poGDS->GetRasterBand(3)->GetColorInterpretation() == GCI_BlueBand )\n        {\n            m_poGDS->m_nPhotometric = PHOTOMETRIC_RGB;\n            TIFFSetField( m_poGDS->m_hTIFF, TIFFTAG_PHOTOMETRIC,\n                          m_poGDS->m_nPhotometric );\n\n            // We need to update the number of extra samples.\n            uint16 *v = nullptr;\n            uint16 count = 0;\n            const uint16 nNewExtraSamplesCount =\n                static_cast<uint16>(m_poGDS->nBands - 3);\n            if( m_poGDS->nBands >= 4 &&\n                TIFFGetField( m_poGDS->m_hTIFF, TIFFTAG_EXTRASAMPLES,\n                              &count, &v ) &&\n                count > nNewExtraSamplesCount )\n            {\n                uint16 * const pasNewExtraSamples =\n                    static_cast<uint16 *>( CPLMalloc(\n                        nNewExtraSamplesCount * sizeof(uint16) ) );\n                memcpy( pasNewExtraSamples, v + count - nNewExtraSamplesCount,\n                        nNewExtraSamplesCount * sizeof(uint16) );\n\n                TIFFSetField( m_poGDS->m_hTIFF, TIFFTAG_EXTRASAMPLES,\n                              nNewExtraSamplesCount, pasNewExtraSamples );\n\n                CPLFree(pasNewExtraSamples);\n            }\n        }\n        return CE_None;\n    }\n\n    // On the contrary, cancel the above if needed\n    if( m_poGDS->m_nCompression != COMPRESSION_JPEG &&\n        m_poGDS->m_nPhotometric == PHOTOMETRIC_RGB &&\n        CSLFetchNameValue( m_poGDS->m_papszCreationOptions,\n                           \"PHOTOMETRIC\") == nullptr &&\n        ((nBand == 1 && eInterp != GCI_RedBand) ||\n         (nBand == 2 && eInterp != GCI_GreenBand) ||\n         (nBand == 3 && eInterp != GCI_BlueBand)) )\n    {\n        m_poGDS->m_nPhotometric = PHOTOMETRIC_MINISBLACK;\n        TIFFSetField(m_poGDS->m_hTIFF, TIFFTAG_PHOTOMETRIC, m_poGDS->m_nPhotometric);\n\n        // We need to update the number of extra samples.\n        uint16 *v = nullptr;\n        uint16 count = 0;\n        const uint16 nNewExtraSamplesCount =\n            static_cast<uint16>(m_poGDS->nBands - 1);\n        if( m_poGDS->nBands >= 2 )\n        {\n            TIFFGetField( m_poGDS->m_hTIFF, TIFFTAG_EXTRASAMPLES, &count, &v );\n            if( nNewExtraSamplesCount > count )\n            {\n                uint16 * const pasNewExtraSamples =\n                    static_cast<uint16 *>( CPLMalloc(\n                        nNewExtraSamplesCount * sizeof(uint16) ) );\n                for( int i = 0;\n                     i < static_cast<int>(nNewExtraSamplesCount - count);\n                     ++i )\n                    pasNewExtraSamples[i] = EXTRASAMPLE_UNSPECIFIED;\n                if( count > 0 )\n                {\n                    memcpy( pasNewExtraSamples + nNewExtraSamplesCount - count,\n                            v,\n                            count * sizeof(uint16) );\n                }\n\n                TIFFSetField( m_poGDS->m_hTIFF, TIFFTAG_EXTRASAMPLES,\n                              nNewExtraSamplesCount, pasNewExtraSamples );\n\n                CPLFree(pasNewExtraSamples);\n            }\n        }\n    }\n\n    // Mark alpha band / undefined in extrasamples.\n    if( eInterp == GCI_AlphaBand || eInterp == GCI_Undefined )\n    {\n        uint16 *v = nullptr;\n        uint16 count = 0;\n        if( TIFFGetField( m_poGDS->m_hTIFF, TIFFTAG_EXTRASAMPLES, &count, &v ) )\n        {\n            const int nBaseSamples = m_poGDS->m_nSamplesPerPixel - count;\n\n            if( eInterp == GCI_AlphaBand )\n            {\n                for( int i = 1; i <= m_poGDS->nBands; ++i )\n                {\n                    if( i != nBand &&\n                        m_poGDS->GetRasterBand(i)->GetColorInterpretation() ==\n                        GCI_AlphaBand )\n                    {\n                        if( i == nBaseSamples + 1 &&\n                            CSLFetchNameValue( m_poGDS->m_papszCreationOptions,\n                                            \"ALPHA\" ) != nullptr )\n                        {\n                            ReportError(\n                                CE_Warning, CPLE_AppDefined,\n                                \"Band %d was already identified as alpha band, \"\n                                \"and band %d is now marked as alpha too. \"\n                                \"Presumably ALPHA creation option is not needed\",\n                                i, nBand );\n                        }\n                        else\n                        {\n                            ReportError(\n                                CE_Warning, CPLE_AppDefined,\n                                \"Band %d was already identified as alpha band, \"\n                                \"and band %d is now marked as alpha too\",\n                                i, nBand );\n                        }\n                    }\n                }\n            }\n\n            if( nBand > nBaseSamples && nBand - nBaseSamples - 1 < count )\n            {\n                // We need to allocate a new array as (current) libtiff\n                // versions will not like that we reuse the array we got from\n                // TIFFGetField().\n\n                uint16* pasNewExtraSamples =\n                    static_cast<uint16 *>(\n                        CPLMalloc( count * sizeof(uint16) ) );\n                memcpy( pasNewExtraSamples, v, count * sizeof(uint16) );\n                if( eInterp == GCI_AlphaBand )\n                {\n                    pasNewExtraSamples[nBand - nBaseSamples - 1] =\n                        GTiffGetAlphaValue(CPLGetConfigOption(\"GTIFF_ALPHA\", nullptr),\n                                            DEFAULT_ALPHA_TYPE);\n                }\n                else\n                {\n                    pasNewExtraSamples[nBand - nBaseSamples - 1] =\n                        EXTRASAMPLE_UNSPECIFIED;\n                }\n\n                TIFFSetField( m_poGDS->m_hTIFF, TIFFTAG_EXTRASAMPLES,\n                              count, pasNewExtraSamples);\n\n                CPLFree(pasNewExtraSamples);\n\n                return CE_None;\n            }\n        }\n    }\n\n    if( m_poGDS->m_nPhotometric != PHOTOMETRIC_MINISBLACK &&\n        CSLFetchNameValue( m_poGDS->m_papszCreationOptions, \"PHOTOMETRIC\") == nullptr )\n    {\n        m_poGDS->m_nPhotometric = PHOTOMETRIC_MINISBLACK;\n        TIFFSetField(m_poGDS->m_hTIFF, TIFFTAG_PHOTOMETRIC, m_poGDS->m_nPhotometric);\n    }\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                           GetColorTable()                            */\n/************************************************************************/\n\nGDALColorTable *GTiffRasterBand::GetColorTable()\n\n{\n    m_poGDS->LoadGeoreferencingAndPamIfNeeded();\n\n    if( nBand == 1 )\n        return m_poGDS->m_poColorTable;\n\n    return nullptr;\n}\n\n/************************************************************************/\n/*                           SetColorTable()                            */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::SetColorTable( GDALColorTable * poCT )\n\n{\n    m_poGDS->LoadGeoreferencingAndPamIfNeeded();\n\n/* -------------------------------------------------------------------- */\n/*      Check if this is even a candidate for applying a PCT.           */\n/* -------------------------------------------------------------------- */\n    if( nBand != 1)\n    {\n        ReportError( CE_Failure, CPLE_NotSupported,\n                  \"SetColorTable() can only be called on band 1.\" );\n        return CE_Failure;\n    }\n\n    if( m_poGDS->m_nSamplesPerPixel != 1 && m_poGDS->m_nSamplesPerPixel != 2)\n    {\n        ReportError( CE_Failure, CPLE_NotSupported,\n                  \"SetColorTable() not supported for multi-sample TIFF \"\n                  \"files.\" );\n        return CE_Failure;\n    }\n\n    if( eDataType != GDT_Byte && eDataType != GDT_UInt16 )\n    {\n        ReportError( CE_Failure, CPLE_NotSupported,\n                  \"SetColorTable() only supported for Byte or UInt16 bands \"\n                  \"in TIFF format.\" );\n        return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Is this really a request to clear the color table?              */\n/* -------------------------------------------------------------------- */\n    if( poCT == nullptr || poCT->GetColorEntryCount() == 0 )\n    {\n        TIFFSetField( m_poGDS->m_hTIFF, TIFFTAG_PHOTOMETRIC,\n                      PHOTOMETRIC_MINISBLACK );\n\n        TIFFUnsetField( m_poGDS->m_hTIFF, TIFFTAG_COLORMAP );\n\n        if( m_poGDS->m_poColorTable )\n        {\n            delete m_poGDS->m_poColorTable;\n            m_poGDS->m_poColorTable = nullptr;\n        }\n\n        return CE_None;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Write out the colortable, and update the configuration.         */\n/* -------------------------------------------------------------------- */\n    int nColors = 65536;\n\n    if( eDataType == GDT_Byte )\n        nColors = 256;\n\n    unsigned short *panTRed = static_cast<unsigned short *>(\n        CPLMalloc(sizeof(unsigned short)*nColors) );\n    unsigned short *panTGreen = static_cast<unsigned short *>(\n        CPLMalloc(sizeof(unsigned short)*nColors) );\n    unsigned short *panTBlue = static_cast<unsigned short *>(\n        CPLMalloc(sizeof(unsigned short)*nColors) );\n\n    for( int iColor = 0; iColor < nColors; ++iColor )\n    {\n        if( iColor < poCT->GetColorEntryCount() )\n        {\n            GDALColorEntry sRGB;\n            poCT->GetColorEntryAsRGB( iColor, &sRGB );\n\n            panTRed[iColor] = static_cast<unsigned short>(257 * sRGB.c1);\n            panTGreen[iColor] = static_cast<unsigned short>(257 * sRGB.c2);\n            panTBlue[iColor] = static_cast<unsigned short>(257 * sRGB.c3);\n        }\n        else\n        {\n            panTRed[iColor] = 0;\n            panTGreen[iColor] = 0;\n            panTBlue[iColor] = 0;\n        }\n    }\n\n    TIFFSetField( m_poGDS->m_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_PALETTE );\n    TIFFSetField( m_poGDS->m_hTIFF, TIFFTAG_COLORMAP,\n                  panTRed, panTGreen, panTBlue );\n\n    CPLFree( panTRed );\n    CPLFree( panTGreen );\n    CPLFree( panTBlue );\n\n    if( m_poGDS->m_poColorTable )\n        delete m_poGDS->m_poColorTable;\n\n    // libtiff 3.X needs setting this in all cases (creation or update)\n    // whereas libtiff 4.X would just need it if there\n    // was no color table before.\n    m_poGDS->m_bNeedsRewrite = true;\n\n    m_poGDS->m_poColorTable = poCT->Clone();\n    m_eBandInterp = GCI_PaletteIndex;\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                           GetNoDataValue()                           */\n/************************************************************************/\n\ndouble GTiffRasterBand::GetNoDataValue( int * pbSuccess )\n\n{\n    m_poGDS->LoadGeoreferencingAndPamIfNeeded();\n\n    if( m_bNoDataSet )\n    {\n        if( pbSuccess )\n            *pbSuccess = TRUE;\n\n        return m_dfNoDataValue;\n    }\n\n    if( m_poGDS->m_bNoDataSet )\n    {\n        if( pbSuccess )\n            *pbSuccess = TRUE;\n\n        return m_poGDS->m_dfNoDataValue;\n    }\n\n    return GDALPamRasterBand::GetNoDataValue( pbSuccess );\n}\n\n/************************************************************************/\n/*                           SetNoDataValue()                           */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::SetNoDataValue( double dfNoData )\n\n{\n    m_poGDS->LoadGeoreferencingAndPamIfNeeded();\n\n    if( m_poGDS->m_bNoDataSet && m_poGDS->m_dfNoDataValue == dfNoData )\n    {\n        m_bNoDataSet = true;\n        m_dfNoDataValue = dfNoData;\n        return CE_None;\n    }\n\n    if( m_poGDS->nBands > 1 && m_poGDS->m_eProfile == GTiffProfile::GDALGEOTIFF )\n    {\n        int bOtherBandHasNoData = FALSE;\n        const int nOtherBand = nBand > 1 ? 1 : 2;\n        double dfOtherNoData = m_poGDS->GetRasterBand(nOtherBand)->\n                                    GetNoDataValue(&bOtherBandHasNoData);\n        if( bOtherBandHasNoData && dfOtherNoData != dfNoData )\n        {\n            ReportError(CE_Warning, CPLE_AppDefined,\n                 \"Setting nodata to %.18g on band %d, but band %d has nodata \"\n                 \"at %.18g. The TIFFTAG_GDAL_NODATA only support one value \"\n                 \"per dataset. This value of %.18g will be used for all bands \"\n                 \"on re-opening\",\n                 dfNoData, nBand, nOtherBand, dfOtherNoData, dfNoData);\n        }\n    }\n\n    if( m_poGDS->m_bStreamingOut && m_poGDS->m_bCrystalized )\n    {\n        ReportError(\n            CE_Failure, CPLE_NotSupported,\n            \"Cannot modify nodata at that point in a streamed output file\" );\n        return CE_Failure;\n    }\n\n    m_poGDS->m_bNoDataSet = true;\n    m_poGDS->m_dfNoDataValue = dfNoData;\n\n    m_poGDS->m_bNoDataChanged = true;\n\n    m_bNoDataSet = true;\n    m_dfNoDataValue = dfNoData;\n    return CE_None;\n}\n\n/************************************************************************/\n/*                        DeleteNoDataValue()                           */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::DeleteNoDataValue()\n\n{\n    m_poGDS->LoadGeoreferencingAndPamIfNeeded();\n\n    if( !m_poGDS->m_bNoDataSet )\n        return CE_None;\n\n    if( m_poGDS->m_bStreamingOut && m_poGDS->m_bCrystalized )\n    {\n        ReportError(\n            CE_Failure, CPLE_NotSupported,\n            \"Cannot modify nodata at that point in a streamed output file\" );\n        return CE_Failure;\n    }\n\n    m_poGDS->m_bNoDataSet = false;\n    m_poGDS->m_dfNoDataValue = -9999.0;\n\n    m_poGDS->m_bNoDataChanged = true;\n\n    m_bNoDataSet = false;\n    m_dfNoDataValue = -9999.0;\n    return CE_None;\n}\n\n/************************************************************************/\n/*                             NullBlock()                              */\n/*                                                                      */\n/*      Set the block data to the null value if it is set, or zero      */\n/*      if there is no null data value.                                 */\n/************************************************************************/\n\nvoid GTiffRasterBand::NullBlock( void *pData )\n\n{\n    const GPtrDiff_t nWords = static_cast<GPtrDiff_t>(nBlockXSize) * nBlockYSize;\n    const int nChunkSize = std::max(1, GDALGetDataTypeSizeBytes(eDataType));\n\n    int bNoDataSetIn = FALSE;\n    const double dfNoData = GetNoDataValue( &bNoDataSetIn );\n    if( !bNoDataSetIn )\n    {\n#ifdef ESRI_BUILD\n        if( m_poGDS->m_nBitsPerSample >= 2 )\n            memset( pData, 0, nWords * nChunkSize );\n        else\n            memset( pData, 1, nWords * nChunkSize );\n#else\n        memset( pData, 0, nWords * nChunkSize );\n#endif\n    }\n    else\n    {\n        // Will convert nodata value to the right type and copy efficiently.\n        GDALCopyWords64( &dfNoData, GDT_Float64, 0,\n                       pData, eDataType, nChunkSize, nWords);\n    }\n}\n\n/************************************************************************/\n/*                          GetOverviewCount()                          */\n/************************************************************************/\n\nint GTiffRasterBand::GetOverviewCount()\n\n{\n    m_poGDS->ScanDirectories();\n\n    if( m_poGDS->m_nOverviewCount > 0 )\n    {\n        return m_poGDS->m_nOverviewCount;\n    }\n\n    const int nOverviewCount = GDALRasterBand::GetOverviewCount();\n    if( nOverviewCount > 0 )\n        return nOverviewCount;\n\n    // Implicit JPEG overviews are normally hidden, except when doing\n    // IRasterIO() operations.\n    if( m_poGDS->m_nJPEGOverviewVisibilityCounter )\n        return m_poGDS->GetJPEGOverviewCount();\n\n    return 0;\n}\n\n/************************************************************************/\n/*                            GetOverview()                             */\n/************************************************************************/\n\nGDALRasterBand *GTiffRasterBand::GetOverview( int i )\n\n{\n    m_poGDS->ScanDirectories();\n\n    if( m_poGDS->m_nOverviewCount > 0 )\n    {\n        // Do we have internal overviews?\n        if( i < 0 || i >= m_poGDS->m_nOverviewCount )\n            return nullptr;\n\n        return m_poGDS->m_papoOverviewDS[i]->GetRasterBand(nBand);\n    }\n\n    GDALRasterBand* const poOvrBand = GDALRasterBand::GetOverview( i );\n    if( poOvrBand != nullptr )\n        return poOvrBand;\n\n    // For consistency with GetOverviewCount(), we should also test\n    // m_nJPEGOverviewVisibilityCounter, but it is also convenient to be able\n    // to query them for testing purposes.\n    if( i >= 0 && i < m_poGDS->GetJPEGOverviewCount() )\n        return m_poGDS->m_papoJPEGOverviewDS[i]->GetRasterBand(nBand);\n\n    return nullptr;\n}\n\n/************************************************************************/\n/*                           GetMaskFlags()                             */\n/************************************************************************/\n\nint GTiffRasterBand::GetMaskFlags()\n{\n    m_poGDS->ScanDirectories();\n\n    if( m_poGDS->m_poExternalMaskDS != nullptr )\n    {\n        return GMF_PER_DATASET;\n    }\n\n    if( m_poGDS->m_poMaskDS != nullptr )\n    {\n        if( m_poGDS->m_poMaskDS->GetRasterCount() == 1)\n        {\n            return GMF_PER_DATASET;\n        }\n\n        return 0;\n    }\n\n    if( m_poGDS->m_bIsOverview )\n    {\n        return m_poGDS->m_poBaseDS->GetRasterBand(nBand)->GetMaskFlags();\n    }\n\n    return GDALPamRasterBand::GetMaskFlags();\n}\n\n/************************************************************************/\n/*                            GetMaskBand()                             */\n/************************************************************************/\n\nGDALRasterBand *GTiffRasterBand::GetMaskBand()\n{\n    m_poGDS->ScanDirectories();\n\n    if( m_poGDS->m_poExternalMaskDS != nullptr )\n    {\n        return m_poGDS->m_poExternalMaskDS->GetRasterBand(1);\n    }\n\n    if( m_poGDS->m_poMaskDS != nullptr )\n    {\n        if( m_poGDS->m_poMaskDS->GetRasterCount() == 1 )\n            return m_poGDS->m_poMaskDS->GetRasterBand(1);\n\n        return m_poGDS->m_poMaskDS->GetRasterBand(nBand);\n    }\n\n    if( m_poGDS->m_bIsOverview )\n    {\n        GDALRasterBand* poBaseMask =\n            m_poGDS->m_poBaseDS->GetRasterBand(nBand)->GetMaskBand();\n        if( poBaseMask )\n        {\n            const int nOverviews = poBaseMask->GetOverviewCount();\n            for( int i = 0; i < nOverviews; i++ )\n            {\n                GDALRasterBand* poOvr = poBaseMask->GetOverview(i);\n                if( poOvr &&\n                    poOvr->GetXSize() == GetXSize() &&\n                    poOvr->GetYSize() == GetYSize() )\n                {\n                    return poOvr;\n                }\n            }\n        }\n    }\n\n    return GDALPamRasterBand::GetMaskBand();\n}\n\n/************************************************************************/\n/* ==================================================================== */\n/*                             GTiffSplitBand                           */\n/* ==================================================================== */\n/************************************************************************/\n\nclass GTiffSplitBand final : public GTiffRasterBand\n{\n    friend class GTiffDataset;\n\n  public:\n             GTiffSplitBand( GTiffDataset *, int );\n    virtual ~GTiffSplitBand() {}\n\n    virtual int IGetDataCoverageStatus( int nXOff, int nYOff,\n                                        int nXSize, int nYSize,\n                                        int nMaskFlagStop,\n                                        double* pdfDataPct) override;\n\n    virtual CPLErr IReadBlock( int, int, void * ) override;\n    virtual CPLErr IWriteBlock( int, int, void * ) override;\n};\n\n/************************************************************************/\n/*                           GTiffSplitBand()                           */\n/************************************************************************/\n\nGTiffSplitBand::GTiffSplitBand( GTiffDataset *poDSIn, int nBandIn ) :\n    GTiffRasterBand( poDSIn, nBandIn )\n{\n    nBlockXSize = poDS->GetRasterXSize();\n    nBlockYSize = 1;\n}\n\n/************************************************************************/\n/*                       IGetDataCoverageStatus()                       */\n/************************************************************************/\n\nint GTiffSplitBand::IGetDataCoverageStatus( int , int ,\n                                             int , int ,\n                                             int ,\n                                             double* )\n{\n     return GDAL_DATA_COVERAGE_STATUS_UNIMPLEMENTED |\n            GDAL_DATA_COVERAGE_STATUS_DATA;\n}\n\n/************************************************************************/\n/*                             IReadBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffSplitBand::IReadBlock( int /* nBlockXOff */, int nBlockYOff,\n                                   void * pImage )\n\n{\n    m_poGDS->Crystalize();\n\n    // Optimization when reading the same line in a contig multi-band TIFF.\n    if( m_poGDS->m_nPlanarConfig == PLANARCONFIG_CONTIG && m_poGDS->nBands > 1 &&\n        m_poGDS->m_nLoadedBlock == nBlockYOff )\n    {\n        goto extract_band_data;\n    }\n\n    if( m_poGDS->m_nPlanarConfig == PLANARCONFIG_CONTIG &&\n        m_poGDS->nBands > 1 )\n    {\n        if( m_poGDS->m_pabyBlockBuf == nullptr )\n        {\n            m_poGDS->m_pabyBlockBuf =\n                static_cast<GByte *>(\n                    VSI_MALLOC_VERBOSE(TIFFScanlineSize(m_poGDS->m_hTIFF)) );\n            if( m_poGDS->m_pabyBlockBuf == nullptr )\n            {\n                return CE_Failure;\n            }\n        }\n    }\n    else\n    {\n        CPLAssert(TIFFScanlineSize(m_poGDS->m_hTIFF) == nBlockXSize);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Read through to target scanline.                                */\n/* -------------------------------------------------------------------- */\n    if( m_poGDS->m_nLoadedBlock >= nBlockYOff )\n        m_poGDS->m_nLoadedBlock = -1;\n\n    if( m_poGDS->m_nPlanarConfig == PLANARCONFIG_SEPARATE && m_poGDS->nBands > 1 )\n    {\n        // If we change of band, we must start reading the\n        // new strip from its beginning.\n        if( m_poGDS->m_nLastBandRead != nBand )\n            m_poGDS->m_nLoadedBlock = -1;\n        m_poGDS->m_nLastBandRead = nBand;\n    }\n\n    while( m_poGDS->m_nLoadedBlock < nBlockYOff )\n    {\n        ++m_poGDS->m_nLoadedBlock;\n        if( TIFFReadScanline(\n                m_poGDS->m_hTIFF,\n                m_poGDS->m_pabyBlockBuf ? m_poGDS->m_pabyBlockBuf : pImage,\n                m_poGDS->m_nLoadedBlock,\n                (m_poGDS->m_nPlanarConfig == PLANARCONFIG_SEPARATE) ?\n                 static_cast<uint16>(nBand - 1) : 0 ) == -1\n            && !m_poGDS->m_bIgnoreReadErrors )\n        {\n            ReportError( CE_Failure, CPLE_AppDefined,\n                      \"TIFFReadScanline() failed.\" );\n            m_poGDS->m_nLoadedBlock = -1;\n            return CE_Failure;\n        }\n    }\n\nextract_band_data:\n/* -------------------------------------------------------------------- */\n/*      Extract band data from contig buffer.                           */\n/* -------------------------------------------------------------------- */\n    if( m_poGDS->m_pabyBlockBuf != nullptr )\n    {\n        for( int iPixel = 0, iSrcOffset= nBand - 1, iDstOffset = 0;\n             iPixel < nBlockXSize;\n             ++iPixel, iSrcOffset += m_poGDS->nBands, ++iDstOffset )\n        {\n            static_cast<GByte *>(pImage)[iDstOffset] =\n                m_poGDS->m_pabyBlockBuf[iSrcOffset];\n        }\n    }\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                            IWriteBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffSplitBand::IWriteBlock( int /* nBlockXOff */, int /* nBlockYOff */,\n                                    void * /* pImage */ )\n\n{\n    ReportError( CE_Failure, CPLE_AppDefined,\n              \"Split bands are read-only.\" );\n    return CE_Failure;\n}\n\n/************************************************************************/\n/* ==================================================================== */\n/*                             GTiffRGBABand                            */\n/* ==================================================================== */\n/************************************************************************/\n\nclass GTiffRGBABand final : public GTiffRasterBand\n{\n    friend class GTiffDataset;\n\n  public:\n                   GTiffRGBABand( GTiffDataset *, int );\n    virtual ~GTiffRGBABand() {}\n\n    virtual int IGetDataCoverageStatus( int nXOff, int nYOff,\n                                        int nXSize, int nYSize,\n                                        int nMaskFlagStop,\n                                        double* pdfDataPct) override;\n\n    virtual CPLErr IReadBlock( int, int, void * ) override;\n    virtual CPLErr IWriteBlock( int, int, void * ) override;\n\n    virtual GDALColorInterp GetColorInterpretation() override;\n};\n\n/************************************************************************/\n/*                           GTiffRGBABand()                            */\n/************************************************************************/\n\nGTiffRGBABand::GTiffRGBABand( GTiffDataset *poDSIn, int nBandIn ) :\n    GTiffRasterBand( poDSIn, nBandIn )\n{\n    eDataType = GDT_Byte;\n}\n\n/************************************************************************/\n/*                       IGetDataCoverageStatus()                       */\n/************************************************************************/\n\nint GTiffRGBABand::IGetDataCoverageStatus( int , int ,\n                                             int , int ,\n                                             int ,\n                                             double* )\n{\n     return GDAL_DATA_COVERAGE_STATUS_UNIMPLEMENTED |\n            GDAL_DATA_COVERAGE_STATUS_DATA;\n}\n\n/************************************************************************/\n/*                            IWriteBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffRGBABand::IWriteBlock( int, int, void * )\n\n{\n    ReportError( CE_Failure, CPLE_AppDefined,\n              \"RGBA interpreted raster bands are read-only.\" );\n    return CE_Failure;\n}\n\n/************************************************************************/\n/*                             IReadBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffRGBABand::IReadBlock( int nBlockXOff, int nBlockYOff,\n                                  void * pImage )\n\n{\n    m_poGDS->Crystalize();\n\n    CPLAssert( nBlocksPerRow != 0 );\n    const auto nBlockBufSize = 4 * static_cast<GPtrDiff_t>(nBlockXSize) * nBlockYSize;\n    const int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n\n    if( m_poGDS->m_nPlanarConfig == PLANARCONFIG_SEPARATE )\n    {\n        for( int iBand = 0; iBand < m_poGDS->m_nSamplesPerPixel; iBand ++ )\n        {\n            int nBlockIdBand = nBlockId + iBand * m_poGDS->m_nBlocksPerBand;\n            if( !m_poGDS->IsBlockAvailable(nBlockIdBand) )\n                return CE_Failure;\n        }\n    }\n    else\n    {\n        if( !m_poGDS->IsBlockAvailable(nBlockId) )\n            return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Allocate a temporary buffer for this strip.                     */\n/* -------------------------------------------------------------------- */\n    if( m_poGDS->m_pabyBlockBuf == nullptr )\n    {\n        m_poGDS->m_pabyBlockBuf =\n            static_cast<GByte *>(\n                VSI_MALLOC3_VERBOSE( 4, nBlockXSize, nBlockYSize ) );\n        if( m_poGDS->m_pabyBlockBuf == nullptr )\n            return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Read the strip                                                  */\n/* -------------------------------------------------------------------- */\n    CPLErr eErr = CE_None;\n\n    if( m_poGDS->m_nLoadedBlock != nBlockId )\n    {\n        if( TIFFIsTiled( m_poGDS->m_hTIFF ) )\n        {\n#if TIFFLIB_VERSION > 20161119\n            if( TIFFReadRGBATileExt(\n                   m_poGDS->m_hTIFF,\n                   nBlockXOff * nBlockXSize,\n                   nBlockYOff * nBlockYSize,\n                   reinterpret_cast<uint32 *>(m_poGDS->m_pabyBlockBuf),\n                   !m_poGDS->m_bIgnoreReadErrors) == 0\n                && !m_poGDS->m_bIgnoreReadErrors )\n#else\n            if( TIFFReadRGBATile(\n                   m_poGDS->m_hTIFF,\n                   nBlockXOff * nBlockXSize,\n                   nBlockYOff * nBlockYSize,\n                   reinterpret_cast<uint32 *>(m_poGDS->m_pabyBlockBuf)) == 0\n                && !m_poGDS->m_bIgnoreReadErrors )\n#endif\n            {\n                // Once TIFFError() is properly hooked, this can go away.\n                ReportError( CE_Failure, CPLE_AppDefined,\n                          \"TIFFReadRGBATile() failed.\" );\n\n                memset( m_poGDS->m_pabyBlockBuf, 0, nBlockBufSize );\n\n                eErr = CE_Failure;\n            }\n        }\n        else\n        {\n#if TIFFLIB_VERSION > 20161119\n            if( TIFFReadRGBAStripExt(\n                   m_poGDS->m_hTIFF,\n                   nBlockId * nBlockYSize,\n                   reinterpret_cast<uint32 *>(m_poGDS->m_pabyBlockBuf),\n                   !m_poGDS->m_bIgnoreReadErrors) == 0\n                && !m_poGDS->m_bIgnoreReadErrors )\n#else\n            if( TIFFReadRGBAStrip(\n                   m_poGDS->m_hTIFF,\n                   nBlockId * nBlockYSize,\n                   reinterpret_cast<uint32 *>(m_poGDS->m_pabyBlockBuf)) == 0\n                && !m_poGDS->m_bIgnoreReadErrors )\n#endif\n            {\n                // Once TIFFError() is properly hooked, this can go away.\n                ReportError( CE_Failure, CPLE_AppDefined,\n                          \"TIFFReadRGBAStrip() failed.\" );\n\n                memset( m_poGDS->m_pabyBlockBuf, 0, nBlockBufSize );\n\n                eErr = CE_Failure;\n            }\n        }\n    }\n\n    m_poGDS->m_nLoadedBlock = nBlockId;\n\n/* -------------------------------------------------------------------- */\n/*      Handle simple case of eight bit data, and pixel interleaving.   */\n/* -------------------------------------------------------------------- */\n    int nThisBlockYSize = nBlockYSize;\n\n    if( nBlockYOff * nBlockYSize > GetYSize() - nBlockYSize\n        && !TIFFIsTiled( m_poGDS->m_hTIFF ) )\n        nThisBlockYSize = GetYSize() - nBlockYOff * nBlockYSize;\n\n#ifdef CPL_LSB\n    const int nBO = nBand - 1;\n#else\n    const int nBO = 4 - nBand;\n#endif\n\n    for( int iDestLine = 0; iDestLine < nThisBlockYSize; ++iDestLine )\n    {\n        const auto nSrcOffset =\n            static_cast<GPtrDiff_t>(nThisBlockYSize - iDestLine - 1) * nBlockXSize * 4;\n\n        GDALCopyWords(\n            m_poGDS->m_pabyBlockBuf + nBO + nSrcOffset, GDT_Byte, 4,\n            static_cast<GByte *>(pImage)+static_cast<GPtrDiff_t>(iDestLine)*nBlockXSize, GDT_Byte, 1,\n            nBlockXSize );\n    }\n\n    if( eErr == CE_None )\n        eErr = FillCacheForOtherBands(nBlockXOff, nBlockYOff);\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                       GetColorInterpretation()                       */\n/************************************************************************/\n\nGDALColorInterp GTiffRGBABand::GetColorInterpretation()\n\n{\n    if( nBand == 1 )\n        return GCI_RedBand;\n    if( nBand == 2 )\n        return GCI_GreenBand;\n    if( nBand == 3 )\n        return GCI_BlueBand;\n\n    return GCI_AlphaBand;\n}\n\n/************************************************************************/\n/* ==================================================================== */\n/*                             GTiffOddBitsBand                         */\n/* ==================================================================== */\n/************************************************************************/\n\nclass GTiffOddBitsBand CPL_NON_FINAL: public GTiffRasterBand\n{\n    friend class GTiffDataset;\n  public:\n\n                   GTiffOddBitsBand( GTiffDataset *, int );\n    virtual ~GTiffOddBitsBand() {}\n\n    virtual CPLErr IReadBlock( int, int, void * ) override;\n    virtual CPLErr IWriteBlock( int, int, void * ) override;\n};\n\n/************************************************************************/\n/*                           GTiffOddBitsBand()                         */\n/************************************************************************/\n\nGTiffOddBitsBand::GTiffOddBitsBand( GTiffDataset *m_poGDSIn, int nBandIn )\n        : GTiffRasterBand( m_poGDSIn, nBandIn )\n\n{\n    eDataType = GDT_Unknown;\n    if( (m_poGDS->m_nBitsPerSample == 16 || m_poGDS->m_nBitsPerSample == 24) &&\n        m_poGDS->m_nSampleFormat == SAMPLEFORMAT_IEEEFP )\n        eDataType = GDT_Float32;\n    // FIXME ? in autotest we currently open gcore/data/int24.tif\n    // which is declared as signed, but we consider it as unsigned\n    else if( (m_poGDS->m_nSampleFormat == SAMPLEFORMAT_UINT ||\n              m_poGDS->m_nSampleFormat == SAMPLEFORMAT_INT) &&\n             m_poGDS->m_nBitsPerSample < 8 )\n        eDataType = GDT_Byte;\n    else if( (m_poGDS->m_nSampleFormat == SAMPLEFORMAT_UINT ||\n              m_poGDS->m_nSampleFormat == SAMPLEFORMAT_INT) &&\n             m_poGDS->m_nBitsPerSample > 8 && m_poGDS->m_nBitsPerSample < 16 )\n        eDataType = GDT_UInt16;\n    else if( (m_poGDS->m_nSampleFormat == SAMPLEFORMAT_UINT ||\n              m_poGDS->m_nSampleFormat == SAMPLEFORMAT_INT) &&\n             m_poGDS->m_nBitsPerSample > 16 && m_poGDS->m_nBitsPerSample < 32 )\n        eDataType = GDT_UInt32;\n}\n\n/************************************************************************/\n/*                            FloatToHalf()                             */\n/************************************************************************/\n\nstatic GUInt16 FloatToHalf( GUInt32 iFloat32, bool& bHasWarned )\n{\n    GUInt32 iSign =     (iFloat32 >> 31) & 0x00000001;\n    GUInt32 iExponent = (iFloat32 >> 23) & 0x000000ff;\n    GUInt32 iMantissa = iFloat32         & 0x007fffff;\n\n    if (iExponent == 255)\n    {\n        if (iMantissa == 0)\n        {\n/* -------------------------------------------------------------------- */\n/*       Positive or negative infinity.                                 */\n/* -------------------------------------------------------------------- */\n\n            return static_cast<GUInt16>((iSign << 15) | 0x7C00);\n        }\n        else\n        {\n/* -------------------------------------------------------------------- */\n/*       NaN -- preserve sign and significand bits.                     */\n/* -------------------------------------------------------------------- */\n            if( iMantissa >> 13 )\n                return static_cast<GUInt16>((iSign << 15) | 0x7C00 |\n                                                            (iMantissa >> 13));\n\n            return static_cast<GUInt16>((iSign << 15) | 0x7E00);\n        }\n    }\n\n    if( iExponent <= 127 - 15 )\n    {\n        // Zero, float32 denormalized number or float32 too small normalized\n        // number\n        if( 13 + 1 + 127 - 15 - iExponent >= 32 )\n            return static_cast<GUInt16>(iSign << 15);\n\n        // Return a denormalized number\n        return static_cast<GUInt16>((iSign << 15) |\n                ((iMantissa | 0x00800000) >> (13 + 1 + 127 - 15 - iExponent)));\n    }\n    if( iExponent - (127 - 15) >= 31 )\n    {\n        if( !bHasWarned )\n        {\n            bHasWarned = true;\n            float fVal = 0.0f;\n            memcpy(&fVal, &iFloat32, 4);\n            CPLError(\n                CE_Failure, CPLE_AppDefined,\n                \"Value %.8g is beyond range of float16. Converted to %sinf\",\n                fVal, (fVal > 0) ? \"+\" : \"-\");\n        }\n        return static_cast<GUInt16>((iSign << 15) | 0x7C00);  // Infinity\n    }\n\n/* -------------------------------------------------------------------- */\n/*       Normalized number.                                             */\n/* -------------------------------------------------------------------- */\n\n    iExponent = iExponent - (127 - 15);\n    iMantissa = iMantissa >> 13;\n\n/* -------------------------------------------------------------------- */\n/*       Assemble sign, exponent and mantissa.                          */\n/* -------------------------------------------------------------------- */\n\n    // coverity[overflow_sink]\n    return static_cast<GUInt16>((iSign << 15) | (iExponent << 10) | iMantissa);\n}\n\n/************************************************************************/\n/*                            IWriteBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffOddBitsBand::IWriteBlock( int nBlockXOff, int nBlockYOff,\n                                      void *pImage )\n\n{\n    m_poGDS->Crystalize();\n\n    if( m_poGDS->m_bWriteError )\n    {\n        // Report as an error if a previously loaded block couldn't be written\n        // correctly.\n        return CE_Failure;\n    }\n\n    if( eDataType == GDT_Float32 && m_poGDS->m_nBitsPerSample != 16 )\n    {\n        ReportError(CE_Failure, CPLE_NotSupported,\n                 \"Writing float data with nBitsPerSample = %d is unsupported\",\n                 m_poGDS->m_nBitsPerSample);\n        return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Load the block buffer.                                          */\n/* -------------------------------------------------------------------- */\n    CPLAssert(nBlocksPerRow != 0);\n    int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n\n    if( m_poGDS->m_nPlanarConfig == PLANARCONFIG_SEPARATE )\n        nBlockId += (nBand - 1) * m_poGDS->m_nBlocksPerBand;\n\n    // Only read content from disk in the CONTIG case.\n    {\n        const CPLErr eErr =\n            m_poGDS->LoadBlockBuf( nBlockId,\n                                 m_poGDS->m_nPlanarConfig == PLANARCONFIG_CONTIG &&\n                                 m_poGDS->nBands > 1 );\n        if( eErr != CE_None )\n            return eErr;\n    }\n\n    const GUInt32 nMaxVal = (1U << m_poGDS->m_nBitsPerSample) - 1;\n\n/* -------------------------------------------------------------------- */\n/*      Handle case of \"separate\" images or single band images where    */\n/*      no interleaving with other data is required.                    */\n/* -------------------------------------------------------------------- */\n    if( m_poGDS->m_nPlanarConfig == PLANARCONFIG_SEPARATE\n        || m_poGDS->nBands == 1 )\n    {\n        // TODO(schwehr): Create a CplNumBits8Aligned.\n        // Bits per line rounds up to next byte boundary.\n        GInt64 nBitsPerLine = static_cast<GInt64>(nBlockXSize) * m_poGDS->m_nBitsPerSample;\n        if( (nBitsPerLine & 7) != 0 )\n            nBitsPerLine = (nBitsPerLine + 7) & (~7);\n\n        GPtrDiff_t iPixel = 0;\n\n        // Small optimization in 1 bit case.\n        if( m_poGDS->m_nBitsPerSample == 1 )\n        {\n            for( int iY = 0; iY < nBlockYSize; ++iY, iPixel += nBlockXSize )\n            {\n                GInt64 iBitOffset = iY * nBitsPerLine;\n\n                const GByte* pabySrc =\n                    static_cast<const GByte*>(pImage) + iPixel;\n                auto iByteOffset = iBitOffset / 8;\n                int iX = 0;  // Used after for.\n                for( ; iX + 7 < nBlockXSize; iX += 8, iByteOffset++ )\n                {\n                    int nRes = (!(!pabySrc[iX+0])) << 7;\n                    nRes |= (!(!pabySrc[iX+1])) << 6;\n                    nRes |= (!(!pabySrc[iX+2])) << 5;\n                    nRes |= (!(!pabySrc[iX+3])) << 4;\n                    nRes |= (!(!pabySrc[iX+4])) << 3;\n                    nRes |= (!(!pabySrc[iX+5])) << 2;\n                    nRes |= (!(!pabySrc[iX+6])) << 1;\n                    nRes |= (!(!pabySrc[iX+7])) << 0;\n                    m_poGDS->m_pabyBlockBuf[iByteOffset] = static_cast<GByte>(nRes);\n                }\n                iBitOffset = iByteOffset * 8;\n                if( iX < nBlockXSize )\n                {\n                    int nRes = 0;\n                    for( ; iX < nBlockXSize; ++iX )\n                    {\n                        if( pabySrc[iX] )\n                            nRes |= (0x80 >>(iBitOffset & 7) );\n                        ++iBitOffset;\n                    }\n                    m_poGDS->m_pabyBlockBuf[iBitOffset>>3] =\n                        static_cast<GByte>(nRes);\n                }\n            }\n\n            m_poGDS->m_bLoadedBlockDirty = true;\n\n            return CE_None;\n        }\n\n        if( eDataType == GDT_Float32 && m_poGDS->m_nBitsPerSample == 16 )\n        {\n            for( ; iPixel < static_cast<GPtrDiff_t>(nBlockYSize) * nBlockXSize; iPixel++ )\n            {\n                GUInt32 nInWord = static_cast<GUInt32 *>(pImage)[iPixel];\n                bool bClipWarn = m_poGDS->m_bClipWarn;\n                GUInt16 nHalf = FloatToHalf(nInWord, bClipWarn);\n                m_poGDS->m_bClipWarn = bClipWarn;\n                reinterpret_cast<GUInt16*>(m_poGDS->m_pabyBlockBuf)[iPixel] = nHalf;\n            }\n\n            m_poGDS->m_bLoadedBlockDirty = true;\n\n            return CE_None;\n        }\n\n        // Initialize to zero as we set the buffer with binary or operations.\n        if( m_poGDS->m_nBitsPerSample != 24 )\n            memset(m_poGDS->m_pabyBlockBuf, 0, static_cast<size_t>((nBitsPerLine / 8) * nBlockYSize));\n\n        for( int iY = 0; iY < nBlockYSize; ++iY )\n        {\n            GInt64 iBitOffset = iY * nBitsPerLine;\n\n            if( m_poGDS->m_nBitsPerSample == 12 )\n            {\n                for( int iX = 0; iX < nBlockXSize; ++iX )\n                {\n                    GUInt32 nInWord = static_cast<GUInt16 *>(pImage)[iPixel++];\n                    if( nInWord > nMaxVal )\n                    {\n                        nInWord = nMaxVal;\n                        if( !m_poGDS->m_bClipWarn )\n                        {\n                            m_poGDS->m_bClipWarn = true;\n                            ReportError(\n                                CE_Warning, CPLE_AppDefined,\n                                \"One or more pixels clipped to fit %d bit \"\n                                \"domain.\", m_poGDS->m_nBitsPerSample );\n                        }\n                    }\n\n                    if( (iBitOffset % 8) == 0 )\n                    {\n                        m_poGDS->m_pabyBlockBuf[iBitOffset>>3] =\n                            static_cast<GByte>(nInWord >> 4);\n                        // Let 4 lower bits to zero as they're going to be\n                        // overridden by the next word.\n                        m_poGDS->m_pabyBlockBuf[(iBitOffset>>3)+1] =\n                            static_cast<GByte>((nInWord & 0xf) << 4);\n                    }\n                    else\n                    {\n                        // Must or to preserve the 4 upper bits written\n                        // for the previous word.\n                        m_poGDS->m_pabyBlockBuf[iBitOffset>>3] |=\n                            static_cast<GByte>(nInWord >> 8);\n                        m_poGDS->m_pabyBlockBuf[(iBitOffset>>3)+1] =\n                            static_cast<GByte>(nInWord & 0xff);\n                    }\n\n                    iBitOffset += m_poGDS->m_nBitsPerSample;\n                }\n                continue;\n            }\n\n            for( int iX = 0; iX < nBlockXSize; ++iX )\n            {\n                GUInt32 nInWord = 0;\n                if( eDataType == GDT_Byte )\n                {\n                    nInWord = static_cast<GByte *>(pImage)[iPixel++];\n                }\n                else if( eDataType == GDT_UInt16 )\n                {\n                    nInWord = static_cast<GUInt16 *>(pImage)[iPixel++];\n                }\n                else if( eDataType == GDT_UInt32 )\n                {\n                    nInWord = static_cast<GUInt32 *>(pImage)[iPixel++];\n                }\n                else\n                {\n                    CPLAssert(false);\n                }\n\n                if( nInWord > nMaxVal )\n                {\n                    nInWord = nMaxVal;\n                    if( !m_poGDS->m_bClipWarn )\n                    {\n                        m_poGDS->m_bClipWarn = true;\n                        ReportError(\n                            CE_Warning, CPLE_AppDefined,\n                            \"One or more pixels clipped to fit %d bit domain.\",\n                            m_poGDS->m_nBitsPerSample );\n                    }\n                }\n\n                if( m_poGDS->m_nBitsPerSample == 24 )\n                {\n/* -------------------------------------------------------------------- */\n/*      Special case for 24bit data which is pre-byteswapped since      */\n/*      the size falls on a byte boundary ... ugh (#2361).              */\n/* -------------------------------------------------------------------- */\n#ifdef CPL_MSB\n                    m_poGDS->m_pabyBlockBuf[(iBitOffset>>3) + 0] =\n                        static_cast<GByte>( nInWord );\n                    m_poGDS->m_pabyBlockBuf[(iBitOffset>>3) + 1] =\n                        static_cast<GByte>( nInWord >> 8 );\n                    m_poGDS->m_pabyBlockBuf[(iBitOffset>>3) + 2] =\n                        static_cast<GByte>( nInWord >> 16 );\n#else\n                    m_poGDS->m_pabyBlockBuf[(iBitOffset>>3) + 0] =\n                        static_cast<GByte>( nInWord >> 16 );\n                    m_poGDS->m_pabyBlockBuf[(iBitOffset>>3) + 1] =\n                        static_cast<GByte>( nInWord >> 8 );\n                    m_poGDS->m_pabyBlockBuf[(iBitOffset>>3) + 2] =\n                        static_cast<GByte>( nInWord );\n#endif\n                    iBitOffset += 24;\n                }\n                else\n                {\n                    for( int iBit = 0; iBit < m_poGDS->m_nBitsPerSample; ++iBit )\n                    {\n                        if( nInWord &\n                            (1 << (m_poGDS->m_nBitsPerSample - 1 - iBit)) )\n                            m_poGDS->m_pabyBlockBuf[iBitOffset>>3] |=\n                                ( 0x80 >> (iBitOffset & 7) );\n                        ++iBitOffset;\n                    }\n                }\n            }\n        }\n\n        m_poGDS->m_bLoadedBlockDirty = true;\n\n        return CE_None;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Handle case of pixel interleaved (PLANARCONFIG_CONTIG) images.  */\n/* -------------------------------------------------------------------- */\n\n/* -------------------------------------------------------------------- */\n/*      On write of pixel interleaved data, we might as well flush      */\n/*      out any other bands that are dirty in our cache.  This is       */\n/*      especially helpful when writing compressed blocks.              */\n/* -------------------------------------------------------------------- */\n    for( int iBand = 0; iBand < m_poGDS->nBands; ++iBand )\n    {\n        const GByte *pabyThisImage = nullptr;\n        GDALRasterBlock *poBlock = nullptr;\n\n        if( iBand + 1 == nBand )\n        {\n            pabyThisImage = static_cast<GByte *>( pImage );\n        }\n        else\n        {\n            poBlock =\n                cpl::down_cast<GTiffOddBitsBand *>(\n                    m_poGDS->GetRasterBand( iBand + 1 ))\n                        ->TryGetLockedBlockRef( nBlockXOff, nBlockYOff );\n\n            if( poBlock == nullptr )\n                continue;\n\n            if( !poBlock->GetDirty() )\n            {\n                poBlock->DropLock();\n                continue;\n            }\n\n            pabyThisImage = static_cast<GByte *>(poBlock->GetDataRef());\n        }\n\n        const int iPixelBitSkip = m_poGDS->m_nBitsPerSample * m_poGDS->nBands;\n        const int iBandBitOffset = iBand * m_poGDS->m_nBitsPerSample;\n\n        // Bits per line rounds up to next byte boundary.\n        GInt64 nBitsPerLine = static_cast<GInt64>(nBlockXSize) * iPixelBitSkip;\n        if( (nBitsPerLine & 7) != 0 )\n            nBitsPerLine = (nBitsPerLine + 7) & (~7);\n\n        GPtrDiff_t iPixel = 0;\n\n        if( eDataType == GDT_Float32 && m_poGDS->m_nBitsPerSample == 16 )\n        {\n            for( ; iPixel < static_cast<GPtrDiff_t>(nBlockYSize) * nBlockXSize; iPixel++ )\n            {\n                GUInt32 nInWord = reinterpret_cast<const GUInt32 *>(\n                                                        pabyThisImage)[iPixel];\n                bool bClipWarn = m_poGDS->m_bClipWarn;\n                GUInt16 nHalf = FloatToHalf(nInWord, bClipWarn);\n                m_poGDS->m_bClipWarn = bClipWarn;\n                reinterpret_cast<GUInt16*>(m_poGDS->m_pabyBlockBuf)[\n                                    iPixel * m_poGDS->nBands + iBand] = nHalf;\n            }\n\n            if( poBlock != nullptr )\n            {\n                poBlock->MarkClean();\n                poBlock->DropLock();\n            }\n            continue;\n        }\n\n        for( int iY = 0; iY < nBlockYSize; ++iY )\n        {\n            GInt64 iBitOffset = iBandBitOffset + iY * nBitsPerLine;\n\n            if( m_poGDS->m_nBitsPerSample == 12 )\n            {\n                for( int iX = 0; iX < nBlockXSize; ++iX )\n                {\n                    GUInt32 nInWord =\n                        reinterpret_cast<const GUInt16 *>(\n                            pabyThisImage)[iPixel++];\n                    if( nInWord > nMaxVal )\n                    {\n                        nInWord = nMaxVal;\n                        if( !m_poGDS->m_bClipWarn )\n                        {\n                            m_poGDS->m_bClipWarn = true;\n                            ReportError(\n                                CE_Warning, CPLE_AppDefined,\n                                \"One or more pixels clipped to fit %d bit \"\n                                \"domain.\", m_poGDS->m_nBitsPerSample );\n                        }\n                    }\n\n                    if( (iBitOffset % 8) == 0 )\n                    {\n                        m_poGDS->m_pabyBlockBuf[iBitOffset>>3] =\n                            static_cast<GByte>( nInWord >> 4 );\n                        m_poGDS->m_pabyBlockBuf[(iBitOffset>>3)+1] =\n                            static_cast<GByte>(\n                                ((nInWord & 0xf) << 4) |\n                                (m_poGDS->m_pabyBlockBuf[(iBitOffset>>3)+1] &\n                                 0xf) );\n                    }\n                    else\n                    {\n                        m_poGDS->m_pabyBlockBuf[iBitOffset>>3] =\n                            static_cast<GByte>(\n                                (m_poGDS->m_pabyBlockBuf[iBitOffset>>3] &\n                                 0xf0) |\n                                (nInWord >> 8));\n                        m_poGDS->m_pabyBlockBuf[(iBitOffset>>3)+1] =\n                            static_cast<GByte>(nInWord & 0xff);\n                    }\n\n                    iBitOffset += iPixelBitSkip;\n                }\n                continue;\n            }\n\n            for( int iX = 0; iX < nBlockXSize; ++iX )\n            {\n                GUInt32 nInWord = 0;\n                if( eDataType == GDT_Byte )\n                {\n                    nInWord =\n                        static_cast<const GByte *>(pabyThisImage)[iPixel++];\n                }\n                else if( eDataType == GDT_UInt16 )\n                {\n                    nInWord = reinterpret_cast<const GUInt16 *>(\n                        pabyThisImage)[iPixel++];\n                }\n                else if( eDataType == GDT_UInt32 )\n                {\n                    nInWord = reinterpret_cast<const GUInt32 *>(\n                        pabyThisImage)[iPixel++];\n                }\n                else\n                {\n                    CPLAssert(false);\n                }\n\n                if( nInWord > nMaxVal )\n                {\n                    nInWord = nMaxVal;\n                    if( !m_poGDS->m_bClipWarn )\n                    {\n                        m_poGDS->m_bClipWarn = true;\n                        ReportError(\n                            CE_Warning, CPLE_AppDefined,\n                            \"One or more pixels clipped to fit %d bit domain.\",\n                            m_poGDS->m_nBitsPerSample );\n                    }\n                }\n\n                if( m_poGDS->m_nBitsPerSample == 24 )\n                {\n/* -------------------------------------------------------------------- */\n/*      Special case for 24bit data which is pre-byteswapped since      */\n/*      the size falls on a byte boundary ... ugh (#2361).              */\n/* -------------------------------------------------------------------- */\n#ifdef CPL_MSB\n                    m_poGDS->m_pabyBlockBuf[(iBitOffset>>3) + 0] =\n                        static_cast<GByte>(nInWord);\n                    m_poGDS->m_pabyBlockBuf[(iBitOffset>>3) + 1] =\n                        static_cast<GByte>(nInWord >> 8);\n                    m_poGDS->m_pabyBlockBuf[(iBitOffset>>3) + 2] =\n                        static_cast<GByte>(nInWord >> 16);\n#else\n                    m_poGDS->m_pabyBlockBuf[(iBitOffset>>3) + 0] =\n                        static_cast<GByte>(nInWord >> 16);\n                    m_poGDS->m_pabyBlockBuf[(iBitOffset>>3) + 1] =\n                        static_cast<GByte>(nInWord >> 8);\n                    m_poGDS->m_pabyBlockBuf[(iBitOffset>>3) + 2] =\n                        static_cast<GByte>(nInWord);\n#endif\n                    iBitOffset += 24;\n                }\n                else\n                {\n                    for( int iBit = 0; iBit < m_poGDS->m_nBitsPerSample; ++iBit )\n                    {\n                        // TODO(schwehr): Revisit this block.\n                        if( nInWord &\n                            (1 << (m_poGDS->m_nBitsPerSample - 1 - iBit)) )\n                        {\n                            m_poGDS->m_pabyBlockBuf[iBitOffset>>3] |=\n                                ( 0x80 >> (iBitOffset & 7) );\n                        }\n                        else\n                        {\n                            // We must explicitly unset the bit as we\n                            // may update an existing block.\n                            m_poGDS->m_pabyBlockBuf[iBitOffset>>3] &=\n                                ~(0x80 >>(iBitOffset & 7));\n                        }\n\n                        ++iBitOffset;\n                    }\n                }\n\n                iBitOffset = iBitOffset + iPixelBitSkip - m_poGDS->m_nBitsPerSample;\n            }\n        }\n\n        if( poBlock != nullptr )\n        {\n            poBlock->MarkClean();\n            poBlock->DropLock();\n        }\n    }\n\n    m_poGDS->m_bLoadedBlockDirty = true;\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                             IReadBlock()                             */\n/************************************************************************/\n\nstatic void ExpandPacked8ToByte1( const GByte * const CPL_RESTRICT pabySrc,\n                                  GByte* const CPL_RESTRICT pabyDest,\n                                  GPtrDiff_t nBytes )\n{\n    for( decltype(nBytes) i = 0, j = 0; i < nBytes; i++, j+= 8 )\n    {\n        const GByte byVal = pabySrc[i];\n        pabyDest[j+0] = (byVal >> 7) & 0x1;\n        pabyDest[j+1] = (byVal >> 6) & 0x1;\n        pabyDest[j+2] = (byVal >> 5) & 0x1;\n        pabyDest[j+3] = (byVal >> 4) & 0x1;\n        pabyDest[j+4] = (byVal >> 3) & 0x1;\n        pabyDest[j+5] = (byVal >> 2) & 0x1;\n        pabyDest[j+6] = (byVal >> 1) & 0x1;\n        pabyDest[j+7] = (byVal >> 0) & 0x1;\n    }\n}\n\n#if defined(__GNUC__) || defined(_MSC_VER)\n// Signedness of char implementation dependent, so be explicit.\n// Assumes 2-complement integer types and sign extension of right shifting\n// GCC guarantees such:\n// https://gcc.gnu.org/onlinedocs/gcc/Integers-implementation.html#Integers-implementation\nstatic inline GByte ExtractBitAndConvertTo255(GByte byVal, int nBit)\n{\n    return\n        static_cast<GByte>(static_cast<signed char>(byVal << (7 - nBit)) >> 7);\n}\n#else\n// Portable way\nstatic inline GByte ExtractBitAndConvertTo255(GByte byVal, int nBit)\n{\n    return (byVal & (1 << nBit)) ? 255 : 0;\n}\n#endif\n\nstatic void ExpandPacked8ToByte255( const GByte * const CPL_RESTRICT pabySrc,\n                                    GByte* const CPL_RESTRICT pabyDest,\n                                    GPtrDiff_t nBytes )\n{\n    for( decltype(nBytes) i = 0, j = 0; i < nBytes; i++, j += 8 )\n    {\n        const GByte byVal = pabySrc[i];\n        pabyDest[j+0] = ExtractBitAndConvertTo255(byVal, 7);\n        pabyDest[j+1] = ExtractBitAndConvertTo255(byVal, 6);\n        pabyDest[j+2] = ExtractBitAndConvertTo255(byVal, 5);\n        pabyDest[j+3] = ExtractBitAndConvertTo255(byVal, 4);\n        pabyDest[j+4] = ExtractBitAndConvertTo255(byVal, 3);\n        pabyDest[j+5] = ExtractBitAndConvertTo255(byVal, 2);\n        pabyDest[j+6] = ExtractBitAndConvertTo255(byVal, 1);\n        pabyDest[j+7] = ExtractBitAndConvertTo255(byVal, 0);\n    }\n}\n\nCPLErr GTiffOddBitsBand::IReadBlock( int nBlockXOff, int nBlockYOff,\n                                     void * pImage )\n\n{\n    m_poGDS->Crystalize();\n\n    CPLAssert(nBlocksPerRow != 0);\n    int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n\n    if( m_poGDS->m_nPlanarConfig == PLANARCONFIG_SEPARATE )\n        nBlockId += (nBand - 1) * m_poGDS->m_nBlocksPerBand;\n\n/* -------------------------------------------------------------------- */\n/*      Handle the case of a strip in a writable file that doesn't      */\n/*      exist yet, but that we want to read.  Just set to zeros and     */\n/*      return.                                                         */\n/* -------------------------------------------------------------------- */\n    if( nBlockId != m_poGDS->m_nLoadedBlock )\n    {\n        bool bErrOccurred = false;\n        if( !m_poGDS->IsBlockAvailable(nBlockId, nullptr, nullptr, &bErrOccurred) )\n        {\n            NullBlock( pImage );\n            if( bErrOccurred )\n                return CE_Failure;\n            return CE_None;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Load the block buffer.                                          */\n/* -------------------------------------------------------------------- */\n    {\n        const CPLErr eErr = m_poGDS->LoadBlockBuf( nBlockId );\n        if( eErr != CE_None )\n            return eErr;\n    }\n\n    if( m_poGDS->m_nBitsPerSample == 1 &&\n        (m_poGDS->nBands == 1 || m_poGDS->m_nPlanarConfig == PLANARCONFIG_SEPARATE ) )\n    {\n/* -------------------------------------------------------------------- */\n/*      Translate 1bit data to eight bit.                               */\n/* -------------------------------------------------------------------- */\n        GPtrDiff_t iDstOffset = 0;\n        const GByte * const CPL_RESTRICT m_pabyBlockBuf = m_poGDS->m_pabyBlockBuf;\n        GByte* CPL_RESTRICT pabyDest = static_cast<GByte *>(pImage);\n\n        for( int iLine = 0; iLine < nBlockYSize; ++iLine )\n        {\n            GPtrDiff_t iSrcOffsetByte = static_cast<GPtrDiff_t>((nBlockXSize + 7) >> 3) * iLine;\n\n            if( !m_poGDS->m_bPromoteTo8Bits )\n            {\n                ExpandPacked8ToByte1( m_pabyBlockBuf + iSrcOffsetByte,\n                                      pabyDest + iDstOffset,\n                                      nBlockXSize / 8 );\n            }\n            else\n            {\n                ExpandPacked8ToByte255( m_pabyBlockBuf + iSrcOffsetByte,\n                                        pabyDest + iDstOffset,\n                                        nBlockXSize / 8 );\n            }\n            GPtrDiff_t iSrcOffsetBit = (iSrcOffsetByte + nBlockXSize / 8) * 8;\n            iDstOffset += nBlockXSize & ~0x7;\n            const GByte bSetVal = m_poGDS->m_bPromoteTo8Bits ? 255 : 1;\n            for( int iPixel = nBlockXSize & ~0x7 ;\n                 iPixel < nBlockXSize;\n                 ++iPixel, ++iSrcOffsetBit )\n            {\n                if( m_pabyBlockBuf[iSrcOffsetBit >>3] &\n                    (0x80 >> (iSrcOffsetBit & 0x7)) )\n                    static_cast<GByte *>(pImage)[iDstOffset++] = bSetVal;\n                else\n                    static_cast<GByte *>(pImage)[iDstOffset++] = 0;\n            }\n        }\n    }\n/* -------------------------------------------------------------------- */\n/*      Handle the case of 16- and 24-bit floating point data as per    */\n/*      TIFF Technical Note 3.                                          */\n/* -------------------------------------------------------------------- */\n    else if( eDataType == GDT_Float32 )\n    {\n        const int nWordBytes = m_poGDS->m_nBitsPerSample / 8;\n        const GByte *pabyImage = m_poGDS->m_pabyBlockBuf +\n            ( ( m_poGDS->m_nPlanarConfig == PLANARCONFIG_SEPARATE ) ? 0 :\n              (nBand - 1) * nWordBytes );\n        const int iSkipBytes =\n            ( m_poGDS->m_nPlanarConfig == PLANARCONFIG_SEPARATE ) ?\n            nWordBytes : m_poGDS->nBands * nWordBytes;\n\n        const auto nBlockPixels = static_cast<GPtrDiff_t>(nBlockXSize) * nBlockYSize;\n        if( m_poGDS->m_nBitsPerSample == 16 )\n        {\n            for( GPtrDiff_t i = 0; i < nBlockPixels; ++i )\n            {\n                static_cast<GUInt32 *>(pImage)[i] =\n                    HalfToFloat( *reinterpret_cast<const GUInt16 *>(pabyImage) );\n                pabyImage += iSkipBytes;\n            }\n        }\n        else if( m_poGDS->m_nBitsPerSample == 24 )\n        {\n            for( GPtrDiff_t i = 0; i < nBlockPixels; ++i )\n            {\n#ifdef CPL_MSB\n                static_cast<GUInt32 *>(pImage)[i] =\n                    TripleToFloat(\n                        ( static_cast<GUInt32>(*(pabyImage + 0)) << 16)\n                        | (static_cast<GUInt32>(*(pabyImage + 1)) << 8)\n                        | static_cast<GUInt32>(*(pabyImage + 2)) );\n#else\n                static_cast<GUInt32 *>(pImage)[i] =\n                    TripleToFloat(\n                        ( static_cast<GUInt32>(*(pabyImage + 2)) << 16)\n                        | (static_cast<GUInt32>(*(pabyImage + 1)) << 8)\n                        | static_cast<GUInt32>(*pabyImage) );\n#endif\n                pabyImage += iSkipBytes;\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Special case for moving 12bit data somewhat more efficiently.   */\n/* -------------------------------------------------------------------- */\n    else if( m_poGDS->m_nBitsPerSample == 12 )\n    {\n        int iPixelBitSkip = 0;\n        int iBandBitOffset = 0;\n\n        if( m_poGDS->m_nPlanarConfig == PLANARCONFIG_CONTIG )\n        {\n            iPixelBitSkip = m_poGDS->nBands * m_poGDS->m_nBitsPerSample;\n            iBandBitOffset = (nBand - 1) * m_poGDS->m_nBitsPerSample;\n        }\n        else\n        {\n            iPixelBitSkip = m_poGDS->m_nBitsPerSample;\n        }\n\n        // Bits per line rounds up to next byte boundary.\n        GPtrDiff_t nBitsPerLine = static_cast<GPtrDiff_t>(nBlockXSize) * iPixelBitSkip;\n        if( (nBitsPerLine & 7) != 0 )\n            nBitsPerLine = (nBitsPerLine + 7) & (~7);\n\n        int iPixel = 0;\n        for( int iY = 0; iY < nBlockYSize; ++iY )\n        {\n            GPtrDiff_t iBitOffset = iBandBitOffset + iY * nBitsPerLine;\n\n            for( int iX = 0; iX < nBlockXSize; ++iX )\n            {\n                const auto iByte = iBitOffset >> 3;\n\n                if( (iBitOffset & 0x7) == 0 )\n                {\n                    // Starting on byte boundary.\n\n                    static_cast<GUInt16 *>(pImage)[iPixel++] =\n                        (m_poGDS->m_pabyBlockBuf[iByte] << 4)\n                        | (m_poGDS->m_pabyBlockBuf[iByte+1] >> 4);\n                }\n                else\n                {\n                    // Starting off byte boundary.\n\n                    static_cast<GUInt16 *>(pImage)[iPixel++] =\n                        ((m_poGDS->m_pabyBlockBuf[iByte] & 0xf) << 8)\n                        | (m_poGDS->m_pabyBlockBuf[iByte+1]);\n                }\n                iBitOffset += iPixelBitSkip;\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Special case for 24bit data which is pre-byteswapped since      */\n/*      the size falls on a byte boundary ... ugh (#2361).              */\n/* -------------------------------------------------------------------- */\n    else if( m_poGDS->m_nBitsPerSample == 24 )\n    {\n        int iPixelByteSkip = 0;\n        int iBandByteOffset = 0;\n\n        if( m_poGDS->m_nPlanarConfig == PLANARCONFIG_CONTIG )\n        {\n            iPixelByteSkip = (m_poGDS->nBands * m_poGDS->m_nBitsPerSample) / 8;\n            iBandByteOffset = ((nBand - 1) * m_poGDS->m_nBitsPerSample) / 8;\n        }\n        else\n        {\n            iPixelByteSkip = m_poGDS->m_nBitsPerSample / 8;\n        }\n\n        const GPtrDiff_t nBytesPerLine = static_cast<GPtrDiff_t>(nBlockXSize) * iPixelByteSkip;\n\n        GPtrDiff_t iPixel = 0;\n        for( int iY = 0; iY < nBlockYSize; ++iY )\n        {\n            GByte *pabyImage =\n                m_poGDS->m_pabyBlockBuf + iBandByteOffset + iY * nBytesPerLine;\n\n            for( int iX = 0; iX < nBlockXSize; ++iX )\n            {\n#ifdef CPL_MSB\n                static_cast<GUInt32 *>(pImage)[iPixel++] =\n                    ( static_cast<GUInt32>(*(pabyImage + 2)) << 16)\n                    | (static_cast<GUInt32>(*(pabyImage + 1)) << 8)\n                    | static_cast<GUInt32>(*(pabyImage + 0));\n#else\n                static_cast<GUInt32 *>(pImage)[iPixel++] =\n                    ( static_cast<GUInt32>(*(pabyImage + 0)) << 16)\n                    | (static_cast<GUInt32>(*(pabyImage + 1)) << 8)\n                    | static_cast<GUInt32>(*(pabyImage + 2));\n#endif\n                pabyImage += iPixelByteSkip;\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Handle 1-32 bit integer data.                                   */\n/* -------------------------------------------------------------------- */\n    else\n    {\n        unsigned iPixelBitSkip = 0;\n        unsigned iBandBitOffset = 0;\n\n        if( m_poGDS->m_nPlanarConfig == PLANARCONFIG_CONTIG )\n        {\n            iPixelBitSkip = m_poGDS->nBands * m_poGDS->m_nBitsPerSample;\n            iBandBitOffset = (nBand - 1) * m_poGDS->m_nBitsPerSample;\n        }\n        else\n        {\n            iPixelBitSkip = m_poGDS->m_nBitsPerSample;\n        }\n\n        // Bits per line rounds up to next byte boundary.\n        GUIntBig nBitsPerLine = static_cast<GUIntBig>(nBlockXSize) * iPixelBitSkip;\n        if( (nBitsPerLine & 7) != 0 )\n            nBitsPerLine = (nBitsPerLine + 7) & (~7);\n\n        const GByte * const m_pabyBlockBuf = m_poGDS->m_pabyBlockBuf;\n        const unsigned nBitsPerSample = m_poGDS->m_nBitsPerSample;\n        GPtrDiff_t iPixel = 0;\n\n        if( nBitsPerSample == 1 && eDataType == GDT_Byte )\n        {\n          for( unsigned iY = 0; iY < static_cast<unsigned>(nBlockYSize); ++iY )\n          {\n            GUIntBig iBitOffset = iBandBitOffset + iY * nBitsPerLine;\n\n            for( unsigned iX = 0; iX < static_cast<unsigned>(nBlockXSize); ++iX )\n            {\n                if( m_pabyBlockBuf[iBitOffset>>3] & (0x80 >>(iBitOffset & 7)) )\n                    static_cast<GByte *>(pImage)[iPixel] = 1;\n                else\n                    static_cast<GByte *>(pImage)[iPixel] = 0;\n                iBitOffset += iPixelBitSkip;\n                iPixel++;\n            }\n          }\n        }\n        else\n        {\n          for( unsigned iY = 0; iY < static_cast<unsigned>(nBlockYSize); ++iY )\n          {\n            GUIntBig iBitOffset = iBandBitOffset + iY * nBitsPerLine;\n\n            for( unsigned iX = 0; iX < static_cast<unsigned>(nBlockXSize); ++iX )\n            {\n                unsigned nOutWord = 0;\n\n                for( unsigned iBit = 0; iBit < nBitsPerSample; ++iBit )\n                {\n                    if( m_pabyBlockBuf[iBitOffset>>3]\n                        & (0x80 >>(iBitOffset & 7)) )\n                        nOutWord |= (1 << (nBitsPerSample - 1 - iBit));\n                    ++iBitOffset;\n                }\n\n                iBitOffset = iBitOffset + iPixelBitSkip - nBitsPerSample;\n\n                if( eDataType == GDT_Byte )\n                {\n                    static_cast<GByte *>(pImage)[iPixel++] =\n                        static_cast<GByte>(nOutWord);\n                }\n                else if( eDataType == GDT_UInt16 )\n                {\n                  static_cast<GUInt16 *>(pImage)[iPixel++] =\n                      static_cast<GUInt16>(nOutWord);\n                }\n                else if( eDataType == GDT_UInt32 )\n                {\n                  static_cast<GUInt32 *>(pImage)[iPixel++] = nOutWord;\n                }\n                else\n                {\n                    CPLAssert(false);\n                }\n            }\n          }\n        }\n    }\n\n#ifdef SUPPORTS_GET_OFFSET_BYTECOUNT\n    CacheMaskForBlock(nBlockXOff,nBlockYOff);\n#endif\n\n    return CE_None;\n}\n\n/************************************************************************/\n/* ==================================================================== */\n/*                             GTiffBitmapBand                          */\n/* ==================================================================== */\n/************************************************************************/\n\nclass GTiffBitmapBand : public GTiffOddBitsBand\n{\n    friend class GTiffDataset;\n\n    GDALColorTable *m_poColorTable = nullptr;\n\n    CPL_DISALLOW_COPY_ASSIGN(GTiffBitmapBand)\n\n  public:\n\n                   GTiffBitmapBand( GTiffDataset *, int );\n    virtual       ~GTiffBitmapBand();\n\n    virtual GDALColorInterp GetColorInterpretation() override;\n    virtual GDALColorTable *GetColorTable() override;\n};\n\n/************************************************************************/\n/*                           GTiffBitmapBand()                          */\n/************************************************************************/\n\nGTiffBitmapBand::GTiffBitmapBand( GTiffDataset *poDSIn, int nBandIn )\n        : GTiffOddBitsBand( poDSIn, nBandIn )\n\n{\n    eDataType = GDT_Byte;\n\n    if( poDSIn->m_poColorTable != nullptr )\n    {\n        m_poColorTable = poDSIn->m_poColorTable->Clone();\n    }\n    else\n    {\n#ifdef ESRI_BUILD\n        m_poColorTable = nullptr;\n#else\n        const GDALColorEntry oWhite = { 255, 255, 255, 255 };\n        const GDALColorEntry oBlack = { 0, 0, 0, 255 };\n\n        m_poColorTable = new GDALColorTable();\n\n        if( poDSIn->m_nPhotometric == PHOTOMETRIC_MINISWHITE )\n        {\n            m_poColorTable->SetColorEntry( 0, &oWhite );\n            m_poColorTable->SetColorEntry( 1, &oBlack );\n        }\n        else\n        {\n            m_poColorTable->SetColorEntry( 0, &oBlack );\n            m_poColorTable->SetColorEntry( 1, &oWhite );\n        }\n#endif  // not defined ESRI_BUILD.\n    }\n}\n\n/************************************************************************/\n/*                          ~GTiffBitmapBand()                          */\n/************************************************************************/\n\nGTiffBitmapBand::~GTiffBitmapBand()\n\n{\n    delete m_poColorTable;\n}\n\n/************************************************************************/\n/*                       GetColorInterpretation()                       */\n/************************************************************************/\n\nGDALColorInterp GTiffBitmapBand::GetColorInterpretation()\n\n{\n    if( m_poGDS->m_bPromoteTo8Bits )\n        return GCI_Undefined;\n\n    return GCI_PaletteIndex;\n}\n\n/************************************************************************/\n/*                           GetColorTable()                            */\n/************************************************************************/\n\nGDALColorTable *GTiffBitmapBand::GetColorTable()\n\n{\n    if( m_poGDS->m_bPromoteTo8Bits )\n        return nullptr;\n\n    return m_poColorTable;\n}\n\n/************************************************************************/\n/* ==================================================================== */\n/*                          GTiffSplitBitmapBand                        */\n/* ==================================================================== */\n/************************************************************************/\n\nclass GTiffSplitBitmapBand final : public GTiffBitmapBand\n{\n    friend class GTiffDataset;\n    int m_nLastLineValid = -1;\n\n  public:\n\n                   GTiffSplitBitmapBand( GTiffDataset *, int );\n    virtual       ~GTiffSplitBitmapBand();\n\n    virtual int IGetDataCoverageStatus( int nXOff, int nYOff,\n                                        int nXSize, int nYSize,\n                                        int nMaskFlagStop,\n                                        double* pdfDataPct) override;\n\n    virtual CPLErr IReadBlock( int, int, void * ) override;\n    virtual CPLErr IWriteBlock( int, int, void * ) override;\n};\n\n/************************************************************************/\n/*                       GTiffSplitBitmapBand()                         */\n/************************************************************************/\n\nGTiffSplitBitmapBand::GTiffSplitBitmapBand( GTiffDataset *poDSIn, int nBandIn )\n        : GTiffBitmapBand( poDSIn, nBandIn )\n\n{\n    nBlockXSize = poDS->GetRasterXSize();\n    nBlockYSize = 1;\n}\n\n/************************************************************************/\n/*                      ~GTiffSplitBitmapBand()                         */\n/************************************************************************/\n\nGTiffSplitBitmapBand::~GTiffSplitBitmapBand() {}\n\n\n/************************************************************************/\n/*                       IGetDataCoverageStatus()                       */\n/************************************************************************/\n\nint GTiffSplitBitmapBand::IGetDataCoverageStatus( int , int ,\n                                             int , int ,\n                                             int ,\n                                             double* )\n{\n     return GDAL_DATA_COVERAGE_STATUS_UNIMPLEMENTED |\n            GDAL_DATA_COVERAGE_STATUS_DATA;\n}\n\n/************************************************************************/\n/*                             IReadBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffSplitBitmapBand::IReadBlock( int /* nBlockXOff */, int nBlockYOff,\n                                         void * pImage )\n\n{\n    m_poGDS->Crystalize();\n\n    if( m_nLastLineValid >= 0 && nBlockYOff > m_nLastLineValid )\n        return CE_Failure;\n\n    if( m_poGDS->m_pabyBlockBuf == nullptr )\n    {\n        m_poGDS->m_pabyBlockBuf =\n            static_cast<GByte *>(\n                VSI_MALLOC_VERBOSE(TIFFScanlineSize(m_poGDS->m_hTIFF)) );\n        if( m_poGDS->m_pabyBlockBuf == nullptr )\n        {\n            return CE_Failure;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Read through to target scanline.                                */\n/* -------------------------------------------------------------------- */\n    if( m_poGDS->m_nLoadedBlock >= nBlockYOff )\n        m_poGDS->m_nLoadedBlock = -1;\n\n    while( m_poGDS->m_nLoadedBlock < nBlockYOff )\n    {\n        ++m_poGDS->m_nLoadedBlock;\n\n        std::vector<CPLErrorHandlerAccumulatorStruct> aoErrors;\n        CPLInstallErrorHandlerAccumulator(aoErrors);\n        int nRet = TIFFReadScanline( m_poGDS->m_hTIFF, m_poGDS->m_pabyBlockBuf,\n                                     m_poGDS->m_nLoadedBlock, 0 );\n        CPLUninstallErrorHandlerAccumulator();\n\n        for( size_t iError = 0; iError < aoErrors.size(); ++iError )\n        {\n            ReportError( aoErrors[iError].type,\n                      aoErrors[iError].no,\n                      \"%s\",\n                      aoErrors[iError].msg.c_str() );\n            // FAX decoding only handles EOF condition as a warning, so\n            // catch it so as to turn on error when attempting to read\n            // following lines, to avoid performance issues.\n            if(  !m_poGDS->m_bIgnoreReadErrors &&\n                    aoErrors[iError].msg.find(\"Premature EOF\") !=\n                                                    std::string::npos )\n            {\n                m_nLastLineValid = nBlockYOff;\n                nRet = -1;\n            }\n        }\n\n        if( nRet == -1\n            && !m_poGDS->m_bIgnoreReadErrors )\n        {\n            ReportError( CE_Failure, CPLE_AppDefined,\n                      \"TIFFReadScanline() failed.\" );\n            m_poGDS->m_nLoadedBlock = -1;\n            return CE_Failure;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Translate 1bit data to eight bit.                               */\n/* -------------------------------------------------------------------- */\n    int iSrcOffset = 0;\n    int iDstOffset = 0;\n\n    for( int iPixel = 0; iPixel < nBlockXSize; ++iPixel, ++iSrcOffset )\n    {\n        if( m_poGDS->m_pabyBlockBuf[iSrcOffset >>3] & (0x80 >> (iSrcOffset & 0x7)) )\n            static_cast<GByte *>(pImage)[iDstOffset++] = 1;\n        else\n            static_cast<GByte *>(pImage)[iDstOffset++] = 0;\n    }\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                            IWriteBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffSplitBitmapBand::IWriteBlock( int /* nBlockXOff */,\n                                          int /* nBlockYOff */,\n                                          void * /* pImage */ )\n\n{\n    ReportError( CE_Failure, CPLE_AppDefined,\n              \"Split bitmap bands are read-only.\" );\n    return CE_Failure;\n}\n\n/************************************************************************/\n/* ==================================================================== */\n/*                            GTiffDataset                              */\n/* ==================================================================== */\n/************************************************************************/\n\n/************************************************************************/\n/*                            GTiffDataset()                            */\n/************************************************************************/\n\nGTiffDataset::GTiffDataset():\n    m_bStreamingIn(false),\n    m_bStreamingOut(false),\n    m_bScanDeferred(true),\n    m_bSingleIFDOpened(false),\n    m_bLoadedBlockDirty(false),\n    m_bWriteError(false),\n    m_bLookedForProjection(false),\n    m_bLookedForMDAreaOrPoint(false),\n    m_bGeoTransformValid(false),\n    m_bCrystalized(true),\n    m_bGeoTIFFInfoChanged(false),\n    m_bForceUnsetGTOrGCPs(false),\n    m_bForceUnsetProjection(false),\n    m_bNoDataChanged(false),\n    m_bNoDataSet(false),\n    m_bMetadataChanged(false),\n    m_bColorProfileMetadataChanged(false),\n    m_bForceUnsetRPC(false),\n    m_bNeedsRewrite(false),\n    m_bLoadingOtherBands(false),\n    m_bIsOverview(false),\n    m_bWriteEmptyTiles(true),\n    m_bFillEmptyTilesAtClosing(false),\n    m_bTreatAsSplit(false),\n    m_bTreatAsSplitBitmap(false),\n    m_bClipWarn(false),\n    m_bIMDRPCMetadataLoaded(false),\n    m_bEXIFMetadataLoaded(false),\n    m_bICCMetadataLoaded(false),\n    m_bHasWarnedDisableAggressiveBandCaching(false),\n    m_bDontReloadFirstBlock(false),\n    m_bWebPLossless(false),\n    m_bPromoteTo8Bits(false),\n    m_bDebugDontWriteBlocks(CPLTestBool(CPLGetConfigOption(\"GTIFF_DONT_WRITE_BLOCKS\", \"NO\"))),\n    m_bIsFinalized(false),\n    m_bIgnoreReadErrors(CPLTestBool(CPLGetConfigOption(\"GTIFF_IGNORE_READ_ERRORS\", \"NO\"))),\n    m_bDirectIO(CPLTestBool(CPLGetConfigOption(\"GTIFF_DIRECT_IO\", \"NO\"))),\n    m_bReadGeoTransform(false),\n    m_bLoadPam(false),\n    m_bHasGotSiblingFiles(false),\n    m_bHasIdentifiedAuthorizedGeoreferencingSources(false),\n    m_bLayoutIFDSBeforeData(false),\n    m_bBlockOrderRowMajor(false),\n    m_bLeaderSizeAsUInt4(false),\n    m_bTrailerRepeatedLast4BytesRepeated(false),\n    m_bMaskInterleavedWithImagery(false),\n    m_bKnownIncompatibleEdition(false),\n    m_bWriteKnownIncompatibleEdition(false),\n    m_bHasUsedReadEncodedAPI(false),\n    m_bWriteCOGLayout(false)\n{\n    //CPLDebug(\"GDAL\", \"sizeof(GTiffDataset) = %d bytes\", static_cast<int>(\n    //    sizeof(GTiffDataset)));\n\n    const char* pszVirtualMemIO =\n        CPLGetConfigOption(\"GTIFF_VIRTUAL_MEM_IO\", \"NO\");\n    if( EQUAL(pszVirtualMemIO, \"IF_ENOUGH_RAM\") )\n        m_eVirtualMemIOUsage = VirtualMemIOEnum::IF_ENOUGH_RAM;\n    else if( CPLTestBool(pszVirtualMemIO) )\n        m_eVirtualMemIOUsage = VirtualMemIOEnum::YES;\n\n    m_oSRS.SetAxisMappingStrategy(OAMS_TRADITIONAL_GIS_ORDER);\n}\n\n/************************************************************************/\n/*                           ~GTiffDataset()                            */\n/************************************************************************/\n\nGTiffDataset::~GTiffDataset()\n\n{\n    Finalize();\n    if( m_pszTmpFilename )\n    {\n        VSIUnlink(m_pszTmpFilename);\n        CPLFree(m_pszTmpFilename);\n    }\n}\n\n/************************************************************************/\n/*                             Finalize()                               */\n/************************************************************************/\n\nint GTiffDataset::Finalize()\n{\n    if( m_bIsFinalized )\n        return FALSE;\n\n    bool bHasDroppedRef = false;\n\n    Crystalize();\n\n    if( m_bColorProfileMetadataChanged )\n    {\n        SaveICCProfile(this, nullptr, nullptr, 0);\n        m_bColorProfileMetadataChanged = false;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Handle forcing xml:ESRI data to be written to PAM.              */\n/* -------------------------------------------------------------------- */\n    if( CPLTestBool(CPLGetConfigOption( \"ESRI_XML_PAM\", \"NO\" )) )\n    {\n        char **papszESRIMD = GTiffDataset::GetMetadata(\"xml:ESRI\");\n        if( papszESRIMD )\n        {\n            GDALPamDataset::SetMetadata( papszESRIMD, \"xml:ESRI\");\n        }\n    }\n\n    if( m_psVirtualMemIOMapping )\n        CPLVirtualMemFree( m_psVirtualMemIOMapping );\n    m_psVirtualMemIOMapping = nullptr;\n\n/* -------------------------------------------------------------------- */\n/*      Fill in missing blocks with empty data.                         */\n/* -------------------------------------------------------------------- */\n    if( m_bFillEmptyTilesAtClosing )\n    {\n/* -------------------------------------------------------------------- */\n/*  Ensure any blocks write cached by GDAL gets pushed through libtiff. */\n/* -------------------------------------------------------------------- */\n        FlushCacheInternal( false /* do not call FlushDirectory */ );\n\n        FillEmptyTiles();\n        m_bFillEmptyTilesAtClosing = false;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Force a complete flush, including either rewriting(moving)      */\n/*      of writing in place the current directory.                      */\n/* -------------------------------------------------------------------- */\n    FlushCacheInternal( true );\n\n    // Destroy compression queue\n    if( m_poCompressQueue )\n    {\n        m_poCompressQueue->WaitCompletion();\n\n        for( int i = 0; i < static_cast<int>(m_asCompressionJobs.size()); ++i )\n        {\n            CPLFree(m_asCompressionJobs[i].pabyBuffer);\n            if( m_asCompressionJobs[i].pszTmpFilename )\n            {\n                VSIUnlink(m_asCompressionJobs[i].pszTmpFilename);\n                CPLFree(m_asCompressionJobs[i].pszTmpFilename);\n            }\n        }\n        CPLDestroyMutex(m_hCompressThreadPoolMutex);\n        m_poCompressQueue.reset();\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If there is still changed metadata, then presumably we want     */\n/*      to push it into PAM.                                            */\n/* -------------------------------------------------------------------- */\n    if( m_bMetadataChanged )\n    {\n        PushMetadataToPam();\n        m_bMetadataChanged = false;\n        GDALPamDataset::FlushCache();\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Cleanup overviews.                                              */\n/* -------------------------------------------------------------------- */\n    if( !m_poBaseDS )\n    {\n        for( int i = 0; i < m_nOverviewCount; ++i )\n        {\n            delete m_papoOverviewDS[i];\n            bHasDroppedRef = true;\n        }\n        m_nOverviewCount = 0;\n\n        for( int i = 0; i < m_nJPEGOverviewCountOri; ++i )\n        {\n            delete m_papoJPEGOverviewDS[i];\n            bHasDroppedRef = true;\n        }\n        m_nJPEGOverviewCount = 0;\n        m_nJPEGOverviewCountOri = 0;\n        CPLFree( m_papoJPEGOverviewDS );\n        m_papoJPEGOverviewDS = nullptr;\n    }\n\n    // If we are a mask dataset, we can have overviews, but we don't\n    // own them. We can only free the array, not the overviews themselves.\n    CPLFree( m_papoOverviewDS );\n    m_papoOverviewDS = nullptr;\n\n    // m_poMaskDS is owned by the main image and the overviews\n    // so because of the latter case, we can delete it even if\n    // we are not the base image.\n    if( m_poMaskDS )\n    {\n        delete m_poMaskDS;\n        m_poMaskDS = nullptr;\n        bHasDroppedRef = true;\n    }\n\n    if( m_poColorTable != nullptr )\n        delete m_poColorTable;\n    m_poColorTable = nullptr;\n\n    if( m_hTIFF )\n    {\n        XTIFFClose( m_hTIFF );\n        m_hTIFF = nullptr;\n    }\n\n    if ( !m_poBaseDS ) \n    {\n        if( m_fpL != nullptr )\n        {\n            if( m_bWriteKnownIncompatibleEdition )\n            {\n                GByte abyHeader[4096];\n                VSIFSeekL( m_fpL, 0, SEEK_SET );\n                VSIFReadL( abyHeader, 1, sizeof(abyHeader), m_fpL );\n                const char* szKeyToLook = \"KNOWN_INCOMPATIBLE_EDITION=NO\\n \"; // trailing space intended\n                for( size_t i = 0; i < sizeof(abyHeader) - strlen(szKeyToLook); i++ )\n                {\n                    if( memcmp(abyHeader + i, szKeyToLook, strlen(szKeyToLook)) == 0 )\n                    {\n                        const char* szNewKey = \"KNOWN_INCOMPATIBLE_EDITION=YES\\n\";\n                        CPLAssert( strlen(szKeyToLook) == strlen(szNewKey) );\n                        memcpy(abyHeader + i, szNewKey, strlen(szNewKey));\n                        VSIFSeekL( m_fpL, 0, SEEK_SET );\n                        VSIFWriteL( abyHeader, 1, sizeof(abyHeader), m_fpL );\n                        break;\n                    }\n                }\n            }\n            if( VSIFCloseL( m_fpL ) != 0 )\n            {\n                ReportError(CE_Failure, CPLE_FileIO, \"I/O error\");\n            }\n            m_fpL = nullptr;\n        }\n    }\n\n    if( m_fpToWrite != nullptr )\n    {\n        if( VSIFCloseL( m_fpToWrite ) != 0 )\n        {\n            ReportError(CE_Failure, CPLE_FileIO, \"I/O error\");\n        }\n        m_fpToWrite = nullptr;\n    }\n\n    if( m_nGCPCount > 0 )\n    {\n        GDALDeinitGCPs( m_nGCPCount, m_pasGCPList );\n        CPLFree( m_pasGCPList );\n        m_pasGCPList = nullptr;\n        m_nGCPCount = 0;\n    }\n\n    CSLDestroy( m_papszCreationOptions );\n    m_papszCreationOptions = nullptr;\n\n    CPLFree(m_pabyTempWriteBuffer);\n    m_pabyTempWriteBuffer = nullptr;\n\n    m_bIMDRPCMetadataLoaded = false;\n    CSLDestroy(m_papszMetadataFiles);\n    m_papszMetadataFiles = nullptr;\n\n    VSIFree(m_pTempBufferForCommonDirectIO);\n    m_pTempBufferForCommonDirectIO = nullptr;\n\n    CPLFree(m_panMaskOffsetLsb);\n    m_panMaskOffsetLsb = nullptr;\n\n    CPLFree(m_pszVertUnit);\n    m_pszVertUnit = nullptr;\n\n    CPLFree(m_pszFilename);\n    m_pszFilename = nullptr;\n\n    CPLFree(m_pszGeorefFilename);\n    m_pszGeorefFilename = nullptr;\n\n    m_bIsFinalized = true;\n\n    return bHasDroppedRef;\n}\n\n/************************************************************************/\n/*                        CloseDependentDatasets()                      */\n/************************************************************************/\n\nint GTiffDataset::CloseDependentDatasets()\n{\n    if( m_poBaseDS )\n        return FALSE;\n\n    int bHasDroppedRef = GDALPamDataset::CloseDependentDatasets();\n\n    bHasDroppedRef |= Finalize();\n\n    return bHasDroppedRef;\n}\n\n/************************************************************************/\n/*                        GetJPEGOverviewCount()                        */\n/************************************************************************/\n\nint GTiffDataset::GetJPEGOverviewCount()\n{\n    if( m_nJPEGOverviewCount >= 0 )\n        return m_nJPEGOverviewCount;\n\n    m_nJPEGOverviewCount = 0;\n    if( m_poBaseDS || eAccess != GA_ReadOnly || m_nCompression != COMPRESSION_JPEG ||\n        (nRasterXSize < 256 && nRasterYSize < 256) ||\n        !CPLTestBool(CPLGetConfigOption(\"GTIFF_IMPLICIT_JPEG_OVR\", \"YES\")) ||\n        GDALGetDriverByName(\"JPEG\") == nullptr )\n    {\n        return 0;\n    }\n    const char* pszSourceColorSpace =\n        m_oGTiffMDMD.GetMetadataItem( \"SOURCE_COLOR_SPACE\", \"IMAGE_STRUCTURE\" );\n    if( pszSourceColorSpace != nullptr && EQUAL(pszSourceColorSpace, \"CMYK\") )\n    {\n        // We cannot handle implicit overviews on JPEG CMYK datasets converted\n        // to RGBA This would imply doing the conversion in\n        // GTiffJPEGOverviewBand.\n        return 0;\n    }\n\n    // libjpeg-6b only supports 2, 4 and 8 scale denominators.\n    // TODO: Later versions support more.\n    for( signed char i = 2; i >= 0; i-- )\n    {\n        if( nRasterXSize >= (256 << i) || nRasterYSize >= (256 << i) )\n        {\n            m_nJPEGOverviewCount = i + 1;\n            break;\n        }\n    }\n    if( m_nJPEGOverviewCount == 0 )\n        return 0;\n\n    // Get JPEG tables.\n    uint32 nJPEGTableSize = 0;\n    void* pJPEGTable = nullptr;\n    GByte abyFFD8[] = { 0xFF, 0xD8 };\n    if( TIFFGetField(m_hTIFF, TIFFTAG_JPEGTABLES, &nJPEGTableSize, &pJPEGTable) )\n    {\n        if( pJPEGTable == nullptr ||\n            nJPEGTableSize > INT_MAX ||\n            static_cast<GByte*>(pJPEGTable)[nJPEGTableSize-1] != 0xD9 )\n        {\n            m_nJPEGOverviewCount = 0;\n            return 0;\n        }\n        nJPEGTableSize--;  // Remove final 0xD9.\n    }\n    else\n    {\n        pJPEGTable = abyFFD8;\n        nJPEGTableSize = 2;\n    }\n\n    m_papoJPEGOverviewDS =\n        static_cast<GTiffJPEGOverviewDS **>(\n            CPLMalloc( sizeof(GTiffJPEGOverviewDS*) * m_nJPEGOverviewCount ) );\n    for( int i = 0; i < m_nJPEGOverviewCount; ++i )\n    {\n        m_papoJPEGOverviewDS[i] =\n            new GTiffJPEGOverviewDS(\n                this, i + 1,\n                pJPEGTable, static_cast<int>(nJPEGTableSize) );\n    }\n\n    m_nJPEGOverviewCountOri = m_nJPEGOverviewCount;\n\n    return m_nJPEGOverviewCount;\n}\n\n/************************************************************************/\n/*                           FillEmptyTiles()                           */\n/************************************************************************/\n\nvoid GTiffDataset::FillEmptyTiles()\n\n{\n/* -------------------------------------------------------------------- */\n/*      How many blocks are there in this file?                         */\n/* -------------------------------------------------------------------- */\n    const int nBlockCount =\n        m_nPlanarConfig == PLANARCONFIG_SEPARATE ?\n        m_nBlocksPerBand * nBands :\n        m_nBlocksPerBand;\n\n/* -------------------------------------------------------------------- */\n/*      Fetch block maps.                                               */\n/* -------------------------------------------------------------------- */\n    toff_t *panByteCounts = nullptr;\n\n    if( TIFFIsTiled( m_hTIFF ) )\n        TIFFGetField( m_hTIFF, TIFFTAG_TILEBYTECOUNTS, &panByteCounts );\n    else\n        TIFFGetField( m_hTIFF, TIFFTAG_STRIPBYTECOUNTS, &panByteCounts );\n\n    if( panByteCounts == nullptr )\n    {\n        // Got here with libtiff 3.9.3 and tiff_write_8 test.\n        ReportError( CE_Failure, CPLE_AppDefined,\n                  \"FillEmptyTiles() failed because panByteCounts == NULL\" );\n        return;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Prepare a blank data buffer to write for uninitialized blocks.  */\n/* -------------------------------------------------------------------- */\n    const GPtrDiff_t nBlockBytes =\n        TIFFIsTiled( m_hTIFF ) ?\n        static_cast<GPtrDiff_t>(TIFFTileSize(m_hTIFF)) :\n        static_cast<GPtrDiff_t>(TIFFStripSize(m_hTIFF));\n\n    GByte *pabyData =\n        static_cast<GByte *>( VSI_CALLOC_VERBOSE(nBlockBytes, 1) );\n    if( pabyData == nullptr )\n    {\n        return;\n    }\n\n    // Force tiles completely filled with the nodata value to be written.\n    m_bWriteEmptyTiles = true;\n\n/* -------------------------------------------------------------------- */\n/*      If set, fill data buffer with no data value.                    */\n/* -------------------------------------------------------------------- */\n    if( m_bNoDataSet && m_dfNoDataValue != 0.0 )\n    {\n        const GDALDataType eDataType = GetRasterBand( 1 )->GetRasterDataType();\n        const int nDataTypeSize = GDALGetDataTypeSizeBytes( eDataType );\n        if( nDataTypeSize &&\n            nDataTypeSize * 8 == static_cast<int>(m_nBitsPerSample) )\n        {\n            GDALCopyWords64( &m_dfNoDataValue, GDT_Float64, 0,\n                           pabyData, eDataType,\n                           nDataTypeSize,\n                           nBlockBytes / nDataTypeSize );\n        }\n        else if( nDataTypeSize )\n        {\n            // Handle non power-of-two depths.\n            // Ideally make a packed buffer, but that is a bit tedious,\n            // so use the normal I/O interfaces.\n\n            CPLFree( pabyData );\n\n            pabyData = static_cast<GByte *>(\n                VSI_MALLOC3_VERBOSE(m_nBlockXSize, m_nBlockYSize, nDataTypeSize) );\n            if( pabyData == nullptr )\n                return;\n            GDALCopyWords64( &m_dfNoDataValue, GDT_Float64, 0,\n                           pabyData, eDataType,\n                           nDataTypeSize,\n                           static_cast<GPtrDiff_t>(m_nBlockXSize) * m_nBlockYSize );\n            const int nBlocksPerRow = DIV_ROUND_UP(nRasterXSize, m_nBlockYSize);\n            for( int iBlock = 0; iBlock < nBlockCount; ++iBlock )\n            {\n                if( panByteCounts[iBlock] == 0 )\n                {\n                    if( m_nPlanarConfig == PLANARCONFIG_SEPARATE || nBands == 1 )\n                    {\n                        CPL_IGNORE_RET_VAL( GetRasterBand(\n                            1 + iBlock / m_nBlocksPerBand )->WriteBlock(\n                                (iBlock % m_nBlocksPerBand) % nBlocksPerRow,\n                                (iBlock % m_nBlocksPerBand) / nBlocksPerRow,\n                                pabyData ) );\n                    }\n                    else\n                    {\n                        // In contig case, don't directly call WriteBlock(), as\n                        // it could cause useless decompression-recompression.\n                        const int nXOff =\n                            (iBlock % nBlocksPerRow) * m_nBlockXSize;\n                        const int nYOff =\n                            (iBlock / nBlocksPerRow) * m_nBlockYSize;\n                        const int nXSize =\n                            (nXOff + m_nBlockXSize <= nRasterXSize) ?\n                            m_nBlockXSize : nRasterXSize - nXOff;\n                        const int nYSize =\n                            (nYOff + m_nBlockYSize <= nRasterYSize) ?\n                            m_nBlockYSize : nRasterYSize - nYOff;\n                        for( int iBand = 1; iBand <= nBands; ++iBand )\n                        {\n                            CPL_IGNORE_RET_VAL( GetRasterBand( iBand )->\n                                RasterIO(\n                                    GF_Write, nXOff, nYOff, nXSize, nYSize,\n                                    pabyData, nXSize, nYSize,\n                                    eDataType, 0, 0, nullptr ) );\n                        }\n                    }\n                }\n            }\n            CPLFree( pabyData );\n            return;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      When we must fill with zeroes, try to create non-sparse file    */\n/*      w.r.t TIFF spec ... as a sparse file w.r.t filesystem, ie by    */\n/*      seeking to end of file instead of writing zero blocks.          */\n/* -------------------------------------------------------------------- */\n    else if( m_nCompression == COMPRESSION_NONE && (m_nBitsPerSample % 8) == 0 )\n    {\n        // Only use libtiff to write the first sparse block to ensure that it\n        // will serialize offset and count arrays back to disk.\n        int nCountBlocksToZero = 0;\n        for( int iBlock = 0; iBlock < nBlockCount; ++iBlock )\n        {\n            if( panByteCounts[iBlock] == 0 )\n            {\n                if( nCountBlocksToZero == 0 )\n                {\n                    const bool bWriteEmptyTilesBak = m_bWriteEmptyTiles;\n                    m_bWriteEmptyTiles = true;\n                    const bool bOK =\n                        WriteEncodedTileOrStrip( iBlock, pabyData,\n                                                 FALSE ) == CE_None;\n                    m_bWriteEmptyTiles = bWriteEmptyTilesBak;\n                    if( !bOK )\n                        break;\n                }\n                nCountBlocksToZero++;\n            }\n        }\n        CPLFree( pabyData );\n\n        --nCountBlocksToZero;\n\n        // And then seek to end of file for other ones.\n        if( nCountBlocksToZero > 0 )\n        {\n            toff_t *panByteOffsets = nullptr;\n\n            if( TIFFIsTiled( m_hTIFF ) )\n                TIFFGetField( m_hTIFF, TIFFTAG_TILEOFFSETS, &panByteOffsets );\n            else\n                TIFFGetField( m_hTIFF, TIFFTAG_STRIPOFFSETS, &panByteOffsets );\n\n            if( panByteOffsets == nullptr )\n            {\n                ReportError(\n                    CE_Failure, CPLE_AppDefined,\n                    \"FillEmptyTiles() failed because panByteOffsets == NULL\");\n                return;\n            }\n\n            VSILFILE* fpTIF = VSI_TIFFGetVSILFile(TIFFClientdata( m_hTIFF ));\n            VSIFSeekL( fpTIF, 0, SEEK_END );\n            const vsi_l_offset nOffset = VSIFTellL(fpTIF);\n\n            vsi_l_offset iBlockToZero = 0;\n            for( int iBlock = 0; iBlock < nBlockCount; ++iBlock )\n            {\n                if( panByteCounts[iBlock] == 0 )\n                {\n                    panByteOffsets[iBlock] = static_cast<toff_t>(\n                                        nOffset + iBlockToZero * nBlockBytes);\n                    panByteCounts[iBlock] = nBlockBytes;\n                    iBlockToZero++;\n                }\n            }\n            CPLAssert( iBlockToZero ==\n                       static_cast<vsi_l_offset>(nCountBlocksToZero) );\n\n            if( VSIFTruncateL( fpTIF,\n                               nOffset + iBlockToZero * nBlockBytes ) != 0 )\n            {\n                ReportError(CE_Failure, CPLE_FileIO,\n                         \"Cannot initialize empty blocks\");\n            }\n        }\n\n        return;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Check all blocks, writing out data for uninitialized blocks.    */\n/* -------------------------------------------------------------------- */\n\n    GByte* pabyRaw = nullptr;\n    vsi_l_offset nRawSize = 0;\n    for( int iBlock = 0; iBlock < nBlockCount; ++iBlock )\n    {\n        if( panByteCounts[iBlock] == 0 )\n        {\n            if( pabyRaw == nullptr )\n            {\n                if( WriteEncodedTileOrStrip( iBlock, pabyData, FALSE\n                                                                ) != CE_None )\n                    break;\n\n                vsi_l_offset nOffset = 0;\n                bool b = IsBlockAvailable( iBlock, &nOffset, &nRawSize);\n                CPL_IGNORE_RET_VAL(b);\n                CPLAssert(b);\n\n                // When using compression, get back the compressed block\n                // so we can use the raw API to write it faster.\n                if( m_nCompression != COMPRESSION_NONE )\n                {\n                    pabyRaw = static_cast<GByte*>(\n                            VSI_MALLOC_VERBOSE(static_cast<size_t>(nRawSize)));\n                    if( pabyRaw )\n                    {\n                        VSILFILE* fp = VSI_TIFFGetVSILFile(\n                                                    TIFFClientdata( m_hTIFF ));\n                        const vsi_l_offset nCurOffset = VSIFTellL(fp);\n                        VSIFSeekL(fp, nOffset, SEEK_SET);\n                        VSIFReadL(pabyRaw, 1, static_cast<size_t>(nRawSize), fp);\n                        VSIFSeekL(fp, nCurOffset, SEEK_SET);\n                    }\n                }\n            }\n            else\n            {\n                WriteRawStripOrTile( iBlock, pabyRaw,\n                                     static_cast<GPtrDiff_t>(nRawSize) );\n            }\n        }\n    }\n\n    CPLFree( pabyData );\n    VSIFree( pabyRaw );\n}\n\n/************************************************************************/\n/*                         HasOnlyNoData()                              */\n/************************************************************************/\n\ntemplate<class T>\nstatic inline bool IsEqualToNoData( T value, T noDataValue )\n{\n    return value == noDataValue;\n}\n\ntemplate<> bool IsEqualToNoData<float>( float value, float noDataValue )\n{\n    return\n        CPLIsNan(noDataValue) ?\n        CPL_TO_BOOL(CPLIsNan(value)) : value == noDataValue;\n}\n\ntemplate<> bool IsEqualToNoData<double>( double value, double noDataValue )\n{\n    return\n        CPLIsNan(noDataValue) ?\n        CPL_TO_BOOL(CPLIsNan(value)) : value == noDataValue;\n}\n\ntemplate<class T>\nbool GTiffDataset::HasOnlyNoDataT( const T* pBuffer, int nWidth, int nHeight,\n                                   int nLineStride, int nComponents ) const\n{\n    const T noDataValue = static_cast<T>((m_bNoDataSet) ? m_dfNoDataValue : 0.0);\n\n    CPLAssert(m_nBitsPerSample != 1 || noDataValue == 0);\n\n    // Fast test: check the 4 corners and the middle pixel.\n    for( int iBand = 0; iBand < nComponents; iBand++ )\n    {\n        if( !(IsEqualToNoData(pBuffer[iBand], noDataValue) &&\n              IsEqualToNoData(\n                  pBuffer[static_cast<size_t>(nWidth - 1) * nComponents +\n                          iBand],\n                  noDataValue) &&\n              IsEqualToNoData(\n                  pBuffer[(static_cast<size_t>(nHeight-1)/2 * nLineStride +\n                           (nWidth - 1)/2) * nComponents + iBand],\n                  noDataValue) &&\n              IsEqualToNoData(\n                  pBuffer[static_cast<size_t>(nHeight - 1) * nLineStride *\n                          nComponents + iBand], noDataValue) &&\n              IsEqualToNoData(\n                  pBuffer[(static_cast<size_t>(nHeight - 1) * nLineStride +\n                           nWidth - 1) * nComponents + iBand], noDataValue) ) )\n        {\n            return false;\n        }\n    }\n\n    // Test all pixels.\n    for( int iY = 0; iY < nHeight; iY++ )\n    {\n        for( int iX = 0; iX < nWidth * nComponents; iX++ )\n        {\n            if( !IsEqualToNoData(\n                   pBuffer[iY * static_cast<size_t>(nLineStride) * nComponents +\n                           iX], noDataValue) )\n            {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nbool GTiffDataset::HasOnlyNoData( const void* pBuffer, int nWidth, int nHeight,\n                                  int nLineStride, int nComponents )\n{\n    const GDALDataType eDT = GetRasterBand(1)->GetRasterDataType();\n\n    // In the case where the nodata is 0, we can compare several bytes at\n    // once. Select the largest natural integer type for the architecture.\n#if SIZEOF_VOIDP == 8 || defined(__x86_64__)\n    // We test __x86_64__ for x32 arch where SIZEOF_VOIDP == 4\n    typedef GUInt64 WordType;\n#else\n    typedef unsigned int WordType;\n#endif\n    if( (!m_bNoDataSet || m_dfNoDataValue == 0.0) && nWidth == nLineStride )\n    {\n        const GByte* pabyBuffer = static_cast<const GByte*>(pBuffer);\n        const size_t nSize = (static_cast<size_t>(nWidth) * nHeight *\n                                nComponents * m_nBitsPerSample + 7) / 8;\n        size_t i = 0;\n        const size_t nInitialIters = std::min(\n            sizeof(WordType) -\n                (reinterpret_cast<std::uintptr_t>(pabyBuffer) % sizeof(WordType)),\n            nSize);\n        for( ; i < nInitialIters; i++ )\n        {\n            if( pabyBuffer[i] )\n                return false;\n        }\n        for( ; i + sizeof(WordType) - 1 < nSize; i += sizeof(WordType) )\n        {\n            if( *(reinterpret_cast<const WordType*>(pabyBuffer + i)) )\n                return false;\n        }\n        for( ; i < nSize; i++ )\n        {\n            if( pabyBuffer[i] )\n                return false;\n        }\n        return true;\n    }\n\n    if( m_nBitsPerSample == 8 )\n    {\n        if( m_nSampleFormat == SAMPLEFORMAT_INT )\n        {\n            return HasOnlyNoDataT(static_cast<const signed char*>(pBuffer),\n                                  nWidth, nHeight, nLineStride, nComponents);\n        }\n        return HasOnlyNoDataT(static_cast<const GByte*>(pBuffer),\n                              nWidth, nHeight, nLineStride, nComponents);\n    }\n    if( m_nBitsPerSample == 16 && eDT == GDT_UInt16 )\n    {\n        return HasOnlyNoDataT(static_cast<const GUInt16*>(pBuffer),\n                              nWidth, nHeight, nLineStride, nComponents);\n    }\n    if( m_nBitsPerSample == 16 && eDT== GDT_Int16 )\n    {\n        return HasOnlyNoDataT(static_cast<const GInt16*>(pBuffer),\n                              nWidth, nHeight, nLineStride, nComponents);\n    }\n    if( m_nBitsPerSample == 32 && eDT == GDT_UInt32 )\n    {\n        return HasOnlyNoDataT(static_cast<const GUInt32*>(pBuffer),\n                              nWidth, nHeight, nLineStride, nComponents);\n    }\n    if( m_nBitsPerSample == 32 && eDT == GDT_Int32 )\n    {\n        return HasOnlyNoDataT(static_cast<const GInt32*>(pBuffer),\n                              nWidth, nHeight, nLineStride, nComponents);\n    }\n    if( m_nBitsPerSample == 32 && eDT == GDT_Float32 )\n    {\n        return HasOnlyNoDataT(static_cast<const float*>(pBuffer),\n                              nWidth, nHeight, nLineStride, nComponents);\n    }\n    if( m_nBitsPerSample == 64 && eDT == GDT_Float64 )\n    {\n        return HasOnlyNoDataT(static_cast<const double*>(pBuffer),\n                              nWidth, nHeight, nLineStride, nComponents);\n    }\n    return false;\n}\n\n/************************************************************************/\n/*                     IsFirstPixelEqualToNoData()                      */\n/************************************************************************/\n\ninline bool GTiffDataset::IsFirstPixelEqualToNoData( const void* pBuffer )\n{\n    const GDALDataType eDT = GetRasterBand(1)->GetRasterDataType();\n    const double dfEffectiveNoData = (m_bNoDataSet) ? m_dfNoDataValue : 0.0;\n    if( m_nBitsPerSample == 8 || (m_nBitsPerSample < 8 && dfEffectiveNoData == 0) )\n    {\n        if( m_nSampleFormat == SAMPLEFORMAT_INT )\n        {\n            return GDALIsValueInRange<signed char>(dfEffectiveNoData) &&\n                   *(static_cast<const signed char*>(pBuffer)) ==\n                        static_cast<signed char>(dfEffectiveNoData);\n        }\n        return GDALIsValueInRange<GByte>(dfEffectiveNoData) &&\n               *(static_cast<const GByte*>(pBuffer)) ==\n                        static_cast<GByte>(dfEffectiveNoData);\n    }\n    if( m_nBitsPerSample == 16 && eDT == GDT_UInt16 )\n    {\n        return GDALIsValueInRange<GUInt16>(dfEffectiveNoData) &&\n               *(static_cast<const GUInt16*>(pBuffer)) ==\n                        static_cast<GUInt16>(dfEffectiveNoData);\n    }\n    if( m_nBitsPerSample == 16 && eDT == GDT_Int16 )\n    {\n        return GDALIsValueInRange<GInt16>(dfEffectiveNoData) &&\n               *(static_cast<const GInt16*>(pBuffer)) ==\n                        static_cast<GInt16>(dfEffectiveNoData);\n    }\n    if( m_nBitsPerSample == 32 && eDT == GDT_UInt32 )\n    {\n        return GDALIsValueInRange<GUInt32>(dfEffectiveNoData) &&\n               *(static_cast<const GUInt32*>(pBuffer)) ==\n                        static_cast<GUInt32>(dfEffectiveNoData);\n    }\n    if( m_nBitsPerSample == 32 && eDT == GDT_Int32 )\n    {\n        return GDALIsValueInRange<GInt32>(dfEffectiveNoData) &&\n               *(static_cast<const GInt32*>(pBuffer)) ==\n                        static_cast<GInt32>(dfEffectiveNoData);\n    }\n    if( m_nBitsPerSample == 32 && eDT == GDT_Float32 )\n    {\n        if( CPLIsNan(m_dfNoDataValue) )\n            return CPL_TO_BOOL(\n                CPLIsNan(*(static_cast<const float*>(pBuffer))));\n        return GDALIsValueInRange<float>(dfEffectiveNoData) &&\n               *(static_cast<const float*>(pBuffer)) ==\n                        static_cast<float>(dfEffectiveNoData);\n    }\n    if( m_nBitsPerSample == 64 && eDT == GDT_Float64 )\n    {\n        if( CPLIsNan(dfEffectiveNoData) )\n            return CPL_TO_BOOL(\n                CPLIsNan(*(static_cast<const double*>(pBuffer))));\n        return *(static_cast<const double*>(pBuffer)) == dfEffectiveNoData;\n    }\n    return false;\n}\n\n/************************************************************************/\n/*                        WriteEncodedTile()                            */\n/************************************************************************/\n\nbool GTiffDataset::WriteEncodedTile( uint32 tile, GByte *pabyData,\n                                     int bPreserveDataBuffer )\n{\n    int iRow = 0;\n    int iColumn = 0;\n    int nBlocksPerRow = 1;\n    int nBlocksPerColumn = 1;\n\n/* -------------------------------------------------------------------- */\n/*      Don't write empty blocks in some cases.                         */\n/* -------------------------------------------------------------------- */\n    if( !m_bWriteEmptyTiles && IsFirstPixelEqualToNoData(pabyData) )\n    {\n        if( !IsBlockAvailable(tile) )\n        {\n            const int nComponents =\n                m_nPlanarConfig == PLANARCONFIG_CONTIG ? nBands : 1;\n            nBlocksPerRow = DIV_ROUND_UP(nRasterXSize, m_nBlockXSize);\n            nBlocksPerColumn = DIV_ROUND_UP(nRasterYSize, m_nBlockYSize);\n\n            iColumn = (tile % m_nBlocksPerBand) % nBlocksPerRow;\n            iRow = (tile % m_nBlocksPerBand) / nBlocksPerRow;\n\n            const int nActualBlockWidth =\n                ( iColumn == nBlocksPerRow - 1 ) ?\n                nRasterXSize - iColumn * m_nBlockXSize : m_nBlockXSize;\n            const int nActualBlockHeight =\n                ( iRow == nBlocksPerColumn - 1 ) ?\n                nRasterYSize - iRow * m_nBlockYSize : m_nBlockYSize;\n\n            if( HasOnlyNoData(pabyData,\n                              nActualBlockWidth, nActualBlockHeight,\n                              m_nBlockXSize, nComponents ) )\n            {\n                return true;\n            }\n        }\n    }\n\n    // Do we need to spread edge values right or down for a partial\n    // JPEG encoded tile?  We do this to avoid edge artifacts.\n    bool bNeedTileFill = false;\n    if( m_nCompression == COMPRESSION_JPEG )\n    {\n        nBlocksPerRow = DIV_ROUND_UP(nRasterXSize, m_nBlockXSize);\n        nBlocksPerColumn = DIV_ROUND_UP(nRasterYSize, m_nBlockYSize);\n\n        iColumn = (tile % m_nBlocksPerBand) % nBlocksPerRow;\n        iRow = (tile % m_nBlocksPerBand) / nBlocksPerRow;\n\n        // Is this a partial right edge tile?\n        if( iRow == nBlocksPerRow - 1\n            && nRasterXSize % m_nBlockXSize != 0 )\n            bNeedTileFill = true;\n\n        // Is this a partial bottom edge tile?\n        if( iColumn == nBlocksPerColumn - 1\n            && nRasterYSize % m_nBlockYSize != 0 )\n            bNeedTileFill = true;\n    }\n\n    // If we need to fill out the tile, or if we want to prevent\n    // TIFFWriteEncodedTile from altering the buffer as part of\n    // byte swapping the data on write then we will need a temporary\n    // working buffer.  If not, we can just do a direct write.\n    const GPtrDiff_t cc = static_cast<GPtrDiff_t>(TIFFTileSize( m_hTIFF ));\n\n    if( bPreserveDataBuffer\n        && (TIFFIsByteSwapped(m_hTIFF) || bNeedTileFill || m_panMaskOffsetLsb) )\n    {\n        if( m_pabyTempWriteBuffer == nullptr )\n        {\n            m_pabyTempWriteBuffer = CPLMalloc(cc);\n        }\n        memcpy(m_pabyTempWriteBuffer, pabyData, cc);\n\n        pabyData = static_cast<GByte *>( m_pabyTempWriteBuffer );\n    }\n\n    // Perform tile fill if needed.\n    // TODO: we should also handle the case of nBitsPerSample == 12\n    // but this is more involved.\n    if( bNeedTileFill && m_nBitsPerSample == 8 )\n    {\n        const int nComponents =\n            m_nPlanarConfig == PLANARCONFIG_CONTIG ? nBands : 1;\n\n        CPLDebug( \"GTiff\", \"Filling out jpeg edge tile on write.\" );\n\n        const int nRightPixelsToFill =\n            iColumn == nBlocksPerRow - 1 ?\n            m_nBlockXSize * (iColumn + 1) - nRasterXSize :\n            0;\n        const int nBottomPixelsToFill =\n            iRow == nBlocksPerColumn - 1 ?\n            m_nBlockYSize * (iRow + 1) - nRasterYSize :\n            0;\n\n        // Fill out to the right.\n        const int iSrcX = m_nBlockXSize - nRightPixelsToFill - 1;\n\n        for( int iX = iSrcX + 1; iX < m_nBlockXSize; ++iX )\n        {\n            for( int iY = 0; iY < m_nBlockYSize; ++iY )\n            {\n                memcpy( pabyData + (static_cast<GPtrDiff_t>(m_nBlockXSize) * iY + iX) * nComponents,\n                        pabyData + (static_cast<GPtrDiff_t>(m_nBlockXSize) * iY + iSrcX) * nComponents,\n                        nComponents );\n            }\n        }\n\n        // Now fill out the bottom.\n        const int iSrcY = m_nBlockYSize - nBottomPixelsToFill - 1;\n        for( int iY = iSrcY + 1; iY < m_nBlockYSize; ++iY )\n        {\n            memcpy( pabyData + static_cast<GPtrDiff_t>(m_nBlockXSize) * nComponents * iY,\n                    pabyData + static_cast<GPtrDiff_t>(m_nBlockXSize) * nComponents * iSrcY,\n                    static_cast<GPtrDiff_t>(m_nBlockXSize) * nComponents );\n        }\n    }\n\n    if( m_panMaskOffsetLsb )\n    {\n        const int iBand =\n            m_nPlanarConfig == PLANARCONFIG_SEPARATE ?\n            static_cast<int>(tile) / m_nBlocksPerBand : -1;\n        DiscardLsb(pabyData, cc, iBand);\n    }\n\n    if( m_bStreamingOut )\n    {\n        if( tile != static_cast<uint32>(m_nLastWrittenBlockId + 1) )\n        {\n            ReportError(CE_Failure, CPLE_NotSupported,\n                     \"Attempt to write block %d whereas %d was expected\",\n                     tile, m_nLastWrittenBlockId + 1);\n            return false;\n        }\n        if( static_cast<GPtrDiff_t>( VSIFWriteL(pabyData, 1, cc, m_fpToWrite) ) != cc )\n        {\n            ReportError( CE_Failure, CPLE_FileIO, \"Could not write \" CPL_FRMT_GUIB \" bytes\",\n                      static_cast<GUIntBig>(cc) );\n            return false;\n        }\n        m_nLastWrittenBlockId = tile;\n        return true;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Should we do compression in a worker thread ?                   */\n/* -------------------------------------------------------------------- */\n    if( SubmitCompressionJob(tile, pabyData, cc, m_nBlockYSize) )\n        return true;\n\n    // libtiff 4.0.6 or older do not always properly report write errors.\n#if TIFFLIB_VERSION <= 20150912\n    const CPLErr eBefore = CPLGetLastErrorType();\n#endif\n    const bool bRet =\n        TIFFWriteEncodedTile(m_hTIFF, tile, pabyData, cc) == cc;\n#if TIFFLIB_VERSION <= 20150912\n    if( eBefore == CE_None && CPLGetLastErrorType() == CE_Failure )\n        return false;\n#endif\n    return bRet;\n}\n\n/************************************************************************/\n/*                        WriteEncodedStrip()                           */\n/************************************************************************/\n\nbool GTiffDataset::WriteEncodedStrip( uint32 strip, GByte* pabyData,\n                                      int bPreserveDataBuffer )\n{\n    GPtrDiff_t cc = static_cast<GPtrDiff_t>(TIFFStripSize( m_hTIFF ));\n    const auto ccFull = cc;\n\n/* -------------------------------------------------------------------- */\n/*      If this is the last strip in the image, and is partial, then    */\n/*      we need to trim the number of scanlines written to the          */\n/*      amount of valid data we have. (#2748)                           */\n/* -------------------------------------------------------------------- */\n    const int nStripWithinBand = strip % m_nBlocksPerBand;\n    int nStripHeight = m_nRowsPerStrip;\n\n    if( nStripWithinBand * nStripHeight > GetRasterYSize() - nStripHeight )\n    {\n        nStripHeight = GetRasterYSize() - nStripWithinBand * m_nRowsPerStrip;\n        cc = (cc / m_nRowsPerStrip) * nStripHeight;\n        CPLDebug( \"GTiff\", \"Adjusted bytes to write from \" CPL_FRMT_GUIB \" to \" CPL_FRMT_GUIB \".\",\n                  static_cast<GUIntBig>(TIFFStripSize(m_hTIFF)),\n                  static_cast<GUIntBig>(cc) );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Don't write empty blocks in some cases.                         */\n/* -------------------------------------------------------------------- */\n    if( !m_bWriteEmptyTiles && IsFirstPixelEqualToNoData(pabyData) )\n    {\n        if( !IsBlockAvailable(strip) )\n        {\n            const int nComponents =\n                m_nPlanarConfig == PLANARCONFIG_CONTIG ? nBands : 1;\n\n            if( HasOnlyNoData(pabyData,\n                              m_nBlockXSize, nStripHeight,\n                              m_nBlockXSize, nComponents ) )\n            {\n                return true;\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      TIFFWriteEncodedStrip can alter the passed buffer if            */\n/*      byte-swapping is necessary so we use a temporary buffer         */\n/*      before calling it.                                              */\n/* -------------------------------------------------------------------- */\n    if( bPreserveDataBuffer && (TIFFIsByteSwapped(m_hTIFF) || m_panMaskOffsetLsb) )\n    {\n        if( m_pabyTempWriteBuffer == nullptr )\n        {\n            m_pabyTempWriteBuffer = CPLMalloc(ccFull);\n        }\n        memcpy(m_pabyTempWriteBuffer, pabyData, cc);\n        pabyData = static_cast<GByte *>( m_pabyTempWriteBuffer );\n    }\n\n    if( m_panMaskOffsetLsb )\n    {\n        int iBand =\n            m_nPlanarConfig == PLANARCONFIG_SEPARATE ?\n            static_cast<int>(strip) / m_nBlocksPerBand : -1;\n        DiscardLsb(pabyData, cc, iBand);\n    }\n\n    if( m_bStreamingOut )\n    {\n        if( strip != static_cast<uint32>(m_nLastWrittenBlockId + 1) )\n        {\n            ReportError(CE_Failure, CPLE_NotSupported,\n                     \"Attempt to write block %d whereas %d was expected\",\n                     strip, m_nLastWrittenBlockId + 1);\n            return false;\n        }\n        if( static_cast<GPtrDiff_t>(VSIFWriteL(pabyData, 1, cc, m_fpToWrite)) != cc )\n        {\n            ReportError(CE_Failure, CPLE_FileIO, \"Could not write \" CPL_FRMT_GUIB \" bytes\",\n                     static_cast<GUIntBig>(cc));\n            return false;\n        }\n        m_nLastWrittenBlockId = strip;\n        return true;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Should we do compression in a worker thread ?                   */\n/* -------------------------------------------------------------------- */\n    if( SubmitCompressionJob(strip, pabyData, cc, nStripHeight) )\n        return true;\n\n    // libtiff 4.0.6 or older do not always properly report write errors.\n#if TIFFLIB_VERSION <= 20150912\n    CPLErr eBefore = CPLGetLastErrorType();\n#endif\n    bool bRet = TIFFWriteEncodedStrip( m_hTIFF, strip, pabyData, cc) == cc;\n#if TIFFLIB_VERSION <= 20150912\n    if( eBefore == CE_None && CPLGetLastErrorType() == CE_Failure )\n        bRet = FALSE;\n#endif\n    return bRet;\n}\n\n/************************************************************************/\n/*                        InitCompressionThreads()                      */\n/************************************************************************/\n\nvoid GTiffDataset::InitCompressionThreads( char** papszOptions )\n{\n    // Raster == tile, then no need for threads\n    if( m_nBlockXSize == nRasterXSize && m_nBlockYSize == nRasterYSize )\n        return;\n\n    const char* pszValue = CSLFetchNameValue( papszOptions, \"NUM_THREADS\" );\n    if( pszValue == nullptr )\n        pszValue = CPLGetConfigOption(\"GDAL_NUM_THREADS\", nullptr);\n    if( pszValue )\n    {\n        const int nThreads =\n            EQUAL(pszValue, \"ALL_CPUS\") ? CPLGetNumCPUs() : atoi(pszValue);\n        if( nThreads > 1 )\n        {\n            if( m_nCompression == COMPRESSION_NONE )\n            {\n                CPLDebug( \"GTiff\",\n                          \"NUM_THREADS ignored with uncompressed\" );\n            }\n            else\n            {\n                CPLDebug(\"GTiff\", \"Using %d threads for compression\", nThreads);\n\n                auto poThreadPool = GDALGetGlobalThreadPool(nThreads);\n                if( poThreadPool )\n                    m_poCompressQueue = poThreadPool->CreateJobQueue();\n\n                if( m_poCompressQueue != nullptr )\n                {\n                    // Add a margin of an extra job w.r.t thread number\n                    // so as to optimize compression time (enables the main\n                    // thread to do boring I/O while all CPUs are working).\n                    m_asCompressionJobs.resize(nThreads + 1);\n                    memset(&m_asCompressionJobs[0], 0,\n                           m_asCompressionJobs.size() *\n                           sizeof(GTiffCompressionJob));\n                    for( int i = 0;\n                         i < static_cast<int>(m_asCompressionJobs.size());\n                         ++i )\n                    {\n                        m_asCompressionJobs[i].pszTmpFilename =\n                            CPLStrdup(CPLSPrintf(\"/vsimem/gtiff/thread/job/%p\",\n                                                 &m_asCompressionJobs[i]));\n                        m_asCompressionJobs[i].nStripOrTile = -1;\n                    }\n                    m_hCompressThreadPoolMutex = CPLCreateMutex();\n                    CPLReleaseMutex(m_hCompressThreadPoolMutex);\n\n                    // This is kind of a hack, but basically using\n                    // TIFFWriteRawStrip/Tile and then TIFFReadEncodedStrip/Tile\n                    // does not work on a newly created file, because\n                    // TIFF_MYBUFFER is not set in tif_flags\n                    // (if using TIFFWriteEncodedStrip/Tile first,\n                    // TIFFWriteBufferSetup() is automatically called).\n                    // This should likely rather fixed in libtiff itself.\n                    CPL_IGNORE_RET_VAL(\n                        TIFFWriteBufferSetup(m_hTIFF, nullptr, -1));\n                }\n            }\n        }\n        else if( nThreads < 0 ||\n                 (!EQUAL(pszValue, \"0\") &&\n                  !EQUAL(pszValue, \"1\") &&\n                  !EQUAL(pszValue, \"ALL_CPUS\")) )\n        {\n            ReportError(CE_Warning, CPLE_AppDefined,\n                     \"Invalid value for NUM_THREADS: %s\", pszValue);\n        }\n    }\n}\n\n/************************************************************************/\n/*                       GetGTIFFKeysFlavor()                           */\n/************************************************************************/\n\nstatic GTIFFKeysFlavorEnum GetGTIFFKeysFlavor( char** papszOptions )\n{\n    const char* pszGeoTIFFKeysFlavor =\n        CSLFetchNameValueDef( papszOptions, \"GEOTIFF_KEYS_FLAVOR\", \"STANDARD\" );\n    if( EQUAL(pszGeoTIFFKeysFlavor, \"ESRI_PE\") )\n        return GEOTIFF_KEYS_ESRI_PE;\n    return GEOTIFF_KEYS_STANDARD;\n}\n\n/************************************************************************/\n/*                       GetGeoTIFFVersion()                            */\n/************************************************************************/\n\nstatic GeoTIFFVersionEnum GetGeoTIFFVersion( char** papszOptions )\n{\n    const char* pszVersion =\n        CSLFetchNameValueDef( papszOptions, \"GEOTIFF_VERSION\", \"AUTO\" );\n    if( EQUAL(pszVersion, \"1.0\") )\n        return GEOTIFF_VERSION_1_0;\n    if( EQUAL(pszVersion, \"1.1\") )\n        return GEOTIFF_VERSION_1_1;\n    return GEOTIFF_VERSION_AUTO;\n}\n\n/************************************************************************/\n/*                      InitCreationOrOpenOptions()                     */\n/************************************************************************/\n\nvoid GTiffDataset::InitCreationOrOpenOptions( char** papszOptions )\n{\n    InitCompressionThreads(papszOptions);\n\n    m_eGeoTIFFKeysFlavor = GetGTIFFKeysFlavor(papszOptions);\n    m_eGeoTIFFVersion = GetGeoTIFFVersion(papszOptions);\n}\n\n/************************************************************************/\n/*                      ThreadCompressionFunc()                         */\n/************************************************************************/\n\nvoid GTiffDataset::ThreadCompressionFunc( void* pData )\n{\n    GTiffCompressionJob* psJob = static_cast<GTiffCompressionJob *>(pData);\n    GTiffDataset* poDS = psJob->poDS;\n\n    VSILFILE* fpTmp = VSIFOpenL(psJob->pszTmpFilename, \"wb+\");\n    TIFF* hTIFFTmp = VSI_TIFFOpen(psJob->pszTmpFilename,\n        psJob->bTIFFIsBigEndian ? \"wb+\" : \"wl+\", fpTmp);\n    CPLAssert( hTIFFTmp != nullptr );\n    TIFFSetField(hTIFFTmp, TIFFTAG_IMAGEWIDTH, poDS->m_nBlockXSize);\n    TIFFSetField(hTIFFTmp, TIFFTAG_IMAGELENGTH, psJob->nHeight);\n    TIFFSetField(hTIFFTmp, TIFFTAG_BITSPERSAMPLE, poDS->m_nBitsPerSample);\n    TIFFSetField(hTIFFTmp, TIFFTAG_COMPRESSION, poDS->m_nCompression);\n    TIFFSetField(hTIFFTmp, TIFFTAG_PHOTOMETRIC, poDS->m_nPhotometric);\n    TIFFSetField(hTIFFTmp, TIFFTAG_SAMPLEFORMAT, poDS->m_nSampleFormat);\n    TIFFSetField(hTIFFTmp, TIFFTAG_SAMPLESPERPIXEL, poDS->m_nSamplesPerPixel);\n    TIFFSetField(hTIFFTmp, TIFFTAG_ROWSPERSTRIP, poDS->m_nBlockYSize);\n    TIFFSetField(hTIFFTmp, TIFFTAG_PLANARCONFIG, poDS->m_nPlanarConfig);\n    if( psJob->nPredictor != PREDICTOR_NONE )\n        TIFFSetField(hTIFFTmp, TIFFTAG_PREDICTOR, psJob->nPredictor);\n#if HAVE_LERC\n    if( poDS->m_nCompression == COMPRESSION_LERC )\n    {\n        TIFFSetField(hTIFFTmp, TIFFTAG_LERC_PARAMETERS, 2,\n                    poDS->m_anLercAddCompressionAndVersion);\n    }\n#endif\n\n    TIFFSetField(hTIFFTmp, TIFFTAG_PHOTOMETRIC, poDS->m_nPhotometric);\n    TIFFSetField(hTIFFTmp, TIFFTAG_SAMPLEFORMAT, poDS->m_nSampleFormat);\n    TIFFSetField(hTIFFTmp, TIFFTAG_SAMPLESPERPIXEL, poDS->m_nSamplesPerPixel);\n    TIFFSetField(hTIFFTmp, TIFFTAG_ROWSPERSTRIP, poDS->m_nBlockYSize);\n    TIFFSetField(hTIFFTmp, TIFFTAG_PLANARCONFIG, poDS->m_nPlanarConfig);\n\n    poDS->RestoreVolatileParameters(hTIFFTmp);\n\n    bool bOK =\n        TIFFWriteEncodedStrip(hTIFFTmp, 0, psJob->pabyBuffer,\n                              psJob->nBufferSize) == psJob->nBufferSize;\n\n    toff_t nOffset = 0;\n    if( bOK )\n    {\n        toff_t* panOffsets = nullptr;\n        toff_t* panByteCounts = nullptr;\n        TIFFGetField(hTIFFTmp, TIFFTAG_STRIPOFFSETS, &panOffsets);\n        TIFFGetField(hTIFFTmp, TIFFTAG_STRIPBYTECOUNTS, &panByteCounts);\n\n        nOffset = panOffsets[0];\n        psJob->nCompressedBufferSize = static_cast<GPtrDiff_t>(panByteCounts[0]);\n    }\n    else\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                  \"Error when compressing strip/tile %d\",\n                  psJob->nStripOrTile);\n    }\n\n    XTIFFClose(hTIFFTmp);\n    if( VSIFCloseL(fpTmp) != 0 )\n    {\n        if( bOK )\n        {\n            bOK = false;\n            CPLError( CE_Failure, CPLE_AppDefined,\n                      \"Error when compressing strip/tile %d\",\n                      psJob->nStripOrTile);\n        }\n    }\n\n    if( bOK )\n    {\n        vsi_l_offset nFileSize = 0;\n        GByte* pabyCompressedBuffer = VSIGetMemFileBuffer(psJob->pszTmpFilename,\n                                                          &nFileSize,\n                                                          FALSE);\n        CPLAssert( static_cast<vsi_l_offset>(nOffset + psJob->nCompressedBufferSize) <= nFileSize );\n        psJob->pabyCompressedBuffer = pabyCompressedBuffer + nOffset;\n    }\n    else\n    {\n        psJob->pabyCompressedBuffer = nullptr;\n        psJob->nCompressedBufferSize = 0;\n    }\n\n    auto mutex = poDS->m_poBaseDS ?\n        poDS->m_poBaseDS->m_hCompressThreadPoolMutex : poDS->m_hCompressThreadPoolMutex;\n    if( mutex )\n    {\n        CPLAcquireMutex(mutex, 1000.0);\n        psJob->bReady = true;\n        CPLReleaseMutex(mutex);\n    }\n}\n\n/************************************************************************/\n/*                        WriteRawStripOrTile()                         */\n/************************************************************************/\n\nvoid GTiffDataset::WriteRawStripOrTile( int nStripOrTile,\n                                        GByte* pabyCompressedBuffer,\n                                        GPtrDiff_t nCompressedBufferSize )\n{\n#ifdef DEBUG_VERBOSE\n    CPLDebug(\"GTIFF\", \"Writing raw strip/tile %d, size \" CPL_FRMT_GUIB,\n             nStripOrTile, static_cast<GUIntBig>(nCompressedBufferSize));\n#endif\n    toff_t *panOffsets = nullptr;\n    toff_t* panByteCounts = nullptr;\n    bool bWriteAtEnd = true;\n    bool bWriteLeader = m_bLeaderSizeAsUInt4;\n    bool bWriteTrailer = m_bTrailerRepeatedLast4BytesRepeated;\n    if( TIFFGetField(\n            m_hTIFF,\n            TIFFIsTiled( m_hTIFF ) ?\n            TIFFTAG_TILEOFFSETS : TIFFTAG_STRIPOFFSETS, &panOffsets ) &&\n            panOffsets != nullptr &&\n            panOffsets[nStripOrTile] != 0 )\n    {\n        // Forces TIFFAppendStrip() to consider if the location of the tile/strip\n        // can be reused or if the strile should be written at end of file.\n        TIFFSetWriteOffset(m_hTIFF, 0);\n\n        if( m_bBlockOrderRowMajor )\n        {\n            if( TIFFGetField(\n                m_hTIFF,\n                TIFFIsTiled( m_hTIFF ) ?\n                TIFFTAG_TILEBYTECOUNTS : TIFFTAG_STRIPBYTECOUNTS, &panByteCounts ) &&\n                panByteCounts != nullptr )\n            {\n                if( static_cast<GUIntBig>(nCompressedBufferSize) >\n                        panByteCounts[nStripOrTile] )\n                {\n                    GTiffDataset* poRootDS = m_poBaseDS ? m_poBaseDS : this;\n                    if( !poRootDS->m_bKnownIncompatibleEdition &&\n                        !poRootDS->m_bWriteKnownIncompatibleEdition )\n                    {\n                        ReportError(CE_Warning, CPLE_AppDefined,\n                            \"A strile cannot be rewritten in place, which \"\n                            \"invalidates the BLOCK_ORDER optimization.\");\n                        poRootDS->m_bKnownIncompatibleEdition = true;\n                        poRootDS->m_bWriteKnownIncompatibleEdition = true;\n                    }\n                }\n                // For mask interleaving, if the size is not exactly the same,\n                // completely give up (we could potentially move the mask in\n                // case the imagery is smaller)\n                else if( m_poMaskDS && m_bMaskInterleavedWithImagery &&\n                         static_cast<GUIntBig>(nCompressedBufferSize) !=\n                            panByteCounts[nStripOrTile] )\n                {\n                    GTiffDataset* poRootDS = m_poBaseDS ? m_poBaseDS : this;\n                    if( !poRootDS->m_bKnownIncompatibleEdition &&\n                        !poRootDS->m_bWriteKnownIncompatibleEdition )\n                    {\n                        ReportError(CE_Warning, CPLE_AppDefined,\n                            \"A strile cannot be rewritten in place, which \"\n                            \"invalidates the MASK_INTERLEAVED_WITH_IMAGERY \"\n                            \"optimization.\");\n                        poRootDS->m_bKnownIncompatibleEdition = true;\n                        poRootDS->m_bWriteKnownIncompatibleEdition = true;\n                    }\n                    bWriteLeader = false;\n                    bWriteTrailer = false;\n                    if( m_bLeaderSizeAsUInt4 )\n                    {\n                        // If there was a valid leader, invalidat it\n                        VSI_TIFFSeek( m_hTIFF, panOffsets[nStripOrTile] - 4, SEEK_SET );\n                        uint32 nOldSize;\n                        VSIFReadL(&nOldSize, 1, 4, VSI_TIFFGetVSILFile(TIFFClientdata(m_hTIFF)));\n                        CPL_LSBPTR32(&nOldSize);\n                        if( nOldSize == panByteCounts[nStripOrTile] )\n                        {\n                            uint32 nInvalidatedSize = 0;\n                            VSI_TIFFSeek( m_hTIFF, panOffsets[nStripOrTile] - 4, SEEK_SET );\n                            VSI_TIFFWrite(m_hTIFF, &nInvalidatedSize, sizeof(nInvalidatedSize));\n                        }\n                    }\n                }\n                else\n                {\n                    bWriteAtEnd = false;\n                }\n            }\n        }\n    }\n    if( bWriteLeader &&\n        static_cast<GUIntBig>(nCompressedBufferSize) <= 0xFFFFFFFFU )\n    {\n        // cppcheck-suppress knownConditionTrueFalse\n        if( bWriteAtEnd )\n        {\n            VSI_TIFFSeek( m_hTIFF, 0, SEEK_END );\n        }\n        else\n        {\n            // If we rewrite an existing strile in place with an existing leader,\n            // check that the leader is valid, before rewriting it.\n            // And if it is not valid, then do not write the trailer, as we\n            // could corrupt other data.\n            VSI_TIFFSeek( m_hTIFF, panOffsets[nStripOrTile] - 4, SEEK_SET );\n            uint32 nOldSize;\n            VSIFReadL(&nOldSize, 1, 4, VSI_TIFFGetVSILFile(TIFFClientdata(m_hTIFF)));\n            CPL_LSBPTR32(&nOldSize);\n            bWriteLeader = panByteCounts && nOldSize == panByteCounts[nStripOrTile];\n            bWriteTrailer = bWriteLeader;\n            VSI_TIFFSeek( m_hTIFF, panOffsets[nStripOrTile] - 4, SEEK_SET );\n        }\n        // cppcheck-suppress knownConditionTrueFalse\n        if( bWriteLeader )\n        {\n            uint32 nSize = static_cast<uint32>(nCompressedBufferSize);\n            CPL_LSBPTR32(&nSize);\n            if( !VSI_TIFFWrite(m_hTIFF, &nSize, sizeof(nSize)) )\n                m_bWriteError = true;\n        }\n    }\n    tmsize_t written;\n    if( TIFFIsTiled( m_hTIFF ) )\n        written = TIFFWriteRawTile( m_hTIFF, nStripOrTile, pabyCompressedBuffer,\n                          nCompressedBufferSize );\n    else\n        written = TIFFWriteRawStrip( m_hTIFF, nStripOrTile, pabyCompressedBuffer,\n                           nCompressedBufferSize );\n    if( written != nCompressedBufferSize )\n        m_bWriteError = true;\n    if( bWriteTrailer &&\n        static_cast<GUIntBig>(nCompressedBufferSize) <= 0xFFFFFFFFU )\n    {\n        GByte abyLastBytes[4] = {};\n        if( nCompressedBufferSize >= 4 )\n            memcpy(abyLastBytes, pabyCompressedBuffer + nCompressedBufferSize - 4, 4);\n        else\n            memcpy(abyLastBytes, pabyCompressedBuffer, nCompressedBufferSize);\n        if( !VSI_TIFFWrite(m_hTIFF, abyLastBytes, 4) )\n            m_bWriteError = true;\n    }\n}\n\n/************************************************************************/\n/*                        WaitCompletionForJobIdx()                     */\n/************************************************************************/\n\nvoid GTiffDataset::WaitCompletionForJobIdx(int i)\n{\n    auto poQueue = m_poBaseDS ?\n        m_poBaseDS->m_poCompressQueue.get() : m_poCompressQueue.get();\n    auto& oQueue = m_poBaseDS ? m_poBaseDS->m_asQueueJobIdx : m_asQueueJobIdx;\n    auto& asJobs = m_poBaseDS ? m_poBaseDS->m_asCompressionJobs : m_asCompressionJobs;\n    auto mutex = m_poBaseDS ? m_poBaseDS->m_hCompressThreadPoolMutex : m_hCompressThreadPoolMutex;\n\n    CPLAssert( i >= 0 && static_cast<size_t>(i) < asJobs.size() );\n    CPLAssert( asJobs[i].nStripOrTile >= 0 );\n    CPLAssert( !oQueue.empty() );\n\n    bool bHasWarned = false;\n    while( true )\n    {\n        CPLAcquireMutex(mutex, 1000.0);\n        const bool bReady = asJobs[i].bReady;\n        CPLReleaseMutex(mutex);\n        if( !bReady )\n        {\n            if( !bHasWarned )\n            {\n                CPLDebug(\"GTIFF\",\n                        \"Waiting for worker job to finish handling block %d\",\n                        asJobs[i].nStripOrTile);\n                bHasWarned = true;\n            }\n            poQueue->GetPool()->WaitEvent();\n        }\n        else\n        {\n            break;\n        }\n    }\n\n    if( asJobs[i].nCompressedBufferSize )\n    {\n        asJobs[i].poDS->WriteRawStripOrTile(asJobs[i].nStripOrTile,\n                        asJobs[i].pabyCompressedBuffer,\n                        asJobs[i].nCompressedBufferSize);\n    }\n    asJobs[i].pabyCompressedBuffer = nullptr;\n    asJobs[i].nBufferSize = 0;\n    asJobs[i].bReady = false;\n    asJobs[i].nStripOrTile = -1;\n    oQueue.pop();\n}\n\n/************************************************************************/\n/*                        WaitCompletionForBlock()                      */\n/************************************************************************/\n\nvoid GTiffDataset::WaitCompletionForBlock(int nBlockId)\n{\n    auto poQueue = m_poBaseDS ?\n        m_poBaseDS->m_poCompressQueue.get() : m_poCompressQueue.get();\n    auto& oQueue = m_poBaseDS ? m_poBaseDS->m_asQueueJobIdx : m_asQueueJobIdx;\n    auto& asJobs = m_poBaseDS ? m_poBaseDS->m_asCompressionJobs : m_asCompressionJobs;\n\n    if( poQueue != nullptr )\n    {\n        for( int i = 0; i < static_cast<int>(asJobs.size()); ++i )\n        {\n            if( asJobs[i].poDS == this && asJobs[i].nStripOrTile == nBlockId )\n            {\n                while( !oQueue.empty() &&\n                       !(asJobs[oQueue.front()].poDS == this &&\n                         asJobs[oQueue.front()].nStripOrTile == nBlockId) )\n                {\n                    WaitCompletionForJobIdx(oQueue.front());\n                }\n                CPLAssert( !oQueue.empty() &&\n                          asJobs[oQueue.front()].poDS == this &&\n                          asJobs[oQueue.front()].nStripOrTile == nBlockId );\n                WaitCompletionForJobIdx(oQueue.front());\n            }\n        }\n    }\n}\n\n/************************************************************************/\n/*                      SubmitCompressionJob()                          */\n/************************************************************************/\n\nbool GTiffDataset::SubmitCompressionJob( int nStripOrTile, GByte* pabyData,\n                                         GPtrDiff_t cc, int nHeight )\n{\n/* -------------------------------------------------------------------- */\n/*      Should we do compression in a worker thread ?                   */\n/* -------------------------------------------------------------------- */\n    auto poQueue = m_poBaseDS ?\n        m_poBaseDS->m_poCompressQueue.get() : m_poCompressQueue.get();\n\n    if( poQueue == nullptr ||\n          !(m_nCompression == COMPRESSION_ADOBE_DEFLATE ||\n            m_nCompression == COMPRESSION_LZW ||\n            m_nCompression == COMPRESSION_PACKBITS ||\n            m_nCompression == COMPRESSION_LZMA ||\n            m_nCompression == COMPRESSION_ZSTD ||\n            m_nCompression == COMPRESSION_LERC ||\n            m_nCompression == COMPRESSION_WEBP ||\n            m_nCompression == COMPRESSION_JPEG) )\n    {\n        if( m_bBlockOrderRowMajor || m_bLeaderSizeAsUInt4 ||\n            m_bTrailerRepeatedLast4BytesRepeated )\n        {\n            GTiffCompressionJob sJob;\n            memset(&sJob, 0, sizeof(sJob));\n            sJob.poDS = this;\n            sJob.pszTmpFilename = CPLStrdup(CPLSPrintf(\"/vsimem/gtiff/%p\", this));\n            sJob.bTIFFIsBigEndian = CPL_TO_BOOL( TIFFIsBigEndian(m_hTIFF) );\n            sJob.pabyBuffer =\n                static_cast<GByte*>( CPLRealloc(sJob.pabyBuffer, cc) );\n            memcpy(sJob.pabyBuffer, pabyData, cc);\n            sJob.nBufferSize = cc;\n            sJob.nHeight = nHeight;\n            sJob.nStripOrTile = nStripOrTile;\n            sJob.nPredictor = PREDICTOR_NONE;\n            if( m_nCompression == COMPRESSION_LZW ||\n                m_nCompression == COMPRESSION_ADOBE_DEFLATE ||\n                m_nCompression == COMPRESSION_ZSTD )\n            {\n                TIFFGetField( m_hTIFF, TIFFTAG_PREDICTOR, &sJob.nPredictor );\n            }\n\n            ThreadCompressionFunc(&sJob);\n\n            if( sJob.nCompressedBufferSize )\n            {\n                sJob.poDS->\n                    WriteRawStripOrTile(sJob.nStripOrTile,\n                                sJob.pabyCompressedBuffer,\n                                sJob.nCompressedBufferSize);\n            }\n\n            CPLFree(sJob.pabyBuffer);\n            VSIUnlink(sJob.pszTmpFilename);\n            CPLFree(sJob.pszTmpFilename);\n            return sJob.nCompressedBufferSize > 0 && !m_bWriteError;\n        }\n\n        return false;\n    }\n\n    auto& oQueue = m_poBaseDS ? m_poBaseDS->m_asQueueJobIdx : m_asQueueJobIdx;\n    auto& asJobs = m_poBaseDS ? m_poBaseDS->m_asCompressionJobs : m_asCompressionJobs;\n\n    int nNextCompressionJobAvail = -1;\n\n    if( oQueue.size() == asJobs.size() )\n    {\n        CPLAssert( !oQueue.empty() );\n        nNextCompressionJobAvail = oQueue.front();\n        WaitCompletionForJobIdx(nNextCompressionJobAvail);\n    }\n    else\n    {\n        const int nJobs = static_cast<int>(asJobs.size());\n        for( int i = 0; i < nJobs; ++i )\n        {\n            if( asJobs[i].nBufferSize == 0 )\n            {\n                nNextCompressionJobAvail = i;\n                break;\n            }\n        }\n    }\n    CPLAssert(nNextCompressionJobAvail >= 0);\n\n    GTiffCompressionJob* psJob = &asJobs[nNextCompressionJobAvail];\n    psJob->poDS = this;\n    psJob->bTIFFIsBigEndian = CPL_TO_BOOL( TIFFIsBigEndian(m_hTIFF) );\n    psJob->pabyBuffer =\n        static_cast<GByte*>( CPLRealloc(psJob->pabyBuffer, cc) );\n    memcpy(psJob->pabyBuffer, pabyData, cc);\n    psJob->nBufferSize = cc;\n    psJob->nHeight = nHeight;\n    psJob->nStripOrTile = nStripOrTile;\n    psJob->nPredictor = PREDICTOR_NONE;\n    if( m_nCompression == COMPRESSION_LZW ||\n        m_nCompression == COMPRESSION_ADOBE_DEFLATE ||\n        m_nCompression == COMPRESSION_ZSTD )\n    {\n        TIFFGetField( m_hTIFF, TIFFTAG_PREDICTOR, &psJob->nPredictor );\n    }\n\n    poQueue->SubmitJob(ThreadCompressionFunc, psJob);\n    oQueue.push(nNextCompressionJobAvail);\n\n    return true;\n}\n\n/************************************************************************/\n/*                          DiscardLsb()                                */\n/************************************************************************/\n\ntemplate<class T> static void DiscardLsbT(GByte* pabyBuffer, \n                                         size_t nBytes,\n                                         int iBand,\n                                         int nBands,\n                                         uint16 nPlanarConfig,\n                                         const GTiffDataset::MaskOffset* panMaskOffsetLsb)\n{\n    if( nPlanarConfig == PLANARCONFIG_SEPARATE )\n    {\n        const int nMask = panMaskOffsetLsb[iBand].nMask;\n        const int nOffset = panMaskOffsetLsb[iBand].nOffset;\n        for( size_t i = 0; i < nBytes/sizeof(T); ++i )\n        {\n            reinterpret_cast<T*>(pabyBuffer)[i] =\n                static_cast<T>(\n                    (reinterpret_cast<T *>(pabyBuffer)[i] & nMask) |\n                    nOffset);\n        }\n    }\n    else\n    {\n        for( size_t i = 0; i < nBytes/sizeof(T); i += nBands )\n        {\n            for( int j = 0; j < nBands; ++j )\n            {\n                reinterpret_cast<T*>(pabyBuffer)[i + j] =\n                    static_cast<T>(\n                        (reinterpret_cast<T*>(pabyBuffer)[i + j] &\n                            panMaskOffsetLsb[j].nMask) |\n                        panMaskOffsetLsb[j].nOffset);\n            }\n        }\n    }\n}\n\nvoid GTiffDataset::DiscardLsb( GByte* pabyBuffer, GPtrDiff_t nBytes, int iBand ) const\n{\n    if( m_nBitsPerSample == 8 )\n    {\n        if( m_nPlanarConfig == PLANARCONFIG_SEPARATE )\n        {\n            const int nMask = m_panMaskOffsetLsb[iBand].nMask;\n            const int nOffset = m_panMaskOffsetLsb[iBand].nOffset;\n            for( decltype(nBytes) i = 0; i < nBytes; ++i )\n            {\n                // Keep 255 in case it is alpha.\n                if( pabyBuffer[i] != 255 )\n                    pabyBuffer[i] =\n                        static_cast<GByte>((pabyBuffer[i] & nMask) | nOffset);\n            }\n        }\n        else\n        {\n            for( decltype(nBytes) i = 0; i < nBytes; i += nBands )\n            {\n                for( int j = 0; j < nBands; ++j )\n                {\n                    // Keep 255 in case it is alpha.\n                    if( pabyBuffer[i + j] != 255 )\n                        pabyBuffer[i + j] =\n                            static_cast<GByte>((pabyBuffer[i + j] &\n                                                m_panMaskOffsetLsb[j].nMask) | m_panMaskOffsetLsb[j].nOffset);\n                }\n            }\n        }\n    }\n    else if( m_nBitsPerSample == 16 )\n    {\n        DiscardLsbT<GUInt16>(pabyBuffer, nBytes, iBand, nBands, m_nPlanarConfig,\n                            m_panMaskOffsetLsb);\n    }\n    else if( m_nBitsPerSample == 32 )\n    {\n        DiscardLsbT<GUInt32>(pabyBuffer, nBytes, iBand, nBands, m_nPlanarConfig,\n                            m_panMaskOffsetLsb);\n    }\n}\n\n/************************************************************************/\n/*                  WriteEncodedTileOrStrip()                           */\n/************************************************************************/\n\nCPLErr GTiffDataset::WriteEncodedTileOrStrip( uint32 tile_or_strip, void* data,\n                                              int bPreserveDataBuffer )\n{\n    CPLErr eErr = CE_None;\n\n    if( TIFFIsTiled( m_hTIFF ) )\n    {\n        if( !(WriteEncodedTile(\n               tile_or_strip,\n               static_cast<GByte *>(data),\n               bPreserveDataBuffer)) )\n        {\n            eErr = CE_Failure;\n        }\n    }\n    else\n    {\n        if( !(WriteEncodedStrip(\n               tile_or_strip,\n               static_cast<GByte *>(data),\n               bPreserveDataBuffer)) )\n        {\n            eErr = CE_Failure;\n        }\n    }\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                           FlushBlockBuf()                            */\n/************************************************************************/\n\nCPLErr GTiffDataset::FlushBlockBuf()\n\n{\n    if( m_nLoadedBlock < 0 || !m_bLoadedBlockDirty )\n        return CE_None;\n\n    m_bLoadedBlockDirty = false;\n\n    const CPLErr eErr =\n        WriteEncodedTileOrStrip(m_nLoadedBlock, m_pabyBlockBuf, true);\n    if( eErr != CE_None )\n    {\n        ReportError( CE_Failure, CPLE_AppDefined,\n                    \"WriteEncodedTile/Strip() failed.\" );\n        m_bWriteError = true;\n    }\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                            LoadBlockBuf()                            */\n/*                                                                      */\n/*      Load working block buffer with request block (tile/strip).      */\n/************************************************************************/\n\nCPLErr GTiffDataset::LoadBlockBuf( int nBlockId, bool bReadFromDisk )\n\n{\n    if( m_nLoadedBlock == nBlockId && m_pabyBlockBuf != nullptr )\n        return CE_None;\n\n/* -------------------------------------------------------------------- */\n/*      If we have a dirty loaded block, flush it out first.            */\n/* -------------------------------------------------------------------- */\n    if( m_nLoadedBlock != -1 && m_bLoadedBlockDirty )\n    {\n        const CPLErr eErr = FlushBlockBuf();\n        if( eErr != CE_None )\n            return eErr;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Get block size.                                                 */\n/* -------------------------------------------------------------------- */\n    const GPtrDiff_t nBlockBufSize =\n        static_cast<GPtrDiff_t>(\n            TIFFIsTiled(m_hTIFF) ? TIFFTileSize(m_hTIFF) : TIFFStripSize(m_hTIFF));\n    if( !nBlockBufSize )\n    {\n        ReportError( CE_Failure, CPLE_AppDefined,\n                  \"Bogus block size; unable to allocate a buffer.\" );\n        return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Allocate a temporary buffer for this strip.                     */\n/* -------------------------------------------------------------------- */\n    if( m_pabyBlockBuf == nullptr )\n    {\n        m_pabyBlockBuf =\n            static_cast<GByte *>( VSI_CALLOC_VERBOSE( 1, nBlockBufSize ) );\n        if( m_pabyBlockBuf == nullptr )\n        {\n            return CE_Failure;\n        }\n    }\n\n    if( m_nLoadedBlock == nBlockId )\n        return CE_None;\n\n/* -------------------------------------------------------------------- */\n/*  When called from ::IWriteBlock in separate cases (or in single band */\n/*  geotiffs), the ::IWriteBlock will override the content of the buffer*/\n/*  with pImage, so we don't need to read data from disk                */\n/* -------------------------------------------------------------------- */\n    if( !bReadFromDisk || m_bStreamingOut )\n    {\n        m_nLoadedBlock = nBlockId;\n        return CE_None;\n    }\n\n    // libtiff 3.X doesn't like mixing read&write of JPEG compressed blocks\n    // The below hack is necessary due to another hack that consist in\n    // writing zero block to force creation of JPEG tables.\n    if( nBlockId == 0 && m_bDontReloadFirstBlock )\n    {\n        m_bDontReloadFirstBlock = false;\n        memset( m_pabyBlockBuf, 0, nBlockBufSize );\n        m_nLoadedBlock = nBlockId;\n        return CE_None;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      The bottom most partial tiles and strips are sometimes only     */\n/*      partially encoded.  This code reduces the requested data so     */\n/*      an error won't be reported in this case. (#1179)                */\n/* -------------------------------------------------------------------- */\n    auto nBlockReqSize = nBlockBufSize;\n    const int nBlocksPerRow = DIV_ROUND_UP(nRasterXSize, m_nBlockXSize);\n    const int nBlockYOff = (nBlockId % m_nBlocksPerBand) / nBlocksPerRow;\n\n    if( nBlockYOff * m_nBlockYSize > nRasterYSize - m_nBlockYSize )\n    {\n        nBlockReqSize = (nBlockBufSize / m_nBlockYSize)\n            * (m_nBlockYSize - static_cast<int>(\n                (static_cast<GIntBig>(nBlockYOff + 1) * m_nBlockYSize) %\n                    nRasterYSize));\n        memset( m_pabyBlockBuf, 0, nBlockBufSize );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If we don't have this block already loaded, and we know it      */\n/*      doesn't yet exist on disk, just zero the memory buffer and      */\n/*      pretend we loaded it.                                           */\n/* -------------------------------------------------------------------- */\n    bool bErrOccurred = false;\n    if( !IsBlockAvailable( nBlockId, nullptr, nullptr, &bErrOccurred ) )\n    {\n        memset( m_pabyBlockBuf, 0, nBlockBufSize );\n        m_nLoadedBlock = nBlockId;\n        if( bErrOccurred )\n            return CE_Failure;\n        return CE_None;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Load the block, if it isn't our current block.                  */\n/* -------------------------------------------------------------------- */\n    CPLErr eErr = CE_None;\n    \n    if( !ReadStrile(nBlockId, m_pabyBlockBuf, nBlockReqSize) )\n    {\n        memset( m_pabyBlockBuf, 0, nBlockBufSize );\n        eErr = CE_Failure;\n    }\n\n    if( eErr == CE_None )\n    {\n        m_nLoadedBlock = nBlockId;\n    }\n    else\n    {\n        m_nLoadedBlock = -1;\n    }\n    m_bLoadedBlockDirty = false;\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                   GTiffFillStreamableOffsetAndCount()                */\n/************************************************************************/\n\nstatic void GTiffFillStreamableOffsetAndCount( TIFF* hTIFF, int nSize )\n{\n    uint32 nXSize = 0;\n    uint32 nYSize = 0;\n    TIFFGetField( hTIFF, TIFFTAG_IMAGEWIDTH, &nXSize );\n    TIFFGetField( hTIFF, TIFFTAG_IMAGELENGTH, &nYSize );\n    const bool bIsTiled = CPL_TO_BOOL( TIFFIsTiled(hTIFF) );\n    const int nBlockCount =\n        bIsTiled ? TIFFNumberOfTiles(hTIFF) : TIFFNumberOfStrips(hTIFF);\n\n    toff_t *panOffset = nullptr;\n    TIFFGetField( hTIFF, bIsTiled ? TIFFTAG_TILEOFFSETS : TIFFTAG_STRIPOFFSETS,\n                  &panOffset );\n    toff_t *panSize = nullptr;\n    TIFFGetField( hTIFF,\n                  bIsTiled ? TIFFTAG_TILEBYTECOUNTS : TIFFTAG_STRIPBYTECOUNTS,\n                  &panSize );\n    toff_t nOffset = nSize;\n    // Trick to avoid clang static analyzer raising false positive about\n    // divide by zero later.\n    int nBlocksPerBand = 1;\n    uint32 nRowsPerStrip = 0;\n    if( !bIsTiled )\n    {\n        TIFFGetField( hTIFF, TIFFTAG_ROWSPERSTRIP, &nRowsPerStrip);\n        if( nRowsPerStrip > static_cast<uint32>(nYSize) )\n            nRowsPerStrip = nYSize;\n        nBlocksPerBand = DIV_ROUND_UP(nYSize, nRowsPerStrip);\n    }\n    for( int i = 0; i < nBlockCount; ++i )\n    {\n        GPtrDiff_t cc = bIsTiled ? static_cast<GPtrDiff_t>(TIFFTileSize(hTIFF)) :\n                            static_cast<GPtrDiff_t>(TIFFStripSize(hTIFF));\n        if( !bIsTiled )\n        {\n/* -------------------------------------------------------------------- */\n/*      If this is the last strip in the image, and is partial, then    */\n/*      we need to trim the number of scanlines written to the          */\n/*      amount of valid data we have. (#2748)                           */\n/* -------------------------------------------------------------------- */\n            int nStripWithinBand = i % nBlocksPerBand;\n            if( nStripWithinBand * nRowsPerStrip > nYSize - nRowsPerStrip )\n            {\n                cc = (cc / nRowsPerStrip)\n                    * (nYSize - nStripWithinBand * nRowsPerStrip);\n            }\n        }\n        panOffset[i] = nOffset;\n        panSize[i] = cc;\n        nOffset += cc;\n    }\n}\n\n/************************************************************************/\n/*                             Crystalize()                             */\n/*                                                                      */\n/*      Make sure that the directory information is written out for     */\n/*      a new file, require before writing any imagery data.            */\n/************************************************************************/\n\nvoid GTiffDataset::Crystalize()\n\n{\n    if( m_bCrystalized )\n        return;\n\n    // TODO: libtiff writes extended tags in the order they are specified\n    // and not in increasing order.\n    WriteMetadata( this, m_hTIFF, true, m_eProfile, m_pszFilename,\n                   m_papszCreationOptions );\n    WriteGeoTIFFInfo();\n    if( m_bNoDataSet )\n        WriteNoDataValue( m_hTIFF, m_dfNoDataValue );\n\n    m_bMetadataChanged = false;\n    m_bGeoTIFFInfoChanged = false;\n    m_bNoDataChanged = false;\n    m_bNeedsRewrite = false;\n\n    m_bCrystalized = true;\n\n    TIFFWriteCheck( m_hTIFF, TIFFIsTiled(m_hTIFF), \"GTiffDataset::Crystalize\");\n\n    TIFFWriteDirectory( m_hTIFF );\n    if( m_bStreamingOut )\n    {\n        // We need to write twice the directory to be sure that custom\n        // TIFF tags are correctly sorted and that padding bytes have been\n        // added.\n        TIFFSetDirectory( m_hTIFF, 0 );\n        TIFFWriteDirectory( m_hTIFF );\n\n        if( VSIFSeekL( m_fpL, 0, SEEK_END ) != 0 )\n        {\n            ReportError(CE_Failure, CPLE_FileIO, \"Could not seek\");\n        }\n        const int nSize = static_cast<int>( VSIFTellL(m_fpL) );\n\n        TIFFSetDirectory( m_hTIFF, 0 );\n        GTiffFillStreamableOffsetAndCount( m_hTIFF, nSize );\n        TIFFWriteDirectory( m_hTIFF );\n\n        vsi_l_offset nDataLength = 0;\n        void* pabyBuffer =\n            VSIGetMemFileBuffer( m_pszTmpFilename, &nDataLength, FALSE);\n        if( static_cast<int>(\n                VSIFWriteL( pabyBuffer, 1,\n                            static_cast<int>(nDataLength), m_fpToWrite ) ) !=\n            static_cast<int>(nDataLength) )\n        {\n            ReportError( CE_Failure, CPLE_FileIO, \"Could not write %d bytes\",\n                      static_cast<int>(nDataLength) );\n        }\n        // In case of single strip file, there's a libtiff check that would\n        // issue a warning since the file hasn't the required size.\n        CPLPushErrorHandler(CPLQuietErrorHandler);\n        TIFFSetDirectory( m_hTIFF, 0 );\n        CPLPopErrorHandler();\n    }\n    else\n    {\n        TIFFSetDirectory( m_hTIFF,\n                      static_cast<tdir_t>(TIFFNumberOfDirectories(m_hTIFF) - 1) );\n    }\n\n    RestoreVolatileParameters( m_hTIFF );\n\n    m_nDirOffset = TIFFCurrentDirOffset( m_hTIFF );\n}\n\n/************************************************************************/\n/*                          IsBlockAvailable()                          */\n/*                                                                      */\n/*      Return true if the indicated strip/tile is available.  We       */\n/*      establish this by testing if the stripbytecount is zero.  If    */\n/*      zero then the block has never been committed to disk.           */\n/************************************************************************/\n\nbool GTiffDataset::IsBlockAvailable( int nBlockId,\n                                     vsi_l_offset* pnOffset,\n                                     vsi_l_offset* pnSize,\n                                     bool *pbErrOccurred )\n\n{\n    if( pbErrOccurred )\n        *pbErrOccurred = false;\n\n#ifdef SUPPORTS_GET_OFFSET_BYTECOUNT\n    std::pair<vsi_l_offset, vsi_l_offset> oPair;\n    if( m_oCacheStrileToOffsetByteCount.tryGet(nBlockId, oPair) )\n    {\n        if( pnOffset )\n            *pnOffset = oPair.first;\n        if( pnSize )\n            *pnSize = oPair.second;\n        return oPair.first != 0;\n    }\n#endif\n    \n    WaitCompletionForBlock(nBlockId);\n\n#ifdef SUPPORTS_GET_OFFSET_BYTECOUNT\n    // Optimization to avoid fetching the whole Strip/TileCounts and\n    // Strip/TileOffsets arrays.\n    if( eAccess == GA_ReadOnly && !m_bStreamingIn )\n    {\n        int nErrOccurred = 0;\n        auto bytecount = TIFFGetStrileByteCountWithErr(m_hTIFF, nBlockId, &nErrOccurred);\n        if( nErrOccurred && pbErrOccurred )\n            *pbErrOccurred = true;\n        if( pnOffset )\n        {\n            *pnOffset = TIFFGetStrileOffsetWithErr(m_hTIFF, nBlockId, &nErrOccurred);\n            if( nErrOccurred && pbErrOccurred )\n                *pbErrOccurred = true;\n        }\n        if( pnSize )\n            *pnSize = bytecount;\n        return bytecount != 0;\n    }\n#endif\n\n    toff_t *panByteCounts = nullptr;\n    toff_t *panOffsets = nullptr;\n    const bool bIsTiled = CPL_TO_BOOL( TIFFIsTiled(m_hTIFF) );\n\n    if( ( bIsTiled\n          && TIFFGetField( m_hTIFF, TIFFTAG_TILEBYTECOUNTS, &panByteCounts )\n          && (pnOffset == nullptr ||\n              TIFFGetField( m_hTIFF, TIFFTAG_TILEOFFSETS, &panOffsets )) )\n        || ( !bIsTiled\n          && TIFFGetField( m_hTIFF, TIFFTAG_STRIPBYTECOUNTS, &panByteCounts )\n          && (pnOffset == nullptr ||\n              TIFFGetField( m_hTIFF, TIFFTAG_STRIPOFFSETS, &panOffsets )) ) )\n    {\n        if( panByteCounts == nullptr || (pnOffset != nullptr && panOffsets == nullptr) )\n        {\n            if( pbErrOccurred )\n                *pbErrOccurred = true;\n            return false;\n        }\n        const int nBlockCount =\n            bIsTiled ? TIFFNumberOfTiles(m_hTIFF) : TIFFNumberOfStrips(m_hTIFF);\n        if( nBlockId >= nBlockCount )\n        {\n            if( pbErrOccurred )\n                *pbErrOccurred = true;\n            return false;\n        }\n\n        if( pnOffset )\n            *pnOffset = panOffsets[nBlockId];\n        if( pnSize )\n            *pnSize = panByteCounts[nBlockId];\n        return panByteCounts[nBlockId] != 0;\n    }\n    else\n    {\n        if( pbErrOccurred )\n            *pbErrOccurred = true;\n    }\n\n    return false;\n}\n\n/************************************************************************/\n/*                             FlushCache()                             */\n/*                                                                      */\n/*      We override this so we can also flush out local tiff strip      */\n/*      cache if need be.                                               */\n/************************************************************************/\n\nvoid GTiffDataset::FlushCache()\n\n{\n    FlushCacheInternal( true );\n}\n\nvoid GTiffDataset::FlushCacheInternal( bool bFlushDirectory )\n{\n    if( m_bIsFinalized )\n        return;\n\n    GDALPamDataset::FlushCache();\n\n    if( m_bLoadedBlockDirty && m_nLoadedBlock != -1 )\n        FlushBlockBuf();\n\n    CPLFree( m_pabyBlockBuf );\n    m_pabyBlockBuf = nullptr;\n    m_nLoadedBlock = -1;\n    m_bLoadedBlockDirty = false;\n\n    // Finish compression\n    auto poQueue = m_poBaseDS ? m_poBaseDS->m_poCompressQueue.get() : m_poCompressQueue.get();\n    if( poQueue )\n    {\n        poQueue->WaitCompletion();\n\n        // Flush remaining data\n        auto& oQueue = m_poBaseDS ? m_poBaseDS->m_asQueueJobIdx : m_asQueueJobIdx;\n        while( !oQueue.empty() )\n        {\n            WaitCompletionForJobIdx(oQueue.front());\n        }\n    }\n\n    if( bFlushDirectory && GetAccess() == GA_Update )\n    {\n        FlushDirectory();\n    }\n}\n\n/************************************************************************/\n/*                           FlushDirectory()                           */\n/************************************************************************/\n\nvoid GTiffDataset::FlushDirectory()\n\n{\n    if( GetAccess() == GA_Update )\n    {\n        if( m_bMetadataChanged )\n        {\n            m_bNeedsRewrite =\n                    WriteMetadata( this, m_hTIFF, true, m_eProfile, m_pszFilename,\n                                   m_papszCreationOptions );\n            m_bMetadataChanged = false;\n\n            if( m_bForceUnsetRPC )\n            {\n                double *padfRPCTag = nullptr;\n                uint16 nCount;\n                if( TIFFGetField( m_hTIFF, TIFFTAG_RPCCOEFFICIENT, &nCount, &padfRPCTag ) )\n                {\n                    std::vector<double> zeroes(92);\n                    TIFFSetField( m_hTIFF, TIFFTAG_RPCCOEFFICIENT, 92, zeroes.data() );\n                    TIFFUnsetField( m_hTIFF, TIFFTAG_RPCCOEFFICIENT );\n                    m_bNeedsRewrite = true;\n                }\n\n                GDALWriteRPCTXTFile( m_pszFilename, nullptr );\n                GDALWriteRPBFile( m_pszFilename, nullptr );\n            }\n        }\n\n        if( m_bGeoTIFFInfoChanged )\n        {\n            WriteGeoTIFFInfo();\n            m_bGeoTIFFInfoChanged = false;\n        }\n\n        if( m_bNoDataChanged )\n        {\n            if( m_bNoDataSet )\n            {\n                WriteNoDataValue( m_hTIFF, m_dfNoDataValue );\n            }\n            else\n            {\n                UnsetNoDataValue( m_hTIFF );\n            }\n            m_bNeedsRewrite = true;\n            m_bNoDataChanged = false;\n        }\n\n        if( m_bNeedsRewrite )\n        {\n            if( !m_bCrystalized)\n            {\n                Crystalize();\n            }\n            else\n            {\n                const TIFFSizeProc pfnSizeProc = TIFFGetSizeProc( m_hTIFF );\n\n                m_nDirOffset = pfnSizeProc( TIFFClientdata( m_hTIFF ) );\n                if( (m_nDirOffset % 2) == 1 )\n                    ++m_nDirOffset;\n\n                TIFFRewriteDirectory( m_hTIFF );\n\n                TIFFSetSubDirectory( m_hTIFF, m_nDirOffset );\n\n                if( m_bLayoutIFDSBeforeData &&\n                    m_bBlockOrderRowMajor &&\n                    m_bLeaderSizeAsUInt4 &&\n                    m_bTrailerRepeatedLast4BytesRepeated &&\n                    !m_bKnownIncompatibleEdition &&\n                    !m_bWriteKnownIncompatibleEdition )\n                {\n                    ReportError(CE_Warning, CPLE_AppDefined,\n                                \"The IFD has been rewritten at the end of \"\n                                \"the file, which breaks COG layout.\");\n                    m_bKnownIncompatibleEdition = true;\n                    m_bWriteKnownIncompatibleEdition = true;\n                }\n            }\n            m_bNeedsRewrite = false;\n        }\n    }\n\n    // There are some circumstances in which we can reach this point\n    // without having made this our directory (SetDirectory()) in which\n    // case we should not risk a flush.\n    if( GetAccess() == GA_Update && TIFFCurrentDirOffset(m_hTIFF) == m_nDirOffset )\n    {\n        const TIFFSizeProc pfnSizeProc = TIFFGetSizeProc( m_hTIFF );\n\n        toff_t nNewDirOffset = pfnSizeProc( TIFFClientdata( m_hTIFF ) );\n        if( (nNewDirOffset % 2) == 1 )\n            ++nNewDirOffset;\n\n        TIFFFlush( m_hTIFF );\n\n        if( m_nDirOffset != TIFFCurrentDirOffset( m_hTIFF ) )\n        {\n            m_nDirOffset = nNewDirOffset;\n            CPLDebug( \"GTiff\",\n                      \"directory moved during flush in FlushDirectory()\" );\n        }\n    }\n\n    SetDirectory();\n}\n\n/************************************************************************/\n/*                           CleanOverviews()                           */\n/************************************************************************/\n\nCPLErr GTiffDataset::CleanOverviews()\n\n{\n    CPLAssert( !m_poBaseDS );\n\n    ScanDirectories();\n\n    FlushDirectory();\n\n/* -------------------------------------------------------------------- */\n/*      Cleanup overviews objects, and get offsets to all overview      */\n/*      directories.                                                    */\n/* -------------------------------------------------------------------- */\n    std::vector<toff_t> anOvDirOffsets;\n\n    for( int i = 0; i < m_nOverviewCount; ++i )\n    {\n        anOvDirOffsets.push_back( m_papoOverviewDS[i]->m_nDirOffset );\n        delete m_papoOverviewDS[i];\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Loop through all the directories, translating the offsets       */\n/*      into indexes we can use with TIFFUnlinkDirectory().             */\n/* -------------------------------------------------------------------- */\n    std::vector<uint16> anOvDirIndexes;\n    int iThisOffset = 1;\n\n    TIFFSetDirectory( m_hTIFF, 0 );\n\n    while( true )\n    {\n        for( int i = 0; i < m_nOverviewCount; ++i )\n        {\n            if( anOvDirOffsets[i] == TIFFCurrentDirOffset( m_hTIFF ) )\n            {\n                CPLDebug( \"GTiff\", \"%d -> %d\",\n                          static_cast<int>(anOvDirOffsets[i]), iThisOffset );\n                anOvDirIndexes.push_back( static_cast<uint16>(iThisOffset) );\n            }\n        }\n\n        if( TIFFLastDirectory( m_hTIFF ) )\n            break;\n\n        TIFFReadDirectory( m_hTIFF );\n        ++iThisOffset;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Actually unlink the target directories.  Note that we do        */\n/*      this from last to first so as to avoid renumbering any of       */\n/*      the earlier directories we need to remove.                      */\n/* -------------------------------------------------------------------- */\n    while( !anOvDirIndexes.empty() )\n    {\n        TIFFUnlinkDirectory( m_hTIFF, anOvDirIndexes.back() );\n        anOvDirIndexes.pop_back();\n    }\n\n    CPLFree( m_papoOverviewDS );\n\n    m_nOverviewCount = 0;\n    m_papoOverviewDS = nullptr;\n\n    if( !SetDirectory() )\n        return CE_Failure;\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                   RegisterNewOverviewDataset()                       */\n/************************************************************************/\n\nCPLErr GTiffDataset::RegisterNewOverviewDataset(toff_t nOverviewOffset,\n                                                int l_nJpegQuality,\n                                                int l_nWebPLevel)\n{\n    if( m_nOverviewCount == 127 )\n        return CE_Failure;\n\n    GTiffDataset* poODS = new GTiffDataset();\n    poODS->ShareLockWithParentDataset(this);\n    poODS->m_pszFilename = CPLStrdup(m_pszFilename);\n    poODS->m_nJpegQuality = static_cast<signed char>(l_nJpegQuality);\n    poODS->m_nWebPLevel = static_cast<signed char>(l_nWebPLevel);\n    poODS->m_nZLevel = m_nZLevel;\n    poODS->m_nLZMAPreset = m_nLZMAPreset;\n    poODS->m_nZSTDLevel = m_nZSTDLevel;\n    poODS->m_bWebPLossless = m_bWebPLossless;\n    poODS->m_nJpegTablesMode = m_nJpegTablesMode;\n#if HAVE_LERC\n    poODS->m_dfMaxZError = m_dfMaxZError;\n    memcpy(poODS->m_anLercAddCompressionAndVersion, m_anLercAddCompressionAndVersion,\n           sizeof(m_anLercAddCompressionAndVersion));\n#endif\n\n    if( poODS->OpenOffset( VSI_TIFFOpenChild(m_hTIFF), nOverviewOffset,\n                            GA_Update ) != CE_None )\n    {\n        delete poODS;\n        return CE_Failure;\n    }\n\n    // Do that now that m_nCompression is set\n    poODS->RestoreVolatileParameters( poODS->m_hTIFF );\n\n    ++m_nOverviewCount;\n    m_papoOverviewDS = static_cast<GTiffDataset **>(\n        CPLRealloc( m_papoOverviewDS,\n                    m_nOverviewCount * (sizeof(void*))) );\n    m_papoOverviewDS[m_nOverviewCount-1] = poODS;\n    poODS->m_poBaseDS = this;\n    poODS->m_bIsOverview = true;\n    return CE_None;\n}\n\n/************************************************************************/\n/*                     CreateTIFFColorTable()                           */\n/************************************************************************/\n\nstatic void CreateTIFFColorTable(GDALColorTable* poColorTable,\n                                 int nBits,\n                                 std::vector<unsigned short>& anTRed,\n                                 std::vector<unsigned short>& anTGreen,\n                                 std::vector<unsigned short>& anTBlue,\n                                 unsigned short*& panRed,\n                                 unsigned short*& panGreen,\n                                 unsigned short*& panBlue)\n{\n    int nColors;\n\n    if( nBits == 8 )\n        nColors = 256;\n    else if( nBits < 8 )\n        nColors = 1 << nBits;\n    else\n        nColors = 65536;\n\n    anTRed.resize(nColors,0);\n    anTGreen.resize(nColors,0);\n    anTBlue.resize(nColors,0);\n\n    for( int iColor = 0; iColor < nColors; ++iColor )\n    {\n        if( iColor < poColorTable->GetColorEntryCount() )\n        {\n            GDALColorEntry sRGB;\n\n            poColorTable->GetColorEntryAsRGB( iColor, &sRGB );\n\n            anTRed[iColor] = static_cast<unsigned short>(257 * sRGB.c1);\n            anTGreen[iColor] = static_cast<unsigned short>(257 * sRGB.c2);\n            anTBlue[iColor] = static_cast<unsigned short>(257 * sRGB.c3);\n        }\n        else\n        {\n            anTRed[iColor] = 0;\n            anTGreen[iColor] = 0;\n            anTBlue[iColor] = 0;\n        }\n    }\n\n    panRed = &(anTRed[0]);\n    panGreen = &(anTGreen[0]);\n    panBlue = &(anTBlue[0]);\n}\n\n/************************************************************************/\n/*                  CreateOverviewsFromSrcOverviews()                   */\n/************************************************************************/\n\n// If poOvrDS is not null, it is used and poSrcDS is ignored.\n\nCPLErr GTiffDataset::CreateOverviewsFromSrcOverviews(GDALDataset* poSrcDS,\n                                                     GDALDataset* poOvrDS)\n{\n    CPLAssert(poSrcDS->GetRasterCount() != 0);\n    CPLAssert(m_nOverviewCount == 0);\n\n    ScanDirectories();\n\n    FlushDirectory();\n\n    int nOvBitsPerSample = m_nBitsPerSample;\n\n/* -------------------------------------------------------------------- */\n/*      Do we have a palette?  If so, create a TIFF compatible version. */\n/* -------------------------------------------------------------------- */\n    std::vector<unsigned short> anTRed;\n    std::vector<unsigned short> anTGreen;\n    std::vector<unsigned short> anTBlue;\n    unsigned short *panRed = nullptr;\n    unsigned short *panGreen = nullptr;\n    unsigned short *panBlue = nullptr;\n\n    if( m_nPhotometric == PHOTOMETRIC_PALETTE && m_poColorTable != nullptr )\n    {\n        CreateTIFFColorTable(m_poColorTable, nOvBitsPerSample,\n                             anTRed, anTGreen, anTBlue,\n                             panRed, panGreen, panBlue);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Do we need some metadata for the overviews?                     */\n/* -------------------------------------------------------------------- */\n    CPLString osMetadata;\n\n    GTIFFBuildOverviewMetadata( \"NONE\", this, osMetadata );\n\n/* -------------------------------------------------------------------- */\n/*      Fetch extra sample tag                                          */\n/* -------------------------------------------------------------------- */\n    uint16 *panExtraSampleValues = nullptr;\n    uint16 nExtraSamples = 0;\n\n    if( TIFFGetField( m_hTIFF, TIFFTAG_EXTRASAMPLES, &nExtraSamples,\n                      &panExtraSampleValues) )\n    {\n        uint16* panExtraSampleValuesNew =\n            static_cast<uint16*>(\n                CPLMalloc(nExtraSamples * sizeof(uint16)) );\n        memcpy( panExtraSampleValuesNew, panExtraSampleValues,\n                nExtraSamples * sizeof(uint16));\n        panExtraSampleValues = panExtraSampleValuesNew;\n    }\n    else\n    {\n        panExtraSampleValues = nullptr;\n        nExtraSamples = 0;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Fetch predictor tag                                             */\n/* -------------------------------------------------------------------- */\n    uint16 nPredictor = PREDICTOR_NONE;\n    if( m_nCompression == COMPRESSION_LZW ||\n        m_nCompression == COMPRESSION_ADOBE_DEFLATE ||\n        m_nCompression == COMPRESSION_ZSTD )\n        TIFFGetField( m_hTIFF, TIFFTAG_PREDICTOR, &nPredictor );\n    int nOvrBlockXSize = 0;\n    int nOvrBlockYSize = 0;\n    GTIFFGetOverviewBlockSize(GDALRasterBand::ToHandle(GetRasterBand(1)),\n                              &nOvrBlockXSize, &nOvrBlockYSize);\n\n    int nSrcOverviews = poOvrDS ?\n        poOvrDS->GetRasterBand(1)->GetOverviewCount() + 1:\n        poSrcDS->GetRasterBand(1)->GetOverviewCount();\n    CPLErr eErr = CE_None;\n\n    for( int i = 0; i < nSrcOverviews && eErr == CE_None; ++i )\n    {\n        GDALRasterBand* poOvrBand = poOvrDS ?\n            ((i == 0) ? poOvrDS->GetRasterBand(1) :\n                        poOvrDS->GetRasterBand(1)->GetOverview(i-1)):\n            poSrcDS->GetRasterBand(1)->GetOverview(i);\n\n        int nOXSize = poOvrBand->GetXSize();\n        int nOYSize = poOvrBand->GetYSize();\n\n        int nOvrJpegQuality = m_nJpegQuality;\n        if( m_nCompression == COMPRESSION_JPEG &&\n            CPLGetConfigOption( \"JPEG_QUALITY_OVERVIEW\", nullptr ) != nullptr )\n        {\n            nOvrJpegQuality =\n                atoi(CPLGetConfigOption(\"JPEG_QUALITY_OVERVIEW\",\"75\"));\n        }\n        int nOvrWebpLevel = m_nWebPLevel;\n        if( m_nCompression == COMPRESSION_WEBP &&\n            CPLGetConfigOption( \"WEBP_LEVEL_OVERVIEW\", nullptr ) != nullptr )\n        {\n            nOvrWebpLevel =\n                atoi(CPLGetConfigOption(\"WEBP_LEVEL_OVERVIEW\",\"75\"));\n        }\n\n        CPLString osNoData; // don't move this in inner scope\n        const char* pszNoData = nullptr;\n        if( m_bNoDataSet )\n        {\n            osNoData = GTiffFormatGDALNoDataTagValue(m_dfNoDataValue);\n            pszNoData = osNoData.c_str();\n        }\n\n        toff_t nOverviewOffset =\n                GTIFFWriteDirectory(m_hTIFF, FILETYPE_REDUCEDIMAGE,\n                                    nOXSize, nOYSize,\n                                    nOvBitsPerSample, m_nPlanarConfig,\n                                    m_nSamplesPerPixel,\n                                    nOvrBlockXSize,\n                                    nOvrBlockYSize,\n                                    TRUE,\n                                    m_nCompression, m_nPhotometric, m_nSampleFormat,\n                                    nPredictor,\n                                    panRed, panGreen, panBlue,\n                                    nExtraSamples, panExtraSampleValues,\n                                    osMetadata,\n                                    nOvrJpegQuality >= 0 ?\n                                        CPLSPrintf(\"%d\", nOvrJpegQuality) : nullptr,\n                                    CPLSPrintf(\"%d\", m_nJpegTablesMode),\n                                    pszNoData,\n#ifdef HAVE_LERC\n                                    m_anLercAddCompressionAndVersion,\n#else\n                                    nullptr,\n#endif\n                                    m_bWriteCOGLayout,\n                                    nOvrWebpLevel >= 0 ?\n                                        CPLSPrintf(\"%d\", nOvrWebpLevel) : nullptr\n                                   );\n\n        if( nOverviewOffset == 0 )\n            eErr = CE_Failure;\n        else\n            eErr = RegisterNewOverviewDataset(nOverviewOffset, nOvrJpegQuality, nOvrWebpLevel);\n    }\n\n    // For directory reloading, so that the chaining to the next directory is\n    // reloaded, as well as compression parameters.\n    ReloadDirectory();\n\n    CPLFree(panExtraSampleValues);\n    panExtraSampleValues = nullptr;\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                           ReloadDirectory()                          */\n/************************************************************************/\n\nvoid GTiffDataset::ReloadDirectory()\n{\n    TIFFSetSubDirectory( m_hTIFF, 0 );\n    CPL_IGNORE_RET_VAL( SetDirectory() );\n}\n\n/************************************************************************/\n/*                       CreateInternalMaskOverviews()                  */\n/************************************************************************/\n\nCPLErr GTiffDataset::CreateInternalMaskOverviews(int nOvrBlockXSize,\n                                                 int nOvrBlockYSize)\n{\n    ScanDirectories();\n\n/* -------------------------------------------------------------------- */\n/*      Create overviews for the mask.                                  */\n/* -------------------------------------------------------------------- */\n    CPLErr eErr = CE_None;\n\n    const char* pszInternalMask =\n        CPLGetConfigOption(\"GDAL_TIFF_INTERNAL_MASK\", nullptr);\n    if( m_poMaskDS != nullptr &&\n        m_poMaskDS->GetRasterCount() == 1 &&\n        (pszInternalMask == nullptr || CPLTestBool(pszInternalMask)) )\n    {\n        int nMaskOvrCompression;\n        if( strstr(GDALGetMetadataItem(GDALGetDriverByName( \"GTiff\" ),\n                                       GDAL_DMD_CREATIONOPTIONLIST, nullptr ),\n                   \"<Value>DEFLATE</Value>\") != nullptr )\n            nMaskOvrCompression = COMPRESSION_ADOBE_DEFLATE;\n        else\n            nMaskOvrCompression = COMPRESSION_PACKBITS;\n\n        for( int i = 0; i < m_nOverviewCount; ++i )\n        {\n            if( m_papoOverviewDS[i]->m_poMaskDS == nullptr )\n            {\n                const toff_t nOverviewOffset =\n                    GTIFFWriteDirectory(\n                        m_hTIFF, FILETYPE_REDUCEDIMAGE | FILETYPE_MASK,\n                        m_papoOverviewDS[i]->nRasterXSize,\n                        m_papoOverviewDS[i]->nRasterYSize,\n                        1, PLANARCONFIG_CONTIG,\n                        1, nOvrBlockXSize, nOvrBlockYSize, TRUE,\n                        nMaskOvrCompression, PHOTOMETRIC_MASK,\n                        SAMPLEFORMAT_UINT, PREDICTOR_NONE,\n                        nullptr, nullptr, nullptr, 0, nullptr,\n                        \"\",\n                        nullptr, nullptr, nullptr, nullptr,\n                        m_bWriteCOGLayout,\n                        nullptr );\n\n                if( nOverviewOffset == 0 )\n                {\n                    eErr = CE_Failure;\n                    continue;\n                }\n\n                GTiffDataset *poODS = new GTiffDataset();\n                poODS->ShareLockWithParentDataset(this);\n                poODS->m_pszFilename = CPLStrdup(m_pszFilename);\n                if( poODS->OpenOffset( VSI_TIFFOpenChild(m_hTIFF),\n                                       nOverviewOffset,\n                                       GA_Update ) != CE_None )\n                {\n                    delete poODS;\n                    eErr = CE_Failure;\n                }\n                else\n                {\n                    poODS->m_bPromoteTo8Bits =\n                        CPLTestBool(\n                            CPLGetConfigOption(\n                                \"GDAL_TIFF_INTERNAL_MASK_TO_8BIT\", \"YES\" ) );\n                    poODS->m_poBaseDS = this;\n                    poODS->m_poImageryDS = m_papoOverviewDS[i];\n                    m_papoOverviewDS[i]->m_poMaskDS = poODS;\n                    ++m_poMaskDS->m_nOverviewCount;\n                    m_poMaskDS->m_papoOverviewDS = static_cast<GTiffDataset **>(\n                        CPLRealloc(\n                            m_poMaskDS->m_papoOverviewDS,\n                            m_poMaskDS->m_nOverviewCount * (sizeof(void*))) );\n                    m_poMaskDS->m_papoOverviewDS[m_poMaskDS->m_nOverviewCount-1] =\n                        poODS;\n                }\n            }\n        }\n    }\n\n    ReloadDirectory();\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                          IBuildOverviews()                           */\n/************************************************************************/\n\nCPLErr GTiffDataset::IBuildOverviews(\n    const char * pszResampling,\n    int nOverviews, int * panOverviewList,\n    int nBandsIn, int * panBandList,\n    GDALProgressFunc pfnProgress, void * pProgressData )\n\n{\n    ScanDirectories();\n\n    // Make implicit JPEG overviews invisible, but do not destroy\n    // them in case they are already used (not sure that the client\n    // has the right to do that.  Behavior maybe undefined in GDAL API.\n    m_nJPEGOverviewCount = 0;\n\n/* -------------------------------------------------------------------- */\n/*      If RRD or external OVR overviews requested, then invoke         */\n/*      generic handling.                                               */\n/* -------------------------------------------------------------------- */\n    bool bUseGenericHandling = false;\n\n    if( CPLTestBool(CPLGetConfigOption( \"USE_RRD\", \"NO\" ))\n        || CPLTestBool(CPLGetConfigOption( \"TIFF_USE_OVR\", \"NO\" )) )\n    {\n        bUseGenericHandling = true;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If we don't have read access, then create the overviews         */\n/*      externally.                                                     */\n/* -------------------------------------------------------------------- */\n    if( GetAccess() != GA_Update )\n    {\n        CPLDebug( \"GTiff\",\n                  \"File open for read-only accessing, \"\n                  \"creating overviews externally.\" );\n\n        bUseGenericHandling = true;\n    }\n\n    if( bUseGenericHandling )\n    {\n        if( m_nOverviewCount != 0 )\n        {\n            ReportError(\n                CE_Failure, CPLE_NotSupported,\n                \"Cannot add external overviews when there are already \"\n                \"internal overviews\" );\n            return CE_Failure;\n        }\n\n        CPLErr eErr = GDALDataset::IBuildOverviews(\n            pszResampling, nOverviews, panOverviewList,\n            nBandsIn, panBandList, pfnProgress, pProgressData );\n        if( eErr == CE_None && m_poMaskDS )\n        {\n            ReportError(CE_Warning, CPLE_NotSupported,\n                     \"Building external overviews whereas there is an internal \"\n                     \"mask is not fully supported. \"\n                     \"The overviews of the non-mask bands will be created, \"\n                     \"but not the overviews of the mask band.\");\n        }\n        return eErr;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Our TIFF overview support currently only works safely if all    */\n/*      bands are handled at the same time.                             */\n/* -------------------------------------------------------------------- */\n    if( nBandsIn != GetRasterCount() )\n    {\n        ReportError( CE_Failure, CPLE_NotSupported,\n                  \"Generation of overviews in TIFF currently only \"\n                  \"supported when operating on all bands.  \"\n                  \"Operation failed.\" );\n        return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If zero overviews were requested, we need to clear all          */\n/*      existing overviews.                                             */\n/* -------------------------------------------------------------------- */\n    if( nOverviews == 0 )\n    {\n        if( m_nOverviewCount == 0 )\n            return GDALDataset::IBuildOverviews(\n                pszResampling, nOverviews, panOverviewList,\n                nBandsIn, panBandList, pfnProgress, pProgressData );\n\n        return CleanOverviews();\n    }\n\n    CPLErr eErr = CE_None;\n\n/* -------------------------------------------------------------------- */\n/*      Initialize progress counter.                                    */\n/* -------------------------------------------------------------------- */\n    if( !pfnProgress( 0.0, nullptr, pProgressData ) )\n    {\n        ReportError( CE_Failure, CPLE_UserInterrupt, \"User terminated\" );\n        return CE_Failure;\n    }\n\n    FlushDirectory();\n\n/* -------------------------------------------------------------------- */\n/*      If we are averaging bit data to grayscale we need to create     */\n/*      8bit overviews.                                                 */\n/* -------------------------------------------------------------------- */\n    int nOvBitsPerSample = m_nBitsPerSample;\n\n    if( STARTS_WITH_CI(pszResampling, \"AVERAGE_BIT2\") )\n        nOvBitsPerSample = 8;\n\n/* -------------------------------------------------------------------- */\n/*      Do we have a palette?  If so, create a TIFF compatible version. */\n/* -------------------------------------------------------------------- */\n    std::vector<unsigned short> anTRed;\n    std::vector<unsigned short> anTGreen;\n    std::vector<unsigned short> anTBlue;\n    unsigned short *panRed = nullptr;\n    unsigned short *panGreen = nullptr;\n    unsigned short *panBlue = nullptr;\n\n    if( m_nPhotometric == PHOTOMETRIC_PALETTE && m_poColorTable != nullptr )\n    {\n        CreateTIFFColorTable(m_poColorTable, nOvBitsPerSample,\n                             anTRed, anTGreen, anTBlue,\n                             panRed, panGreen, panBlue);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Do we need some metadata for the overviews?                     */\n/* -------------------------------------------------------------------- */\n    CPLString osMetadata;\n\n    GTIFFBuildOverviewMetadata( pszResampling, this, osMetadata );\n\n/* -------------------------------------------------------------------- */\n/*      Fetch extra sample tag                                          */\n/* -------------------------------------------------------------------- */\n    uint16 *panExtraSampleValues = nullptr;\n    uint16 nExtraSamples = 0;\n\n    if( TIFFGetField( m_hTIFF, TIFFTAG_EXTRASAMPLES, &nExtraSamples,\n                      &panExtraSampleValues) )\n    {\n        uint16* panExtraSampleValuesNew =\n            static_cast<uint16*>( CPLMalloc(nExtraSamples * sizeof(uint16)) );\n        memcpy( panExtraSampleValuesNew, panExtraSampleValues,\n                nExtraSamples * sizeof(uint16) );\n        panExtraSampleValues = panExtraSampleValuesNew;\n    }\n    else\n    {\n        panExtraSampleValues = nullptr;\n        nExtraSamples = 0;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Fetch predictor tag                                             */\n/* -------------------------------------------------------------------- */\n    uint16 nPredictor = PREDICTOR_NONE;\n    if( m_nCompression == COMPRESSION_LZW ||\n        m_nCompression == COMPRESSION_ADOBE_DEFLATE ||\n        m_nCompression == COMPRESSION_ZSTD )\n        TIFFGetField( m_hTIFF, TIFFTAG_PREDICTOR, &nPredictor );\n\n/* -------------------------------------------------------------------- */\n/*      Establish which of the overview levels we already have, and     */\n/*      which are new.  We assume that band 1 of the file is            */\n/*      representative.                                                 */\n/* -------------------------------------------------------------------- */\n    int nOvrBlockXSize = 0;\n    int nOvrBlockYSize = 0;\n    GTIFFGetOverviewBlockSize(GDALRasterBand::ToHandle(GetRasterBand(1)),\n                              &nOvrBlockXSize, &nOvrBlockYSize);\n    std::vector<bool> abRequireNewOverview(nOverviews, true);\n    for( int i = 0; i < nOverviews && eErr == CE_None; ++i )\n    {\n        for( int j = 0; j < m_nOverviewCount && eErr == CE_None; ++j )\n        {\n            GTiffDataset *poODS = m_papoOverviewDS[j];\n\n            const int nOvFactor =\n                GDALComputeOvFactor(poODS->GetRasterXSize(),\n                                    GetRasterXSize(),\n                                    poODS->GetRasterYSize(),\n                                    GetRasterYSize());\n\n            // If we already have a 1x1 overview and this new one would result\n            // in it too, then don't create it.\n            if( poODS->GetRasterXSize() == 1 &&\n                poODS->GetRasterYSize() == 1 &&\n                (GetRasterXSize() + panOverviewList[i] - 1)\n                    / panOverviewList[i] == 1 &&\n                (GetRasterYSize() + panOverviewList[i] - 1)\n                    / panOverviewList[i] == 1 )\n            {\n                abRequireNewOverview[i] = false;\n                break;\n            }\n\n            if( nOvFactor == panOverviewList[i]\n                || nOvFactor == GDALOvLevelAdjust2( panOverviewList[i],\n                                                    GetRasterXSize(),\n                                                    GetRasterYSize() ) )\n            {\n                abRequireNewOverview[i] = false;\n                break;\n            }\n        }\n\n        if( abRequireNewOverview[i] )\n        {\n            if( m_bLayoutIFDSBeforeData && !m_bKnownIncompatibleEdition &&\n                !m_bWriteKnownIncompatibleEdition )\n            {\n                ReportError(CE_Warning, CPLE_AppDefined,\n                         \"Adding new overviews invalidates the \"\n                         \"LAYOUT=IFDS_BEFORE_DATA property\");\n                m_bKnownIncompatibleEdition = true;\n                m_bWriteKnownIncompatibleEdition = true;\n            }\n\n            const int nOXSize =\n                (GetRasterXSize() + panOverviewList[i] - 1)\n                / panOverviewList[i];\n            const int nOYSize =\n                (GetRasterYSize() + panOverviewList[i] - 1)\n                / panOverviewList[i];\n\n            int nOvrJpegQuality = m_nJpegQuality;\n            if( m_nCompression == COMPRESSION_JPEG &&\n                CPLGetConfigOption( \"JPEG_QUALITY_OVERVIEW\", nullptr ) != nullptr )\n            {\n                nOvrJpegQuality =\n                    atoi(CPLGetConfigOption(\"JPEG_QUALITY_OVERVIEW\",\"75\"));\n            }\n            int nOvrWebpLevel = m_nWebPLevel;\n            if( m_nCompression == COMPRESSION_WEBP &&\n                CPLGetConfigOption( \"WEBP_LEVEL_OVERVIEW\", nullptr ) != nullptr )\n            {\n                nOvrWebpLevel =\n                    atoi(CPLGetConfigOption(\"WEBP_LEVEL_OVERVIEW\",\"75\"));\n            }\n\n            CPLString osNoData; // don't move this in inner scope\n            const char* pszNoData = nullptr;\n            if( m_bNoDataSet )\n            {\n                osNoData = GTiffFormatGDALNoDataTagValue(m_dfNoDataValue);\n                pszNoData = osNoData.c_str();\n            }\n\n            const toff_t nOverviewOffset =\n                GTIFFWriteDirectory(\n                    m_hTIFF, FILETYPE_REDUCEDIMAGE,\n                    nOXSize, nOYSize,\n                    nOvBitsPerSample, m_nPlanarConfig,\n                    m_nSamplesPerPixel, nOvrBlockXSize, nOvrBlockYSize, TRUE,\n                    m_nCompression, m_nPhotometric, m_nSampleFormat,\n                    nPredictor,\n                    panRed, panGreen, panBlue,\n                    nExtraSamples, panExtraSampleValues,\n                    osMetadata,\n                    nOvrJpegQuality >= 0 ?\n                                CPLSPrintf(\"%d\", nOvrJpegQuality) : nullptr,\n                    CPLSPrintf(\"%d\", m_nJpegTablesMode),\n                    pszNoData,\n#ifdef HAVE_LERC\n                    m_anLercAddCompressionAndVersion,\n#else\n                    nullptr,\n#endif\n                    false,\n                    nOvrWebpLevel >= 0 ?\n                                CPLSPrintf(\"%d\", nOvrWebpLevel) : nullptr\n            );\n\n            if( nOverviewOffset == 0 )\n                eErr = CE_Failure;\n            else\n                eErr = RegisterNewOverviewDataset(nOverviewOffset,\n                                                  nOvrJpegQuality,\n                                                  nOvrWebpLevel);\n        }\n    }\n\n    CPLFree(panExtraSampleValues);\n    panExtraSampleValues = nullptr;\n\n    ReloadDirectory();\n\n/* -------------------------------------------------------------------- */\n/*      Create overviews for the mask.                                  */\n/* -------------------------------------------------------------------- */\n    if( eErr != CE_None )\n        return eErr;\n\n    eErr = CreateInternalMaskOverviews(nOvrBlockXSize, nOvrBlockYSize);\n\n/* -------------------------------------------------------------------- */\n/*      Refresh overviews for the mask                                  */\n/* -------------------------------------------------------------------- */\n    if( m_poMaskDS != nullptr &&\n        m_poMaskDS->GetRasterCount() == 1 )\n    {\n        int nMaskOverviews = 0;\n\n        GDALRasterBand **papoOverviewBands = static_cast<GDALRasterBand **>(\n            CPLCalloc(sizeof(void*),m_nOverviewCount) );\n        for( int i = 0; i < m_nOverviewCount; ++i )\n        {\n            if( m_papoOverviewDS[i]->m_poMaskDS != nullptr )\n            {\n                papoOverviewBands[nMaskOverviews++] =\n                        m_papoOverviewDS[i]->m_poMaskDS->GetRasterBand(1);\n            }\n        }\n        eErr = GDALRegenerateOverviews(\n            m_poMaskDS->GetRasterBand(1),\n            nMaskOverviews,\n            reinterpret_cast<GDALRasterBandH *>( papoOverviewBands ),\n            pszResampling, GDALDummyProgress, nullptr );\n        CPLFree(papoOverviewBands);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Refresh old overviews that were listed.                         */\n/* -------------------------------------------------------------------- */\n    if( m_nPlanarConfig == PLANARCONFIG_CONTIG &&\n        GDALDataTypeIsComplex(GetRasterBand( panBandList[0] )->\n                              GetRasterDataType()) == FALSE &&\n        GetRasterBand( panBandList[0] )->GetColorTable() == nullptr &&\n        (STARTS_WITH_CI(pszResampling, \"NEAR\") ||\n         EQUAL(pszResampling, \"AVERAGE\") ||\n         EQUAL(pszResampling, \"GAUSS\") ||\n         EQUAL(pszResampling, \"CUBIC\") ||\n         EQUAL(pszResampling, \"CUBICSPLINE\") ||\n         EQUAL(pszResampling, \"LANCZOS\") ||\n         EQUAL(pszResampling, \"BILINEAR\")) )\n    {\n        // In the case of pixel interleaved compressed overviews, we want to\n        // generate the overviews for all the bands block by block, and not\n        // band after band, in order to write the block once and not loose\n        // space in the TIFF file.  We also use that logic for uncompressed\n        // overviews, since GDALRegenerateOverviewsMultiBand() will be able to\n        // trigger cascading overview regeneration even in the presence\n        // of an alpha band.\n\n        int nNewOverviews = 0;\n\n        GDALRasterBand ***papapoOverviewBands =\n            static_cast<GDALRasterBand ***>(CPLCalloc(sizeof(void*),nBandsIn));\n        GDALRasterBand **papoBandList =\n            static_cast<GDALRasterBand **>(CPLCalloc(sizeof(void*),nBandsIn));\n        for( int iBand = 0; iBand < nBandsIn; ++iBand )\n        {\n            GDALRasterBand* poBand = GetRasterBand( panBandList[iBand] );\n\n            papoBandList[iBand] = poBand;\n            papapoOverviewBands[iBand] =\n                static_cast<GDALRasterBand **>( CPLCalloc(\n                    sizeof(void*), poBand->GetOverviewCount()) );\n\n            int iCurOverview = 0;\n            std::vector<bool> abAlreadyUsedOverviewBand(\n                poBand->GetOverviewCount(), false);\n\n            for( int i = 0; i < nOverviews; ++i )\n            {\n                for( int j = 0; j < poBand->GetOverviewCount(); ++j )\n                {\n                    if( abAlreadyUsedOverviewBand[j] )\n                        continue;\n\n                    int    nOvFactor;\n                    GDALRasterBand * poOverview = poBand->GetOverview( j );\n\n                    nOvFactor = GDALComputeOvFactor(poOverview->GetXSize(),\n                                                     poBand->GetXSize(),\n                                                     poOverview->GetYSize(),\n                                                     poBand->GetYSize());\n\n                    int bHasNoData = FALSE;\n                    double noDataValue = poBand->GetNoDataValue(&bHasNoData);\n\n                    if( bHasNoData )\n                        poOverview->SetNoDataValue(noDataValue);\n\n                    if( nOvFactor == panOverviewList[i]\n                        || nOvFactor == GDALOvLevelAdjust2(\n                                            panOverviewList[i],\n                                            poBand->GetXSize(),\n                                            poBand->GetYSize() ) )\n                    {\n                        abAlreadyUsedOverviewBand[j] = true;\n                        CPLAssert(iCurOverview < poBand->GetOverviewCount());\n                        papapoOverviewBands[iBand][iCurOverview] = poOverview;\n                        ++iCurOverview ;\n                        break;\n                    }\n                }\n            }\n\n            if( nNewOverviews == 0 )\n            {\n                nNewOverviews = iCurOverview;\n            }\n            else if( nNewOverviews != iCurOverview )\n            {\n                CPLAssert(false);\n                return CE_Failure;\n            }\n        }\n\n        GDALRegenerateOverviewsMultiBand( nBandsIn, papoBandList,\n                                          nNewOverviews, papapoOverviewBands,\n                                          pszResampling, pfnProgress,\n                                          pProgressData );\n\n        for( int iBand = 0; iBand < nBandsIn; ++iBand )\n        {\n            CPLFree(papapoOverviewBands[iBand]);\n        }\n        CPLFree(papapoOverviewBands);\n        CPLFree(papoBandList);\n    }\n    else\n    {\n        GDALRasterBand **papoOverviewBands = static_cast<GDALRasterBand **>(\n            CPLCalloc(sizeof(void*), nOverviews) );\n\n        for( int iBand = 0; iBand < nBandsIn && eErr == CE_None; ++iBand )\n        {\n            GDALRasterBand *poBand = GetRasterBand( panBandList[iBand] );\n            if( poBand == nullptr )\n            {\n                eErr = CE_Failure;\n                break;\n            }\n\n            std::vector<bool> abAlreadyUsedOverviewBand(\n                poBand->GetOverviewCount(), false);\n\n            int nNewOverviews = 0;\n            for( int i = 0; i < nOverviews; ++i )\n            {\n                for( int j = 0; j < poBand->GetOverviewCount(); ++j )\n                {\n                    if( abAlreadyUsedOverviewBand[j] )\n                        continue;\n\n                    GDALRasterBand * poOverview = poBand->GetOverview( j );\n\n                    int bHasNoData = FALSE;\n                    double noDataValue = poBand->GetNoDataValue(&bHasNoData);\n\n                    if( bHasNoData )\n                        poOverview->SetNoDataValue(noDataValue);\n\n                    const int nOvFactor =\n                        GDALComputeOvFactor(poOverview->GetXSize(),\n                                            poBand->GetXSize(),\n                                            poOverview->GetYSize(),\n                                            poBand->GetYSize());\n\n                    if( nOvFactor == panOverviewList[i]\n                        || nOvFactor == GDALOvLevelAdjust2(\n                                            panOverviewList[i],\n                                            poBand->GetXSize(),\n                                            poBand->GetYSize() ) )\n                    {\n                        abAlreadyUsedOverviewBand[j] = true;\n                        CPLAssert(nNewOverviews < poBand->GetOverviewCount());\n                        papoOverviewBands[nNewOverviews++] = poOverview;\n                        break;\n                    }\n                }\n            }\n\n            void *pScaledProgressData =\n                GDALCreateScaledProgress(\n                    iBand / static_cast<double>( nBandsIn ),\n                    (iBand + 1) / static_cast<double>( nBandsIn ),\n                    pfnProgress, pProgressData );\n\n            eErr = GDALRegenerateOverviews(\n                poBand,\n                nNewOverviews,\n                reinterpret_cast<GDALRasterBandH *>( papoOverviewBands ),\n                pszResampling,\n                GDALScaledProgress,\n                pScaledProgressData );\n\n            GDALDestroyScaledProgress( pScaledProgressData );\n        }\n\n    /* -------------------------------------------------------------------- */\n    /*      Cleanup                                                         */\n    /* -------------------------------------------------------------------- */\n        CPLFree( papoOverviewBands );\n    }\n\n    pfnProgress( 1.0, nullptr, pProgressData );\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                      GTiffWriteDummyGeokeyDirectory()                */\n/************************************************************************/\n\nstatic void GTiffWriteDummyGeokeyDirectory( TIFF* hTIFF )\n{\n    // If we have existing geokeys, try to wipe them\n    // by writing a dummy geokey directory. (#2546)\n    uint16 *panVI = nullptr;\n    uint16 nKeyCount = 0;\n\n    if( TIFFGetField( hTIFF, TIFFTAG_GEOKEYDIRECTORY,\n                        &nKeyCount, &panVI ) )\n    {\n        GUInt16 anGKVersionInfo[4] = { 1, 1, 0, 0 };\n        double adfDummyDoubleParams[1] = { 0.0 };\n        TIFFSetField( hTIFF, TIFFTAG_GEOKEYDIRECTORY,\n                        4, anGKVersionInfo );\n        TIFFSetField( hTIFF, TIFFTAG_GEODOUBLEPARAMS,\n                        1, adfDummyDoubleParams );\n        TIFFSetField( hTIFF, TIFFTAG_GEOASCIIPARAMS, \"\" );\n    }\n}\n\n/************************************************************************/\n/*               GTiffDatasetLibGeotiffErrorCallback()                  */\n/************************************************************************/\n\nstatic void GTiffDatasetLibGeotiffErrorCallback(GTIF*,\n                                                int level,\n                                                const char* pszMsg, ...)\n{\n    va_list ap;\n    va_start(ap, pszMsg);\n    CPLErrorV( (level == LIBGEOTIFF_WARNING ) ? CE_Warning : CE_Failure,\n               CPLE_AppDefined, pszMsg, ap );\n    va_end(ap);\n}\n\n/************************************************************************/\n/*                           GTiffDatasetGTIFNew()                      */\n/************************************************************************/\n\nstatic GTIF* GTiffDatasetGTIFNew( TIFF* hTIFF )\n{\n    GTIF* gtif = GTIFNewEx(hTIFF, GTiffDatasetLibGeotiffErrorCallback, nullptr);\n    if( gtif )\n    {\n        GTIFAttachPROJContext(gtif, OSRGetProjTLSContext());\n    }\n    return gtif;\n}\n\n/************************************************************************/\n/*                          WriteGeoTIFFInfo()                          */\n/************************************************************************/\n\nvoid GTiffDataset::WriteGeoTIFFInfo()\n\n{\n    bool bPixelIsPoint = false;\n    bool bPointGeoIgnore = false;\n\n    const char* pszAreaOrPoint =\n        GTiffDataset::GetMetadataItem( GDALMD_AREA_OR_POINT );\n    if( pszAreaOrPoint && EQUAL(pszAreaOrPoint, GDALMD_AOP_POINT) )\n    {\n        bPixelIsPoint = true;\n        bPointGeoIgnore =\n            CPLTestBool( CPLGetConfigOption( \"GTIFF_POINT_GEO_IGNORE\",\n                                             \"FALSE\") );\n    }\n\n    if( m_bForceUnsetGTOrGCPs )\n    {\n        m_bNeedsRewrite = true;\n        m_bForceUnsetGTOrGCPs = false;\n\n        TIFFUnsetField( m_hTIFF, TIFFTAG_GEOPIXELSCALE );\n        TIFFUnsetField( m_hTIFF, TIFFTAG_GEOTIEPOINTS );\n        TIFFUnsetField( m_hTIFF, TIFFTAG_GEOTRANSMATRIX );\n    }\n\n    if( m_bForceUnsetProjection )\n    {\n        m_bNeedsRewrite = true;\n        m_bForceUnsetProjection = false;\n\n        TIFFUnsetField( m_hTIFF, TIFFTAG_GEOKEYDIRECTORY );\n        TIFFUnsetField( m_hTIFF, TIFFTAG_GEODOUBLEPARAMS );\n        TIFFUnsetField( m_hTIFF, TIFFTAG_GEOASCIIPARAMS );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Write geotransform if valid.                                    */\n/* -------------------------------------------------------------------- */\n    if( m_bGeoTransformValid )\n    {\n        m_bNeedsRewrite = true;\n\n/* -------------------------------------------------------------------- */\n/*      Clear old tags to ensure we don't end up with conflicting       */\n/*      information. (#2625)                                            */\n/* -------------------------------------------------------------------- */\n        TIFFUnsetField( m_hTIFF, TIFFTAG_GEOPIXELSCALE );\n        TIFFUnsetField( m_hTIFF, TIFFTAG_GEOTIEPOINTS );\n        TIFFUnsetField( m_hTIFF, TIFFTAG_GEOTRANSMATRIX );\n\n/* -------------------------------------------------------------------- */\n/*      Write the transform.  If we have a normal north-up image we     */\n/*      use the tiepoint plus pixelscale otherwise we use a matrix.     */\n/* -------------------------------------------------------------------- */\n        if( m_adfGeoTransform[2] == 0.0 && m_adfGeoTransform[4] == 0.0\n                && m_adfGeoTransform[5] < 0.0 )\n        {\n            double dfOffset = 0.0;\n            if( m_eProfile != GTiffProfile::BASELINE )\n            {\n                // In the case the SRS has a vertical component and we have\n                // a single band, encode its scale/offset in the GeoTIFF tags\n                int bHasScale = FALSE;\n                double dfScale = GetRasterBand(1)->GetScale(&bHasScale);\n                int bHasOffset = FALSE;\n                dfOffset = GetRasterBand(1)->GetOffset(&bHasOffset);\n                const bool bApplyScaleOffset =\n                    m_oSRS.IsVertical() &&\n                    GetRasterCount() == 1;\n                if( bApplyScaleOffset && !bHasScale )\n                    dfScale = 1.0;\n                if( !bApplyScaleOffset || !bHasOffset )\n                    dfOffset = 0.0;\n                const double adfPixelScale[3] = {\n                    m_adfGeoTransform[1], fabs(m_adfGeoTransform[5]),\n                    bApplyScaleOffset ? dfScale  : 0.0 };\n                TIFFSetField( m_hTIFF, TIFFTAG_GEOPIXELSCALE, 3, adfPixelScale );\n            }\n\n            double adfTiePoints[6] = {\n                0.0, 0.0, 0.0, m_adfGeoTransform[0], m_adfGeoTransform[3], dfOffset };\n\n            if( bPixelIsPoint && !bPointGeoIgnore )\n            {\n                adfTiePoints[3] +=\n                    m_adfGeoTransform[1] * 0.5 + m_adfGeoTransform[2] * 0.5;\n                adfTiePoints[4] +=\n                    m_adfGeoTransform[4] * 0.5 + m_adfGeoTransform[5] * 0.5;\n            }\n\n            if( m_eProfile != GTiffProfile::BASELINE )\n                TIFFSetField( m_hTIFF, TIFFTAG_GEOTIEPOINTS, 6, adfTiePoints );\n        }\n        else\n        {\n            double adfMatrix[16] = {};\n\n            adfMatrix[0] = m_adfGeoTransform[1];\n            adfMatrix[1] = m_adfGeoTransform[2];\n            adfMatrix[3] = m_adfGeoTransform[0];\n            adfMatrix[4] = m_adfGeoTransform[4];\n            adfMatrix[5] = m_adfGeoTransform[5];\n            adfMatrix[7] = m_adfGeoTransform[3];\n            adfMatrix[15] = 1.0;\n\n            if( bPixelIsPoint && !bPointGeoIgnore )\n            {\n                adfMatrix[3] +=\n                    m_adfGeoTransform[1] * 0.5 + m_adfGeoTransform[2] * 0.5;\n                adfMatrix[7] +=\n                    m_adfGeoTransform[4] * 0.5 + m_adfGeoTransform[5] * 0.5;\n            }\n\n            if( m_eProfile != GTiffProfile::BASELINE )\n                TIFFSetField( m_hTIFF, TIFFTAG_GEOTRANSMATRIX, 16, adfMatrix );\n        }\n\n        // Do we need a world file?\n        if( CPLFetchBool( m_papszCreationOptions, \"TFW\", false ) )\n            GDALWriteWorldFile( m_pszFilename, \"tfw\", m_adfGeoTransform );\n        else if( CPLFetchBool( m_papszCreationOptions, \"WORLDFILE\", false ) )\n            GDALWriteWorldFile( m_pszFilename, \"wld\", m_adfGeoTransform );\n    }\n    else if( GetGCPCount() > 0 )\n    {\n        m_bNeedsRewrite = true;\n\n        double *padfTiePoints = static_cast<double *>(\n            CPLMalloc( 6 * sizeof(double) * GetGCPCount() ) );\n\n        for( int iGCP = 0; iGCP < GetGCPCount(); ++iGCP )\n        {\n\n            padfTiePoints[iGCP*6+0] = m_pasGCPList[iGCP].dfGCPPixel;\n            padfTiePoints[iGCP*6+1] = m_pasGCPList[iGCP].dfGCPLine;\n            padfTiePoints[iGCP*6+2] = 0;\n            padfTiePoints[iGCP*6+3] = m_pasGCPList[iGCP].dfGCPX;\n            padfTiePoints[iGCP*6+4] = m_pasGCPList[iGCP].dfGCPY;\n            padfTiePoints[iGCP*6+5] = m_pasGCPList[iGCP].dfGCPZ;\n\n            if( bPixelIsPoint && !bPointGeoIgnore )\n            {\n                padfTiePoints[iGCP*6+0] += 0.5;\n                padfTiePoints[iGCP*6+1] += 0.5;\n            }\n        }\n\n        if( m_eProfile != GTiffProfile::BASELINE )\n            TIFFSetField( m_hTIFF, TIFFTAG_GEOTIEPOINTS,\n                          6 * GetGCPCount(), padfTiePoints );\n        CPLFree( padfTiePoints );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Write out projection definition.                                */\n/* -------------------------------------------------------------------- */\n    const bool bHasProjection = !m_oSRS.IsEmpty();\n    if( (bHasProjection || bPixelIsPoint)\n        && m_eProfile != GTiffProfile::BASELINE )\n    {\n        m_bNeedsRewrite = true;\n\n        // If we have existing geokeys, try to wipe them\n        // by writing a dummy geokey directory. (#2546)\n        GTiffWriteDummyGeokeyDirectory(m_hTIFF);\n\n        GTIF *psGTIF = GTiffDatasetGTIFNew( m_hTIFF );\n\n        // Set according to coordinate system.\n        if( bHasProjection )\n        {\n            char* pszProjection = nullptr;\n            {\n                CPLErrorStateBackuper oErrorStateBackuper;\n                CPLErrorHandlerPusher oErrorHandler(CPLQuietErrorHandler);\n                m_oSRS.exportToWkt(&pszProjection);\n            }\n            if( pszProjection && pszProjection[0] &&\n                strstr(pszProjection, \"custom_proj4\") == nullptr )\n            {\n                GTIFSetFromOGISDefnEx( psGTIF, pszProjection,\n                                       m_eGeoTIFFKeysFlavor,\n                                       m_eGeoTIFFVersion );\n            }\n            else\n            {\n                GDALPamDataset::SetSpatialRef(&m_oSRS);\n            }\n            CPLFree(pszProjection);\n        }\n\n        if( bPixelIsPoint )\n        {\n            GTIFKeySet(psGTIF, GTRasterTypeGeoKey, TYPE_SHORT, 1,\n                       RasterPixelIsPoint);\n        }\n\n        GTIFWriteKeys( psGTIF );\n        GTIFFree( psGTIF );\n    }\n}\n\n/************************************************************************/\n/*                         AppendMetadataItem()                         */\n/************************************************************************/\n\nstatic void AppendMetadataItem( CPLXMLNode **ppsRoot, CPLXMLNode **ppsTail,\n                                const char *pszKey, const char *pszValue,\n                                int nBand, const char *pszRole,\n                                const char *pszDomain )\n\n{\n/* -------------------------------------------------------------------- */\n/*      Create the Item element, and subcomponents.                     */\n/* -------------------------------------------------------------------- */\n    CPLXMLNode *psItem = CPLCreateXMLNode( nullptr, CXT_Element, \"Item\" );\n    CPLCreateXMLNode( CPLCreateXMLNode( psItem, CXT_Attribute, \"name\"),\n                      CXT_Text, pszKey );\n\n    if( nBand > 0 )\n    {\n        char szBandId[32] = {};\n        snprintf( szBandId, sizeof(szBandId), \"%d\", nBand - 1 );\n        CPLCreateXMLNode( CPLCreateXMLNode( psItem,CXT_Attribute,\"sample\"),\n                          CXT_Text, szBandId );\n    }\n\n    if( pszRole != nullptr )\n        CPLCreateXMLNode( CPLCreateXMLNode( psItem,CXT_Attribute,\"role\"),\n                          CXT_Text, pszRole );\n\n    if( pszDomain != nullptr && strlen(pszDomain) > 0 )\n        CPLCreateXMLNode( CPLCreateXMLNode( psItem,CXT_Attribute,\"domain\"),\n                          CXT_Text, pszDomain );\n\n    char *pszEscapedItemValue = CPLEscapeString(pszValue,-1,CPLES_XML);\n    CPLCreateXMLNode( psItem, CXT_Text, pszEscapedItemValue );\n    CPLFree( pszEscapedItemValue );\n\n/* -------------------------------------------------------------------- */\n/*      Create root, if missing.                                        */\n/* -------------------------------------------------------------------- */\n    if( *ppsRoot == nullptr )\n        *ppsRoot = CPLCreateXMLNode( nullptr, CXT_Element, \"GDALMetadata\" );\n\n/* -------------------------------------------------------------------- */\n/*      Append item to tail.  We keep track of the tail to avoid        */\n/*      O(nsquared) time as the list gets longer.                       */\n/* -------------------------------------------------------------------- */\n    if( *ppsTail == nullptr )\n        CPLAddXMLChild( *ppsRoot, psItem );\n    else\n        CPLAddXMLSibling( *ppsTail, psItem );\n\n    *ppsTail = psItem;\n}\n\n/************************************************************************/\n/*                         WriteMDMetadata()                            */\n/************************************************************************/\n\nstatic void WriteMDMetadata( GDALMultiDomainMetadata *poMDMD, TIFF *hTIFF,\n                             CPLXMLNode **ppsRoot, CPLXMLNode **ppsTail,\n                             int nBand, GTiffProfile eProfile )\n\n{\n\n/* ==================================================================== */\n/*      Process each domain.                                            */\n/* ==================================================================== */\n    char **papszDomainList = poMDMD->GetDomainList();\n    for( int iDomain = 0;\n         papszDomainList && papszDomainList[iDomain];\n         ++iDomain )\n    {\n        char **papszMD = poMDMD->GetMetadata( papszDomainList[iDomain] );\n        bool bIsXML = false;\n\n        if( EQUAL(papszDomainList[iDomain], \"IMAGE_STRUCTURE\") )\n            continue;  // Ignored.\n        if( EQUAL(papszDomainList[iDomain], \"COLOR_PROFILE\") )\n            continue;  // Ignored.\n        if( EQUAL(papszDomainList[iDomain], MD_DOMAIN_RPC) )\n            continue;  // Handled elsewhere.\n        if( EQUAL(papszDomainList[iDomain], \"xml:ESRI\")\n            && CPLTestBool(CPLGetConfigOption( \"ESRI_XML_PAM\", \"NO\" )) )\n            continue;  // Handled elsewhere.\n        if( EQUAL(papszDomainList[iDomain], \"xml:XMP\") )\n            continue;  // Handled in SetMetadata.\n\n        if( STARTS_WITH_CI(papszDomainList[iDomain], \"xml:\") )\n            bIsXML = true;\n\n/* -------------------------------------------------------------------- */\n/*      Process each item in this domain.                               */\n/* -------------------------------------------------------------------- */\n        for( int iItem = 0; papszMD && papszMD[iItem]; ++iItem )\n        {\n            const char *pszItemValue = nullptr;\n            char *pszItemName = nullptr;\n\n            if( bIsXML )\n            {\n                pszItemName = CPLStrdup(\"doc\");\n                pszItemValue = papszMD[iItem];\n            }\n            else\n            {\n                pszItemValue = CPLParseNameValue( papszMD[iItem], &pszItemName);\n                if( pszItemName == nullptr )\n                {\n                    CPLDebug( \"GTiff\",\n                              \"Invalid metadata item : %s\", papszMD[iItem] );\n                    continue;\n                }\n            }\n\n/* -------------------------------------------------------------------- */\n/*      Convert into XML item or handle as a special TIFF tag.          */\n/* -------------------------------------------------------------------- */\n            if( strlen(papszDomainList[iDomain]) == 0\n                && nBand == 0 &&\n                (STARTS_WITH_CI(pszItemName, \"TIFFTAG_\") ||\n                 (EQUAL(pszItemName, \"GEO_METADATA\") &&\n                  eProfile == GTiffProfile::GDALGEOTIFF) ||\n                 (EQUAL(pszItemName, \"TIFF_RSID\") &&\n                  eProfile == GTiffProfile::GDALGEOTIFF)) )\n            {\n                if( EQUAL(pszItemName, \"TIFFTAG_RESOLUTIONUNIT\") )\n                {\n                    // ResolutionUnit can't be 0, which is the default if\n                    // atoi() fails.  Set to 1=Unknown.\n                    int v = atoi(pszItemValue);\n                    if( !v ) v = RESUNIT_NONE;\n                    TIFFSetField( hTIFF, TIFFTAG_RESOLUTIONUNIT, v);\n                }\n                else\n                {\n                    bool bFoundTag = false;\n                    size_t iTag = 0;  // Used after for.\n                    for( ;\n                         iTag < sizeof(asTIFFTags) / sizeof(asTIFFTags[0]);\n                         ++iTag )\n                    {\n                        if( EQUAL(pszItemName, asTIFFTags[iTag].pszTagName) )\n                        {\n                            bFoundTag = true;\n                            break;\n                        }\n                    }\n\n                    if( bFoundTag &&\n                        asTIFFTags[iTag].eType == GTIFFTAGTYPE_STRING )\n                        TIFFSetField( hTIFF, asTIFFTags[iTag].nTagVal,\n                                      pszItemValue );\n                    else if( bFoundTag &&\n                             asTIFFTags[iTag].eType == GTIFFTAGTYPE_FLOAT )\n                        TIFFSetField( hTIFF, asTIFFTags[iTag].nTagVal,\n                                      CPLAtof(pszItemValue) );\n                    else if( bFoundTag &&\n                             asTIFFTags[iTag].eType == GTIFFTAGTYPE_SHORT )\n                        TIFFSetField( hTIFF, asTIFFTags[iTag].nTagVal,\n                                      atoi(pszItemValue) );\n                    else if( bFoundTag &&\n                             asTIFFTags[iTag].eType == GTIFFTAGTYPE_BYTE_STRING )\n                    {\n                        uint32 nLen = static_cast<uint32>(strlen(pszItemValue));\n                        if( nLen )\n                        {\n                            TIFFSetField( hTIFF, asTIFFTags[iTag].nTagVal,\n                                          nLen,\n                                          pszItemValue );\n                        }\n                    }\n                    else\n                        CPLError(\n                            CE_Warning, CPLE_NotSupported,\n                            \"%s metadata item is unhandled and \"\n                            \"will not be written\",\n                            pszItemName);\n                }\n            }\n            else if( nBand == 0 && EQUAL(pszItemName,GDALMD_AREA_OR_POINT) )\n            {\n                /* Do nothing, handled elsewhere. */;\n            }\n            else\n            {\n                AppendMetadataItem( ppsRoot, ppsTail,\n                                    pszItemName, pszItemValue,\n                                    nBand, nullptr, papszDomainList[iDomain] );\n            }\n\n            CPLFree( pszItemName );\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Remove TIFFTAG_xxxxxx that are already set but no longer in     */\n/*      the metadata list (#5619)                                       */\n/* -------------------------------------------------------------------- */\n        if( strlen(papszDomainList[iDomain]) == 0 && nBand == 0 )\n        {\n            for( size_t iTag = 0;\n                 iTag < sizeof(asTIFFTags) / sizeof(asTIFFTags[0]);\n                 ++iTag )\n            {\n                uint32 nCount = 0;\n                char* pszText = nullptr;\n                int16 nVal = 0;\n                float fVal = 0.0f;\n                const char* pszVal =\n                    CSLFetchNameValue(papszMD, asTIFFTags[iTag].pszTagName);\n                if( pszVal == nullptr &&\n                    ((asTIFFTags[iTag].eType == GTIFFTAGTYPE_STRING &&\n                      TIFFGetField( hTIFF, asTIFFTags[iTag].nTagVal,\n                                    &pszText )) ||\n                     (asTIFFTags[iTag].eType == GTIFFTAGTYPE_SHORT &&\n                      TIFFGetField( hTIFF, asTIFFTags[iTag].nTagVal, &nVal )) ||\n                     (asTIFFTags[iTag].eType == GTIFFTAGTYPE_FLOAT &&\n                      TIFFGetField( hTIFF, asTIFFTags[iTag].nTagVal, &fVal )) ||\n                     (asTIFFTags[iTag].eType == GTIFFTAGTYPE_BYTE_STRING &&\n                      TIFFGetField( hTIFF, asTIFFTags[iTag].nTagVal, &nCount, &pszText ))) )\n                {\n                    TIFFUnsetField( hTIFF, asTIFFTags[iTag].nTagVal );\n                }\n            }\n        }\n    }\n}\n\n/************************************************************************/\n/*                           WriteRPC()                                 */\n/************************************************************************/\n\nvoid GTiffDataset::WriteRPC( GDALDataset *poSrcDS, TIFF *l_hTIFF,\n                             int bSrcIsGeoTIFF,\n                             GTiffProfile eProfile,\n                             const char *pszTIFFFilename,\n                             char **l_papszCreationOptions,\n                             bool bWriteOnlyInPAMIfNeeded )\n{\n/* -------------------------------------------------------------------- */\n/*      Handle RPC data written to TIFF RPCCoefficient tag, RPB file,   */\n/*      RPCTEXT file or PAM.                                            */\n/* -------------------------------------------------------------------- */\n    char **papszRPCMD = poSrcDS->GetMetadata(MD_DOMAIN_RPC);\n    if( papszRPCMD != nullptr )\n    {\n        bool bRPCSerializedOtherWay = false;\n\n        if( eProfile == GTiffProfile::GDALGEOTIFF )\n        {\n            if( !bWriteOnlyInPAMIfNeeded )\n                GTiffDatasetWriteRPCTag( l_hTIFF, papszRPCMD );\n            bRPCSerializedOtherWay = true;\n        }\n\n        // Write RPB file if explicitly asked, or if a non GDAL specific\n        // profile is selected and RPCTXT is not asked.\n        bool bRPBExplicitlyAsked =\n            CPLFetchBool( l_papszCreationOptions, \"RPB\", false );\n        bool bRPBExplicitlyDenied =\n            !CPLFetchBool( l_papszCreationOptions, \"RPB\", true );\n        if( (eProfile != GTiffProfile::GDALGEOTIFF &&\n             !CPLFetchBool( l_papszCreationOptions, \"RPCTXT\", false ) &&\n             !bRPBExplicitlyDenied )\n            || bRPBExplicitlyAsked )\n        {\n            if( !bWriteOnlyInPAMIfNeeded )\n                GDALWriteRPBFile( pszTIFFFilename, papszRPCMD );\n            bRPCSerializedOtherWay = true;\n        }\n\n        if( CPLFetchBool( l_papszCreationOptions, \"RPCTXT\", false ) )\n        {\n            if( !bWriteOnlyInPAMIfNeeded )\n                GDALWriteRPCTXTFile( pszTIFFFilename, papszRPCMD );\n            bRPCSerializedOtherWay = true;\n        }\n\n        if( !bRPCSerializedOtherWay && bWriteOnlyInPAMIfNeeded &&\n            bSrcIsGeoTIFF )\n            cpl::down_cast<GTiffDataset*>(poSrcDS)->\n                GDALPamDataset::SetMetadata( papszRPCMD, MD_DOMAIN_RPC );\n    }\n}\n\n/************************************************************************/\n/*                  IsStandardColorInterpretation()                     */\n/************************************************************************/\n\nstatic bool IsStandardColorInterpretation(GDALDataset* poSrcDS,\n                                          uint16 nPhotometric,\n                                          char** papszCreationOptions)\n{\n    bool bStardardColorInterp = true;\n    if( nPhotometric == PHOTOMETRIC_MINISBLACK )\n    {\n        for( int i = 0; i < poSrcDS->GetRasterCount(); ++i )\n        {\n            const GDALColorInterp eInterp =\n                poSrcDS->GetRasterBand(i + 1)->GetColorInterpretation();\n            if( !(eInterp == GCI_GrayIndex || eInterp == GCI_Undefined ||\n                    (i > 0 && eInterp == GCI_AlphaBand)) )\n            {\n                bStardardColorInterp = false;\n                break;\n            }\n        }\n    }\n    else if( nPhotometric == PHOTOMETRIC_PALETTE )\n    {\n        bStardardColorInterp =\n            poSrcDS->GetRasterBand(1)->GetColorInterpretation() ==\n                GCI_PaletteIndex;\n    }\n    else if( nPhotometric == PHOTOMETRIC_RGB )\n    {\n        int iStart = 0;\n        if( EQUAL(CSLFetchNameValueDef(papszCreationOptions,\n                                       \"PHOTOMETRIC\", \"\"), \"RGB\") )\n        {\n            iStart = 3;\n            if( poSrcDS->GetRasterCount() == 4 &&\n                CSLFetchNameValue(papszCreationOptions, \"ALPHA\") != nullptr )\n            {\n                iStart = 4;\n            }\n        }\n        for( int i = iStart; i < poSrcDS->GetRasterCount(); ++i )\n        {\n            const GDALColorInterp eInterp =\n                poSrcDS->GetRasterBand(i+1)->GetColorInterpretation();\n            if( !((i == 0 && eInterp == GCI_RedBand) ||\n                    (i == 1 && eInterp == GCI_GreenBand) ||\n                    (i == 2 && eInterp == GCI_BlueBand) ||\n                    (i >= 3 && (eInterp == GCI_Undefined ||\n                                eInterp == GCI_AlphaBand))) )\n            {\n                bStardardColorInterp = false;\n                break;\n            }\n        }\n    }\n    else if( nPhotometric == PHOTOMETRIC_YCBCR &&\n             poSrcDS->GetRasterCount() == 3 )\n    {\n        // do nothing\n    }\n    else\n    {\n        bStardardColorInterp = false;\n    }\n    return bStardardColorInterp;\n}\n\n/************************************************************************/\n/*                           WriteMetadata()                            */\n/************************************************************************/\n\nbool GTiffDataset::WriteMetadata( GDALDataset *poSrcDS, TIFF *l_hTIFF,\n                                  bool bSrcIsGeoTIFF,\n                                  GTiffProfile eProfile,\n                                  const char *pszTIFFFilename,\n                                  char **l_papszCreationOptions,\n                                  bool bExcludeRPBandIMGFileWriting)\n\n{\n/* -------------------------------------------------------------------- */\n/*      Convert all the remaining metadata into a simple XML            */\n/*      format.                                                         */\n/* -------------------------------------------------------------------- */\n    CPLXMLNode *psRoot = nullptr;\n    CPLXMLNode *psTail = nullptr;\n\n    if( bSrcIsGeoTIFF )\n    {\n        GTiffDataset* poSrcDSGTiff = cpl::down_cast<GTiffDataset *>(poSrcDS);\n        assert(poSrcDSGTiff);\n        WriteMDMetadata(\n            &poSrcDSGTiff->m_oGTiffMDMD,\n            l_hTIFF, &psRoot, &psTail, 0, eProfile );\n    }\n    else\n    {\n        char **papszMD = poSrcDS->GetMetadata();\n\n        if( CSLCount(papszMD) > 0 )\n        {\n            GDALMultiDomainMetadata l_oMDMD;\n            l_oMDMD.SetMetadata( papszMD );\n\n            WriteMDMetadata( &l_oMDMD, l_hTIFF, &psRoot, &psTail,\n                             0, eProfile );\n        }\n    }\n\n    if( !bExcludeRPBandIMGFileWriting )\n    {\n        WriteRPC(poSrcDS, l_hTIFF, bSrcIsGeoTIFF,\n                 eProfile, pszTIFFFilename,\n                 l_papszCreationOptions);\n\n/* -------------------------------------------------------------------- */\n/*      Handle metadata data written to an IMD file.                    */\n/* -------------------------------------------------------------------- */\n        char **papszIMDMD = poSrcDS->GetMetadata(MD_DOMAIN_IMD);\n        if( papszIMDMD != nullptr )\n        {\n            GDALWriteIMDFile( pszTIFFFilename, papszIMDMD );\n        }\n    }\n\n    uint16 nPhotometric = 0;\n    if( !TIFFGetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, &(nPhotometric) ) )\n        nPhotometric = PHOTOMETRIC_MINISBLACK;\n\n    const bool bStardardColorInterp =\n        IsStandardColorInterpretation(poSrcDS, nPhotometric,\n                                      l_papszCreationOptions);\n\n/* -------------------------------------------------------------------- */\n/*      We also need to address band specific metadata, and special     */\n/*      \"role\" metadata.                                                */\n/* -------------------------------------------------------------------- */\n    for( int nBand = 1; nBand <= poSrcDS->GetRasterCount(); ++nBand )\n    {\n        GDALRasterBand *poBand = poSrcDS->GetRasterBand( nBand );\n\n        if( bSrcIsGeoTIFF )\n        {\n            GTiffRasterBand* poSrcBandGTiff = cpl::down_cast<GTiffRasterBand *>(poBand);\n            assert(poSrcBandGTiff);\n            WriteMDMetadata(\n                &poSrcBandGTiff->m_oGTiffMDMD,\n                l_hTIFF, &psRoot, &psTail, nBand, eProfile );\n        }\n        else\n        {\n            char **papszMD = poBand->GetMetadata();\n\n            if( CSLCount(papszMD) > 0 )\n            {\n                GDALMultiDomainMetadata l_oMDMD;\n                l_oMDMD.SetMetadata( papszMD );\n\n                WriteMDMetadata( &l_oMDMD, l_hTIFF, &psRoot, &psTail, nBand,\n                                 eProfile );\n            }\n        }\n\n        const double dfOffset = poBand->GetOffset();\n        const double dfScale = poBand->GetScale();\n        bool bGeoTIFFScaleOffsetInZ = false;\n        double adfGeoTransform[6];\n        // Check if we have already encoded scale/offset in the GeoTIFF tags\n        if( poSrcDS->GetGeoTransform(adfGeoTransform) == CE_None &&\n            adfGeoTransform[2] == 0.0 && adfGeoTransform[4] == 0.0\n            && adfGeoTransform[5] < 0.0 &&\n            poSrcDS->GetSpatialRef() &&\n            poSrcDS->GetSpatialRef()->IsVertical() &&\n            poSrcDS->GetRasterCount() == 1 )\n        {\n            bGeoTIFFScaleOffsetInZ = true;\n        }\n\n        if( (dfOffset != 0.0 || dfScale != 1.0) && !bGeoTIFFScaleOffsetInZ )\n        {\n            char szValue[128] = {};\n\n            CPLsnprintf( szValue, sizeof(szValue), \"%.18g\", dfOffset );\n            AppendMetadataItem( &psRoot, &psTail, \"OFFSET\", szValue, nBand,\n                                \"offset\", \"\" );\n            CPLsnprintf( szValue, sizeof(szValue), \"%.18g\", dfScale );\n            AppendMetadataItem( &psRoot, &psTail, \"SCALE\", szValue, nBand,\n                                \"scale\", \"\" );\n        }\n\n        const char* pszUnitType = poBand->GetUnitType();\n        if( pszUnitType != nullptr && pszUnitType[0] != '\\0' )\n        {\n            bool bWriteUnit = true;\n            auto poSRS = poSrcDS->GetSpatialRef();\n            if( poSRS && poSRS->IsCompound() )\n            {\n                const char* pszVertUnit = nullptr;\n                poSRS->GetTargetLinearUnits(\"COMPD_CS|VERT_CS\", &pszVertUnit);\n                if( pszVertUnit && EQUAL(pszVertUnit, pszUnitType) )\n                {\n                    bWriteUnit = false;\n                }\n            }\n            if( bWriteUnit )\n            {\n                AppendMetadataItem( &psRoot, &psTail, \"UNITTYPE\",\n                                    pszUnitType, nBand,\n                                    \"unittype\", \"\" );\n            }\n        }\n\n        if( strlen(poBand->GetDescription()) > 0 )\n        {\n            AppendMetadataItem( &psRoot, &psTail, \"DESCRIPTION\",\n                                poBand->GetDescription(), nBand,\n                                \"description\", \"\" );\n        }\n\n        if( !bStardardColorInterp &&\n            !(nBand <= 3 &&  EQUAL(CSLFetchNameValueDef(\n                l_papszCreationOptions, \"PHOTOMETRIC\", \"\"), \"RGB\") ) )\n        {\n            AppendMetadataItem( &psRoot, &psTail, \"COLORINTERP\",\n                                GDALGetColorInterpretationName(\n                                    poBand->GetColorInterpretation()),\n                                nBand,\n                                \"colorinterp\", \"\" );\n        }\n    }\n\n    const char* pszTilingSchemeName =\n        CSLFetchNameValue(l_papszCreationOptions, \"@TILING_SCHEME_NAME\");\n    if( pszTilingSchemeName )\n    {\n        AppendMetadataItem( &psRoot, &psTail,\n                            \"NAME\", pszTilingSchemeName,\n                            0, nullptr, \"TILING_SCHEME\" );\n\n        const char* pszZoomLevel = CSLFetchNameValue(\n            l_papszCreationOptions, \"@TILING_SCHEME_ZOOM_LEVEL\");\n        if( pszZoomLevel )\n        {\n            AppendMetadataItem( &psRoot, &psTail,\n                                \"ZOOM_LEVEL\", pszZoomLevel,\n                                0, nullptr, \"TILING_SCHEME\" );\n        }\n\n        const char* pszAlignedLevels = CSLFetchNameValue(\n            l_papszCreationOptions, \"@TILING_SCHEME_ALIGNED_LEVELS\");\n        if( pszAlignedLevels )\n        {\n            AppendMetadataItem( &psRoot, &psTail,\n                                \"ALIGNED_LEVELS\", pszAlignedLevels,\n                                0, nullptr, \"TILING_SCHEME\" );\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Write out the generic XML metadata if there is any.             */\n/* -------------------------------------------------------------------- */\n    if( psRoot != nullptr )\n    {\n        bool bRet = true;\n\n        if( eProfile == GTiffProfile::GDALGEOTIFF )\n        {\n            char *pszXML_MD = CPLSerializeXMLTree( psRoot );\n            if( strlen(pszXML_MD) > 32000 )\n            {\n                if( bSrcIsGeoTIFF )\n                {\n                    if( cpl::down_cast<GTiffDataset *>(\n                           poSrcDS)->GetPamFlags() & GPF_DISABLED )\n                    {\n                        ReportError(\n                            pszTIFFFilename, CE_Warning, CPLE_AppDefined,\n                            \"Metadata exceeding 32000 bytes cannot be written \"\n                            \"into GeoTIFF.\" );\n                    }\n                    else\n                    {\n                        cpl::down_cast<GTiffDataset *>(poSrcDS)->\n                            PushMetadataToPam();\n                        ReportError(\n                            pszTIFFFilename, CE_Warning, CPLE_AppDefined,\n                            \"Metadata exceeding 32000 bytes cannot be written \"\n                            \"into GeoTIFF. Transferred to PAM instead.\" );\n                    }\n                }\n                else\n                {\n                    bRet = false;\n                }\n            }\n            else\n            {\n                TIFFSetField( l_hTIFF, TIFFTAG_GDAL_METADATA, pszXML_MD );\n            }\n            CPLFree( pszXML_MD );\n        }\n        else\n        {\n            if( bSrcIsGeoTIFF )\n                cpl::down_cast<GTiffDataset *>(poSrcDS)->PushMetadataToPam();\n            else\n                bRet = false;\n        }\n\n        CPLDestroyXMLNode( psRoot );\n\n        return bRet;\n    }\n\n    // If we have no more metadata but it existed before,\n    // remove the GDAL_METADATA tag.\n    if( eProfile == GTiffProfile::GDALGEOTIFF )\n    {\n        char* pszText = nullptr;\n        if( TIFFGetField( l_hTIFF, TIFFTAG_GDAL_METADATA, &pszText ) )\n        {\n            TIFFUnsetField( l_hTIFF, TIFFTAG_GDAL_METADATA );\n        }\n    }\n\n    return true;\n}\n\n/************************************************************************/\n/*                         PushMetadataToPam()                          */\n/*                                                                      */\n/*      When producing a strict profile TIFF or if our aggregate        */\n/*      metadata is too big for a single tiff tag we may end up         */\n/*      needing to write it via the PAM mechanisms.  This method        */\n/*      copies all the appropriate metadata into the PAM level          */\n/*      metadata object but with special care to avoid copying          */\n/*      metadata handled in other ways in TIFF format.                  */\n/************************************************************************/\n\nvoid GTiffDataset::PushMetadataToPam()\n\n{\n    if( GetPamFlags() & GPF_DISABLED )\n        return;\n\n    const bool bStardardColorInterp =\n        IsStandardColorInterpretation(this, m_nPhotometric, m_papszCreationOptions);\n\n    for( int nBand = 0; nBand <= GetRasterCount(); ++nBand )\n    {\n        GDALMultiDomainMetadata *poSrcMDMD = nullptr;\n        GTiffRasterBand *poBand = nullptr;\n\n        if( nBand == 0 )\n        {\n            poSrcMDMD = &(this->m_oGTiffMDMD);\n        }\n        else\n        {\n            poBand = cpl::down_cast<GTiffRasterBand *>(GetRasterBand(nBand));\n            poSrcMDMD = &(poBand->m_oGTiffMDMD);\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Loop over the available domains.                                */\n/* -------------------------------------------------------------------- */\n        char **papszDomainList = poSrcMDMD->GetDomainList();\n        for( int iDomain = 0;\n             papszDomainList && papszDomainList[iDomain];\n             ++iDomain )\n        {\n            char **papszMD = poSrcMDMD->GetMetadata( papszDomainList[iDomain] );\n\n            if( EQUAL(papszDomainList[iDomain],MD_DOMAIN_RPC)\n                || EQUAL(papszDomainList[iDomain],MD_DOMAIN_IMD)\n                || EQUAL(papszDomainList[iDomain],\"_temporary_\")\n                || EQUAL(papszDomainList[iDomain],\"IMAGE_STRUCTURE\")\n                || EQUAL(papszDomainList[iDomain],\"COLOR_PROFILE\") )\n                continue;\n\n            papszMD = CSLDuplicate(papszMD);\n\n            for( int i = CSLCount(papszMD)-1; i >= 0; --i )\n            {\n                if( STARTS_WITH_CI(papszMD[i], \"TIFFTAG_\")\n                    || EQUALN(papszMD[i],GDALMD_AREA_OR_POINT,\n                              strlen(GDALMD_AREA_OR_POINT)) )\n                    papszMD = CSLRemoveStrings( papszMD, i, 1, nullptr );\n            }\n\n            if( nBand == 0 )\n                GDALPamDataset::SetMetadata( papszMD, papszDomainList[iDomain]);\n            else\n                poBand->\n                    GDALPamRasterBand::SetMetadata( papszMD,\n                                                    papszDomainList[iDomain]);\n\n            CSLDestroy( papszMD );\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Handle some \"special domain\" stuff.                             */\n/* -------------------------------------------------------------------- */\n        if( poBand != nullptr )\n        {\n            poBand->GDALPamRasterBand::SetOffset( poBand->GetOffset() );\n            poBand->GDALPamRasterBand::SetScale( poBand->GetScale() );\n            poBand->GDALPamRasterBand::SetUnitType( poBand->GetUnitType() );\n            poBand->\n                GDALPamRasterBand::SetDescription( poBand->GetDescription() );\n            if( !bStardardColorInterp )\n            {\n                poBand->GDALPamRasterBand::SetColorInterpretation(\n                                        poBand->GetColorInterpretation() );\n            }\n        }\n    }\n    MarkPamDirty();\n}\n\n/************************************************************************/\n/*                     GTiffDatasetWriteRPCTag()                        */\n/*                                                                      */\n/*      Format a TAG according to:                                      */\n/*                                                                      */\n/*      http://geotiff.maptools.org/rpc_prop.html                       */\n/************************************************************************/\n\nvoid GTiffDatasetWriteRPCTag( TIFF *hTIFF, char **papszRPCMD )\n\n{\n    GDALRPCInfo sRPC;\n\n    if( !GDALExtractRPCInfo( papszRPCMD, &sRPC ) )\n        return;\n\n    double adfRPCTag[92] = {};\n    adfRPCTag[0] = -1.0;  // Error Bias\n    adfRPCTag[1] = -1.0;  // Error Random\n\n    adfRPCTag[2] = sRPC.dfLINE_OFF;\n    adfRPCTag[3] = sRPC.dfSAMP_OFF;\n    adfRPCTag[4] = sRPC.dfLAT_OFF;\n    adfRPCTag[5] = sRPC.dfLONG_OFF;\n    adfRPCTag[6] = sRPC.dfHEIGHT_OFF;\n    adfRPCTag[7] = sRPC.dfLINE_SCALE;\n    adfRPCTag[8] = sRPC.dfSAMP_SCALE;\n    adfRPCTag[9] = sRPC.dfLAT_SCALE;\n    adfRPCTag[10] = sRPC.dfLONG_SCALE;\n    adfRPCTag[11] = sRPC.dfHEIGHT_SCALE;\n\n    memcpy( adfRPCTag + 12, sRPC.adfLINE_NUM_COEFF, sizeof(double) * 20 );\n    memcpy( adfRPCTag + 32, sRPC.adfLINE_DEN_COEFF, sizeof(double) * 20 );\n    memcpy( adfRPCTag + 52, sRPC.adfSAMP_NUM_COEFF, sizeof(double) * 20 );\n    memcpy( adfRPCTag + 72, sRPC.adfSAMP_DEN_COEFF, sizeof(double) * 20 );\n\n    TIFFSetField( hTIFF, TIFFTAG_RPCCOEFFICIENT, 92, adfRPCTag );\n}\n\n/************************************************************************/\n/*                             ReadRPCTag()                             */\n/*                                                                      */\n/*      Format a TAG according to:                                      */\n/*                                                                      */\n/*      http://geotiff.maptools.org/rpc_prop.html                       */\n/************************************************************************/\n\nchar** GTiffDatasetReadRPCTag(TIFF* hTIFF)\n\n{\n    double *padfRPCTag = nullptr;\n    uint16 nCount;\n\n    if( !TIFFGetField( hTIFF, TIFFTAG_RPCCOEFFICIENT, &nCount, &padfRPCTag )\n        || nCount != 92 )\n        return nullptr;\n\n    CPLStringList asMD;\n    asMD.SetNameValue(RPC_LINE_OFF, CPLOPrintf(\"%.15g\", padfRPCTag[2]));\n    asMD.SetNameValue(RPC_SAMP_OFF, CPLOPrintf(\"%.15g\", padfRPCTag[3]));\n    asMD.SetNameValue(RPC_LAT_OFF, CPLOPrintf(\"%.15g\", padfRPCTag[4]));\n    asMD.SetNameValue(RPC_LONG_OFF, CPLOPrintf(\"%.15g\", padfRPCTag[5]));\n    asMD.SetNameValue(RPC_HEIGHT_OFF, CPLOPrintf(\"%.15g\", padfRPCTag[6]));\n    asMD.SetNameValue(RPC_LINE_SCALE, CPLOPrintf(\"%.15g\", padfRPCTag[7]));\n    asMD.SetNameValue(RPC_SAMP_SCALE, CPLOPrintf(\"%.15g\", padfRPCTag[8]));\n    asMD.SetNameValue(RPC_LAT_SCALE, CPLOPrintf(\"%.15g\", padfRPCTag[9]));\n    asMD.SetNameValue(RPC_LONG_SCALE, CPLOPrintf(\"%.15g\", padfRPCTag[10]));\n    asMD.SetNameValue(RPC_HEIGHT_SCALE, CPLOPrintf(\"%.15g\", padfRPCTag[11]));\n\n    CPLString osField;\n    CPLString osMultiField;\n\n    for( int i = 0; i < 20; ++i )\n    {\n        osField.Printf( \"%.15g\", padfRPCTag[12+i] );\n        if( i > 0 )\n            osMultiField += \" \";\n        else\n            osMultiField = \"\";\n        osMultiField += osField;\n    }\n    asMD.SetNameValue(RPC_LINE_NUM_COEFF, osMultiField );\n\n    for( int i = 0; i < 20; ++i )\n    {\n        osField.Printf( \"%.15g\", padfRPCTag[32+i] );\n        if( i > 0 )\n            osMultiField += \" \";\n        else\n            osMultiField = \"\";\n        osMultiField += osField;\n    }\n    asMD.SetNameValue( RPC_LINE_DEN_COEFF, osMultiField );\n\n    for( int i = 0; i < 20; ++i )\n    {\n        osField.Printf( \"%.15g\", padfRPCTag[52+i] );\n        if( i > 0 )\n            osMultiField += \" \";\n        else\n            osMultiField = \"\";\n        osMultiField += osField;\n    }\n    asMD.SetNameValue( RPC_SAMP_NUM_COEFF, osMultiField );\n\n    for( int i = 0; i < 20; ++i )\n    {\n        osField.Printf( \"%.15g\", padfRPCTag[72+i] );\n        if( i > 0 )\n            osMultiField += \" \";\n        else\n            osMultiField = \"\";\n        osMultiField += osField;\n    }\n    asMD.SetNameValue( RPC_SAMP_DEN_COEFF, osMultiField );\n\n    return asMD.StealList();\n}\n\n/************************************************************************/\n/*                  GTiffFormatGDALNoDataTagValue()                     */\n/************************************************************************/\n\nCPLString GTiffFormatGDALNoDataTagValue( double dfNoData )\n{\n    CPLString osVal;\n    if( CPLIsNan(dfNoData) )\n        osVal = \"nan\";\n    else\n        osVal.Printf(\"%.18g\", dfNoData);\n    return osVal;\n}\n\n/************************************************************************/\n/*                         WriteNoDataValue()                           */\n/************************************************************************/\n\nvoid GTiffDataset::WriteNoDataValue( TIFF *l_hTIFF, double dfNoData )\n\n{\n    CPLString osVal( GTiffFormatGDALNoDataTagValue(dfNoData) );\n    TIFFSetField( l_hTIFF, TIFFTAG_GDAL_NODATA, osVal.c_str() );\n}\n\n/************************************************************************/\n/*                         UnsetNoDataValue()                           */\n/************************************************************************/\n\nvoid GTiffDataset::UnsetNoDataValue( TIFF *l_hTIFF )\n\n{\n    TIFFUnsetField( l_hTIFF, TIFFTAG_GDAL_NODATA );\n}\n\n/************************************************************************/\n/*                            SetDirectory()                            */\n/************************************************************************/\n\nbool GTiffDataset::SetDirectory()\n\n{\n    Crystalize();\n\n    if( TIFFCurrentDirOffset(m_hTIFF) == m_nDirOffset )\n    {\n        return true;\n    }\n\n    const int nSetDirResult = TIFFSetSubDirectory( m_hTIFF, m_nDirOffset );\n    if( !nSetDirResult )\n        return false;\n\n    RestoreVolatileParameters( m_hTIFF );\n\n    return true;\n}\n\n/************************************************************************/\n/*                     GTiffSetDeflateSubCodec()                        */\n/************************************************************************/\n\nstatic void GTiffSetDeflateSubCodec(TIFF* hTIFF)\n{\n    (void)hTIFF;\n\n#if defined(TIFFTAG_DEFLATE_SUBCODEC) && defined(LIBDEFLATE_SUPPORT)\n    // Mostly for strict reproducibility purposes\n    if( EQUAL(CPLGetConfigOption(\"GDAL_TIFF_DEFLATE_SUBCODEC\", \"\"), \"ZLIB\") )\n    {\n        TIFFSetField(hTIFF, TIFFTAG_DEFLATE_SUBCODEC,\n                     DEFLATE_SUBCODEC_ZLIB);\n    }\n#endif\n}\n\n/************************************************************************/\n/*                     RestoreVolatileParameters()                      */\n/************************************************************************/\n\nvoid GTiffDataset::RestoreVolatileParameters(TIFF* hTIFF)\n{\n\n/* -------------------------------------------------------------------- */\n/*      YCbCr JPEG compressed images should be translated on the fly    */\n/*      to RGB by libtiff/libjpeg unless specifically requested         */\n/*      otherwise.                                                      */\n/* -------------------------------------------------------------------- */\n    if( m_nCompression == COMPRESSION_JPEG\n        && m_nPhotometric == PHOTOMETRIC_YCBCR\n        && CPLTestBool( CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\",\n                                              \"YES\") ) )\n    {\n        int nColorMode = JPEGCOLORMODE_RAW;  // Initialize to 0;\n\n        TIFFGetField( hTIFF, TIFFTAG_JPEGCOLORMODE, &nColorMode );\n        if( nColorMode != JPEGCOLORMODE_RGB )\n        {\n            TIFFSetField(hTIFF, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n        }\n    }\n\n    if( m_nCompression == COMPRESSION_ADOBE_DEFLATE ||\n        m_nCompression == COMPRESSION_LERC )\n    {\n        GTiffSetDeflateSubCodec(hTIFF);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Propagate any quality settings.                                 */\n/* -------------------------------------------------------------------- */\n    if( GetAccess() == GA_Update )\n    {\n        // Now, reset zip and jpeg quality.\n        if(m_nJpegQuality > 0 && m_nCompression == COMPRESSION_JPEG)\n        {\n#ifdef DEBUG_VERBOSE\n            CPLDebug( \"GTiff\", \"Propagate JPEG_QUALITY(%d) in SetDirectory()\",\n                      m_nJpegQuality );\n#endif\n            TIFFSetField(hTIFF, TIFFTAG_JPEGQUALITY, m_nJpegQuality);\n        }\n        if(m_nJpegTablesMode >= 0 && m_nCompression == COMPRESSION_JPEG)\n            TIFFSetField(hTIFF, TIFFTAG_JPEGTABLESMODE, m_nJpegTablesMode);\n        if(m_nZLevel > 0 && (m_nCompression == COMPRESSION_ADOBE_DEFLATE ||\n                           m_nCompression == COMPRESSION_LERC) )\n            TIFFSetField(hTIFF, TIFFTAG_ZIPQUALITY, m_nZLevel);\n        if(m_nLZMAPreset > 0 && m_nCompression == COMPRESSION_LZMA)\n            TIFFSetField(hTIFF, TIFFTAG_LZMAPRESET, m_nLZMAPreset);\n        if( m_nZSTDLevel > 0 && (m_nCompression == COMPRESSION_ZSTD ||\n                               m_nCompression == COMPRESSION_LERC) )\n            TIFFSetField(hTIFF, TIFFTAG_ZSTD_LEVEL, m_nZSTDLevel);\n#if HAVE_LERC\n        if( m_nCompression == COMPRESSION_LERC )\n        {\n            TIFFSetField(hTIFF, TIFFTAG_LERC_MAXZERROR, m_dfMaxZError);\n        }\n#endif\n        if( m_nWebPLevel > 0 && m_nCompression == COMPRESSION_WEBP)\n            TIFFSetField(hTIFF, TIFFTAG_WEBP_LEVEL, m_nWebPLevel);\n        if( m_bWebPLossless && m_nCompression == COMPRESSION_WEBP)\n            TIFFSetField(hTIFF, TIFFTAG_WEBP_LOSSLESS, 1);\n    }\n}\n\n/************************************************************************/\n/*                              Identify()                              */\n/************************************************************************/\n\nint GTiffDataset::Identify( GDALOpenInfo *poOpenInfo )\n\n{\n    const char *pszFilename = poOpenInfo->pszFilename;\n    if( STARTS_WITH_CI(pszFilename, \"GTIFF_RAW:\") )\n    {\n        pszFilename += strlen(\"GTIFF_RAW:\");\n        GDALOpenInfo oOpenInfo( pszFilename, poOpenInfo->eAccess );\n        return Identify(&oOpenInfo);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      We have a special hook for handling opening a specific          */\n/*      directory of a TIFF file.                                       */\n/* -------------------------------------------------------------------- */\n    if( STARTS_WITH_CI(pszFilename, \"GTIFF_DIR:\") )\n        return TRUE;\n\n/* -------------------------------------------------------------------- */\n/*      First we check to see if the file has the expected header       */\n/*      bytes.                                                          */\n/* -------------------------------------------------------------------- */\n    if( poOpenInfo->fpL == nullptr || poOpenInfo->nHeaderBytes < 2 )\n        return FALSE;\n\n    if( (poOpenInfo->pabyHeader[0] != 'I' || poOpenInfo->pabyHeader[1] != 'I')\n        && (poOpenInfo->pabyHeader[0] != 'M'\n        || poOpenInfo->pabyHeader[1] != 'M'))\n        return FALSE;\n\n    if( (poOpenInfo->pabyHeader[2] != 0x2A || poOpenInfo->pabyHeader[3] != 0)\n        && (poOpenInfo->pabyHeader[3] != 0x2A || poOpenInfo->pabyHeader[2] != 0)\n        && (poOpenInfo->pabyHeader[2] != 0x2B || poOpenInfo->pabyHeader[3] != 0)\n        && (poOpenInfo->pabyHeader[3] != 0x2B ||\n            poOpenInfo->pabyHeader[2] != 0))\n        return FALSE;\n\n    return TRUE;\n}\n\n/************************************************************************/\n/*                          GTIFFExtendMemoryFile()                     */\n/************************************************************************/\n\nstatic bool GTIFFExtendMemoryFile( const CPLString& osTmpFilename,\n                                   VSILFILE* fpTemp,\n                                   VSILFILE* fpL,\n                                   int nNewLength,\n                                   GByte*& pabyBuffer,\n                                   vsi_l_offset& nDataLength )\n{\n    if( nNewLength <= static_cast<int>(nDataLength) )\n        return true;\n    if( VSIFSeekL(fpTemp, nNewLength - 1, SEEK_SET) != 0 )\n        return false;\n    char ch = 0;\n    if( VSIFWriteL(&ch, 1, 1, fpTemp) != 1 )\n        return false;\n    const int nOldDataLength = static_cast<int>(nDataLength);\n    pabyBuffer = static_cast<GByte*>(\n        VSIGetMemFileBuffer( osTmpFilename, &nDataLength, FALSE) );\n    const int nToRead = nNewLength - nOldDataLength;\n    const int nRead = static_cast<int>(\n        VSIFReadL( pabyBuffer + nOldDataLength, 1, nToRead, fpL) );\n    if( nRead != nToRead )\n    {\n        CPLError(CE_Failure, CPLE_FileIO,\n                 \"Needed to read %d bytes. Only %d got\", nToRead, nRead);\n        return false;\n    }\n    return true;\n}\n\n/************************************************************************/\n/*                         GTIFFMakeBufferedStream()                    */\n/************************************************************************/\n\nstatic bool GTIFFMakeBufferedStream(GDALOpenInfo* poOpenInfo)\n{\n    CPLString osTmpFilename;\n    static int nCounter = 0;\n    osTmpFilename.Printf(\"/vsimem/stream_%d.tif\", ++nCounter);\n    VSILFILE* fpTemp = VSIFOpenL(osTmpFilename, \"wb+\");\n    if( fpTemp == nullptr )\n        return false;\n    // The seek is needed for /vsistdin/ that has some rewind capabilities.\n    if( VSIFSeekL(poOpenInfo->fpL, poOpenInfo->nHeaderBytes, SEEK_SET) != 0 )\n    {\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n        return false;\n    }\n    CPLAssert( static_cast<int>( VSIFTellL(poOpenInfo->fpL) ) ==\n               poOpenInfo->nHeaderBytes );\n    if( VSIFWriteL(poOpenInfo->pabyHeader, poOpenInfo->nHeaderBytes,\n                   1, fpTemp) != 1 )\n    {\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n        return false;\n    }\n    vsi_l_offset nDataLength = 0;\n    GByte* pabyBuffer =\n        static_cast<GByte*>(\n            VSIGetMemFileBuffer( osTmpFilename, &nDataLength, FALSE) );\n    const bool bLittleEndian = (pabyBuffer[0] == 'I');\n#if CPL_IS_LSB\n    const bool bSwap = !bLittleEndian;\n#else\n    const bool bSwap = bLittleEndian;\n#endif\n    const bool bBigTIFF = pabyBuffer[2] == 43 || pabyBuffer[3] == 43;\n    vsi_l_offset nMaxOffset = 0;\n    if( bBigTIFF )\n    {\n        GUInt64 nTmp = 0;\n        memcpy(&nTmp, pabyBuffer + 8, 8);\n        if( bSwap ) CPL_SWAP64PTR(&nTmp);\n        if( nTmp != 16 )\n        {\n            CPLError(CE_Failure, CPLE_NotSupported,\n                     \"IFD start should be at offset 16 for a streamed BigTIFF\");\n            CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n            VSIUnlink(osTmpFilename);\n            return false;\n        }\n        memcpy(&nTmp, pabyBuffer + 16, 8);\n        if( bSwap ) CPL_SWAP64PTR(&nTmp);\n        if( nTmp > 1024 )\n        {\n            CPLError(CE_Failure, CPLE_NotSupported,\n                     \"Too many tags : \" CPL_FRMT_GIB, nTmp);\n            CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n            VSIUnlink(osTmpFilename);\n            return false;\n        }\n        const int nTags = static_cast<int>(nTmp);\n        const int nSpaceForTags = nTags * 20;\n        if( !GTIFFExtendMemoryFile(osTmpFilename, fpTemp, poOpenInfo->fpL,\n                                    24 + nSpaceForTags,\n                                    pabyBuffer, nDataLength) )\n        {\n            CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n            VSIUnlink(osTmpFilename);\n            return false;\n        }\n        nMaxOffset = 24 + nSpaceForTags + 8;\n        for( int i = 0; i < nTags; ++i )\n        {\n            GUInt16 nTmp16 = 0;\n            memcpy(&nTmp16, pabyBuffer + 24 + i * 20, 2);\n            if( bSwap ) CPL_SWAP16PTR(&nTmp16);\n            const int nTag = nTmp16;\n            memcpy(&nTmp16, pabyBuffer + 24 + i * 20 + 2, 2);\n            if( bSwap ) CPL_SWAP16PTR(&nTmp16);\n            const int nDataType = nTmp16;\n            memcpy(&nTmp, pabyBuffer + 24 + i * 20 + 4, 8);\n            if( bSwap ) CPL_SWAP64PTR(&nTmp);\n            if( nTmp >= 16 * 1024 * 1024 )\n            {\n                CPLError(\n                    CE_Failure, CPLE_NotSupported,\n                    \"Too many elements for tag %d : \" CPL_FRMT_GUIB,\n                    nTag, nTmp );\n                CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n                VSIUnlink(osTmpFilename);\n                return false;\n            }\n            const GUInt32 nCount = static_cast<GUInt32>(nTmp);\n            const GUInt32 nTagSize =\n                TIFFDataWidth(static_cast<TIFFDataType>(nDataType)) * nCount;\n            if( nTagSize > 8 )\n            {\n                memcpy(&nTmp, pabyBuffer + 24 + i * 20 + 12, 8);\n                if( bSwap ) CPL_SWAP64PTR(&nTmp);\n                if( nTmp > GUINT64_MAX - nTagSize )\n                {\n                    CPLError(CE_Failure, CPLE_NotSupported,\n                             \"Overflow with tag %d\", nTag);\n                    CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n                    VSIUnlink(osTmpFilename);\n                    return false;\n                }\n                if( static_cast<vsi_l_offset>(nTmp + nTagSize) > nMaxOffset )\n                    nMaxOffset = nTmp + nTagSize;\n            }\n        }\n    }\n    else\n    {\n        GUInt32 nTmp = 0;\n        memcpy(&nTmp, pabyBuffer + 4, 4);\n        if( bSwap ) CPL_SWAP32PTR(&nTmp);\n        if( nTmp != 8 )\n        {\n            CPLError(CE_Failure, CPLE_NotSupported,\n                     \"IFD start should be at offset 8 for a streamed TIFF\");\n            CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n            VSIUnlink(osTmpFilename);\n            return false;\n        }\n        GUInt16 nTmp16 = 0;\n        memcpy(&nTmp16, pabyBuffer + 8, 2);\n        if( bSwap ) CPL_SWAP16PTR(&nTmp16);\n        if( nTmp16 > 1024 )\n        {\n            CPLError(CE_Failure, CPLE_NotSupported,\n                     \"Too many tags : %d\", nTmp16);\n            CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n            VSIUnlink(osTmpFilename);\n            return false;\n        }\n        const int nTags = nTmp16;\n        const int nSpaceForTags = nTags * 12;\n        if( !GTIFFExtendMemoryFile(osTmpFilename, fpTemp, poOpenInfo->fpL,\n                                   10 + nSpaceForTags,\n                                   pabyBuffer, nDataLength) )\n        {\n            CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n            VSIUnlink(osTmpFilename);\n            return false;\n        }\n        nMaxOffset = 10 + nSpaceForTags + 4;\n        for( int i = 0; i < nTags; ++i )\n        {\n            memcpy(&nTmp16, pabyBuffer + 10 + i * 12, 2);\n            if( bSwap ) CPL_SWAP16PTR(&nTmp16);\n            const int nTag = nTmp16;\n            memcpy(&nTmp16, pabyBuffer + 10 + i * 12 + 2, 2);\n            if( bSwap ) CPL_SWAP16PTR(&nTmp16);\n            const int nDataType = nTmp16;\n            memcpy(&nTmp, pabyBuffer + 10 + i * 12 + 4, 4);\n            if( bSwap ) CPL_SWAP32PTR(&nTmp);\n            if( nTmp >= 16 * 1024 * 1024 )\n            {\n                CPLError(CE_Failure, CPLE_NotSupported,\n                         \"Too many elements for tag %d : %u\", nTag, nTmp);\n                CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n                VSIUnlink(osTmpFilename);\n                return false;\n            }\n            const GUInt32 nCount = nTmp;\n            const GUInt32 nTagSize =\n                TIFFDataWidth(static_cast<TIFFDataType>(nDataType)) * nCount;\n            if( nTagSize > 4 )\n            {\n                memcpy(&nTmp, pabyBuffer + 10 + i * 12 + 8, 4);\n                if( bSwap ) CPL_SWAP32PTR(&nTmp);\n                if( nTmp > static_cast<GUInt32>(UINT_MAX - nTagSize) )\n                {\n                    CPLError(CE_Failure, CPLE_NotSupported,\n                             \"Overflow with tag %d\", nTag);\n                    CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n                    VSIUnlink(osTmpFilename);\n                    return false;\n                }\n                if( nTmp + nTagSize > nMaxOffset )\n                    nMaxOffset = nTmp + nTagSize;\n            }\n        }\n    }\n    if( nMaxOffset > 10 * 1024 * 1024 )\n    {\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n        VSIUnlink(osTmpFilename);\n        return false;\n    }\n    if( !GTIFFExtendMemoryFile(\n           osTmpFilename, fpTemp, poOpenInfo->fpL,\n           static_cast<int>(nMaxOffset), pabyBuffer, nDataLength) )\n    {\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fpTemp));\n        VSIUnlink(osTmpFilename);\n        return false;\n    }\n    CPLAssert(nDataLength == VSIFTellL(poOpenInfo->fpL));\n    poOpenInfo->fpL = reinterpret_cast<VSILFILE *>(\n        VSICreateBufferedReaderHandle(\n            reinterpret_cast<VSIVirtualHandle*>(poOpenInfo->fpL),\n            pabyBuffer,\n            static_cast<vsi_l_offset>(INT_MAX) << 32 ) );\n    if( VSIFCloseL(fpTemp) != 0 )\n        return false;\n    VSIUnlink(osTmpFilename);\n\n    return true;\n}\n\n/************************************************************************/\n/*                       AssociateExternalMask()                        */\n/************************************************************************/\n\n// Used by GTIFFBuildOverviewsEx() for the COG driver\nbool GTiffDataset::AssociateExternalMask()\n{\n    if( m_poMaskExtOvrDS->GetRasterBand(1)->GetOverviewCount() !=\n        GetRasterBand(1)->GetOverviewCount() )\n        return false;\n    if( m_papoOverviewDS == nullptr )\n        return false;\n    if( m_poMaskDS )\n        return false;\n    if( m_poMaskExtOvrDS->GetRasterXSize() != nRasterXSize ||\n        m_poMaskExtOvrDS->GetRasterYSize() != nRasterYSize )\n        return false;\n    m_poExternalMaskDS = m_poMaskExtOvrDS.get();\n    for(int i = 0; i < m_nOverviewCount; i++ )\n    {\n        if( m_papoOverviewDS[i]->m_poMaskDS )\n            return false;\n        m_papoOverviewDS[i]->m_poExternalMaskDS =\n            m_poMaskExtOvrDS->GetRasterBand(1)->GetOverview(i)->GetDataset();\n        if( !m_papoOverviewDS[i]->m_poExternalMaskDS)\n            return false;\n        auto poOvrBand = m_papoOverviewDS[i]->GetRasterBand(1);\n        if( m_papoOverviewDS[i]->m_poExternalMaskDS->GetRasterXSize() !=\n                poOvrBand->GetXSize() ||\n            m_papoOverviewDS[i]->m_poExternalMaskDS->GetRasterYSize() !=\n                poOvrBand->GetYSize() )\n            return false;\n    }\n    return true;\n}\n\n/************************************************************************/\n/*                                Open()                                */\n/************************************************************************/\n\nGDALDataset *GTiffDataset::Open( GDALOpenInfo * poOpenInfo )\n\n{\n    const char *pszFilename = poOpenInfo->pszFilename;\n\n/* -------------------------------------------------------------------- */\n/*      Check if it looks like a TIFF file.                             */\n/* -------------------------------------------------------------------- */\n    if( !Identify(poOpenInfo) )\n        return nullptr;\n\n    bool bAllowRGBAInterface = true;\n    if( STARTS_WITH_CI(pszFilename, \"GTIFF_RAW:\") )\n    {\n        bAllowRGBAInterface = false;\n        pszFilename += strlen(\"GTIFF_RAW:\");\n    }\n\n/* -------------------------------------------------------------------- */\n/*      We have a special hook for handling opening a specific          */\n/*      directory of a TIFF file.                                       */\n/* -------------------------------------------------------------------- */\n    if( STARTS_WITH_CI(pszFilename, \"GTIFF_DIR:\") )\n        return OpenDir( poOpenInfo );\n\n    if( !GTiffOneTimeInit() )\n        return nullptr;\n\n/* -------------------------------------------------------------------- */\n/*      Try opening the dataset.                                        */\n/* -------------------------------------------------------------------- */\n    // Disable strip chop for now.\n    bool bStreaming = false;\n    const char* pszReadStreaming =\n        CPLGetConfigOption(\"TIFF_READ_STREAMING\", nullptr);\n    if( poOpenInfo->fpL == nullptr )\n    {\n        poOpenInfo->fpL =\n            VSIFOpenL( pszFilename,\n                       poOpenInfo->eAccess == GA_ReadOnly ? \"rb\" : \"r+b\" );\n        if( poOpenInfo->fpL == nullptr )\n            return nullptr;\n    }\n    else if( !(pszReadStreaming && !CPLTestBool(pszReadStreaming)) &&\n             poOpenInfo->nHeaderBytes >= 24 &&\n             // A pipe has no seeking capability, so its position is 0 despite\n             // having read bytes.\n             (static_cast<int>( VSIFTellL(poOpenInfo->fpL) ) ==\n              poOpenInfo->nHeaderBytes ||\n              strcmp(pszFilename, \"/vsistdin/\") == 0 ||\n              // STARTS_WITH(pszFilename, \"/vsicurl_streaming/\") ||\n              (pszReadStreaming && CPLTestBool(pszReadStreaming))) )\n    {\n        bStreaming = true;\n        if( !GTIFFMakeBufferedStream(poOpenInfo) )\n            return nullptr;\n    }\n\n    // Store errors/warnings and emit them later.\n    std::vector<CPLErrorHandlerAccumulatorStruct> aoErrors;\n    CPLInstallErrorHandlerAccumulator(aoErrors);\n    CPLSetCurrentErrorHandlerCatchDebug( FALSE );\n    const bool bDeferStrileLoading = CPLTestBool(\n        CPLGetConfigOption(\"GTIFF_USE_DEFER_STRILE_LOADING\", \"YES\"));\n    TIFF *l_hTIFF =\n        VSI_TIFFOpen( pszFilename,\n                      poOpenInfo->eAccess == GA_ReadOnly ?\n                        ((bStreaming || !bDeferStrileLoading) ? \"r\" : \"rDO\") :\n                        (!bDeferStrileLoading ? \"r+\" : \"r+D\"),\n                      poOpenInfo->fpL );\n    CPLUninstallErrorHandlerAccumulator();\n\n    // Now emit errors and change their criticality if needed\n    // We only emit failures if we didn't manage to open the file.\n    // Otherwise it makes Python bindings unhappy (#5616).\n    for( size_t iError = 0; iError < aoErrors.size(); ++iError )\n    {\n        ReportError( pszFilename,\n                  (l_hTIFF == nullptr && aoErrors[iError].type == CE_Failure) ?\n                  CE_Failure : CE_Warning,\n                  aoErrors[iError].no,\n                  \"%s\",\n                  aoErrors[iError].msg.c_str() );\n    }\n    aoErrors.resize(0);\n\n    if( l_hTIFF == nullptr )\n        return nullptr;\n\n    uint32 nXSize = 0;\n    TIFFGetField( l_hTIFF, TIFFTAG_IMAGEWIDTH, &nXSize );\n    uint32 nYSize = 0;\n    TIFFGetField( l_hTIFF, TIFFTAG_IMAGELENGTH, &nYSize );\n\n    if( nXSize > INT_MAX || nYSize > INT_MAX )\n    {\n        // GDAL only supports signed 32bit dimensions.\n        ReportError(pszFilename, CE_Failure, CPLE_NotSupported,\n                    \"Too large image size: %u x %u\",\n                    nXSize, nYSize);\n        XTIFFClose( l_hTIFF );\n        return nullptr;\n    }\n\n    uint16 l_nCompression = 0;\n    if( !TIFFGetField( l_hTIFF, TIFFTAG_COMPRESSION, &(l_nCompression) ) )\n        l_nCompression = COMPRESSION_NONE;\n\n/* -------------------------------------------------------------------- */\n/*      Create a corresponding GDALDataset.                             */\n/* -------------------------------------------------------------------- */\n    GTiffDataset *poDS = new GTiffDataset();\n    poDS->SetDescription( pszFilename );\n    poDS->m_pszFilename = CPLStrdup(pszFilename);\n    poDS->m_fpL = poOpenInfo->fpL;\n    poOpenInfo->fpL = nullptr;\n    poDS->m_bStreamingIn = bStreaming;\n    poDS->m_nCompression = l_nCompression;\n\n    // Check structural metadata (for COG)\n    const int nOffsetOfStructuralMetadata =\n        poOpenInfo->nHeaderBytes &&\n        ((poOpenInfo->pabyHeader[2] == 0x2B ||\n         poOpenInfo->pabyHeader[3] == 0x2B )) ? 16 : 8;\n    if( poOpenInfo->nHeaderBytes > nOffsetOfStructuralMetadata +\n            static_cast<int>(strlen(\"GDAL_STRUCTURAL_METADATA_SIZE=\")) &&\n        memcmp(poOpenInfo->pabyHeader + nOffsetOfStructuralMetadata,\n               \"GDAL_STRUCTURAL_METADATA_SIZE=\",\n               strlen(\"GDAL_STRUCTURAL_METADATA_SIZE=\")) == 0 )\n    {\n        const char* pszStructuralMD = reinterpret_cast<const char*>(\n            poOpenInfo->pabyHeader + nOffsetOfStructuralMetadata);\n        poDS->m_bLayoutIFDSBeforeData = strstr(pszStructuralMD,\n                            \"LAYOUT=IFDS_BEFORE_DATA\") != nullptr;\n        poDS->m_bBlockOrderRowMajor = strstr(pszStructuralMD,\n                            \"BLOCK_ORDER=ROW_MAJOR\") != nullptr;\n        poDS->m_bLeaderSizeAsUInt4 = strstr(pszStructuralMD,\n                            \"BLOCK_LEADER=SIZE_AS_UINT4\") != nullptr;\n        poDS->m_bTrailerRepeatedLast4BytesRepeated = strstr(pszStructuralMD,\n                            \"BLOCK_TRAILER=LAST_4_BYTES_REPEATED\") != nullptr;\n        poDS->m_bMaskInterleavedWithImagery = strstr(pszStructuralMD,\n                            \"MASK_INTERLEAVED_WITH_IMAGERY=YES\") != nullptr;\n        poDS->m_bKnownIncompatibleEdition = strstr(pszStructuralMD,\n                            \"KNOWN_INCOMPATIBLE_EDITION=YES\") != nullptr;\n        if( poDS->m_bKnownIncompatibleEdition )\n        {\n            poDS->ReportError(CE_Warning, CPLE_AppDefined,\n                     \"This file used to have optimizations in its layout, \"\n                     \"but those have been, at least partly, invalidated by \"\n                     \"later changes\");\n        }\n        else if( poDS->m_bLayoutIFDSBeforeData &&\n                 poDS->m_bBlockOrderRowMajor &&\n                 poDS->m_bLeaderSizeAsUInt4 &&\n                 poDS->m_bTrailerRepeatedLast4BytesRepeated )\n        {\n            poDS->m_oGTiffMDMD.SetMetadataItem(\"LAYOUT\", \"COG\", \"IMAGE_STRUCTURE\");\n        }\n    }\n\n    // In the case of GDAL_DISABLE_READDIR_ON_OPEN = NO / EMPTY_DIR\n    if( poOpenInfo->AreSiblingFilesLoaded() &&\n        CSLCount( poOpenInfo->GetSiblingFiles() ) <= 1 )\n    {\n        poDS->oOvManager.TransferSiblingFiles( CSLDuplicate(\n                                            poOpenInfo->GetSiblingFiles() ) );\n        poDS->m_bHasGotSiblingFiles = true;\n    }\n\n    if( poDS->OpenOffset( l_hTIFF,\n                          TIFFCurrentDirOffset(l_hTIFF),\n                          poOpenInfo->eAccess,\n                          bAllowRGBAInterface, true) != CE_None )\n    {\n        delete poDS;\n        return nullptr;\n    }\n\n    // Do we want blocks that are set to zero and that haven't yet being\n    // allocated as tile/strip to remain implicit?\n    if( CPLFetchBool( poOpenInfo->papszOpenOptions, \"SPARSE_OK\", false ) )\n        poDS->m_bWriteEmptyTiles = false;\n\n    if( poOpenInfo->eAccess == GA_Update )\n    {\n        poDS->InitCreationOrOpenOptions(poOpenInfo->papszOpenOptions);\n    }\n\n    poDS->m_bLoadPam = true;\n    poDS->m_bColorProfileMetadataChanged = false;\n    poDS->m_bMetadataChanged = false;\n    poDS->m_bGeoTIFFInfoChanged = false;\n    poDS->m_bNoDataChanged = false;\n    poDS->m_bForceUnsetGTOrGCPs = false;\n    poDS->m_bForceUnsetProjection = false;\n\n    // Used by GTIFFBuildOverviewsEx() for the COG driver\n    const char* pszMaskOverviewDS = CSLFetchNameValue(poOpenInfo->papszOpenOptions,\n                                                      \"MASK_OVERVIEW_DATASET\");\n    if( pszMaskOverviewDS )\n    {\n        poDS->m_poMaskExtOvrDS.reset(GDALDataset::Open(pszMaskOverviewDS,\n                                            GDAL_OF_RASTER | GDAL_OF_INTERNAL));\n        if( !poDS->m_poMaskExtOvrDS || !poDS->AssociateExternalMask() )\n        {\n            CPLDebug(\"GTiff\",\n                     \"Association with external mask overview file failed\");\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Initialize info for external overviews.                         */\n/* -------------------------------------------------------------------- */\n    poDS->oOvManager.Initialize( poDS, pszFilename );\n    if( poOpenInfo->AreSiblingFilesLoaded() )\n        poDS->oOvManager.TransferSiblingFiles(\n            poOpenInfo->StealSiblingFiles() );\n\n    // For backward compatibility, in case GTIFF_POINT_GEO_IGNORE is defined\n    // load georeferencing right now so as to not require it to be defined\n    // at the GetGeoTransform() time.\n    if( CPLGetConfigOption(\"GTIFF_POINT_GEO_IGNORE\", nullptr) != nullptr )\n    {\n        poDS->LoadGeoreferencingAndPamIfNeeded();\n    }\n\n    return poDS;\n}\n\n/************************************************************************/\n/*                      GTiffDatasetSetAreaOrPointMD()                  */\n/************************************************************************/\n\nstatic void GTiffDatasetSetAreaOrPointMD( GTIF* hGTIF,\n                                          GDALMultiDomainMetadata& m_oGTiffMDMD )\n{\n    // Is this a pixel-is-point dataset?\n    unsigned short nRasterType = 0;\n\n    if( GDALGTIFKeyGetSHORT(hGTIF, GTRasterTypeGeoKey, &nRasterType,\n                    0, 1 ) == 1 )\n    {\n        if( nRasterType == static_cast<short>(RasterPixelIsPoint) )\n            m_oGTiffMDMD.SetMetadataItem(GDALMD_AREA_OR_POINT, GDALMD_AOP_POINT);\n        else\n            m_oGTiffMDMD.SetMetadataItem(GDALMD_AREA_OR_POINT, GDALMD_AOP_AREA);\n    }\n}\n\n/************************************************************************/\n/*                         LoadMDAreaOrPoint()                          */\n/************************************************************************/\n\n// This is a light version of LookForProjection(), which saves the\n// potential costly cost of GTIFGetOGISDefn(), since we just need to\n// access to a raw GeoTIFF key, and not build the full projection object.\n\nvoid GTiffDataset::LoadMDAreaOrPoint()\n{\n    if( m_bLookedForProjection || m_bLookedForMDAreaOrPoint ||\n        m_oGTiffMDMD.GetMetadataItem( GDALMD_AREA_OR_POINT ) != nullptr )\n        return;\n\n    m_bLookedForMDAreaOrPoint = true;\n\n    GTIF* hGTIF = GTiffDatasetGTIFNew(m_hTIFF);\n\n    if( !hGTIF )\n    {\n        ReportError( CE_Warning, CPLE_AppDefined,\n                  \"GeoTIFF tags apparently corrupt, they are being ignored.\" );\n    }\n    else\n    {\n        GTiffDatasetSetAreaOrPointMD( hGTIF, m_oGTiffMDMD );\n\n        GTIFFree( hGTIF );\n    }\n}\n\n/************************************************************************/\n/*                         LookForProjection()                          */\n/************************************************************************/\n\nvoid GTiffDataset::LookForProjection()\n\n{\n    if( m_bLookedForProjection )\n        return;\n\n    m_bLookedForProjection = true;\n\n    IdentifyAuthorizedGeoreferencingSources();\n    if( m_nINTERNALGeorefSrcIndex < 0 )\n        return;\n\n/* -------------------------------------------------------------------- */\n/*      Capture the GeoTIFF projection, if available.                   */\n/* -------------------------------------------------------------------- */\n    m_oSRS.Clear();\n\n    GTIF *hGTIF = GTiffDatasetGTIFNew(m_hTIFF);\n\n    if( !hGTIF )\n    {\n        ReportError( CE_Warning, CPLE_AppDefined,\n                  \"GeoTIFF tags apparently corrupt, they are being ignored.\" );\n    }\n    else\n    {\n        GTIFDefn *psGTIFDefn = GTIFAllocDefn();\n\n        if( GTIFGetDefn( hGTIF, psGTIFDefn ) )\n        {\n            OGRSpatialReferenceH hSRS = GTIFGetOGISDefnAsOSR( hGTIF, psGTIFDefn );\n            if( hSRS )\n            {\n                m_oSRS = *(OGRSpatialReference::FromHandle(hSRS));\n                OSRDestroySpatialReference(hSRS);\n            }\n\n            if( m_oSRS.IsCompound() )\n            {\n                const char* pszVertUnit = nullptr;\n                m_oSRS.GetTargetLinearUnits(\"COMPD_CS|VERT_CS\", &pszVertUnit);\n                if( pszVertUnit && !EQUAL(pszVertUnit, \"unknown\") )\n                {\n                    CPLFree(m_pszVertUnit);\n                    m_pszVertUnit = CPLStrdup(pszVertUnit);\n                }\n\n                int versions[3];\n                GTIFDirectoryInfo(hGTIF, versions, nullptr);\n\n                // If GeoTIFF 1.0, strip vertical by default\n                const char* pszDefaultReportCompdCS =\n                    ( versions[0] == 1 && versions[1]== 1 && versions[2] == 0 ) ? \"NO\" : \"YES\";\n\n                // Should we simplify away vertical CS stuff?\n                if( !CPLTestBool( CPLGetConfigOption(\"GTIFF_REPORT_COMPD_CS\", \n                                            pszDefaultReportCompdCS) ) )\n                {\n                    CPLDebug( \"GTiff\", \"Got COMPD_CS, but stripping it.\" );\n\n                    m_oSRS.StripVertical();\n                }\n            }\n        }\n\n        // Check the tif linear unit and the CS linear unit.\n#ifdef ESRI_BUILD\n        AdjustLinearUnit(psGTIFDefn.UOMLength);\n#endif\n\n        GTIFFreeDefn(psGTIFDefn);\n\n        GTiffDatasetSetAreaOrPointMD( hGTIF, m_oGTiffMDMD );\n\n        GTIFFree( hGTIF );\n    }\n\n    m_bGeoTIFFInfoChanged = false;\n    m_bForceUnsetGTOrGCPs = false;\n    m_bForceUnsetProjection = false;\n}\n\n/************************************************************************/\n/*                          AdjustLinearUnit()                          */\n/*                                                                      */\n/*      The following code is only used in ESRI Builds and there is     */\n/*      outstanding discussion on whether it is even appropriate        */\n/*      then.                                                           */\n/************************************************************************/\n#ifdef ESRI_BUILD\n\nvoid GTiffDataset::AdjustLinearUnit( short UOMLength )\n{\n    if( !pszProjection || strlen(pszProjection) == 0 )\n        return;\n    if( UOMLength == 9001 )\n    {\n        char* pstr = strstr(pszProjection, \"PARAMETER\");\n        if( !pstr )\n            return;\n        pstr = strstr(pstr, \"UNIT[\");\n        if( !pstr )\n            return;\n        pstr = strchr(pstr, ',') + 1;\n        if( !pstr )\n            return;\n        char* pstr1 = strchr(pstr, ']');\n        if( !pstr1 || pstr1 - pstr >= 128 )\n            return;\n        char csUnitStr[128];\n        strncpy(csUnitStr, pstr, pstr1 - pstr);\n        csUnitStr[pstr1-pstr] = '\\0';\n        const double csUnit = CPLAtof(csUnitStr);\n        if( fabs(csUnit - 1.0) > 0.000001 )\n        {\n            for( long i = 0; i < 6; ++i )\n                adfGeoTransform[i] /= csUnit;\n        }\n    }\n}\n\n#endif  // def ESRI_BUILD\n\n/************************************************************************/\n/*                            ApplyPamInfo()                            */\n/*                                                                      */\n/*      PAM Information, if available, overrides the GeoTIFF            */\n/*      geotransform and projection definition.  Check for them         */\n/*      now.                                                            */\n/************************************************************************/\n\nvoid GTiffDataset::ApplyPamInfo()\n\n{\n    if( m_nPAMGeorefSrcIndex >= 0 &&\n        ((m_bGeoTransformValid &&\n          m_nPAMGeorefSrcIndex < m_nGeoTransformGeorefSrcIndex) ||\n          m_nGeoTransformGeorefSrcIndex < 0 || !m_bGeoTransformValid) )\n    {\n        double adfPamGeoTransform[6] = { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 };\n        if( GDALPamDataset::GetGeoTransform( adfPamGeoTransform ) == CE_None )\n        {\n            if( m_nGeoTransformGeorefSrcIndex == m_nWORLDFILEGeorefSrcIndex )\n            {\n                CPLFree(m_pszGeorefFilename);\n                m_pszGeorefFilename = nullptr;\n            }\n            memcpy(m_adfGeoTransform, adfPamGeoTransform, sizeof(double) * 6);\n            m_bGeoTransformValid = true;\n        }\n    }\n\n    if( m_nPAMGeorefSrcIndex >= 0 )\n    {\n        if( (m_nTABFILEGeorefSrcIndex < 0 ||\n             m_nPAMGeorefSrcIndex < m_nTABFILEGeorefSrcIndex) &&\n            (m_nINTERNALGeorefSrcIndex < 0 ||\n             m_nPAMGeorefSrcIndex < m_nINTERNALGeorefSrcIndex) )\n        {\n            const auto* poPamSRS = GDALPamDataset::GetSpatialRef();\n            if( poPamSRS )\n            {\n                m_oSRS = *poPamSRS;\n                m_bLookedForProjection = true;\n                // m_nProjectionGeorefSrcIndex = m_nPAMGeorefSrcIndex;\n            }\n        }\n        else\n        {\n            if( m_nINTERNALGeorefSrcIndex >= 0 )\n                LookForProjection();\n            if( m_oSRS.IsEmpty() )\n            {\n                const auto* poPamSRS = GDALPamDataset::GetSpatialRef();\n                if( poPamSRS )\n                {\n                    m_oSRS = *poPamSRS;\n                    m_bLookedForProjection = true;\n                    // m_nProjectionGeorefSrcIndex = m_nPAMGeorefSrcIndex;\n                }\n            }\n        }\n    }\n\n    int nPamGCPCount;\n    if( m_nPAMGeorefSrcIndex >= 0 &&\n        (nPamGCPCount = GDALPamDataset::GetGCPCount()) > 0 &&\n        ( (m_nGCPCount > 0 &&\n           m_nPAMGeorefSrcIndex < m_nGeoTransformGeorefSrcIndex) ||\n          m_nGeoTransformGeorefSrcIndex < 0 || m_nGCPCount == 0 ) )\n    {\n        if( m_nGCPCount > 0 )\n        {\n            GDALDeinitGCPs( m_nGCPCount, m_pasGCPList );\n            CPLFree( m_pasGCPList );\n            m_pasGCPList = nullptr;\n        }\n\n        m_nGCPCount = nPamGCPCount;\n        m_pasGCPList = GDALDuplicateGCPs(m_nGCPCount, GDALPamDataset::GetGCPs());\n\n        // m_nProjectionGeorefSrcIndex = m_nPAMGeorefSrcIndex;\n\n        const auto* poPamGCPSRS = GDALPamDataset::GetGCPSpatialRef();\n        if( poPamGCPSRS )\n            m_oSRS = *poPamGCPSRS;\n        else\n            m_oSRS.Clear();\n\n        m_bLookedForProjection = true;\n    }\n\n    if( m_nPAMGeorefSrcIndex >= 0 )\n    {\n        CPLXMLNode *psValueAsXML = nullptr;\n        CPLXMLNode *psGeodataXform = nullptr;\n        char** papszXML = oMDMD.GetMetadata( \"xml:ESRI\" );\n        if (CSLCount(papszXML) == 1)\n        {\n            psValueAsXML = CPLParseXMLString( papszXML[0] );\n            if( psValueAsXML )\n                psGeodataXform = CPLGetXMLNode(psValueAsXML, \"=GeodataXform\");\n        }\n\n        const char* pszTIFFTagResUnit = GetMetadataItem(\"TIFFTAG_RESOLUTIONUNIT\");\n        const char* pszTIFFTagXRes = GetMetadataItem(\"TIFFTAG_XRESOLUTION\");\n        const char* pszTIFFTagYRes = GetMetadataItem(\"TIFFTAG_YRESOLUTION\");\n        if (psGeodataXform && pszTIFFTagResUnit &&pszTIFFTagXRes &&\n            pszTIFFTagYRes && atoi(pszTIFFTagResUnit) == 2 )\n        {\n            CPLXMLNode* psSourceGCPs = CPLGetXMLNode(psGeodataXform,\n                                                        \"SourceGCPs\");\n            CPLXMLNode* psTargetGCPs = CPLGetXMLNode(psGeodataXform,\n                                                        \"TargetGCPs\");\n            if( psSourceGCPs && psTargetGCPs )\n            {\n                std::vector<double> adfSourceGCPs, adfTargetGCPs;\n                for( CPLXMLNode* psIter = psSourceGCPs->psChild;\n                                    psIter != nullptr;\n                                    psIter = psIter->psNext )\n                {\n                    if( psIter->eType == CXT_Element &&\n                        EQUAL(psIter->pszValue, \"Double\") )\n                    {\n                        adfSourceGCPs.push_back(\n                            CPLAtof( CPLGetXMLValue(psIter, nullptr, \"\") ) );\n                    }\n                }\n                for( CPLXMLNode* psIter = psTargetGCPs->psChild;\n                                    psIter != nullptr;\n                                    psIter = psIter->psNext )\n                {\n                    if( psIter->eType == CXT_Element &&\n                        EQUAL(psIter->pszValue, \"Double\") )\n                    {\n                        adfTargetGCPs.push_back(\n                            CPLAtof( CPLGetXMLValue(psIter, nullptr, \"\") ) );\n                    }\n                }\n                if( adfSourceGCPs.size() == adfTargetGCPs.size() &&\n                    (adfSourceGCPs.size() % 2) == 0 )\n                {\n                    if( m_nGCPCount > 0 )\n                    {\n                        GDALDeinitGCPs( m_nGCPCount, m_pasGCPList );\n                        CPLFree( m_pasGCPList );\n                        m_pasGCPList = nullptr;\n                        m_nGCPCount = 0;\n                    }\n                    m_nGCPCount = static_cast<int>(\n                                            adfSourceGCPs.size() / 2);\n                    m_pasGCPList = static_cast<GDAL_GCP *>(\n                            CPLCalloc(sizeof(GDAL_GCP), m_nGCPCount) );\n                    for( int i = 0; i < m_nGCPCount; ++i )\n                    {\n                        m_pasGCPList[i].pszId = CPLStrdup(\"\");\n                        m_pasGCPList[i].pszInfo = CPLStrdup(\"\");\n                        // The origin used is the bottom left corner,\n                        // and raw values are in inches!\n                        m_pasGCPList[i].dfGCPPixel = adfSourceGCPs[2*i] *\n                                                        CPLAtof(pszTIFFTagXRes);\n                        m_pasGCPList[i].dfGCPLine = nRasterYSize -\n                                adfSourceGCPs[2*i+1] * CPLAtof(pszTIFFTagYRes);\n                        m_pasGCPList[i].dfGCPX = adfTargetGCPs[2*i];\n                        m_pasGCPList[i].dfGCPY = adfTargetGCPs[2*i+1];\n                    }\n                }\n            }\n        }\n        if( psValueAsXML )\n            CPLDestroyXMLNode(psValueAsXML);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Copy any PAM metadata into our GeoTIFF context, and with        */\n/*      the PAM info overriding the GeoTIFF context.                    */\n/* -------------------------------------------------------------------- */\n    char **papszPamDomains = oMDMD.GetDomainList();\n\n    for( int iDomain = 0;\n         papszPamDomains && papszPamDomains[iDomain] != nullptr;\n         ++iDomain )\n    {\n        const char *pszDomain = papszPamDomains[iDomain];\n        char **papszGT_MD = CSLDuplicate(m_oGTiffMDMD.GetMetadata( pszDomain ));\n        char **papszPAM_MD = oMDMD.GetMetadata( pszDomain );\n\n        papszGT_MD = CSLMerge( papszGT_MD, papszPAM_MD );\n\n        m_oGTiffMDMD.SetMetadata( papszGT_MD, pszDomain );\n        CSLDestroy( papszGT_MD );\n    }\n\n    for( int i = 1; i <= GetRasterCount(); ++i )\n    {\n        GTiffRasterBand* poBand =\n            cpl::down_cast<GTiffRasterBand *>(GetRasterBand(i));\n        papszPamDomains = poBand->oMDMD.GetDomainList();\n\n        for( int iDomain = 0;\n             papszPamDomains && papszPamDomains[iDomain] != nullptr;\n             ++iDomain )\n        {\n            const char *pszDomain = papszPamDomains[iDomain];\n            char **papszGT_MD =\n                CSLDuplicate(poBand->m_oGTiffMDMD.GetMetadata( pszDomain ));\n            char **papszPAM_MD = poBand->oMDMD.GetMetadata( pszDomain );\n\n            papszGT_MD = CSLMerge( papszGT_MD, papszPAM_MD );\n\n            poBand->m_oGTiffMDMD.SetMetadata( papszGT_MD, pszDomain );\n            CSLDestroy( papszGT_MD );\n        }\n    }\n}\n\n/************************************************************************/\n/*                              OpenDir()                               */\n/*                                                                      */\n/*      Open a specific directory as encoded into a filename.           */\n/************************************************************************/\n\nGDALDataset *GTiffDataset::OpenDir( GDALOpenInfo * poOpenInfo )\n\n{\n    bool bAllowRGBAInterface = true;\n    const char* pszFilename = poOpenInfo->pszFilename;\n    if( STARTS_WITH_CI(pszFilename, \"GTIFF_RAW:\") )\n    {\n        bAllowRGBAInterface = false;\n        pszFilename += strlen(\"GTIFF_RAW:\");\n    }\n\n    if( !STARTS_WITH_CI(pszFilename, \"GTIFF_DIR:\") ||\n        pszFilename[strlen(\"GTIFF_DIR:\")] == '\\0' )\n    {\n        return nullptr;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Split out filename, and dir#/offset.                            */\n/* -------------------------------------------------------------------- */\n    pszFilename += strlen(\"GTIFF_DIR:\");\n    bool bAbsolute = false;\n\n    if( STARTS_WITH_CI(pszFilename, \"off:\") )\n    {\n        bAbsolute = true;\n        pszFilename += 4;\n    }\n\n    toff_t nOffset = atol(pszFilename);\n    pszFilename += 1;\n\n    while( *pszFilename != '\\0' && pszFilename[-1] != ':' )\n        ++pszFilename;\n\n    if( *pszFilename == '\\0' || nOffset == 0 )\n    {\n        ReportError(pszFilename, CE_Failure, CPLE_OpenFailed,\n            \"Unable to extract offset or filename, should take the form:\\n\"\n            \"GTIFF_DIR:<dir>:filename or GTIFF_DIR:off:<dir_offset>:filename\" );\n        return nullptr;\n    }\n\n    if( poOpenInfo->eAccess == GA_Update )\n    {\n        ReportError(\n            pszFilename, CE_Warning, CPLE_AppDefined,\n            \"Opening a specific TIFF directory is not supported in \"\n            \"update mode. Switching to read-only\" );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Try opening the dataset.                                        */\n/* -------------------------------------------------------------------- */\n    if( !GTiffOneTimeInit() )\n        return nullptr;\n\n    const char* pszFlag = poOpenInfo->eAccess == GA_Update ? \"r+D\" : \"rDO\";\n    VSILFILE* l_fpL = VSIFOpenL(pszFilename, pszFlag);\n    if( l_fpL == nullptr )\n        return nullptr;\n    TIFF *l_hTIFF = VSI_TIFFOpen( pszFilename, pszFlag, l_fpL );\n    if( l_hTIFF == nullptr )\n    {\n        CPL_IGNORE_RET_VAL(VSIFCloseL(l_fpL));\n        return nullptr;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If a directory was requested by index, advance to it now.       */\n/* -------------------------------------------------------------------- */\n    if( !bAbsolute )\n    {\n        const toff_t nOffsetRequested = nOffset;\n        while( nOffset > 1 )\n        {\n            if( TIFFReadDirectory( l_hTIFF ) == 0 )\n            {\n                XTIFFClose( l_hTIFF );\n                ReportError(\n                    pszFilename, CE_Failure, CPLE_OpenFailed,\n                    \"Requested directory %lu not found.\",\n                    static_cast<long unsigned int>(nOffsetRequested));\n                CPL_IGNORE_RET_VAL(VSIFCloseL(l_fpL));\n                return nullptr;\n            }\n            nOffset--;\n        }\n\n        nOffset = TIFFCurrentDirOffset( l_hTIFF );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Create a corresponding GDALDataset.                             */\n/* -------------------------------------------------------------------- */\n    GTiffDataset *poDS = new GTiffDataset();\n    poDS->SetDescription( poOpenInfo->pszFilename );\n    poDS->m_pszFilename = CPLStrdup(pszFilename);\n    poDS->m_fpL = l_fpL;\n    poDS->m_hTIFF = l_hTIFF;\n    poDS->m_bSingleIFDOpened = true;\n\n    if( !EQUAL(pszFilename,poOpenInfo->pszFilename)\n        && !STARTS_WITH_CI(poOpenInfo->pszFilename, \"GTIFF_RAW:\") )\n    {\n        poDS->SetPhysicalFilename( pszFilename );\n        poDS->SetSubdatasetName( poOpenInfo->pszFilename );\n    }\n\n    if( poOpenInfo->AreSiblingFilesLoaded() )\n        poDS->oOvManager.TransferSiblingFiles(\n            poOpenInfo->StealSiblingFiles() );\n\n    if( poDS->OpenOffset( l_hTIFF,\n                          nOffset, poOpenInfo->eAccess,\n                          bAllowRGBAInterface, true ) != CE_None )\n    {\n        delete poDS;\n        return nullptr;\n    }\n\n    return poDS;\n}\n\n/************************************************************************/\n/*                   ConvertTransferFunctionToString()                  */\n/*                                                                      */\n/*      Convert a transfer function table into a string.                */\n/*      Used by LoadICCProfile().                                       */\n/************************************************************************/\nstatic CPLString ConvertTransferFunctionToString( const uint16 *pTable,\n                                                  uint32 nTableEntries )\n{\n    CPLString sValue;\n\n    for( uint32 i = 0; i < nTableEntries; ++i )\n    {\n        if( i == 0 )\n            sValue = sValue.Printf(\"%d\", static_cast<uint32>(pTable[i]));\n        else\n            sValue = sValue.Printf( \"%s, %d\",\n                                    sValue.c_str(),\n                                    static_cast<uint32>(pTable[i]));\n    }\n\n    return sValue;\n}\n\n/************************************************************************/\n/*                             LoadICCProfile()                         */\n/*                                                                      */\n/*      Load ICC Profile or colorimetric data into metadata             */\n/************************************************************************/\n\nvoid GTiffDataset::LoadICCProfile()\n{\n    if( m_bICCMetadataLoaded )\n        return;\n    m_bICCMetadataLoaded = true;\n\n    uint32 nEmbedLen = 0;\n    uint8* pEmbedBuffer = nullptr;\n\n\n    if( TIFFGetField(m_hTIFF, TIFFTAG_ICCPROFILE, &nEmbedLen, &pEmbedBuffer) )\n    {\n        char *pszBase64Profile =\n            CPLBase64Encode(nEmbedLen, reinterpret_cast<const GByte*>(pEmbedBuffer));\n\n        m_oGTiffMDMD.SetMetadataItem( \"SOURCE_ICC_PROFILE\", pszBase64Profile,\n                                    \"COLOR_PROFILE\" );\n\n        CPLFree(pszBase64Profile);\n\n        return;\n    }\n\n    // Check for colorimetric tiff.\n    float* pCHR = nullptr;\n    float* pWP = nullptr;\n    uint16 *pTFR = nullptr;\n    uint16 *pTFG = nullptr;\n    uint16 *pTFB = nullptr;\n    uint16 *pTransferRange = nullptr;\n\n    if( TIFFGetField(m_hTIFF, TIFFTAG_PRIMARYCHROMATICITIES, &pCHR) )\n    {\n        if( TIFFGetField(m_hTIFF, TIFFTAG_WHITEPOINT, &pWP) )\n        {\n            if( !TIFFGetFieldDefaulted( m_hTIFF, TIFFTAG_TRANSFERFUNCTION, &pTFR,\n                                        &pTFG, &pTFB) ||\n                pTFR == nullptr || pTFG == nullptr || pTFB == nullptr )\n            {\n                return;\n            }\n\n            const int TIFFTAG_TRANSFERRANGE = 0x0156;\n            TIFFGetFieldDefaulted( m_hTIFF, TIFFTAG_TRANSFERRANGE,\n                                   &pTransferRange);\n\n            // Set all the colorimetric metadata.\n            m_oGTiffMDMD.SetMetadataItem(\n                \"SOURCE_PRIMARIES_RED\",\n                CPLString().Printf( \"%.9f, %.9f, 1.0\",\n                                    static_cast<double>(pCHR[0]),\n                                    static_cast<double>(pCHR[1]) ),\n                \"COLOR_PROFILE\" );\n            m_oGTiffMDMD.SetMetadataItem(\n                \"SOURCE_PRIMARIES_GREEN\",\n                CPLString().Printf( \"%.9f, %.9f, 1.0\",\n                                    static_cast<double>(pCHR[2]),\n                                    static_cast<double>(pCHR[3]) ),\n                \"COLOR_PROFILE\" );\n            m_oGTiffMDMD.SetMetadataItem(\n                \"SOURCE_PRIMARIES_BLUE\",\n                CPLString().Printf( \"%.9f, %.9f, 1.0\",\n                                    static_cast<double>(pCHR[4]),\n                                    static_cast<double>(pCHR[5]) ),\n                \"COLOR_PROFILE\" );\n\n            m_oGTiffMDMD.SetMetadataItem(\n                \"SOURCE_WHITEPOINT\",\n                CPLString().Printf( \"%.9f, %.9f, 1.0\",\n                                    static_cast<double>(pWP[0]),\n                                    static_cast<double>(pWP[1]) ),\n                \"COLOR_PROFILE\" );\n\n            // Set transfer function metadata.\n\n            // Get length of table.\n            const uint32 nTransferFunctionLength = 1 << m_nBitsPerSample;\n\n            m_oGTiffMDMD.SetMetadataItem(\n                \"TIFFTAG_TRANSFERFUNCTION_RED\",\n                ConvertTransferFunctionToString( pTFR, nTransferFunctionLength),\n                \"COLOR_PROFILE\" );\n\n            m_oGTiffMDMD.SetMetadataItem(\n                \"TIFFTAG_TRANSFERFUNCTION_GREEN\",\n                ConvertTransferFunctionToString( pTFG, nTransferFunctionLength),\n                \"COLOR_PROFILE\" );\n\n            m_oGTiffMDMD.SetMetadataItem(\n                \"TIFFTAG_TRANSFERFUNCTION_BLUE\",\n                ConvertTransferFunctionToString( pTFB, nTransferFunctionLength),\n                \"COLOR_PROFILE\" );\n\n            // Set transfer range.\n            if( pTransferRange )\n            {\n                m_oGTiffMDMD.SetMetadataItem(\n                    \"TIFFTAG_TRANSFERRANGE_BLACK\",\n                    CPLString().Printf( \"%d, %d, %d\",\n                                        static_cast<int>(pTransferRange[0]),\n                                        static_cast<int>(pTransferRange[2]),\n                                        static_cast<int>(pTransferRange[4])),\n                    \"COLOR_PROFILE\" );\n                m_oGTiffMDMD.SetMetadataItem(\n                    \"TIFFTAG_TRANSFERRANGE_WHITE\",\n                    CPLString().Printf( \"%d, %d, %d\",\n                                        static_cast<int>(pTransferRange[1]),\n                                        static_cast<int>(pTransferRange[3]),\n                                        static_cast<int>(pTransferRange[5])),\n                    \"COLOR_PROFILE\" );\n            }\n        }\n    }\n}\n\n/************************************************************************/\n/*                             SaveICCProfile()                         */\n/*                                                                      */\n/*      Save ICC Profile or colorimetric data into file                 */\n/* pDS:                                                                 */\n/*      Dataset that contains the metadata with the ICC or colorimetric */\n/*      data. If this argument is specified, all other arguments are    */\n/*      ignored. Set them to NULL or 0.                                 */\n/* hTIFF:                                                               */\n/*      Pointer to TIFF handle. Only needed if pDS is NULL or           */\n/*      pDS->m_hTIFF is NULL.                                             */\n/* papszParmList:                                                       */\n/*      Options containing the ICC profile or colorimetric metadata.    */\n/*      Ignored if pDS is not NULL.                                     */\n/* nBitsPerSample:                                                      */\n/*      Bits per sample. Ignored if pDS is not NULL.                    */\n/************************************************************************/\n\nvoid GTiffDataset::SaveICCProfile( GTiffDataset *pDS, TIFF *l_hTIFF,\n                                   char **papszParmList,\n                                   uint32 l_nBitsPerSample )\n{\n    if( (pDS != nullptr) && (pDS->eAccess != GA_Update) )\n        return;\n\n    if( l_hTIFF == nullptr )\n    {\n        if( pDS == nullptr )\n            return;\n\n        l_hTIFF = pDS->m_hTIFF;\n        if( l_hTIFF == nullptr )\n            return;\n    }\n\n    if( (papszParmList == nullptr) && (pDS == nullptr) )\n        return;\n\n    const char *pszValue = nullptr;\n    if( pDS != nullptr )\n        pszValue = pDS->GetMetadataItem(\"SOURCE_ICC_PROFILE\", \"COLOR_PROFILE\");\n    else\n        pszValue = CSLFetchNameValue(papszParmList, \"SOURCE_ICC_PROFILE\");\n    if( pszValue != nullptr )\n    {\n        char *pEmbedBuffer = CPLStrdup(pszValue);\n        int32 nEmbedLen =\n            CPLBase64DecodeInPlace(reinterpret_cast<GByte *>(pEmbedBuffer));\n\n        TIFFSetField(l_hTIFF, TIFFTAG_ICCPROFILE, nEmbedLen, pEmbedBuffer);\n\n        CPLFree(pEmbedBuffer);\n    }\n    else\n    {\n        // Output colorimetric data.\n        float pCHR[6] = {};  // Primaries.\n        uint16 pTXR[6] = {};  // Transfer range.\n        const char* pszCHRNames[] = {\n            \"SOURCE_PRIMARIES_RED\",\n            \"SOURCE_PRIMARIES_GREEN\",\n            \"SOURCE_PRIMARIES_BLUE\"\n        };\n        const char* pszTXRNames[] = {\n            \"TIFFTAG_TRANSFERRANGE_BLACK\",\n            \"TIFFTAG_TRANSFERRANGE_WHITE\"\n        };\n\n        // Output chromacities.\n        bool bOutputCHR = true;\n        for( int i = 0; i < 3 && bOutputCHR; ++i )\n        {\n            if( pDS != nullptr )\n                pszValue =\n                    pDS->GetMetadataItem(pszCHRNames[i], \"COLOR_PROFILE\");\n            else\n                pszValue = CSLFetchNameValue(papszParmList, pszCHRNames[i]);\n            if( pszValue == nullptr )\n            {\n                bOutputCHR = false;\n                break;\n            }\n\n            char** papszTokens =\n                CSLTokenizeString2(\n                    pszValue, \",\",\n                    CSLT_ALLOWEMPTYTOKENS | CSLT_STRIPLEADSPACES |\n                    CSLT_STRIPENDSPACES );\n\n            if( CSLCount( papszTokens ) != 3 )\n            {\n                bOutputCHR = false;\n                CSLDestroy( papszTokens );\n                break;\n            }\n\n            for( int j = 0; j < 3; ++j )\n            {\n                float v = static_cast<float>(CPLAtof(papszTokens[j]));\n\n                if( j == 2 )\n                {\n                    // Last term of xyY color must be 1.0.\n                    if( v != 1.0 )\n                    {\n                        bOutputCHR = false;\n                        break;\n                    }\n                }\n                else\n                {\n                    pCHR[i * 2 + j] = v;\n                }\n            }\n\n            CSLDestroy( papszTokens );\n        }\n\n        if( bOutputCHR )\n        {\n            TIFFSetField(l_hTIFF, TIFFTAG_PRIMARYCHROMATICITIES, pCHR);\n        }\n\n        // Output whitepoint.\n        if( pDS != nullptr )\n            pszValue =\n                pDS->GetMetadataItem(\"SOURCE_WHITEPOINT\", \"COLOR_PROFILE\");\n        else\n            pszValue = CSLFetchNameValue(papszParmList, \"SOURCE_WHITEPOINT\");\n        if( pszValue != nullptr )\n        {\n            char** papszTokens =\n                CSLTokenizeString2(\n                    pszValue, \",\",\n                    CSLT_ALLOWEMPTYTOKENS | CSLT_STRIPLEADSPACES |\n                    CSLT_STRIPENDSPACES );\n\n            bool bOutputWhitepoint = true;\n            float pWP[2] = { 0.0f, 0.0f };  // Whitepoint\n            if( CSLCount( papszTokens ) != 3 )\n            {\n                bOutputWhitepoint = false;\n            }\n            else\n            {\n                for( int j = 0; j < 3; ++j )\n                {\n                    const float v = static_cast<float>(CPLAtof(papszTokens[j]));\n\n                    if( j == 2 )\n                    {\n                        // Last term of xyY color must be 1.0.\n                        if( v != 1.0 )\n                        {\n                            bOutputWhitepoint = false;\n                            break;\n                        }\n                    }\n                    else\n                    {\n                        pWP[j] = v;\n                    }\n                }\n            }\n            CSLDestroy( papszTokens );\n\n            if( bOutputWhitepoint )\n            {\n                TIFFSetField(l_hTIFF, TIFFTAG_WHITEPOINT, pWP);\n            }\n        }\n\n        // Set transfer function metadata.\n        char const *pszTFRed = nullptr;\n        if( pDS != nullptr )\n            pszTFRed =\n                pDS->GetMetadataItem( \"TIFFTAG_TRANSFERFUNCTION_RED\",\n                                      \"COLOR_PROFILE\" );\n        else\n            pszTFRed =\n                CSLFetchNameValue( papszParmList,\n                                   \"TIFFTAG_TRANSFERFUNCTION_RED\" );\n\n        char const *pszTFGreen = nullptr;\n        if( pDS != nullptr )\n            pszTFGreen =\n                pDS->GetMetadataItem( \"TIFFTAG_TRANSFERFUNCTION_GREEN\",\n                                      \"COLOR_PROFILE\" );\n        else\n            pszTFGreen =\n                CSLFetchNameValue( papszParmList,\n                                   \"TIFFTAG_TRANSFERFUNCTION_GREEN\" );\n\n        char const *pszTFBlue = nullptr;\n        if( pDS != nullptr )\n            pszTFBlue =\n                pDS->GetMetadataItem( \"TIFFTAG_TRANSFERFUNCTION_BLUE\",\n                                      \"COLOR_PROFILE\" );\n        else\n            pszTFBlue =\n                CSLFetchNameValue( papszParmList,\n                                   \"TIFFTAG_TRANSFERFUNCTION_BLUE\" );\n\n        if( (pszTFRed != nullptr) && (pszTFGreen != nullptr) && (pszTFBlue != nullptr) )\n        {\n            // Get length of table.\n            const int nTransferFunctionLength =\n                1 << ((pDS!=nullptr)?pDS->m_nBitsPerSample:l_nBitsPerSample);\n\n            char** papszTokensRed =\n                CSLTokenizeString2(\n                    pszTFRed, \",\",\n                    CSLT_ALLOWEMPTYTOKENS | CSLT_STRIPLEADSPACES |\n                    CSLT_STRIPENDSPACES );\n            char** papszTokensGreen =\n                CSLTokenizeString2(\n                    pszTFGreen, \",\",\n                    CSLT_ALLOWEMPTYTOKENS | CSLT_STRIPLEADSPACES |\n                    CSLT_STRIPENDSPACES );\n            char** papszTokensBlue =\n                CSLTokenizeString2(\n                    pszTFBlue, \",\",\n                    CSLT_ALLOWEMPTYTOKENS | CSLT_STRIPLEADSPACES |\n                    CSLT_STRIPENDSPACES );\n\n            if( (CSLCount( papszTokensRed ) == nTransferFunctionLength) &&\n                (CSLCount( papszTokensGreen ) == nTransferFunctionLength) &&\n                (CSLCount( papszTokensBlue ) == nTransferFunctionLength) )\n            {\n                uint16 *pTransferFuncRed =\n                    static_cast<uint16*>( CPLMalloc(\n                        sizeof(uint16) * nTransferFunctionLength ) );\n                uint16 *pTransferFuncGreen =\n                    static_cast<uint16*>( CPLMalloc(\n                        sizeof(uint16) * nTransferFunctionLength ) );\n                uint16 *pTransferFuncBlue =\n                    static_cast<uint16*>( CPLMalloc(\n                        sizeof(uint16) * nTransferFunctionLength ) );\n\n                // Convert our table in string format into int16 format.\n                for( int i = 0; i < nTransferFunctionLength; ++i )\n                {\n                    pTransferFuncRed[i] =\n                        static_cast<uint16>(atoi(papszTokensRed[i]));\n                    pTransferFuncGreen[i] =\n                        static_cast<uint16>(atoi(papszTokensGreen[i]));\n                    pTransferFuncBlue[i] =\n                        static_cast<uint16>(atoi(papszTokensBlue[i]));\n                }\n\n                TIFFSetField(l_hTIFF, TIFFTAG_TRANSFERFUNCTION,\n                    pTransferFuncRed, pTransferFuncGreen, pTransferFuncBlue);\n\n                CPLFree(pTransferFuncRed);\n                CPLFree(pTransferFuncGreen);\n                CPLFree(pTransferFuncBlue);\n            }\n\n            CSLDestroy( papszTokensRed );\n            CSLDestroy( papszTokensGreen );\n            CSLDestroy( papszTokensBlue );\n        }\n\n        // Output transfer range.\n        bool bOutputTransferRange = true;\n        for( int i = 0; (i < 2) && bOutputTransferRange; ++i )\n        {\n            if( pDS != nullptr )\n                pszValue = pDS->GetMetadataItem( pszTXRNames[i],\n                                                 \"COLOR_PROFILE\" );\n            else\n                pszValue = CSLFetchNameValue(papszParmList, pszTXRNames[i]);\n            if( pszValue == nullptr )\n            {\n                bOutputTransferRange = false;\n                break;\n            }\n\n            char** papszTokens =\n                CSLTokenizeString2(\n                    pszValue, \",\",\n                    CSLT_ALLOWEMPTYTOKENS | CSLT_STRIPLEADSPACES |\n                    CSLT_STRIPENDSPACES );\n\n            if( CSLCount( papszTokens ) != 3 )\n            {\n                bOutputTransferRange = false;\n                CSLDestroy( papszTokens );\n                break;\n            }\n\n            for( int j = 0; j < 3; ++j )\n            {\n                pTXR[i + j * 2] = static_cast<uint16>(atoi(papszTokens[j]));\n            }\n\n            CSLDestroy( papszTokens );\n        }\n\n        if( bOutputTransferRange )\n        {\n            const int TIFFTAG_TRANSFERRANGE = 0x0156;\n            TIFFSetField(l_hTIFF, TIFFTAG_TRANSFERRANGE, pTXR);\n        }\n    }\n}\n\n/************************************************************************/\n/*                             OpenOffset()                             */\n/*                                                                      */\n/*      Initialize the GTiffDataset based on a passed in file           */\n/*      handle, and directory offset to utilize.  This is called for    */\n/*      full res, and overview pages.                                   */\n/************************************************************************/\n\nCPLErr GTiffDataset::OpenOffset( TIFF *hTIFFIn,\n                                 toff_t nDirOffsetIn,\n                                 GDALAccess eAccessIn,\n                                 bool bAllowRGBAInterface,\n                                 bool bReadGeoTransform )\n\n{\n    if( !hTIFFIn )\n        return CE_Failure;\n\n    eAccess = eAccessIn;\n\n    m_hTIFF = hTIFFIn;\n\n    m_nDirOffset = nDirOffsetIn;\n\n    if( !SetDirectory() )\n        return CE_Failure;\n\n/* -------------------------------------------------------------------- */\n/*      Capture some information from the file that is of interest.     */\n/* -------------------------------------------------------------------- */\n    uint32 nXSize = 0;\n    uint32 nYSize = 0;\n    TIFFGetField( m_hTIFF, TIFFTAG_IMAGEWIDTH, &nXSize );\n    TIFFGetField( m_hTIFF, TIFFTAG_IMAGELENGTH, &nYSize );\n    if( nXSize > INT_MAX || nYSize > INT_MAX )\n    {\n        // GDAL only supports signed 32bit dimensions.\n        ReportError(CE_Failure, CPLE_NotSupported,\n                 \"Too large image size: %u x %u\",\n                 nXSize, nYSize);\n        return CE_Failure;\n    }\n    nRasterXSize = nXSize;\n    nRasterYSize = nYSize;\n\n    if( !TIFFGetField(m_hTIFF, TIFFTAG_SAMPLESPERPIXEL, &m_nSamplesPerPixel ) )\n        nBands = 1;\n    else\n        nBands = m_nSamplesPerPixel;\n\n    if( !TIFFGetField(m_hTIFF, TIFFTAG_BITSPERSAMPLE, &(m_nBitsPerSample)) )\n        m_nBitsPerSample = 1;\n\n    if( !TIFFGetField( m_hTIFF, TIFFTAG_PLANARCONFIG, &(m_nPlanarConfig) ) )\n        m_nPlanarConfig = PLANARCONFIG_CONTIG;\n\n    if( !TIFFGetField( m_hTIFF, TIFFTAG_PHOTOMETRIC, &(m_nPhotometric) ) )\n        m_nPhotometric = PHOTOMETRIC_MINISBLACK;\n\n    if( !TIFFGetField( m_hTIFF, TIFFTAG_SAMPLEFORMAT, &(m_nSampleFormat) ) )\n        m_nSampleFormat = SAMPLEFORMAT_UINT;\n\n    if( !TIFFGetField( m_hTIFF, TIFFTAG_COMPRESSION, &(m_nCompression) ) )\n        m_nCompression = COMPRESSION_NONE;\n\n    if( m_nCompression != COMPRESSION_NONE &&\n        !TIFFIsCODECConfigured(m_nCompression) )\n    {\n        ReportError( CE_Failure, CPLE_AppDefined,\n                  \"Cannot open TIFF file due to missing codec.\" );\n        return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      YCbCr JPEG compressed images should be translated on the fly    */\n/*      to RGB by libtiff/libjpeg unless specifically requested         */\n/*      otherwise.                                                      */\n/* -------------------------------------------------------------------- */\n    if( m_nCompression == COMPRESSION_JPEG\n        && m_nPhotometric == PHOTOMETRIC_YCBCR\n        && CPLTestBool( CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\", \"YES\") ) )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"SOURCE_COLOR_SPACE\", \"YCbCr\",\n                                    \"IMAGE_STRUCTURE\" );\n        int nColorMode = 0;\n        if( !TIFFGetField( m_hTIFF, TIFFTAG_JPEGCOLORMODE, &nColorMode ) ||\n            nColorMode != JPEGCOLORMODE_RGB )\n        {\n            TIFFSetField(m_hTIFF, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Get strip/tile layout.                                          */\n/* -------------------------------------------------------------------- */\n    if( TIFFIsTiled(m_hTIFF) )\n    {\n        uint32 l_nBlockXSize = 0;\n        uint32 l_nBlockYSize = 0;\n        TIFFGetField( m_hTIFF, TIFFTAG_TILEWIDTH, &(l_nBlockXSize) );\n        TIFFGetField( m_hTIFF, TIFFTAG_TILELENGTH, &(l_nBlockYSize) );\n        if( l_nBlockXSize > INT_MAX || l_nBlockYSize > INT_MAX )\n        {\n            ReportError(CE_Failure, CPLE_NotSupported,\n                     \"Too large block size: %u x %u\",\n                     l_nBlockXSize, l_nBlockYSize);\n            return CE_Failure;\n        }\n        m_nBlockXSize = static_cast<int>(l_nBlockXSize);\n        m_nBlockYSize = static_cast<int>(l_nBlockYSize);\n    }\n    else\n    {\n        if( !TIFFGetField( m_hTIFF, TIFFTAG_ROWSPERSTRIP,\n                           &(m_nRowsPerStrip) ) )\n        {\n            ReportError( CE_Warning, CPLE_AppDefined,\n                      \"RowsPerStrip not defined ... assuming all one strip.\" );\n            m_nRowsPerStrip = nYSize;  // Dummy value.\n        }\n\n        // If the rows per strip is larger than the file we will get\n        // confused.  libtiff internally will treat the rowsperstrip as\n        // the image height and it is best if we do too. (#4468)\n        if( m_nRowsPerStrip > static_cast<uint32>(nRasterYSize) )\n            m_nRowsPerStrip = nRasterYSize;\n\n        m_nBlockXSize = nRasterXSize;\n        m_nBlockYSize = m_nRowsPerStrip;\n    }\n\n    const int l_nBlocksPerColumn = DIV_ROUND_UP(nRasterYSize, m_nBlockYSize);\n    const int l_nBlocksPerRow = DIV_ROUND_UP(nRasterXSize, m_nBlockXSize);\n    if( l_nBlocksPerColumn > INT_MAX / l_nBlocksPerRow )\n    {\n        ReportError( CE_Failure, CPLE_AppDefined,\n                  \"Too many blocks: %d x %d\",\n                  l_nBlocksPerRow, l_nBlocksPerColumn );\n        return CE_Failure;\n    }\n\n    // Note: we could potentially go up to UINT_MAX blocks, but currently\n    // we use a int nBlockId\n    m_nBlocksPerBand = l_nBlocksPerColumn * l_nBlocksPerRow;\n    if( m_nPlanarConfig == PLANARCONFIG_SEPARATE &&\n        m_nBlocksPerBand > INT_MAX / nBands )\n    {\n        ReportError( CE_Failure, CPLE_AppDefined,\n                  \"Too many blocks: %d x %d x %d bands\",\n                  l_nBlocksPerRow, l_nBlocksPerColumn, nBands );\n        return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Should we handle this using the GTiffBitmapBand?                */\n/* -------------------------------------------------------------------- */\n    bool bTreatAsBitmap = false;\n\n    if( m_nBitsPerSample == 1 && nBands == 1 )\n    {\n        bTreatAsBitmap = true;\n\n        // Lets treat large \"one row\" bitmaps using the scanline api.\n        if( !TIFFIsTiled(m_hTIFF)\n            && m_nBlockYSize == nRasterYSize\n            && nRasterYSize > 2000\n            // libtiff does not support reading JBIG files with\n            // TIFFReadScanline().\n            && m_nCompression != COMPRESSION_JBIG )\n        {\n            m_bTreatAsSplitBitmap = true;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Should we treat this via the RGBA interface?                    */\n/* -------------------------------------------------------------------- */\n    bool bTreatAsRGBA = false;\n    if(\n#ifdef DEBUG\n        CPLTestBool(CPLGetConfigOption(\"GTIFF_FORCE_RGBA\", \"NO\")) ||\n#endif\n        (bAllowRGBAInterface &&\n        !bTreatAsBitmap && !(m_nBitsPerSample > 8)\n        && (m_nPhotometric == PHOTOMETRIC_CIELAB ||\n            m_nPhotometric == PHOTOMETRIC_LOGL ||\n            m_nPhotometric == PHOTOMETRIC_LOGLUV ||\n            m_nPhotometric == PHOTOMETRIC_SEPARATED ||\n            ( m_nPhotometric == PHOTOMETRIC_YCBCR\n              && m_nCompression != COMPRESSION_JPEG ))) )\n    {\n        char szMessage[1024] = {};\n\n        if( TIFFRGBAImageOK( m_hTIFF, szMessage ) == 1 )\n        {\n            const char* pszSourceColorSpace = nullptr;\n            nBands = 4;\n            switch( m_nPhotometric )\n            {\n                case PHOTOMETRIC_CIELAB:\n                    pszSourceColorSpace = \"CIELAB\";\n                    break;\n                case PHOTOMETRIC_LOGL:\n                    pszSourceColorSpace = \"LOGL\";\n                    break;\n                case PHOTOMETRIC_LOGLUV:\n                    pszSourceColorSpace = \"LOGLUV\";\n                    break;\n                case PHOTOMETRIC_SEPARATED:\n                    pszSourceColorSpace = \"CMYK\";\n                    break;\n                case PHOTOMETRIC_YCBCR:\n                    pszSourceColorSpace = \"YCbCr\";\n                    nBands = 3; // probably true for other photometric values\n                    break;\n            }\n            if( pszSourceColorSpace )\n                m_oGTiffMDMD.SetMetadataItem( \"SOURCE_COLOR_SPACE\",\n                                            pszSourceColorSpace,\n                                            \"IMAGE_STRUCTURE\" );\n            bTreatAsRGBA = true;\n\n        }\n        else\n        {\n            CPLDebug( \"GTiff\", \"TIFFRGBAImageOK says:\\n%s\", szMessage );\n        }\n    }\n\n    // libtiff has various issues with OJPEG compression and chunky-strip\n    // support with the \"classic\" scanline/strip/tile interfaces, and that\n    // wouldn't work either, so better bail out.\n    if( m_nCompression == COMPRESSION_OJPEG &&\n        !bTreatAsRGBA )\n    {\n        ReportError(CE_Failure, CPLE_NotSupported,\n                 \"Old-JPEG compression only supported through RGBA interface, \"\n                 \"which cannot be used probably because the file is corrupted\");\n        return CE_Failure;\n    }\n\n    // If photometric is YCbCr, scanline/strip/tile interfaces assumes that\n    // we are ready with downsampled data. And we are not.\n    if( m_nCompression != COMPRESSION_JPEG &&\n        m_nCompression != COMPRESSION_OJPEG &&\n        m_nPhotometric == PHOTOMETRIC_YCBCR &&\n        m_nPlanarConfig == PLANARCONFIG_CONTIG &&\n        !bTreatAsRGBA )\n    {\n        uint16 nF1, nF2;\n        TIFFGetFieldDefaulted(m_hTIFF,TIFFTAG_YCBCRSUBSAMPLING,&nF1,&nF2);\n        if( nF1 != 1 || nF2 != 1 )\n        {\n            ReportError( CE_Failure, CPLE_AppDefined,\n                      \"Cannot open TIFF file with YCbCr, subsampling and \"\n                      \"BitsPerSample > 8 that is not JPEG compressed\" );\n            return CE_Failure;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Should we treat this via the split interface?                   */\n/* -------------------------------------------------------------------- */\n    if( !TIFFIsTiled(m_hTIFF)\n        && m_nBitsPerSample == 8\n        && m_nBlockYSize == nRasterYSize\n        && nRasterYSize > 2000\n        && !bTreatAsRGBA\n        && CPLTestBool(CPLGetConfigOption(\"GDAL_ENABLE_TIFF_SPLIT\", \"YES\")) )\n    {\n        // libtiff 4.0.0beta5 (also\n        // 20091104) and older will crash when trying to open a\n        // all-in-one-strip YCbCr JPEG compressed TIFF (see #3259).\n#if (TIFFLIB_VERSION <= 20091104)\n        if( m_nPhotometric == PHOTOMETRIC_YCBCR &&\n            m_nCompression == COMPRESSION_JPEG )\n        {\n            CPLDebug(\n                \"GTiff\",\n                \"Avoid using split band to open all-in-one-strip \"\n                \"YCbCr JPEG compressed TIFF because of older libtiff\" );\n        }\n        else\n#endif\n        {\n            m_bTreatAsSplit = true;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Should we treat this via the odd bits interface?                */\n/* -------------------------------------------------------------------- */\n    bool bTreatAsOdd = false;\n    if( m_nSampleFormat == SAMPLEFORMAT_IEEEFP )\n    {\n        if( m_nBitsPerSample == 16 || m_nBitsPerSample == 24 )\n            bTreatAsOdd = true;\n    }\n    else if( !bTreatAsRGBA && !bTreatAsBitmap\n             && m_nBitsPerSample != 8\n             && m_nBitsPerSample != 16\n             && m_nBitsPerSample != 32\n             && m_nBitsPerSample != 64\n             && m_nBitsPerSample != 128 )\n    {\n        bTreatAsOdd = true;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      We can't support 'chunks' bigger than 2GB on 32 bit builds      */\n/* -------------------------------------------------------------------- */\n#if SIZEOF_VOIDP == 4\n    uint64 nChunkSize = 0;\n    if( m_bTreatAsSplit || m_bTreatAsSplitBitmap )\n    {\n        nChunkSize = TIFFScanlineSize64( m_hTIFF );\n    }\n    else\n    {\n        if( TIFFIsTiled(m_hTIFF) )\n            nChunkSize = TIFFTileSize64( m_hTIFF );\n        else\n            nChunkSize = TIFFStripSize64( m_hTIFF );\n    }\n    if( bTreatAsRGBA )\n    {\n        nChunkSize = std::max(nChunkSize,\n                        4 * static_cast<uint64>(m_nBlockXSize) * m_nBlockYSize);\n    }\n    if( nChunkSize > static_cast<uint64>(INT_MAX) )\n    {\n        ReportError( CE_Failure, CPLE_NotSupported,\n                  \"Scanline/tile/strip size bigger than 2GB unsupported \"\n                  \"on 32-bit builds.\" );\n        return CE_Failure;\n    }\n#endif\n\n    const bool bMinIsWhite = m_nPhotometric == PHOTOMETRIC_MINISWHITE;\n\n/* -------------------------------------------------------------------- */\n/*      Check for NODATA                                                */\n/* -------------------------------------------------------------------- */\n    char *pszText = nullptr;\n    if( TIFFGetField( m_hTIFF, TIFFTAG_GDAL_NODATA, &pszText ) &&\n        !EQUAL(pszText, \"\") )\n    {\n        m_bNoDataSet = true;\n        m_dfNoDataValue = CPLAtofM( pszText );\n        if( m_nBitsPerSample == 32 && m_nSampleFormat == SAMPLEFORMAT_IEEEFP )\n        {\n            m_dfNoDataValue = GDALAdjustNoDataCloseToFloatMax(m_dfNoDataValue);\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Capture the color table if there is one.                        */\n/* -------------------------------------------------------------------- */\n    unsigned short *panRed = nullptr;\n    unsigned short *panGreen = nullptr;\n    unsigned short *panBlue = nullptr;\n\n    if( bTreatAsRGBA || m_nBitsPerSample > 16\n        || TIFFGetField( m_hTIFF, TIFFTAG_COLORMAP,\n                         &panRed, &panGreen, &panBlue) == 0 )\n    {\n        // Build inverted palette if we have inverted photometric.\n        // Pixel values remains unchanged.  Avoid doing this for *deep*\n        // data types (per #1882)\n        if( m_nBitsPerSample <= 16 && m_nPhotometric == PHOTOMETRIC_MINISWHITE )\n        {\n            m_poColorTable = new GDALColorTable();\n            const int nColorCount = 1 << m_nBitsPerSample;\n\n            for( int iColor = 0; iColor < nColorCount; ++iColor )\n            {\n                const short nValue =\n                    static_cast<short>(((255 * (nColorCount - 1 - iColor)) /\n                                        (nColorCount - 1)));\n                const GDALColorEntry oEntry =\n                    { nValue, nValue, nValue, static_cast<short>(255) };\n                m_poColorTable->SetColorEntry( iColor, &oEntry );\n            }\n\n            m_nPhotometric = PHOTOMETRIC_PALETTE;\n        }\n        else\n        {\n            m_poColorTable = nullptr;\n        }\n    }\n    else\n    {\n        unsigned short nMaxColor = 0;\n\n        m_poColorTable = new GDALColorTable();\n\n        const int nColorCount = 1 << m_nBitsPerSample;\n\n        for( int iColor = nColorCount - 1; iColor >= 0; iColor-- )\n        {\n            // TODO(schwehr): Ensure the color entries are never negative?\n            const unsigned short divisor = 257;\n            const GDALColorEntry oEntry = {\n                static_cast<short>(panRed[iColor] / divisor),\n                static_cast<short>(panGreen[iColor] / divisor),\n                static_cast<short>(panBlue[iColor] / divisor),\n                static_cast<short>(\n                    m_bNoDataSet && static_cast<int>(m_dfNoDataValue) == iColor\n                    ? 0\n                    : 255)\n            };\n\n            m_poColorTable->SetColorEntry( iColor, &oEntry );\n\n            nMaxColor = std::max(nMaxColor, panRed[iColor]);\n            nMaxColor = std::max(nMaxColor, panGreen[iColor]);\n            nMaxColor = std::max(nMaxColor, panBlue[iColor]);\n        }\n\n        // Bug 1384 - Some TIFF files are generated with color map entry\n        // values in range 0-255 instead of 0-65535 - try to handle these\n        // gracefully.\n        if( nMaxColor > 0 && nMaxColor < 256 )\n        {\n            CPLDebug(\n                \"GTiff\",\n                \"TIFF ColorTable seems to be improperly scaled, fixing up.\" );\n\n            for( int iColor = nColorCount - 1; iColor >= 0; iColor-- )\n            {\n                // TODO(schwehr): Ensure the color entries are never negative?\n                const GDALColorEntry oEntry = {\n                    static_cast<short>(panRed[iColor]),\n                    static_cast<short>(panGreen[iColor]),\n                    static_cast<short>(panBlue[iColor]),\n                    m_bNoDataSet &&\n                    static_cast<int>(m_dfNoDataValue) == iColor\n                    ? static_cast<short>(0)\n                    : static_cast<short>(255)\n                };\n\n                m_poColorTable->SetColorEntry( iColor, &oEntry );\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Create band information objects.                                */\n/* -------------------------------------------------------------------- */\n    for( int iBand = 0; iBand < nBands; ++iBand )\n    {\n        if( bTreatAsRGBA )\n            SetBand( iBand + 1, new GTiffRGBABand( this, iBand + 1 ) );\n        else if( m_bTreatAsSplitBitmap )\n            SetBand( iBand + 1, new GTiffSplitBitmapBand( this, iBand + 1 ) );\n        else if( m_bTreatAsSplit )\n            SetBand( iBand + 1, new GTiffSplitBand( this, iBand + 1 ) );\n        else if( bTreatAsBitmap )\n            SetBand( iBand + 1, new GTiffBitmapBand( this, iBand + 1 ) );\n        else if( bTreatAsOdd )\n            SetBand( iBand + 1, new GTiffOddBitsBand( this, iBand + 1 ) );\n        else\n            SetBand( iBand + 1, new GTiffRasterBand( this, iBand + 1 ) );\n    }\n\n    if( GetRasterBand(1)->GetRasterDataType() == GDT_Unknown )\n    {\n        ReportError(CE_Failure, CPLE_NotSupported,\n                 \"Unsupported TIFF configuration: BitsPerSample(=%d) and \"\n                 \"SampleType(=%d)\",\n                 m_nBitsPerSample,\n                 m_nSampleFormat);\n        return CE_Failure;\n    }\n\n    m_bReadGeoTransform = bReadGeoTransform;\n\n/* -------------------------------------------------------------------- */\n/*      Capture some other potentially interesting information.         */\n/* -------------------------------------------------------------------- */\n    char szWorkMDI[200] = {};\n    uint16 nShort = 0;\n\n    for( size_t iTag = 0;\n         iTag < sizeof(asTIFFTags) / sizeof(asTIFFTags[0]);\n         ++iTag )\n    {\n        if( asTIFFTags[iTag].eType == GTIFFTAGTYPE_STRING )\n        {\n            if( TIFFGetField( m_hTIFF, asTIFFTags[iTag].nTagVal, &pszText ) )\n                m_oGTiffMDMD.SetMetadataItem( asTIFFTags[iTag].pszTagName,\n                                            pszText );\n        }\n        else if( asTIFFTags[iTag].eType == GTIFFTAGTYPE_FLOAT )\n        {\n            float fVal = 0.0;\n            if( TIFFGetField( m_hTIFF, asTIFFTags[iTag].nTagVal, &fVal ) )\n            {\n                CPLsnprintf( szWorkMDI, sizeof(szWorkMDI), \"%.8g\", fVal );\n                m_oGTiffMDMD.SetMetadataItem( asTIFFTags[iTag].pszTagName,\n                                            szWorkMDI );\n            }\n        }\n        else if( asTIFFTags[iTag].eType == GTIFFTAGTYPE_SHORT &&\n                 asTIFFTags[iTag].nTagVal != TIFFTAG_RESOLUTIONUNIT )\n        {\n            if( TIFFGetField( m_hTIFF, asTIFFTags[iTag].nTagVal, &nShort ) )\n            {\n                snprintf( szWorkMDI, sizeof(szWorkMDI), \"%d\", nShort );\n                m_oGTiffMDMD.SetMetadataItem( asTIFFTags[iTag].pszTagName,\n                                            szWorkMDI );\n            }\n        }\n        else if( asTIFFTags[iTag].eType == GTIFFTAGTYPE_BYTE_STRING )\n        {\n            uint32 nCount = 0;\n            if( TIFFGetField( m_hTIFF, asTIFFTags[iTag].nTagVal,\n                              &nCount, &pszText ) )\n            {\n                std::string osStr;\n                osStr.assign(pszText, nCount);\n                m_oGTiffMDMD.SetMetadataItem( asTIFFTags[iTag].pszTagName,\n                                            osStr.c_str() );\n            }\n        }\n    }\n\n    if( TIFFGetField( m_hTIFF, TIFFTAG_RESOLUTIONUNIT, &nShort ) )\n    {\n        if( nShort == RESUNIT_NONE )\n            snprintf( szWorkMDI, sizeof(szWorkMDI), \"%d (unitless)\", nShort );\n        else if( nShort == RESUNIT_INCH )\n            snprintf( szWorkMDI, sizeof(szWorkMDI),\n                      \"%d (pixels/inch)\", nShort );\n        else if( nShort == RESUNIT_CENTIMETER )\n            snprintf( szWorkMDI, sizeof(szWorkMDI), \"%d (pixels/cm)\", nShort );\n        else\n            snprintf( szWorkMDI, sizeof(szWorkMDI), \"%d\", nShort );\n        m_oGTiffMDMD.SetMetadataItem( \"TIFFTAG_RESOLUTIONUNIT\", szWorkMDI );\n    }\n\n    int nTagSize = 0;\n    void* pData = nullptr;\n    if( TIFFGetField( m_hTIFF, TIFFTAG_XMLPACKET, &nTagSize, &pData ) )\n    {\n        char* pszXMP =\n            static_cast<char *>( VSI_MALLOC_VERBOSE(nTagSize + 1) );\n        if( pszXMP )\n        {\n            memcpy(pszXMP, pData, nTagSize);\n            pszXMP[nTagSize] = '\\0';\n\n            char *apszMDList[2] = { pszXMP, nullptr };\n            m_oGTiffMDMD.SetMetadata(apszMDList, \"xml:XMP\");\n\n            CPLFree(pszXMP);\n        }\n    }\n\n    if( m_nCompression == COMPRESSION_NONE )\n        /* no compression tag */;\n    else if( m_nCompression == COMPRESSION_CCITTRLE )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"CCITTRLE\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_CCITTFAX3 )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"CCITTFAX3\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_CCITTFAX4 )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"CCITTFAX4\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_LZW )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"LZW\", \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_OJPEG )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"OJPEG\", \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_JPEG )\n    {\n        if( m_nPhotometric == PHOTOMETRIC_YCBCR )\n            m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"YCbCr JPEG\",\n                                        \"IMAGE_STRUCTURE\" );\n        else\n            m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"JPEG\",\n                                        \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_NEXT )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"NEXT\", \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_CCITTRLEW )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"CCITTRLEW\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_PACKBITS )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"PACKBITS\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_THUNDERSCAN )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"THUNDERSCAN\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_PIXARFILM )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"PIXARFILM\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_PIXARLOG )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"PIXARLOG\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_DEFLATE )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"DEFLATE\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_ADOBE_DEFLATE )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"DEFLATE\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_DCS )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"DCS\", \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_JBIG )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"JBIG\", \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_SGILOG )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"SGILOG\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_SGILOG24 )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"SGILOG24\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_JP2000 )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"JP2000\",\n                                    \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_LZMA )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"LZMA\", \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_ZSTD )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"ZSTD\", \"IMAGE_STRUCTURE\" );\n    }\n    else if( m_nCompression == COMPRESSION_LERC )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"LERC\", \"IMAGE_STRUCTURE\" );\n#if HAVE_LERC\n        uint32 nLercParamCount = 0;\n        uint32* panLercParms = nullptr;\n        if( TIFFGetField( m_hTIFF, TIFFTAG_LERC_PARAMETERS, &nLercParamCount,\n                          &panLercParms ) &&\n            nLercParamCount == 2 )\n        {\n            memcpy( m_anLercAddCompressionAndVersion, panLercParms,\n                    sizeof(m_anLercAddCompressionAndVersion) );\n        }\n\n        uint32 nAddVersion = LERC_ADD_COMPRESSION_NONE;\n        if( TIFFGetField( m_hTIFF, TIFFTAG_LERC_ADD_COMPRESSION, &nAddVersion ) &&\n            nAddVersion != LERC_ADD_COMPRESSION_NONE )\n        {\n            if( nAddVersion == LERC_ADD_COMPRESSION_DEFLATE )\n            {\n                m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"LERC_DEFLATE\",\n                                            \"IMAGE_STRUCTURE\" );\n            }\n            else if( nAddVersion == LERC_ADD_COMPRESSION_ZSTD )\n            {\n                m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"LERC_ZSTD\",\n                                            \"IMAGE_STRUCTURE\" );\n            }\n        }\n        uint32 nLercVersion = LERC_VERSION_2_4;\n        if( TIFFGetField( m_hTIFF, TIFFTAG_LERC_VERSION, &nLercVersion) )\n        {\n            if( nLercVersion == LERC_VERSION_2_4 )\n            {\n                m_oGTiffMDMD.SetMetadataItem( \"LERC_VERSION\", \"2.4\",\n                                            \"IMAGE_STRUCTURE\" );\n            }\n            else\n            {\n                ReportError(CE_Warning, CPLE_AppDefined,\n                         \"Unknown Lerc version: %d\", nLercVersion);\n            }\n        }\n#endif\n    }\n    else if( m_nCompression == COMPRESSION_WEBP )\n    {\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", \"WEBP\", \"IMAGE_STRUCTURE\" );\n    }\n    else\n    {\n        CPLString oComp;\n        oComp.Printf( \"%d\", m_nCompression);\n        m_oGTiffMDMD.SetMetadataItem( \"COMPRESSION\", oComp.c_str());\n    }\n\n    if( m_nPlanarConfig == PLANARCONFIG_CONTIG && nBands != 1 )\n        m_oGTiffMDMD.SetMetadataItem( \"INTERLEAVE\", \"PIXEL\", \"IMAGE_STRUCTURE\" );\n    else\n        m_oGTiffMDMD.SetMetadataItem( \"INTERLEAVE\", \"BAND\", \"IMAGE_STRUCTURE\" );\n\n    if( (GetRasterBand(1)->GetRasterDataType() == GDT_Byte &&\n         m_nBitsPerSample != 8 ) ||\n        (GetRasterBand(1)->GetRasterDataType() == GDT_UInt16 &&\n         m_nBitsPerSample != 16) ||\n        ((GetRasterBand(1)->GetRasterDataType() == GDT_UInt32 ||\n          GetRasterBand(1)->GetRasterDataType() == GDT_Float32) &&\n         m_nBitsPerSample != 32) )\n    {\n        for( int i = 0; i < nBands; ++i )\n            cpl::down_cast<GTiffRasterBand*>(GetRasterBand(i + 1))->\n                m_oGTiffMDMD.SetMetadataItem(\n                    \"NBITS\",\n                    CPLString().Printf(\n                        \"%d\", static_cast<int>(m_nBitsPerSample) ),\n                    \"IMAGE_STRUCTURE\" );\n    }\n\n    if( bMinIsWhite )\n        m_oGTiffMDMD.SetMetadataItem( \"MINISWHITE\", \"YES\", \"IMAGE_STRUCTURE\" );\n\n    if( TIFFGetField( m_hTIFF, TIFFTAG_GDAL_METADATA, &pszText ) )\n    {\n        CPLXMLNode *psRoot = CPLParseXMLString( pszText );\n        CPLXMLNode *psItem = nullptr;\n\n        if( psRoot != nullptr && psRoot->eType == CXT_Element\n            && EQUAL(psRoot->pszValue,\"GDALMetadata\") )\n            psItem = psRoot->psChild;\n\n        for( ; psItem != nullptr; psItem = psItem->psNext )\n        {\n\n            if( psItem->eType != CXT_Element\n                || !EQUAL(psItem->pszValue,\"Item\") )\n                continue;\n\n            const char *pszKey = CPLGetXMLValue( psItem, \"name\", nullptr );\n            const char *pszValue = CPLGetXMLValue( psItem, nullptr, nullptr );\n            int nBand =\n                atoi(CPLGetXMLValue( psItem, \"sample\", \"-1\" ));\n            if( nBand < -1 || nBand > 65535 )\n                continue;\n            nBand ++;\n            const char *pszRole = CPLGetXMLValue( psItem, \"role\", \"\" );\n            const char *pszDomain = CPLGetXMLValue( psItem, \"domain\", \"\" );\n\n            if( pszKey == nullptr || pszValue == nullptr )\n                continue;\n            if( EQUAL(pszDomain, \"IMAGE_STRUCTURE\") )\n                continue;\n\n            bool bIsXML = false;\n\n            if( STARTS_WITH_CI(pszDomain, \"xml:\") )\n                bIsXML = TRUE;\n\n            char *pszUnescapedValue =\n                CPLUnescapeString( pszValue, nullptr, CPLES_XML );\n            if( nBand == 0 )\n            {\n                if( bIsXML )\n                {\n                    char *apszMD[2] = { pszUnescapedValue, nullptr };\n                    m_oGTiffMDMD.SetMetadata( apszMD, pszDomain );\n                }\n                else\n                {\n                    m_oGTiffMDMD.SetMetadataItem( pszKey, pszUnescapedValue,\n                                                pszDomain );\n                }\n            }\n            else\n            {\n                GTiffRasterBand *poBand =\n                    cpl::down_cast<GTiffRasterBand*>(GetRasterBand(nBand));\n                if( poBand != nullptr )\n                {\n                    if( EQUAL(pszRole,\"scale\") )\n                    {\n                        poBand->m_bHaveOffsetScale = true;\n                        poBand->m_dfScale = CPLAtofM(pszUnescapedValue);\n                    }\n                    else if( EQUAL(pszRole,\"offset\") )\n                    {\n                        poBand->m_bHaveOffsetScale = true;\n                        poBand->m_dfOffset = CPLAtofM(pszUnescapedValue);\n                    }\n                    else if( EQUAL(pszRole,\"unittype\") )\n                    {\n                        poBand->m_osUnitType = pszUnescapedValue;\n                    }\n                    else if( EQUAL(pszRole,\"description\") )\n                    {\n                        poBand->m_osDescription = pszUnescapedValue;\n                    }\n                    else if( EQUAL(pszRole, \"colorinterp\") )\n                    {\n                        poBand->m_eBandInterp =\n                            GDALGetColorInterpretationByName(pszUnescapedValue);\n                    }\n                    else\n                    {\n                        if( bIsXML )\n                        {\n                            char *apszMD[2] = { pszUnescapedValue, nullptr };\n                            poBand->m_oGTiffMDMD.SetMetadata( apszMD, pszDomain );\n                        }\n                        else\n                        {\n                            poBand->m_oGTiffMDMD.SetMetadataItem(\n                                pszKey,\n                                pszUnescapedValue,\n                                pszDomain );\n                        }\n                    }\n                }\n            }\n            CPLFree( pszUnescapedValue );\n        }\n\n        CPLDestroyXMLNode( psRoot );\n    }\n\n    if( m_bStreamingIn )\n    {\n        toff_t* panOffsets = nullptr;\n        TIFFGetField( m_hTIFF,\n                      TIFFIsTiled( m_hTIFF ) ?\n                      TIFFTAG_TILEOFFSETS : TIFFTAG_STRIPOFFSETS,\n                      &panOffsets );\n        if( panOffsets )\n        {\n            int nBlockCount =\n                TIFFIsTiled(m_hTIFF) ?\n                TIFFNumberOfTiles(m_hTIFF) : TIFFNumberOfStrips(m_hTIFF);\n            for( int i = 1; i < nBlockCount; ++i )\n            {\n                if( panOffsets[i] < panOffsets[i-1] )\n                {\n                    m_oGTiffMDMD.SetMetadataItem( \"UNORDERED_BLOCKS\", \"YES\",\n                                                \"TIFF\");\n                    CPLDebug(\n                        \"GTIFF\",\n                        \"Offset of block %d is lower than previous block. \"\n                        \"Reader must be careful\",\n                        i );\n                    break;\n                }\n            }\n        }\n    }\n\n    if( m_nCompression == COMPRESSION_JPEG && eAccess == GA_Update )\n    {\n        SetJPEGQualityAndTablesModeFromFile();\n    }\n\n    CPLAssert(m_bReadGeoTransform == bReadGeoTransform);\n    CPLAssert(!m_bMetadataChanged);\n    m_bMetadataChanged = false;\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                         GetSiblingFiles()                            */\n/************************************************************************/\n\nchar** GTiffDataset::GetSiblingFiles()\n{\n    if( m_bHasGotSiblingFiles )\n    {\n        return oOvManager.GetSiblingFiles();\n    }\n\n    m_bHasGotSiblingFiles = true;\n    const int nMaxFiles =\n        atoi(CPLGetConfigOption(\"GDAL_READDIR_LIMIT_ON_OPEN\", \"1000\"));\n    char** papszSiblingFiles =\n        VSIReadDirEx(CPLGetDirname(m_pszFilename), nMaxFiles);\n    if( nMaxFiles > 0 && CSLCount(papszSiblingFiles) > nMaxFiles )\n    {\n        CPLDebug(\"GTiff\", \"GDAL_READDIR_LIMIT_ON_OPEN reached on %s\",\n                 CPLGetDirname(m_pszFilename));\n        CSLDestroy(papszSiblingFiles);\n        papszSiblingFiles = nullptr;\n    }\n    oOvManager.TransferSiblingFiles( papszSiblingFiles );\n\n    return papszSiblingFiles;\n}\n\n/************************************************************************/\n/*                   IdentifyAuthorizedGeoreferencingSources()          */\n/************************************************************************/\n\nvoid GTiffDataset::IdentifyAuthorizedGeoreferencingSources()\n{\n    if( m_bHasIdentifiedAuthorizedGeoreferencingSources )\n        return;\n    m_bHasIdentifiedAuthorizedGeoreferencingSources = true;\n    CPLString osGeorefSources = CSLFetchNameValueDef( papszOpenOptions,\n        \"GEOREF_SOURCES\",\n        CPLGetConfigOption(\"GDAL_GEOREF_SOURCES\",\n                           \"PAM,INTERNAL,TABFILE,WORLDFILE\") );\n    char** papszTokens = CSLTokenizeString2(osGeorefSources, \",\", 0);\n    m_nPAMGeorefSrcIndex = static_cast<signed char>(CSLFindString(papszTokens, \"PAM\"));\n    m_nINTERNALGeorefSrcIndex = static_cast<signed char>(CSLFindString(papszTokens, \"INTERNAL\"));\n    m_nTABFILEGeorefSrcIndex = static_cast<signed char>(CSLFindString(papszTokens, \"TABFILE\"));\n    m_nWORLDFILEGeorefSrcIndex = static_cast<signed char>(CSLFindString(papszTokens, \"WORLDFILE\"));\n    CSLDestroy(papszTokens);\n}\n\n/************************************************************************/\n/*                     LoadGeoreferencingAndPamIfNeeded()               */\n/************************************************************************/\n\nvoid GTiffDataset::LoadGeoreferencingAndPamIfNeeded()\n\n{\n    if( !m_bReadGeoTransform && !m_bLoadPam )\n        return;\n\n    IdentifyAuthorizedGeoreferencingSources();\n\n/* -------------------------------------------------------------------- */\n/*      Get the transform or gcps from the GeoTIFF file.                */\n/* -------------------------------------------------------------------- */\n    if( m_bReadGeoTransform )\n    {\n        m_bReadGeoTransform = false;\n\n        char *pszTabWKT = nullptr;\n        double *padfTiePoints = nullptr;\n        double *padfScale = nullptr;\n        double *padfMatrix = nullptr;\n        uint16 nCount = 0;\n        bool bPixelIsPoint = false;\n        unsigned short nRasterType = 0;\n        bool bPointGeoIgnore = false;\n\n        std::set<signed char> aoSetPriorities;\n        if( m_nINTERNALGeorefSrcIndex >= 0 )\n            aoSetPriorities.insert(m_nINTERNALGeorefSrcIndex);\n        if( m_nTABFILEGeorefSrcIndex >= 0 )\n            aoSetPriorities.insert(m_nTABFILEGeorefSrcIndex);\n        if( m_nWORLDFILEGeorefSrcIndex >= 0 )\n            aoSetPriorities.insert(m_nWORLDFILEGeorefSrcIndex);\n        for(const auto nIndex: aoSetPriorities )\n        {\n            if( m_nINTERNALGeorefSrcIndex == nIndex )\n            {\n                GTIF *psGTIF = GTiffDatasetGTIFNew( m_hTIFF );  // How expensive this is?\n\n                if( psGTIF )\n                {\n                    if( GDALGTIFKeyGetSHORT(psGTIF, GTRasterTypeGeoKey,\n                                            &nRasterType, 0, 1 ) == 1\n                        && nRasterType ==\n                           static_cast<short>(RasterPixelIsPoint) )\n                    {\n                        bPixelIsPoint = true;\n                        bPointGeoIgnore =\n                            CPLTestBool(\n                                CPLGetConfigOption(\"GTIFF_POINT_GEO_IGNORE\",\n                                                   \"FALSE\") );\n                    }\n\n                    GTIFFree( psGTIF );\n                }\n\n                m_adfGeoTransform[0] = 0.0;\n                m_adfGeoTransform[1] = 1.0;\n                m_adfGeoTransform[2] = 0.0;\n                m_adfGeoTransform[3] = 0.0;\n                m_adfGeoTransform[4] = 0.0;\n                m_adfGeoTransform[5] = 1.0;\n\n                uint16 nCountScale = 0;\n                if( TIFFGetField(m_hTIFF, TIFFTAG_GEOPIXELSCALE,\n                                 &nCountScale, &padfScale )\n                    && nCountScale >= 2\n                    && padfScale[0] != 0.0 && padfScale[1] != 0.0 )\n                {\n                    m_adfGeoTransform[1] = padfScale[0];\n                    if( padfScale[1] < 0 )\n                    {\n                        const char* pszOptionVal =\n                            CPLGetConfigOption(\"GTIFF_HONOUR_NEGATIVE_SCALEY\",\n                                               nullptr);\n                        if( pszOptionVal == nullptr )\n                        {\n                            ReportError(CE_Warning, CPLE_AppDefined,\n                                \"File with negative value for ScaleY in \"\n                                \"GeoPixelScale tag. This is rather \"\n                                \"unusual. GDAL, contrary to the GeoTIFF \"\n                                \"specification, assumes that the file \"\n                                \"was intended to be north-up, and will \"\n                                \"treat this file as if ScaleY was \"\n                                \"positive. You may override this behavior \"\n                                \"by setting the GTIFF_HONOUR_NEGATIVE_SCALEY \"\n                                \"configuration option to YES\");\n                            m_adfGeoTransform[5] = padfScale[1];\n                        }\n                        else if( CPLTestBool(pszOptionVal) )\n                        {\n                            m_adfGeoTransform[5] = -padfScale[1];\n                        }\n                        else\n                        {\n                            m_adfGeoTransform[5] = padfScale[1];\n                        }\n                    }\n                    else\n                    {\n                        m_adfGeoTransform[5] = -padfScale[1];\n                    }\n\n                    if( TIFFGetField(m_hTIFF, TIFFTAG_GEOTIEPOINTS,\n                                     &nCount, &padfTiePoints )\n                        && nCount >= 6 )\n                    {\n                        m_adfGeoTransform[0] =\n                            padfTiePoints[3] -\n                            padfTiePoints[0] * m_adfGeoTransform[1];\n                        m_adfGeoTransform[3] =\n                            padfTiePoints[4] -\n                            padfTiePoints[1] * m_adfGeoTransform[5];\n\n                        if( bPixelIsPoint && !bPointGeoIgnore )\n                        {\n                            m_adfGeoTransform[0] -=\n                                (m_adfGeoTransform[1] * 0.5 +\n                                 m_adfGeoTransform[2] * 0.5);\n                            m_adfGeoTransform[3] -=\n                                (m_adfGeoTransform[4] * 0.5 +\n                                 m_adfGeoTransform[5] * 0.5);\n                        }\n\n                        m_bGeoTransformValid = true;\n                        m_nGeoTransformGeorefSrcIndex = nIndex;\n\n                        if( nCountScale >= 3 && GetRasterCount() == 1 &&\n                            (padfScale[2] != 0.0 ||\n                             padfTiePoints[2] != 0.0 ||\n                             padfTiePoints[5] != 0.0) )\n                        {\n                            LookForProjection();\n                            if( !m_oSRS.IsEmpty() && m_oSRS.IsVertical() )\n                            {\n                                /* modelTiePointTag = (pixel, line, z0, X, Y, Z0) */\n                                /* thus Z(some_point) = (z(some_point) - z0) * scaleZ + Z0 */\n                                /* equivalently written as */\n                                /* Z(some_point) = z(some_point) * scaleZ + offsetZ with */\n                                /* offsetZ = - z0 * scaleZ + Z0 */\n                                double dfScale = padfScale[2];\n                                double dfOffset =\n                                    -padfTiePoints[2] * dfScale + padfTiePoints[5];\n                                GTiffRasterBand* poBand =\n                                    cpl::down_cast<GTiffRasterBand*>(GetRasterBand(1));\n                                poBand->m_bHaveOffsetScale = true;\n                                poBand->m_dfScale = dfScale;\n                                poBand->m_dfOffset = dfOffset;\n                            }\n                        }\n                    }\n                }\n\n                else if( TIFFGetField(m_hTIFF, TIFFTAG_GEOTRANSMATRIX,\n                                      &nCount, &padfMatrix )\n                        && nCount == 16 )\n                {\n                    m_adfGeoTransform[0] = padfMatrix[3];\n                    m_adfGeoTransform[1] = padfMatrix[0];\n                    m_adfGeoTransform[2] = padfMatrix[1];\n                    m_adfGeoTransform[3] = padfMatrix[7];\n                    m_adfGeoTransform[4] = padfMatrix[4];\n                    m_adfGeoTransform[5] = padfMatrix[5];\n\n                    if( bPixelIsPoint && !bPointGeoIgnore )\n                    {\n                        m_adfGeoTransform[0] -=\n                            m_adfGeoTransform[1] * 0.5 + m_adfGeoTransform[2] * 0.5;\n                        m_adfGeoTransform[3] -=\n                            m_adfGeoTransform[4] * 0.5 + m_adfGeoTransform[5] * 0.5;\n                    }\n\n                    m_bGeoTransformValid = true;\n                    m_nGeoTransformGeorefSrcIndex = nIndex;\n                }\n                if( m_bGeoTransformValid )\n                    break;\n            }\n\n/* -------------------------------------------------------------------- */\n/*      Otherwise try looking for a .tab, .tfw, .tifw or .wld file.     */\n/* -------------------------------------------------------------------- */\n            if( m_nTABFILEGeorefSrcIndex == nIndex )\n            {\n                char* pszGeorefFilename = nullptr;\n\n                char** papszSiblingFiles = GetSiblingFiles();\n\n                // Begin with .tab since it can also have projection info.\n                const int bTabFileOK =\n                    GDALReadTabFile2( m_pszFilename, m_adfGeoTransform,\n                                        &pszTabWKT, &m_nGCPCount, &m_pasGCPList,\n                                        papszSiblingFiles, &pszGeorefFilename );\n\n                if( bTabFileOK )\n                {\n                    m_nGeoTransformGeorefSrcIndex = nIndex;\n                    // if( pszTabWKT )\n                    // {\n                    //     m_nProjectionGeorefSrcIndex = nIndex;\n                    // }\n                    if( m_nGCPCount == 0 )\n                    {\n                        m_bGeoTransformValid = true;\n                    }\n                }\n\n                if( pszGeorefFilename )\n                {\n                    CPLFree(m_pszGeorefFilename);\n                    m_pszGeorefFilename = pszGeorefFilename;\n                    pszGeorefFilename = nullptr;\n                }\n                if( m_bGeoTransformValid )\n                    break;\n            }\n\n            if( m_nWORLDFILEGeorefSrcIndex == nIndex )\n            {\n                char* pszGeorefFilename = nullptr;\n\n                char** papszSiblingFiles = GetSiblingFiles();\n\n                m_bGeoTransformValid = CPL_TO_BOOL( GDALReadWorldFile2(\n                                m_pszFilename, nullptr, m_adfGeoTransform,\n                                papszSiblingFiles, &pszGeorefFilename) );\n\n                if( !m_bGeoTransformValid )\n                {\n                    m_bGeoTransformValid =\n                        CPL_TO_BOOL( GDALReadWorldFile2(\n                            m_pszFilename, \"wld\", m_adfGeoTransform,\n                            papszSiblingFiles, &pszGeorefFilename ) );\n                }\n                if( m_bGeoTransformValid )\n                    m_nGeoTransformGeorefSrcIndex = nIndex;\n\n                if( pszGeorefFilename )\n                {\n                    CPLFree(m_pszGeorefFilename);\n                    m_pszGeorefFilename = pszGeorefFilename;\n                    pszGeorefFilename = nullptr;\n                }\n                if( m_bGeoTransformValid )\n                    break;\n            }\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Check for GCPs.                                                 */\n/* -------------------------------------------------------------------- */\n        if( m_nINTERNALGeorefSrcIndex >= 0 &&\n            TIFFGetField(m_hTIFF,TIFFTAG_GEOTIEPOINTS,&nCount,&padfTiePoints )\n            && !m_bGeoTransformValid )\n        {\n            if( m_nGCPCount > 0 )\n            {\n                GDALDeinitGCPs( m_nGCPCount, m_pasGCPList );\n                CPLFree( m_pasGCPList );\n            }\n            m_nGCPCount = nCount / 6;\n            m_pasGCPList =\n                static_cast<GDAL_GCP *>(CPLCalloc(sizeof(GDAL_GCP), m_nGCPCount));\n\n            for( int iGCP = 0; iGCP < m_nGCPCount; ++iGCP )\n            {\n                char szID[32] = {};\n\n                snprintf( szID, sizeof(szID), \"%d\", iGCP + 1 );\n                m_pasGCPList[iGCP].pszId = CPLStrdup( szID );\n                m_pasGCPList[iGCP].pszInfo = CPLStrdup(\"\");\n                m_pasGCPList[iGCP].dfGCPPixel = padfTiePoints[iGCP*6+0];\n                m_pasGCPList[iGCP].dfGCPLine = padfTiePoints[iGCP*6+1];\n                m_pasGCPList[iGCP].dfGCPX = padfTiePoints[iGCP*6+3];\n                m_pasGCPList[iGCP].dfGCPY = padfTiePoints[iGCP*6+4];\n                m_pasGCPList[iGCP].dfGCPZ = padfTiePoints[iGCP*6+5];\n\n                if( bPixelIsPoint && !bPointGeoIgnore )\n                {\n                    m_pasGCPList[iGCP].dfGCPPixel += 0.5;\n                    m_pasGCPList[iGCP].dfGCPLine += 0.5;\n                }\n            }\n            m_nGeoTransformGeorefSrcIndex = m_nINTERNALGeorefSrcIndex;\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Did we find a tab file?  If so we will use its coordinate       */\n/*      system and give it precedence.                                  */\n/* -------------------------------------------------------------------- */\n        if( pszTabWKT != nullptr && m_oSRS.IsEmpty() )\n        {\n            m_oSRS.SetFromUserInput(pszTabWKT);\n            m_bLookedForProjection = true;\n        }\n\n        CPLFree( pszTabWKT );\n    }\n\n    if( m_bLoadPam && m_nPAMGeorefSrcIndex >= 0 )\n    {\n/* -------------------------------------------------------------------- */\n/*      Initialize any PAM information.                                 */\n/* -------------------------------------------------------------------- */\n        CPLAssert(!m_bColorProfileMetadataChanged);\n        CPLAssert(!m_bMetadataChanged);\n        CPLAssert(!m_bGeoTIFFInfoChanged);\n        CPLAssert(!m_bNoDataChanged);\n\n        // We must absolutely unset m_bLoadPam now, otherwise calling\n        // GetFileList() on a .tif with a .aux will result in an (almost)\n        // endless sequence of calls.\n        m_bLoadPam = false;\n\n        TryLoadXML( GetSiblingFiles() );\n        ApplyPamInfo();\n\n        m_bColorProfileMetadataChanged = false;\n        m_bMetadataChanged = false;\n        m_bGeoTIFFInfoChanged = false;\n        m_bNoDataChanged = false;\n\n        for( int i = 1; i <= nBands; ++i )\n        {\n            GTiffRasterBand* poBand =\n                cpl::down_cast<GTiffRasterBand *>(GetRasterBand(i));\n\n            /* Load scale, offset and unittype from PAM if available */\n            if( !poBand->m_bHaveOffsetScale )\n            {\n                int nHaveOffsetScale = FALSE;\n                poBand->m_dfScale =\n                    poBand->GDALPamRasterBand::GetScale( &nHaveOffsetScale );\n                poBand->m_bHaveOffsetScale = CPL_TO_BOOL(nHaveOffsetScale);\n                poBand->m_dfOffset = poBand->GDALPamRasterBand::GetOffset();\n            }\n            if( poBand->m_osUnitType.empty() )\n            {\n                const char* pszUnitType =\n                    poBand->GDALPamRasterBand::GetUnitType();\n                if( pszUnitType )\n                    poBand->m_osUnitType = pszUnitType;\n            }\n            if( poBand->m_osDescription.empty() )\n                poBand->m_osDescription =\n                    poBand->GDALPamRasterBand::GetDescription();\n\n            GDALColorInterp ePAMColorInterp =\n                poBand->GDALPamRasterBand::GetColorInterpretation();\n            if( ePAMColorInterp != GCI_Undefined )\n                poBand->m_eBandInterp = ePAMColorInterp;\n        }\n    }\n    m_bLoadPam = false;\n}\n\n/************************************************************************/\n/*                   SetStructuralMDFromParent()                        */\n/************************************************************************/\n\nvoid GTiffDataset::SetStructuralMDFromParent(GTiffDataset* poParentDS)\n{\n    m_bBlockOrderRowMajor = poParentDS->m_bBlockOrderRowMajor;\n    m_bLeaderSizeAsUInt4 = poParentDS->m_bLeaderSizeAsUInt4;\n    m_bTrailerRepeatedLast4BytesRepeated = poParentDS->m_bTrailerRepeatedLast4BytesRepeated;\n    m_bMaskInterleavedWithImagery = poParentDS->m_bMaskInterleavedWithImagery;\n    m_bWriteEmptyTiles = poParentDS->m_bWriteEmptyTiles;\n}\n\n/************************************************************************/\n/*                          ScanDirectories()                           */\n/*                                                                      */\n/*      Scan through all the directories finding overviews, masks       */\n/*      and subdatasets.                                                */\n/************************************************************************/\n\nvoid GTiffDataset::ScanDirectories()\n\n{\n/* -------------------------------------------------------------------- */\n/*      We only scan once.  We do not scan for non-base datasets.       */\n/* -------------------------------------------------------------------- */\n    if( !m_bScanDeferred )\n        return;\n\n    m_bScanDeferred = false;\n\n    if( m_poBaseDS )\n        return;\n\n    Crystalize();\n\n    CPLDebug( \"GTiff\", \"ScanDirectories()\" );\n\n/* ==================================================================== */\n/*      Scan all directories.                                           */\n/* ==================================================================== */\n    CPLStringList aosSubdatasets;\n    int iDirIndex = 0;\n\n    FlushDirectory();\n\n    do\n    {\n        // Only libtiff 4.0.4 can handle between 32768 and 65535 directories.\n#if !defined(SUPPORTS_MORE_THAN_32768_DIRECTORIES)\n        if( iDirIndex == 32768 )\n            break;\n#endif\n        toff_t nTopDir = TIFFCurrentDirOffset(m_hTIFF);\n        uint32 nSubType = 0;\n\n        ++iDirIndex;\n\n        toff_t *tmpSubIFDOffsets = nullptr;\n        toff_t *subIFDOffsets = nullptr;\n        uint16 nSubIFDs = 0;\n        if (TIFFGetField(m_hTIFF, TIFFTAG_SUBIFD, &nSubIFDs, &tmpSubIFDOffsets) && iDirIndex == 1)\n        {\n            subIFDOffsets = static_cast<toff_t *>(CPLMalloc(nSubIFDs * sizeof(toff_t)));\n            for (uint16 iSubIFD = 0; iSubIFD < nSubIFDs; iSubIFD++)\n            {\n                subIFDOffsets[iSubIFD] = tmpSubIFDOffsets[iSubIFD];\n            }\n        }\n\n        //early break for backwards compatibility: if the first directory read is also the last, and there are no subIFDs, no use continuing\n        if( iDirIndex==1 && nSubIFDs==0 && TIFFLastDirectory( m_hTIFF )) {\n            CPLFree(subIFDOffsets);\n            break;\n        }\n\n\n        for( uint16 iSubIFD = 0; iSubIFD<=nSubIFDs; iSubIFD++ ) {\n            toff_t nThisDir = nTopDir;\n            if ( iSubIFD > 0 && iDirIndex > 1 ) //don't read subIFDs if we are not in the original directory\n                break;\n            if ( iSubIFD > 0 ) {\n                // make static analyzer happy. subIFDOffsets cannot be null if iSubIFD>0\n                assert(subIFDOffsets != nullptr); \n                nThisDir = subIFDOffsets[iSubIFD-1];\n                //CPLDebug(\"GTiff\", \"Opened subIFD %d/%d at offset %llu.\", iSubIFD, nSubIFDs, nThisDir);\n                if (!TIFFSetSubDirectory(m_hTIFF,nThisDir))\n                    break;\n            }\n\n\n            if( !TIFFGetField(m_hTIFF, TIFFTAG_SUBFILETYPE, &nSubType) )\n                nSubType = 0;\n\n            /* Embedded overview of the main image */\n            if( (nSubType & FILETYPE_REDUCEDIMAGE) != 0 &&\n                (nSubType & FILETYPE_MASK) == 0 &&\n                ((nSubIFDs==0 && iDirIndex != 1) || iSubIFD>0) &&\n                m_nOverviewCount < 30 /* to avoid DoS */ )\n            {\n                GTiffDataset *poODS = new GTiffDataset();\n                poODS->ShareLockWithParentDataset(this);\n                poODS->SetStructuralMDFromParent(this);\n                poODS->m_pszFilename = CPLStrdup(m_pszFilename);\n                if( poODS->OpenOffset( VSI_TIFFOpenChild(m_hTIFF), nThisDir,\n                                    eAccess ) != CE_None\n                    || poODS->GetRasterCount() != GetRasterCount() )\n                {\n                    delete poODS;\n                }\n                else\n                {\n                    CPLDebug( \"GTiff\", \"Opened %dx%d overview.\",\n                            poODS->GetRasterXSize(), poODS->GetRasterYSize());\n                    ++m_nOverviewCount;\n                    m_papoOverviewDS = static_cast<GTiffDataset **>(\n                        CPLRealloc(m_papoOverviewDS,\n                                m_nOverviewCount * (sizeof(void*))) );\n                    m_papoOverviewDS[m_nOverviewCount-1] = poODS;\n                    poODS->m_poBaseDS = this;\n                    poODS->m_bIsOverview = true;\n                }\n            }\n            // Embedded mask of the main image.\n            else if( (nSubType & FILETYPE_MASK) != 0 &&\n                    (nSubType & FILETYPE_REDUCEDIMAGE) == 0 &&\n                    ((nSubIFDs==0 && iDirIndex != 1) || iSubIFD>0) &&\n                    m_poMaskDS == nullptr )\n            {\n                m_poMaskDS = new GTiffDataset();\n                m_poMaskDS->ShareLockWithParentDataset(this);\n                m_poMaskDS->SetStructuralMDFromParent(this);\n                m_poMaskDS->m_pszFilename = CPLStrdup(m_pszFilename);\n\n                // The TIFF6 specification - page 37 - only allows 1\n                // SamplesPerPixel and 1 BitsPerSample Here we support either 1 or\n                // 8 bit per sample and we support either 1 sample per pixel or as\n                // many samples as in the main image We don't check the value of\n                // the PhotometricInterpretation tag, which should be set to\n                // \"Transparency mask\" (4) according to the specification (page\n                // 36).  However, the TIFF6 specification allows image masks to\n                // have a higher resolution than the main image, what we don't\n                // support here.\n\n                if( m_poMaskDS->OpenOffset( VSI_TIFFOpenChild(m_hTIFF), nThisDir,\n                                        eAccess ) != CE_None\n                    || m_poMaskDS->GetRasterCount() == 0\n                    || !(m_poMaskDS->GetRasterCount() == 1\n                        || m_poMaskDS->GetRasterCount() == GetRasterCount())\n                    || m_poMaskDS->GetRasterXSize() != GetRasterXSize()\n                    || m_poMaskDS->GetRasterYSize() != GetRasterYSize()\n                    || m_poMaskDS->GetRasterBand(1)->GetRasterDataType() != GDT_Byte)\n                {\n                    delete m_poMaskDS;\n                    m_poMaskDS = nullptr;\n                }\n                else\n                {\n                    CPLDebug( \"GTiff\", \"Opened band mask.\");\n                    m_poMaskDS->m_poBaseDS = this;\n                    m_poMaskDS->m_poImageryDS = this;\n\n                    m_poMaskDS->m_bPromoteTo8Bits =\n                        CPLTestBool(\n                            CPLGetConfigOption( \"GDAL_TIFF_INTERNAL_MASK_TO_8BIT\",\n                                                \"YES\" ) );\n                }\n            }\n\n            // Embedded mask of an overview.  The TIFF6 specification allows the\n            // combination of the FILETYPE_xxxx masks.\n            else if( (nSubType & FILETYPE_REDUCEDIMAGE) != 0 &&\n                    (nSubType & FILETYPE_MASK) != 0 &&\n                    ((nSubIFDs==0 && iDirIndex != 1) || iSubIFD>0))\n            {\n                GTiffDataset* poDS = new GTiffDataset();\n                poDS->ShareLockWithParentDataset(this);\n                poDS->SetStructuralMDFromParent(this);\n                poDS->m_pszFilename = CPLStrdup(m_pszFilename);\n                if( poDS->OpenOffset( VSI_TIFFOpenChild(m_hTIFF), nThisDir,\n                                    eAccess ) != CE_None\n                    || poDS->GetRasterCount() == 0\n                    || poDS->GetRasterBand(1)->GetRasterDataType() != GDT_Byte)\n                {\n                    delete poDS;\n                }\n                else\n                {\n                    int i = 0;  // Used after for.\n                    for( ; i < m_nOverviewCount; ++i )\n                    {\n                        auto poOvrDS = cpl::down_cast<GTiffDataset*>(\n                                GDALDataset::FromHandle(m_papoOverviewDS[i]));\n                        if( poOvrDS->m_poMaskDS == nullptr &&\n                            poDS->GetRasterXSize() ==\n                            m_papoOverviewDS[i]->GetRasterXSize() &&\n                            poDS->GetRasterYSize() ==\n                            m_papoOverviewDS[i]->GetRasterYSize() &&\n                            (poDS->GetRasterCount() == 1 ||\n                            poDS->GetRasterCount() == GetRasterCount()))\n                        {\n                            CPLDebug(\n                                \"GTiff\", \"Opened band mask for %dx%d overview.\",\n                                poDS->GetRasterXSize(), poDS->GetRasterYSize());\n                            poDS->m_poImageryDS = poOvrDS;\n                            poOvrDS->m_poMaskDS = poDS;\n                            poDS->m_bPromoteTo8Bits =\n                                CPLTestBool(\n                                    CPLGetConfigOption(\n                                        \"GDAL_TIFF_INTERNAL_MASK_TO_8BIT\",\n                                        \"YES\" ) );\n                            poDS->m_poBaseDS = this;\n                            break;\n                        }\n                    }\n                    if( i == m_nOverviewCount )\n                    {\n                        delete poDS;\n                    }\n                }\n            }\n            else if( !m_bSingleIFDOpened && (nSubType == 0 || nSubType == FILETYPE_PAGE) )\n            {\n                uint32 nXSize = 0;\n                uint32 nYSize = 0;\n\n                TIFFGetField( m_hTIFF, TIFFTAG_IMAGEWIDTH, &nXSize );\n                TIFFGetField( m_hTIFF, TIFFTAG_IMAGELENGTH, &nYSize );\n\n                // For Geodetic TIFF grids (GTG)\n                // (https://proj.org/specifications/geodetictiffgrids.html)\n                // extract the grid_name to put it in the description\n                std::string osFriendlyName;\n                char* pszText = nullptr;\n                if( TIFFGetField( m_hTIFF, TIFFTAG_GDAL_METADATA, &pszText ) &&\n                    strstr(pszText, \"grid_name\") != nullptr )\n                {\n                    CPLXMLNode *psRoot = CPLParseXMLString( pszText );\n                    CPLXMLNode *psItem = nullptr;\n\n                    if( psRoot != nullptr && psRoot->eType == CXT_Element\n                        && EQUAL(psRoot->pszValue,\"GDALMetadata\") )\n                        psItem = psRoot->psChild;\n\n                    for( ; psItem != nullptr; psItem = psItem->psNext )\n                    {\n\n                        if( psItem->eType != CXT_Element\n                            || !EQUAL(psItem->pszValue,\"Item\") )\n                            continue;\n\n                        const char *pszKey = CPLGetXMLValue( psItem, \"name\", nullptr );\n                        const char *pszValue = CPLGetXMLValue( psItem, nullptr, nullptr );\n                        int nBand =\n                            atoi(CPLGetXMLValue( psItem, \"sample\", \"-1\" ));\n                        if( pszKey && pszValue && nBand <= 0 &&\n                            EQUAL(pszKey, \"grid_name\") )\n                        {\n                            osFriendlyName = \": \";\n                            osFriendlyName += pszValue;\n                            break;\n                        }\n                    }\n\n                    CPLDestroyXMLNode(psRoot);\n                }\n\n                if( nXSize > INT_MAX || nYSize > INT_MAX )\n                {\n                    CPLDebug(\"GTiff\",\n                            \"Skipping directory with too large image: %u x %u\",\n                            nXSize, nYSize);\n                }\n                else\n                {\n                    uint16 nSPP = 0;\n                    if( !TIFFGetField(m_hTIFF, TIFFTAG_SAMPLESPERPIXEL, &nSPP ) )\n                        nSPP = 1;\n\n                    CPLString osName, osDesc;\n                    osName.Printf( \"SUBDATASET_%d_NAME=GTIFF_DIR:%d:%s\",\n                                iDirIndex, iDirIndex, m_pszFilename );\n                    osDesc.Printf( \"SUBDATASET_%d_DESC=Page %d (%dP x %dL x %dB)\",\n                                iDirIndex, iDirIndex,\n                                static_cast<int>(nXSize),\n                                static_cast<int>(nYSize),\n                                nSPP );\n                    osDesc += osFriendlyName;\n\n                    aosSubdatasets.AddString(osName);\n                    aosSubdatasets.AddString(osDesc);\n                }\n            }\n        }\n        CPLFree(subIFDOffsets);\n\n        // Make sure we are stepping from the expected directory regardless\n        // of churn done processing the above.\n        if( TIFFCurrentDirOffset(m_hTIFF) != nTopDir )\n            TIFFSetSubDirectory( m_hTIFF, nTopDir );\n    } while( !m_bSingleIFDOpened && !TIFFLastDirectory( m_hTIFF ) && TIFFReadDirectory( m_hTIFF ) != 0 );\n\n\n    ReloadDirectory();\n\n    // If we have a mask for the main image, loop over the overviews, and if\n    // they have a mask, let's set this mask as an overview of the main mask.\n    if( m_poMaskDS != nullptr )\n    {\n        for( int i = 0; i < m_nOverviewCount; ++i )\n        {\n            if( cpl::down_cast<GTiffDataset *>(GDALDataset::FromHandle(\n                   m_papoOverviewDS[i]))->m_poMaskDS != nullptr)\n            {\n                ++m_poMaskDS->m_nOverviewCount;\n                m_poMaskDS->m_papoOverviewDS = static_cast<GTiffDataset **>(\n                    CPLRealloc(m_poMaskDS->m_papoOverviewDS,\n                               m_poMaskDS->m_nOverviewCount * (sizeof(void*))) );\n                m_poMaskDS->m_papoOverviewDS[m_poMaskDS->m_nOverviewCount-1] =\n                    cpl::down_cast<GTiffDataset*>(GDALDataset::FromHandle(\n                        m_papoOverviewDS[i]))->m_poMaskDS;\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Only keep track of subdatasets if we have more than one         */\n/*      subdataset (pair).                                              */\n/* -------------------------------------------------------------------- */\n    if( aosSubdatasets.size() > 2 )\n    {\n        m_oGTiffMDMD.SetMetadata( aosSubdatasets.List(), \"SUBDATASETS\" );\n    }\n}\n\nstatic signed char GTiffGetLZMAPreset(char** papszOptions)\n{\n    int nLZMAPreset = -1;\n    const char* pszValue = CSLFetchNameValue( papszOptions, \"LZMA_PRESET\" );\n    if( pszValue != nullptr )\n    {\n        nLZMAPreset = atoi( pszValue );\n        if( !(nLZMAPreset >= 0 && nLZMAPreset <= 9) )\n        {\n            CPLError( CE_Warning, CPLE_IllegalArg,\n                      \"LZMA_PRESET=%s value not recognised, ignoring.\",\n                      pszValue );\n            nLZMAPreset = -1;\n        }\n    }\n    return static_cast<signed char>(nLZMAPreset);\n}\n\nstatic signed char GTiffGetZSTDPreset(char** papszOptions)\n{\n    int nZSTDLevel = -1;\n    const char* pszValue = CSLFetchNameValue( papszOptions, \"ZSTD_LEVEL\" );\n    if( pszValue != nullptr )\n    {\n        nZSTDLevel = atoi( pszValue );\n        if( !(nZSTDLevel >= 1 && nZSTDLevel <= 22) )\n        {\n            CPLError( CE_Warning, CPLE_IllegalArg,\n                      \"ZSTD_LEVEL=%s value not recognised, ignoring.\",\n                      pszValue );\n            nZSTDLevel = -1;\n        }\n    }\n    return static_cast<signed char>(nZSTDLevel);\n}\n\n#if HAVE_LERC\nstatic double GTiffGetLERCMaxZError(char** papszOptions)\n{\n    return CPLAtof(CSLFetchNameValueDef( papszOptions, \"MAX_Z_ERROR\", \"0.0\") );\n}\n#endif\n\nstatic signed char GTiffGetWebPLevel(char** papszOptions)\n{\n    int nWebPLevel = -1;\n    const char* pszValue = CSLFetchNameValue( papszOptions, \"WEBP_LEVEL\" );\n    if( pszValue != nullptr )\n    {\n        nWebPLevel = atoi( pszValue );\n        if( !(nWebPLevel >= 1 && nWebPLevel <= 100) )\n        {\n            CPLError( CE_Warning, CPLE_IllegalArg,\n                      \"WEBP_LEVEL=%s value not recognised, ignoring.\",\n                      pszValue );\n            nWebPLevel = -1;\n        }\n    }\n    return static_cast<signed char>(nWebPLevel);\n}\n\nstatic bool GTiffGetWebPLossless(char** papszOptions)\n{\n    return CPLFetchBool( papszOptions, \"WEBP_LOSSLESS\", false);\n}\n\nstatic signed char GTiffGetZLevel(char** papszOptions)\n{\n    int nZLevel = -1;\n    const char* pszValue = CSLFetchNameValue( papszOptions, \"ZLEVEL\" );\n    if( pszValue != nullptr )\n    {\n        nZLevel = atoi( pszValue );\n#ifdef TIFFTAG_DEFLATE_SUBCODEC\n        constexpr int nMaxLevel = 12;\n#ifndef LIBDEFLATE_SUPPORT\n        if( nZLevel > 9 && nZLevel <= nMaxLevel )\n        {\n            CPLDebug(\"GTiff\",\n                     \"ZLEVEL=%d not supported in a non-libdeflate enabled \"\n                     \"libtiff build. Capping to 9\",\n                     nZLevel);\n            nZLevel = 9;\n        }\n#endif\n#else\n        constexpr int nMaxLevel = 9;\n#endif\n        if( nZLevel < 1 || nZLevel > nMaxLevel )\n        {\n            CPLError( CE_Warning, CPLE_IllegalArg,\n                      \"ZLEVEL=%s value not recognised, ignoring.\",\n                      pszValue );\n            nZLevel = -1;\n        }\n    }\n    return static_cast<signed char>(nZLevel);\n}\n\nstatic signed char GTiffGetJpegQuality(char** papszOptions)\n{\n    int nJpegQuality = -1;\n    const char* pszValue = CSLFetchNameValue( papszOptions, \"JPEG_QUALITY\" );\n    if( pszValue != nullptr )\n    {\n        nJpegQuality = atoi( pszValue );\n        if( nJpegQuality < 1 || nJpegQuality > 100 )\n        {\n            CPLError( CE_Warning, CPLE_IllegalArg,\n                      \"JPEG_QUALITY=%s value not recognised, ignoring.\",\n                      pszValue );\n            nJpegQuality = -1;\n        }\n    }\n    return static_cast<signed char>(nJpegQuality);\n}\n\nstatic signed char GTiffGetJpegTablesMode(char** papszOptions)\n{\n    return static_cast<signed char>(\n        atoi(CSLFetchNameValueDef( papszOptions, \"JPEGTABLESMODE\",\n                                      CPLSPrintf(\"%d\",\n                                                knGTIFFJpegTablesModeDefault))));\n}\n\n/************************************************************************/\n/*                        GetDiscardLsbOption()                         */\n/************************************************************************/\n\nvoid GTiffDataset::GetDiscardLsbOption(char** papszOptions)\n{\n    const char* pszBits = CSLFetchNameValue( papszOptions, \"DISCARD_LSB\" );\n    if( pszBits == nullptr)\n        return;\n\n    if( m_nPhotometric == PHOTOMETRIC_PALETTE )\n    {\n        ReportError(CE_Warning, CPLE_AppDefined,\n                 \"DISCARD_LSB ignored on a paletted image\");\n        return;\n    }\n    if( !(m_nBitsPerSample == 8 || m_nBitsPerSample == 16 || m_nBitsPerSample == 32) )\n    {\n        ReportError(CE_Warning, CPLE_AppDefined,\n                 \"DISCARD_LSB ignored on non 8, 16 or 32 bits integer images\");\n        return;\n    }\n\n    char** papszTokens = CSLTokenizeString2( pszBits, \",\", 0 );\n    const int nTokens = CSLCount(papszTokens);\n    if( nTokens == 1 || nTokens == nBands )\n    {\n        m_panMaskOffsetLsb = static_cast<MaskOffset*>(CPLCalloc(nBands, sizeof(MaskOffset)));\n        for( int i = 0; i < nBands; ++i )\n        {\n            int nBits = atoi(papszTokens[nTokens == 1 ? 0 : i]);\n            m_panMaskOffsetLsb[i].nMask = ~((1 << nBits)-1);\n            if( nBits > 1 )\n                m_panMaskOffsetLsb[i].nOffset = 1 << (nBits - 1);\n        }\n    }\n    else\n    {\n        ReportError(CE_Warning, CPLE_AppDefined,\n                 \"DISCARD_LSB ignored: wrong number of components\");\n    }\n    CSLDestroy(papszTokens);\n}\n\n/************************************************************************/\n/*                             GetProfile()                             */\n/************************************************************************/\n\nstatic GTiffProfile GetProfile(const char* pszProfile)\n{\n    GTiffProfile eProfile = GTiffProfile::GDALGEOTIFF;\n    if( pszProfile != nullptr )\n    {\n        if( EQUAL(pszProfile, szPROFILE_BASELINE) )\n            eProfile = GTiffProfile::BASELINE;\n        else if( EQUAL(pszProfile, szPROFILE_GeoTIFF) )\n            eProfile = GTiffProfile::GEOTIFF;\n        else if( !EQUAL(pszProfile, szPROFILE_GDALGeoTIFF) )\n        {\n            CPLError(CE_Warning, CPLE_NotSupported,\n                     \"Unsupported value for PROFILE: %s\", pszProfile);\n        }\n    }\n    return eProfile;\n}\n\n/************************************************************************/\n/*                            GTiffCreate()                             */\n/*                                                                      */\n/*      Shared functionality between GTiffDataset::Create() and         */\n/*      GTiffCreateCopy() for creating TIFF file based on a set of      */\n/*      options and a configuration.                                    */\n/************************************************************************/\n\nTIFF *GTiffDataset::CreateLL( const char * pszFilename,\n                              int nXSize, int nYSize, int l_nBands,\n                              GDALDataType eType,\n                              double dfExtraSpaceForOverviews,\n                              char **papszParmList,\n                              VSILFILE** pfpL,\n                              CPLString& l_osTmpFilename )\n\n{\n    if( !GTiffOneTimeInit() )\n        return nullptr;\n\n/* -------------------------------------------------------------------- */\n/*      Blow on a few errors.                                           */\n/* -------------------------------------------------------------------- */\n    if( nXSize < 1 || nYSize < 1 || l_nBands < 1 )\n    {\n        ReportError( pszFilename, CE_Failure, CPLE_AppDefined,\n            \"Attempt to create %dx%dx%d TIFF file, but width, height and bands\"\n            \"must be positive.\",\n            nXSize, nYSize, l_nBands );\n\n        return nullptr;\n    }\n\n    if( l_nBands > 65535 )\n    {\n        ReportError(pszFilename, CE_Failure, CPLE_AppDefined,\n                  \"Attempt to create %dx%dx%d TIFF file, but bands \"\n                  \"must be lesser or equal to 65535.\",\n                  nXSize, nYSize, l_nBands );\n\n        return nullptr;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Setup values based on options.                                  */\n/* -------------------------------------------------------------------- */\n    const GTiffProfile eProfile = GetProfile(\n        CSLFetchNameValue(papszParmList, \"PROFILE\"));\n\n    const bool bTiled = CPLFetchBool( papszParmList, \"TILED\", false );\n\n    int l_nBlockXSize = 0;\n    const char *pszValue = CSLFetchNameValue(papszParmList, \"BLOCKXSIZE\");\n    if( pszValue != nullptr )\n    {\n        l_nBlockXSize = atoi( pszValue );\n        if( l_nBlockXSize < 0 )\n        {\n            ReportError( pszFilename,CE_Failure, CPLE_IllegalArg,\n                     \"Invalid value for BLOCKXSIZE\");\n            return nullptr;\n        }\n    }\n\n    int l_nBlockYSize = 0;\n    pszValue = CSLFetchNameValue(papszParmList, \"BLOCKYSIZE\");\n    if( pszValue != nullptr )\n    {\n        l_nBlockYSize = atoi( pszValue );\n        if( l_nBlockYSize < 0 )\n        {\n            ReportError( pszFilename, CE_Failure, CPLE_IllegalArg,\n                     \"Invalid value for BLOCKYSIZE\");\n            return nullptr;\n        }\n    }\n\n    if( bTiled )\n    {\n        if( l_nBlockXSize == 0 )\n            l_nBlockXSize = 256;\n\n        if( l_nBlockYSize == 0 )\n            l_nBlockYSize = 256;\n    }\n\n    int nPlanar = 0;\n    pszValue = CSLFetchNameValue(papszParmList, \"INTERLEAVE\");\n    if( pszValue != nullptr )\n    {\n        if( EQUAL( pszValue, \"PIXEL\" ) )\n            nPlanar = PLANARCONFIG_CONTIG;\n        else if( EQUAL( pszValue, \"BAND\" ) )\n        {\n            nPlanar = PLANARCONFIG_SEPARATE;\n        }\n        else\n        {\n            ReportError( pszFilename,CE_Failure, CPLE_IllegalArg, \n                      \"INTERLEAVE=%s unsupported, value must be PIXEL or BAND.\",\n                      pszValue );\n            return nullptr;\n        }\n    }\n    else\n    {\n        nPlanar = PLANARCONFIG_CONTIG;\n    }\n\n    int l_nCompression = COMPRESSION_NONE;\n    pszValue = CSLFetchNameValue( papszParmList, \"COMPRESS\" );\n    if( pszValue != nullptr )\n    {\n        l_nCompression = GTIFFGetCompressionMethod(pszValue, \"COMPRESS\");\n        if( l_nCompression < 0 )\n            return nullptr;\n    }\n\n    int nPredictor = PREDICTOR_NONE;\n    pszValue = CSLFetchNameValue( papszParmList, \"PREDICTOR\" );\n    if( pszValue != nullptr )\n        nPredictor = atoi( pszValue );\n\n    const int l_nZLevel = GTiffGetZLevel(papszParmList);\n    const int l_nLZMAPreset = GTiffGetLZMAPreset(papszParmList);\n    const int l_nZSTDLevel = GTiffGetZSTDPreset(papszParmList);\n    const int l_nWebPLevel = GTiffGetWebPLevel(papszParmList);\n    const bool l_bWebPLossless = GTiffGetWebPLossless(papszParmList);\n    const int l_nJpegQuality = GTiffGetJpegQuality(papszParmList);\n    const int l_nJpegTablesMode = GTiffGetJpegTablesMode(papszParmList);\n#if HAVE_LERC\n    const double l_dfMaxZError = GTiffGetLERCMaxZError(papszParmList);\n#endif\n\n/* -------------------------------------------------------------------- */\n/*      Streaming related code                                          */\n/* -------------------------------------------------------------------- */\n    const CPLString osOriFilename(pszFilename);\n    bool bStreaming =\n        strcmp(pszFilename, \"/vsistdout/\") == 0 ||\n        CPLFetchBool(papszParmList, \"STREAMABLE_OUTPUT\", false);\n#ifdef S_ISFIFO\n    if( !bStreaming )\n    {\n        VSIStatBufL sStat;\n        if( VSIStatExL( pszFilename, &sStat,\n                        VSI_STAT_EXISTS_FLAG | VSI_STAT_NATURE_FLAG) == 0 &&\n             S_ISFIFO(sStat.st_mode) )\n        {\n            bStreaming = true;\n        }\n    }\n#endif\n    if( bStreaming &&\n        !EQUAL( \"NONE\",\n                CSLFetchNameValueDef(papszParmList, \"COMPRESS\", \"NONE\")) )\n    {\n        ReportError( pszFilename, CE_Failure, CPLE_NotSupported,\n            \"Streaming only supported to uncompressed TIFF\" );\n        return nullptr;\n    }\n    if( bStreaming && CPLFetchBool(papszParmList, \"SPARSE_OK\", false) )\n    {\n        ReportError( pszFilename, CE_Failure, CPLE_NotSupported,\n            \"Streaming not supported with SPARSE_OK\" );\n        return nullptr;\n    }\n    const bool bCopySrcOverviews = CPLFetchBool(papszParmList, \"COPY_SRC_OVERVIEWS\", false);\n    if( bStreaming && bCopySrcOverviews )\n    {\n        ReportError( pszFilename, CE_Failure, CPLE_NotSupported,\n            \"Streaming not supported with COPY_SRC_OVERVIEWS\" );\n        return nullptr;\n    }\n    if( bStreaming )\n    {\n        static int nCounter = 0;\n        l_osTmpFilename = CPLSPrintf(\"/vsimem/vsistdout_%d.tif\", ++nCounter);\n        pszFilename = l_osTmpFilename.c_str();\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Compute the uncompressed size.                                  */\n/* -------------------------------------------------------------------- */\n    const double dfUncompressedImageSize =\n        nXSize * static_cast<double>(nYSize) * l_nBands *\n        GDALGetDataTypeSizeBytes(eType)\n        + dfExtraSpaceForOverviews;\n\n/* -------------------------------------------------------------------- */\n/*      Should the file be created as a bigtiff file?                   */\n/* -------------------------------------------------------------------- */\n    const char *pszBIGTIFF = CSLFetchNameValue(papszParmList, \"BIGTIFF\");\n\n    if( pszBIGTIFF == nullptr )\n        pszBIGTIFF = \"IF_NEEDED\";\n\n    bool bCreateBigTIFF = false;\n    if( EQUAL(pszBIGTIFF, \"IF_NEEDED\") )\n    {\n        if( l_nCompression == COMPRESSION_NONE\n            && dfUncompressedImageSize > 4200000000.0 )\n            bCreateBigTIFF = true;\n    }\n    else if( EQUAL(pszBIGTIFF, \"IF_SAFER\") )\n    {\n        if( dfUncompressedImageSize > 2000000000.0 )\n            bCreateBigTIFF = true;\n    }\n    else\n    {\n        bCreateBigTIFF = CPLTestBool( pszBIGTIFF );\n        if( !bCreateBigTIFF && l_nCompression == COMPRESSION_NONE &&\n             dfUncompressedImageSize > 4200000000.0 )\n        {\n            ReportError( pszFilename, CE_Failure, CPLE_NotSupported,\n                \"The TIFF file will be larger than 4GB, so BigTIFF is \"\n                \"necessary.  Creation failed.\");\n            return nullptr;\n        }\n    }\n\n    if( bCreateBigTIFF )\n        CPLDebug( \"GTiff\", \"File being created as a BigTIFF.\" );\n\n/* -------------------------------------------------------------------- */\n/*      Sanity check.                                                   */\n/* -------------------------------------------------------------------- */\n    if( bTiled )\n    {\n        unsigned nTileXCount = DIV_ROUND_UP(nXSize, l_nBlockXSize);\n        unsigned nTileYCount = DIV_ROUND_UP(nYSize, l_nBlockYSize);\n        // libtiff implementation limitation\n        if( nTileXCount > 0x80000000U / (bCreateBigTIFF ? 8 : 4) / nTileYCount )\n        {\n            ReportError( pszFilename, CE_Failure, CPLE_NotSupported,\n                     \"File too large regarding tile size. This would result \"\n                     \"in a file with tile arrays larger than 2GB\");\n            return nullptr;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Check free space (only for big, non sparse, uncompressed)       */\n/* -------------------------------------------------------------------- */\n    if( l_nCompression == COMPRESSION_NONE &&\n        dfUncompressedImageSize >= 1e9 &&\n        !CPLFetchBool(papszParmList, \"SPARSE_OK\", false) &&\n        osOriFilename != \"/vsistdout/\" &&\n        osOriFilename != \"/vsistdout_redirect/\" &&\n        CPLTestBool(CPLGetConfigOption(\"CHECK_DISK_FREE_SPACE\", \"TRUE\")) )\n    {\n        GIntBig nFreeDiskSpace =\n            VSIGetDiskFreeSpace(CPLGetDirname(pszFilename));\n        if( nFreeDiskSpace >= 0 &&\n            nFreeDiskSpace < dfUncompressedImageSize )\n        {\n            ReportError( pszFilename, CE_Failure, CPLE_FileIO,\n                      \"Free disk space available is \" CPL_FRMT_GIB \" bytes, \"\n                      \"whereas \" CPL_FRMT_GIB \" are at least necessary. \"\n                      \"You can disable this check by defining the \"\n                      \"CHECK_DISK_FREE_SPACE configuration option to FALSE.\",\n                      nFreeDiskSpace,\n                      static_cast<GIntBig>(dfUncompressedImageSize) );\n            return nullptr;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Check if the user wishes a particular endianness                */\n/* -------------------------------------------------------------------- */\n\n    int eEndianness = ENDIANNESS_NATIVE;\n    pszValue = CSLFetchNameValue(papszParmList, \"ENDIANNESS\");\n    if( pszValue == nullptr )\n        pszValue = CPLGetConfigOption( \"GDAL_TIFF_ENDIANNESS\", nullptr );\n    if( pszValue != nullptr )\n    {\n        if( EQUAL(pszValue, \"LITTLE\") )\n        {\n            eEndianness = ENDIANNESS_LITTLE;\n        }\n        else if( EQUAL(pszValue, \"BIG\") )\n        {\n            eEndianness = ENDIANNESS_BIG;\n        }\n        else if( EQUAL(pszValue, \"INVERTED\") )\n        {\n#ifdef CPL_LSB\n            eEndianness = ENDIANNESS_BIG;\n#else\n            eEndianness = ENDIANNESS_LITTLE;\n#endif\n        }\n        else if( !EQUAL(pszValue, \"NATIVE\") )\n        {\n            ReportError( pszFilename, CE_Warning, CPLE_NotSupported,\n                \"ENDIANNESS=%s not supported. Defaulting to NATIVE\", pszValue );\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Try opening the dataset.                                        */\n/* -------------------------------------------------------------------- */\n\n    const bool bAppend = CPLFetchBool(papszParmList, \"APPEND_SUBDATASET\", false);\n\n    char szOpeningFlag[5] = {};\n    strcpy(szOpeningFlag, bAppend ? \"r+\" : \"w+\");\n    if( bCreateBigTIFF )\n        strcat(szOpeningFlag, \"8\");\n    if( eEndianness == ENDIANNESS_BIG )\n        strcat(szOpeningFlag, \"b\");\n    else if( eEndianness == ENDIANNESS_LITTLE )\n        strcat(szOpeningFlag, \"l\");\n\n    VSILFILE* l_fpL = VSIFOpenL( pszFilename, bAppend ? \"r+b\" : \"w+b\" );\n    if( l_fpL == nullptr )\n    {\n        CPLError( CE_Failure, CPLE_OpenFailed,\n                  \"Attempt to create new tiff file `%s' failed: %s\",\n                  pszFilename, VSIStrerror(errno) );\n        return nullptr;\n    }\n    TIFF *l_hTIFF = VSI_TIFFOpen( pszFilename, szOpeningFlag, l_fpL );\n    if( l_hTIFF == nullptr )\n    {\n        if( CPLGetLastErrorNo() == 0 )\n            CPLError( CE_Failure, CPLE_OpenFailed,\n                      \"Attempt to create new tiff file `%s' \"\n                      \"failed in XTIFFOpen().\",\n                      pszFilename );\n        CPL_IGNORE_RET_VAL(VSIFCloseL(l_fpL));\n        return nullptr;\n    }\n\n    if( bAppend )\n    {\n        // This is a bit of a hack to cause (*tif->tif_cleanup)(tif); to be called.\n        // See https://trac.osgeo.org/gdal/ticket/2055\n        TIFFSetField( l_hTIFF, TIFFTAG_COMPRESSION, COMPRESSION_NONE );\n        TIFFFreeDirectory( l_hTIFF );\n        TIFFCreateDirectory( l_hTIFF );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      How many bits per sample?  We have a special case if NBITS      */\n/*      specified for GDT_Byte, GDT_UInt16, GDT_UInt32.                 */\n/* -------------------------------------------------------------------- */\n    int l_nBitsPerSample = GDALGetDataTypeSizeBits(eType);\n    if( CSLFetchNameValue(papszParmList, \"NBITS\") != nullptr )\n    {\n        int nMinBits = 0;\n        int nMaxBits = 0;\n        l_nBitsPerSample = atoi(CSLFetchNameValue(papszParmList, \"NBITS\"));\n        if( eType == GDT_Byte )\n        {\n            nMinBits = 1;\n            nMaxBits = 8;\n        }\n        else if( eType == GDT_UInt16 )\n        {\n            nMinBits = 9;\n            nMaxBits = 16;\n        }\n        else if( eType == GDT_UInt32 )\n        {\n            nMinBits = 17;\n            nMaxBits = 32;\n        }\n        else if( eType == GDT_Float32 )\n        {\n            if( l_nBitsPerSample != 16 && l_nBitsPerSample != 32 )\n            {\n                ReportError( pszFilename, CE_Warning, CPLE_NotSupported,\n                     \"Only NBITS=16 is supported for data type Float32\");\n                l_nBitsPerSample = GDALGetDataTypeSizeBits(eType);\n            }\n        }\n        else\n        {\n            ReportError( pszFilename, CE_Warning, CPLE_NotSupported,\n                     \"NBITS is not supported for data type %s\",\n                     GDALGetDataTypeName(eType));\n            l_nBitsPerSample = GDALGetDataTypeSizeBits(eType);\n        }\n\n        if( nMinBits != 0 )\n        {\n            if( l_nBitsPerSample < nMinBits )\n            {\n                ReportError( pszFilename,CE_Warning, CPLE_AppDefined,\n                         \"NBITS=%d is invalid for data type %s. Using NBITS=%d\",\n                         l_nBitsPerSample, GDALGetDataTypeName(eType),\n                         nMinBits);\n                l_nBitsPerSample = nMinBits;\n            }\n            else if( l_nBitsPerSample > nMaxBits )\n            {\n                ReportError( pszFilename,CE_Warning, CPLE_AppDefined,\n                         \"NBITS=%d is invalid for data type %s. Using NBITS=%d\",\n                         l_nBitsPerSample, GDALGetDataTypeName(eType),\n                         nMaxBits);\n                l_nBitsPerSample = nMaxBits;\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Do we have a custom pixel type (just used for signed byte now). */\n/* -------------------------------------------------------------------- */\n    const char *pszPixelType = CSLFetchNameValue( papszParmList, \"PIXELTYPE\" );\n    if( pszPixelType == nullptr )\n        pszPixelType = \"\";\n\n/* -------------------------------------------------------------------- */\n/*      Setup some standard flags.                                      */\n/* -------------------------------------------------------------------- */\n    TIFFSetField( l_hTIFF, TIFFTAG_IMAGEWIDTH, nXSize );\n    TIFFSetField( l_hTIFF, TIFFTAG_IMAGELENGTH, nYSize );\n    TIFFSetField( l_hTIFF, TIFFTAG_BITSPERSAMPLE, l_nBitsPerSample );\n\n    uint16 l_nSampleFormat = 0;\n    if( (eType == GDT_Byte && EQUAL(pszPixelType,\"SIGNEDBYTE\"))\n        || eType == GDT_Int16 || eType == GDT_Int32 )\n        l_nSampleFormat = SAMPLEFORMAT_INT;\n    else if( eType == GDT_CInt16 || eType == GDT_CInt32 )\n        l_nSampleFormat = SAMPLEFORMAT_COMPLEXINT;\n    else if( eType == GDT_Float32 || eType == GDT_Float64 )\n        l_nSampleFormat = SAMPLEFORMAT_IEEEFP;\n    else if( eType == GDT_CFloat32 || eType == GDT_CFloat64 )\n        l_nSampleFormat = SAMPLEFORMAT_COMPLEXIEEEFP;\n    else\n        l_nSampleFormat = SAMPLEFORMAT_UINT;\n\n    TIFFSetField( l_hTIFF, TIFFTAG_SAMPLEFORMAT, l_nSampleFormat );\n    TIFFSetField( l_hTIFF, TIFFTAG_SAMPLESPERPIXEL, l_nBands );\n    TIFFSetField( l_hTIFF, TIFFTAG_PLANARCONFIG, nPlanar );\n\n/* -------------------------------------------------------------------- */\n/*      Setup Photometric Interpretation. Take this value from the user */\n/*      passed option or guess correct value otherwise.                 */\n/* -------------------------------------------------------------------- */\n    int nSamplesAccountedFor = 1;\n    bool bForceColorTable = false;\n\n    pszValue = CSLFetchNameValue(papszParmList,\"PHOTOMETRIC\");\n    if( pszValue != nullptr )\n    {\n        if( EQUAL( pszValue, \"MINISBLACK\" ) )\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC,\n                          PHOTOMETRIC_MINISBLACK );\n        else if( EQUAL( pszValue, \"MINISWHITE\" ) )\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC,\n                          PHOTOMETRIC_MINISWHITE );\n        }\n        else if( EQUAL( pszValue, \"PALETTE\" ))\n        {\n            if( eType == GDT_Byte || eType == GDT_UInt16 )\n            {\n                TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC,\n                              PHOTOMETRIC_PALETTE );\n                nSamplesAccountedFor = 1;\n                bForceColorTable = true;\n            }\n            else\n            {\n                ReportError( pszFilename,CE_Warning, CPLE_AppDefined,\n                    \"PHOTOMETRIC=PALETTE only compatible with Byte or UInt16\" );\n            }\n        }\n        else if( EQUAL( pszValue, \"RGB\" ))\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB );\n            nSamplesAccountedFor = 3;\n        }\n        else if( EQUAL( pszValue, \"CMYK\" ))\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_SEPARATED );\n            nSamplesAccountedFor = 4;\n        }\n        else if( EQUAL( pszValue, \"YCBCR\" ))\n        {\n            // Because of subsampling, setting YCBCR without JPEG compression\n            // leads to a crash currently. Would need to make\n            // GTiffRasterBand::IWriteBlock() aware of subsampling so that it\n            // doesn't overrun buffer size returned by libtiff.\n            if( l_nCompression != COMPRESSION_JPEG )\n            {\n                ReportError( pszFilename, CE_Failure, CPLE_NotSupported,\n                         \"Currently, PHOTOMETRIC=YCBCR requires COMPRESS=JPEG\");\n                XTIFFClose(l_hTIFF);\n                CPL_IGNORE_RET_VAL(VSIFCloseL(l_fpL));\n                return nullptr;\n            }\n\n            if( nPlanar == PLANARCONFIG_SEPARATE )\n            {\n                ReportError( pszFilename, CE_Failure, CPLE_NotSupported,\n                         \"PHOTOMETRIC=YCBCR requires INTERLEAVE=PIXEL\");\n                XTIFFClose(l_hTIFF);\n                CPL_IGNORE_RET_VAL(VSIFCloseL(l_fpL));\n                return nullptr;\n            }\n\n            // YCBCR strictly requires 3 bands. Not less, not more Issue an\n            // explicit error message as libtiff one is a bit cryptic:\n            // TIFFVStripSize64:Invalid td_samplesperpixel value.\n            if( l_nBands != 3 )\n            {\n                ReportError( pszFilename, CE_Failure, CPLE_NotSupported,\n                    \"PHOTOMETRIC=YCBCR not supported on a %d-band raster: \"\n                    \"only compatible of a 3-band (RGB) raster\", l_nBands );\n                XTIFFClose(l_hTIFF);\n                CPL_IGNORE_RET_VAL(VSIFCloseL(l_fpL));\n                return nullptr;\n            }\n\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR );\n            nSamplesAccountedFor = 3;\n\n            // Explicitly register the subsampling so that JPEGFixupTags\n            // is a no-op (helps for cloud optimized geotiffs)\n            TIFFSetField( l_hTIFF, TIFFTAG_YCBCRSUBSAMPLING, 2, 2 );\n        }\n        else if( EQUAL( pszValue, \"CIELAB\" ))\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_CIELAB );\n            nSamplesAccountedFor = 3;\n        }\n        else if( EQUAL( pszValue, \"ICCLAB\" ))\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_ICCLAB );\n            nSamplesAccountedFor = 3;\n        }\n        else if( EQUAL( pszValue, \"ITULAB\" ))\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_ITULAB );\n            nSamplesAccountedFor = 3;\n        }\n        else\n        {\n            ReportError( pszFilename,CE_Warning, CPLE_IllegalArg,\n                      \"PHOTOMETRIC=%s value not recognised, ignoring.  \"\n                      \"Set the Photometric Interpretation as MINISBLACK.\",\n                      pszValue );\n            TIFFSetField(l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n        }\n\n        if( l_nBands < nSamplesAccountedFor )\n        {\n            ReportError( pszFilename,CE_Warning, CPLE_IllegalArg,\n                      \"PHOTOMETRIC=%s value does not correspond to number \"\n                      \"of bands (%d), ignoring.  \"\n                      \"Set the Photometric Interpretation as MINISBLACK.\",\n                      pszValue, l_nBands );\n            TIFFSetField(l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n        }\n    }\n    else\n    {\n        // If image contains 3 or 4 bands and datatype is Byte then we will\n        // assume it is RGB. In all other cases assume it is MINISBLACK.\n        if( l_nBands == 3 && eType == GDT_Byte )\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB );\n            nSamplesAccountedFor = 3;\n        }\n        else if( l_nBands == 4 && eType == GDT_Byte )\n        {\n            uint16 v[1] = {\n                GTiffGetAlphaValue(CSLFetchNameValue(papszParmList, \"ALPHA\"),\n                                   DEFAULT_ALPHA_TYPE)\n            };\n\n            TIFFSetField( l_hTIFF, TIFFTAG_EXTRASAMPLES, 1, v);\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB );\n            nSamplesAccountedFor = 4;\n        }\n        else\n        {\n            TIFFSetField(l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n            nSamplesAccountedFor = 1;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If there are extra samples, we need to mark them with an        */\n/*      appropriate extrasamples definition here.                       */\n/* -------------------------------------------------------------------- */\n    if( l_nBands > nSamplesAccountedFor )\n    {\n        const int nExtraSamples = l_nBands - nSamplesAccountedFor;\n\n        uint16 *v = static_cast<uint16 *>(\n            CPLMalloc( sizeof(uint16) * nExtraSamples ) );\n\n        v[0] = GTiffGetAlphaValue( CSLFetchNameValue(papszParmList, \"ALPHA\"),\n                                   EXTRASAMPLE_UNSPECIFIED );\n\n        for( int i = 1; i < nExtraSamples; ++i )\n            v[i] = EXTRASAMPLE_UNSPECIFIED;\n\n        TIFFSetField(l_hTIFF, TIFFTAG_EXTRASAMPLES, nExtraSamples, v );\n\n        CPLFree(v);\n    }\n\n    // Set the ICC color profile.\n    if( eProfile != GTiffProfile::BASELINE )\n    {\n        SaveICCProfile(nullptr, l_hTIFF, papszParmList, l_nBitsPerSample);\n    }\n\n    // Set the compression method before asking the default strip size\n    // This is useful when translating to a JPEG-In-TIFF file where\n    // the default strip size is 8 or 16 depending on the photometric value.\n    TIFFSetField( l_hTIFF, TIFFTAG_COMPRESSION, l_nCompression );\n\n#if HAVE_LERC\n    if( l_nCompression == COMPRESSION_LERC )\n    {\n        const char* pszCompress =\n            CSLFetchNameValueDef( papszParmList, \"COMPRESS\", \"\" );\n        if( EQUAL(pszCompress , \"LERC_DEFLATE\" ) )\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_LERC_ADD_COMPRESSION,\n                        LERC_ADD_COMPRESSION_DEFLATE );\n        }\n        else if( EQUAL(pszCompress, \"LERC_ZSTD\" ) )\n        {\n            if( TIFFSetField( l_hTIFF, TIFFTAG_LERC_ADD_COMPRESSION,\n                            LERC_ADD_COMPRESSION_ZSTD ) != 1 )\n            {\n                XTIFFClose(l_hTIFF);\n                CPL_IGNORE_RET_VAL(VSIFCloseL(l_fpL));\n                return nullptr;\n            }\n        }\n    }\n    // TODO later: take into account LERC version\n#endif\n\n/* -------------------------------------------------------------------- */\n/*      Setup tiling/stripping flags.                                   */\n/* -------------------------------------------------------------------- */\n    if( bTiled )\n    {\n        if( !TIFFSetField( l_hTIFF, TIFFTAG_TILEWIDTH, l_nBlockXSize ) ||\n            !TIFFSetField( l_hTIFF, TIFFTAG_TILELENGTH, l_nBlockYSize ) )\n        {\n            XTIFFClose(l_hTIFF);\n            CPL_IGNORE_RET_VAL(VSIFCloseL(l_fpL));\n            return nullptr;\n        }\n    }\n    else\n    {\n        const uint32 l_nRowsPerStrip = std::min(nYSize,\n            l_nBlockYSize == 0\n            ? static_cast<int>(TIFFDefaultStripSize(l_hTIFF,0))\n            : l_nBlockYSize );\n\n        TIFFSetField( l_hTIFF, TIFFTAG_ROWSPERSTRIP, l_nRowsPerStrip );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Set compression related tags.                                   */\n/* -------------------------------------------------------------------- */\n    if( l_nCompression == COMPRESSION_LZW ||\n         l_nCompression == COMPRESSION_ADOBE_DEFLATE ||\n         l_nCompression == COMPRESSION_ZSTD )\n        TIFFSetField( l_hTIFF, TIFFTAG_PREDICTOR, nPredictor );\n    if( l_nCompression == COMPRESSION_ADOBE_DEFLATE ||\n        l_nCompression == COMPRESSION_LERC )\n    {\n        GTiffSetDeflateSubCodec(l_hTIFF);\n\n        if( l_nZLevel != -1 )\n            TIFFSetField( l_hTIFF, TIFFTAG_ZIPQUALITY, l_nZLevel );\n    }\n    if( l_nCompression == COMPRESSION_JPEG && l_nJpegQuality != -1 )\n        TIFFSetField( l_hTIFF, TIFFTAG_JPEGQUALITY, l_nJpegQuality );\n    if( l_nCompression == COMPRESSION_LZMA && l_nLZMAPreset != -1)\n        TIFFSetField( l_hTIFF, TIFFTAG_LZMAPRESET, l_nLZMAPreset );\n    if( (l_nCompression == COMPRESSION_ZSTD ||\n         l_nCompression == COMPRESSION_LERC) && l_nZSTDLevel != -1)\n        TIFFSetField( l_hTIFF, TIFFTAG_ZSTD_LEVEL, l_nZSTDLevel);\n#if HAVE_LERC\n    if( l_nCompression == COMPRESSION_LERC )\n    {\n        TIFFSetField( l_hTIFF, TIFFTAG_LERC_MAXZERROR, l_dfMaxZError );\n    }\n#endif\n    if( l_nCompression == COMPRESSION_WEBP && l_nWebPLevel != -1)\n        TIFFSetField( l_hTIFF, TIFFTAG_WEBP_LEVEL, l_nWebPLevel);\n    if( l_nCompression == COMPRESSION_WEBP && l_bWebPLossless)\n        TIFFSetField( l_hTIFF, TIFFTAG_WEBP_LOSSLESS, 1);\n\n    if( l_nCompression == COMPRESSION_JPEG )\n        TIFFSetField( l_hTIFF, TIFFTAG_JPEGTABLESMODE, l_nJpegTablesMode );\n\n/* -------------------------------------------------------------------- */\n/*      If we forced production of a file with photometric=palette,     */\n/*      we need to push out a default color table.                      */\n/* -------------------------------------------------------------------- */\n    if( bForceColorTable )\n    {\n        const int nColors = eType == GDT_Byte ? 256 : 65536;\n\n        unsigned short *panTRed = static_cast<unsigned short *>(\n            CPLMalloc(sizeof(unsigned short)*nColors) );\n        unsigned short *panTGreen = static_cast<unsigned short *>(\n            CPLMalloc(sizeof(unsigned short)*nColors) );\n        unsigned short *panTBlue = static_cast<unsigned short *>(\n            CPLMalloc(sizeof(unsigned short)*nColors) );\n\n        for( int iColor = 0; iColor < nColors; ++iColor )\n        {\n            if( eType == GDT_Byte )\n            {\n                panTRed[iColor] = static_cast<unsigned short>(257 * iColor);\n                panTGreen[iColor] = static_cast<unsigned short>(257 * iColor);\n                panTBlue[iColor] = static_cast<unsigned short>(257 * iColor);\n            }\n            else\n            {\n                panTRed[iColor] = static_cast<unsigned short>(iColor);\n                panTGreen[iColor] = static_cast<unsigned short>(iColor);\n                panTBlue[iColor] = static_cast<unsigned short>(iColor);\n            }\n        }\n\n        TIFFSetField( l_hTIFF, TIFFTAG_COLORMAP,\n                      panTRed, panTGreen, panTBlue );\n\n        CPLFree( panTRed );\n        CPLFree( panTGreen );\n        CPLFree( panTBlue );\n    }\n\n    // This trick\n    // creates a temporary in-memory file and fetches its JPEG tables so that\n    // we can directly set them, before tif_jpeg.c compute them at the first\n    // strip/tile writing, which is too late, since we have already crystalized\n    // the directory. This way we avoid a directory rewriting.\n    if( l_nCompression == COMPRESSION_JPEG &&\n        !STARTS_WITH(pszFilename, szJPEGGTiffDatasetTmpPrefix) &&\n        CPLTestBool(\n            CSLFetchNameValueDef(papszParmList, \"WRITE_JPEGTABLE_TAG\", \"YES\")) )\n    {\n        GTiffWriteJPEGTables( l_hTIFF,\n                              CSLFetchNameValue(papszParmList, \"PHOTOMETRIC\"),\n                              CSLFetchNameValue(papszParmList, \"JPEG_QUALITY\"),\n                              CSLFetchNameValue(papszParmList,\n                                                \"JPEGTABLESMODE\") );\n    }\n\n    *pfpL = l_fpL;\n\n    return l_hTIFF;\n}\n\n/************************************************************************/\n/*                      GTiffWriteJPEGTables()                          */\n/*                                                                      */\n/*      Sets the TIFFTAG_JPEGTABLES (and TIFFTAG_REFERENCEBLACKWHITE)   */\n/*      tags immediately, instead of relying on the TIFF JPEG codec     */\n/*      to write them when it starts compressing imagery. This avoids   */\n/*      an IFD rewrite at the end of the file.                          */\n/*      Must be used after having set TIFFTAG_SAMPLESPERPIXEL,          */\n/*      TIFFTAG_BITSPERSAMPLE.                                          */\n/************************************************************************/\n\nvoid GTiffWriteJPEGTables( TIFF* hTIFF,\n                           const char* pszPhotometric,\n                           const char* pszJPEGQuality,\n                           const char* pszJPEGTablesMode )\n{\n    // This trick\n    // creates a temporary in-memory file and fetches its JPEG tables so that\n    // we can directly set them, before tif_jpeg.c compute them at the first\n    // strip/tile writing, which is too late, since we have already crystalized\n    // the directory. This way we avoid a directory rewriting.\n    uint16 nBands = 0;\n    if( !TIFFGetField( hTIFF, TIFFTAG_SAMPLESPERPIXEL,\n                        &nBands ) )\n        nBands = 1;\n\n    uint16 l_nBitsPerSample = 0;\n    if( !TIFFGetField(hTIFF, TIFFTAG_BITSPERSAMPLE,\n                        &(l_nBitsPerSample)) )\n        l_nBitsPerSample = 1;\n\n    CPLString osTmpFilenameIn;\n    osTmpFilenameIn.Printf(\"%s%p\", szJPEGGTiffDatasetTmpPrefix, hTIFF);\n    VSILFILE* fpTmp = nullptr;\n    CPLString osTmp;\n    char** papszLocalParameters = nullptr;\n    const int nInMemImageWidth = 16;\n    const int nInMemImageHeight = 16;\n    papszLocalParameters = CSLSetNameValue( papszLocalParameters,\n                                            \"COMPRESS\", \"JPEG\" );\n    papszLocalParameters = CSLSetNameValue( papszLocalParameters,\n                                            \"JPEG_QUALITY\",\n                                            pszJPEGQuality );\n    papszLocalParameters = CSLSetNameValue( papszLocalParameters,\n                                            \"PHOTOMETRIC\", pszPhotometric );\n    papszLocalParameters = CSLSetNameValue( papszLocalParameters,\n                                            \"BLOCKYSIZE\",\n                                            CPLSPrintf(\"%u\", nInMemImageHeight)\n                                          );\n    papszLocalParameters = CSLSetNameValue( papszLocalParameters,\n                                            \"NBITS\",\n                                            CPLSPrintf(\"%u\", l_nBitsPerSample));\n    papszLocalParameters = CSLSetNameValue( papszLocalParameters,\n                                            \"JPEGTABLESMODE\",\n                                            pszJPEGTablesMode );\n\n    TIFF* hTIFFTmp = GTiffDataset::CreateLL(\n                    osTmpFilenameIn, nInMemImageWidth, nInMemImageHeight,\n                    (nBands <= 4) ? nBands : 1,\n                    (l_nBitsPerSample <= 8) ? GDT_Byte : GDT_UInt16, 0.0,\n                    papszLocalParameters, &fpTmp, osTmp );\n    CSLDestroy(papszLocalParameters);\n    if( hTIFFTmp )\n    {\n        uint16 l_nPhotometric = 0;\n        int nJpegTablesModeIn = 0;\n        TIFFGetField( hTIFFTmp, TIFFTAG_PHOTOMETRIC, &(l_nPhotometric) );\n        TIFFGetField( hTIFFTmp, TIFFTAG_JPEGTABLESMODE,\n                        &nJpegTablesModeIn );\n        TIFFWriteCheck( hTIFFTmp, FALSE, \"CreateLL\" );\n        TIFFWriteDirectory( hTIFFTmp );\n        TIFFSetDirectory( hTIFFTmp, 0 );\n        // Now, reset quality and jpegcolormode.\n        const int l_nJpegQuality = pszJPEGQuality ? atoi(pszJPEGQuality) : 0;\n        if(l_nJpegQuality > 0)\n            TIFFSetField(hTIFFTmp, TIFFTAG_JPEGQUALITY, l_nJpegQuality);\n        if( l_nPhotometric == PHOTOMETRIC_YCBCR\n            && CPLTestBool( CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\",\n                                                \"YES\") ) )\n        {\n            TIFFSetField( hTIFFTmp, TIFFTAG_JPEGCOLORMODE,\n                            JPEGCOLORMODE_RGB);\n        }\n        if( nJpegTablesModeIn >= 0 )\n            TIFFSetField( hTIFFTmp, TIFFTAG_JPEGTABLESMODE,\n                            nJpegTablesModeIn);\n\n        GPtrDiff_t nBlockSize = static_cast<GPtrDiff_t>(nInMemImageWidth) * nInMemImageHeight *\n                                        ((nBands <= 4) ? nBands : 1);\n        if( l_nBitsPerSample == 12 )\n            nBlockSize = (nBlockSize * 3) / 2;\n        std::vector<GByte> abyZeroData( nBlockSize, 0 );\n        TIFFWriteEncodedStrip( hTIFFTmp, 0, &abyZeroData[0], nBlockSize);\n\n        uint32 nJPEGTableSize = 0;\n        void* pJPEGTable = nullptr;\n        if( TIFFGetField( hTIFFTmp, TIFFTAG_JPEGTABLES, &nJPEGTableSize,\n                            &pJPEGTable) )\n            TIFFSetField( hTIFF, TIFFTAG_JPEGTABLES, nJPEGTableSize,\n                            pJPEGTable);\n\n        float *ref = nullptr;\n        if( TIFFGetField(hTIFFTmp, TIFFTAG_REFERENCEBLACKWHITE, &ref) )\n            TIFFSetField(hTIFF, TIFFTAG_REFERENCEBLACKWHITE, ref);\n\n        XTIFFClose(hTIFFTmp);\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fpTmp));\n    }\n    VSIUnlink(osTmpFilenameIn);\n}\n\n/************************************************************************/\n/*                            GuessJPEGQuality()                        */\n/*                                                                      */\n/*      Guess JPEG quality from JPEGTABLES tag.                         */\n/************************************************************************/\n\nstatic const GByte* GTIFFFindNextTable( const GByte* paby, GByte byMarker,\n                                        int nLen, int* pnLenTable )\n{\n    for( int i = 0; i + 1 < nLen; )\n    {\n        if( paby[i] != 0xFF )\n            return nullptr;\n        ++i;\n        if( paby[i] == 0xD8 )\n        {\n            ++i;\n            continue;\n        }\n        if( i + 2 >= nLen )\n            return nullptr;\n        int nMarkerLen = paby[i+1] * 256 + paby[i+2];\n        if( i+1+nMarkerLen >= nLen )\n            return nullptr;\n        if( paby[i] == byMarker )\n        {\n            if( pnLenTable ) *pnLenTable = nMarkerLen;\n            return paby + i + 1;\n        }\n        i += 1 + nMarkerLen;\n    }\n    return nullptr;\n}\n\n// We assume that if there are several quantization tables, they are\n// in the same order. Which is a reasonable assumption for updating\n// a file generated by ourselves.\nstatic bool GTIFFQuantizationTablesEqual( const GByte* paby1, int nLen1,\n                                          const GByte* paby2, int nLen2 )\n{\n    bool bFound = false;\n    while( true )\n    {\n        int nLenTable1 = 0;\n        int nLenTable2 = 0;\n        const GByte* paby1New =\n            GTIFFFindNextTable(paby1, 0xDB, nLen1, &nLenTable1);\n        const GByte* paby2New =\n            GTIFFFindNextTable(paby2, 0xDB, nLen2, &nLenTable2);\n        if( paby1New == nullptr && paby2New == nullptr )\n            return bFound;\n        if( paby1New == nullptr || paby2New == nullptr )\n            return false;\n        if( nLenTable1 != nLenTable2 )\n            return false;\n        if( memcmp(paby1New, paby2New, nLenTable1) != 0 )\n            return false;\n        paby1New += nLenTable1;\n        paby2New += nLenTable2;\n        nLen1 -= static_cast<int>(paby1New - paby1);\n        nLen2 -= static_cast<int>(paby2New - paby2);\n        paby1 = paby1New;\n        paby2 = paby2New;\n        bFound = true;\n    }\n}\n\nint GTiffDataset::GuessJPEGQuality( bool& bOutHasQuantizationTable,\n                                    bool& bOutHasHuffmanTable )\n{\n    CPLAssert( m_nCompression == COMPRESSION_JPEG );\n    uint32 nJPEGTableSize = 0;\n    void* pJPEGTable = nullptr;\n    if( !TIFFGetField(m_hTIFF, TIFFTAG_JPEGTABLES, &nJPEGTableSize, &pJPEGTable) )\n    {\n        bOutHasQuantizationTable = false;\n        bOutHasHuffmanTable = false;\n        return -1;\n    }\n\n    bOutHasQuantizationTable =\n        GTIFFFindNextTable( static_cast<const GByte*>(pJPEGTable), 0xDB,\n                            nJPEGTableSize, nullptr) != nullptr;\n    bOutHasHuffmanTable =\n        GTIFFFindNextTable( static_cast<const GByte*>(pJPEGTable), 0xC4,\n                            nJPEGTableSize, nullptr) != nullptr;\n    if( !bOutHasQuantizationTable )\n        return -1;\n\n    char** papszLocalParameters = nullptr;\n    papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                            \"COMPRESS\", \"JPEG\");\n    if( m_nPhotometric == PHOTOMETRIC_YCBCR )\n        papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                            \"PHOTOMETRIC\", \"YCBCR\");\n    else if( m_nPhotometric == PHOTOMETRIC_SEPARATED )\n        papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                            \"PHOTOMETRIC\", \"CMYK\");\n    papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                            \"BLOCKYSIZE\", \"16\");\n    if( m_nBitsPerSample == 12 )\n        papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                                \"NBITS\", \"12\");\n\n    CPLString osTmpFilenameIn;\n    osTmpFilenameIn.Printf( \"/vsimem/gtiffdataset_guess_jpeg_quality_tmp_%p\",\n                            this );\n\n    int nRet = -1;\n    for( int nQuality = 0; nQuality <= 100 && nRet < 0; ++nQuality )\n    {\n        VSILFILE* fpTmp = nullptr;\n        if( nQuality == 0 )\n            papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                                   \"JPEG_QUALITY\", \"75\");\n        else\n            papszLocalParameters = CSLSetNameValue(papszLocalParameters,\n                                \"JPEG_QUALITY\", CPLSPrintf(\"%d\", nQuality));\n\n        CPLPushErrorHandler(CPLQuietErrorHandler);\n        CPLString osTmp;\n        TIFF* hTIFFTmp =\n            CreateLL( osTmpFilenameIn, 16, 16, (nBands <= 4) ? nBands : 1,\n                      GetRasterBand(1)->GetRasterDataType(), 0.0,\n                      papszLocalParameters, &fpTmp, osTmp );\n        CPLPopErrorHandler();\n        if( !hTIFFTmp )\n        {\n            break;\n        }\n\n        TIFFWriteCheck( hTIFFTmp, FALSE, \"CreateLL\" );\n        TIFFWriteDirectory( hTIFFTmp );\n        TIFFSetDirectory( hTIFFTmp, 0 );\n        // Now reset jpegcolormode.\n        if( m_nPhotometric == PHOTOMETRIC_YCBCR\n            && CPLTestBool( CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\",\n                                                \"YES\") ) )\n        {\n            TIFFSetField(hTIFFTmp, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n        }\n\n        GByte abyZeroData[(16*16*4*3)/2] = {};\n        const int nBlockSize =\n            (16 * 16 * ((nBands <= 4) ? nBands : 1) * m_nBitsPerSample) / 8;\n        TIFFWriteEncodedStrip( hTIFFTmp, 0, abyZeroData, nBlockSize);\n\n        uint32 nJPEGTableSizeTry = 0;\n        void* pJPEGTableTry = nullptr;\n        if( TIFFGetField(hTIFFTmp, TIFFTAG_JPEGTABLES,\n                         &nJPEGTableSizeTry, &pJPEGTableTry) )\n        {\n            if( GTIFFQuantizationTablesEqual(\n                   static_cast<GByte *>(pJPEGTable), nJPEGTableSize,\n                   static_cast<GByte *>(pJPEGTableTry), nJPEGTableSizeTry) )\n            {\n                nRet = (nQuality == 0 ) ? 75 : nQuality;\n            }\n        }\n\n        XTIFFClose(hTIFFTmp);\n        CPL_IGNORE_RET_VAL(VSIFCloseL(fpTmp));\n    }\n\n    CSLDestroy(papszLocalParameters);\n    VSIUnlink(osTmpFilenameIn);\n\n    return nRet;\n}\n\n/************************************************************************/\n/*               SetJPEGQualityAndTablesModeFromFile()                  */\n/************************************************************************/\n\nvoid GTiffDataset::SetJPEGQualityAndTablesModeFromFile()\n{\n    bool bHasQuantizationTable = false;\n    bool bHasHuffmanTable = false;\n    int nQuality = GuessJPEGQuality( bHasQuantizationTable,\n                                     bHasHuffmanTable );\n    if( nQuality > 0 )\n    {\n        CPLDebug(\"GTiff\", \"Guessed JPEG quality to be %d\", nQuality);\n        m_nJpegQuality = static_cast<signed char>(nQuality);\n        TIFFSetField( m_hTIFF, TIFFTAG_JPEGQUALITY, nQuality );\n\n        // This means we will use the quantization tables from the\n        // JpegTables tag.\n        m_nJpegTablesMode = JPEGTABLESMODE_QUANT;\n    }\n    else\n    {\n        uint32 nJPEGTableSize = 0;\n        void* pJPEGTable = nullptr;\n        if( !TIFFGetField( m_hTIFF, TIFFTAG_JPEGTABLES,\n                            &nJPEGTableSize, &pJPEGTable) )\n        {\n            toff_t *panByteCounts = nullptr;\n            const int nBlockCount =\n                m_nPlanarConfig == PLANARCONFIG_SEPARATE\n                ? m_nBlocksPerBand * nBands\n                : m_nBlocksPerBand;\n            if( TIFFIsTiled( m_hTIFF ) )\n                TIFFGetField( m_hTIFF, TIFFTAG_TILEBYTECOUNTS,\n                                &panByteCounts );\n            else\n                TIFFGetField( m_hTIFF, TIFFTAG_STRIPBYTECOUNTS,\n                                &panByteCounts );\n\n            bool bFoundNonEmptyBlock = false;\n            if( panByteCounts != nullptr )\n            {\n                for( int iBlock = 0; iBlock < nBlockCount; ++iBlock )\n                {\n                    if( panByteCounts[iBlock] != 0 )\n                    {\n                        bFoundNonEmptyBlock = true;\n                        break;\n                    }\n                }\n            }\n            if( bFoundNonEmptyBlock )\n            {\n                CPLDebug(\"GTiff\", \"Could not guess JPEG quality. \"\n                            \"JPEG tables are missing, so going in \"\n                            \"TIFFTAG_JPEGTABLESMODE = 0/2 mode\");\n                // Write quantization tables in each strile.\n                m_nJpegTablesMode = 0;\n            }\n        }\n        else\n        {\n            if( bHasQuantizationTable )\n            {\n                // FIXME in libtiff: this is likely going to cause issues\n                // since libtiff will reuse in each strile the number of\n                // the global quantization table, which is invalid.\n                CPLDebug(\n                    \"GTiff\", \"Could not guess JPEG quality although JPEG \"\n                    \"quantization tables are present, so going in \"\n                    \"TIFFTAG_JPEGTABLESMODE = 0/2 mode\" );\n            }\n            else\n            {\n                CPLDebug(\"GTiff\", \"Could not guess JPEG quality since JPEG \"\n                        \"quantization tables are not present, so going in \"\n                        \"TIFFTAG_JPEGTABLESMODE = 0/2 mode\");\n            }\n\n            // Write quantization tables in each strile.\n            m_nJpegTablesMode = 0;\n        }\n    }\n    if( bHasHuffmanTable )\n    {\n        // If there are Huffman tables in header use them, otherwise\n        // if we use optimized tables, libtiff will currently reuse\n        // the number of the Huffman tables of the header for the\n        // optimized version of each strile, which is illegal.\n        m_nJpegTablesMode |= JPEGTABLESMODE_HUFF;\n    }\n    if( m_nJpegTablesMode >= 0 )\n        TIFFSetField( m_hTIFF, TIFFTAG_JPEGTABLESMODE,\n                        m_nJpegTablesMode);\n}\n\n/************************************************************************/\n/*                               Create()                               */\n/*                                                                      */\n/*      Create a new GeoTIFF or TIFF file.                              */\n/************************************************************************/\n\nGDALDataset *GTiffDataset::Create( const char * pszFilename,\n                                   int nXSize, int nYSize, int l_nBands,\n                                   GDALDataType eType,\n                                   char **papszParmList )\n\n{\n    VSILFILE* l_fpL = nullptr;\n    CPLString l_osTmpFilename;\n\n/* -------------------------------------------------------------------- */\n/*      Create the underlying TIFF file.                                */\n/* -------------------------------------------------------------------- */\n    TIFF *l_hTIFF = CreateLL(\n        pszFilename,\n        nXSize, nYSize, l_nBands,\n        eType, 0, papszParmList, &l_fpL, l_osTmpFilename );\n    const bool bStreaming = !l_osTmpFilename.empty();\n\n    if( l_hTIFF == nullptr )\n        return nullptr;\n\n/* -------------------------------------------------------------------- */\n/*      Create the new GTiffDataset object.                             */\n/* -------------------------------------------------------------------- */\n    GTiffDataset *poDS = new GTiffDataset();\n    poDS->m_hTIFF = l_hTIFF;\n    poDS->m_fpL = l_fpL;\n    if( bStreaming )\n    {\n        poDS->m_bStreamingOut = true;\n        poDS->m_pszTmpFilename = CPLStrdup(l_osTmpFilename);\n        poDS->m_fpToWrite = VSIFOpenL( pszFilename, \"wb\" );\n        if( poDS->m_fpToWrite == nullptr )\n        {\n            VSIUnlink(l_osTmpFilename);\n            delete poDS;\n            return nullptr;\n        }\n    }\n    poDS->nRasterXSize = nXSize;\n    poDS->nRasterYSize = nYSize;\n    poDS->eAccess = GA_Update;\n    poDS->m_bCrystalized = false;\n    poDS->m_nSamplesPerPixel = static_cast<uint16>(l_nBands);\n    poDS->m_pszFilename = CPLStrdup(pszFilename);\n\n    // Don't try to load external metadata files (#6597).\n    poDS->m_bIMDRPCMetadataLoaded = true;\n\n    // Avoid premature crystalization that will cause directory re-writing if\n    // GetProjectionRef() or GetGeoTransform() are called on the newly created\n    // GeoTIFF.\n    poDS->m_bLookedForProjection = true;\n\n    TIFFGetField( l_hTIFF, TIFFTAG_SAMPLEFORMAT, &(poDS->m_nSampleFormat) );\n    TIFFGetField( l_hTIFF, TIFFTAG_PLANARCONFIG, &(poDS->m_nPlanarConfig) );\n    // Weird that we need this, but otherwise we get a Valgrind warning on\n    // tiff_write_124.\n    if( !TIFFGetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, &(poDS->m_nPhotometric) ) )\n        poDS->m_nPhotometric = PHOTOMETRIC_MINISBLACK;\n    TIFFGetField( l_hTIFF, TIFFTAG_BITSPERSAMPLE, &(poDS->m_nBitsPerSample) );\n    TIFFGetField( l_hTIFF, TIFFTAG_COMPRESSION, &(poDS->m_nCompression) );\n\n    if( TIFFIsTiled(l_hTIFF) )\n    {\n        TIFFGetField( l_hTIFF, TIFFTAG_TILEWIDTH, &(poDS->m_nBlockXSize) );\n        TIFFGetField( l_hTIFF, TIFFTAG_TILELENGTH, &(poDS->m_nBlockYSize) );\n    }\n    else\n    {\n        if( !TIFFGetField( l_hTIFF, TIFFTAG_ROWSPERSTRIP,\n                           &(poDS->m_nRowsPerStrip) ) )\n            poDS->m_nRowsPerStrip = 1;  // Dummy value.\n\n        poDS->m_nBlockXSize = nXSize;\n        poDS->m_nBlockYSize =\n            std::min( static_cast<int>(poDS->m_nRowsPerStrip) , nYSize );\n    }\n\n    poDS->m_nBlocksPerBand =\n        DIV_ROUND_UP(nYSize, poDS->m_nBlockYSize)\n        * DIV_ROUND_UP(nXSize, poDS->m_nBlockXSize);\n\n    poDS->m_eProfile = GetProfile(\n        CSLFetchNameValue( papszParmList, \"PROFILE\" ) );\n\n/* -------------------------------------------------------------------- */\n/*      YCbCr JPEG compressed images should be translated on the fly    */\n/*      to RGB by libtiff/libjpeg unless specifically requested         */\n/*      otherwise.                                                      */\n/* -------------------------------------------------------------------- */\n    if( poDS->m_nCompression == COMPRESSION_JPEG\n        && poDS->m_nPhotometric == PHOTOMETRIC_YCBCR\n        && CPLTestBool( CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\", \"YES\") ) )\n    {\n        int nColorMode = 0;\n\n        poDS->SetMetadataItem(\"SOURCE_COLOR_SPACE\", \"YCbCr\", \"IMAGE_STRUCTURE\");\n        if( !TIFFGetField( l_hTIFF, TIFFTAG_JPEGCOLORMODE, &nColorMode ) ||\n            nColorMode != JPEGCOLORMODE_RGB )\n            TIFFSetField(l_hTIFF, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n    }\n\n#ifdef HAVE_LERC\n    if( poDS->m_nCompression == COMPRESSION_LERC )\n    {\n        uint32 nLercParamCount = 0;\n        uint32* panLercParms = nullptr;\n        if( TIFFGetField( l_hTIFF, TIFFTAG_LERC_PARAMETERS, &nLercParamCount,\n                          &panLercParms ) &&\n            nLercParamCount == 2 )\n        {\n            memcpy( poDS->m_anLercAddCompressionAndVersion, panLercParms,\n                    sizeof(poDS->m_anLercAddCompressionAndVersion) );\n        }\n    }\n#endif\n\n/* -------------------------------------------------------------------- */\n/*      Read palette back as a color table if it has one.               */\n/* -------------------------------------------------------------------- */\n    unsigned short *panRed = nullptr;\n    unsigned short *panGreen = nullptr;\n    unsigned short *panBlue = nullptr;\n\n    if( poDS->m_nPhotometric == PHOTOMETRIC_PALETTE\n        && TIFFGetField( l_hTIFF, TIFFTAG_COLORMAP,\n                         &panRed, &panGreen, &panBlue) )\n    {\n\n        poDS->m_poColorTable = new GDALColorTable();\n\n        const int nColorCount = 1 << poDS->m_nBitsPerSample;\n\n        for( int iColor = nColorCount - 1; iColor >= 0; iColor-- )\n        {\n            const unsigned short divisor = 257;\n            const GDALColorEntry oEntry = {\n                static_cast<short>(panRed[iColor] / divisor),\n                static_cast<short>(panGreen[iColor] / divisor),\n                static_cast<short>(panBlue[iColor] / divisor),\n                static_cast<short>(255)\n            };\n\n            poDS->m_poColorTable->SetColorEntry( iColor, &oEntry );\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Do we want to ensure all blocks get written out on close to     */\n/*      avoid sparse files?                                             */\n/* -------------------------------------------------------------------- */\n    if( !CPLFetchBool( papszParmList, \"SPARSE_OK\", false ) )\n        poDS->m_bFillEmptyTilesAtClosing = true;\n\n    poDS->m_bWriteEmptyTiles = bStreaming ||\n        (poDS->m_nCompression != COMPRESSION_NONE &&\n         poDS->m_bFillEmptyTilesAtClosing);\n    // Only required for people writing non-compressed striped files in the\n    // right order and wanting all tstrips to be written in the same order\n    // so that the end result can be memory mapped without knowledge of each\n    // strip offset.\n    if( CPLTestBool( CSLFetchNameValueDef( papszParmList,\n                              \"WRITE_EMPTY_TILES_SYNCHRONOUSLY\", \"FALSE\" )) ||\n         CPLTestBool( CSLFetchNameValueDef( papszParmList,\n                              \"@WRITE_EMPTY_TILES_SYNCHRONOUSLY\", \"FALSE\" )) )\n    {\n        poDS->m_bWriteEmptyTiles = true;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Preserve creation options for consulting later (for instance    */\n/*      to decide if a TFW file should be written).                     */\n/* -------------------------------------------------------------------- */\n    poDS->m_papszCreationOptions = CSLDuplicate( papszParmList );\n\n    poDS->m_nZLevel = GTiffGetZLevel(papszParmList);\n    poDS->m_nLZMAPreset = GTiffGetLZMAPreset(papszParmList);\n    poDS->m_nZSTDLevel = GTiffGetZSTDPreset(papszParmList);\n    poDS->m_nWebPLevel = GTiffGetWebPLevel(papszParmList);\n    poDS->m_bWebPLossless = GTiffGetWebPLossless(papszParmList);\n    poDS->m_nJpegQuality = GTiffGetJpegQuality(papszParmList);\n    poDS->m_nJpegTablesMode = GTiffGetJpegTablesMode(papszParmList);\n#if HAVE_LERC\n    poDS->m_dfMaxZError = GTiffGetLERCMaxZError(papszParmList);\n#endif\n    poDS->InitCreationOrOpenOptions(papszParmList);\n\n/* -------------------------------------------------------------------- */\n/*      Create band information objects.                                */\n/* -------------------------------------------------------------------- */\n    for( int iBand = 0; iBand < l_nBands; ++iBand )\n    {\n        if( poDS->m_nBitsPerSample == 8 ||\n            (poDS->m_nBitsPerSample == 16 && eType != GDT_Float32) ||\n            poDS->m_nBitsPerSample == 32 ||\n            poDS->m_nBitsPerSample == 64 ||\n            poDS->m_nBitsPerSample == 128)\n        {\n            poDS->SetBand( iBand + 1, new GTiffRasterBand( poDS, iBand + 1 ) );\n        }\n        else\n        {\n            poDS->SetBand( iBand + 1, new GTiffOddBitsBand( poDS, iBand + 1 ) );\n            poDS->GetRasterBand( iBand + 1 )->\n                SetMetadataItem( \"NBITS\",\n                                 CPLString().Printf(\"%d\",poDS->m_nBitsPerSample),\n                                 \"IMAGE_STRUCTURE\" );\n        }\n    }\n\n    poDS->GetDiscardLsbOption(papszParmList);\n\n    if( poDS->m_nPlanarConfig == PLANARCONFIG_CONTIG && l_nBands != 1 )\n        poDS->SetMetadataItem( \"INTERLEAVE\", \"PIXEL\", \"IMAGE_STRUCTURE\" );\n    else\n        poDS->SetMetadataItem( \"INTERLEAVE\", \"BAND\", \"IMAGE_STRUCTURE\" );\n\n    poDS->oOvManager.Initialize( poDS, pszFilename );\n\n    return poDS;\n}\n\n/************************************************************************/\n/*                           CopyImageryAndMask()                       */\n/************************************************************************/\n\nCPLErr GTiffDataset::CopyImageryAndMask(GTiffDataset* poDstDS,\n                                        GDALDataset* poSrcDS,\n                                        GDALRasterBand* poSrcMaskBand,\n                                        GDALProgressFunc pfnProgress,\n                                        void * pProgressData )\n{\n    CPLErr eErr = CE_None;\n\n    const auto eType = poDstDS->GetRasterBand(1)->GetRasterDataType();\n    const int nDataTypeSize = GDALGetDataTypeSizeBytes(eType);\n    const int l_nBands = poDstDS->GetRasterCount();\n    void *pBlockBuffer = VSI_MALLOC3_VERBOSE(\n        poDstDS->m_nBlockXSize, poDstDS->m_nBlockYSize, l_nBands * nDataTypeSize);\n    if( pBlockBuffer == nullptr )\n    {\n        eErr = CE_Failure;\n    }\n    const int nYSize = poDstDS->nRasterYSize;\n    const int nXSize = poDstDS->nRasterXSize;\n    const int nYBlocks = DIV_ROUND_UP(nYSize, poDstDS->m_nBlockYSize);\n    const int nXBlocks = DIV_ROUND_UP(nXSize, poDstDS->m_nBlockXSize);\n    const int nBlocks = nXBlocks * nYBlocks;\n\n    CPLAssert(l_nBands == 1 || poDstDS->m_nPlanarConfig == PLANARCONFIG_CONTIG );\n\n    const bool bIsOddBand =\n        dynamic_cast<GTiffOddBitsBand*>(poDstDS->GetRasterBand(1)) != nullptr;\n\n    if( poDstDS->m_poMaskDS )\n    {\n        CPLAssert( poDstDS->m_poMaskDS->m_nBlockXSize == poDstDS->m_nBlockXSize );\n        CPLAssert( poDstDS->m_poMaskDS->m_nBlockYSize == poDstDS->m_nBlockYSize );\n    }\n\n    int iBlock = 0;\n    for( int iY = 0, nYBlock = 0; iY < nYSize && eErr == CE_None;\n            iY = ((nYSize - iY < poDstDS->m_nBlockYSize) ? nYSize :\n                iY + poDstDS->m_nBlockYSize),\n            nYBlock++ )\n    {\n        const int nReqYSize = std::min(nYSize - iY, poDstDS->m_nBlockYSize);\n        for( int iX = 0, nXBlock = 0; iX < nXSize && eErr == CE_None;\n                iX = ((nXSize - iX < poDstDS->m_nBlockXSize) ? nXSize :\n                    iX + poDstDS->m_nBlockXSize),\n                nXBlock++ )\n        {\n            const int nReqXSize = std::min(nXSize - iX, poDstDS->m_nBlockXSize);\n            if( nReqXSize < poDstDS->m_nBlockXSize ||\n                nReqYSize < poDstDS->m_nBlockYSize )\n            {\n                memset(pBlockBuffer, 0, static_cast<size_t>(\n                    poDstDS->m_nBlockXSize) * poDstDS->m_nBlockYSize *\n                    l_nBands * nDataTypeSize);\n            }\n\n            if( !bIsOddBand )\n            {\n                eErr = poSrcDS->RasterIO( GF_Read,\n                    iX, iY, nReqXSize, nReqYSize,\n                    pBlockBuffer, nReqXSize, nReqYSize,\n                    eType,\n                    l_nBands, nullptr,\n                    nDataTypeSize * l_nBands,\n                    poDstDS->m_nBlockXSize * nDataTypeSize * l_nBands,\n                    nDataTypeSize,\n                    nullptr );\n                if( eErr == CE_None )\n                {\n                    eErr = poDstDS->WriteEncodedTileOrStrip(\n                        iBlock, pBlockBuffer, false);\n                }\n            }\n            else\n            {\n                // In the odd bit case, this is a bit messy to ensure\n                // the strile gets written synchronously.\n                // We load the content of the n-1 bands in the cache,\n                // and for the last band we invoke WriteBlock() directly\n                // We also force FlushBlockBuf()\n                std::vector<GDALRasterBlock*> apoLockedBlocks;\n                for( int i = 0; eErr == CE_None && i < l_nBands - 1; i++ )\n                {\n                    auto poBlock = poDstDS->GetRasterBand(i+1)->GetLockedBlockRef(\n                        nXBlock, nYBlock, TRUE);\n                    if( poBlock )\n                    {\n                        eErr = poSrcDS->GetRasterBand(i+1)->RasterIO(\n                            GF_Read,\n                            iX, iY, nReqXSize, nReqYSize,\n                            poBlock->GetDataRef(), nReqXSize, nReqYSize,\n                            eType,\n                            nDataTypeSize,\n                            nDataTypeSize * poDstDS->m_nBlockXSize, nullptr);\n                        poBlock->MarkDirty();\n                        apoLockedBlocks.emplace_back(poBlock);\n                    }\n                    else\n                    {\n                        eErr = CE_Failure;\n                    }\n                }\n                if( eErr == CE_None )\n                {\n                    eErr = poSrcDS->GetRasterBand(l_nBands)->RasterIO(\n                            GF_Read,\n                            iX, iY, nReqXSize, nReqYSize,\n                            pBlockBuffer, nReqXSize, nReqYSize,\n                            eType,\n                            nDataTypeSize,\n                            nDataTypeSize * poDstDS->m_nBlockXSize, nullptr);\n                }\n                if( eErr == CE_None )\n                {\n                    // Avoid any attempt to load from disk\n                    poDstDS->m_nLoadedBlock = iBlock;\n                    eErr = poDstDS->GetRasterBand(l_nBands)->WriteBlock(\n                        nXBlock, nYBlock, pBlockBuffer);\n                    if( eErr == CE_None )\n                        eErr = poDstDS->FlushBlockBuf();\n                }\n                for( auto poBlock: apoLockedBlocks )\n                {\n                    poBlock->MarkClean();\n                    poBlock->DropLock();\n                }\n            }\n\n            if( eErr == CE_None && poDstDS->m_poMaskDS )\n            {\n                if( nReqXSize < poDstDS->m_nBlockXSize ||\n                    nReqYSize < poDstDS->m_nBlockYSize )\n                {\n                    memset(pBlockBuffer, 0,\n                            static_cast<size_t>(poDstDS->m_nBlockXSize) *\n                            poDstDS->m_nBlockYSize);\n                }\n                eErr = poSrcMaskBand->RasterIO(\n                    GF_Read,\n                    iX, iY, nReqXSize, nReqYSize,\n                    pBlockBuffer, nReqXSize, nReqYSize,\n                    GDT_Byte,\n                    1, poDstDS->m_nBlockXSize, nullptr);\n                if( eErr == CE_None )\n                {\n                    // Avoid any attempt to load from disk\n                    poDstDS->m_poMaskDS->m_nLoadedBlock = iBlock;\n                    eErr = poDstDS->m_poMaskDS->GetRasterBand(1)->\n                        WriteBlock(nXBlock, nYBlock, pBlockBuffer);\n                    if( eErr == CE_None )\n                        eErr = poDstDS->m_poMaskDS->FlushBlockBuf();\n                }\n            }\n            if( poDstDS->m_bWriteError )\n                eErr = CE_Failure;\n\n            iBlock ++;\n            if( pfnProgress && !pfnProgress(\n                static_cast<double>(iBlock) / nBlocks, nullptr, pProgressData) )\n            {\n                eErr = CE_Failure;\n            }\n        }\n    }\n    poDstDS->FlushCache(); // mostly to wait for thread completion\n    VSIFree(pBlockBuffer);\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                             CreateCopy()                             */\n/************************************************************************/\n\nGDALDataset *\nGTiffDataset::CreateCopy( const char * pszFilename, GDALDataset *poSrcDS,\n                          int bStrict, char ** papszOptions,\n                          GDALProgressFunc pfnProgress, void * pProgressData )\n\n{\n    if( poSrcDS->GetRasterCount() == 0 )\n    {\n        ReportError( pszFilename, CE_Failure, CPLE_AppDefined,\n                  \"Unable to export GeoTIFF files with zero bands.\" );\n        return nullptr;\n    }\n\n    GDALRasterBand * const poPBand = poSrcDS->GetRasterBand(1);\n    const GDALDataType eType = poPBand->GetRasterDataType();\n\n/* -------------------------------------------------------------------- */\n/*      Check, whether all bands in input dataset has the same type.    */\n/* -------------------------------------------------------------------- */\n    const int l_nBands = poSrcDS->GetRasterCount();\n    for( int iBand = 2; iBand <= l_nBands; ++iBand )\n    {\n        if( eType != poSrcDS->GetRasterBand(iBand)->GetRasterDataType() )\n        {\n            if( bStrict )\n            {\n                ReportError( pszFilename, CE_Failure, CPLE_AppDefined,\n                    \"Unable to export GeoTIFF file with different datatypes \"\n                    \"per different bands. All bands should have the same \"\n                    \"types in TIFF.\" );\n                return nullptr;\n            }\n            else\n            {\n                ReportError( pszFilename,CE_Warning, CPLE_AppDefined,\n                    \"Unable to export GeoTIFF file with different datatypes \"\n                    \"per different bands. All bands should have the same \"\n                    \"types in TIFF.\" );\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Capture the profile.                                            */\n/* -------------------------------------------------------------------- */\n    const GTiffProfile eProfile = GetProfile(\n        CSLFetchNameValue(papszOptions, \"PROFILE\"));\n\n    const bool bGeoTIFF = eProfile != GTiffProfile::BASELINE;\n\n/* -------------------------------------------------------------------- */\n/*      Special handling for NBITS.  Copy from band metadata if found.  */\n/* -------------------------------------------------------------------- */\n    char **papszCreateOptions = CSLDuplicate( papszOptions );\n\n    if( poPBand->GetMetadataItem( \"NBITS\", \"IMAGE_STRUCTURE\" ) != nullptr\n        && atoi(poPBand->GetMetadataItem( \"NBITS\", \"IMAGE_STRUCTURE\" )) > 0\n        && CSLFetchNameValue( papszCreateOptions, \"NBITS\") == nullptr )\n    {\n        papszCreateOptions =\n            CSLSetNameValue( papszCreateOptions, \"NBITS\",\n                             poPBand->GetMetadataItem( \"NBITS\",\n                                                       \"IMAGE_STRUCTURE\" ) );\n    }\n\n    if( CSLFetchNameValue( papszOptions, \"PIXELTYPE\" ) == nullptr\n        && eType == GDT_Byte\n        && poPBand->GetMetadataItem( \"PIXELTYPE\", \"IMAGE_STRUCTURE\" ) )\n    {\n        papszCreateOptions =\n            CSLSetNameValue( papszCreateOptions, \"PIXELTYPE\",\n                             poPBand->GetMetadataItem(\n                                 \"PIXELTYPE\", \"IMAGE_STRUCTURE\" ) );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Color profile.  Copy from band metadata if found.              */\n/* -------------------------------------------------------------------- */\n    if( bGeoTIFF )\n    {\n        const char* pszOptionsMD[] = {\n            \"SOURCE_ICC_PROFILE\",\n            \"SOURCE_PRIMARIES_RED\",\n            \"SOURCE_PRIMARIES_GREEN\",\n            \"SOURCE_PRIMARIES_BLUE\",\n            \"SOURCE_WHITEPOINT\",\n            \"TIFFTAG_TRANSFERFUNCTION_RED\",\n            \"TIFFTAG_TRANSFERFUNCTION_GREEN\",\n            \"TIFFTAG_TRANSFERFUNCTION_BLUE\",\n            \"TIFFTAG_TRANSFERRANGE_BLACK\",\n            \"TIFFTAG_TRANSFERRANGE_WHITE\",\n            nullptr\n        };\n\n        // Copy all the tags.  Options will override tags in the source.\n        int i = 0;\n        while(pszOptionsMD[i] != nullptr)\n        {\n            char const *pszMD =\n                CSLFetchNameValue(papszOptions, pszOptionsMD[i]);\n            if( pszMD == nullptr )\n                pszMD = poSrcDS->GetMetadataItem( pszOptionsMD[i],\n                                                  \"COLOR_PROFILE\" );\n\n            if( (pszMD != nullptr) && !EQUAL(pszMD, \"\") )\n            {\n                papszCreateOptions =\n                    CSLSetNameValue( papszCreateOptions, pszOptionsMD[i],\n                                     pszMD );\n\n                // If an ICC profile exists, other tags are not needed.\n                if( EQUAL(pszOptionsMD[i], \"SOURCE_ICC_PROFILE\") )\n                    break;\n            }\n\n            ++i;\n        }\n    }\n\n    double dfExtraSpaceForOverviews = 0;\n    const bool bCopySrcOverviews = CPLFetchBool(papszCreateOptions, \"COPY_SRC_OVERVIEWS\", false);\n    std::unique_ptr<GDALDataset> poOvrDS;\n    int nSrcOverviews = 0;\n    if( bCopySrcOverviews )\n    {\n        const char* pszOvrDS = CSLFetchNameValue(papszCreateOptions, \"@OVERVIEW_DATASET\");\n        if( pszOvrDS )\n        {\n            // Empty string is used by COG driver to indicate that we want\n            // to ignore source overviews.\n            if( !EQUAL(pszOvrDS, \"\") )\n            {\n                poOvrDS.reset(GDALDataset::Open(pszOvrDS));\n                if( !poOvrDS )\n                {\n                    CSLDestroy(papszCreateOptions);\n                    return nullptr;\n                }\n                if( poOvrDS->GetRasterCount() != l_nBands )\n                {\n                    CSLDestroy(papszCreateOptions);\n                    return nullptr;\n                }\n                nSrcOverviews = poOvrDS->GetRasterBand(1)->GetOverviewCount() + 1;\n            }\n        }\n        else\n        {\n            nSrcOverviews = poSrcDS->GetRasterBand(1)->GetOverviewCount();\n        }\n        if( nSrcOverviews )\n        {\n            for( int j = 1; j <= l_nBands; ++j )\n            {\n                const int nOtherBandOverviewCount = poOvrDS ?\n                    poOvrDS->GetRasterBand(j)->GetOverviewCount() + 1:\n                    poSrcDS->GetRasterBand(j)->GetOverviewCount();\n                if( nOtherBandOverviewCount != nSrcOverviews )\n                {\n                    ReportError( pszFilename, CE_Failure, CPLE_NotSupported,\n                        \"COPY_SRC_OVERVIEWS cannot be used when the bands have \"\n                        \"not the same number of overview levels.\" );\n                    CSLDestroy(papszCreateOptions);\n                    return nullptr;\n                }\n                for( int i = 0; i < nSrcOverviews; ++i )\n                {\n                    GDALRasterBand* poOvrBand = poOvrDS ?\n                        (i == 0 ? poOvrDS->GetRasterBand(j) :\n                                  poOvrDS->GetRasterBand(j)->GetOverview(i-1)) :\n                        poSrcDS->GetRasterBand(j)->GetOverview(i);\n                    if( poOvrBand == nullptr )\n                    {\n                        ReportError( pszFilename, CE_Failure, CPLE_NotSupported,\n                            \"COPY_SRC_OVERVIEWS cannot be used when one \"\n                            \"overview band is NULL.\" );\n                        CSLDestroy(papszCreateOptions);\n                        return nullptr;\n                    }\n                    GDALRasterBand* poOvrFirstBand = poOvrDS ?\n                        (i == 0 ? poOvrDS->GetRasterBand(1) :\n                                  poOvrDS->GetRasterBand(1)->GetOverview(i-1)) :\n                        poSrcDS->GetRasterBand(1)->GetOverview(i);\n                    if( poOvrBand->GetXSize() != poOvrFirstBand->GetXSize() ||\n                        poOvrBand->GetYSize() != poOvrFirstBand->GetYSize() )\n                    {\n                        ReportError( pszFilename, CE_Failure, CPLE_NotSupported,\n                            \"COPY_SRC_OVERVIEWS cannot be used when the \"\n                            \"overview bands have not the same dimensions \"\n                            \"among bands.\" );\n                        CSLDestroy(papszCreateOptions);\n                        return nullptr;\n                    }\n                }\n            }\n\n            for( int i = 0; i < nSrcOverviews; ++i )\n            {\n                GDALRasterBand* poOvrFirstBand = poOvrDS ?\n                        (i == 0 ? poOvrDS->GetRasterBand(1) :\n                                  poOvrDS->GetRasterBand(1)->GetOverview(i-1)) :\n                        poSrcDS->GetRasterBand(1)->GetOverview(i);\n                dfExtraSpaceForOverviews +=\n                    static_cast<double>(\n                      poOvrFirstBand->GetXSize()) *\n                      poOvrFirstBand->GetYSize();\n            }\n            dfExtraSpaceForOverviews *=\n                                l_nBands * GDALGetDataTypeSizeBytes(eType);\n        }\n        else\n        {\n            CPLDebug(\"GTiff\", \"No source overviews to copy\");\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Should we use optimized way of copying from an input JPEG       */\n/*      dataset?                                                        */\n/* -------------------------------------------------------------------- */\n\n// TODO(schwehr): Refactor bDirectCopyFromJPEG to be a const.\n#if defined(HAVE_LIBJPEG) || defined(JPEG_DIRECT_COPY)\n    bool bDirectCopyFromJPEG = false;\n#endif\n\n    // Note: JPEG_DIRECT_COPY is not defined by default, because it is mainly\n    // useful for debugging purposes.\n#ifdef JPEG_DIRECT_COPY\n    if( CPLFetchBool(papszCreateOptions, \"JPEG_DIRECT_COPY\", false) &&\n        GTIFF_CanDirectCopyFromJPEG(poSrcDS, papszCreateOptions) )\n    {\n        CPLDebug(\"GTiff\", \"Using special direct copy mode from a JPEG dataset\");\n\n        bDirectCopyFromJPEG = true;\n    }\n#endif\n\n#ifdef HAVE_LIBJPEG\n    bool bCopyFromJPEG = false;\n\n    // When CreateCopy'ing() from a JPEG dataset, and asking for COMPRESS=JPEG,\n    // use DCT coefficients (unless other options are incompatible, like\n    // strip/tile dimensions, specifying JPEG_QUALITY option, incompatible\n    // PHOTOMETRIC with the source colorspace, etc.) to avoid the lossy steps\n    // involved by decompression/recompression.\n    if( !bDirectCopyFromJPEG &&\n        GTIFF_CanCopyFromJPEG(poSrcDS, papszCreateOptions) )\n    {\n        CPLDebug( \"GTiff\", \"Using special copy mode from a JPEG dataset\" );\n\n        bCopyFromJPEG = true;\n    }\n#endif\n\n/* -------------------------------------------------------------------- */\n/*      If the source is RGB, then set the PHOTOMETRIC=RGB value        */\n/* -------------------------------------------------------------------- */\n\n    const bool bForcePhotometric =\n        CSLFetchNameValue(papszOptions, \"PHOTOMETRIC\") != nullptr;\n\n    if( l_nBands >= 3 && !bForcePhotometric &&\n#ifdef HAVE_LIBJPEG\n        !bCopyFromJPEG &&\n#endif\n        poSrcDS->GetRasterBand(1)->GetColorInterpretation() == GCI_RedBand &&\n        poSrcDS->GetRasterBand(2)->GetColorInterpretation() == GCI_GreenBand &&\n        poSrcDS->GetRasterBand(3)->GetColorInterpretation() == GCI_BlueBand )\n    {\n        papszCreateOptions =\n            CSLSetNameValue( papszCreateOptions, \"PHOTOMETRIC\", \"RGB\" );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Create the file.                                                */\n/* -------------------------------------------------------------------- */\n    VSILFILE* l_fpL = nullptr;\n    CPLString l_osTmpFilename;\n\n    const int nXSize = poSrcDS->GetRasterXSize();\n    const int nYSize = poSrcDS->GetRasterYSize();\n    TIFF *l_hTIFF =\n        CreateLL( pszFilename, nXSize, nYSize, l_nBands,\n                  eType, dfExtraSpaceForOverviews, papszCreateOptions, &l_fpL,\n                  l_osTmpFilename );\n    const bool bStreaming = !l_osTmpFilename.empty();\n\n    CSLDestroy( papszCreateOptions );\n    papszCreateOptions = nullptr;\n\n    if( l_hTIFF == nullptr )\n    {\n        if( bStreaming ) VSIUnlink(l_osTmpFilename);\n        return nullptr;\n    }\n\n    uint16 l_nPlanarConfig = 0;\n    TIFFGetField( l_hTIFF, TIFFTAG_PLANARCONFIG, &l_nPlanarConfig );\n\n    uint16 l_nCompression = 0;\n\n    if( !TIFFGetField( l_hTIFF, TIFFTAG_COMPRESSION, &(l_nCompression) ) )\n        l_nCompression = COMPRESSION_NONE;\n\n/* -------------------------------------------------------------------- */\n/*      Set the alpha channel if it is the last one.                    */\n/* -------------------------------------------------------------------- */\n    if( poSrcDS->GetRasterBand(l_nBands)->GetColorInterpretation() ==\n        GCI_AlphaBand )\n    {\n        uint16 *v = nullptr;\n        uint16 count = 0;\n        if( TIFFGetField( l_hTIFF, TIFFTAG_EXTRASAMPLES, &count, &v ) )\n        {\n            const int nBaseSamples = l_nBands - count;\n            if( l_nBands > nBaseSamples && l_nBands - nBaseSamples - 1 < count )\n            {\n                // We need to allocate a new array as (current) libtiff\n                // versions will not like that we reuse the array we got from\n                // TIFFGetField().\n\n                uint16* pasNewExtraSamples =\n                    static_cast<uint16 *>(\n                        CPLMalloc( count * sizeof(uint16) ) );\n                memcpy( pasNewExtraSamples, v, count * sizeof(uint16) );\n                pasNewExtraSamples[l_nBands - nBaseSamples - 1] =\n                    GTiffGetAlphaValue(\n                        CPLGetConfigOption(\n                            \"GTIFF_ALPHA\",\n                            CSLFetchNameValue(papszOptions,\"ALPHA\") ),\n                        DEFAULT_ALPHA_TYPE);\n\n                TIFFSetField( l_hTIFF, TIFFTAG_EXTRASAMPLES, count,\n                              pasNewExtraSamples);\n\n                CPLFree(pasNewExtraSamples);\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If the output is jpeg compressed, and the input is RGB make     */\n/*      sure we note that.                                              */\n/* -------------------------------------------------------------------- */\n\n    if( l_nCompression == COMPRESSION_JPEG )\n    {\n        if( l_nBands >= 3\n            && (poSrcDS->GetRasterBand(1)->GetColorInterpretation()\n                == GCI_YCbCr_YBand)\n            && (poSrcDS->GetRasterBand(2)->GetColorInterpretation()\n                == GCI_YCbCr_CbBand)\n            && (poSrcDS->GetRasterBand(3)->GetColorInterpretation()\n                == GCI_YCbCr_CrBand) )\n        {\n            // Do nothing.\n        }\n        else\n        {\n            // Assume RGB if it is not explicitly YCbCr.\n            CPLDebug( \"GTiff\", \"Setting JPEGCOLORMODE_RGB\" );\n            TIFFSetField( l_hTIFF, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB );\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Does the source image consist of one band, with a palette?      */\n/*      If so, copy over.                                               */\n/* -------------------------------------------------------------------- */\n    if( (l_nBands == 1 || l_nBands == 2) &&\n        poSrcDS->GetRasterBand(1)->GetColorTable() != nullptr\n        && eType == GDT_Byte )\n    {\n        unsigned short anTRed[256] = { 0 };\n        unsigned short anTGreen[256] = { 0 };\n        unsigned short anTBlue[256] = { 0 };\n        GDALColorTable *poCT = poSrcDS->GetRasterBand(1)->GetColorTable();\n\n        for( int iColor = 0; iColor < 256; ++iColor )\n        {\n            if( iColor < poCT->GetColorEntryCount() )\n            {\n                GDALColorEntry sRGB = { 0, 0, 0, 0 };\n\n                poCT->GetColorEntryAsRGB( iColor, &sRGB );\n\n                anTRed[iColor] = static_cast<unsigned short>(257 * sRGB.c1);\n                anTGreen[iColor] = static_cast<unsigned short>(257 * sRGB.c2);\n                anTBlue[iColor] = static_cast<unsigned short>(257 * sRGB.c3);\n            }\n            else\n            {\n                anTRed[iColor] = 0;\n                anTGreen[iColor] = 0;\n                anTBlue[iColor] = 0;\n            }\n        }\n\n        if( !bForcePhotometric )\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_PALETTE );\n        TIFFSetField( l_hTIFF, TIFFTAG_COLORMAP, anTRed, anTGreen, anTBlue );\n    }\n    else if( (l_nBands == 1 || l_nBands == 2)\n             && poSrcDS->GetRasterBand(1)->GetColorTable() != nullptr\n             && eType == GDT_UInt16 )\n    {\n        unsigned short *panTRed = static_cast<unsigned short *>(\n            CPLMalloc(65536 * sizeof(unsigned short)) );\n        unsigned short *panTGreen = static_cast<unsigned short *>(\n            CPLMalloc(65536 * sizeof(unsigned short)) );\n        unsigned short *panTBlue = static_cast<unsigned short *>(\n            CPLMalloc(65536 * sizeof(unsigned short)) );\n\n        GDALColorTable *poCT = poSrcDS->GetRasterBand(1)->GetColorTable();\n\n        for( int iColor = 0; iColor < 65536; ++iColor )\n        {\n            if( iColor < poCT->GetColorEntryCount() )\n            {\n                GDALColorEntry sRGB = { 0, 0, 0, 0 };\n\n                poCT->GetColorEntryAsRGB( iColor, &sRGB );\n\n                panTRed[iColor] = static_cast<unsigned short>(257 * sRGB.c1);\n                panTGreen[iColor] = static_cast<unsigned short>(257 * sRGB.c2);\n                panTBlue[iColor] = static_cast<unsigned short>(257 * sRGB.c3);\n            }\n            else\n            {\n                panTRed[iColor] = 0;\n                panTGreen[iColor] = 0;\n                panTBlue[iColor] = 0;\n            }\n        }\n\n        if( !bForcePhotometric )\n            TIFFSetField( l_hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_PALETTE );\n        TIFFSetField( l_hTIFF, TIFFTAG_COLORMAP, panTRed, panTGreen, panTBlue );\n\n        CPLFree( panTRed );\n        CPLFree( panTGreen );\n        CPLFree( panTBlue );\n    }\n    else if( poSrcDS->GetRasterBand(1)->GetColorTable() != nullptr )\n        ReportError( pszFilename, CE_Failure, CPLE_AppDefined,\n            \"Unable to export color table to GeoTIFF file.  Color tables \"\n            \"can only be written to 1 band or 2 bands Byte or \"\n            \"UInt16 GeoTIFF files.\" );\n\n    if( l_nCompression == COMPRESSION_JPEG )\n    {\n        uint16 l_nPhotometric = 0;\n        TIFFGetField(l_hTIFF, TIFFTAG_PHOTOMETRIC, &l_nPhotometric);\n        // Check done in tif_jpeg.c later, but not with a very clear error message\n        if( l_nPhotometric == PHOTOMETRIC_PALETTE )\n        {\n            ReportError( pszFilename, CE_Failure, CPLE_NotSupported,\n                     \"JPEG compression not supported with paletted image\");\n            XTIFFClose( l_hTIFF );\n            VSIUnlink(l_osTmpFilename);\n            CPL_IGNORE_RET_VAL( VSIFCloseL(l_fpL) );\n            return nullptr;\n        }\n    }\n\n    if( l_nBands == 2\n        && poSrcDS->GetRasterBand(1)->GetColorTable() != nullptr\n        && (eType == GDT_Byte || eType == GDT_UInt16) )\n    {\n        uint16 v[1] = { EXTRASAMPLE_UNASSALPHA };\n\n        TIFFSetField(l_hTIFF, TIFFTAG_EXTRASAMPLES, 1, v );\n    }\n\n    const int nMaskFlags = poSrcDS->GetRasterBand(1)->GetMaskFlags();\n    bool bCreateMask = false;\n    CPLString osHiddenStructuralMD;\n    if( (l_nBands == 1 || l_nPlanarConfig == PLANARCONFIG_CONTIG) &&\n        bCopySrcOverviews )\n    {\n        osHiddenStructuralMD += \"LAYOUT=IFDS_BEFORE_DATA\\n\";\n        osHiddenStructuralMD += \"BLOCK_ORDER=ROW_MAJOR\\n\";\n        osHiddenStructuralMD += \"BLOCK_LEADER=SIZE_AS_UINT4\\n\";\n        osHiddenStructuralMD += \"BLOCK_TRAILER=LAST_4_BYTES_REPEATED\\n\";\n        osHiddenStructuralMD += \"KNOWN_INCOMPATIBLE_EDITION=NO\\n \"; // Final space intended, so this can be replaced by YES\n    }\n    if( !(nMaskFlags & (GMF_ALL_VALID|GMF_ALPHA|GMF_NODATA) )\n        && (nMaskFlags & GMF_PER_DATASET) && !bStreaming )\n    {\n        bCreateMask = true;\n        if( GTiffDataset::MustCreateInternalMask() &&\n            !osHiddenStructuralMD.empty() )\n        {\n            osHiddenStructuralMD += \"MASK_INTERLEAVED_WITH_IMAGERY=YES\\n\";\n        }\n    }\n    if( !osHiddenStructuralMD.empty() )\n    {\n        const int nHiddenMDSize = static_cast<int>(osHiddenStructuralMD.size());\n        osHiddenStructuralMD = CPLOPrintf(\n            \"GDAL_STRUCTURAL_METADATA_SIZE=%06d bytes\\n\", nHiddenMDSize) + osHiddenStructuralMD;\n        VSI_TIFFWrite(l_hTIFF, osHiddenStructuralMD.c_str(), osHiddenStructuralMD.size());\n    }\n \n\n    // FIXME? libtiff writes extended tags in the order they are specified\n    // and not in increasing order.\n\n/* -------------------------------------------------------------------- */\n/*      Transfer some TIFF specific metadata, if available.             */\n/*      The return value will tell us if we need to try again later with*/\n/*      PAM because the profile doesn't allow to write some metadata    */\n/*      as TIFF tag                                                     */\n/* -------------------------------------------------------------------- */\n    const bool bHasWrittenMDInGeotiffTAG =\n            GTiffDataset::WriteMetadata( poSrcDS, l_hTIFF, false, eProfile,\n                                         pszFilename, papszOptions );\n\n/* -------------------------------------------------------------------- */\n/*      Write NoData value, if exist.                                   */\n/* -------------------------------------------------------------------- */\n    if( eProfile == GTiffProfile::GDALGEOTIFF )\n    {\n        int bSuccess = FALSE;\n        const double dfNoData =\n            poSrcDS->GetRasterBand(1)->GetNoDataValue( &bSuccess );\n        if( bSuccess )\n            GTiffDataset::WriteNoDataValue( l_hTIFF, dfNoData );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Are we addressing PixelIsPoint mode?                            */\n/* -------------------------------------------------------------------- */\n    bool bPixelIsPoint = false;\n    bool bPointGeoIgnore = false;\n\n    if( poSrcDS->GetMetadataItem( GDALMD_AREA_OR_POINT )\n        && EQUAL(poSrcDS->GetMetadataItem(GDALMD_AREA_OR_POINT),\n                 GDALMD_AOP_POINT) )\n    {\n        bPixelIsPoint = true;\n        bPointGeoIgnore =\n            CPLTestBool( CPLGetConfigOption( \"GTIFF_POINT_GEO_IGNORE\",\n                                             \"FALSE\") );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Write affine transform if it is meaningful.                     */\n/* -------------------------------------------------------------------- */\n    const OGRSpatialReference* l_poSRS = nullptr;\n    double l_adfGeoTransform[6] = { 0.0 };\n\n    if( poSrcDS->GetGeoTransform( l_adfGeoTransform ) == CE_None )\n    {\n        if( bGeoTIFF )\n        {\n            l_poSRS = poSrcDS->GetSpatialRef();\n\n            if( l_adfGeoTransform[2] == 0.0 && l_adfGeoTransform[4] == 0.0\n                && l_adfGeoTransform[5] < 0.0 )\n            {\n                double dfOffset = 0.0;\n                {\n                    // In the case the SRS has a vertical component and we have\n                    // a single band, encode its scale/offset in the GeoTIFF tags\n                    int bHasScale = FALSE;\n                    double dfScale =\n                        poSrcDS->GetRasterBand(1)->GetScale(&bHasScale);\n                    int bHasOffset = FALSE;\n                    dfOffset =\n                        poSrcDS->GetRasterBand(1)->GetOffset(&bHasOffset);\n                    const bool bApplyScaleOffset =\n                        l_poSRS && l_poSRS->IsVertical() &&\n                        poSrcDS->GetRasterCount() == 1;\n                    if( bApplyScaleOffset && !bHasScale )\n                        dfScale = 1.0;\n                    if( !bApplyScaleOffset || !bHasOffset )\n                        dfOffset = 0.0;\n                    const double adfPixelScale[3] = {\n                        l_adfGeoTransform[1], fabs(l_adfGeoTransform[5]),\n                        bApplyScaleOffset ? dfScale : 0.0 };\n\n                    TIFFSetField( l_hTIFF, TIFFTAG_GEOPIXELSCALE, 3,\n                                  adfPixelScale );\n                }\n\n                double adfTiePoints[6] = {\n                    0.0,\n                    0.0,\n                    0.0,\n                    l_adfGeoTransform[0],\n                    l_adfGeoTransform[3],\n                    dfOffset\n                };\n\n                if( bPixelIsPoint && !bPointGeoIgnore )\n                {\n                    adfTiePoints[3] +=\n                        l_adfGeoTransform[1] * 0.5 + l_adfGeoTransform[2] * 0.5;\n                    adfTiePoints[4] +=\n                        l_adfGeoTransform[4] * 0.5 + l_adfGeoTransform[5] * 0.5;\n                }\n\n                TIFFSetField( l_hTIFF, TIFFTAG_GEOTIEPOINTS, 6, adfTiePoints );\n            }\n            else\n            {\n                double adfMatrix[16] = { 0.0 };\n\n                adfMatrix[0] = l_adfGeoTransform[1];\n                adfMatrix[1] = l_adfGeoTransform[2];\n                adfMatrix[3] = l_adfGeoTransform[0];\n                adfMatrix[4] = l_adfGeoTransform[4];\n                adfMatrix[5] = l_adfGeoTransform[5];\n                adfMatrix[7] = l_adfGeoTransform[3];\n                adfMatrix[15] = 1.0;\n\n                if( bPixelIsPoint && !bPointGeoIgnore )\n                {\n                    adfMatrix[3] +=\n                        l_adfGeoTransform[1] * 0.5 + l_adfGeoTransform[2] * 0.5;\n                    adfMatrix[7] +=\n                        l_adfGeoTransform[4] * 0.5 + l_adfGeoTransform[5] * 0.5;\n                }\n\n                TIFFSetField( l_hTIFF, TIFFTAG_GEOTRANSMATRIX, 16, adfMatrix );\n            }\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Do we need a TFW file?                                          */\n/* -------------------------------------------------------------------- */\n        if( CPLFetchBool( papszOptions, \"TFW\", false ) )\n            GDALWriteWorldFile( pszFilename, \"tfw\", l_adfGeoTransform );\n        else if( CPLFetchBool( papszOptions, \"WORLDFILE\", false ) )\n            GDALWriteWorldFile( pszFilename, \"wld\", l_adfGeoTransform );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Otherwise write tiepoints if they are available.                */\n/* -------------------------------------------------------------------- */\n    else if( poSrcDS->GetGCPCount() > 0 && bGeoTIFF )\n    {\n        const GDAL_GCP *pasGCPs = poSrcDS->GetGCPs();\n        double *padfTiePoints = static_cast<double *>(\n            CPLMalloc(6 * sizeof(double) * poSrcDS->GetGCPCount()) );\n\n        for( int iGCP = 0; iGCP < poSrcDS->GetGCPCount(); ++iGCP )\n        {\n\n            padfTiePoints[iGCP*6+0] = pasGCPs[iGCP].dfGCPPixel;\n            padfTiePoints[iGCP*6+1] = pasGCPs[iGCP].dfGCPLine;\n            padfTiePoints[iGCP*6+2] = 0;\n            padfTiePoints[iGCP*6+3] = pasGCPs[iGCP].dfGCPX;\n            padfTiePoints[iGCP*6+4] = pasGCPs[iGCP].dfGCPY;\n            padfTiePoints[iGCP*6+5] = pasGCPs[iGCP].dfGCPZ;\n\n            if( bPixelIsPoint && !bPointGeoIgnore )\n            {\n                padfTiePoints[iGCP*6+0] -= 0.5;\n                padfTiePoints[iGCP*6+1] -= 0.5;\n            }\n        }\n\n        TIFFSetField( l_hTIFF, TIFFTAG_GEOTIEPOINTS,\n                      6*poSrcDS->GetGCPCount(), padfTiePoints );\n        CPLFree( padfTiePoints );\n\n        l_poSRS = poSrcDS->GetGCPSpatialRef();\n\n        if( CPLFetchBool( papszOptions, \"TFW\", false )\n            || CPLFetchBool( papszOptions, \"WORLDFILE\", false ) )\n        {\n            ReportError( pszFilename,CE_Warning, CPLE_AppDefined,\n                \"TFW=ON or WORLDFILE=ON creation options are ignored when \"\n                \"GCPs are available\" );\n        }\n    }\n    else\n    {\n        l_poSRS = poSrcDS->GetSpatialRef();\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Copy xml:XMP data                                               */\n/* -------------------------------------------------------------------- */\n    char **papszXMP = poSrcDS->GetMetadata(\"xml:XMP\");\n    if( papszXMP != nullptr && *papszXMP != nullptr )\n    {\n        int nTagSize = static_cast<int>(strlen(*papszXMP));\n        TIFFSetField( l_hTIFF, TIFFTAG_XMLPACKET, nTagSize, *papszXMP );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Write the projection information, if possible.                  */\n/* -------------------------------------------------------------------- */\n    const bool bHasProjection = l_poSRS != nullptr;\n    bool bExportSRSToPAM = false;\n    if( (bHasProjection || bPixelIsPoint) && bGeoTIFF )\n    {\n        GTIF *psGTIF = GTiffDatasetGTIFNew( l_hTIFF );\n\n        if( bHasProjection )\n        {\n            char* pszWKT = nullptr;\n            OGRErr eErr;\n            {\n                CPLErrorStateBackuper oErrorStateBackuper;\n                CPLErrorHandlerPusher oErrorHandler(CPLQuietErrorHandler);\n                eErr = l_poSRS->exportToWkt(&pszWKT);\n            }\n            if( eErr == OGRERR_NONE && strstr(pszWKT, \"custom_proj4\") == nullptr )\n            {\n                GTIFSetFromOGISDefnEx( psGTIF, pszWKT,\n                                    GetGTIFFKeysFlavor(papszOptions),\n                                    GetGeoTIFFVersion(papszOptions) );\n            }\n            else\n            {\n                bExportSRSToPAM = true;\n            }\n            CPLFree(pszWKT);\n        }\n\n        if( bPixelIsPoint )\n        {\n            GTIFKeySet( psGTIF, GTRasterTypeGeoKey, TYPE_SHORT, 1,\n                        RasterPixelIsPoint );\n        }\n\n        GTIFWriteKeys( psGTIF );\n        GTIFFree( psGTIF );\n    }\n\n    bool l_bDontReloadFirstBlock = false;\n\n#ifdef HAVE_LIBJPEG\n    if( bCopyFromJPEG )\n    {\n        GTIFF_CopyFromJPEG_WriteAdditionalTags(l_hTIFF,\n                                               poSrcDS);\n    }\n#endif\n\n/* -------------------------------------------------------------------- */\n/*      Cleanup                                                         */\n/* -------------------------------------------------------------------- */\n#ifdef SUPPORTS_GET_OFFSET_BYTECOUNT\n    if( bCopySrcOverviews )\n    {\n        TIFFDeferStrileArrayWriting( l_hTIFF );\n    }\n#endif\n    TIFFWriteCheck( l_hTIFF, TIFFIsTiled(l_hTIFF), \"GTiffCreateCopy()\" );\n    TIFFWriteDirectory( l_hTIFF );\n    if( bStreaming )\n    {\n        // We need to write twice the directory to be sure that custom\n        // TIFF tags are correctly sorted and that padding bytes have been\n        // added.\n        TIFFSetDirectory( l_hTIFF, 0 );\n        TIFFWriteDirectory( l_hTIFF );\n\n        if( VSIFSeekL( l_fpL, 0, SEEK_END ) != 0 )\n            ReportError(pszFilename, CE_Failure, CPLE_FileIO, \"Cannot seek\");\n        const int nSize = static_cast<int>( VSIFTellL(l_fpL) );\n\n        vsi_l_offset nDataLength = 0;\n        VSIGetMemFileBuffer( l_osTmpFilename, &nDataLength, FALSE);\n        TIFFSetDirectory( l_hTIFF, 0 );\n        GTiffFillStreamableOffsetAndCount( l_hTIFF, nSize );\n        TIFFWriteDirectory( l_hTIFF );\n    }\n    TIFFSetDirectory( l_hTIFF,\n                    static_cast<tdir_t>(TIFFNumberOfDirectories(l_hTIFF) - 1) );\n    const toff_t l_nDirOffset = TIFFCurrentDirOffset( l_hTIFF );\n    TIFFFlush( l_hTIFF );\n    XTIFFClose( l_hTIFF );\n\n    VSIFSeekL(l_fpL, 0, SEEK_SET);\n\n    // fpStreaming will assigned to the instance and not closed here.\n    VSILFILE *fpStreaming = nullptr;\n    if( bStreaming )\n    {\n        vsi_l_offset nDataLength = 0;\n        void* pabyBuffer =\n            VSIGetMemFileBuffer( l_osTmpFilename, &nDataLength, FALSE);\n        fpStreaming = VSIFOpenL( pszFilename, \"wb\" );\n        if( fpStreaming == nullptr )\n        {\n            VSIUnlink(l_osTmpFilename);\n            CPL_IGNORE_RET_VAL( VSIFCloseL(l_fpL) );\n            return nullptr;\n        }\n        if( static_cast<vsi_l_offset>(\n                VSIFWriteL( pabyBuffer, 1, static_cast<int>(nDataLength),\n                            fpStreaming ) ) != nDataLength )\n        {\n            ReportError(pszFilename, CE_Failure, CPLE_FileIO,\n                        \"Could not write %d bytes\",\n                        static_cast<int>(nDataLength) );\n            CPL_IGNORE_RET_VAL(VSIFCloseL( fpStreaming ));\n            VSIUnlink(l_osTmpFilename);\n            CPL_IGNORE_RET_VAL( VSIFCloseL(l_fpL) );\n            return nullptr;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Re-open as a dataset and copy over missing metadata using       */\n/*      PAM facilities.                                                 */\n/* -------------------------------------------------------------------- */\n    l_hTIFF =\n        VSI_TIFFOpen( bStreaming ? l_osTmpFilename.c_str() : pszFilename,\n                      \"r+\",\n                      l_fpL );\n    if( l_hTIFF == nullptr )\n    {\n        if( bStreaming ) VSIUnlink(l_osTmpFilename);\n        CPL_IGNORE_RET_VAL( VSIFCloseL(l_fpL) );\n        return nullptr;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Create a corresponding GDALDataset.                             */\n/* -------------------------------------------------------------------- */\n    GTiffDataset *poDS = new GTiffDataset();\n    poDS->SetDescription( pszFilename );\n    poDS->eAccess = GA_Update;\n    poDS->m_pszFilename = CPLStrdup(pszFilename);\n    poDS->m_fpL = l_fpL;\n    poDS->m_bIMDRPCMetadataLoaded = true;\n\n    const bool bAppend = CPLFetchBool(papszOptions, \"APPEND_SUBDATASET\", false);\n    if( poDS->OpenOffset( l_hTIFF,\n                          bAppend ? l_nDirOffset : TIFFCurrentDirOffset(l_hTIFF),\n                          GA_Update,\n                          false, // bAllowRGBAInterface\n                          true // bReadGeoTransform\n                         ) != CE_None )\n    {\n        delete poDS;\n        if( bStreaming ) VSIUnlink(l_osTmpFilename);\n        return nullptr;\n    }\n    poDS->oOvManager.Initialize( poDS, pszFilename );\n\n    if( bStreaming )\n    {\n        VSIUnlink(l_osTmpFilename);\n        poDS->m_fpToWrite = fpStreaming;\n    }\n    poDS->m_eProfile = eProfile;\n\n    int nCloneInfoFlags = GCIF_PAM_DEFAULT & ~GCIF_MASK;\n\n    // If we explicitly asked not to tag the alpha band as such, do not\n    // reintroduce this alpha color interpretation in PAM.\n    if( poSrcDS->GetRasterBand(l_nBands)->GetColorInterpretation() ==\n        GCI_AlphaBand &&\n        GTiffGetAlphaValue(\n            CPLGetConfigOption(\n                \"GTIFF_ALPHA\",\n                CSLFetchNameValue(papszOptions,\"ALPHA\") ),\n            DEFAULT_ALPHA_TYPE) == EXTRASAMPLE_UNSPECIFIED )\n    {\n        nCloneInfoFlags &= ~GCIF_COLORINTERP;\n    }\n    // Ignore source band color interpretation if requesting PHOTOMETRIC=RGB\n    else if( l_nBands >= 3 &&\n        EQUAL(CSLFetchNameValueDef(papszOptions, \"PHOTOMETRIC\", \"\"), \"RGB\") )\n    {\n        for( int i = 1; i <= 3; i++)\n        {\n            poDS->GetRasterBand(i)->SetColorInterpretation(\n                static_cast<GDALColorInterp>(GCI_RedBand + (i-1)));\n        }\n        nCloneInfoFlags &= ~GCIF_COLORINTERP;\n        if( !(l_nBands == 4 && CSLFetchNameValue(papszOptions, \"ALPHA\") != nullptr) )\n        {\n            for( int i = 4; i <= l_nBands; i++)\n            {\n                poDS->GetRasterBand(i)->SetColorInterpretation(\n                    poSrcDS->GetRasterBand(i)->GetColorInterpretation());\n            }\n        }\n    }\n\n    CPLString osOldGTIFF_REPORT_COMPD_CSVal(\n        CPLGetConfigOption(\"GTIFF_REPORT_COMPD_CS\", \"\"));\n    CPLSetThreadLocalConfigOption(\"GTIFF_REPORT_COMPD_CS\", \"YES\");\n    poDS->CloneInfo( poSrcDS, nCloneInfoFlags );\n    CPLSetThreadLocalConfigOption(\"GTIFF_REPORT_COMPD_CS\",\n        osOldGTIFF_REPORT_COMPD_CSVal.empty() ? nullptr :\n        osOldGTIFF_REPORT_COMPD_CSVal.c_str());\n\n    if( (!bGeoTIFF || bExportSRSToPAM) && (poDS->GetPamFlags() & GPF_DISABLED) == 0 )\n    {\n        // Copy georeferencing info to PAM if the profile is not GeoTIFF\n        poDS->GDALPamDataset::SetSpatialRef(poDS->GetSpatialRef());\n        double adfGeoTransform[6];\n        if( poDS->GetGeoTransform(adfGeoTransform) == CE_None )\n        {\n            poDS->GDALPamDataset::SetGeoTransform(adfGeoTransform);\n        }\n        poDS->GDALPamDataset::SetGCPs(poDS->GetGCPCount(),\n                                      poDS->GetGCPs(),\n                                      poDS->GetGCPSpatialRef());\n    }\n\n    poDS->m_papszCreationOptions = CSLDuplicate( papszOptions );\n    poDS->m_bDontReloadFirstBlock = l_bDontReloadFirstBlock;\n\n/* -------------------------------------------------------------------- */\n/*      CloneInfo() does not merge metadata, it just replaces it        */\n/*      totally.  So we have to merge it.                               */\n/* -------------------------------------------------------------------- */\n\n    char **papszSRC_MD = poSrcDS->GetMetadata();\n    char **papszDST_MD = CSLDuplicate(poDS->GetMetadata());\n\n    papszDST_MD = CSLMerge( papszDST_MD, papszSRC_MD );\n\n    poDS->SetMetadata( papszDST_MD );\n    CSLDestroy( papszDST_MD );\n\n    // Depending on the PHOTOMETRIC tag, the TIFF file may not have the same\n    // band count as the source. Will fail later in GDALDatasetCopyWholeRaster\n    // anyway.\n    for( int nBand = 1;\n         nBand <= std::min(poDS->GetRasterCount(), poSrcDS->GetRasterCount()) ;\n         ++nBand )\n    {\n        GDALRasterBand* poSrcBand = poSrcDS->GetRasterBand(nBand);\n        GDALRasterBand* poDstBand = poDS->GetRasterBand(nBand);\n        papszSRC_MD = poSrcBand->GetMetadata();\n        papszDST_MD = CSLDuplicate(poDstBand->GetMetadata());\n\n        papszDST_MD = CSLMerge( papszDST_MD, papszSRC_MD );\n\n        poDstBand->SetMetadata( papszDST_MD );\n        CSLDestroy( papszDST_MD );\n\n        char** papszCatNames = poSrcBand->GetCategoryNames();\n        if( nullptr != papszCatNames )\n            poDstBand->SetCategoryNames( papszCatNames );\n    }\n\n    l_hTIFF = static_cast<TIFF *>( poDS->GetInternalHandle(nullptr) );\n\n/* -------------------------------------------------------------------- */\n/*      Handle forcing xml:ESRI data to be written to PAM.              */\n/* -------------------------------------------------------------------- */\n    if( CPLTestBool(CPLGetConfigOption( \"ESRI_XML_PAM\", \"NO\" )) )\n    {\n        char **papszESRIMD = poSrcDS->GetMetadata(\"xml:ESRI\");\n        if( papszESRIMD )\n        {\n            poDS->SetMetadata( papszESRIMD, \"xml:ESRI\");\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Second chance: now that we have a PAM dataset, it is possible   */\n/*      to write metadata that we could not write as a TIFF tag.        */\n/* -------------------------------------------------------------------- */\n    if( !bHasWrittenMDInGeotiffTAG && !bStreaming )\n    {\n        GTiffDataset::WriteMetadata(\n            poDS, l_hTIFF, true, eProfile,\n            pszFilename, papszOptions,\n            true /* don't write RPC and IMD file again */ );\n    }\n\n    if( !bStreaming )\n        GTiffDataset::WriteRPC(\n            poDS, l_hTIFF, true, eProfile,\n            pszFilename, papszOptions,\n            true /* write only in PAM AND if needed */ );\n\n    // Propagate ISIS3 or VICAR metadata, but only as PAM metadata.\n    for( const char* pszMDD: { \"json:ISIS3\", \"json:VICAR\" } )\n    {\n        char **papszMD = poSrcDS->GetMetadata(pszMDD);\n        if( papszMD )\n        {\n            poDS->SetMetadata( papszMD, pszMDD);\n            poDS->PushMetadataToPam();\n        }\n    }\n\n    poDS->m_bWriteCOGLayout = bCopySrcOverviews;\n\n    // To avoid unnecessary directory rewriting.\n    poDS->m_bMetadataChanged = false;\n    poDS->m_bGeoTIFFInfoChanged = false;\n    poDS->m_bNoDataChanged = false;\n    poDS->m_bForceUnsetGTOrGCPs = false;\n    poDS->m_bForceUnsetProjection = false;\n    poDS->m_bStreamingOut = bStreaming;\n\n    // Don't try to load external metadata files (#6597).\n    poDS->m_bIMDRPCMetadataLoaded = true;\n\n    // We must re-set the compression level at this point, since it has been\n    // lost a few lines above when closing the newly create TIFF file The\n    // TIFFTAG_ZIPQUALITY & TIFFTAG_JPEGQUALITY are not store in the TIFF file.\n    // They are just TIFF session parameters.\n\n    poDS->m_nZLevel = GTiffGetZLevel(papszOptions);\n    poDS->m_nLZMAPreset = GTiffGetLZMAPreset(papszOptions);\n    poDS->m_nZSTDLevel = GTiffGetZSTDPreset(papszOptions);\n    poDS->m_nWebPLevel = GTiffGetWebPLevel(papszOptions);\n    poDS->m_bWebPLossless = GTiffGetWebPLossless(papszOptions);\n    poDS->m_nJpegQuality = GTiffGetJpegQuality(papszOptions);\n    poDS->m_nJpegTablesMode = GTiffGetJpegTablesMode(papszOptions);\n    poDS->GetDiscardLsbOption(papszOptions);\n#if HAVE_LERC\n    poDS->m_dfMaxZError = GTiffGetLERCMaxZError(papszOptions);\n#endif\n    poDS->InitCreationOrOpenOptions(papszOptions);\n\n    if( l_nCompression == COMPRESSION_ADOBE_DEFLATE ||\n        l_nCompression == COMPRESSION_LERC )\n    {\n        GTiffSetDeflateSubCodec(l_hTIFF);\n\n        if( poDS->m_nZLevel != -1 )\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_ZIPQUALITY, poDS->m_nZLevel );\n        }\n    }\n    if( l_nCompression == COMPRESSION_JPEG )\n    {\n        if( poDS->m_nJpegQuality != -1 )\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_JPEGQUALITY, poDS->m_nJpegQuality );\n        }\n        TIFFSetField( l_hTIFF, TIFFTAG_JPEGTABLESMODE, poDS->m_nJpegTablesMode );\n    }\n    if( l_nCompression == COMPRESSION_LZMA )\n    {\n        if( poDS->m_nLZMAPreset != -1 )\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_LZMAPRESET, poDS->m_nLZMAPreset );\n        }\n    }\n    if( l_nCompression == COMPRESSION_ZSTD ||\n        l_nCompression == COMPRESSION_LERC )\n    {\n        if( poDS->m_nZSTDLevel != -1 )\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_ZSTD_LEVEL, poDS->m_nZSTDLevel );\n        }\n    }\n#if HAVE_LERC\n    if( l_nCompression == COMPRESSION_LERC )\n    {\n        TIFFSetField( l_hTIFF, TIFFTAG_LERC_MAXZERROR, poDS->m_dfMaxZError );\n    }\n#endif\n    if( l_nCompression == COMPRESSION_WEBP )\n    {\n        if( poDS->m_nWebPLevel != -1 )\n        {\n            TIFFSetField( l_hTIFF, TIFFTAG_WEBP_LEVEL, poDS->m_nWebPLevel );\n        }\n\n        if( poDS->m_bWebPLossless)\n        {\n          TIFFSetField( l_hTIFF, TIFFTAG_WEBP_LOSSLESS, poDS->m_bWebPLossless );\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Do we want to ensure all blocks get written out on close to     */\n/*      avoid sparse files?                                             */\n/* -------------------------------------------------------------------- */\n    if( !CPLFetchBool( papszOptions, \"SPARSE_OK\", false ) )\n        poDS->m_bFillEmptyTilesAtClosing = true;\n\n    poDS->m_bWriteEmptyTiles =\n        (bCopySrcOverviews && poDS->m_bFillEmptyTilesAtClosing) ||\n        bStreaming ||\n        (poDS->m_nCompression != COMPRESSION_NONE &&\n            poDS->m_bFillEmptyTilesAtClosing);\n    // Only required for people writing non-compressed striped files in the\n    // rightorder and wanting all tstrips to be written in the same order\n    // so that the end result can be memory mapped without knowledge of each\n    // strip offset\n    if( CPLTestBool( CSLFetchNameValueDef(\n                            papszOptions,\n                            \"WRITE_EMPTY_TILES_SYNCHRONOUSLY\", \"FALSE\" )) ||\n        CPLTestBool( CSLFetchNameValueDef(\n                            papszOptions,\n                            \"@WRITE_EMPTY_TILES_SYNCHRONOUSLY\", \"FALSE\" )) )\n    {\n        poDS->m_bWriteEmptyTiles = true;\n    }\n\n    // Precreate (internal) mask, so that the IBuildOverviews() below\n    // has a chance to create also the overviews of the mask.\n    CPLErr eErr = CE_None;\n\n    if( bCreateMask )\n    {\n        eErr = poDS->CreateMaskBand( nMaskFlags );\n        if( poDS->m_poMaskDS )\n        {\n            poDS->m_poMaskDS->m_bFillEmptyTilesAtClosing = poDS->m_bFillEmptyTilesAtClosing;\n            poDS->m_poMaskDS->m_bWriteEmptyTiles = poDS->m_bWriteEmptyTiles;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Create and then copy existing overviews if requested            */\n/*  We do it such that all the IFDs are at the beginning of the file,   */\n/*  and that the imagery data for the smallest overview is written      */\n/*  first, that way the file is more usable when embedded in a          */\n/*  compressed stream.                                                  */\n/* -------------------------------------------------------------------- */\n\n    // For scaled progress due to overview copying.\n    const int nBandsWidthMask = l_nBands +  (bCreateMask ? 1 : 0);\n    double dfTotalPixels =\n        static_cast<double>(nXSize) * nYSize * nBandsWidthMask;\n    double dfCurPixels = 0;\n\n    if( eErr == CE_None && bCopySrcOverviews )\n    {\n        std::unique_ptr<GDALDataset> poMaskOvrDS;\n        const char* pszMaskOvrDS = CSLFetchNameValue(papszOptions, \"@MASK_OVERVIEW_DATASET\");\n        if( pszMaskOvrDS )\n        {\n            poMaskOvrDS.reset(GDALDataset::Open(pszMaskOvrDS));\n            if( !poMaskOvrDS )\n            {\n                delete poDS;\n                return nullptr;\n            }\n            if( poMaskOvrDS->GetRasterCount() != 1 )\n            {\n                delete poDS;\n                return nullptr;\n            }\n        }\n        if( nSrcOverviews )\n        {\n            eErr = poDS->CreateOverviewsFromSrcOverviews(poSrcDS, poOvrDS.get());\n\n            if( eErr == CE_None &&\n                (poMaskOvrDS != nullptr ||\n                 (poSrcDS->GetRasterBand(1)->GetOverview(0) &&\n                  poSrcDS->GetRasterBand(1)->GetOverview(0)->GetMaskFlags() == GMF_PER_DATASET)) )\n            {\n                int nOvrBlockXSize = 0;\n                int nOvrBlockYSize = 0;\n                GTIFFGetOverviewBlockSize(\n                    GDALRasterBand::ToHandle(poDS->GetRasterBand(1)),\n                    &nOvrBlockXSize, &nOvrBlockYSize);\n                eErr = poDS->CreateInternalMaskOverviews(nOvrBlockXSize, nOvrBlockYSize);\n            }\n        }\n\n#ifdef SUPPORTS_GET_OFFSET_BYTECOUNT\n        TIFFForceStrileArrayWriting( poDS->m_hTIFF );\n\n        if( poDS->m_poMaskDS )\n        {\n            TIFFForceStrileArrayWriting( poDS->m_poMaskDS->m_hTIFF );\n        }\n\n        for( int i = 0; i < poDS->m_nOverviewCount; i++)\n        {\n            TIFFForceStrileArrayWriting( poDS->m_papoOverviewDS[i]->m_hTIFF );\n\n            if( poDS->m_papoOverviewDS[i]->m_poMaskDS )\n            {\n                TIFFForceStrileArrayWriting(\n                    poDS->m_papoOverviewDS[i]->m_poMaskDS->m_hTIFF );\n            }\n        }\n#endif\n\n        if( eErr == CE_None && nSrcOverviews )\n        {\n            if( poDS->m_nOverviewCount != nSrcOverviews )\n            {\n                ReportError( pszFilename, CE_Failure, CPLE_AppDefined,\n                        \"Did only manage to instantiate %d overview levels, \"\n                        \"whereas source contains %d\",\n                        poDS->m_nOverviewCount, nSrcOverviews);\n                eErr = CE_Failure;\n            }\n\n            for( int i = 0; eErr == CE_None && i < nSrcOverviews; ++i )\n            {\n                GDALRasterBand* poOvrBand = poOvrDS ?\n                    (i == 0 ? poOvrDS->GetRasterBand(1) : poOvrDS->GetRasterBand(1)->GetOverview(i-1)) :\n                    poSrcDS->GetRasterBand(1)->GetOverview(i);\n                const double dfOvrPixels =\n                    static_cast<double>(poOvrBand->GetXSize()) *\n                                poOvrBand->GetYSize();\n                dfTotalPixels += dfOvrPixels * l_nBands;\n                if( poOvrBand->GetMaskFlags() == GMF_PER_DATASET ||\n                    poMaskOvrDS != nullptr )\n                {\n                    dfTotalPixels += dfOvrPixels;\n                }\n                else if( i == 0 &&\n                         poDS->GetRasterBand(1)->GetMaskFlags() == GMF_PER_DATASET )\n                {\n                    ReportError( pszFilename, CE_Warning, CPLE_AppDefined,\n                             \"Source dataset has a mask band on full \"\n                             \"resolution, overviews on the regular bands, \"\n                             \"but lacks overviews on the mask band.\");\n                }\n            }\n\n            char* papszCopyWholeRasterOptions[2] = { nullptr, nullptr };\n            if( l_nCompression != COMPRESSION_NONE )\n                papszCopyWholeRasterOptions[0] =\n                    const_cast<char*>( \"COMPRESSED=YES\" );\n            // Now copy the imagery.\n            // Begin with the smallest overview.\n            for( int iOvrLevel = nSrcOverviews - 1;\n                    eErr == CE_None && iOvrLevel >= 0; --iOvrLevel )\n            {\n                auto poDstDS = poDS->m_papoOverviewDS[iOvrLevel];\n\n                // Create a fake dataset with the source overview level so that\n                // GDALDatasetCopyWholeRaster can cope with it.\n                GDALDataset* poSrcOvrDS = poOvrDS ?\n                    (iOvrLevel == 0 ? poOvrDS.get() :\n                        GDALCreateOverviewDataset(poOvrDS.get(), iOvrLevel - 1, TRUE)) :\n                    GDALCreateOverviewDataset(poSrcDS, iOvrLevel, TRUE);\n                GDALRasterBand* poSrcOvrBand = poOvrDS ?\n                    (iOvrLevel == 0 ? poOvrDS->GetRasterBand(1):\n                        poOvrDS->GetRasterBand(1)->GetOverview(iOvrLevel - 1)) :\n                    poSrcDS->GetRasterBand(1)->GetOverview(iOvrLevel);\n                double dfNextCurPixels =\n                    dfCurPixels +\n                    static_cast<double>(poSrcOvrBand->GetXSize()) *\n                    poSrcOvrBand->GetYSize() * l_nBands;\n\n                poDstDS->m_bBlockOrderRowMajor = true;\n                poDstDS->m_bLeaderSizeAsUInt4 = true;\n                poDstDS->m_bTrailerRepeatedLast4BytesRepeated = true;\n                poDstDS->m_bFillEmptyTilesAtClosing = poDS->m_bFillEmptyTilesAtClosing;\n                poDstDS->m_bWriteEmptyTiles = poDS->m_bWriteEmptyTiles;\n                GDALRasterBand* poSrcMaskBand = nullptr;\n                if( poDstDS->m_poMaskDS )\n                {\n                    poDstDS->m_poMaskDS->m_bBlockOrderRowMajor = true;\n                    poDstDS->m_poMaskDS->m_bLeaderSizeAsUInt4 = true;\n                    poDstDS->m_poMaskDS->m_bTrailerRepeatedLast4BytesRepeated = true;\n                    poDstDS->m_poMaskDS->m_bFillEmptyTilesAtClosing = poDS->m_bFillEmptyTilesAtClosing;\n                    poDstDS->m_poMaskDS->m_bWriteEmptyTiles = poDS->m_bWriteEmptyTiles;\n\n                    poSrcMaskBand = poMaskOvrDS ?\n                        (iOvrLevel == 0 ? poMaskOvrDS->GetRasterBand(1) :\n                            poMaskOvrDS->GetRasterBand(1)->GetOverview(iOvrLevel - 1)) :\n                        poSrcOvrBand->GetMaskBand();\n                }\n\n                if( l_nBands == 1 || poDstDS->m_nPlanarConfig == PLANARCONFIG_CONTIG)\n                {\n                    if( poDstDS->m_poMaskDS )\n                    {\n                        dfNextCurPixels +=\n                            static_cast<double>(poSrcOvrBand->GetXSize()) *\n                                                poSrcOvrBand->GetYSize();\n                    }\n                    void* pScaledData =\n                        GDALCreateScaledProgress( dfCurPixels / dfTotalPixels,\n                                                  dfNextCurPixels / dfTotalPixels,\n                                                  pfnProgress, pProgressData );\n\n                    eErr = CopyImageryAndMask(poDstDS, poSrcOvrDS,\n                                      poSrcMaskBand,\n                                      GDALScaledProgress, pScaledData);\n\n\n                    dfCurPixels = dfNextCurPixels;\n                    GDALDestroyScaledProgress(pScaledData);\n                }\n                else\n                {\n                    void* pScaledData =\n                        GDALCreateScaledProgress( dfCurPixels / dfTotalPixels,\n                                                dfNextCurPixels / dfTotalPixels,\n                                                pfnProgress, pProgressData );\n\n                    eErr =\n                        GDALDatasetCopyWholeRaster(\n                            GDALDataset::ToHandle(poSrcOvrDS),\n                            GDALDataset::ToHandle(poDstDS),\n                            papszCopyWholeRasterOptions,\n                            GDALScaledProgress, pScaledData );\n\n                    dfCurPixels = dfNextCurPixels;\n                    GDALDestroyScaledProgress(pScaledData);\n\n                    poDstDS->FlushCache();\n\n                    // Copy mask of the overview.\n                    if( eErr == CE_None &&\n                        (poMaskOvrDS ||\n                         poSrcOvrBand->GetMaskFlags() == GMF_PER_DATASET) &&\n                        poDstDS->m_poMaskDS != nullptr )\n                    {\n                        dfNextCurPixels +=\n                            static_cast<double>(poSrcOvrBand->GetXSize()) *\n                                                poSrcOvrBand->GetYSize();\n                        pScaledData =\n                            GDALCreateScaledProgress( dfCurPixels / dfTotalPixels,\n                                                dfNextCurPixels / dfTotalPixels,\n                                                pfnProgress, pProgressData );\n                        eErr =\n                            GDALRasterBandCopyWholeRaster(\n                                poSrcMaskBand,\n                                poDstDS->m_poMaskDS->GetRasterBand(1),\n                                papszCopyWholeRasterOptions,\n                                GDALScaledProgress, pScaledData );\n                        dfCurPixels = dfNextCurPixels;\n                        GDALDestroyScaledProgress(pScaledData);\n                        poDstDS->m_poMaskDS->FlushCache();\n                    }\n                }\n\n                if( poSrcOvrDS != poOvrDS.get() )\n                    delete poSrcOvrDS;\n                poSrcOvrDS = nullptr;\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Copy actual imagery.                                            */\n/* -------------------------------------------------------------------- */\n    double dfNextCurPixels =\n        dfCurPixels + static_cast<double>(nXSize) * nYSize * l_nBands;\n    void* pScaledData = GDALCreateScaledProgress(\n        dfCurPixels / dfTotalPixels,\n        dfNextCurPixels / dfTotalPixels,\n        pfnProgress, pProgressData);\n\n#if defined(HAVE_LIBJPEG) || defined(JPEG_DIRECT_COPY)\n    bool bTryCopy = true;\n#endif\n\n#ifdef HAVE_LIBJPEG\n    if( bCopyFromJPEG )\n    {\n        eErr = GTIFF_CopyFromJPEG( poDS, poSrcDS,\n                                   pfnProgress, pProgressData,\n                                   bTryCopy );\n\n        // In case of failure in the decompression step, try normal copy.\n        if( bTryCopy )\n            eErr = CE_None;\n    }\n#endif\n\n#ifdef JPEG_DIRECT_COPY\n    if( bDirectCopyFromJPEG )\n    {\n        eErr = GTIFF_DirectCopyFromJPEG(poDS, poSrcDS,\n                                        pfnProgress, pProgressData,\n                                        bTryCopy);\n\n        // In case of failure in the reading step, try normal copy.\n        if( bTryCopy )\n            eErr = CE_None;\n    }\n#endif\n\n    bool bWriteMask = true;\n    if( \n#if defined(HAVE_LIBJPEG) || defined(JPEG_DIRECT_COPY)\n        bTryCopy &&\n#endif\n        (poDS->m_bTreatAsSplit || poDS->m_bTreatAsSplitBitmap) )\n    {\n        // For split bands, we use TIFFWriteScanline() interface.\n        CPLAssert(poDS->m_nBitsPerSample == 8 || poDS->m_nBitsPerSample == 1);\n\n        if( poDS->m_nPlanarConfig == PLANARCONFIG_CONTIG && poDS->nBands > 1 )\n        {\n            GByte* pabyScanline =\n                static_cast<GByte *>(\n                    VSI_MALLOC_VERBOSE(TIFFScanlineSize(l_hTIFF)) );\n            if( pabyScanline == nullptr )\n                eErr = CE_Failure;\n            for( int j = 0; j < nYSize && eErr == CE_None; ++j )\n            {\n                eErr =\n                    poSrcDS->RasterIO(\n                        GF_Read, 0, j, nXSize, 1,\n                        pabyScanline, nXSize, 1,\n                        GDT_Byte, l_nBands, nullptr, poDS->nBands, 0, 1,\n                        nullptr );\n                if( eErr == CE_None &&\n                    TIFFWriteScanline( l_hTIFF, pabyScanline, j, 0) == -1 )\n                {\n                    ReportError( pszFilename, CE_Failure, CPLE_AppDefined,\n                              \"TIFFWriteScanline() failed.\" );\n                    eErr = CE_Failure;\n                }\n                if( !GDALScaledProgress( (j + 1) * 1.0 / nYSize,\n                                         nullptr, pScaledData ) )\n                    eErr = CE_Failure;\n            }\n            CPLFree( pabyScanline );\n        }\n        else\n        {\n            GByte* pabyScanline = static_cast<GByte *>(\n                VSI_MALLOC_VERBOSE(nXSize) );\n            if( pabyScanline == nullptr )\n                eErr = CE_Failure;\n            else\n                eErr = CE_None;\n            for( int iBand = 1; iBand <= l_nBands && eErr == CE_None; ++iBand )\n            {\n                for( int j = 0; j < nYSize && eErr == CE_None; ++j )\n                {\n                    eErr = poSrcDS->GetRasterBand(iBand)->RasterIO(\n                        GF_Read, 0, j, nXSize, 1,\n                        pabyScanline, nXSize, 1,\n                        GDT_Byte, 0, 0, nullptr );\n                    if( poDS->m_bTreatAsSplitBitmap )\n                    {\n                        for( int i = 0; i < nXSize; ++i )\n                        {\n                            const GByte byVal = pabyScanline[i];\n                            if( (i & 0x7) == 0 )\n                                pabyScanline[i >> 3] = 0;\n                            if( byVal )\n                                pabyScanline[i >> 3] |= 0x80 >> (i & 0x7);\n                        }\n                    }\n                    if( eErr == CE_None &&\n                        TIFFWriteScanline(\n                            l_hTIFF, pabyScanline, j,\n                            static_cast<uint16>(iBand - 1)) == -1 )\n                    {\n                        ReportError( pszFilename, CE_Failure, CPLE_AppDefined,\n                                  \"TIFFWriteScanline() failed.\" );\n                        eErr = CE_Failure;\n                    }\n                    if( !GDALScaledProgress(\n                           (j + 1 + (iBand - 1) * nYSize) * 1.0 /\n                           (l_nBands * nYSize),\n                           nullptr, pScaledData ) )\n                        eErr = CE_Failure;\n                }\n            }\n            CPLFree(pabyScanline);\n        }\n\n        // Necessary to be able to read the file without re-opening.\n        TIFFSizeProc pfnSizeProc = TIFFGetSizeProc( l_hTIFF );\n\n        TIFFFlushData( l_hTIFF );\n\n        toff_t nNewDirOffset = pfnSizeProc( TIFFClientdata( l_hTIFF ) );\n        if( (nNewDirOffset % 2) == 1 )\n            ++nNewDirOffset;\n\n        TIFFFlush( l_hTIFF );\n\n        if( poDS->m_nDirOffset != TIFFCurrentDirOffset( l_hTIFF ) )\n        {\n            poDS->m_nDirOffset = nNewDirOffset;\n            CPLDebug( \"GTiff\", \"directory moved during flush.\" );\n        }\n    }\n    else if( \n#if defined(HAVE_LIBJPEG) || defined(JPEG_DIRECT_COPY)\n        bTryCopy &&\n#endif\n        eErr == CE_None )\n    {\n        const char* papszCopyWholeRasterOptions[3] = { nullptr, nullptr, nullptr };\n        int iNextOption = 0;\n        papszCopyWholeRasterOptions[iNextOption++] =\n                \"SKIP_HOLES=YES\" ;\n        if( l_nCompression != COMPRESSION_NONE )\n        {\n            papszCopyWholeRasterOptions[iNextOption++] =\n                \"COMPRESSED=YES\";\n        }\n        // For streaming with separate, we really want that bands are written\n        // after each other, even if the source is pixel interleaved.\n        else if( bStreaming && poDS->m_nPlanarConfig == PLANARCONFIG_SEPARATE )\n        {\n            papszCopyWholeRasterOptions[iNextOption++] =\n                \"INTERLEAVE=BAND\";\n        }\n\n        if( bCopySrcOverviews &&\n            (l_nBands == 1 || poDS->m_nPlanarConfig == PLANARCONFIG_CONTIG) )\n        {\n            poDS->m_bBlockOrderRowMajor = true;\n            poDS->m_bLeaderSizeAsUInt4 = true;\n            poDS->m_bTrailerRepeatedLast4BytesRepeated = true;\n            if( poDS->m_poMaskDS )\n            {\n                poDS->m_poMaskDS->m_bBlockOrderRowMajor = true;\n                poDS->m_poMaskDS->m_bLeaderSizeAsUInt4 = true;\n                poDS->m_poMaskDS->m_bTrailerRepeatedLast4BytesRepeated = true;\n            }\n\n            if( poDS->m_poMaskDS )\n            {\n                GDALDestroyScaledProgress(pScaledData);\n                pScaledData = GDALCreateScaledProgress(\n                                dfCurPixels / dfTotalPixels,\n                                1.0,\n                                pfnProgress, pProgressData);\n            }\n\n            eErr = CopyImageryAndMask(poDS, poSrcDS,\n                              poSrcDS->GetRasterBand(1)->GetMaskBand(),\n                              GDALScaledProgress, pScaledData);\n            if( poDS->m_poMaskDS )\n            {\n                bWriteMask = false;\n            }\n        }\n        else\n        {\n            eErr = GDALDatasetCopyWholeRaster(\n                /* (GDALDatasetH) */ poSrcDS,\n                /* (GDALDatasetH) */ poDS,\n                papszCopyWholeRasterOptions,\n                GDALScaledProgress, pScaledData );\n        }\n    }\n\n    GDALDestroyScaledProgress(pScaledData);\n\n    if( eErr == CE_None && !bStreaming && bWriteMask )\n    {\n        pScaledData = GDALCreateScaledProgress(\n            dfNextCurPixels / dfTotalPixels,\n            1.0,\n            pfnProgress, pProgressData);\n        if( poDS->m_poMaskDS )\n        {\n            const char* l_papszOptions[2] = { \"COMPRESSED=YES\", nullptr };\n            eErr = GDALRasterBandCopyWholeRaster(\n                                    poSrcDS->GetRasterBand(1)->GetMaskBand(),\n                                    poDS->GetRasterBand(1)->GetMaskBand(),\n                                    const_cast<char **>(l_papszOptions),\n                                    GDALScaledProgress, pScaledData );\n        }\n        else\n        {\n            eErr = GDALDriver::DefaultCopyMasks( poSrcDS, poDS, bStrict,\n                                                 nullptr,\n                                                 GDALScaledProgress, pScaledData );\n        }\n        GDALDestroyScaledProgress(pScaledData);\n    }\n\n    poDS->m_bWriteCOGLayout = false;\n\n    if( eErr == CE_Failure )\n    {\n        delete poDS;\n        poDS = nullptr;\n\n        if( CPLTestBool(CPLGetConfigOption(\"GTIFF_DELETE_ON_ERROR\", \"YES\")) )\n        {\n            if( !bStreaming )\n            {\n                // Should really delete more carefully.\n                VSIUnlink( pszFilename );\n            }\n        }\n    }\n\n    return poDS;\n}\n\n/************************************************************************/\n/*                          GetSpatialRef()                             */\n/************************************************************************/\n\nconst OGRSpatialReference* GTiffDataset::GetSpatialRef() const\n\n{\n    if( m_nGCPCount == 0 )\n    {\n        const_cast<GTiffDataset*>(this)->LoadGeoreferencingAndPamIfNeeded();\n        const_cast<GTiffDataset*>(this)->LookForProjection();\n\n        return m_oSRS.IsEmpty() ? nullptr : &m_oSRS;\n    }\n\n    return nullptr;\n}\n\n/************************************************************************/\n/*                           SetSpatialRef()                            */\n/************************************************************************/\n\nCPLErr GTiffDataset::SetSpatialRef( const OGRSpatialReference * poSRS )\n\n{\n    if( m_bStreamingOut && m_bCrystalized )\n    {\n        ReportError(\n            CE_Failure, CPLE_NotSupported,\n            \"Cannot modify projection at that point in \"\n            \"a streamed output file\" );\n        return CE_Failure;\n    }\n\n    LoadGeoreferencingAndPamIfNeeded();\n    LookForProjection();\n\n    if( poSRS == nullptr || poSRS->IsEmpty() )\n    {\n        if( !m_oSRS.IsEmpty() )\n        {\n            m_bForceUnsetProjection = true;\n        }\n        m_oSRS.Clear();\n    }\n    else\n    {\n        m_oSRS = *poSRS;\n        m_oSRS.SetAxisMappingStrategy(OAMS_TRADITIONAL_GIS_ORDER);\n    }\n\n    m_bGeoTIFFInfoChanged = true;\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                          GetGeoTransform()                           */\n/************************************************************************/\n\nCPLErr GTiffDataset::GetGeoTransform( double * padfTransform )\n\n{\n    LoadGeoreferencingAndPamIfNeeded();\n\n    memcpy( padfTransform, m_adfGeoTransform, sizeof(double) * 6 );\n\n    if( !m_bGeoTransformValid )\n        return CE_Failure;\n\n    // Same logic as in the .gtx driver, for the benefit of GDALOpenVerticalShiftGrid()\n    // when used with PROJ-data's US geoids.\n    if( CPLFetchBool(papszOpenOptions,\n                                \"SHIFT_ORIGIN_IN_MINUS_180_PLUS_180\", false) )\n    {\n        if( padfTransform[0] < -180.0 - padfTransform[1] )\n            padfTransform[0] += 360.0;\n        else if( padfTransform[0] > 180.0 )\n            padfTransform[0] -= 360.0;\n    }\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                          SetGeoTransform()                           */\n/************************************************************************/\n\nCPLErr GTiffDataset::SetGeoTransform( double * padfTransform )\n\n{\n    if( m_bStreamingOut && m_bCrystalized )\n    {\n        ReportError(\n            CE_Failure, CPLE_NotSupported,\n            \"Cannot modify geotransform at that point in a \"\n            \"streamed output file\" );\n        return CE_Failure;\n    }\n\n    LoadGeoreferencingAndPamIfNeeded();\n\n    if( GetAccess() == GA_Update )\n    {\n        if( m_nGCPCount > 0 )\n        {\n            ReportError(CE_Warning, CPLE_AppDefined,\n                     \"GCPs previously set are going to be cleared \"\n                     \"due to the setting of a geotransform.\");\n            m_bForceUnsetGTOrGCPs = true;\n            GDALDeinitGCPs( m_nGCPCount, m_pasGCPList );\n            CPLFree( m_pasGCPList );\n            m_nGCPCount = 0;\n            m_pasGCPList = nullptr;\n        }\n        else if( padfTransform[0] == 0.0 &&\n                 padfTransform[1] == 0.0 &&\n                 padfTransform[2] == 0.0 &&\n                 padfTransform[3] == 0.0 &&\n                 padfTransform[4] == 0.0 &&\n                 padfTransform[5] == 0.0 )\n        {\n            if( m_bGeoTransformValid )\n            {\n                m_bForceUnsetGTOrGCPs = true;\n                m_bGeoTIFFInfoChanged = true;\n            }\n            m_bGeoTransformValid = false;\n            memcpy( m_adfGeoTransform, padfTransform, sizeof(double)*6 );\n            return CE_None;\n        }\n\n        memcpy( m_adfGeoTransform, padfTransform, sizeof(double)*6 );\n        m_bGeoTransformValid = true;\n        m_bGeoTIFFInfoChanged = true;\n\n        return CE_None;\n    }\n    else\n    {\n        ReportError(\n            CE_Failure, CPLE_NotSupported,\n            \"Attempt to call SetGeoTransform() on a read-only GeoTIFF file.\" );\n        return CE_Failure;\n    }\n}\n\n/************************************************************************/\n/*                            GetGCPCount()                             */\n/************************************************************************/\n\nint GTiffDataset::GetGCPCount()\n\n{\n    LoadGeoreferencingAndPamIfNeeded();\n\n    return m_nGCPCount;\n}\n\n/************************************************************************/\n/*                          GetGCPSpatialRef()                          */\n/************************************************************************/\n\nconst OGRSpatialReference *GTiffDataset::GetGCPSpatialRef() const\n\n{\n    const_cast<GTiffDataset*>(this)->LoadGeoreferencingAndPamIfNeeded();\n\n    if( m_nGCPCount > 0 )\n    {\n        const_cast<GTiffDataset*>(this)->LookForProjection();\n    }\n    if( !m_oSRS.IsEmpty() )\n        return &m_oSRS;\n\n    return nullptr;\n}\n\n/************************************************************************/\n/*                               GetGCPs()                              */\n/************************************************************************/\n\nconst GDAL_GCP *GTiffDataset::GetGCPs()\n\n{\n    LoadGeoreferencingAndPamIfNeeded();\n\n    return m_pasGCPList;\n}\n\n/************************************************************************/\n/*                               SetGCPs()                              */\n/************************************************************************/\n\nCPLErr GTiffDataset::SetGCPs( int nGCPCountIn, const GDAL_GCP *pasGCPListIn,\n                              const OGRSpatialReference *poGCPSRS )\n{\n    LoadGeoreferencingAndPamIfNeeded();\n\n    if( GetAccess() == GA_Update )\n    {\n        LookForProjection();\n\n        if( m_nGCPCount > 0 && nGCPCountIn == 0 )\n        {\n            m_bForceUnsetGTOrGCPs = true;\n        }\n        else if( nGCPCountIn > 0 &&\n                 m_bGeoTransformValid )\n        {\n            ReportError(CE_Warning, CPLE_AppDefined,\n                     \"A geotransform previously set is going to be cleared \"\n                     \"due to the setting of GCPs.\");\n            m_adfGeoTransform[0] = 0.0;\n            m_adfGeoTransform[1] = 1.0;\n            m_adfGeoTransform[2] = 0.0;\n            m_adfGeoTransform[3] = 0.0;\n            m_adfGeoTransform[4] = 0.0;\n            m_adfGeoTransform[5] = 1.0;\n            m_bGeoTransformValid = false;\n            m_bForceUnsetGTOrGCPs = true;\n        }\n\n        if( poGCPSRS == nullptr || poGCPSRS->IsEmpty() )\n        {\n            if( !m_oSRS.IsEmpty() )\n            {\n                m_bForceUnsetProjection = true;\n            }\n            m_oSRS.Clear();\n        }\n        else\n        {\n            m_oSRS = *poGCPSRS;\n            m_oSRS.SetAxisMappingStrategy(OAMS_TRADITIONAL_GIS_ORDER);\n        }\n\n        if( m_nGCPCount > 0 )\n        {\n            GDALDeinitGCPs( m_nGCPCount, m_pasGCPList );\n            CPLFree( m_pasGCPList );\n        }\n\n        m_nGCPCount = nGCPCountIn;\n        m_pasGCPList = GDALDuplicateGCPs(m_nGCPCount, pasGCPListIn);\n\n        m_bGeoTIFFInfoChanged = true;\n\n        return CE_None;\n    }\n    else\n    {\n        ReportError(CE_Failure, CPLE_NotSupported,\n                 \"SetGCPs() is only supported on newly created GeoTIFF files.\");\n        return CE_Failure;\n    }\n}\n\n/************************************************************************/\n/*                      GetMetadataDomainList()                         */\n/************************************************************************/\n\nchar **GTiffDataset::GetMetadataDomainList()\n{\n    LoadGeoreferencingAndPamIfNeeded();\n\n    char **papszDomainList = CSLDuplicate(m_oGTiffMDMD.GetDomainList());\n    char **papszBaseList = GDALDataset::GetMetadataDomainList();\n\n    const int nbBaseDomains = CSLCount(papszBaseList);\n\n    for( int domainId = 0; domainId < nbBaseDomains; ++domainId )\n    {\n        if( CSLFindString(papszDomainList, papszBaseList[domainId]) < 0 )\n        {\n            papszDomainList = CSLAddString(papszDomainList,papszBaseList[domainId]);\n        }\n    }\n\n    CSLDestroy(papszBaseList);\n\n    return BuildMetadataDomainList(\n        papszDomainList,\n        TRUE,\n        \"\", \"ProxyOverviewRequest\", MD_DOMAIN_RPC, MD_DOMAIN_IMD,\n        \"SUBDATASETS\", \"EXIF\",\n        \"xml:XMP\", \"COLOR_PROFILE\", nullptr);\n}\n\n/************************************************************************/\n/*                            GetMetadata()                             */\n/************************************************************************/\n\nchar **GTiffDataset::GetMetadata( const char * pszDomain )\n\n{\n    if( pszDomain == nullptr || !EQUAL(pszDomain, \"IMAGE_STRUCTURE\") )\n    {\n        LoadGeoreferencingAndPamIfNeeded();\n    }\n\n    if( pszDomain != nullptr && EQUAL(pszDomain, \"ProxyOverviewRequest\") )\n        return GDALPamDataset::GetMetadata( pszDomain );\n\n    if( pszDomain != nullptr && EQUAL(pszDomain, \"DERIVED_SUBDATASETS\"))\n    {\n        return GDALDataset::GetMetadata(pszDomain);\n    }\n\n    else if( pszDomain != nullptr && (EQUAL(pszDomain, MD_DOMAIN_RPC) ||\n                                   EQUAL(pszDomain, MD_DOMAIN_IMD) ||\n                                   EQUAL(pszDomain, MD_DOMAIN_IMAGERY)) )\n        LoadMetadata();\n\n    else if( pszDomain != nullptr && EQUAL(pszDomain, \"SUBDATASETS\") )\n        ScanDirectories();\n\n    else if( pszDomain != nullptr && EQUAL(pszDomain, \"EXIF\") )\n        LoadEXIFMetadata();\n\n    else if( pszDomain != nullptr && EQUAL(pszDomain, \"COLOR_PROFILE\") )\n        LoadICCProfile();\n\n    else if( pszDomain == nullptr || EQUAL(pszDomain, \"\") )\n        LoadMDAreaOrPoint();  // To set GDALMD_AREA_OR_POINT.\n\n    return m_oGTiffMDMD.GetMetadata( pszDomain );\n}\n\n/************************************************************************/\n/*                            SetMetadata()                             */\n/************************************************************************/\nCPLErr GTiffDataset::SetMetadata( char ** papszMD, const char *pszDomain )\n\n{\n    LoadGeoreferencingAndPamIfNeeded();\n\n    if( m_bStreamingOut && m_bCrystalized )\n    {\n        ReportError(\n            CE_Failure, CPLE_NotSupported,\n            \"Cannot modify metadata at that point in a streamed output file\" );\n        return CE_Failure;\n    }\n\n    if( pszDomain != nullptr && EQUAL(pszDomain, MD_DOMAIN_RPC) )\n    {\n        // So that a subsequent GetMetadata() wouldn't override our new values\n        LoadMetadata();\n        m_bForceUnsetRPC = (CSLCount(papszMD) == 0);\n    }\n\n    if( (papszMD != nullptr) &&\n        (pszDomain != nullptr) &&\n        EQUAL(pszDomain, \"COLOR_PROFILE\") )\n    {\n        m_bColorProfileMetadataChanged = true;\n    }\n    else if( pszDomain == nullptr || !EQUAL(pszDomain,\"_temporary_\") )\n    {\n        m_bMetadataChanged = true;\n        // Cancel any existing metadata from PAM file.\n        if( eAccess == GA_Update &&\n            GDALPamDataset::GetMetadata(pszDomain) != nullptr )\n            GDALPamDataset::SetMetadata(nullptr, pszDomain);\n    }\n\n    if( (pszDomain == nullptr || EQUAL(pszDomain, \"\")) &&\n        CSLFetchNameValue(papszMD, GDALMD_AREA_OR_POINT) != nullptr )\n    {\n        const char* pszPrevValue =\n                GetMetadataItem(GDALMD_AREA_OR_POINT);\n        const char* pszNewValue =\n                CSLFetchNameValue(papszMD, GDALMD_AREA_OR_POINT);\n        if( pszPrevValue == nullptr || pszNewValue == nullptr ||\n            !EQUAL(pszPrevValue, pszNewValue) )\n        {\n            LookForProjection();\n            m_bGeoTIFFInfoChanged = true;\n        }\n    }\n\n    if( pszDomain != nullptr && EQUAL(pszDomain, \"xml:XMP\") )\n    {\n        if( papszMD != nullptr && *papszMD != nullptr )\n        {\n            int nTagSize = static_cast<int>(strlen(*papszMD));\n            TIFFSetField( m_hTIFF, TIFFTAG_XMLPACKET, nTagSize, *papszMD );\n        }\n        else\n        {\n            TIFFUnsetField( m_hTIFF, TIFFTAG_XMLPACKET );\n        }\n    }\n\n    return m_oGTiffMDMD.SetMetadata( papszMD, pszDomain );\n}\n\n/************************************************************************/\n/*                          GetMetadataItem()                           */\n/************************************************************************/\n\nconst char *GTiffDataset::GetMetadataItem( const char *pszName,\n                                           const char *pszDomain )\n\n{\n    if( pszDomain == nullptr || !EQUAL(pszDomain, \"IMAGE_STRUCTURE\") )\n    {\n        LoadGeoreferencingAndPamIfNeeded();\n    }\n\n    if( pszDomain != nullptr && EQUAL(pszDomain,\"ProxyOverviewRequest\") )\n    {\n        return GDALPamDataset::GetMetadataItem( pszName, pszDomain );\n    }\n    else if( pszDomain != nullptr && (EQUAL(pszDomain, MD_DOMAIN_RPC) ||\n                                   EQUAL(pszDomain, MD_DOMAIN_IMD) ||\n                                   EQUAL(pszDomain, MD_DOMAIN_IMAGERY)) )\n    {\n        LoadMetadata();\n    }\n    else if( pszDomain != nullptr && EQUAL(pszDomain, \"SUBDATASETS\") )\n    {\n        ScanDirectories();\n    }\n    else if( pszDomain != nullptr && EQUAL(pszDomain, \"EXIF\") )\n    {\n        LoadEXIFMetadata();\n    }\n    else if( pszDomain != nullptr && EQUAL(pszDomain, \"COLOR_PROFILE\") )\n    {\n        LoadICCProfile();\n    }\n    else if( (pszDomain == nullptr || EQUAL(pszDomain, \"\")) &&\n        pszName != nullptr && EQUAL(pszName, GDALMD_AREA_OR_POINT) )\n    {\n        LoadMDAreaOrPoint();  // To set GDALMD_AREA_OR_POINT.\n    }\n    else if( pszDomain != nullptr && EQUAL(pszDomain, \"_DEBUG_\") &&\n             pszName != nullptr )\n    {\n#ifdef DEBUG_REACHED_VIRTUAL_MEM_IO\n        if( EQUAL(pszName, \"UNREACHED_VIRTUALMEMIO_CODE_PATH\") )\n        {\n            CPLString osMissing;\n            for( int i = 0; i < static_cast<int>(\n                                    CPL_ARRAYSIZE(anReachedVirtualMemIO)); ++i )\n            {\n                if( !anReachedVirtualMemIO[i] )\n                {\n                    if( !osMissing.empty() ) osMissing += \",\";\n                    osMissing += CPLSPrintf(\"%d\", i);\n                }\n            }\n            return (osMissing.size()) ? CPLSPrintf(\"%s\", osMissing.c_str()) : nullptr;\n        }\n        else\n#endif\n        if( EQUAL(pszName, \"TIFFTAG_EXTRASAMPLES\") )\n        {\n            CPLString osRet;\n            uint16 *v = nullptr;\n            uint16 count = 0;\n\n            if( TIFFGetField( m_hTIFF, TIFFTAG_EXTRASAMPLES, &count, &v ) )\n            {\n                for( int i = 0; i < static_cast<int>(count); ++i )\n                {\n                    if( i > 0 ) osRet += \",\";\n                    osRet += CPLSPrintf(\"%d\", v[i]);\n                }\n            }\n            return (osRet.size()) ? CPLSPrintf(\"%s\", osRet.c_str()) : nullptr;\n        }\n        else if( EQUAL(pszName, \"TIFFTAG_PHOTOMETRIC\") )\n        {\n            return CPLSPrintf(\"%d\", m_nPhotometric);\n        }\n\n        else if( EQUAL( pszName, \"TIFFTAG_GDAL_METADATA\") )\n        {\n            char* pszText = nullptr;\n            if( !TIFFGetField( m_hTIFF, TIFFTAG_GDAL_METADATA, &pszText ) )\n                return nullptr;\n\n            return CPLSPrintf(\"%s\", pszText);\n        }\n        else if( EQUAL( pszName, \"HAS_USED_READ_ENCODED_API\") )\n        {\n            return m_bHasUsedReadEncodedAPI ? \"1\" : \"0\";\n        }\n        return nullptr;\n    }\n\n    else if( pszDomain != nullptr && EQUAL(pszDomain, \"TIFF\") &&\n             pszName != nullptr )\n    {\n        if( EQUAL(pszName, \"GDAL_STRUCTURAL_METADATA\") )\n        {\n            const auto nOffset = VSIFTellL(m_fpL);\n            VSIFSeekL( m_fpL, 0, SEEK_SET );\n            GByte abyData[1024];\n            size_t nRead = VSIFReadL(abyData, 1, sizeof(abyData)-1, m_fpL);\n            abyData[nRead] = 0;\n            VSIFSeekL( m_fpL, nOffset, SEEK_SET );\n            if( nRead > 4 )\n            {\n                const int nOffsetOfStructuralMetadata =\n                    (abyData[2] == 0x2B || abyData[3] == 0x2B ) ? 16 : 8;\n                const int nSizePatternLen = static_cast<int>(strlen(\"XXXXXX bytes\\n\"));\n                if( nRead > nOffsetOfStructuralMetadata +\n                            strlen(\"GDAL_STRUCTURAL_METADATA_SIZE=\") + nSizePatternLen &&\n                    memcmp(abyData + nOffsetOfStructuralMetadata,\n                            \"GDAL_STRUCTURAL_METADATA_SIZE=\",\n                            strlen(\"GDAL_STRUCTURAL_METADATA_SIZE=\")) == 0 )\n                {\n                    char* pszStructuralMD = reinterpret_cast<char*>(\n                        abyData + nOffsetOfStructuralMetadata);\n                    const int nLenMD = atoi(pszStructuralMD +\n                                    strlen(\"GDAL_STRUCTURAL_METADATA_SIZE=\"));\n                    if( nOffsetOfStructuralMetadata +\n                        strlen(\"GDAL_STRUCTURAL_METADATA_SIZE=\") +\n                        nSizePatternLen + nLenMD <= nRead )\n                    {\n                        pszStructuralMD[\n                            strlen(\"GDAL_STRUCTURAL_METADATA_SIZE=\") +\n                            nSizePatternLen + nLenMD] = 0;\n                        return CPLSPrintf(\"%s\", pszStructuralMD);\n                    }\n                }\n            }\n            return nullptr;\n        }\n    }\n\n    return m_oGTiffMDMD.GetMetadataItem( pszName, pszDomain );\n}\n\n/************************************************************************/\n/*                          SetMetadataItem()                           */\n/************************************************************************/\n\nCPLErr GTiffDataset::SetMetadataItem( const char *pszName,\n                                      const char *pszValue,\n                                      const char *pszDomain )\n\n{\n    LoadGeoreferencingAndPamIfNeeded();\n\n    if( m_bStreamingOut && m_bCrystalized )\n    {\n        ReportError(\n            CE_Failure, CPLE_NotSupported,\n            \"Cannot modify metadata at that point in a streamed output file\" );\n        return CE_Failure;\n    }\n\n    if( (pszDomain != nullptr) && EQUAL(pszDomain, \"COLOR_PROFILE\") )\n    {\n        m_bColorProfileMetadataChanged = true;\n    }\n    else if( pszDomain == nullptr || !EQUAL(pszDomain,\"_temporary_\") )\n    {\n        m_bMetadataChanged = true;\n        // Cancel any existing metadata from PAM file.\n        if( eAccess == GA_Update &&\n            GDALPamDataset::GetMetadataItem(pszName, pszDomain) != nullptr )\n            GDALPamDataset::SetMetadataItem(pszName, nullptr, pszDomain);\n    }\n\n    if( (pszDomain == nullptr || EQUAL(pszDomain, \"\")) &&\n        pszName != nullptr && EQUAL(pszName, GDALMD_AREA_OR_POINT) )\n    {\n        LookForProjection();\n        m_bGeoTIFFInfoChanged = true;\n    }\n\n    return m_oGTiffMDMD.SetMetadataItem( pszName, pszValue, pszDomain );\n}\n\n/************************************************************************/\n/*                         GetInternalHandle()                          */\n/************************************************************************/\n\nvoid *GTiffDataset::GetInternalHandle( const char * /* pszHandleName */ )\n\n{\n    return m_hTIFF;\n}\n\n/************************************************************************/\n/*                         LoadEXIFMetadata()                           */\n/************************************************************************/\n\nvoid GTiffDataset::LoadEXIFMetadata()\n{\n    if( m_bEXIFMetadataLoaded )\n        return;\n    m_bEXIFMetadataLoaded = true;\n\n    VSILFILE* fp = VSI_TIFFGetVSILFile(TIFFClientdata( m_hTIFF ));\n\n    GByte abyHeader[2] = { 0 };\n    if( VSIFSeekL(fp, 0, SEEK_SET) != 0 ||\n        VSIFReadL(abyHeader, 1, 2, fp) != 2 )\n        return;\n\n    const bool bLittleEndian = abyHeader[0] == 'I' && abyHeader[1] == 'I';\n    const bool bLeastSignificantBit = CPL_IS_LSB != 0;\n    const bool bSwabflag = bLittleEndian != bLeastSignificantBit;  // != is XOR.\n\n    char** papszMetadata = nullptr;\n    toff_t nOffset = 0;  // TODO(b/28199387): Refactor to simplify casting.\n\n    if( TIFFGetField(m_hTIFF, TIFFTAG_EXIFIFD, &nOffset) )\n    {\n        int nExifOffset = static_cast<int>(nOffset);\n        int nInterOffset = 0;\n        int nGPSOffset = 0;\n        EXIFExtractMetadata( papszMetadata,\n                             fp, static_cast<int>(nOffset),\n                             bSwabflag, 0,\n                             nExifOffset, nInterOffset, nGPSOffset);\n    }\n\n    if( TIFFGetField(m_hTIFF, TIFFTAG_GPSIFD, &nOffset) )\n    {\n        int nExifOffset = 0;  // TODO(b/28199387): Refactor to simplify casting.\n        int nInterOffset = 0;\n        int nGPSOffset = static_cast<int>(nOffset);\n        EXIFExtractMetadata( papszMetadata,\n                             fp, static_cast<int>(nOffset),\n                             bSwabflag, 0,\n                             nExifOffset, nInterOffset, nGPSOffset );\n    }\n\n    if( papszMetadata )\n    {\n        m_oGTiffMDMD.SetMetadata( papszMetadata, \"EXIF\" );\n        CSLDestroy( papszMetadata );\n    }\n}\n\n/************************************************************************/\n/*                           LoadMetadata()                             */\n/************************************************************************/\nvoid GTiffDataset::LoadMetadata()\n{\n    if( m_bIMDRPCMetadataLoaded )\n        return;\n    m_bIMDRPCMetadataLoaded = true;\n\n    GDALMDReaderManager mdreadermanager;\n    GDALMDReaderBase* mdreader =\n        mdreadermanager.GetReader(m_pszFilename,\n                                  oOvManager.GetSiblingFiles(), MDR_ANY);\n\n    if( nullptr != mdreader )\n    {\n        mdreader->FillMetadata(&m_oGTiffMDMD);\n\n        if(mdreader->GetMetadataDomain(MD_DOMAIN_RPC) == nullptr)\n        {\n            char** papszRPCMD = GTiffDatasetReadRPCTag(m_hTIFF);\n            if( papszRPCMD )\n            {\n                m_oGTiffMDMD.SetMetadata( papszRPCMD, MD_DOMAIN_RPC );\n                CSLDestroy( papszRPCMD );\n            }\n        }\n\n        m_papszMetadataFiles = mdreader->GetMetadataFiles();\n    }\n    else\n    {\n        char** papszRPCMD = GTiffDatasetReadRPCTag(m_hTIFF);\n        if( papszRPCMD )\n        {\n            m_oGTiffMDMD.SetMetadata( papszRPCMD, MD_DOMAIN_RPC );\n            CSLDestroy( papszRPCMD );\n        }\n    }\n}\n\n/************************************************************************/\n/*                            GetFileList()                             */\n/************************************************************************/\n\nchar **GTiffDataset::GetFileList()\n\n{\n    LoadGeoreferencingAndPamIfNeeded();\n\n    char **papszFileList = GDALPamDataset::GetFileList();\n\n    LoadMetadata();\n    if(nullptr != m_papszMetadataFiles)\n    {\n        for( int i = 0; m_papszMetadataFiles[i] != nullptr; ++i )\n        {\n            if( CSLFindString( papszFileList, m_papszMetadataFiles[i] ) < 0 )\n            {\n                papszFileList =\n                    CSLAddString( papszFileList, m_papszMetadataFiles[i] );\n            }\n        }\n    }\n\n    if( m_pszGeorefFilename &&\n        CSLFindString(papszFileList, m_pszGeorefFilename) == -1 )\n    {\n        papszFileList = CSLAddString( papszFileList, m_pszGeorefFilename );\n    }\n\n    return papszFileList;\n}\n\n/************************************************************************/\n/*                         CreateMaskBand()                             */\n/************************************************************************/\n\nCPLErr GTiffDataset::CreateMaskBand(int nFlagsIn)\n{\n    ScanDirectories();\n\n    if( m_poMaskDS != nullptr )\n    {\n        ReportError( CE_Failure, CPLE_AppDefined,\n                  \"This TIFF dataset has already an internal mask band\" );\n        return CE_Failure;\n    }\n    else if( MustCreateInternalMask() )\n    {\n        if( nFlagsIn != GMF_PER_DATASET )\n        {\n            ReportError(\n                CE_Failure, CPLE_AppDefined,\n                \"The only flag value supported for internal mask is \"\n                \"GMF_PER_DATASET\" );\n            return CE_Failure;\n        }\n\n        int l_nCompression = COMPRESSION_PACKBITS;\n        if( strstr(GDALGetMetadataItem(GDALGetDriverByName( \"GTiff\" ),\n                                       GDAL_DMD_CREATIONOPTIONLIST, nullptr ),\n                   \"<Value>DEFLATE</Value>\") != nullptr )\n            l_nCompression = COMPRESSION_ADOBE_DEFLATE;\n\n    /* -------------------------------------------------------------------- */\n    /*      If we don't have read access, then create the mask externally.  */\n    /* -------------------------------------------------------------------- */\n        if( GetAccess() != GA_Update )\n        {\n            ReportError( CE_Warning, CPLE_AppDefined,\n                      \"File open for read-only accessing, \"\n                      \"creating mask externally.\" );\n\n            return GDALPamDataset::CreateMaskBand(nFlagsIn);\n        }\n\n        if( m_bLayoutIFDSBeforeData && !m_bKnownIncompatibleEdition &&\n            !m_bWriteKnownIncompatibleEdition )\n        {\n            ReportError(CE_Warning, CPLE_AppDefined,\n                        \"Adding a mask invalidates the \"\n                        \"LAYOUT=IFDS_BEFORE_DATA property\");\n            m_bKnownIncompatibleEdition = true;\n            m_bWriteKnownIncompatibleEdition = true;\n        }\n\n        bool bIsOverview = false;\n        uint32 nSubType = 0;\n        if( TIFFGetField(m_hTIFF, TIFFTAG_SUBFILETYPE, &nSubType) )\n        {\n            bIsOverview = (nSubType & FILETYPE_REDUCEDIMAGE) != 0;\n\n            if( (nSubType & FILETYPE_MASK) != 0 )\n            {\n                ReportError( CE_Failure, CPLE_AppDefined,\n                          \"Cannot create a mask on a TIFF mask IFD !\" );\n                return CE_Failure;\n            }\n        }\n\n        const int bIsTiled = TIFFIsTiled(m_hTIFF);\n\n        FlushDirectory();\n\n        const toff_t nOffset =\n            GTIFFWriteDirectory(\n                m_hTIFF,\n                bIsOverview ?\n                FILETYPE_REDUCEDIMAGE | FILETYPE_MASK : FILETYPE_MASK,\n                nRasterXSize, nRasterYSize,\n                1, PLANARCONFIG_CONTIG, 1,\n                m_nBlockXSize, m_nBlockYSize,\n                bIsTiled, l_nCompression,\n                PHOTOMETRIC_MASK, PREDICTOR_NONE,\n                SAMPLEFORMAT_UINT, nullptr, nullptr, nullptr, 0, nullptr, \"\", nullptr, nullptr,\n                nullptr, nullptr, m_bWriteCOGLayout, nullptr );\n\n        ReloadDirectory();\n\n        if( nOffset == 0 )\n            return CE_Failure;\n\n        m_poMaskDS = new GTiffDataset();\n        m_poMaskDS->m_poBaseDS = this;\n        m_poMaskDS->m_poImageryDS = this;\n        m_poMaskDS->ShareLockWithParentDataset(this);\n        m_poMaskDS->m_bPromoteTo8Bits =\n            CPLTestBool(\n                CPLGetConfigOption(\"GDAL_TIFF_INTERNAL_MASK_TO_8BIT\", \"YES\"));\n        if( m_poMaskDS->OpenOffset( VSI_TIFFOpenChild(m_hTIFF), nOffset,\n                                  GA_Update ) != CE_None)\n        {\n            delete m_poMaskDS;\n            m_poMaskDS = nullptr;\n            return CE_Failure;\n        }\n\n        return CE_None;\n    }\n\n    return GDALPamDataset::CreateMaskBand(nFlagsIn);\n}\n\n/************************************************************************/\n/*                        MustCreateInternalMask()                      */\n/************************************************************************/\n\nbool GTiffDataset::MustCreateInternalMask()\n{\n    return CPLTestBool(CPLGetConfigOption(\"GDAL_TIFF_INTERNAL_MASK\", \"NO\"));\n}\n\n/************************************************************************/\n/*                         CreateMaskBand()                             */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::CreateMaskBand( int nFlagsIn )\n{\n    m_poGDS->ScanDirectories();\n\n    if( m_poGDS->m_poMaskDS != nullptr )\n    {\n        ReportError( CE_Failure, CPLE_AppDefined,\n                  \"This TIFF dataset has already an internal mask band\" );\n        return CE_Failure;\n    }\n\n    if( CPLTestBool( CPLGetConfigOption(\"GDAL_TIFF_INTERNAL_MASK\", \"NO\") ) )\n    {\n        return m_poGDS->CreateMaskBand(nFlagsIn);\n    }\n\n    return GDALPamRasterBand::CreateMaskBand(nFlagsIn);\n}\n\n/************************************************************************/\n/*                        GetRawBinaryLayout()                          */\n/************************************************************************/\n\nbool GTiffDataset::GetRawBinaryLayout(GDALDataset::RawBinaryLayout& sLayout)\n{\n    if( eAccess == GA_Update )\n    {\n        FlushCache();\n        Crystalize();\n    }\n\n    if( m_nCompression != COMPRESSION_NONE )\n        return false;\n    if( !CPLIsPowerOfTwo(m_nBitsPerSample) || m_nBitsPerSample < 8 )\n        return false;\n    const auto eDT = GetRasterBand(1)->GetRasterDataType();\n    if( GDALDataTypeIsComplex( eDT ) )\n        return false;\n\n    toff_t *panByteCounts = nullptr;\n    toff_t *panOffsets = nullptr;\n    const bool bIsTiled = CPL_TO_BOOL( TIFFIsTiled(m_hTIFF) );\n\n    if( !(( bIsTiled\n            && TIFFGetField( m_hTIFF, TIFFTAG_TILEBYTECOUNTS, &panByteCounts )\n            && TIFFGetField( m_hTIFF, TIFFTAG_TILEOFFSETS, &panOffsets ) )\n            || ( !bIsTiled\n            && TIFFGetField( m_hTIFF, TIFFTAG_STRIPBYTECOUNTS, &panByteCounts )\n            && TIFFGetField( m_hTIFF, TIFFTAG_STRIPOFFSETS, &panOffsets ) )) )\n    {\n        return false;\n    }\n\n    const int nDTSize = GDALGetDataTypeSizeBytes(eDT);\n    vsi_l_offset        nImgOffset = panOffsets[0];\n    GIntBig             nPixelOffset = ( m_nPlanarConfig == PLANARCONFIG_CONTIG ) ? static_cast<GIntBig>(nDTSize) * nBands : nDTSize;\n    GIntBig             nLineOffset = nPixelOffset * nRasterXSize;\n    GIntBig             nBandOffset = ( m_nPlanarConfig == PLANARCONFIG_CONTIG && nBands > 1 ) ? nDTSize : 0;\n    RawBinaryLayout::Interleaving eInterleaving =\n        (nBands == 1) ?                             RawBinaryLayout::Interleaving::UNKNOWN :\n        (m_nPlanarConfig == PLANARCONFIG_CONTIG ) ? RawBinaryLayout::Interleaving::BIP :\n                                                    RawBinaryLayout::Interleaving::BSQ;\n    if( bIsTiled )\n    {\n        // Only a single block tiled file with same dimension as the raster\n        // might be acceptable\n        if( m_nBlockXSize != nRasterXSize || m_nBlockYSize != nRasterYSize )\n            return false;\n        if( nBands > 1 && m_nPlanarConfig != PLANARCONFIG_CONTIG )\n        {\n            nBandOffset = static_cast<GIntBig>(panOffsets[1]) - static_cast<GIntBig>(panOffsets[0]);\n            for( int i = 2; i < nBands; i++ )\n            {\n                if( static_cast<GIntBig>(panOffsets[i]) - static_cast<GIntBig>(panOffsets[i - 1]) != nBandOffset )\n                    return false;\n            }\n        }\n    }\n    else\n    {\n        const int nStrips = DIV_ROUND_UP(nRasterYSize, m_nRowsPerStrip);\n        if( nBands == 1 || m_nPlanarConfig == PLANARCONFIG_CONTIG )\n        {\n            vsi_l_offset nLastStripEnd = panOffsets[0] + panByteCounts[0];\n            for( int iStrip = 1; iStrip < nStrips; iStrip++ )\n            {\n                if( nLastStripEnd != panOffsets[iStrip] )\n                    return false;\n                nLastStripEnd = panOffsets[iStrip] + panByteCounts[iStrip];\n            }\n        }\n        else\n        {\n            // Note: we could potentially have BIL order with m_nRowsPerStrip == 1\n            // and if strips are ordered strip_line_1_band_1, ..., strip_line_1_band_N, strip_line2_band1, ... strip_line2_band_N, etc....\n            // but that'd be faily exotic !\n            // So only detect BSQ layout here\n            nBandOffset = static_cast<GIntBig>(panOffsets[nStrips]) - static_cast<GIntBig>(panOffsets[0]);\n            for( int i = 0; i < nBands; i++ )\n            {\n                uint32 iStripOffset = nStrips * i;\n                vsi_l_offset nLastStripEnd = panOffsets[iStripOffset] + panByteCounts[iStripOffset];\n                for( int iStrip = 1; iStrip < nStrips; iStrip++ )\n                {\n                    if( nLastStripEnd != panOffsets[iStripOffset + iStrip] )\n                        return false;\n                    nLastStripEnd = panOffsets[iStripOffset + iStrip] + panByteCounts[iStripOffset + iStrip];\n                }\n                if( i >= 2 &&\n                     static_cast<GIntBig>(panOffsets[iStripOffset]) -\n                        static_cast<GIntBig>(panOffsets[iStripOffset - nStrips]) != nBandOffset )\n                {\n                    return false;\n                }\n            }\n        }\n    }\n\n    sLayout.osRawFilename = m_pszFilename;\n    sLayout.eInterleaving = eInterleaving;\n    sLayout.eDataType = eDT;\n#ifdef CPL_LSB\n    sLayout.bLittleEndianOrder = !TIFFIsByteSwapped(m_hTIFF);\n#else\n    sLayout.bLittleEndianOrder = TIFFIsByteSwapped(m_hTIFF);\n#endif\n    sLayout.nImageOffset = nImgOffset;\n    sLayout.nPixelOffset = nPixelOffset;\n    sLayout.nLineOffset = nLineOffset;\n    sLayout.nBandOffset = nBandOffset;\n\n    return true;\n}\n\n/************************************************************************/\n/*                       PrepareTIFFErrorFormat()                       */\n/*                                                                      */\n/*      sometimes the \"module\" has stuff in it that has special         */\n/*      meaning in a printf() style format, so we try to escape it.     */\n/*      For now we hope the only thing we have to escape is %'s.        */\n/************************************************************************/\n\nstatic char *PrepareTIFFErrorFormat( const char *module, const char *fmt )\n\n{\n    const size_t nModuleSize = strlen(module);\n    const size_t nModFmtSize = nModuleSize * 2 + strlen(fmt) + 2;\n    char *pszModFmt = static_cast<char *>( CPLMalloc( nModFmtSize ) );\n\n    size_t iOut = 0;  // Used after for.\n\n    for( size_t iIn = 0; iIn < nModuleSize; ++iIn )\n    {\n        if( module[iIn] == '%' )\n        {\n            CPLAssert(iOut < nModFmtSize - 2);\n            pszModFmt[iOut++] = '%';\n            pszModFmt[iOut++] = '%';\n        }\n        else\n        {\n            CPLAssert(iOut < nModFmtSize - 1);\n            pszModFmt[iOut++] = module[iIn];\n        }\n    }\n    CPLAssert(iOut < nModFmtSize);\n    pszModFmt[iOut] = '\\0';\n    strcat( pszModFmt, \":\" );\n    strcat( pszModFmt, fmt );\n\n    return pszModFmt;\n}\n\n/************************************************************************/\n/*                        GTiffWarningHandler()                         */\n/************************************************************************/\nstatic void\nGTiffWarningHandler(const char* module, const char* fmt, va_list ap )\n{\n    if( strstr(fmt,\"nknown field\") != nullptr )\n        return;\n\n    char *pszModFmt = PrepareTIFFErrorFormat( module, fmt );\n    if( strstr(fmt, \"does not end in null byte\") != nullptr )\n    {\n        CPLString osMsg;\n        osMsg.vPrintf(pszModFmt, ap);\n        CPLDebug( \"GTiff\", \"%s\", osMsg.c_str() );\n    }\n    else\n    {\n        CPLErrorV( CE_Warning, CPLE_AppDefined, pszModFmt, ap );\n    }\n    CPLFree( pszModFmt );\n}\n\n/************************************************************************/\n/*                         GTiffErrorHandler()                          */\n/************************************************************************/\nstatic void\nGTiffErrorHandler( const char* module, const char* fmt, va_list ap )\n{\n    if( strcmp(fmt, \"Maximum TIFF file size exceeded\") == 0 )\n    {\n        // Ideally there would be a thread-safe way of setting this flag,\n        // but we cannot really use the extended error handler, since the\n        // handler is for all TIFF handles, and not necessarily the ones of\n        // this driver.\n        if( bGlobalInExternalOvr )\n            fmt =\n                \"Maximum TIFF file size exceeded. \"\n                \"Use --config BIGTIFF_OVERVIEW YES configuration option.\";\n        else\n            fmt =\n                \"Maximum TIFF file size exceeded. \"\n                \"Use BIGTIFF=YES creation option.\";\n    }\n\n    char* pszModFmt = PrepareTIFFErrorFormat( module, fmt );\n    CPLErrorV( CE_Failure, CPLE_AppDefined, pszModFmt, ap );\n    CPLFree( pszModFmt );\n}\n\n/************************************************************************/\n/*                          GTiffTagExtender()                          */\n/*                                                                      */\n/*      Install tags specially known to GDAL.                           */\n/************************************************************************/\n\nstatic TIFFExtendProc _ParentExtender = nullptr;\n\nstatic void GTiffTagExtender(TIFF *tif)\n\n{\n    const TIFFFieldInfo xtiffFieldInfo[] = {\n        { TIFFTAG_GDAL_METADATA, -1, -1, TIFF_ASCII, FIELD_CUSTOM,\n          TRUE, FALSE, const_cast<char *>( \"GDALMetadata\" ) },\n        { TIFFTAG_GDAL_NODATA, -1, -1, TIFF_ASCII, FIELD_CUSTOM,\n          TRUE, FALSE, const_cast<char*>( \"GDALNoDataValue\" ) },\n        { TIFFTAG_RPCCOEFFICIENT, -1, -1, TIFF_DOUBLE, FIELD_CUSTOM,\n          TRUE, TRUE, const_cast<char *>( \"RPCCoefficient\" ) },\n        { TIFFTAG_TIFF_RSID, -1, -1, TIFF_ASCII, FIELD_CUSTOM,\n          TRUE, FALSE, const_cast<char *>( \"TIFF_RSID\" ) },\n        { TIFFTAG_GEO_METADATA, TIFF_VARIABLE2, TIFF_VARIABLE2, TIFF_BYTE, FIELD_CUSTOM,\n          TRUE, TRUE, const_cast<char *>( \"GEO_METADATA\" ) }\n    };\n\n    if( _ParentExtender )\n        (*_ParentExtender)(tif);\n\n    TIFFMergeFieldInfo( tif, xtiffFieldInfo,\n                        sizeof(xtiffFieldInfo) / sizeof(xtiffFieldInfo[0]) );\n}\n\n/************************************************************************/\n/*                          GTiffOneTimeInit()                          */\n/*                                                                      */\n/*      This is stuff that is initialized for the TIFF library just     */\n/*      once.  We deliberately defer the initialization till the        */\n/*      first time we are likely to call into libtiff to avoid          */\n/*      unnecessary paging in of the library for GDAL apps that         */\n/*      don't use it.                                                   */\n/************************************************************************/\n#if defined(HAVE_DLFCN_H) && !defined(WIN32)\n#include <dlfcn.h>\n#endif\n\nstatic std::mutex oDeleteMutex;\n#ifdef HAVE_LERC\nstatic TIFFCodec* pLercCodec = nullptr;\n#endif\n\nint GTiffOneTimeInit()\n\n{\n    std::lock_guard<std::mutex> oLock(oDeleteMutex);\n \n#ifdef HAVE_LERC\n    if( pLercCodec == nullptr )\n    {\n        pLercCodec = TIFFRegisterCODEC(COMPRESSION_LERC, \"LERC\", TIFFInitLERC);\n    }\n#endif\n\n    static bool bOneTimeInitDone = false;\n    if( bOneTimeInitDone )\n        return TRUE;\n\n    bOneTimeInitDone = true;\n\n    // This is a frequent configuration error that is difficult to track down\n    // for people unaware of the issue : GDAL built against internal libtiff\n    // (4.X), but used by an application that links with external libtiff (3.X)\n    // Note: on my conf, the order that cause GDAL to crash - and that is\n    // detected by the following code - is \"-ltiff -lgdal\". \"-lgdal -ltiff\"\n    // works for the GTiff driver but probably breaks the application that\n    // believes it uses libtiff 3.X but we cannot detect that.\n#if !defined(RENAME_INTERNAL_LIBTIFF_SYMBOLS)\n#if defined(HAVE_DLFCN_H) && !defined(WIN32)\n    const char* (*pfnVersion)(void);\n#ifdef HAVE_GCC_WARNING_ZERO_AS_NULL_POINTER_CONSTANT\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wzero-as-null-pointer-constant\"\n#endif\n    pfnVersion = reinterpret_cast<const char* (*)(void)>(dlsym(RTLD_DEFAULT, \"TIFFGetVersion\"));\n#ifdef HAVE_GCC_WARNING_ZERO_AS_NULL_POINTER_CONSTANT\n#pragma GCC diagnostic pop\n#endif\n    if( pfnVersion )\n    {\n        const char* pszVersion = pfnVersion();\n        if( pszVersion && strstr(pszVersion, \"Version 3.\") != nullptr )\n        {\n            CPLError(\n                CE_Warning, CPLE_AppDefined,\n                \"libtiff version mismatch: You're linking against libtiff 3.X, \"\n                \"but GDAL has been compiled against libtiff >= 4.0.0\" );\n        }\n    }\n#endif  // HAVE_DLFCN_H\n#endif // !defined(RENAME_INTERNAL_LIBTIFF_SYMBOLS)\n\n    _ParentExtender = TIFFSetTagExtender(GTiffTagExtender);\n\n    TIFFSetWarningHandler( GTiffWarningHandler );\n    TIFFSetErrorHandler( GTiffErrorHandler );\n\n    LibgeotiffOneTimeInit();\n\n    return TRUE;\n}\n\n/************************************************************************/\n/*                        GDALDeregister_GTiff()                        */\n/************************************************************************/\n\nstatic\nvoid GDALDeregister_GTiff( GDALDriver * )\n\n{\n#ifdef HAVE_LERC\n    if( pLercCodec )\n        TIFFUnRegisterCODEC(pLercCodec);\n    pLercCodec = nullptr;\n#endif\n}\n\n/************************************************************************/\n/*                   GTIFFGetCompressionMethod()                        */\n/************************************************************************/\n\nint GTIFFGetCompressionMethod(const char* pszValue, const char* pszVariableName)\n{\n    int nCompression = COMPRESSION_NONE;\n    if( EQUAL( pszValue, \"NONE\" ) )\n        nCompression = COMPRESSION_NONE;\n    else if( EQUAL( pszValue, \"JPEG\" ) )\n        nCompression = COMPRESSION_JPEG;\n    else if( EQUAL( pszValue, \"LZW\" ) )\n        nCompression = COMPRESSION_LZW;\n    else if( EQUAL( pszValue, \"PACKBITS\" ))\n        nCompression = COMPRESSION_PACKBITS;\n    else if( EQUAL( pszValue, \"DEFLATE\" ) || EQUAL( pszValue, \"ZIP\" ))\n        nCompression = COMPRESSION_ADOBE_DEFLATE;\n    else if( EQUAL( pszValue, \"FAX3\" )\n             || EQUAL( pszValue, \"CCITTFAX3\" ))\n        nCompression = COMPRESSION_CCITTFAX3;\n    else if( EQUAL( pszValue, \"FAX4\" )\n             || EQUAL( pszValue, \"CCITTFAX4\" ))\n        nCompression = COMPRESSION_CCITTFAX4;\n    else if( EQUAL( pszValue, \"CCITTRLE\" ) )\n        nCompression = COMPRESSION_CCITTRLE;\n    else if( EQUAL( pszValue, \"LZMA\" ) )\n        nCompression = COMPRESSION_LZMA;\n    else if( EQUAL( pszValue, \"ZSTD\" ) )\n        nCompression = COMPRESSION_ZSTD;\n#ifdef HAVE_LERC\n    else if( EQUAL( pszValue, \"LERC\" ) ||\n             EQUAL( pszValue, \"LERC_DEFLATE\" ) ||\n             EQUAL( pszValue, \"LERC_ZSTD\" ) )\n    {\n        nCompression = COMPRESSION_LERC;\n    }\n#endif\n    else if( EQUAL( pszValue, \"WEBP\" ) )\n        nCompression = COMPRESSION_WEBP;\n    else\n        CPLError( CE_Warning, CPLE_IllegalArg,\n                  \"%s=%s value not recognised, ignoring.\",\n                  pszVariableName,pszValue );\n\n    if( nCompression != COMPRESSION_NONE &&\n        !TIFFIsCODECConfigured(static_cast<uint16>(nCompression)) )\n    {\n        CPLError(\n            CE_Failure, CPLE_AppDefined,\n            \"Cannot create TIFF file due to missing codec for %s.\", pszValue );\n        return -1;\n    }\n\n    return nCompression;\n}\n\n/************************************************************************/\n/*                     GTiffGetCompressValues()                         */\n/************************************************************************/\n\nCPLString GTiffGetCompressValues(bool& bHasLZW,\n                                 bool& bHasDEFLATE,\n                                 bool& bHasLZMA,\n                                 bool& bHasZSTD,\n                                 bool& bHasJPEG,\n                                 bool& bHasWebP,\n                                 bool bForCOG)\n{\n\n/* -------------------------------------------------------------------- */\n/*      Determine which compression codecs are available that we        */\n/*      want to advertise.  If we are using an old libtiff we won't     */\n/*      be able to find out so we just assume all are available.        */\n/* -------------------------------------------------------------------- */\n    CPLString osCompressValues = \"       <Value>NONE</Value>\";\n\n    TIFFCodec *codecs = TIFFGetConfiguredCODECs();\n\n    for( TIFFCodec *c = codecs; c->name; ++c )\n    {\n        if( c->scheme == COMPRESSION_PACKBITS && !bForCOG )\n        {\n            osCompressValues +=\n                    \"       <Value>PACKBITS</Value>\";\n        }\n        else if( c->scheme == COMPRESSION_JPEG )\n        {\n            bHasJPEG = true;\n            osCompressValues +=\n                    \"       <Value>JPEG</Value>\";\n        }\n        else if( c->scheme == COMPRESSION_LZW )\n        {\n            bHasLZW = true;\n            osCompressValues +=\n                    \"       <Value>LZW</Value>\";\n        }\n        else if( c->scheme == COMPRESSION_ADOBE_DEFLATE )\n        {\n            bHasDEFLATE = true;\n            osCompressValues +=\n                    \"       <Value>DEFLATE</Value>\";\n        }\n        else if( c->scheme == COMPRESSION_CCITTRLE && !bForCOG )\n        {\n            osCompressValues +=\n                    \"       <Value>CCITTRLE</Value>\";\n        }\n        else if( c->scheme == COMPRESSION_CCITTFAX3 && !bForCOG )\n        {\n            osCompressValues +=\n                    \"       <Value>CCITTFAX3</Value>\";\n        }\n        else if( c->scheme == COMPRESSION_CCITTFAX4 && !bForCOG )\n        {\n            osCompressValues +=\n                    \"       <Value>CCITTFAX4</Value>\";\n        }\n        else if( c->scheme == COMPRESSION_LZMA && !bForCOG )\n        {\n            bHasLZMA = true;\n            osCompressValues +=\n                    \"       <Value>LZMA</Value>\";\n        }\n        else if( c->scheme == COMPRESSION_ZSTD )\n        {\n            bHasZSTD = true;\n            osCompressValues +=\n                    \"       <Value>ZSTD</Value>\";\n        }\n        else if( c->scheme == COMPRESSION_WEBP )\n        {\n            bHasWebP = true;\n            osCompressValues +=\n                    \"       <Value>WEBP</Value>\";\n        }\n    }\n#ifdef HAVE_LERC\n    osCompressValues +=\n                    \"       <Value>LERC</Value>\";\n    osCompressValues +=\n                    \"       <Value>LERC_DEFLATE</Value>\";\n    if( bHasZSTD )\n    {\n        osCompressValues +=\n                    \"       <Value>LERC_ZSTD</Value>\";\n    }\n#endif\n    _TIFFfree( codecs );\n\n    return osCompressValues;\n}\n\n/************************************************************************/\n/*                          GDALRegister_GTiff()                        */\n/************************************************************************/\n\nvoid GDALRegister_GTiff()\n\n{\n    if( GDALGetDriverByName( \"GTiff\" ) != nullptr )\n        return;\n\n    CPLString osOptions;\n\n    bool bHasLZW = false;\n    bool bHasDEFLATE = false;\n    bool bHasLZMA = false;\n    bool bHasZSTD = false;\n    bool bHasJPEG = false;\n    bool bHasWebP = false;\n    CPLString osCompressValues(GTiffGetCompressValues(\n        bHasLZW, bHasDEFLATE, bHasLZMA, bHasZSTD, bHasJPEG, bHasWebP,\n        false /* bForCOG */));\n\n    GDALDriver *poDriver = new GDALDriver();\n\n/* -------------------------------------------------------------------- */\n/*      Build full creation option list.                                */\n/* -------------------------------------------------------------------- */\n    osOptions = \"<CreationOptionList>\"\n              \"   <Option name='COMPRESS' type='string-select'>\";\n    osOptions += osCompressValues;\n    osOptions += \"   </Option>\";\n    if( bHasLZW || bHasDEFLATE || bHasZSTD )\n        osOptions += \"\"\n\"   <Option name='PREDICTOR' type='int' description='Predictor Type (1=default, 2=horizontal differencing, 3=floating point prediction)'/>\";\n    osOptions += \"\"\n\"   <Option name='DISCARD_LSB' type='string' description='Number of least-significant bits to set to clear as a single value or comma-separated list of values for per-band values'/>\";\n    if( bHasJPEG )\n    {\n        osOptions += \"\"\n\"   <Option name='JPEG_QUALITY' type='int' description='JPEG quality 1-100' default='75'/>\"\n\"   <Option name='JPEGTABLESMODE' type='int' description='Content of JPEGTABLES tag. 0=no JPEGTABLES tag, 1=Quantization tables only, 2=Huffman tables only, 3=Both' default='1'/>\";\n#ifdef JPEG_DIRECT_COPY\n        osOptions += \"\"\n\"   <Option name='JPEG_DIRECT_COPY' type='boolean' description='To copy without any decompression/recompression a JPEG source file' default='NO'/>\";\n#endif\n    }\n    if( bHasDEFLATE )\n    {\n#ifdef LIBDEFLATE_SUPPORT\n        osOptions += \"\"\n\"   <Option name='ZLEVEL' type='int' description='DEFLATE compression level 1-12' default='6'/>\";\n#else\n        osOptions += \"\"\n\"   <Option name='ZLEVEL' type='int' description='DEFLATE compression level 1-9' default='6'/>\";\n#endif\n    }\n    if( bHasLZMA )\n        osOptions += \"\"\n\"   <Option name='LZMA_PRESET' type='int' description='LZMA compression level 0(fast)-9(slow)' default='6'/>\";\n    if( bHasZSTD )\n        osOptions += \"\"\n\"   <Option name='ZSTD_LEVEL' type='int' description='ZSTD compression level 1(fast)-22(slow)' default='9'/>\";\n#ifdef HAVE_LERC\n    osOptions += \"\"\n\"   <Option name='MAX_Z_ERROR' type='float' description='Maximum error for LERC compression' default='0'/>\";\n#endif\n    if ( bHasWebP )\n    {\n      osOptions += \"\"\n#if WEBP_ENCODER_ABI_VERSION >= 0x0100\n\"   <Option name='WEBP_LOSSLESS' type='boolean' description='Whether lossless compression should be used' default='FALSE'/>\"\n#endif\n\"   <Option name='WEBP_LEVEL' type='int' description='WEBP quality level. Low values result in higher compression ratios' default='75'/>\";\n    }\n    osOptions += \"\"\n\"   <Option name='NUM_THREADS' type='string' description='Number of worker threads for compression. Can be set to ALL_CPUS' default='1'/>\"\n\"   <Option name='NBITS' type='int' description='BITS for sub-byte files (1-7), sub-uint16 (9-15), sub-uint32 (17-31), or float32 (16)'/>\"\n\"   <Option name='INTERLEAVE' type='string-select' default='PIXEL'>\"\n\"       <Value>BAND</Value>\"\n\"       <Value>PIXEL</Value>\"\n\"   </Option>\"\n\"   <Option name='TILED' type='boolean' description='Switch to tiled format'/>\"\n\"   <Option name='TFW' type='boolean' description='Write out world file'/>\"\n\"   <Option name='RPB' type='boolean' description='Write out .RPB (RPC) file'/>\"\n\"   <Option name='RPCTXT' type='boolean' description='Write out _RPC.TXT file'/>\"\n\"   <Option name='BLOCKXSIZE' type='int' description='Tile Width'/>\"\n\"   <Option name='BLOCKYSIZE' type='int' description='Tile/Strip Height'/>\"\n\"   <Option name='PHOTOMETRIC' type='string-select'>\"\n\"       <Value>MINISBLACK</Value>\"\n\"       <Value>MINISWHITE</Value>\"\n\"       <Value>PALETTE</Value>\"\n\"       <Value>RGB</Value>\"\n\"       <Value>CMYK</Value>\"\n\"       <Value>YCBCR</Value>\"\n\"       <Value>CIELAB</Value>\"\n\"       <Value>ICCLAB</Value>\"\n\"       <Value>ITULAB</Value>\"\n\"   </Option>\"\n\"   <Option name='SPARSE_OK' type='boolean' description='Should empty blocks be omitted on disk?' default='FALSE'/>\"\n\"   <Option name='ALPHA' type='string-select' description='Mark first extrasample as being alpha'>\"\n\"       <Value>NON-PREMULTIPLIED</Value>\"\n\"       <Value>PREMULTIPLIED</Value>\"\n\"       <Value>UNSPECIFIED</Value>\"\n\"       <Value aliasOf='NON-PREMULTIPLIED'>YES</Value>\"\n\"       <Value aliasOf='UNSPECIFIED'>NO</Value>\"\n\"   </Option>\"\n\"   <Option name='PROFILE' type='string-select' default='GDALGeoTIFF'>\"\n\"       <Value>GDALGeoTIFF</Value>\"\n\"       <Value>GeoTIFF</Value>\"\n\"       <Value>BASELINE</Value>\"\n\"   </Option>\"\n\"   <Option name='PIXELTYPE' type='string-select'>\"\n\"       <Value>DEFAULT</Value>\"\n\"       <Value>SIGNEDBYTE</Value>\"\n\"   </Option>\"\n\"   <Option name='BIGTIFF' type='string-select' description='Force creation of BigTIFF file'>\"\n\"     <Value>YES</Value>\"\n\"     <Value>NO</Value>\"\n\"     <Value>IF_NEEDED</Value>\"\n\"     <Value>IF_SAFER</Value>\"\n\"   </Option>\"\n\"   <Option name='ENDIANNESS' type='string-select' default='NATIVE' description='Force endianness of created file. For DEBUG purpose mostly'>\"\n\"       <Value>NATIVE</Value>\"\n\"       <Value>INVERTED</Value>\"\n\"       <Value>LITTLE</Value>\"\n\"       <Value>BIG</Value>\"\n\"   </Option>\"\n\"   <Option name='COPY_SRC_OVERVIEWS' type='boolean' default='NO' description='Force copy of overviews of source dataset (CreateCopy())'/>\"\n\"   <Option name='SOURCE_ICC_PROFILE' type='string' description='ICC profile'/>\"\n\"   <Option name='SOURCE_PRIMARIES_RED' type='string' description='x,y,1.0 (xyY) red chromaticity'/>\"\n\"   <Option name='SOURCE_PRIMARIES_GREEN' type='string' description='x,y,1.0 (xyY) green chromaticity'/>\"\n\"   <Option name='SOURCE_PRIMARIES_BLUE' type='string' description='x,y,1.0 (xyY) blue chromaticity'/>\"\n\"   <Option name='SOURCE_WHITEPOINT' type='string' description='x,y,1.0 (xyY) whitepoint'/>\"\n\"   <Option name='TIFFTAG_TRANSFERFUNCTION_RED' type='string' description='Transfer function for red'/>\"\n\"   <Option name='TIFFTAG_TRANSFERFUNCTION_GREEN' type='string' description='Transfer function for green'/>\"\n\"   <Option name='TIFFTAG_TRANSFERFUNCTION_BLUE' type='string' description='Transfer function for blue'/>\"\n\"   <Option name='TIFFTAG_TRANSFERRANGE_BLACK' type='string' description='Transfer range for black'/>\"\n\"   <Option name='TIFFTAG_TRANSFERRANGE_WHITE' type='string' description='Transfer range for white'/>\"\n\"   <Option name='STREAMABLE_OUTPUT' type='boolean' default='NO' description='Enforce a mode compatible with a streamable file'/>\"\n\"   <Option name='GEOTIFF_KEYS_FLAVOR' type='string-select' default='STANDARD' description='Which flavor of GeoTIFF keys must be used'>\"\n\"       <Value>STANDARD</Value>\"\n\"       <Value>ESRI_PE</Value>\"\n\"   </Option>\"\n#if LIBGEOTIFF_VERSION >= 1600\n\"   <Option name='GEOTIFF_VERSION' type='string-select' default='AUTO' description='Which version of GeoTIFF must be used'>\"\n\"       <Value>AUTO</Value>\"\n\"       <Value>1.0</Value>\"\n\"       <Value>1.1</Value>\"\n\"   </Option>\"\n#endif\n\"</CreationOptionList>\";\n\n/* -------------------------------------------------------------------- */\n/*      Set the driver details.                                         */\n/* -------------------------------------------------------------------- */\n    poDriver->SetDescription( \"GTiff\" );\n    poDriver->SetMetadataItem( GDAL_DCAP_RASTER, \"YES\" );\n    poDriver->SetMetadataItem( GDAL_DMD_LONGNAME, \"GeoTIFF\" );\n    poDriver->SetMetadataItem( GDAL_DMD_HELPTOPIC, \"drivers/raster/gtiff.html\" );\n    poDriver->SetMetadataItem( GDAL_DMD_MIMETYPE, \"image/tiff\" );\n    poDriver->SetMetadataItem( GDAL_DMD_EXTENSION, \"tif\" );\n    poDriver->SetMetadataItem( GDAL_DMD_EXTENSIONS, \"tif tiff\" );\n    poDriver->SetMetadataItem( GDAL_DMD_CREATIONDATATYPES,\n                               \"Byte UInt16 Int16 UInt32 Int32 Float32 \"\n                               \"Float64 CInt16 CInt32 CFloat32 CFloat64\" );\n    poDriver->SetMetadataItem( GDAL_DMD_CREATIONOPTIONLIST, osOptions );\n    poDriver->SetMetadataItem( GDAL_DMD_OPENOPTIONLIST,\n\"<OpenOptionList>\"\n\"   <Option name='NUM_THREADS' type='string' description='Number of worker threads for compression. Can be set to ALL_CPUS' default='1'/>\"\n\"   <Option name='GEOTIFF_KEYS_FLAVOR' type='string-select' default='STANDARD' description='Which flavor of GeoTIFF keys must be used (for writing)'>\"\n\"       <Value>STANDARD</Value>\"\n\"       <Value>ESRI_PE</Value>\"\n\"   </Option>\"\n\"   <Option name='GEOREF_SOURCES' type='string' description='Comma separated list made with values INTERNAL/TABFILE/WORLDFILE/PAM/NONE that describe the priority order for georeferencing' default='PAM,INTERNAL,TABFILE,WORLDFILE'/>\"\n\"   <Option name='SPARSE_OK' type='boolean' description='Should empty blocks be omitted on disk?' default='FALSE'/>\"\n\"</OpenOptionList>\" );\n    poDriver->SetMetadataItem( GDAL_DMD_SUBDATASETS, \"YES\" );\n    poDriver->SetMetadataItem( GDAL_DCAP_VIRTUALIO, \"YES\" );\n\n#ifdef INTERNAL_LIBTIFF\n    poDriver->SetMetadataItem( \"LIBTIFF\", \"INTERNAL\" );\n#else\n    poDriver->SetMetadataItem( \"LIBTIFF\", TIFFLIB_VERSION_STR );\n#endif\n\n#define STRINGIFY(x) #x\n#define XSTRINGIFY(x) STRINGIFY(x)\n    poDriver->SetMetadataItem( \"LIBGEOTIFF\", XSTRINGIFY(LIBGEOTIFF_VERSION) );\n\n    poDriver->pfnOpen = GTiffDataset::Open;\n    poDriver->pfnCreate = GTiffDataset::Create;\n    poDriver->pfnCreateCopy = GTiffDataset::CreateCopy;\n    poDriver->pfnUnloadDriver = GDALDeregister_GTiff;\n    poDriver->pfnIdentify = GTiffDataset::Identify;\n\n    GetGDALDriverManager()->RegisterDriver( poDriver );\n}\n",
                "name": "geotiff.cpp",
                "path": "deps/libgdal/gdal/frmts/gtiff/geotiff.cpp",
                "url": "/github.com/yocontra/node-gdal-next/-/blob/deps/libgdal/gdal/frmts/gtiff/geotiff.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 6341,
                    "offsetAndLengths": [
                        [
                            16,
                            16
                        ]
                    ],
                    "preview": "            if( TIFFReadRGBATileExt("
                },
                {
                    "limitHit": false,
                    "lineNumber": 6349,
                    "offsetAndLengths": [
                        [
                            16,
                            16
                        ]
                    ],
                    "preview": "            if( TIFFReadRGBATile("
                },
                {
                    "limitHit": false,
                    "lineNumber": 6359,
                    "offsetAndLengths": [
                        [
                            27,
                            16
                        ]
                    ],
                    "preview": "                          \"TIFFReadRGBATile() failed.\" );"
                }
            ],
            "repository": {
                "name": "github.com/yocontra/node-gdal-next",
                "url": "/github.com/yocontra/node-gdal-next"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "5aa5499353318d7ca1ca88c0467c51981aebc0e5"
                },
                "content": "/*M///////////////////////////////////////////////////////////////////////////////////////\n//\n//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.\n//\n//  By downloading, copying, installing or using the software you agree to this license.\n//  If you do not agree to this license, do not download, install,\n//  copy or use the software.\n//\n//\n//                           License Agreement\n//                For Open Source Computer Vision Library\n//\n// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.\n// Copyright (C) 2009, Willow Garage Inc., all rights reserved.\n// Third party copyrights are property of their respective owners.\n//\n// Redistribution and use in source and binary forms, with or without modification,\n// are permitted provided that the following conditions are met:\n//\n//   * Redistribution's of source code must retain the above copyright notice,\n//     this list of conditions and the following disclaimer.\n//\n//   * Redistribution's in binary form must reproduce the above copyright notice,\n//     this list of conditions and the following disclaimer in the documentation\n//     and/or other materials provided with the distribution.\n//\n//   * The name of the copyright holders may not be used to endorse or promote products\n//     derived from this software without specific prior written permission.\n//\n// This software is provided by the copyright holders and contributors \"as is\" and\n// any express or implied warranties, including, but not limited to, the implied\n// warranties of merchantability and fitness for a particular purpose are disclaimed.\n// In no event shall the Intel Corporation or contributors be liable for any direct,\n// indirect, incidental, special, exemplary, or consequential damages\n// (including, but not limited to, procurement of substitute goods or services;\n// loss of use, data, or profits; or business interruption) however caused\n// and on any theory of liability, whether in contract, strict liability,\n// or tort (including negligence or otherwise) arising in any way out of\n// the use of this software, even if advised of the possibility of such damage.\n//\n//M*/\n\n/****************************************************************************************\\\n    A part of the file implements TIFF reader on base of libtiff library\n    (see otherlibs/_graphics/readme.txt for copyright notice)\n\\****************************************************************************************/\n\n#include <stdarg.h>\n\n#include \"precomp.hpp\"\n#include \"grfmt_tiff.hpp\"\n\n#define int64 int64_tiff\n#define uint64 uint64_tiff\n\n#ifdef HAVE_TIFF\n# include \"tiff.h\"\n# include \"tiffio.h\"\n#endif\n\nnamespace cv\n{\nstatic const char fmtSignTiffII[] = \"II\\x2a\\x00\";\n\n#ifdef HAVE_TIFF\n\nstatic const char fmtSignTiffMM[] = \"MM\\x00\\x2a\";\nstatic int grfmt_tiff_err_handler_init = 0;\nstatic void GrFmtSilentTIFFErrorHandler( const char*, const char*, va_list ) {}\n\nTiffDecoder::TiffDecoder()\n{\n    m_tif = 0;\n    if( !grfmt_tiff_err_handler_init )\n    {\n        grfmt_tiff_err_handler_init = 1;\n\n        TIFFSetErrorHandler( GrFmtSilentTIFFErrorHandler );\n        TIFFSetWarningHandler( GrFmtSilentTIFFErrorHandler );\n    }\n}\n\n\nvoid TiffDecoder::close()\n{\n    if( m_tif )\n    {\n        TIFF* tif = (TIFF*)m_tif;\n        TIFFClose( tif );\n        m_tif = 0;\n    }\n}\n\nTiffDecoder::~TiffDecoder()\n{\n    close();\n}\n\nsize_t TiffDecoder::signatureLength() const\n{\n    return 4;\n}\n\nbool TiffDecoder::checkSignature( const string& signature ) const\n{\n    return signature.size() >= 4 &&\n        (memcmp(signature.c_str(), fmtSignTiffII, 4) == 0 ||\n        memcmp(signature.c_str(), fmtSignTiffMM, 4) == 0);\n}\n\nImageDecoder TiffDecoder::newDecoder() const\n{\n    return new TiffDecoder;\n}\n\nbool TiffDecoder::readHeader()\n{\n    bool result = false;\n\n    close();\n    // TIFFOpen() mode flags are different to fopen().  A 'b' in mode \"rb\" has no effect when reading.\n    // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n    TIFF* tif = TIFFOpen( m_filename.c_str(), \"r\" );\n\n    if( tif )\n    {\n        uint32 wdth = 0, hght = 0;\n        uint16 photometric = 0;\n        m_tif = tif;\n\n        if( TIFFGetField( tif, TIFFTAG_IMAGEWIDTH, &wdth ) &&\n            TIFFGetField( tif, TIFFTAG_IMAGELENGTH, &hght ) &&\n            TIFFGetField( tif, TIFFTAG_PHOTOMETRIC, &photometric ))\n        {\n            uint16 bpp=8, ncn = photometric > 1 ? 3 : 1;\n            TIFFGetField( tif, TIFFTAG_BITSPERSAMPLE, &bpp );\n            TIFFGetField( tif, TIFFTAG_SAMPLESPERPIXEL, &ncn );\n\n            m_width = wdth;\n            m_height = hght;\n            if( bpp > 8 &&\n               ((photometric != 2 && photometric != 1) ||\n                (ncn != 1 && ncn != 3 && ncn != 4)))\n                bpp = 8;\n\n            switch(bpp)\n            {\n                case 8:\n                    m_type = CV_MAKETYPE(CV_8U, photometric > 1 ? 3 : 1);\n                    break;\n                case 16:\n                    m_type = CV_MAKETYPE(CV_16U, photometric > 1 ? 3 : 1);\n                    break;\n\n                case 32:\n                    m_type = CV_MAKETYPE(CV_32F, photometric > 1 ? 3 : 1);\n                    break;\n                case 64:\n                    m_type = CV_MAKETYPE(CV_64F, photometric > 1 ? 3 : 1);\n                    break;\n\n                default:\n                    result = false;\n            }\n            result = true;\n        }\n    }\n\n    if( !result )\n        close();\n\n    return result;\n}\n\n\nbool  TiffDecoder::readData( Mat& img )\n{\n    bool result = false;\n    bool color = img.channels() > 1;\n    uchar* data = img.data;\n\n    if( img.depth() != CV_8U && img.depth() != CV_16U && img.depth() != CV_32F && img.depth() != CV_64F )\n        return false;\n\n    if( m_tif && m_width && m_height )\n    {\n        TIFF* tif = (TIFF*)m_tif;\n        uint32 tile_width0 = m_width, tile_height0 = 0;\n        int x, y, i;\n        int is_tiled = TIFFIsTiled(tif);\n        uint16 photometric;\n        TIFFGetField( tif, TIFFTAG_PHOTOMETRIC, &photometric );\n        uint16 bpp = 8, ncn = photometric > 1 ? 3 : 1;\n        TIFFGetField( tif, TIFFTAG_BITSPERSAMPLE, &bpp );\n        TIFFGetField( tif, TIFFTAG_SAMPLESPERPIXEL, &ncn );\n        const int bitsPerByte = 8;\n        int dst_bpp = (int)(img.elemSize1() * bitsPerByte);\n\n        if(dst_bpp == 8)\n        {\n            char errmsg[1024];\n            if(!TIFFRGBAImageOK( tif, errmsg ))\n            {\n                close();\n                return false;\n            }\n        }\n\n        if( (!is_tiled) ||\n            (is_tiled &&\n            TIFFGetField( tif, TIFFTAG_TILEWIDTH, &tile_width0 ) &&\n            TIFFGetField( tif, TIFFTAG_TILELENGTH, &tile_height0 )))\n        {\n            if(!is_tiled)\n                TIFFGetField( tif, TIFFTAG_ROWSPERSTRIP, &tile_height0 );\n\n            if( tile_width0 <= 0 )\n                tile_width0 = m_width;\n\n            if( tile_height0 <= 0 ||\n                (!is_tiled && tile_height0 == std::numeric_limits<uint32>::max()) )\n                tile_height0 = m_height;\n\n            const size_t buffer_size = bpp * ncn * tile_height0 * tile_width0;\n            AutoBuffer<uchar> _buffer( buffer_size );\n            uchar* buffer = _buffer;\n            ushort* buffer16 = (ushort*)buffer;\n            float* buffer32 = (float*)buffer;\n            double* buffer64 = (double*)buffer;\n            int tileidx = 0;\n\n            for( y = 0; y < m_height; y += tile_height0, data += img.step*tile_height0 )\n            {\n                int tile_height = tile_height0;\n\n                if( y + tile_height > m_height )\n                    tile_height = m_height - y;\n\n                for( x = 0; x < m_width; x += tile_width0, tileidx++ )\n                {\n                    int tile_width = tile_width0, ok;\n\n                    if( x + tile_width > m_width )\n                        tile_width = m_width - x;\n\n                    switch(dst_bpp)\n                    {\n                        case 8:\n                        {\n                            uchar * bstart = buffer;\n                            if( !is_tiled )\n                                ok = TIFFReadRGBAStrip( tif, y, (uint32*)buffer );\n                            else\n                            {\n                                ok = TIFFReadRGBATile( tif, x, y, (uint32*)buffer );\n                                //Tiles fill the buffer from the bottom up\n                                bstart += (tile_height0 - tile_height) * tile_width0 * 4;\n                            }\n                            if( !ok )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                                if( color )\n                                    icvCvt_BGRA2BGR_8u_C4C3R( bstart + i*tile_width0*4, 0,\n                                                             data + x*3 + img.step*(tile_height - i - 1), 0,\n                                                             cvSize(tile_width,1), 2 );\n                                else\n                                    icvCvt_BGRA2Gray_8u_C4C1R( bstart + i*tile_width0*4, 0,\n                                                              data + x + img.step*(tile_height - i - 1), 0,\n                                                              cvSize(tile_width,1), 2 );\n                            break;\n                        }\n\n                        case 16:\n                        {\n                            if( !is_tiled )\n                                ok = (int)TIFFReadEncodedStrip( tif, tileidx, (uint32*)buffer, buffer_size ) >= 0;\n                            else\n                                ok = (int)TIFFReadEncodedTile( tif, tileidx, (uint32*)buffer, buffer_size ) >= 0;\n\n                            if( !ok )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                            {\n                                if( color )\n                                {\n                                    if( ncn == 1 )\n                                    {\n                                        icvCvt_Gray2BGR_16u_C1C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                                  (ushort*)(data + img.step*i) + x*3, 0,\n                                                                  cvSize(tile_width,1) );\n                                    }\n                                    else if( ncn == 3 )\n                                    {\n                                        icvCvt_RGB2BGR_16u_C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                               (ushort*)(data + img.step*i) + x*3, 0,\n                                                               cvSize(tile_width,1) );\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2BGR_16u_C4C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                               (ushort*)(data + img.step*i) + x*3, 0,\n                                                               cvSize(tile_width,1), 2 );\n                                    }\n                                }\n                                else\n                                {\n                                    if( ncn == 1 )\n                                    {\n                                        memcpy((ushort*)(data + img.step*i)+x,\n                                               buffer16 + i*tile_width0*ncn,\n                                               tile_width*sizeof(buffer16[0]));\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2Gray_16u_CnC1R(buffer16 + i*tile_width0*ncn, 0,\n                                                               (ushort*)(data + img.step*i) + x, 0,\n                                                               cvSize(tile_width,1), ncn, 2 );\n                                    }\n                                }\n                            }\n                            break;\n                        }\n\n                        case 32:\n                        case 64:\n                        {\n                            if( !is_tiled )\n                                ok = (int)TIFFReadEncodedStrip( tif, tileidx, buffer, buffer_size ) >= 0;\n                            else\n                                ok = (int)TIFFReadEncodedTile( tif, tileidx, buffer, buffer_size ) >= 0;\n\n                            if( !ok || ncn != 1 )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                            {\n                                if(dst_bpp == 32)\n                                {\n                                    memcpy((float*)(data + img.step*i)+x,\n                                           buffer32 + i*tile_width0*ncn,\n                                           tile_width*sizeof(buffer32[0]));\n                                }\n                                else\n                                {\n                                    memcpy((double*)(data + img.step*i)+x,\n                                         buffer64 + i*tile_width0*ncn,\n                                         tile_width*sizeof(buffer64[0]));\n                                }\n                            }\n\n                            break;\n                        }\n                        default:\n                        {\n                            close();\n                            return false;\n                        }\n                    }\n                }\n            }\n\n            result = true;\n        }\n    }\n\n    close();\n    return result;\n}\n\n#endif\n\n//////////////////////////////////////////////////////////////////////////////////////////\n\nTiffEncoder::TiffEncoder()\n{\n    m_description = \"TIFF Files (*.tiff;*.tif)\";\n#ifdef HAVE_TIFF\n    m_buf_supported = false;\n#else\n    m_buf_supported = true;\n#endif\n}\n\nTiffEncoder::~TiffEncoder()\n{\n}\n\nImageEncoder TiffEncoder::newEncoder() const\n{\n    return new TiffEncoder;\n}\n\nbool TiffEncoder::isFormatSupported( int depth ) const\n{\n    return depth == CV_8U || depth == CV_16U;\n}\n\nvoid  TiffEncoder::writeTag( WLByteStream& strm, TiffTag tag,\n                             TiffFieldType fieldType,\n                             int count, int value )\n{\n    strm.putWord( tag );\n    strm.putWord( fieldType );\n    strm.putDWord( count );\n    strm.putDWord( value );\n}\n\n#ifdef HAVE_TIFF\n\nstatic void readParam(const vector<int>& params, int key, int& value)\n{\n    for(size_t i = 0; i + 1 < params.size(); i += 2)\n        if(params[i] == key)\n        {\n            value = params[i+1];\n            break;\n        }\n}\n\nbool  TiffEncoder::writeLibTiff( const Mat& img, const vector<int>& params)\n{\n    int channels = img.channels();\n    int width = img.cols, height = img.rows;\n    int depth = img.depth();\n\n    int bitsPerChannel = -1;\n    switch (depth)\n    {\n        case CV_8U:\n        {\n            bitsPerChannel = 8;\n            break;\n        }\n        case CV_16U:\n        {\n            bitsPerChannel = 16;\n            break;\n        }\n        default:\n        {\n            return false;\n        }\n    }\n\n    const int bitsPerByte = 8;\n    size_t fileStep = (width * channels * bitsPerChannel) / bitsPerByte;\n\n    int rowsPerStrip = (int)((1 << 13)/fileStep);\n    readParam(params, TIFFTAG_ROWSPERSTRIP, rowsPerStrip);\n\n    if( rowsPerStrip < 1 )\n        rowsPerStrip = 1;\n\n    if( rowsPerStrip > height )\n        rowsPerStrip = height;\n\n\n    // do NOT put \"wb\" as the mode, because the b means \"big endian\" mode, not \"binary\" mode.\n    // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n    TIFF* pTiffHandle = TIFFOpen(m_filename.c_str(), \"w\");\n    if (!pTiffHandle)\n    {\n        return false;\n    }\n\n    // defaults for now, maybe base them on params in the future\n    int   compression  = COMPRESSION_LZW;\n    int   predictor    = PREDICTOR_HORIZONTAL;\n\n    readParam(params, TIFFTAG_COMPRESSION, compression);\n    readParam(params, TIFFTAG_PREDICTOR, predictor);\n\n    int   colorspace = channels > 1 ? PHOTOMETRIC_RGB : PHOTOMETRIC_MINISBLACK;\n\n    if ( !TIFFSetField(pTiffHandle, TIFFTAG_IMAGEWIDTH, width)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_IMAGELENGTH, height)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_BITSPERSAMPLE, bitsPerChannel)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_COMPRESSION, compression)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_PHOTOMETRIC, colorspace)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_SAMPLESPERPIXEL, channels)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_ROWSPERSTRIP, rowsPerStrip)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_PREDICTOR, predictor)\n       )\n    {\n        TIFFClose(pTiffHandle);\n        return false;\n    }\n\n    // row buffer, because TIFFWriteScanline modifies the original data!\n    size_t scanlineSize = TIFFScanlineSize(pTiffHandle);\n    AutoBuffer<uchar> _buffer(scanlineSize+32);\n    uchar* buffer = _buffer;\n    if (!buffer)\n    {\n        TIFFClose(pTiffHandle);\n        return false;\n    }\n\n    for (int y = 0; y < height; ++y)\n    {\n        switch(channels)\n        {\n            case 1:\n            {\n                memcpy(buffer, img.data + img.step * y, scanlineSize);\n                break;\n            }\n\n            case 3:\n            {\n                if (depth == CV_8U)\n                    icvCvt_BGR2RGB_8u_C3R( img.data + img.step*y, 0, buffer, 0, cvSize(width,1) );\n                else\n                    icvCvt_BGR2RGB_16u_C3R( (const ushort*)(img.data + img.step*y), 0, (ushort*)buffer, 0, cvSize(width,1) );\n                break;\n            }\n\n            case 4:\n            {\n                if (depth == CV_8U)\n                    icvCvt_BGRA2RGBA_8u_C4R( img.data + img.step*y, 0, buffer, 0, cvSize(width,1) );\n                else\n                    icvCvt_BGRA2RGBA_16u_C4R( (const ushort*)(img.data + img.step*y), 0, (ushort*)buffer, 0, cvSize(width,1) );\n                break;\n            }\n\n            default:\n            {\n                TIFFClose(pTiffHandle);\n                return false;\n            }\n        }\n\n        int writeResult = TIFFWriteScanline(pTiffHandle, buffer, y, 0);\n        if (writeResult != 1)\n        {\n            TIFFClose(pTiffHandle);\n            return false;\n        }\n    }\n\n    TIFFClose(pTiffHandle);\n    return true;\n}\n\n#endif\n\n#ifdef HAVE_TIFF\nbool  TiffEncoder::write( const Mat& img, const vector<int>& params)\n#else\nbool  TiffEncoder::write( const Mat& img, const vector<int>& /*params*/)\n#endif\n{\n    int channels = img.channels();\n    int width = img.cols, height = img.rows;\n    int depth = img.depth();\n\n    if (depth != CV_8U && depth != CV_16U)\n        return false;\n\n    int bytesPerChannel = depth == CV_8U ? 1 : 2;\n    int fileStep = width * channels * bytesPerChannel;\n\n    WLByteStream strm;\n\n    if( m_buf )\n    {\n        if( !strm.open(*m_buf) )\n            return false;\n    }\n    else\n    {\n#ifdef HAVE_TIFF\n      return writeLibTiff(img, params);\n#else\n      if( !strm.open(m_filename) )\n          return false;\n#endif\n    }\n\n    int rowsPerStrip = (1 << 13)/fileStep;\n\n    if( rowsPerStrip < 1 )\n        rowsPerStrip = 1;\n\n    if( rowsPerStrip > height )\n        rowsPerStrip = height;\n\n    int i, stripCount = (height + rowsPerStrip - 1) / rowsPerStrip;\n\n    if( m_buf )\n        m_buf->reserve( alignSize(stripCount*8 + fileStep*height + 256, 256) );\n\n/*#if defined _DEBUG || !defined WIN32\n    int uncompressedRowSize = rowsPerStrip * fileStep;\n#endif*/\n    int directoryOffset = 0;\n\n    AutoBuffer<int> stripOffsets(stripCount);\n    AutoBuffer<short> stripCounts(stripCount);\n    AutoBuffer<uchar> _buffer(fileStep+32);\n    uchar* buffer = _buffer;\n    int  stripOffsetsOffset = 0;\n    int  stripCountsOffset = 0;\n    int  bitsPerSample = 8 * bytesPerChannel;\n    int  y = 0;\n\n    strm.putBytes( fmtSignTiffII, 4 );\n    strm.putDWord( directoryOffset );\n\n    // write an image data first (the most reasonable way\n    // for compressed images)\n    for( i = 0; i < stripCount; i++ )\n    {\n        int limit = y + rowsPerStrip;\n\n        if( limit > height )\n            limit = height;\n\n        stripOffsets[i] = strm.getPos();\n\n        for( ; y < limit; y++ )\n        {\n            if( channels == 3 )\n            {\n                if (depth == CV_8U)\n                    icvCvt_BGR2RGB_8u_C3R( img.data + img.step*y, 0, buffer, 0, cvSize(width,1) );\n                else\n                    icvCvt_BGR2RGB_16u_C3R( (const ushort*)(img.data + img.step*y), 0, (ushort*)buffer, 0, cvSize(width,1) );\n            }\n            else\n            {\n              if( channels == 4 )\n              {\n                if (depth == CV_8U)\n                    icvCvt_BGRA2RGBA_8u_C4R( img.data + img.step*y, 0, buffer, 0, cvSize(width,1) );\n                else\n                    icvCvt_BGRA2RGBA_16u_C4R( (const ushort*)(img.data + img.step*y), 0, (ushort*)buffer, 0, cvSize(width,1) );\n              }\n            }\n\n            strm.putBytes( channels > 1 ? buffer : img.data + img.step*y, fileStep );\n        }\n\n        stripCounts[i] = (short)(strm.getPos() - stripOffsets[i]);\n        /*assert( stripCounts[i] == uncompressedRowSize ||\n                stripCounts[i] < uncompressedRowSize &&\n                i == stripCount - 1);*/\n    }\n\n    if( stripCount > 2 )\n    {\n        stripOffsetsOffset = strm.getPos();\n        for( i = 0; i < stripCount; i++ )\n            strm.putDWord( stripOffsets[i] );\n\n        stripCountsOffset = strm.getPos();\n        for( i = 0; i < stripCount; i++ )\n            strm.putWord( stripCounts[i] );\n    }\n    else if(stripCount == 2)\n    {\n        stripOffsetsOffset = strm.getPos();\n        for (i = 0; i < stripCount; i++)\n        {\n            strm.putDWord (stripOffsets [i]);\n        }\n        stripCountsOffset = stripCounts [0] + (stripCounts [1] << 16);\n    }\n    else\n    {\n        stripOffsetsOffset = stripOffsets[0];\n        stripCountsOffset = stripCounts[0];\n    }\n\n    if( channels > 1 )\n    {\n        int bitsPerSamplePos = strm.getPos();\n        strm.putWord(bitsPerSample);\n        strm.putWord(bitsPerSample);\n        strm.putWord(bitsPerSample);\n        if( channels == 4 )\n            strm.putWord(bitsPerSample);\n        bitsPerSample = bitsPerSamplePos;\n    }\n\n    directoryOffset = strm.getPos();\n\n    // write header\n    strm.putWord( 9 );\n\n    /* warning: specification 5.0 of Tiff want to have tags in\n       ascending order. This is a non-fatal error, but this cause\n       warning with some tools. So, keep this in ascending order */\n\n    writeTag( strm, TIFF_TAG_WIDTH, TIFF_TYPE_LONG, 1, width );\n    writeTag( strm, TIFF_TAG_HEIGHT, TIFF_TYPE_LONG, 1, height );\n    writeTag( strm, TIFF_TAG_BITS_PER_SAMPLE,\n              TIFF_TYPE_SHORT, channels, bitsPerSample );\n    writeTag( strm, TIFF_TAG_COMPRESSION, TIFF_TYPE_LONG, 1, TIFF_UNCOMP );\n    writeTag( strm, TIFF_TAG_PHOTOMETRIC, TIFF_TYPE_SHORT, 1, channels > 1 ? 2 : 1 );\n\n    writeTag( strm, TIFF_TAG_STRIP_OFFSETS, TIFF_TYPE_LONG,\n              stripCount, stripOffsetsOffset );\n\n    writeTag( strm, TIFF_TAG_SAMPLES_PER_PIXEL, TIFF_TYPE_SHORT, 1, channels );\n    writeTag( strm, TIFF_TAG_ROWS_PER_STRIP, TIFF_TYPE_LONG, 1, rowsPerStrip );\n\n    writeTag( strm, TIFF_TAG_STRIP_COUNTS,\n              stripCount > 1 ? TIFF_TYPE_SHORT : TIFF_TYPE_LONG,\n              stripCount, stripCountsOffset );\n\n    strm.putDWord(0);\n    strm.close();\n\n    if( m_buf )\n    {\n        (*m_buf)[4] = (uchar)directoryOffset;\n        (*m_buf)[5] = (uchar)(directoryOffset >> 8);\n        (*m_buf)[6] = (uchar)(directoryOffset >> 16);\n        (*m_buf)[7] = (uchar)(directoryOffset >> 24);\n    }\n    else\n    {\n        // write directory offset\n        FILE* f = fopen( m_filename.c_str(), \"r+b\" );\n        buffer[0] = (uchar)directoryOffset;\n        buffer[1] = (uchar)(directoryOffset >> 8);\n        buffer[2] = (uchar)(directoryOffset >> 16);\n        buffer[3] = (uchar)(directoryOffset >> 24);\n\n        fseek( f, 4, SEEK_SET );\n        fwrite( buffer, 1, 4, f );\n        fclose(f);\n    }\n\n    return true;\n}\n\n}\n",
                "name": "grfmt_tiff.cpp",
                "path": "opencv-2.4.11/modules/highgui/src/grfmt_tiff.cpp",
                "url": "/github.com/rajkataria/ReliableResectioning/-/blob/opencv-2.4.11/modules/highgui/src/grfmt_tiff.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 254,
                    "offsetAndLengths": [
                        [
                            37,
                            16
                        ]
                    ],
                    "preview": "                                ok = TIFFReadRGBATile( tif, x, y, (uint32*)buffer );"
                }
            ],
            "repository": {
                "name": "github.com/rajkataria/ReliableResectioning",
                "url": "/github.com/rajkataria/ReliableResectioning"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "a9e7f2cc6ead1b932a86aa1d95073330d67c31ec"
                },
                "content": "/*M///////////////////////////////////////////////////////////////////////////////////////\n//\n//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.\n//\n//  By downloading, copying, installing or using the software you agree to this license.\n//  If you do not agree to this license, do not download, install,\n//  copy or use the software.\n//\n//\n//                           License Agreement\n//                For Open Source Computer Vision Library\n//\n// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.\n// Copyright (C) 2009, Willow Garage Inc., all rights reserved.\n// Third party copyrights are property of their respective owners.\n//\n// Redistribution and use in source and binary forms, with or without modification,\n// are permitted provided that the following conditions are met:\n//\n//   * Redistribution's of source code must retain the above copyright notice,\n//     this list of conditions and the following disclaimer.\n//\n//   * Redistribution's in binary form must reproduce the above copyright notice,\n//     this list of conditions and the following disclaimer in the documentation\n//     and/or other materials provided with the distribution.\n//\n//   * The name of the copyright holders may not be used to endorse or promote products\n//     derived from this software without specific prior written permission.\n//\n// This software is provided by the copyright holders and contributors \"as is\" and\n// any express or implied warranties, including, but not limited to, the implied\n// warranties of merchantability and fitness for a particular purpose are disclaimed.\n// In no event shall the Intel Corporation or contributors be liable for any direct,\n// indirect, incidental, special, exemplary, or consequential damages\n// (including, but not limited to, procurement of substitute goods or services;\n// loss of use, data, or profits; or business interruption) however caused\n// and on any theory of liability, whether in contract, strict liability,\n// or tort (including negligence or otherwise) arising in any way out of\n// the use of this software, even if advised of the possibility of such damage.\n//\n//M*/\n\n/****************************************************************************************\\\n    A part of the file implements TIFF reader on base of libtiff library\n    (see otherlibs/_graphics/readme.txt for copyright notice)\n\\****************************************************************************************/\n\n#include \"precomp.hpp\"\n\n#ifdef HAVE_TIFF\n#include \"grfmt_tiff.hpp\"\n#include <limits>\n\n// TODO FIXIT Conflict declarations for common types like int64/uint64\nnamespace tiff_dummy_namespace {\n#include \"tiff.h\"\n#include \"tiffio.h\"\n}\nusing namespace tiff_dummy_namespace;\n\nnamespace cv\n{\n\n\nstatic const char fmtSignTiffII[] = \"II\\x2a\\x00\";\nstatic const char fmtSignTiffMM[] = \"MM\\x00\\x2a\";\n\nstatic int grfmt_tiff_err_handler_init = 0;\nstatic void GrFmtSilentTIFFErrorHandler( const char*, const char*, va_list ) {}\n\nTiffDecoder::TiffDecoder()\n{\n    m_tif = 0;\n    if( !grfmt_tiff_err_handler_init )\n    {\n        grfmt_tiff_err_handler_init = 1;\n\n        TIFFSetErrorHandler( GrFmtSilentTIFFErrorHandler );\n        TIFFSetWarningHandler( GrFmtSilentTIFFErrorHandler );\n    }\n    m_hdr = false;\n    m_buf_supported = true;\n    m_buf_pos = 0;\n}\n\n\nvoid TiffDecoder::close()\n{\n    if( m_tif )\n    {\n        TIFF* tif = (TIFF*)m_tif;\n        TIFFClose( tif );\n        m_tif = 0;\n    }\n}\n\nTiffDecoder::~TiffDecoder()\n{\n    close();\n}\n\nsize_t TiffDecoder::signatureLength() const\n{\n    return 4;\n}\n\nbool TiffDecoder::checkSignature( const String& signature ) const\n{\n    return signature.size() >= 4 &&\n        (memcmp(signature.c_str(), fmtSignTiffII, 4) == 0 ||\n        memcmp(signature.c_str(), fmtSignTiffMM, 4) == 0);\n}\n\nint TiffDecoder::normalizeChannelsNumber(int channels) const\n{\n    return channels > 4 ? 4 : channels;\n}\n\nImageDecoder TiffDecoder::newDecoder() const\n{\n    return makePtr<TiffDecoder>();\n}\n\nclass TiffDecoderBufHelper\n{\n    Mat& m_buf;\n    size_t& m_buf_pos;\npublic:\n    TiffDecoderBufHelper(Mat& buf, size_t& buf_pos) :\n        m_buf(buf), m_buf_pos(buf_pos)\n    {}\n    static tmsize_t read( thandle_t handle, void* buffer, tmsize_t n )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        const Mat& buf = helper->m_buf;\n        const tmsize_t size = buf.cols*buf.rows*buf.elemSize();\n        tmsize_t pos = helper->m_buf_pos;\n        if ( n > (size - pos) )\n        {\n            n = size - pos;\n        }\n        memcpy(buffer, buf.ptr() + pos, n);\n        helper->m_buf_pos += n;\n        return n;\n    }\n\n    static tmsize_t write( thandle_t /*handle*/, void* /*buffer*/, tmsize_t /*n*/ )\n    {\n        // Not used for decoding.\n        return 0;\n    }\n\n    static toff_t seek( thandle_t handle, toff_t offset, int whence )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        const Mat& buf = helper->m_buf;\n        const toff_t size = buf.cols*buf.rows*buf.elemSize();\n        toff_t new_pos = helper->m_buf_pos;\n        switch (whence)\n        {\n            case SEEK_SET:\n                new_pos = offset;\n                break;\n            case SEEK_CUR:\n                new_pos += offset;\n                break;\n            case SEEK_END:\n                new_pos = size + offset;\n                break;\n        }\n        new_pos = std::min(new_pos, size);\n        helper->m_buf_pos = (size_t)new_pos;\n        return new_pos;\n    }\n\n    static int map( thandle_t handle, void** base, toff_t* size )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        Mat& buf = helper->m_buf;\n        *base = buf.ptr();\n        *size = buf.cols*buf.rows*buf.elemSize();\n        return 0;\n    }\n\n    static toff_t size( thandle_t handle )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        const Mat& buf = helper->m_buf;\n        return buf.cols*buf.rows*buf.elemSize();\n    }\n\n    static int close( thandle_t handle )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        delete helper;\n        return 0;\n    }\n};\n\nbool TiffDecoder::readHeader()\n{\n    bool result = false;\n\n    TIFF* tif = static_cast<TIFF*>(m_tif);\n    if (!m_tif)\n    {\n        // TIFFOpen() mode flags are different to fopen().  A 'b' in mode \"rb\" has no effect when reading.\n        // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n        if ( !m_buf.empty() )\n        {\n            m_buf_pos = 0;\n            TiffDecoderBufHelper* buf_helper = new TiffDecoderBufHelper(this->m_buf, this->m_buf_pos);\n            tif = TIFFClientOpen( \"\", \"r\", reinterpret_cast<thandle_t>(buf_helper), &TiffDecoderBufHelper::read,\n                                  &TiffDecoderBufHelper::write, &TiffDecoderBufHelper::seek,\n                                  &TiffDecoderBufHelper::close, &TiffDecoderBufHelper::size,\n                                  &TiffDecoderBufHelper::map, /*unmap=*/0 );\n        }\n        else\n        {\n            tif = TIFFOpen(m_filename.c_str(), \"r\");\n        }\n    }\n\n    if( tif )\n    {\n        uint32 wdth = 0, hght = 0;\n        uint16 photometric = 0;\n        m_tif = tif;\n\n        if( TIFFGetField( tif, TIFFTAG_IMAGEWIDTH, &wdth ) &&\n            TIFFGetField( tif, TIFFTAG_IMAGELENGTH, &hght ) &&\n            TIFFGetField( tif, TIFFTAG_PHOTOMETRIC, &photometric ))\n        {\n            uint16 bpp=8, ncn = photometric > 1 ? 3 : 1;\n            TIFFGetField( tif, TIFFTAG_BITSPERSAMPLE, &bpp );\n            TIFFGetField( tif, TIFFTAG_SAMPLESPERPIXEL, &ncn );\n\n            m_width = wdth;\n            m_height = hght;\n            if((bpp == 32 && ncn == 3) || photometric == PHOTOMETRIC_LOGLUV)\n            {\n                m_type = CV_32FC3;\n                m_hdr = true;\n                return true;\n            }\n            m_hdr = false;\n\n            if( bpp > 8 &&\n               ((photometric > 2) ||\n                (ncn != 1 && ncn != 3 && ncn != 4)))\n                bpp = 8;\n\n            int wanted_channels = normalizeChannelsNumber(ncn);\n            switch(bpp)\n            {\n                case 8:\n                    m_type = CV_MAKETYPE(CV_8U, photometric > 1 ? wanted_channels : 1);\n                    break;\n                case 16:\n                    m_type = CV_MAKETYPE(CV_16U, photometric > 1 ? wanted_channels : 1);\n                    break;\n\n                case 32:\n                    m_type = CV_MAKETYPE(CV_32F, photometric > 1 ? 3 : 1);\n                    break;\n                case 64:\n                    m_type = CV_MAKETYPE(CV_64F, photometric > 1 ? 3 : 1);\n                    break;\n\n                default:\n                    result = false;\n            }\n            result = true;\n        }\n    }\n\n    if( !result )\n        close();\n\n    return result;\n}\n\nbool TiffDecoder::nextPage()\n{\n    // Prepare the next page, if any.\n    return m_tif &&\n           TIFFReadDirectory(static_cast<TIFF*>(m_tif)) &&\n           readHeader();\n}\n\nbool  TiffDecoder::readData( Mat& img )\n{\n    if(m_hdr && img.type() == CV_32FC3)\n    {\n        return readData_32FC3(img);\n    }\n    if(img.type() == CV_32FC1)\n    {\n        return readData_32FC1(img);\n    }\n    bool result = false;\n    bool color = img.channels() > 1;\n\n    if( img.depth() != CV_8U && img.depth() != CV_16U && img.depth() != CV_32F && img.depth() != CV_64F )\n        return false;\n\n    if( m_tif && m_width && m_height )\n    {\n        TIFF* tif = (TIFF*)m_tif;\n        uint32 tile_width0 = m_width, tile_height0 = 0;\n        int x, y, i;\n        int is_tiled = TIFFIsTiled(tif);\n        uint16 photometric;\n        TIFFGetField( tif, TIFFTAG_PHOTOMETRIC, &photometric );\n        uint16 bpp = 8, ncn = photometric > 1 ? 3 : 1;\n        TIFFGetField( tif, TIFFTAG_BITSPERSAMPLE, &bpp );\n        TIFFGetField( tif, TIFFTAG_SAMPLESPERPIXEL, &ncn );\n        uint16 img_orientation = ORIENTATION_TOPLEFT;\n        TIFFGetField( tif, TIFFTAG_ORIENTATION, &img_orientation);\n        bool vert_flip = (img_orientation == ORIENTATION_BOTRIGHT) || (img_orientation == ORIENTATION_RIGHTBOT) ||\n                         (img_orientation == ORIENTATION_BOTLEFT) || (img_orientation == ORIENTATION_LEFTBOT);\n        const int bitsPerByte = 8;\n        int dst_bpp = (int)(img.elemSize1() * bitsPerByte);\n        int wanted_channels = normalizeChannelsNumber(img.channels());\n\n        if(dst_bpp == 8)\n        {\n            char errmsg[1024];\n            if(!TIFFRGBAImageOK( tif, errmsg ))\n            {\n                close();\n                return false;\n            }\n        }\n\n        if( (!is_tiled) ||\n            (is_tiled &&\n            TIFFGetField( tif, TIFFTAG_TILEWIDTH, &tile_width0 ) &&\n            TIFFGetField( tif, TIFFTAG_TILELENGTH, &tile_height0 )))\n        {\n            if(!is_tiled)\n                TIFFGetField( tif, TIFFTAG_ROWSPERSTRIP, &tile_height0 );\n\n            if( tile_width0 <= 0 )\n                tile_width0 = m_width;\n\n            if( tile_height0 <= 0 ||\n               (!is_tiled && tile_height0 == std::numeric_limits<uint32>::max()) )\n                tile_height0 = m_height;\n\n            if(dst_bpp == 8) {\n                // we will use TIFFReadRGBA* functions, so allocate temporary buffer for 32bit RGBA\n                bpp = 8;\n                ncn = 4;\n            }\n            const size_t buffer_size = (bpp/bitsPerByte) * ncn * tile_height0 * tile_width0;\n            AutoBuffer<uchar> _buffer( buffer_size );\n            uchar* buffer = _buffer;\n            ushort* buffer16 = (ushort*)buffer;\n            float* buffer32 = (float*)buffer;\n            double* buffer64 = (double*)buffer;\n            int tileidx = 0;\n\n            for( y = 0; y < m_height; y += tile_height0 )\n            {\n                int tile_height = tile_height0;\n\n                if( y + tile_height > m_height )\n                    tile_height = m_height - y;\n\n                uchar* data = img.ptr(vert_flip ? m_height - y - tile_height : y);\n\n                for( x = 0; x < m_width; x += tile_width0, tileidx++ )\n                {\n                    int tile_width = tile_width0, ok;\n\n                    if( x + tile_width > m_width )\n                        tile_width = m_width - x;\n\n                    switch(dst_bpp)\n                    {\n                        case 8:\n                        {\n                            uchar * bstart = buffer;\n                            if( !is_tiled )\n                                ok = TIFFReadRGBAStrip( tif, y, (uint32*)buffer );\n                            else\n                            {\n                                ok = TIFFReadRGBATile( tif, x, y, (uint32*)buffer );\n                                //Tiles fill the buffer from the bottom up\n                                bstart += (tile_height0 - tile_height) * tile_width0 * 4;\n                            }\n                            if( !ok )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                                if( color )\n                                {\n                                    if (wanted_channels == 4)\n                                    {\n                                        icvCvt_BGRA2RGBA_8u_C4R( bstart + i*tile_width0*4, 0,\n                                                             data + x*4 + img.step*(tile_height - i - 1), 0,\n                                                             cvSize(tile_width,1) );\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2BGR_8u_C4C3R( bstart + i*tile_width0*4, 0,\n                                                             data + x*3 + img.step*(tile_height - i - 1), 0,\n                                                             cvSize(tile_width,1), 2 );\n                                    }\n                                }\n                                else\n                                    icvCvt_BGRA2Gray_8u_C4C1R( bstart + i*tile_width0*4, 0,\n                                                              data + x + img.step*(tile_height - i - 1), 0,\n                                                              cvSize(tile_width,1), 2 );\n                            break;\n                        }\n\n                        case 16:\n                        {\n                            if( !is_tiled )\n                                ok = (int)TIFFReadEncodedStrip( tif, tileidx, (uint32*)buffer, buffer_size ) >= 0;\n                            else\n                                ok = (int)TIFFReadEncodedTile( tif, tileidx, (uint32*)buffer, buffer_size ) >= 0;\n\n                            if( !ok )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                            {\n                                if( color )\n                                {\n                                    if( ncn == 1 )\n                                    {\n                                        icvCvt_Gray2BGR_16u_C1C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                                  (ushort*)(data + img.step*i) + x*3, 0,\n                                                                  cvSize(tile_width,1) );\n                                    }\n                                    else if( ncn == 3 )\n                                    {\n                                        icvCvt_RGB2BGR_16u_C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                               (ushort*)(data + img.step*i) + x*3, 0,\n                                                               cvSize(tile_width,1) );\n                                    }\n                                    else if (ncn == 4)\n                                    {\n                                        if (wanted_channels == 4)\n                                        {\n                                            icvCvt_BGRA2RGBA_16u_C4R(buffer16 + i*tile_width0*ncn, 0,\n                                                (ushort*)(data + img.step*i) + x * 4, 0,\n                                                cvSize(tile_width, 1));\n                                        }\n                                        else\n                                        {\n                                            icvCvt_BGRA2BGR_16u_C4C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                (ushort*)(data + img.step*i) + x * 3, 0,\n                                                cvSize(tile_width, 1), 2);\n                                        }\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2BGR_16u_C4C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                               (ushort*)(data + img.step*i) + x*3, 0,\n                                                               cvSize(tile_width,1), 2 );\n                                    }\n                                }\n                                else\n                                {\n                                    if( ncn == 1 )\n                                    {\n                                        memcpy((ushort*)(data + img.step*i)+x,\n                                               buffer16 + i*tile_width0*ncn,\n                                               tile_width*sizeof(buffer16[0]));\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2Gray_16u_CnC1R(buffer16 + i*tile_width0*ncn, 0,\n                                                               (ushort*)(data + img.step*i) + x, 0,\n                                                               cvSize(tile_width,1), ncn, 2 );\n                                    }\n                                }\n                            }\n                            break;\n                        }\n\n                        case 32:\n                        case 64:\n                        {\n                            if( !is_tiled )\n                                ok = (int)TIFFReadEncodedStrip( tif, tileidx, buffer, buffer_size ) >= 0;\n                            else\n                                ok = (int)TIFFReadEncodedTile( tif, tileidx, buffer, buffer_size ) >= 0;\n\n                            if( !ok || ncn != 1 )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                            {\n                                if(dst_bpp == 32)\n                                {\n                                    memcpy((float*)(data + img.step*i)+x,\n                                           buffer32 + i*tile_width0*ncn,\n                                           tile_width*sizeof(buffer32[0]));\n                                }\n                                else\n                                {\n                                    memcpy((double*)(data + img.step*i)+x,\n                                         buffer64 + i*tile_width0*ncn,\n                                         tile_width*sizeof(buffer64[0]));\n                                }\n                            }\n\n                            break;\n                        }\n                        default:\n                        {\n                            close();\n                            return false;\n                        }\n                    }\n                }\n            }\n\n            result = true;\n        }\n    }\n\n    return result;\n}\n\nbool TiffDecoder::readData_32FC3(Mat& img)\n{\n    int rows_per_strip = 0, photometric = 0;\n    if(!m_tif)\n    {\n        return false;\n    }\n    TIFF *tif = static_cast<TIFF*>(m_tif);\n    TIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &rows_per_strip);\n    TIFFGetField( tif, TIFFTAG_PHOTOMETRIC, &photometric );\n    TIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_FLOAT);\n    int size = 3 * m_width * m_height * sizeof (float);\n    tstrip_t strip_size = 3 * m_width * rows_per_strip;\n    float *ptr = img.ptr<float>();\n    for (tstrip_t i = 0; i < TIFFNumberOfStrips(tif); i++, ptr += strip_size)\n    {\n        TIFFReadEncodedStrip(tif, i, ptr, size);\n        size -= strip_size * sizeof(float);\n    }\n    close();\n    if(photometric == PHOTOMETRIC_LOGLUV)\n    {\n        cvtColor(img, img, COLOR_XYZ2BGR);\n    }\n    else\n    {\n        cvtColor(img, img, COLOR_RGB2BGR);\n    }\n    return true;\n}\n\nbool TiffDecoder::readData_32FC1(Mat& img)\n{\n    if(!m_tif)\n    {\n        return false;\n    }\n    TIFF *tif = static_cast<TIFF*>(m_tif);\n\n    uint32 img_width, img_height;\n    TIFFGetField(tif,TIFFTAG_IMAGEWIDTH, &img_width);\n    TIFFGetField(tif,TIFFTAG_IMAGELENGTH, &img_height);\n    if(img.size() != Size(img_width,img_height))\n    {\n        close();\n        return false;\n    }\n    tsize_t scanlength = TIFFScanlineSize(tif);\n    tdata_t buf = _TIFFmalloc(scanlength);\n    float* data;\n    bool result = true;\n    for (uint32 row = 0; row < img_height; row++)\n    {\n        if (TIFFReadScanline(tif, buf, row) != 1)\n        {\n            result = false;\n            break;\n        }\n        data=(float*)buf;\n        for (uint32 i=0; i<img_width; i++)\n        {\n            img.at<float>(row,i) = data[i];\n        }\n    }\n    _TIFFfree(buf);\n    close();\n\n    return result;\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////\n\nTiffEncoder::TiffEncoder()\n{\n    m_description = \"TIFF Files (*.tiff;*.tif)\";\n    m_buf_supported = true;\n}\n\nTiffEncoder::~TiffEncoder()\n{\n}\n\nImageEncoder TiffEncoder::newEncoder() const\n{\n    return makePtr<TiffEncoder>();\n}\n\nbool TiffEncoder::isFormatSupported( int depth ) const\n{\n    return depth == CV_8U || depth == CV_16U || depth == CV_32F;\n}\n\nvoid  TiffEncoder::writeTag( WLByteStream& strm, TiffTag tag,\n                             TiffFieldType fieldType,\n                             int count, int value )\n{\n    strm.putWord( tag );\n    strm.putWord( fieldType );\n    strm.putDWord( count );\n    strm.putDWord( value );\n}\n\nclass TiffEncoderBufHelper\n{\npublic:\n\n    TiffEncoderBufHelper(std::vector<uchar> *buf)\n            : m_buf(buf), m_buf_pos(0)\n    {}\n\n    TIFF* open ()\n    {\n        return TIFFClientOpen( \"\", \"w\", reinterpret_cast<thandle_t>(this), &TiffEncoderBufHelper::read,\n                               &TiffEncoderBufHelper::write, &TiffEncoderBufHelper::seek,\n                               &TiffEncoderBufHelper::close, &TiffEncoderBufHelper::size,\n                               /*map=*/0, /*unmap=*/0 );\n    }\n\n    static tmsize_t read( thandle_t /*handle*/, void* /*buffer*/, tmsize_t /*n*/ )\n    {\n        // Not used for encoding.\n        return 0;\n    }\n\n    static tmsize_t write( thandle_t handle, void* buffer, tmsize_t n )\n    {\n        TiffEncoderBufHelper *helper = reinterpret_cast<TiffEncoderBufHelper*>(handle);\n        size_t begin = (size_t)helper->m_buf_pos;\n        size_t end = begin + n;\n        if ( helper->m_buf->size() < end )\n        {\n            helper->m_buf->resize(end);\n        }\n        memcpy(&(*helper->m_buf)[begin], buffer, n);\n        helper->m_buf_pos = end;\n        return n;\n    }\n\n    static toff_t seek( thandle_t handle, toff_t offset, int whence )\n    {\n        TiffEncoderBufHelper *helper = reinterpret_cast<TiffEncoderBufHelper*>(handle);\n        const toff_t size = helper->m_buf->size();\n        toff_t new_pos = helper->m_buf_pos;\n        switch (whence)\n        {\n            case SEEK_SET:\n                new_pos = offset;\n                break;\n            case SEEK_CUR:\n                new_pos += offset;\n                break;\n            case SEEK_END:\n                new_pos = size + offset;\n                break;\n        }\n        helper->m_buf_pos = new_pos;\n        return new_pos;\n    }\n\n    static toff_t size( thandle_t handle )\n    {\n        TiffEncoderBufHelper *helper = reinterpret_cast<TiffEncoderBufHelper*>(handle);\n        return helper->m_buf->size();\n    }\n\n    static int close( thandle_t /*handle*/ )\n    {\n        // Do nothing.\n        return 0;\n    }\n\nprivate:\n\n    std::vector<uchar>* m_buf;\n    toff_t m_buf_pos;\n};\n\nstatic void readParam(const std::vector<int>& params, int key, int& value)\n{\n    for(size_t i = 0; i + 1 < params.size(); i += 2)\n        if(params[i] == key)\n        {\n            value = params[i+1];\n            break;\n        }\n}\n\nbool TiffEncoder::writeLibTiff( const std::vector<Mat>& img_vec, const std::vector<int>& params)\n{\n    // do NOT put \"wb\" as the mode, because the b means \"big endian\" mode, not \"binary\" mode.\n    // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n    TIFF* pTiffHandle;\n\n    TiffEncoderBufHelper buf_helper(m_buf);\n    if ( m_buf )\n    {\n        pTiffHandle = buf_helper.open();\n    }\n    else\n    {\n        pTiffHandle = TIFFOpen(m_filename.c_str(), \"w\");\n    }\n    if (!pTiffHandle)\n    {\n        return false;\n    }\n\n    //Settings that matter to all images\n    // defaults for now, maybe base them on params in the future\n    int compression = COMPRESSION_LZW;\n    int predictor = PREDICTOR_HORIZONTAL;\n\n    readParam(params, TIFFTAG_COMPRESSION, compression);\n    readParam(params, TIFFTAG_PREDICTOR, predictor);\n\n    //Iterate through each image in the vector and write them out as Tiff directories\n    for (size_t page = 0; page < img_vec.size(); page++)\n    {\n        const Mat& img = img_vec[page];\n        int channels = img.channels();\n        int width = img.cols, height = img.rows;\n        int depth = img.depth();\n\n        int bitsPerChannel = -1;\n        switch (depth)\n        {\n            case CV_8U:\n            {\n                bitsPerChannel = 8;\n                break;\n            }\n            case CV_16U:\n            {\n                bitsPerChannel = 16;\n                break;\n            }\n            default:\n            {\n                TIFFClose(pTiffHandle);\n                return false;\n            }\n        }\n\n        const int bitsPerByte = 8;\n        size_t fileStep = (width * channels * bitsPerChannel) / bitsPerByte;\n\n        int rowsPerStrip = (int)((1 << 13) / fileStep);\n        readParam(params, TIFFTAG_ROWSPERSTRIP, rowsPerStrip);\n\n        if (rowsPerStrip < 1)\n            rowsPerStrip = 1;\n\n        if (rowsPerStrip > height)\n            rowsPerStrip = height;\n\n        int   colorspace = channels > 1 ? PHOTOMETRIC_RGB : PHOTOMETRIC_MINISBLACK;\n\n        if (!TIFFSetField(pTiffHandle, TIFFTAG_IMAGEWIDTH, width)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_IMAGELENGTH, height)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_BITSPERSAMPLE, bitsPerChannel)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_COMPRESSION, compression)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_PHOTOMETRIC, colorspace)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_SAMPLESPERPIXEL, channels)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_ROWSPERSTRIP, rowsPerStrip)\n            || (img_vec.size() > 1 && (\n               !TIFFSetField(pTiffHandle, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_PAGENUMBER, page, img_vec.size() )))\n            )\n        {\n            TIFFClose(pTiffHandle);\n            return false;\n        }\n\n        if (compression != COMPRESSION_NONE && !TIFFSetField(pTiffHandle, TIFFTAG_PREDICTOR, predictor))\n        {\n            TIFFClose(pTiffHandle);\n            return false;\n        }\n\n        // row buffer, because TIFFWriteScanline modifies the original data!\n        size_t scanlineSize = TIFFScanlineSize(pTiffHandle);\n        AutoBuffer<uchar> _buffer(scanlineSize + 32);\n        uchar* buffer = _buffer;\n        if (!buffer)\n        {\n            TIFFClose(pTiffHandle);\n            return false;\n        }\n\n        for (int y = 0; y < height; ++y)\n        {\n            switch (channels)\n            {\n                case 1:\n                {\n                    memcpy(buffer, img.ptr(y), scanlineSize);\n                    break;\n                }\n\n                case 3:\n                {\n                    if (depth == CV_8U)\n                        icvCvt_BGR2RGB_8u_C3R( img.ptr(y), 0, buffer, 0, cvSize(width, 1));\n                    else\n                        icvCvt_BGR2RGB_16u_C3R( img.ptr<ushort>(y), 0, (ushort*)buffer, 0, cvSize(width, 1));\n                    break;\n                }\n\n                case 4:\n                {\n                    if (depth == CV_8U)\n                        icvCvt_BGRA2RGBA_8u_C4R( img.ptr(y), 0, buffer, 0, cvSize(width, 1));\n                    else\n                        icvCvt_BGRA2RGBA_16u_C4R( img.ptr<ushort>(y), 0, (ushort*)buffer, 0, cvSize(width, 1));\n                    break;\n                }\n\n                default:\n                {\n                    TIFFClose(pTiffHandle);\n                    return false;\n                }\n            }\n\n            int writeResult = TIFFWriteScanline(pTiffHandle, buffer, y, 0);\n            if (writeResult != 1)\n            {\n                TIFFClose(pTiffHandle);\n                return false;\n            }\n        }\n\n        TIFFWriteDirectory(pTiffHandle);\n\n    }\n\n    TIFFClose(pTiffHandle);\n    return true;\n}\n\nbool TiffEncoder::write_32FC3(const Mat& _img)\n{\n    Mat img;\n    cvtColor(_img, img, COLOR_BGR2XYZ);\n\n    TIFF* tif;\n\n    TiffEncoderBufHelper buf_helper(m_buf);\n    if ( m_buf )\n    {\n        tif = buf_helper.open();\n    }\n    else\n    {\n        tif = TIFFOpen(m_filename.c_str(), \"w\");\n    }\n\n    if (!tif)\n    {\n        return false;\n    }\n    TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, img.cols);\n    TIFFSetField(tif, TIFFTAG_IMAGELENGTH, img.rows);\n    TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 3);\n    TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_SGILOG);\n    TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_LOGLUV);\n    TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    TIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_FLOAT);\n    TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, 1);\n    int strip_size = 3 * img.cols;\n    float *ptr = const_cast<float*>(img.ptr<float>());\n    for (int i = 0; i < img.rows; i++, ptr += strip_size)\n    {\n        TIFFWriteEncodedStrip(tif, i, ptr, strip_size * sizeof(float));\n    }\n    TIFFClose(tif);\n    return true;\n}\n\nbool TiffEncoder::write_32FC1(const Mat& _img)\n{\n\n    TIFF* tif;\n\n    TiffEncoderBufHelper buf_helper(m_buf);\n    if ( m_buf )\n    {\n        tif = buf_helper.open();\n    }\n    else\n    {\n        tif = TIFFOpen(m_filename.c_str(), \"w\");\n    }\n\n    if (!tif)\n    {\n        return false;\n    }\n\n    TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, _img.cols);\n    TIFFSetField(tif, TIFFTAG_IMAGELENGTH, _img.rows);\n    TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 1);\n    TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 32);\n    TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n    TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);\n    TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n    for (uint32 row = 0; row < (uint32)_img.rows; row++)\n    {\n        if (TIFFWriteScanline(tif, (tdata_t)_img.ptr<float>(row), row, 1) != 1)\n        {\n            TIFFClose(tif);\n            return false;\n        }\n    }\n    TIFFWriteDirectory(tif);\n    TIFFClose(tif);\n\n    return true;\n}\n\nbool TiffEncoder::writemulti(const std::vector<Mat>& img_vec, const std::vector<int>& params)\n{\n    return writeLibTiff(img_vec, params);\n}\n\nbool  TiffEncoder::write( const Mat& img, const std::vector<int>& params)\n{\n    int depth = img.depth();\n\n    if(img.type() == CV_32FC3)\n    {\n        return write_32FC3(img);\n    }\n    if(img.type() == CV_32FC1)\n    {\n        return write_32FC1(img);\n    }\n\n    CV_Assert(depth == CV_8U || depth == CV_16U);\n\n    std::vector<Mat> img_vec;\n    img_vec.push_back(img);\n    return writeLibTiff(img_vec, params);\n}\n\n} // namespace\n\n#endif\n",
                "name": "grfmt_tiff.cpp",
                "path": "opencv/modules/imgcodecs/src/grfmt_tiff.cpp",
                "url": "/github.com/ganwenyao/opencv_js/-/blob/opencv/modules/imgcodecs/src/grfmt_tiff.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 388,
                    "offsetAndLengths": [
                        [
                            37,
                            16
                        ]
                    ],
                    "preview": "                                ok = TIFFReadRGBATile( tif, x, y, (uint32*)buffer );"
                }
            ],
            "repository": {
                "name": "github.com/ganwenyao/opencv_js",
                "url": "/github.com/ganwenyao/opencv_js"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "3a32119b39091212fc57242b64dcc6292e0a7212"
                },
                "content": "/*M///////////////////////////////////////////////////////////////////////////////////////\n//\n//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.\n//\n//  By downloading, copying, installing or using the software you agree to this license.\n//  If you do not agree to this license, do not download, install,\n//  copy or use the software.\n//\n//\n//                           License Agreement\n//                For Open Source Computer Vision Library\n//\n// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.\n// Copyright (C) 2009, Willow Garage Inc., all rights reserved.\n// Third party copyrights are property of their respective owners.\n//\n// Redistribution and use in source and binary forms, with or without modification,\n// are permitted provided that the following conditions are met:\n//\n//   * Redistribution's of source code must retain the above copyright notice,\n//     this list of conditions and the following disclaimer.\n//\n//   * Redistribution's in binary form must reproduce the above copyright notice,\n//     this list of conditions and the following disclaimer in the documentation\n//     and/or other materials provided with the distribution.\n//\n//   * The name of the copyright holders may not be used to endorse or promote products\n//     derived from this software without specific prior written permission.\n//\n// This software is provided by the copyright holders and contributors \"as is\" and\n// any express or implied warranties, including, but not limited to, the implied\n// warranties of merchantability and fitness for a particular purpose are disclaimed.\n// In no event shall the Intel Corporation or contributors be liable for any direct,\n// indirect, incidental, special, exemplary, or consequential damages\n// (including, but not limited to, procurement of substitute goods or services;\n// loss of use, data, or profits; or business interruption) however caused\n// and on any theory of liability, whether in contract, strict liability,\n// or tort (including negligence or otherwise) arising in any way out of\n// the use of this software, even if advised of the possibility of such damage.\n//\n//M*/\n\n/****************************************************************************************\\\n    A part of the file implements TIFF reader on base of libtiff library\n    (see otherlibs/_graphics/readme.txt for copyright notice)\n\\****************************************************************************************/\n\n#include \"precomp.hpp\"\n\n#ifdef HAVE_TIFF\n#include \"grfmt_tiff.hpp\"\n#include <limits>\n\n// TODO FIXIT Conflict declarations for common types like int64/uint64\nnamespace tiff_dummy_namespace {\n#include \"tiff.h\"\n#include \"tiffio.h\"\n}\nusing namespace tiff_dummy_namespace;\n\nnamespace cv\n{\n\n\nstatic const char fmtSignTiffII[] = \"II\\x2a\\x00\";\nstatic const char fmtSignTiffMM[] = \"MM\\x00\\x2a\";\n\nstatic int grfmt_tiff_err_handler_init = 0;\nstatic void GrFmtSilentTIFFErrorHandler( const char*, const char*, va_list ) {}\n\nTiffDecoder::TiffDecoder()\n{\n    m_tif = 0;\n    if( !grfmt_tiff_err_handler_init )\n    {\n        grfmt_tiff_err_handler_init = 1;\n\n        TIFFSetErrorHandler( GrFmtSilentTIFFErrorHandler );\n        TIFFSetWarningHandler( GrFmtSilentTIFFErrorHandler );\n    }\n    m_hdr = false;\n    m_buf_supported = true;\n    m_buf_pos = 0;\n}\n\n\nvoid TiffDecoder::close()\n{\n    if( m_tif )\n    {\n        TIFF* tif = (TIFF*)m_tif;\n        TIFFClose( tif );\n        m_tif = 0;\n    }\n}\n\nTiffDecoder::~TiffDecoder()\n{\n    close();\n}\n\nsize_t TiffDecoder::signatureLength() const\n{\n    return 4;\n}\n\nbool TiffDecoder::checkSignature( const String& signature ) const\n{\n    return signature.size() >= 4 &&\n        (memcmp(signature.c_str(), fmtSignTiffII, 4) == 0 ||\n        memcmp(signature.c_str(), fmtSignTiffMM, 4) == 0);\n}\n\nint TiffDecoder::normalizeChannelsNumber(int channels) const\n{\n    return channels > 4 ? 4 : channels;\n}\n\nImageDecoder TiffDecoder::newDecoder() const\n{\n    return makePtr<TiffDecoder>();\n}\n\nclass TiffDecoderBufHelper\n{\n    Mat& m_buf;\n    size_t& m_buf_pos;\npublic:\n    TiffDecoderBufHelper(Mat& buf, size_t& buf_pos) :\n        m_buf(buf), m_buf_pos(buf_pos)\n    {}\n    static tmsize_t read( thandle_t handle, void* buffer, tmsize_t n )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        const Mat& buf = helper->m_buf;\n        const tmsize_t size = buf.cols*buf.rows*buf.elemSize();\n        tmsize_t pos = helper->m_buf_pos;\n        if ( n > (size - pos) )\n        {\n            n = size - pos;\n        }\n        memcpy(buffer, buf.ptr() + pos, n);\n        helper->m_buf_pos += n;\n        return n;\n    }\n\n    static tmsize_t write( thandle_t /*handle*/, void* /*buffer*/, tmsize_t /*n*/ )\n    {\n        // Not used for decoding.\n        return 0;\n    }\n\n    static toff_t seek( thandle_t handle, toff_t offset, int whence )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        const Mat& buf = helper->m_buf;\n        const toff_t size = buf.cols*buf.rows*buf.elemSize();\n        toff_t new_pos = helper->m_buf_pos;\n        switch (whence)\n        {\n            case SEEK_SET:\n                new_pos = offset;\n                break;\n            case SEEK_CUR:\n                new_pos += offset;\n                break;\n            case SEEK_END:\n                new_pos = size + offset;\n                break;\n        }\n        new_pos = std::min(new_pos, size);\n        helper->m_buf_pos = (size_t)new_pos;\n        return new_pos;\n    }\n\n    static int map( thandle_t handle, void** base, toff_t* size )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        Mat& buf = helper->m_buf;\n        *base = buf.ptr();\n        *size = buf.cols*buf.rows*buf.elemSize();\n        return 0;\n    }\n\n    static toff_t size( thandle_t handle )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        const Mat& buf = helper->m_buf;\n        return buf.cols*buf.rows*buf.elemSize();\n    }\n\n    static int close( thandle_t handle )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        delete helper;\n        return 0;\n    }\n};\n\nbool TiffDecoder::readHeader()\n{\n    bool result = false;\n\n    TIFF* tif = static_cast<TIFF*>(m_tif);\n    if (!m_tif)\n    {\n        // TIFFOpen() mode flags are different to fopen().  A 'b' in mode \"rb\" has no effect when reading.\n        // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n        if ( !m_buf.empty() )\n        {\n            m_buf_pos = 0;\n            TiffDecoderBufHelper* buf_helper = new TiffDecoderBufHelper(this->m_buf, this->m_buf_pos);\n            tif = TIFFClientOpen( \"\", \"r\", reinterpret_cast<thandle_t>(buf_helper), &TiffDecoderBufHelper::read,\n                                  &TiffDecoderBufHelper::write, &TiffDecoderBufHelper::seek,\n                                  &TiffDecoderBufHelper::close, &TiffDecoderBufHelper::size,\n                                  &TiffDecoderBufHelper::map, /*unmap=*/0 );\n        }\n        else\n        {\n            tif = TIFFOpen(m_filename.c_str(), \"r\");\n        }\n    }\n\n    if( tif )\n    {\n        uint32 wdth = 0, hght = 0;\n        uint16 photometric = 0;\n        m_tif = tif;\n\n        if( TIFFGetField( tif, TIFFTAG_IMAGEWIDTH, &wdth ) &&\n            TIFFGetField( tif, TIFFTAG_IMAGELENGTH, &hght ) &&\n            TIFFGetField( tif, TIFFTAG_PHOTOMETRIC, &photometric ))\n        {\n            uint16 bpp=8, ncn = photometric > 1 ? 3 : 1;\n            TIFFGetField( tif, TIFFTAG_BITSPERSAMPLE, &bpp );\n            TIFFGetField( tif, TIFFTAG_SAMPLESPERPIXEL, &ncn );\n\n            m_width = wdth;\n            m_height = hght;\n            if((bpp == 32 && ncn == 3) || photometric == PHOTOMETRIC_LOGLUV)\n            {\n                m_type = CV_32FC3;\n                m_hdr = true;\n                return true;\n            }\n            m_hdr = false;\n\n            if( bpp > 8 &&\n               ((photometric > 2) ||\n                (ncn != 1 && ncn != 3 && ncn != 4)))\n                bpp = 8;\n\n            int wanted_channels = normalizeChannelsNumber(ncn);\n            switch(bpp)\n            {\n                case 8:\n                    m_type = CV_MAKETYPE(CV_8U, photometric > 1 ? wanted_channels : 1);\n                    break;\n                case 16:\n                    m_type = CV_MAKETYPE(CV_16U, photometric > 1 ? wanted_channels : 1);\n                    break;\n\n                case 32:\n                    m_type = CV_MAKETYPE(CV_32F, photometric > 1 ? 3 : 1);\n                    break;\n                case 64:\n                    m_type = CV_MAKETYPE(CV_64F, photometric > 1 ? 3 : 1);\n                    break;\n\n                default:\n                    result = false;\n            }\n            result = true;\n        }\n    }\n\n    if( !result )\n        close();\n\n    return result;\n}\n\nbool TiffDecoder::nextPage()\n{\n    // Prepare the next page, if any.\n    return m_tif &&\n           TIFFReadDirectory(static_cast<TIFF*>(m_tif)) &&\n           readHeader();\n}\n\nbool  TiffDecoder::readData( Mat& img )\n{\n    if(m_hdr && img.type() == CV_32FC3)\n    {\n        return readHdrData(img);\n    }\n    bool result = false;\n    bool color = img.channels() > 1;\n    uchar* data = img.ptr();\n\n    if( img.depth() != CV_8U && img.depth() != CV_16U && img.depth() != CV_32F && img.depth() != CV_64F )\n        return false;\n\n    if( m_tif && m_width && m_height )\n    {\n        TIFF* tif = (TIFF*)m_tif;\n        uint32 tile_width0 = m_width, tile_height0 = 0;\n        int x, y, i;\n        int is_tiled = TIFFIsTiled(tif);\n        uint16 photometric;\n        TIFFGetField( tif, TIFFTAG_PHOTOMETRIC, &photometric );\n        uint16 bpp = 8, ncn = photometric > 1 ? 3 : 1;\n        TIFFGetField( tif, TIFFTAG_BITSPERSAMPLE, &bpp );\n        TIFFGetField( tif, TIFFTAG_SAMPLESPERPIXEL, &ncn );\n        const int bitsPerByte = 8;\n        int dst_bpp = (int)(img.elemSize1() * bitsPerByte);\n        int wanted_channels = normalizeChannelsNumber(img.channels());\n\n        if(dst_bpp == 8)\n        {\n            char errmsg[1024];\n            if(!TIFFRGBAImageOK( tif, errmsg ))\n            {\n                close();\n                return false;\n            }\n        }\n\n        if( (!is_tiled) ||\n            (is_tiled &&\n            TIFFGetField( tif, TIFFTAG_TILEWIDTH, &tile_width0 ) &&\n            TIFFGetField( tif, TIFFTAG_TILELENGTH, &tile_height0 )))\n        {\n            if(!is_tiled)\n                TIFFGetField( tif, TIFFTAG_ROWSPERSTRIP, &tile_height0 );\n\n            if( tile_width0 <= 0 )\n                tile_width0 = m_width;\n\n            if( tile_height0 <= 0 ||\n               (!is_tiled && tile_height0 == std::numeric_limits<uint32>::max()) )\n                tile_height0 = m_height;\n\n            if(dst_bpp == 8) {\n                // we will use TIFFReadRGBA* functions, so allocate temporary buffer for 32bit RGBA\n                bpp = 8;\n                ncn = 4;\n            }\n            const size_t buffer_size = (bpp/bitsPerByte) * ncn * tile_height0 * tile_width0;\n            AutoBuffer<uchar> _buffer( buffer_size );\n            uchar* buffer = _buffer;\n            ushort* buffer16 = (ushort*)buffer;\n            float* buffer32 = (float*)buffer;\n            double* buffer64 = (double*)buffer;\n            int tileidx = 0;\n\n            for( y = 0; y < m_height; y += tile_height0, data += img.step*tile_height0 )\n            {\n                int tile_height = tile_height0;\n\n                if( y + tile_height > m_height )\n                    tile_height = m_height - y;\n\n                for( x = 0; x < m_width; x += tile_width0, tileidx++ )\n                {\n                    int tile_width = tile_width0, ok;\n\n                    if( x + tile_width > m_width )\n                        tile_width = m_width - x;\n\n                    switch(dst_bpp)\n                    {\n                        case 8:\n                        {\n                            uchar * bstart = buffer;\n                            if( !is_tiled )\n                                ok = TIFFReadRGBAStrip( tif, y, (uint32*)buffer );\n                            else\n                            {\n                                ok = TIFFReadRGBATile( tif, x, y, (uint32*)buffer );\n                                //Tiles fill the buffer from the bottom up\n                                bstart += (tile_height0 - tile_height) * tile_width0 * 4;\n                            }\n                            if( !ok )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                                if( color )\n                                {\n                                    if (wanted_channels == 4)\n                                    {\n                                        icvCvt_BGRA2RGBA_8u_C4R( bstart + i*tile_width0*4, 0,\n                                                             data + x*4 + img.step*(tile_height - i - 1), 0,\n                                                             cvSize(tile_width,1) );\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2BGR_8u_C4C3R( bstart + i*tile_width0*4, 0,\n                                                             data + x*3 + img.step*(tile_height - i - 1), 0,\n                                                             cvSize(tile_width,1), 2 );\n                                    }\n                                }\n                                else\n                                    icvCvt_BGRA2Gray_8u_C4C1R( bstart + i*tile_width0*4, 0,\n                                                              data + x + img.step*(tile_height - i - 1), 0,\n                                                              cvSize(tile_width,1), 2 );\n                            break;\n                        }\n\n                        case 16:\n                        {\n                            if( !is_tiled )\n                                ok = (int)TIFFReadEncodedStrip( tif, tileidx, (uint32*)buffer, buffer_size ) >= 0;\n                            else\n                                ok = (int)TIFFReadEncodedTile( tif, tileidx, (uint32*)buffer, buffer_size ) >= 0;\n\n                            if( !ok )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                            {\n                                if( color )\n                                {\n                                    if( ncn == 1 )\n                                    {\n                                        icvCvt_Gray2BGR_16u_C1C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                                  (ushort*)(data + img.step*i) + x*3, 0,\n                                                                  cvSize(tile_width,1) );\n                                    }\n                                    else if( ncn == 3 )\n                                    {\n                                        icvCvt_RGB2BGR_16u_C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                               (ushort*)(data + img.step*i) + x*3, 0,\n                                                               cvSize(tile_width,1) );\n                                    }\n                                    else if (ncn == 4)\n                                    {\n                                        if (wanted_channels == 4)\n                                        {\n                                            icvCvt_BGRA2RGBA_16u_C4R(buffer16 + i*tile_width0*ncn, 0,\n                                                (ushort*)(data + img.step*i) + x * 4, 0,\n                                                cvSize(tile_width, 1));\n                                        }\n                                        else\n                                        {\n                                            icvCvt_BGRA2BGR_16u_C4C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                (ushort*)(data + img.step*i) + x * 3, 0,\n                                                cvSize(tile_width, 1), 2);\n                                        }\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2BGR_16u_C4C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                               (ushort*)(data + img.step*i) + x*3, 0,\n                                                               cvSize(tile_width,1), 2 );\n                                    }\n                                }\n                                else\n                                {\n                                    if( ncn == 1 )\n                                    {\n                                        memcpy((ushort*)(data + img.step*i)+x,\n                                               buffer16 + i*tile_width0*ncn,\n                                               tile_width*sizeof(buffer16[0]));\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2Gray_16u_CnC1R(buffer16 + i*tile_width0*ncn, 0,\n                                                               (ushort*)(data + img.step*i) + x, 0,\n                                                               cvSize(tile_width,1), ncn, 2 );\n                                    }\n                                }\n                            }\n                            break;\n                        }\n\n                        case 32:\n                        case 64:\n                        {\n                            if( !is_tiled )\n                                ok = (int)TIFFReadEncodedStrip( tif, tileidx, buffer, buffer_size ) >= 0;\n                            else\n                                ok = (int)TIFFReadEncodedTile( tif, tileidx, buffer, buffer_size ) >= 0;\n\n                            if( !ok || ncn != 1 )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                            {\n                                if(dst_bpp == 32)\n                                {\n                                    memcpy((float*)(data + img.step*i)+x,\n                                           buffer32 + i*tile_width0*ncn,\n                                           tile_width*sizeof(buffer32[0]));\n                                }\n                                else\n                                {\n                                    memcpy((double*)(data + img.step*i)+x,\n                                         buffer64 + i*tile_width0*ncn,\n                                         tile_width*sizeof(buffer64[0]));\n                                }\n                            }\n\n                            break;\n                        }\n                        default:\n                        {\n                            close();\n                            return false;\n                        }\n                    }\n                }\n            }\n\n            result = true;\n        }\n    }\n\n    return result;\n}\n\nbool TiffDecoder::readHdrData(Mat& img)\n{\n    int rows_per_strip = 0, photometric = 0;\n    if(!m_tif)\n    {\n        return false;\n    }\n    TIFF *tif = static_cast<TIFF*>(m_tif);\n    TIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &rows_per_strip);\n    TIFFGetField( tif, TIFFTAG_PHOTOMETRIC, &photometric );\n    TIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_FLOAT);\n    int size = 3 * m_width * m_height * sizeof (float);\n    tstrip_t strip_size = 3 * m_width * rows_per_strip;\n    float *ptr = img.ptr<float>();\n    for (tstrip_t i = 0; i < TIFFNumberOfStrips(tif); i++, ptr += strip_size)\n    {\n        TIFFReadEncodedStrip(tif, i, ptr, size);\n        size -= strip_size * sizeof(float);\n    }\n    close();\n    if(photometric == PHOTOMETRIC_LOGLUV)\n    {\n        cvtColor(img, img, COLOR_XYZ2BGR);\n    }\n    else\n    {\n        cvtColor(img, img, COLOR_RGB2BGR);\n    }\n    return true;\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////\n\nTiffEncoder::TiffEncoder()\n{\n    m_description = \"TIFF Files (*.tiff;*.tif)\";\n    m_buf_supported = true;\n}\n\nTiffEncoder::~TiffEncoder()\n{\n}\n\nImageEncoder TiffEncoder::newEncoder() const\n{\n    return makePtr<TiffEncoder>();\n}\n\nbool TiffEncoder::isFormatSupported( int depth ) const\n{\n    return depth == CV_8U || depth == CV_16U || depth == CV_32F;\n}\n\nvoid  TiffEncoder::writeTag( WLByteStream& strm, TiffTag tag,\n                             TiffFieldType fieldType,\n                             int count, int value )\n{\n    strm.putWord( tag );\n    strm.putWord( fieldType );\n    strm.putDWord( count );\n    strm.putDWord( value );\n}\n\nclass TiffEncoderBufHelper\n{\npublic:\n\n    TiffEncoderBufHelper(std::vector<uchar> *buf)\n            : m_buf(buf), m_buf_pos(0)\n    {}\n\n    TIFF* open ()\n    {\n        return TIFFClientOpen( \"\", \"w\", reinterpret_cast<thandle_t>(this), &TiffEncoderBufHelper::read,\n                               &TiffEncoderBufHelper::write, &TiffEncoderBufHelper::seek,\n                               &TiffEncoderBufHelper::close, &TiffEncoderBufHelper::size,\n                               /*map=*/0, /*unmap=*/0 );\n    }\n\n    static tmsize_t read( thandle_t /*handle*/, void* /*buffer*/, tmsize_t /*n*/ )\n    {\n        // Not used for encoding.\n        return 0;\n    }\n\n    static tmsize_t write( thandle_t handle, void* buffer, tmsize_t n )\n    {\n        TiffEncoderBufHelper *helper = reinterpret_cast<TiffEncoderBufHelper*>(handle);\n        size_t begin = (size_t)helper->m_buf_pos;\n        size_t end = begin + n;\n        if ( helper->m_buf->size() < end )\n        {\n            helper->m_buf->resize(end);\n        }\n        memcpy(&(*helper->m_buf)[begin], buffer, n);\n        helper->m_buf_pos = end;\n        return n;\n    }\n\n    static toff_t seek( thandle_t handle, toff_t offset, int whence )\n    {\n        TiffEncoderBufHelper *helper = reinterpret_cast<TiffEncoderBufHelper*>(handle);\n        const toff_t size = helper->m_buf->size();\n        toff_t new_pos = helper->m_buf_pos;\n        switch (whence)\n        {\n            case SEEK_SET:\n                new_pos = offset;\n                break;\n            case SEEK_CUR:\n                new_pos += offset;\n                break;\n            case SEEK_END:\n                new_pos = size + offset;\n                break;\n        }\n        helper->m_buf_pos = new_pos;\n        return new_pos;\n    }\n\n    static toff_t size( thandle_t handle )\n    {\n        TiffEncoderBufHelper *helper = reinterpret_cast<TiffEncoderBufHelper*>(handle);\n        return helper->m_buf->size();\n    }\n\n    static int close( thandle_t /*handle*/ )\n    {\n        // Do nothing.\n        return 0;\n    }\n\nprivate:\n\n    std::vector<uchar>* m_buf;\n    toff_t m_buf_pos;\n};\n\nstatic void readParam(const std::vector<int>& params, int key, int& value)\n{\n    for(size_t i = 0; i + 1 < params.size(); i += 2)\n        if(params[i] == key)\n        {\n            value = params[i+1];\n            break;\n        }\n}\n\nbool  TiffEncoder::writeLibTiff( const Mat& img, const std::vector<int>& params)\n{\n    int channels = img.channels();\n    int width = img.cols, height = img.rows;\n    int depth = img.depth();\n\n    int bitsPerChannel = -1;\n    switch (depth)\n    {\n        case CV_8U:\n        {\n            bitsPerChannel = 8;\n            break;\n        }\n        case CV_16U:\n        {\n            bitsPerChannel = 16;\n            break;\n        }\n        default:\n        {\n            return false;\n        }\n    }\n\n    const int bitsPerByte = 8;\n    size_t fileStep = (width * channels * bitsPerChannel) / bitsPerByte;\n\n    int rowsPerStrip = (int)((1 << 13)/fileStep);\n    readParam(params, TIFFTAG_ROWSPERSTRIP, rowsPerStrip);\n\n    if( rowsPerStrip < 1 )\n        rowsPerStrip = 1;\n\n    if( rowsPerStrip > height )\n        rowsPerStrip = height;\n\n\n    // do NOT put \"wb\" as the mode, because the b means \"big endian\" mode, not \"binary\" mode.\n    // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n    TIFF* pTiffHandle;\n\n    TiffEncoderBufHelper buf_helper(m_buf);\n    if ( m_buf )\n    {\n        pTiffHandle = buf_helper.open();\n    }\n    else\n    {\n        pTiffHandle = TIFFOpen(m_filename.c_str(), \"w\");\n    }\n    if (!pTiffHandle)\n    {\n        return false;\n    }\n\n    // defaults for now, maybe base them on params in the future\n    int   compression  = COMPRESSION_LZW;\n    int   predictor    = PREDICTOR_HORIZONTAL;\n\n    readParam(params, TIFFTAG_COMPRESSION, compression);\n    readParam(params, TIFFTAG_PREDICTOR, predictor);\n\n    int   colorspace = channels > 1 ? PHOTOMETRIC_RGB : PHOTOMETRIC_MINISBLACK;\n\n    if ( !TIFFSetField(pTiffHandle, TIFFTAG_IMAGEWIDTH, width)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_IMAGELENGTH, height)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_BITSPERSAMPLE, bitsPerChannel)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_COMPRESSION, compression)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_PHOTOMETRIC, colorspace)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_SAMPLESPERPIXEL, channels)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_ROWSPERSTRIP, rowsPerStrip)\n       )\n    {\n        TIFFClose(pTiffHandle);\n        return false;\n    }\n\n    if (compression != COMPRESSION_NONE && !TIFFSetField(pTiffHandle, TIFFTAG_PREDICTOR, predictor) )\n    {\n        TIFFClose(pTiffHandle);\n        return false;\n    }\n\n    // row buffer, because TIFFWriteScanline modifies the original data!\n    size_t scanlineSize = TIFFScanlineSize(pTiffHandle);\n    AutoBuffer<uchar> _buffer(scanlineSize+32);\n    uchar* buffer = _buffer;\n    if (!buffer)\n    {\n        TIFFClose(pTiffHandle);\n        return false;\n    }\n\n    for (int y = 0; y < height; ++y)\n    {\n        switch(channels)\n        {\n            case 1:\n            {\n                memcpy(buffer, img.ptr(y), scanlineSize);\n                break;\n            }\n\n            case 3:\n            {\n                if (depth == CV_8U)\n                    icvCvt_BGR2RGB_8u_C3R( img.ptr(y), 0, buffer, 0, cvSize(width,1) );\n                else\n                    icvCvt_BGR2RGB_16u_C3R( img.ptr<ushort>(y), 0, (ushort*)buffer, 0, cvSize(width,1) );\n                break;\n            }\n\n            case 4:\n            {\n                if (depth == CV_8U)\n                    icvCvt_BGRA2RGBA_8u_C4R( img.ptr(y), 0, buffer, 0, cvSize(width,1) );\n                else\n                    icvCvt_BGRA2RGBA_16u_C4R( img.ptr<ushort>(y), 0, (ushort*)buffer, 0, cvSize(width,1) );\n                break;\n            }\n\n            default:\n            {\n                TIFFClose(pTiffHandle);\n                return false;\n            }\n        }\n\n        int writeResult = TIFFWriteScanline(pTiffHandle, buffer, y, 0);\n        if (writeResult != 1)\n        {\n            TIFFClose(pTiffHandle);\n            return false;\n        }\n    }\n\n    TIFFClose(pTiffHandle);\n    return true;\n}\n\nbool TiffEncoder::writeHdr(const Mat& _img)\n{\n    Mat img;\n    cvtColor(_img, img, COLOR_BGR2XYZ);\n\n    TIFF* tif;\n\n    TiffEncoderBufHelper buf_helper(m_buf);\n    if ( m_buf )\n    {\n        tif = buf_helper.open();\n    }\n    else\n    {\n        tif = TIFFOpen(m_filename.c_str(), \"w\");\n    }\n\n    if (!tif)\n    {\n        return false;\n    }\n    TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, img.cols);\n    TIFFSetField(tif, TIFFTAG_IMAGELENGTH, img.rows);\n    TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 3);\n    TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_SGILOG);\n    TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_LOGLUV);\n    TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    TIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_FLOAT);\n    TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, 1);\n    int strip_size = 3 * img.cols;\n    float *ptr = const_cast<float*>(img.ptr<float>());\n    for (int i = 0; i < img.rows; i++, ptr += strip_size)\n    {\n        TIFFWriteEncodedStrip(tif, i, ptr, strip_size * sizeof(float));\n    }\n    TIFFClose(tif);\n    return true;\n}\n\nbool  TiffEncoder::write( const Mat& img, const std::vector<int>& params)\n{\n    int depth = img.depth();\n\n    if(img.type() == CV_32FC3)\n    {\n        return writeHdr(img); // TODO Rename\n    }\n\n    CV_Assert(depth == CV_8U || depth == CV_16U);\n\n    return writeLibTiff(img, params);\n}\n\n} // namespace\n\n#endif\n",
                "name": "grfmt_tiff.cpp",
                "path": "sources/modules/imgcodecs/src/grfmt_tiff.cpp",
                "url": "/github.com/ultravideo/video-stitcher/-/blob/sources/modules/imgcodecs/src/grfmt_tiff.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 379,
                    "offsetAndLengths": [
                        [
                            37,
                            16
                        ]
                    ],
                    "preview": "                                ok = TIFFReadRGBATile( tif, x, y, (uint32*)buffer );"
                }
            ],
            "repository": {
                "name": "github.com/ultravideo/video-stitcher",
                "url": "/github.com/ultravideo/video-stitcher"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "f1067c2dd9ede2f87c0c10528d3e1b8f5ea38d7e"
                },
                "content": "/*M///////////////////////////////////////////////////////////////////////////////////////\n//\n//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.\n//\n//  By downloading, copying, installing or using the software you agree to this license.\n//  If you do not agree to this license, do not download, install,\n//  copy or use the software.\n//\n//\n//                           License Agreement\n//                For Open Source Computer Vision Library\n//\n// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.\n// Copyright (C) 2009, Willow Garage Inc., all rights reserved.\n// Third party copyrights are property of their respective owners.\n//\n// Redistribution and use in source and binary forms, with or without modification,\n// are permitted provided that the following conditions are met:\n//\n//   * Redistribution's of source code must retain the above copyright notice,\n//     this list of conditions and the following disclaimer.\n//\n//   * Redistribution's in binary form must reproduce the above copyright notice,\n//     this list of conditions and the following disclaimer in the documentation\n//     and/or other materials provided with the distribution.\n//\n//   * The name of the copyright holders may not be used to endorse or promote products\n//     derived from this software without specific prior written permission.\n//\n// This software is provided by the copyright holders and contributors \"as is\" and\n// any express or implied warranties, including, but not limited to, the implied\n// warranties of merchantability and fitness for a particular purpose are disclaimed.\n// In no event shall the Intel Corporation or contributors be liable for any direct,\n// indirect, incidental, special, exemplary, or consequential damages\n// (including, but not limited to, procurement of substitute goods or services;\n// loss of use, data, or profits; or business interruption) however caused\n// and on any theory of liability, whether in contract, strict liability,\n// or tort (including negligence or otherwise) arising in any way out of\n// the use of this software, even if advised of the possibility of such damage.\n//\n//M*/\n\n/****************************************************************************************\\\n    A part of the file implements TIFF reader on base of libtiff library\n    (see otherlibs/_graphics/readme.txt for copyright notice)\n\\****************************************************************************************/\n\n#include \"precomp.hpp\"\n#include \"grfmt_tiff.hpp\"\n\nnamespace cv\n{\nstatic const char fmtSignTiffII[] = \"II\\x2a\\x00\";\nstatic const char fmtSignTiffMM[] = \"MM\\x00\\x2a\";\n\n#ifdef HAVE_TIFF\n\n#include \"tiff.h\"\n#include \"tiffio.h\"\n\nstatic int grfmt_tiff_err_handler_init = 0;\nstatic void GrFmtSilentTIFFErrorHandler( const char*, const char*, va_list ) {}\n\nTiffDecoder::TiffDecoder()\n{\n    m_tif = 0;\n    if( !grfmt_tiff_err_handler_init )\n    {\n        grfmt_tiff_err_handler_init = 1;\n\n        TIFFSetErrorHandler( GrFmtSilentTIFFErrorHandler );\n        TIFFSetWarningHandler( GrFmtSilentTIFFErrorHandler );\n    }\n}\n\n\nvoid TiffDecoder::close()\n{\n    if( m_tif )\n    {\n        TIFF* tif = (TIFF*)m_tif;\n        TIFFClose( tif );\n        m_tif = 0;\n    }\n}\n\nTiffDecoder::~TiffDecoder()\n{\n    close();\n}\n\nsize_t TiffDecoder::signatureLength() const\n{\n    return 4;\n}\n\nbool TiffDecoder::checkSignature( const string& signature ) const\n{\n    return signature.size() >= 4 &&\n        (memcmp(signature.c_str(), fmtSignTiffII, 4) == 0 ||\n        memcmp(signature.c_str(), fmtSignTiffMM, 4) == 0);\n}\n\nImageDecoder TiffDecoder::newDecoder() const\n{\n    return new TiffDecoder;\n}\n\nbool TiffDecoder::readHeader()\n{\n    bool result = false;\n\n    close();\n    // TIFFOpen() mode flags are different to fopen().  A 'b' in mode \"rb\" has no effect when reading.\n    // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n    TIFF* tif = TIFFOpen( m_filename.c_str(), \"r\" );\n\n    if( tif )\n    {\n        uint32 wdth = 0, hght = 0;\n        uint16 photometric = 0;\n        m_tif = tif;\n\n        if( TIFFGetField( tif, TIFFTAG_IMAGEWIDTH, &wdth ) &&\n            TIFFGetField( tif, TIFFTAG_IMAGELENGTH, &hght ) &&\n            TIFFGetField( tif, TIFFTAG_PHOTOMETRIC, &photometric ))\n        {\n            uint16 bpp=8, ncn = photometric > 1 ? 3 : 1;\n            TIFFGetField( tif, TIFFTAG_BITSPERSAMPLE, &bpp );\n            TIFFGetField( tif, TIFFTAG_SAMPLESPERPIXEL, &ncn );\n\n            m_width = wdth;\n            m_height = hght;\n            if( bpp > 8 &&\n               ((photometric != 2 && photometric != 1) ||\n                (ncn != 1 && ncn != 3 && ncn != 4)))\n                bpp = 8;\n\n            switch(bpp)\n            {\n                case 8:\n                    m_type = CV_MAKETYPE(CV_8U, photometric > 1 ? 3 : 1);\n                    break;\n                case 16:\n                    m_type = CV_MAKETYPE(CV_16U, photometric > 1 ? 3 : 1);\n                    break;\n\n                case 32:\n                    m_type = CV_MAKETYPE(CV_32F, photometric > 1 ? 3 : 1);\n                    break;\n                case 64:\n                    m_type = CV_MAKETYPE(CV_64F, photometric > 1 ? 3 : 1);\n                    break;\n\n                default:\n                    result = false;\n            }\n            result = true;\n        }\n    }\n\n    if( !result )\n        close();\n\n    return result;\n}\n\n\nbool  TiffDecoder::readData( Mat& img )\n{\n    bool result = false;\n    bool color = img.channels() > 1;\n    uchar* data = img.data;\n\n    if( img.depth() != CV_8U && img.depth() != CV_16U && img.depth() != CV_32F && img.depth() != CV_64F )\n        return false;\n\n    if( m_tif && m_width && m_height )\n    {\n        TIFF* tif = (TIFF*)m_tif;\n        uint32 tile_width0 = m_width, tile_height0 = 0;\n        int x, y, i;\n        int is_tiled = TIFFIsTiled(tif);\n        uint16 photometric;\n        TIFFGetField( tif, TIFFTAG_PHOTOMETRIC, &photometric );\n        uint16 bpp = 8, ncn = photometric > 1 ? 3 : 1;\n        TIFFGetField( tif, TIFFTAG_BITSPERSAMPLE, &bpp );\n        TIFFGetField( tif, TIFFTAG_SAMPLESPERPIXEL, &ncn );\n        const int bitsPerByte = 8;\n        int dst_bpp = (int)(img.elemSize1() * bitsPerByte);\n\n        if(dst_bpp == 8)\n        {\n            char errmsg[1024];\n            if(!TIFFRGBAImageOK( tif, errmsg ))\n            {\n                close();\n                return false;\n            }\n        }\n\n        if( (!is_tiled) ||\n            (is_tiled &&\n            TIFFGetField( tif, TIFFTAG_TILEWIDTH, &tile_width0 ) &&\n            TIFFGetField( tif, TIFFTAG_TILELENGTH, &tile_height0 )))\n        {\n            if(!is_tiled)\n                TIFFGetField( tif, TIFFTAG_ROWSPERSTRIP, &tile_height0 );\n\n            if( tile_width0 <= 0 )\n                tile_width0 = m_width;\n\n            if( tile_height0 <= 0 )\n                tile_height0 = m_height;\n\n            AutoBuffer<uchar> _buffer( size_t(8) * tile_height0*tile_width0);\n            uchar* buffer = _buffer;\n            ushort* buffer16 = (ushort*)buffer;\n            float* buffer32 = (float*)buffer;\n            double* buffer64 = (double*)buffer;\n            int tileidx = 0;\n\n            for( y = 0; y < m_height; y += tile_height0, data += img.step*tile_height0 )\n            {\n                int tile_height = tile_height0;\n\n                if( y + tile_height > m_height )\n                    tile_height = m_height - y;\n\n                for( x = 0; x < m_width; x += tile_width0, tileidx++ )\n                {\n                    int tile_width = tile_width0, ok;\n\n                    if( x + tile_width > m_width )\n                        tile_width = m_width - x;\n\n                    switch(dst_bpp)\n                    {\n                        case 8:\n                        {\n                            uchar * bstart = buffer;\n                            if( !is_tiled )\n                                ok = TIFFReadRGBAStrip( tif, y, (uint32*)buffer );\n                            else\n                            {\n                                ok = TIFFReadRGBATile( tif, x, y, (uint32*)buffer );\n                                //Tiles fill the buffer from the bottom up\n                                bstart += (tile_height0 - tile_height) * tile_width0 * 4;\n                            }\n                            if( !ok )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                                if( color )\n                                    icvCvt_BGRA2BGR_8u_C4C3R( bstart + i*tile_width0*4, 0,\n                                                             data + x*3 + img.step*(tile_height - i - 1), 0,\n                                                             cvSize(tile_width,1), 2 );\n                                else\n                                    icvCvt_BGRA2Gray_8u_C4C1R( bstart + i*tile_width0*4, 0,\n                                                              data + x + img.step*(tile_height - i - 1), 0,\n                                                              cvSize(tile_width,1), 2 );\n                            break;\n                        }\n\n                        case 16:\n                        {\n                            if( !is_tiled )\n                                ok = (int)TIFFReadEncodedStrip( tif, tileidx, (uint32*)buffer, (tsize_t)-1 ) >= 0;\n                            else\n                                ok = (int)TIFFReadEncodedTile( tif, tileidx, (uint32*)buffer, (tsize_t)-1 ) >= 0;\n\n                            if( !ok )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                            {\n                                if( color )\n                                {\n                                    if( ncn == 1 )\n                                    {\n                                        icvCvt_Gray2BGR_16u_C1C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                                  (ushort*)(data + img.step*i) + x*3, 0,\n                                                                  cvSize(tile_width,1) );\n                                    }\n                                    else if( ncn == 3 )\n                                    {\n                                        icvCvt_RGB2BGR_16u_C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                               (ushort*)(data + img.step*i) + x*3, 0,\n                                                               cvSize(tile_width,1) );\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2BGR_16u_C4C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                               (ushort*)(data + img.step*i) + x*3, 0,\n                                                               cvSize(tile_width,1), 2 );\n                                    }\n                                }\n                                else\n                                {\n                                    if( ncn == 1 )\n                                    {\n                                        memcpy((ushort*)(data + img.step*i)+x,\n                                               buffer16 + i*tile_width0*ncn,\n                                               tile_width*sizeof(buffer16[0]));\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2Gray_16u_CnC1R(buffer16 + i*tile_width0*ncn, 0,\n                                                               (ushort*)(data + img.step*i) + x, 0,\n                                                               cvSize(tile_width,1), ncn, 2 );\n                                    }\n                                }\n                            }\n                            break;\n                        }\n\n                        case 32:\n                        case 64:\n                        {\n                            if( !is_tiled )\n                                ok = (int)TIFFReadEncodedStrip( tif, tileidx, buffer, (tsize_t)-1 ) >= 0;\n                            else\n                                ok = (int)TIFFReadEncodedTile( tif, tileidx, buffer, (tsize_t)-1 ) >= 0;\n\n                            if( !ok || ncn != 1 )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                            {\n                                if(dst_bpp == 32)\n                                {\n                                    memcpy((float*)(data + img.step*i)+x,\n                                           buffer32 + i*tile_width0*ncn,\n                                           tile_width*sizeof(buffer32[0]));\n                                }\n                                else\n                                {\n                                    memcpy((double*)(data + img.step*i)+x,\n                                         buffer64 + i*tile_width0*ncn,\n                                         tile_width*sizeof(buffer64[0]));\n                                }\n                            }\n\n                            break;\n                        }\n                        default:\n                        {\n                            close();\n                            return false;\n                        }\n                    }\n                }\n            }\n\n            result = true;\n        }\n    }\n\n    close();\n    return result;\n}\n\n#endif\n\n//////////////////////////////////////////////////////////////////////////////////////////\n\nTiffEncoder::TiffEncoder()\n{\n    m_description = \"TIFF Files (*.tiff;*.tif)\";\n#ifdef HAVE_TIFF\n    m_buf_supported = false;\n#else\n    m_buf_supported = true;\n#endif\n}\n\nTiffEncoder::~TiffEncoder()\n{\n}\n\nImageEncoder TiffEncoder::newEncoder() const\n{\n    return new TiffEncoder;\n}\n\nbool TiffEncoder::isFormatSupported( int depth ) const\n{\n    return depth == CV_8U || depth == CV_16U;\n}\n\nvoid  TiffEncoder::writeTag( WLByteStream& strm, TiffTag tag,\n                             TiffFieldType fieldType,\n                             int count, int value )\n{\n    strm.putWord( tag );\n    strm.putWord( fieldType );\n    strm.putDWord( count );\n    strm.putDWord( value );\n}\n\n#ifdef HAVE_TIFF\n\nstatic void readParam(const vector<int>& params, int key, int& value)\n{\n    for(size_t i = 0; i + 1 < params.size(); i += 2)\n        if(params[i] == key)\n        {\n            value = params[i+1];\n            break;\n        }\n}\n\nbool  TiffEncoder::writeLibTiff( const Mat& img, const vector<int>& params)\n{\n    int channels = img.channels();\n    int width = img.cols, height = img.rows;\n    int depth = img.depth();\n\n    int bitsPerChannel = -1;\n    switch (depth)\n    {\n        case CV_8U:\n        {\n            bitsPerChannel = 8;\n            break;\n        }\n        case CV_16U:\n        {\n            bitsPerChannel = 16;\n            break;\n        }\n        default:\n        {\n            return false;\n        }\n    }\n\n    const int bitsPerByte = 8;\n    size_t fileStep = (width * channels * bitsPerChannel) / bitsPerByte;\n\n    int rowsPerStrip = (int)((1 << 13)/fileStep);\n    readParam(params, TIFFTAG_ROWSPERSTRIP, rowsPerStrip);\n\n    if( rowsPerStrip < 1 )\n        rowsPerStrip = 1;\n\n    if( rowsPerStrip > height )\n        rowsPerStrip = height;\n\n\n    // do NOT put \"wb\" as the mode, because the b means \"big endian\" mode, not \"binary\" mode.\n    // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n    TIFF* pTiffHandle = TIFFOpen(m_filename.c_str(), \"w\");\n    if (!pTiffHandle)\n    {\n        return false;\n    }\n\n    // defaults for now, maybe base them on params in the future\n    int   compression  = COMPRESSION_LZW;\n    int   predictor    = PREDICTOR_HORIZONTAL;\n\n    readParam(params, TIFFTAG_COMPRESSION, compression);\n    readParam(params, TIFFTAG_PREDICTOR, predictor);\n\n    int   colorspace = channels > 1 ? PHOTOMETRIC_RGB : PHOTOMETRIC_MINISBLACK;\n\n    if ( !TIFFSetField(pTiffHandle, TIFFTAG_IMAGEWIDTH, width)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_IMAGELENGTH, height)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_BITSPERSAMPLE, bitsPerChannel)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_COMPRESSION, compression)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_PHOTOMETRIC, colorspace)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_SAMPLESPERPIXEL, channels)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_ROWSPERSTRIP, rowsPerStrip)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_PREDICTOR, predictor)\n       )\n    {\n        TIFFClose(pTiffHandle);\n        return false;\n    }\n\n    // row buffer, because TIFFWriteScanline modifies the original data!\n    size_t scanlineSize = TIFFScanlineSize(pTiffHandle);\n    AutoBuffer<uchar> _buffer(scanlineSize+32);\n    uchar* buffer = _buffer;\n    if (!buffer)\n    {\n        TIFFClose(pTiffHandle);\n        return false;\n    }\n\n    for (int y = 0; y < height; ++y)\n    {\n        switch(channels)\n        {\n            case 1:\n            {\n                memcpy(buffer, img.data + img.step * y, scanlineSize);\n                break;\n            }\n\n            case 3:\n            {\n                if (depth == CV_8U)\n                    icvCvt_BGR2RGB_8u_C3R( img.data + img.step*y, 0, buffer, 0, cvSize(width,1) );\n                else\n                    icvCvt_BGR2RGB_16u_C3R( (const ushort*)(img.data + img.step*y), 0, (ushort*)buffer, 0, cvSize(width,1) );\n                break;\n            }\n\n            case 4:\n            {\n                if (depth == CV_8U)\n                    icvCvt_BGRA2RGBA_8u_C4R( img.data + img.step*y, 0, buffer, 0, cvSize(width,1) );\n                else\n                    icvCvt_BGRA2RGBA_16u_C4R( (const ushort*)(img.data + img.step*y), 0, (ushort*)buffer, 0, cvSize(width,1) );\n                break;\n            }\n\n            default:\n            {\n                TIFFClose(pTiffHandle);\n                return false;\n            }\n        }\n\n        int writeResult = TIFFWriteScanline(pTiffHandle, buffer, y, 0);\n        if (writeResult != 1)\n        {\n            TIFFClose(pTiffHandle);\n            return false;\n        }\n    }\n\n    TIFFClose(pTiffHandle);\n    return true;\n}\n\n#endif\n\n#ifdef HAVE_TIFF\nbool  TiffEncoder::write( const Mat& img, const vector<int>& params)\n#else\nbool  TiffEncoder::write( const Mat& img, const vector<int>& /*params*/)\n#endif\n{\n    int channels = img.channels();\n    int width = img.cols, height = img.rows;\n    int depth = img.depth();\n\n    if (depth != CV_8U && depth != CV_16U)\n        return false;\n\n    int bytesPerChannel = depth == CV_8U ? 1 : 2;\n    int fileStep = width * channels * bytesPerChannel;\n\n    WLByteStream strm;\n\n    if( m_buf )\n    {\n        if( !strm.open(*m_buf) )\n            return false;\n    }\n    else\n    {\n#ifdef HAVE_TIFF\n      return writeLibTiff(img, params);\n#else\n      if( !strm.open(m_filename) )\n          return false;\n#endif\n    }\n\n    int rowsPerStrip = (1 << 13)/fileStep;\n\n    if( rowsPerStrip < 1 )\n        rowsPerStrip = 1;\n\n    if( rowsPerStrip > height )\n        rowsPerStrip = height;\n\n    int i, stripCount = (height + rowsPerStrip - 1) / rowsPerStrip;\n\n    if( m_buf )\n        m_buf->reserve( alignSize(stripCount*8 + fileStep*height + 256, 256) );\n\n/*#if defined _DEBUG || !defined WIN32\n    int uncompressedRowSize = rowsPerStrip * fileStep;\n#endif*/\n    int directoryOffset = 0;\n\n    AutoBuffer<int> stripOffsets(stripCount);\n    AutoBuffer<short> stripCounts(stripCount);\n    AutoBuffer<uchar> _buffer(fileStep+32);\n    uchar* buffer = _buffer;\n    int  stripOffsetsOffset = 0;\n    int  stripCountsOffset = 0;\n    int  bitsPerSample = 8 * bytesPerChannel;\n    int  y = 0;\n\n    strm.putBytes( fmtSignTiffII, 4 );\n    strm.putDWord( directoryOffset );\n\n    // write an image data first (the most reasonable way\n    // for compressed images)\n    for( i = 0; i < stripCount; i++ )\n    {\n        int limit = y + rowsPerStrip;\n\n        if( limit > height )\n            limit = height;\n\n        stripOffsets[i] = strm.getPos();\n\n        for( ; y < limit; y++ )\n        {\n            if( channels == 3 )\n            {\n                if (depth == CV_8U)\n                    icvCvt_BGR2RGB_8u_C3R( img.data + img.step*y, 0, buffer, 0, cvSize(width,1) );\n                else\n                    icvCvt_BGR2RGB_16u_C3R( (const ushort*)(img.data + img.step*y), 0, (ushort*)buffer, 0, cvSize(width,1) );\n            }\n            else\n            {\n              if( channels == 4 )\n              {\n                if (depth == CV_8U)\n                    icvCvt_BGRA2RGBA_8u_C4R( img.data + img.step*y, 0, buffer, 0, cvSize(width,1) );\n                else\n                    icvCvt_BGRA2RGBA_16u_C4R( (const ushort*)(img.data + img.step*y), 0, (ushort*)buffer, 0, cvSize(width,1) );\n              }\n            }\n\n            strm.putBytes( channels > 1 ? buffer : img.data + img.step*y, fileStep );\n        }\n\n        stripCounts[i] = (short)(strm.getPos() - stripOffsets[i]);\n        /*assert( stripCounts[i] == uncompressedRowSize ||\n                stripCounts[i] < uncompressedRowSize &&\n                i == stripCount - 1);*/\n    }\n\n    if( stripCount > 2 )\n    {\n        stripOffsetsOffset = strm.getPos();\n        for( i = 0; i < stripCount; i++ )\n            strm.putDWord( stripOffsets[i] );\n\n        stripCountsOffset = strm.getPos();\n        for( i = 0; i < stripCount; i++ )\n            strm.putWord( stripCounts[i] );\n    }\n    else if(stripCount == 2)\n    {\n        stripOffsetsOffset = strm.getPos();\n        for (i = 0; i < stripCount; i++)\n        {\n            strm.putDWord (stripOffsets [i]);\n        }\n        stripCountsOffset = stripCounts [0] + (stripCounts [1] << 16);\n    }\n    else\n    {\n        stripOffsetsOffset = stripOffsets[0];\n        stripCountsOffset = stripCounts[0];\n    }\n\n    if( channels > 1 )\n    {\n        int bitsPerSamplePos = strm.getPos();\n        strm.putWord(bitsPerSample);\n        strm.putWord(bitsPerSample);\n        strm.putWord(bitsPerSample);\n        if( channels == 4 )\n            strm.putWord(bitsPerSample);\n        bitsPerSample = bitsPerSamplePos;\n    }\n\n    directoryOffset = strm.getPos();\n\n    // write header\n    strm.putWord( 9 );\n\n    /* warning: specification 5.0 of Tiff want to have tags in\n       ascending order. This is a non-fatal error, but this cause\n       warning with some tools. So, keep this in ascending order */\n\n    writeTag( strm, TIFF_TAG_WIDTH, TIFF_TYPE_LONG, 1, width );\n    writeTag( strm, TIFF_TAG_HEIGHT, TIFF_TYPE_LONG, 1, height );\n    writeTag( strm, TIFF_TAG_BITS_PER_SAMPLE,\n              TIFF_TYPE_SHORT, channels, bitsPerSample );\n    writeTag( strm, TIFF_TAG_COMPRESSION, TIFF_TYPE_LONG, 1, TIFF_UNCOMP );\n    writeTag( strm, TIFF_TAG_PHOTOMETRIC, TIFF_TYPE_SHORT, 1, channels > 1 ? 2 : 1 );\n\n    writeTag( strm, TIFF_TAG_STRIP_OFFSETS, TIFF_TYPE_LONG,\n              stripCount, stripOffsetsOffset );\n\n    writeTag( strm, TIFF_TAG_SAMPLES_PER_PIXEL, TIFF_TYPE_SHORT, 1, channels );\n    writeTag( strm, TIFF_TAG_ROWS_PER_STRIP, TIFF_TYPE_LONG, 1, rowsPerStrip );\n\n    writeTag( strm, TIFF_TAG_STRIP_COUNTS,\n              stripCount > 1 ? TIFF_TYPE_SHORT : TIFF_TYPE_LONG,\n              stripCount, stripCountsOffset );\n\n    strm.putDWord(0);\n    strm.close();\n\n    if( m_buf )\n    {\n        (*m_buf)[4] = (uchar)directoryOffset;\n        (*m_buf)[5] = (uchar)(directoryOffset >> 8);\n        (*m_buf)[6] = (uchar)(directoryOffset >> 16);\n        (*m_buf)[7] = (uchar)(directoryOffset >> 24);\n    }\n    else\n    {\n        // write directory offset\n        FILE* f = fopen( m_filename.c_str(), \"r+b\" );\n        buffer[0] = (uchar)directoryOffset;\n        buffer[1] = (uchar)(directoryOffset >> 8);\n        buffer[2] = (uchar)(directoryOffset >> 16);\n        buffer[3] = (uchar)(directoryOffset >> 24);\n\n        fseek( f, 4, SEEK_SET );\n        fwrite( buffer, 1, 4, f );\n        fclose(f);\n    }\n\n    return true;\n}\n\n}\n",
                "name": "grfmt_tiff.cpp",
                "path": "opencv-2.4.9/modules/highgui/src/grfmt_tiff.cpp",
                "url": "/github.com/jacob-zjj/LinuxSocket_Cplus/-/blob/opencv-2.4.9/modules/highgui/src/grfmt_tiff.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 245,
                    "offsetAndLengths": [
                        [
                            37,
                            16
                        ]
                    ],
                    "preview": "                                ok = TIFFReadRGBATile( tif, x, y, (uint32*)buffer );"
                }
            ],
            "repository": {
                "name": "github.com/jacob-zjj/LinuxSocket_Cplus",
                "url": "/github.com/jacob-zjj/LinuxSocket_Cplus"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "bd847da3af6cfd116189f11eb0a36309f1669951"
                },
                "content": "// Copyright 2008-present Contributors to the OpenImageIO project.\n// SPDX-License-Identifier: BSD-3-Clause\n// https://github.com/OpenImageIO/oiio/blob/master/LICENSE.md\n\n\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n\n#include <boost/thread/tss.hpp>\n\n#include <tiffio.h>\n#include <zlib.h>\n\n#include <OpenImageIO/dassert.h>\n#include <OpenImageIO/filesystem.h>\n#include <OpenImageIO/fmath.h>\n#include <OpenImageIO/imageio.h>\n#include <OpenImageIO/parallel.h>\n#include <OpenImageIO/strutil.h>\n#include <OpenImageIO/thread.h>\n#include <OpenImageIO/tiffutils.h>\n#include <OpenImageIO/typedesc.h>\n\n#include \"imageio_pvt.h\"\n\n\nOIIO_PLUGIN_NAMESPACE_BEGIN\n\n\n// General TIFF information:\n// TIFF 6.0 spec:\n//     http://partners.adobe.com/public/developer/en/tiff/TIFF6.pdf\n// Other Adobe TIFF docs:\n//     http://partners.adobe.com/public/developer/tiff/index.html\n// Adobe extensions to allow 16 (and 24) bit float in TIFF (ugh, not on\n// their developer page, only on Chris Cox's web site?):\n//     http://chriscox.org/TIFFTN3d1.pdf\n// Libtiff:\n//     http://remotesensing.org/libtiff/\n\n\n\n// Helper struct for constructing tables of TIFF tags\nstruct TIFF_tag_info {\n    int tifftag;            // TIFF tag used for this info\n    const char* name;       // Attribute name we use, or NULL to ignore the tag\n    TIFFDataType tifftype;  // Data type that TIFF wants\n};\n\n\n\n// Note about MIP-maps versus subimages:\n//\n// TIFF files support subimages, but do not explicitly support\n// multiresolution/MIP maps.  So we have always used subimages to store\n// MIP levels.\n//\n// At present, TIFF is the only format people use for multires textures\n// that don't explicitly support it, so rather than make the\n// TextureSystem have to handle both cases, we choose instead to emulate\n// MIP with subimage in a way that's purely within the TIFFInput class.\n// To the outside world, it really does look MIP-mapped.  This only\n// kicks in for TIFF files that have the \"textureformat\" metadata set.\n//\n// The internal m_subimage really does contain the subimage, but for the\n// MIP emulation case, we report the subimage as the MIP level, and 0 as\n// the subimage.  It is indeed a tangled web of deceit we weave.\n\n\n\nclass TIFFInput final : public ImageInput {\npublic:\n    TIFFInput();\n    virtual ~TIFFInput();\n    virtual const char* format_name(void) const override { return \"tiff\"; }\n    virtual bool valid_file(const std::string& filename) const override;\n    virtual int supports(string_view feature) const override\n    {\n        return (feature == \"exif\" || feature == \"iptc\");\n        // N.B. No support for arbitrary metadata.\n    }\n    virtual bool open(const std::string& name, ImageSpec& newspec) override;\n    virtual bool open(const std::string& name, ImageSpec& newspec,\n                      const ImageSpec& config) override;\n    virtual bool close() override;\n    virtual int current_subimage(void) const override\n    {\n        // If m_emulate_mipmap is true, pretend subimages are mipmap levels\n        lock_guard lock(m_mutex);\n        return m_emulate_mipmap ? 0 : m_subimage;\n    }\n    virtual int current_miplevel(void) const override\n    {\n        // If m_emulate_mipmap is true, pretend subimages are mipmap levels\n        lock_guard lock(m_mutex);\n        return m_emulate_mipmap ? m_subimage : 0;\n    }\n    virtual bool seek_subimage(int subimage, int miplevel) override;\n    virtual ImageSpec spec(int subimage, int miplevel) override;\n    virtual ImageSpec spec_dimensions(int subimage, int miplevel) override;\n    const ImageSpec& spec(void) const override { return m_spec; }\n    virtual bool read_native_scanline(int subimage, int miplevel, int y, int z,\n                                      void* data) override;\n    virtual bool read_native_scanlines(int subimage, int miplevel, int ybegin,\n                                       int yend, int z, void* data) override;\n    virtual bool read_native_tile(int subimage, int miplevel, int x, int y,\n                                  int z, void* data) override;\n    virtual bool read_native_tiles(int subimage, int miplevel, int xbegin,\n                                   int xend, int ybegin, int yend, int zbegin,\n                                   int zend, void* data) override;\n    virtual bool read_scanline(int y, int z, TypeDesc format, void* data,\n                               stride_t xstride) override;\n    virtual bool read_scanlines(int subimage, int miplevel, int ybegin,\n                                int yend, int z, int chbegin, int chend,\n                                TypeDesc format, void* data, stride_t xstride,\n                                stride_t ystride) override;\n    virtual bool read_tile(int x, int y, int z, TypeDesc format, void* data,\n                           stride_t xstride, stride_t ystride,\n                           stride_t zstride) override;\n    virtual bool read_tiles(int subimage, int miplevel, int xbegin, int xend,\n                            int ybegin, int yend, int zbegin, int zend,\n                            int chbegin, int chend, TypeDesc format, void* data,\n                            stride_t xstride, stride_t ystride,\n                            stride_t zstride) override;\n\nprivate:\n    TIFF* m_tif;                            ///< libtiff handle\n    std::string m_filename;                 ///< Stash the filename\n    std::vector<unsigned char> m_scratch;   ///< Scratch space for us to use\n    std::vector<unsigned char> m_scratch2;  ///< More scratch\n    int m_subimage;                  ///< What subimage are we looking at?\n    int m_next_scanline;             ///< Next scanline we'll read\n    bool m_no_random_access;         ///< Should we avoid random access?\n    bool m_emulate_mipmap;           ///< Should we emulate mip with subimage?\n    bool m_keep_unassociated_alpha;  ///< If the image is unassociated, please\n                                     ///<   try to keep it that way!\n    bool m_raw_color;                ///< If the image is not RGB, don't\n                                     ///<   transform the color.\n    bool m_convert_alpha;            ///< Do we need to associate alpha?\n    bool m_separate;                 ///< Separate planarconfig?\n    bool m_testopenconfig;           ///< Debug aid to test open-with-config\n    bool m_use_rgba_interface;       ///< Sometimes we punt\n    bool m_is_byte_swapped;          ///< Is the file opposite our endian?\n    int m_rowsperstrip;              ///< For scanline imgs, rows per strip\n    unsigned short m_planarconfig;   ///< Planar config of the file\n    unsigned short m_bitspersample;  ///< Of the *file*, not the client's view\n    unsigned short m_photometric;    ///< Of the *file*, not the client's view\n    unsigned short m_compression;    ///< TIFF compression tag\n    unsigned short m_predictor;      ///< TIFF compression predictor tag\n    unsigned short m_inputchannels;  ///< Channels in the file (careful with CMYK)\n    std::vector<unsigned short> m_colormap;   ///< Color map for palette images\n    std::vector<uint32_t> m_rgbadata;         ///< Sometimes we punt\n    std::vector<ImageSpec> m_subimage_specs;  ///< Cached subimage specs\n\n    // Reset everything to initial state\n    void init()\n    {\n        m_tif                     = NULL;\n        m_subimage                = -1;\n        m_emulate_mipmap          = false;\n        m_keep_unassociated_alpha = false;\n        m_raw_color               = false;\n        m_convert_alpha           = false;\n        m_separate                = false;\n        m_inputchannels           = 0;\n        m_testopenconfig          = false;\n        m_colormap.clear();\n        m_use_rgba_interface = false;\n        m_subimage_specs.clear();\n    }\n\n    // Just close the TIFF file handle, but don't forget anything we\n    // learned about the contents of the file or any configuration hints.\n    void close_tif()\n    {\n        if (m_tif) {\n            TIFFClose(m_tif);\n            m_tif = NULL;\n            if (m_rgbadata.size())\n                std::vector<uint32_t>().swap(m_rgbadata);  // release\n        }\n    }\n\n    // Read tags from the current directory of m_tif and fill out spec.\n    // If read_meta is false, assume that m_spec already contains valid\n    // metadata and should not be cleared or rewritten.\n    void readspec(bool read_meta = true);\n\n    // Figure out all the photometric-related aspects of the header\n    void readspec_photometric();\n\n    // Convert planar separate to contiguous data format\n    void separate_to_contig(int nplanes, int nvals,\n                            const unsigned char* separate,\n                            unsigned char* contig);\n\n    // Convert palette to RGB\n    void palette_to_rgb(int n, const unsigned char* palettepels,\n                        unsigned char* rgb);\n\n    // Convert in-bits to out-bits (outbits must be 8, 16, 32, and\n    // inbits < outbits)\n    void bit_convert(int n, const unsigned char* in, int inbits, void* out,\n                     int outbits);\n\n    void invert_photometric(int n, void* data);\n\n    // Calling TIFFGetField (tif, tag, &dest) is supposed to work fine for\n    // simple types... as long as the tag types in the file are the correct\n    // advertised types.  But for some types -- which we never expect, but\n    // it turns out can sometimes happen, TIFFGetField will try to pull\n    // a second argument (a void**) off the stack, and that can crash the\n    // program!  Ick.  So to avoid this, we always push a pointer, which\n    // we expect NOT to be altered, and if it is, it's a danger sign (plus\n    // we didn't crash).\n    bool safe_tiffgetfield(string_view name, int tag, void* dest)\n    {\n        void* ptr = NULL;  // dummy -- expect it to stay NULL\n        bool ok   = TIFFGetField(m_tif, tag, dest, &ptr);\n        if (ptr) {\n#ifndef NDEBUG\n            std::cerr << \"Error safe_tiffgetfield : did not expect ptr set on \"\n                      << name << \" \" << (void*)ptr << \"\\n\";\n#endif\n            return false;\n        }\n        return ok;\n    }\n\n    // Get a string tiff tag field and save it it as a string_view. The\n    // return value will be true if the tag was found, otherwise false.\n    bool tiff_get_string_field(int tag, string_view& result)\n    {\n        char* s   = NULL;\n        void* ptr = NULL;  // dummy -- expect it to stay NULL\n        bool ok   = TIFFGetField(m_tif, tag, &s, &ptr);\n        if (ok && ptr) {\n            // Oy, some tags need 2 args, which are count, then ptr.\n            // There's no way to know ahead of time which ones, so we send\n            // a second pointer. If it gets overwritten, then we understand\n            // and try it again with 2 args, first one is count.\n            unsigned short count;\n            ok     = TIFFGetField(m_tif, tag, &count, &s);\n            result = string_view(s, count);\n        } else if (ok && s && *s)\n            result = string_view(s);\n        return ok;\n    }\n\n    // Get a string tiff tag field and put it into extra_params\n    void get_string_attribute(string_view name, int tag)\n    {\n        string_view s;\n        if (tiff_get_string_field(tag, s))\n            m_spec.attribute(name, s);\n    }\n\n    // Get a matrix tiff tag field and put it into extra_params\n    void get_matrix_attribute(string_view name, int tag)\n    {\n        float* f = NULL;\n        if (safe_tiffgetfield(name, tag, &f) && f)\n            m_spec.attribute(name, TypeMatrix, f);\n    }\n\n    // Get a float tiff tag field and put it into extra_params\n    void get_float_attribute(string_view name, int tag)\n    {\n        float f[16];\n        if (safe_tiffgetfield(name, tag, f))\n            m_spec.attribute(name, f[0]);\n    }\n\n    // Get an int tiff tag field and put it into extra_params\n    void get_int_attribute(string_view name, int tag)\n    {\n        int i;\n        if (safe_tiffgetfield(name, tag, &i))\n            m_spec.attribute(name, i);\n    }\n\n    // Get an int tiff tag field and put it into extra_params\n    void get_short_attribute(string_view name, int tag)\n    {\n        // Make room for two shorts, in case the tag is not the type we\n        // expect, and libtiff writes a long instead.\n        unsigned short s[2] = { 0, 0 };\n        if (safe_tiffgetfield(name, tag, &s)) {\n            int i = s[0];\n            m_spec.attribute(name, i);\n        }\n    }\n\n#ifdef TIFF_VERSION_BIG\n    const TIFFField* find_field(int tifftag, TIFFDataType tifftype)\n    {\n        return TIFFFindField(m_tif, tifftag, tifftype);\n    }\n#else\n    const TIFFFieldInfo* find_field(int tifftag, TIFFDataType tifftype)\n    {\n        return TIFFFindFieldInfo(m_tif, tifftag, tifftype);\n    }\n#endif\n\n    // Search for TIFF tag having type 'tifftype', and if found,\n    // add it in the obvious way to m_spec under the name 'oiioname'.\n    void find_tag(int tifftag, TIFFDataType tifftype, string_view oiioname)\n    {\n        auto info = find_field(tifftag, tifftype);\n        if (!info) {\n            // Something has gone wrong, libtiff doesn't think the field type\n            // is the same as we do.\n            return;\n        }\n        if (tifftype == TIFF_ASCII)\n            get_string_attribute(oiioname, tifftag);\n        else if (tifftype == TIFF_SHORT)\n            get_short_attribute(oiioname, tifftag);\n        else if (tifftype == TIFF_LONG)\n            get_int_attribute(oiioname, tifftag);\n        else if (tifftype == TIFF_RATIONAL || tifftype == TIFF_SRATIONAL\n                 || tifftype == TIFF_FLOAT || tifftype == TIFF_DOUBLE)\n            get_float_attribute(oiioname, tifftag);\n    }\n\n    // If we're at scanline y, where does the next strip start?\n    int next_strip_boundary(int y)\n    {\n        return round_to_multiple(y - m_spec.y, m_rowsperstrip) + m_spec.y;\n    }\n\n    bool is_strip_boundary(int y)\n    {\n        return y == next_strip_boundary(y) || y == m_spec.height;\n    }\n\n    // Copy a height x width x chans region of src to dst, un-applying a\n    // horizontal predictor to each row. It is permitted for src and dst to\n    // be the same.\n    template<typename T>\n    void undo_horizontal_predictor(T* dst, const T* src, int chans, int width,\n                                   int height)\n    {\n        for (int y = 0; y < height;\n             ++y, src += chans * width, dst += chans * width)\n            for (int c = 0; c < chans; ++c) {\n                dst[c] = src[c];  // element 0\n                for (int x = 1; x < width; ++x)\n                    dst[x * chans + c] = src[(x - 1) * chans + c]\n                                         + src[x * chans + c];\n            }\n    }\n\n    void uncompress_one_strip(void* compressed_buf, unsigned long csize,\n                              void* uncompressed_buf, size_t strip_bytes,\n                              int channels, int width, int height,\n                              int compression, bool* ok)\n    {\n        ASSERT (compression == COMPRESSION_ADOBE_DEFLATE /*||\n                compression == COMPRESSION_NONE*/);\n        if (compression == COMPRESSION_NONE) {\n            // just copy if there's no compression\n            memcpy(uncompressed_buf, compressed_buf, csize);\n            if (m_is_byte_swapped && m_spec.format == TypeUInt16)\n                TIFFSwabArrayOfShort((unsigned short*)uncompressed_buf,\n                                     width * height * channels);\n            return;\n        }\n        uLong uncompressed_size = (uLong)strip_bytes;\n        auto zok = uncompress((Bytef*)uncompressed_buf, &uncompressed_size,\n                              (const Bytef*)compressed_buf, csize);\n        if (zok != Z_OK || uncompressed_size != strip_bytes) {\n            *ok = false;\n            return;\n        }\n        if (m_is_byte_swapped && m_spec.format == TypeUInt16)\n            TIFFSwabArrayOfShort((unsigned short*)uncompressed_buf,\n                                 width * height * channels);\n        if (m_predictor == PREDICTOR_HORIZONTAL) {\n            if (m_spec.format == TypeUInt8)\n                undo_horizontal_predictor((unsigned char*)uncompressed_buf,\n                                          (unsigned char*)uncompressed_buf,\n                                          channels, width, height);\n            else if (m_spec.format == TypeUInt16)\n                undo_horizontal_predictor((unsigned short*)uncompressed_buf,\n                                          (unsigned short*)uncompressed_buf,\n                                          channels, width, height);\n        }\n    }\n\n    int tile_index(int x, int y, int z)\n    {\n        int xtile   = (x - m_spec.x) / m_spec.tile_width;\n        int ytile   = (y - m_spec.y) / m_spec.tile_height;\n        int ztile   = (z - m_spec.z) / m_spec.tile_depth;\n        int nxtiles = (m_spec.width + m_spec.tile_width - 1)\n                      / m_spec.tile_width;\n        int nytiles = (m_spec.height + m_spec.tile_height - 1)\n                      / m_spec.tile_height;\n        return xtile + ytile * nxtiles + ztile * nxtiles * nytiles;\n    }\n};\n\n\n\n// Obligatory material to make this a recognizeable imageio plugin:\nOIIO_PLUGIN_EXPORTS_BEGIN\n\nOIIO_EXPORT ImageInput*\ntiff_input_imageio_create()\n{\n    return new TIFFInput;\n}\n\n// OIIO_EXPORT int tiff_imageio_version = OIIO_PLUGIN_VERSION; // it's in tiffoutput.cpp\n\nOIIO_EXPORT const char* tiff_input_extensions[]\n    = { \"tif\", \"tiff\", \"tx\", \"env\", \"sm\", \"vsm\", nullptr };\n\nOIIO_PLUGIN_EXPORTS_END\n\n\n\n// Someplace to store an error message from the TIFF error handler\n// To avoid thread oddities, we have the storage area buffering error\n// messages for seterror()/geterror() be thread-specific.\nstatic boost::thread_specific_ptr<std::string> thread_error_msg;\nstatic atomic_int handler_set;\nstatic spin_mutex handler_mutex;\n\n\n\nstd::string&\noiio_tiff_last_error()\n{\n    std::string* e = thread_error_msg.get();\n    if (!e) {\n        e = new std::string;\n        thread_error_msg.reset(e);\n    }\n    return *e;\n}\n\n\n\nstatic void\nmy_error_handler(const char* str, const char* format, va_list ap)\n{\n    oiio_tiff_last_error() = Strutil::vformat(format, ap);\n}\n\n\n\nvoid\noiio_tiff_set_error_handler()\n{\n    if (!handler_set) {\n        spin_lock lock(handler_mutex);\n        if (!handler_set) {\n            TIFFSetErrorHandler(my_error_handler);\n            TIFFSetWarningHandler(my_error_handler);\n            handler_set = 1;\n        }\n    }\n}\n\n\n\nstruct CompressionCode {\n    int code;\n    const char* name;\n};\n\n// clang-format off\n\nstatic CompressionCode tiff_compressions[] = {\n    { COMPRESSION_NONE,          \"none\" },        // no compression\n    { COMPRESSION_LZW,           \"lzw\" },         // LZW\n    { COMPRESSION_ADOBE_DEFLATE, \"zip\" },         // deflate / zip\n    { COMPRESSION_DEFLATE,       \"zip\" },         // deflate / zip\n    { COMPRESSION_CCITTRLE,      \"ccittrle\" },    // CCITT RLE\n    { COMPRESSION_CCITTFAX3,     \"ccittfax3\" },   // CCITT group 3 fax\n    { COMPRESSION_CCITT_T4,      \"ccitt_t4\" },    // CCITT T.4\n    { COMPRESSION_CCITTFAX4,     \"ccittfax4\" },   // CCITT group 4 fax\n    { COMPRESSION_CCITT_T6,      \"ccitt_t6\" },    // CCITT T.6\n    { COMPRESSION_OJPEG,         \"ojpeg\" },       // old (pre-TIFF6.0) JPEG\n    { COMPRESSION_JPEG,          \"jpeg\" },        // JPEG\n    { COMPRESSION_NEXT,          \"next\" },        // NeXT 2-bit RLE\n    { COMPRESSION_CCITTRLEW,     \"ccittrle2\" },   // #1 w/ word alignment\n    { COMPRESSION_PACKBITS,      \"packbits\" },    // Macintosh RLE\n    { COMPRESSION_THUNDERSCAN,   \"thunderscan\" }, // ThundeScan RLE\n    { COMPRESSION_IT8CTPAD,      \"IT8CTPAD\" },    // IT8 CT w/ patting\n    { COMPRESSION_IT8LW,         \"IT8LW\" },       // IT8 linework RLE\n    { COMPRESSION_IT8MP,         \"IT8MP\" },       // IT8 monochrome picture\n    { COMPRESSION_IT8BL,         \"IT8BL\" },       // IT8 binary line art\n    { COMPRESSION_PIXARFILM,     \"pixarfilm\" },   // Pixar 10 bit LZW\n    { COMPRESSION_PIXARLOG,      \"pixarlog\" },    // Pixar 11 bit ZIP\n    { COMPRESSION_DCS,           \"dcs\" },         // Kodak DCS encoding\n    { COMPRESSION_JBIG,          \"isojbig\" },     // ISO JBIG\n    { COMPRESSION_SGILOG,        \"sgilog\" },      // SGI log luminance RLE\n    { COMPRESSION_SGILOG24,      \"sgilog24\" },    // SGI log 24bit\n    { COMPRESSION_JP2000,        \"jp2000\" },      // Leadtools JPEG2000\n#if defined(TIFF_VERSION_BIG) && TIFFLIB_VERSION >= 20120922\n    // Others supported in more recent TIFF library versions.\n    { COMPRESSION_T85,           \"T85\" },         // TIFF/FX T.85 JBIG\n    { COMPRESSION_T43,           \"T43\" },         // TIFF/FX T.43 color layered JBIG\n    { COMPRESSION_LZMA,          \"lzma\" },        // LZMA2\n#endif\n    { -1, NULL }\n};\n\n// clang-format on\n\nstatic const char*\ntiff_compression_name(int code)\n{\n    for (int i = 0; tiff_compressions[i].name; ++i)\n        if (code == tiff_compressions[i].code)\n            return tiff_compressions[i].name;\n    return NULL;\n}\n\n\n\nTIFFInput::TIFFInput()\n{\n    oiio_tiff_set_error_handler();\n    init();\n}\n\n\n\nTIFFInput::~TIFFInput()\n{\n    // Close, if not already done.\n    close();\n}\n\n\n\nbool\nTIFFInput::valid_file(const std::string& filename) const\n{\n    FILE* file = Filesystem::fopen(filename, \"r\");\n    if (!file)\n        return false;  // needs to be able to open\n    unsigned short magic[2] = { 0, 0 };\n    size_t numRead          = fread(magic, sizeof(unsigned short), 2, file);\n    fclose(file);\n    if (numRead != 2)  // fread failed\n        return false;\n    if (magic[0] != TIFF_LITTLEENDIAN && magic[0] != TIFF_BIGENDIAN)\n        return false;  // not the right byte order\n    if ((magic[0] == TIFF_LITTLEENDIAN) != littleendian())\n        swap_endian(&magic[1], 1);\n    return (magic[1] == 42 /* Classic TIFF */ || magic[1] == 43 /* Big TIFF */);\n}\n\n\n\nbool\nTIFFInput::open(const std::string& name, ImageSpec& newspec)\n{\n    oiio_tiff_set_error_handler();\n    m_filename = name;\n    m_subimage = -1;\n\n    bool ok = seek_subimage(0, 0);\n    newspec = spec();\n    return ok;\n}\n\n\n\nbool\nTIFFInput::open(const std::string& name, ImageSpec& newspec,\n                const ImageSpec& config)\n{\n    // Check 'config' for any special requests\n    if (config.get_int_attribute(\"oiio:UnassociatedAlpha\", 0) == 1)\n        m_keep_unassociated_alpha = true;\n    if (config.get_int_attribute(\"oiio:RawColor\", 0) == 1)\n        m_raw_color = true;\n    // This configuration hint has no function other than as a debugging aid\n    // for testing whether configurations are received properly from other\n    // OIIO components.\n    if (config.get_int_attribute(\"oiio:DebugOpenConfig!\", 0))\n        m_testopenconfig = true;\n    return open(name, newspec);\n}\n\n\n\nbool\nTIFFInput::seek_subimage(int subimage, int miplevel)\n{\n    if (subimage < 0)  // Illegal\n        return false;\n    if (m_emulate_mipmap) {\n        // Emulating MIPmap?  Pretend one subimage, many MIP levels.\n        if (subimage != 0)\n            return false;\n        subimage = miplevel;\n    } else {\n        // No MIPmap emulation\n        if (miplevel != 0)\n            return false;\n    }\n\n    if (subimage == m_subimage) {\n        // We're already pointing to the right subimage\n        return true;\n    }\n\n    // If we're emulating a MIPmap, only resolution is allowed to change\n    // between MIP levels, so if we already have a valid level in m_spec,\n    // we don't need to re-parse metadata, it's guaranteed to be the same.\n    bool read_meta = !(m_emulate_mipmap && m_tif && m_subimage >= 0);\n\n    if (!m_tif) {\n#ifdef _WIN32\n        std::wstring wfilename = Strutil::utf8_to_utf16(m_filename);\n        m_tif                  = TIFFOpenW(wfilename.c_str(), \"rm\");\n#else\n        m_tif = TIFFOpen(m_filename.c_str(), \"rm\");\n#endif\n        if (m_tif == NULL) {\n            std::string e = oiio_tiff_last_error();\n            error(\"Could not open file: %s\", e.length() ? e : m_filename);\n            return false;\n        }\n        m_is_byte_swapped = TIFFIsByteSwapped(m_tif);\n        m_subimage        = 0;\n    }\n\n    m_next_scanline = 0;  // next scanline we'll read\n    if (subimage == m_subimage || TIFFSetDirectory(m_tif, subimage)) {\n        m_subimage = subimage;\n        readspec(read_meta);\n        // OK, some edge cases we just don't handle. For those, fall back on\n        // the TIFFRGBA interface.\n        bool is_jpeg        = (m_compression == COMPRESSION_JPEG\n                        || m_compression == COMPRESSION_OJPEG);\n        bool is_nonspectral = (m_photometric == PHOTOMETRIC_YCBCR\n                               || m_photometric == PHOTOMETRIC_CIELAB\n                               || m_photometric == PHOTOMETRIC_ICCLAB\n                               || m_photometric == PHOTOMETRIC_ITULAB\n                               || m_photometric == PHOTOMETRIC_LOGL\n                               || m_photometric == PHOTOMETRIC_LOGLUV);\n        if ((is_jpeg && m_spec.nchannels != 3)\n            || (is_nonspectral && !m_raw_color)) {\n            char emsg[1024];\n            m_use_rgba_interface = true;\n            if (!TIFFRGBAImageOK(m_tif, emsg)) {\n                errorf(\"No support for this flavor of TIFF file (%s)\", emsg);\n                return false;\n            }\n            // This falls back to looking like uint8 images\n            m_spec.format = TypeDesc::UINT8;\n            m_spec.channelformats.clear();\n            m_photometric = PHOTOMETRIC_RGB;\n        }\n        if (size_t(subimage) >= m_subimage_specs.size())  // make room\n            m_subimage_specs.resize(\n                subimage > 0 ? round_to_multiple(subimage + 1, 4) : 1);\n        if (m_subimage_specs[subimage]\n                .undefined())  // haven't cached this spec yet\n            m_subimage_specs[subimage] = m_spec;\n        if (m_spec.format == TypeDesc::UNKNOWN) {\n            error(\"No support for data format of \\\"%s\\\"\", m_filename);\n            return false;\n        }\n        return true;\n    } else {\n        std::string e = oiio_tiff_last_error();\n        error(\"%s\", e.length() ? e : m_filename);\n        m_subimage = -1;\n        return false;\n    }\n}\n\n\n\nImageSpec\nTIFFInput::spec(int subimage, int miplevel)\n{\n    ImageSpec ret;\n    int s = m_emulate_mipmap ? miplevel : subimage;\n    lock_guard lock(m_mutex);\n    if (s >= 0 && s < int(m_subimage_specs.size())\n        && !m_subimage_specs[s].undefined()) {\n        // If we've cached this spec, we don't need to seek and read\n        ret = m_subimage_specs[s];\n    } else {\n        if (seek_subimage(subimage, miplevel))\n            ret = m_spec;\n    }\n    return ret;\n}\n\n\n\nImageSpec\nTIFFInput::spec_dimensions(int subimage, int miplevel)\n{\n    ImageSpec ret;\n    int s = m_emulate_mipmap ? miplevel : subimage;\n    lock_guard lock(m_mutex);\n    if (s >= 0 && s < int(m_subimage_specs.size())\n        && !m_subimage_specs[s].undefined()) {\n        // If we've cached this spec, we don't need to seek and read\n        ret.copy_dimensions(m_subimage_specs[s]);\n    } else {\n        if (seek_subimage(subimage, miplevel))\n            ret.copy_dimensions(m_spec);\n    }\n    return ret;\n}\n\n\n\n#define ICC_PROFILE_ATTR \"ICCProfile\"\n\n\nvoid\nTIFFInput::readspec(bool read_meta)\n{\n    uint32 width = 0, height = 0, depth = 0;\n    TIFFGetField(m_tif, TIFFTAG_IMAGEWIDTH, &width);\n    TIFFGetField(m_tif, TIFFTAG_IMAGELENGTH, &height);\n    TIFFGetFieldDefaulted(m_tif, TIFFTAG_IMAGEDEPTH, &depth);\n    TIFFGetFieldDefaulted(m_tif, TIFFTAG_SAMPLESPERPIXEL, &m_inputchannels);\n\n    if (read_meta) {\n        // clear the whole m_spec and start fresh\n        m_spec = ImageSpec((int)width, (int)height, (int)m_inputchannels);\n    } else {\n        // assume m_spec is valid, except for things that might differ\n        // between MIP levels\n        m_spec.width     = (int)width;\n        m_spec.height    = (int)height;\n        m_spec.depth     = (int)depth;\n        m_spec.nchannels = (int)m_inputchannels;\n    }\n\n    float xpos = 0, ypos = 0;\n    TIFFGetField(m_tif, TIFFTAG_XPOSITION, &xpos);\n    TIFFGetField(m_tif, TIFFTAG_YPOSITION, &ypos);\n    if (xpos || ypos) {\n        // In the TIFF files, the positions are in resolutionunit. But we\n        // didn't used to interpret it that way, hence the mess below.\n        float xres = 1, yres = 1;\n        TIFFGetField(m_tif, TIFFTAG_XRESOLUTION, &xres);\n        TIFFGetField(m_tif, TIFFTAG_YRESOLUTION, &yres);\n        // See if the 'Software' field has a clue about what version of OIIO\n        // wrote the TIFF file. This can save us from embarrassing mistakes\n        // misinterpreting the image offset.\n        int oiio_write_version = 0;\n        string_view software;\n        if (tiff_get_string_field(TIFFTAG_SOFTWARE, software)\n            && Strutil::parse_prefix(software, \"OpenImageIO\")) {\n            int major = 0, minor = 0, patch = 0;\n            if (Strutil::parse_int(software, major)\n                && Strutil::parse_char(software, '.')\n                && Strutil::parse_int(software, minor)\n                && Strutil::parse_char(software, '.')\n                && Strutil::parse_int(software, patch)) {\n                oiio_write_version = major * 10000 + minor * 100 + patch;\n            }\n        }\n        // Old version of OIIO did not write the field correctly, so try\n        // to compensate.\n        if (oiio_write_version && oiio_write_version < 10803) {\n            xres = yres = 1.0f;\n        }\n        m_spec.x = (int)(xpos * xres);\n        m_spec.y = (int)(ypos * yres);\n    } else {\n        m_spec.x = 0;\n        m_spec.y = 0;\n    }\n    m_spec.z = 0;\n\n    // Start by assuming the \"full\" (aka display) window is the same as the\n    // data window. That's what we'll stick to if there is no further\n    // information in the file. But if the file has tags for hte \"full\"\n    // size, assume a display window with origin (0,0) and those dimensions.\n    // (Unfortunately, there are no TIFF tags for \"full\" origin.)\n    m_spec.full_x      = m_spec.x;\n    m_spec.full_y      = m_spec.y;\n    m_spec.full_z      = m_spec.z;\n    m_spec.full_width  = m_spec.width;\n    m_spec.full_height = m_spec.height;\n    m_spec.full_depth  = m_spec.depth;\n    if (TIFFGetField(m_tif, TIFFTAG_PIXAR_IMAGEFULLWIDTH, &width) == 1\n        && TIFFGetField(m_tif, TIFFTAG_PIXAR_IMAGEFULLLENGTH, &height) == 1\n        && width > 0 && height > 0) {\n        m_spec.full_width  = width;\n        m_spec.full_height = height;\n        m_spec.full_x      = 0;\n        m_spec.full_y      = 0;\n    }\n\n    if (TIFFIsTiled(m_tif)) {\n        TIFFGetField(m_tif, TIFFTAG_TILEWIDTH, &m_spec.tile_width);\n        TIFFGetField(m_tif, TIFFTAG_TILELENGTH, &m_spec.tile_height);\n        TIFFGetFieldDefaulted(m_tif, TIFFTAG_TILEDEPTH, &m_spec.tile_depth);\n    } else {\n        m_spec.tile_width  = 0;\n        m_spec.tile_height = 0;\n        m_spec.tile_depth  = 0;\n    }\n\n    m_bitspersample = 8;\n    TIFFGetField(m_tif, TIFFTAG_BITSPERSAMPLE, &m_bitspersample);\n    m_spec.attribute(\"oiio:BitsPerSample\", (int)m_bitspersample);\n\n    unsigned short sampleformat = SAMPLEFORMAT_UINT;\n    TIFFGetFieldDefaulted(m_tif, TIFFTAG_SAMPLEFORMAT, &sampleformat);\n    switch (m_bitspersample) {\n    case 1:\n    case 2:\n    case 4:\n    case 6:\n        // Make 1, 2, 4, 6 bpp look like byte images\n    case 8:\n        if (sampleformat == SAMPLEFORMAT_UINT)\n            m_spec.set_format(TypeDesc::UINT8);\n        else if (sampleformat == SAMPLEFORMAT_INT)\n            m_spec.set_format(TypeDesc::INT8);\n        else\n            m_spec.set_format(TypeDesc::UINT8);  // punt\n        break;\n    case 10:\n    case 12:\n    case 14:\n        // Make 10, 12, 14 bpp look like 16 bit images\n    case 16:\n        if (sampleformat == SAMPLEFORMAT_UINT)\n            m_spec.set_format(TypeDesc::UINT16);\n        else if (sampleformat == SAMPLEFORMAT_INT)\n            m_spec.set_format(TypeDesc::INT16);\n        else if (sampleformat == SAMPLEFORMAT_IEEEFP) {\n            m_spec.set_format(TypeDesc::HALF);\n            // Adobe extension, see http://chriscox.org/TIFFTN3d1.pdf\n        } else\n            m_spec.set_format(TypeDesc::UNKNOWN);\n        break;\n    case 24:\n        // Make 24 bit look like 32 bit\n    case 32:\n        if (sampleformat == SAMPLEFORMAT_IEEEFP)\n            m_spec.set_format(TypeDesc::FLOAT);\n        else if (sampleformat == SAMPLEFORMAT_UINT)\n            m_spec.set_format(TypeDesc::UINT32);\n        else if (sampleformat == SAMPLEFORMAT_INT)\n            m_spec.set_format(TypeDesc::INT32);\n        else\n            m_spec.set_format(TypeDesc::UNKNOWN);\n        break;\n    case 64:\n        if (sampleformat == SAMPLEFORMAT_IEEEFP)\n            m_spec.set_format(TypeDesc::DOUBLE);\n        else\n            m_spec.set_format(TypeDesc::UNKNOWN);\n        break;\n    default: m_spec.set_format(TypeDesc::UNKNOWN); break;\n    }\n\n    // Use the table for all the obvious things that can be mindlessly\n    // shoved into the image spec.\n    if (read_meta) {\n        for (const auto& tag : tag_table(\"TIFF\"))\n            find_tag(tag.tifftag, tag.tifftype, tag.name);\n        for (const auto& tag : tag_table(\"Exif\"))\n            find_tag(tag.tifftag, tag.tifftype, tag.name);\n    }\n\n    // Now we need to get fields \"by hand\" for anything else that is less\n    // straightforward...\n\n    readspec_photometric();\n\n    TIFFGetFieldDefaulted(m_tif, TIFFTAG_PLANARCONFIG, &m_planarconfig);\n    m_separate = (m_planarconfig == PLANARCONFIG_SEPARATE\n                  && m_spec.nchannels > 1\n                  && m_photometric != PHOTOMETRIC_PALETTE);\n    m_spec.attribute(\"tiff:PlanarConfiguration\", (int)m_planarconfig);\n    if (m_planarconfig == PLANARCONFIG_SEPARATE)\n        m_spec.attribute(\"planarconfig\", \"separate\");\n    else\n        m_spec.attribute(\"planarconfig\", \"contig\");\n\n    m_compression = 0;\n    TIFFGetFieldDefaulted(m_tif, TIFFTAG_COMPRESSION, &m_compression);\n    m_spec.attribute(\"tiff:Compression\", (int)m_compression);\n    if (const char* compressname = tiff_compression_name(m_compression))\n        m_spec.attribute(\"compression\", compressname);\n    m_predictor = PREDICTOR_NONE;\n    if (!safe_tiffgetfield(\"Predictor\", TIFFTAG_PREDICTOR, &m_predictor))\n        m_predictor = PREDICTOR_NONE;\n\n    m_rowsperstrip = -1;\n    if (!m_spec.tile_width) {\n        TIFFGetField(m_tif, TIFFTAG_ROWSPERSTRIP, &m_rowsperstrip);\n        if (m_rowsperstrip > 0)\n            m_spec.attribute(\"tiff:RowsPerStrip\", m_rowsperstrip);\n    }\n\n    // The libtiff docs say that only uncompressed images, or those with\n    // rowsperstrip==1, support random access to scanlines.\n    m_no_random_access = (m_compression != COMPRESSION_NONE\n                          && m_rowsperstrip != 1);\n\n    // Do we care about fillorder?  No, the TIFF spec says, \"We\n    // recommend that FillOrder=2 (lsb-to-msb) be used only in\n    // special-purpose applications\".  So OIIO will assume msb-to-lsb\n    // convention until somebody finds a TIFF file in the wild that\n    // breaks this assumption.\n\n    unsigned short* sampleinfo  = NULL;\n    unsigned short extrasamples = 0;\n    TIFFGetFieldDefaulted(m_tif, TIFFTAG_EXTRASAMPLES, &extrasamples,\n                          &sampleinfo);\n    // std::cerr << \"Extra samples = \" << extrasamples << \"\\n\";\n    bool alpha_is_unassociated = false;  // basic assumption\n    if (extrasamples) {\n        // If the TIFF ExtraSamples tag was specified, use that to figure\n        // out the meaning of alpha.\n        int colorchannels = 3;\n        if (m_photometric == PHOTOMETRIC_MINISWHITE\n            || m_photometric == PHOTOMETRIC_MINISBLACK\n            || m_photometric == PHOTOMETRIC_PALETTE\n            || m_photometric == PHOTOMETRIC_MASK)\n            colorchannels = 1;\n        for (int i = 0, c = colorchannels;\n             i < extrasamples && c < m_inputchannels; ++i, ++c) {\n            // std::cerr << \"   extra \" << i << \" \" << sampleinfo[i] << \"\\n\";\n            if (sampleinfo[i] == EXTRASAMPLE_ASSOCALPHA) {\n                // This is the alpha channel, associated as usual\n                m_spec.alpha_channel = c;\n            } else if (sampleinfo[i] == EXTRASAMPLE_UNASSALPHA) {\n                // This is the alpha channel, but color is unassociated\n                m_spec.alpha_channel  = c;\n                alpha_is_unassociated = true;\n                if (m_keep_unassociated_alpha)\n                    m_spec.attribute(\"oiio:UnassociatedAlpha\", 1);\n            } else {\n                DASSERT(sampleinfo[i] == EXTRASAMPLE_UNSPECIFIED);\n                // This extra channel is not alpha at all.  Undo any\n                // assumptions we previously made about this channel.\n                if (m_spec.alpha_channel == c) {\n                    m_spec.channelnames[c] = Strutil::sprintf(\"channel%d\", c);\n                    m_spec.alpha_channel   = -1;\n                }\n            }\n        }\n        if (m_spec.alpha_channel >= 0) {\n            m_spec.channelnames[m_spec.alpha_channel] = \"A\";\n            // Special case: \"R\",\"A\" should really be named \"Y\",\"A\", since\n            // the first channel is luminance, not red.\n            if (m_spec.nchannels == 2 && m_spec.alpha_channel == 1)\n                m_spec.channelnames[0] = \"Y\";\n        }\n    }\n    if (alpha_is_unassociated)\n        m_spec.attribute(\"tiff:UnassociatedAlpha\", 1);\n    // Will we need to do alpha conversions?\n    m_convert_alpha = (m_spec.alpha_channel >= 0 && alpha_is_unassociated\n                       && !m_keep_unassociated_alpha);\n\n    // N.B. we currently ignore the following TIFF fields:\n    // GrayResponseCurve GrayResponseUnit\n    // MaxSampleValue MinSampleValue\n    // NewSubfileType SubfileType(deprecated)\n    // Colorimetry fields\n\n    // If we've been instructed to skip reading metadata, because it is\n    // assumed to be identical to what we already have in m_spec,\n    // skip everything following.\n    if (!read_meta)\n        return;\n\n    short resunit = -1;\n    TIFFGetField(m_tif, TIFFTAG_RESOLUTIONUNIT, &resunit);\n    switch (resunit) {\n    case RESUNIT_NONE: m_spec.attribute(\"ResolutionUnit\", \"none\"); break;\n    case RESUNIT_INCH: m_spec.attribute(\"ResolutionUnit\", \"in\"); break;\n    case RESUNIT_CENTIMETER: m_spec.attribute(\"ResolutionUnit\", \"cm\"); break;\n    }\n    float xdensity = m_spec.get_float_attribute(\"XResolution\", 0.0f);\n    float ydensity = m_spec.get_float_attribute(\"YResolution\", 0.0f);\n    if (xdensity && ydensity)\n        m_spec.attribute(\"PixelAspectRatio\", ydensity / xdensity);\n\n    get_matrix_attribute(\"worldtocamera\", TIFFTAG_PIXAR_MATRIX_WORLDTOCAMERA);\n    get_matrix_attribute(\"worldtoscreen\", TIFFTAG_PIXAR_MATRIX_WORLDTOSCREEN);\n    get_int_attribute(\"tiff:subfiletype\", TIFFTAG_SUBFILETYPE);\n    // FIXME -- should subfiletype be \"conventionized\" and used for all\n    // plugins uniformly?\n\n    // Special names for shadow maps\n    char* s = NULL;\n    TIFFGetField(m_tif, TIFFTAG_PIXAR_TEXTUREFORMAT, &s);\n    if (s)\n        m_emulate_mipmap = true;\n    if (s && !strcmp(s, \"Shadow\")) {\n        for (int c = 0; c < m_spec.nchannels; ++c)\n            m_spec.channelnames[c] = \"z\";\n    }\n\n    /// read color profile\n    unsigned int icc_datasize = 0;\n    unsigned char* icc_buf    = NULL;\n    TIFFGetField(m_tif, TIFFTAG_ICCPROFILE, &icc_datasize, &icc_buf);\n    if (icc_datasize && icc_buf)\n        m_spec.attribute(ICC_PROFILE_ATTR,\n                         TypeDesc(TypeDesc::UINT8, icc_datasize), icc_buf);\n\n        // Search for an EXIF IFD in the TIFF file, and if found, rummage\n        // around for Exif fields.\n#if TIFFLIB_VERSION > 20050912 /* compat with old TIFF libs - skip Exif */\n    toff_t exifoffset = 0;\n    if (TIFFGetField(m_tif, TIFFTAG_EXIFIFD, &exifoffset)\n        && TIFFReadEXIFDirectory(m_tif, exifoffset)) {\n        for (const auto& tag : tag_table(\"Exif\"))\n            find_tag(tag.tifftag, tag.tifftype, tag.name);\n        // Look for a Makernote\n        auto makerfield = find_field(EXIF_MAKERNOTE, TIFF_UNDEFINED);\n        // std::unique_ptr<uint32_t[]> buf (new uint32_t[]);\n        if (makerfield) {\n            // bool ok = TIFFGetField (m_tif, tag, dest, &ptr);\n            unsigned int mn_datasize = 0;\n            unsigned char* mn_buf    = NULL;\n            TIFFGetField(m_tif, EXIF_MAKERNOTE, &mn_datasize, &mn_buf);\n        }\n        // I'm not sure what state TIFFReadEXIFDirectory leaves us.\n        // So to be safe, close and re-seek.\n        TIFFClose(m_tif);\n#    ifdef _WIN32\n        std::wstring wfilename = Strutil::utf8_to_utf16(m_filename);\n        m_tif                  = TIFFOpenW(wfilename.c_str(), \"rm\");\n#    else\n        m_tif = TIFFOpen(m_filename.c_str(), \"rm\");\n#    endif\n        if (m_subimage)\n            TIFFSetDirectory(m_tif, m_subimage);\n\n        // A few tidbits to look for\n        ParamValue* p;\n        if ((p = m_spec.find_attribute(\"Exif:ColorSpace\", TypeDesc::INT))) {\n            // Exif spec says that anything other than 0xffff==uncalibrated\n            // should be interpreted to be sRGB.\n            if (*(const int*)p->data() != 0xffff)\n                m_spec.attribute(\"oiio:ColorSpace\", \"sRGB\");\n        }\n    }\n#endif\n\n#if TIFFLIB_VERSION >= 20051230\n    // Search for IPTC metadata in IIM form -- but older versions of\n    // libtiff botch the size, so ignore it for very old libtiff.\n    int iptcsize         = 0;\n    const void* iptcdata = NULL;\n    if (TIFFGetField(m_tif, TIFFTAG_RICHTIFFIPTC, &iptcsize, &iptcdata)) {\n        std::vector<uint32> iptc((uint32*)iptcdata,\n                                 (uint32*)iptcdata + iptcsize);\n        if (TIFFIsByteSwapped(m_tif))\n            TIFFSwabArrayOfLong((uint32*)&iptc[0], iptcsize);\n        decode_iptc_iim(&iptc[0], iptcsize * 4, m_spec);\n    }\n#endif\n\n    // Search for an XML packet containing XMP (IPTC, Exif, etc.)\n    int xmlsize         = 0;\n    const void* xmldata = NULL;\n    if (TIFFGetField(m_tif, TIFFTAG_XMLPACKET, &xmlsize, &xmldata)) {\n        // std::cerr << \"Found XML data, size \" << xmlsize << \"\\n\";\n        if (xmldata && xmlsize) {\n            std::string xml((const char*)xmldata, xmlsize);\n            decode_xmp(xml, m_spec);\n        }\n    }\n\n#if 0\n    // Experimental -- look for photoshop data\n    int photoshopsize = 0;\n    const void *photoshopdata = NULL;\n    if (TIFFGetField (m_tif, TIFFTAG_PHOTOSHOP, &photoshopsize, &photoshopdata)) {\n        std::cerr << \"Found PHOTOSHOP data, size \" << photoshopsize << \"\\n\";\n        if (photoshopdata && photoshopsize) {\n//            std::string photoshop ((const char *)photoshopdata, photoshopsize);\n//            std::cerr << \"PHOTOSHOP:\\n\" << photoshop << \"\\n---\\n\";\n        }\n    }\n#endif\n\n    // If Software and IPTC:OriginatingProgram are identical, kill the latter\n    if (m_spec.get_string_attribute(\"Software\")\n        == m_spec.get_string_attribute(\"IPTC:OriginatingProgram\"))\n        m_spec.erase_attribute(\"IPTC:OriginatingProgram\");\n\n    std::string desc = m_spec.get_string_attribute(\"ImageDescription\");\n    // If ImageDescription and IPTC:Caption are identical, kill the latter\n    if (desc == m_spec.get_string_attribute(\"IPTC:Caption\"))\n        m_spec.erase_attribute(\"IPTC:Caption\");\n\n    // Because TIFF doesn't support arbitrary metadata, we look for certain\n    // hints in the ImageDescription and turn them into metadata, also\n    // removing them from the ImageDescrption.\n    bool updatedDesc = false;\n    auto cc = Strutil::excise_string_after_head(desc, \"oiio:ConstantColor=\");\n    if (cc.size()) {\n        m_spec.attribute(\"oiio:ConstantColor\", cc);\n        updatedDesc = true;\n    }\n    auto ac = Strutil::excise_string_after_head(desc, \"oiio:AverageColor=\");\n    if (ac.size()) {\n        m_spec.attribute(\"oiio:AverageColor\", ac);\n        updatedDesc = true;\n    }\n    std::string sha = Strutil::excise_string_after_head(desc, \"oiio:SHA-1=\");\n    if (sha.empty())  // back compatibility with OIIO < 1.5\n        sha = Strutil::excise_string_after_head(desc, \"SHA-1=\");\n    if (sha.size()) {\n        m_spec.attribute(\"oiio:SHA-1\", sha);\n        updatedDesc = true;\n    }\n\n    if (updatedDesc) {\n        string_view d(desc);\n        Strutil::skip_whitespace(d);  // erase if it's only whitespace\n        if (d.size())\n            m_spec.attribute(\"ImageDescription\", desc);\n        else\n            m_spec.erase_attribute(\"ImageDescription\");\n    }\n\n    // Squash some problematic texture metadata if we suspect it's wrong\n    pvt::check_texture_metadata_sanity(m_spec);\n\n    if (m_testopenconfig)  // open-with-config debugging\n        m_spec.attribute(\"oiio:DebugOpenConfig!\", 42);\n}\n\n\n\nvoid\nTIFFInput::readspec_photometric()\n{\n    m_photometric = (m_spec.nchannels == 1 ? PHOTOMETRIC_MINISBLACK\n                                           : PHOTOMETRIC_RGB);\n    TIFFGetField(m_tif, TIFFTAG_PHOTOMETRIC, &m_photometric);\n    m_spec.attribute(\"tiff:PhotometricInterpretation\", (int)m_photometric);\n    switch (m_photometric) {\n    case PHOTOMETRIC_SEPARATED: {\n        // Photometric \"separated\" is \"usually CMYK\".\n        m_spec.channelnames.clear();\n        short inkset       = INKSET_CMYK;\n        short numberofinks = 0;\n        TIFFGetFieldDefaulted(m_tif, TIFFTAG_INKSET, &inkset);\n        TIFFGetFieldDefaulted(m_tif, TIFFTAG_NUMBEROFINKS, &numberofinks);\n        if (inkset == INKSET_CMYK && m_spec.nchannels == 4) {\n            // True CMYK\n            m_spec.attribute(\"tiff:ColorSpace\", \"CMYK\");\n            if (m_raw_color) {\n                m_spec.channelnames.resize(4);\n                m_spec.channelnames[0] = \"C\";\n                m_spec.channelnames[1] = \"M\";\n                m_spec.channelnames[2] = \"Y\";\n                m_spec.channelnames[3] = \"K\";\n                m_spec.attribute(\"oiio:ColorSpace\", \"CMYK\");\n            } else {\n                // Silently convert to RGB\n                m_spec.nchannels = 3;\n                m_spec.default_channel_names();\n            }\n        } else {\n            // Non-CMYK ink set\n            m_spec.attribute(\"tiff:ColorSpace\", \"color separated\");\n            m_spec.attribute(\"oiio:ColorSpace\", \"color separated\");\n            m_raw_color = true;  // Conversion to RGB doesn't make sense\n            const char* inknames = NULL;\n            safe_tiffgetfield(\"tiff:InkNames\", TIFFTAG_INKNAMES, &inknames);\n            if (inknames && inknames[0] && numberofinks) {\n                m_spec.channelnames.clear();\n                // Decode the ink names, which are all concatenated together.\n                for (int i = 0; i < int(numberofinks); ++i) {\n                    string_view ink(inknames);\n                    if (ink.size()) {\n                        m_spec.channelnames.emplace_back(ink);\n                        inknames += ink.size() + 1;\n                    } else {\n                        // Run out of road\n                        numberofinks = i;\n                    }\n                }\n            } else {\n                numberofinks = 0;\n            }\n            // No ink names. Make it up.\n            for (int i = numberofinks; i < m_spec.nchannels; ++i)\n                m_spec.channelnames.emplace_back(Strutil::sprintf(\"ink%d\", i));\n        }\n        break;\n    }\n    case PHOTOMETRIC_YCBCR: m_spec.attribute(\"tiff:ColorSpace\", \"YCbCr\"); break;\n    case PHOTOMETRIC_CIELAB:\n        m_spec.attribute(\"tiff:ColorSpace\", \"CIELAB\");\n        break;\n    case PHOTOMETRIC_ICCLAB:\n        m_spec.attribute(\"tiff:ColorSpace\", \"ICCLAB\");\n        break;\n    case PHOTOMETRIC_ITULAB:\n        m_spec.attribute(\"tiff:ColorSpace\", \"ITULAB\");\n        break;\n    case PHOTOMETRIC_LOGL: m_spec.attribute(\"tiff:ColorSpace\", \"LOGL\"); break;\n    case PHOTOMETRIC_LOGLUV:\n        m_spec.attribute(\"tiff:ColorSpace\", \"LOGLUV\");\n        break;\n    case PHOTOMETRIC_PALETTE: {\n        m_spec.attribute(\"tiff:ColorSpace\", \"palette\");\n        // Read the color map\n        unsigned short *r = NULL, *g = NULL, *b = NULL;\n        TIFFGetField(m_tif, TIFFTAG_COLORMAP, &r, &g, &b);\n        ASSERT(r != NULL && g != NULL && b != NULL);\n        m_colormap.clear();\n        m_colormap.insert(m_colormap.end(), r, r + (1 << m_bitspersample));\n        m_colormap.insert(m_colormap.end(), g, g + (1 << m_bitspersample));\n        m_colormap.insert(m_colormap.end(), b, b + (1 << m_bitspersample));\n        // Palette TIFF images are always 3 channels (to the client)\n        m_spec.nchannels = 3;\n        m_spec.default_channel_names();\n        if (m_bitspersample != m_spec.format.size() * 8) {\n            // For palette images with unusual bits per sample, set\n            // oiio:BitsPerSample to the \"full\" version, to avoid problems\n            // when copying the file back to a TIFF file (we don't write\n            // palette images), but do leave \"tiff:BitsPerSample\" to reflect\n            // the original file.\n            m_spec.attribute(\"tiff:BitsPerSample\", (int)m_bitspersample);\n            m_spec.attribute(\"oiio:BitsPerSample\",\n                             (int)m_spec.format.size() * 8);\n        }\n        // FIXME - what about palette + extra (alpha?) channels?  Is that\n        // allowed?  And if so, ever encountered in the wild?\n        break;\n    }\n    }\n}\n\n\n\nbool\nTIFFInput::close()\n{\n    close_tif();\n    init();  // Reset to initial state\n    return true;\n}\n\n\n\n/// Helper: Convert n pixels from separate (RRRGGGBBB) to contiguous\n/// (RGBRGBRGB) planarconfig.\nvoid\nTIFFInput::separate_to_contig(int nplanes, int nvals,\n                              const unsigned char* separate,\n                              unsigned char* contig)\n{\n    int channelbytes = m_spec.channel_bytes();\n    for (int p = 0; p < nvals; ++p)                 // loop over pixels\n        for (int c = 0; c < nplanes; ++c)           // loop over channels\n            for (int i = 0; i < channelbytes; ++i)  // loop over data bytes\n                contig[(p * nplanes + c) * channelbytes + i]\n                    = separate[(c * nvals + p) * channelbytes + i];\n}\n\n\n\nvoid\nTIFFInput::palette_to_rgb(int n, const unsigned char* palettepels,\n                          unsigned char* rgb)\n{\n    size_t vals_per_byte = 8 / m_bitspersample;\n    size_t entries       = 1 << m_bitspersample;\n    int highest          = entries - 1;\n    DASSERT(m_spec.nchannels == 3);\n    DASSERT(m_colormap.size() == 3 * entries);\n    for (int x = 0; x < n; ++x) {\n        int i = palettepels[x / vals_per_byte];\n        i >>= (m_bitspersample * (vals_per_byte - 1 - (x % vals_per_byte)));\n        i &= highest;\n        *rgb++ = m_colormap[0 * entries + i] / 257;\n        *rgb++ = m_colormap[1 * entries + i] / 257;\n        *rgb++ = m_colormap[2 * entries + i] / 257;\n    }\n}\n\n\n\nvoid\nTIFFInput::bit_convert(int n, const unsigned char* in, int inbits, void* out,\n                       int outbits)\n{\n    ASSERT(inbits >= 1 && inbits < 32);  // surely bugs if not\n    uint32_t highest = (1 << inbits) - 1;\n    int B = 0, b = 0;\n    // Invariant:\n    // So far, we have used in[0..B-1] and the high b bits of in[B].\n    for (int i = 0; i < n; ++i) {\n        long long val = 0;\n        int valbits   = 0;  // bits so far we've accumulated in val\n        while (valbits < inbits) {\n            // Invariant: we have already accumulated valbits of the next\n            // needed value (of a total of inbits), living in the valbits\n            // low bits of val.\n            int out_left = inbits - valbits;  // How much more we still need\n            int in_left  = 8 - b;             // Bits still available in in[B].\n            if (in_left <= out_left) {\n                // Eat the rest of this byte:\n                //   |---------|--------|\n                //        b      in_left\n                val <<= in_left;\n                val |= in[B] & ~(0xffffffff << in_left);\n                ++B;\n                b = 0;\n                valbits += in_left;\n            } else {\n                // Eat just the bits we need:\n                //   |--|---------|-----|\n                //     b  out_left  extra\n                val <<= out_left;\n                int extra = 8 - b - out_left;\n                val |= (in[B] >> extra) & ~(0xffffffff << out_left);\n                b += out_left;\n                valbits = inbits;\n            }\n        }\n        if (outbits == 8)\n            ((unsigned char*)out)[i] = (unsigned char)((val * 0xff) / highest);\n        else if (outbits == 16)\n            ((unsigned short*)out)[i] = (unsigned short)((val * 0xffff)\n                                                         / highest);\n        else\n            ((unsigned int*)out)[i] = (unsigned int)((val * 0xffffffff)\n                                                     / highest);\n    }\n}\n\n\n\nvoid\nTIFFInput::invert_photometric(int n, void* data)\n{\n    switch (m_spec.format.basetype) {\n    case TypeDesc::UINT8: {\n        unsigned char* d = (unsigned char*)data;\n        for (int i = 0; i < n; ++i)\n            d[i] = 255 - d[i];\n        break;\n    }\n    default: break;\n    }\n}\n\n\n\ntemplate<typename T>\nstatic void\ncmyk_to_rgb(int n, const T* cmyk, size_t cmyk_stride, T* rgb, size_t rgb_stride)\n{\n    for (; n; --n, cmyk += cmyk_stride, rgb += rgb_stride) {\n        float C = convert_type<T, float>(cmyk[0]);\n        float M = convert_type<T, float>(cmyk[1]);\n        float Y = convert_type<T, float>(cmyk[2]);\n        float K = convert_type<T, float>(cmyk[3]);\n        float R = (1.0f - C) * (1.0f - K);\n        float G = (1.0f - M) * (1.0f - K);\n        float B = (1.0f - Y) * (1.0f - K);\n        rgb[0]  = convert_type<float, T>(R);\n        rgb[1]  = convert_type<float, T>(G);\n        rgb[2]  = convert_type<float, T>(B);\n    }\n}\n\n\n\nbool\nTIFFInput::read_native_scanline(int subimage, int miplevel, int y, int z,\n                                void* data)\n{\n    lock_guard lock(m_mutex);\n    if (!seek_subimage(subimage, miplevel))\n        return false;\n    y -= m_spec.y;\n\n    if (m_use_rgba_interface) {\n        // We punted and used the RGBA image interface -- copy from buffer.\n        // libtiff has no way to read just one scanline as RGBA. So we\n        // buffer the whole image.\n        if (!m_rgbadata.size()) {  // first time through: allocate & read\n            m_rgbadata.resize(m_spec.width * m_spec.height * m_spec.depth);\n            bool ok = TIFFReadRGBAImageOriented(m_tif, m_spec.width,\n                                                m_spec.height, &m_rgbadata[0],\n                                                ORIENTATION_TOPLEFT, 0);\n            if (!ok) {\n                error(\"Unknown error trying to read TIFF as RGBA\");\n                return false;\n            }\n        }\n        copy_image(m_spec.nchannels, m_spec.width, 1, 1,\n                   &m_rgbadata[y * m_spec.width], m_spec.nchannels, 4,\n                   4 * m_spec.width, AutoStride, data, m_spec.nchannels,\n                   m_spec.width * m_spec.nchannels, AutoStride);\n        return true;\n    }\n\n    // Make sure there's enough scratch space\n    int nvals = m_spec.width * m_inputchannels;\n    m_scratch.resize(nvals * m_spec.format.size());\n\n    // For compression modes that don't support random access to scanlines\n    // (which I *think* is only LZW), we need to emulate random access by\n    // re-seeking.\n    if (m_no_random_access) {\n        if (m_next_scanline > y) {\n            // User is trying to read an earlier scanline than the one we're\n            // up to.  Easy fix: start over.\n            // FIXME: I'm too tired to look into it now, but I wonder if\n            // it is able to randomly seek to the first line in any\n            // \"strip\", in which case we don't need to start from 0, just\n            // start from the beginning of the strip we need.\n            ImageSpec dummyspec;\n            int old_subimage = current_subimage();\n            int old_miplevel = current_miplevel();\n            // We need to close the TIFF file s that we can re-open and\n            // seek back to the beginning of this subimage. The close_tif()\n            // accomplishes that. It's important not to do a full close()\n            // here, because that would also call init() to fully reset\n            // to a fresh ImageInput, thus forgetting any configuration\n            // settings such as raw_color or keep_unassociated_alpha.\n            close_tif();\n            if (!open(m_filename, dummyspec)\n                || !seek_subimage(old_subimage, old_miplevel)) {\n                return false;  // Somehow, the re-open failed\n            }\n            ASSERT(m_next_scanline == 0 && current_subimage() == old_subimage\n                   && current_miplevel() == old_miplevel);\n        }\n        while (m_next_scanline < y) {\n            // Keep reading until we're read the scanline we really need\n            if (TIFFReadScanline(m_tif, &m_scratch[0], m_next_scanline) < 0) {\n                error(\"%s\", oiio_tiff_last_error());\n                return false;\n            }\n            ++m_next_scanline;\n        }\n    }\n    m_next_scanline = y + 1;\n\n    bool need_bit_convert = (m_bitspersample != 8 && m_bitspersample != 16\n                             && m_bitspersample != 32);\n    if (m_photometric == PHOTOMETRIC_PALETTE) {\n        // Convert from palette to RGB\n        if (TIFFReadScanline(m_tif, &m_scratch[0], y) < 0) {\n            error(\"%s\", oiio_tiff_last_error());\n            return false;\n        }\n        palette_to_rgb(m_spec.width, &m_scratch[0], (unsigned char*)data);\n        return true;\n    }\n    // Not palette...\n\n    int plane_bytes = m_spec.width * m_spec.format.size();\n    int planes      = m_separate ? m_inputchannels : 1;\n    int input_bytes = plane_bytes * m_inputchannels;\n    // Where to read?  Directly into user data if no channel shuffling, bit\n    // shifting, or CMYK conversion is needed, otherwise into scratch space.\n    unsigned char* readbuf = (unsigned char*)data;\n    if (need_bit_convert || m_separate\n        || (m_photometric == PHOTOMETRIC_SEPARATED && !m_raw_color))\n        readbuf = &m_scratch[0];\n    // Perform the reads.  Note that for contig, planes==1, so it will\n    // only do one TIFFReadScanline.\n    for (int c = 0; c < planes; ++c) { /* planes==1 for contig */\n        if (TIFFReadScanline(m_tif, &readbuf[plane_bytes * c], y, c) < 0) {\n            error(\"%s\", oiio_tiff_last_error());\n            return false;\n        }\n    }\n\n    // Handle less-than-full bit depths\n    if (m_bitspersample < 8) {\n        // m_scratch now holds nvals n-bit values, contig or separate\n        m_scratch2.resize(input_bytes);\n        m_scratch.swap(m_scratch2);\n        for (int c = 0; c < planes; ++c) /* planes==1 for contig */\n            bit_convert(m_separate ? m_spec.width : nvals,\n                        &m_scratch2[plane_bytes * c], m_bitspersample,\n                        m_separate ? &m_scratch[plane_bytes * c]\n                                   : (unsigned char*)data + plane_bytes * c,\n                        8);\n    } else if (m_bitspersample > 8 && m_bitspersample < 16) {\n        // m_scratch now holds nvals n-bit values, contig or separate\n        m_scratch2.resize(input_bytes);\n        m_scratch.swap(m_scratch2);\n        for (int c = 0; c < planes; ++c) /* planes==1 for contig */\n            bit_convert(m_separate ? m_spec.width : nvals,\n                        &m_scratch2[plane_bytes * c], m_bitspersample,\n                        m_separate ? &m_scratch[plane_bytes * c]\n                                   : (unsigned char*)data + plane_bytes * c,\n                        16);\n    } else if (m_bitspersample > 16 && m_bitspersample < 32) {\n        // m_scratch now holds nvals n-bit values, contig or separate\n        m_scratch2.resize(input_bytes);\n        m_scratch.swap(m_scratch2);\n        for (int c = 0; c < planes; ++c) /* planes==1 for contig */\n            bit_convert(m_separate ? m_spec.width : nvals,\n                        &m_scratch2[plane_bytes * c], m_bitspersample,\n                        m_separate ? &m_scratch[plane_bytes * c]\n                                   : (unsigned char*)data + plane_bytes * c,\n                        32);\n    }\n\n    // Handle \"separate\" planarconfig\n    if (m_separate) {\n        // Convert from separate (RRRGGGBBB) to contiguous (RGBRGBRGB).\n        // We know the data is in m_scratch at this point, so\n        // contiguize it into the user data area.\n        if (m_photometric == PHOTOMETRIC_SEPARATED && !m_raw_color) {\n            // CMYK->RGB means we need temp storage.\n            m_scratch2.resize(input_bytes);\n            separate_to_contig(planes, m_spec.width, &m_scratch[0],\n                               &m_scratch2[0]);\n            m_scratch.swap(m_scratch2);\n        } else {\n            // If no CMYK->RGB conversion is necessary, we can \"separate\"\n            // straight into the data area.\n            separate_to_contig(planes, m_spec.width, &m_scratch[0],\n                               (unsigned char*)data);\n        }\n    }\n\n    // Handle CMYK\n    if (m_photometric == PHOTOMETRIC_SEPARATED && !m_raw_color) {\n        // The CMYK will be in m_scratch.\n        if (spec().format == TypeDesc::UINT8) {\n            cmyk_to_rgb(m_spec.width, (unsigned char*)&m_scratch[0],\n                        m_inputchannels, (unsigned char*)data,\n                        m_spec.nchannels);\n        } else if (spec().format == TypeDesc::UINT16) {\n            cmyk_to_rgb(m_spec.width, (unsigned short*)&m_scratch[0],\n                        m_inputchannels, (unsigned short*)data,\n                        m_spec.nchannels);\n        } else {\n            error(\"CMYK only supported for UINT8, UINT16\");\n            return false;\n        }\n    }\n\n    if (m_photometric == PHOTOMETRIC_MINISWHITE)\n        invert_photometric(nvals, data);\n\n    return true;\n}\n\n\n\nbool\nTIFFInput::read_native_scanlines(int subimage, int miplevel, int ybegin,\n                                 int yend, int z, void* data)\n{\n    // If the stars all align properly, try to read strips, and use the\n    // thread pool to parallelize the decompression. This can give a large\n    // speedup (5x or more!) because the zip decompression dwarfs the\n    // actual raw I/O. But libtiff is totally serialized, so we can only\n    // parallelize by reading raw (compressed) strips then making calls to\n    // zlib ourselves to decompress. Don't bother trying to handle any of\n    // the uncommon cases with strips. This covers most real-world cases.\n    lock_guard lock(m_mutex);\n    if (!seek_subimage(subimage, miplevel))\n        return false;\n    yend        = std::min(yend, spec().y + spec().height);\n    int nstrips = (yend - ybegin + m_rowsperstrip - 1) / m_rowsperstrip;\n\n    // See if it's easy to read this scanline range as strips. For edge\n    // cases we don't with to deal with here, we just call the base class\n    // read_native_scanlines, which in turn will loop over each scanline in\n    // the range to call our read_native_scanline, which does handle the\n    // full range of cases.\n    bool read_as_strips =\n        // we're reading more than one scanline\n        (yend - ybegin) > 1  // no advantage to strips for single scanlines\n        // scanline range must be complete strips\n        && is_strip_boundary(ybegin)\n        && is_strip_boundary(yend)\n        // and not palette or cmyk color separated conversions\n        && (m_photometric != PHOTOMETRIC_SEPARATED\n            && m_photometric != PHOTOMETRIC_PALETTE)\n        // no non-multiple-of-8 bits per sample\n        && (spec().format.size() * 8 == m_bitspersample)\n        // No other unusual cases\n        && !m_use_rgba_interface;\n    if (!read_as_strips) {\n        // Punt and call the base class, which loops over scanlines.\n        return ImageInput::read_native_scanlines(subimage, miplevel, ybegin,\n                                                 yend, z, data);\n    }\n\n    // Are we reading raw (compressed) strips and doing the decompression\n    // ourselves?\n    bool read_raw_strips =\n        // only deflate/zip compression\n        (m_compression\n         == COMPRESSION_ADOBE_DEFLATE /*|| m_compression == COMPRESSION_NONE*/)\n        // only horizontal predictor (or none)\n        && (m_predictor == PREDICTOR_HORIZONTAL\n            || m_predictor == PREDICTOR_NONE)\n        // contig planarconfig only (for now?)\n        && !m_separate\n        // only uint8, uint16\n        && (m_spec.format == TypeUInt8 || m_spec.format == TypeUInt16);\n\n    // We know we wish to read as strips. But additionally, there are some\n    // circumstances in which we want to read RAW strips, and do the\n    // decompression ourselves, which we can feed to the thread pool to\n    // perform in parallel.\n    thread_pool* pool = default_thread_pool();\n    bool parallelize =\n        // and more than one, or no point parallelizing\n        nstrips > 1\n        // only if we are reading scanlines in order\n        && ybegin == m_next_scanline\n        // only if we're threading and don't enter the thread pool recursively!\n        && pool->size() > 1\n        && !pool->this_thread_is_in_pool()\n        // and not if the feature is turned off\n        && m_spec.get_int_attribute(\"tiff:multithread\",\n                                    OIIO::get_int_attribute(\"tiff:multithread\"));\n\n    // Make room for, and read the raw (still compressed) strips. As each\n    // one is read, kick off the decompress and any other extras, to execute\n    // in parallel.\n    task_set tasks(pool);\n    bool ok        = true;  // failed compression will stash a false here\n    int y          = ybegin;\n    size_t ystride = m_spec.scanline_bytes(true);\n    int stripchans = m_separate ? 1 : m_spec.nchannels;  // chans in each strip\n    int planes     = m_separate ? m_spec.nchannels : 1;  // color planes\n        // N.B. \"separate\" planarconfig stores only one channel in a strip\n    int stripvals = m_spec.width * stripchans\n                    * m_rowsperstrip;  // values in a strip\n    imagesize_t strip_bytes = stripvals * m_spec.format.size();\n    size_t cbound           = compressBound((uLong)strip_bytes);\n    std::unique_ptr<char[]> compressed_scratch;\n    std::unique_ptr<char[]> separate_tmp(\n        m_separate ? new char[strip_bytes * nstrips * planes] : nullptr);\n\n    if (read_raw_strips) {\n        // Make room for, and read the raw (still compressed) strips. As each\n        // one is read, kick off the decompress and any other extras, to execute\n        // in parallel.\n        compressed_scratch.reset(new char[cbound * nstrips * planes]);\n        for (size_t stripidx = 0; y + m_rowsperstrip <= yend;\n             y += m_rowsperstrip, ++stripidx) {\n            char* cbuf        = compressed_scratch.get() + stripidx * cbound;\n            tstrip_t stripnum = (y - m_spec.y) / m_rowsperstrip;\n            tsize_t csize;\n            if (read_raw_strips) {\n                csize = TIFFReadRawStrip(m_tif, stripnum, cbuf,\n                                         tmsize_t(cbound));\n            } else {\n                csize = TIFFReadEncodedStrip(m_tif, stripnum, data,\n                                             tmsize_t(strip_bytes));\n            }\n            if (csize < 0) {\n                std::string err = oiio_tiff_last_error();\n                error(\"TIFFRead%sStrip failed reading line y=%d,z=%d: %s\",\n                      read_raw_strips ? \"Raw\" : \"Encoded\", y, z,\n                      err.size() ? err.c_str() : \"unknown error\");\n                ok = false;\n            }\n            auto uncompress_etc = [=, &ok](int id) {\n                if (read_raw_strips)\n                    uncompress_one_strip(cbuf, (unsigned long)csize, data,\n                                         strip_bytes, this->m_spec.nchannels,\n                                         this->m_spec.width, m_rowsperstrip,\n                                         m_compression, &ok);\n                if (m_photometric == PHOTOMETRIC_MINISWHITE)\n                    invert_photometric(stripvals * stripchans, data);\n            };\n            if (parallelize) {\n                // Push the rest of the work onto the thread pool queue\n                tasks.push(pool->push(uncompress_etc));\n            } else {\n                uncompress_etc(0);\n            }\n            data = (char*)data + strip_bytes * planes;\n        }\n\n    } else {\n        // One of the cases where we don't bother reading raw, we read\n        // encoded strips. Still can be a lot more efficient than reading\n        // individual scanlines. This is the clause that has to handle\n        // \"separate\" planarconfig.\n        int strips_in_file = (m_spec.height + m_rowsperstrip - 1)\n                             / m_rowsperstrip;\n        for (size_t stripidx = 0; y + m_rowsperstrip <= yend;\n             y += m_rowsperstrip, ++stripidx) {\n            for (int c = 0; c < planes; ++c) {\n                tstrip_t stripnum = ((y - m_spec.y) / m_rowsperstrip)\n                                    + c * strips_in_file;\n                tsize_t csize = TIFFReadEncodedStrip(m_tif, stripnum,\n                                                     (char*)data\n                                                         + c * strip_bytes,\n                                                     tmsize_t(strip_bytes));\n                if (csize < 0) {\n                    std::string err = oiio_tiff_last_error();\n                    error(\n                        \"TIFFReadEncodedStrip failed reading line y=%d,z=%d: %s\",\n                        y, z, err.size() ? err.c_str() : \"unknown error\");\n                    ok = false;\n                }\n            }\n            if (m_photometric == PHOTOMETRIC_MINISWHITE)\n                invert_photometric(stripvals * planes, data);\n            if (m_separate) {\n                // handle \"separate\" planarconfig: copy to temp area, then\n                // separate_to_contig it back.\n                char* sepbuf = separate_tmp.get()\n                               + stripidx * strip_bytes * planes;\n                memcpy(sepbuf, data, strip_bytes * planes);\n                separate_to_contig(planes, m_spec.width * m_rowsperstrip,\n                                   (unsigned char*)sepbuf,\n                                   (unsigned char*)data);\n            }\n            data = (char*)data + strip_bytes * planes;\n        }\n    }\n\n    // If we have left over scanlines, read them serially\n    m_next_scanline = y;\n    for (; y < yend; ++y) {\n        bool ok = read_native_scanline(subimage, miplevel, y, z, data);\n        if (!ok)\n            return false;\n        data = (char*)data + ystride;\n    }\n    tasks.wait();\n    return true;\n}\n\n\n\nbool\nTIFFInput::read_native_tile(int subimage, int miplevel, int x, int y, int z,\n                            void* data)\n{\n    lock_guard lock(m_mutex);\n    if (!seek_subimage(subimage, miplevel))\n        return false;\n    x -= m_spec.x;\n    y -= m_spec.y;\n\n    if (m_use_rgba_interface) {\n        // We punted and used the RGBA image interface\n        // libtiff has a call to read just one tile as RGBA. So that's all\n        // we need to do, not buffer the whole image.\n        m_rgbadata.resize(m_spec.tile_pixels() * 4);\n        bool ok = TIFFReadRGBATile(m_tif, x, y, &m_rgbadata[0]);\n        if (!ok) {\n            error(\"Unknown error trying to read TIFF as RGBA\");\n            return false;\n        }\n        // Copy, and use stride magic to reverse top-to-bottom\n        int tw = std::min(m_spec.tile_width, m_spec.width - x);\n        int th = std::min(m_spec.tile_height, m_spec.height - y);\n        copy_image(m_spec.nchannels, tw, th, 1,\n                   &m_rgbadata[(th - 1) * m_spec.tile_width], m_spec.nchannels,\n                   4, -m_spec.tile_width * 4, AutoStride, data,\n                   m_spec.nchannels, m_spec.nchannels * m_spec.tile_width,\n                   AutoStride);\n        return true;\n    }\n\n    imagesize_t tile_pixels = m_spec.tile_pixels();\n    imagesize_t nvals       = tile_pixels * m_spec.nchannels;\n    m_scratch.resize(m_spec.tile_bytes());\n    bool no_bit_convert = (m_bitspersample == 8 || m_bitspersample == 16\n                           || m_bitspersample == 32);\n    if (m_photometric == PHOTOMETRIC_PALETTE) {\n        // Convert from palette to RGB\n        if (TIFFReadTile(m_tif, &m_scratch[0], x, y, z, 0) < 0) {\n            error(\"%s\", oiio_tiff_last_error());\n            return false;\n        }\n        palette_to_rgb(tile_pixels, &m_scratch[0], (unsigned char*)data);\n    } else {\n        // Not palette\n        imagesize_t plane_bytes = m_spec.tile_pixels() * m_spec.format.size();\n        int planes              = m_separate ? m_spec.nchannels : 1;\n        std::vector<unsigned char> scratch2(m_separate ? m_spec.tile_bytes()\n                                                       : 0);\n        // Where to read?  Directly into user data if no channel shuffling\n        // or bit shifting is needed, otherwise into scratch space.\n        unsigned char* readbuf = (no_bit_convert && !m_separate)\n                                     ? (unsigned char*)data\n                                     : &m_scratch[0];\n        // Perform the reads.  Note that for contig, planes==1, so it will\n        // only do one TIFFReadTile.\n        for (int c = 0; c < planes; ++c) /* planes==1 for contig */\n            if (TIFFReadTile(m_tif, &readbuf[plane_bytes * c], x, y, z, c)\n                < 0) {\n                error(\"%s\", oiio_tiff_last_error());\n                return false;\n            }\n        if (m_bitspersample < 8) {\n            // m_scratch now holds nvals n-bit values, contig or separate\n            std::swap(m_scratch, scratch2);\n            for (int c = 0; c < planes; ++c) /* planes==1 for contig */\n                bit_convert(m_separate ? tile_pixels : nvals,\n                            &scratch2[plane_bytes * c], m_bitspersample,\n                            m_separate ? &m_scratch[plane_bytes * c]\n                                       : (unsigned char*)data + plane_bytes * c,\n                            8);\n        } else if (m_bitspersample > 8 && m_bitspersample < 16) {\n            // m_scratch now holds nvals n-bit values, contig or separate\n            std::swap(m_scratch, scratch2);\n            for (int c = 0; c < planes; ++c) /* planes==1 for contig */\n                bit_convert(m_separate ? tile_pixels : nvals,\n                            &scratch2[plane_bytes * c], m_bitspersample,\n                            m_separate ? &m_scratch[plane_bytes * c]\n                                       : (unsigned char*)data + plane_bytes * c,\n                            16);\n        }\n        if (m_separate) {\n            // Convert from separate (RRRGGGBBB) to contiguous (RGBRGBRGB).\n            // We know the data is in m_scratch at this point, so\n            // contiguize it into the user data area.\n            separate_to_contig(planes, tile_pixels, &m_scratch[0],\n                               (unsigned char*)data);\n        }\n    }\n\n    if (m_photometric == PHOTOMETRIC_MINISWHITE)\n        invert_photometric(nvals, data);\n\n    return true;\n}\n\n\n\nbool\nTIFFInput::read_native_tiles(int subimage, int miplevel, int xbegin, int xend,\n                             int ybegin, int yend, int zbegin, int zend,\n                             void* data)\n{\n    lock_guard lock(m_mutex);\n    if (!seek_subimage(subimage, miplevel))\n        return false;\n    if (!m_spec.valid_tile_range(xbegin, xend, ybegin, yend, zbegin, zend))\n        return false;\n\n    // If the stars all align properly, use the thread pool to parallelize\n    // the decompression. This can give a large speedup (5x or more!)\n    // because the zip decompression dwarfs the actual raw I/O. But libtiff\n    // is totally serialized, so we can only parallelize by making calls to\n    // zlib ourselves and then writing \"raw\" (compressed) strips. Don't\n    // bother trying to handle any of the uncommon cases with strips. This\n    // covers most real-world cases.\n    thread_pool* pool = default_thread_pool();\n    ASSERT(m_spec.tile_depth >= 1);\n    size_t ntiles = size_t(\n        (xend - xbegin + m_spec.tile_width - 1) / m_spec.tile_width\n        * (yend - ybegin + m_spec.tile_height - 1) / m_spec.tile_height\n        * (zend - zbegin + m_spec.tile_depth - 1) / m_spec.tile_depth);\n    bool parallelize =\n        // more than one tile, or no point parallelizing\n        ntiles > 1\n        // and not palette or cmyk color separated conversions\n        && (m_photometric != PHOTOMETRIC_SEPARATED\n            && m_photometric != PHOTOMETRIC_PALETTE)\n        // no non-multiple-of-8 bits per sample\n        && (spec().format.size() * 8 == m_bitspersample)\n        // contig planarconfig only (for now?)\n        && !m_separate\n        // only deflate/zip compression with horizontal predictor\n        && m_compression == COMPRESSION_ADOBE_DEFLATE\n        && m_predictor == PREDICTOR_HORIZONTAL\n        // only uint8, uint16\n        && (m_spec.format == TypeUInt8 || m_spec.format == TypeUInt16)\n        // No other unusual cases\n        && !m_use_rgba_interface\n        // only if we're threading and don't enter the thread pool recursively!\n        && pool->size() > 1\n        && !pool->this_thread_is_in_pool()\n        // and not if the feature is turned off\n        && m_spec.get_int_attribute(\"tiff:multithread\",\n                                    OIIO::get_int_attribute(\"tiff:multithread\"));\n\n    // If we're not parallelizing, just call the parent class default\n    // implementaiton of read_native_tiles, which will loop over the tiles\n    // and read each one individually.\n    if (!parallelize) {\n        return ImageInput::read_native_tiles(subimage, miplevel, xbegin, xend,\n                                             ybegin, yend, zbegin, zend, data);\n    }\n\n    // Make room for, and read the raw (still compressed) tiles. As each one\n    // is read, kick off the decompress and any other extras, to execute in\n    // parallel.\n    stride_t pixel_bytes   = (stride_t)m_spec.pixel_bytes(true);\n    stride_t tileystride   = pixel_bytes * m_spec.tile_width;\n    stride_t tilezstride   = tileystride * m_spec.tile_height;\n    stride_t ystride       = (xend - xbegin) * pixel_bytes;\n    stride_t zstride       = (yend - ybegin) * ystride;\n    imagesize_t tile_bytes = m_spec.tile_bytes(true);\n    int tilevals           = m_spec.tile_pixels() * m_spec.nchannels;\n    size_t cbound          = compressBound((uLong)tile_bytes);\n    std::unique_ptr<char[]> compressed_scratch(new char[cbound * ntiles]);\n    std::unique_ptr<char[]> scratch(new char[tile_bytes * ntiles]);\n    task_set tasks(pool);\n    bool ok = true;  // failed compression will stash a false here\n\n    // Strutil::printf (\"Parallel tile case %d %d  %d %d  %d %d\\n\",\n    //                  xbegin, xend, ybegin, yend, zbegin, zend);\n    size_t tileidx = 0;\n    for (int z = zbegin; z < zend; z += m_spec.tile_depth) {\n        for (int y = ybegin; y < yend; y += m_spec.tile_height) {\n            for (int x = xbegin; x < xend; x += m_spec.tile_width, ++tileidx) {\n                char* cbuf = compressed_scratch.get() + tileidx * cbound;\n                char* ubuf = scratch.get() + tileidx * tile_bytes;\n                auto csize = TIFFReadRawTile(m_tif, tile_index(x, y, z), cbuf,\n                                             tmsize_t(cbound));\n                if (csize < 0) {\n                    std::string err = oiio_tiff_last_error();\n                    error(\n                        \"TIFFReadRawTile failed reading tile x=%d,y=%d,z=%d: %s\",\n                        x, y, z, err.size() ? err.c_str() : \"unknown error\");\n                    return false;\n                }\n                // Push the rest of the work onto the thread pool queue\n                tasks.push(pool->push([=, &ok](int id) {\n                    uncompress_one_strip(cbuf, (unsigned long)csize, ubuf,\n                                         tile_bytes, this->m_spec.nchannels,\n                                         this->m_spec.tile_width,\n                                         this->m_spec.tile_height\n                                             * this->m_spec.tile_depth,\n                                         m_compression, &ok);\n                    if (m_photometric == PHOTOMETRIC_MINISWHITE)\n                        invert_photometric(tilevals, ubuf);\n                    copy_image(this->m_spec.nchannels, this->m_spec.tile_width,\n                               this->m_spec.tile_height,\n                               this->m_spec.tile_depth, ubuf,\n                               size_t(pixel_bytes), pixel_bytes, tileystride,\n                               tilezstride,\n                               (char*)data + (z - zbegin) * zstride\n                                   + (y - ybegin) * ystride\n                                   + (x - xbegin) * pixel_bytes,\n                               pixel_bytes, ystride, zstride);\n                }));\n            }\n        }\n    }\n    return ok;\n}\n\n\n\nbool\nTIFFInput::read_scanline(int y, int z, TypeDesc format, void* data,\n                         stride_t xstride)\n{\n    bool ok = ImageInput::read_scanline(y, z, format, data, xstride);\n    if (ok && m_convert_alpha) {\n        // If alpha is unassociated and we aren't requested to keep it that\n        // way, multiply the colors by alpha per the usual OIIO conventions\n        // to deliver associated color & alpha.  Any auto-premultiplication\n        // by alpha should happen after we've already done data format\n        // conversions. That's why we do it here, rather than in\n        // read_native_blah.\n        {\n            lock_guard lock(m_mutex);\n            if (format\n                == TypeUnknown)  // unknown means retrieve the native type\n                format = m_spec.format;\n        }\n        OIIO::premult(m_spec.nchannels, m_spec.width, 1, 1, 0 /*chbegin*/,\n                      m_spec.nchannels /*chend*/, format, data, xstride,\n                      AutoStride, AutoStride, m_spec.alpha_channel,\n                      m_spec.z_channel);\n    }\n    return ok;\n}\n\n\n\nbool\nTIFFInput::read_scanlines(int subimage, int miplevel, int ybegin, int yend,\n                          int z, int chbegin, int chend, TypeDesc format,\n                          void* data, stride_t xstride, stride_t ystride)\n{\n    bool ok = ImageInput::read_scanlines(subimage, miplevel, ybegin, yend, z,\n                                         chbegin, chend, format, data, xstride,\n                                         ystride);\n    if (ok && m_convert_alpha) {\n        // If alpha is unassociated and we aren't requested to keep it that\n        // way, multiply the colors by alpha per the usual OIIO conventions\n        // to deliver associated color & alpha.  Any auto-premultiplication\n        // by alpha should happen after we've already done data format\n        // conversions. That's why we do it here, rather than in\n        // read_native_blah.\n        int nchannels, alpha_channel, z_channel, width;\n        {\n            lock_guard lock(m_mutex);\n            seek_subimage(subimage, miplevel);\n            nchannels     = m_spec.nchannels;\n            alpha_channel = m_spec.alpha_channel;\n            z_channel     = m_spec.z_channel;\n            width         = m_spec.width;\n            if (format == TypeUnknown)  // unknown == native type\n                format = m_spec.format;\n        }\n        // NOTE: if the channel range we read doesn't include the alpha\n        // channel, we don't have the alpha data to do the premult, so skip\n        // this. Pity the hapless soul who tries to read only the first\n        // three channels of an RGBA file with unassociated alpha. They will\n        // not get the premultiplication they deserve.\n        if (alpha_channel >= chbegin && alpha_channel < chend)\n            OIIO::premult(nchannels, width, yend - ybegin, 1, chbegin, chend,\n                          format, data, xstride, ystride, AutoStride,\n                          alpha_channel, z_channel);\n    }\n    return ok;\n}\n\n\n\nbool\nTIFFInput::read_tile(int x, int y, int z, TypeDesc format, void* data,\n                     stride_t xstride, stride_t ystride, stride_t zstride)\n{\n    bool ok = ImageInput::read_tile(x, y, z, format, data, xstride, ystride,\n                                    zstride);\n    if (ok && m_convert_alpha) {\n        // If alpha is unassociated and we aren't requested to keep it that\n        // way, multiply the colors by alpha per the usual OIIO conventions\n        // to deliver associated color & alpha.  Any auto-premultiplication\n        // by alpha should happen after we've already done data format\n        // conversions. That's why we do it here, rather than in\n        // read_native_blah.\n        {\n            lock_guard lock(m_mutex);\n            if (format\n                == TypeUnknown)  // unknown means retrieve the native type\n                format = m_spec.format;\n        }\n        OIIO::premult(m_spec.nchannels, m_spec.tile_width, m_spec.tile_height,\n                      std::max(1, m_spec.tile_depth), 0, m_spec.nchannels,\n                      format, data, xstride, ystride, zstride,\n                      m_spec.alpha_channel, m_spec.z_channel);\n    }\n    return ok;\n}\n\n\n\nbool\nTIFFInput::read_tiles(int subimage, int miplevel, int xbegin, int xend,\n                      int ybegin, int yend, int zbegin, int zend, int chbegin,\n                      int chend, TypeDesc format, void* data, stride_t xstride,\n                      stride_t ystride, stride_t zstride)\n{\n    bool ok = ImageInput::read_tiles(subimage, miplevel, xbegin, xend, ybegin,\n                                     yend, zbegin, zend, chbegin, chend, format,\n                                     data, xstride, ystride, zstride);\n    if (ok && m_convert_alpha) {\n        // If alpha is unassociated and we aren't requested to keep it that\n        // way, multiply the colors by alpha per the usual OIIO conventions\n        // to deliver associated color & alpha.  Any auto-premultiplication\n        // by alpha should happen after we've already done data format\n        // conversions. That's why we do it here, rather than in\n        // read_native_blah.\n        int nchannels, alpha_channel, z_channel;\n        {\n            lock_guard lock(m_mutex);\n            seek_subimage(subimage, miplevel);\n            nchannels     = m_spec.nchannels;\n            alpha_channel = m_spec.alpha_channel;\n            z_channel     = m_spec.z_channel;\n            if (format == TypeUnknown)  // unknown == native type\n                format = m_spec.format;\n        }\n        // NOTE: if the channel range we read doesn't include the alpha\n        // channel, we don't have the alpha data to do the premult, so skip\n        // this. Pity the hapless soul who tries to read only the first\n        // three channels of an RGBA file with unassociated alpha. They will\n        // not get the premultiplication they deserve.\n        if (alpha_channel >= chbegin && alpha_channel < chend)\n            OIIO::premult(nchannels, xend - xbegin, yend - ybegin,\n                          zend - zbegin, chbegin, chend, format, data, xstride,\n                          ystride, zstride, alpha_channel, z_channel);\n    }\n    return ok;\n}\n\nOIIO_PLUGIN_NAMESPACE_END\n",
                "name": "tiffinput.cpp",
                "path": "oiio/src/tiff.imageio/tiffinput.cpp",
                "url": "/github.com/luanfujun/Langevin-MCMC/-/blob/oiio/src/tiff.imageio/tiffinput.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 1772,
                    "offsetAndLengths": [
                        [
                            18,
                            16
                        ]
                    ],
                    "preview": "        bool ok = TIFFReadRGBATile(m_tif, x, y, &m_rgbadata[0]);"
                }
            ],
            "repository": {
                "name": "github.com/luanfujun/Langevin-MCMC",
                "url": "/github.com/luanfujun/Langevin-MCMC"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "99f18a15a06855dc5ba764679a1d75bfd0d2e782"
                },
                "content": "/*M///////////////////////////////////////////////////////////////////////////////////////\n//\n//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.\n//\n//  By downloading, copying, installing or using the software you agree to this license.\n//  If you do not agree to this license, do not download, install,\n//  copy or use the software.\n//\n//\n//                           License Agreement\n//                For Open Source Computer Vision Library\n//\n// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.\n// Copyright (C) 2009, Willow Garage Inc., all rights reserved.\n// Third party copyrights are property of their respective owners.\n//\n// Redistribution and use in source and binary forms, with or without modification,\n// are permitted provided that the following conditions are met:\n//\n//   * Redistribution's of source code must retain the above copyright notice,\n//     this list of conditions and the following disclaimer.\n//\n//   * Redistribution's in binary form must reproduce the above copyright notice,\n//     this list of conditions and the following disclaimer in the documentation\n//     and/or other materials provided with the distribution.\n//\n//   * The name of the copyright holders may not be used to endorse or promote products\n//     derived from this software without specific prior written permission.\n//\n// This software is provided by the copyright holders and contributors \"as is\" and\n// any express or implied warranties, including, but not limited to, the implied\n// warranties of merchantability and fitness for a particular purpose are disclaimed.\n// In no event shall the Intel Corporation or contributors be liable for any direct,\n// indirect, incidental, special, exemplary, or consequential damages\n// (including, but not limited to, procurement of substitute goods or services;\n// loss of use, data, or profits; or business interruption) however caused\n// and on any theory of liability, whether in contract, strict liability,\n// or tort (including negligence or otherwise) arising in any way out of\n// the use of this software, even if advised of the possibility of such damage.\n//\n//M*/\n\n/****************************************************************************************\\\n    A part of the file implements TIFF reader on base of libtiff library\n    (see otherlibs/_graphics/readme.txt for copyright notice)\n\\****************************************************************************************/\n\n#include \"precomp.hpp\"\n\n#ifdef HAVE_TIFF\n#include \"grfmt_tiff.hpp\"\n#include <limits>\n\n// TODO FIXIT Conflict declarations for common types like int64/uint64\nnamespace tiff_dummy_namespace {\n#include \"tiff.h\"\n#include \"tiffio.h\"\n}\nusing namespace tiff_dummy_namespace;\n\nnamespace cv\n{\n\n\nstatic const char fmtSignTiffII[] = \"II\\x2a\\x00\";\nstatic const char fmtSignTiffMM[] = \"MM\\x00\\x2a\";\n\nstatic int grfmt_tiff_err_handler_init = 0;\nstatic void GrFmtSilentTIFFErrorHandler( const char*, const char*, va_list ) {}\n\nTiffDecoder::TiffDecoder()\n{\n    m_tif = 0;\n    if( !grfmt_tiff_err_handler_init )\n    {\n        grfmt_tiff_err_handler_init = 1;\n\n        TIFFSetErrorHandler( GrFmtSilentTIFFErrorHandler );\n        TIFFSetWarningHandler( GrFmtSilentTIFFErrorHandler );\n    }\n    m_hdr = false;\n    m_buf_supported = true;\n    m_buf_pos = 0;\n}\n\n\nvoid TiffDecoder::close()\n{\n    if( m_tif )\n    {\n        TIFF* tif = (TIFF*)m_tif;\n        TIFFClose( tif );\n        m_tif = 0;\n    }\n}\n\nTiffDecoder::~TiffDecoder()\n{\n    close();\n}\n\nsize_t TiffDecoder::signatureLength() const\n{\n    return 4;\n}\n\nbool TiffDecoder::checkSignature( const String& signature ) const\n{\n    return signature.size() >= 4 &&\n        (memcmp(signature.c_str(), fmtSignTiffII, 4) == 0 ||\n        memcmp(signature.c_str(), fmtSignTiffMM, 4) == 0);\n}\n\nint TiffDecoder::normalizeChannelsNumber(int channels) const\n{\n    return channels > 4 ? 4 : channels;\n}\n\nImageDecoder TiffDecoder::newDecoder() const\n{\n    return makePtr<TiffDecoder>();\n}\n\nclass TiffDecoderBufHelper\n{\n    Mat& m_buf;\n    size_t& m_buf_pos;\npublic:\n    TiffDecoderBufHelper(Mat& buf, size_t& buf_pos) :\n        m_buf(buf), m_buf_pos(buf_pos)\n    {}\n    static tmsize_t read( thandle_t handle, void* buffer, tmsize_t n )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        const Mat& buf = helper->m_buf;\n        const tmsize_t size = buf.cols*buf.rows*buf.elemSize();\n        tmsize_t pos = helper->m_buf_pos;\n        if ( n > (size - pos) )\n        {\n            n = size - pos;\n        }\n        memcpy(buffer, buf.ptr() + pos, n);\n        helper->m_buf_pos += n;\n        return n;\n    }\n\n    static tmsize_t write( thandle_t /*handle*/, void* /*buffer*/, tmsize_t /*n*/ )\n    {\n        // Not used for decoding.\n        return 0;\n    }\n\n    static toff_t seek( thandle_t handle, toff_t offset, int whence )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        const Mat& buf = helper->m_buf;\n        const toff_t size = buf.cols*buf.rows*buf.elemSize();\n        toff_t new_pos = helper->m_buf_pos;\n        switch (whence)\n        {\n            case SEEK_SET:\n                new_pos = offset;\n                break;\n            case SEEK_CUR:\n                new_pos += offset;\n                break;\n            case SEEK_END:\n                new_pos = size + offset;\n                break;\n        }\n        new_pos = std::min(new_pos, size);\n        helper->m_buf_pos = (size_t)new_pos;\n        return new_pos;\n    }\n\n    static int map( thandle_t handle, void** base, toff_t* size )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        Mat& buf = helper->m_buf;\n        *base = buf.ptr();\n        *size = buf.cols*buf.rows*buf.elemSize();\n        return 0;\n    }\n\n    static toff_t size( thandle_t handle )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        const Mat& buf = helper->m_buf;\n        return buf.cols*buf.rows*buf.elemSize();\n    }\n\n    static int close( thandle_t handle )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        delete helper;\n        return 0;\n    }\n};\n\nbool TiffDecoder::readHeader()\n{\n    bool result = false;\n\n    TIFF* tif = static_cast<TIFF*>(m_tif);\n    if (!m_tif)\n    {\n        // TIFFOpen() mode flags are different to fopen().  A 'b' in mode \"rb\" has no effect when reading.\n        // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n        if ( !m_buf.empty() )\n        {\n            m_buf_pos = 0;\n            TiffDecoderBufHelper* buf_helper = new TiffDecoderBufHelper(this->m_buf, this->m_buf_pos);\n            tif = TIFFClientOpen( \"\", \"r\", reinterpret_cast<thandle_t>(buf_helper), &TiffDecoderBufHelper::read,\n                                  &TiffDecoderBufHelper::write, &TiffDecoderBufHelper::seek,\n                                  &TiffDecoderBufHelper::close, &TiffDecoderBufHelper::size,\n                                  &TiffDecoderBufHelper::map, /*unmap=*/0 );\n        }\n        else\n        {\n            tif = TIFFOpen(m_filename.c_str(), \"r\");\n        }\n    }\n\n    if( tif )\n    {\n        uint32 wdth = 0, hght = 0;\n        uint16 photometric = 0;\n        m_tif = tif;\n\n        if( TIFFGetField( tif, TIFFTAG_IMAGEWIDTH, &wdth ) &&\n            TIFFGetField( tif, TIFFTAG_IMAGELENGTH, &hght ) &&\n            TIFFGetField( tif, TIFFTAG_PHOTOMETRIC, &photometric ))\n        {\n            uint16 bpp=8, ncn = photometric > 1 ? 3 : 1;\n            TIFFGetField( tif, TIFFTAG_BITSPERSAMPLE, &bpp );\n            TIFFGetField( tif, TIFFTAG_SAMPLESPERPIXEL, &ncn );\n\n            m_width = wdth;\n            m_height = hght;\n            if((bpp == 32 && ncn == 3) || photometric == PHOTOMETRIC_LOGLUV)\n            {\n                m_type = CV_32FC3;\n                m_hdr = true;\n                return true;\n            }\n            m_hdr = false;\n\n            if( bpp > 8 &&\n               ((photometric > 2) ||\n                (ncn != 1 && ncn != 3 && ncn != 4)))\n                bpp = 8;\n\n            int wanted_channels = normalizeChannelsNumber(ncn);\n            switch(bpp)\n            {\n                case 1:\n                    m_type = CV_MAKETYPE(CV_8U, photometric > 1 ? wanted_channels : 1);\n                    result = true;\n                    break;\n                case 8:\n                    m_type = CV_MAKETYPE(CV_8U, photometric > 1 ? wanted_channels : 1);\n                    result = true;\n                    break;\n                case 16:\n                    m_type = CV_MAKETYPE(CV_16U, photometric > 1 ? wanted_channels : 1);\n                    result = true;\n                    break;\n                case 32:\n                    m_type = CV_MAKETYPE(CV_32F, photometric > 1 ? 3 : 1);\n                    result = true;\n                    break;\n                case 64:\n                    m_type = CV_MAKETYPE(CV_64F, photometric > 1 ? 3 : 1);\n                    result = true;\n                    break;\n            default:\n                CV_Error(cv::Error::StsError, \"Invalid bitsperpixel value read from TIFF header! Must be 1, 8, 16, 32 or 64.\");\n            }\n        }\n    }\n\n    if( !result )\n        close();\n\n    return result;\n}\n\nbool TiffDecoder::nextPage()\n{\n    // Prepare the next page, if any.\n    return m_tif &&\n           TIFFReadDirectory(static_cast<TIFF*>(m_tif)) &&\n           readHeader();\n}\n\nbool  TiffDecoder::readData( Mat& img )\n{\n    if(m_hdr && img.type() == CV_32FC3)\n    {\n        return readData_32FC3(img);\n    }\n    if(img.type() == CV_32FC1)\n    {\n        return readData_32FC1(img);\n    }\n    bool result = false;\n    bool color = img.channels() > 1;\n\n    if( img.depth() != CV_8U && img.depth() != CV_16U && img.depth() != CV_32F && img.depth() != CV_64F )\n        return false;\n\n    if( m_tif && m_width && m_height )\n    {\n        TIFF* tif = (TIFF*)m_tif;\n        uint32 tile_width0 = m_width, tile_height0 = 0;\n        int x, y, i;\n        int is_tiled = TIFFIsTiled(tif);\n        uint16 photometric;\n        TIFFGetField( tif, TIFFTAG_PHOTOMETRIC, &photometric );\n        uint16 bpp = 8, ncn = photometric > 1 ? 3 : 1;\n        TIFFGetField( tif, TIFFTAG_BITSPERSAMPLE, &bpp );\n        TIFFGetField( tif, TIFFTAG_SAMPLESPERPIXEL, &ncn );\n        uint16 img_orientation = ORIENTATION_TOPLEFT;\n        TIFFGetField( tif, TIFFTAG_ORIENTATION, &img_orientation);\n        bool vert_flip = (img_orientation == ORIENTATION_BOTRIGHT) || (img_orientation == ORIENTATION_RIGHTBOT) ||\n                         (img_orientation == ORIENTATION_BOTLEFT) || (img_orientation == ORIENTATION_LEFTBOT);\n        const int bitsPerByte = 8;\n        int dst_bpp = (int)(img.elemSize1() * bitsPerByte);\n        int wanted_channels = normalizeChannelsNumber(img.channels());\n\n        if(dst_bpp == 8)\n        {\n            char errmsg[1024];\n            if(!TIFFRGBAImageOK( tif, errmsg ))\n            {\n                close();\n                return false;\n            }\n        }\n\n        if( (!is_tiled) ||\n            (is_tiled &&\n            TIFFGetField( tif, TIFFTAG_TILEWIDTH, &tile_width0 ) &&\n            TIFFGetField( tif, TIFFTAG_TILELENGTH, &tile_height0 )))\n        {\n            if(!is_tiled)\n                TIFFGetField( tif, TIFFTAG_ROWSPERSTRIP, &tile_height0 );\n\n            if( tile_width0 <= 0 )\n                tile_width0 = m_width;\n\n            if( tile_height0 <= 0 ||\n               (!is_tiled && tile_height0 == std::numeric_limits<uint32>::max()) )\n                tile_height0 = m_height;\n\n            if(dst_bpp == 8) {\n                // we will use TIFFReadRGBA* functions, so allocate temporary buffer for 32bit RGBA\n                bpp = 8;\n                ncn = 4;\n            }\n            const size_t buffer_size = (bpp/bitsPerByte) * ncn * tile_height0 * tile_width0;\n            AutoBuffer<uchar> _buffer( buffer_size );\n            uchar* buffer = _buffer.data();\n            ushort* buffer16 = (ushort*)buffer;\n            float* buffer32 = (float*)buffer;\n            double* buffer64 = (double*)buffer;\n            int tileidx = 0;\n\n            for( y = 0; y < m_height; y += tile_height0 )\n            {\n                int tile_height = tile_height0;\n\n                if( y + tile_height > m_height )\n                    tile_height = m_height - y;\n\n                uchar* data = img.ptr(vert_flip ? m_height - y - tile_height : y);\n\n                for( x = 0; x < m_width; x += tile_width0, tileidx++ )\n                {\n                    int tile_width = tile_width0, ok;\n\n                    if( x + tile_width > m_width )\n                        tile_width = m_width - x;\n\n                    switch(dst_bpp)\n                    {\n                        case 8:\n                        {\n                            uchar * bstart = buffer;\n                            if( !is_tiled )\n                                ok = TIFFReadRGBAStrip( tif, y, (uint32*)buffer );\n                            else\n                            {\n                                ok = TIFFReadRGBATile( tif, x, y, (uint32*)buffer );\n                                //Tiles fill the buffer from the bottom up\n                                bstart += (tile_height0 - tile_height) * tile_width0 * 4;\n                            }\n                            if( !ok )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                                if( color )\n                                {\n                                    if (wanted_channels == 4)\n                                    {\n                                        icvCvt_BGRA2RGBA_8u_C4R( bstart + i*tile_width0*4, 0,\n                                                             data + x*4 + img.step*(tile_height - i - 1), 0,\n                                                             Size(tile_width,1) );\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2BGR_8u_C4C3R( bstart + i*tile_width0*4, 0,\n                                                             data + x*3 + img.step*(tile_height - i - 1), 0,\n                                                             Size(tile_width,1), 2 );\n                                    }\n                                }\n                                else\n                                    icvCvt_BGRA2Gray_8u_C4C1R( bstart + i*tile_width0*4, 0,\n                                                              data + x + img.step*(tile_height - i - 1), 0,\n                                                              Size(tile_width,1), 2 );\n                            break;\n                        }\n\n                        case 16:\n                        {\n                            if( !is_tiled )\n                                ok = (int)TIFFReadEncodedStrip( tif, tileidx, (uint32*)buffer, buffer_size ) >= 0;\n                            else\n                                ok = (int)TIFFReadEncodedTile( tif, tileidx, (uint32*)buffer, buffer_size ) >= 0;\n\n                            if( !ok )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                            {\n                                if( color )\n                                {\n                                    if( ncn == 1 )\n                                    {\n                                        icvCvt_Gray2BGR_16u_C1C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                                  (ushort*)(data + img.step*i) + x*3, 0,\n                                                                  Size(tile_width,1) );\n                                    }\n                                    else if( ncn == 3 )\n                                    {\n                                        icvCvt_RGB2BGR_16u_C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                               (ushort*)(data + img.step*i) + x*3, 0,\n                                                               Size(tile_width,1) );\n                                    }\n                                    else if (ncn == 4)\n                                    {\n                                        if (wanted_channels == 4)\n                                        {\n                                            icvCvt_BGRA2RGBA_16u_C4R(buffer16 + i*tile_width0*ncn, 0,\n                                                (ushort*)(data + img.step*i) + x * 4, 0,\n                                                Size(tile_width, 1));\n                                        }\n                                        else\n                                        {\n                                            icvCvt_BGRA2BGR_16u_C4C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                (ushort*)(data + img.step*i) + x * 3, 0,\n                                                Size(tile_width, 1), 2);\n                                        }\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2BGR_16u_C4C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                               (ushort*)(data + img.step*i) + x*3, 0,\n                                                               Size(tile_width,1), 2 );\n                                    }\n                                }\n                                else\n                                {\n                                    if( ncn == 1 )\n                                    {\n                                        memcpy((ushort*)(data + img.step*i)+x,\n                                               buffer16 + i*tile_width0*ncn,\n                                               tile_width*sizeof(buffer16[0]));\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2Gray_16u_CnC1R(buffer16 + i*tile_width0*ncn, 0,\n                                                               (ushort*)(data + img.step*i) + x, 0,\n                                                               Size(tile_width,1), ncn, 2 );\n                                    }\n                                }\n                            }\n                            break;\n                        }\n\n                        case 32:\n                        case 64:\n                        {\n                            if( !is_tiled )\n                                ok = (int)TIFFReadEncodedStrip( tif, tileidx, buffer, buffer_size ) >= 0;\n                            else\n                                ok = (int)TIFFReadEncodedTile( tif, tileidx, buffer, buffer_size ) >= 0;\n\n                            if( !ok || ncn != 1 )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                            {\n                                if(dst_bpp == 32)\n                                {\n                                    memcpy((float*)(data + img.step*i)+x,\n                                           buffer32 + i*tile_width0*ncn,\n                                           tile_width*sizeof(buffer32[0]));\n                                }\n                                else\n                                {\n                                    memcpy((double*)(data + img.step*i)+x,\n                                         buffer64 + i*tile_width0*ncn,\n                                         tile_width*sizeof(buffer64[0]));\n                                }\n                            }\n\n                            break;\n                        }\n                        default:\n                        {\n                            close();\n                            return false;\n                        }\n                    }\n                }\n            }\n\n            result = true;\n        }\n    }\n\n    return result;\n}\n\nbool TiffDecoder::readData_32FC3(Mat& img)\n{\n    int rows_per_strip = 0, photometric = 0;\n    if(!m_tif)\n    {\n        return false;\n    }\n    TIFF *tif = static_cast<TIFF*>(m_tif);\n    TIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &rows_per_strip);\n    TIFFGetField( tif, TIFFTAG_PHOTOMETRIC, &photometric );\n    TIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_FLOAT);\n    int size = 3 * m_width * m_height * sizeof (float);\n    tstrip_t strip_size = 3 * m_width * rows_per_strip;\n    float *ptr = img.ptr<float>();\n    for (tstrip_t i = 0; i < TIFFNumberOfStrips(tif); i++, ptr += strip_size)\n    {\n        TIFFReadEncodedStrip(tif, i, ptr, size);\n        size -= strip_size * sizeof(float);\n    }\n    close();\n    if(photometric == PHOTOMETRIC_LOGLUV)\n    {\n        cvtColor(img, img, COLOR_XYZ2BGR);\n    }\n    else\n    {\n        cvtColor(img, img, COLOR_RGB2BGR);\n    }\n    return true;\n}\n\nbool TiffDecoder::readData_32FC1(Mat& img)\n{\n    if(!m_tif)\n    {\n        return false;\n    }\n    TIFF *tif = static_cast<TIFF*>(m_tif);\n\n    uint32 img_width, img_height;\n    TIFFGetField(tif,TIFFTAG_IMAGEWIDTH, &img_width);\n    TIFFGetField(tif,TIFFTAG_IMAGELENGTH, &img_height);\n    if(img.size() != Size(img_width,img_height))\n    {\n        close();\n        return false;\n    }\n    tsize_t scanlength = TIFFScanlineSize(tif);\n    tdata_t buf = _TIFFmalloc(scanlength);\n    float* data;\n    bool result = true;\n    for (uint32 row = 0; row < img_height; row++)\n    {\n        if (TIFFReadScanline(tif, buf, row) != 1)\n        {\n            result = false;\n            break;\n        }\n        data=(float*)buf;\n        for (uint32 i=0; i<img_width; i++)\n        {\n            img.at<float>(row,i) = data[i];\n        }\n    }\n    _TIFFfree(buf);\n    close();\n\n    return result;\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////\n\nTiffEncoder::TiffEncoder()\n{\n    m_description = \"TIFF Files (*.tiff;*.tif)\";\n    m_buf_supported = true;\n}\n\nTiffEncoder::~TiffEncoder()\n{\n}\n\nImageEncoder TiffEncoder::newEncoder() const\n{\n    return makePtr<TiffEncoder>();\n}\n\nbool TiffEncoder::isFormatSupported( int depth ) const\n{\n    return depth == CV_8U || depth == CV_16U || depth == CV_32F;\n}\n\nvoid  TiffEncoder::writeTag( WLByteStream& strm, TiffTag tag,\n                             TiffFieldType fieldType,\n                             int count, int value )\n{\n    strm.putWord( tag );\n    strm.putWord( fieldType );\n    strm.putDWord( count );\n    strm.putDWord( value );\n}\n\nclass TiffEncoderBufHelper\n{\npublic:\n\n    TiffEncoderBufHelper(std::vector<uchar> *buf)\n            : m_buf(buf), m_buf_pos(0)\n    {}\n\n    TIFF* open ()\n    {\n        return TIFFClientOpen( \"\", \"w\", reinterpret_cast<thandle_t>(this), &TiffEncoderBufHelper::read,\n                               &TiffEncoderBufHelper::write, &TiffEncoderBufHelper::seek,\n                               &TiffEncoderBufHelper::close, &TiffEncoderBufHelper::size,\n                               /*map=*/0, /*unmap=*/0 );\n    }\n\n    static tmsize_t read( thandle_t /*handle*/, void* /*buffer*/, tmsize_t /*n*/ )\n    {\n        // Not used for encoding.\n        return 0;\n    }\n\n    static tmsize_t write( thandle_t handle, void* buffer, tmsize_t n )\n    {\n        TiffEncoderBufHelper *helper = reinterpret_cast<TiffEncoderBufHelper*>(handle);\n        size_t begin = (size_t)helper->m_buf_pos;\n        size_t end = begin + n;\n        if ( helper->m_buf->size() < end )\n        {\n            helper->m_buf->resize(end);\n        }\n        memcpy(&(*helper->m_buf)[begin], buffer, n);\n        helper->m_buf_pos = end;\n        return n;\n    }\n\n    static toff_t seek( thandle_t handle, toff_t offset, int whence )\n    {\n        TiffEncoderBufHelper *helper = reinterpret_cast<TiffEncoderBufHelper*>(handle);\n        const toff_t size = helper->m_buf->size();\n        toff_t new_pos = helper->m_buf_pos;\n        switch (whence)\n        {\n            case SEEK_SET:\n                new_pos = offset;\n                break;\n            case SEEK_CUR:\n                new_pos += offset;\n                break;\n            case SEEK_END:\n                new_pos = size + offset;\n                break;\n        }\n        helper->m_buf_pos = new_pos;\n        return new_pos;\n    }\n\n    static toff_t size( thandle_t handle )\n    {\n        TiffEncoderBufHelper *helper = reinterpret_cast<TiffEncoderBufHelper*>(handle);\n        return helper->m_buf->size();\n    }\n\n    static int close( thandle_t /*handle*/ )\n    {\n        // Do nothing.\n        return 0;\n    }\n\nprivate:\n\n    std::vector<uchar>* m_buf;\n    toff_t m_buf_pos;\n};\n\nstatic void readParam(const std::vector<int>& params, int key, int& value)\n{\n    for(size_t i = 0; i + 1 < params.size(); i += 2)\n        if(params[i] == key)\n        {\n            value = params[i+1];\n            break;\n        }\n}\n\nbool TiffEncoder::writeLibTiff( const std::vector<Mat>& img_vec, const std::vector<int>& params)\n{\n    // do NOT put \"wb\" as the mode, because the b means \"big endian\" mode, not \"binary\" mode.\n    // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n    TIFF* pTiffHandle;\n\n    TiffEncoderBufHelper buf_helper(m_buf);\n    if ( m_buf )\n    {\n        pTiffHandle = buf_helper.open();\n    }\n    else\n    {\n        pTiffHandle = TIFFOpen(m_filename.c_str(), \"w\");\n    }\n    if (!pTiffHandle)\n    {\n        return false;\n    }\n\n    //Settings that matter to all images\n    // defaults for now, maybe base them on params in the future\n    int compression = COMPRESSION_LZW;\n    int predictor = PREDICTOR_HORIZONTAL;\n    int resUnit = -1, dpiX = -1, dpiY = -1;\n\n    readParam(params, TIFFTAG_COMPRESSION, compression);\n    readParam(params, TIFFTAG_PREDICTOR, predictor);\n    readParam(params, IMWRITE_TIFF_RESUNIT, resUnit);\n    readParam(params, IMWRITE_TIFF_XDPI, dpiX);\n    readParam(params, IMWRITE_TIFF_YDPI, dpiY);\n\n    //Iterate through each image in the vector and write them out as Tiff directories\n    for (size_t page = 0; page < img_vec.size(); page++)\n    {\n        const Mat& img = img_vec[page];\n        int channels = img.channels();\n        int width = img.cols, height = img.rows;\n        int depth = img.depth();\n\n        int bitsPerChannel = -1;\n        switch (depth)\n        {\n            case CV_8U:\n            {\n                bitsPerChannel = 8;\n                break;\n            }\n            case CV_16U:\n            {\n                bitsPerChannel = 16;\n                break;\n            }\n            default:\n            {\n                TIFFClose(pTiffHandle);\n                return false;\n            }\n        }\n\n        const int bitsPerByte = 8;\n        size_t fileStep = (width * channels * bitsPerChannel) / bitsPerByte;\n\n        int rowsPerStrip = (int)((1 << 13) / fileStep);\n        readParam(params, TIFFTAG_ROWSPERSTRIP, rowsPerStrip);\n\n        if (rowsPerStrip < 1)\n            rowsPerStrip = 1;\n\n        if (rowsPerStrip > height)\n            rowsPerStrip = height;\n\n        int   colorspace = channels > 1 ? PHOTOMETRIC_RGB : PHOTOMETRIC_MINISBLACK;\n\n        if (!TIFFSetField(pTiffHandle, TIFFTAG_IMAGEWIDTH, width)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_IMAGELENGTH, height)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_BITSPERSAMPLE, bitsPerChannel)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_COMPRESSION, compression)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_PHOTOMETRIC, colorspace)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_SAMPLESPERPIXEL, channels)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_ROWSPERSTRIP, rowsPerStrip)\n            || (img_vec.size() > 1 && (\n               !TIFFSetField(pTiffHandle, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_PAGENUMBER, page, img_vec.size() )))\n            )\n        {\n            TIFFClose(pTiffHandle);\n            return false;\n        }\n\n        if (compression != COMPRESSION_NONE && !TIFFSetField(pTiffHandle, TIFFTAG_PREDICTOR, predictor))\n        {\n            TIFFClose(pTiffHandle);\n            return false;\n        }\n\n        if (((resUnit >= RESUNIT_NONE && resUnit <= RESUNIT_CENTIMETER) && !TIFFSetField(pTiffHandle, TIFFTAG_RESOLUTIONUNIT, resUnit))\n            || (dpiX >= 0 && !TIFFSetField(pTiffHandle, TIFFTAG_XRESOLUTION, (float)dpiX))\n            || (dpiY >= 0 && !TIFFSetField(pTiffHandle, TIFFTAG_YRESOLUTION, (float)dpiY))\n            )\n        {\n            TIFFClose(pTiffHandle);\n            return false;\n        }\n\n\n        // row buffer, because TIFFWriteScanline modifies the original data!\n        size_t scanlineSize = TIFFScanlineSize(pTiffHandle);\n        AutoBuffer<uchar> _buffer(scanlineSize + 32);\n        uchar* buffer = _buffer.data();\n        if (!buffer)\n        {\n            TIFFClose(pTiffHandle);\n            return false;\n        }\n\n        for (int y = 0; y < height; ++y)\n        {\n            switch (channels)\n            {\n                case 1:\n                {\n                    memcpy(buffer, img.ptr(y), scanlineSize);\n                    break;\n                }\n\n                case 3:\n                {\n                    if (depth == CV_8U)\n                        icvCvt_BGR2RGB_8u_C3R( img.ptr(y), 0, buffer, 0, Size(width, 1));\n                    else\n                        icvCvt_BGR2RGB_16u_C3R( img.ptr<ushort>(y), 0, (ushort*)buffer, 0, Size(width, 1));\n                    break;\n                }\n\n                case 4:\n                {\n                    if (depth == CV_8U)\n                        icvCvt_BGRA2RGBA_8u_C4R( img.ptr(y), 0, buffer, 0, Size(width, 1));\n                    else\n                        icvCvt_BGRA2RGBA_16u_C4R( img.ptr<ushort>(y), 0, (ushort*)buffer, 0, Size(width, 1));\n                    break;\n                }\n\n                default:\n                {\n                    TIFFClose(pTiffHandle);\n                    return false;\n                }\n            }\n\n            int writeResult = TIFFWriteScanline(pTiffHandle, buffer, y, 0);\n            if (writeResult != 1)\n            {\n                TIFFClose(pTiffHandle);\n                return false;\n            }\n        }\n\n        TIFFWriteDirectory(pTiffHandle);\n\n    }\n\n    TIFFClose(pTiffHandle);\n    return true;\n}\n\nbool TiffEncoder::write_32FC3(const Mat& _img)\n{\n    Mat img;\n    cvtColor(_img, img, COLOR_BGR2XYZ);\n\n    TIFF* tif;\n\n    TiffEncoderBufHelper buf_helper(m_buf);\n    if ( m_buf )\n    {\n        tif = buf_helper.open();\n    }\n    else\n    {\n        tif = TIFFOpen(m_filename.c_str(), \"w\");\n    }\n\n    if (!tif)\n    {\n        return false;\n    }\n    TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, img.cols);\n    TIFFSetField(tif, TIFFTAG_IMAGELENGTH, img.rows);\n    TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 3);\n    TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_SGILOG);\n    TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_LOGLUV);\n    TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    TIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_FLOAT);\n    TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, 1);\n    int strip_size = 3 * img.cols;\n    float *ptr = const_cast<float*>(img.ptr<float>());\n    for (int i = 0; i < img.rows; i++, ptr += strip_size)\n    {\n        TIFFWriteEncodedStrip(tif, i, ptr, strip_size * sizeof(float));\n    }\n    TIFFClose(tif);\n    return true;\n}\n\nbool TiffEncoder::write_32FC1(const Mat& _img)\n{\n\n    TIFF* tif;\n\n    TiffEncoderBufHelper buf_helper(m_buf);\n    if ( m_buf )\n    {\n        tif = buf_helper.open();\n    }\n    else\n    {\n        tif = TIFFOpen(m_filename.c_str(), \"w\");\n    }\n\n    if (!tif)\n    {\n        return false;\n    }\n\n    TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, _img.cols);\n    TIFFSetField(tif, TIFFTAG_IMAGELENGTH, _img.rows);\n    TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 1);\n    TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 32);\n    TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n    TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);\n    TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n    for (uint32 row = 0; row < (uint32)_img.rows; row++)\n    {\n        if (TIFFWriteScanline(tif, (tdata_t)_img.ptr<float>(row), row, 1) != 1)\n        {\n            TIFFClose(tif);\n            return false;\n        }\n    }\n    TIFFWriteDirectory(tif);\n    TIFFClose(tif);\n\n    return true;\n}\n\nbool TiffEncoder::writemulti(const std::vector<Mat>& img_vec, const std::vector<int>& params)\n{\n    return writeLibTiff(img_vec, params);\n}\n\nbool  TiffEncoder::write( const Mat& img, const std::vector<int>& params)\n{\n    int depth = img.depth();\n\n    if(img.type() == CV_32FC3)\n    {\n        return write_32FC3(img);\n    }\n    if(img.type() == CV_32FC1)\n    {\n        return write_32FC1(img);\n    }\n\n    CV_Assert(depth == CV_8U || depth == CV_16U);\n\n    std::vector<Mat> img_vec;\n    img_vec.push_back(img);\n    return writeLibTiff(img_vec, params);\n}\n\n} // namespace\n\n#endif\n",
                "name": "grfmt_tiff.cpp",
                "path": "opencv_src/modules/imgcodecs/src/grfmt_tiff.cpp",
                "url": "/github.com/latsic/imgalign/-/blob/opencv_src/modules/imgcodecs/src/grfmt_tiff.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 393,
                    "offsetAndLengths": [
                        [
                            37,
                            16
                        ]
                    ],
                    "preview": "                                ok = TIFFReadRGBATile( tif, x, y, (uint32*)buffer );"
                }
            ],
            "repository": {
                "name": "github.com/latsic/imgalign",
                "url": "/github.com/latsic/imgalign"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "a55ea2fdc5ff05560e14ab66e9c7b8abb1ea3960"
                },
                "content": "/*M///////////////////////////////////////////////////////////////////////////////////////\n//\n//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.\n//\n//  By downloading, copying, installing or using the software you agree to this license.\n//  If you do not agree to this license, do not download, install,\n//  copy or use the software.\n//\n//\n//                           License Agreement\n//                For Open Source Computer Vision Library\n//\n// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.\n// Copyright (C) 2009, Willow Garage Inc., all rights reserved.\n// Third party copyrights are property of their respective owners.\n//\n// Redistribution and use in source and binary forms, with or without modification,\n// are permitted provided that the following conditions are met:\n//\n//   * Redistribution's of source code must retain the above copyright notice,\n//     this list of conditions and the following disclaimer.\n//\n//   * Redistribution's in binary form must reproduce the above copyright notice,\n//     this list of conditions and the following disclaimer in the documentation\n//     and/or other materials provided with the distribution.\n//\n//   * The name of the copyright holders may not be used to endorse or promote products\n//     derived from this software without specific prior written permission.\n//\n// This software is provided by the copyright holders and contributors \"as is\" and\n// any express or implied warranties, including, but not limited to, the implied\n// warranties of merchantability and fitness for a particular purpose are disclaimed.\n// In no event shall the Intel Corporation or contributors be liable for any direct,\n// indirect, incidental, special, exemplary, or consequential damages\n// (including, but not limited to, procurement of substitute goods or services;\n// loss of use, data, or profits; or business interruption) however caused\n// and on any theory of liability, whether in contract, strict liability,\n// or tort (including negligence or otherwise) arising in any way out of\n// the use of this software, even if advised of the possibility of such damage.\n//\n//M*/\n\n/****************************************************************************************\\\n    A part of the file implements TIFF reader on base of libtiff library\n    (see otherlibs/_graphics/readme.txt for copyright notice)\n\\****************************************************************************************/\n\n#include \"precomp.hpp\"\n#include \"grfmt_tiff.hpp\"\n#include <opencv2/imgproc.hpp>\n\nnamespace cv\n{\nstatic const char fmtSignTiffII[] = \"II\\x2a\\x00\";\nstatic const char fmtSignTiffMM[] = \"MM\\x00\\x2a\";\n\n#ifdef HAVE_TIFF\n\n#include \"tiff.h\"\n#include \"tiffio.h\"\n\nstatic int grfmt_tiff_err_handler_init = 0;\nstatic void GrFmtSilentTIFFErrorHandler( const char*, const char*, va_list ) {}\n\nTiffDecoder::TiffDecoder()\n{\n    m_tif = 0;\n    if( !grfmt_tiff_err_handler_init )\n    {\n        grfmt_tiff_err_handler_init = 1;\n\n        TIFFSetErrorHandler( GrFmtSilentTIFFErrorHandler );\n        TIFFSetWarningHandler( GrFmtSilentTIFFErrorHandler );\n    }\n    m_hdr = false;\n}\n\n\nvoid TiffDecoder::close()\n{\n    if( m_tif )\n    {\n        TIFF* tif = (TIFF*)m_tif;\n        TIFFClose( tif );\n        m_tif = 0;\n    }\n}\n\nTiffDecoder::~TiffDecoder()\n{\n    close();\n}\n\nsize_t TiffDecoder::signatureLength() const\n{\n    return 4;\n}\n\nbool TiffDecoder::checkSignature( const String& signature ) const\n{\n    return signature.size() >= 4 &&\n        (memcmp(signature.c_str(), fmtSignTiffII, 4) == 0 ||\n        memcmp(signature.c_str(), fmtSignTiffMM, 4) == 0);\n}\n\nint TiffDecoder::normalizeChannelsNumber(int channels) const\n{\n    return channels > 4 ? 4 : channels;\n}\n\nImageDecoder TiffDecoder::newDecoder() const\n{\n    return makePtr<TiffDecoder>();\n}\n\nbool TiffDecoder::readHeader()\n{\n    bool result = false;\n\n    close();\n    // TIFFOpen() mode flags are different to fopen().  A 'b' in mode \"rb\" has no effect when reading.\n    // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n    TIFF* tif = TIFFOpen( m_filename.c_str(), \"r\" );\n\n    if( tif )\n    {\n        uint32 wdth = 0, hght = 0;\n        uint16 photometric = 0;\n        m_tif = tif;\n\n        if( TIFFGetField( tif, TIFFTAG_IMAGEWIDTH, &wdth ) &&\n            TIFFGetField( tif, TIFFTAG_IMAGELENGTH, &hght ) &&\n            TIFFGetField( tif, TIFFTAG_PHOTOMETRIC, &photometric ))\n        {\n            uint16 bpp=8, ncn = photometric > 1 ? 3 : 1;\n            TIFFGetField( tif, TIFFTAG_BITSPERSAMPLE, &bpp );\n            TIFFGetField( tif, TIFFTAG_SAMPLESPERPIXEL, &ncn );\n\n            m_width = wdth;\n            m_height = hght;\n            if((bpp == 32 && ncn == 3) || photometric == PHOTOMETRIC_LOGLUV)\n            {\n                m_type = CV_32FC3;\n                m_hdr = true;\n                return true;\n            }\n            m_hdr = false;\n\n            if( bpp > 8 &&\n               ((photometric != 2 && photometric != 1) ||\n                (ncn != 1 && ncn != 3 && ncn != 4)))\n                bpp = 8;\n\n            int wanted_channels = normalizeChannelsNumber(ncn);\n            switch(bpp)\n            {\n                case 8:\n                    m_type = CV_MAKETYPE(CV_8U, photometric > 1 ? wanted_channels : 1);\n                    break;\n                case 16:\n                    m_type = CV_MAKETYPE(CV_16U, photometric > 1 ? wanted_channels : 1);\n                    break;\n\n                case 32:\n                    m_type = CV_MAKETYPE(CV_32F, photometric > 1 ? 3 : 1);\n                    break;\n                case 64:\n                    m_type = CV_MAKETYPE(CV_64F, photometric > 1 ? 3 : 1);\n                    break;\n\n                default:\n                    result = false;\n            }\n            result = true;\n        }\n    }\n\n    if( !result )\n        close();\n\n    return result;\n}\n\n\nbool  TiffDecoder::readData( Mat& img )\n{\n    if(m_hdr && img.type() == CV_32FC3)\n    {\n        return readHdrData(img);\n    }\n    bool result = false;\n    bool color = img.channels() > 1;\n    uchar* data = img.ptr();\n\n    if( img.depth() != CV_8U && img.depth() != CV_16U && img.depth() != CV_32F && img.depth() != CV_64F )\n        return false;\n\n    if( m_tif && m_width && m_height )\n    {\n        TIFF* tif = (TIFF*)m_tif;\n        uint32 tile_width0 = m_width, tile_height0 = 0;\n        int x, y, i;\n        int is_tiled = TIFFIsTiled(tif);\n        uint16 photometric;\n        TIFFGetField( tif, TIFFTAG_PHOTOMETRIC, &photometric );\n        uint16 bpp = 8, ncn = photometric > 1 ? 3 : 1;\n        TIFFGetField( tif, TIFFTAG_BITSPERSAMPLE, &bpp );\n        TIFFGetField( tif, TIFFTAG_SAMPLESPERPIXEL, &ncn );\n        const int bitsPerByte = 8;\n        int dst_bpp = (int)(img.elemSize1() * bitsPerByte);\n        int wanted_channels = normalizeChannelsNumber(img.channels());\n\n        if(dst_bpp == 8)\n        {\n            char errmsg[1024];\n            if(!TIFFRGBAImageOK( tif, errmsg ))\n            {\n                close();\n                return false;\n            }\n        }\n\n        if( (!is_tiled) ||\n            (is_tiled &&\n            TIFFGetField( tif, TIFFTAG_TILEWIDTH, &tile_width0 ) &&\n            TIFFGetField( tif, TIFFTAG_TILELENGTH, &tile_height0 )))\n        {\n            if(!is_tiled)\n                TIFFGetField( tif, TIFFTAG_ROWSPERSTRIP, &tile_height0 );\n\n            if( tile_width0 <= 0 )\n                tile_width0 = m_width;\n\n            if( tile_height0 <= 0 )\n                tile_height0 = m_height;\n\n            AutoBuffer<uchar> _buffer( size_t(8) * tile_height0*tile_width0);\n            uchar* buffer = _buffer;\n            ushort* buffer16 = (ushort*)buffer;\n            float* buffer32 = (float*)buffer;\n            double* buffer64 = (double*)buffer;\n            int tileidx = 0;\n\n            for( y = 0; y < m_height; y += tile_height0, data += img.step*tile_height0 )\n            {\n                int tile_height = tile_height0;\n\n                if( y + tile_height > m_height )\n                    tile_height = m_height - y;\n\n                for( x = 0; x < m_width; x += tile_width0, tileidx++ )\n                {\n                    int tile_width = tile_width0, ok;\n\n                    if( x + tile_width > m_width )\n                        tile_width = m_width - x;\n\n                    switch(dst_bpp)\n                    {\n                        case 8:\n                        {\n                            uchar * bstart = buffer;\n                            if( !is_tiled )\n                                ok = TIFFReadRGBAStrip( tif, y, (uint32*)buffer );\n                            else\n                            {\n                                ok = TIFFReadRGBATile( tif, x, y, (uint32*)buffer );\n                                //Tiles fill the buffer from the bottom up\n                                bstart += (tile_height0 - tile_height) * tile_width0 * 4;\n                            }\n                            if( !ok )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                                if( color )\n                                {\n                                    if (wanted_channels == 4)\n                                    {\n                                        icvCvt_BGRA2RGBA_8u_C4R( bstart + i*tile_width0*4, 0,\n                                                             data + x*4 + img.step*(tile_height - i - 1), 0,\n                                                             cvSize(tile_width,1) );\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2BGR_8u_C4C3R( bstart + i*tile_width0*4, 0,\n                                                             data + x*3 + img.step*(tile_height - i - 1), 0,\n                                                             cvSize(tile_width,1), 2 );\n                                    }\n                                }\n                                else\n                                    icvCvt_BGRA2Gray_8u_C4C1R( bstart + i*tile_width0*4, 0,\n                                                              data + x + img.step*(tile_height - i - 1), 0,\n                                                              cvSize(tile_width,1), 2 );\n                            break;\n                        }\n\n                        case 16:\n                        {\n                            if( !is_tiled )\n                                ok = (int)TIFFReadEncodedStrip( tif, tileidx, (uint32*)buffer, (tsize_t)-1 ) >= 0;\n                            else\n                                ok = (int)TIFFReadEncodedTile( tif, tileidx, (uint32*)buffer, (tsize_t)-1 ) >= 0;\n\n                            if( !ok )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                            {\n                                if( color )\n                                {\n                                    if( ncn == 1 )\n                                    {\n                                        icvCvt_Gray2BGR_16u_C1C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                                  (ushort*)(data + img.step*i) + x*3, 0,\n                                                                  cvSize(tile_width,1) );\n                                    }\n                                    else if( ncn == 3 )\n                                    {\n                                        icvCvt_RGB2BGR_16u_C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                               (ushort*)(data + img.step*i) + x*3, 0,\n                                                               cvSize(tile_width,1) );\n                                    }\n                                    else if (ncn == 4)\n                                    {\n                                        if (wanted_channels == 4)\n                                        {\n                                            icvCvt_BGRA2RGBA_16u_C4R(buffer16 + i*tile_width0*ncn, 0,\n                                                (ushort*)(data + img.step*i) + x * 4, 0,\n                                                cvSize(tile_width, 1));\n                                        }\n                                        else\n                                        {\n                                            icvCvt_BGRA2BGR_16u_C4C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                (ushort*)(data + img.step*i) + x * 3, 0,\n                                                cvSize(tile_width, 1), 2);\n                                        }\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2BGR_16u_C4C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                               (ushort*)(data + img.step*i) + x*3, 0,\n                                                               cvSize(tile_width,1), 2 );\n                                    }\n                                }\n                                else\n                                {\n                                    if( ncn == 1 )\n                                    {\n                                        memcpy((ushort*)(data + img.step*i)+x,\n                                               buffer16 + i*tile_width0*ncn,\n                                               tile_width*sizeof(buffer16[0]));\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2Gray_16u_CnC1R(buffer16 + i*tile_width0*ncn, 0,\n                                                               (ushort*)(data + img.step*i) + x, 0,\n                                                               cvSize(tile_width,1), ncn, 2 );\n                                    }\n                                }\n                            }\n                            break;\n                        }\n\n                        case 32:\n                        case 64:\n                        {\n                            if( !is_tiled )\n                                ok = (int)TIFFReadEncodedStrip( tif, tileidx, buffer, (tsize_t)-1 ) >= 0;\n                            else\n                                ok = (int)TIFFReadEncodedTile( tif, tileidx, buffer, (tsize_t)-1 ) >= 0;\n\n                            if( !ok || ncn != 1 )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                            {\n                                if(dst_bpp == 32)\n                                {\n                                    memcpy((float*)(data + img.step*i)+x,\n                                           buffer32 + i*tile_width0*ncn,\n                                           tile_width*sizeof(buffer32[0]));\n                                }\n                                else\n                                {\n                                    memcpy((double*)(data + img.step*i)+x,\n                                         buffer64 + i*tile_width0*ncn,\n                                         tile_width*sizeof(buffer64[0]));\n                                }\n                            }\n\n                            break;\n                        }\n                        default:\n                        {\n                            close();\n                            return false;\n                        }\n                    }\n                }\n            }\n\n            result = true;\n        }\n    }\n\n    close();\n    return result;\n}\n\nbool TiffDecoder::readHdrData(Mat& img)\n{\n    int rows_per_strip = 0, photometric = 0;\n    if(!m_tif)\n    {\n        return false;\n    }\n    TIFF *tif = static_cast<TIFF*>(m_tif);\n    TIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &rows_per_strip);\n    TIFFGetField( tif, TIFFTAG_PHOTOMETRIC, &photometric );\n    TIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_FLOAT);\n    int size = 3 * m_width * m_height * sizeof (float);\n    tstrip_t strip_size = 3 * m_width * rows_per_strip;\n    float *ptr = img.ptr<float>();\n    for (tstrip_t i = 0; i < TIFFNumberOfStrips(tif); i++, ptr += strip_size)\n    {\n        TIFFReadEncodedStrip(tif, i, ptr, size);\n        size -= strip_size * sizeof(float);\n    }\n    close();\n    if(photometric == PHOTOMETRIC_LOGLUV)\n    {\n        cvtColor(img, img, COLOR_XYZ2BGR);\n    }\n    else\n    {\n        cvtColor(img, img, COLOR_RGB2BGR);\n    }\n    return true;\n}\n\n#endif\n\n//////////////////////////////////////////////////////////////////////////////////////////\n\nTiffEncoder::TiffEncoder()\n{\n    m_description = \"TIFF Files (*.tiff;*.tif)\";\n#ifdef HAVE_TIFF\n    m_buf_supported = false;\n#else\n    m_buf_supported = true;\n#endif\n}\n\nTiffEncoder::~TiffEncoder()\n{\n}\n\nImageEncoder TiffEncoder::newEncoder() const\n{\n    return makePtr<TiffEncoder>();\n}\n\nbool TiffEncoder::isFormatSupported( int depth ) const\n{\n#ifdef HAVE_TIFF\n    return depth == CV_8U || depth == CV_16U || depth == CV_32F;\n#else\n    return depth == CV_8U || depth == CV_16U;\n#endif\n}\n\nvoid  TiffEncoder::writeTag( WLByteStream& strm, TiffTag tag,\n                             TiffFieldType fieldType,\n                             int count, int value )\n{\n    strm.putWord( tag );\n    strm.putWord( fieldType );\n    strm.putDWord( count );\n    strm.putDWord( value );\n}\n\n#ifdef HAVE_TIFF\n\nstatic void readParam(const std::vector<int>& params, int key, int& value)\n{\n    for(size_t i = 0; i + 1 < params.size(); i += 2)\n        if(params[i] == key)\n        {\n            value = params[i+1];\n            break;\n        }\n}\n\nbool  TiffEncoder::writeLibTiff( const Mat& img, const std::vector<int>& params)\n{\n    int channels = img.channels();\n    int width = img.cols, height = img.rows;\n    int depth = img.depth();\n\n    int bitsPerChannel = -1;\n    switch (depth)\n    {\n        case CV_8U:\n        {\n            bitsPerChannel = 8;\n            break;\n        }\n        case CV_16U:\n        {\n            bitsPerChannel = 16;\n            break;\n        }\n        default:\n        {\n            return false;\n        }\n    }\n\n    const int bitsPerByte = 8;\n    size_t fileStep = (width * channels * bitsPerChannel) / bitsPerByte;\n\n    int rowsPerStrip = (int)((1 << 13)/fileStep);\n    readParam(params, TIFFTAG_ROWSPERSTRIP, rowsPerStrip);\n\n    if( rowsPerStrip < 1 )\n        rowsPerStrip = 1;\n\n    if( rowsPerStrip > height )\n        rowsPerStrip = height;\n\n\n    // do NOT put \"wb\" as the mode, because the b means \"big endian\" mode, not \"binary\" mode.\n    // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n    TIFF* pTiffHandle = TIFFOpen(m_filename.c_str(), \"w\");\n    if (!pTiffHandle)\n    {\n        return false;\n    }\n\n    // defaults for now, maybe base them on params in the future\n    int   compression  = COMPRESSION_LZW;\n    int   predictor    = PREDICTOR_HORIZONTAL;\n\n    readParam(params, TIFFTAG_COMPRESSION, compression);\n    readParam(params, TIFFTAG_PREDICTOR, predictor);\n\n    int   colorspace = channels > 1 ? PHOTOMETRIC_RGB : PHOTOMETRIC_MINISBLACK;\n\n    if ( !TIFFSetField(pTiffHandle, TIFFTAG_IMAGEWIDTH, width)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_IMAGELENGTH, height)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_BITSPERSAMPLE, bitsPerChannel)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_COMPRESSION, compression)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_PHOTOMETRIC, colorspace)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_SAMPLESPERPIXEL, channels)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_ROWSPERSTRIP, rowsPerStrip)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_PREDICTOR, predictor)\n       )\n    {\n        TIFFClose(pTiffHandle);\n        return false;\n    }\n\n    // row buffer, because TIFFWriteScanline modifies the original data!\n    size_t scanlineSize = TIFFScanlineSize(pTiffHandle);\n    AutoBuffer<uchar> _buffer(scanlineSize+32);\n    uchar* buffer = _buffer;\n    if (!buffer)\n    {\n        TIFFClose(pTiffHandle);\n        return false;\n    }\n\n    for (int y = 0; y < height; ++y)\n    {\n        switch(channels)\n        {\n            case 1:\n            {\n                memcpy(buffer, img.ptr(y), scanlineSize);\n                break;\n            }\n\n            case 3:\n            {\n                if (depth == CV_8U)\n                    icvCvt_BGR2RGB_8u_C3R( img.ptr(y), 0, buffer, 0, cvSize(width,1) );\n                else\n                    icvCvt_BGR2RGB_16u_C3R( img.ptr<ushort>(y), 0, (ushort*)buffer, 0, cvSize(width,1) );\n                break;\n            }\n\n            case 4:\n            {\n                if (depth == CV_8U)\n                    icvCvt_BGRA2RGBA_8u_C4R( img.ptr(y), 0, buffer, 0, cvSize(width,1) );\n                else\n                    icvCvt_BGRA2RGBA_16u_C4R( img.ptr<ushort>(y), 0, (ushort*)buffer, 0, cvSize(width,1) );\n                break;\n            }\n\n            default:\n            {\n                TIFFClose(pTiffHandle);\n                return false;\n            }\n        }\n\n        int writeResult = TIFFWriteScanline(pTiffHandle, buffer, y, 0);\n        if (writeResult != 1)\n        {\n            TIFFClose(pTiffHandle);\n            return false;\n        }\n    }\n\n    TIFFClose(pTiffHandle);\n    return true;\n}\n\nbool TiffEncoder::writeHdr(const Mat& _img)\n{\n    Mat img;\n    cvtColor(_img, img, COLOR_BGR2XYZ);\n    TIFF* tif = TIFFOpen(m_filename.c_str(), \"w\");\n    if (!tif)\n    {\n        return false;\n    }\n    TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, img.cols);\n    TIFFSetField(tif, TIFFTAG_IMAGELENGTH, img.rows);\n    TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 3);\n    TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_SGILOG);\n    TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_LOGLUV);\n    TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    TIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_FLOAT);\n    TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, 1);\n    int strip_size = 3 * img.cols;\n    float *ptr = const_cast<float*>(img.ptr<float>());\n    for (int i = 0; i < img.rows; i++, ptr += strip_size)\n    {\n        TIFFWriteEncodedStrip(tif, i, ptr, strip_size * sizeof(float));\n    }\n    TIFFClose(tif);\n    return true;\n}\n\n#endif\n\n#ifdef HAVE_TIFF\nbool  TiffEncoder::write( const Mat& img, const std::vector<int>& params)\n#else\nbool  TiffEncoder::write( const Mat& img, const std::vector<int>& /*params*/)\n#endif\n{\n    int channels = img.channels();\n    int width = img.cols, height = img.rows;\n    int depth = img.depth();\n#ifdef HAVE_TIFF\n    if(img.type() == CV_32FC3)\n    {\n        return writeHdr(img);\n    }\n#endif\n\n    if (depth != CV_8U && depth != CV_16U)\n        return false;\n\n    int bytesPerChannel = depth == CV_8U ? 1 : 2;\n    int fileStep = width * channels * bytesPerChannel;\n\n    WLByteStream strm;\n\n    if( m_buf )\n    {\n        if( !strm.open(*m_buf) )\n            return false;\n    }\n    else\n    {\n#ifdef HAVE_TIFF\n      return writeLibTiff(img, params);\n#else\n      if( !strm.open(m_filename) )\n          return false;\n#endif\n    }\n\n    int rowsPerStrip = (1 << 13)/fileStep;\n\n    if( rowsPerStrip < 1 )\n        rowsPerStrip = 1;\n\n    if( rowsPerStrip > height )\n        rowsPerStrip = height;\n\n    int i, stripCount = (height + rowsPerStrip - 1) / rowsPerStrip;\n\n    if( m_buf )\n        m_buf->reserve( alignSize(stripCount*8 + fileStep*height + 256, 256) );\n\n/*#if defined _DEBUG || !defined WIN32\n    int uncompressedRowSize = rowsPerStrip * fileStep;\n#endif*/\n    int directoryOffset = 0;\n\n    AutoBuffer<int> stripOffsets(stripCount);\n    AutoBuffer<short> stripCounts(stripCount);\n    AutoBuffer<uchar> _buffer(fileStep+32);\n    uchar* buffer = _buffer;\n    int  stripOffsetsOffset = 0;\n    int  stripCountsOffset = 0;\n    int  bitsPerSample = 8 * bytesPerChannel;\n    int  y = 0;\n\n    strm.putBytes( fmtSignTiffII, 4 );\n    strm.putDWord( directoryOffset );\n\n    // write an image data first (the most reasonable way\n    // for compressed images)\n    for( i = 0; i < stripCount; i++ )\n    {\n        int limit = y + rowsPerStrip;\n\n        if( limit > height )\n            limit = height;\n\n        stripOffsets[i] = strm.getPos();\n\n        for( ; y < limit; y++ )\n        {\n            if( channels == 3 )\n            {\n                if (depth == CV_8U)\n                    icvCvt_BGR2RGB_8u_C3R( img.ptr(y), 0, buffer, 0, cvSize(width,1) );\n                else\n                    icvCvt_BGR2RGB_16u_C3R( img.ptr<ushort>(y), 0, (ushort*)buffer, 0, cvSize(width,1) );\n            }\n            else\n            {\n              if( channels == 4 )\n              {\n                if (depth == CV_8U)\n                    icvCvt_BGRA2RGBA_8u_C4R( img.ptr(y), 0, buffer, 0, cvSize(width,1) );\n                else\n                    icvCvt_BGRA2RGBA_16u_C4R( img.ptr<ushort>(y), 0, (ushort*)buffer, 0, cvSize(width,1) );\n              }\n            }\n\n            strm.putBytes( channels > 1 ? buffer : img.ptr(y), fileStep );\n        }\n\n        stripCounts[i] = (short)(strm.getPos() - stripOffsets[i]);\n        /*assert( stripCounts[i] == uncompressedRowSize ||\n                stripCounts[i] < uncompressedRowSize &&\n                i == stripCount - 1);*/\n    }\n\n    if( stripCount > 2 )\n    {\n        stripOffsetsOffset = strm.getPos();\n        for( i = 0; i < stripCount; i++ )\n            strm.putDWord( stripOffsets[i] );\n\n        stripCountsOffset = strm.getPos();\n        for( i = 0; i < stripCount; i++ )\n            strm.putWord( stripCounts[i] );\n    }\n    else if(stripCount == 2)\n    {\n        stripOffsetsOffset = strm.getPos();\n        for (i = 0; i < stripCount; i++)\n        {\n            strm.putDWord (stripOffsets [i]);\n        }\n        stripCountsOffset = stripCounts [0] + (stripCounts [1] << 16);\n    }\n    else\n    {\n        stripOffsetsOffset = stripOffsets[0];\n        stripCountsOffset = stripCounts[0];\n    }\n\n    if( channels > 1 )\n    {\n        int bitsPerSamplePos = strm.getPos();\n        strm.putWord(bitsPerSample);\n        strm.putWord(bitsPerSample);\n        strm.putWord(bitsPerSample);\n        if( channels == 4 )\n            strm.putWord(bitsPerSample);\n        bitsPerSample = bitsPerSamplePos;\n    }\n\n    directoryOffset = strm.getPos();\n\n    // write header\n    strm.putWord( 9 );\n\n    /* warning: specification 5.0 of Tiff want to have tags in\n       ascending order. This is a non-fatal error, but this cause\n       warning with some tools. So, keep this in ascending order */\n\n    writeTag( strm, TIFF_TAG_WIDTH, TIFF_TYPE_LONG, 1, width );\n    writeTag( strm, TIFF_TAG_HEIGHT, TIFF_TYPE_LONG, 1, height );\n    writeTag( strm, TIFF_TAG_BITS_PER_SAMPLE,\n              TIFF_TYPE_SHORT, channels, bitsPerSample );\n    writeTag( strm, TIFF_TAG_COMPRESSION, TIFF_TYPE_LONG, 1, TIFF_UNCOMP );\n    writeTag( strm, TIFF_TAG_PHOTOMETRIC, TIFF_TYPE_SHORT, 1, channels > 1 ? 2 : 1 );\n\n    writeTag( strm, TIFF_TAG_STRIP_OFFSETS, TIFF_TYPE_LONG,\n              stripCount, stripOffsetsOffset );\n\n    writeTag( strm, TIFF_TAG_SAMPLES_PER_PIXEL, TIFF_TYPE_SHORT, 1, channels );\n    writeTag( strm, TIFF_TAG_ROWS_PER_STRIP, TIFF_TYPE_LONG, 1, rowsPerStrip );\n\n    writeTag( strm, TIFF_TAG_STRIP_COUNTS,\n              stripCount > 1 ? TIFF_TYPE_SHORT : TIFF_TYPE_LONG,\n              stripCount, stripCountsOffset );\n\n    strm.putDWord(0);\n    strm.close();\n\n    if( m_buf )\n    {\n        (*m_buf)[4] = (uchar)directoryOffset;\n        (*m_buf)[5] = (uchar)(directoryOffset >> 8);\n        (*m_buf)[6] = (uchar)(directoryOffset >> 16);\n        (*m_buf)[7] = (uchar)(directoryOffset >> 24);\n    }\n    else\n    {\n        // write directory offset\n        FILE* f = fopen( m_filename.c_str(), \"r+b\" );\n        buffer[0] = (uchar)directoryOffset;\n        buffer[1] = (uchar)(directoryOffset >> 8);\n        buffer[2] = (uchar)(directoryOffset >> 16);\n        buffer[3] = (uchar)(directoryOffset >> 24);\n\n        fseek( f, 4, SEEK_SET );\n        fwrite( buffer, 1, 4, f );\n        fclose(f);\n    }\n\n    return true;\n}\n\n}\n",
                "name": "grfmt_tiff.cpp",
                "path": "3rdparty/opencv-git/modules/imgcodecs/src/grfmt_tiff.cpp",
                "url": "/github.com/plumonito/planecalib/-/blob/3rdparty/opencv-git/modules/imgcodecs/src/grfmt_tiff.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 266,
                    "offsetAndLengths": [
                        [
                            37,
                            16
                        ]
                    ],
                    "preview": "                                ok = TIFFReadRGBATile( tif, x, y, (uint32*)buffer );"
                }
            ],
            "repository": {
                "name": "github.com/plumonito/planecalib",
                "url": "/github.com/plumonito/planecalib"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "cba92797346b590c9572133f2d6e430de6c80f24"
                },
                "content": "/*M///////////////////////////////////////////////////////////////////////////////////////\n//\n//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.\n//\n//  By downloading, copying, installing or using the software you agree to this license.\n//  If you do not agree to this license, do not download, install,\n//  copy or use the software.\n//\n//\n//                           License Agreement\n//                For Open Source Computer Vision Library\n//\n// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.\n// Copyright (C) 2009, Willow Garage Inc., all rights reserved.\n// Third party copyrights are property of their respective owners.\n//\n// Redistribution and use in source and binary forms, with or without modification,\n// are permitted provided that the following conditions are met:\n//\n//   * Redistribution's of source code must retain the above copyright notice,\n//     this list of conditions and the following disclaimer.\n//\n//   * Redistribution's in binary form must reproduce the above copyright notice,\n//     this list of conditions and the following disclaimer in the documentation\n//     and/or other materials provided with the distribution.\n//\n//   * The name of the copyright holders may not be used to endorse or promote products\n//     derived from this software without specific prior written permission.\n//\n// This software is provided by the copyright holders and contributors \"as is\" and\n// any express or implied warranties, including, but not limited to, the implied\n// warranties of merchantability and fitness for a particular purpose are disclaimed.\n// In no event shall the Intel Corporation or contributors be liable for any direct,\n// indirect, incidental, special, exemplary, or consequential damages\n// (including, but not limited to, procurement of substitute goods or services;\n// loss of use, data, or profits; or business interruption) however caused\n// and on any theory of liability, whether in contract, strict liability,\n// or tort (including negligence or otherwise) arising in any way out of\n// the use of this software, even if advised of the possibility of such damage.\n//\n//M*/\n\n/****************************************************************************************\\\n    A part of the file implements TIFF reader on base of libtiff library\n    (see otherlibs/_graphics/readme.txt for copyright notice)\n\\****************************************************************************************/\n\n#include <stdarg.h>\n\n#include \"precomp.hpp\"\n#include \"grfmt_tiff.hpp\"\n\n#define int64 int64_tiff\n#define uint64 uint64_tiff\n\n#ifdef HAVE_TIFF\n# include \"tiff.h\"\n# include \"tiffio.h\"\n#endif\n\nnamespace cv\n{\nstatic const char fmtSignTiffII[] = \"II\\x2a\\x00\";\n\n#ifdef HAVE_TIFF\n\nstatic const char fmtSignTiffMM[] = \"MM\\x00\\x2a\";\nstatic int grfmt_tiff_err_handler_init = 0;\nstatic void GrFmtSilentTIFFErrorHandler( const char*, const char*, va_list ) {}\n\nTiffDecoder::TiffDecoder()\n{\n    m_tif = 0;\n    if( !grfmt_tiff_err_handler_init )\n    {\n        grfmt_tiff_err_handler_init = 1;\n\n        TIFFSetErrorHandler( GrFmtSilentTIFFErrorHandler );\n        TIFFSetWarningHandler( GrFmtSilentTIFFErrorHandler );\n    }\n}\n\n\nvoid TiffDecoder::close()\n{\n    if( m_tif )\n    {\n        TIFF* tif = (TIFF*)m_tif;\n        TIFFClose( tif );\n        m_tif = 0;\n    }\n}\n\nTiffDecoder::~TiffDecoder()\n{\n    close();\n}\n\nsize_t TiffDecoder::signatureLength() const\n{\n    return 4;\n}\n\nbool TiffDecoder::checkSignature( const string& signature ) const\n{\n    return signature.size() >= 4 &&\n        (memcmp(signature.c_str(), fmtSignTiffII, 4) == 0 ||\n        memcmp(signature.c_str(), fmtSignTiffMM, 4) == 0);\n}\n\nImageDecoder TiffDecoder::newDecoder() const\n{\n    return new TiffDecoder;\n}\n\nbool TiffDecoder::readHeader()\n{\n    bool result = false;\n\n    close();\n    // TIFFOpen() mode flags are different to fopen().  A 'b' in mode \"rb\" has no effect when reading.\n    // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n    TIFF* tif = TIFFOpen( m_filename.c_str(), \"r\" );\n\n    if( tif )\n    {\n        uint32 wdth = 0, hght = 0;\n        uint16 photometric = 0;\n        m_tif = tif;\n\n        if( TIFFGetField( tif, TIFFTAG_IMAGEWIDTH, &wdth ) &&\n            TIFFGetField( tif, TIFFTAG_IMAGELENGTH, &hght ) &&\n            TIFFGetField( tif, TIFFTAG_PHOTOMETRIC, &photometric ))\n        {\n            uint16 bpp=8, ncn = photometric > 1 ? 3 : 1;\n            TIFFGetField( tif, TIFFTAG_BITSPERSAMPLE, &bpp );\n            TIFFGetField( tif, TIFFTAG_SAMPLESPERPIXEL, &ncn );\n\n            m_width = wdth;\n            m_height = hght;\n            if( bpp > 8 &&\n               ((photometric != 2 && photometric != 1) ||\n                (ncn != 1 && ncn != 3 && ncn != 4)))\n                bpp = 8;\n\n            switch(bpp)\n            {\n                case 8:\n                    m_type = CV_MAKETYPE(CV_8U, photometric > 1 ? 3 : 1);\n                    break;\n                case 16:\n                    m_type = CV_MAKETYPE(CV_16U, photometric > 1 ? 3 : 1);\n                    break;\n\n                case 32:\n                    m_type = CV_MAKETYPE(CV_32F, photometric > 1 ? 3 : 1);\n                    break;\n                case 64:\n                    m_type = CV_MAKETYPE(CV_64F, photometric > 1 ? 3 : 1);\n                    break;\n\n                default:\n                    result = false;\n            }\n            result = true;\n        }\n    }\n\n    if( !result )\n        close();\n\n    return result;\n}\n\n\nbool  TiffDecoder::readData( Mat& img )\n{\n    bool result = false;\n    bool color = img.channels() > 1;\n    uchar* data = img.data;\n\n    if( img.depth() != CV_8U && img.depth() != CV_16U && img.depth() != CV_32F && img.depth() != CV_64F )\n        return false;\n\n    if( m_tif && m_width && m_height )\n    {\n        TIFF* tif = (TIFF*)m_tif;\n        uint32 tile_width0 = m_width, tile_height0 = 0;\n        int x, y, i;\n        int is_tiled = TIFFIsTiled(tif);\n        uint16 photometric;\n        TIFFGetField( tif, TIFFTAG_PHOTOMETRIC, &photometric );\n        uint16 bpp = 8, ncn = photometric > 1 ? 3 : 1;\n        TIFFGetField( tif, TIFFTAG_BITSPERSAMPLE, &bpp );\n        TIFFGetField( tif, TIFFTAG_SAMPLESPERPIXEL, &ncn );\n        const int bitsPerByte = 8;\n        int dst_bpp = (int)(img.elemSize1() * bitsPerByte);\n\n        if(dst_bpp == 8)\n        {\n            char errmsg[1024];\n            if(!TIFFRGBAImageOK( tif, errmsg ))\n            {\n                close();\n                return false;\n            }\n        }\n\n        if( (!is_tiled) ||\n            (is_tiled &&\n            TIFFGetField( tif, TIFFTAG_TILEWIDTH, &tile_width0 ) &&\n            TIFFGetField( tif, TIFFTAG_TILELENGTH, &tile_height0 )))\n        {\n            if(!is_tiled)\n                TIFFGetField( tif, TIFFTAG_ROWSPERSTRIP, &tile_height0 );\n\n            if( tile_width0 <= 0 )\n                tile_width0 = m_width;\n\n            if( tile_height0 <= 0 ||\n                (!is_tiled && tile_height0 == std::numeric_limits<uint32>::max()) )\n                tile_height0 = m_height;\n\n            const size_t buffer_size = bpp * ncn * tile_height0 * tile_width0;\n            AutoBuffer<uchar> _buffer( buffer_size );\n            uchar* buffer = _buffer;\n            ushort* buffer16 = (ushort*)buffer;\n            float* buffer32 = (float*)buffer;\n            double* buffer64 = (double*)buffer;\n            int tileidx = 0;\n\n            for( y = 0; y < m_height; y += tile_height0, data += img.step*tile_height0 )\n            {\n                int tile_height = tile_height0;\n\n                if( y + tile_height > m_height )\n                    tile_height = m_height - y;\n\n                for( x = 0; x < m_width; x += tile_width0, tileidx++ )\n                {\n                    int tile_width = tile_width0, ok;\n\n                    if( x + tile_width > m_width )\n                        tile_width = m_width - x;\n\n                    switch(dst_bpp)\n                    {\n                        case 8:\n                        {\n                            uchar * bstart = buffer;\n                            if( !is_tiled )\n                                ok = TIFFReadRGBAStrip( tif, y, (uint32*)buffer );\n                            else\n                            {\n                                ok = TIFFReadRGBATile( tif, x, y, (uint32*)buffer );\n                                //Tiles fill the buffer from the bottom up\n                                bstart += (tile_height0 - tile_height) * tile_width0 * 4;\n                            }\n                            if( !ok )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                                if( color )\n                                    icvCvt_BGRA2BGR_8u_C4C3R( bstart + i*tile_width0*4, 0,\n                                                             data + x*3 + img.step*(tile_height - i - 1), 0,\n                                                             cvSize(tile_width,1), 2 );\n                                else\n                                    icvCvt_BGRA2Gray_8u_C4C1R( bstart + i*tile_width0*4, 0,\n                                                              data + x + img.step*(tile_height - i - 1), 0,\n                                                              cvSize(tile_width,1), 2 );\n                            break;\n                        }\n\n                        case 16:\n                        {\n                            if( !is_tiled )\n                                ok = (int)TIFFReadEncodedStrip( tif, tileidx, (uint32*)buffer, buffer_size ) >= 0;\n                            else\n                                ok = (int)TIFFReadEncodedTile( tif, tileidx, (uint32*)buffer, buffer_size ) >= 0;\n\n                            if( !ok )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                            {\n                                if( color )\n                                {\n                                    if( ncn == 1 )\n                                    {\n                                        icvCvt_Gray2BGR_16u_C1C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                                  (ushort*)(data + img.step*i) + x*3, 0,\n                                                                  cvSize(tile_width,1) );\n                                    }\n                                    else if( ncn == 3 )\n                                    {\n                                        icvCvt_RGB2BGR_16u_C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                               (ushort*)(data + img.step*i) + x*3, 0,\n                                                               cvSize(tile_width,1) );\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2BGR_16u_C4C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                               (ushort*)(data + img.step*i) + x*3, 0,\n                                                               cvSize(tile_width,1), 2 );\n                                    }\n                                }\n                                else\n                                {\n                                    if( ncn == 1 )\n                                    {\n                                        memcpy((ushort*)(data + img.step*i)+x,\n                                               buffer16 + i*tile_width0*ncn,\n                                               tile_width*sizeof(buffer16[0]));\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2Gray_16u_CnC1R(buffer16 + i*tile_width0*ncn, 0,\n                                                               (ushort*)(data + img.step*i) + x, 0,\n                                                               cvSize(tile_width,1), ncn, 2 );\n                                    }\n                                }\n                            }\n                            break;\n                        }\n\n                        case 32:\n                        case 64:\n                        {\n                            if( !is_tiled )\n                                ok = (int)TIFFReadEncodedStrip( tif, tileidx, buffer, buffer_size ) >= 0;\n                            else\n                                ok = (int)TIFFReadEncodedTile( tif, tileidx, buffer, buffer_size ) >= 0;\n\n                            if( !ok || ncn != 1 )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                            {\n                                if(dst_bpp == 32)\n                                {\n                                    memcpy((float*)(data + img.step*i)+x,\n                                           buffer32 + i*tile_width0*ncn,\n                                           tile_width*sizeof(buffer32[0]));\n                                }\n                                else\n                                {\n                                    memcpy((double*)(data + img.step*i)+x,\n                                         buffer64 + i*tile_width0*ncn,\n                                         tile_width*sizeof(buffer64[0]));\n                                }\n                            }\n\n                            break;\n                        }\n                        default:\n                        {\n                            close();\n                            return false;\n                        }\n                    }\n                }\n            }\n\n            result = true;\n        }\n    }\n\n    close();\n    return result;\n}\n\n#endif\n\n//////////////////////////////////////////////////////////////////////////////////////////\n\nTiffEncoder::TiffEncoder()\n{\n    m_description = \"TIFF Files (*.tiff;*.tif)\";\n#ifdef HAVE_TIFF\n    m_buf_supported = false;\n#else\n    m_buf_supported = true;\n#endif\n}\n\nTiffEncoder::~TiffEncoder()\n{\n}\n\nImageEncoder TiffEncoder::newEncoder() const\n{\n    return new TiffEncoder;\n}\n\nbool TiffEncoder::isFormatSupported( int depth ) const\n{\n    return depth == CV_8U || depth == CV_16U;\n}\n\nvoid  TiffEncoder::writeTag( WLByteStream& strm, TiffTag tag,\n                             TiffFieldType fieldType,\n                             int count, int value )\n{\n    strm.putWord( tag );\n    strm.putWord( fieldType );\n    strm.putDWord( count );\n    strm.putDWord( value );\n}\n\n#ifdef HAVE_TIFF\n\nstatic void readParam(const vector<int>& params, int key, int& value)\n{\n    for(size_t i = 0; i + 1 < params.size(); i += 2)\n        if(params[i] == key)\n        {\n            value = params[i+1];\n            break;\n        }\n}\n\nbool  TiffEncoder::writeLibTiff( const Mat& img, const vector<int>& params)\n{\n    int channels = img.channels();\n    int width = img.cols, height = img.rows;\n    int depth = img.depth();\n\n    int bitsPerChannel = -1;\n    switch (depth)\n    {\n        case CV_8U:\n        {\n            bitsPerChannel = 8;\n            break;\n        }\n        case CV_16U:\n        {\n            bitsPerChannel = 16;\n            break;\n        }\n        default:\n        {\n            return false;\n        }\n    }\n\n    const int bitsPerByte = 8;\n    size_t fileStep = (width * channels * bitsPerChannel) / bitsPerByte;\n\n    int rowsPerStrip = (int)((1 << 13)/fileStep);\n    readParam(params, TIFFTAG_ROWSPERSTRIP, rowsPerStrip);\n\n    if( rowsPerStrip < 1 )\n        rowsPerStrip = 1;\n\n    if( rowsPerStrip > height )\n        rowsPerStrip = height;\n\n\n    // do NOT put \"wb\" as the mode, because the b means \"big endian\" mode, not \"binary\" mode.\n    // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n    TIFF* pTiffHandle = TIFFOpen(m_filename.c_str(), \"w\");\n    if (!pTiffHandle)\n    {\n        return false;\n    }\n\n    // defaults for now, maybe base them on params in the future\n    int   compression  = COMPRESSION_LZW;\n    int   predictor    = PREDICTOR_HORIZONTAL;\n\n    readParam(params, TIFFTAG_COMPRESSION, compression);\n    readParam(params, TIFFTAG_PREDICTOR, predictor);\n\n    int   colorspace = channels > 1 ? PHOTOMETRIC_RGB : PHOTOMETRIC_MINISBLACK;\n\n    if ( !TIFFSetField(pTiffHandle, TIFFTAG_IMAGEWIDTH, width)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_IMAGELENGTH, height)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_BITSPERSAMPLE, bitsPerChannel)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_COMPRESSION, compression)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_PHOTOMETRIC, colorspace)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_SAMPLESPERPIXEL, channels)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_ROWSPERSTRIP, rowsPerStrip)\n       )\n    {\n        TIFFClose(pTiffHandle);\n        return false;\n    }\n\n    if (compression != COMPRESSION_NONE && !TIFFSetField(pTiffHandle, TIFFTAG_PREDICTOR, predictor) )\n    {\n        TIFFClose(pTiffHandle);\n        return false;\n    }\n\n    // row buffer, because TIFFWriteScanline modifies the original data!\n    size_t scanlineSize = TIFFScanlineSize(pTiffHandle);\n    AutoBuffer<uchar> _buffer(scanlineSize+32);\n    uchar* buffer = _buffer;\n    if (!buffer)\n    {\n        TIFFClose(pTiffHandle);\n        return false;\n    }\n\n    for (int y = 0; y < height; ++y)\n    {\n        switch(channels)\n        {\n            case 1:\n            {\n                memcpy(buffer, img.data + img.step * y, scanlineSize);\n                break;\n            }\n\n            case 3:\n            {\n                if (depth == CV_8U)\n                    icvCvt_BGR2RGB_8u_C3R( img.data + img.step*y, 0, buffer, 0, cvSize(width,1) );\n                else\n                    icvCvt_BGR2RGB_16u_C3R( (const ushort*)(img.data + img.step*y), 0, (ushort*)buffer, 0, cvSize(width,1) );\n                break;\n            }\n\n            case 4:\n            {\n                if (depth == CV_8U)\n                    icvCvt_BGRA2RGBA_8u_C4R( img.data + img.step*y, 0, buffer, 0, cvSize(width,1) );\n                else\n                    icvCvt_BGRA2RGBA_16u_C4R( (const ushort*)(img.data + img.step*y), 0, (ushort*)buffer, 0, cvSize(width,1) );\n                break;\n            }\n\n            default:\n            {\n                TIFFClose(pTiffHandle);\n                return false;\n            }\n        }\n\n        int writeResult = TIFFWriteScanline(pTiffHandle, buffer, y, 0);\n        if (writeResult != 1)\n        {\n            TIFFClose(pTiffHandle);\n            return false;\n        }\n    }\n\n    TIFFClose(pTiffHandle);\n    return true;\n}\n\n#endif\n\n#ifdef HAVE_TIFF\nbool  TiffEncoder::write( const Mat& img, const vector<int>& params)\n#else\nbool  TiffEncoder::write( const Mat& img, const vector<int>& /*params*/)\n#endif\n{\n    int channels = img.channels();\n    int width = img.cols, height = img.rows;\n    int depth = img.depth();\n\n    if (depth != CV_8U && depth != CV_16U)\n        return false;\n\n    int bytesPerChannel = depth == CV_8U ? 1 : 2;\n    int fileStep = width * channels * bytesPerChannel;\n\n    WLByteStream strm;\n\n    if( m_buf )\n    {\n        if( !strm.open(*m_buf) )\n            return false;\n    }\n    else\n    {\n#ifdef HAVE_TIFF\n      return writeLibTiff(img, params);\n#else\n      if( !strm.open(m_filename) )\n          return false;\n#endif\n    }\n\n    int rowsPerStrip = (1 << 13)/fileStep;\n\n    if( rowsPerStrip < 1 )\n        rowsPerStrip = 1;\n\n    if( rowsPerStrip > height )\n        rowsPerStrip = height;\n\n    int i, stripCount = (height + rowsPerStrip - 1) / rowsPerStrip;\n\n    if( m_buf )\n        m_buf->reserve( alignSize(stripCount*8 + fileStep*height + 256, 256) );\n\n/*#if defined _DEBUG || !defined WIN32\n    int uncompressedRowSize = rowsPerStrip * fileStep;\n#endif*/\n    int directoryOffset = 0;\n\n    AutoBuffer<int> stripOffsets(stripCount);\n    AutoBuffer<short> stripCounts(stripCount);\n    AutoBuffer<uchar> _buffer(fileStep+32);\n    uchar* buffer = _buffer;\n    int  stripOffsetsOffset = 0;\n    int  stripCountsOffset = 0;\n    int  bitsPerSample = 8 * bytesPerChannel;\n    int  y = 0;\n\n    strm.putBytes( fmtSignTiffII, 4 );\n    strm.putDWord( directoryOffset );\n\n    // write an image data first (the most reasonable way\n    // for compressed images)\n    for( i = 0; i < stripCount; i++ )\n    {\n        int limit = y + rowsPerStrip;\n\n        if( limit > height )\n            limit = height;\n\n        stripOffsets[i] = strm.getPos();\n\n        for( ; y < limit; y++ )\n        {\n            if( channels == 3 )\n            {\n                if (depth == CV_8U)\n                    icvCvt_BGR2RGB_8u_C3R( img.data + img.step*y, 0, buffer, 0, cvSize(width,1) );\n                else\n                    icvCvt_BGR2RGB_16u_C3R( (const ushort*)(img.data + img.step*y), 0, (ushort*)buffer, 0, cvSize(width,1) );\n            }\n            else\n            {\n              if( channels == 4 )\n              {\n                if (depth == CV_8U)\n                    icvCvt_BGRA2RGBA_8u_C4R( img.data + img.step*y, 0, buffer, 0, cvSize(width,1) );\n                else\n                    icvCvt_BGRA2RGBA_16u_C4R( (const ushort*)(img.data + img.step*y), 0, (ushort*)buffer, 0, cvSize(width,1) );\n              }\n            }\n\n            strm.putBytes( channels > 1 ? buffer : img.data + img.step*y, fileStep );\n        }\n\n        stripCounts[i] = (short)(strm.getPos() - stripOffsets[i]);\n        /*assert( stripCounts[i] == uncompressedRowSize ||\n                stripCounts[i] < uncompressedRowSize &&\n                i == stripCount - 1);*/\n    }\n\n    if( stripCount > 2 )\n    {\n        stripOffsetsOffset = strm.getPos();\n        for( i = 0; i < stripCount; i++ )\n            strm.putDWord( stripOffsets[i] );\n\n        stripCountsOffset = strm.getPos();\n        for( i = 0; i < stripCount; i++ )\n            strm.putWord( stripCounts[i] );\n    }\n    else if(stripCount == 2)\n    {\n        stripOffsetsOffset = strm.getPos();\n        for (i = 0; i < stripCount; i++)\n        {\n            strm.putDWord (stripOffsets [i]);\n        }\n        stripCountsOffset = stripCounts [0] + (stripCounts [1] << 16);\n    }\n    else\n    {\n        stripOffsetsOffset = stripOffsets[0];\n        stripCountsOffset = stripCounts[0];\n    }\n\n    if( channels > 1 )\n    {\n        int bitsPerSamplePos = strm.getPos();\n        strm.putWord(bitsPerSample);\n        strm.putWord(bitsPerSample);\n        strm.putWord(bitsPerSample);\n        if( channels == 4 )\n            strm.putWord(bitsPerSample);\n        bitsPerSample = bitsPerSamplePos;\n    }\n\n    directoryOffset = strm.getPos();\n\n    // write header\n    strm.putWord( 9 );\n\n    /* warning: specification 5.0 of Tiff want to have tags in\n       ascending order. This is a non-fatal error, but this cause\n       warning with some tools. So, keep this in ascending order */\n\n    writeTag( strm, TIFF_TAG_WIDTH, TIFF_TYPE_LONG, 1, width );\n    writeTag( strm, TIFF_TAG_HEIGHT, TIFF_TYPE_LONG, 1, height );\n    writeTag( strm, TIFF_TAG_BITS_PER_SAMPLE,\n              TIFF_TYPE_SHORT, channels, bitsPerSample );\n    writeTag( strm, TIFF_TAG_COMPRESSION, TIFF_TYPE_LONG, 1, TIFF_UNCOMP );\n    writeTag( strm, TIFF_TAG_PHOTOMETRIC, TIFF_TYPE_SHORT, 1, channels > 1 ? 2 : 1 );\n\n    writeTag( strm, TIFF_TAG_STRIP_OFFSETS, TIFF_TYPE_LONG,\n              stripCount, stripOffsetsOffset );\n\n    writeTag( strm, TIFF_TAG_SAMPLES_PER_PIXEL, TIFF_TYPE_SHORT, 1, channels );\n    writeTag( strm, TIFF_TAG_ROWS_PER_STRIP, TIFF_TYPE_LONG, 1, rowsPerStrip );\n\n    writeTag( strm, TIFF_TAG_STRIP_COUNTS,\n              stripCount > 1 ? TIFF_TYPE_SHORT : TIFF_TYPE_LONG,\n              stripCount, stripCountsOffset );\n\n    strm.putDWord(0);\n    strm.close();\n\n    if( m_buf )\n    {\n        (*m_buf)[4] = (uchar)directoryOffset;\n        (*m_buf)[5] = (uchar)(directoryOffset >> 8);\n        (*m_buf)[6] = (uchar)(directoryOffset >> 16);\n        (*m_buf)[7] = (uchar)(directoryOffset >> 24);\n    }\n    else\n    {\n        // write directory offset\n        FILE* f = fopen( m_filename.c_str(), \"r+b\" );\n        buffer[0] = (uchar)directoryOffset;\n        buffer[1] = (uchar)(directoryOffset >> 8);\n        buffer[2] = (uchar)(directoryOffset >> 16);\n        buffer[3] = (uchar)(directoryOffset >> 24);\n\n        fseek( f, 4, SEEK_SET );\n        fwrite( buffer, 1, 4, f );\n        fclose(f);\n    }\n\n    return true;\n}\n\n}\n",
                "name": "grfmt_tiff.cpp",
                "path": "opencv/sources/modules/highgui/src/grfmt_tiff.cpp",
                "url": "/github.com/michaelreeves08/elmo-core/-/blob/opencv/sources/modules/highgui/src/grfmt_tiff.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 254,
                    "offsetAndLengths": [
                        [
                            37,
                            16
                        ]
                    ],
                    "preview": "                                ok = TIFFReadRGBATile( tif, x, y, (uint32*)buffer );"
                }
            ],
            "repository": {
                "name": "github.com/michaelreeves08/elmo-core",
                "url": "/github.com/michaelreeves08/elmo-core"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "8932c2bf78c729c285853e51c8875a863496b561"
                },
                "content": "/*M///////////////////////////////////////////////////////////////////////////////////////\n//\n//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.\n//\n//  By downloading, copying, installing or using the software you agree to this license.\n//  If you do not agree to this license, do not download, install,\n//  copy or use the software.\n//\n//\n//                        Intel License Agreement\n//                For Open Source Computer Vision Library\n//\n// Copyright (C) 2000, Intel Corporation, all rights reserved.\n// Third party copyrights are property of their respective owners.\n//\n// Redistribution and use in source and binary forms, with or without modification,\n// are permitted provided that the following conditions are met:\n//\n//   * Redistribution's of source code must retain the above copyright notice,\n//     this list of conditions and the following disclaimer.\n//\n//   * Redistribution's in binary form must reproduce the above copyright notice,\n//     this list of conditions and the following disclaimer in the documentation\n//     and/or other materials provided with the distribution.\n//\n//   * The name of Intel Corporation may not be used to endorse or promote products\n//     derived from this software without specific prior written permission.\n//\n// This software is provided by the copyright holders and contributors \"as is\" and\n// any express or implied warranties, including, but not limited to, the implied\n// warranties of merchantability and fitness for a particular purpose are disclaimed.\n// In no event shall the Intel Corporation or contributors be liable for any direct,\n// indirect, incidental, special, exemplary, or consequential damages\n// (including, but not limited to, procurement of substitute goods or services;\n// loss of use, data, or profits; or business interruption) however caused\n// and on any theory of liability, whether in contract, strict liability,\n// or tort (including negligence or otherwise) arising in any way out of\n// the use of this software, even if advised of the possibility of such damage.\n//\n//M*/\n\n/****************************************************************************************\\\n    A part of the file implements TIFF reader on base of libtiff library\n    (see otherlibs/_graphics/readme.txt for copyright notice)\n\\****************************************************************************************/\n\n#include \"_highgui.h\"\n#include \"grfmt_tiff.h\"\n\nstatic const char fmtSignTiffII[] = \"II\\x2a\\x00\";\nstatic const char fmtSignTiffMM[] = \"MM\\x00\\x2a\";\n\nGrFmtTiff::GrFmtTiff()\n{\n    m_sign_len = 4;\n    m_signature = \"\";\n    m_description = \"TIFF Files (*.tiff;*.tif)\";\n}\n\nGrFmtTiff::~GrFmtTiff()\n{\n}\n\nbool GrFmtTiff::CheckSignature( const char* signature )\n{\n    return memcmp( signature, fmtSignTiffII, 4 ) == 0 ||\n           memcmp( signature, fmtSignTiffMM, 4 ) == 0;\n}\n\n\nGrFmtReader* GrFmtTiff::NewReader( const char* filename )\n{\n    return new GrFmtTiffReader( filename );\n}\n\n\nGrFmtWriter* GrFmtTiff::NewWriter( const char* filename )\n{\n    return new GrFmtTiffWriter( filename );\n}\n\n\n#ifdef HAVE_TIFF\n\n#include \"tiff.h\"\n#include \"tiffio.h\"\n\nstatic int grfmt_tiff_err_handler_init = 0;\n\nstatic void GrFmtSilentTIFFErrorHandler( const char*, const char*, va_list ) {}\n\nGrFmtTiffReader::GrFmtTiffReader( const char* filename ) : GrFmtReader( filename )\n{\n    m_tif = 0;\n\n    if( !grfmt_tiff_err_handler_init )\n    {\n        grfmt_tiff_err_handler_init = 1;\n\n        TIFFSetErrorHandler( GrFmtSilentTIFFErrorHandler );\n        TIFFSetWarningHandler( GrFmtSilentTIFFErrorHandler );\n    }\n}\n\n\nGrFmtTiffReader::~GrFmtTiffReader()\n{\n}\n\n\nvoid  GrFmtTiffReader::Close()\n{\n    if( m_tif )\n    {\n        TIFF* tif = (TIFF*)m_tif;\n        TIFFClose( tif );\n        m_tif = 0;\n    }\n}\n\n\nbool  GrFmtTiffReader::CheckFormat( const char* signature )\n{\n    return memcmp( signature, fmtSignTiffII, 4 ) == 0 ||\n           memcmp( signature, fmtSignTiffMM, 4 ) == 0;\n}\n\n\nbool  GrFmtTiffReader::ReadHeader()\n{\n    char errmsg[1024];\n    bool result = false;\n\n    Close();\n    TIFF* tif = TIFFOpen( m_filename, \"r\" );\n\n    if( tif )\n    {\n        int width = 0, height = 0, photometric = 0, compression = 0;\n        m_tif = tif;\n\n        if( TIFFRGBAImageOK( tif, errmsg ) &&\n            TIFFGetField( tif, TIFFTAG_IMAGEWIDTH, &width ) &&\n            TIFFGetField( tif, TIFFTAG_IMAGELENGTH, &height ) &&\n            TIFFGetField( tif, TIFFTAG_PHOTOMETRIC, &photometric ) && \n            (!TIFFGetField( tif, TIFFTAG_COMPRESSION, &compression ) ||\n            (compression != COMPRESSION_LZW &&\n             compression != COMPRESSION_OJPEG)))\n        {\n            m_width = width;\n            m_height = height;\n            m_iscolor = photometric > 1;\n            \n            result = true;\n        }\n    }\n\n    if( !result )\n        Close();\n\n    return result;\n}\n\n\nbool  GrFmtTiffReader::ReadData( uchar* data, int step, int color )\n{\n    bool result = false;\n    uchar* buffer = 0;\n\n    color = color > 0 || (color < 0 && m_iscolor);\n\n    if( m_tif && m_width && m_height )\n    {\n        TIFF* tif = (TIFF*)m_tif;\n        int tile_width0 = m_width, tile_height0 = 0;\n        int x, y, i;\n        int is_tiled = TIFFIsTiled(tif);\n        \n        if( !is_tiled &&\n            TIFFGetField( tif, TIFFTAG_ROWSPERSTRIP, &tile_height0 ) ||\n            is_tiled &&\n            TIFFGetField( tif, TIFFTAG_TILEWIDTH, &tile_width0 ) &&\n            TIFFGetField( tif, TIFFTAG_TILELENGTH, &tile_height0 ))\n        {\n            if( tile_width0 <= 0 )\n                tile_width0 = m_width;\n\n            if( tile_height0 <= 0 )\n                tile_height0 = m_height;\n            \n            buffer = new uchar[tile_height0*tile_width0*4];\n\n            for( y = 0; y < m_height; y += tile_height0, data += step*tile_height0 )\n            {\n                int tile_height = tile_height0;\n\n                if( y + tile_height > m_height )\n                    tile_height = m_height - y;\n\n                for( x = 0; x < m_width; x += tile_width0 )\n                {\n                    int tile_width = tile_width0, ok;\n\n                    if( x + tile_width > m_width )\n                        tile_width = m_width - x;\n\n                    if( !is_tiled )\n                        ok = TIFFReadRGBAStrip( tif, y, (uint32*)buffer );\n                    else\n                        ok = TIFFReadRGBATile( tif, x, y, (uint32*)buffer );\n\n                    if( !ok )\n                        goto exit_func;\n\n                    for( i = 0; i < tile_height; i++ )\n                        if( color )\n                            icvCvt_BGRA2BGR_8u_C4C3R( buffer + i*tile_width*4, 0,\n                                          data + x*3 + step*(tile_height - i - 1), 0,\n                                          cvSize(tile_width,1), 2 );\n                        else\n                            icvCvt_BGRA2Gray_8u_C4C1R( buffer + i*tile_width*4, 0,\n                                           data + x + step*(tile_height - i - 1), 0,\n                                           cvSize(tile_width,1), 2 );\n                }\n            }\n\n            result = true;\n        }\n    }\n\nexit_func:\n\n    Close();\n    delete[] buffer;\n\n    return result;\n}\n\n#else\n\nstatic const int  tiffMask[] = { 0xff, 0xff, 0xffffffff, 0xffff, 0xffffffff };\n\n/************************ TIFF reader *****************************/\n\nGrFmtTiffReader::GrFmtTiffReader( const char* filename ) : GrFmtReader( filename )\n{\n    m_offsets = 0;\n    m_maxoffsets = 0;\n    m_strips = -1;\n    m_max_pal_length = 0;\n    m_temp_palette = 0;\n}\n\n\nGrFmtTiffReader::~GrFmtTiffReader()\n{\n    Close();\n\n    delete[] m_offsets;\n    delete[] m_temp_palette;\n}\n\nvoid  GrFmtTiffReader::Close()\n{\n    m_strm.Close();\n}\n\n\nbool  GrFmtTiffReader::CheckFormat( const char* signature )\n{\n    return memcmp( signature, fmtSignTiffII, 4 ) == 0 ||\n           memcmp( signature, fmtSignTiffMM, 4 ) == 0;\n}\n\n\nint   GrFmtTiffReader::GetWordEx()\n{\n    int val = m_strm.GetWord();\n    if( m_byteorder == TIFF_ORDER_MM )\n        val = ((val)>>8)|(((val)&0xff)<<8);\n    return val;\n}\n\n\nint   GrFmtTiffReader::GetDWordEx()\n{\n    int val = m_strm.GetDWord();\n    if( m_byteorder == TIFF_ORDER_MM )\n        val = BSWAP( val );\n    return val;\n}\n\n\nint  GrFmtTiffReader::ReadTable( int offset, int count,\n                                 TiffFieldType fieldType,\n                                 int*& array, int& arraysize )\n{\n    int i;\n    \n    if( count < 0 )\n        return RBS_BAD_HEADER;\n    \n    if( fieldType != TIFF_TYPE_SHORT &&\n        fieldType != TIFF_TYPE_LONG &&\n        fieldType != TIFF_TYPE_BYTE )\n        return RBS_BAD_HEADER;\n\n    if( count > arraysize )\n    {\n        delete[] array;\n        arraysize = arraysize*3/2;\n        if( arraysize < count )\n            arraysize = count;\n        array = new int[arraysize];\n    }\n\n    if( count > 1 )\n    {\n        int pos = m_strm.GetPos();\n        m_strm.SetPos( offset );\n\n        if( fieldType == TIFF_TYPE_LONG )\n        {\n            if( m_byteorder == TIFF_ORDER_MM )\n                for( i = 0; i < count; i++ )\n                    array[i] = ((RMByteStream&)m_strm).GetDWord();\n            else\n                for( i = 0; i < count; i++ )\n                    array[i] = ((RLByteStream&)m_strm).GetDWord();\n        }\n        else if( fieldType == TIFF_TYPE_SHORT )\n        {\n            if( m_byteorder == TIFF_ORDER_MM )\n                for( i = 0; i < count; i++ )\n                    array[i] = ((RMByteStream&)m_strm).GetWord();\n            else\n                for( i = 0; i < count; i++ )\n                    array[i] = ((RLByteStream&)m_strm).GetWord();\n        }\n        else // fieldType == TIFF_TYPE_BYTE\n            for( i = 0; i < count; i++ )\n                array[i] = m_strm.GetByte();\n\n        m_strm.SetPos(pos);\n    }\n    else\n    {\n        assert( (offset & ~tiffMask[fieldType]) == 0 );\n        array[0] = offset;\n    }\n\n    return 0;\n}\n\n\nbool  GrFmtTiffReader::ReadHeader()\n{\n    bool result = false;\n    int  photometric = -1;\n    int  channels = 1;\n    int  pal_length = -1;\n\n    const int MAX_CHANNELS = 4;\n    int  bpp_arr[MAX_CHANNELS];\n\n    assert( strlen(m_filename) != 0 );\n    if( !m_strm.Open( m_filename )) return false;\n\n    m_width = -1;\n    m_height = -1;\n    m_strips = -1;\n    m_bpp = 1;\n    m_compression = TIFF_UNCOMP;\n    m_rows_per_strip = -1;\n    m_iscolor = false;\n\n    if( setjmp( m_strm.JmpBuf()) == 0 )\n    {\n        m_byteorder = (TiffByteOrder)m_strm.GetWord();\n        m_strm.Skip( 2 );\n        int header_offset = GetDWordEx();\n\n        m_strm.SetPos( header_offset );\n\n        // read the first tag directory\n        int i, j, count = GetWordEx();\n\n        for( i = 0; i < count; i++ )\n        {\n            // read tag\n            TiffTag tag = (TiffTag)GetWordEx();\n            TiffFieldType fieldType = (TiffFieldType)GetWordEx();\n            int count = GetDWordEx();\n            int value = GetDWordEx();\n            if( count == 1 )\n            {\n                if( m_byteorder == TIFF_ORDER_MM )\n                {\n                    if( fieldType == TIFF_TYPE_SHORT )\n                        value = (unsigned)value >> 16;\n                    else if( fieldType == TIFF_TYPE_BYTE )\n                        value = (unsigned)value >> 24;\n                }\n\n                value &= tiffMask[fieldType];\n            }\n\n            switch( tag )\n            {\n            case  TIFF_TAG_WIDTH:\n                m_width = value;\n                break;\n\n            case  TIFF_TAG_HEIGHT:\n                m_height = value;\n                break;\n\n            case  TIFF_TAG_BITS_PER_SAMPLE:\n                {\n                    int* bpp_arr_ref = bpp_arr;\n\n                    if( count > MAX_CHANNELS )\n                        BAD_HEADER_ERR();\n\n                    if( ReadTable( value, count, fieldType, bpp_arr_ref, count ) < 0 )\n                        BAD_HEADER_ERR();\n                \n                    for( j = 1; j < count; j++ )\n                    {\n                        if( bpp_arr[j] != bpp_arr[0] )\n                            BAD_HEADER_ERR();\n                    }\n\n                    m_bpp = bpp_arr[0];\n                }\n\n                break;\n\n            case  TIFF_TAG_COMPRESSION:\n                m_compression = (TiffCompression)value;\n                if( m_compression != TIFF_UNCOMP &&\n                    m_compression != TIFF_HUFFMAN &&\n                    m_compression != TIFF_PACKBITS )\n                    BAD_HEADER_ERR();\n                break;\n\n            case  TIFF_TAG_PHOTOMETRIC:\n                photometric = value;\n                if( (unsigned)photometric > 3 )\n                    BAD_HEADER_ERR();\n                break;\n\n            case  TIFF_TAG_STRIP_OFFSETS:\n                m_strips = count;\n                if( ReadTable( value, count, fieldType, m_offsets, m_maxoffsets ) < 0 )\n                    BAD_HEADER_ERR();\n                break;\n\n            case  TIFF_TAG_SAMPLES_PER_PIXEL:\n                channels = value;\n                if( channels != 1 && channels != 3 && channels != 4 )\n                    BAD_HEADER_ERR();\n                break;\n\n            case  TIFF_TAG_ROWS_PER_STRIP:\n                m_rows_per_strip = value;\n                break;\n\n            case  TIFF_TAG_PLANAR_CONFIG:\n                {\n                int planar_config = value;\n                if( planar_config != 1 )\n                    BAD_HEADER_ERR();\n                }\n                break;\n\n            case  TIFF_TAG_COLOR_MAP:\n                if( fieldType != TIFF_TYPE_SHORT || count < 2 )\n                    BAD_HEADER_ERR();\n                if( ReadTable( value, count, fieldType,\n                               m_temp_palette, m_max_pal_length ) < 0 )\n                    BAD_HEADER_ERR();\n                pal_length = count / 3;\n                if( pal_length > 256 )\n                    BAD_HEADER_ERR();\n                for( i = 0; i < pal_length; i++ )\n                {\n                    m_palette[i].r = (uchar)(m_temp_palette[i] >> 8);\n                    m_palette[i].g = (uchar)(m_temp_palette[i + pal_length] >> 8);\n                    m_palette[i].b = (uchar)(m_temp_palette[i + pal_length*2] >> 8);\n                }\n                break;\n            case  TIFF_TAG_STRIP_COUNTS:\n                break;\n            }\n        }\n\n        if( m_strips == 1 && m_rows_per_strip == -1 )\n            m_rows_per_strip = m_height;\n\n        if( m_width > 0 && m_height > 0 && m_strips > 0 &&\n            (m_height + m_rows_per_strip - 1)/m_rows_per_strip == m_strips )\n        {\n            switch( m_bpp )\n            {\n            case 1:\n                if( photometric == 0 || photometric == 1 && channels == 1 )\n                {\n                    FillGrayPalette( m_palette, m_bpp, photometric == 0 );\n                    result = true;\n                    m_iscolor = false;\n                }\n                break;\n            case 4:\n            case 8:\n                if( (photometric == 0 || photometric == 1 ||\n                     photometric == 3 && pal_length == (1 << m_bpp)) &&\n                    m_compression != TIFF_HUFFMAN && channels == 1 )\n                {\n                    if( pal_length < 0 )\n                    {\n                        FillGrayPalette( m_palette, m_bpp, photometric == 0 );\n                        m_iscolor = false;\n                    }\n                    else\n                    {\n                        m_iscolor = IsColorPalette( m_palette, m_bpp );\n                    }\n                    result = true;\n                }\n                else if( photometric == 2 && pal_length < 0 &&\n                         (channels == 3 || channels == 4) &&\n                         m_compression == TIFF_UNCOMP )\n                {\n                    m_bpp = 8*channels;\n                    m_iscolor = true;\n                    result = true;\n                }\n                break;\n            default:\n                BAD_HEADER_ERR();\n            }\n        }\nbad_header_exit:\n        ;\n    }\n\n    if( !result )\n    {\n        m_strips = -1;\n        m_width = m_height = -1;\n        m_strm.Close();\n    }\n\n    return result;\n}\n\n\nbool  GrFmtTiffReader::ReadData( uchar* data, int step, int color )\n{\n    const  int buffer_size = 1 << 12;\n    uchar  buffer[buffer_size];\n    uchar  gray_palette[256];\n    bool   result = false;\n    uchar* src = buffer;\n    int    src_pitch = (m_width*m_bpp + 7)/8;\n    int    y = 0;\n\n    if( m_strips < 0 || !m_strm.IsOpened())\n        return false;\n    \n    if( src_pitch+32 > buffer_size )\n        src = new uchar[src_pitch+32];\n\n    if( !color )\n        if( m_bpp <= 8 )\n        {\n            CvtPaletteToGray( m_palette, gray_palette, 1 << m_bpp );\n        }\n\n    if( setjmp( m_strm.JmpBuf()) == 0 )\n    {\n        for( int s = 0; s < m_strips; s++ )\n        {\n            int y_limit = m_rows_per_strip;\n\n            y_limit += y;\n            if( y_limit > m_height ) y_limit = m_height;\n\n            m_strm.SetPos( m_offsets[s] );\n\n            if( m_compression == TIFF_UNCOMP )\n            {\n                for( ; y < y_limit; y++, data += step )\n                {\n                    m_strm.GetBytes( src, src_pitch );\n                    if( color )\n                        switch( m_bpp )\n                        {\n                        case 1:\n                            FillColorRow1( data, src, m_width, m_palette );\n                            break;\n                        case 4:\n                            FillColorRow4( data, src, m_width, m_palette );\n                            break;\n                        case 8:\n                            FillColorRow8( data, src, m_width, m_palette );\n                            break;\n                        case 24:\n                            icvCvt_RGB2BGR_8u_C3R( src, 0, data, 0, cvSize(m_width,1) );\n                            break;\n                        case 32:\n                            icvCvt_BGRA2BGR_8u_C4C3R( src, 0, data, 0, cvSize(m_width,1), 2 );\n                            break;\n                        default:\n                            assert(0);\n                            goto bad_decoding_end;\n                        }\n                    else\n                        switch( m_bpp )\n                        {\n                        case 1:\n                            FillGrayRow1( data, src, m_width, gray_palette );\n                            break;\n                        case 4:\n                            FillGrayRow4( data, src, m_width, gray_palette );\n                            break;\n                        case 8:\n                            FillGrayRow8( data, src, m_width, gray_palette );\n                            break;\n                        case 24:\n                            icvCvt_BGR2Gray_8u_C3C1R( src, 0, data, 0, cvSize(m_width,1), 2 );\n                            break;\n                        case 32:\n                            icvCvt_BGRA2Gray_8u_C4C1R( src, 0, data, 0, cvSize(m_width,1), 2 );\n                            break;\n                        default:\n                            assert(0);\n                            goto bad_decoding_end;\n                        }\n                }\n            }\n            else\n            {\n            }\n\n            result = true;\n\nbad_decoding_end:\n\n            ;\n        }\n    }\n\n    if( src != buffer ) delete[] src; \n    return result;\n}\n\n#endif\n\n//////////////////////////////////////////////////////////////////////////////////////////\n\nGrFmtTiffWriter::GrFmtTiffWriter( const char* filename ) : GrFmtWriter( filename )\n{\n}\n\nGrFmtTiffWriter::~GrFmtTiffWriter()\n{\n}\n\nvoid  GrFmtTiffWriter::WriteTag( TiffTag tag, TiffFieldType fieldType,\n                                 int count, int value )\n{\n    m_strm.PutWord( tag );\n    m_strm.PutWord( fieldType );\n    m_strm.PutDWord( count );\n    m_strm.PutDWord( value );\n}\n\n\nbool  GrFmtTiffWriter::WriteImage( const uchar* data, int step,\n                                   int width, int height, int /*depth*/, int channels )\n{\n    bool result = false;\n    int fileStep = width*channels;\n\n    assert( data && width > 0 && height > 0 && step >= fileStep);\n\n    if( m_strm.Open( m_filename ) )\n    {\n        int rowsPerStrip = (1 << 13)/fileStep;\n\n        if( rowsPerStrip < 1 )\n            rowsPerStrip = 1;\n\n        if( rowsPerStrip > height )\n            rowsPerStrip = height;\n\n        int i, stripCount = (height + rowsPerStrip - 1) / rowsPerStrip;\n/*#if defined _DEBUG || !defined WIN32\n        int uncompressedRowSize = rowsPerStrip * fileStep;\n#endif*/\n        int directoryOffset = 0;\n\n        int* stripOffsets = new int[stripCount];\n        short* stripCounts = new short[stripCount];\n        uchar* buffer = new uchar[fileStep + 32];\n        int  stripOffsetsOffset = 0;\n        int  stripCountsOffset = 0;\n        int  bitsPerSample = 8; // TODO support 16 bit\n        int  y = 0;\n\n        m_strm.PutBytes( fmtSignTiffII, 4 );\n        m_strm.PutDWord( directoryOffset );\n\n        // write an image data first (the most reasonable way\n        // for compressed images)\n        for( i = 0; i < stripCount; i++ )\n        {\n            int limit = y + rowsPerStrip;\n\n            if( limit > height )\n                limit = height;\n\n            stripOffsets[i] = m_strm.GetPos();\n\n            for( ; y < limit; y++, data += step )\n            {\n                if( channels == 3 )\n                    icvCvt_BGR2RGB_8u_C3R( data, 0, buffer, 0, cvSize(width,1) );\n                else if( channels == 4 )\n                    icvCvt_BGRA2RGBA_8u_C4R( data, 0, buffer, 0, cvSize(width,1) );\n\n                m_strm.PutBytes( channels > 1 ? buffer : data, fileStep );\n            }\n\n            stripCounts[i] = (short)(m_strm.GetPos() - stripOffsets[i]);\n            /*assert( stripCounts[i] == uncompressedRowSize ||\n                    stripCounts[i] < uncompressedRowSize &&\n                    i == stripCount - 1);*/\n        }\n\n        if( stripCount > 2 )\n        {\n            stripOffsetsOffset = m_strm.GetPos();\n            for( i = 0; i < stripCount; i++ )\n                m_strm.PutDWord( stripOffsets[i] );\n\n            stripCountsOffset = m_strm.GetPos();\n            for( i = 0; i < stripCount; i++ )\n                m_strm.PutWord( stripCounts[i] );\n        }\n        else if(stripCount == 2)\n        {\n            stripOffsetsOffset = m_strm.GetPos();\n            for (i = 0; i < stripCount; i++)\n            {\n                m_strm.PutDWord (stripOffsets [i]);\n            }\n            stripCountsOffset = stripCounts [0] + (stripCounts [1] << 16);\n        }\n        else\n        {\n            stripOffsetsOffset = stripOffsets[0];\n            stripCountsOffset = stripCounts[0];\n        }\n\n        if( channels > 1 )\n        {\n            bitsPerSample = m_strm.GetPos();\n            m_strm.PutWord(8);\n            m_strm.PutWord(8);\n            m_strm.PutWord(8);\n            if( channels == 4 )\n                m_strm.PutWord(8);\n        }\n\n        directoryOffset = m_strm.GetPos();\n\n        // write header\n        m_strm.PutWord( 9 );\n\n        /* warning: specification 5.0 of Tiff want to have tags in\n           ascending order. This is a non-fatal error, but this cause\n           warning with some tools. So, keep this in ascending order */\n\n        WriteTag( TIFF_TAG_WIDTH, TIFF_TYPE_LONG, 1, width );\n        WriteTag( TIFF_TAG_HEIGHT, TIFF_TYPE_LONG, 1, height );\n        WriteTag( TIFF_TAG_BITS_PER_SAMPLE,\n                  TIFF_TYPE_SHORT, channels, bitsPerSample );\n        WriteTag( TIFF_TAG_COMPRESSION, TIFF_TYPE_LONG, 1, TIFF_UNCOMP );\n        WriteTag( TIFF_TAG_PHOTOMETRIC, TIFF_TYPE_SHORT, 1, channels > 1 ? 2 : 1 );\n\n        WriteTag( TIFF_TAG_STRIP_OFFSETS, TIFF_TYPE_LONG,\n                  stripCount, stripOffsetsOffset );\n\n        WriteTag( TIFF_TAG_SAMPLES_PER_PIXEL, TIFF_TYPE_SHORT, 1, channels );\n        WriteTag( TIFF_TAG_ROWS_PER_STRIP, TIFF_TYPE_LONG, 1, rowsPerStrip );\n        \n        WriteTag( TIFF_TAG_STRIP_COUNTS,\n                  stripCount > 1 ? TIFF_TYPE_SHORT : TIFF_TYPE_LONG,\n                  stripCount, stripCountsOffset );\n\n        m_strm.PutDWord(0);\n        m_strm.Close();\n\n        // write directory offset\n        FILE* f = fopen( m_filename, \"r+b\" );\n        buffer[0] = (uchar)directoryOffset;\n        buffer[1] = (uchar)(directoryOffset >> 8);\n        buffer[2] = (uchar)(directoryOffset >> 16);\n        buffer[3] = (uchar)(directoryOffset >> 24);\n\n        fseek( f, 4, SEEK_SET );\n        fwrite( buffer, 1, 4, f );\n        fclose(f);\n\n        delete[]  stripOffsets;\n        delete[]  stripCounts;\n        delete[] buffer;\n\n        result = true;\n    }\n    return result;\n}\n\n",
                "name": "grfmt_tiff.cpp",
                "path": "Platform Software/myriad/libs/leon/OpenCV/grfmt_tiff.cpp",
                "url": "/github.com/EyesOfThings/Software/-/blob/Platform%20Software/myriad/libs/leon/OpenCV/grfmt_tiff.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 209,
                    "offsetAndLengths": [
                        [
                            29,
                            16
                        ]
                    ],
                    "preview": "                        ok = TIFFReadRGBATile( tif, x, y, (uint32*)buffer );"
                }
            ],
            "repository": {
                "name": "github.com/EyesOfThings/Software",
                "url": "/github.com/EyesOfThings/Software"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "5994bb9cf7a11981b830370db206bceb654c085d"
                },
                "content": "/*M///////////////////////////////////////////////////////////////////////////////////////\n//\n//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.\n//\n//  By downloading, copying, installing or using the software you agree to this license.\n//  If you do not agree to this license, do not download, install,\n//  copy or use the software.\n//\n//\n//                           License Agreement\n//                For Open Source Computer Vision Library\n//\n// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.\n// Copyright (C) 2009, Willow Garage Inc., all rights reserved.\n// Third party copyrights are property of their respective owners.\n//\n// Redistribution and use in source and binary forms, with or without modification,\n// are permitted provided that the following conditions are met:\n//\n//   * Redistribution's of source code must retain the above copyright notice,\n//     this list of conditions and the following disclaimer.\n//\n//   * Redistribution's in binary form must reproduce the above copyright notice,\n//     this list of conditions and the following disclaimer in the documentation\n//     and/or other materials provided with the distribution.\n//\n//   * The name of the copyright holders may not be used to endorse or promote products\n//     derived from this software without specific prior written permission.\n//\n// This software is provided by the copyright holders and contributors \"as is\" and\n// any express or implied warranties, including, but not limited to, the implied\n// warranties of merchantability and fitness for a particular purpose are disclaimed.\n// In no event shall the Intel Corporation or contributors be liable for any direct,\n// indirect, incidental, special, exemplary, or consequential damages\n// (including, but not limited to, procurement of substitute goods or services;\n// loss of use, data, or profits; or business interruption) however caused\n// and on any theory of liability, whether in contract, strict liability,\n// or tort (including negligence or otherwise) arising in any way out of\n// the use of this software, even if advised of the possibility of such damage.\n//\n//M*/\n\n/****************************************************************************************\\\n    A part of the file implements TIFF reader on base of libtiff library\n    (see otherlibs/_graphics/readme.txt for copyright notice)\n\\****************************************************************************************/\n\n#include \"precomp.hpp\"\n#include \"grfmt_tiff.hpp\"\n#include <opencv2/imgproc.hpp>\n\nnamespace cv\n{\nstatic const char fmtSignTiffII[] = \"II\\x2a\\x00\";\nstatic const char fmtSignTiffMM[] = \"MM\\x00\\x2a\";\n\n#ifdef HAVE_TIFF\n\n#include \"tiff.h\"\n#include \"tiffio.h\"\n\nstatic int grfmt_tiff_err_handler_init = 0;\nstatic void GrFmtSilentTIFFErrorHandler( const char*, const char*, va_list ) {}\n\nTiffDecoder::TiffDecoder()\n{\n    m_tif = 0;\n    if( !grfmt_tiff_err_handler_init )\n    {\n        grfmt_tiff_err_handler_init = 1;\n\n        TIFFSetErrorHandler( GrFmtSilentTIFFErrorHandler );\n        TIFFSetWarningHandler( GrFmtSilentTIFFErrorHandler );\n    }\n    m_hdr = false;\n}\n\n\nvoid TiffDecoder::close()\n{\n    if( m_tif )\n    {\n        TIFF* tif = (TIFF*)m_tif;\n        TIFFClose( tif );\n        m_tif = 0;\n    }\n}\n\nTiffDecoder::~TiffDecoder()\n{\n    close();\n}\n\nsize_t TiffDecoder::signatureLength() const\n{\n    return 4;\n}\n\nbool TiffDecoder::checkSignature( const String& signature ) const\n{\n    return signature.size() >= 4 &&\n        (memcmp(signature.c_str(), fmtSignTiffII, 4) == 0 ||\n        memcmp(signature.c_str(), fmtSignTiffMM, 4) == 0);\n}\n\nint TiffDecoder::normalizeChannelsNumber(int channels) const\n{\n    return channels > 4 ? 4 : channels;\n}\n\nImageDecoder TiffDecoder::newDecoder() const\n{\n    return makePtr<TiffDecoder>();\n}\n\nbool TiffDecoder::readHeader()\n{\n    bool result = false;\n\n    close();\n    // TIFFOpen() mode flags are different to fopen().  A 'b' in mode \"rb\" has no effect when reading.\n    // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n    TIFF* tif = TIFFOpen( m_filename.c_str(), \"r\" );\n\n    if( tif )\n    {\n        uint32 wdth = 0, hght = 0;\n        uint16 photometric = 0;\n        m_tif = tif;\n\n        if( TIFFGetField( tif, TIFFTAG_IMAGEWIDTH, &wdth ) &&\n            TIFFGetField( tif, TIFFTAG_IMAGELENGTH, &hght ) &&\n            TIFFGetField( tif, TIFFTAG_PHOTOMETRIC, &photometric ))\n        {\n            uint16 bpp=8, ncn = photometric > 1 ? 3 : 1;\n            TIFFGetField( tif, TIFFTAG_BITSPERSAMPLE, &bpp );\n            TIFFGetField( tif, TIFFTAG_SAMPLESPERPIXEL, &ncn );\n\n            m_width = wdth;\n            m_height = hght;\n            if((bpp == 32 && ncn == 3) || photometric == PHOTOMETRIC_LOGLUV)\n            {\n                m_type = CV_32FC3;\n                m_hdr = true;\n                return true;\n            }\n            m_hdr = false;\n\n            if( bpp > 8 &&\n               ((photometric != 2 && photometric != 1) ||\n                (ncn != 1 && ncn != 3 && ncn != 4)))\n                bpp = 8;\n\n            int wanted_channels = normalizeChannelsNumber(ncn);\n            switch(bpp)\n            {\n                case 8:\n                    m_type = CV_MAKETYPE(CV_8U, photometric > 1 ? wanted_channels : 1);\n                    break;\n                case 16:\n                    m_type = CV_MAKETYPE(CV_16U, photometric > 1 ? wanted_channels : 1);\n                    break;\n\n                case 32:\n                    m_type = CV_MAKETYPE(CV_32F, photometric > 1 ? 3 : 1);\n                    break;\n                case 64:\n                    m_type = CV_MAKETYPE(CV_64F, photometric > 1 ? 3 : 1);\n                    break;\n\n                default:\n                    result = false;\n            }\n            result = true;\n        }\n    }\n\n    if( !result )\n        close();\n\n    return result;\n}\n\n\nbool  TiffDecoder::readData( Mat& img )\n{\n    if(m_hdr && img.type() == CV_32FC3)\n    {\n        return readHdrData(img);\n    }\n    bool result = false;\n    bool color = img.channels() > 1;\n    uchar* data = img.ptr();\n\n    if( img.depth() != CV_8U && img.depth() != CV_16U && img.depth() != CV_32F && img.depth() != CV_64F )\n        return false;\n\n    if( m_tif && m_width && m_height )\n    {\n        TIFF* tif = (TIFF*)m_tif;\n        uint32 tile_width0 = m_width, tile_height0 = 0;\n        int x, y, i;\n        int is_tiled = TIFFIsTiled(tif);\n        uint16 photometric;\n        TIFFGetField( tif, TIFFTAG_PHOTOMETRIC, &photometric );\n        uint16 bpp = 8, ncn = photometric > 1 ? 3 : 1;\n        TIFFGetField( tif, TIFFTAG_BITSPERSAMPLE, &bpp );\n        TIFFGetField( tif, TIFFTAG_SAMPLESPERPIXEL, &ncn );\n        const int bitsPerByte = 8;\n        int dst_bpp = (int)(img.elemSize1() * bitsPerByte);\n        int wanted_channels = normalizeChannelsNumber(img.channels());\n\n        if(dst_bpp == 8)\n        {\n            char errmsg[1024];\n            if(!TIFFRGBAImageOK( tif, errmsg ))\n            {\n                close();\n                return false;\n            }\n        }\n\n        if( (!is_tiled) ||\n            (is_tiled &&\n            TIFFGetField( tif, TIFFTAG_TILEWIDTH, &tile_width0 ) &&\n            TIFFGetField( tif, TIFFTAG_TILELENGTH, &tile_height0 )))\n        {\n            if(!is_tiled)\n                TIFFGetField( tif, TIFFTAG_ROWSPERSTRIP, &tile_height0 );\n\n            if( tile_width0 <= 0 )\n                tile_width0 = m_width;\n\n            if( tile_height0 <= 0 )\n                tile_height0 = m_height;\n\n            AutoBuffer<uchar> _buffer( size_t(8) * tile_height0*tile_width0);\n            uchar* buffer = _buffer;\n            ushort* buffer16 = (ushort*)buffer;\n            float* buffer32 = (float*)buffer;\n            double* buffer64 = (double*)buffer;\n            int tileidx = 0;\n\n            for( y = 0; y < m_height; y += tile_height0, data += img.step*tile_height0 )\n            {\n                int tile_height = tile_height0;\n\n                if( y + tile_height > m_height )\n                    tile_height = m_height - y;\n\n                for( x = 0; x < m_width; x += tile_width0, tileidx++ )\n                {\n                    int tile_width = tile_width0, ok;\n\n                    if( x + tile_width > m_width )\n                        tile_width = m_width - x;\n\n                    switch(dst_bpp)\n                    {\n                        case 8:\n                        {\n                            uchar * bstart = buffer;\n                            if( !is_tiled )\n                                ok = TIFFReadRGBAStrip( tif, y, (uint32*)buffer );\n                            else\n                            {\n                                ok = TIFFReadRGBATile( tif, x, y, (uint32*)buffer );\n                                //Tiles fill the buffer from the bottom up\n                                bstart += (tile_height0 - tile_height) * tile_width0 * 4;\n                            }\n                            if( !ok )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                                if( color )\n                                {\n                                    if (wanted_channels == 4)\n                                    {\n                                        icvCvt_BGRA2RGBA_8u_C4R( bstart + i*tile_width0*4, 0,\n                                                             data + x*4 + img.step*(tile_height - i - 1), 0,\n                                                             cvSize(tile_width,1) );\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2BGR_8u_C4C3R( bstart + i*tile_width0*4, 0,\n                                                             data + x*3 + img.step*(tile_height - i - 1), 0,\n                                                             cvSize(tile_width,1), 2 );\n                                    }\n                                }\n                                else\n                                    icvCvt_BGRA2Gray_8u_C4C1R( bstart + i*tile_width0*4, 0,\n                                                              data + x + img.step*(tile_height - i - 1), 0,\n                                                              cvSize(tile_width,1), 2 );\n                            break;\n                        }\n\n                        case 16:\n                        {\n                            if( !is_tiled )\n                                ok = (int)TIFFReadEncodedStrip( tif, tileidx, (uint32*)buffer, (tsize_t)-1 ) >= 0;\n                            else\n                                ok = (int)TIFFReadEncodedTile( tif, tileidx, (uint32*)buffer, (tsize_t)-1 ) >= 0;\n\n                            if( !ok )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                            {\n                                if( color )\n                                {\n                                    if( ncn == 1 )\n                                    {\n                                        icvCvt_Gray2BGR_16u_C1C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                                  (ushort*)(data + img.step*i) + x*3, 0,\n                                                                  cvSize(tile_width,1) );\n                                    }\n                                    else if( ncn == 3 )\n                                    {\n                                        icvCvt_RGB2BGR_16u_C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                               (ushort*)(data + img.step*i) + x*3, 0,\n                                                               cvSize(tile_width,1) );\n                                    }\n                                    else if (ncn == 4)\n                                    {\n                                        if (wanted_channels == 4)\n                                        {\n                                            icvCvt_BGRA2RGBA_16u_C4R(buffer16 + i*tile_width0*ncn, 0,\n                                                (ushort*)(data + img.step*i) + x * 4, 0,\n                                                cvSize(tile_width, 1));\n                                        }\n                                        else\n                                        {\n                                            icvCvt_BGRA2BGR_16u_C4C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                (ushort*)(data + img.step*i) + x * 3, 0,\n                                                cvSize(tile_width, 1), 2);\n                                        }\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2BGR_16u_C4C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                               (ushort*)(data + img.step*i) + x*3, 0,\n                                                               cvSize(tile_width,1), 2 );\n                                    }\n                                }\n                                else\n                                {\n                                    if( ncn == 1 )\n                                    {\n                                        memcpy((ushort*)(data + img.step*i)+x,\n                                               buffer16 + i*tile_width0*ncn,\n                                               tile_width*sizeof(buffer16[0]));\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2Gray_16u_CnC1R(buffer16 + i*tile_width0*ncn, 0,\n                                                               (ushort*)(data + img.step*i) + x, 0,\n                                                               cvSize(tile_width,1), ncn, 2 );\n                                    }\n                                }\n                            }\n                            break;\n                        }\n\n                        case 32:\n                        case 64:\n                        {\n                            if( !is_tiled )\n                                ok = (int)TIFFReadEncodedStrip( tif, tileidx, buffer, (tsize_t)-1 ) >= 0;\n                            else\n                                ok = (int)TIFFReadEncodedTile( tif, tileidx, buffer, (tsize_t)-1 ) >= 0;\n\n                            if( !ok || ncn != 1 )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                            {\n                                if(dst_bpp == 32)\n                                {\n                                    memcpy((float*)(data + img.step*i)+x,\n                                           buffer32 + i*tile_width0*ncn,\n                                           tile_width*sizeof(buffer32[0]));\n                                }\n                                else\n                                {\n                                    memcpy((double*)(data + img.step*i)+x,\n                                         buffer64 + i*tile_width0*ncn,\n                                         tile_width*sizeof(buffer64[0]));\n                                }\n                            }\n\n                            break;\n                        }\n                        default:\n                        {\n                            close();\n                            return false;\n                        }\n                    }\n                }\n            }\n\n            result = true;\n        }\n    }\n\n    close();\n    return result;\n}\n\nbool TiffDecoder::readHdrData(Mat& img)\n{\n    int rows_per_strip = 0, photometric = 0;\n    if(!m_tif)\n    {\n        return false;\n    }\n    TIFF *tif = static_cast<TIFF*>(m_tif);\n    TIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &rows_per_strip);\n    TIFFGetField( tif, TIFFTAG_PHOTOMETRIC, &photometric );\n    TIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_FLOAT);\n    int size = 3 * m_width * m_height * sizeof (float);\n    tstrip_t strip_size = 3 * m_width * rows_per_strip;\n    float *ptr = img.ptr<float>();\n    for (tstrip_t i = 0; i < TIFFNumberOfStrips(tif); i++, ptr += strip_size)\n    {\n        TIFFReadEncodedStrip(tif, i, ptr, size);\n        size -= strip_size * sizeof(float);\n    }\n    close();\n    if(photometric == PHOTOMETRIC_LOGLUV)\n    {\n        cvtColor(img, img, COLOR_XYZ2BGR);\n    }\n    else\n    {\n        cvtColor(img, img, COLOR_RGB2BGR);\n    }\n    return true;\n}\n\n#endif\n\n//////////////////////////////////////////////////////////////////////////////////////////\n\nTiffEncoder::TiffEncoder()\n{\n    m_description = \"TIFF Files (*.tiff;*.tif)\";\n#ifdef HAVE_TIFF\n    m_buf_supported = false;\n#else\n    m_buf_supported = true;\n#endif\n}\n\nTiffEncoder::~TiffEncoder()\n{\n}\n\nImageEncoder TiffEncoder::newEncoder() const\n{\n    return makePtr<TiffEncoder>();\n}\n\nbool TiffEncoder::isFormatSupported( int depth ) const\n{\n#ifdef HAVE_TIFF\n    return depth == CV_8U || depth == CV_16U || depth == CV_32F;\n#else\n    return depth == CV_8U || depth == CV_16U;\n#endif\n}\n\nvoid  TiffEncoder::writeTag( WLByteStream& strm, TiffTag tag,\n                             TiffFieldType fieldType,\n                             int count, int value )\n{\n    strm.putWord( tag );\n    strm.putWord( fieldType );\n    strm.putDWord( count );\n    strm.putDWord( value );\n}\n\n#ifdef HAVE_TIFF\n\nstatic void readParam(const std::vector<int>& params, int key, int& value)\n{\n    for(size_t i = 0; i + 1 < params.size(); i += 2)\n        if(params[i] == key)\n        {\n            value = params[i+1];\n            break;\n        }\n}\n\nbool  TiffEncoder::writeLibTiff( const Mat& img, const std::vector<int>& params)\n{\n    int channels = img.channels();\n    int width = img.cols, height = img.rows;\n    int depth = img.depth();\n\n    int bitsPerChannel = -1;\n    switch (depth)\n    {\n        case CV_8U:\n        {\n            bitsPerChannel = 8;\n            break;\n        }\n        case CV_16U:\n        {\n            bitsPerChannel = 16;\n            break;\n        }\n        default:\n        {\n            return false;\n        }\n    }\n\n    const int bitsPerByte = 8;\n    size_t fileStep = (width * channels * bitsPerChannel) / bitsPerByte;\n\n    int rowsPerStrip = (int)((1 << 13)/fileStep);\n    readParam(params, TIFFTAG_ROWSPERSTRIP, rowsPerStrip);\n\n    if( rowsPerStrip < 1 )\n        rowsPerStrip = 1;\n\n    if( rowsPerStrip > height )\n        rowsPerStrip = height;\n\n\n    // do NOT put \"wb\" as the mode, because the b means \"big endian\" mode, not \"binary\" mode.\n    // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n    TIFF* pTiffHandle = TIFFOpen(m_filename.c_str(), \"w\");\n    if (!pTiffHandle)\n    {\n        return false;\n    }\n\n    // defaults for now, maybe base them on params in the future\n    int   compression  = COMPRESSION_LZW;\n    int   predictor    = PREDICTOR_HORIZONTAL;\n\n    readParam(params, TIFFTAG_COMPRESSION, compression);\n    readParam(params, TIFFTAG_PREDICTOR, predictor);\n\n    int   colorspace = channels > 1 ? PHOTOMETRIC_RGB : PHOTOMETRIC_MINISBLACK;\n\n    if ( !TIFFSetField(pTiffHandle, TIFFTAG_IMAGEWIDTH, width)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_IMAGELENGTH, height)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_BITSPERSAMPLE, bitsPerChannel)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_COMPRESSION, compression)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_PHOTOMETRIC, colorspace)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_SAMPLESPERPIXEL, channels)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_ROWSPERSTRIP, rowsPerStrip)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_PREDICTOR, predictor)\n       )\n    {\n        TIFFClose(pTiffHandle);\n        return false;\n    }\n\n    // row buffer, because TIFFWriteScanline modifies the original data!\n    size_t scanlineSize = TIFFScanlineSize(pTiffHandle);\n    AutoBuffer<uchar> _buffer(scanlineSize+32);\n    uchar* buffer = _buffer;\n    if (!buffer)\n    {\n        TIFFClose(pTiffHandle);\n        return false;\n    }\n\n    for (int y = 0; y < height; ++y)\n    {\n        switch(channels)\n        {\n            case 1:\n            {\n                memcpy(buffer, img.ptr(y), scanlineSize);\n                break;\n            }\n\n            case 3:\n            {\n                if (depth == CV_8U)\n                    icvCvt_BGR2RGB_8u_C3R( img.ptr(y), 0, buffer, 0, cvSize(width,1) );\n                else\n                    icvCvt_BGR2RGB_16u_C3R( img.ptr<ushort>(y), 0, (ushort*)buffer, 0, cvSize(width,1) );\n                break;\n            }\n\n            case 4:\n            {\n                if (depth == CV_8U)\n                    icvCvt_BGRA2RGBA_8u_C4R( img.ptr(y), 0, buffer, 0, cvSize(width,1) );\n                else\n                    icvCvt_BGRA2RGBA_16u_C4R( img.ptr<ushort>(y), 0, (ushort*)buffer, 0, cvSize(width,1) );\n                break;\n            }\n\n            default:\n            {\n                TIFFClose(pTiffHandle);\n                return false;\n            }\n        }\n\n        int writeResult = TIFFWriteScanline(pTiffHandle, buffer, y, 0);\n        if (writeResult != 1)\n        {\n            TIFFClose(pTiffHandle);\n            return false;\n        }\n    }\n\n    TIFFClose(pTiffHandle);\n    return true;\n}\n\nbool TiffEncoder::writeHdr(const Mat& _img)\n{\n    Mat img;\n    cvtColor(_img, img, COLOR_BGR2XYZ);\n    TIFF* tif = TIFFOpen(m_filename.c_str(), \"w\");\n    if (!tif)\n    {\n        return false;\n    }\n    TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, img.cols);\n    TIFFSetField(tif, TIFFTAG_IMAGELENGTH, img.rows);\n    TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 3);\n    TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_SGILOG);\n    TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_LOGLUV);\n    TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    TIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_FLOAT);\n    TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, 1);\n    int strip_size = 3 * img.cols;\n    float *ptr = const_cast<float*>(img.ptr<float>());\n    for (int i = 0; i < img.rows; i++, ptr += strip_size)\n    {\n        TIFFWriteEncodedStrip(tif, i, ptr, strip_size * sizeof(float));\n    }\n    TIFFClose(tif);\n    return true;\n}\n\n#endif\n\n#ifdef HAVE_TIFF\nbool  TiffEncoder::write( const Mat& img, const std::vector<int>& params)\n#else\nbool  TiffEncoder::write( const Mat& img, const std::vector<int>& /*params*/)\n#endif\n{\n    int channels = img.channels();\n    int width = img.cols, height = img.rows;\n    int depth = img.depth();\n#ifdef HAVE_TIFF\n    if(img.type() == CV_32FC3)\n    {\n        return writeHdr(img);\n    }\n#endif\n\n    if (depth != CV_8U && depth != CV_16U)\n        return false;\n\n    int bytesPerChannel = depth == CV_8U ? 1 : 2;\n    int fileStep = width * channels * bytesPerChannel;\n\n    WLByteStream strm;\n\n    if( m_buf )\n    {\n        if( !strm.open(*m_buf) )\n            return false;\n    }\n    else\n    {\n#ifdef HAVE_TIFF\n      return writeLibTiff(img, params);\n#else\n      if( !strm.open(m_filename) )\n          return false;\n#endif\n    }\n\n    int rowsPerStrip = (1 << 13)/fileStep;\n\n    if( rowsPerStrip < 1 )\n        rowsPerStrip = 1;\n\n    if( rowsPerStrip > height )\n        rowsPerStrip = height;\n\n    int i, stripCount = (height + rowsPerStrip - 1) / rowsPerStrip;\n\n    if( m_buf )\n        m_buf->reserve( alignSize(stripCount*8 + fileStep*height + 256, 256) );\n\n/*#if defined _DEBUG || !defined WIN32\n    int uncompressedRowSize = rowsPerStrip * fileStep;\n#endif*/\n    int directoryOffset = 0;\n\n    AutoBuffer<int> stripOffsets(stripCount);\n    AutoBuffer<short> stripCounts(stripCount);\n    AutoBuffer<uchar> _buffer(fileStep+32);\n    uchar* buffer = _buffer;\n    int  stripOffsetsOffset = 0;\n    int  stripCountsOffset = 0;\n    int  bitsPerSample = 8 * bytesPerChannel;\n    int  y = 0;\n\n    strm.putBytes( fmtSignTiffII, 4 );\n    strm.putDWord( directoryOffset );\n\n    // write an image data first (the most reasonable way\n    // for compressed images)\n    for( i = 0; i < stripCount; i++ )\n    {\n        int limit = y + rowsPerStrip;\n\n        if( limit > height )\n            limit = height;\n\n        stripOffsets[i] = strm.getPos();\n\n        for( ; y < limit; y++ )\n        {\n            if( channels == 3 )\n            {\n                if (depth == CV_8U)\n                    icvCvt_BGR2RGB_8u_C3R( img.ptr(y), 0, buffer, 0, cvSize(width,1) );\n                else\n                    icvCvt_BGR2RGB_16u_C3R( img.ptr<ushort>(y), 0, (ushort*)buffer, 0, cvSize(width,1) );\n            }\n            else\n            {\n              if( channels == 4 )\n              {\n                if (depth == CV_8U)\n                    icvCvt_BGRA2RGBA_8u_C4R( img.ptr(y), 0, buffer, 0, cvSize(width,1) );\n                else\n                    icvCvt_BGRA2RGBA_16u_C4R( img.ptr<ushort>(y), 0, (ushort*)buffer, 0, cvSize(width,1) );\n              }\n            }\n\n            strm.putBytes( channels > 1 ? buffer : img.ptr(y), fileStep );\n        }\n\n        stripCounts[i] = (short)(strm.getPos() - stripOffsets[i]);\n        /*assert( stripCounts[i] == uncompressedRowSize ||\n                stripCounts[i] < uncompressedRowSize &&\n                i == stripCount - 1);*/\n    }\n\n    if( stripCount > 2 )\n    {\n        stripOffsetsOffset = strm.getPos();\n        for( i = 0; i < stripCount; i++ )\n            strm.putDWord( stripOffsets[i] );\n\n        stripCountsOffset = strm.getPos();\n        for( i = 0; i < stripCount; i++ )\n            strm.putWord( stripCounts[i] );\n    }\n    else if(stripCount == 2)\n    {\n        stripOffsetsOffset = strm.getPos();\n        for (i = 0; i < stripCount; i++)\n        {\n            strm.putDWord (stripOffsets [i]);\n        }\n        stripCountsOffset = stripCounts [0] + (stripCounts [1] << 16);\n    }\n    else\n    {\n        stripOffsetsOffset = stripOffsets[0];\n        stripCountsOffset = stripCounts[0];\n    }\n\n    if( channels > 1 )\n    {\n        int bitsPerSamplePos = strm.getPos();\n        strm.putWord(bitsPerSample);\n        strm.putWord(bitsPerSample);\n        strm.putWord(bitsPerSample);\n        if( channels == 4 )\n            strm.putWord(bitsPerSample);\n        bitsPerSample = bitsPerSamplePos;\n    }\n\n    directoryOffset = strm.getPos();\n\n    // write header\n    strm.putWord( 9 );\n\n    /* warning: specification 5.0 of Tiff want to have tags in\n       ascending order. This is a non-fatal error, but this cause\n       warning with some tools. So, keep this in ascending order */\n\n    writeTag( strm, TIFF_TAG_WIDTH, TIFF_TYPE_LONG, 1, width );\n    writeTag( strm, TIFF_TAG_HEIGHT, TIFF_TYPE_LONG, 1, height );\n    writeTag( strm, TIFF_TAG_BITS_PER_SAMPLE,\n              TIFF_TYPE_SHORT, channels, bitsPerSample );\n    writeTag( strm, TIFF_TAG_COMPRESSION, TIFF_TYPE_LONG, 1, TIFF_UNCOMP );\n    writeTag( strm, TIFF_TAG_PHOTOMETRIC, TIFF_TYPE_SHORT, 1, channels > 1 ? 2 : 1 );\n\n    writeTag( strm, TIFF_TAG_STRIP_OFFSETS, TIFF_TYPE_LONG,\n              stripCount, stripOffsetsOffset );\n\n    writeTag( strm, TIFF_TAG_SAMPLES_PER_PIXEL, TIFF_TYPE_SHORT, 1, channels );\n    writeTag( strm, TIFF_TAG_ROWS_PER_STRIP, TIFF_TYPE_LONG, 1, rowsPerStrip );\n\n    writeTag( strm, TIFF_TAG_STRIP_COUNTS,\n              stripCount > 1 ? TIFF_TYPE_SHORT : TIFF_TYPE_LONG,\n              stripCount, stripCountsOffset );\n\n    strm.putDWord(0);\n    strm.close();\n\n    if( m_buf )\n    {\n        (*m_buf)[4] = (uchar)directoryOffset;\n        (*m_buf)[5] = (uchar)(directoryOffset >> 8);\n        (*m_buf)[6] = (uchar)(directoryOffset >> 16);\n        (*m_buf)[7] = (uchar)(directoryOffset >> 24);\n    }\n    else\n    {\n        // write directory offset\n        FILE* f = fopen( m_filename.c_str(), \"r+b\" );\n        buffer[0] = (uchar)directoryOffset;\n        buffer[1] = (uchar)(directoryOffset >> 8);\n        buffer[2] = (uchar)(directoryOffset >> 16);\n        buffer[3] = (uchar)(directoryOffset >> 24);\n\n        fseek( f, 4, SEEK_SET );\n        fwrite( buffer, 1, 4, f );\n        fclose(f);\n    }\n\n    return true;\n}\n\n}\n",
                "name": "grfmt_tiff.cpp",
                "path": "3rdparty/opencv-git/modules/imgcodecs/src/grfmt_tiff.cpp",
                "url": "/github.com/plumonito/dtslam/-/blob/3rdparty/opencv-git/modules/imgcodecs/src/grfmt_tiff.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 266,
                    "offsetAndLengths": [
                        [
                            37,
                            16
                        ]
                    ],
                    "preview": "                                ok = TIFFReadRGBATile( tif, x, y, (uint32*)buffer );"
                }
            ],
            "repository": {
                "name": "github.com/plumonito/dtslam",
                "url": "/github.com/plumonito/dtslam"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "31450d613c0c091c6ad510cf2a42a25edbe01e62"
                },
                "content": "/*M///////////////////////////////////////////////////////////////////////////////////////\n//\n//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.\n//\n//  By downloading, copying, installing or using the software you agree to this license.\n//  If you do not agree to this license, do not download, install,\n//  copy or use the software.\n//\n//\n//                           License Agreement\n//                For Open Source Computer Vision Library\n//\n// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.\n// Copyright (C) 2009, Willow Garage Inc., all rights reserved.\n// Third party copyrights are property of their respective owners.\n//\n// Redistribution and use in source and binary forms, with or without modification,\n// are permitted provided that the following conditions are met:\n//\n//   * Redistribution's of source code must retain the above copyright notice,\n//     this list of conditions and the following disclaimer.\n//\n//   * Redistribution's in binary form must reproduce the above copyright notice,\n//     this list of conditions and the following disclaimer in the documentation\n//     and/or other materials provided with the distribution.\n//\n//   * The name of the copyright holders may not be used to endorse or promote products\n//     derived from this software without specific prior written permission.\n//\n// This software is provided by the copyright holders and contributors \"as is\" and\n// any express or implied warranties, including, but not limited to, the implied\n// warranties of merchantability and fitness for a particular purpose are disclaimed.\n// In no event shall the Intel Corporation or contributors be liable for any direct,\n// indirect, incidental, special, exemplary, or consequential damages\n// (including, but not limited to, procurement of substitute goods or services;\n// loss of use, data, or profits; or business interruption) however caused\n// and on any theory of liability, whether in contract, strict liability,\n// or tort (including negligence or otherwise) arising in any way out of\n// the use of this software, even if advised of the possibility of such damage.\n//\n//M*/\n\n/****************************************************************************************\\\n    A part of the file implements TIFF reader on base of libtiff library\n    (see otherlibs/_graphics/readme.txt for copyright notice)\n\\****************************************************************************************/\n\n#include \"precomp.hpp\"\n#include \"grfmt_tiff.hpp\"\n\nnamespace cv\n{\nstatic const char fmtSignTiffII[] = \"II\\x2a\\x00\";\nstatic const char fmtSignTiffMM[] = \"MM\\x00\\x2a\";\n\n#ifdef HAVE_TIFF\n\n#include \"tiff.h\"\n#include \"tiffio.h\"\n\nstatic int grfmt_tiff_err_handler_init = 0;\nstatic void GrFmtSilentTIFFErrorHandler( const char*, const char*, va_list ) {}\n\nTiffDecoder::TiffDecoder()\n{\n    m_tif = 0;\n    if( !grfmt_tiff_err_handler_init )\n    {\n        grfmt_tiff_err_handler_init = 1;\n\n        TIFFSetErrorHandler( GrFmtSilentTIFFErrorHandler );\n        TIFFSetWarningHandler( GrFmtSilentTIFFErrorHandler );\n    }\n}\n\n\nvoid TiffDecoder::close()\n{\n    if( m_tif )\n    {\n        TIFF* tif = (TIFF*)m_tif;\n        TIFFClose( tif );\n        m_tif = 0;\n    }\n}\n\nTiffDecoder::~TiffDecoder()\n{\n    close();\n}\n\nsize_t TiffDecoder::signatureLength() const\n{\n    return 4;\n}\n\nbool TiffDecoder::checkSignature( const string& signature ) const\n{\n    return signature.size() >= 4 &&\n        (memcmp(signature.c_str(), fmtSignTiffII, 4) == 0 ||\n        memcmp(signature.c_str(), fmtSignTiffMM, 4) == 0);\n}\n\nImageDecoder TiffDecoder::newDecoder() const\n{\n    return new TiffDecoder;\n}\n\nbool TiffDecoder::readHeader()\n{\n    bool result = false;\n\n    close();\n    TIFF* tif = TIFFOpen( m_filename.c_str(), \"rb\" );\n\n    if( tif )\n    {\n        int wdth = 0, hght = 0, photometric = 0;\n        m_tif = tif;\n\n        if( TIFFGetField( tif, TIFFTAG_IMAGEWIDTH, &wdth ) &&\n            TIFFGetField( tif, TIFFTAG_IMAGELENGTH, &hght ) &&\n            TIFFGetField( tif, TIFFTAG_PHOTOMETRIC, &photometric ))\n        {\n            int bpp=8, ncn = photometric > 1 ? 3 : 1;\n            TIFFGetField( tif, TIFFTAG_BITSPERSAMPLE, &bpp );\n            TIFFGetField( tif, TIFFTAG_SAMPLESPERPIXEL, &ncn );\n\n            m_width = wdth;\n            m_height = hght;\n            if( bpp > 8 &&\n               ((photometric != 2 && photometric != 1) ||\n                (ncn != 1 && ncn != 3 && ncn != 4)))\n                bpp = 8;\n\n            switch(bpp)\n            {\n                case 8:\n                    m_type = CV_MAKETYPE(CV_8U, photometric > 1 ? 3 : 1);\n                    break;\n                case 16:\n                    m_type = CV_MAKETYPE(CV_16U, photometric > 1 ? 3 : 1);\n                    break;\n\n                case 32:\n                    m_type = CV_MAKETYPE(CV_32F, photometric > 1 ? 3 : 1);\n                    break;\n                case 64:\n                    m_type = CV_MAKETYPE(CV_64F, photometric > 1 ? 3 : 1);\n                    break;\n\n                default:\n                    result = false;\n            }\n            result = true;\n        }\n    }\n\n    if( !result )\n        close();\n\n    return result;\n}\n\n\nbool  TiffDecoder::readData( Mat& img )\n{\n    bool result = false;\n    bool color = img.channels() > 1;\n    uchar* data = img.data;\n\n    if( img.depth() != CV_8U && img.depth() != CV_16U && img.depth() != CV_32F && img.depth() != CV_64F )\n        return false;\n\n    if( m_tif && m_width && m_height )\n    {\n        TIFF* tif = (TIFF*)m_tif;\n        int tile_width0 = m_width, tile_height0 = 0;\n        int x, y, i;\n        int is_tiled = TIFFIsTiled(tif);\n        int photometric;\n        TIFFGetField( tif, TIFFTAG_PHOTOMETRIC, &photometric );\n        int bpp = 8, ncn = photometric > 1 ? 3 : 1;\n        TIFFGetField( tif, TIFFTAG_BITSPERSAMPLE, &bpp );\n        TIFFGetField( tif, TIFFTAG_SAMPLESPERPIXEL, &ncn );\n        const int bitsPerByte = 8;\n        int dst_bpp = (int)(img.elemSize1() * bitsPerByte);\n\n        if(dst_bpp == 8)\n        {\n            char errmsg[1024];\n            if(!TIFFRGBAImageOK( tif, errmsg ))\n            {\n                close();\n                return false;\n            }\n        }\n\n        if( (!is_tiled) ||\n            (is_tiled &&\n            TIFFGetField( tif, TIFFTAG_TILEWIDTH, &tile_width0 ) &&\n            TIFFGetField( tif, TIFFTAG_TILELENGTH, &tile_height0 )))\n        {\n            if(!is_tiled)\n                TIFFGetField( tif, TIFFTAG_ROWSPERSTRIP, &tile_height0 );\n\n            if( tile_width0 <= 0 )\n                tile_width0 = m_width;\n\n            if( tile_height0 <= 0 )\n                tile_height0 = m_height;\n\n            AutoBuffer<uchar> _buffer( size_t(8) * tile_height0*tile_width0);\n            uchar* buffer = _buffer;\n            ushort* buffer16 = (ushort*)buffer;\n            float* buffer32 = (float*)buffer;\n            double* buffer64 = (double*)buffer;\n            int tileidx = 0;\n\n            for( y = 0; y < m_height; y += tile_height0, data += img.step*tile_height0 )\n            {\n                int tile_height = tile_height0;\n\n                if( y + tile_height > m_height )\n                    tile_height = m_height - y;\n\n                for( x = 0; x < m_width; x += tile_width0, tileidx++ )\n                {\n                    int tile_width = tile_width0, ok;\n\n                    if( x + tile_width > m_width )\n                        tile_width = m_width - x;\n\n                    switch(dst_bpp)\n                    {\n                        case 8:\n                        {\n                            if( !is_tiled )\n                                ok = TIFFReadRGBAStrip( tif, y, (uint32*)buffer );\n                            else\n                                ok = TIFFReadRGBATile( tif, x, y, (uint32*)buffer );\n\n                            if( !ok )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                                if( color )\n                                    icvCvt_BGRA2BGR_8u_C4C3R( buffer + i*tile_width*4, 0,\n                                                             data + x*3 + img.step*(tile_height - i - 1), 0,\n                                                             cvSize(tile_width,1), 2 );\n                                else\n                                    icvCvt_BGRA2Gray_8u_C4C1R( buffer + i*tile_width*4, 0,\n                                                              data + x + img.step*(tile_height - i - 1), 0,\n                                                              cvSize(tile_width,1), 2 );\n                            break;\n                        }\n\n                        case 16:\n                        {\n                            if( !is_tiled )\n                                ok = (int)TIFFReadEncodedStrip( tif, tileidx, (uint32*)buffer, (tsize_t)-1 ) >= 0;\n                            else\n                                ok = (int)TIFFReadEncodedTile( tif, tileidx, (uint32*)buffer, (tsize_t)-1 ) >= 0;\n\n                            if( !ok )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                            {\n                                if( color )\n                                {\n                                    if( ncn == 1 )\n                                    {\n                                        icvCvt_Gray2BGR_16u_C1C3R(buffer16 + i*tile_width*ncn, 0,\n                                                                  (ushort*)(data + img.step*i) + x*3, 0,\n                                                                  cvSize(tile_width,1) );\n                                    }\n                                    else if( ncn == 3 )\n                                    {\n                                        icvCvt_RGB2BGR_16u_C3R(buffer16 + i*tile_width*ncn, 0,\n                                                               (ushort*)(data + img.step*i) + x*3, 0,\n                                                               cvSize(tile_width,1) );\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2BGR_16u_C4C3R(buffer16 + i*tile_width*ncn, 0,\n                                                               (ushort*)(data + img.step*i) + x*3, 0,\n                                                               cvSize(tile_width,1), 2 );\n                                    }\n                                }\n                                else\n                                {\n                                    if( ncn == 1 )\n                                    {\n                                        memcpy((ushort*)(data + img.step*i)+x,\n                                               buffer16 + i*tile_width*ncn,\n                                               tile_width*sizeof(buffer16[0]));\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2Gray_16u_CnC1R(buffer16 + i*tile_width*ncn, 0,\n                                                               (ushort*)(data + img.step*i) + x, 0,\n                                                               cvSize(tile_width,1), ncn, 2 );\n                                    }\n                                }\n                            }\n                            break;\n                        }\n\n                        case 32:\n                        case 64:\n                        {\n                            if( !is_tiled )\n                                ok = (int)TIFFReadEncodedStrip( tif, tileidx, buffer, (tsize_t)-1 ) >= 0;\n                            else\n                                ok = (int)TIFFReadEncodedTile( tif, tileidx, buffer, (tsize_t)-1 ) >= 0;\n\n                            if( !ok || ncn != 1 )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                            {\n                                if(dst_bpp == 32)\n                                {\n                                    memcpy((float*)(data + img.step*i)+x,\n                                           buffer32 + i*tile_width*ncn,\n                                           tile_width*sizeof(buffer32[0]));\n                                }\n                                else\n                                {\n                                    memcpy((double*)(data + img.step*i)+x,\n                                         buffer64 + i*tile_width*ncn,\n                                         tile_width*sizeof(buffer64[0]));\n                                }\n                            }\n\n                            break;\n                        }\n                        default:\n                        {\n                            close();\n                            return false;\n                        }\n                    }\n                }\n            }\n\n            result = true;\n        }\n    }\n\n    close();\n    return result;\n}\n\n#endif\n\n//////////////////////////////////////////////////////////////////////////////////////////\n\nTiffEncoder::TiffEncoder()\n{\n    m_description = \"TIFF Files (*.tiff;*.tif)\";\n#ifdef HAVE_TIFF\n    m_buf_supported = false;\n#else\n    m_buf_supported = true;\n#endif\n}\n\nTiffEncoder::~TiffEncoder()\n{\n}\n\nImageEncoder TiffEncoder::newEncoder() const\n{\n    return new TiffEncoder;\n}\n\nbool TiffEncoder::isFormatSupported( int depth ) const\n{\n    return depth == CV_8U || depth == CV_16U;\n}\n\nvoid  TiffEncoder::writeTag( WLByteStream& strm, TiffTag tag,\n                             TiffFieldType fieldType,\n                             int count, int value )\n{\n    strm.putWord( tag );\n    strm.putWord( fieldType );\n    strm.putDWord( count );\n    strm.putDWord( value );\n}\n\n#ifdef HAVE_TIFF\n\nstatic void readParam(const vector<int>& params, int key, int& value)\n{\n    for(size_t i = 0; i + 1 < params.size(); i += 2)\n        if(params[i] == key)\n        {\n            value = params[i+1];\n            break;\n        }\n}\n\nbool  TiffEncoder::writeLibTiff( const Mat& img, const vector<int>& params)\n{\n    int channels = img.channels();\n    int width = img.cols, height = img.rows;\n    int depth = img.depth();\n\n    int bitsPerChannel = -1;\n    switch (depth)\n    {\n        case CV_8U:\n        {\n            bitsPerChannel = 8;\n            break;\n        }\n        case CV_16U:\n        {\n            bitsPerChannel = 16;\n            break;\n        }\n        default:\n        {\n            return false;\n        }\n    }\n\n    const int bitsPerByte = 8;\n    size_t fileStep = (width * channels * bitsPerChannel) / bitsPerByte;\n\n    int rowsPerStrip = (int)((1 << 13)/fileStep);\n    readParam(params, TIFFTAG_ROWSPERSTRIP, rowsPerStrip);\n\n    if( rowsPerStrip < 1 )\n        rowsPerStrip = 1;\n\n    if( rowsPerStrip > height )\n        rowsPerStrip = height;\n\n\n    // do NOT put \"wb\" as the mode, because the b means \"big endian\" mode, not \"binary\" mode.\n    // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n    TIFF* pTiffHandle = TIFFOpen(m_filename.c_str(), \"w\");\n    if (!pTiffHandle)\n    {\n        return false;\n    }\n\n    // defaults for now, maybe base them on params in the future\n    int   compression  = COMPRESSION_LZW;\n    int   predictor    = PREDICTOR_HORIZONTAL;\n\n    readParam(params, TIFFTAG_COMPRESSION, compression);\n    readParam(params, TIFFTAG_PREDICTOR, predictor);\n\n    int   colorspace = channels > 1 ? PHOTOMETRIC_RGB : PHOTOMETRIC_MINISBLACK;\n\n    if ( !TIFFSetField(pTiffHandle, TIFFTAG_IMAGEWIDTH, width)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_IMAGELENGTH, height)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_BITSPERSAMPLE, bitsPerChannel)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_COMPRESSION, compression)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_PHOTOMETRIC, colorspace)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_SAMPLESPERPIXEL, channels)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_ROWSPERSTRIP, rowsPerStrip)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_PREDICTOR, predictor)\n       )\n    {\n        TIFFClose(pTiffHandle);\n        return false;\n    }\n\n    // row buffer, because TIFFWriteScanline modifies the original data!\n    size_t scanlineSize = TIFFScanlineSize(pTiffHandle);\n    AutoBuffer<uchar> _buffer(scanlineSize+32);\n    uchar* buffer = _buffer;\n    if (!buffer)\n    {\n        TIFFClose(pTiffHandle);\n        return false;\n    }\n\n    for (int y = 0; y < height; ++y)\n    {\n        switch(channels)\n        {\n            case 1:\n            {\n                memcpy(buffer, img.data + img.step * y, scanlineSize);\n                break;\n            }\n\n            case 3:\n            {\n                if (depth == CV_8U)\n                    icvCvt_BGR2RGB_8u_C3R( img.data + img.step*y, 0, buffer, 0, cvSize(width,1) );\n                else\n                    icvCvt_BGR2RGB_16u_C3R( (const ushort*)(img.data + img.step*y), 0, (ushort*)buffer, 0, cvSize(width,1) );\n                break;\n            }\n\n            case 4:\n            {\n                if (depth == CV_8U)\n                    icvCvt_BGRA2RGBA_8u_C4R( img.data + img.step*y, 0, buffer, 0, cvSize(width,1) );\n                else\n                    icvCvt_BGRA2RGBA_16u_C4R( (const ushort*)(img.data + img.step*y), 0, (ushort*)buffer, 0, cvSize(width,1) );\n                break;\n            }\n\n            default:\n            {\n                TIFFClose(pTiffHandle);\n                return false;\n            }\n        }\n\n        int writeResult = TIFFWriteScanline(pTiffHandle, buffer, y, 0);\n        if (writeResult != 1)\n        {\n            TIFFClose(pTiffHandle);\n            return false;\n        }\n    }\n\n    TIFFClose(pTiffHandle);\n    return true;\n}\n\n#endif\n\n#ifdef HAVE_TIFF\nbool  TiffEncoder::write( const Mat& img, const vector<int>& params)\n#else\nbool  TiffEncoder::write( const Mat& img, const vector<int>& /*params*/)\n#endif\n{\n    int channels = img.channels();\n    int width = img.cols, height = img.rows;\n    int depth = img.depth();\n\n    if (depth != CV_8U && depth != CV_16U)\n        return false;\n\n    int bytesPerChannel = depth == CV_8U ? 1 : 2;\n    int fileStep = width * channels * bytesPerChannel;\n\n    WLByteStream strm;\n\n    if( m_buf )\n    {\n        if( !strm.open(*m_buf) )\n            return false;\n    }\n    else\n    {\n#ifdef HAVE_TIFF\n      return writeLibTiff(img, params);\n#else\n      if( !strm.open(m_filename) )\n          return false;\n#endif\n    }\n\n    int rowsPerStrip = (1 << 13)/fileStep;\n\n    if( rowsPerStrip < 1 )\n        rowsPerStrip = 1;\n\n    if( rowsPerStrip > height )\n        rowsPerStrip = height;\n\n    int i, stripCount = (height + rowsPerStrip - 1) / rowsPerStrip;\n\n    if( m_buf )\n        m_buf->reserve( alignSize(stripCount*8 + fileStep*height + 256, 256) );\n\n/*#if defined _DEBUG || !defined WIN32\n    int uncompressedRowSize = rowsPerStrip * fileStep;\n#endif*/\n    int directoryOffset = 0;\n\n    AutoBuffer<int> stripOffsets(stripCount);\n    AutoBuffer<short> stripCounts(stripCount);\n    AutoBuffer<uchar> _buffer(fileStep+32);\n    uchar* buffer = _buffer;\n    int  stripOffsetsOffset = 0;\n    int  stripCountsOffset = 0;\n    int  bitsPerSample = 8 * bytesPerChannel;\n    int  y = 0;\n\n    strm.putBytes( fmtSignTiffII, 4 );\n    strm.putDWord( directoryOffset );\n\n    // write an image data first (the most reasonable way\n    // for compressed images)\n    for( i = 0; i < stripCount; i++ )\n    {\n        int limit = y + rowsPerStrip;\n\n        if( limit > height )\n            limit = height;\n\n        stripOffsets[i] = strm.getPos();\n\n        for( ; y < limit; y++ )\n        {\n            if( channels == 3 )\n            {\n                if (depth == CV_8U)\n                    icvCvt_BGR2RGB_8u_C3R( img.data + img.step*y, 0, buffer, 0, cvSize(width,1) );\n                else\n                    icvCvt_BGR2RGB_16u_C3R( (const ushort*)(img.data + img.step*y), 0, (ushort*)buffer, 0, cvSize(width,1) );\n            }\n            else\n            {\n              if( channels == 4 )\n              {\n                if (depth == CV_8U)\n                    icvCvt_BGRA2RGBA_8u_C4R( img.data + img.step*y, 0, buffer, 0, cvSize(width,1) );\n                else\n                    icvCvt_BGRA2RGBA_16u_C4R( (const ushort*)(img.data + img.step*y), 0, (ushort*)buffer, 0, cvSize(width,1) );\n              }\n            }\n\n            strm.putBytes( channels > 1 ? buffer : img.data + img.step*y, fileStep );\n        }\n\n        stripCounts[i] = (short)(strm.getPos() - stripOffsets[i]);\n        /*assert( stripCounts[i] == uncompressedRowSize ||\n                stripCounts[i] < uncompressedRowSize &&\n                i == stripCount - 1);*/\n    }\n\n    if( stripCount > 2 )\n    {\n        stripOffsetsOffset = strm.getPos();\n        for( i = 0; i < stripCount; i++ )\n            strm.putDWord( stripOffsets[i] );\n\n        stripCountsOffset = strm.getPos();\n        for( i = 0; i < stripCount; i++ )\n            strm.putWord( stripCounts[i] );\n    }\n    else if(stripCount == 2)\n    {\n        stripOffsetsOffset = strm.getPos();\n        for (i = 0; i < stripCount; i++)\n        {\n            strm.putDWord (stripOffsets [i]);\n        }\n        stripCountsOffset = stripCounts [0] + (stripCounts [1] << 16);\n    }\n    else\n    {\n        stripOffsetsOffset = stripOffsets[0];\n        stripCountsOffset = stripCounts[0];\n    }\n\n    if( channels > 1 )\n    {\n        int bitsPerSamplePos = strm.getPos();\n        strm.putWord(bitsPerSample);\n        strm.putWord(bitsPerSample);\n        strm.putWord(bitsPerSample);\n        if( channels == 4 )\n            strm.putWord(bitsPerSample);\n        bitsPerSample = bitsPerSamplePos;\n    }\n\n    directoryOffset = strm.getPos();\n\n    // write header\n    strm.putWord( 9 );\n\n    /* warning: specification 5.0 of Tiff want to have tags in\n       ascending order. This is a non-fatal error, but this cause\n       warning with some tools. So, keep this in ascending order */\n\n    writeTag( strm, TIFF_TAG_WIDTH, TIFF_TYPE_LONG, 1, width );\n    writeTag( strm, TIFF_TAG_HEIGHT, TIFF_TYPE_LONG, 1, height );\n    writeTag( strm, TIFF_TAG_BITS_PER_SAMPLE,\n              TIFF_TYPE_SHORT, channels, bitsPerSample );\n    writeTag( strm, TIFF_TAG_COMPRESSION, TIFF_TYPE_LONG, 1, TIFF_UNCOMP );\n    writeTag( strm, TIFF_TAG_PHOTOMETRIC, TIFF_TYPE_SHORT, 1, channels > 1 ? 2 : 1 );\n\n    writeTag( strm, TIFF_TAG_STRIP_OFFSETS, TIFF_TYPE_LONG,\n              stripCount, stripOffsetsOffset );\n\n    writeTag( strm, TIFF_TAG_SAMPLES_PER_PIXEL, TIFF_TYPE_SHORT, 1, channels );\n    writeTag( strm, TIFF_TAG_ROWS_PER_STRIP, TIFF_TYPE_LONG, 1, rowsPerStrip );\n\n    writeTag( strm, TIFF_TAG_STRIP_COUNTS,\n              stripCount > 1 ? TIFF_TYPE_SHORT : TIFF_TYPE_LONG,\n              stripCount, stripCountsOffset );\n\n    strm.putDWord(0);\n    strm.close();\n\n    if( m_buf )\n    {\n        (*m_buf)[4] = (uchar)directoryOffset;\n        (*m_buf)[5] = (uchar)(directoryOffset >> 8);\n        (*m_buf)[6] = (uchar)(directoryOffset >> 16);\n        (*m_buf)[7] = (uchar)(directoryOffset >> 24);\n    }\n    else\n    {\n        // write directory offset\n        FILE* f = fopen( m_filename.c_str(), \"r+b\" );\n        buffer[0] = (uchar)directoryOffset;\n        buffer[1] = (uchar)(directoryOffset >> 8);\n        buffer[2] = (uchar)(directoryOffset >> 16);\n        buffer[3] = (uchar)(directoryOffset >> 24);\n\n        fseek( f, 4, SEEK_SET );\n        fwrite( buffer, 1, 4, f );\n        fclose(f);\n    }\n\n    return true;\n}\n\n}\n",
                "name": "grfmt_tiff.cpp",
                "path": "modules/highgui/src/grfmt_tiff.cpp",
                "url": "/github.com/kipr/opencv/-/blob/modules/highgui/src/grfmt_tiff.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 240,
                    "offsetAndLengths": [
                        [
                            37,
                            16
                        ]
                    ],
                    "preview": "                                ok = TIFFReadRGBATile( tif, x, y, (uint32*)buffer );"
                }
            ],
            "repository": {
                "name": "github.com/kipr/opencv",
                "url": "/github.com/kipr/opencv"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "42f7329c788bf2eb60b2c1de2ed8efb91ae84cde"
                },
                "content": "/*M///////////////////////////////////////////////////////////////////////////////////////\n//\n//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.\n//\n//  By downloading, copying, installing or using the software you agree to this license.\n//  If you do not agree to this license, do not download, install,\n//  copy or use the software.\n//\n//\n//                           License Agreement\n//                For Open Source Computer Vision Library\n//\n// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.\n// Copyright (C) 2009, Willow Garage Inc., all rights reserved.\n// Third party copyrights are property of their respective owners.\n//\n// Redistribution and use in source and binary forms, with or without modification,\n// are permitted provided that the following conditions are met:\n//\n//   * Redistribution's of source code must retain the above copyright notice,\n//     this list of conditions and the following disclaimer.\n//\n//   * Redistribution's in binary form must reproduce the above copyright notice,\n//     this list of conditions and the following disclaimer in the documentation\n//     and/or other materials provided with the distribution.\n//\n//   * The name of the copyright holders may not be used to endorse or promote products\n//     derived from this software without specific prior written permission.\n//\n// This software is provided by the copyright holders and contributors \"as is\" and\n// any express or implied warranties, including, but not limited to, the implied\n// warranties of merchantability and fitness for a particular purpose are disclaimed.\n// In no event shall the Intel Corporation or contributors be liable for any direct,\n// indirect, incidental, special, exemplary, or consequential damages\n// (including, but not limited to, procurement of substitute goods or services;\n// loss of use, data, or profits; or business interruption) however caused\n// and on any theory of liability, whether in contract, strict liability,\n// or tort (including negligence or otherwise) arising in any way out of\n// the use of this software, even if advised of the possibility of such damage.\n//\n//M*/\n\n/****************************************************************************************\\\n    A part of the file implements TIFF reader on base of libtiff library\n    (see otherlibs/_graphics/readme.txt for copyright notice)\n\\****************************************************************************************/\n\n#include \"precomp.hpp\"\n#include \"grfmt_tiff.hpp\"\n\nnamespace cv\n{\nstatic const char fmtSignTiffII[] = \"II\\x2a\\x00\";\nstatic const char fmtSignTiffMM[] = \"MM\\x00\\x2a\";\n\n#ifdef HAVE_TIFF\n\n#include \"tiff.h\"\n#include \"tiffio.h\"\n\nstatic int grfmt_tiff_err_handler_init = 0;\nstatic void GrFmtSilentTIFFErrorHandler( const char*, const char*, va_list ) {}\n\nTiffDecoder::TiffDecoder()\n{\n    m_tif = 0;\n    if( !grfmt_tiff_err_handler_init )\n    {\n        grfmt_tiff_err_handler_init = 1;\n\n        TIFFSetErrorHandler( GrFmtSilentTIFFErrorHandler );\n        TIFFSetWarningHandler( GrFmtSilentTIFFErrorHandler );\n    }\n}\n\n\nvoid TiffDecoder::close()\n{\n    if( m_tif )\n    {\n        TIFF* tif = (TIFF*)m_tif;\n        TIFFClose( tif );\n        m_tif = 0;\n    }\n}\n\nTiffDecoder::~TiffDecoder()\n{\n    close();\n}\n\nsize_t TiffDecoder::signatureLength() const\n{\n    return 4;\n}\n\nbool TiffDecoder::checkSignature( const string& signature ) const\n{\n    return signature.size() >= 4 &&\n        (memcmp(signature.c_str(), fmtSignTiffII, 4) == 0 ||\n        memcmp(signature.c_str(), fmtSignTiffMM, 4) == 0);\n}\n\nImageDecoder TiffDecoder::newDecoder() const\n{\n    return new TiffDecoder;\n}\n\nbool TiffDecoder::readHeader()\n{\n    bool result = false;\n\n    close();\n    TIFF* tif = TIFFOpen( m_filename.c_str(), \"rb\" );\n\n    if( tif )\n    {\n        int wdth = 0, hght = 0, photometric = 0;\n        m_tif = tif;\n\n        if( TIFFGetField( tif, TIFFTAG_IMAGEWIDTH, &wdth ) &&\n            TIFFGetField( tif, TIFFTAG_IMAGELENGTH, &hght ) &&\n            TIFFGetField( tif, TIFFTAG_PHOTOMETRIC, &photometric ))\n        {\n            int bpp=8, ncn = photometric > 1 ? 3 : 1;\n            TIFFGetField( tif, TIFFTAG_BITSPERSAMPLE, &bpp );\n            TIFFGetField( tif, TIFFTAG_SAMPLESPERPIXEL, &ncn );\n\n            m_width = wdth;\n            m_height = hght;\n            if( bpp > 8 &&\n               ((photometric != 2 && photometric != 1) ||\n                (ncn != 1 && ncn != 3 && ncn != 4)))\n                bpp = 8;\n\n            switch(bpp)\n            {\n                case 8:\n                    m_type = CV_MAKETYPE(CV_8U, photometric > 1 ? 3 : 1);\n                    break;\n                case 16:\n                    m_type = CV_MAKETYPE(CV_16U, photometric > 1 ? 3 : 1);\n                    break;\n\n                case 32:\n                    m_type = CV_MAKETYPE(CV_32F, photometric > 1 ? 3 : 1);\n                    break;\n                case 64:\n                    m_type = CV_MAKETYPE(CV_64F, photometric > 1 ? 3 : 1);\n                    break;\n\n                default:\n                    result = false;\n            }\n            result = true;\n        }\n    }\n\n    if( !result )\n        close();\n\n    return result;\n}\n\n\nbool  TiffDecoder::readData( Mat& img )\n{\n    bool result = false;\n    bool color = img.channels() > 1;\n    uchar* data = img.data;\n    int step = (int)img.step;\n\n    if( img.depth() != CV_8U && img.depth() != CV_16U && img.depth() != CV_32F && img.depth() != CV_64F )\n        return false;\n\n    if( m_tif && m_width && m_height )\n    {\n        TIFF* tif = (TIFF*)m_tif;\n        int tile_width0 = m_width, tile_height0 = 0;\n        int x, y, i;\n        int is_tiled = TIFFIsTiled(tif);\n        int photometric;\n        TIFFGetField( tif, TIFFTAG_PHOTOMETRIC, &photometric );\n        int bpp = 8, ncn = photometric > 1 ? 3 : 1;\n        TIFFGetField( tif, TIFFTAG_BITSPERSAMPLE, &bpp );\n        TIFFGetField( tif, TIFFTAG_SAMPLESPERPIXEL, &ncn );\n        const int bitsPerByte = 8;\n        int dst_bpp = (int)(img.elemSize1() * bitsPerByte);\n\n        if(dst_bpp == 8)\n        {\n            char errmsg[1024];\n            if(!TIFFRGBAImageOK( tif, errmsg ))\n            {\n                close();\n                return false;\n            }\n        }\n\n        if( (!is_tiled &&\n            TIFFGetField( tif, TIFFTAG_ROWSPERSTRIP, &tile_height0 )) ||\n            (is_tiled &&\n            TIFFGetField( tif, TIFFTAG_TILEWIDTH, &tile_width0 ) &&\n            TIFFGetField( tif, TIFFTAG_TILELENGTH, &tile_height0 )))\n        {\n            if( tile_width0 <= 0 )\n                tile_width0 = m_width;\n\n            if( tile_height0 <= 0 )\n                tile_height0 = m_height;\n\n            AutoBuffer<uchar> _buffer(tile_height0*tile_width0*8);\n            uchar* buffer = _buffer;\n            ushort* buffer16 = (ushort*)buffer;\n            float* buffer32 = (float*)buffer;\n            double* buffer64 = (double*)buffer;\n            int tileidx = 0;\n\n            for( y = 0; y < m_height; y += tile_height0, data += step*tile_height0 )\n            {\n                int tile_height = tile_height0;\n\n                if( y + tile_height > m_height )\n                    tile_height = m_height - y;\n\n                for( x = 0; x < m_width; x += tile_width0, tileidx++ )\n                {\n                    int tile_width = tile_width0, ok;\n\n                    if( x + tile_width > m_width )\n                        tile_width = m_width - x;\n\n                    switch(dst_bpp)\n                    {\n                        case 8:\n                        {\n                            if( !is_tiled )\n                                ok = TIFFReadRGBAStrip( tif, y, (uint32*)buffer );\n                            else\n                                ok = TIFFReadRGBATile( tif, x, y, (uint32*)buffer );\n\n                            if( !ok )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                                if( color )\n                                    icvCvt_BGRA2BGR_8u_C4C3R( buffer + i*tile_width*4, 0,\n                                                             data + x*3 + step*(tile_height - i - 1), 0,\n                                                             cvSize(tile_width,1), 2 );\n                                else\n                                    icvCvt_BGRA2Gray_8u_C4C1R( buffer + i*tile_width*4, 0,\n                                                              data + x + step*(tile_height - i - 1), 0,\n                                                              cvSize(tile_width,1), 2 );\n                            break;\n                        }\n\n                        case 16:\n                        {\n                            if( !is_tiled )\n                                ok = (int)TIFFReadEncodedStrip( tif, tileidx, (uint32*)buffer, (tsize_t)-1 ) >= 0;\n                            else\n                                ok = (int)TIFFReadEncodedTile( tif, tileidx, (uint32*)buffer, (tsize_t)-1 ) >= 0;\n\n                            if( !ok )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                            {\n                                if( color )\n                                {\n                                    if( ncn == 1 )\n                                    {\n                                        icvCvt_Gray2BGR_16u_C1C3R(buffer16 + i*tile_width*ncn, 0,\n                                                                  (ushort*)(data + step*i) + x*3, 0,\n                                                                  cvSize(tile_width,1) );\n                                    }\n                                    else if( ncn == 3 )\n                                    {\n                                        icvCvt_RGB2BGR_16u_C3R(buffer16 + i*tile_width*ncn, 0,\n                                                               (ushort*)(data + step*i) + x*3, 0,\n                                                               cvSize(tile_width,1) );\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2BGR_16u_C4C3R(buffer16 + i*tile_width*ncn, 0,\n                                                               (ushort*)(data + step*i) + x*3, 0,\n                                                               cvSize(tile_width,1), 2 );\n                                    }\n                                }\n                                else\n                                {\n                                    if( ncn == 1 )\n                                    {\n                                        memcpy((ushort*)(data + step*i)+x,\n                                               buffer16 + i*tile_width*ncn,\n                                               tile_width*sizeof(buffer16[0]));\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2Gray_16u_CnC1R(buffer16 + i*tile_width*ncn, 0,\n                                                               (ushort*)(data + step*i) + x, 0,\n                                                               cvSize(tile_width,1), ncn, 2 );\n                                    }\n                                }\n                            }\n                            break;\n                        }\n\n                        case 32:\n                        case 64:\n                        {\n                            if( !is_tiled )\n                                ok = (int)TIFFReadEncodedStrip( tif, tileidx, buffer, (tsize_t)-1 ) >= 0;\n                            else\n                                ok = (int)TIFFReadEncodedTile( tif, tileidx, buffer, (tsize_t)-1 ) >= 0;\n\n                            if( !ok || ncn != 1 )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                            {\n                                if(dst_bpp == 32)\n                                {\n                                    memcpy((float*)(data + step*i)+x,\n                                           buffer32 + i*tile_width*ncn,\n                                           tile_width*sizeof(buffer32[0]));\n                                }\n                                else\n                                {\n                                    memcpy((double*)(data + step*i)+x,\n                                         buffer64 + i*tile_width*ncn,\n                                         tile_width*sizeof(buffer64[0]));\n                                }\n                            }\n\n                            break;\n                        }\n                        default:\n                        {\n                            close();\n                            return false;\n                        }\n                    }\n                }\n            }\n\n            result = true;\n        }\n    }\n\n    close();\n    return result;\n}\n\n#endif\n\n//////////////////////////////////////////////////////////////////////////////////////////\n\nTiffEncoder::TiffEncoder()\n{\n    m_description = \"TIFF Files (*.tiff;*.tif)\";\n#ifdef HAVE_TIFF\n    m_buf_supported = false;\n#else\n    m_buf_supported = true;\n#endif\n}\n\nTiffEncoder::~TiffEncoder()\n{\n}\n\nImageEncoder TiffEncoder::newEncoder() const\n{\n    return new TiffEncoder;\n}\n\nbool TiffEncoder::isFormatSupported( int depth ) const\n{\n    return depth == CV_8U || depth == CV_16U;\n}\n\nvoid  TiffEncoder::writeTag( WLByteStream& strm, TiffTag tag,\n                             TiffFieldType fieldType,\n                             int count, int value )\n{\n    strm.putWord( tag );\n    strm.putWord( fieldType );\n    strm.putDWord( count );\n    strm.putDWord( value );\n}\n\n#ifdef HAVE_TIFF\nbool  TiffEncoder::writeLibTiff( const Mat& img, const vector<int>& /*params*/)\n{\n    int channels = img.channels();\n    int width = img.cols, height = img.rows;\n    int depth = img.depth();\n\n    int bitsPerChannel = -1;\n    switch (depth)\n    {\n        case CV_8U:\n        {\n            bitsPerChannel = 8;\n            break;\n        }\n        case CV_16U:\n        {\n            bitsPerChannel = 16;\n            break;\n        }\n        default:\n        {\n            return false;\n        }\n    }\n\n    const int bitsPerByte = 8;\n    size_t fileStep = (width * channels * bitsPerChannel) / bitsPerByte;\n    int rowsPerStrip = (int)((1 << 13)/fileStep);\n\n    if( rowsPerStrip < 1 )\n        rowsPerStrip = 1;\n\n    if( rowsPerStrip > height )\n        rowsPerStrip = height;\n\n\n    // do NOT put \"wb\" as the mode, because the b means \"big endian\" mode, not \"binary\" mode.\n    // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n    TIFF* pTiffHandle = TIFFOpen(m_filename.c_str(), \"w\");\n    if (!pTiffHandle)\n    {\n        return false;\n    }\n\n    // defaults for now, maybe base them on params in the future\n    int   compression  = COMPRESSION_LZW;\n    int   predictor    = PREDICTOR_HORIZONTAL;\n\n    int   colorspace = channels > 1 ? PHOTOMETRIC_RGB : PHOTOMETRIC_MINISBLACK;\n\n    if ( !TIFFSetField(pTiffHandle, TIFFTAG_IMAGEWIDTH, width)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_IMAGELENGTH, height)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_BITSPERSAMPLE, bitsPerChannel)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_COMPRESSION, compression)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_PHOTOMETRIC, colorspace)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_SAMPLESPERPIXEL, channels)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_ROWSPERSTRIP, rowsPerStrip)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_PREDICTOR, predictor)\n       )\n    {\n        TIFFClose(pTiffHandle);\n        return false;\n    }\n\n    // row buffer, because TIFFWriteScanline modifies the original data!\n    size_t scanlineSize = TIFFScanlineSize(pTiffHandle);\n    AutoBuffer<uchar,1024> _buffer(scanlineSize+32);\n    uchar* buffer = _buffer;\n    if (!buffer)\n    {\n        TIFFClose(pTiffHandle);\n        return false;\n    }\n\n    for (int y = 0; y < height; ++y)\n    {\n        switch(channels)\n        {\n            case 1:\n            {\n                memcpy(buffer, img.data + img.step * y, scanlineSize);\n                break;\n            }\n\n            case 3:\n            {\n                if (depth == CV_8U)\n                    icvCvt_BGR2RGB_8u_C3R( img.data + img.step*y, 0, buffer, 0, cvSize(width,1) );\n                else\n                    icvCvt_BGR2RGB_16u_C3R( (const ushort*)(img.data + img.step*y), 0, (ushort*)buffer, 0, cvSize(width,1) );\n                break;\n            }\n\n            case 4:\n            {\n                if (depth == CV_8U)\n                    icvCvt_BGRA2RGBA_8u_C4R( img.data + img.step*y, 0, buffer, 0, cvSize(width,1) );\n                else\n                    icvCvt_BGRA2RGBA_16u_C4R( (const ushort*)(img.data + img.step*y), 0, (ushort*)buffer, 0, cvSize(width,1) );\n            }\n\n            default:\n            {\n                TIFFClose(pTiffHandle);\n                return false;\n            }\n        }\n\n        int writeResult = TIFFWriteScanline(pTiffHandle, buffer, y, 0);\n        if (writeResult != 1)\n        {\n            TIFFClose(pTiffHandle);\n            return false;\n        }\n    }\n\n    TIFFClose(pTiffHandle);\n    return true;\n}\n\n#endif\n\n#ifdef HAVE_TIFF\nbool  TiffEncoder::write( const Mat& img, const vector<int>& params)\n#else\nbool  TiffEncoder::write( const Mat& img, const vector<int>& /*params*/)\n#endif\n{\n    int channels = img.channels();\n    int width = img.cols, height = img.rows;\n    int depth = img.depth();\n\n    if (depth != CV_8U && depth != CV_16U)\n        return false;\n\n    int bytesPerChannel = depth == CV_8U ? 1 : 2;\n    int fileStep = width * channels * bytesPerChannel;\n\n    WLByteStream strm;\n\n    if( m_buf )\n    {\n        if( !strm.open(*m_buf) )\n            return false;\n    }\n    else\n    {\n#ifdef HAVE_TIFF\n      return writeLibTiff(img, params);\n#else\n      if( !strm.open(m_filename) )\n          return false;\n#endif\n    }\n\n    int rowsPerStrip = (1 << 13)/fileStep;\n\n    if( rowsPerStrip < 1 )\n        rowsPerStrip = 1;\n\n    if( rowsPerStrip > height )\n        rowsPerStrip = height;\n\n    int i, stripCount = (height + rowsPerStrip - 1) / rowsPerStrip;\n\n    if( m_buf )\n        m_buf->reserve( alignSize(stripCount*8 + fileStep*height + 256, 256) );\n\n/*#if defined _DEBUG || !defined WIN32\n    int uncompressedRowSize = rowsPerStrip * fileStep;\n#endif*/\n    int directoryOffset = 0;\n\n    AutoBuffer<int,1024> stripOffsets(stripCount);\n    AutoBuffer<short,1024> stripCounts(stripCount);\n    AutoBuffer<uchar,1024> _buffer(fileStep+32);\n    uchar* buffer = _buffer;\n    int  stripOffsetsOffset = 0;\n    int  stripCountsOffset = 0;\n    int  bitsPerSample = 8 * bytesPerChannel;\n    int  y = 0;\n\n    strm.putBytes( fmtSignTiffII, 4 );\n    strm.putDWord( directoryOffset );\n\n    // write an image data first (the most reasonable way\n    // for compressed images)\n    for( i = 0; i < stripCount; i++ )\n    {\n        int limit = y + rowsPerStrip;\n\n        if( limit > height )\n            limit = height;\n\n        stripOffsets[i] = strm.getPos();\n\n        for( ; y < limit; y++ )\n        {\n            if( channels == 3 )\n            {\n                if (depth == CV_8U)\n                    icvCvt_BGR2RGB_8u_C3R( img.data + img.step*y, 0, buffer, 0, cvSize(width,1) );\n                else\n                    icvCvt_BGR2RGB_16u_C3R( (const ushort*)(img.data + img.step*y), 0, (ushort*)buffer, 0, cvSize(width,1) );\n            }\n            else\n            {\n              if( channels == 4 )\n              {\n                if (depth == CV_8U)\n                    icvCvt_BGRA2RGBA_8u_C4R( img.data + img.step*y, 0, buffer, 0, cvSize(width,1) );\n                else\n                    icvCvt_BGRA2RGBA_16u_C4R( (const ushort*)(img.data + img.step*y), 0, (ushort*)buffer, 0, cvSize(width,1) );\n              }\n            }\n\n            strm.putBytes( channels > 1 ? buffer : img.data + img.step*y, fileStep );\n        }\n\n        stripCounts[i] = (short)(strm.getPos() - stripOffsets[i]);\n        /*assert( stripCounts[i] == uncompressedRowSize ||\n                stripCounts[i] < uncompressedRowSize &&\n                i == stripCount - 1);*/\n    }\n\n    if( stripCount > 2 )\n    {\n        stripOffsetsOffset = strm.getPos();\n        for( i = 0; i < stripCount; i++ )\n            strm.putDWord( stripOffsets[i] );\n\n        stripCountsOffset = strm.getPos();\n        for( i = 0; i < stripCount; i++ )\n            strm.putWord( stripCounts[i] );\n    }\n    else if(stripCount == 2)\n    {\n        stripOffsetsOffset = strm.getPos();\n        for (i = 0; i < stripCount; i++)\n        {\n            strm.putDWord (stripOffsets [i]);\n        }\n        stripCountsOffset = stripCounts [0] + (stripCounts [1] << 16);\n    }\n    else\n    {\n        stripOffsetsOffset = stripOffsets[0];\n        stripCountsOffset = stripCounts[0];\n    }\n\n    if( channels > 1 )\n    {\n        int bitsPerSamplePos = strm.getPos();\n        strm.putWord(bitsPerSample);\n        strm.putWord(bitsPerSample);\n        strm.putWord(bitsPerSample);\n        if( channels == 4 )\n            strm.putWord(bitsPerSample);\n        bitsPerSample = bitsPerSamplePos;\n    }\n\n    directoryOffset = strm.getPos();\n\n    // write header\n    strm.putWord( 9 );\n\n    /* warning: specification 5.0 of Tiff want to have tags in\n       ascending order. This is a non-fatal error, but this cause\n       warning with some tools. So, keep this in ascending order */\n\n    writeTag( strm, TIFF_TAG_WIDTH, TIFF_TYPE_LONG, 1, width );\n    writeTag( strm, TIFF_TAG_HEIGHT, TIFF_TYPE_LONG, 1, height );\n    writeTag( strm, TIFF_TAG_BITS_PER_SAMPLE,\n              TIFF_TYPE_SHORT, channels, bitsPerSample );\n    writeTag( strm, TIFF_TAG_COMPRESSION, TIFF_TYPE_LONG, 1, TIFF_UNCOMP );\n    writeTag( strm, TIFF_TAG_PHOTOMETRIC, TIFF_TYPE_SHORT, 1, channels > 1 ? 2 : 1 );\n\n    writeTag( strm, TIFF_TAG_STRIP_OFFSETS, TIFF_TYPE_LONG,\n              stripCount, stripOffsetsOffset );\n\n    writeTag( strm, TIFF_TAG_SAMPLES_PER_PIXEL, TIFF_TYPE_SHORT, 1, channels );\n    writeTag( strm, TIFF_TAG_ROWS_PER_STRIP, TIFF_TYPE_LONG, 1, rowsPerStrip );\n\n    writeTag( strm, TIFF_TAG_STRIP_COUNTS,\n              stripCount > 1 ? TIFF_TYPE_SHORT : TIFF_TYPE_LONG,\n              stripCount, stripCountsOffset );\n\n    strm.putDWord(0);\n    strm.close();\n\n    if( m_buf )\n    {\n        (*m_buf)[4] = (uchar)directoryOffset;\n        (*m_buf)[5] = (uchar)(directoryOffset >> 8);\n        (*m_buf)[6] = (uchar)(directoryOffset >> 16);\n        (*m_buf)[7] = (uchar)(directoryOffset >> 24);\n    }\n    else\n    {\n        // write directory offset\n        FILE* f = fopen( m_filename.c_str(), \"r+b\" );\n        buffer[0] = (uchar)directoryOffset;\n        buffer[1] = (uchar)(directoryOffset >> 8);\n        buffer[2] = (uchar)(directoryOffset >> 16);\n        buffer[3] = (uchar)(directoryOffset >> 24);\n\n        fseek( f, 4, SEEK_SET );\n        fwrite( buffer, 1, 4, f );\n        fclose(f);\n    }\n\n    return true;\n}\n\n}\n",
                "name": "grfmt_tiff.cpp",
                "path": "modules/highgui/src/grfmt_tiff.cpp",
                "url": "/github.com/npinto/opencv/-/blob/modules/highgui/src/grfmt_tiff.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 239,
                    "offsetAndLengths": [
                        [
                            37,
                            16
                        ]
                    ],
                    "preview": "                                ok = TIFFReadRGBATile( tif, x, y, (uint32*)buffer );"
                }
            ],
            "repository": {
                "name": "github.com/npinto/opencv",
                "url": "/github.com/npinto/opencv"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "880057df505c13bc98e0b174cd50679eb3958bdc"
                },
                "content": "/*M///////////////////////////////////////////////////////////////////////////////////////\n//\n//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.\n//\n//  By downloading, copying, installing or using the software you agree to this license.\n//  If you do not agree to this license, do not download, install,\n//  copy or use the software.\n//\n//\n//                           License Agreement\n//                For Open Source Computer Vision Library\n//\n// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.\n// Copyright (C) 2009, Willow Garage Inc., all rights reserved.\n// Third party copyrights are property of their respective owners.\n//\n// Redistribution and use in source and binary forms, with or without modification,\n// are permitted provided that the following conditions are met:\n//\n//   * Redistribution's of source code must retain the above copyright notice,\n//     this list of conditions and the following disclaimer.\n//\n//   * Redistribution's in binary form must reproduce the above copyright notice,\n//     this list of conditions and the following disclaimer in the documentation\n//     and/or other materials provided with the distribution.\n//\n//   * The name of the copyright holders may not be used to endorse or promote products\n//     derived from this software without specific prior written permission.\n//\n// This software is provided by the copyright holders and contributors \"as is\" and\n// any express or implied warranties, including, but not limited to, the implied\n// warranties of merchantability and fitness for a particular purpose are disclaimed.\n// In no event shall the Intel Corporation or contributors be liable for any direct,\n// indirect, incidental, special, exemplary, or consequential damages\n// (including, but not limited to, procurement of substitute goods or services;\n// loss of use, data, or profits; or business interruption) however caused\n// and on any theory of liability, whether in contract, strict liability,\n// or tort (including negligence or otherwise) arising in any way out of\n// the use of this software, even if advised of the possibility of such damage.\n//\n//M*/\n\n/****************************************************************************************\\\n    A part of the file implements TIFF reader on base of libtiff library\n    (see otherlibs/_graphics/readme.txt for copyright notice)\n\\****************************************************************************************/\n\n#include \"precomp.hpp\"\n#include \"grfmt_tiff.hpp\"\n\nnamespace cv\n{\nstatic const char fmtSignTiffII[] = \"II\\x2a\\x00\";\nstatic const char fmtSignTiffMM[] = \"MM\\x00\\x2a\";\n\n#ifdef HAVE_TIFF\n\n#include \"tiff.h\"\n#include \"tiffio.h\"\n\nstatic int grfmt_tiff_err_handler_init = 0;\nstatic void GrFmtSilentTIFFErrorHandler( const char*, const char*, va_list ) {}\n\nTiffDecoder::TiffDecoder()\n{\n    m_tif = 0;\n    if( !grfmt_tiff_err_handler_init )\n    {\n        grfmt_tiff_err_handler_init = 1;\n\n        TIFFSetErrorHandler( GrFmtSilentTIFFErrorHandler );\n        TIFFSetWarningHandler( GrFmtSilentTIFFErrorHandler );\n    }\n}\n\n\nvoid TiffDecoder::close()\n{\n    if( m_tif )\n    {\n        TIFF* tif = (TIFF*)m_tif;\n        TIFFClose( tif );\n        m_tif = 0;\n    }\n}\n\nTiffDecoder::~TiffDecoder()\n{\n    close();\n}\n\nsize_t TiffDecoder::signatureLength() const\n{\n    return 4;\n}\n\nbool TiffDecoder::checkSignature( const string& signature ) const\n{\n    return signature.size() >= 4 &&\n        (memcmp(signature.c_str(), fmtSignTiffII, 4) == 0 ||\n        memcmp(signature.c_str(), fmtSignTiffMM, 4) == 0);\n}\n\nImageDecoder TiffDecoder::newDecoder() const\n{\n    return new TiffDecoder;\n}\n\nbool TiffDecoder::readHeader()\n{\n    bool result = false;\n\n    close();\n    TIFF* tif = TIFFOpen( m_filename.c_str(), \"rb\" );\n\n    if( tif )\n    {\n        int width = 0, height = 0, photometric = 0;\n        m_tif = tif;\n\n        if( TIFFGetField( tif, TIFFTAG_IMAGEWIDTH, &width ) &&\n            TIFFGetField( tif, TIFFTAG_IMAGELENGTH, &height ) &&\n            TIFFGetField( tif, TIFFTAG_PHOTOMETRIC, &photometric ))\n        {\n            int bpp=8, ncn = photometric > 1 ? 3 : 1;\n            TIFFGetField( tif, TIFFTAG_BITSPERSAMPLE, &bpp );\n            TIFFGetField( tif, TIFFTAG_SAMPLESPERPIXEL, &ncn );\n            \n            m_width = width;\n            m_height = height;\n            if( bpp > 8 &&\n               ((photometric != 2 && photometric != 1) ||\n                (ncn != 1 && ncn != 3 && ncn != 4)))\n                bpp = 8;\n\n            switch(bpp)\n            {\n                case 8:\n                    m_type = CV_MAKETYPE(CV_8U, photometric > 1 ? 3 : 1);\n                    break;\n                case 16:\n                    m_type = CV_MAKETYPE(CV_16U, photometric > 1 ? 3 : 1);\n                    break;\n\n                case 32:\n                    m_type = CV_MAKETYPE(CV_32F, photometric > 1 ? 3 : 1);\n                    break;\n                case 64:\n                    m_type = CV_MAKETYPE(CV_64F, photometric > 1 ? 3 : 1);\n                    break;\n\n                default:\n                    result = false;\n            }\n            result = true;\n        }\n    }\n\n    if( !result )\n        close();\n\n    return result;\n}\n\n\nbool  TiffDecoder::readData( Mat& img )\n{\n    bool result = false;\n    bool color = img.channels() > 1;\n    uchar* data = img.data;\n    int step = (int)img.step;\n    \n    if( img.depth() != CV_8U && img.depth() != CV_16U && img.depth() != CV_32F && img.depth() != CV_64F )\n        return false;\n\n    if( m_tif && m_width && m_height )\n    {\n        TIFF* tif = (TIFF*)m_tif;\n        int tile_width0 = m_width, tile_height0 = 0;\n        int x, y, i;\n        int is_tiled = TIFFIsTiled(tif);\n        int photometric;\n        TIFFGetField( tif, TIFFTAG_PHOTOMETRIC, &photometric );\n        int bpp = 8, ncn = photometric > 1 ? 3 : 1;\n        TIFFGetField( tif, TIFFTAG_BITSPERSAMPLE, &bpp );\n        TIFFGetField( tif, TIFFTAG_SAMPLESPERPIXEL, &ncn );\n        const int bitsPerByte = 8;\n        int dst_bpp = (int)(img.elemSize1() * bitsPerByte);\n\n        if(dst_bpp == 8)\n        {\n            char errmsg[1024];\n            if(!TIFFRGBAImageOK( tif, errmsg ))\n            {\n                close();\n                return false;\n            }\n        }\n\n        if( (!is_tiled &&\n            TIFFGetField( tif, TIFFTAG_ROWSPERSTRIP, &tile_height0 )) ||\n            (is_tiled &&\n            TIFFGetField( tif, TIFFTAG_TILEWIDTH, &tile_width0 ) &&\n            TIFFGetField( tif, TIFFTAG_TILELENGTH, &tile_height0 )))\n        {\n            if( tile_width0 <= 0 )\n                tile_width0 = m_width;\n\n            if( tile_height0 <= 0 )\n                tile_height0 = m_height;\n\n            AutoBuffer<uchar> _buffer(tile_height0*tile_width0*8);\n            uchar* buffer = _buffer;\n            ushort* buffer16 = (ushort*)buffer;\n            float* buffer32 = (float*)buffer;\n            double* buffer64 = (double*)buffer;\n            int tileidx = 0;\n\n            for( y = 0; y < m_height; y += tile_height0, data += step*tile_height0 )\n            {\n                int tile_height = tile_height0;\n\n                if( y + tile_height > m_height )\n                    tile_height = m_height - y;\n\n                for( x = 0; x < m_width; x += tile_width0, tileidx++ )\n                {\n                    int tile_width = tile_width0, ok;\n\n                    if( x + tile_width > m_width )\n                        tile_width = m_width - x;\n\n                    switch(dst_bpp)\n                    {\n                        case 8:\n                        {\n                            if( !is_tiled )\n                                ok = TIFFReadRGBAStrip( tif, y, (uint32*)buffer );\n                            else\n                                ok = TIFFReadRGBATile( tif, x, y, (uint32*)buffer );\n\n                            if( !ok )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                                if( color )\n                                    icvCvt_BGRA2BGR_8u_C4C3R( buffer + i*tile_width*4, 0,\n                                                             data + x*3 + step*(tile_height - i - 1), 0,\n                                                             cvSize(tile_width,1), 2 );\n                                else\n                                    icvCvt_BGRA2Gray_8u_C4C1R( buffer + i*tile_width*4, 0,\n                                                              data + x + step*(tile_height - i - 1), 0,\n                                                              cvSize(tile_width,1), 2 );\n                            break;\n                        }\n\n                        case 16:\n                        {\n                            if( !is_tiled )\n                                ok = (int)TIFFReadEncodedStrip( tif, tileidx, (uint32*)buffer, (tsize_t)-1 ) >= 0;\n                            else\n                                ok = (int)TIFFReadEncodedTile( tif, tileidx, (uint32*)buffer, (tsize_t)-1 ) >= 0;\n\n                            if( !ok )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                            {\n                                if( color )\n                                {\n                                    if( ncn == 1 )\n                                    {\n                                        icvCvt_Gray2BGR_16u_C1C3R(buffer16 + i*tile_width*ncn, 0,\n                                                                  (ushort*)(data + step*i) + x*3, 0,\n                                                                  cvSize(tile_width,1) );\n                                    }\n                                    else if( ncn == 3 )\n                                    {\n                                        icvCvt_RGB2BGR_16u_C3R(buffer16 + i*tile_width*ncn, 0,\n                                                               (ushort*)(data + step*i) + x*3, 0,\n                                                               cvSize(tile_width,1) );\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2BGR_16u_C4C3R(buffer16 + i*tile_width*ncn, 0,\n                                                               (ushort*)(data + step*i) + x*3, 0,\n                                                               cvSize(tile_width,1), 2 );\n                                    }\n                                }\n                                else\n                                {\n                                    if( ncn == 1 )\n                                    {\n                                        memcpy((ushort*)(data + step*i)+x,\n                                               buffer16 + i*tile_width*ncn,\n                                               tile_width*sizeof(buffer16[0]));\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2Gray_16u_CnC1R(buffer16 + i*tile_width*ncn, 0,\n                                                               (ushort*)(data + step*i) + x, 0,\n                                                               cvSize(tile_width,1), ncn, 2 );\n                                    }\n                                }\n                            }\n                            break;\n                        }\n\n                        case 32:\n                        case 64:\n                        {\n                            if( !is_tiled )\n                                ok = (int)TIFFReadEncodedStrip( tif, tileidx, buffer, (tsize_t)-1 ) >= 0;\n                            else\n                                ok = (int)TIFFReadEncodedTile( tif, tileidx, buffer, (tsize_t)-1 ) >= 0;\n\n                            if( !ok || ncn != 1 )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                            {\n                                if(dst_bpp == 32)\n                                {\n                                    memcpy((float*)(data + step*i)+x,\n                                           buffer32 + i*tile_width*ncn,\n                                           tile_width*sizeof(buffer32[0]));\n                                }\n                                else\n                                {\n                                    memcpy((double*)(data + step*i)+x,\n                                         buffer64 + i*tile_width*ncn,\n                                         tile_width*sizeof(buffer64[0]));\n                                }\n                            }\n\n                            break;\n                        }\n                        default:\n                        {\n                            close();\n                            return false;\n                        }\n                    }\n                }\n            }\n\n            result = true;\n        }\n    }\n\n    close();\n    return result;\n}\n\n#endif\n\n//////////////////////////////////////////////////////////////////////////////////////////\n\nTiffEncoder::TiffEncoder()\n{\n    m_description = \"TIFF Files (*.tiff;*.tif)\";\n#ifdef HAVE_TIFF\n    m_buf_supported = false;\n#else\n    m_buf_supported = true;\n#endif\n}\n\nTiffEncoder::~TiffEncoder()\n{\n}\n\nImageEncoder TiffEncoder::newEncoder() const\n{\n    return new TiffEncoder;\n}\n\nbool TiffEncoder::isFormatSupported( int depth ) const\n{\n    return depth == CV_8U || depth == CV_16U;\n}\n\nvoid  TiffEncoder::writeTag( WLByteStream& strm, TiffTag tag,\n                             TiffFieldType fieldType,\n                             int count, int value )\n{\n    strm.putWord( tag );\n    strm.putWord( fieldType );\n    strm.putDWord( count );\n    strm.putDWord( value );\n}\n\n#ifdef HAVE_TIFF\nbool  TiffEncoder::writeLibTiff( const Mat& img, const vector<int>& /*params*/)\n{\n    int channels = img.channels();\n    int width = img.cols, height = img.rows;\n    int depth = img.depth();\n\n    int bitsPerChannel = -1;\n    switch (depth)\n    {\n        case CV_8U:\n        {\n            bitsPerChannel = 8;\n            break;\n        }\n        case CV_16U:\n        {\n            bitsPerChannel = 16;\n            break;\n        }\n        default:\n        {\n            return false;\n        }   \n    }\n    \n    const int bitsPerByte = 8;\n    size_t fileStep = (width * channels * bitsPerChannel) / bitsPerByte;\n    int rowsPerStrip = (int)((1 << 13)/fileStep);\n\n    if( rowsPerStrip < 1 )\n        rowsPerStrip = 1;\n\n    if( rowsPerStrip > height )\n        rowsPerStrip = height;\n\n\n    // do NOT put \"wb\" as the mode, because the b means \"big endian\" mode, not \"binary\" mode.\n    // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n    TIFF* pTiffHandle = TIFFOpen(m_filename.c_str(), \"w\");\n    if (!pTiffHandle)\n    {\n        return false;\n    }\n    \n    // defaults for now, maybe base them on params in the future\n    int   compression  = COMPRESSION_LZW;\n    int   predictor    = PREDICTOR_HORIZONTAL;\n\n    int   colorspace = channels > 1 ? PHOTOMETRIC_RGB : PHOTOMETRIC_MINISBLACK;\n\n    if ( !TIFFSetField(pTiffHandle, TIFFTAG_IMAGEWIDTH, width)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_IMAGELENGTH, height)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_BITSPERSAMPLE, bitsPerChannel)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_COMPRESSION, compression)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_PHOTOMETRIC, colorspace)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_SAMPLESPERPIXEL, channels)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_ROWSPERSTRIP, rowsPerStrip)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_PREDICTOR, predictor)\n       )\n    {\n        TIFFClose(pTiffHandle);\n        return false;\n    }\n\n    // row buffer, because TIFFWriteScanline modifies the original data!\n    size_t scanlineSize = TIFFScanlineSize(pTiffHandle);\n    AutoBuffer<uchar,1024> _buffer(scanlineSize+32);\n    uchar* buffer = _buffer;\n    if (!buffer)\n    {\n        TIFFClose(pTiffHandle);\n        return false;\n    }\n\n    for (int y = 0; y < height; ++y)\n    {\n        switch(channels)\n        {\n            case 1:\n            {\n                memcpy(buffer, img.data + img.step * y, scanlineSize);\n                break;\n            }\n\n            case 3:\n            {\n                if (depth == CV_8U)\n                    icvCvt_BGR2RGB_8u_C3R( img.data + img.step*y, 0, buffer, 0, cvSize(width,1) );\n                else\n                    icvCvt_BGR2RGB_16u_C3R( (const ushort*)(img.data + img.step*y), 0, (ushort*)buffer, 0, cvSize(width,1) );\n                break;\n            }\n\n            case 4:\n            {\n                if (depth == CV_8U)\n                    icvCvt_BGRA2RGBA_8u_C4R( img.data + img.step*y, 0, buffer, 0, cvSize(width,1) );\n                else\n                    icvCvt_BGRA2RGBA_16u_C4R( (const ushort*)(img.data + img.step*y), 0, (ushort*)buffer, 0, cvSize(width,1) );\n            }\n\n            default:\n            {\n                TIFFClose(pTiffHandle);\n                return false;\n            }\n        }\n\n        int writeResult = TIFFWriteScanline(pTiffHandle, buffer, y, 0);\n        if (writeResult != 1)\n        {\n            TIFFClose(pTiffHandle);\n            return false;\n        }\n    }\n    \n    TIFFClose(pTiffHandle);\n    return true;\n}\n\n#endif\n\n#ifdef HAVE_TIFF\nbool  TiffEncoder::write( const Mat& img, const vector<int>& params)\n#else\nbool  TiffEncoder::write( const Mat& img, const vector<int>& /*params*/)\n#endif\n{\n    int channels = img.channels();\n    int width = img.cols, height = img.rows;\n    int depth = img.depth();\n\n    if (depth != CV_8U && depth != CV_16U)\n        return false;\n\n    int bytesPerChannel = depth == CV_8U ? 1 : 2;\n    int fileStep = width * channels * bytesPerChannel;\n\n    WLByteStream strm;\n\n    if( m_buf )\n    {\n        if( !strm.open(*m_buf) )\n            return false;\n    }\n    else \n    {\n#ifdef HAVE_TIFF\n      return writeLibTiff(img, params);\n#else\n      if( !strm.open(m_filename) )\n          return false;\n#endif\n    }\n\n    int rowsPerStrip = (1 << 13)/fileStep;\n\n    if( rowsPerStrip < 1 )\n        rowsPerStrip = 1;\n\n    if( rowsPerStrip > height )\n        rowsPerStrip = height;\n\n    int i, stripCount = (height + rowsPerStrip - 1) / rowsPerStrip;\n\n    if( m_buf )\n        m_buf->reserve( alignSize(stripCount*8 + fileStep*height + 256, 256) );\n\n/*#if defined _DEBUG || !defined WIN32\n    int uncompressedRowSize = rowsPerStrip * fileStep;\n#endif*/\n    int directoryOffset = 0;\n\n    AutoBuffer<int,1024> stripOffsets(stripCount);\n    AutoBuffer<short,1024> stripCounts(stripCount);\n    AutoBuffer<uchar,1024> _buffer(fileStep+32);\n    uchar* buffer = _buffer;\n    int  stripOffsetsOffset = 0;\n    int  stripCountsOffset = 0;\n    int  bitsPerSample = 8 * bytesPerChannel;\n    int  y = 0;\n\n    strm.putBytes( fmtSignTiffII, 4 );\n    strm.putDWord( directoryOffset );\n\n    // write an image data first (the most reasonable way\n    // for compressed images)\n    for( i = 0; i < stripCount; i++ )\n    {\n        int limit = y + rowsPerStrip;\n\n        if( limit > height )\n            limit = height;\n\n        stripOffsets[i] = strm.getPos();\n\n        for( ; y < limit; y++ )\n        {\n            if( channels == 3 )\n            {\n                if (depth == CV_8U)\n                    icvCvt_BGR2RGB_8u_C3R( img.data + img.step*y, 0, buffer, 0, cvSize(width,1) );\n                else\n                    icvCvt_BGR2RGB_16u_C3R( (const ushort*)(img.data + img.step*y), 0, (ushort*)buffer, 0, cvSize(width,1) );\n            }\n            else\n            {\n              if( channels == 4 )\n              {\n                if (depth == CV_8U)\n                    icvCvt_BGRA2RGBA_8u_C4R( img.data + img.step*y, 0, buffer, 0, cvSize(width,1) );\n                else\n                    icvCvt_BGRA2RGBA_16u_C4R( (const ushort*)(img.data + img.step*y), 0, (ushort*)buffer, 0, cvSize(width,1) );\n              }\n            }\n\n            strm.putBytes( channels > 1 ? buffer : img.data + img.step*y, fileStep );\n        }\n\n        stripCounts[i] = (short)(strm.getPos() - stripOffsets[i]);\n        /*assert( stripCounts[i] == uncompressedRowSize ||\n                stripCounts[i] < uncompressedRowSize &&\n                i == stripCount - 1);*/\n    }\n\n    if( stripCount > 2 )\n    {\n        stripOffsetsOffset = strm.getPos();\n        for( i = 0; i < stripCount; i++ )\n            strm.putDWord( stripOffsets[i] );\n\n        stripCountsOffset = strm.getPos();\n        for( i = 0; i < stripCount; i++ )\n            strm.putWord( stripCounts[i] );\n    }\n    else if(stripCount == 2)\n    {\n        stripOffsetsOffset = strm.getPos();\n        for (i = 0; i < stripCount; i++)\n        {\n            strm.putDWord (stripOffsets [i]);\n        }\n        stripCountsOffset = stripCounts [0] + (stripCounts [1] << 16);\n    }\n    else\n    {\n        stripOffsetsOffset = stripOffsets[0];\n        stripCountsOffset = stripCounts[0];\n    }\n\n    if( channels > 1 )\n    {\n        int bitsPerSamplePos = strm.getPos();\n        strm.putWord(bitsPerSample);\n        strm.putWord(bitsPerSample);\n        strm.putWord(bitsPerSample);\n        if( channels == 4 )\n            strm.putWord(bitsPerSample);\n        bitsPerSample = bitsPerSamplePos;\n    }\n\n    directoryOffset = strm.getPos();\n\n    // write header\n    strm.putWord( 9 );\n\n    /* warning: specification 5.0 of Tiff want to have tags in\n       ascending order. This is a non-fatal error, but this cause\n       warning with some tools. So, keep this in ascending order */\n\n    writeTag( strm, TIFF_TAG_WIDTH, TIFF_TYPE_LONG, 1, width );\n    writeTag( strm, TIFF_TAG_HEIGHT, TIFF_TYPE_LONG, 1, height );\n    writeTag( strm, TIFF_TAG_BITS_PER_SAMPLE,\n              TIFF_TYPE_SHORT, channels, bitsPerSample );\n    writeTag( strm, TIFF_TAG_COMPRESSION, TIFF_TYPE_LONG, 1, TIFF_UNCOMP );\n    writeTag( strm, TIFF_TAG_PHOTOMETRIC, TIFF_TYPE_SHORT, 1, channels > 1 ? 2 : 1 );\n\n    writeTag( strm, TIFF_TAG_STRIP_OFFSETS, TIFF_TYPE_LONG,\n              stripCount, stripOffsetsOffset );\n\n    writeTag( strm, TIFF_TAG_SAMPLES_PER_PIXEL, TIFF_TYPE_SHORT, 1, channels );\n    writeTag( strm, TIFF_TAG_ROWS_PER_STRIP, TIFF_TYPE_LONG, 1, rowsPerStrip );\n\n    writeTag( strm, TIFF_TAG_STRIP_COUNTS,\n              stripCount > 1 ? TIFF_TYPE_SHORT : TIFF_TYPE_LONG,\n              stripCount, stripCountsOffset );\n\n    strm.putDWord(0);\n    strm.close();\n\n    if( m_buf )\n    {\n        (*m_buf)[4] = (uchar)directoryOffset;\n        (*m_buf)[5] = (uchar)(directoryOffset >> 8);\n        (*m_buf)[6] = (uchar)(directoryOffset >> 16);\n        (*m_buf)[7] = (uchar)(directoryOffset >> 24);\n    }\n    else\n    {\n        // write directory offset\n        FILE* f = fopen( m_filename.c_str(), \"r+b\" );\n        buffer[0] = (uchar)directoryOffset;\n        buffer[1] = (uchar)(directoryOffset >> 8);\n        buffer[2] = (uchar)(directoryOffset >> 16);\n        buffer[3] = (uchar)(directoryOffset >> 24);\n\n        fseek( f, 4, SEEK_SET );\n        fwrite( buffer, 1, 4, f );\n        fclose(f);\n    }\n\n    return true;\n}\n\n}\n",
                "name": "grfmt_tiff.cpp",
                "path": "Face Recognition Library/ThirdParty/OpenCV/modules/highgui/src/grfmt_tiff.cpp",
                "url": "/github.com/pcentieiro/midian/-/blob/Face%20Recognition%20Library/ThirdParty/OpenCV/modules/highgui/src/grfmt_tiff.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 239,
                    "offsetAndLengths": [
                        [
                            37,
                            16
                        ]
                    ],
                    "preview": "                                ok = TIFFReadRGBATile( tif, x, y, (uint32*)buffer );"
                }
            ],
            "repository": {
                "name": "github.com/pcentieiro/midian",
                "url": "/github.com/pcentieiro/midian"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "7c9886ab67ac03d53bdb04f161b9605d3f3dd810"
                },
                "content": "/******************************************************************************\n * $Id$\n *\n * Project:  GeoTIFF Driver\n * Purpose:  GDAL GeoTIFF support.\n * Author:   Frank Warmerdam, warmerdam@pobox.com\n *\n ******************************************************************************\n * Copyright (c) 1998, 2002, Frank Warmerdam <warmerdam@pobox.com>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n ****************************************************************************/\n\n#include \"gdal_pam.h\"\n#define CPL_SERV_H_INCLUDED\n\n#include \"tiffio.h\"\n#include \"xtiffio.h\"\n#include \"geotiff.h\"\n#include \"geo_normalize.h\"\n#include \"geovalues.h\"\n#include \"cpl_string.h\"\n#include \"cpl_csv.h\"\n#include \"cpl_minixml.h\"\n#include \"gt_overview.h\"\n#include \"ogr_spatialref.h\"\n\nCPL_CVSID(\"$Id$\");\n\nCPL_C_START\nchar CPL_DLL *  GTIFGetOGISDefn( GTIF *, GTIFDefn * );\nint  CPL_DLL   GTIFSetFromOGISDefn( GTIF *, const char * );\nconst char * GDALDefaultCSVFilename( const char *pszBasename );\nGUInt32 HalfToFloat( GUInt16 );\nGUInt32 TripleToFloat( GUInt32 );\nvoid    GTiffOneTimeInit();\nCPL_C_END\n\n#define TIFFTAG_GDAL_METADATA  42112\n#define TIFFTAG_GDAL_NODATA    42113\n#define TIFFTAG_RPCCOEFFICIENT 50844\n\n#if TIFFLIB_VERSION >= 20081217 && defined(BIGTIFF_SUPPORT)\n#  define HAVE_UNSETFIELD\n#endif\n\nTIFF* VSI_TIFFOpen(const char* name, const char* mode);\n\nenum\n{\n    ENDIANNESS_NATIVE,\n    ENDIANNESS_LITTLE,\n    ENDIANNESS_BIG\n};\n\n/************************************************************************/\n/* ==================================================================== */\n/*\t\t\t\tGTiffDataset\t\t\t\t*/\n/* ==================================================================== */\n/************************************************************************/\n\nclass GTiffRasterBand;\nclass GTiffRGBABand;\nclass GTiffBitmapBand;\n\nclass GTiffDataset : public GDALPamDataset\n{\n    friend class GTiffRasterBand;\n    friend class GTiffSplitBand;\n    friend class GTiffRGBABand;\n    friend class GTiffBitmapBand;\n    friend class GTiffSplitBitmapBand;\n    friend class GTiffOddBitsBand;\n    \n    TIFF\t*hTIFF;\n    GTiffDataset **ppoActiveDSRef;\n    GTiffDataset *poActiveDS; /* only used in actual base */\n\n    toff_t      nDirOffset;\n    int\t\tbBase;\n    int         bCloseTIFFHandle; /* usefull for closing TIFF handle opened by GTIFF_DIR: */\n\n    uint16\tnPlanarConfig;\n    uint16\tnSamplesPerPixel;\n    uint16\tnBitsPerSample;\n    uint32\tnRowsPerStrip;\n    uint16\tnPhotometric;\n    uint16      nSampleFormat;\n    uint16      nCompression;\n    \n    int\t\tnBlocksPerBand;\n\n    uint32      nBlockXSize;\n    uint32\tnBlockYSize;\n\n    int\t\tnLoadedBlock;\t\t/* or tile */\n    int         bLoadedBlockDirty;  \n    GByte\t*pabyBlockBuf;\n\n    CPLErr      LoadBlockBuf( int nBlockId, int bReadFromDisk = TRUE );\n    CPLErr      FlushBlockBuf();\n\n    char\t*pszProjection;\n    int         bLookedForProjection;\n\n    void        LookForProjection();\n\n    double\tadfGeoTransform[6];\n    int\t\tbGeoTransformValid;\n\n    int         bTreatAsRGBA;\n    int         bCrystalized;\n\n    void\tCrystalize();\n\n    GDALColorTable *poColorTable;\n\n    void\tWriteGeoTIFFInfo();\n    int\t\tSetDirectory( toff_t nDirOffset = 0 );\n\n    int\t\tnOverviewCount;\n    GTiffDataset **papoOverviewDS;\n\n    int\t\tnGCPCount;\n    GDAL_GCP\t*pasGCPList;\n\n    int         IsBlockAvailable( int nBlockId );\n\n    int         bGeoTIFFInfoChanged;\n    int         bNoDataSet;\n    double      dfNoDataValue;\n\n    int\t        bMetadataChanged;\n\n    int         bNeedsRewrite;\n\n    void        ApplyPamInfo();\n    void        PushMetadataToPam();\n\n    GDALMultiDomainMetadata oGTiffMDMD;\n\n    CPLString   osProfile;\n    char      **papszCreationOptions;\n\n    int         bLoadingOtherBands;\n\n    static void WriteRPCTag( TIFF *, char ** );\n    void        ReadRPCTag();\n\n    void*        pabyTempWriteBuffer;\n    int          nTempWriteBufferSize;\n    int          WriteEncodedTile(uint32 tile, void* data, int bPreserveDataBuffer);\n    int          WriteEncodedStrip(uint32 strip, void* data, int bPreserveDataBuffer);\n\n    GTiffDataset* poMaskDS;\n    GTiffDataset* poBaseDS;\n\n    CPLString    osFilename;\n\n    int          bFillEmptyTiles;\n    void         FillEmptyTiles(void);\n\n    void         FlushDirectory();\n    CPLErr       CleanOverviews();\n\n    /* Used for the all-in-on-strip case */\n    int           nLastLineRead;\n    int           nLastBandRead;\n    int           bTreatAsSplit;\n    int           bTreatAsSplitBitmap;\n\n  public:\n                 GTiffDataset();\n                 ~GTiffDataset();\n\n    virtual const char *GetProjectionRef(void);\n    virtual CPLErr SetProjection( const char * );\n    virtual CPLErr GetGeoTransform( double * );\n    virtual CPLErr SetGeoTransform( double * );\n\n    virtual int    GetGCPCount();\n    virtual const char *GetGCPProjection();\n    virtual const GDAL_GCP *GetGCPs();\n    CPLErr         SetGCPs( int, const GDAL_GCP *, const char * );\n\n    virtual char **GetFileList(void);\n\n    virtual CPLErr IBuildOverviews( const char *, int, int *, int, int *, \n                                    GDALProgressFunc, void * );\n\n    CPLErr\t   OpenOffset( TIFF *, GTiffDataset **ppoActiveDSRef, \n                               toff_t nDirOffset, int, GDALAccess, \n                               int bAllowRGBAInterface = TRUE);\n\n    static GDALDataset *OpenDir( GDALOpenInfo * );\n    static GDALDataset *Open( GDALOpenInfo * );\n    static int          Identify( GDALOpenInfo * );\n    static GDALDataset *Create( const char * pszFilename,\n                                int nXSize, int nYSize, int nBands,\n                                GDALDataType eType, char ** papszParmList );\n    static GDALDataset *CreateCopy( const char * pszFilename, \n                                    GDALDataset *poSrcDS, \n                                    int bStrict, char ** papszOptions, \n                                    GDALProgressFunc pfnProgress, \n                                    void * pProgressData );\n    virtual void    FlushCache( void );\n\n    virtual CPLErr  SetMetadata( char **, const char * = \"\" );\n    virtual char  **GetMetadata( const char * pszDomain = \"\" );\n    virtual CPLErr  SetMetadataItem( const char*, const char*, \n                                     const char* = \"\" );\n    virtual const char *GetMetadataItem( const char * pszName,\n                                         const char * pszDomain = \"\" );\n    virtual void   *GetInternalHandle( const char * );\n\n    virtual CPLErr          CreateMaskBand( int nFlags );\n\n    // only needed by createcopy and close code.\n    static int\t    WriteMetadata( GDALDataset *, TIFF *, int, const char *,\n                                   const char *, char **, int bExcludeRPBandIMGFileWriting = FALSE );\n    static void\t    WriteNoDataValue( TIFF *, double );\n\n    static TIFF *   CreateLL( const char * pszFilename,\n                              int nXSize, int nYSize, int nBands,\n                              GDALDataType eType, char **papszParmList );\n\n    CPLErr   WriteEncodedTileOrStrip(uint32 tile_or_strip, void* data, int bPreserveDataBuffer);\n};\n\n/************************************************************************/\n/* ==================================================================== */\n/*                            GTiffRasterBand                           */\n/* ==================================================================== */\n/************************************************************************/\n\nclass GTiffRasterBand : public GDALPamRasterBand\n{\n    friend class GTiffDataset;\n\n    GDALColorInterp    eBandInterp;\n\n    int                bHaveOffsetScale;\n    double             dfOffset;\n    double             dfScale;\n    CPLString          osUnitType;\n\nprotected:\n    GTiffDataset       *poGDS;\n    GDALMultiDomainMetadata oGTiffMDMD;\n\n    int                bNoDataSet;\n    double             dfNoDataValue;\n\n    void NullBlock( void *pData );\n\npublic:\n                   GTiffRasterBand( GTiffDataset *, int );\n\n    // should override RasterIO eventually.\n    \n    virtual CPLErr IReadBlock( int, int, void * );\n    virtual CPLErr IWriteBlock( int, int, void * ); \n\n    virtual GDALColorInterp GetColorInterpretation();\n    virtual GDALColorTable *GetColorTable();\n    virtual CPLErr          SetColorTable( GDALColorTable * );\n    virtual double\t    GetNoDataValue( int * );\n    virtual CPLErr\t    SetNoDataValue( double );\n\n    virtual double GetOffset( int *pbSuccess = NULL );\n    virtual CPLErr SetOffset( double dfNewValue );\n    virtual double GetScale( int *pbSuccess = NULL );\n    virtual CPLErr SetScale( double dfNewValue );\n    virtual const char* GetUnitType();\n    virtual CPLErr SetUnitType( const char *pszNewValue );\n    virtual CPLErr SetColorInterpretation( GDALColorInterp );\n\n    virtual CPLErr  SetMetadata( char **, const char * = \"\" );\n    virtual char  **GetMetadata( const char * pszDomain = \"\" );\n    virtual CPLErr  SetMetadataItem( const char*, const char*, \n                                     const char* = \"\" );\n    virtual const char *GetMetadataItem( const char * pszName,\n                                         const char * pszDomain = \"\" );\n    virtual int    GetOverviewCount();\n    virtual GDALRasterBand *GetOverview( int );\n\n    virtual GDALRasterBand *GetMaskBand();\n    virtual int             GetMaskFlags();\n    virtual CPLErr          CreateMaskBand( int nFlags );\n};\n\n/************************************************************************/\n/*                           GTiffRasterBand()                          */\n/************************************************************************/\n\nGTiffRasterBand::GTiffRasterBand( GTiffDataset *poDS, int nBand )\n\n{\n    poGDS = poDS;\n\n    this->poDS = poDS;\n    this->nBand = nBand;\n\n    bHaveOffsetScale = FALSE;\n    dfOffset = 0.0;\n    dfScale = 1.0;\n\n/* -------------------------------------------------------------------- */\n/*      Get the GDAL data type.                                         */\n/* -------------------------------------------------------------------- */\n    uint16\t\tnSampleFormat = poDS->nSampleFormat;\n\n    eDataType = GDT_Unknown;\n\n    if( poDS->nBitsPerSample <= 8 )\n    {\n        eDataType = GDT_Byte;\n        if( nSampleFormat == SAMPLEFORMAT_INT )\n            SetMetadataItem( \"PIXELTYPE\", \"SIGNEDBYTE\", \"IMAGE_STRUCTURE\" );\n            \n    }\n    else if( poDS->nBitsPerSample <= 16 )\n    {\n        if( nSampleFormat == SAMPLEFORMAT_INT )\n            eDataType = GDT_Int16;\n        else\n            eDataType = GDT_UInt16;\n    }\n    else if( poDS->nBitsPerSample == 32 )\n    {\n        if( nSampleFormat == SAMPLEFORMAT_COMPLEXINT )\n            eDataType = GDT_CInt16;\n        else if( nSampleFormat == SAMPLEFORMAT_IEEEFP )\n            eDataType = GDT_Float32;\n        else if( nSampleFormat == SAMPLEFORMAT_INT )\n            eDataType = GDT_Int32;\n        else\n            eDataType = GDT_UInt32;\n    }\n    else if( poDS->nBitsPerSample == 64 )\n    {\n        if( nSampleFormat == SAMPLEFORMAT_IEEEFP )\n            eDataType = GDT_Float64;\n        else if( nSampleFormat == SAMPLEFORMAT_COMPLEXIEEEFP )\n            eDataType = GDT_CFloat32;\n        else if( nSampleFormat == SAMPLEFORMAT_COMPLEXINT )\n            eDataType = GDT_CInt32;\n    }\n    else if( poDS->nBitsPerSample == 128 )\n    {\n        if( nSampleFormat == SAMPLEFORMAT_COMPLEXIEEEFP )\n            eDataType = GDT_CFloat64;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Try to work out band color interpretation.                      */\n/* -------------------------------------------------------------------- */\n    if( poDS->poColorTable != NULL && nBand == 1 ) \n        eBandInterp = GCI_PaletteIndex;\n    else if( poDS->nPhotometric == PHOTOMETRIC_RGB \n             || (poDS->nPhotometric == PHOTOMETRIC_YCBCR \n                 && poDS->nCompression == COMPRESSION_JPEG \n                 && CSLTestBoolean( CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\",\n                                                       \"YES\") )) )\n    {\n        if( nBand == 1 )\n            eBandInterp = GCI_RedBand;\n        else if( nBand == 2 )\n            eBandInterp = GCI_GreenBand;\n        else if( nBand == 3 )\n            eBandInterp = GCI_BlueBand;\n        else\n        {\n            uint16 *v;\n            uint16 count = 0;\n\n            if( TIFFGetField( poDS->hTIFF, TIFFTAG_EXTRASAMPLES, &count, &v) )\n            {\n                if( nBand - 3 <= count && v[nBand-4] == EXTRASAMPLE_ASSOCALPHA )\n                    eBandInterp = GCI_AlphaBand;\n                else\n                    eBandInterp = GCI_Undefined;\n            }\n            else if( nBand == 4 )\n                eBandInterp = GCI_AlphaBand;\n            else\n                eBandInterp = GCI_Undefined;\n        }\n    }\n    else if( poDS->nPhotometric == PHOTOMETRIC_YCBCR )\n    {\n        if( nBand == 1 )\n            eBandInterp = GCI_YCbCr_YBand;\n        else if( nBand == 2 )\n            eBandInterp = GCI_YCbCr_CbBand;\n        else if( nBand == 3 )\n            eBandInterp = GCI_YCbCr_CrBand;\n        else\n        {\n            uint16 *v;\n            uint16 count = 0;\n\n            if( TIFFGetField( poDS->hTIFF, TIFFTAG_EXTRASAMPLES, &count, &v) )\n            {\n                if( nBand - 3 <= count && v[nBand-4] == EXTRASAMPLE_ASSOCALPHA )\n                    eBandInterp = GCI_AlphaBand;\n                else\n                    eBandInterp = GCI_Undefined;\n            }\n            else if( nBand == 4 )\n                eBandInterp = GCI_AlphaBand;\n            else\n                eBandInterp = GCI_Undefined;\n        }\n    }\n    else if( poDS->nPhotometric == PHOTOMETRIC_SEPARATED )\n    {\n        if( nBand == 1 )\n            eBandInterp = GCI_CyanBand;\n        else if( nBand == 2 )\n            eBandInterp = GCI_MagentaBand;\n        else if( nBand == 3 )\n            eBandInterp = GCI_YellowBand;\n        else\n            eBandInterp = GCI_BlackBand;\n    }\n    else if( poDS->nPhotometric == PHOTOMETRIC_MINISBLACK && nBand == 1 )\n        eBandInterp = GCI_GrayIndex;\n    else\n    {\n        uint16 *v;\n        uint16 count = 0;\n\n        if( TIFFGetField( poDS->hTIFF, TIFFTAG_EXTRASAMPLES, &count, &v ) )\n        {\n            int nBaseSamples;\n            nBaseSamples = poDS->nSamplesPerPixel - count;\n\n            if( nBand > nBaseSamples \n                && v[nBand-nBaseSamples-1] == EXTRASAMPLE_ASSOCALPHA )\n                eBandInterp = GCI_AlphaBand;\n            else\n                eBandInterp = GCI_Undefined;\n        }\n        else\n            eBandInterp = GCI_Undefined;\n    }\n\n/* -------------------------------------------------------------------- */\n/*\tEstablish block size for strip or tiles.\t\t\t*/\n/* -------------------------------------------------------------------- */\n    nBlockXSize = poDS->nBlockXSize;\n    nBlockYSize = poDS->nBlockYSize;\n\n    bNoDataSet = FALSE;\n    dfNoDataValue = -9999.0;\n}\n\n/************************************************************************/\n/*                             IReadBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::IReadBlock( int nBlockXOff, int nBlockYOff,\n                                    void * pImage )\n\n{\n    int\t\t\tnBlockBufSize, nBlockId, nBlockIdBand0;\n    CPLErr\t\teErr = CE_None;\n\n    if (!poGDS->SetDirectory())\n        return CE_Failure;\n\n    if( TIFFIsTiled(poGDS->hTIFF) )\n        nBlockBufSize = TIFFTileSize( poGDS->hTIFF );\n    else\n    {\n        CPLAssert( nBlockXOff == 0 );\n        nBlockBufSize = TIFFStripSize( poGDS->hTIFF );\n    }\n\n    nBlockIdBand0 = nBlockXOff + nBlockYOff * nBlocksPerRow;\n    if( poGDS->nPlanarConfig == PLANARCONFIG_SEPARATE )\n        nBlockId = nBlockIdBand0 + (nBand-1) * poGDS->nBlocksPerBand;\n    else\n        nBlockId = nBlockIdBand0;\n        \n/* -------------------------------------------------------------------- */\n/*      The bottom most partial tiles and strips are sometimes only     */\n/*      partially encoded.  This code reduces the requested data so     */\n/*      an error won't be reported in this case. (#1179)                */\n/* -------------------------------------------------------------------- */\n    int nBlockReqSize = nBlockBufSize;\n\n    if( (nBlockYOff+1) * nBlockYSize > nRasterYSize )\n    {\n        nBlockReqSize = (nBlockBufSize / nBlockYSize) \n            * (nBlockYSize - (((nBlockYOff+1) * nBlockYSize) % nRasterYSize));\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Handle the case of a strip or tile that doesn't exist yet.      */\n/*      Just set to zeros and return.                                   */\n/* -------------------------------------------------------------------- */\n    if( !poGDS->IsBlockAvailable(nBlockId) )\n    {\n        NullBlock( pImage );\n        return CE_None;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Handle simple case (separate, onesampleperpixel)\t\t*/\n/* -------------------------------------------------------------------- */\n    if( poGDS->nBands == 1\n        || poGDS->nPlanarConfig == PLANARCONFIG_SEPARATE )\n    {\n        if( nBlockReqSize < nBlockBufSize )\n            memset( pImage, 0, nBlockBufSize );\n\n        if( TIFFIsTiled( poGDS->hTIFF ) )\n        {\n            if( TIFFReadEncodedTile( poGDS->hTIFF, nBlockId, pImage,\n                                     nBlockReqSize ) == -1 )\n            {\n                memset( pImage, 0, nBlockBufSize );\n                CPLError( CE_Failure, CPLE_AppDefined,\n                          \"TIFFReadEncodedTile() failed.\\n\" );\n                \n                eErr = CE_Failure;\n            }\n        }\n        else\n        {\n            if( TIFFReadEncodedStrip( poGDS->hTIFF, nBlockId, pImage,\n                                      nBlockReqSize ) == -1 )\n            {\n                memset( pImage, 0, nBlockBufSize );\n                CPLError( CE_Failure, CPLE_AppDefined,\n                          \"TIFFReadEncodedStrip() failed.\\n\" );\n                \n                eErr = CE_Failure;\n            }\n        }\n\n        return eErr;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Load desired block                                              */\n/* -------------------------------------------------------------------- */\n    eErr = poGDS->LoadBlockBuf( nBlockId );\n    if( eErr != CE_None )\n    {\n        memset( pImage, 0,\n                nBlockXSize * nBlockYSize\n                * (GDALGetDataTypeSize(eDataType) / 8) );\n        return eErr;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Special case for YCbCr subsampled data.                         */\n/* -------------------------------------------------------------------- */\n#ifdef notdef\n    if( (eBandInterp == GCI_YCbCr_YBand \n         || eBandInterp == GCI_YCbCr_CbBand\n         ||  eBandInterp == GCI_YCbCr_CrBand)\n        && poGDS->nBitsPerSample == 8 )\n    {\n\tuint16 hs, vs;\n        int iX, iY;\n\n\tTIFFGetFieldDefaulted( poGDS->hTIFF, TIFFTAG_YCBCRSUBSAMPLING, \n                               &hs, &vs);\n        \n        for( iY = 0; iY < nBlockYSize; iY++ )\n        {\n            for( iX = 0; iX < nBlockXSize; iX++ )\n            {\n                int iBlock = (iY / vs) * (nBlockXSize/hs) + (iX / hs);\n                GByte *pabySrcBlock = poGDS->pabyBlockBuf + \n                    (vs * hs + 2) * iBlock;\n                \n                if( eBandInterp == GCI_YCbCr_YBand )\n                    ((GByte *)pImage)[iY*nBlockXSize + iX] = \n                        pabySrcBlock[(iX % hs) + (iY % vs) * hs];\n                else if( eBandInterp == GCI_YCbCr_CbBand )\n                    ((GByte *)pImage)[iY*nBlockXSize + iX] = \n                        pabySrcBlock[vs * hs + 0];\n                else if( eBandInterp == GCI_YCbCr_CrBand )\n                    ((GByte *)pImage)[iY*nBlockXSize + iX] = \n                        pabySrcBlock[vs * hs + 1];\n            }\n        }\n\n        return CE_None;\n    }\n#endif\n        \n/* -------------------------------------------------------------------- */\n/*      Handle simple case of eight bit data, and pixel interleaving.   */\n/* -------------------------------------------------------------------- */\n    if( poGDS->nBitsPerSample == 8 )\n    {\n        int\ti, nBlockPixels;\n        GByte\t*pabyImage;\n        GByte   *pabyImageDest = (GByte*)pImage;\n        int      nBands = poGDS->nBands;\n\n        pabyImage = poGDS->pabyBlockBuf + nBand - 1;\n\n        nBlockPixels = nBlockXSize * nBlockYSize;\n\n/* ==================================================================== */\n/*     Optimization for high number of words to transfer and some       */\n/*     typical band numbers : we unroll the loop.                       */\n/* ==================================================================== */\n#define COPY_TO_DST_BUFFER(nBands) \\\n        if (nBlockPixels > 100) \\\n        { \\\n            for ( i = nBlockPixels / 16; i != 0; i -- ) \\\n            { \\\n                pabyImageDest[0] = pabyImage[0*nBands]; \\\n                pabyImageDest[1] = pabyImage[1*nBands]; \\\n                pabyImageDest[2] = pabyImage[2*nBands]; \\\n                pabyImageDest[3] = pabyImage[3*nBands]; \\\n                pabyImageDest[4] = pabyImage[4*nBands]; \\\n                pabyImageDest[5] = pabyImage[5*nBands]; \\\n                pabyImageDest[6] = pabyImage[6*nBands]; \\\n                pabyImageDest[7] = pabyImage[7*nBands]; \\\n                pabyImageDest[8] = pabyImage[8*nBands]; \\\n                pabyImageDest[9] = pabyImage[9*nBands]; \\\n                pabyImageDest[10] = pabyImage[10*nBands]; \\\n                pabyImageDest[11] = pabyImage[11*nBands]; \\\n                pabyImageDest[12] = pabyImage[12*nBands]; \\\n                pabyImageDest[13] = pabyImage[13*nBands]; \\\n                pabyImageDest[14] = pabyImage[14*nBands]; \\\n                pabyImageDest[15] = pabyImage[15*nBands]; \\\n                pabyImageDest += 16; \\\n                pabyImage += 16*nBands; \\\n            } \\\n            nBlockPixels = nBlockPixels % 16; \\\n        } \\\n        for( i = 0; i < nBlockPixels; i++ ) \\\n        { \\\n            pabyImageDest[i] = *pabyImage; \\\n            pabyImage += nBands; \\\n        }\n\n        switch (nBands)\n        {\n            case 3:  COPY_TO_DST_BUFFER(3); break;\n            case 4:  COPY_TO_DST_BUFFER(4); break;\n            default:\n            {\n                for( i = 0; i < nBlockPixels; i++ )\n                {\n                    pabyImageDest[i] = *pabyImage;\n                    pabyImage += nBands;\n                }\n            }\n        }\n    }\n\n    else\n    {\n        int\ti, nBlockPixels, nWordBytes;\n        GByte\t*pabyImage;\n\n        nWordBytes = poGDS->nBitsPerSample / 8;\n        pabyImage = poGDS->pabyBlockBuf + (nBand - 1) * nWordBytes;\n\n        nBlockPixels = nBlockXSize * nBlockYSize;\n        for( i = 0; i < nBlockPixels; i++ )\n        {\n            for( int j = 0; j < nWordBytes; j++ )\n            {\n                ((GByte *) pImage)[i*nWordBytes + j] = pabyImage[j];\n            }\n            pabyImage += poGDS->nBands * nWordBytes;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      In the fairly common case of pixel interleaved 8bit data        */\n/*      that is multi-band, lets push the rest of the data into the     */\n/*      block cache too, to avoid (hopefully) having to redecode it.    */\n/*                                                                      */\n/*      Our following logic actually depends on the fact that the       */\n/*      this block is already loaded, so subsequent calls will end      */\n/*      up back in this method and pull from the loaded block.          */\n/*                                                                      */\n/*      Be careful not entering this portion of code from               */\n/*      the other bands, otherwise we'll get very deep nested calls     */\n/*      and O(nBands^2) performance !                                   */\n/*                                                                      */\n/*      If there are many bands and the block cache size is not big     */\n/*      enough to accomodate the size of all the blocks, don't enter    */\n/* -------------------------------------------------------------------- */\n    if( poGDS->nBands != 1 && eErr == CE_None && !poGDS->bLoadingOtherBands &&\n        nBlockXSize * nBlockYSize * (GDALGetDataTypeSize(eDataType) / 8) < GDALGetCacheMax() / poGDS->nBands)\n    {\n        int iOtherBand;\n\n        poGDS->bLoadingOtherBands = TRUE;\n\n        for( iOtherBand = 1; iOtherBand <= poGDS->nBands; iOtherBand++ )\n        {\n            if( iOtherBand == nBand )\n                continue;\n\n            GDALRasterBlock *poBlock;\n\n            poBlock = poGDS->GetRasterBand(iOtherBand)->\n                GetLockedBlockRef(nBlockXOff,nBlockYOff);\n            if (poBlock == NULL)\n            {\n                eErr = CE_Failure;\n                break;\n            }\n            poBlock->DropLock();\n        }\n\n        poGDS->bLoadingOtherBands = FALSE;\n    }\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                            IWriteBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::IWriteBlock( int nBlockXOff, int nBlockYOff,\n                                     void * pImage )\n\n{\n    int\t\tnBlockId;\n    CPLErr      eErr = CE_None;\n\n    if (!poGDS->SetDirectory())\n        return CE_Failure;\n\n    CPLAssert( poGDS != NULL\n               && nBlockXOff >= 0\n               && nBlockYOff >= 0\n               && pImage != NULL );\n\n/* -------------------------------------------------------------------- */\n/*      Handle case of \"separate\" images                                */\n/* -------------------------------------------------------------------- */\n    if( poGDS->nPlanarConfig == PLANARCONFIG_SEPARATE\n        || poGDS->nBands == 1 )\n    {\n        nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow\n            + (nBand-1) * poGDS->nBlocksPerBand;\n\n        eErr = poGDS->WriteEncodedTileOrStrip(nBlockId, pImage, TRUE);\n\n        return eErr;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Handle case of pixel interleaved (PLANARCONFIG_CONTIG) images.  */\n/* -------------------------------------------------------------------- */\n\n    nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n        \n    eErr = poGDS->LoadBlockBuf( nBlockId );\n    if( eErr != CE_None )\n        return eErr;\n\n/* -------------------------------------------------------------------- */\n/*      On write of pixel interleaved data, we might as well flush      */\n/*      out any other bands that are dirty in our cache.  This is       */\n/*      especially helpful when writing compressed blocks.              */\n/* -------------------------------------------------------------------- */\n    int iBand; \n    int nWordBytes = poGDS->nBitsPerSample / 8;\n\n    for( iBand = 0; iBand < poGDS->nBands; iBand++ )\n    {\n        const GByte *pabyThisImage = NULL;\n        GDALRasterBlock *poBlock = NULL;\n\n        if( iBand+1 == nBand )\n            pabyThisImage = (GByte *) pImage;\n        else\n        {\n            poBlock = ((GTiffRasterBand *)poGDS->GetRasterBand( iBand+1 ))\n                ->TryGetLockedBlockRef( nBlockXOff, nBlockYOff );\n\n            if( poBlock == NULL )\n                continue;\n\n            if( !poBlock->GetDirty() )\n            {\n                poBlock->DropLock();\n                continue;\n            }\n\n            pabyThisImage = (GByte *) poBlock->GetDataRef();\n        }\n\n        int i, nBlockPixels = nBlockXSize * nBlockYSize;\n        GByte *pabyOut = poGDS->pabyBlockBuf + iBand*nWordBytes;\n\n        for( i = 0; i < nBlockPixels; i++ )\n        {\n            memcpy( pabyOut, pabyThisImage, nWordBytes );\n            \n            pabyOut += nWordBytes * poGDS->nBands;\n            pabyThisImage += nWordBytes;\n        }\n        \n        if( poBlock != NULL )\n        {\n            poBlock->MarkClean();\n            poBlock->DropLock();\n        }\n    }\n\n    poGDS->bLoadedBlockDirty = TRUE;\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                             GetOffset()                              */\n/************************************************************************/\n\ndouble GTiffRasterBand::GetOffset( int *pbSuccess )\n\n{\n    if( pbSuccess )\n        *pbSuccess = bHaveOffsetScale;\n    return dfOffset;\n}\n\n/************************************************************************/\n/*                             SetOffset()                              */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::SetOffset( double dfNewValue )\n\n{\n    if( !bHaveOffsetScale || dfNewValue != dfOffset )\n        poGDS->bMetadataChanged = TRUE;\n\n    bHaveOffsetScale = TRUE;\n    dfOffset = dfNewValue;\n    return CE_None;\n}\n\n/************************************************************************/\n/*                              GetScale()                              */\n/************************************************************************/\n\ndouble GTiffRasterBand::GetScale( int *pbSuccess )\n\n{\n    if( pbSuccess )\n        *pbSuccess = bHaveOffsetScale;\n    return dfScale;\n}\n\n/************************************************************************/\n/*                              SetScale()                              */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::SetScale( double dfNewValue )\n\n{\n    if( !bHaveOffsetScale || dfNewValue != dfScale )\n        poGDS->bMetadataChanged = TRUE;\n\n    bHaveOffsetScale = TRUE;\n    dfScale = dfNewValue;\n    return CE_None;\n}\n\n/************************************************************************/\n/*                            GetUnitType()                             */\n/************************************************************************/\n\nconst char* GTiffRasterBand::GetUnitType()\n\n{\n    return osUnitType.c_str();\n}\n\n/************************************************************************/\n/*                           SetUnitType()                              */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::SetUnitType( const char* pszNewValue )\n\n{\n    CPLString osNewValue(pszNewValue ? pszNewValue : \"\");\n    if( osNewValue.compare(osUnitType) != 0 )\n        poGDS->bMetadataChanged = TRUE;\n\n    osUnitType = osNewValue;\n    return CE_None;\n}\n\n/************************************************************************/\n/*                            GetMetadata()                             */\n/************************************************************************/\n\nchar **GTiffRasterBand::GetMetadata( const char * pszDomain )\n\n{\n    return oGTiffMDMD.GetMetadata( pszDomain );\n}\n\n/************************************************************************/\n/*                            SetMetadata()                             */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::SetMetadata( char ** papszMD, const char *pszDomain )\n\n{\n    if( pszDomain == NULL || !EQUAL(pszDomain,\"_temporary_\") )\n    {\n        if( papszMD != NULL )\n            poGDS->bMetadataChanged = TRUE;\n    }\n\n    return oGTiffMDMD.SetMetadata( papszMD, pszDomain );\n}\n\n/************************************************************************/\n/*                          GetMetadataItem()                           */\n/************************************************************************/\n\nconst char *GTiffRasterBand::GetMetadataItem( const char * pszName, \n                                              const char * pszDomain )\n\n{\n    return oGTiffMDMD.GetMetadataItem( pszName, pszDomain );\n}\n\n/************************************************************************/\n/*                          SetMetadataItem()                           */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::SetMetadataItem( const char *pszName, \n                                         const char *pszValue,\n                                         const char *pszDomain )\n\n{\n    if( pszDomain == NULL || !EQUAL(pszDomain,\"_temporary_\") )\n        poGDS->bMetadataChanged = TRUE;\n\n    return oGTiffMDMD.SetMetadataItem( pszName, pszValue, pszDomain );\n}\n\n/************************************************************************/\n/*                       GetColorInterpretation()                       */\n/************************************************************************/\n\nGDALColorInterp GTiffRasterBand::GetColorInterpretation()\n\n{\n    return eBandInterp;\n}\n\n/************************************************************************/\n/*                       SetColorInterpretation()                       */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::SetColorInterpretation( GDALColorInterp eInterp )\n\n{\n    if( eInterp == eBandInterp )\n        return CE_None;\n    \n    if( poGDS->bCrystalized )\n        return GDALPamRasterBand::SetColorInterpretation( eInterp );\n\n    /* greyscale + alpha */\n    else if( eInterp == GCI_AlphaBand \n        && nBand == 2 \n        && poGDS->nSamplesPerPixel == 2 \n        && poGDS->nPhotometric == PHOTOMETRIC_MINISBLACK )\n    {\n        uint16 v[1] = { EXTRASAMPLE_ASSOCALPHA };\n\n        TIFFSetField(poGDS->hTIFF, TIFFTAG_EXTRASAMPLES, 1, v);\n        eBandInterp = eInterp;\n        return CE_None;\n    }\n\n    /* RGB + alpha */\n    else if( eInterp == GCI_AlphaBand \n             && nBand == 4 \n             && poGDS->nSamplesPerPixel == 4\n             && poGDS->nPhotometric == PHOTOMETRIC_RGB )\n    {\n        uint16 v[1] = { EXTRASAMPLE_ASSOCALPHA };\n\n        TIFFSetField(poGDS->hTIFF, TIFFTAG_EXTRASAMPLES, 1, v);\n        eBandInterp = eInterp;\n        return CE_None;\n    }\n    \n    else\n        return GDALPamRasterBand::SetColorInterpretation( eInterp );\n}\n\n/************************************************************************/\n/*                           GetColorTable()                            */\n/************************************************************************/\n\nGDALColorTable *GTiffRasterBand::GetColorTable()\n\n{\n    if( nBand == 1 )\n        return poGDS->poColorTable;\n    else\n        return NULL;\n}\n\n/************************************************************************/\n/*                           SetColorTable()                            */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::SetColorTable( GDALColorTable * poCT )\n\n{\n/* -------------------------------------------------------------------- */\n/*      Check if this is even a candidate for applying a PCT.           */\n/* -------------------------------------------------------------------- */\n    if( poGDS->nSamplesPerPixel != 1 )\n    {\n        CPLError( CE_Failure, CPLE_NotSupported, \n                  \"SetColorTable() not supported for multi-sample TIFF files.\" );\n        return CE_Failure;\n    }\n        \n    if( eDataType != GDT_Byte && eDataType != GDT_UInt16 )\n    {\n        CPLError( CE_Failure, CPLE_NotSupported, \n                  \"SetColorTable() only supported for Byte or UInt16 bands in TIFF format.\" );\n        return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      We are careful about calling SetDirectory() to avoid            */\n/*      prematurely crystalizing the directory.  (#2820)                */\n/* -------------------------------------------------------------------- */\n    if( poGDS->bCrystalized )\n    {\n        if (!poGDS->SetDirectory())\n            return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Is this really a request to clear the color table?              */\n/* -------------------------------------------------------------------- */\n    if( poCT == NULL || poCT->GetColorEntryCount() == 0 )\n    {\n        TIFFSetField( poGDS->hTIFF, TIFFTAG_PHOTOMETRIC, \n                      PHOTOMETRIC_MINISBLACK );\n\n#ifdef HAVE_UNSETFIELD\n        TIFFUnsetField( poGDS->hTIFF, TIFFTAG_COLORMAP );\n#else\n        CPLDebug( \"GTiff\", \n                  \"TIFFUnsetField() not supported, colormap may not be cleared.\" );\n#endif\n        \n        if( poGDS->poColorTable )\n        {\n            delete poGDS->poColorTable;\n            poGDS->poColorTable = NULL;\n        }\n\n        return CE_None;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Write out the colortable, and update the configuration.         */\n/* -------------------------------------------------------------------- */\n    int nColors;\n\n    if( eDataType == GDT_Byte )\n        nColors = 256;\n    else\n        nColors = 65536;\n\n    unsigned short *panTRed, *panTGreen, *panTBlue;\n\n    panTRed = (unsigned short *) CPLMalloc(sizeof(unsigned short)*nColors);\n    panTGreen = (unsigned short *) CPLMalloc(sizeof(unsigned short)*nColors);\n    panTBlue = (unsigned short *) CPLMalloc(sizeof(unsigned short)*nColors);\n\n    for( int iColor = 0; iColor < nColors; iColor++ )\n    {\n        if( iColor < poCT->GetColorEntryCount() )\n        {\n            GDALColorEntry  sRGB;\n            \n            poCT->GetColorEntryAsRGB( iColor, &sRGB );\n            \n            panTRed[iColor] = (unsigned short) (257 * sRGB.c1);\n            panTGreen[iColor] = (unsigned short) (257 * sRGB.c2);\n            panTBlue[iColor] = (unsigned short) (257 * sRGB.c3);\n        }\n        else\n        {\n            panTRed[iColor] = panTGreen[iColor] = panTBlue[iColor] = 0;\n        }\n    }\n\n    TIFFSetField( poGDS->hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_PALETTE );\n    TIFFSetField( poGDS->hTIFF, TIFFTAG_COLORMAP,\n                  panTRed, panTGreen, panTBlue );\n\n    CPLFree( panTRed );\n    CPLFree( panTGreen );\n    CPLFree( panTBlue );\n\n    if( poGDS->poColorTable )\n        delete poGDS->poColorTable;\n\n    /* libtiff 3.X needs setting this in all cases (creation or update) */\n    /* whereas libtiff 4.X would just need it if there */\n    /* was no color table before */\n#if 0\n    else\n#endif\n        poGDS->bNeedsRewrite = TRUE;\n\n    poGDS->poColorTable = poCT->Clone();\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                           GetNoDataValue()                           */\n/************************************************************************/\n\ndouble GTiffRasterBand::GetNoDataValue( int * pbSuccess )\n\n{\n    if( bNoDataSet )\n    {\n        if( pbSuccess )\n            *pbSuccess = TRUE;\n\n        return dfNoDataValue;\n    }\n   \n    if( poGDS->bNoDataSet )\n    {\n        if( pbSuccess )\n            *pbSuccess = TRUE;\n\n        return poGDS->dfNoDataValue;\n    }\n\n    return GDALPamRasterBand::GetNoDataValue( pbSuccess );\n}\n\n/************************************************************************/\n/*                           SetNoDataValue()                           */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::SetNoDataValue( double dfNoData )\n\n{\n    if( poGDS->bNoDataSet && poGDS->dfNoDataValue == dfNoData )\n        return CE_None;\n\n    if (!poGDS->SetDirectory())  // needed to call TIFFSetField().\n        return CE_Failure;\n\n    poGDS->bNoDataSet = TRUE;\n    poGDS->dfNoDataValue = dfNoData;\n\n    poGDS->WriteNoDataValue( poGDS->hTIFF, dfNoData );\n    poGDS->bNeedsRewrite = TRUE;\n\n    bNoDataSet = TRUE;\n    dfNoDataValue = dfNoData;\n    return CE_None;\n}\n\n/************************************************************************/\n/*                             NullBlock()                              */\n/*                                                                      */\n/*      Set the block data to the null value if it is set, or zero      */\n/*      if there is no null data value.                                 */\n/************************************************************************/\n\nvoid GTiffRasterBand::NullBlock( void *pData )\n\n{\n    int nWords = nBlockXSize * nBlockYSize;\n    int nChunkSize = MAX(1,GDALGetDataTypeSize(eDataType)/8);\n\n    int bNoDataSet;\n    double dfNoData = GetNoDataValue( &bNoDataSet );\n    if( !bNoDataSet )\n    {\n        memset( pData, 0, nWords*nChunkSize );\n    }\n    else\n    {\n        /* Will convert nodata value to the right type and copy efficiently */\n        GDALCopyWords( &dfNoData, GDT_Float64, 0,\n                       pData, eDataType, nChunkSize, nWords);\n    }\n}\n\n/************************************************************************/\n/*                          GetOverviewCount()                          */\n/************************************************************************/\n\nint GTiffRasterBand::GetOverviewCount()\n\n{\n    if( poGDS->nOverviewCount > 0 )\n        return poGDS->nOverviewCount;\n    else\n        return GDALRasterBand::GetOverviewCount();\n}\n\n/************************************************************************/\n/*                            GetOverview()                             */\n/************************************************************************/\n\nGDALRasterBand *GTiffRasterBand::GetOverview( int i )\n\n{\n    if( poGDS->nOverviewCount > 0 )\n    {\n        if( i < 0 || i >= poGDS->nOverviewCount )\n            return NULL;\n        else\n            return poGDS->papoOverviewDS[i]->GetRasterBand(nBand);\n    }\n    else\n        return GDALRasterBand::GetOverview( i );\n}\n\n/************************************************************************/\n/*                           GetMaskFlags()                             */\n/************************************************************************/\n\nint GTiffRasterBand::GetMaskFlags()\n{\n    if( poGDS->poMaskDS != NULL )\n    {\n        int iBand;\n        int nMaskFlag = 0;\n        if( poGDS->poMaskDS->GetRasterCount() == 1)\n        {\n            iBand = 1;\n            nMaskFlag = GMF_PER_DATASET;\n        }\n        else\n        {\n            iBand = nBand;\n        }\n        if( poGDS->poMaskDS->GetRasterBand(iBand)->GetMetadataItem( \"NBITS\", \"IMAGE_STRUCTURE\" ) != NULL \n            && atoi(poGDS->poMaskDS->GetRasterBand(iBand)->GetMetadataItem( \"NBITS\", \"IMAGE_STRUCTURE\" )) == 1)\n        {\n            return nMaskFlag;\n        }\n        else\n        {\n            return nMaskFlag | GMF_ALPHA;\n        }\n    }\n    else\n        return GDALPamRasterBand::GetMaskFlags();\n}\n\n/************************************************************************/\n/*                            GetMaskBand()                             */\n/************************************************************************/\n\nGDALRasterBand *GTiffRasterBand::GetMaskBand()\n{\n    if( poGDS->poMaskDS != NULL )\n    {\n        if( poGDS->poMaskDS->GetRasterCount() == 1)\n            return poGDS->poMaskDS->GetRasterBand(1);\n        else\n            return poGDS->poMaskDS->GetRasterBand(nBand);\n    }\n    else\n        return GDALPamRasterBand::GetMaskBand();\n}\n\n/************************************************************************/\n/* ==================================================================== */\n/*                             GTiffSplitBand                            */\n/* ==================================================================== */\n/************************************************************************/\n\nclass GTiffSplitBand : public GTiffRasterBand\n{\n    friend class GTiffDataset;\n\n  public:\n\n                   GTiffSplitBand( GTiffDataset *, int );\n    virtual       ~GTiffSplitBand();\n\n    virtual CPLErr IReadBlock( int, int, void * );\n    virtual CPLErr IWriteBlock( int, int, void * );\n};\n\n/************************************************************************/\n/*                           GTiffSplitBand()                           */\n/************************************************************************/\n\nGTiffSplitBand::GTiffSplitBand( GTiffDataset *poDS, int nBand )\n        : GTiffRasterBand( poDS, nBand )\n\n{\n    nBlockXSize = poDS->GetRasterXSize();\n    nBlockYSize = 1;\n}\n\n/************************************************************************/\n/*                          ~GTiffSplitBand()                          */\n/************************************************************************/\n\nGTiffSplitBand::~GTiffSplitBand()\n{\n}\n\n/************************************************************************/\n/*                             IReadBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffSplitBand::IReadBlock( int nBlockXOff, int nBlockYOff,\n                                   void * pImage )\n\n{\n    (void) nBlockXOff;\n    \n    /* Optimization when reading the same line in a contig multi-band TIFF */\n    if( poGDS->nPlanarConfig == PLANARCONFIG_CONTIG && poGDS->nBands > 1 &&\n        poGDS->nLastLineRead == nBlockYOff )\n    {\n        goto extract_band_data;\n    }\n\n    if (!poGDS->SetDirectory())\n        return CE_Failure;\n        \n    if (poGDS->nPlanarConfig == PLANARCONFIG_CONTIG &&\n        poGDS->nBands > 1)\n    {\n        if (poGDS->pabyBlockBuf == NULL)\n            poGDS->pabyBlockBuf = (GByte *) CPLMalloc(TIFFScanlineSize(poGDS->hTIFF));\n    }\n    else\n    {\n        CPLAssert(TIFFScanlineSize(poGDS->hTIFF) == nBlockXSize);\n    }\n    \n/* -------------------------------------------------------------------- */\n/*      Read through to target scanline.                                */\n/* -------------------------------------------------------------------- */\n    if( poGDS->nLastLineRead >= nBlockYOff )\n        poGDS->nLastLineRead = -1;\n\n    if( poGDS->nPlanarConfig == PLANARCONFIG_SEPARATE && poGDS->nBands > 1 )\n    {\n        /* If we change of band, we must start reading the */\n        /* new strip from its beginning */\n        if ( poGDS->nLastBandRead != nBand )\n            poGDS->nLastLineRead = -1;\n        poGDS->nLastBandRead = nBand;\n    }\n    \n    while( poGDS->nLastLineRead < nBlockYOff )\n    {\n        if( TIFFReadScanline( poGDS->hTIFF,\n                              poGDS->pabyBlockBuf ? poGDS->pabyBlockBuf : pImage,\n                              ++poGDS->nLastLineRead,\n                              (poGDS->nPlanarConfig == PLANARCONFIG_SEPARATE) ? nBand-1 : 0 ) == -1 )\n        {\n            CPLError( CE_Failure, CPLE_AppDefined,\n                      \"TIFFReadScanline() failed.\" );\n            return CE_Failure;\n        }\n    }\n    \nextract_band_data:\n/* -------------------------------------------------------------------- */\n/*      Extract band data from contig buffer.                           */\n/* -------------------------------------------------------------------- */\n    if ( poGDS->pabyBlockBuf != NULL )\n    {\n        int\t  iPixel, iSrcOffset= nBand - 1, iDstOffset=0;\n\n        for( iPixel = 0; iPixel < nBlockXSize; iPixel++, iSrcOffset+=poGDS->nBands, iDstOffset++ )\n        {\n            ((GByte *) pImage)[iDstOffset] = poGDS->pabyBlockBuf[iSrcOffset];\n        }\n    }\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                            IWriteBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffSplitBand::IWriteBlock( int nBlockXOff, int nBlockYOff,\n                                    void * pImage )\n\n{\n    (void) nBlockXOff;\n    (void) nBlockYOff;\n    (void) pImage;\n\n    CPLError( CE_Failure, CPLE_AppDefined, \n              \"Split bands are read-only.\" );\n    return CE_Failure;\n}\n\n/************************************************************************/\n/* ==================================================================== */\n/*                             GTiffRGBABand                            */\n/* ==================================================================== */\n/************************************************************************/\n\nclass GTiffRGBABand : public GTiffRasterBand\n{\n    friend class GTiffDataset;\n\n  public:\n\n                   GTiffRGBABand( GTiffDataset *, int );\n\n    virtual CPLErr IReadBlock( int, int, void * );\n    virtual CPLErr IWriteBlock( int, int, void * );\n\n    virtual GDALColorInterp GetColorInterpretation();\n};\n\n\n/************************************************************************/\n/*                           GTiffRGBABand()                            */\n/************************************************************************/\n\nGTiffRGBABand::GTiffRGBABand( GTiffDataset *poDS, int nBand )\n        : GTiffRasterBand( poDS, nBand )\n\n{\n    eDataType = GDT_Byte;\n}\n\n/************************************************************************/\n/*                            IWriteBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffRGBABand::IWriteBlock( int, int, void * )\n\n{\n    CPLError( CE_Failure, CPLE_AppDefined, \n              \"RGBA interpreted raster bands are read-only.\" );\n    return CE_Failure;\n}\n\n/************************************************************************/\n/*                             IReadBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffRGBABand::IReadBlock( int nBlockXOff, int nBlockYOff,\n                                    void * pImage )\n\n{\n    int\t\t\tnBlockBufSize, nBlockId;\n    CPLErr\t\teErr = CE_None;\n\n    if (!poGDS->SetDirectory())\n        return CE_Failure;\n\n    nBlockBufSize = 4 * nBlockXSize * nBlockYSize;\n    nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n\n/* -------------------------------------------------------------------- */\n/*      Allocate a temporary buffer for this strip.                     */\n/* -------------------------------------------------------------------- */\n    if( poGDS->pabyBlockBuf == NULL )\n    {\n        poGDS->pabyBlockBuf = (GByte *) VSIMalloc3( 4, nBlockXSize, nBlockYSize );\n        if( poGDS->pabyBlockBuf == NULL )\n            return( CE_Failure );\n    }\n    \n/* -------------------------------------------------------------------- */\n/*      Read the strip                                                  */\n/* -------------------------------------------------------------------- */\n    if( poGDS->nLoadedBlock != nBlockId )\n    {\n        if( TIFFIsTiled( poGDS->hTIFF ) )\n        {\n            if( TIFFReadRGBATile(poGDS->hTIFF, \n                                 nBlockXOff * nBlockXSize, \n                                 nBlockYOff * nBlockYSize,\n                                 (uint32 *) poGDS->pabyBlockBuf) == -1 )\n            {\n                /* Once TIFFError() is properly hooked, this can go away */\n                CPLError( CE_Failure, CPLE_AppDefined,\n                          \"TIFFReadRGBATile() failed.\" );\n                \n                memset( poGDS->pabyBlockBuf, 0, nBlockBufSize );\n                \n                eErr = CE_Failure;\n            }\n        }\n        else\n        {\n            if( TIFFReadRGBAStrip(poGDS->hTIFF, \n                                  nBlockId * nBlockYSize,\n                                  (uint32 *) poGDS->pabyBlockBuf) == -1 )\n            {\n                /* Once TIFFError() is properly hooked, this can go away */\n                CPLError( CE_Failure, CPLE_AppDefined,\n                          \"TIFFReadRGBAStrip() failed.\" );\n                \n                memset( poGDS->pabyBlockBuf, 0, nBlockBufSize );\n                \n                eErr = CE_Failure;\n            }\n        }\n    }\n\n    poGDS->nLoadedBlock = nBlockId;\n                              \n/* -------------------------------------------------------------------- */\n/*      Handle simple case of eight bit data, and pixel interleaving.   */\n/* -------------------------------------------------------------------- */\n    int   iDestLine, nBO;\n    int   nThisBlockYSize;\n\n    if( (nBlockYOff+1) * nBlockYSize > GetYSize()\n        && !TIFFIsTiled( poGDS->hTIFF ) )\n        nThisBlockYSize = GetYSize() - nBlockYOff * nBlockYSize;\n    else\n        nThisBlockYSize = nBlockYSize;\n\n#ifdef CPL_LSB\n    nBO = nBand - 1;\n#else\n    nBO = 4 - nBand;\n#endif\n\n    for( iDestLine = 0; iDestLine < nThisBlockYSize; iDestLine++ )\n    {\n        int\tnSrcOffset;\n\n        nSrcOffset = (nThisBlockYSize - iDestLine - 1) * nBlockXSize * 4;\n\n        GDALCopyWords( poGDS->pabyBlockBuf + nBO + nSrcOffset, GDT_Byte, 4,\n                       ((GByte *) pImage)+iDestLine*nBlockXSize, GDT_Byte, 1, \n                       nBlockXSize );\n    }\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                       GetColorInterpretation()                       */\n/************************************************************************/\n\nGDALColorInterp GTiffRGBABand::GetColorInterpretation()\n\n{\n    if( nBand == 1 )\n        return GCI_RedBand;\n    else if( nBand == 2 )\n        return GCI_GreenBand;\n    else if( nBand == 3 )\n        return GCI_BlueBand;\n    else\n        return GCI_AlphaBand;\n}\n\n/************************************************************************/\n/* ==================================================================== */\n/*                             GTiffOddBitsBand                         */\n/* ==================================================================== */\n/************************************************************************/\n\nclass GTiffOddBitsBand : public GTiffRasterBand\n{\n    friend class GTiffDataset;\n  public:\n\n                   GTiffOddBitsBand( GTiffDataset *, int );\n    virtual       ~GTiffOddBitsBand();\n\n    virtual CPLErr IReadBlock( int, int, void * );\n    virtual CPLErr IWriteBlock( int, int, void * );\n};\n\n\n/************************************************************************/\n/*                           GTiffOddBitsBand()                         */\n/************************************************************************/\n\nGTiffOddBitsBand::GTiffOddBitsBand( GTiffDataset *poGDS, int nBand )\n        : GTiffRasterBand( poGDS, nBand )\n\n{\n    eDataType = GDT_Byte;\n    if( poGDS->nSampleFormat == SAMPLEFORMAT_IEEEFP )\n        eDataType = GDT_Float32;\n    else if( poGDS->nBitsPerSample > 8 && poGDS->nBitsPerSample < 16 )\n        eDataType = GDT_UInt16;\n    else if( poGDS->nBitsPerSample > 16 )\n        eDataType = GDT_UInt32;\n}\n\n/************************************************************************/\n/*                          ~GTiffOddBitsBand()                          */\n/************************************************************************/\n\nGTiffOddBitsBand::~GTiffOddBitsBand()\n\n{\n}\n\n/************************************************************************/\n/*                            IWriteBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffOddBitsBand::IWriteBlock( int nBlockXOff, int nBlockYOff, \n                                      void *pImage )\n\n{\n    int\t\tnBlockId;\n    CPLErr      eErr = CE_None;\n\n    if (!poGDS->SetDirectory())\n        return CE_Failure;\n\n    CPLAssert( poGDS != NULL\n               && nBlockXOff >= 0\n               && nBlockYOff >= 0\n               && pImage != NULL );\n\n    if( eDataType == GDT_Float32 && poGDS->nBitsPerSample < 32 )\n    {\n        CPLError(CE_Failure, CPLE_NotSupported,\n                 \"Writing float data with nBitsPerSample < 32 is unsupported\");\n        return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Load the block buffer.                                          */\n/* -------------------------------------------------------------------- */\n    nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n\n    if( poGDS->nPlanarConfig == PLANARCONFIG_SEPARATE )\n        nBlockId += (nBand-1) * poGDS->nBlocksPerBand;\n\n    /* Only read content from disk in the CONTIG case */\n    eErr = poGDS->LoadBlockBuf( nBlockId, \n                                poGDS->nPlanarConfig == PLANARCONFIG_CONTIG && poGDS->nBands > 1 );\n    if( eErr != CE_None )\n        return eErr;\n\n/* -------------------------------------------------------------------- */\n/*      Handle case of \"separate\" images or single band images where    */\n/*      no interleaving with other data is required.                    */\n/* -------------------------------------------------------------------- */\n    if( poGDS->nPlanarConfig == PLANARCONFIG_SEPARATE\n        || poGDS->nBands == 1 )\n    {\n        int\tiBit, iPixel, iBitOffset = 0;\n        int     iX, iY, nBitsPerLine;\n\n        // bits per line rounds up to next byte boundary.\n        nBitsPerLine = nBlockXSize * poGDS->nBitsPerSample;\n        if( (nBitsPerLine & 7) != 0 )\n            nBitsPerLine = (nBitsPerLine + 7) & (~7);\n\n        /* Initialize to zero as we set the buffer with binary or operations */\n        if (poGDS->nBitsPerSample != 24)\n            memset(poGDS->pabyBlockBuf, 0, (nBitsPerLine / 8) * nBlockYSize);\n\n        iPixel = 0;\n        for( iY = 0; iY < nBlockYSize; iY++ )\n        {\n            iBitOffset = iY * nBitsPerLine;\n\n            /* Small optimization in 1 bit case */\n            if (poGDS->nBitsPerSample == 1)\n            {\n                for( iX = 0; iX < nBlockXSize; iX++ )\n                {\n                    if (((GByte *) pImage)[iPixel++])\n                        poGDS->pabyBlockBuf[iBitOffset>>3] |= (0x80 >>(iBitOffset & 7));\n                    iBitOffset++;\n                }\n\n                continue;\n            }\n\n            for( iX = 0; iX < nBlockXSize; iX++ )\n            {\n                int  nInWord = 0;\n                if( eDataType == GDT_Byte )\n                    nInWord = ((GByte *) pImage)[iPixel++];\n                else if( eDataType == GDT_UInt16 )\n                    nInWord = ((GUInt16 *) pImage)[iPixel++];\n                else if( eDataType == GDT_UInt32 )\n                    nInWord = ((GUInt32 *) pImage)[iPixel++];\n                else\n                    CPLAssert(0);\n\n\n                if (poGDS->nBitsPerSample == 24)\n                {\n/* -------------------------------------------------------------------- */\n/*      Special case for 24bit data which is pre-byteswapped since      */\n/*      the size falls on a byte boundary ... ugg (#2361).              */\n/* -------------------------------------------------------------------- */\n#ifdef CPL_MSB\n                    poGDS->pabyBlockBuf[(iBitOffset>>3) + 0] = \n                        (GByte) nInWord;\n                    poGDS->pabyBlockBuf[(iBitOffset>>3) + 1] = \n                        (GByte) (nInWord >> 8);\n                    poGDS->pabyBlockBuf[(iBitOffset>>3) + 2] = \n                        (GByte) (nInWord >> 16);\n#else\n                    poGDS->pabyBlockBuf[(iBitOffset>>3) + 0] = \n                        (GByte) (nInWord >> 16);\n                    poGDS->pabyBlockBuf[(iBitOffset>>3) + 1] = \n                        (GByte) (nInWord >> 8);\n                    poGDS->pabyBlockBuf[(iBitOffset>>3) + 2] = \n                        (GByte) nInWord;\n#endif\n                    iBitOffset += 24;\n                }\n                else\n                {\n                    for( iBit = 0; iBit < poGDS->nBitsPerSample; iBit++ )\n                    {\n                        if (nInWord & (1 << (poGDS->nBitsPerSample - 1 - iBit)))\n                            poGDS->pabyBlockBuf[iBitOffset>>3] |= (0x80 >>(iBitOffset & 7));\n                        iBitOffset++;\n                    }\n                } \n            }\n        }\n\n        poGDS->bLoadedBlockDirty = TRUE;\n\n        return eErr;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Handle case of pixel interleaved (PLANARCONFIG_CONTIG) images.  */\n/* -------------------------------------------------------------------- */\n\n/* -------------------------------------------------------------------- */\n/*      On write of pixel interleaved data, we might as well flush      */\n/*      out any other bands that are dirty in our cache.  This is       */\n/*      especially helpful when writing compressed blocks.              */\n/* -------------------------------------------------------------------- */\n    int iBand; \n\n    for( iBand = 0; iBand < poGDS->nBands; iBand++ )\n    {\n        const GByte *pabyThisImage = NULL;\n        GDALRasterBlock *poBlock = NULL;\n        int\tiBit, iPixel, iBitOffset = 0;\n        int     iPixelBitSkip, iBandBitOffset, iX, iY, nBitsPerLine;\n\n        if( iBand+1 == nBand )\n            pabyThisImage = (GByte *) pImage;\n        else\n        {\n            poBlock = ((GTiffOddBitsBand *)poGDS->GetRasterBand( iBand+1 ))\n                ->TryGetLockedBlockRef( nBlockXOff, nBlockYOff );\n\n            if( poBlock == NULL )\n                continue;\n\n            if( !poBlock->GetDirty() )\n            {\n                poBlock->DropLock();\n                continue;\n            }\n\n            pabyThisImage = (GByte *) poBlock->GetDataRef();\n        }\n\n        iPixelBitSkip = poGDS->nBitsPerSample * poGDS->nBands;\n        iBandBitOffset = iBand * poGDS->nBitsPerSample;\n\n        // bits per line rounds up to next byte boundary.\n        nBitsPerLine = nBlockXSize * iPixelBitSkip;\n        if( (nBitsPerLine & 7) != 0 )\n            nBitsPerLine = (nBitsPerLine + 7) & (~7);\n\n        iPixel = 0;\n        for( iY = 0; iY < nBlockYSize; iY++ )\n        {\n            iBitOffset = iBandBitOffset + iY * nBitsPerLine;\n\n            for( iX = 0; iX < nBlockXSize; iX++ )\n            {\n                int  nInWord = 0;\n                if( eDataType == GDT_Byte )\n                    nInWord = ((GByte *) pabyThisImage)[iPixel++];\n                else if( eDataType == GDT_UInt16 )\n                    nInWord = ((GUInt16 *) pabyThisImage)[iPixel++];\n                else if( eDataType == GDT_UInt32 )\n                    nInWord = ((GUInt32 *) pabyThisImage)[iPixel++];\n                else\n                    CPLAssert(0);\n\n\n                if (poGDS->nBitsPerSample == 24)\n                {\n/* -------------------------------------------------------------------- */\n/*      Special case for 24bit data which is pre-byteswapped since      */\n/*      the size falls on a byte boundary ... ugg (#2361).              */\n/* -------------------------------------------------------------------- */\n#ifdef CPL_MSB\n                    poGDS->pabyBlockBuf[(iBitOffset>>3) + 0] = \n                        (GByte) nInWord;\n                    poGDS->pabyBlockBuf[(iBitOffset>>3) + 1] = \n                        (GByte) (nInWord >> 8);\n                    poGDS->pabyBlockBuf[(iBitOffset>>3) + 2] = \n                        (GByte) (nInWord >> 16);\n#else\n                    poGDS->pabyBlockBuf[(iBitOffset>>3) + 0] = \n                        (GByte) (nInWord >> 16);\n                    poGDS->pabyBlockBuf[(iBitOffset>>3) + 1] = \n                        (GByte) (nInWord >> 8);\n                    poGDS->pabyBlockBuf[(iBitOffset>>3) + 2] = \n                        (GByte) nInWord;\n#endif\n                    iBitOffset += 24;\n                }\n                else\n                {\n                    for( iBit = 0; iBit < poGDS->nBitsPerSample; iBit++ )\n                    {\n                        if (nInWord & (1 << (poGDS->nBitsPerSample - 1 - iBit)))\n                            poGDS->pabyBlockBuf[iBitOffset>>3] |= (0x80 >>(iBitOffset & 7));\n                        else\n                        {\n                            /* We must explictly unset the bit as we may update an existing block */\n                            poGDS->pabyBlockBuf[iBitOffset>>3] &= ~(0x80 >>(iBitOffset & 7));\n                        }\n\n                        iBitOffset++;\n                    }\n                } \n\n                iBitOffset= iBitOffset + iPixelBitSkip - poGDS->nBitsPerSample;\n            }\n        }\n\n        if( poBlock != NULL )\n        {\n            poBlock->MarkClean();\n            poBlock->DropLock();\n        }\n    }\n\n    poGDS->bLoadedBlockDirty = TRUE;\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                             IReadBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffOddBitsBand::IReadBlock( int nBlockXOff, int nBlockYOff,\n                                    void * pImage )\n\n{\n    int\t\t\tnBlockId;\n    CPLErr\t\teErr = CE_None;\n\n    if (!poGDS->SetDirectory())\n        return CE_Failure;\n\n    nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n\n    if( poGDS->nPlanarConfig == PLANARCONFIG_SEPARATE )\n        nBlockId += (nBand-1) * poGDS->nBlocksPerBand;\n\n/* -------------------------------------------------------------------- */\n/*\tHandle the case of a strip in a writable file that doesn't\t*/\n/*\texist yet, but that we want to read.  Just set to zeros and\t*/\n/*\treturn.\t\t\t\t\t\t\t\t*/\n/* -------------------------------------------------------------------- */\n    if( !poGDS->IsBlockAvailable(nBlockId) )\n    {\n        NullBlock( pImage );\n        return CE_None;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Load the block buffer.                                          */\n/* -------------------------------------------------------------------- */\n    eErr = poGDS->LoadBlockBuf( nBlockId );\n    if( eErr != CE_None )\n        return eErr;\n\n    if (  poGDS->nBitsPerSample == 1 && (poGDS->nBands == 1 || poGDS->nPlanarConfig == PLANARCONFIG_SEPARATE ) )\n    {\n/* -------------------------------------------------------------------- */\n/*      Translate 1bit data to eight bit.                               */\n/* -------------------------------------------------------------------- */\n        int\t  iDstOffset=0, iLine;\n        register GByte *pabyBlockBuf = poGDS->pabyBlockBuf;\n\n        for( iLine = 0; iLine < nBlockYSize; iLine++ )\n        {\n            int iSrcOffset, iPixel;\n\n            iSrcOffset = ((nBlockXSize+7) >> 3) * 8 * iLine;\n\n            for( iPixel = 0; iPixel < nBlockXSize; iPixel++, iSrcOffset++ )\n            {\n                if( pabyBlockBuf[iSrcOffset >>3] & (0x80 >> (iSrcOffset & 0x7)) )\n                    ((GByte *) pImage)[iDstOffset++] = 1;\n                else\n                    ((GByte *) pImage)[iDstOffset++] = 0;\n            }\n        }\n    }\n/* -------------------------------------------------------------------- */\n/*      Handle the case of 16- and 24-bit floating point data as per    */\n/*      TIFF Technical Note 3.                                          */\n/* -------------------------------------------------------------------- */\n    else if( eDataType == GDT_Float32 && poGDS->nBitsPerSample < 32 )\n    {\n        int\ti, nBlockPixels, nWordBytes, iSkipBytes;\n        GByte\t*pabyImage;\n\n        nWordBytes = poGDS->nBitsPerSample / 8;\n        pabyImage = poGDS->pabyBlockBuf + (nBand - 1) * nWordBytes;\n        iSkipBytes = ( poGDS->nPlanarConfig == PLANARCONFIG_SEPARATE ) ?\n            nWordBytes : poGDS->nBands * nWordBytes;\n\n        nBlockPixels = nBlockXSize * nBlockYSize;\n        if ( poGDS->nBitsPerSample == 16 )\n        {\n            for( i = 0; i < nBlockPixels; i++ )\n            {\n                ((GUInt32 *) pImage)[i] =\n                    HalfToFloat( *((GUInt16 *)pabyImage) );\n                pabyImage += iSkipBytes;\n            }\n        }\n        else if ( poGDS->nBitsPerSample == 24 )\n        {\n            for( i = 0; i < nBlockPixels; i++ )\n            {\n#ifdef CPL_MSB\n                ((GUInt32 *) pImage)[i] =\n                    TripleToFloat( ((GUInt32)*(pabyImage + 0) << 16)\n                                   | ((GUInt32)*(pabyImage + 1) << 8)\n                                   | (GUInt32)*(pabyImage + 2) );\n#else\n                ((GUInt32 *) pImage)[i] =\n                    TripleToFloat( ((GUInt32)*(pabyImage + 2) << 16)\n                                   | ((GUInt32)*(pabyImage + 1) << 8)\n                                   | (GUInt32)*pabyImage );\n#endif\n                pabyImage += iSkipBytes;\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Special case for moving 12bit data somewhat more efficiently.   */\n/* -------------------------------------------------------------------- */\n    else if( poGDS->nBitsPerSample == 12 )\n    {\n        int\tiPixel, iBitOffset = 0;\n        int     iPixelBitSkip, iBandBitOffset, iX, iY, nBitsPerLine;\n\n        if( poGDS->nPlanarConfig == PLANARCONFIG_CONTIG )\n        {\n            iPixelBitSkip = poGDS->nBands * poGDS->nBitsPerSample;\n            iBandBitOffset = (nBand-1) * poGDS->nBitsPerSample;\n        }\n        else\n        {\n            iPixelBitSkip = poGDS->nBitsPerSample;\n            iBandBitOffset = 0;\n        }\n\n        // bits per line rounds up to next byte boundary.\n        nBitsPerLine = nBlockXSize * iPixelBitSkip;\n        if( (nBitsPerLine & 7) != 0 )\n            nBitsPerLine = (nBitsPerLine + 7) & (~7);\n\n        iPixel = 0;\n        for( iY = 0; iY < nBlockYSize; iY++ )\n        {\n            iBitOffset = iBandBitOffset + iY * nBitsPerLine;\n\n            for( iX = 0; iX < nBlockXSize; iX++ )\n            {\n                int iByte = iBitOffset>>3;\n\n                if( (iBitOffset & 0x7) == 0 )\n                {\n                    /* starting on byte boundary */\n                    \n                    ((GUInt16 *) pImage)[iPixel++] = \n                        (poGDS->pabyBlockBuf[iByte] << 4)\n                        | (poGDS->pabyBlockBuf[iByte+1] >> 4);\n                }\n                else\n                {\n                    /* starting off byte boundary */\n                    \n                    ((GUInt16 *) pImage)[iPixel++] = \n                        ((poGDS->pabyBlockBuf[iByte] & 0xf) << 8)\n                        | (poGDS->pabyBlockBuf[iByte+1]);\n                }\n                iBitOffset += iPixelBitSkip;\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Special case for 24bit data which is pre-byteswapped since      */\n/*      the size falls on a byte boundary ... ugg (#2361).              */\n/* -------------------------------------------------------------------- */\n    else if( poGDS->nBitsPerSample == 24 )\n    {\n        int\tiPixel;\n        int     iPixelByteSkip, iBandByteOffset, iX, iY, nBytesPerLine;\n\n        if( poGDS->nPlanarConfig == PLANARCONFIG_CONTIG )\n        {\n            iPixelByteSkip = (poGDS->nBands * poGDS->nBitsPerSample) / 8;\n            iBandByteOffset = ((nBand-1) * poGDS->nBitsPerSample) / 8;\n        }\n        else\n        {\n            iPixelByteSkip = poGDS->nBitsPerSample / 8;\n            iBandByteOffset = 0;\n        }\n\n        nBytesPerLine = nBlockXSize * iPixelByteSkip;\n\n        iPixel = 0;\n        for( iY = 0; iY < nBlockYSize; iY++ )\n        {\n            GByte *pabyImage = \n                poGDS->pabyBlockBuf + iBandByteOffset + iY * nBytesPerLine;\n\n            for( iX = 0; iX < nBlockXSize; iX++ )\n            {\n#ifdef CPL_MSB\n                ((GUInt32 *) pImage)[iPixel++] = \n                    ((GUInt32)*(pabyImage + 2) << 16)\n                    | ((GUInt32)*(pabyImage + 1) << 8)\n                    | (GUInt32)*(pabyImage + 0);\n#else\n                ((GUInt32 *) pImage)[iPixel++] = \n                    ((GUInt32)*(pabyImage + 0) << 16)\n                    | ((GUInt32)*(pabyImage + 1) << 8)\n                    | (GUInt32)*(pabyImage + 2);\n#endif\n                pabyImage += iPixelByteSkip;\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Handle 1-32 bit integer data.                                   */\n/* -------------------------------------------------------------------- */\n    else\n    {\n        int\tiBit, iPixel, iBitOffset = 0;\n        int     iPixelBitSkip, iBandBitOffset, iX, iY, nBitsPerLine;\n\n        if( poGDS->nPlanarConfig == PLANARCONFIG_CONTIG )\n        {\n            iPixelBitSkip = poGDS->nBands * poGDS->nBitsPerSample;\n            iBandBitOffset = (nBand-1) * poGDS->nBitsPerSample;\n        }\n        else\n        {\n            iPixelBitSkip = poGDS->nBitsPerSample;\n            iBandBitOffset = 0;\n        }\n\n        // bits per line rounds up to next byte boundary.\n        nBitsPerLine = nBlockXSize * iPixelBitSkip;\n        if( (nBitsPerLine & 7) != 0 )\n            nBitsPerLine = (nBitsPerLine + 7) & (~7);\n\n        register GByte *pabyBlockBuf = poGDS->pabyBlockBuf;\n        iPixel = 0;\n\n        for( iY = 0; iY < nBlockYSize; iY++ )\n        {\n            iBitOffset = iBandBitOffset + iY * nBitsPerLine;\n\n            for( iX = 0; iX < nBlockXSize; iX++ )\n            {\n                int  nOutWord = 0;\n\n                for( iBit = 0; iBit < poGDS->nBitsPerSample; iBit++ )\n                {\n                    if( pabyBlockBuf[iBitOffset>>3] \n                        & (0x80 >>(iBitOffset & 7)) )\n                        nOutWord |= (1 << (poGDS->nBitsPerSample - 1 - iBit));\n                    iBitOffset++;\n                } \n\n                iBitOffset= iBitOffset + iPixelBitSkip - poGDS->nBitsPerSample;\n                \n                if( eDataType == GDT_Byte )\n                    ((GByte *) pImage)[iPixel++] = (GByte) nOutWord;\n                else if( eDataType == GDT_UInt16 )\n                    ((GUInt16 *) pImage)[iPixel++] = (GUInt16) nOutWord;\n                else if( eDataType == GDT_UInt32 )\n                    ((GUInt32 *) pImage)[iPixel++] = nOutWord;\n                else\n                    CPLAssert(0);\n            }\n        }\n    }\n\n    return CE_None;\n}\n\n\n/************************************************************************/\n/* ==================================================================== */\n/*                             GTiffBitmapBand                          */\n/* ==================================================================== */\n/************************************************************************/\n\nclass GTiffBitmapBand : public GTiffOddBitsBand\n{\n    friend class GTiffDataset;\n\n    GDALColorTable *poColorTable;\n\n  public:\n\n                   GTiffBitmapBand( GTiffDataset *, int );\n    virtual       ~GTiffBitmapBand();\n\n    virtual GDALColorInterp GetColorInterpretation();\n    virtual GDALColorTable *GetColorTable();\n};\n\n\n/************************************************************************/\n/*                           GTiffBitmapBand()                          */\n/************************************************************************/\n\nGTiffBitmapBand::GTiffBitmapBand( GTiffDataset *poDS, int nBand )\n        : GTiffOddBitsBand( poDS, nBand )\n\n{\n    eDataType = GDT_Byte;\n\n    if( poDS->poColorTable != NULL )\n        poColorTable = poDS->poColorTable->Clone();\n    else\n    {\n        GDALColorEntry\toWhite, oBlack;\n\n        oWhite.c1 = 255;\n        oWhite.c2 = 255;\n        oWhite.c3 = 255;\n        oWhite.c4 = 255;\n\n        oBlack.c1 = 0;\n        oBlack.c2 = 0;\n        oBlack.c3 = 0;\n        oBlack.c4 = 255;\n\n        poColorTable = new GDALColorTable();\n        \n        if( poDS->nPhotometric == PHOTOMETRIC_MINISWHITE )\n        {\n            poColorTable->SetColorEntry( 0, &oWhite );\n            poColorTable->SetColorEntry( 1, &oBlack );\n        }\n        else\n        {\n            poColorTable->SetColorEntry( 0, &oBlack );\n            poColorTable->SetColorEntry( 1, &oWhite );\n        }\n    }\n}\n\n/************************************************************************/\n/*                          ~GTiffBitmapBand()                          */\n/************************************************************************/\n\nGTiffBitmapBand::~GTiffBitmapBand()\n\n{\n    delete poColorTable;\n}\n\n/************************************************************************/\n/*                       GetColorInterpretation()                       */\n/************************************************************************/\n\nGDALColorInterp GTiffBitmapBand::GetColorInterpretation()\n\n{\n    return GCI_PaletteIndex;\n}\n\n/************************************************************************/\n/*                           GetColorTable()                            */\n/************************************************************************/\n\nGDALColorTable *GTiffBitmapBand::GetColorTable()\n\n{\n    return poColorTable;\n}\n\n/************************************************************************/\n/* ==================================================================== */\n/*                          GTiffSplitBitmapBand                        */\n/* ==================================================================== */\n/************************************************************************/\n\nclass GTiffSplitBitmapBand : public GTiffBitmapBand\n{\n    friend class GTiffDataset;\n\n  public:\n\n                   GTiffSplitBitmapBand( GTiffDataset *, int );\n    virtual       ~GTiffSplitBitmapBand();\n\n    virtual CPLErr IReadBlock( int, int, void * );\n    virtual CPLErr IWriteBlock( int, int, void * );\n};\n\n\n/************************************************************************/\n/*                       GTiffSplitBitmapBand()                         */\n/************************************************************************/\n\nGTiffSplitBitmapBand::GTiffSplitBitmapBand( GTiffDataset *poDS, int nBand )\n        : GTiffBitmapBand( poDS, nBand )\n\n{\n    nBlockXSize = poDS->GetRasterXSize();\n    nBlockYSize = 1;\n}\n\n/************************************************************************/\n/*                      ~GTiffSplitBitmapBand()                         */\n/************************************************************************/\n\nGTiffSplitBitmapBand::~GTiffSplitBitmapBand()\n\n{\n}\n\n\n/************************************************************************/\n/*                             IReadBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffSplitBitmapBand::IReadBlock( int nBlockXOff, int nBlockYOff,\n                                         void * pImage )\n\n{\n    (void) nBlockXOff;\n\n    if (!poGDS->SetDirectory())\n        return CE_Failure;\n        \n    if (poGDS->pabyBlockBuf == NULL)\n        poGDS->pabyBlockBuf = (GByte *) CPLMalloc(TIFFScanlineSize(poGDS->hTIFF));\n\n/* -------------------------------------------------------------------- */\n/*      Read through to target scanline.                                */\n/* -------------------------------------------------------------------- */\n    if( poGDS->nLastLineRead >= nBlockYOff )\n        poGDS->nLastLineRead = -1;\n\n    while( poGDS->nLastLineRead < nBlockYOff )\n    {\n        if( TIFFReadScanline( poGDS->hTIFF, poGDS->pabyBlockBuf, ++poGDS->nLastLineRead, 0 ) == -1 )\n        {\n            CPLError( CE_Failure, CPLE_AppDefined,\n                      \"TIFFReadScanline() failed.\" );\n            return CE_Failure;\n        }\n    }\n    \n/* -------------------------------------------------------------------- */\n/*      Translate 1bit data to eight bit.                               */\n/* -------------------------------------------------------------------- */\n    int\t  iPixel, iSrcOffset=0, iDstOffset=0;\n\n    for( iPixel = 0; iPixel < nBlockXSize; iPixel++, iSrcOffset++ )\n    {\n        if( poGDS->pabyBlockBuf[iSrcOffset >>3] & (0x80 >> (iSrcOffset & 0x7)) )\n            ((GByte *) pImage)[iDstOffset++] = 1;\n        else\n            ((GByte *) pImage)[iDstOffset++] = 0;\n    }\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                            IWriteBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffSplitBitmapBand::IWriteBlock( int nBlockXOff, int nBlockYOff,\n                                          void * pImage )\n\n{\n    (void) nBlockXOff;\n    (void) nBlockYOff;\n    (void) pImage;\n\n    CPLError( CE_Failure, CPLE_AppDefined, \n              \"Split bitmap bands are read-only.\" );\n    return CE_Failure;\n}\n\n/************************************************************************/\n/* ==================================================================== */\n/*                            GTiffDataset                              */\n/* ==================================================================== */\n/************************************************************************/\n\n\n/************************************************************************/\n/*                            GTiffDataset()                            */\n/************************************************************************/\n\nGTiffDataset::GTiffDataset()\n\n{\n    nLoadedBlock = -1;\n    bLoadedBlockDirty = FALSE;\n    pabyBlockBuf = NULL;\n    hTIFF = NULL;\n    bNeedsRewrite = FALSE;\n    bMetadataChanged = FALSE;\n    bGeoTIFFInfoChanged = FALSE;\n    bCrystalized = TRUE;\n    poColorTable = NULL;\n    bNoDataSet = FALSE;\n    dfNoDataValue = -9999.0;\n    pszProjection = CPLStrdup(\"\");\n    bLookedForProjection = FALSE;\n    bBase = TRUE;\n    bCloseTIFFHandle = FALSE;\n    bTreatAsRGBA = FALSE;\n    nOverviewCount = 0;\n    papoOverviewDS = NULL;\n    nDirOffset = 0;\n    poActiveDS = NULL;\n    ppoActiveDSRef = NULL;\n\n    bGeoTransformValid = FALSE;\n    adfGeoTransform[0] = 0.0;\n    adfGeoTransform[1] = 1.0;\n    adfGeoTransform[2] = 0.0;\n    adfGeoTransform[3] = 0.0;\n    adfGeoTransform[4] = 0.0;\n    adfGeoTransform[5] = 1.0;\n\n    nGCPCount = 0;\n    pasGCPList = NULL;\n\n    osProfile = \"GDALGeoTIFF\";\n\n    papszCreationOptions = NULL;\n\n    nTempWriteBufferSize = 0;\n    pabyTempWriteBuffer = NULL;\n\n    poMaskDS = NULL;\n    poBaseDS = NULL;\n\n    bFillEmptyTiles = FALSE;\n    bLoadingOtherBands = FALSE;\n    nLastLineRead = -1;\n    nLastBandRead = -1;\n    bTreatAsSplit = FALSE;\n    bTreatAsSplitBitmap = FALSE;\n}\n\n/************************************************************************/\n/*                           ~GTiffDataset()                            */\n/************************************************************************/\n\nGTiffDataset::~GTiffDataset()\n\n{\n    Crystalize();\n\n/* -------------------------------------------------------------------- */\n/*      Ensure any blocks write cached by GDAL gets pushed through libtiff.*/\n/* -------------------------------------------------------------------- */\n    GDALPamDataset::FlushCache();\n\n/* -------------------------------------------------------------------- */\n/*      Fill in missing blocks with empty data.                         */\n/* -------------------------------------------------------------------- */\n    if( bFillEmptyTiles )\n    {\n        FillEmptyTiles();\n        bFillEmptyTiles = FALSE;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Force a complete flush, including either rewriting(moving)      */\n/*      of writing in place the current directory.                      */\n/* -------------------------------------------------------------------- */\n    FlushCache();\n\n/* -------------------------------------------------------------------- */\n/*      If there is still changed metadata, then presumably we want     */\n/*      to push it into PAM.                                            */\n/* -------------------------------------------------------------------- */\n    if( bMetadataChanged )\n    {\n        PushMetadataToPam();\n        bMetadataChanged = FALSE;\n        GDALPamDataset::FlushCache();\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Cleanup overviews.                                              */\n/* -------------------------------------------------------------------- */\n    if( bBase )\n    {\n        for( int i = 0; i < nOverviewCount; i++ )\n        {\n            delete papoOverviewDS[i];\n        }\n    }\n\n    /* If we are a mask dataset, we can have overviews, but we don't */\n    /* own them. We can only free the array, not the overviews themselves */\n    CPLFree( papoOverviewDS );\n\n    /* poMaskDS is owned by the main image and the overviews */\n    /* so because of the latter case, we can delete it even if */\n    /* we are not the base image */\n    if (poMaskDS)\n        delete poMaskDS;\n\n    if( poColorTable != NULL )\n        delete poColorTable;\n\n    if( bBase || bCloseTIFFHandle )\n    {\n        XTIFFClose( hTIFF );\n    }\n\n    if( nGCPCount > 0 )\n    {\n        GDALDeinitGCPs( nGCPCount, pasGCPList );\n        CPLFree( pasGCPList );\n    }\n\n    CPLFree( pszProjection );\n\n    CSLDestroy( papszCreationOptions );\n\n    CPLFree(pabyTempWriteBuffer);\n\n    if( *ppoActiveDSRef == this )\n        *ppoActiveDSRef = NULL;\n}\n\n/************************************************************************/\n/*                           FillEmptyTiles()                           */\n/************************************************************************/\n\nvoid GTiffDataset::FillEmptyTiles()\n\n{\n    toff_t *panByteCounts = NULL;\n    int    nBlockCount, iBlock;\n\n    if (!SetDirectory())\n        return;\n\n/* -------------------------------------------------------------------- */\n/*      How many blocks are there in this file?                         */\n/* -------------------------------------------------------------------- */\n    if( nPlanarConfig == PLANARCONFIG_SEPARATE )\n        nBlockCount = nBlocksPerBand * nBands;\n    else\n        nBlockCount = nBlocksPerBand;\n\n/* -------------------------------------------------------------------- */\n/*      Fetch block maps.                                               */\n/* -------------------------------------------------------------------- */\n    if( TIFFIsTiled( hTIFF ) )\n        TIFFGetField( hTIFF, TIFFTAG_TILEBYTECOUNTS, &panByteCounts );\n    else\n        TIFFGetField( hTIFF, TIFFTAG_STRIPBYTECOUNTS, &panByteCounts );\n\n/* -------------------------------------------------------------------- */\n/*      Prepare a blank data buffer to write for uninitialized blocks.  */\n/* -------------------------------------------------------------------- */\n    int nBlockBytes;\n\n    if( TIFFIsTiled( hTIFF ) )\n        nBlockBytes = TIFFTileSize(hTIFF);\n    else\n        nBlockBytes = TIFFStripSize(hTIFF);\n\n    GByte *pabyData = (GByte *) VSICalloc(nBlockBytes,1);\n    if (pabyData == NULL)\n    {\n        CPLError(CE_Failure, CPLE_OutOfMemory,\n                 \"Cannot allocate %d bytes\", nBlockBytes);\n        return;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Check all blocks, writing out data for uninitialized blocks.    */\n/* -------------------------------------------------------------------- */\n    for( iBlock = 0; iBlock < nBlockCount; iBlock++ )\n    {\n        if( panByteCounts[iBlock] == 0 )\n            WriteEncodedTileOrStrip( iBlock, pabyData, FALSE );\n    }\n\n    CPLFree( pabyData );\n}\n\n/************************************************************************/\n/*                        WriteEncodedTile()                            */\n/************************************************************************/\n\nint GTiffDataset::WriteEncodedTile(uint32 tile, void* data,\n                                   int bPreserveDataBuffer)\n{\n    /* TIFFWriteEncodedTile can alter the passed buffer if byte-swapping is necessary */\n    /* so we use a temporary buffer before calling it */\n    int cc = TIFFTileSize( hTIFF );\n    if (bPreserveDataBuffer && TIFFIsByteSwapped(hTIFF))\n    {\n        if (cc != nTempWriteBufferSize)\n        {\n            pabyTempWriteBuffer = CPLRealloc(pabyTempWriteBuffer, cc);\n            nTempWriteBufferSize = cc;\n        }\n        memcpy(pabyTempWriteBuffer, data, cc);\n        return TIFFWriteEncodedTile(hTIFF, tile, pabyTempWriteBuffer, cc);\n    }\n    else\n        return TIFFWriteEncodedTile(hTIFF, tile, data, cc);\n}\n\n/************************************************************************/\n/*                        WriteEncodedStrip()                           */\n/************************************************************************/\n\nint  GTiffDataset::WriteEncodedStrip(uint32 strip, void* data,\n                                     int bPreserveDataBuffer)\n{\n    int cc = TIFFStripSize( hTIFF );\n    \n/* -------------------------------------------------------------------- */\n/*      If this is the last strip in the image, and is partial, then    */\n/*      we need to trim the number of scanlines written to the          */\n/*      amount of valid data we have. (#2748)                           */\n/* -------------------------------------------------------------------- */\n    int nStripWithinBand = strip % nBlocksPerBand;\n    \n    if( (int) ((nStripWithinBand+1) * nRowsPerStrip) > GetRasterYSize() )\n    {\n        cc = (cc / nRowsPerStrip)\n            * (GetRasterYSize() - nStripWithinBand * nRowsPerStrip);\n        CPLDebug( \"GTiff\", \"Adjusted bytes to write from %d to %d.\", \n                  (int) TIFFStripSize(hTIFF), cc );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      TIFFWriteEncodedStrip can alter the passed buffer if            */\n/*      byte-swapping is necessary so we use a temporary buffer         */\n/*      before calling it.                                              */\n/* -------------------------------------------------------------------- */\n    if (bPreserveDataBuffer && TIFFIsByteSwapped(hTIFF))\n    {\n        if (cc != nTempWriteBufferSize)\n        {\n            pabyTempWriteBuffer = CPLRealloc(pabyTempWriteBuffer, cc);\n            nTempWriteBufferSize = cc;\n        }\n        memcpy(pabyTempWriteBuffer, data, cc);\n        return TIFFWriteEncodedStrip(hTIFF, strip, pabyTempWriteBuffer, cc);\n    }\n    else\n        return TIFFWriteEncodedStrip(hTIFF, strip, data, cc);\n}\n\n/************************************************************************/\n/*                  WriteEncodedTileOrStrip()                           */\n/************************************************************************/\n\nCPLErr  GTiffDataset::WriteEncodedTileOrStrip(uint32 tile_or_strip, void* data,\n                                              int bPreserveDataBuffer)\n{\n    CPLErr eErr = CE_None;\n\n    if( TIFFIsTiled( hTIFF ) )\n    {\n        if( WriteEncodedTile(tile_or_strip, data, bPreserveDataBuffer) == -1 )\n        {\n            eErr = CE_Failure;\n        }\n    }\n    else\n    {\n        if( WriteEncodedStrip(tile_or_strip, data, bPreserveDataBuffer) == -1 )\n        {\n            eErr = CE_Failure;\n        }\n    }\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                           FlushBlockBuf()                            */\n/************************************************************************/\n\nCPLErr GTiffDataset::FlushBlockBuf()\n\n{\n    CPLErr      eErr = CE_None;\n\n    if( nLoadedBlock < 0 || !bLoadedBlockDirty )\n        return CE_None;\n\n    bLoadedBlockDirty = FALSE;\n\n    if (!SetDirectory())\n        return CE_Failure;\n\n    eErr = WriteEncodedTileOrStrip(nLoadedBlock, pabyBlockBuf, TRUE);\n    if (eErr != CE_None)\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                    \"WriteEncodedTile/Strip() failed.\" );\n    }\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                            LoadBlockBuf()                            */\n/*                                                                      */\n/*      Load working block buffer with request block (tile/strip).      */\n/************************************************************************/\n\nCPLErr GTiffDataset::LoadBlockBuf( int nBlockId, int bReadFromDisk )\n\n{\n    int\tnBlockBufSize;\n    CPLErr\teErr = CE_None;\n\n    if( nLoadedBlock == nBlockId )\n        return CE_None;\n\n/* -------------------------------------------------------------------- */\n/*      If we have a dirty loaded block, flush it out first.            */\n/* -------------------------------------------------------------------- */\n    if( nLoadedBlock != -1 && bLoadedBlockDirty )\n    {\n        eErr = FlushBlockBuf();\n        if( eErr != CE_None )\n            return eErr;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Get block size.                                                 */\n/* -------------------------------------------------------------------- */\n    if( TIFFIsTiled(hTIFF) )\n        nBlockBufSize = TIFFTileSize( hTIFF );\n    else\n        nBlockBufSize = TIFFStripSize( hTIFF );\n\n    if ( !nBlockBufSize )\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                  \"Bogus block size; unable to allocate a buffer.\");\n        return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Allocate a temporary buffer for this strip.                     */\n/* -------------------------------------------------------------------- */\n    if( pabyBlockBuf == NULL )\n    {\n        pabyBlockBuf = (GByte *) VSICalloc( 1, nBlockBufSize );\n        if( pabyBlockBuf == NULL )\n        {\n            CPLError( CE_Failure, CPLE_OutOfMemory,\n                      \"Unable to allocate %d bytes for a temporary strip \"\n                      \"buffer in GTIFF driver.\",\n                      nBlockBufSize );\n            \n            return( CE_Failure );\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*  When called from ::IWriteBlock in separate cases (or in single band */\n/*  geotiffs), the ::IWriteBlock will override the content of the buffer*/\n/*  with pImage, so we don't need to read data from disk                */\n/* -------------------------------------------------------------------- */\n    if( !bReadFromDisk )\n    {\n        nLoadedBlock = nBlockId;\n        return CE_None;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      The bottom most partial tiles and strips are sometimes only     */\n/*      partially encoded.  This code reduces the requested data so     */\n/*      an error won't be reported in this case. (#1179)                */\n/* -------------------------------------------------------------------- */\n    int nBlockReqSize = nBlockBufSize;\n    int nBlocksPerRow = (nRasterXSize + nBlockXSize - 1) / nBlockXSize;\n    int nBlockYOff = (nBlockId % nBlocksPerBand) / nBlocksPerRow;\n\n    if( (int)((nBlockYOff+1) * nBlockYSize) > nRasterYSize )\n    {\n        nBlockReqSize = (nBlockBufSize / nBlockYSize) \n            * (nBlockYSize - (((nBlockYOff+1) * nBlockYSize) % nRasterYSize));\n        memset( pabyBlockBuf, 0, nBlockBufSize );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If we don't have this block already loaded, and we know it      */\n/*      doesn't yet exist on disk, just zero the memory buffer and      */\n/*      pretend we loaded it.                                           */\n/* -------------------------------------------------------------------- */\n    if( !IsBlockAvailable( nBlockId ) )\n    {\n        memset( pabyBlockBuf, 0, nBlockBufSize );\n        nLoadedBlock = nBlockId;\n        return CE_None;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Load the block, if it isn't our current block.                  */\n/* -------------------------------------------------------------------- */\n    if( TIFFIsTiled( hTIFF ) )\n    {\n        if( TIFFReadEncodedTile(hTIFF, nBlockId, pabyBlockBuf,\n                                nBlockReqSize) == -1 )\n        {\n            /* Once TIFFError() is properly hooked, this can go away */\n            CPLError( CE_Failure, CPLE_AppDefined,\n                      \"TIFFReadEncodedTile() failed.\" );\n                \n            memset( pabyBlockBuf, 0, nBlockBufSize );\n                \n            eErr = CE_Failure;\n        }\n    }\n    else\n    {\n        if( TIFFReadEncodedStrip(hTIFF, nBlockId, pabyBlockBuf,\n                                 nBlockReqSize) == -1 )\n        {\n            /* Once TIFFError() is properly hooked, this can go away */\n            CPLError( CE_Failure, CPLE_AppDefined,\n                      \"TIFFReadEncodedStrip() failed.\" );\n                \n            memset( pabyBlockBuf, 0, nBlockBufSize );\n                \n            eErr = CE_Failure;\n        }\n    }\n\n    nLoadedBlock = nBlockId;\n    bLoadedBlockDirty = FALSE;\n\n    return eErr;\n}\n\n\n/************************************************************************/\n/*                             Crystalize()                             */\n/*                                                                      */\n/*      Make sure that the directory information is written out for     */\n/*      a new file, require before writing any imagery data.            */\n/************************************************************************/\n\nvoid GTiffDataset::Crystalize()\n\n{\n    if( !bCrystalized )\n    {\n        WriteMetadata( this, hTIFF, TRUE, osProfile, osFilename,\n                       papszCreationOptions );\n        WriteGeoTIFFInfo();\n\n        bMetadataChanged = FALSE;\n        bGeoTIFFInfoChanged = FALSE;\n        bNeedsRewrite = FALSE;\n\n        bCrystalized = TRUE;\n\n        TIFFWriteCheck( hTIFF, TIFFIsTiled(hTIFF), \"GTiffDataset::Crystalize\");\n\n \t// Keep zip and tiff quality, and jpegcolormode which get reset when we call \n        // TIFFWriteDirectory \n        int jquality = -1, zquality = -1, nColorMode = -1; \n        TIFFGetField(hTIFF, TIFFTAG_JPEGQUALITY, &jquality); \n        TIFFGetField(hTIFF, TIFFTAG_ZIPQUALITY, &zquality); \n        TIFFGetField( hTIFF, TIFFTAG_JPEGCOLORMODE, &nColorMode );\n\n        TIFFWriteDirectory( hTIFF );\n        TIFFSetDirectory( hTIFF, 0 );\n\n\n        // Now, reset zip and tiff quality and jpegcolormode. \n        if(jquality > 0) \n            TIFFSetField(hTIFF, TIFFTAG_JPEGQUALITY, jquality); \n        if(zquality > 0) \n            TIFFSetField(hTIFF, TIFFTAG_ZIPQUALITY, zquality);\n        if (nColorMode >= 0)\n            TIFFSetField(hTIFF, TIFFTAG_JPEGCOLORMODE, nColorMode);\n\n        nDirOffset = TIFFCurrentDirOffset( hTIFF );\n    }\n}\n\n\n/************************************************************************/\n/*                          IsBlockAvailable()                          */\n/*                                                                      */\n/*      Return TRUE if the indicated strip/tile is available.  We       */\n/*      establish this by testing if the stripbytecount is zero.  If    */\n/*      zero then the block has never been committed to disk.           */\n/************************************************************************/\n\nint GTiffDataset::IsBlockAvailable( int nBlockId )\n\n{\n    toff_t *panByteCounts = NULL;\n\n    if( ( TIFFIsTiled( hTIFF ) \n          && TIFFGetField( hTIFF, TIFFTAG_TILEBYTECOUNTS, &panByteCounts ) )\n        || ( !TIFFIsTiled( hTIFF ) \n          && TIFFGetField( hTIFF, TIFFTAG_STRIPBYTECOUNTS, &panByteCounts ) ) )\n    {\n        if( panByteCounts == NULL )\n            return FALSE;\n        else\n            return panByteCounts[nBlockId] != 0;\n    }\n    else\n        return FALSE;\n}\n\n/************************************************************************/\n/*                             FlushCache()                             */\n/*                                                                      */\n/*      We override this so we can also flush out local tiff strip      */\n/*      cache if need be.                                               */\n/************************************************************************/\n\nvoid GTiffDataset::FlushCache()\n\n{\n    GDALPamDataset::FlushCache();\n\n    if( bLoadedBlockDirty && nLoadedBlock != -1 )\n        FlushBlockBuf();\n\n    CPLFree( pabyBlockBuf );\n    pabyBlockBuf = NULL;\n    nLoadedBlock = -1;\n    bLoadedBlockDirty = FALSE;\n\n    if (!SetDirectory())\n        return;\n    FlushDirectory();\n}\n\n/************************************************************************/\n/*                           FlushDirectory()                           */\n/************************************************************************/\n\nvoid GTiffDataset::FlushDirectory()\n\n{\n    if( GetAccess() == GA_Update )\n    {\n        if( bMetadataChanged )\n        {\n            if (!SetDirectory())\n                return;\n            bNeedsRewrite = \n                WriteMetadata( this, hTIFF, TRUE, osProfile, osFilename,\n                               papszCreationOptions );\n            bMetadataChanged = FALSE;\n        }\n        \n        if( bGeoTIFFInfoChanged )\n        {\n            if (!SetDirectory())\n                return;\n            WriteGeoTIFFInfo();\n        }\n\n        if( bNeedsRewrite )\n        {\n#if defined(TIFFLIB_VERSION)\n/* We need at least TIFF 3.7.0 for TIFFGetSizeProc and TIFFClientdata */\n#if  TIFFLIB_VERSION > 20041016\n            if (!SetDirectory())\n                return;\n\n            TIFFSizeProc pfnSizeProc = TIFFGetSizeProc( hTIFF );\n\n            nDirOffset = pfnSizeProc( TIFFClientdata( hTIFF ) );\n            if( (nDirOffset % 2) == 1 )\n                nDirOffset++;\n\n            TIFFRewriteDirectory( hTIFF );\n\n            TIFFSetSubDirectory( hTIFF, nDirOffset );\n#elif  TIFFLIB_VERSION > 20010925 && TIFFLIB_VERSION != 20011807\n            if (!SetDirectory())\n                return;\n\n            TIFFRewriteDirectory( hTIFF );\n#endif\n#endif\n            bNeedsRewrite = FALSE;\n        }\n    }\n\n    // there are some circumstances in which we can reach this point\n    // without having made this our directory (SetDirectory()) in which\n    // case we should not risk a flush. \n    if( TIFFCurrentDirOffset(hTIFF) == nDirOffset )\n        TIFFFlush( hTIFF );\n}\n\n/************************************************************************/\n/*                         TIFF_OvLevelAdjust()                         */\n/*                                                                      */\n/*      Some overview levels cannot be achieved closely enough to be    */\n/*      recognised as the desired overview level.  This function        */\n/*      will adjust an overview level to one that is achievable on      */\n/*      the given raster size.                                          */\n/*                                                                      */\n/*      For instance a 1200x1200 image on which a 256 level overview    */\n/*      is request will end up generating a 5x5 overview.  However,     */\n/*      this will appear to the system be a level 240 overview.         */\n/*      This function will adjust 256 to 240 based on knowledge of      */\n/*      the image size.                                                 */\n/*                                                                      */\n/*      This is a copy of the GDALOvLevelAdjust() function in           */\n/*      gdaldefaultoverviews.cpp.                                       */\n/************************************************************************/\n\nstatic int TIFF_OvLevelAdjust( int nOvLevel, int nXSize )\n\n{\n    int\tnOXSize = (nXSize + nOvLevel - 1) / nOvLevel;\n    \n    return (int) (0.5 + nXSize / (double) nOXSize);\n}\n\n/************************************************************************/\n/*                           CleanOverviews()                           */\n/************************************************************************/\n\nCPLErr GTiffDataset::CleanOverviews()\n\n{\n    CPLAssert( bBase );\n\n    FlushDirectory();\n    *ppoActiveDSRef = NULL;\n\n/* -------------------------------------------------------------------- */\n/*      Cleanup overviews objects, and get offsets to all overview      */\n/*      directories.                                                    */\n/* -------------------------------------------------------------------- */\n    std::vector<toff_t>  anOvDirOffsets;\n    int i;\n\n    for( i = 0; i < nOverviewCount; i++ )\n    {\n        anOvDirOffsets.push_back( papoOverviewDS[i]->nDirOffset );\n        delete papoOverviewDS[i];\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Loop through all the directories, translating the offsets       */\n/*      into indexes we can use with TIFFUnlinkDirectory().             */\n/* -------------------------------------------------------------------- */\n    std::vector<uint16> anOvDirIndexes;\n    int iThisOffset = 1;\n\n    TIFFSetDirectory( hTIFF, 0 );\n    \n    for( ; TRUE; ) \n    {\n        for( i = 0; i < nOverviewCount; i++ )\n        {\n            if( anOvDirOffsets[i] == TIFFCurrentDirOffset( hTIFF ) )\n            {\n                CPLDebug( \"GTiff\", \"%d -> %d\", \n                          (int) anOvDirOffsets[i], iThisOffset );\n                anOvDirIndexes.push_back( iThisOffset );\n            }\n        }\n        \n        if( TIFFLastDirectory( hTIFF ) )\n            break;\n\n        TIFFReadDirectory( hTIFF );\n        iThisOffset++;\n    } \n\n/* -------------------------------------------------------------------- */\n/*      Actually unlink the target directories.  Note that we do        */\n/*      this from last to first so as to avoid renumbering any of       */\n/*      the earlier directories we need to remove.                      */\n/* -------------------------------------------------------------------- */\n    while( !anOvDirIndexes.empty() )\n    {\n        TIFFUnlinkDirectory( hTIFF, anOvDirIndexes.back() );\n        anOvDirIndexes.pop_back();\n    }\n\n    CPLFree( papoOverviewDS );\n\n    nOverviewCount = 0;\n    papoOverviewDS = NULL;\n\n    if (!SetDirectory())\n        return CE_Failure;\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                          IBuildOverviews()                           */\n/************************************************************************/\n\nCPLErr GTiffDataset::IBuildOverviews( \n    const char * pszResampling, \n    int nOverviews, int * panOverviewList,\n    int nBands, int * panBandList,\n    GDALProgressFunc pfnProgress, void * pProgressData )\n\n{\n    CPLErr       eErr = CE_None;\n    int          i;\n    GTiffDataset *poODS;\n\n/* -------------------------------------------------------------------- */\n/*      If we don't have read access, then create the overviews         */\n/*      externally.                                                     */\n/* -------------------------------------------------------------------- */\n    if( GetAccess() != GA_Update )\n    {\n        CPLDebug( \"GTiff\",\n                  \"File open for read-only accessing, \"\n                  \"creating overviews externally.\" );\n\n        return GDALDataset::IBuildOverviews( \n            pszResampling, nOverviews, panOverviewList, \n            nBands, panBandList, pfnProgress, pProgressData );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If RRD overviews requested, then invoke generic handling.       */\n/* -------------------------------------------------------------------- */\n    if( CSLTestBoolean(CPLGetConfigOption( \"USE_RRD\", \"NO\" )) )\n    {\n        return GDALDataset::IBuildOverviews( \n            pszResampling, nOverviews, panOverviewList, \n            nBands, panBandList, pfnProgress, pProgressData );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Our TIFF overview support currently only works safely if all    */\n/*      bands are handled at the same time.                             */\n/* -------------------------------------------------------------------- */\n    if( nBands != GetRasterCount() )\n    {\n        CPLError( CE_Failure, CPLE_NotSupported,\n                  \"Generation of overviews in TIFF currently only\"\n                  \" supported when operating on all bands.\\n\" \n                  \"Operation failed.\\n\" );\n        return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Initialize progress counter.                                    */\n/* -------------------------------------------------------------------- */\n    if( !pfnProgress( 0.0, NULL, pProgressData ) )\n    {\n        CPLError( CE_Failure, CPLE_UserInterrupt, \"User terminated\" );\n        return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If zero overviews were requested, we need to clear all          */\n/*      existing overviews.                                             */\n/* -------------------------------------------------------------------- */\n    if( nOverviews == 0 )\n    {\n        if( nOverviewCount == 0 )\n            return GDALDataset::IBuildOverviews( \n                pszResampling, nOverviews, panOverviewList, \n                nBands, panBandList, pfnProgress, pProgressData );\n        else\n            return CleanOverviews();\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Move to the directory for this dataset.                         */\n/* -------------------------------------------------------------------- */\n    if (!SetDirectory())\n        return CE_Failure;\n    FlushDirectory();\n\n/* -------------------------------------------------------------------- */\n/*      If we are averaging bit data to grayscale we need to create     */\n/*      8bit overviews.                                                 */\n/* -------------------------------------------------------------------- */\n    int nOvBitsPerSample = nBitsPerSample;\n\n    if( EQUALN(pszResampling,\"AVERAGE_BIT2\",12) )\n        nOvBitsPerSample = 8;\n\n/* -------------------------------------------------------------------- */\n/*      Do we have a palette?  If so, create a TIFF compatible version. */\n/* -------------------------------------------------------------------- */\n    std::vector<unsigned short> anTRed, anTGreen, anTBlue;\n    unsigned short      *panRed=NULL, *panGreen=NULL, *panBlue=NULL;\n\n    if( nPhotometric == PHOTOMETRIC_PALETTE && poColorTable != NULL )\n    {\n        int nColors;\n\n        if( nOvBitsPerSample == 8 )\n            nColors = 256;\n        else if( nOvBitsPerSample < 8 )\n            nColors = 1 << nOvBitsPerSample;\n        else\n            nColors = 65536;\n        \n        anTRed.resize(nColors,0);\n        anTGreen.resize(nColors,0);\n        anTBlue.resize(nColors,0);\n        \n        for( int iColor = 0; iColor < nColors; iColor++ )\n        {\n            if( iColor < poColorTable->GetColorEntryCount() )\n            {\n                GDALColorEntry  sRGB;\n\n                poColorTable->GetColorEntryAsRGB( iColor, &sRGB );\n\n                anTRed[iColor] = (unsigned short) (256 * sRGB.c1);\n                anTGreen[iColor] = (unsigned short) (256 * sRGB.c2);\n                anTBlue[iColor] = (unsigned short) (256 * sRGB.c3);\n            }\n            else\n            {\n                anTRed[iColor] = anTGreen[iColor] = anTBlue[iColor] = 0;\n            }\n        }\n\n        panRed = &(anTRed[0]);\n        panGreen = &(anTGreen[0]);\n        panBlue = &(anTBlue[0]);\n    }\n        \n/* -------------------------------------------------------------------- */\n/*      Do we need some metadata for the overviews?                     */\n/* -------------------------------------------------------------------- */\n    CPLString osMetadata;\n\n    GTIFFBuildOverviewMetadata( pszResampling, this, osMetadata );\n\n/* -------------------------------------------------------------------- */\n/*      Fetch extra sample tag                                          */\n/* -------------------------------------------------------------------- */\n    uint16 *panExtraSampleValues = NULL;\n    uint16 nExtraSamples = 0;\n\n    if( TIFFGetField( hTIFF, TIFFTAG_EXTRASAMPLES, &nExtraSamples, &panExtraSampleValues) )\n    {\n        uint16* panExtraSampleValuesNew = (uint16*) CPLMalloc(nExtraSamples * sizeof(uint16));\n        memcpy(panExtraSampleValuesNew, panExtraSampleValues, nExtraSamples * sizeof(uint16));\n        panExtraSampleValues = panExtraSampleValuesNew;\n    }\n    else\n    {\n        panExtraSampleValues = NULL;\n        nExtraSamples = 0;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Establish which of the overview levels we already have, and     */\n/*      which are new.  We assume that band 1 of the file is            */\n/*      representative.                                                 */\n/* -------------------------------------------------------------------- */\n    for( i = 0; i < nOverviews && eErr == CE_None; i++ )\n    {\n        int   j;\n\n        for( j = 0; j < nOverviewCount; j++ )\n        {\n            int    nOvFactor;\n\n            poODS = papoOverviewDS[j];\n\n            nOvFactor = (int) \n                (0.5 + GetRasterXSize() / (double) poODS->GetRasterXSize());\n\n            if( nOvFactor == panOverviewList[i] \n                || nOvFactor == TIFF_OvLevelAdjust( panOverviewList[i],\n                                                    GetRasterXSize() ) )\n                panOverviewList[i] *= -1;\n        }\n\n        if( panOverviewList[i] > 0 )\n        {\n            toff_t\tnOverviewOffset;\n            int         nOXSize, nOYSize;\n\n            nOXSize = (GetRasterXSize() + panOverviewList[i] - 1) \n                / panOverviewList[i];\n            nOYSize = (GetRasterYSize() + panOverviewList[i] - 1)\n                / panOverviewList[i];\n\n            nOverviewOffset = \n                GTIFFWriteDirectory(hTIFF, FILETYPE_REDUCEDIMAGE,\n                                    nOXSize, nOYSize, \n                                    nOvBitsPerSample, nPlanarConfig,\n                                    nSamplesPerPixel, 128, 128, TRUE,\n                                    nCompression, nPhotometric, nSampleFormat, \n                                    panRed, panGreen, panBlue,\n                                    nExtraSamples, panExtraSampleValues,\n                                    osMetadata );\n\n            if( nOverviewOffset == 0 )\n            {\n                eErr = CE_Failure;\n                continue;\n            }\n\n            poODS = new GTiffDataset();\n            if( poODS->OpenOffset( hTIFF, ppoActiveDSRef, nOverviewOffset, FALSE, \n                                   GA_Update ) != CE_None )\n            {\n                delete poODS;\n                eErr = CE_Failure;\n            }\n            else\n            {\n                nOverviewCount++;\n                papoOverviewDS = (GTiffDataset **)\n                    CPLRealloc(papoOverviewDS, \n                               nOverviewCount * (sizeof(void*)));\n                papoOverviewDS[nOverviewCount-1] = poODS;\n                poODS->poBaseDS = this;\n            }\n        }\n        else\n            panOverviewList[i] *= -1;\n    }\n\n    CPLFree(panExtraSampleValues);\n    panExtraSampleValues = NULL;\n\n/* -------------------------------------------------------------------- */\n/*      Create overviews for the mask.                                  */\n/* -------------------------------------------------------------------- */\n\n    if (poMaskDS != NULL &&\n        poMaskDS->GetRasterCount() == 1 &&\n        CSLTestBoolean(CPLGetConfigOption(\"GDAL_TIFF_INTERNAL_MASK\", \"NO\")))\n    {\n        for( i = 0; i < nOverviewCount; i++ )\n        {\n            if (papoOverviewDS[i]->poMaskDS == NULL)\n            {\n                toff_t\tnOverviewOffset;\n\n                nOverviewOffset = \n                    GTIFFWriteDirectory(hTIFF, FILETYPE_REDUCEDIMAGE | FILETYPE_MASK,\n                                        papoOverviewDS[i]->nRasterXSize, papoOverviewDS[i]->nRasterYSize, \n                                        1, PLANARCONFIG_CONTIG,\n                                        1, 128, 128, TRUE,\n                                        COMPRESSION_NONE, PHOTOMETRIC_MASK, SAMPLEFORMAT_UINT, \n                                        NULL, NULL, NULL, 0, NULL,\n                                        \"\" );\n\n                if( nOverviewOffset == 0 )\n                {\n                    eErr = CE_Failure;\n                    continue;\n                }\n\n                poODS = new GTiffDataset();\n                if( poODS->OpenOffset( hTIFF, ppoActiveDSRef, \n                                       nOverviewOffset, FALSE, \n                                       GA_Update ) != CE_None )\n                {\n                    delete poODS;\n                    eErr = CE_Failure;\n                }\n                else\n                {\n                    poODS->poBaseDS = this;\n                    papoOverviewDS[i]->poMaskDS = poODS;\n                    poMaskDS->nOverviewCount++;\n                    poMaskDS->papoOverviewDS = (GTiffDataset **)\n                    CPLRealloc(poMaskDS->papoOverviewDS, \n                               poMaskDS->nOverviewCount * (sizeof(void*)));\n                    poMaskDS->papoOverviewDS[poMaskDS->nOverviewCount-1] = poODS;\n                }\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Refresh overviews for the mask                                  */\n/* -------------------------------------------------------------------- */\n    if (poMaskDS != NULL &&\n        poMaskDS->GetRasterCount() == 1)\n    {\n        GDALRasterBand **papoOverviewBands;\n        int nMaskOverviews = 0;\n\n        papoOverviewBands = (GDALRasterBand **) CPLCalloc(sizeof(void*),nOverviewCount);\n        for( i = 0; i < nOverviewCount; i++ )\n        {\n            if (papoOverviewDS[i]->poMaskDS != NULL)\n            {\n                papoOverviewBands[nMaskOverviews ++] =\n                        papoOverviewDS[i]->poMaskDS->GetRasterBand(1);\n            }\n        }\n        eErr = GDALRegenerateOverviews( (GDALRasterBandH) \n                                        poMaskDS->GetRasterBand(1),\n                                        nMaskOverviews, \n                                        (GDALRasterBandH *) papoOverviewBands,\n                                        pszResampling, GDALDummyProgress, NULL);\n        CPLFree(papoOverviewBands);\n    }\n\n\n/* -------------------------------------------------------------------- */\n/*      Refresh old overviews that were listed.                         */\n/* -------------------------------------------------------------------- */\n    if (nCompression != COMPRESSION_NONE &&\n        nPlanarConfig == PLANARCONFIG_CONTIG &&\n        GDALDataTypeIsComplex(GetRasterBand( panBandList[0] )->GetRasterDataType()) == FALSE &&\n        GetRasterBand( panBandList[0] )->GetColorTable() == NULL &&\n        (EQUALN(pszResampling, \"NEAR\", 4) || EQUAL(pszResampling, \"AVERAGE\") || EQUAL(pszResampling, \"GAUSS\")))\n    {\n        /* In the case of pixel interleaved compressed overviews, we want to generate */\n        /* the overviews for all the bands block by block, and not band after band, */\n        /* in order to write the block once and not loose space in the TIFF file */\n\n        GDALRasterBand ***papapoOverviewBands;\n        GDALRasterBand  **papoBandList;\n\n        int nNewOverviews = 0;\n        int iBand;\n\n        papapoOverviewBands = (GDALRasterBand ***) CPLCalloc(sizeof(void*),nBands);\n        papoBandList = (GDALRasterBand **) CPLCalloc(sizeof(void*),nBands);\n        for( iBand = 0; iBand < nBands; iBand++ )\n        {\n            GDALRasterBand* poBand = GetRasterBand( panBandList[iBand] );\n\n            papoBandList[iBand] = poBand;\n            papapoOverviewBands[iBand] = (GDALRasterBand **) CPLCalloc(sizeof(void*), poBand->GetOverviewCount());\n\n            int iCurOverview = 0;\n            for( i = 0; i < nOverviews; i++ )\n            {\n                int   j;\n\n                for( j = 0; j < poBand->GetOverviewCount(); j++ )\n                {\n                    int    nOvFactor;\n                    GDALRasterBand * poOverview = poBand->GetOverview( j );\n\n                    nOvFactor = (int) \n                    (0.5 + poBand->GetXSize() / (double) poOverview->GetXSize());\n\n                    int bHasNoData;\n                    double noDataValue = poBand->GetNoDataValue(&bHasNoData);\n\n                    if (bHasNoData)\n                        poOverview->SetNoDataValue(noDataValue);\n\n                    if( nOvFactor == panOverviewList[i] \n                        || nOvFactor == TIFF_OvLevelAdjust( panOverviewList[i],\n                                                            poBand->GetXSize() ) )\n                    {\n                        papapoOverviewBands[iBand][iCurOverview] = poOverview;\n                        iCurOverview++ ;\n                        break;\n                    }\n                }\n            }\n\n            if (nNewOverviews == 0)\n                nNewOverviews = iCurOverview;\n            else if (nNewOverviews != iCurOverview)\n            {\n                CPLAssert(0);\n                return CE_Failure;\n            }\n        }\n\n        GDALRegenerateOverviewsMultiBand(nBands, papoBandList,\n                                         nNewOverviews, papapoOverviewBands,\n                                         pszResampling, pfnProgress, pProgressData );\n\n        for( iBand = 0; iBand < nBands; iBand++ )\n        {\n            CPLFree(papapoOverviewBands[iBand]);\n        }\n        CPLFree(papapoOverviewBands);\n        CPLFree(papoBandList);\n    }\n    else\n    {\n        GDALRasterBand **papoOverviewBands;\n\n        papoOverviewBands = (GDALRasterBand **) \n            CPLCalloc(sizeof(void*),nOverviews);\n\n        for( int iBand = 0; iBand < nBands && eErr == CE_None; iBand++ )\n        {\n            GDALRasterBand *poBand;\n            int            nNewOverviews;\n\n            poBand = GetRasterBand( panBandList[iBand] );\n\n            nNewOverviews = 0;\n            for( i = 0; i < nOverviews && poBand != NULL; i++ )\n            {\n                int   j;\n\n                for( j = 0; j < poBand->GetOverviewCount(); j++ )\n                {\n                    int    nOvFactor;\n                    GDALRasterBand * poOverview = poBand->GetOverview( j );\n\n                    int bHasNoData;\n                    double noDataValue = poBand->GetNoDataValue(&bHasNoData);\n\n                    if (bHasNoData)\n                        poOverview->SetNoDataValue(noDataValue);\n\n                    nOvFactor = (int) \n                    (0.5 + poBand->GetXSize() / (double) poOverview->GetXSize());\n\n                    if( nOvFactor == panOverviewList[i] \n                        || nOvFactor == TIFF_OvLevelAdjust( panOverviewList[i],\n                                                            poBand->GetXSize() ) )\n                    {\n                        papoOverviewBands[nNewOverviews++] = poOverview;\n                        break;\n                    }\n                }\n            }\n\n            void         *pScaledProgressData;\n\n            pScaledProgressData = \n                GDALCreateScaledProgress( iBand / (double) nBands, \n                                        (iBand+1) / (double) nBands,\n                                        pfnProgress, pProgressData );\n\n            eErr = GDALRegenerateOverviews( (GDALRasterBandH) poBand,\n                                            nNewOverviews, \n                                            (GDALRasterBandH *) papoOverviewBands,\n                                            pszResampling, \n                                            GDALScaledProgress, \n                                            pScaledProgressData);\n\n            GDALDestroyScaledProgress( pScaledProgressData );\n        }\n\n    /* -------------------------------------------------------------------- */\n    /*      Cleanup                                                         */\n    /* -------------------------------------------------------------------- */\n        CPLFree( papoOverviewBands );\n    }\n\n\n    pfnProgress( 1.0, NULL, pProgressData );\n\n    return eErr;\n}\n\n\n/************************************************************************/\n/*                          WriteGeoTIFFInfo()                          */\n/************************************************************************/\n\nvoid GTiffDataset::WriteGeoTIFFInfo()\n\n{\n/* -------------------------------------------------------------------- */\n/*      If the geotransform is the default, don't bother writing it.    */\n/* -------------------------------------------------------------------- */\n    if( adfGeoTransform[0] != 0.0 || adfGeoTransform[1] != 1.0\n        || adfGeoTransform[2] != 0.0 || adfGeoTransform[3] != 0.0\n        || adfGeoTransform[4] != 0.0 || ABS(adfGeoTransform[5]) != 1.0 )\n    {\n        bNeedsRewrite = TRUE;\n\n/* -------------------------------------------------------------------- */\n/*      Clear old tags to ensure we don't end up with conflicting       */\n/*      information. (#2625)                                            */\n/* -------------------------------------------------------------------- */\n#ifdef HAVE_UNSETFIELD\n        TIFFUnsetField( hTIFF, TIFFTAG_GEOPIXELSCALE );\n        TIFFUnsetField( hTIFF, TIFFTAG_GEOTIEPOINTS );\n        TIFFUnsetField( hTIFF, TIFFTAG_GEOTRANSMATRIX );\n#endif\n\n/* -------------------------------------------------------------------- */\n/*      Write the transform.  If we have a normal north-up image we     */\n/*      use the tiepoint plus pixelscale otherwise we use a matrix.     */\n/* -------------------------------------------------------------------- */\n\tif( adfGeoTransform[2] == 0.0 && adfGeoTransform[4] == 0.0 \n            && adfGeoTransform[5] < 0.0 )\n\t{\n\t    double\tadfPixelScale[3], adfTiePoints[6];\n\n\t    adfPixelScale[0] = adfGeoTransform[1];\n\t    adfPixelScale[1] = fabs(adfGeoTransform[5]);\n\t    adfPixelScale[2] = 0.0;\n\n            if( !EQUAL(osProfile,\"BASELINE\") )\n                TIFFSetField( hTIFF, TIFFTAG_GEOPIXELSCALE, 3, adfPixelScale );\n\t    \n\t    adfTiePoints[0] = 0.0;\n\t    adfTiePoints[1] = 0.0;\n\t    adfTiePoints[2] = 0.0;\n\t    adfTiePoints[3] = adfGeoTransform[0];\n\t    adfTiePoints[4] = adfGeoTransform[3];\n\t    adfTiePoints[5] = 0.0;\n\t    \n            if( !EQUAL(osProfile,\"BASELINE\") )\n                TIFFSetField( hTIFF, TIFFTAG_GEOTIEPOINTS, 6, adfTiePoints );\n\t}\n\telse\n\t{\n\t    double\tadfMatrix[16];\n\t    \n\t    memset(adfMatrix,0,sizeof(double) * 16);\n\t    \n\t    adfMatrix[0] = adfGeoTransform[1];\n\t    adfMatrix[1] = adfGeoTransform[2];\n\t    adfMatrix[3] = adfGeoTransform[0];\n\t    adfMatrix[4] = adfGeoTransform[4];\n\t    adfMatrix[5] = adfGeoTransform[5];\n\t    adfMatrix[7] = adfGeoTransform[3];\n\t    adfMatrix[15] = 1.0;\n\t    \n            if( !EQUAL(osProfile,\"BASELINE\") )\n                TIFFSetField( hTIFF, TIFFTAG_GEOTRANSMATRIX, 16, adfMatrix );\n\t}\n\n        // Do we need a world file?\n        if( CSLFetchBoolean( papszCreationOptions, \"TFW\", FALSE ) )\n            GDALWriteWorldFile( osFilename, \"tfw\", adfGeoTransform );\n        else if( CSLFetchBoolean( papszCreationOptions, \"WORLDFILE\", FALSE ) )\n            GDALWriteWorldFile( osFilename, \"wld\", adfGeoTransform );\n    }\n    else if( GetGCPCount() > 0 )\n    {\n\tdouble\t*padfTiePoints;\n\tint\t\tiGCP;\n        bNeedsRewrite = TRUE;\n\t\n\tpadfTiePoints = (double *) \n\t    CPLMalloc( 6 * sizeof(double) * GetGCPCount() );\n\n\tfor( iGCP = 0; iGCP < GetGCPCount(); iGCP++ )\n\t{\n\n\t    padfTiePoints[iGCP*6+0] = pasGCPList[iGCP].dfGCPPixel;\n\t    padfTiePoints[iGCP*6+1] = pasGCPList[iGCP].dfGCPLine;\n\t    padfTiePoints[iGCP*6+2] = 0;\n\t    padfTiePoints[iGCP*6+3] = pasGCPList[iGCP].dfGCPX;\n\t    padfTiePoints[iGCP*6+4] = pasGCPList[iGCP].dfGCPY;\n\t    padfTiePoints[iGCP*6+5] = pasGCPList[iGCP].dfGCPZ;\n\t}\n\n        if( !EQUAL(osProfile,\"BASELINE\") )\n            TIFFSetField( hTIFF, TIFFTAG_GEOTIEPOINTS, \n                          6 * GetGCPCount(), padfTiePoints );\n\tCPLFree( padfTiePoints );\n    }\n\n/* -------------------------------------------------------------------- */\n/*\tWrite out projection definition.\t\t\t\t*/\n/* -------------------------------------------------------------------- */\n    if( pszProjection != NULL && !EQUAL( pszProjection, \"\" )\n        && !EQUAL(osProfile,\"BASELINE\") )\n    {\n        GTIF\t*psGTIF;\n\n        bNeedsRewrite = TRUE;\n\n        // If we have existing geokeys, try to wipe them\n        // by writing a dummy goekey directory. (#2546)\n        uint16 *panVI = NULL;\n        uint16 nKeyCount;\n\n        if( TIFFGetField( hTIFF, TIFFTAG_GEOKEYDIRECTORY, \n                          &nKeyCount, &panVI ) )\n        {\n            GUInt16 anGKVersionInfo[4] = { 1, 1, 0, 0 };\n            double  adfDummyDoubleParams[1] = { 0.0 };\n            TIFFSetField( hTIFF, TIFFTAG_GEOKEYDIRECTORY, \n                          4, anGKVersionInfo );\n            TIFFSetField( hTIFF, TIFFTAG_GEODOUBLEPARAMS, \n                          1, adfDummyDoubleParams );\n            TIFFSetField( hTIFF, TIFFTAG_GEOASCIIPARAMS, \"\" );\n        }\n\n        psGTIF = GTIFNew( hTIFF );  \n\n        // set according to coordinate system.\n        GTIFSetFromOGISDefn( psGTIF, pszProjection );\n\n        if( GetMetadataItem( GDALMD_AREA_OR_POINT ) \n            && EQUAL(GetMetadataItem(GDALMD_AREA_OR_POINT),\n                     GDALMD_AOP_POINT) )\n        {\n            GTIFKeySet(psGTIF, GTRasterTypeGeoKey, TYPE_SHORT, 1,\n                       RasterPixelIsPoint);\n        }\n\n        GTIFWriteKeys( psGTIF );\n        GTIFFree( psGTIF );\n    }\n}\n\n/************************************************************************/\n/*                         AppendMetadataItem()                         */\n/************************************************************************/\n\nstatic void AppendMetadataItem( CPLXMLNode **ppsRoot, CPLXMLNode **ppsTail,\n                                const char *pszKey, const char *pszValue,\n                                int nBand, const char *pszRole, \n                                const char *pszDomain )\n\n{\n    char szBandId[32];\n    CPLXMLNode *psItem;\n\n/* -------------------------------------------------------------------- */\n/*      Create the Item element, and subcomponents.                     */\n/* -------------------------------------------------------------------- */\n    psItem = CPLCreateXMLNode( NULL, CXT_Element, \"Item\" );\n    CPLCreateXMLNode( CPLCreateXMLNode( psItem, CXT_Attribute, \"name\"),\n                      CXT_Text, pszKey );\n\n    if( nBand > 0 )\n    {\n        sprintf( szBandId, \"%d\", nBand - 1 );\n        CPLCreateXMLNode( CPLCreateXMLNode( psItem,CXT_Attribute,\"sample\"),\n                          CXT_Text, szBandId );\n    }\n\n    if( pszRole != NULL )\n        CPLCreateXMLNode( CPLCreateXMLNode( psItem,CXT_Attribute,\"role\"),\n                          CXT_Text, pszRole );\n\n    if( pszDomain != NULL && strlen(pszDomain) > 0 )\n        CPLCreateXMLNode( CPLCreateXMLNode( psItem,CXT_Attribute,\"domain\"),\n                          CXT_Text, pszDomain );\n\n    char *pszEscapedItemValue = CPLEscapeString(pszValue,-1,CPLES_XML);\n    CPLCreateXMLNode( psItem, CXT_Text, pszEscapedItemValue );\n    CPLFree( pszEscapedItemValue );\n\n/* -------------------------------------------------------------------- */\n/*      Create root, if missing.                                        */\n/* -------------------------------------------------------------------- */\n    if( *ppsRoot == NULL )\n        *ppsRoot = CPLCreateXMLNode( NULL, CXT_Element, \"GDALMetadata\" );\n\n/* -------------------------------------------------------------------- */\n/*      Append item to tail.  We keep track of the tail to avoid        */\n/*      O(nsquared) time as the list gets longer.                       */\n/* -------------------------------------------------------------------- */\n    if( *ppsTail == NULL )\n        CPLAddXMLChild( *ppsRoot, psItem );\n    else\n        CPLAddXMLSibling( *ppsTail, psItem );\n    \n    *ppsTail = psItem;\n}\n\n/************************************************************************/\n/*                         WriteMDMDMetadata()                          */\n/************************************************************************/\n\nstatic void WriteMDMetadata( GDALMultiDomainMetadata *poMDMD, TIFF *hTIFF,\n                             CPLXMLNode **ppsRoot, CPLXMLNode **ppsTail, \n                             int nBand, const char *pszProfile )\n\n{\n    int iDomain;\n    char **papszDomainList;\n\n    (void) pszProfile;\n\n/* ==================================================================== */\n/*      Process each domain.                                            */\n/* ==================================================================== */\n    papszDomainList = poMDMD->GetDomainList();\n    for( iDomain = 0; papszDomainList && papszDomainList[iDomain]; iDomain++ )\n    {\n        char **papszMD = poMDMD->GetMetadata( papszDomainList[iDomain] );\n        int iItem;\n        int bIsXML = FALSE;\n\n        if( EQUAL(papszDomainList[iDomain], \"IMAGE_STRUCTURE\") )\n            continue; // ignored\n        if( EQUAL(papszDomainList[iDomain], \"RPC\") )\n            continue; // handled elsewhere\n        if( EQUALN(papszDomainList[iDomain], \"xml:\",4 ) )\n            bIsXML = TRUE;\n\n/* -------------------------------------------------------------------- */\n/*      Process each item in this domain.                               */\n/* -------------------------------------------------------------------- */\n        for( iItem = 0; papszMD && papszMD[iItem]; iItem++ )\n        {\n            const char *pszItemValue;\n            char *pszItemName = NULL;\n\n            if( bIsXML )\n            {\n                pszItemName = CPLStrdup(\"doc\");\n                pszItemValue = papszMD[iItem];\n            }\n            else\n            {\n                pszItemValue = CPLParseNameValue( papszMD[iItem], &pszItemName);\n            }\n            \n/* -------------------------------------------------------------------- */\n/*      Convert into XML item or handle as a special TIFF tag.          */\n/* -------------------------------------------------------------------- */\n            if( strlen(papszDomainList[iDomain]) == 0 \n                && nBand == 0 && EQUALN(pszItemName,\"TIFFTAG_\",8) )\n            {\n                if( EQUAL(pszItemName,\"TIFFTAG_DOCUMENTNAME\") )\n                    TIFFSetField( hTIFF, TIFFTAG_DOCUMENTNAME, pszItemValue );\n                else if( EQUAL(pszItemName,\"TIFFTAG_IMAGEDESCRIPTION\") )\n                    TIFFSetField( hTIFF, TIFFTAG_IMAGEDESCRIPTION, pszItemValue );\n                else if( EQUAL(pszItemName,\"TIFFTAG_SOFTWARE\") )\n                    TIFFSetField( hTIFF, TIFFTAG_SOFTWARE, pszItemValue );\n                else if( EQUAL(pszItemName,\"TIFFTAG_DATETIME\") )\n                    TIFFSetField( hTIFF, TIFFTAG_DATETIME, pszItemValue );\n                else if( EQUAL(pszItemName,\"TIFFTAG_ARTIST\") )\n                    TIFFSetField( hTIFF, TIFFTAG_ARTIST, pszItemValue );\n                else if( EQUAL(pszItemName,\"TIFFTAG_HOSTCOMPUTER\") )\n                    TIFFSetField( hTIFF, TIFFTAG_HOSTCOMPUTER, pszItemValue );\n                else if( EQUAL(pszItemName,\"TIFFTAG_COPYRIGHT\") )\n                    TIFFSetField( hTIFF, TIFFTAG_COPYRIGHT, pszItemValue );\n                else if( EQUAL(pszItemName,\"TIFFTAG_XRESOLUTION\") )\n                    TIFFSetField( hTIFF, TIFFTAG_XRESOLUTION, atof(pszItemValue) );\n                else if( EQUAL(pszItemName,\"TIFFTAG_YRESOLUTION\") )\n                    TIFFSetField( hTIFF, TIFFTAG_YRESOLUTION, atof(pszItemValue) );\n                else if( EQUAL(pszItemName,\"TIFFTAG_RESOLUTIONUNIT\") )\n                    TIFFSetField( hTIFF, TIFFTAG_RESOLUTIONUNIT, atoi(pszItemValue) );\n            }\n            else if( nBand == 0 && EQUAL(pszItemName,GDALMD_AREA_OR_POINT) )\n                /* do nothing, handled elsewhere */;\n            else\n                AppendMetadataItem( ppsRoot, ppsTail, \n                                    pszItemName, pszItemValue, \n                                    nBand, NULL, papszDomainList[iDomain] );\n\n            CPLFree( pszItemName );\n        }\n    }\n}\n\n/************************************************************************/\n/*                           WriteMetadata()                            */\n/************************************************************************/\n\nint  GTiffDataset::WriteMetadata( GDALDataset *poSrcDS, TIFF *hTIFF,\n                                  int bSrcIsGeoTIFF,\n                                  const char *pszProfile,\n                                  const char *pszTIFFFilename,\n                                  char **papszCreationOptions,\n                                  int bExcludeRPBandIMGFileWriting)\n\n{\n/* -------------------------------------------------------------------- */\n/*      Convert all the remaining metadata into a simple XML            */\n/*      format.                                                         */\n/* -------------------------------------------------------------------- */\n    CPLXMLNode *psRoot = NULL, *psTail = NULL;\n\n    if( bSrcIsGeoTIFF )\n    {\n        WriteMDMetadata( &(((GTiffDataset *)poSrcDS)->oGTiffMDMD), \n                         hTIFF, &psRoot, &psTail, 0, pszProfile );\n    }\n    else\n    {\n        char **papszMD = poSrcDS->GetMetadata();\n\n        if( CSLCount(papszMD) > 0 )\n        {\n            GDALMultiDomainMetadata oMDMD;\n            oMDMD.SetMetadata( papszMD );\n\n            WriteMDMetadata( &oMDMD, hTIFF, &psRoot, &psTail, 0, pszProfile );\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Handle RPC data written to an RPB file.                         */\n/* -------------------------------------------------------------------- */\n    char **papszRPCMD = poSrcDS->GetMetadata(\"RPC\");\n    if( papszRPCMD != NULL && !bExcludeRPBandIMGFileWriting )\n    {\n        if( EQUAL(pszProfile,\"GDALGeoTIFF\") )\n            WriteRPCTag( hTIFF, papszRPCMD );\n\n        if( !EQUAL(pszProfile,\"GDALGeoTIFF\") \n            || CSLFetchBoolean( papszCreationOptions, \"RPB\", FALSE ) )\n        {\n            GDALWriteRPBFile( pszTIFFFilename, papszRPCMD );\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Handle metadata data written to an IMD file.                    */\n/* -------------------------------------------------------------------- */\n    char **papszIMDMD = poSrcDS->GetMetadata(\"IMD\");\n    if( papszIMDMD != NULL && !bExcludeRPBandIMGFileWriting)\n    {\n        GDALWriteIMDFile( pszTIFFFilename, papszIMDMD );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      We also need to address band specific metadata, and special     */\n/*      \"role\" metadata.                                                */\n/* -------------------------------------------------------------------- */\n    int nBand;\n    for( nBand = 1; nBand <= poSrcDS->GetRasterCount(); nBand++ )\n    {\n        GDALRasterBand *poBand = poSrcDS->GetRasterBand( nBand );\n\n        if( bSrcIsGeoTIFF )\n        {\n            WriteMDMetadata( &(((GTiffRasterBand *)poBand)->oGTiffMDMD), \n                             hTIFF, &psRoot, &psTail, nBand, pszProfile );\n        }\n        else\n        {\n            char **papszMD = poBand->GetMetadata();\n            \n            if( CSLCount(papszMD) > 0 )\n            {\n                GDALMultiDomainMetadata oMDMD;\n                oMDMD.SetMetadata( papszMD );\n                \n                WriteMDMetadata( &oMDMD, hTIFF, &psRoot, &psTail, nBand,\n                                 pszProfile );\n            }\n        }\n\n        int bSuccess;\n        double dfOffset = poBand->GetOffset( &bSuccess );\n        double dfScale = poBand->GetScale();\n\n        if( bSuccess && (dfOffset != 0.0 || dfScale != 1.0) )\n        {\n            char szValue[128];\n\n            sprintf( szValue, \"%.18g\", dfOffset );\n            AppendMetadataItem( &psRoot, &psTail, \"OFFSET\", szValue, nBand, \n                                \"offset\", \"\" );\n            sprintf( szValue, \"%.18g\", dfScale );\n            AppendMetadataItem( &psRoot, &psTail, \"SCALE\", szValue, nBand, \n                                \"scale\", \"\" );\n        }\n\n        const char* pszUnitType = poBand->GetUnitType();\n        if (pszUnitType != NULL && pszUnitType[0] != '\\0')\n            AppendMetadataItem( &psRoot, &psTail, \"UNITTYPE\", pszUnitType, nBand, \"unittype\", \"\" );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Write out the generic XML metadata if there is any.             */\n/* -------------------------------------------------------------------- */\n    if( psRoot != NULL )\n    {\n        int bRet = TRUE;\n\n        if( EQUAL(pszProfile,\"GDALGeoTIFF\") )\n        {\n            char *pszXML_MD = CPLSerializeXMLTree( psRoot );\n            if( strlen(pszXML_MD) > 32000 )\n            {\n                if( bSrcIsGeoTIFF )\n                    ((GTiffDataset *) poSrcDS)->PushMetadataToPam();\n                else\n                    bRet = FALSE;\n                CPLError( CE_Warning, CPLE_AppDefined, \n                          \"Lost metadata writing to GeoTIFF ... too large to fit in tag.\" );\n            }\n            else\n            {\n                TIFFSetField( hTIFF, TIFFTAG_GDAL_METADATA, pszXML_MD );\n            }\n            CPLFree( pszXML_MD );\n        }\n        else\n        {\n            if( bSrcIsGeoTIFF )\n                ((GTiffDataset *) poSrcDS)->PushMetadataToPam();\n            else\n                bRet = FALSE;\n        }\n\n        CPLDestroyXMLNode( psRoot );\n\n        return bRet;\n    }\n\n    return TRUE;\n}\n\n/************************************************************************/\n/*                         PushMetadataToPam()                          */\n/*                                                                      */\n/*      When producing a strict profile TIFF or if our aggregate        */\n/*      metadata is too big for a single tiff tag we may end up         */\n/*      needing to write it via the PAM mechanisms.  This method        */\n/*      copies all the appropriate metadata into the PAM level          */\n/*      metadata object but with special care to avoid copying          */\n/*      metadata handled in other ways in TIFF format.                  */\n/************************************************************************/\n\nvoid GTiffDataset::PushMetadataToPam()\n\n{\n    int nBand;\n    for( nBand = 0; nBand <= GetRasterCount(); nBand++ )\n    {\n        GDALMultiDomainMetadata *poSrcMDMD;\n        GTiffRasterBand *poBand = NULL;\n\n        if( nBand == 0 )\n            poSrcMDMD = &(this->oGTiffMDMD);\n        else\n        {\n            poBand = (GTiffRasterBand *) GetRasterBand(nBand);\n            poSrcMDMD = &(poBand->oGTiffMDMD);\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Loop over the available domains.                                */\n/* -------------------------------------------------------------------- */\n        int iDomain, i;\n        char **papszDomainList;\n\n        papszDomainList = poSrcMDMD->GetDomainList();\n        for( iDomain = 0; \n             papszDomainList && papszDomainList[iDomain]; \n             iDomain++ )\n        {\n            char **papszMD = poSrcMDMD->GetMetadata( papszDomainList[iDomain] );\n\n            if( EQUAL(papszDomainList[iDomain],\"RPC\")\n                || EQUAL(papszDomainList[iDomain],\"IMD\") \n                || EQUAL(papszDomainList[iDomain],\"_temporary_\")\n                || EQUAL(papszDomainList[iDomain],\"IMAGE_STRUCTURE\") )\n                continue;\n\n            papszMD = CSLDuplicate(papszMD);\n\n            for( i = CSLCount(papszMD)-1; i >= 0; i-- )\n            {\n                if( EQUALN(papszMD[i],\"TIFFTAG_\",8)\n                    || EQUALN(papszMD[i],GDALMD_AREA_OR_POINT,\n                              strlen(GDALMD_AREA_OR_POINT)) )\n                    papszMD = CSLRemoveStrings( papszMD, i, 1, NULL );\n            }\n\n            if( nBand == 0 )\n                GDALPamDataset::SetMetadata( papszMD, papszDomainList[iDomain]);\n            else\n                poBand->GDALPamRasterBand::SetMetadata( papszMD, papszDomainList[iDomain]);\n\n            CSLDestroy( papszMD );\n        }\n            \n/* -------------------------------------------------------------------- */\n/*      Handle some \"special domain\" stuff.                             */\n/* -------------------------------------------------------------------- */\n        if( poBand != NULL )\n        {\n            int bSuccess;\n            double dfOffset = poBand->GetOffset( &bSuccess );\n            double dfScale = poBand->GetScale();\n\n            if( bSuccess && (dfOffset != 0.0 || dfScale != 1.0) )\n            {\n                poBand->GDALPamRasterBand::SetScale( dfScale );\n                poBand->GDALPamRasterBand::SetOffset( dfOffset );\n            }\n\n            poBand->GDALPamRasterBand::SetUnitType( poBand->GetUnitType() );\n        }\n    }\n}\n\n/************************************************************************/\n/*                            WriteRPCTag()                             */\n/*                                                                      */\n/*      Format a TAG according to:                                      */\n/*                                                                      */\n/*      http://geotiff.maptools.org/rpc_prop.html                       */\n/************************************************************************/\n\n/* static */\nvoid GTiffDataset::WriteRPCTag( TIFF *hTIFF, char **papszRPCMD )\n\n{\n    double adfRPCTag[92];\n    GDALRPCInfo sRPC;\n\n    if( !GDALExtractRPCInfo( papszRPCMD, &sRPC ) )\n        return;\n\n    adfRPCTag[0] = -1.0;  // Error Bias \n    adfRPCTag[1] = -1.0;  // Error Random\n\n    adfRPCTag[2] = sRPC.dfLINE_OFF;\n    adfRPCTag[3] = sRPC.dfSAMP_OFF;\n    adfRPCTag[4] = sRPC.dfLAT_OFF;\n    adfRPCTag[5] = sRPC.dfLONG_OFF;\n    adfRPCTag[6] = sRPC.dfHEIGHT_OFF;\n    adfRPCTag[7] = sRPC.dfLINE_SCALE;\n    adfRPCTag[8] = sRPC.dfSAMP_SCALE;\n    adfRPCTag[9] = sRPC.dfLAT_SCALE;\n    adfRPCTag[10] = sRPC.dfLONG_SCALE;\n    adfRPCTag[11] = sRPC.dfHEIGHT_SCALE;\n\n    memcpy( adfRPCTag + 12, sRPC.adfLINE_NUM_COEFF, sizeof(double) * 20 );\n    memcpy( adfRPCTag + 32, sRPC.adfLINE_DEN_COEFF, sizeof(double) * 20 );\n    memcpy( adfRPCTag + 52, sRPC.adfSAMP_NUM_COEFF, sizeof(double) * 20 );\n    memcpy( adfRPCTag + 72, sRPC.adfSAMP_DEN_COEFF, sizeof(double) * 20 );\n\n    TIFFSetField( hTIFF, TIFFTAG_RPCCOEFFICIENT, 92, adfRPCTag );\n}\n\n/************************************************************************/\n/*                             ReadRPCTag()                             */\n/*                                                                      */\n/*      Format a TAG according to:                                      */\n/*                                                                      */\n/*      http://geotiff.maptools.org/rpc_prop.html                       */\n/************************************************************************/\n\nvoid GTiffDataset::ReadRPCTag()\n\n{\n    double *padfRPCTag;\n    char **papszMD = NULL;\n    CPLString osField;\n    CPLString osMultiField;\n    int i;\n    uint16 nCount;\n\n    if( !TIFFGetField( hTIFF, TIFFTAG_RPCCOEFFICIENT, &nCount, &padfRPCTag ) \n        || nCount != 92 )\n        return;\n\n    osField.Printf( \"%.15g\", padfRPCTag[2] );\n    papszMD = CSLSetNameValue( papszMD, \"LINE_OFF\", osField );\n\n    osField.Printf( \"%.15g\", padfRPCTag[3] );\n    papszMD = CSLSetNameValue( papszMD, \"SAMP_OFF\", osField );\n\n    osField.Printf( \"%.15g\", padfRPCTag[4] );\n    papszMD = CSLSetNameValue( papszMD, \"LAT_OFF\", osField );\n\n    osField.Printf( \"%.15g\", padfRPCTag[5] );\n    papszMD = CSLSetNameValue( papszMD, \"LONG_OFF\", osField );\n\n    osField.Printf( \"%.15g\", padfRPCTag[6] );\n    papszMD = CSLSetNameValue( papszMD, \"HEIGHT_OFF\", osField );\n\n    osField.Printf( \"%.15g\", padfRPCTag[7] );\n    papszMD = CSLSetNameValue( papszMD, \"LINE_SCALE\", osField );\n\n    osField.Printf( \"%.15g\", padfRPCTag[8] );\n    papszMD = CSLSetNameValue( papszMD, \"SAMP_SCALE\", osField );\n\n    osField.Printf( \"%.15g\", padfRPCTag[9] );\n    papszMD = CSLSetNameValue( papszMD, \"LAT_SCALE\", osField );\n\n    osField.Printf( \"%.15g\", padfRPCTag[10] );\n    papszMD = CSLSetNameValue( papszMD, \"LONG_SCALE\", osField );\n\n    osField.Printf( \"%.15g\", padfRPCTag[11] );\n    papszMD = CSLSetNameValue( papszMD, \"HEIGHT_SCALE\", osField );\n\n    for( i = 0; i < 20; i++ )\n    {\n        osField.Printf( \"%.15g\", padfRPCTag[12+i] );\n        if( i > 0 )\n            osMultiField += \" \";\n        else\n            osMultiField = \"\";\n        osMultiField += osField;\n    }\n    papszMD = CSLSetNameValue( papszMD, \"LINE_NUM_COEFF\", osMultiField );\n\n    for( i = 0; i < 20; i++ )\n    {\n        osField.Printf( \"%.15g\", padfRPCTag[32+i] );\n        if( i > 0 )\n            osMultiField += \" \";\n        else\n            osMultiField = \"\";\n        osMultiField += osField;\n    }\n    papszMD = CSLSetNameValue( papszMD, \"LINE_DEN_COEFF\", osMultiField );\n\n    for( i = 0; i < 20; i++ )\n    {\n        osField.Printf( \"%.15g\", padfRPCTag[52+i] );\n        if( i > 0 )\n            osMultiField += \" \";\n        else\n            osMultiField = \"\";\n        osMultiField += osField;\n    }\n    papszMD = CSLSetNameValue( papszMD, \"SAMP_NUM_COEFF\", osMultiField );\n\n    for( i = 0; i < 20; i++ )\n    {\n        osField.Printf( \"%.15g\", padfRPCTag[72+i] );\n        if( i > 0 )\n            osMultiField += \" \";\n        else\n            osMultiField = \"\";\n        osMultiField += osField;\n    }\n    papszMD = CSLSetNameValue( papszMD, \"SAMP_DEN_COEFF\", osMultiField );\n\n    oGTiffMDMD.SetMetadata( papszMD, \"RPC\" );\n    CSLDestroy( papszMD );\n}\n\n/************************************************************************/\n/*                         WriteNoDataValue()                           */\n/************************************************************************/\n\nvoid GTiffDataset::WriteNoDataValue( TIFF *hTIFF, double dfNoData )\n\n{\n    TIFFSetField( hTIFF, TIFFTAG_GDAL_NODATA, \n                  CPLString().Printf( \"%.18g\", dfNoData ).c_str() );\n}\n\n/************************************************************************/\n/*                            SetDirectory()                            */\n/************************************************************************/\n\nint GTiffDataset::SetDirectory( toff_t nNewOffset )\n\n{\n    Crystalize();\n\n    FlushBlockBuf();\n\n    if( nNewOffset == 0 )\n        nNewOffset = nDirOffset;\n\n    if( TIFFCurrentDirOffset(hTIFF) == nNewOffset )\n    {\n        CPLAssert( *ppoActiveDSRef == this || *ppoActiveDSRef == NULL );\n        *ppoActiveDSRef = this;\n        return TRUE;\n    }\n\n    int jquality = -1, zquality = -1; \n\n    if( GetAccess() == GA_Update )\n    {\n        TIFFGetField(hTIFF, TIFFTAG_JPEGQUALITY, &jquality); \n        TIFFGetField(hTIFF, TIFFTAG_ZIPQUALITY, &zquality); \n\n        if( *ppoActiveDSRef != NULL )\n            (*ppoActiveDSRef)->FlushDirectory();\n    }\n    \n    if( nNewOffset == 0)\n        return TRUE;\n\n    (*ppoActiveDSRef) = this;\n\n    int nSetDirResult = TIFFSetSubDirectory( hTIFF, nNewOffset );\n    if (!nSetDirResult)\n        return nSetDirResult;\n\n/* -------------------------------------------------------------------- */\n/*      YCbCr JPEG compressed images should be translated on the fly    */\n/*      to RGB by libtiff/libjpeg unless specifically requested         */\n/*      otherwise.                                                      */\n/* -------------------------------------------------------------------- */\n    if( !TIFFGetField( hTIFF, TIFFTAG_COMPRESSION, &(nCompression) ) )\n        nCompression = COMPRESSION_NONE;\n\n    if( !TIFFGetField( hTIFF, TIFFTAG_PHOTOMETRIC, &(nPhotometric) ) )\n        nPhotometric = PHOTOMETRIC_MINISBLACK;\n    \n    if( nCompression == COMPRESSION_JPEG \n        && nPhotometric == PHOTOMETRIC_YCBCR \n        && CSLTestBoolean( CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\",\n                                              \"YES\") ) )\n    {\n        int nColorMode;\n\n        TIFFGetField( hTIFF, TIFFTAG_JPEGCOLORMODE, &nColorMode );\n        if( nColorMode != JPEGCOLORMODE_RGB )\n            TIFFSetField(hTIFF, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Propogate any quality settings.                                 */\n/* -------------------------------------------------------------------- */\n    if( GetAccess() == GA_Update )\n    {\n        // Now, reset zip and jpeg quality. \n        if(jquality > 0) \n        {\n            CPLDebug( \"GTiff\", \"Propgate JPEG_QUALITY(%d) in SetDirectory()\",\n                      jquality );\n            TIFFSetField(hTIFF, TIFFTAG_JPEGQUALITY, jquality); \n        }\n        if(zquality > 0) \n            TIFFSetField(hTIFF, TIFFTAG_ZIPQUALITY, zquality);\n    }\n\n    return nSetDirResult;\n}\n\n/************************************************************************/\n/*                              Identify()                              */\n/************************************************************************/\n\nint GTiffDataset::Identify( GDALOpenInfo * poOpenInfo )\n\n{\n    const char  *pszFilename = poOpenInfo->pszFilename;\n    if( EQUALN(pszFilename,\"GTIFF_RAW:\", strlen(\"GTIFF_RAW:\")) )\n    {\n        pszFilename += strlen(\"GTIFF_RAW:\");\n        GDALOpenInfo oOpenInfo( pszFilename, poOpenInfo->eAccess );\n        return Identify(&oOpenInfo);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      We have a special hook for handling opening a specific          */\n/*      directory of a TIFF file.                                       */\n/* -------------------------------------------------------------------- */\n    if( EQUALN(pszFilename,\"GTIFF_DIR:\",strlen(\"GTIFF_DIR:\")) )\n        return TRUE;\n\n/* -------------------------------------------------------------------- */\n/*\tFirst we check to see if the file has the expected header\t*/\n/*\tbytes.\t\t\t\t\t\t\t\t*/    \n/* -------------------------------------------------------------------- */\n    if( poOpenInfo->nHeaderBytes < 2 )\n        return FALSE;\n\n    if( (poOpenInfo->pabyHeader[0] != 'I' || poOpenInfo->pabyHeader[1] != 'I')\n        && (poOpenInfo->pabyHeader[0] != 'M' || poOpenInfo->pabyHeader[1] != 'M'))\n        return FALSE;\n\n#ifndef BIGTIFF_SUPPORT\n    if( (poOpenInfo->pabyHeader[2] == 0x2B && poOpenInfo->pabyHeader[3] == 0) ||\n        (poOpenInfo->pabyHeader[2] == 0 && poOpenInfo->pabyHeader[3] == 0x2B) )\n    {\n        CPLError( CE_Failure, CPLE_OpenFailed,\n                  \"This is a BigTIFF file.  BigTIFF is not supported by this\\n\"\n                  \"version of GDAL and libtiff.\" );\n        return FALSE;\n    }\n#endif\n\n    if( (poOpenInfo->pabyHeader[2] != 0x2A || poOpenInfo->pabyHeader[3] != 0)\n        && (poOpenInfo->pabyHeader[3] != 0x2A || poOpenInfo->pabyHeader[2] != 0)\n        && (poOpenInfo->pabyHeader[2] != 0x2B || poOpenInfo->pabyHeader[3] != 0)\n        && (poOpenInfo->pabyHeader[3] != 0x2B || poOpenInfo->pabyHeader[2] != 0))\n        return FALSE;\n\n    return TRUE;\n}\n\n/************************************************************************/\n/*                                Open()                                */\n/************************************************************************/\n\nGDALDataset *GTiffDataset::Open( GDALOpenInfo * poOpenInfo )\n\n{\n    TIFF\t*hTIFF;\n    int          bAllowRGBAInterface = TRUE;\n    const char  *pszFilename = poOpenInfo->pszFilename;\n\n/* -------------------------------------------------------------------- */\n/*      Check if it looks like a TIFF file.                             */\n/* -------------------------------------------------------------------- */\n    if (!Identify(poOpenInfo))\n        return NULL;\n\n    if( EQUALN(pszFilename,\"GTIFF_RAW:\", strlen(\"GTIFF_RAW:\")) )\n    {\n        bAllowRGBAInterface = FALSE;\n        pszFilename +=  strlen(\"GTIFF_RAW:\");\n    }\n\n/* -------------------------------------------------------------------- */\n/*      We have a special hook for handling opening a specific          */\n/*      directory of a TIFF file.                                       */\n/* -------------------------------------------------------------------- */\n    if( EQUALN(pszFilename,\"GTIFF_DIR:\",strlen(\"GTIFF_DIR:\")) )\n        return OpenDir( poOpenInfo );\n\n    GTiffOneTimeInit();\n\n/* -------------------------------------------------------------------- */\n/*      Try opening the dataset.                                        */\n/* -------------------------------------------------------------------- */\n    if( poOpenInfo->eAccess == GA_ReadOnly )\n\thTIFF = VSI_TIFFOpen( pszFilename, \"r\" );\n    else\n        hTIFF = VSI_TIFFOpen( pszFilename, \"r+\" );\n    \n    if( hTIFF == NULL )\n        return( NULL );\n\n/* -------------------------------------------------------------------- */\n/*      Create a corresponding GDALDataset.                             */\n/* -------------------------------------------------------------------- */\n    GTiffDataset \t*poDS;\n\n    poDS = new GTiffDataset();\n    poDS->SetDescription( pszFilename );\n    poDS->osFilename = pszFilename;\n    poDS->poActiveDS = poDS;\n\n    if( poDS->OpenOffset( hTIFF, &(poDS->poActiveDS),\n                          TIFFCurrentDirOffset(hTIFF), TRUE,\n                          poOpenInfo->eAccess, \n                          bAllowRGBAInterface ) != CE_None )\n    {\n        delete poDS;\n        return NULL;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Initialize any PAM information.                                 */\n/* -------------------------------------------------------------------- */\n    poDS->TryLoadXML();\n    poDS->ApplyPamInfo();\n\n    int i;\n    for(i=1;i<=poDS->nBands;i++)\n    {\n        GTiffRasterBand* poBand = (GTiffRasterBand*) poDS->GetRasterBand(i);\n\n        /* Load scale, offset and unittype from PAM if available */\n        if (!poBand->bHaveOffsetScale)\n        {\n            poBand->dfScale = poBand->GDALPamRasterBand::GetScale(&poBand->bHaveOffsetScale);\n            poBand->dfOffset = poBand->GDALPamRasterBand::GetOffset();\n        }\n        if (poBand->osUnitType.size() == 0)\n        {\n            const char* pszUnitType = poBand->GDALPamRasterBand::GetUnitType();\n            if (pszUnitType)\n                poBand->osUnitType = pszUnitType;\n        }\n    }\n    poDS->bMetadataChanged = FALSE;\n    poDS->bGeoTIFFInfoChanged = FALSE;\n\n/* -------------------------------------------------------------------- */\n/*      Check for external overviews.                                   */\n/* -------------------------------------------------------------------- */\n    poDS->oOvManager.Initialize( poDS, pszFilename );\n    \n    return poDS;\n}\n\n/************************************************************************/\n/*                         LookForProjection()                          */\n/************************************************************************/\n\nvoid GTiffDataset::LookForProjection()\n\n{\n    if( bLookedForProjection )\n        return;\n\n    bLookedForProjection = TRUE;\n    if (!SetDirectory())\n        return;\n\n/* -------------------------------------------------------------------- */\n/*      Capture the GeoTIFF projection, if available.                   */\n/* -------------------------------------------------------------------- */\n    GTIF \t*hGTIF;\n    GTIFDefn\tsGTIFDefn;\n\n    CPLFree( pszProjection );\n    pszProjection = NULL;\n    \n    hGTIF = GTIFNew(hTIFF);\n\n    if ( !hGTIF )\n    {\n        CPLError( CE_Warning, CPLE_AppDefined,\n                  \"GeoTIFF tags apparently corrupt, they are being ignored.\" );\n    }\n    else\n    {\n        if( GTIFGetDefn( hGTIF, &sGTIFDefn ) )\n        {\n            pszProjection = GTIFGetOGISDefn( hGTIF, &sGTIFDefn );\n            \n            // Should we simplify away vertical CS stuff?\n            if( EQUALN(pszProjection,\"COMPD_CS\",8)\n                && !CSLTestBoolean( CPLGetConfigOption(\"GTIFF_REPORT_COMPD_CS\",\n                                                       \"NO\") ) )\n            {\n                OGRSpatialReference oSRS;\n\n                CPLDebug( \"GTiff\", \"Got COMPD_CS, but stripping it.\" );\n                char *pszWKT = pszProjection;\n                oSRS.importFromWkt( &pszWKT );\n                CPLFree( pszProjection );\n\n                oSRS.StripVertical();\n                oSRS.exportToWkt( &pszProjection );\n            }\n        }\n\n        // Is this a pixel-is-point dataset?\n        short nRasterType;\n\n        if( GTIFKeyGet(hGTIF, GTRasterTypeGeoKey, &nRasterType, \n                       0, 1 ) == 1 )\n        {\n            if( nRasterType == (short) RasterPixelIsPoint )\n                oGTiffMDMD.SetMetadataItem( GDALMD_AREA_OR_POINT, GDALMD_AOP_POINT );\n            else\n                oGTiffMDMD.SetMetadataItem( GDALMD_AREA_OR_POINT, GDALMD_AOP_AREA );\n        }\n\n        GTIFFree( hGTIF );\n    }\n\n    if( pszProjection == NULL )\n    {\n        pszProjection = CPLStrdup( \"\" );\n    }\n\n    bGeoTIFFInfoChanged = FALSE;\n}\n\n/************************************************************************/\n/*                            ApplyPamInfo()                            */\n/*                                                                      */\n/*      PAM Information, if available, overrides the GeoTIFF            */\n/*      geotransform and projection definition.  Check for them         */\n/*      now.                                                            */\n/************************************************************************/\n\nvoid GTiffDataset::ApplyPamInfo()\n\n{\n    double adfPamGeoTransform[6];\n\n    if( GDALPamDataset::GetGeoTransform( adfPamGeoTransform ) == CE_None \n        && (adfPamGeoTransform[0] != 0.0 || adfPamGeoTransform[1] != 1.0\n            || adfPamGeoTransform[2] != 0.0 || adfPamGeoTransform[3] != 0.0\n            || adfPamGeoTransform[4] != 0.0 || adfPamGeoTransform[5] != 1.0 ))\n    {\n        memcpy( adfGeoTransform, adfPamGeoTransform, sizeof(double)*6 );\n        bGeoTransformValid = TRUE;\n    }\n\n    const char *pszPamSRS = GDALPamDataset::GetProjectionRef();\n\n    if( pszPamSRS != NULL && strlen(pszPamSRS) > 0 )\n    {\n        CPLFree( pszProjection );\n        pszProjection = CPLStrdup( pszPamSRS );\n        bLookedForProjection= TRUE;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Copy any PAM metadata into our GeoTIFF context, but with the    */\n/*      GeoTIFF context overriding the PAM info.                        */\n/* -------------------------------------------------------------------- */\n    char **papszPamDomains = oMDMD.GetDomainList();\n\n    for( int iDomain = 0; papszPamDomains && papszPamDomains[iDomain] != NULL; iDomain++ )\n    {\n        const char *pszDomain = papszPamDomains[iDomain];\n        char **papszGT_MD = oGTiffMDMD.GetMetadata( pszDomain );\n        char **papszPAM_MD = CSLDuplicate(oMDMD.GetMetadata( pszDomain ));\n\n        papszPAM_MD = CSLMerge( papszPAM_MD, papszGT_MD );\n\n        oGTiffMDMD.SetMetadata( papszPAM_MD, pszDomain );\n        CSLDestroy( papszPAM_MD );\n    }\n\n    for( int i = 1; i <= GetRasterCount(); i++)\n    {\n        GTiffRasterBand* poBand = (GTiffRasterBand *)GetRasterBand(i);\n        papszPamDomains = poBand->oMDMD.GetDomainList();\n\n        for( int iDomain = 0; papszPamDomains && papszPamDomains[iDomain] != NULL; iDomain++ )\n        {\n            const char *pszDomain = papszPamDomains[iDomain];\n            char **papszGT_MD = poBand->oGTiffMDMD.GetMetadata( pszDomain );\n            char **papszPAM_MD = CSLDuplicate(poBand->oMDMD.GetMetadata( pszDomain ));\n\n            papszPAM_MD = CSLMerge( papszPAM_MD, papszGT_MD );\n\n            poBand->oGTiffMDMD.SetMetadata( papszPAM_MD, pszDomain );\n            CSLDestroy( papszPAM_MD );\n        }\n    }\n}\n\n/************************************************************************/\n/*                              OpenDir()                               */\n/*                                                                      */\n/*      Open a specific directory as encoded into a filename.           */\n/************************************************************************/\n\nGDALDataset *GTiffDataset::OpenDir( GDALOpenInfo * poOpenInfo )\n\n{\n    int bAllowRGBAInterface = TRUE;\n    const char* pszFilename = poOpenInfo->pszFilename;\n    if( EQUALN(pszFilename,\"GTIFF_RAW:\", strlen(\"GTIFF_RAW:\")) )\n    {\n        bAllowRGBAInterface = FALSE;\n        pszFilename += strlen(\"GTIFF_RAW:\");\n    }\n\n    if( !EQUALN(pszFilename,\"GTIFF_DIR:\",strlen(\"GTIFF_DIR:\")) )\n        return NULL;\n    \n/* -------------------------------------------------------------------- */\n/*      Split out filename, and dir#/offset.                            */\n/* -------------------------------------------------------------------- */\n    pszFilename += strlen(\"GTIFF_DIR:\");\n    int        bAbsolute = FALSE;\n    toff_t     nOffset;\n    \n    if( EQUALN(pszFilename,\"off:\",4) )\n    {\n        bAbsolute = TRUE;\n        pszFilename += 4;\n    }\n\n    nOffset = atol(pszFilename);\n    pszFilename += 1;\n\n    while( *pszFilename != '\\0' && pszFilename[-1] != ':' )\n        pszFilename++;\n\n    if( *pszFilename == '\\0' || nOffset == 0 )\n    {\n        CPLError( CE_Failure, CPLE_OpenFailed,\n                  \"Unable to extract offset or filename, should take the form\\n\"\n                  \"GTIFF_DIR:<dir>:filename or GTIFF_DIR:off:<dir_offset>:filename\" );\n        return NULL;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Try opening the dataset.                                        */\n/* -------------------------------------------------------------------- */\n    TIFF\t*hTIFF;\n\n    GTiffOneTimeInit();\n\n    hTIFF = VSI_TIFFOpen( pszFilename, \"r\" );\n    if( hTIFF == NULL )\n        return( NULL );\n\n/* -------------------------------------------------------------------- */\n/*      If a directory was requested by index, advance to it now.       */\n/* -------------------------------------------------------------------- */\n    if( !bAbsolute )\n    {\n        while( nOffset > 1 )\n        {\n            if( TIFFReadDirectory( hTIFF ) == 0 )\n            {\n                XTIFFClose( hTIFF );\n                CPLError( CE_Failure, CPLE_OpenFailed, \n                          \"Requested directory %lu not found.\", (long unsigned int)nOffset );\n                return NULL;\n            }\n            nOffset--;\n        }\n\n        nOffset = TIFFCurrentDirOffset( hTIFF );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Create a corresponding GDALDataset.                             */\n/* -------------------------------------------------------------------- */\n    GTiffDataset \t*poDS;\n\n    poDS = new GTiffDataset();\n    poDS->SetDescription( poOpenInfo->pszFilename );\n    poDS->osFilename = poOpenInfo->pszFilename;\n    poDS->poActiveDS = poDS;\n\n    if( !EQUAL(pszFilename,poOpenInfo->pszFilename) \n        && !EQUALN(poOpenInfo->pszFilename,\"GTIFF_RAW:\",10) )\n    {\n        poDS->SetPhysicalFilename( pszFilename );\n        poDS->SetSubdatasetName( poOpenInfo->pszFilename );\n        poDS->osFilename = pszFilename;\n    }\n\n    if (poOpenInfo->eAccess == GA_Update)\n    {\n        CPLError( CE_Warning, CPLE_AppDefined,\n                  \"Opening a specific TIFF directory is not supported in update mode. Switching to read-only\" );\n    }\n\n    if( poDS->OpenOffset( hTIFF, &(poDS->poActiveDS),\n                          nOffset, FALSE, GA_ReadOnly, bAllowRGBAInterface ) != CE_None )\n    {\n        delete poDS;\n        return NULL;\n    }\n    else\n    {\n        poDS->bCloseTIFFHandle = TRUE;\n        return poDS;\n    }\n}\n\n/************************************************************************/\n/*                             OpenOffset()                             */\n/*                                                                      */\n/*      Initialize the GTiffDataset based on a passed in file           */\n/*      handle, and directory offset to utilize.  This is called for    */\n/*      full res, and overview pages.                                   */\n/************************************************************************/\n\nCPLErr GTiffDataset::OpenOffset( TIFF *hTIFFIn, \n                                 GTiffDataset **ppoActiveDSRef,\n                                 toff_t nDirOffsetIn, \n\t\t\t\t int bBaseIn, GDALAccess eAccess,\n                                 int bAllowRGBAInterface)\n\n{\n    uint32\tnXSize, nYSize;\n    int\t\tbTreatAsBitmap = FALSE;\n    int         bTreatAsOdd = FALSE;\n\n    this->eAccess = eAccess;\n\n    hTIFF = hTIFFIn;\n    this->ppoActiveDSRef = ppoActiveDSRef;\n\n    nDirOffset = nDirOffsetIn;\n\n    if (!SetDirectory( nDirOffsetIn ))\n        return CE_Failure;\n\n    bBase = bBaseIn;\n\n    this->eAccess = eAccess;\n\n/* -------------------------------------------------------------------- */\n/*      Capture some information from the file that is of interest.     */\n/* -------------------------------------------------------------------- */\n    TIFFGetField( hTIFF, TIFFTAG_IMAGEWIDTH, &nXSize );\n    TIFFGetField( hTIFF, TIFFTAG_IMAGELENGTH, &nYSize );\n    nRasterXSize = nXSize;\n    nRasterYSize = nYSize;\n\n    if( !TIFFGetField(hTIFF, TIFFTAG_SAMPLESPERPIXEL, &nSamplesPerPixel ) )\n        nBands = 1;\n    else\n        nBands = nSamplesPerPixel;\n    \n    if( !TIFFGetField(hTIFF, TIFFTAG_BITSPERSAMPLE, &(nBitsPerSample)) )\n        nBitsPerSample = 1;\n    \n    if( !TIFFGetField( hTIFF, TIFFTAG_PLANARCONFIG, &(nPlanarConfig) ) )\n        nPlanarConfig = PLANARCONFIG_CONTIG;\n    \n    if( !TIFFGetField( hTIFF, TIFFTAG_PHOTOMETRIC, &(nPhotometric) ) )\n        nPhotometric = PHOTOMETRIC_MINISBLACK;\n    \n    if( !TIFFGetField( hTIFF, TIFFTAG_SAMPLEFORMAT, &(nSampleFormat) ) )\n        nSampleFormat = SAMPLEFORMAT_UINT;\n    \n    if( !TIFFGetField( hTIFF, TIFFTAG_COMPRESSION, &(nCompression) ) )\n        nCompression = COMPRESSION_NONE;\n    \n#if defined(TIFFLIB_VERSION) && TIFFLIB_VERSION > 20031007 /* 3.6.0 */\n    if (nCompression != COMPRESSION_NONE &&\n        !TIFFIsCODECConfigured(nCompression))\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                  \"Cannot open TIFF file due to missing codec.\" );\n        return CE_Failure;\n    }\n#endif\n\n/* -------------------------------------------------------------------- */\n/*      YCbCr JPEG compressed images should be translated on the fly    */\n/*      to RGB by libtiff/libjpeg unless specifically requested         */\n/*      otherwise.                                                      */\n/* -------------------------------------------------------------------- */\n    if( nCompression == COMPRESSION_JPEG \n        && nPhotometric == PHOTOMETRIC_YCBCR \n        && CSLTestBoolean( CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\",\n                                              \"YES\") ) )\n    {\n        int nColorMode;\n\n        SetMetadataItem( \"SOURCE_COLOR_SPACE\", \"YCbCr\", \"IMAGE_STRUCTURE\" );\n        if ( !TIFFGetField( hTIFF, TIFFTAG_JPEGCOLORMODE, &nColorMode ) ||\n              nColorMode != JPEGCOLORMODE_RGB )\n            TIFFSetField(hTIFF, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Get strip/tile layout.                                          */\n/* -------------------------------------------------------------------- */\n    if( TIFFIsTiled(hTIFF) )\n    {\n        TIFFGetField( hTIFF, TIFFTAG_TILEWIDTH, &(nBlockXSize) );\n        TIFFGetField( hTIFF, TIFFTAG_TILELENGTH, &(nBlockYSize) );\n    }\n    else\n    {\n        if( !TIFFGetField( hTIFF, TIFFTAG_ROWSPERSTRIP,\n                           &(nRowsPerStrip) ) )\n        {\n            CPLError( CE_Warning, CPLE_AppDefined, \n                      \"RowsPerStrip not defined ... assuming all one strip.\" );\n            nRowsPerStrip = nYSize; /* dummy value */\n        }\n\n        nBlockXSize = nRasterXSize;\n        nBlockYSize = MIN(nRowsPerStrip,nYSize);\n    }\n        \n    nBlocksPerBand =\n        ((nYSize + nBlockYSize - 1) / nBlockYSize)\n        * ((nXSize + nBlockXSize  - 1) / nBlockXSize);\n\n/* -------------------------------------------------------------------- */\n/*      Should we handle this using the GTiffBitmapBand?                */\n/* -------------------------------------------------------------------- */\n    if( nBitsPerSample == 1 && nBands == 1 )\n    {\n        bTreatAsBitmap = TRUE;\n\n        // Lets treat large \"one row\" bitmaps using the scanline api.\n        if( !TIFFIsTiled(hTIFF) \n            && nBlockYSize == nYSize \n            && nYSize > 2000 \n            && bAllowRGBAInterface )\n            bTreatAsSplitBitmap = TRUE;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Should we treat this via the RGBA interface?                    */\n/* -------------------------------------------------------------------- */\n    if( bAllowRGBAInterface &&\n        !bTreatAsBitmap && !(nBitsPerSample > 8) \n        && (nPhotometric == PHOTOMETRIC_CIELAB ||\n            nPhotometric == PHOTOMETRIC_LOGL ||\n            nPhotometric == PHOTOMETRIC_LOGLUV ||\n            nPhotometric == PHOTOMETRIC_SEPARATED ||\n            ( nPhotometric == PHOTOMETRIC_YCBCR \n              && nCompression != COMPRESSION_JPEG )) )\n    {\n        char\tszMessage[1024];\n\n        if( TIFFRGBAImageOK( hTIFF, szMessage ) == 1 )\n        {\n            const char* pszSourceColorSpace = NULL;\n            switch (nPhotometric)\n            {\n                case PHOTOMETRIC_CIELAB:\n                    pszSourceColorSpace = \"CIELAB\";\n                    break;\n                case PHOTOMETRIC_LOGL:\n                    pszSourceColorSpace = \"LOGL\";\n                    break;\n                case PHOTOMETRIC_LOGLUV:\n                    pszSourceColorSpace = \"LOGLUV\";\n                    break;\n                case PHOTOMETRIC_SEPARATED:\n                    pszSourceColorSpace = \"CMYK\";\n                    break;\n                case PHOTOMETRIC_YCBCR:\n                    pszSourceColorSpace = \"YCbCr\";\n                    break;\n            }\n            if (pszSourceColorSpace)\n                SetMetadataItem( \"SOURCE_COLOR_SPACE\", pszSourceColorSpace, \"IMAGE_STRUCTURE\" );\n            bTreatAsRGBA = TRUE;\n            nBands = 4;\n        }\n        else\n        {\n            CPLDebug( \"GTiff\", \"TIFFRGBAImageOK says:\\n%s\", szMessage );\n        }\n    }\n    \n/* -------------------------------------------------------------------- */\n/*      Should we treat this via the split interface?                   */\n/* -------------------------------------------------------------------- */\n    if( !TIFFIsTiled(hTIFF) \n        && nBitsPerSample == 8\n        && nBlockYSize == nYSize \n        && nYSize > 2000\n        && !bTreatAsRGBA \n        && CSLTestBoolean(CPLGetConfigOption(\"GDAL_ENABLE_TIFF_SPLIT\", \"YES\")))\n    {\n        /* libtiff 3.9.2 (20091104) and older, libtiff 4.0.0beta5 (also 20091104) */\n        /* and older will crash when trying to open a all-in-one-strip */\n        /* YCbCr JPEG compressed TIFF (see #3259). BUG_3259_FIXED is defined */\n        /* in internal libtiff tif_config.h until a 4.0.0beta6 is released */\n#if (TIFFLIB_VERSION <= 20091104 && !defined(BIGTIFF_SUPPORT)) || \\\n    (TIFFLIB_VERSION <= 20091104 && defined(BIGTIFF_SUPPORT) && !defined(BUG_3259_FIXED))\n        if (nPhotometric == PHOTOMETRIC_YCBCR  &&\n            nCompression == COMPRESSION_JPEG)\n        {\n            CPLDebug(\"GTiff\", \"Avoid using split band to open all-in-one-strip \"\n                              \"YCbCr JPEG compressed TIFF because of older libtiff\");\n        }\n        else\n#endif\n            bTreatAsSplit = TRUE;\n    }\n    \n/* -------------------------------------------------------------------- */\n/*      Should we treat this via the odd bits interface?                */\n/* -------------------------------------------------------------------- */\n    if ( nSampleFormat == SAMPLEFORMAT_IEEEFP )\n    {\n        if ( nBitsPerSample == 16 || nBitsPerSample == 24 )\n            bTreatAsOdd = TRUE;\n    }\n    else if ( !bTreatAsRGBA && !bTreatAsBitmap\n              && nBitsPerSample != 8\n              && nBitsPerSample != 16\n              && nBitsPerSample != 32\n              && nBitsPerSample != 64 \n              && nBitsPerSample != 128 )\n        bTreatAsOdd = TRUE;\n\n    int bMinIsWhite = nPhotometric == PHOTOMETRIC_MINISWHITE;\n\n/* -------------------------------------------------------------------- */\n/*      Capture the color table if there is one.                        */\n/* -------------------------------------------------------------------- */\n    unsigned short\t*panRed, *panGreen, *panBlue;\n\n    if( bTreatAsRGBA \n        || TIFFGetField( hTIFF, TIFFTAG_COLORMAP, \n                         &panRed, &panGreen, &panBlue) == 0 )\n    {\n\t// Build inverted palette if we have inverted photometric.\n\t// Pixel values remains unchanged.  Avoid doing this for *deep*\n        // data types (per #1882)\n\tif( nBitsPerSample <= 16 && nPhotometric == PHOTOMETRIC_MINISWHITE )\n\t{\n\t    GDALColorEntry  oEntry;\n\t    int\t\t    iColor, nColorCount;\n\t    \n\t    poColorTable = new GDALColorTable();\n\t    nColorCount = 1 << nBitsPerSample;\n\n\t    for ( iColor = 0; iColor < nColorCount; iColor++ )\n\t    {\n\t\toEntry.c1 = oEntry.c2 = oEntry.c3 = (short) \n                    ((255 * (nColorCount - 1 - iColor)) / (nColorCount-1));\n\t\toEntry.c4 = 255;\n\t\tpoColorTable->SetColorEntry( iColor, &oEntry );\n\t    }\n\n\t    nPhotometric = PHOTOMETRIC_PALETTE;\n\t}\n\telse\n\t    poColorTable = NULL;\n    }\n    else\n    {\n        int\tnColorCount, nMaxColor = 0;\n        GDALColorEntry oEntry;\n\n        poColorTable = new GDALColorTable();\n\n        nColorCount = 1 << nBitsPerSample;\n\n        for( int iColor = nColorCount - 1; iColor >= 0; iColor-- )\n        {\n            oEntry.c1 = panRed[iColor] / 256;\n            oEntry.c2 = panGreen[iColor] / 256;\n            oEntry.c3 = panBlue[iColor] / 256;\n            oEntry.c4 = 255;\n\n            poColorTable->SetColorEntry( iColor, &oEntry );\n\n            nMaxColor = MAX(nMaxColor,panRed[iColor]);\n            nMaxColor = MAX(nMaxColor,panGreen[iColor]);\n            nMaxColor = MAX(nMaxColor,panBlue[iColor]);\n        }\n\n        // Bug 1384 - Some TIFF files are generated with color map entry\n        // values in range 0-255 instead of 0-65535 - try to handle these\n        // gracefully.\n        if( nMaxColor > 0 && nMaxColor < 256 )\n        {\n            CPLDebug( \"GTiff\", \"TIFF ColorTable seems to be improperly scaled, fixing up.\" );\n            \n            for( int iColor = nColorCount - 1; iColor >= 0; iColor-- )\n            {\n                oEntry.c1 = panRed[iColor];\n                oEntry.c2 = panGreen[iColor];\n                oEntry.c3 = panBlue[iColor];\n                oEntry.c4 = 255;\n                \n                poColorTable->SetColorEntry( iColor, &oEntry );\n            }\n        }\n    }\n    \n/* -------------------------------------------------------------------- */\n/*      Create band information objects.                                */\n/* -------------------------------------------------------------------- */\n    for( int iBand = 0; iBand < nBands; iBand++ )\n    {\n        if( bTreatAsRGBA )\n            SetBand( iBand+1, new GTiffRGBABand( this, iBand+1 ) );\n        else if( bTreatAsSplitBitmap )\n            SetBand( iBand+1, new GTiffSplitBitmapBand( this, iBand+1 ) );\n        else if( bTreatAsSplit )\n            SetBand( iBand+1, new GTiffSplitBand( this, iBand+1 ) );\n        else if( bTreatAsBitmap )\n            SetBand( iBand+1, new GTiffBitmapBand( this, iBand+1 ) );\n        else if( bTreatAsOdd )\n            SetBand( iBand+1, new GTiffOddBitsBand( this, iBand+1 ) );\n        else\n            SetBand( iBand+1, new GTiffRasterBand( this, iBand+1 ) );\n    }\n\n    if( GetRasterBand(1)->GetRasterDataType() == GDT_Unknown )\n    {\n        CPLError( CE_Failure, CPLE_NotSupported,\n                  \"Unsupported TIFF configuration.\" );\n        return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Get the transform or gcps from the GeoTIFF file.                */\n/* -------------------------------------------------------------------- */\n    if( bBaseIn )\n    {\n        char    *pszTabWKT = NULL;\n        double\t*padfTiePoints, *padfScale, *padfMatrix;\n        uint16\tnCount;\n\n        adfGeoTransform[0] = 0.0;\n        adfGeoTransform[1] = 1.0;\n        adfGeoTransform[2] = 0.0;\n        adfGeoTransform[3] = 0.0;\n        adfGeoTransform[4] = 0.0;\n        adfGeoTransform[5] = 1.0;\n    \n        if( TIFFGetField(hTIFF,TIFFTAG_GEOPIXELSCALE,&nCount,&padfScale )\n            && nCount >= 2 \n            && padfScale[0] != 0.0 && padfScale[1] != 0.0 )\n        {\n            adfGeoTransform[1] = padfScale[0];\n            adfGeoTransform[5] = - ABS(padfScale[1]);\n\n            if( TIFFGetField(hTIFF,TIFFTAG_GEOTIEPOINTS,&nCount,&padfTiePoints )\n                && nCount >= 6 )\n            {\n                adfGeoTransform[0] =\n                    padfTiePoints[3] - padfTiePoints[0] * adfGeoTransform[1];\n                adfGeoTransform[3] =\n                    padfTiePoints[4] - padfTiePoints[1] * adfGeoTransform[5];\n\n                bGeoTransformValid = TRUE;\n            }\n        }\n\n        else if( TIFFGetField(hTIFF,TIFFTAG_GEOTRANSMATRIX,&nCount,&padfMatrix ) \n                 && nCount == 16 )\n        {\n            adfGeoTransform[0] = padfMatrix[3];\n            adfGeoTransform[1] = padfMatrix[0];\n            adfGeoTransform[2] = padfMatrix[1];\n            adfGeoTransform[3] = padfMatrix[7];\n            adfGeoTransform[4] = padfMatrix[4];\n            adfGeoTransform[5] = padfMatrix[5];\n            bGeoTransformValid = TRUE;\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Otherwise try looking for a .tfw, .tifw or .wld file.           */\n/* -------------------------------------------------------------------- */\n        else\n        {\n            bGeoTransformValid = \n                GDALReadWorldFile( osFilename, NULL, adfGeoTransform );\n\n            if( !bGeoTransformValid )\n            {\n                bGeoTransformValid = \n                    GDALReadWorldFile( osFilename, \"wld\", adfGeoTransform );\n            }\n\n            if( !bGeoTransformValid )\n            {\n                int bTabFileOK = \n                    GDALReadTabFile( osFilename, adfGeoTransform, \n                                     &pszTabWKT, &nGCPCount, &pasGCPList );\n\n                if( bTabFileOK && nGCPCount == 0 )\n                    bGeoTransformValid = TRUE;\n            }\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Check for GCPs.  Note, we will allow there to be GCPs and a     */\n/*      transform in some circumstances.                                */\n/* -------------------------------------------------------------------- */\n        if( TIFFGetField(hTIFF,TIFFTAG_GEOTIEPOINTS,&nCount,&padfTiePoints )\n            && !bGeoTransformValid )\n        {\n            nGCPCount = nCount / 6;\n            pasGCPList = (GDAL_GCP *) CPLCalloc(sizeof(GDAL_GCP),nGCPCount);\n        \n            for( int iGCP = 0; iGCP < nGCPCount; iGCP++ )\n            {\n                char\tszID[32];\n\n                sprintf( szID, \"%d\", iGCP+1 );\n                pasGCPList[iGCP].pszId = CPLStrdup( szID );\n                pasGCPList[iGCP].pszInfo = CPLStrdup(\"\");\n                pasGCPList[iGCP].dfGCPPixel = padfTiePoints[iGCP*6+0];\n                pasGCPList[iGCP].dfGCPLine = padfTiePoints[iGCP*6+1];\n                pasGCPList[iGCP].dfGCPX = padfTiePoints[iGCP*6+3];\n                pasGCPList[iGCP].dfGCPY = padfTiePoints[iGCP*6+4];\n                pasGCPList[iGCP].dfGCPZ = padfTiePoints[iGCP*6+5];\n            }\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Did we find a tab file?  If so we will use it's coordinate      */\n/*      system and give it precidence.                                  */\n/* -------------------------------------------------------------------- */\n        if( pszTabWKT != NULL \n            && (pszProjection == NULL || pszProjection[0] == '\\0') )\n        {\n            CPLFree( pszProjection );\n            pszProjection = pszTabWKT;\n            pszTabWKT = NULL;\n            bLookedForProjection = TRUE;\n        }\n        \n        CPLFree( pszTabWKT );\n        bGeoTIFFInfoChanged = FALSE;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Capture some other potentially interesting information.         */\n/* -------------------------------------------------------------------- */\n    char\t*pszText, szWorkMDI[200];\n    float   fResolution;\n    uint16  nShort;\n\n    if( TIFFGetField( hTIFF, TIFFTAG_DOCUMENTNAME, &pszText ) )\n        SetMetadataItem( \"TIFFTAG_DOCUMENTNAME\",  pszText );\n\n    if( TIFFGetField( hTIFF, TIFFTAG_IMAGEDESCRIPTION, &pszText ) )\n        SetMetadataItem( \"TIFFTAG_IMAGEDESCRIPTION\", pszText );\n\n    if( TIFFGetField( hTIFF, TIFFTAG_SOFTWARE, &pszText ) )\n        SetMetadataItem( \"TIFFTAG_SOFTWARE\", pszText );\n\n    if( TIFFGetField( hTIFF, TIFFTAG_DATETIME, &pszText ) )\n        SetMetadataItem( \"TIFFTAG_DATETIME\", pszText );\n\n    if( TIFFGetField( hTIFF, TIFFTAG_ARTIST, &pszText ) )\n        SetMetadataItem( \"TIFFTAG_ARTIST\", pszText );\n\n    if( TIFFGetField( hTIFF, TIFFTAG_HOSTCOMPUTER, &pszText ) )\n        SetMetadataItem( \"TIFFTAG_HOSTCOMPUTER\", pszText );\n\n    if( TIFFGetField( hTIFF, TIFFTAG_COPYRIGHT, &pszText ) )\n        SetMetadataItem( \"TIFFTAG_COPYRIGHT\", pszText );\n\n    if( TIFFGetField( hTIFF, TIFFTAG_XRESOLUTION, &fResolution ) )\n    {\n        sprintf( szWorkMDI, \"%.8g\", fResolution );\n        SetMetadataItem( \"TIFFTAG_XRESOLUTION\", szWorkMDI );\n    }\n\n    if( TIFFGetField( hTIFF, TIFFTAG_YRESOLUTION, &fResolution ) )\n    {\n        sprintf( szWorkMDI, \"%.8g\", fResolution );\n        SetMetadataItem( \"TIFFTAG_YRESOLUTION\", szWorkMDI );\n    }\n\n    if( TIFFGetField( hTIFF, TIFFTAG_MINSAMPLEVALUE, &nShort ) )\n    {\n        sprintf( szWorkMDI, \"%d\", nShort );\n        SetMetadataItem( \"TIFFTAG_MINSAMPLEVALUE\", szWorkMDI );\n    }\n\n    if( TIFFGetField( hTIFF, TIFFTAG_MAXSAMPLEVALUE, &nShort ) )\n    {\n        sprintf( szWorkMDI, \"%d\", nShort );\n        SetMetadataItem( \"TIFFTAG_MAXSAMPLEVALUE\", szWorkMDI );\n    }\n\n    if( TIFFGetField( hTIFF, TIFFTAG_RESOLUTIONUNIT, &nShort ) )\n    {\n        if( nShort == RESUNIT_NONE )\n            sprintf( szWorkMDI, \"%d (unitless)\", nShort );\n        else if( nShort == RESUNIT_INCH )\n            sprintf( szWorkMDI, \"%d (pixels/inch)\", nShort );\n        else if( nShort == RESUNIT_CENTIMETER )\n            sprintf( szWorkMDI, \"%d (pixels/cm)\", nShort );\n        else\n            sprintf( szWorkMDI, \"%d\", nShort );\n        SetMetadataItem( \"TIFFTAG_RESOLUTIONUNIT\", szWorkMDI );\n    }\n\n    if( nCompression == COMPRESSION_NONE )\n        /* no compression tag */;\n    else if( nCompression == COMPRESSION_CCITTRLE )\n        SetMetadataItem( \"COMPRESSION\", \"CCITTRLE\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_CCITTFAX3 )\n        SetMetadataItem( \"COMPRESSION\", \"CCITTFAX3\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_CCITTFAX4 )\n        SetMetadataItem( \"COMPRESSION\", \"CCITTFAX4\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_LZW )\n        SetMetadataItem( \"COMPRESSION\", \"LZW\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_OJPEG )\n        SetMetadataItem( \"COMPRESSION\", \"OJPEG\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_JPEG )\n    {  \n        if ( nPhotometric == PHOTOMETRIC_YCBCR )\n            SetMetadataItem( \"COMPRESSION\", \"YCbCr JPEG\", \"IMAGE_STRUCTURE\" );\n        else\n            SetMetadataItem( \"COMPRESSION\", \"JPEG\", \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_NEXT )\n        SetMetadataItem( \"COMPRESSION\", \"NEXT\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_CCITTRLEW )\n        SetMetadataItem( \"COMPRESSION\", \"CCITTRLEW\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_PACKBITS )\n        SetMetadataItem( \"COMPRESSION\", \"PACKBITS\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_THUNDERSCAN )\n        SetMetadataItem( \"COMPRESSION\", \"THUNDERSCAN\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_PIXARFILM )\n        SetMetadataItem( \"COMPRESSION\", \"PIXARFILM\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_PIXARLOG )\n        SetMetadataItem( \"COMPRESSION\", \"PIXARLOG\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_DEFLATE )\n        SetMetadataItem( \"COMPRESSION\", \"DEFLATE\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_ADOBE_DEFLATE )\n        SetMetadataItem( \"COMPRESSION\", \"DEFLATE\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_DCS )\n        SetMetadataItem( \"COMPRESSION\", \"DCS\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_JBIG )\n        SetMetadataItem( \"COMPRESSION\", \"JBIG\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_SGILOG )\n        SetMetadataItem( \"COMPRESSION\", \"SGILOG\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_SGILOG24 )\n        SetMetadataItem( \"COMPRESSION\", \"SGILOG24\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_JP2000 )\n        SetMetadataItem( \"COMPRESSION\", \"JP2000\", \"IMAGE_STRUCTURE\" );\n    else\n    {\n        CPLString oComp;\n        SetMetadataItem( \"COMPRESSION\", \n                         (const char *) oComp.Printf( \"%d\", nCompression));\n    }\n\n    if( nPlanarConfig == PLANARCONFIG_CONTIG && nBands != 1 )\n        SetMetadataItem( \"INTERLEAVE\", \"PIXEL\", \"IMAGE_STRUCTURE\" );\n    else\n        SetMetadataItem( \"INTERLEAVE\", \"BAND\", \"IMAGE_STRUCTURE\" );\n\n    if(  (GetRasterBand(1)->GetRasterDataType() == GDT_Byte   && nBitsPerSample != 8 ) ||\n         (GetRasterBand(1)->GetRasterDataType() == GDT_UInt16 && nBitsPerSample != 16) ||\n         (GetRasterBand(1)->GetRasterDataType() == GDT_UInt32 && nBitsPerSample != 32) )\n    {\n        for (int i = 0; i < nBands; ++i)\n            GetRasterBand(i+1)->SetMetadataItem( \"NBITS\", \n                                                 CPLString().Printf( \"%d\", (int)nBitsPerSample ),\n                                                 \"IMAGE_STRUCTURE\" );\n    }\n        \n    if( bMinIsWhite )\n        SetMetadataItem( \"MINISWHITE\", \"YES\", \"IMAGE_STRUCTURE\" );\n\n    if( TIFFGetField( hTIFF, TIFFTAG_GDAL_METADATA, &pszText ) )\n    {\n        CPLXMLNode *psRoot = CPLParseXMLString( pszText );\n        CPLXMLNode *psItem = NULL;\n\n        if( psRoot != NULL && psRoot->eType == CXT_Element\n            && EQUAL(psRoot->pszValue,\"GDALMetadata\") )\n            psItem = psRoot->psChild;\n\n        for( ; psItem != NULL; psItem = psItem->psNext )\n        {\n            const char *pszKey, *pszValue, *pszRole, *pszDomain; \n            char *pszUnescapedValue;\n            int nBand, bIsXML = FALSE;\n\n            if( psItem->eType != CXT_Element\n                || !EQUAL(psItem->pszValue,\"Item\") )\n                continue;\n\n            pszKey = CPLGetXMLValue( psItem, \"name\", NULL );\n            pszValue = CPLGetXMLValue( psItem, NULL, NULL );\n            nBand = atoi(CPLGetXMLValue( psItem, \"sample\", \"-1\" )) + 1;\n            pszRole = CPLGetXMLValue( psItem, \"role\", \"\" );\n            pszDomain = CPLGetXMLValue( psItem, \"domain\", \"\" );\n                \n            if( pszKey == NULL || pszValue == NULL )\n                continue;\n\n            if( EQUALN(pszDomain,\"xml:\",4) )\n                bIsXML = TRUE;\n\n            pszUnescapedValue = CPLUnescapeString( pszValue, NULL, \n                                                   CPLES_XML );\n            if( nBand == 0 )\n            {\n                if( bIsXML )\n                {\n                    char *apszMD[2] = { pszUnescapedValue, NULL };\n                    SetMetadata( apszMD, pszDomain );\n                }\n                else\n                    SetMetadataItem( pszKey, pszUnescapedValue, pszDomain );\n            }\n            else\n            {\n                GDALRasterBand *poBand = GetRasterBand(nBand);\n                if( poBand != NULL )\n                {\n                    if( EQUAL(pszRole,\"scale\") )\n                        poBand->SetScale( atof(pszUnescapedValue) );\n                    else if( EQUAL(pszRole,\"offset\") )\n                        poBand->SetOffset( atof(pszUnescapedValue) );\n                    else if( EQUAL(pszRole,\"unittype\") )\n                        poBand->SetUnitType( pszUnescapedValue );\n                    else\n                    {\n                        if( bIsXML )\n                        {\n                            char *apszMD[2] = { pszUnescapedValue, NULL };\n                            poBand->SetMetadata( apszMD, pszDomain );\n                        }\n                        else\n                            poBand->SetMetadataItem(pszKey,pszUnescapedValue,\n                                                    pszDomain );\n                    }\n                }\n            }\n            CPLFree( pszUnescapedValue );\n        }\n\n        CPLDestroyXMLNode( psRoot );\n    }\n\n    bMetadataChanged = FALSE;\n\n/* -------------------------------------------------------------------- */\n/*      Check for RPC metadata in an RPB file.                          */\n/* -------------------------------------------------------------------- */\n    if( bBaseIn )\n    {\n        char **papszRPCMD = GDALLoadRPBFile( osFilename, NULL );\n        \n        if( papszRPCMD != NULL )\n        {\n            oGTiffMDMD.SetMetadata( papszRPCMD, \"RPC\" );\n            CSLDestroy( papszRPCMD );\n            bMetadataChanged = FALSE;\n        }\n        else\n            ReadRPCTag();\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Check for RPC metadata in an RPB file.                          */\n/* -------------------------------------------------------------------- */\n    if( bBaseIn )\n    {\n        char **papszIMDMD = GDALLoadIMDFile( osFilename, NULL );\n\n        if( papszIMDMD != NULL )\n        {\n            oGTiffMDMD.SetMetadata( papszIMDMD, \"IMD\" );\n            CSLDestroy( papszIMDMD );\n            bMetadataChanged = FALSE;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Check for NODATA                                                */\n/* -------------------------------------------------------------------- */\n    if( TIFFGetField( hTIFF, TIFFTAG_GDAL_NODATA, &pszText ) )\n    {\n        bNoDataSet = TRUE;\n        dfNoDataValue = atof( pszText );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If this is a \"base\" raster, we should scan for any              */\n/*      associated overviews, internal mask bands and subdatasets.      */\n/* -------------------------------------------------------------------- */\n    if( bBase )\n    {\n        char **papszSubdatasets = NULL;\n        int  iDirIndex = 0;\n\n        FlushDirectory();  \n        while( !TIFFLastDirectory( hTIFF ) \n               && (iDirIndex == 0 || TIFFReadDirectory( hTIFF ) != 0) )\n        {\n            toff_t\tnThisDir = TIFFCurrentDirOffset(hTIFF);\n            uint32\tnSubType = 0;\n\n            *ppoActiveDSRef = NULL; // our directory no longer matches this ds\n            \n            iDirIndex++;\n\n            if( !TIFFGetField(hTIFF, TIFFTAG_SUBFILETYPE, &nSubType) )\n                nSubType = 0;\n\n            /* Embedded overview of the main image */\n            if ((nSubType & FILETYPE_REDUCEDIMAGE) != 0 &&\n                (nSubType & FILETYPE_MASK) == 0 &&\n                iDirIndex != 1 )\n            {\n                GTiffDataset\t*poODS;\n                \n                poODS = new GTiffDataset();\n                if( poODS->OpenOffset( hTIFF, ppoActiveDSRef, nThisDir, FALSE, \n                                       eAccess ) != CE_None \n                    || poODS->GetRasterCount() != GetRasterCount() )\n                {\n                    delete poODS;\n                }\n                else\n                {\n                    CPLDebug( \"GTiff\", \"Opened %dx%d overview.\\n\", \n                              poODS->GetRasterXSize(), poODS->GetRasterYSize());\n                    nOverviewCount++;\n                    papoOverviewDS = (GTiffDataset **)\n                        CPLRealloc(papoOverviewDS, \n                                   nOverviewCount * (sizeof(void*)));\n                    papoOverviewDS[nOverviewCount-1] = poODS;\n                    poODS->poBaseDS = this;\n                }\n            }\n            \n            /* Embedded mask of the main image */\n            else if ((nSubType & FILETYPE_MASK) != 0 &&\n                     (nSubType & FILETYPE_REDUCEDIMAGE) == 0 &&\n                     poMaskDS == NULL )\n            {\n                poMaskDS = new GTiffDataset();\n                \n                /* The TIFF6 specification - page 37 - only allows 1 SamplesPerPixel and 1 BitsPerSample\n                   Here we support either 1 or 8 bit per sample\n                   and we support either 1 sample per pixel or as many samples as in the main image\n                   We don't check the value of the PhotometricInterpretation tag, which should be\n                   set to \"Transparency mask\" (4) according to the specification (page 36)\n                   ... But the TIFF6 specification allows image masks to have a higher resolution than\n                   the main image, what we don't support here\n                */\n\n                if( poMaskDS->OpenOffset( hTIFF, ppoActiveDSRef, nThisDir, \n                                          FALSE, eAccess ) != CE_None \n                    || poMaskDS->GetRasterCount() == 0\n                    || !(poMaskDS->GetRasterCount() == 1 || poMaskDS->GetRasterCount() == GetRasterCount())\n                    || poMaskDS->GetRasterXSize() != GetRasterXSize()\n                    || poMaskDS->GetRasterYSize() != GetRasterYSize()\n                    || poMaskDS->GetRasterBand(1)->GetRasterDataType() != GDT_Byte)\n                {\n                    delete poMaskDS;\n                    poMaskDS = NULL;\n                }\n                else\n                {\n                    CPLDebug( \"GTiff\", \"Opened band mask.\\n\");\n                    poMaskDS->poBaseDS = this;\n                }\n            }\n            \n            /* Embedded mask of an overview */\n            /* The TIFF6 specification allows the combination of the FILETYPE_xxxx masks */\n            else if (nSubType & (FILETYPE_REDUCEDIMAGE | FILETYPE_MASK))\n            {\n                GTiffDataset* poDS = new GTiffDataset();\n                if( poDS->OpenOffset( hTIFF, ppoActiveDSRef, nThisDir, FALSE, \n                                      eAccess ) != CE_None\n                    || poDS->GetRasterCount() == 0\n                    || poDS->GetRasterBand(1)->GetRasterDataType() != GDT_Byte)\n                {\n                    delete poDS;\n                }\n                else\n                {\n                    int i;\n                    for(i=0;i<nOverviewCount;i++)\n                    {\n                        if (((GTiffDataset*)papoOverviewDS[i])->poMaskDS == NULL &&\n                            poDS->GetRasterXSize() == papoOverviewDS[i]->GetRasterXSize() &&\n                            poDS->GetRasterYSize() == papoOverviewDS[i]->GetRasterYSize() &&\n                            (poDS->GetRasterCount() == 1 || poDS->GetRasterCount() == GetRasterCount()))\n                        {\n                            CPLDebug( \"GTiff\", \"Opened band mask for %dx%d overview.\\n\",\n                                      poDS->GetRasterXSize(), poDS->GetRasterYSize());\n                            ((GTiffDataset*)papoOverviewDS[i])->poMaskDS = poDS;\n                            poDS->poBaseDS = this;\n                            break;\n                        }\n                    }\n                    if (i == nOverviewCount)\n                    {\n                        delete poDS;\n                    }\n                }\n            }\n            else if( nSubType == 0 ) {\n                CPLString osName, osDesc;\n                uint32\tnXSize, nYSize;\n                uint16  nSPP;\n\n                TIFFGetField( hTIFF, TIFFTAG_IMAGEWIDTH, &nXSize );\n                TIFFGetField( hTIFF, TIFFTAG_IMAGELENGTH, &nYSize );\n                if( !TIFFGetField(hTIFF, TIFFTAG_SAMPLESPERPIXEL, &nSPP ) )\n                    nSPP = 1;\n\n                osName.Printf( \"SUBDATASET_%d_NAME=GTIFF_DIR:%d:%s\", \n                               iDirIndex, iDirIndex, osFilename.c_str() );\n                osDesc.Printf( \"SUBDATASET_%d_DESC=Page %d (%dP x %dL x %dB)\", \n                               iDirIndex, iDirIndex, \n                               (int)nXSize, (int)nYSize, nSPP );\n\n                papszSubdatasets = \n                    CSLAddString( papszSubdatasets, osName );\n                papszSubdatasets = \n                    CSLAddString( papszSubdatasets, osDesc );\n            }\n\n            // Make sure we are stepping from the expected directory regardless\n            // of churn done processing the above.\n            if( TIFFCurrentDirOffset(hTIFF) != nThisDir )\n                TIFFSetSubDirectory( hTIFF, nThisDir );\n            *ppoActiveDSRef = NULL;\n        }\n\n        /* If we have a mask for the main image, loop over the overviews, and if they */\n        /* have a mask, let's set this mask as an overview of the main mask... */\n        if (poMaskDS != NULL)\n        {\n            int i;\n            for(i=0;i<nOverviewCount;i++)\n            {\n                if (((GTiffDataset*)papoOverviewDS[i])->poMaskDS != NULL)\n                {\n                    poMaskDS->nOverviewCount++;\n                    poMaskDS->papoOverviewDS = (GTiffDataset **)\n                        CPLRealloc(poMaskDS->papoOverviewDS, \n                                poMaskDS->nOverviewCount * (sizeof(void*)));\n                    poMaskDS->papoOverviewDS[poMaskDS->nOverviewCount-1] =\n                            ((GTiffDataset*)papoOverviewDS[i])->poMaskDS;\n                }\n            }\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Only keep track of subdatasets if we have more than one         */\n/*      subdataset (pair).                                              */\n/* -------------------------------------------------------------------- */\n        if( CSLCount(papszSubdatasets) > 2 )\n        {\n            oGTiffMDMD.SetMetadata( papszSubdatasets, \"SUBDATASETS\" );\n        }\n        CSLDestroy( papszSubdatasets );\n    }\n\n    return( CE_None );\n}\n\nstatic int GTiffGetZLevel(char** papszOptions)\n{\n    int nZLevel = -1;\n    const char* pszValue = CSLFetchNameValue( papszOptions, \"ZLEVEL\" );\n    if( pszValue  != NULL )\n    {\n        nZLevel =  atoi( pszValue );\n        if (!(nZLevel >= 1 && nZLevel <= 9))\n        {\n            CPLError( CE_Warning, CPLE_IllegalArg, \n                    \"ZLEVEL=%s value not recognised, ignoring.\",\n                    pszValue );\n            nZLevel = -1;\n        }\n    }\n    return nZLevel;\n}\n\nstatic int GTiffGetJpegQuality(char** papszOptions)\n{\n    int nJpegQuality = -1;\n    const char* pszValue = CSLFetchNameValue( papszOptions, \"JPEG_QUALITY\" );\n    if( pszValue  != NULL )\n    {\n        nJpegQuality = atoi( pszValue );\n        if (!(nJpegQuality >= 1 && nJpegQuality <= 100))\n        {\n            CPLError( CE_Warning, CPLE_IllegalArg, \n                    \"JPEG_QUALITY=%s value not recognised, ignoring.\",\n                    pszValue );\n            nJpegQuality = -1;\n        }\n    }\n    return nJpegQuality;\n}\n\n/************************************************************************/\n/*                            GTiffCreate()                             */\n/*                                                                      */\n/*      Shared functionality between GTiffDataset::Create() and         */\n/*      GTiffCreateCopy() for creating TIFF file based on a set of      */\n/*      options and a configuration.                                    */\n/************************************************************************/\n\nTIFF *GTiffDataset::CreateLL( const char * pszFilename,\n                              int nXSize, int nYSize, int nBands,\n                              GDALDataType eType,\n                              char **papszParmList )\n\n{\n    TIFF\t\t*hTIFF;\n    int                 nBlockXSize = 0, nBlockYSize = 0;\n    int                 bTiled = FALSE;\n    uint16              nCompression = COMPRESSION_NONE;\n    int                 nPredictor = 1, nJpegQuality = -1, nZLevel = -1;\n    uint16              nSampleFormat;\n    int\t\t\tnPlanar;\n    const char          *pszValue;\n    const char          *pszProfile;\n    int                 bCreateBigTIFF = FALSE;\n\n    GTiffOneTimeInit();\n\n/* -------------------------------------------------------------------- */\n/*      Blow on a few errors.                                           */\n/* -------------------------------------------------------------------- */\n    if( nXSize < 1 || nYSize < 1 || nBands < 1 )\n    {\n        CPLError( CE_Failure, CPLE_AppDefined, \n                  \"Attempt to create %dx%dx%d TIFF file, but width, height and bands\\n\"\n                  \"must be positive.\", \n                  nXSize, nYSize, nBands );\n\n        return NULL;\n    }\n\n    if (nBands > 65535)\n    {\n        CPLError( CE_Failure, CPLE_AppDefined, \n                  \"Attempt to create %dx%dx%d TIFF file, but bands\\n\"\n                  \"must be lesser or equal to 65535.\", \n                  nXSize, nYSize, nBands );\n\n        return NULL;\n    }\n\n/* -------------------------------------------------------------------- */\n/*\tSetup values based on options.\t\t\t\t\t*/\n/* -------------------------------------------------------------------- */\n    pszProfile = CSLFetchNameValue(papszParmList,\"PROFILE\");\n    if( pszProfile == NULL )\n        pszProfile = \"GDALGeoTIFF\";\n\n    if( CSLFetchBoolean( papszParmList, \"TILED\", FALSE ) )\n        bTiled = TRUE;\n\n    pszValue = CSLFetchNameValue(papszParmList,\"BLOCKXSIZE\");\n    if( pszValue != NULL )\n        nBlockXSize = atoi( pszValue );\n\n    pszValue = CSLFetchNameValue(papszParmList,\"BLOCKYSIZE\");\n    if( pszValue != NULL )\n        nBlockYSize = atoi( pszValue );\n\n    pszValue = CSLFetchNameValue(papszParmList,\"INTERLEAVE\");\n    if( pszValue != NULL )\n    {\n        if( EQUAL( pszValue, \"PIXEL\" ) )\n            nPlanar = PLANARCONFIG_CONTIG;\n        else if( EQUAL( pszValue, \"BAND\" ) )\n            nPlanar = PLANARCONFIG_SEPARATE;\n        else\n        {\n            CPLError( CE_Failure, CPLE_AppDefined, \n                      \"INTERLEAVE=%s unsupported, value must be PIXEL or BAND.\",\n                      pszValue );\n            return NULL;\n        }\n    }\n    else \n    {\n        nPlanar = PLANARCONFIG_CONTIG;\n    }\n\n    pszValue = CSLFetchNameValue( papszParmList, \"COMPRESS\" );\n    if( pszValue  != NULL )\n    {\n        if( EQUAL( pszValue, \"NONE\" ) )\n            nCompression = COMPRESSION_NONE;\n        else if( EQUAL( pszValue, \"JPEG\" ) )\n            nCompression = COMPRESSION_JPEG;\n        else if( EQUAL( pszValue, \"LZW\" ) )\n            nCompression = COMPRESSION_LZW;\n        else if( EQUAL( pszValue, \"PACKBITS\" ))\n            nCompression = COMPRESSION_PACKBITS;\n        else if( EQUAL( pszValue, \"DEFLATE\" ) || EQUAL( pszValue, \"ZIP\" ))\n            nCompression = COMPRESSION_ADOBE_DEFLATE;\n        else if( EQUAL( pszValue, \"FAX3\" )\n                 || EQUAL( pszValue, \"CCITTFAX3\" ))\n            nCompression = COMPRESSION_CCITTFAX3;\n        else if( EQUAL( pszValue, \"FAX4\" )\n                 || EQUAL( pszValue, \"CCITTFAX4\" ))\n            nCompression = COMPRESSION_CCITTFAX4;\n        else if( EQUAL( pszValue, \"CCITTRLE\" ) )\n            nCompression = COMPRESSION_CCITTRLE;\n        else\n            CPLError( CE_Warning, CPLE_IllegalArg, \n                      \"COMPRESS=%s value not recognised, ignoring.\",\n                      pszValue );\n\n#if defined(TIFFLIB_VERSION) && TIFFLIB_VERSION > 20031007 /* 3.6.0 */\n        if (nCompression != COMPRESSION_NONE &&\n            !TIFFIsCODECConfigured(nCompression))\n        {\n            CPLError( CE_Failure, CPLE_AppDefined,\n                    \"Cannot create TIFF file due to missing codec for %s.\", pszValue );\n            return NULL;\n        }\n#endif\n    }\n\n    pszValue = CSLFetchNameValue( papszParmList, \"PREDICTOR\" );\n    if( pszValue  != NULL )\n        nPredictor =  atoi( pszValue );\n\n    nZLevel = GTiffGetZLevel(papszParmList);\n\n    nJpegQuality = GTiffGetJpegQuality(papszParmList);\n\n/* -------------------------------------------------------------------- */\n/*      Compute the uncompressed size.                                  */\n/* -------------------------------------------------------------------- */\n    double  dfUncompressedImageSize;\n\n    dfUncompressedImageSize = \n        nXSize * ((double)nYSize) * nBands * (GDALGetDataTypeSize(eType)/8);\n\n    if( nCompression == COMPRESSION_NONE \n        && dfUncompressedImageSize > 4200000000.0 )\n    {\n#ifndef BIGTIFF_SUPPORT\n        CPLError( CE_Failure, CPLE_NotSupported, \n                  \"A %d pixels x %d lines x %d bands %s image would be larger than 4GB\\n\"\n                  \"but this is the largest size a TIFF can be, and BigTIFF is unavailable.\\n\"\n                  \"Creation failed.\",\n                  nXSize, nYSize, nBands, GDALGetDataTypeName(eType) );\n        return NULL;\n#endif\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Should the file be created as a bigtiff file?                   */\n/* -------------------------------------------------------------------- */\n    const char *pszBIGTIFF = CSLFetchNameValue(papszParmList, \"BIGTIFF\");\n\n    if( pszBIGTIFF == NULL )\n        pszBIGTIFF = \"IF_NEEDED\";\n\n    if( EQUAL(pszBIGTIFF,\"IF_NEEDED\") )\n    {\n        if( nCompression == COMPRESSION_NONE \n            && dfUncompressedImageSize > 4200000000.0 )\n            bCreateBigTIFF = TRUE;\n    }\n    else if( EQUAL(pszBIGTIFF,\"IF_SAFER\") )\n    {\n        if( dfUncompressedImageSize > 2000000000.0 )\n            bCreateBigTIFF = TRUE;\n    }\n\n    else\n    {\n        bCreateBigTIFF = CSLTestBoolean( pszBIGTIFF );\n        if (!bCreateBigTIFF && nCompression == COMPRESSION_NONE &&\n             dfUncompressedImageSize > 4200000000.0 )\n        {\n            CPLError( CE_Failure, CPLE_NotSupported, \n                \"The TIFF file will be larger than 4GB, so BigTIFF is necessary.\\n\"\n                \"Creation failed.\");\n            return NULL;\n        }\n    }\n\n#ifndef BIGTIFF_SUPPORT\n    if( bCreateBigTIFF )\n    {\n        CPLError( CE_Warning, CPLE_NotSupported,\n                  \"BigTIFF requested, but GDAL built without BigTIFF\\n\"\n                  \"enabled libtiff, request ignored.\" );\n        bCreateBigTIFF = FALSE;\n    }\n#endif\n\n    if( bCreateBigTIFF )\n        CPLDebug( \"GTiff\", \"File being created as a BigTIFF.\" );\n    \n/* -------------------------------------------------------------------- */\n/*      Check if the user wishes a particular endianness                */\n/* -------------------------------------------------------------------- */\n\n    int eEndianness = ENDIANNESS_NATIVE;\n    pszValue = CSLFetchNameValue(papszParmList, \"ENDIANNESS\");\n    if ( pszValue == NULL )\n        pszValue = CPLGetConfigOption( \"GDAL_TIFF_ENDIANNESS\", NULL );\n    if ( pszValue != NULL )\n    {\n        if (EQUAL(pszValue, \"LITTLE\"))\n            eEndianness = ENDIANNESS_LITTLE;\n        else if (EQUAL(pszValue, \"BIG\"))\n            eEndianness = ENDIANNESS_BIG;\n        else if (EQUAL(pszValue, \"INVERTED\"))\n        {\n#ifdef CPL_LSB\n            eEndianness = ENDIANNESS_BIG;\n#else\n            eEndianness = ENDIANNESS_LITTLE;\n#endif\n        }\n        else if (!EQUAL(pszValue, \"NATIVE\"))\n        {\n            CPLError( CE_Warning, CPLE_NotSupported,\n                      \"ENDIANNESS=%s not supported. Defaulting to NATIVE\", pszValue );\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Try opening the dataset.                                        */\n/* -------------------------------------------------------------------- */\n\n    char szOpeningFlag[5];\n    strcpy(szOpeningFlag, \"w+\");\n    if (bCreateBigTIFF)\n        strcat(szOpeningFlag, \"8\");\n    if (eEndianness == ENDIANNESS_BIG)\n        strcat(szOpeningFlag, \"b\");\n    else if (eEndianness == ENDIANNESS_LITTLE)\n        strcat(szOpeningFlag, \"l\");\n    hTIFF = VSI_TIFFOpen( pszFilename, szOpeningFlag );\n    if( hTIFF == NULL )\n    {\n        if( CPLGetLastErrorNo() == 0 )\n            CPLError( CE_Failure, CPLE_OpenFailed,\n                      \"Attempt to create new tiff file `%s'\\n\"\n                      \"failed in XTIFFOpen().\\n\",\n                      pszFilename );\n        return NULL;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      How many bits per sample?  We have a special case if NBITS      */\n/*      specified for GDT_Byte, GDT_UInt16, GDT_UInt32.                 */\n/* -------------------------------------------------------------------- */\n    int nBitsPerSample = GDALGetDataTypeSize(eType);\n    if (CSLFetchNameValue(papszParmList, \"NBITS\") != NULL)\n    {\n        int nMinBits = 0, nMaxBits = 0;\n        nBitsPerSample = atoi(CSLFetchNameValue(papszParmList, \"NBITS\"));\n        if( eType == GDT_Byte  )\n        {\n            nMinBits = 1;\n            nMaxBits = 8;\n        }\n        else if( eType == GDT_UInt16 )\n        {\n            nMinBits = 9;\n            nMaxBits = 16;\n        }\n        else if( eType == GDT_UInt32  )\n        {\n            nMinBits = 17;\n            nMaxBits = 32;\n        }\n        else\n        {\n            CPLError(CE_Warning, CPLE_NotSupported,\n                     \"NBITS is not supported for data type %s\",\n                     GDALGetDataTypeName(eType));\n            nBitsPerSample = GDALGetDataTypeSize(eType);\n        }\n\n        if (nMinBits != 0)\n        {\n            if (nBitsPerSample < nMinBits)\n            {\n                CPLError(CE_Warning, CPLE_AppDefined,\n                         \"NBITS=%d is invalid for data type %s. Using NBITS=%d\",\n                         nBitsPerSample, GDALGetDataTypeName(eType), nMinBits);\n                nBitsPerSample = nMinBits;\n            }\n            else if (nBitsPerSample > nMaxBits)\n            {\n                CPLError(CE_Warning, CPLE_AppDefined,\n                         \"NBITS=%d is invalid for data type %s. Using NBITS=%d\",\n                         nBitsPerSample, GDALGetDataTypeName(eType), nMaxBits);\n                nBitsPerSample = nMaxBits;\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Do we have a custom pixel type (just used for signed byte now). */\n/* -------------------------------------------------------------------- */\n    const char *pszPixelType = CSLFetchNameValue( papszParmList, \"PIXELTYPE\" );\n    if( pszPixelType == NULL )\n        pszPixelType = \"\";\n\n/* -------------------------------------------------------------------- */\n/*      Setup some standard flags.                                      */\n/* -------------------------------------------------------------------- */\n    TIFFSetField( hTIFF, TIFFTAG_IMAGEWIDTH, nXSize );\n    TIFFSetField( hTIFF, TIFFTAG_IMAGELENGTH, nYSize );\n    TIFFSetField( hTIFF, TIFFTAG_BITSPERSAMPLE, nBitsPerSample );\n\n    if( (eType == GDT_Byte && EQUAL(pszPixelType,\"SIGNEDBYTE\"))\n        || eType == GDT_Int16 || eType == GDT_Int32 )\n        nSampleFormat = SAMPLEFORMAT_INT;\n    else if( eType == GDT_CInt16 || eType == GDT_CInt32 )\n        nSampleFormat = SAMPLEFORMAT_COMPLEXINT;\n    else if( eType == GDT_Float32 || eType == GDT_Float64 )\n        nSampleFormat = SAMPLEFORMAT_IEEEFP;\n    else if( eType == GDT_CFloat32 || eType == GDT_CFloat64 )\n        nSampleFormat = SAMPLEFORMAT_COMPLEXIEEEFP;\n    else\n        nSampleFormat = SAMPLEFORMAT_UINT;\n\n    TIFFSetField( hTIFF, TIFFTAG_SAMPLEFORMAT, nSampleFormat );\n    TIFFSetField( hTIFF, TIFFTAG_SAMPLESPERPIXEL, nBands );\n    TIFFSetField( hTIFF, TIFFTAG_PLANARCONFIG, nPlanar );\n\n/* -------------------------------------------------------------------- */\n/*      Setup Photometric Interpretation. Take this value from the user */\n/*      passed option or guess correct value otherwise.                 */\n/* -------------------------------------------------------------------- */\n    int nSamplesAccountedFor = 1;\n    int bForceColorTable = FALSE;\n\n    pszValue = CSLFetchNameValue(papszParmList,\"PHOTOMETRIC\");\n    if( pszValue != NULL )\n    {\n        if( EQUAL( pszValue, \"MINISBLACK\" ) )\n            TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK );\n        else if( EQUAL( pszValue, \"MINISWHITE\" ) )\n            TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISWHITE );\n        else if( EQUAL( pszValue, \"PALETTE\" ))\n        {\n            TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_PALETTE );\n            nSamplesAccountedFor = 1;\n            bForceColorTable = TRUE;\n        }\n        else if( EQUAL( pszValue, \"RGB\" ))\n        {\n            TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB );\n            nSamplesAccountedFor = 3;\n        }\n        else if( EQUAL( pszValue, \"CMYK\" ))\n        {\n            TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_SEPARATED );\n            nSamplesAccountedFor = 4;\n        }\n        else if( EQUAL( pszValue, \"YCBCR\" ))\n        {\n            /* Because of subsampling, setting YCBCR without JPEG compression leads */\n            /* to a crash currently. Would need to make GTiffRasterBand::IWriteBlock() */\n            /* aware of subsampling so that it doesn't overrun buffer size returned */\n            /* by libtiff */\n            if ( nCompression != COMPRESSION_JPEG )\n            {\n                CPLError(CE_Failure, CPLE_NotSupported,\n                         \"Currently, PHOTOMETRIC=YCBCR requires COMPRESS=JPEG\");\n                XTIFFClose(hTIFF);\n                return NULL;\n            }\n\n            if ( nPlanar == PLANARCONFIG_SEPARATE )\n            {\n                CPLError(CE_Failure, CPLE_NotSupported,\n                         \"PHOTOMETRIC=YCBCR requires INTERLEAVE=PIXEL\");\n                XTIFFClose(hTIFF);\n                return NULL;\n            }\n\n            /* YCBCR strictly requires 3 bands. Not less, not more */\n            /* Issue an explicit error message as libtiff one is a bit cryptic : */\n            /* TIFFVStripSize64:Invalid td_samplesperpixel value */\n            if ( nBands != 3 )\n            {\n                CPLError(CE_Failure, CPLE_NotSupported,\n                         \"PHOTOMETRIC=YCBCR requires a source raster with only 3 bands (RGB)\");\n                XTIFFClose(hTIFF);\n                return NULL;\n            }\n\n            TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR );\n            nSamplesAccountedFor = 3;\n        }\n        else if( EQUAL( pszValue, \"CIELAB\" ))\n        {\n            TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_CIELAB );\n            nSamplesAccountedFor = 3;\n        }\n        else if( EQUAL( pszValue, \"ICCLAB\" ))\n        {\n            TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_ICCLAB );\n            nSamplesAccountedFor = 3;\n        }\n        else if( EQUAL( pszValue, \"ITULAB\" ))\n        {\n            TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_ITULAB );\n            nSamplesAccountedFor = 3;\n        }\n        else\n        {\n            CPLError( CE_Warning, CPLE_IllegalArg, \n                      \"PHOTOMETRIC=%s value not recognised, ignoring.\\n\"\n                      \"Set the Photometric Interpretation as MINISBLACK.\", \n                      pszValue );\n            TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK );\n        }\n\n        if ( nBands < nSamplesAccountedFor )\n        {\n            CPLError( CE_Warning, CPLE_IllegalArg, \n                      \"PHOTOMETRIC=%s value does not correspond to number \"\n                      \"of bands (%d), ignoring.\\n\"\n                      \"Set the Photometric Interpretation as MINISBLACK.\", \n                      pszValue, nBands );\n            TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK );\n        }\n    }\n    else\n    {\n        /* \n         * If image contains 3 or 4 bands and datatype is Byte then we will\n         * assume it is RGB. In all other cases assume it is MINISBLACK.\n         */\n        if( nBands == 3 && eType == GDT_Byte )\n        {\n            TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB );\n            nSamplesAccountedFor = 3;\n        }\n        else if( nBands == 4 && eType == GDT_Byte )\n        {\n            uint16 v[1];\n\n            v[0] = EXTRASAMPLE_ASSOCALPHA;\n            TIFFSetField(hTIFF, TIFFTAG_EXTRASAMPLES, 1, v);\n            TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB );\n            nSamplesAccountedFor = 4;\n        }\n        else\n        {\n            TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK );\n            nSamplesAccountedFor = 1;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If there are extra samples, we need to mark them with an        */\n/*      appropriate extrasamples definition here.                       */\n/* -------------------------------------------------------------------- */\n    if( nBands > nSamplesAccountedFor )\n    {\n        uint16 *v;\n        int i;\n        int nExtraSamples = nBands - nSamplesAccountedFor;\n\n        v = (uint16 *) CPLMalloc( sizeof(uint16) * nExtraSamples );\n\n        if( CSLFetchBoolean(papszParmList,\"ALPHA\",FALSE) )\n            v[0] = EXTRASAMPLE_ASSOCALPHA;\n        else\n            v[0] = EXTRASAMPLE_UNSPECIFIED;\n            \n        for( i = 1; i < nExtraSamples; i++ )\n            v[i] = EXTRASAMPLE_UNSPECIFIED;\n\n        TIFFSetField(hTIFF, TIFFTAG_EXTRASAMPLES, nExtraSamples, v );\n        \n        CPLFree(v);\n    }\n    \n    /* Set the compression method before asking the default strip size */\n    /* This is usefull when translating to a JPEG-In-TIFF file where */\n    /* the default strip size is 8 or 16 depending on the photometric value */\n    TIFFSetField( hTIFF, TIFFTAG_COMPRESSION, nCompression );\n\n/* -------------------------------------------------------------------- */\n/*      Setup tiling/stripping flags.                                   */\n/* -------------------------------------------------------------------- */\n    if( bTiled )\n    {\n        if( nBlockXSize == 0 )\n            nBlockXSize = 256;\n        \n        if( nBlockYSize == 0 )\n            nBlockYSize = 256;\n\n        if (!TIFFSetField( hTIFF, TIFFTAG_TILEWIDTH, nBlockXSize ) ||\n            !TIFFSetField( hTIFF, TIFFTAG_TILELENGTH, nBlockYSize ))\n        {\n            XTIFFClose(hTIFF);\n            return NULL;\n        }\n    }\n    else\n    {\n        uint32 nRowsPerStrip;\n\n        if( nBlockYSize == 0 )\n            nRowsPerStrip = MIN(nYSize, (int)TIFFDefaultStripSize(hTIFF,0));\n        else\n            nRowsPerStrip = nBlockYSize;\n        \n        TIFFSetField( hTIFF, TIFFTAG_ROWSPERSTRIP, nRowsPerStrip );\n    }\n    \n/* -------------------------------------------------------------------- */\n/*      Set compression related tags.                                   */\n/* -------------------------------------------------------------------- */\n    if ( nCompression == COMPRESSION_LZW ||\n         nCompression == COMPRESSION_ADOBE_DEFLATE )\n        TIFFSetField( hTIFF, TIFFTAG_PREDICTOR, nPredictor );\n    if (nCompression == COMPRESSION_ADOBE_DEFLATE\n        && nZLevel != -1)\n        TIFFSetField( hTIFF, TIFFTAG_ZIPQUALITY, nZLevel );\n    if( nCompression == COMPRESSION_JPEG \n        && nJpegQuality != -1 )\n        TIFFSetField( hTIFF, TIFFTAG_JPEGQUALITY, nJpegQuality );\n\n/* -------------------------------------------------------------------- */\n/*      If we forced production of a file with photometric=palette,     */\n/*      we need to push out a default color table.                      */\n/* -------------------------------------------------------------------- */\n    if( bForceColorTable )\n    {\n        int nColors;\n        \n        if( eType == GDT_Byte )\n            nColors = 256;\n        else\n            nColors = 65536;\n        \n        unsigned short *panTRed, *panTGreen, *panTBlue;\n\n        panTRed = (unsigned short *) CPLMalloc(sizeof(unsigned short)*nColors);\n        panTGreen = (unsigned short *) CPLMalloc(sizeof(unsigned short)*nColors);\n        panTBlue = (unsigned short *) CPLMalloc(sizeof(unsigned short)*nColors);\n\n        for( int iColor = 0; iColor < nColors; iColor++ )\n        {\n            if( eType == GDT_Byte )\n            {                \n                panTRed[iColor] = (unsigned short) (257 * iColor);\n                panTGreen[iColor] = (unsigned short) (257 * iColor);\n                panTBlue[iColor] = (unsigned short) (257 * iColor);\n            }\n            else\n            {\n                panTRed[iColor] = (unsigned short) iColor;\n                panTGreen[iColor] = (unsigned short) iColor;\n                panTBlue[iColor] = (unsigned short) iColor;\n            }\n        }\n        \n        TIFFSetField( hTIFF, TIFFTAG_COLORMAP,\n                      panTRed, panTGreen, panTBlue );\n        \n        CPLFree( panTRed );\n        CPLFree( panTGreen );\n        CPLFree( panTBlue );\n    }\n        \n    return( hTIFF );\n}\n\n/************************************************************************/\n/*                               Create()                               */\n/*                                                                      */\n/*      Create a new GeoTIFF or TIFF file.                              */\n/************************************************************************/\n\nGDALDataset *GTiffDataset::Create( const char * pszFilename,\n                                   int nXSize, int nYSize, int nBands,\n                                   GDALDataType eType,\n                                   char **papszParmList )\n\n{\n    GTiffDataset *\tpoDS;\n    TIFF\t\t*hTIFF;\n\n/* -------------------------------------------------------------------- */\n/*      Create the underlying TIFF file.                                */\n/* -------------------------------------------------------------------- */\n    hTIFF = CreateLL( pszFilename, nXSize, nYSize, nBands, \n                      eType, papszParmList );\n\n    if( hTIFF == NULL )\n        return NULL;\n\n/* -------------------------------------------------------------------- */\n/*      Create the new GTiffDataset object.                             */\n/* -------------------------------------------------------------------- */\n    poDS = new GTiffDataset();\n    poDS->hTIFF = hTIFF;\n    poDS->poActiveDS = poDS;\n    poDS->ppoActiveDSRef = &(poDS->poActiveDS);\n\n    poDS->nRasterXSize = nXSize;\n    poDS->nRasterYSize = nYSize;\n    poDS->eAccess = GA_Update;\n    poDS->bCrystalized = FALSE;\n    poDS->nSamplesPerPixel = (uint16) nBands;\n    poDS->osFilename = pszFilename;\n\n    /* Avoid premature crystalization that will cause directory re-writting */\n    /* if GetProjectionRef() or GetGeoTransform() are called on the newly created GeoTIFF */\n    poDS->bLookedForProjection = TRUE;\n\n    TIFFGetField( hTIFF, TIFFTAG_SAMPLEFORMAT, &(poDS->nSampleFormat) );\n    TIFFGetField( hTIFF, TIFFTAG_PLANARCONFIG, &(poDS->nPlanarConfig) );\n    TIFFGetField( hTIFF, TIFFTAG_PHOTOMETRIC, &(poDS->nPhotometric) );\n    TIFFGetField( hTIFF, TIFFTAG_BITSPERSAMPLE, &(poDS->nBitsPerSample) );\n    TIFFGetField( hTIFF, TIFFTAG_COMPRESSION, &(poDS->nCompression) );\n\n    if( TIFFIsTiled(hTIFF) )\n    {\n        TIFFGetField( hTIFF, TIFFTAG_TILEWIDTH, &(poDS->nBlockXSize) );\n        TIFFGetField( hTIFF, TIFFTAG_TILELENGTH, &(poDS->nBlockYSize) );\n    }\n    else\n    {\n        if( !TIFFGetField( hTIFF, TIFFTAG_ROWSPERSTRIP,\n                           &(poDS->nRowsPerStrip) ) )\n            poDS->nRowsPerStrip = 1; /* dummy value */\n\n        poDS->nBlockXSize = nXSize;\n        poDS->nBlockYSize = MIN((int)poDS->nRowsPerStrip,nYSize);\n    }\n\n    poDS->nBlocksPerBand =\n        ((nYSize + poDS->nBlockYSize - 1) / poDS->nBlockYSize)\n        * ((nXSize + poDS->nBlockXSize - 1) / poDS->nBlockXSize);\n\n    if( CSLFetchNameValue( papszParmList, \"PROFILE\" ) != NULL )\n        poDS->osProfile = CSLFetchNameValue( papszParmList, \"PROFILE\" );\n\n/* -------------------------------------------------------------------- */\n/*      YCbCr JPEG compressed images should be translated on the fly    */\n/*      to RGB by libtiff/libjpeg unless specifically requested         */\n/*      otherwise.                                                      */\n/* -------------------------------------------------------------------- */\n    if( poDS->nCompression == COMPRESSION_JPEG \n        && poDS->nPhotometric == PHOTOMETRIC_YCBCR \n        && CSLTestBoolean( CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\",\n                                              \"YES\") ) )\n    {\n        int nColorMode;\n\n        poDS->SetMetadataItem( \"SOURCE_COLOR_SPACE\", \"YCbCr\", \"IMAGE_STRUCTURE\" );\n        if ( !TIFFGetField( hTIFF, TIFFTAG_JPEGCOLORMODE, &nColorMode ) ||\n             nColorMode != JPEGCOLORMODE_RGB )\n            TIFFSetField(hTIFF, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Read palette back as a color table if it has one.               */\n/* -------------------------------------------------------------------- */\n    unsigned short\t*panRed, *panGreen, *panBlue;\n    \n    if( poDS->nPhotometric == PHOTOMETRIC_PALETTE\n        && TIFFGetField( hTIFF, TIFFTAG_COLORMAP, \n                         &panRed, &panGreen, &panBlue) )\n    {\n        int\tnColorCount;\n        GDALColorEntry oEntry;\n\n        poDS->poColorTable = new GDALColorTable();\n\n        nColorCount = 1 << poDS->nBitsPerSample;\n\n        for( int iColor = nColorCount - 1; iColor >= 0; iColor-- )\n        {\n            oEntry.c1 = panRed[iColor] / 256;\n            oEntry.c2 = panGreen[iColor] / 256;\n            oEntry.c3 = panBlue[iColor] / 256;\n            oEntry.c4 = 255;\n\n            poDS->poColorTable->SetColorEntry( iColor, &oEntry );\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Do we want to ensure all blocks get written out on close to     */\n/*      avoid sparse files?                                             */\n/* -------------------------------------------------------------------- */\n    if( !CSLFetchBoolean( papszParmList, \"SPARSE_OK\", FALSE ) )\n        poDS->bFillEmptyTiles = TRUE;\n        \n/* -------------------------------------------------------------------- */\n/*      Preserve creation options for consulting later (for instance    */\n/*      to decide if a TFW file should be written).                     */\n/* -------------------------------------------------------------------- */\n    poDS->papszCreationOptions = CSLDuplicate( papszParmList );\n    \n/* -------------------------------------------------------------------- */\n/*      Create band information objects.                                */\n/* -------------------------------------------------------------------- */\n    int\t\tiBand;\n\n    for( iBand = 0; iBand < nBands; iBand++ )\n    {\n        if( poDS->nBitsPerSample == 8 ||\n            poDS->nBitsPerSample == 16 ||\n            poDS->nBitsPerSample == 32 ||\n            poDS->nBitsPerSample == 64 ||\n            poDS->nBitsPerSample == 128)\n            poDS->SetBand( iBand+1, new GTiffRasterBand( poDS, iBand+1 ) );\n        else\n        {\n            poDS->SetBand( iBand+1, new GTiffOddBitsBand( poDS, iBand+1 ) );\n            poDS->GetRasterBand( iBand+1 )->\n                SetMetadataItem( \"NBITS\", \n                                 CPLString().Printf(\"%d\",poDS->nBitsPerSample),\n                                 \"IMAGE_STRUCTURE\" );\n        }\n    }\n\n    return( poDS );\n}\n\n/************************************************************************/\n/*                             CreateCopy()                             */\n/************************************************************************/\n\nGDALDataset *\nGTiffDataset::CreateCopy( const char * pszFilename, GDALDataset *poSrcDS, \n                          int bStrict, char ** papszOptions, \n                          GDALProgressFunc pfnProgress, void * pProgressData )\n\n{\n    TIFF\t*hTIFF;\n    int\t\tnXSize = poSrcDS->GetRasterXSize();\n    int\t\tnYSize = poSrcDS->GetRasterYSize();\n    int\t\tnBands = poSrcDS->GetRasterCount();\n    int         iBand;\n    CPLErr      eErr = CE_None;\n    uint16\tnPlanarConfig;\n    uint16\tnBitsPerSample;\n    GDALRasterBand *poPBand;\n\n    if( poSrcDS->GetRasterCount() == 0 )\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                  \"Unable to export GeoTIFF files with zero bands.\" );\n        return NULL;\n    }\n        \n    poPBand = poSrcDS->GetRasterBand(1);\n    GDALDataType eType = poPBand->GetRasterDataType();\n\n/* -------------------------------------------------------------------- */\n/*      Check, whether all bands in input dataset has the same type.    */\n/* -------------------------------------------------------------------- */\n    for ( iBand = 2; iBand <= nBands; iBand++ )\n    {\n        if ( eType != poSrcDS->GetRasterBand(iBand)->GetRasterDataType() )\n        {\n            if ( bStrict )\n            {\n                CPLError( CE_Failure, CPLE_AppDefined,\n                          \"Unable to export GeoTIFF file with different datatypes per\\n\"\n                          \"different bands. All bands should have the same types in TIFF.\" );\n                return NULL;\n            }\n            else\n            {\n                CPLError( CE_Warning, CPLE_AppDefined,\n                          \"Unable to export GeoTIFF file with different datatypes per\\n\"\n                          \"different bands. All bands should have the same types in TIFF.\" );\n            }\n        }\n    }\n\n    if( !pfnProgress( 0.0, NULL, pProgressData ) )\n        return NULL;\n\n/* -------------------------------------------------------------------- */\n/*      Capture the profile.                                            */\n/* -------------------------------------------------------------------- */\n    const char          *pszProfile;\n    int                 bGeoTIFF;\n\n    pszProfile = CSLFetchNameValue(papszOptions,\"PROFILE\");\n    if( pszProfile == NULL )\n        pszProfile = \"GDALGeoTIFF\";\n\n    if( !EQUAL(pszProfile,\"BASELINE\") \n        && !EQUAL(pszProfile,\"GeoTIFF\") \n        && !EQUAL(pszProfile,\"GDALGeoTIFF\") )\n    {\n        CPLError( CE_Failure, CPLE_AppDefined, \n                  \"PROFILE=%s not supported in GTIFF driver.\", \n                  pszProfile );\n        return NULL;\n    }\n    \n    if( EQUAL(pszProfile,\"BASELINE\") )\n        bGeoTIFF = FALSE;\n    else\n        bGeoTIFF = TRUE;\n\n/* -------------------------------------------------------------------- */\n/*      Special handling for NBITS.  Copy from band metadata if found.  */\n/* -------------------------------------------------------------------- */\n    char     **papszCreateOptions = CSLDuplicate( papszOptions );\n\n    if( poPBand->GetMetadataItem( \"NBITS\", \"IMAGE_STRUCTURE\" ) != NULL \n        && atoi(poPBand->GetMetadataItem( \"NBITS\", \"IMAGE_STRUCTURE\" )) > 0\n        && CSLFetchNameValue( papszCreateOptions, \"NBITS\") == NULL )\n    {\n        papszCreateOptions = \n            CSLSetNameValue( papszCreateOptions, \"NBITS\",\n                             poPBand->GetMetadataItem( \"NBITS\", \n                                                       \"IMAGE_STRUCTURE\" ) );\n    }\n\n    if( CSLFetchNameValue( papszOptions, \"PIXELTYPE\" ) == NULL\n        && eType == GDT_Byte\n        && poPBand->GetMetadataItem( \"PIXELTYPE\", \"IMAGE_STRUCTURE\" ) )\n    {\n        papszCreateOptions = \n            CSLSetNameValue( papszCreateOptions, \"PIXELTYPE\", \n                             poPBand->GetMetadataItem( \n                                 \"PIXELTYPE\", \"IMAGE_STRUCTURE\" ) );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Create the file.                                                */\n/* -------------------------------------------------------------------- */\n    hTIFF = CreateLL( pszFilename, nXSize, nYSize, nBands, \n                      eType, papszCreateOptions );\n\n    CSLDestroy( papszCreateOptions );\n\n    if( hTIFF == NULL )\n        return NULL;\n\n    TIFFGetField( hTIFF, TIFFTAG_PLANARCONFIG, &nPlanarConfig );\n    TIFFGetField(hTIFF, TIFFTAG_BITSPERSAMPLE, &nBitsPerSample );\n\n/* -------------------------------------------------------------------- */\n/*      Are we really producing an RGBA image?  If so, set the          */\n/*      associated alpha information.                                   */\n/* -------------------------------------------------------------------- */\n    int bForcePhotometric = \n        CSLFetchNameValue(papszOptions,\"PHOTOMETRIC\") != NULL;\n\n    if( nBands == 4 && !bForcePhotometric\n        && poSrcDS->GetRasterBand(4)->GetColorInterpretation()==GCI_AlphaBand)\n    {\n        uint16 v[1];\n\n        v[0] = EXTRASAMPLE_ASSOCALPHA;\n\tTIFFSetField(hTIFF, TIFFTAG_EXTRASAMPLES, 1, v);\n        TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If the output is jpeg compressed, and the input is RGB make     */\n/*      sure we note that.                                              */\n/* -------------------------------------------------------------------- */\n    uint16      nCompression;\n\n    if( !TIFFGetField( hTIFF, TIFFTAG_COMPRESSION, &(nCompression) ) )\n        nCompression = COMPRESSION_NONE;\n\n    if( nCompression == COMPRESSION_JPEG )\n    {\n        if( nBands >= 3 \n            && (poSrcDS->GetRasterBand(1)->GetColorInterpretation() \n                == GCI_YCbCr_YBand)\n            && (poSrcDS->GetRasterBand(2)->GetColorInterpretation() \n                == GCI_YCbCr_CbBand)\n            && (poSrcDS->GetRasterBand(3)->GetColorInterpretation() \n                == GCI_YCbCr_CrBand) )\n        {\n            /* do nothing ... */\n        }\n        else\n        {\n            /* we assume RGB if it isn't explicitly YCbCr */\n            CPLDebug( \"GTiff\", \"Setting JPEGCOLORMODE_RGB\" );\n            TIFFSetField( hTIFF, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB );\n        }\n    }\n        \n/* -------------------------------------------------------------------- */\n/*      Does the source image consist of one band, with a palette?      */\n/*      If so, copy over.                                               */\n/* -------------------------------------------------------------------- */\n    if( nBands == 1 && poSrcDS->GetRasterBand(1)->GetColorTable() != NULL \n        && eType == GDT_Byte )\n    {\n        unsigned short\tanTRed[256], anTGreen[256], anTBlue[256];\n        GDALColorTable *poCT;\n\n        poCT = poSrcDS->GetRasterBand(1)->GetColorTable();\n        \n        for( int iColor = 0; iColor < 256; iColor++ )\n        {\n            if( iColor < poCT->GetColorEntryCount() )\n            {\n                GDALColorEntry  sRGB;\n\n                poCT->GetColorEntryAsRGB( iColor, &sRGB );\n\n                anTRed[iColor] = (unsigned short) (257 * sRGB.c1);\n                anTGreen[iColor] = (unsigned short) (257 * sRGB.c2);\n                anTBlue[iColor] = (unsigned short) (257 * sRGB.c3);\n            }\n            else\n            {\n                anTRed[iColor] = anTGreen[iColor] = anTBlue[iColor] = 0;\n            }\n        }\n\n        if( !bForcePhotometric )\n            TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_PALETTE );\n        TIFFSetField( hTIFF, TIFFTAG_COLORMAP, anTRed, anTGreen, anTBlue );\n    }\n    else if( nBands == 1 \n             && poSrcDS->GetRasterBand(1)->GetColorTable() != NULL \n             && eType == GDT_UInt16 )\n    {\n        unsigned short\t*panTRed, *panTGreen, *panTBlue;\n        GDALColorTable *poCT;\n\n        panTRed   = (unsigned short *) CPLMalloc(65536*sizeof(unsigned short));\n        panTGreen = (unsigned short *) CPLMalloc(65536*sizeof(unsigned short));\n        panTBlue  = (unsigned short *) CPLMalloc(65536*sizeof(unsigned short));\n\n        poCT = poSrcDS->GetRasterBand(1)->GetColorTable();\n        \n        for( int iColor = 0; iColor < 65536; iColor++ )\n        {\n            if( iColor < poCT->GetColorEntryCount() )\n            {\n                GDALColorEntry  sRGB;\n\n                poCT->GetColorEntryAsRGB( iColor, &sRGB );\n\n                panTRed[iColor] = (unsigned short) (256 * sRGB.c1);\n                panTGreen[iColor] = (unsigned short) (256 * sRGB.c2);\n                panTBlue[iColor] = (unsigned short) (256 * sRGB.c3);\n            }\n            else\n            {\n                panTRed[iColor] = panTGreen[iColor] = panTBlue[iColor] = 0;\n            }\n        }\n\n        if( !bForcePhotometric )\n            TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_PALETTE );\n        TIFFSetField( hTIFF, TIFFTAG_COLORMAP, panTRed, panTGreen, panTBlue );\n\n        CPLFree( panTRed );\n        CPLFree( panTGreen );\n        CPLFree( panTBlue );\n    }\n    else if( poSrcDS->GetRasterBand(1)->GetColorTable() != NULL )\n        CPLError( CE_Warning, CPLE_AppDefined,\n                  \"Unable to export color table to GeoTIFF file.  Color tables\\n\"\n                  \"can only be written to 1 band Byte or UInt16 GeoTIFF files.\" );\n\n/* -------------------------------------------------------------------- */\n/*      Transfer some TIFF specific metadata, if available.             */\n/*      The return value will tell us if we need to try again later with*/\n/*      PAM because the profile doesn't allow to write some metadata    */\n/*      as TIFF tag                                                     */\n/* -------------------------------------------------------------------- */\n    int bHasWrittenMDInGeotiffTAG =\n            GTiffDataset::WriteMetadata( poSrcDS, hTIFF, FALSE, pszProfile,\n                                 pszFilename, papszOptions );\n\n/* -------------------------------------------------------------------- */\n/* \tWrite NoData value, if exist.                                   */\n/* -------------------------------------------------------------------- */\n    if( EQUAL(pszProfile,\"GDALGeoTIFF\") )\n    {\n        int\t\tbSuccess;\n        double\tdfNoData;\n    \n        dfNoData = poSrcDS->GetRasterBand(1)->GetNoDataValue( &bSuccess );\n        if ( bSuccess )\n            GTiffDataset::WriteNoDataValue( hTIFF, dfNoData );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Write affine transform if it is meaningful.                     */\n/* -------------------------------------------------------------------- */\n    const char *pszProjection = NULL;\n    double      adfGeoTransform[6];\n    \n    if( poSrcDS->GetGeoTransform( adfGeoTransform ) == CE_None\n        && (adfGeoTransform[0] != 0.0 || adfGeoTransform[1] != 1.0\n            || adfGeoTransform[2] != 0.0 || adfGeoTransform[3] != 0.0\n            || adfGeoTransform[4] != 0.0 || ABS(adfGeoTransform[5]) != 1.0 ))\n    {\n        if( bGeoTIFF )\n        {\n            if( adfGeoTransform[2] == 0.0 && adfGeoTransform[4] == 0.0 \n                && adfGeoTransform[5] < 0.0 )\n            {\n\n                double\tadfPixelScale[3], adfTiePoints[6];\n\n                adfPixelScale[0] = adfGeoTransform[1];\n                adfPixelScale[1] = fabs(adfGeoTransform[5]);\n                adfPixelScale[2] = 0.0;\n\n                TIFFSetField( hTIFF, TIFFTAG_GEOPIXELSCALE, 3, adfPixelScale );\n            \n                adfTiePoints[0] = 0.0;\n                adfTiePoints[1] = 0.0;\n                adfTiePoints[2] = 0.0;\n                adfTiePoints[3] = adfGeoTransform[0];\n                adfTiePoints[4] = adfGeoTransform[3];\n                adfTiePoints[5] = 0.0;\n        \n                TIFFSetField( hTIFF, TIFFTAG_GEOTIEPOINTS, 6, adfTiePoints );\n            }\n            else\n            {\n                double\tadfMatrix[16];\n\n                memset(adfMatrix,0,sizeof(double) * 16);\n\n                adfMatrix[0] = adfGeoTransform[1];\n                adfMatrix[1] = adfGeoTransform[2];\n                adfMatrix[3] = adfGeoTransform[0];\n                adfMatrix[4] = adfGeoTransform[4];\n                adfMatrix[5] = adfGeoTransform[5];\n                adfMatrix[7] = adfGeoTransform[3];\n                adfMatrix[15] = 1.0;\n\n                TIFFSetField( hTIFF, TIFFTAG_GEOTRANSMATRIX, 16, adfMatrix );\n            }\n            \n            pszProjection = poSrcDS->GetProjectionRef();\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Do we need a TFW file?                                          */\n/* -------------------------------------------------------------------- */\n        if( CSLFetchBoolean( papszOptions, \"TFW\", FALSE ) )\n            GDALWriteWorldFile( pszFilename, \"tfw\", adfGeoTransform );\n        else if( CSLFetchBoolean( papszOptions, \"WORLDFILE\", FALSE ) )\n            GDALWriteWorldFile( pszFilename, \"wld\", adfGeoTransform );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Otherwise write tiepoints if they are available.                */\n/* -------------------------------------------------------------------- */\n    else if( poSrcDS->GetGCPCount() > 0 && bGeoTIFF )\n    {\n        const GDAL_GCP *pasGCPs = poSrcDS->GetGCPs();\n        double\t*padfTiePoints;\n\n        padfTiePoints = (double *) \n            CPLMalloc(6*sizeof(double)*poSrcDS->GetGCPCount());\n\n        for( int iGCP = 0; iGCP < poSrcDS->GetGCPCount(); iGCP++ )\n        {\n\n            padfTiePoints[iGCP*6+0] = pasGCPs[iGCP].dfGCPPixel;\n            padfTiePoints[iGCP*6+1] = pasGCPs[iGCP].dfGCPLine;\n            padfTiePoints[iGCP*6+2] = 0;\n            padfTiePoints[iGCP*6+3] = pasGCPs[iGCP].dfGCPX;\n            padfTiePoints[iGCP*6+4] = pasGCPs[iGCP].dfGCPY;\n            padfTiePoints[iGCP*6+5] = pasGCPs[iGCP].dfGCPZ;\n        }\n\n        TIFFSetField( hTIFF, TIFFTAG_GEOTIEPOINTS, \n                      6*poSrcDS->GetGCPCount(), padfTiePoints );\n        CPLFree( padfTiePoints );\n        \n        pszProjection = poSrcDS->GetGCPProjection();\n        \n        if( CSLFetchBoolean( papszOptions, \"TFW\", FALSE ) \n            || CSLFetchBoolean( papszOptions, \"WORLDFILE\", FALSE ) )\n        {\n            CPLError(CE_Warning, CPLE_AppDefined,\n                     \"TFW=ON or WORLDFILE=ON creation options are ignored when GCPs are available\");\n        }\n    }\n\n    else\n        pszProjection = poSrcDS->GetProjectionRef();\n\n/* -------------------------------------------------------------------- */\n/*      Write the projection information, if possible.                  */\n/* -------------------------------------------------------------------- */\n    if( pszProjection != NULL && strlen(pszProjection) > 0 && bGeoTIFF )\n    {\n        GTIF\t*psGTIF;\n\n        psGTIF = GTIFNew( hTIFF );\n        GTIFSetFromOGISDefn( psGTIF, pszProjection );\n\n        if( poSrcDS->GetMetadataItem( GDALMD_AREA_OR_POINT ) \n            && EQUAL(poSrcDS->GetMetadataItem(GDALMD_AREA_OR_POINT),\n                     GDALMD_AOP_POINT) )\n        {\n            GTIFKeySet(psGTIF, GTRasterTypeGeoKey, TYPE_SHORT, 1,\n                       RasterPixelIsPoint);\n        }\n\n        GTIFWriteKeys( psGTIF );\n        GTIFFree( psGTIF );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Cleanup                                                         */\n/* -------------------------------------------------------------------- */\n    \n    TIFFWriteCheck( hTIFF, TIFFIsTiled(hTIFF), \"GTiffCreateCopy()\");\n    TIFFWriteDirectory( hTIFF );\n    TIFFFlush( hTIFF );\n    XTIFFClose( hTIFF );\n    hTIFF = NULL;\n\n    if( eErr != CE_None )\n    {\n        VSIUnlink( pszFilename );\n        return NULL;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Re-open as a dataset and copy over missing metadata using       */\n/*      PAM facilities.                                                 */\n/* -------------------------------------------------------------------- */\n    GTiffDataset *poDS;\n    CPLString osFileName(\"GTIFF_RAW:\");\n\n    osFileName += pszFilename;\n\n    poDS = (GTiffDataset *) GDALOpen( osFileName, GA_Update );\n    if( poDS == NULL )\n        poDS = (GTiffDataset *) GDALOpen( osFileName, GA_ReadOnly );\n\n    if ( poDS == NULL )\n    {\n        VSIUnlink( pszFilename );\n        return NULL;\n    }\n\n    poDS->osProfile = pszProfile;\n    poDS->CloneInfo( poSrcDS, GCIF_PAM_DEFAULT );\n    poDS->papszCreationOptions = CSLDuplicate( papszOptions );\n\n/* -------------------------------------------------------------------- */\n/*      CloneInfo() doesn't merge metadata, it just replaces it totally */\n/*      So we have to merge it                                          */\n/* -------------------------------------------------------------------- */\n\n    char **papszSRC_MD = poSrcDS->GetMetadata();\n    char **papszDST_MD = CSLDuplicate(poDS->GetMetadata());\n\n    papszDST_MD = CSLMerge( papszDST_MD, papszSRC_MD );\n\n    poDS->SetMetadata( papszDST_MD );\n    CSLDestroy( papszDST_MD );\n\n    /* Depending on the PHOTOMETRIC tag, the TIFF file may not have */\n    /* the same band count as the source. Will fail later in GDALDatasetCopyWholeRaster anyway... */\n    for( int nBand = 1;\n         nBand <= MIN(poDS->GetRasterCount(), poSrcDS->GetRasterCount()) ;\n         nBand++ )\n    {\n        char **papszSRC_MD = poSrcDS->GetRasterBand(nBand)->GetMetadata();\n        char **papszDST_MD = CSLDuplicate(poDS->GetRasterBand(nBand)->GetMetadata());\n\n        papszDST_MD = CSLMerge( papszDST_MD, papszSRC_MD );\n\n        poDS->GetRasterBand(nBand)->SetMetadata( papszDST_MD );\n        CSLDestroy( papszDST_MD );\n    }\n\n    hTIFF = (TIFF*) poDS->GetInternalHandle(NULL);\n\n/* -------------------------------------------------------------------- */\n/*      Second chance : now that we have a PAM dataset, it is possible  */\n/*      to write metadata that we couldn't be writen as TIFF tag        */\n/* -------------------------------------------------------------------- */\n    if (!bHasWrittenMDInGeotiffTAG)\n        GTiffDataset::WriteMetadata( poDS, hTIFF, TRUE, pszProfile,\n                                     pszFilename, papszOptions, TRUE /* don't write RPC and IMG file again */);\n\n    /* To avoid unnecessary directory rewriting */\n    poDS->bMetadataChanged = FALSE;\n    poDS->bGeoTIFFInfoChanged = FALSE;\n\n    /* We must re-set the compression level at this point, since it has */\n    /* been lost a few lines above when closing the newly create TIFF file */\n    /* The TIFFTAG_ZIPQUALITY & TIFFTAG_JPEGQUALITY are not store in the TIFF file. */\n    /* They are just TIFF session parameters */\n    if (nCompression == COMPRESSION_ADOBE_DEFLATE)\n    {\n        int nZLevel = GTiffGetZLevel(papszOptions);\n        if (nZLevel != -1)\n        {\n            TIFFSetField( hTIFF, TIFFTAG_ZIPQUALITY, nZLevel );\n        }\n    }\n    else if( nCompression == COMPRESSION_JPEG)\n    {\n        int nJpegQuality = GTiffGetJpegQuality(papszOptions);\n        if (nJpegQuality != -1)\n        {\n            TIFFSetField( hTIFF, TIFFTAG_JPEGQUALITY, nJpegQuality );\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Copy actual imagery.                                            */\n/* -------------------------------------------------------------------- */\n\n    if (poDS->bTreatAsSplit || poDS->bTreatAsSplitBitmap)\n    {\n        /* For split bands, we use TIFFWriteScanline() interface */\n        CPLAssert(poDS->nBitsPerSample == 8 || poDS->nBitsPerSample == 1);\n        \n        if (poDS->nPlanarConfig == PLANARCONFIG_CONTIG && poDS->nBands > 1)\n        {\n            int j;\n            GByte* pabyScanline = (GByte *) CPLMalloc(TIFFScanlineSize(hTIFF));\n            eErr = CE_None;\n            for(j=0;j<nYSize && eErr == CE_None;j++)\n            {\n                eErr = poSrcDS->RasterIO(GF_Read, 0, j, nXSize, 1,\n                                         pabyScanline, nXSize, 1,\n                                         GDT_Byte, nBands, NULL, poDS->nBands, 0, 1);\n                if (eErr == CE_None &&\n                    TIFFWriteScanline( hTIFF, pabyScanline, j, 0) == -1)\n                {\n                    CPLError( CE_Failure, CPLE_AppDefined,\n                              \"TIFFWriteScanline() failed.\" );\n                    eErr = CE_Failure;\n                }\n                if( !pfnProgress( (j+1) * 1.0 / nYSize, NULL, pProgressData ) )\n                    eErr = CE_Failure;\n            }\n            CPLFree(pabyScanline);\n        }\n        else\n        {\n            int iBand, j;\n            GByte* pabyScanline = (GByte *) CPLMalloc(TIFFScanlineSize(hTIFF));\n            eErr = CE_None;\n            for(iBand=1;iBand<=nBands && eErr == CE_None;iBand++)\n            {\n                for(j=0;j<nYSize && eErr == CE_None;j++)\n                {\n                    eErr = poSrcDS->GetRasterBand(iBand)->RasterIO(\n                                                    GF_Read, 0, j, nXSize, 1,\n                                                    pabyScanline, nXSize, 1,\n                                                    GDT_Byte, 0, 0);\n                    if (poDS->bTreatAsSplitBitmap)\n                    {\n                        for(int i=0;i<nXSize;i++)\n                        {\n                            GByte byVal = pabyScanline[i];\n                            if ((i & 0x7) == 0)\n                                pabyScanline[i >> 3] = 0;\n                            if (byVal)\n                                pabyScanline[i >> 3] |= (0x80 >> (i & 0x7));\n                        }\n                    }\n                    if (eErr == CE_None &&\n                        TIFFWriteScanline( hTIFF, pabyScanline, j, iBand - 1) == -1)\n                    {\n                        CPLError( CE_Failure, CPLE_AppDefined,\n                                  \"TIFFWriteScanline() failed.\" );\n                        eErr = CE_Failure;\n                    }\n                    if( !pfnProgress( (j+1 + (iBand - 1) * nYSize) * 1.0 /\n                                      (nBands * nYSize), NULL, pProgressData ) )\n                        eErr = CE_Failure;\n                }\n            }\n            CPLFree(pabyScanline);\n        }\n        \n        /* Necessary to be able to read the file without re-opening */\n        TIFFFlush( hTIFF );\n    }\n    else\n    {\n        char* papszCopyWholeRasterOptions[2] = { NULL, NULL };\n        if (nCompression != COMPRESSION_NONE)\n            papszCopyWholeRasterOptions[0] = (char*) \"COMPRESSED=YES\";\n        eErr = GDALDatasetCopyWholeRaster( (GDALDatasetH) poSrcDS, \n                                            (GDALDatasetH) poDS,\n                                            papszCopyWholeRasterOptions,\n                                            pfnProgress, pProgressData );\n    }\n\n    if( eErr == CE_Failure )\n    {\n        delete poDS;\n        poDS = NULL;\n\n        VSIUnlink( pszFilename ); // should really delete more carefully.\n    }\n\n    return poDS;\n}\n\n/************************************************************************/\n/*                          GetProjectionRef()                          */\n/************************************************************************/\n\nconst char *GTiffDataset::GetProjectionRef()\n\n{\n    if( nGCPCount == 0 )\n    {\n        LookForProjection();\n\n        if( EQUAL(pszProjection,\"\") )\n            return GDALPamDataset::GetProjectionRef();\n        else\n            return( pszProjection );\n    }\n    else\n        return \"\";\n}\n\n/************************************************************************/\n/*                           SetProjection()                            */\n/************************************************************************/\n\nCPLErr GTiffDataset::SetProjection( const char * pszNewProjection )\n\n{\n    LookForProjection();\n\n    if( !EQUALN(pszNewProjection,\"GEOGCS\",6)\n        && !EQUALN(pszNewProjection,\"PROJCS\",6)\n        && !EQUALN(pszNewProjection,\"LOCAL_CS\",6)\n        && !EQUAL(pszNewProjection,\"\") )\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                \"Only OGC WKT Projections supported for writing to GeoTIFF.\\n\"\n                \"%s not supported.\",\n                  pszNewProjection );\n        \n        return CE_Failure;\n    }\n    \n    CPLFree( pszProjection );\n    pszProjection = CPLStrdup( pszNewProjection );\n\n    bGeoTIFFInfoChanged = TRUE;\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                          GetGeoTransform()                           */\n/************************************************************************/\n\nCPLErr GTiffDataset::GetGeoTransform( double * padfTransform )\n\n{\n    memcpy( padfTransform, adfGeoTransform, sizeof(double)*6 );\n    \n    if( !bGeoTransformValid )\n        return CE_Failure;\n    else\n        return CE_None;\n}\n\n/************************************************************************/\n/*                          SetGeoTransform()                           */\n/************************************************************************/\n\nCPLErr GTiffDataset::SetGeoTransform( double * padfTransform )\n\n{\n    if( GetAccess() == GA_Update )\n    {\n        memcpy( adfGeoTransform, padfTransform, sizeof(double)*6 );\n        bGeoTransformValid = TRUE;\n        bGeoTIFFInfoChanged = TRUE;\n\n        return( CE_None );\n    }\n    else\n    {\n        CPLError( CE_Failure, CPLE_NotSupported,\n      \"SetGeoTransform() is only supported on newly created GeoTIFF files.\" );\n        return CE_Failure;\n    }\n}\n\n/************************************************************************/\n/*                            GetGCPCount()                             */\n/************************************************************************/\n\nint GTiffDataset::GetGCPCount()\n\n{\n    return nGCPCount;\n}\n\n/************************************************************************/\n/*                          GetGCPProjection()                          */\n/************************************************************************/\n\nconst char *GTiffDataset::GetGCPProjection()\n\n{\n    if( nGCPCount > 0 )\n    {\n        LookForProjection();\n        return pszProjection;\n    }\n    else\n        return GDALPamDataset::GetGCPProjection();\n}\n\n/************************************************************************/\n/*                               GetGCPs()                              */\n/************************************************************************/\n\nconst GDAL_GCP *GTiffDataset::GetGCPs()\n\n{\n    return pasGCPList;\n}\n\n/************************************************************************/\n/*                               SetGCPs()                              */\n/************************************************************************/\n\nCPLErr GTiffDataset::SetGCPs( int nGCPCount, const GDAL_GCP *pasGCPList,\n                              const char *pszGCPProjection )\n{\n    if( GetAccess() == GA_Update )\n    {\n        bLookedForProjection = TRUE;\n\n        if( this->nGCPCount > 0 )\n        {\n            GDALDeinitGCPs( this->nGCPCount, this->pasGCPList );\n            CPLFree( this->pasGCPList );\n        }\n\n\tthis->nGCPCount = nGCPCount;\n\tthis->pasGCPList = GDALDuplicateGCPs(nGCPCount, pasGCPList);\n\n        CPLFree( this->pszProjection );\n\tthis->pszProjection = CPLStrdup( pszGCPProjection );\n        bGeoTIFFInfoChanged = TRUE;\n\n\treturn CE_None;\n    }\n    else\n    {\n        CPLError( CE_Failure, CPLE_NotSupported,\n            \"SetGCPs() is only supported on newly created GeoTIFF files.\" );\n        return CE_Failure;\n    }\n}\n\n/************************************************************************/\n/*                            GetMetadata()                             */\n/************************************************************************/\n\nchar **GTiffDataset::GetMetadata( const char * pszDomain )\n\n{\n    if( pszDomain != NULL && EQUAL(pszDomain,\"ProxyOverviewRequest\") )\n        return GDALPamDataset::GetMetadata( pszDomain );\n\n    /* FIXME ? Should we call LookForProjection() to load GDALMD_AREA_OR_POINT ? */\n    /* This can impact performances */\n\n    return oGTiffMDMD.GetMetadata( pszDomain );\n}\n\n/************************************************************************/\n/*                            SetMetadata()                             */\n/************************************************************************/\nCPLErr GTiffDataset::SetMetadata( char ** papszMD, const char *pszDomain )\n\n{\n    if( pszDomain == NULL || !EQUAL(pszDomain,\"_temporary_\") )\n        bMetadataChanged = TRUE;\n\n    if( (pszDomain == NULL || EQUAL(pszDomain, \"\")) &&\n        CSLFetchNameValue(papszMD, GDALMD_AREA_OR_POINT) != NULL )\n    {\n        const char* pszPrevValue = \n                GetMetadataItem(GDALMD_AREA_OR_POINT);\n        const char* pszNewValue = \n                CSLFetchNameValue(papszMD, GDALMD_AREA_OR_POINT);\n        if (pszPrevValue == NULL || pszNewValue == NULL ||\n            !EQUAL(pszPrevValue, pszNewValue))\n        {\n            LookForProjection();\n            bGeoTIFFInfoChanged = TRUE;\n        }\n    }\n\n    return oGTiffMDMD.SetMetadata( papszMD, pszDomain );\n}\n\n/************************************************************************/\n/*                          GetMetadataItem()                           */\n/************************************************************************/\n\nconst char *GTiffDataset::GetMetadataItem( const char * pszName, \n                                           const char * pszDomain )\n\n{\n    if( pszDomain != NULL && EQUAL(pszDomain,\"ProxyOverviewRequest\") )\n        return GDALPamDataset::GetMetadataItem( pszName, pszDomain );\n\n    if( (pszDomain == NULL || EQUAL(pszDomain, \"\")) &&\n        pszName != NULL && EQUAL(pszName, GDALMD_AREA_OR_POINT) )\n    {\n        LookForProjection();\n    }\n\n    return oGTiffMDMD.GetMetadataItem( pszName, pszDomain );\n}\n\n/************************************************************************/\n/*                          SetMetadataItem()                           */\n/************************************************************************/\n\nCPLErr GTiffDataset::SetMetadataItem( const char *pszName, \n                                      const char *pszValue,\n                                      const char *pszDomain )\n\n{\n    if( pszDomain == NULL || !EQUAL(pszDomain,\"_temporary_\") )\n        bMetadataChanged = TRUE;\n\n    if( (pszDomain == NULL || EQUAL(pszDomain, \"\")) &&\n        pszName != NULL && EQUAL(pszName, GDALMD_AREA_OR_POINT) )\n    {\n        LookForProjection();\n        bGeoTIFFInfoChanged = TRUE;\n    }\n\n    return oGTiffMDMD.SetMetadataItem( pszName, pszValue, pszDomain );\n}\n\n/************************************************************************/\n/*                         GetInternalHandle()                          */\n/************************************************************************/\n\nvoid *GTiffDataset::GetInternalHandle( const char * /* pszHandleName */ )\n\n{\n    return hTIFF;\n}\n\n/************************************************************************/\n/*                            GetFileList()                             */\n/************************************************************************/\n\nchar **GTiffDataset::GetFileList()\n\n{\n    char **papszFileList = GDALPamDataset::GetFileList();\n    VSIStatBufL sStatBuf;\n\n/* -------------------------------------------------------------------- */\n/*      Check for .imd file.                                            */\n/* -------------------------------------------------------------------- */\n    CPLString osTarget = CPLResetExtension( osFilename, \"IMD\" );\n    if( VSIStatL( osTarget, &sStatBuf ) == 0 )\n        papszFileList = CSLAddString( papszFileList, osTarget );\n    else\n    {\n        osTarget = CPLResetExtension( osFilename, \"imd\" );\n        if( VSIStatL( osTarget, &sStatBuf ) == 0 )\n            papszFileList = CSLAddString( papszFileList, osTarget );\n    }\n    \n/* -------------------------------------------------------------------- */\n/*      Check for .rpb file.                                            */\n/* -------------------------------------------------------------------- */\n    osTarget = CPLResetExtension( osFilename, \"RPB\" );\n    if( VSIStatL( osTarget, &sStatBuf ) == 0 )\n        papszFileList = CSLAddString( papszFileList, osTarget );\n    else\n    {\n        osTarget = CPLResetExtension( osFilename, \"rpb\" );\n        if( VSIStatL( osTarget, &sStatBuf ) == 0 )\n            papszFileList = CSLAddString( papszFileList, osTarget );\n    }\n\n    return papszFileList;\n}\n\n/************************************************************************/\n/*                         CreateMaskBand()                             */\n/************************************************************************/\n\nCPLErr GTiffDataset::CreateMaskBand(int nFlags)\n{\n    if (poMaskDS != NULL)\n    {\n        CPLError(CE_Failure, CPLE_AppDefined,\n                 \"This TIFF dataset has already an internal mask band\");\n        return CE_Failure;\n    }\n    else if (CSLTestBoolean(CPLGetConfigOption(\"GDAL_TIFF_INTERNAL_MASK\", \"NO\")))\n    {\n        toff_t  nOffset;\n        int     bIsTiled;\n        int     bIsOverview = FALSE;\n        uint32\tnSubType;\n\n        if (nFlags != GMF_PER_DATASET)\n        {\n            CPLError(CE_Failure, CPLE_AppDefined,\n                     \"The only flag value supported for internal mask is GMF_PER_DATASET\");\n            return CE_Failure;\n        }\n\n    /* -------------------------------------------------------------------- */\n    /*      If we don't have read access, then create the mask externally.  */\n    /* -------------------------------------------------------------------- */\n        if( GetAccess() != GA_Update )\n        {\n            CPLError( CE_Warning, CPLE_AppDefined,\n                    \"File open for read-only accessing, \"\n                    \"creating mask externally.\" );\n\n            return GDALPamDataset::CreateMaskBand(nFlags);\n        }\n\n        if (poBaseDS)\n        {\n            if (!poBaseDS->SetDirectory())\n                return CE_Failure;\n        }\n        if (!SetDirectory())\n            return CE_Failure;\n\n        if( TIFFGetField(hTIFF, TIFFTAG_SUBFILETYPE, &nSubType))\n        {\n            bIsOverview = (nSubType & FILETYPE_REDUCEDIMAGE) != 0;\n\n            if ((nSubType & FILETYPE_MASK) != 0)\n            {\n                CPLError( CE_Failure, CPLE_AppDefined,\n                          \"Cannot create a mask on a TIFF mask IFD !\" );\n                return CE_Failure;\n            }\n        }\n\n        TIFFFlush( hTIFF );\n\n        bIsTiled = TIFFIsTiled(hTIFF);\n\n        nOffset = GTIFFWriteDirectory(hTIFF,\n                                      (bIsOverview) ? FILETYPE_REDUCEDIMAGE | FILETYPE_MASK : FILETYPE_MASK,\n                                       nRasterXSize, nRasterYSize,\n                                       1, PLANARCONFIG_CONTIG, 1,\n                                       nBlockXSize, nBlockYSize,\n                                       bIsTiled, COMPRESSION_NONE, PHOTOMETRIC_MASK,\n                                       SAMPLEFORMAT_UINT, NULL, NULL, NULL, 0, NULL, \"\");\n        if (nOffset == 0)\n            return CE_Failure;\n\n        poMaskDS = new GTiffDataset();\n        if( poMaskDS->OpenOffset( hTIFF, ppoActiveDSRef, nOffset, \n                                  FALSE, GA_Update ) != CE_None)\n        {\n            delete poMaskDS;\n            poMaskDS = NULL;\n            return CE_Failure;\n        }\n\n        return CE_None;\n    }\n    else\n    {\n        return GDALPamDataset::CreateMaskBand(nFlags);\n    }\n}\n\n/************************************************************************/\n/*                         CreateMaskBand()                             */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::CreateMaskBand(int nFlags)\n{\n    if (poGDS->poMaskDS != NULL)\n    {\n        CPLError(CE_Failure, CPLE_AppDefined,\n                 \"This TIFF dataset has already an internal mask band\");\n        return CE_Failure;\n    }\n    else if (CSLTestBoolean(CPLGetConfigOption(\"GDAL_TIFF_INTERNAL_MASK\", \"NO\")))\n    {\n        return poGDS->CreateMaskBand(nFlags);\n    }\n    else\n    {\n        return GDALPamRasterBand::CreateMaskBand(nFlags);\n    }\n}\n\n/************************************************************************/\n/*                       PrepareTIFFErrorFormat()                       */\n/*                                                                      */\n/*      sometimes the \"module\" has stuff in it that has special         */\n/*      meaning in a printf() style format, so we try to escape it.     */\n/*      For now we hope the only thing we have to escape is %'s.        */\n/************************************************************************/\n\nstatic char *PrepareTIFFErrorFormat( const char *module, const char *fmt )\n\n{\n    char      *pszModFmt;\n    int       iIn, iOut;\n\n    pszModFmt = (char *) CPLMalloc( strlen(module)*2 + strlen(fmt) + 2 );\n    for( iOut = 0, iIn = 0; module[iIn] != '\\0'; iIn++ )\n    {\n        if( module[iIn] == '%' )\n        {\n            pszModFmt[iOut++] = '%';\n            pszModFmt[iOut++] = '%';\n        }\n        else\n            pszModFmt[iOut++] = module[iIn];\n    }\n    pszModFmt[iOut] = '\\0';\n    strcat( pszModFmt, \":\" );\n    strcat( pszModFmt, fmt );\n\n    return pszModFmt;\n}\n\n/************************************************************************/\n/*                        GTiffWarningHandler()                         */\n/************************************************************************/\nvoid\nGTiffWarningHandler(const char* module, const char* fmt, va_list ap )\n{\n    char\t*pszModFmt;\n\n    if( strstr(fmt,\"unknown field\") != NULL )\n        return;\n\n    pszModFmt = PrepareTIFFErrorFormat( module, fmt );\n    CPLErrorV( CE_Warning, CPLE_AppDefined, pszModFmt, ap );\n    CPLFree( pszModFmt );\n}\n\n/************************************************************************/\n/*                        GTiffWarningHandler()                         */\n/************************************************************************/\nvoid\nGTiffErrorHandler(const char* module, const char* fmt, va_list ap )\n{\n    char *pszModFmt;\n\n    pszModFmt = PrepareTIFFErrorFormat( module, fmt );\n    CPLErrorV( CE_Failure, CPLE_AppDefined, pszModFmt, ap );\n    CPLFree( pszModFmt );\n}\n\n/************************************************************************/\n/*                          GTiffTagExtender()                          */\n/*                                                                      */\n/*      Install tags specially known to GDAL.                           */\n/************************************************************************/\n\nstatic TIFFExtendProc _ParentExtender = NULL;\n\nstatic void GTiffTagExtender(TIFF *tif)\n\n{\n    static const TIFFFieldInfo xtiffFieldInfo[] = {\n        { TIFFTAG_GDAL_METADATA,    -1,-1, TIFF_ASCII,\tFIELD_CUSTOM,\n          TRUE,\tFALSE,\t(char*) \"GDALMetadata\" },\n        { TIFFTAG_GDAL_NODATA,\t    -1,-1, TIFF_ASCII,\tFIELD_CUSTOM,\n          TRUE,\tFALSE,\t(char*) \"GDALNoDataValue\" },\n        { TIFFTAG_RPCCOEFFICIENT,   -1,-1, TIFF_DOUBLE,\tFIELD_CUSTOM,\n          TRUE,\tTRUE,\t(char*) \"RPCCoefficient\" }\n    };\n\n    if (_ParentExtender) \n        (*_ParentExtender)(tif);\n\n    TIFFMergeFieldInfo( tif, xtiffFieldInfo,\n\t\t        sizeof(xtiffFieldInfo) / sizeof(xtiffFieldInfo[0]) );\n}\n\n/************************************************************************/\n/*                          GTiffOneTimeInit()                          */\n/*                                                                      */\n/*      This is stuff that is initialized for the TIFF library just     */\n/*      once.  We deliberately defer the initialization till the        */\n/*      first time we are likely to call into libtiff to avoid          */\n/*      unnecessary paging in of the library for GDAL apps that         */\n/*      don't use it.                                                   */\n/************************************************************************/\n\nvoid GTiffOneTimeInit()\n\n{\n    static int bOneTimeInitDone = FALSE;\n    \n    if( bOneTimeInitDone )\n        return;\n\n    bOneTimeInitDone = TRUE;\n\n    _ParentExtender = TIFFSetTagExtender(GTiffTagExtender);\n\n    TIFFSetWarningHandler( GTiffWarningHandler );\n    TIFFSetErrorHandler( GTiffErrorHandler );\n\n    // This only really needed if we are linked to an external libgeotiff\n    // with its own (lame) file searching logic. \n    SetCSVFilenameHook( GDALDefaultCSVFilename );\n}\n\n/************************************************************************/\n/*                        GDALDeregister_GTiff()                        */\n/************************************************************************/\n\nvoid GDALDeregister_GTiff( GDALDriver * )\n\n{\n    CPLDebug( \"GDAL\", \"GDALDeregister_GTiff() called.\" );\n    CSVDeaccess( NULL );\n\n#if defined(LIBGEOTIFF_VERSION) && LIBGEOTIFF_VERSION > 1150\n    GTIFDeaccessCSV();\n#endif\n}\n\n/************************************************************************/\n/*                          GDALRegister_GTiff()                        */\n/************************************************************************/\n\nvoid GDALRegister_GTiff()\n\n{\n    if( GDALGetDriverByName( \"GTiff\" ) == NULL )\n    {\n        GDALDriver\t*poDriver;\n        char szCreateOptions[3072];\n        char szOptionalCompressItems[500];\n        int bHasJPEG = FALSE, bHasLZW = FALSE, bHasDEFLATE = FALSE;\n\n        poDriver = new GDALDriver();\n        \n/* -------------------------------------------------------------------- */\n/*      Determine which compression codecs are available that we        */\n/*      want to advertise.  If we are using an old libtiff we won't     */\n/*      be able to find out so we just assume all are available.        */\n/* -------------------------------------------------------------------- */\n        strcpy( szOptionalCompressItems, \n                \"       <Value>NONE</Value>\" );\n\n#if TIFFLIB_VERSION <= 20040919\n        strcat( szOptionalCompressItems, \n                \"       <Value>PACKBITS</Value>\"\n                \"       <Value>JPEG</Value>\"\n                \"       <Value>LZW</Value>\"\n                \"       <Value>DEFLATE</Value>\" );\n        bHasLZW = bHasDEFLATE = TRUE;\n#else\n        TIFFCodec\t*c, *codecs = TIFFGetConfiguredCODECs();\n\n        for( c = codecs; c->name; c++ )\n        {\n            if( c->scheme == COMPRESSION_PACKBITS )\n                strcat( szOptionalCompressItems,\n                        \"       <Value>PACKBITS</Value>\" );\n            else if( c->scheme == COMPRESSION_JPEG )\n            {\n                bHasJPEG = TRUE;\n                strcat( szOptionalCompressItems,\n                        \"       <Value>JPEG</Value>\" );\n            }\n            else if( c->scheme == COMPRESSION_LZW )\n            {\n                bHasLZW = TRUE;\n                strcat( szOptionalCompressItems,\n                        \"       <Value>LZW</Value>\" );\n            }\n            else if( c->scheme == COMPRESSION_ADOBE_DEFLATE )\n            {\n                bHasDEFLATE = TRUE;\n                strcat( szOptionalCompressItems,\n                        \"       <Value>DEFLATE</Value>\" );\n            }\n            else if( c->scheme == COMPRESSION_CCITTRLE )\n                strcat( szOptionalCompressItems,\n                        \"       <Value>CCITTRLE</Value>\" );\n            else if( c->scheme == COMPRESSION_CCITTFAX3 )\n                strcat( szOptionalCompressItems,\n                        \"       <Value>CCITTFAX3</Value>\" );\n            else if( c->scheme == COMPRESSION_CCITTFAX4 )\n                strcat( szOptionalCompressItems,\n                        \"       <Value>CCITTFAX4</Value>\" );\n        }\n        _TIFFfree( codecs );\n#endif        \n\n/* -------------------------------------------------------------------- */\n/*      Build full creation option list.                                */\n/* -------------------------------------------------------------------- */\n        sprintf( szCreateOptions, \"%s%s%s\", \n\"<CreationOptionList>\"\n\"   <Option name='COMPRESS' type='string-select'>\",\n                 szOptionalCompressItems,\n\"   </Option>\");\n        if (bHasLZW || bHasDEFLATE)\n            strcat( szCreateOptions, \"\"        \n\"   <Option name='PREDICTOR' type='int' description='Predictor Type'/>\");\n        if (bHasJPEG)\n            strcat( szCreateOptions, \"\"\n\"   <Option name='JPEG_QUALITY' type='int' description='JPEG quality 1-100' default='75'/>\");\n        if (bHasDEFLATE)\n            strcat( szCreateOptions, \"\"\n\"   <Option name='ZLEVEL' type='int' description='DEFLATE compression level 1-9' default='6'/>\");\n        strcat( szCreateOptions, \"\"\n\"   <Option name='NBITS' type='int' description='BITS for sub-byte files (1-7), sub-uint16 (9-15), sub-uint32 (17-31)'/>\"\n\"   <Option name='INTERLEAVE' type='string-select' default='PIXEL'>\"\n\"       <Value>BAND</Value>\"\n\"       <Value>PIXEL</Value>\"\n\"   </Option>\"\n\"   <Option name='TILED' type='boolean' description='Switch to tiled format'/>\"\n\"   <Option name='TFW' type='boolean' description='Write out world file'/>\"\n\"   <Option name='RPB' type='boolean' description='Write out .RPB (RPC) file'/>\"\n\"   <Option name='BLOCKXSIZE' type='int' description='Tile Width'/>\"\n\"   <Option name='BLOCKYSIZE' type='int' description='Tile/Strip Height'/>\"\n\"   <Option name='PHOTOMETRIC' type='string-select'>\"\n\"       <Value>MINISBLACK</Value>\"\n\"       <Value>MINISWHITE</Value>\"\n\"       <Value>PALETTE</Value>\"\n\"       <Value>RGB</Value>\"\n\"       <Value>CMYK</Value>\"\n\"       <Value>YCBCR</Value>\"\n\"       <Value>CIELAB</Value>\"\n\"       <Value>ICCLAB</Value>\"\n\"       <Value>ITULAB</Value>\"\n\"   </Option>\"\n\"   <Option name='SPARSE_OK' type='boolean' description='Can newly created files have missing blocks?' default='FALSE'/>\"\n\"   <Option name='ALPHA' type='boolean' description='Mark first extrasample as being alpha'/>\"\n\"   <Option name='PROFILE' type='string-select' default='GDALGeoTIFF'>\"\n\"       <Value>GDALGeoTIFF</Value>\"\n\"       <Value>GeoTIFF</Value>\"\n\"       <Value>BASELINE</Value>\"\n\"   </Option>\"\n\"   <Option name='PIXELTYPE' type='string-select'>\"\n\"       <Value>DEFAULT</Value>\"\n\"       <Value>SIGNEDBYTE</Value>\"\n\"   </Option>\"\n#ifdef BIGTIFF_SUPPORT\n\"   <Option name='BIGTIFF' type='string-select' description='Force creation of BigTIFF file'>\"\n\"     <Value>YES</Value>\"\n\"     <Value>NO</Value>\"\n\"     <Value>IF_NEEDED</Value>\"\n\"     <Value>IF_SAFER</Value>\"\n\"   </Option>\"\n#endif\n\"   <Option name='ENDIANNESS' type='string-select' default='NATIVE' description='Force endianness of created file. For DEBUG purpose mostly'>\"\n\"       <Value>NATIVE</Value>\"\n\"       <Value>INVERTED</Value>\"\n\"       <Value>LITTLE</Value>\"\n\"       <Value>BIG</Value>\"\n\"   </Option>\"\n\"</CreationOptionList>\" );\n                 \n/* -------------------------------------------------------------------- */\n/*      Set the driver details.                                         */\n/* -------------------------------------------------------------------- */\n        poDriver->SetDescription( \"GTiff\" );\n        poDriver->SetMetadataItem( GDAL_DMD_LONGNAME, \"GeoTIFF\" );\n        poDriver->SetMetadataItem( GDAL_DMD_HELPTOPIC, \"frmt_gtiff.html\" );\n        poDriver->SetMetadataItem( GDAL_DMD_MIMETYPE, \"image/tiff\" );\n        poDriver->SetMetadataItem( GDAL_DMD_EXTENSION, \"tif\" );\n        poDriver->SetMetadataItem( GDAL_DMD_CREATIONDATATYPES, \n                                   \"Byte UInt16 Int16 UInt32 Int32 Float32 \"\n                                   \"Float64 CInt16 CInt32 CFloat32 CFloat64\" );\n        poDriver->SetMetadataItem( GDAL_DMD_CREATIONOPTIONLIST, \n                                   szCreateOptions );\n\n        poDriver->SetMetadataItem( GDAL_DCAP_VIRTUALIO, \"YES\" );\n\n        poDriver->pfnOpen = GTiffDataset::Open;\n        poDriver->pfnCreate = GTiffDataset::Create;\n        poDriver->pfnCreateCopy = GTiffDataset::CreateCopy;\n        poDriver->pfnUnloadDriver = GDALDeregister_GTiff;\n        poDriver->pfnIdentify = GTiffDataset::Identify;\n\n        GetGDALDriverManager()->RegisterDriver( poDriver );\n    }\n}\n",
                "name": "geotiff.cpp",
                "path": "GDAL/GDAL-1.7.2/frmts/gtiff/geotiff.cpp",
                "url": "/github.com/nasa/World-Wind-Java/-/blob/GDAL/GDAL-1.7.2/frmts/gtiff/geotiff.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 1522,
                    "offsetAndLengths": [
                        [
                            16,
                            16
                        ]
                    ],
                    "preview": "            if( TIFFReadRGBATile(poGDS->hTIFF, "
                },
                {
                    "limitHit": false,
                    "lineNumber": 1529,
                    "offsetAndLengths": [
                        [
                            27,
                            16
                        ]
                    ],
                    "preview": "                          \"TIFFReadRGBATile() failed.\" );"
                }
            ],
            "repository": {
                "name": "github.com/nasa/World-Wind-Java",
                "url": "/github.com/nasa/World-Wind-Java"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "5ccb0a9702e9a27f487043f8da03c09a1a54b9f5"
                },
                "content": "/*M///////////////////////////////////////////////////////////////////////////////////////\n//\n//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.\n//\n//  By downloading, copying, installing or using the software you agree to this license.\n//  If you do not agree to this license, do not download, install,\n//  copy or use the software.\n//\n//\n//                        Intel License Agreement\n//                For Open Source Computer Vision Library\n//\n// Copyright (C) 2000, Intel Corporation, all rights reserved.\n// Third party copyrights are property of their respective owners.\n//\n// Redistribution and use in source and binary forms, with or without modification,\n// are permitted provided that the following conditions are met:\n//\n//   * Redistribution's of source code must retain the above copyright notice,\n//     this list of conditions and the following disclaimer.\n//\n//   * Redistribution's in binary form must reproduce the above copyright notice,\n//     this list of conditions and the following disclaimer in the documentation\n//     and/or other materials provided with the distribution.\n//\n//   * The name of Intel Corporation may not be used to endorse or promote products\n//     derived from this software without specific prior written permission.\n//\n// This software is provided by the copyright holders and contributors \"as is\" and\n// any express or implied warranties, including, but not limited to, the implied\n// warranties of merchantability and fitness for a particular purpose are disclaimed.\n// In no event shall the Intel Corporation or contributors be liable for any direct,\n// indirect, incidental, special, exemplary, or consequential damages\n// (including, but not limited to, procurement of substitute goods or services;\n// loss of use, data, or profits; or business interruption) however caused\n// and on any theory of liability, whether in contract, strict liability,\n// or tort (including negligence or otherwise) arising in any way out of\n// the use of this software, even if advised of the possibility of such damage.\n//\n//M*/\n\n/****************************************************************************************\\\n    A part of the file implements TIFF reader on base of libtiff library\n    (see otherlibs/_graphics/readme.txt for copyright notice)\n\\****************************************************************************************/\n\n#include \"_highgui.h\"\n#include \"grfmt_tiff.h\"\n\nstatic const char fmtSignTiffII[] = \"II\\x2a\\x00\";\nstatic const char fmtSignTiffMM[] = \"MM\\x00\\x2a\";\n\nGrFmtTiff::GrFmtTiff()\n{\n    m_sign_len = 4;\n    m_signature = \"\";\n    m_description = \"TIFF Files (*.tiff;*.tif)\";\n}\n\nGrFmtTiff::~GrFmtTiff()\n{\n}\n\nbool GrFmtTiff::CheckSignature( const char* signature )\n{\n    return memcmp( signature, fmtSignTiffII, 4 ) == 0 ||\n           memcmp( signature, fmtSignTiffMM, 4 ) == 0;\n}\n\n\nGrFmtReader* GrFmtTiff::NewReader( const char* filename )\n{\n    return new GrFmtTiffReader( filename );\n}\n\n\nGrFmtWriter* GrFmtTiff::NewWriter( const char* filename )\n{\n    return new GrFmtTiffWriter( filename );\n}\n\n\n#ifdef HAVE_TIFF\n\n#include \"tiff.h\"\n#include \"tiffio.h\"\n\nstatic int grfmt_tiff_err_handler_init = 0;\n\nstatic void GrFmtSilentTIFFErrorHandler( const char*, const char*, va_list ) {}\n\nGrFmtTiffReader::GrFmtTiffReader( const char* filename ) : GrFmtReader( filename )\n{\n    m_tif = 0;\n\n    if( !grfmt_tiff_err_handler_init )\n    {\n        grfmt_tiff_err_handler_init = 1;\n\n        TIFFSetErrorHandler( GrFmtSilentTIFFErrorHandler );\n        TIFFSetWarningHandler( GrFmtSilentTIFFErrorHandler );\n    }\n}\n\n\nGrFmtTiffReader::~GrFmtTiffReader()\n{\n}\n\n\nvoid  GrFmtTiffReader::Close()\n{\n    if( m_tif )\n    {\n        TIFF* tif = (TIFF*)m_tif;\n        TIFFClose( tif );\n        m_tif = 0;\n    }\n}\n\n\nbool  GrFmtTiffReader::CheckFormat( const char* signature )\n{\n    return memcmp( signature, fmtSignTiffII, 4 ) == 0 ||\n           memcmp( signature, fmtSignTiffMM, 4 ) == 0;\n}\n\n\nbool  GrFmtTiffReader::ReadHeader()\n{\n    char errmsg[1024];\n    bool result = false;\n\n    Close();\n    TIFF* tif = TIFFOpen( m_filename, \"r\" );\n\n    if( tif )\n    {\n        int width = 0, height = 0, photometric = 0, compression = 0;\n        m_tif = tif;\n\n        if( TIFFRGBAImageOK( tif, errmsg ) &&\n            TIFFGetField( tif, TIFFTAG_IMAGEWIDTH, &width ) &&\n            TIFFGetField( tif, TIFFTAG_IMAGELENGTH, &height ) &&\n            TIFFGetField( tif, TIFFTAG_PHOTOMETRIC, &photometric ) && \n            (!TIFFGetField( tif, TIFFTAG_COMPRESSION, &compression ) ||\n            (compression != COMPRESSION_LZW &&\n             compression != COMPRESSION_OJPEG)))\n        {\n            m_width = width;\n            m_height = height;\n            m_iscolor = photometric > 1;\n            \n            result = true;\n        }\n    }\n\n    if( !result )\n        Close();\n\n    return result;\n}\n\n\nbool  GrFmtTiffReader::ReadData( uchar* data, int step, int color )\n{\n    bool result = false;\n    uchar* buffer = 0;\n\n    color = color > 0 || (color < 0 && m_iscolor);\n\n    if( m_tif && m_width && m_height )\n    {\n        TIFF* tif = (TIFF*)m_tif;\n        int tile_width0 = m_width, tile_height0 = 0;\n        int x, y, i;\n        int is_tiled = TIFFIsTiled(tif);\n        \n        if( !is_tiled &&\n            TIFFGetField( tif, TIFFTAG_ROWSPERSTRIP, &tile_height0 ) ||\n            is_tiled &&\n            TIFFGetField( tif, TIFFTAG_TILEWIDTH, &tile_width0 ) &&\n            TIFFGetField( tif, TIFFTAG_TILELENGTH, &tile_height0 ))\n        {\n            if( tile_width0 <= 0 )\n                tile_width0 = m_width;\n\n            if( tile_height0 <= 0 )\n                tile_height0 = m_height;\n            \n            buffer = new uchar[tile_height0*tile_width0*4];\n\n            for( y = 0; y < m_height; y += tile_height0, data += step*tile_height0 )\n            {\n                int tile_height = tile_height0;\n\n                if( y + tile_height > m_height )\n                    tile_height = m_height - y;\n\n                for( x = 0; x < m_width; x += tile_width0 )\n                {\n                    int tile_width = tile_width0, ok;\n\n                    if( x + tile_width > m_width )\n                        tile_width = m_width - x;\n\n                    if( !is_tiled )\n                        ok = TIFFReadRGBAStrip( tif, y, (uint32*)buffer );\n                    else\n                        ok = TIFFReadRGBATile( tif, x, y, (uint32*)buffer );\n\n                    if( !ok )\n                        goto exit_func;\n\n                    for( i = 0; i < tile_height; i++ )\n                        if( color )\n                            icvCvt_BGRA2BGR_8u_C4C3R( buffer + i*tile_width*4, 0,\n                                          data + x*3 + step*(tile_height - i - 1), 0,\n                                          cvSize(tile_width,1), 2 );\n                        else\n                            icvCvt_BGRA2Gray_8u_C4C1R( buffer + i*tile_width*4, 0,\n                                           data + x + step*(tile_height - i - 1), 0,\n                                           cvSize(tile_width,1), 2 );\n                }\n            }\n\n            result = true;\n        }\n    }\n\nexit_func:\n\n    Close();\n    delete[] buffer;\n\n    return result;\n}\n\n#else\n\nstatic const int  tiffMask[] = { 0xff, 0xff, 0xffffffff, 0xffff, 0xffffffff };\n\n/************************ TIFF reader *****************************/\n\nGrFmtTiffReader::GrFmtTiffReader( const char* filename ) : GrFmtReader( filename )\n{\n    m_offsets = 0;\n    m_maxoffsets = 0;\n    m_strips = -1;\n    m_max_pal_length = 0;\n    m_temp_palette = 0;\n}\n\n\nGrFmtTiffReader::~GrFmtTiffReader()\n{\n    Close();\n\n    delete[] m_offsets;\n    delete[] m_temp_palette;\n}\n\nvoid  GrFmtTiffReader::Close()\n{\n    m_strm.Close();\n}\n\n\nbool  GrFmtTiffReader::CheckFormat( const char* signature )\n{\n    return memcmp( signature, fmtSignTiffII, 4 ) == 0 ||\n           memcmp( signature, fmtSignTiffMM, 4 ) == 0;\n}\n\n\nint   GrFmtTiffReader::GetWordEx()\n{\n    int val = m_strm.GetWord();\n    if( m_byteorder == TIFF_ORDER_MM )\n        val = ((val)>>8)|(((val)&0xff)<<8);\n    return val;\n}\n\n\nint   GrFmtTiffReader::GetDWordEx()\n{\n    int val = m_strm.GetDWord();\n    if( m_byteorder == TIFF_ORDER_MM )\n        val = BSWAP( val );\n    return val;\n}\n\n\nint  GrFmtTiffReader::ReadTable( int offset, int count,\n                                 TiffFieldType fieldType,\n                                 int*& array, int& arraysize )\n{\n    int i;\n    \n    if( count < 0 )\n        return RBS_BAD_HEADER;\n    \n    if( fieldType != TIFF_TYPE_SHORT &&\n        fieldType != TIFF_TYPE_LONG &&\n        fieldType != TIFF_TYPE_BYTE )\n        return RBS_BAD_HEADER;\n\n    if( count > arraysize )\n    {\n        delete[] array;\n        arraysize = arraysize*3/2;\n        if( arraysize < count )\n            arraysize = count;\n        array = new int[arraysize];\n    }\n\n    if( count > 1 )\n    {\n        int pos = m_strm.GetPos();\n        m_strm.SetPos( offset );\n\n        if( fieldType == TIFF_TYPE_LONG )\n        {\n            if( m_byteorder == TIFF_ORDER_MM )\n                for( i = 0; i < count; i++ )\n                    array[i] = ((RMByteStream&)m_strm).GetDWord();\n            else\n                for( i = 0; i < count; i++ )\n                    array[i] = ((RLByteStream&)m_strm).GetDWord();\n        }\n        else if( fieldType == TIFF_TYPE_SHORT )\n        {\n            if( m_byteorder == TIFF_ORDER_MM )\n                for( i = 0; i < count; i++ )\n                    array[i] = ((RMByteStream&)m_strm).GetWord();\n            else\n                for( i = 0; i < count; i++ )\n                    array[i] = ((RLByteStream&)m_strm).GetWord();\n        }\n        else // fieldType == TIFF_TYPE_BYTE\n            for( i = 0; i < count; i++ )\n                array[i] = m_strm.GetByte();\n\n        m_strm.SetPos(pos);\n    }\n    else\n    {\n        assert( (offset & ~tiffMask[fieldType]) == 0 );\n        array[0] = offset;\n    }\n\n    return 0;\n}\n\n\nbool  GrFmtTiffReader::ReadHeader()\n{\n    bool result = false;\n    int  photometric = -1;\n    int  channels = 1;\n    int  pal_length = -1;\n\n    const int MAX_CHANNELS = 4;\n    int  bpp_arr[MAX_CHANNELS];\n\n    assert( strlen(m_filename) != 0 );\n    if( !m_strm.Open( m_filename )) return false;\n\n    m_width = -1;\n    m_height = -1;\n    m_strips = -1;\n    m_bpp = 1;\n    m_compression = TIFF_UNCOMP;\n    m_rows_per_strip = -1;\n    m_iscolor = false;\n\n    if( setjmp( m_strm.JmpBuf()) == 0 )\n    {\n        m_byteorder = (TiffByteOrder)m_strm.GetWord();\n        m_strm.Skip( 2 );\n        int header_offset = GetDWordEx();\n\n        m_strm.SetPos( header_offset );\n\n        // read the first tag directory\n        int i, j, count = GetWordEx();\n\n        for( i = 0; i < count; i++ )\n        {\n            // read tag\n            TiffTag tag = (TiffTag)GetWordEx();\n            TiffFieldType fieldType = (TiffFieldType)GetWordEx();\n            int count = GetDWordEx();\n            int value = GetDWordEx();\n            if( count == 1 )\n            {\n                if( m_byteorder == TIFF_ORDER_MM )\n                {\n                    if( fieldType == TIFF_TYPE_SHORT )\n                        value = (unsigned)value >> 16;\n                    else if( fieldType == TIFF_TYPE_BYTE )\n                        value = (unsigned)value >> 24;\n                }\n\n                value &= tiffMask[fieldType];\n            }\n\n            switch( tag )\n            {\n            case  TIFF_TAG_WIDTH:\n                m_width = value;\n                break;\n\n            case  TIFF_TAG_HEIGHT:\n                m_height = value;\n                break;\n\n            case  TIFF_TAG_BITS_PER_SAMPLE:\n                {\n                    int* bpp_arr_ref = bpp_arr;\n\n                    if( count > MAX_CHANNELS )\n                        BAD_HEADER_ERR();\n\n                    if( ReadTable( value, count, fieldType, bpp_arr_ref, count ) < 0 )\n                        BAD_HEADER_ERR();\n                \n                    for( j = 1; j < count; j++ )\n                    {\n                        if( bpp_arr[j] != bpp_arr[0] )\n                            BAD_HEADER_ERR();\n                    }\n\n                    m_bpp = bpp_arr[0];\n                }\n\n                break;\n\n            case  TIFF_TAG_COMPRESSION:\n                m_compression = (TiffCompression)value;\n                if( m_compression != TIFF_UNCOMP &&\n                    m_compression != TIFF_HUFFMAN &&\n                    m_compression != TIFF_PACKBITS )\n                    BAD_HEADER_ERR();\n                break;\n\n            case  TIFF_TAG_PHOTOMETRIC:\n                photometric = value;\n                if( (unsigned)photometric > 3 )\n                    BAD_HEADER_ERR();\n                break;\n\n            case  TIFF_TAG_STRIP_OFFSETS:\n                m_strips = count;\n                if( ReadTable( value, count, fieldType, m_offsets, m_maxoffsets ) < 0 )\n                    BAD_HEADER_ERR();\n                break;\n\n            case  TIFF_TAG_SAMPLES_PER_PIXEL:\n                channels = value;\n                if( channels != 1 && channels != 3 && channels != 4 )\n                    BAD_HEADER_ERR();\n                break;\n\n            case  TIFF_TAG_ROWS_PER_STRIP:\n                m_rows_per_strip = value;\n                break;\n\n            case  TIFF_TAG_PLANAR_CONFIG:\n                {\n                int planar_config = value;\n                if( planar_config != 1 )\n                    BAD_HEADER_ERR();\n                }\n                break;\n\n            case  TIFF_TAG_COLOR_MAP:\n                if( fieldType != TIFF_TYPE_SHORT || count < 2 )\n                    BAD_HEADER_ERR();\n                if( ReadTable( value, count, fieldType,\n                               m_temp_palette, m_max_pal_length ) < 0 )\n                    BAD_HEADER_ERR();\n                pal_length = count / 3;\n                if( pal_length > 256 )\n                    BAD_HEADER_ERR();\n                for( i = 0; i < pal_length; i++ )\n                {\n                    m_palette[i].r = (uchar)(m_temp_palette[i] >> 8);\n                    m_palette[i].g = (uchar)(m_temp_palette[i + pal_length] >> 8);\n                    m_palette[i].b = (uchar)(m_temp_palette[i + pal_length*2] >> 8);\n                }\n                break;\n            case  TIFF_TAG_STRIP_COUNTS:\n                break;\n            }\n        }\n\n        if( m_strips == 1 && m_rows_per_strip == -1 )\n            m_rows_per_strip = m_height;\n\n        if( m_width > 0 && m_height > 0 && m_strips > 0 &&\n            (m_height + m_rows_per_strip - 1)/m_rows_per_strip == m_strips )\n        {\n            switch( m_bpp )\n            {\n            case 1:\n                if( photometric == 0 || photometric == 1 && channels == 1 )\n                {\n                    FillGrayPalette( m_palette, m_bpp, photometric == 0 );\n                    result = true;\n                    m_iscolor = false;\n                }\n                break;\n            case 4:\n            case 8:\n                if( (photometric == 0 || photometric == 1 ||\n                     photometric == 3 && pal_length == (1 << m_bpp)) &&\n                    m_compression != TIFF_HUFFMAN && channels == 1 )\n                {\n                    if( pal_length < 0 )\n                    {\n                        FillGrayPalette( m_palette, m_bpp, photometric == 0 );\n                        m_iscolor = false;\n                    }\n                    else\n                    {\n                        m_iscolor = IsColorPalette( m_palette, m_bpp );\n                    }\n                    result = true;\n                }\n                else if( photometric == 2 && pal_length < 0 &&\n                         (channels == 3 || channels == 4) &&\n                         m_compression == TIFF_UNCOMP )\n                {\n                    m_bpp = 8*channels;\n                    m_iscolor = true;\n                    result = true;\n                }\n                break;\n            default:\n                BAD_HEADER_ERR();\n            }\n        }\nbad_header_exit:\n        ;\n    }\n\n    if( !result )\n    {\n        m_strips = -1;\n        m_width = m_height = -1;\n        m_strm.Close();\n    }\n\n    return result;\n}\n\n\nbool  GrFmtTiffReader::ReadData( uchar* data, int step, int color )\n{\n    const  int buffer_size = 1 << 12;\n    uchar  buffer[buffer_size];\n    uchar  gray_palette[256];\n    bool   result = false;\n    uchar* src = buffer;\n    int    src_pitch = (m_width*m_bpp + 7)/8;\n    int    y = 0;\n\n    if( m_strips < 0 || !m_strm.IsOpened())\n        return false;\n    \n    if( src_pitch+32 > buffer_size )\n        src = new uchar[src_pitch+32];\n\n    if( !color )\n        if( m_bpp <= 8 )\n        {\n            CvtPaletteToGray( m_palette, gray_palette, 1 << m_bpp );\n        }\n\n    if( setjmp( m_strm.JmpBuf()) == 0 )\n    {\n        for( int s = 0; s < m_strips; s++ )\n        {\n            int y_limit = m_rows_per_strip;\n\n            y_limit += y;\n            if( y_limit > m_height ) y_limit = m_height;\n\n            m_strm.SetPos( m_offsets[s] );\n\n            if( m_compression == TIFF_UNCOMP )\n            {\n                for( ; y < y_limit; y++, data += step )\n                {\n                    m_strm.GetBytes( src, src_pitch );\n                    if( color )\n                        switch( m_bpp )\n                        {\n                        case 1:\n                            FillColorRow1( data, src, m_width, m_palette );\n                            break;\n                        case 4:\n                            FillColorRow4( data, src, m_width, m_palette );\n                            break;\n                        case 8:\n                            FillColorRow8( data, src, m_width, m_palette );\n                            break;\n                        case 24:\n                            icvCvt_RGB2BGR_8u_C3R( src, 0, data, 0, cvSize(m_width,1) );\n                            break;\n                        case 32:\n                            icvCvt_BGRA2BGR_8u_C4C3R( src, 0, data, 0, cvSize(m_width,1), 2 );\n                            break;\n                        default:\n                            assert(0);\n                            goto bad_decoding_end;\n                        }\n                    else\n                        switch( m_bpp )\n                        {\n                        case 1:\n                            FillGrayRow1( data, src, m_width, gray_palette );\n                            break;\n                        case 4:\n                            FillGrayRow4( data, src, m_width, gray_palette );\n                            break;\n                        case 8:\n                            FillGrayRow8( data, src, m_width, gray_palette );\n                            break;\n                        case 24:\n                            icvCvt_BGR2Gray_8u_C3C1R( src, 0, data, 0, cvSize(m_width,1), 2 );\n                            break;\n                        case 32:\n                            icvCvt_BGRA2Gray_8u_C4C1R( src, 0, data, 0, cvSize(m_width,1), 2 );\n                            break;\n                        default:\n                            assert(0);\n                            goto bad_decoding_end;\n                        }\n                }\n            }\n            else\n            {\n            }\n\n            result = true;\n\nbad_decoding_end:\n\n            ;\n        }\n    }\n\n    if( src != buffer ) delete[] src; \n    return result;\n}\n\n#endif\n\n//////////////////////////////////////////////////////////////////////////////////////////\n\nGrFmtTiffWriter::GrFmtTiffWriter( const char* filename ) : GrFmtWriter( filename )\n{\n}\n\nGrFmtTiffWriter::~GrFmtTiffWriter()\n{\n}\n\nvoid  GrFmtTiffWriter::WriteTag( TiffTag tag, TiffFieldType fieldType,\n                                 int count, int value )\n{\n    m_strm.PutWord( tag );\n    m_strm.PutWord( fieldType );\n    m_strm.PutDWord( count );\n    m_strm.PutDWord( value );\n}\n\n\nbool  GrFmtTiffWriter::WriteImage( const uchar* data, int step,\n                                   int width, int height, int /*depth*/, int channels )\n{\n    bool result = false;\n    int fileStep = width*channels;\n\n    assert( data && width > 0 && height > 0 && step >= fileStep);\n\n    if( m_strm.Open( m_filename ) )\n    {\n        int rowsPerStrip = (1 << 13)/fileStep;\n\n        if( rowsPerStrip < 1 )\n            rowsPerStrip = 1;\n\n        if( rowsPerStrip > height )\n            rowsPerStrip = height;\n\n        int i, stripCount = (height + rowsPerStrip - 1) / rowsPerStrip;\n/*#if defined _DEBUG || !defined WIN32\n        int uncompressedRowSize = rowsPerStrip * fileStep;\n#endif*/\n        int directoryOffset = 0;\n\n        int* stripOffsets = new int[stripCount];\n        short* stripCounts = new short[stripCount];\n        uchar* buffer = new uchar[fileStep + 32];\n        int  stripOffsetsOffset = 0;\n        int  stripCountsOffset = 0;\n        int  bitsPerSample = 8; // TODO support 16 bit\n        int  y = 0;\n\n        m_strm.PutBytes( fmtSignTiffII, 4 );\n        m_strm.PutDWord( directoryOffset );\n\n        // write an image data first (the most reasonable way\n        // for compressed images)\n        for( i = 0; i < stripCount; i++ )\n        {\n            int limit = y + rowsPerStrip;\n\n            if( limit > height )\n                limit = height;\n\n            stripOffsets[i] = m_strm.GetPos();\n\n            for( ; y < limit; y++, data += step )\n            {\n                if( channels == 3 )\n                    icvCvt_BGR2RGB_8u_C3R( data, 0, buffer, 0, cvSize(width,1) );\n                else if( channels == 4 )\n                    icvCvt_BGRA2RGBA_8u_C4R( data, 0, buffer, 0, cvSize(width,1) );\n\n                m_strm.PutBytes( channels > 1 ? buffer : data, fileStep );\n            }\n\n            stripCounts[i] = (short)(m_strm.GetPos() - stripOffsets[i]);\n            /*assert( stripCounts[i] == uncompressedRowSize ||\n                    stripCounts[i] < uncompressedRowSize &&\n                    i == stripCount - 1);*/\n        }\n\n        if( stripCount > 2 )\n        {\n            stripOffsetsOffset = m_strm.GetPos();\n            for( i = 0; i < stripCount; i++ )\n                m_strm.PutDWord( stripOffsets[i] );\n\n            stripCountsOffset = m_strm.GetPos();\n            for( i = 0; i < stripCount; i++ )\n                m_strm.PutWord( stripCounts[i] );\n        }\n        else if(stripCount == 2)\n        {\n            stripOffsetsOffset = m_strm.GetPos();\n            for (i = 0; i < stripCount; i++)\n            {\n                m_strm.PutDWord (stripOffsets [i]);\n            }\n            stripCountsOffset = stripCounts [0] + (stripCounts [1] << 16);\n        }\n        else\n        {\n            stripOffsetsOffset = stripOffsets[0];\n            stripCountsOffset = stripCounts[0];\n        }\n\n        if( channels > 1 )\n        {\n            bitsPerSample = m_strm.GetPos();\n            m_strm.PutWord(8);\n            m_strm.PutWord(8);\n            m_strm.PutWord(8);\n            if( channels == 4 )\n                m_strm.PutWord(8);\n        }\n\n        directoryOffset = m_strm.GetPos();\n\n        // write header\n        m_strm.PutWord( 9 );\n\n        /* warning: specification 5.0 of Tiff want to have tags in\n           ascending order. This is a non-fatal error, but this cause\n           warning with some tools. So, keep this in ascending order */\n\n        WriteTag( TIFF_TAG_WIDTH, TIFF_TYPE_LONG, 1, width );\n        WriteTag( TIFF_TAG_HEIGHT, TIFF_TYPE_LONG, 1, height );\n        WriteTag( TIFF_TAG_BITS_PER_SAMPLE,\n                  TIFF_TYPE_SHORT, channels, bitsPerSample );\n        WriteTag( TIFF_TAG_COMPRESSION, TIFF_TYPE_LONG, 1, TIFF_UNCOMP );\n        WriteTag( TIFF_TAG_PHOTOMETRIC, TIFF_TYPE_SHORT, 1, channels > 1 ? 2 : 1 );\n\n        WriteTag( TIFF_TAG_STRIP_OFFSETS, TIFF_TYPE_LONG,\n                  stripCount, stripOffsetsOffset );\n\n        WriteTag( TIFF_TAG_SAMPLES_PER_PIXEL, TIFF_TYPE_SHORT, 1, channels );\n        WriteTag( TIFF_TAG_ROWS_PER_STRIP, TIFF_TYPE_LONG, 1, rowsPerStrip );\n        \n        WriteTag( TIFF_TAG_STRIP_COUNTS,\n                  stripCount > 1 ? TIFF_TYPE_SHORT : TIFF_TYPE_LONG,\n                  stripCount, stripCountsOffset );\n\n        m_strm.PutDWord(0);\n        m_strm.Close();\n\n        // write directory offset\n        FILE* f = fopen( m_filename, \"r+b\" );\n        buffer[0] = (uchar)directoryOffset;\n        buffer[1] = (uchar)(directoryOffset >> 8);\n        buffer[2] = (uchar)(directoryOffset >> 16);\n        buffer[3] = (uchar)(directoryOffset >> 24);\n\n        fseek( f, 4, SEEK_SET );\n        fwrite( buffer, 1, 4, f );\n        fclose(f);\n\n        delete[]  stripOffsets;\n        delete[]  stripCounts;\n        delete[] buffer;\n\n        result = true;\n    }\n    return result;\n}\n\n",
                "name": "grfmt_tiff.cpp",
                "path": "jni/otherlibs/highgui/grfmt_tiff.cpp",
                "url": "/github.com/billmccord/OpenCV-Android/-/blob/jni/otherlibs/highgui/grfmt_tiff.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 209,
                    "offsetAndLengths": [
                        [
                            29,
                            16
                        ]
                    ],
                    "preview": "                        ok = TIFFReadRGBATile( tif, x, y, (uint32*)buffer );"
                }
            ],
            "repository": {
                "name": "github.com/billmccord/OpenCV-Android",
                "url": "/github.com/billmccord/OpenCV-Android"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "23b9043a2bd576e90bb542f1f76be2d6bfb5fd3c"
                },
                "content": "#if defined(_MSC_VER) && (_MSC_VER >= 1400)\n#define _CRT_SECURE_NO_DEPRECATE 1\n#endif\n#define IS_TIFF_MAIN\n\n#if defined(_WIN32)\n#include <io.h>\n#else\n#include <unistd.h>\n#endif\n\n#include <memory>\n\n#include \"tiio.h\"\n#include \"tpixel.h\"\n#include \"tsystem.h\"\n#include \"../tzp/toonztags.h\"\n#include \"tconvert.h\"\n#include \"tpixelutils.h\"\n#include \"traster.h\"\n\nextern \"C\" {\n#include \"tiffio.h\"\n}\n\n#include \"tiio_tif.h\"\n\n#ifdef _MSC_VER\n#pragma warning(disable : 4996)\n#endif\n\n#ifdef _WIN32\n#include \"windows.h\"\n#endif\n\n//**************************************************************************\n//    TifReader  implementation\n//**************************************************************************\n\nclass TifReader final : public Tiio::Reader {\n  TIFF *m_tiff;\n  int m_row;\n  bool m_tiled, m_stripped;\n  int m_rowsPerStrip;\n  int m_stripIndex;\n  int m_rowLength;\n  UCHAR *m_stripBuffer;\n  double m_xdpi, m_ydpi;\n  Tiio::RowOrder m_rowOrder;\n  bool is16bitEnabled;\n  bool m_isTzi;\n  TRasterGR8P m_tmpRas;\n\npublic:\n  TifReader(bool isTzi);\n  ~TifReader();\n\n  void open(FILE *file) override;\n\n  Tiio::RowOrder getRowOrder() const override { return m_rowOrder; }\n\n  bool read16BitIsEnabled() const override { return false; }\n\n  void enable16BitRead(bool enabled) override { is16bitEnabled = enabled; }\n\n  int skipLines(int lineCount) override;\n  void readLine(char *buffer, int x0, int x1, int shrink) override;\n  void readLine(short *buffer, int x0, int x1, int shrink) override;\n};\n\n//------------------------------------------------------------\n\nTifReader::TifReader(bool isTzi)\n    : m_tiff(0)\n    , m_row(0)\n    , m_rowsPerStrip(0)\n    , m_stripIndex(-1)\n    //, m_stripBuffer(0)\n    , m_rowLength(0)\n    , m_xdpi(0)\n    , m_ydpi(0)\n    , m_rowOrder(Tiio::TOP2BOTTOM)\n    , is16bitEnabled(true)\n    , m_isTzi(isTzi)\n    , m_tmpRas(0) {\n  TIFFSetWarningHandler(0);\n}\n\n//------------------------------------------------------------\n\nTifReader::~TifReader() {\n  if (m_tiff) TIFFClose(m_tiff);\n\n  if (m_tmpRas) m_tmpRas->unlock();\n\n  delete m_info.m_properties;\n}\n\n//------------------------------------------------------------\n\nvoid TifReader::open(FILE *file) {\n  int fd = fileno(file);\n#if 0\n\tm_tiff = TIFFFdOpenNoCloseProc(fd, \"\", \"rb\");\n#elif defined(_WIN32) && defined(__GNUC__)\n  m_tiff = TIFFFdOpen((int)_get_osfhandle(dup(fd)), \"\", \"rb\");\n#else\n  m_tiff = TIFFFdOpen(dup(fd), \"\", \"rb\");\n#endif\n  if (!m_tiff) {\n    std::string str(\"Tiff file closed\");\n    throw(str);\n  }\n\n  uint32 w = 0, h = 0, rps = 0;\n  uint16 bps = 0, spp = 0;\n  uint32 tileWidth = 0, tileLength = 0;\n\n  // TIFFSetDirectory(m_tiff,1);\n  // TIFFGetField(m_tiff, TIFFTAG_PAGENUMBER, &pn);\n  // int pn = TIFFNumberOfDirectories(m_tiff);\n  // TIFFSetDirectory(m_tiff,1);\n  TIFFGetField(m_tiff, TIFFTAG_IMAGEWIDTH, &w);\n  TIFFGetField(m_tiff, TIFFTAG_IMAGELENGTH, &h);\n  TIFFGetField(m_tiff, TIFFTAG_BITSPERSAMPLE, &bps);\n  TIFFGetField(m_tiff, TIFFTAG_SAMPLESPERPIXEL, &spp);\n  TIFFGetField(m_tiff, TIFFTAG_ROWSPERSTRIP, &rps);\n  // int stripCount = TIFFNumberOfStrips(m_tiff);\n  // int tileCount = TIFFNumberOfTiles(m_tiff);\n  TIFFGetField(m_tiff, TIFFTAG_TILEWIDTH, &tileWidth);\n  TIFFGetField(m_tiff, TIFFTAG_TILELENGTH, &tileLength);\n  Tiio::TifWriterProperties *prop = new Tiio::TifWriterProperties();\n  m_info.m_properties             = prop;\n  uint16 orient                   = Tiio::TOP2BOTTOM;\n  if (TIFFGetField(m_tiff, TIFFTAG_ORIENTATION, &orient)) {\n    switch (orient) {\n    case ORIENTATION_TOPLEFT: /* row 0 top, col 0 lhs */\n      prop->m_orientation.setValue(TNZ_INFO_ORIENT_TOPLEFT);\n      m_rowOrder = Tiio::TOP2BOTTOM;\n      break;\n    case ORIENTATION_TOPRIGHT: /* row 0 top, col 0 rhs */\n      prop->m_orientation.setValue(TNZ_INFO_ORIENT_TOPRIGHT);\n      m_rowOrder = Tiio::TOP2BOTTOM;\n      break;\n    case ORIENTATION_LEFTTOP: /* row 0 lhs, col 0 top */\n      prop->m_orientation.setValue(TNZ_INFO_ORIENT_LEFTTOP);\n      m_rowOrder = Tiio::TOP2BOTTOM;\n      break;\n    case ORIENTATION_RIGHTTOP: /* row 0 rhs, col 0 top */\n      prop->m_orientation.setValue(TNZ_INFO_ORIENT_RIGHTTOP);\n      m_rowOrder = Tiio::TOP2BOTTOM;\n      break;\n\n    case ORIENTATION_BOTRIGHT: /* row 0 bottom, col 0 rhs */\n      prop->m_orientation.setValue(TNZ_INFO_ORIENT_BOTRIGHT);\n      m_rowOrder = Tiio::BOTTOM2TOP;\n      break;\n    case ORIENTATION_BOTLEFT: /* row 0 bottom, col 0 lhs */\n      prop->m_orientation.setValue(TNZ_INFO_ORIENT_BOTLEFT);\n      m_rowOrder = Tiio::BOTTOM2TOP;\n      break;\n    case ORIENTATION_RIGHTBOT: /* row 0 rhs, col 0 bottom */\n      prop->m_orientation.setValue(TNZ_INFO_ORIENT_RIGHTBOT);\n      m_rowOrder = Tiio::BOTTOM2TOP;\n      break;\n    case ORIENTATION_LEFTBOT: /* row 0 lhs, col 0 bottom */\n      prop->m_orientation.setValue(TNZ_INFO_ORIENT_LEFTBOT);\n      m_rowOrder = Tiio::BOTTOM2TOP;\n      break;\n    default:\n      prop->m_orientation.setValue(TNZ_INFO_ORIENT_NONE);\n      m_rowOrder = Tiio::TOP2BOTTOM;\n      break;\n    }\n  }\n\n  USHORT compression;\n  TIFFGetField(m_tiff, TIFFTAG_COMPRESSION, &compression);\n  switch (compression) {\n  case COMPRESSION_LZW:\n    prop->m_compressionType.setValue(TNZ_INFO_COMPRESS_LZW);\n    break;\n  case COMPRESSION_PACKBITS:\n    prop->m_compressionType.setValue(TNZ_INFO_COMPRESS_PACKBITS);\n    break;\n  case COMPRESSION_THUNDERSCAN:\n    prop->m_compressionType.setValue(TNZ_INFO_COMPRESS_THUNDERSCAN);\n    break;\n  case COMPRESSION_CCITTFAX3:\n    prop->m_compressionType.setValue(TNZ_INFO_COMPRESS_CCITTFAX3);\n    break;\n  case COMPRESSION_CCITTFAX4:\n    prop->m_compressionType.setValue(TNZ_INFO_COMPRESS_CCITTFAX4);\n    break;\n  case COMPRESSION_CCITTRLE:\n    prop->m_compressionType.setValue(TNZ_INFO_COMPRESS_CCITTRLE);\n    break;\n  case COMPRESSION_JPEG:\n    prop->m_compressionType.setValue(TNZ_INFO_COMPRESS_JPEG);\n    break;\n  case COMPRESSION_OJPEG:\n    prop->m_compressionType.setValue(TNZ_INFO_COMPRESS_OJPEG);\n    break;\n  case COMPRESSION_NONE:\n    prop->m_compressionType.setValue(TNZ_INFO_COMPRESS_NONE);\n    break;\n  case COMPRESSION_SGILOG:\n    prop->m_compressionType.setValue(TNZ_INFO_COMPRESS_SGILOG);\n    break;\n  case COMPRESSION_SGILOG24:\n    prop->m_compressionType.setValue(TNZ_INFO_COMPRESS_SGILOG24);\n    break;\n  case COMPRESSION_ADOBE_DEFLATE:\n    prop->m_compressionType.setValue(TNZ_INFO_COMPRESS_ADOBE_DEFLATE);\n    break;\n  case COMPRESSION_DEFLATE:\n    prop->m_compressionType.setValue(TNZ_INFO_COMPRESS_DEFLATE);\n    break;\n  /*default :\nprop->m_compressionType.setValue(TNZ_INFO_COMPRESS_UNKNOWN);\nbreak;*/\n  default:\n    assert(0);\n  }\n\n  float xdpi = 0, ydpi = 0;\n  TIFFGetField(m_tiff, TIFFTAG_XRESOLUTION, &xdpi);\n  TIFFGetField(m_tiff, TIFFTAG_YRESOLUTION, &ydpi);\n\n  bool swapxy = false;  // orient == ORIENTATION_RIGHTTOP;\n\n  if (swapxy) {\n    std::swap(w, h);\n    std::swap(xdpi, ydpi);\n  }\n\n  m_xdpi        = xdpi;\n  m_ydpi        = ydpi;\n  m_info.m_lx   = w;\n  m_info.m_ly   = h;\n  m_info.m_dpix = xdpi;\n  m_info.m_dpiy = ydpi;\n\n  m_info.m_samplePerPixel = spp;\n\n  if (bps == 64 && spp == 3) bps = 16;  // immagine con bpp = 192\n\n  uint16 photometric;  // codice di controllo\n  TIFFGetField(m_tiff, TIFFTAG_PHOTOMETRIC, &photometric);\n  if (photometric == 3 &&\n      (bps == 2 || bps == 4))  // immagini con PHOTOMATRIC_PALETTE\n    bps = 8;\n\n  if (photometric == 1 && (bps == 12 || bps == 24)) bps = 16;\n\n  if (bps == 6) bps = 4;  // immagini con bps = 6\n\n  if (bps == 10 || bps == 12 ||\n      bps == 14)  // immagini con bps = 10 , 12 , 14 , 24 , 32\n    bps = 8;\n  if (bps == 24 || bps == 32) bps = 16;\n\n  m_info.m_bitsPerSample = bps;\n\n  if (bps == 8) switch (spp) {\n    case 1: /* row 0 top, col 0 lhs */\n      prop->m_bitsPerPixel.setValue(L\" 8(GREYTONES)\");\n      break;\n    case 3: /* row 0 top, col 0 lhs */\n      prop->m_bitsPerPixel.setValue(L\"24(RGB)\");\n      break;\n    case 4: /* row 0 top, col 0 lhs */\n      prop->m_bitsPerPixel.setValue(L\"32(RGBM)\");\n      break;\n    }\n  else if (bps == 16)\n    switch (spp) {\n    case 1: /* row 0 top, col 0 lhs */\n      // prop->m_bitsPerPixel.setValue(L\"16(GREYTONES)\");\n      break;\n    case 3: /* row 0 top, col 0 lhs */\n      prop->m_bitsPerPixel.setValue(L\"48(RGB)\");\n      break;\n    case 4: /* row 0 top, col 0 lhs */\n      prop->m_bitsPerPixel.setValue(L\"64(RGBM)\");\n      break;\n    }\n\n  else if (bps == 2)\n    switch (spp) {\n    case 1: /* row 0 top, col 0 lhs */\n      prop->m_bitsPerPixel.setValue(L\"32(RGBM)\");\n      break;\n    case 3: /* row 0 top, col 0 lhs */\n      prop->m_bitsPerPixel.setValue(L\"32(RGBM)\");\n      break;\n    case 4: /* row 0 top, col 0 lhs */\n      prop->m_bitsPerPixel.setValue(L\"32(RGBM)\");\n      break;\n    }\n\n  else if (bps == 1)\n    switch (spp) {\n    case 1: /* row 0 top, col 0 lhs */\n      prop->m_bitsPerPixel.setValue(L\" 1(BW)\");\n      break;\n    case 3: /* row 0 top, col 0 lhs */\n      prop->m_bitsPerPixel.setValue(L\"32(RGBM)\");\n      break;\n    case 4: /* row 0 top, col 0 lhs */\n      prop->m_bitsPerPixel.setValue(L\"32(RGBM)\");\n      break;\n    }\n\n  else if (bps == 4)\n    switch (spp) {\n    case 1: /* row 0 top, col 0 lhs */\n      prop->m_bitsPerPixel.setValue(L\" 8(GREYTONES)\");\n      break;\n    case 3: /* row 0 top, col 0 lhs */\n      prop->m_bitsPerPixel.setValue(L\"32(RGBM)\");\n      break;\n    case 4: /* row 0 top, col 0 lhs */\n      prop->m_bitsPerPixel.setValue(L\"32(RGBM)\");\n      break;\n    }\n\n  else if (bps == 64 && spp == 3)\n    prop->m_bitsPerPixel.setValue(L\"64(RGBM)\");\n\n  else\n    assert(false);\n\n  if (TIFFIsTiled(m_tiff)) {\n    m_rowsPerStrip  = tileLength;\n    int tilesPerRow = (w + tileWidth - 1) / tileWidth;\n    // m_rowLength = tileWidth * tilesPerRow;\n    m_rowLength   = m_info.m_lx;\n    int pixelSize = bps == 16 ? 8 : 4;\n    int stripSize = m_rowsPerStrip * m_rowLength * pixelSize;\n\n    m_tmpRas = TRasterGR8P(stripSize, 1);\n    m_tmpRas->lock();\n\n    m_stripBuffer = m_tmpRas->getRawData();\n  } else {\n    m_rowsPerStrip = rps;\n    // if(m_rowsPerStrip<=0) m_rowsPerStrip = 1;\t\t\t//potrei\n    // mettere\n    // qualsiasi\n    // valore\n    // purch sia lo stesso in tif_getimage.c linea 2512\n    // if(m_rowsPerStrip==-1) assert(0);\n\n    if (m_rowsPerStrip <= 0) m_rowsPerStrip = m_info.m_ly;\n\n    int stripSize = m_rowsPerStrip * w * 4;  // + 4096;  TIFFStripSize(m_tiff);\n\n    if (bps == 16) stripSize *= 2;\n\n    m_tmpRas = TRasterGR8P(stripSize, 1);\n    m_tmpRas->lock();\n\n    m_stripBuffer = m_tmpRas->getRawData();\n\n    m_rowLength = m_info.m_lx;  // w;\n  }\n\n  /*\nint TIFFTileRowSize(m_tiff);\n\nm_rowsPerStrip = 0;\nif(TIFFGetField(m_tiff, TIFFTAG_ROWSPERSTRIP, &rps) )\n{\nint stripSize = TIFFStripSize(m_tiff);\nif(stripSize>0)\n {\n }\n}\n*/\n  if (m_isTzi) {\n    USHORT risCount  = 0;\n    USHORT *risArray = 0;\n\n    if (TIFFGetField(m_tiff, TIFFTAG_TOONZWINDOW, &risCount, &risArray)) {\n      if (m_info.m_lx == risArray[2] &&\n          m_info.m_ly ==\n              risArray[3])  // se sono diverse, la lettura tif crasha....\n      {\n        // m_info.m_lx = risArray[2];\n        // m_info.m_ly = risArray[3];\n        m_info.m_x0 = risArray[0];\n        m_info.m_y0 = risArray[1];\n      }\n      //      USHORT extraMask = risArray[4];\n      // bool isEduFile = risArray[TOONZWINDOW_COUNT - 1] & 1;\n    } else {\n      m_info.m_x0 = 0;\n      m_info.m_y0 = 0;\n    }\n    if (swapxy) {\n      std::swap(m_info.m_x0, m_info.m_y0);\n      std::swap(m_info.m_lx, m_info.m_ly);\n    }\n    m_info.m_x1 = m_info.m_x0 + w;\n    m_info.m_y1 = m_info.m_y0 + h;\n  } else {\n    m_info.m_x0 = m_info.m_y0 = 0;\n    m_info.m_x1               = m_info.m_x0 + m_info.m_lx - 1;\n    m_info.m_y1               = m_info.m_y0 + m_info.m_ly - 1;\n  }\n}\n\n//------------------------------------------------------------\n\nint TifReader::skipLines(int lineCount) {\n  m_row += lineCount;\n  return lineCount;\n}\n\n//------------------------------------------------------------\n\n#include \"timage_io.h\"\n\nvoid TifReader::readLine(short *buffer, int x0, int x1, int shrink) {\n  assert(shrink > 0);\n\n  const int pixelSize = 8;\n  int stripRowSize    = m_rowLength * pixelSize;\n\n  if (m_row < m_info.m_y0 || m_row > m_info.m_y1) {\n    memset(buffer, 0, (x1 - x0 + 1) * pixelSize);\n    m_row++;\n    return;\n  }\n\n  int stripIndex = m_row / m_rowsPerStrip;\n  if (m_stripIndex != stripIndex) {\n    // Retrieve the strip holding current row. Please, observe that\n    // TIFF functions will return the strip buffer in the BOTTOM-UP orientation,\n    // no matter the internal tif's orientation storage\n\n    m_stripIndex = stripIndex;\n\n    if (TIFFIsTiled(m_tiff)) {\n      // Retrieve tiles size\n      uint32 tileWidth = 0, tileHeight = 0;\n      TIFFGetField(m_tiff, TIFFTAG_TILEWIDTH, &tileWidth);\n      TIFFGetField(m_tiff, TIFFTAG_TILELENGTH, &tileHeight);\n      assert(tileWidth > 0 && tileHeight > 0);\n\n      // Allocate a sufficient buffer to store a single tile\n      int tileSize = tileWidth * tileHeight;\n      std::unique_ptr<uint64[]> tile(new uint64[tileSize]);\n\n      int x = 0;\n      int y = tileHeight * m_stripIndex;\n\n      // In case it's the last tiles row, the tile size might exceed the image\n      // bounds\n      int lastTy = std::min((int)tileHeight, m_info.m_ly - y);\n\n      // Traverse the tiles row\n      while (x < m_info.m_lx) {\n        int ret = TIFFReadRGBATile_64(m_tiff, x, y, tile.get());\n        assert(ret);\n\n        int tileRowSize = std::min((int)tileWidth, m_info.m_lx - x) * pixelSize;\n\n        // Copy the tile rows in the corresponding output strip rows\n        for (int ty = 0; ty < lastTy; ++ty) {\n          memcpy(m_stripBuffer + (ty * m_rowLength + x) * pixelSize,\n                 (UCHAR *)tile.get() + ty * tileWidth * pixelSize, tileRowSize);\n        }\n\n        x += tileWidth;\n      }\n    } else {\n      int y  = m_rowsPerStrip * m_stripIndex;\n      int ok = TIFFReadRGBAStrip_64(m_tiff, y, (uint64 *)m_stripBuffer);\n      assert(ok);\n    }\n  }\n\n  uint16 orient = ORIENTATION_TOPLEFT;\n  TIFFGetField(m_tiff, TIFFTAG_ORIENTATION, &orient);\n\n  int r = m_rowsPerStrip - 1 - (m_row % m_rowsPerStrip);\n  switch (orient)  // Pretty weak check for top/bottom orientation\n  {\n  case ORIENTATION_TOPLEFT:\n  case ORIENTATION_TOPRIGHT:\n  case ORIENTATION_LEFTTOP:\n  case ORIENTATION_RIGHTTOP:\n    // We have to invert the fixed BOTTOM-UP returned by TIFF functions - since\n    // this function is\n    // supposed to ignore orientation issues (which are managed outside).\n\n    // The last tiles row will actually start at the END OF THE IMAGE (not\n    // necessarily at\n    // m_rowsPerStrip multiples). So, we must adjust for that.\n\n    r = std::min(m_rowsPerStrip, m_info.m_ly - m_rowsPerStrip * m_stripIndex) -\n        1 - (m_row % m_rowsPerStrip);\n    break;\n\n  case ORIENTATION_BOTRIGHT:\n  case ORIENTATION_BOTLEFT:\n  case ORIENTATION_RIGHTBOT:\n  case ORIENTATION_LEFTBOT:\n    r = m_row % m_rowsPerStrip;\n    break;\n  }\n\n  // Finally, copy the strip row to the output row buffer\n  TPixel64 *pix = (TPixel64 *)buffer;\n  USHORT *v     = (USHORT *)(m_stripBuffer + r * stripRowSize);\n\n  pix += x0;\n  v += 4 * x0;\n\n  int width =\n      (x1 < x0) ? (m_info.m_lx - 1) / shrink + 1 : (x1 - x0) / shrink + 1;\n\n  for (int i = 0; i < width; i++) {\n    USHORT c = *v++;\n    pix->r   = c;\n    c        = *v++;\n    pix->g   = c;\n    c        = *v++;\n    pix->b   = c;\n    c        = *v++;\n    pix->m   = c;\n\n    pix += shrink;\n    v += 4 * (shrink - 1);\n  }\n\n  m_row++;\n}\n\n//===============================================================\n\nvoid TifReader::readLine(char *buffer, int x0, int x1, int shrink) {\n  if (this->m_info.m_bitsPerSample == 16 &&\n      this->m_info.m_samplePerPixel >= 3) {\n    std::vector<short> app(4 * (m_info.m_lx));\n    readLine(&app[0], x0, x1, shrink);\n\n    TPixel64 *pixin = (TPixel64 *)&app[0];\n\n    TPixel32 *pixout = (TPixel32 *)buffer;\n    for (int j = 0; j < x0; j++) {\n      pixout++;\n      pixin++;\n    }\n\n    for (int i = 0; i < (x1 - x0) + 1; i++)\n      *pixout++ = PixelConverter<TPixel32>::from(*pixin++);\n\n    return;\n  }\n\n  assert(shrink > 0);\n\n  const int pixelSize = 4;\n  int stripRowSize    = m_rowLength * pixelSize;\n\n  if (m_row < m_info.m_y0 || m_row > m_info.m_y1) {\n    memset(buffer, 0, (x1 - x0 + 1) * pixelSize);\n    m_row++;\n    return;\n  }\n\n  int stripIndex = m_row / m_rowsPerStrip;\n  if (m_stripIndex != stripIndex) {\n    m_stripIndex = stripIndex;\n\n    if (TIFFIsTiled(m_tiff)) {\n      uint32 tileWidth = 0, tileHeight = 0;\n      TIFFGetField(m_tiff, TIFFTAG_TILEWIDTH, &tileWidth);\n      TIFFGetField(m_tiff, TIFFTAG_TILELENGTH, &tileHeight);\n      assert(tileWidth > 0 && tileHeight > 0);\n\n      int tileSize = tileWidth * tileHeight;\n      std::unique_ptr<uint32[]> tile(new uint32[tileSize]);\n\n      int x = 0;\n      int y = tileHeight * m_stripIndex;\n\n      int lastTy = std::min((int)tileHeight, m_info.m_ly - y);\n\n      while (x < m_info.m_lx) {\n        int ret = TIFFReadRGBATile(m_tiff, x, y, tile.get());\n        assert(ret);\n\n        int tileRowSize =\n            std::min((int)tileWidth, (int)(m_info.m_lx - x)) * pixelSize;\n\n        for (int ty = 0; ty < lastTy; ++ty) {\n          memcpy(m_stripBuffer + (ty * m_rowLength + x) * pixelSize,\n                 (UCHAR *)tile.get() + ty * tileWidth * pixelSize, tileRowSize);\n        }\n\n        x += tileWidth;\n      }\n    } else {\n      int y  = m_rowsPerStrip * m_stripIndex;\n      int ok = TIFFReadRGBAStrip(m_tiff, y, (uint32 *)m_stripBuffer);\n      assert(ok);\n    }\n  }\n\n  uint16 orient = ORIENTATION_TOPLEFT;\n  TIFFGetField(m_tiff, TIFFTAG_ORIENTATION, &orient);\n\n  int r = m_rowsPerStrip - 1 - (m_row % m_rowsPerStrip);\n  switch (orient)  // Pretty weak check for top/bottom orientation\n  {\n  case ORIENTATION_TOPLEFT:\n  case ORIENTATION_TOPRIGHT:\n  case ORIENTATION_LEFTTOP:\n  case ORIENTATION_RIGHTTOP:\n    // We have to invert the fixed BOTTOM-UP returned by TIFF functions - since\n    // this function is\n    // supposed to ignore orientation issues (which are managed outside).\n\n    // The last tiles row will actually start at the END OF THE IMAGE (not\n    // necessarily at\n    // m_rowsPerStrip multiples). So, we must adjust for that.\n\n    r = std::min(m_rowsPerStrip, m_info.m_ly - m_rowsPerStrip * m_stripIndex) -\n        1 - (m_row % m_rowsPerStrip);\n    break;\n\n  case ORIENTATION_BOTRIGHT:\n  case ORIENTATION_BOTLEFT:\n  case ORIENTATION_RIGHTBOT:\n  case ORIENTATION_LEFTBOT:\n    r = m_row % m_rowsPerStrip;\n    break;\n  }\n\n  TPixel32 *pix = (TPixel32 *)buffer;\n  uint32 *v     = (uint32 *)(m_stripBuffer + r * stripRowSize);\n\n  pix += x0;\n  v += x0;\n\n  int width =\n      (x1 < x0) ? (m_info.m_lx - 1) / shrink + 1 : (x1 - x0) / shrink + 1;\n\n  for (int i = 0; i < width; i++) {\n    uint32 c = *v;\n    pix->r   = (UCHAR)TIFFGetR(c);\n    pix->g   = (UCHAR)TIFFGetG(c);\n    pix->b   = (UCHAR)TIFFGetB(c);\n    pix->m   = (UCHAR)TIFFGetA(c);\n\n    v += shrink;\n    pix += shrink;\n  }\n\n  m_row++;\n}\n\n//============================================================\n\nTiio::TifWriterProperties::TifWriterProperties()\n    : m_byteOrdering(\"Byte Ordering\")\n    , m_compressionType(\"Compression Type\")\n    , m_bitsPerPixel(\"Bits Per Pixel\")\n    , m_orientation(\"Orientation\") {\n  m_byteOrdering.addValue(L\"IBM PC\");\n  m_byteOrdering.addValue(L\"Mac\");\n#ifdef _WIN32\n  m_byteOrdering.setValue(L\"IBM PC\");\n#else\n  m_byteOrdering.setValue(L\"Mac\");\n#endif\n  m_compressionType.addValue(TNZ_INFO_COMPRESS_LZW);\n  m_compressionType.addValue(TNZ_INFO_COMPRESS_NONE);\n  m_compressionType.addValue(TNZ_INFO_COMPRESS_PACKBITS);\n  m_compressionType.addValue(TNZ_INFO_COMPRESS_THUNDERSCAN);\n  m_compressionType.addValue(TNZ_INFO_COMPRESS_CCITTFAX3);\n  m_compressionType.addValue(TNZ_INFO_COMPRESS_CCITTFAX4);\n  m_compressionType.addValue(TNZ_INFO_COMPRESS_CCITTRLE);\n  m_compressionType.addValue(TNZ_INFO_COMPRESS_JPEG);\n  m_compressionType.addValue(TNZ_INFO_COMPRESS_OJPEG);\n\n  m_compressionType.addValue(TNZ_INFO_COMPRESS_SGILOG);\n  m_compressionType.addValue(TNZ_INFO_COMPRESS_SGILOG24);\n  m_compressionType.addValue(TNZ_INFO_COMPRESS_ADOBE_DEFLATE);\n  m_compressionType.addValue(TNZ_INFO_COMPRESS_DEFLATE);\n  m_compressionType.addValue(TNZ_INFO_COMPRESS_UNKNOWN);\n\n  m_compressionType.setValue(TNZ_INFO_COMPRESS_LZW);\n\n  m_bitsPerPixel.addValue(L\"24(RGB)\");\n  m_bitsPerPixel.addValue(L\"48(RGB)\");\n  m_bitsPerPixel.addValue(\n      L\" 1(BW)\");  // WATCH OUT! If you reorder this remember to look for\n  m_bitsPerPixel.addValue(L\" 8(GREYTONES)\");  // TRasterImage::isScanBW() usage\n                                              // that bpp choice index\n  // m_bitsPerPixel.addValue(L\"16(GREYTONES)\");                  // is HARDCODED\n  // nearby...                   -.-'\n  m_bitsPerPixel.addValue(L\"32(RGBM)\");\n  m_bitsPerPixel.addValue(L\"64(RGBM)\");\n\n  m_bitsPerPixel.setValue(L\"32(RGBM)\");\n\n  m_orientation.addValue(TNZ_INFO_ORIENT_TOPLEFT);\n  m_orientation.addValue(TNZ_INFO_ORIENT_TOPRIGHT);\n  m_orientation.addValue(TNZ_INFO_ORIENT_BOTRIGHT);\n  m_orientation.addValue(TNZ_INFO_ORIENT_BOTLEFT);\n  m_orientation.addValue(TNZ_INFO_ORIENT_LEFTTOP);\n  m_orientation.addValue(TNZ_INFO_ORIENT_RIGHTTOP);\n  m_orientation.addValue(TNZ_INFO_ORIENT_RIGHTBOT);\n  m_orientation.addValue(TNZ_INFO_ORIENT_LEFTBOT);\n\n  // m_orientation.setValue(TNZ_INFO_ORIENT_TOPLEFT);\n\n  bind(m_byteOrdering);\n  bind(m_compressionType);\n  bind(m_bitsPerPixel);\n  bind(m_orientation);\n}\n\nvoid Tiio::TifWriterProperties::updateTranslation() {\n  m_byteOrdering.setQStringName(tr(\"Byte Ordering\"));\n  m_compressionType.setQStringName(tr(\"Compression Type\"));\n  m_bitsPerPixel.setQStringName(tr(\"Bits Per Pixel\"));\n  m_bitsPerPixel.setItemUIName(L\"24(RGB)\", tr(\"24(RGB)\"));\n  m_bitsPerPixel.setItemUIName(L\"48(RGB)\", tr(\"48(RGB)\"));\n  m_bitsPerPixel.setItemUIName(L\" 1(BW)\", tr(\" 1(BW)\"));\n  m_bitsPerPixel.setItemUIName(L\" 8(GREYTONES)\", tr(\" 8(GREYTONES)\"));\n  m_bitsPerPixel.setItemUIName(L\"32(RGBM)\", tr(\"32(RGBA)\"));\n  m_bitsPerPixel.setItemUIName(L\"64(RGBM)\", tr(\"64(RGBA)\"));\n  m_orientation.setQStringName(tr(\"Orientation\"));\n  m_orientation.setItemUIName(TNZ_INFO_ORIENT_TOPLEFT, tr(\"Top Left\"));\n  m_orientation.setItemUIName(TNZ_INFO_ORIENT_TOPRIGHT, tr(\"Top Right\"));\n  m_orientation.setItemUIName(TNZ_INFO_ORIENT_BOTRIGHT, tr(\"Bottom Right\"));\n  m_orientation.setItemUIName(TNZ_INFO_ORIENT_BOTLEFT, tr(\"Bottom Left\"));\n  m_orientation.setItemUIName(TNZ_INFO_ORIENT_LEFTTOP, tr(\"Left Top\"));\n  m_orientation.setItemUIName(TNZ_INFO_ORIENT_RIGHTTOP, tr(\"Left Bottom\"));\n  m_orientation.setItemUIName(TNZ_INFO_ORIENT_RIGHTBOT, tr(\"Right Top\"));\n  m_orientation.setItemUIName(TNZ_INFO_ORIENT_LEFTBOT, tr(\"Right Bottom\"));\n}\n\n//============================================================\n\nclass TifWriter final : public Tiio::Writer {\n  TIFF *m_tiff;\n  int m_row;\n  // Tiio::TifWriterProperties m_properties;\n  unsigned char *m_lineBuffer;\n  Tiio::RowOrder m_rowOrder;\n  int m_bpp;\n  int m_RightToLeft;\n  void fillBits(UCHAR *bufout, UCHAR *bufin, int lx, int incr);\n\npublic:\n  TifWriter();\n  ~TifWriter();\n\n  void open(FILE *file, const TImageInfo &info) override;\n  void writeLine(char *buffer) override;\n  void writeLine(short *buffer) override;\n\n  void flush() override;\n\n  Tiio::RowOrder getRowOrder() const override { return m_rowOrder; }\n\n  // m_bpp is set to \"Bits Per Pixel\" property value in the function open()\n  bool writeAlphaSupported() const override {\n    return (m_bpp == 32 || m_bpp == 64);\n  }\n};\n\n//------------------------------------------------------------\n\nTifWriter::TifWriter()\n    : m_tiff(0), m_row(-1), m_lineBuffer(0), m_RightToLeft(false) {\n  TIFFSetWarningHandler(0);\n}\n\n//------------------------------------------------------------\n\nTifWriter::~TifWriter() {\n  if (m_tiff) TIFFClose(m_tiff);\n\n  delete[] m_lineBuffer;\n  delete m_properties;\n}\n\n//------------------------------------------------------------\n\nvoid TifWriter::open(FILE *file, const TImageInfo &info) {\n  m_info           = info;\n  std::string mode = \"w\";\n\n  if (!m_properties) m_properties = new Tiio::TifWriterProperties();\n\n  std::wstring byteOrdering =\n      ((TEnumProperty *)(m_properties->getProperty(\"Byte Ordering\")))\n          ->getValue();\n  if (byteOrdering == L\"IBM PC\")\n    mode += \"l\";\n  else\n    mode += \"b\";\n\n  TEnumProperty *p =\n      (TEnumProperty *)(m_properties->getProperty(\"Bits Per Pixel\"));\n  assert(p);\n  std::string str = ::to_string(p->getValue());\n  m_bpp           = atoi(str.c_str());\n  assert(m_bpp == 1 || m_bpp == 8 || m_bpp == 16 || m_bpp == 24 ||\n         m_bpp == 32 || m_bpp == 48 || m_bpp == 64);\n\n  int fd = fileno(file);\n#if 0\n\tm_tiff = TIFFFdOpenNoCloseProc(fd, \"\", mode.c_str());\n#elif defined(_WIN32) && defined(__GNUC__)\n  m_tiff = TIFFFdOpen((int)_get_osfhandle(dup(fd)), \"\", mode.c_str());\n#else\n  m_tiff = TIFFFdOpen(dup(fd), \"\", mode.c_str());\n#endif\n  if (!m_tiff) return;\n\n  std::wstring worientation =\n      ((TEnumProperty *)(m_properties->getProperty(\"Orientation\")))->getValue();\n\n  int orientation;\n  if (worientation == TNZ_INFO_ORIENT_TOPLEFT)\n    orientation = ORIENTATION_TOPLEFT;\n  else if (worientation == TNZ_INFO_ORIENT_TOPRIGHT)\n    orientation = ORIENTATION_TOPRIGHT;\n  else if (worientation == TNZ_INFO_ORIENT_BOTRIGHT)\n    orientation = ORIENTATION_BOTRIGHT;\n  else if (worientation == TNZ_INFO_ORIENT_BOTLEFT)\n    orientation = ORIENTATION_BOTLEFT;\n  else if (worientation == TNZ_INFO_ORIENT_LEFTTOP)\n    orientation = ORIENTATION_LEFTTOP;\n  else if (worientation == TNZ_INFO_ORIENT_RIGHTTOP)\n    orientation = ORIENTATION_RIGHTTOP;\n  else if (worientation == TNZ_INFO_ORIENT_RIGHTBOT)\n    orientation = ORIENTATION_RIGHTBOT;\n  else if (worientation == TNZ_INFO_ORIENT_LEFTBOT)\n    orientation = ORIENTATION_LEFTBOT;\n  else\n    assert(0);\n\n  switch (orientation) {\n  case ORIENTATION_TOPLEFT: /* row 0 top, col 0 lhs */\n    m_rowOrder = Tiio::TOP2BOTTOM;\n    break;\n  case ORIENTATION_TOPRIGHT: /* row 0 top, col 0 rhs */\n    m_rowOrder = Tiio::TOP2BOTTOM;\n    break;\n  case ORIENTATION_LEFTTOP: /* row 0 lhs, col 0 top */\n    m_rowOrder = Tiio::TOP2BOTTOM;\n    break;\n  case ORIENTATION_RIGHTTOP: /* row 0 rhs, col 0 top */\n    m_rowOrder = Tiio::TOP2BOTTOM;\n    break;\n\n  case ORIENTATION_BOTRIGHT: /* row 0 bottom, col 0 rhs */\n    m_rowOrder = Tiio::BOTTOM2TOP;\n    break;\n  case ORIENTATION_BOTLEFT: /* row 0 bottom, col 0 lhs */\n    m_rowOrder = Tiio::BOTTOM2TOP;\n    break;\n  case ORIENTATION_RIGHTBOT: /* row 0 rhs, col 0 bottom */\n    m_rowOrder = Tiio::BOTTOM2TOP;\n    break;\n  case ORIENTATION_LEFTBOT: /* row 0 lhs, col 0 bottom */\n    m_rowOrder = Tiio::BOTTOM2TOP;\n    break;\n  default:\n    m_rowOrder = Tiio::TOP2BOTTOM;\n    break;\n  }\n  m_RightToLeft = false;\n  if (orientation == ORIENTATION_TOPRIGHT ||\n      orientation == ORIENTATION_BOTRIGHT ||\n      orientation == ORIENTATION_RIGHTTOP ||\n      orientation == ORIENTATION_RIGHTBOT)\n    m_RightToLeft = true;\n\n  int bitsPerSample =\n      (m_bpp == 1) ? 1 : ((m_bpp == 8 || m_bpp == 24 || m_bpp == 32) ? 8 : 16);\n\n  TIFFSetField(m_tiff, TIFFTAG_IMAGEWIDTH, m_info.m_lx);\n  TIFFSetField(m_tiff, TIFFTAG_IMAGELENGTH, m_info.m_ly);\n  TIFFSetField(m_tiff, TIFFTAG_BITSPERSAMPLE, bitsPerSample);\n  TIFFSetField(m_tiff, TIFFTAG_SAMPLESPERPIXEL, m_bpp / bitsPerSample);\n  TIFFSetField(m_tiff, TIFFTAG_ORIENTATION, orientation);\n\n  if (m_bpp == 1)\n    TIFFSetField(m_tiff, TIFFTAG_COMPRESSION, COMPRESSION_CCITTFAX4);\n  else {\n    std::wstring compressionType =\n        ((TEnumProperty *)(m_properties->getProperty(\"Compression Type\")))\n            ->getValue();\n    if (compressionType == TNZ_INFO_COMPRESS_LZW || compressionType == TNZ_INFO_COMPRESS_LZW_LEG)\n      TIFFSetField(m_tiff, TIFFTAG_COMPRESSION, COMPRESSION_LZW);\n    else if (compressionType == TNZ_INFO_COMPRESS_PACKBITS)\n      TIFFSetField(m_tiff, TIFFTAG_COMPRESSION, COMPRESSION_PACKBITS);\n    else if (compressionType == TNZ_INFO_COMPRESS_CCITTFAX3)\n      TIFFSetField(m_tiff, TIFFTAG_COMPRESSION, COMPRESSION_CCITTFAX3);\n    else if (compressionType == TNZ_INFO_COMPRESS_CCITTFAX4)\n      TIFFSetField(m_tiff, TIFFTAG_COMPRESSION, COMPRESSION_CCITTFAX4);\n    else if (compressionType == TNZ_INFO_COMPRESS_CCITTRLE)\n      TIFFSetField(m_tiff, TIFFTAG_COMPRESSION, COMPRESSION_CCITTRLE);\n    else if (compressionType == TNZ_INFO_COMPRESS_JPEG)\n      TIFFSetField(m_tiff, TIFFTAG_COMPRESSION, COMPRESSION_JPEG);\n    else if (compressionType == TNZ_INFO_COMPRESS_OJPEG)\n      TIFFSetField(m_tiff, TIFFTAG_COMPRESSION, COMPRESSION_OJPEG);\n    else if (compressionType == TNZ_INFO_COMPRESS_NONE)\n      TIFFSetField(m_tiff, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n    else if (compressionType == TNZ_INFO_COMPRESS_THUNDERSCAN)\n      TIFFSetField(m_tiff, TIFFTAG_COMPRESSION, COMPRESSION_THUNDERSCAN);\n    else if (compressionType == TNZ_INFO_COMPRESS_ADOBE_DEFLATE)\n      TIFFSetField(m_tiff, TIFFTAG_COMPRESSION, COMPRESSION_ADOBE_DEFLATE);\n    else if (compressionType == TNZ_INFO_COMPRESS_DEFLATE)\n      TIFFSetField(m_tiff, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);\n    else\n      assert(false);\n  }\n  TIFFSetField(m_tiff, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n  TIFFSetField(\n      m_tiff, TIFFTAG_PHOTOMETRIC,\n      (m_bpp == 8 || m_bpp == 1) ? PHOTOMETRIC_MINISBLACK : PHOTOMETRIC_RGB);\n  TIFFSetField(m_tiff, TIFFTAG_XRESOLUTION, m_info.m_dpix);\n  TIFFSetField(m_tiff, TIFFTAG_YRESOLUTION, m_info.m_dpiy);\n  TIFFSetField(m_tiff, TIFFTAG_RESOLUTIONUNIT, RESUNIT_INCH);\n  TIFFSetField(m_tiff, TIFFTAG_ROWSPERSTRIP, TIFFDefaultStripSize(m_tiff, 0));\n\n  m_row = 0;\n  if (m_bpp == 1)\n    m_lineBuffer = new unsigned char[m_info.m_lx / 8 + 1];\n  else\n    m_lineBuffer =\n        new unsigned char[(m_bpp == 1 ? 1 : m_bpp / 8) * m_info.m_lx];\n}\n\n//------------------------------------------------------------\n\nvoid TifWriter::flush() { TIFFFlush(m_tiff); }\n\n//------------------------------------------------------------\n\nvoid TifWriter::writeLine(short *buffer) {\n  int delta = 1;\n  int start = 0;\n  if (m_RightToLeft) {\n    delta = -1;\n    start = m_info.m_lx - 1;\n  }\n  if (m_bpp == 16) {\n    unsigned short *pix = ((unsigned short *)buffer) + start;\n    for (int i = 0; i < m_info.m_lx; i++) {\n      unsigned short *b = (unsigned short *)m_lineBuffer + i * 2;\n      b[0]              = pix[0];\n      b[1]              = pix[1];\n      pix               = pix + delta;\n    }\n  } else {\n    assert(m_bpp == 48 || m_bpp == 64);\n    TPixel64 *pix = ((TPixel64 *)buffer) + start;\n\n    if (m_bpp == 64)\n      for (int i = 0; i < m_info.m_lx; i++) {\n        unsigned short *b = (unsigned short *)m_lineBuffer + i * 4;\n        b[0]              = pix->r;\n        b[1]              = pix->g;\n        b[2]              = pix->b;\n        b[3]              = pix->m;\n        pix               = pix + delta;\n      }\n    else if (m_bpp == 48)\n      for (int i = 0; i < m_info.m_lx; i++) {\n        unsigned short *b = (unsigned short *)m_lineBuffer + i * 3;\n        b[0]              = pix->r;\n        b[1]              = pix->g;\n        b[2]              = pix->b;\n        pix               = pix + delta;\n      }\n  }\n  TIFFWriteScanline(m_tiff, m_lineBuffer, m_row++, 0);\n}\n\n//------------------------------------------------------------\n\nvoid TifWriter::fillBits(UCHAR *bufout, UCHAR *bufin, int lx, int incr) {\n  int lx1 = lx / 8 + ((lx % 8) ? 1 : 0);\n\n  for (int i = 0; i < lx1; i++, bufout++) {\n    UCHAR pix = 0xff;\n    for (int j = 0; j < 8; j++, bufin += incr)\n      if (*bufin < m_bwThreshold) pix &= ~(0x1 << (7 - j));\n    *bufout = pix;\n  }\n}\n\n//------------------------------------------------------\n\nvoid TifWriter::writeLine(char *buffer) {\n  int delta = 1;\n  int start = 0;\n  if (m_RightToLeft) {\n    delta = -1;\n    start = m_info.m_lx - 1;\n  }\n  if (m_bpp == 1)\n    fillBits(m_lineBuffer, ((unsigned char *)buffer) + start, m_info.m_lx,\n             delta);\n  else if (m_bpp == 8) {\n    unsigned char *pix = ((unsigned char *)buffer) + start;\n    for (int i = 0; i < m_info.m_lx; i++) {\n      unsigned char *b = m_lineBuffer + i;\n      b[0]             = pix[0];\n      pix              = pix + delta;\n    }\n  } else {\n    assert(m_bpp == 24 || m_bpp == 32);\n    TPixel32 *pix = ((TPixel32 *)buffer) + start;\n\n    if (m_bpp == 32)\n      for (int i = 0; i < m_info.m_lx; i++) {\n        unsigned char *b = m_lineBuffer + i * 4;\n        b[0]             = pix->r;\n        b[1]             = pix->g;\n        b[2]             = pix->b;\n        b[3]             = pix->m;\n        pix              = pix + delta;\n      }\n    else if (m_bpp == 24)\n      for (int i = 0; i < m_info.m_lx; i++) {\n        unsigned char *b = m_lineBuffer + i * 3;\n        b[0]             = pix->r;\n        b[1]             = pix->g;\n        b[2]             = pix->b;\n        pix              = pix + delta;\n      }\n  }\n  TIFFWriteScanline(m_tiff, m_lineBuffer, m_row++, 0);\n}\n\n//============================================================\n#ifdef _DEBUG\n/* Error & Warning Handler per debug */\n\nextern \"C\" {\nstatic void MyWarningHandler(const char *module, const char *fmt, va_list ap) {\n  std::string outMsg;\n  char msg[2048];\n  msg[0] = 0;\n  if (module != NULL) outMsg = std::string(module);\n  outMsg += \"Warning, \";\n\n  _vsnprintf(msg, 2048, fmt, ap);\n  strcat(msg, \".\\n\");\n\n  outMsg += msg;\n  TSystem::outputDebug(outMsg);\n}\n\nstatic void MyErrorHandler(const char *module, const char *fmt, va_list ap) {\n  std::string outMsg;\n  char msg[2048];\n  msg[0] = 0;\n  if (module != NULL) outMsg = std::string(module);\n  // outMsg += \"Warning, \";\n\n  _vsnprintf(msg, 2048, fmt, ap);\n  strcat(msg, \".\\n\");\n\n  outMsg += msg;\n  TSystem::outputDebug(outMsg);\n}\n}\n\n#endif\n\nTiio::Reader *Tiio::makeTifReader() {\n#ifdef _DEBUG\n  TIFFSetErrorHandler(MyErrorHandler);\n  TIFFSetWarningHandler(MyWarningHandler);\n#endif\n  return new TifReader(false);\n}\n\n//------------------------------------------------------------\n\nTiio::Reader *Tiio::makeTziReader() {\n#ifdef _DEBUG\n  TIFFSetErrorHandler(MyErrorHandler);\n  TIFFSetWarningHandler(MyWarningHandler);\n#endif\n  return new TifReader(true);\n}\n\n//------------------------------------------------------------\n\nTiio::Writer *Tiio::makeTifWriter() {\n#ifdef _DEBUG\n  TIFFSetErrorHandler(MyErrorHandler);\n  TIFFSetWarningHandler(MyWarningHandler);\n#endif\n\n  return new TifWriter();\n}\n",
                "name": "tiio_tif.cpp",
                "path": "toonz/sources/image/tif/tiio_tif.cpp",
                "url": "/github.com/opentoonz/opentoonz/-/blob/toonz/sources/image/tif/tiio_tif.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 464,
                    "offsetAndLengths": [
                        [
                            18,
                            16
                        ]
                    ],
                    "preview": "        int ret = TIFFReadRGBATile_64(m_tiff, x, y, tile.get());"
                },
                {
                    "limitHit": false,
                    "lineNumber": 593,
                    "offsetAndLengths": [
                        [
                            18,
                            16
                        ]
                    ],
                    "preview": "        int ret = TIFFReadRGBATile(m_tiff, x, y, tile.get());"
                }
            ],
            "repository": {
                "name": "github.com/opentoonz/opentoonz",
                "url": "/github.com/opentoonz/opentoonz"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "b6715ba10ccc73bcdd51b221e3d05e393d14ede4"
                },
                "content": "#if defined(_MSC_VER) && (_MSC_VER >= 1400)\n#define _CRT_SECURE_NO_DEPRECATE 1\n#endif\n#define IS_TIFF_MAIN\n\n#if defined(_WIN32)\n#include <io.h>\n#else\n#include <unistd.h>\n#endif\n\n#include <memory>\n\n#include \"tiio.h\"\n#include \"tpixel.h\"\n#include \"tsystem.h\"\n#include \"../tzp/toonztags.h\"\n#include \"tconvert.h\"\n#include \"tpixelutils.h\"\n#include \"traster.h\"\n\nextern \"C\" {\n#include \"tiffio.h\"\n}\n\n#include \"tiio_tif.h\"\n\n#ifdef _MSC_VER\n#pragma warning(disable : 4996)\n#endif\n\n#ifdef _WIN32\n#include \"windows.h\"\n#endif\n\n//**************************************************************************\n//    TifReader  implementation\n//**************************************************************************\n\nclass TifReader final : public Tiio::Reader {\n  TIFF *m_tiff;\n  int m_row;\n  bool m_tiled, m_stripped;\n  int m_rowsPerStrip;\n  int m_stripIndex;\n  int m_rowLength;\n  UCHAR *m_stripBuffer;\n  double m_xdpi, m_ydpi;\n  Tiio::RowOrder m_rowOrder;\n  bool is16bitEnabled;\n  bool m_isTzi;\n  TRasterGR8P m_tmpRas;\n\npublic:\n  TifReader(bool isTzi);\n  ~TifReader();\n\n  void open(FILE *file) override;\n\n  Tiio::RowOrder getRowOrder() const override { return m_rowOrder; }\n\n  bool read16BitIsEnabled() const override { return false; }\n\n  void enable16BitRead(bool enabled) override { is16bitEnabled = enabled; }\n\n  int skipLines(int lineCount) override;\n  void readLine(char *buffer, int x0, int x1, int shrink) override;\n  void readLine(short *buffer, int x0, int x1, int shrink) override;\n};\n\n//------------------------------------------------------------\n\nTifReader::TifReader(bool isTzi)\n    : m_tiff(0)\n    , m_row(0)\n    , m_rowsPerStrip(0)\n    , m_stripIndex(-1)\n    //, m_stripBuffer(0)\n    , m_rowLength(0)\n    , m_xdpi(0)\n    , m_ydpi(0)\n    , m_rowOrder(Tiio::TOP2BOTTOM)\n    , is16bitEnabled(true)\n    , m_isTzi(isTzi)\n    , m_tmpRas(0) {\n  TIFFSetWarningHandler(0);\n}\n\n//------------------------------------------------------------\n\nTifReader::~TifReader() {\n  if (m_tiff) TIFFClose(m_tiff);\n\n  if (m_tmpRas) m_tmpRas->unlock();\n\n  delete m_info.m_properties;\n}\n\n//------------------------------------------------------------\n\nvoid TifReader::open(FILE *file) {\n  int fd = fileno(file);\n#if 0\n\tm_tiff = TIFFFdOpenNoCloseProc(fd, \"\", \"rb\");\n#elif defined(_WIN32) && defined(__GNUC__)\n  m_tiff = TIFFFdOpen((int)_get_osfhandle(dup(fd)), \"\", \"rb\");\n#else\n  m_tiff = TIFFFdOpen(dup(fd), \"\", \"rb\");\n#endif\n  if (!m_tiff) {\n//    std::string str(\"Tiff file closed\");\n//    throw(str);\n    throw TException(\"Can't open file\");\n  }\n\n  uint32 w = 0, h = 0, rps = 0;\n  uint16 bps = 0, spp = 0;\n  uint32 tileWidth = 0, tileLength = 0;\n\n  // TIFFSetDirectory(m_tiff,1);\n  // TIFFGetField(m_tiff, TIFFTAG_PAGENUMBER, &pn);\n  // int pn = TIFFNumberOfDirectories(m_tiff);\n  // TIFFSetDirectory(m_tiff,1);\n  TIFFGetField(m_tiff, TIFFTAG_IMAGEWIDTH, &w);\n  TIFFGetField(m_tiff, TIFFTAG_IMAGELENGTH, &h);\n  TIFFGetField(m_tiff, TIFFTAG_BITSPERSAMPLE, &bps);\n  TIFFGetField(m_tiff, TIFFTAG_SAMPLESPERPIXEL, &spp);\n  TIFFGetField(m_tiff, TIFFTAG_ROWSPERSTRIP, &rps);\n  // int stripCount = TIFFNumberOfStrips(m_tiff);\n  // int tileCount = TIFFNumberOfTiles(m_tiff);\n  TIFFGetField(m_tiff, TIFFTAG_TILEWIDTH, &tileWidth);\n  TIFFGetField(m_tiff, TIFFTAG_TILELENGTH, &tileLength);\n  Tiio::TifWriterProperties *prop = new Tiio::TifWriterProperties();\n  m_info.m_properties             = prop;\n  uint16 orient                   = Tiio::TOP2BOTTOM;\n  if (TIFFGetField(m_tiff, TIFFTAG_ORIENTATION, &orient)) {\n    switch (orient) {\n    case ORIENTATION_TOPLEFT: /* row 0 top, col 0 lhs */\n      prop->m_orientation.setValue(TNZ_INFO_ORIENT_TOPLEFT);\n      m_rowOrder = Tiio::TOP2BOTTOM;\n      break;\n    case ORIENTATION_TOPRIGHT: /* row 0 top, col 0 rhs */\n      prop->m_orientation.setValue(TNZ_INFO_ORIENT_TOPRIGHT);\n      m_rowOrder = Tiio::TOP2BOTTOM;\n      break;\n    case ORIENTATION_LEFTTOP: /* row 0 lhs, col 0 top */\n      prop->m_orientation.setValue(TNZ_INFO_ORIENT_LEFTTOP);\n      m_rowOrder = Tiio::TOP2BOTTOM;\n      break;\n    case ORIENTATION_RIGHTTOP: /* row 0 rhs, col 0 top */\n      prop->m_orientation.setValue(TNZ_INFO_ORIENT_RIGHTTOP);\n      m_rowOrder = Tiio::TOP2BOTTOM;\n      break;\n\n    case ORIENTATION_BOTRIGHT: /* row 0 bottom, col 0 rhs */\n      prop->m_orientation.setValue(TNZ_INFO_ORIENT_BOTRIGHT);\n      m_rowOrder = Tiio::BOTTOM2TOP;\n      break;\n    case ORIENTATION_BOTLEFT: /* row 0 bottom, col 0 lhs */\n      prop->m_orientation.setValue(TNZ_INFO_ORIENT_BOTLEFT);\n      m_rowOrder = Tiio::BOTTOM2TOP;\n      break;\n    case ORIENTATION_RIGHTBOT: /* row 0 rhs, col 0 bottom */\n      prop->m_orientation.setValue(TNZ_INFO_ORIENT_RIGHTBOT);\n      m_rowOrder = Tiio::BOTTOM2TOP;\n      break;\n    case ORIENTATION_LEFTBOT: /* row 0 lhs, col 0 bottom */\n      prop->m_orientation.setValue(TNZ_INFO_ORIENT_LEFTBOT);\n      m_rowOrder = Tiio::BOTTOM2TOP;\n      break;\n    default:\n      prop->m_orientation.setValue(TNZ_INFO_ORIENT_NONE);\n      m_rowOrder = Tiio::TOP2BOTTOM;\n      break;\n    }\n  }\n\n  USHORT compression;\n  TIFFGetField(m_tiff, TIFFTAG_COMPRESSION, &compression);\n  switch (compression) {\n  case COMPRESSION_LZW:\n    prop->m_compressionType.setValue(TNZ_INFO_COMPRESS_LZW);\n    break;\n  case COMPRESSION_PACKBITS:\n    prop->m_compressionType.setValue(TNZ_INFO_COMPRESS_PACKBITS);\n    break;\n  case COMPRESSION_THUNDERSCAN:\n    prop->m_compressionType.setValue(TNZ_INFO_COMPRESS_THUNDERSCAN);\n    break;\n  case COMPRESSION_CCITTFAX3:\n    prop->m_compressionType.setValue(TNZ_INFO_COMPRESS_CCITTFAX3);\n    break;\n  case COMPRESSION_CCITTFAX4:\n    prop->m_compressionType.setValue(TNZ_INFO_COMPRESS_CCITTFAX4);\n    break;\n  case COMPRESSION_CCITTRLE:\n    prop->m_compressionType.setValue(TNZ_INFO_COMPRESS_CCITTRLE);\n    break;\n  case COMPRESSION_JPEG:\n    prop->m_compressionType.setValue(TNZ_INFO_COMPRESS_JPEG);\n    break;\n  case COMPRESSION_OJPEG:\n    prop->m_compressionType.setValue(TNZ_INFO_COMPRESS_OJPEG);\n    break;\n  case COMPRESSION_NONE:\n    prop->m_compressionType.setValue(TNZ_INFO_COMPRESS_NONE);\n    break;\n  case COMPRESSION_SGILOG:\n    prop->m_compressionType.setValue(TNZ_INFO_COMPRESS_SGILOG);\n    break;\n  case COMPRESSION_SGILOG24:\n    prop->m_compressionType.setValue(TNZ_INFO_COMPRESS_SGILOG24);\n    break;\n  case COMPRESSION_ADOBE_DEFLATE:\n    prop->m_compressionType.setValue(TNZ_INFO_COMPRESS_ADOBE_DEFLATE);\n    break;\n  case COMPRESSION_DEFLATE:\n    prop->m_compressionType.setValue(TNZ_INFO_COMPRESS_DEFLATE);\n    break;\n  /*default :\nprop->m_compressionType.setValue(TNZ_INFO_COMPRESS_UNKNOWN);\nbreak;*/\n  default:\n    assert(0);\n  }\n\n  float xdpi = 0, ydpi = 0;\n  TIFFGetField(m_tiff, TIFFTAG_XRESOLUTION, &xdpi);\n  TIFFGetField(m_tiff, TIFFTAG_YRESOLUTION, &ydpi);\n\n  bool swapxy = false;  // orient == ORIENTATION_RIGHTTOP;\n\n  if (swapxy) {\n    std::swap(w, h);\n    std::swap(xdpi, ydpi);\n  }\n\n  m_xdpi        = xdpi;\n  m_ydpi        = ydpi;\n  m_info.m_lx   = w;\n  m_info.m_ly   = h;\n  m_info.m_dpix = xdpi;\n  m_info.m_dpiy = ydpi;\n\n  m_info.m_samplePerPixel = spp;\n\n  if (bps == 64 && spp == 3) bps = 16;  // immagine con bpp = 192\n\n  uint16 photometric;  // codice di controllo\n  TIFFGetField(m_tiff, TIFFTAG_PHOTOMETRIC, &photometric);\n  if (photometric == 3 &&\n      (bps == 2 || bps == 4))  // immagini con PHOTOMATRIC_PALETTE\n    bps = 8;\n\n  if (photometric == 1 && (bps == 12 || bps == 24)) bps = 16;\n\n  if (bps == 6) bps = 4;  // immagini con bps = 6\n\n  if (bps == 10 || bps == 12 ||\n      bps == 14)  // immagini con bps = 10 , 12 , 14 , 24 , 32\n    bps                           = 8;\n  if (bps == 24 || bps == 32) bps = 16;\n\n  m_info.m_bitsPerSample = bps;\n\n  if (bps == 8) switch (spp) {\n    case 1: /* row 0 top, col 0 lhs */\n      prop->m_bitsPerPixel.setValue(L\" 8(GREYTONES)\");\n      break;\n    case 3: /* row 0 top, col 0 lhs */\n      prop->m_bitsPerPixel.setValue(L\"24(RGB)\");\n      break;\n    case 4: /* row 0 top, col 0 lhs */\n      prop->m_bitsPerPixel.setValue(L\"32(RGBM)\");\n      break;\n    }\n  else if (bps == 16)\n    switch (spp) {\n    case 1: /* row 0 top, col 0 lhs */\n      // prop->m_bitsPerPixel.setValue(L\"16(GREYTONES)\");\n      break;\n    case 3: /* row 0 top, col 0 lhs */\n      prop->m_bitsPerPixel.setValue(L\"48(RGB)\");\n      break;\n    case 4: /* row 0 top, col 0 lhs */\n      prop->m_bitsPerPixel.setValue(L\"64(RGBM)\");\n      break;\n    }\n\n  else if (bps == 2)\n    switch (spp) {\n    case 1: /* row 0 top, col 0 lhs */\n      prop->m_bitsPerPixel.setValue(L\"32(RGBM)\");\n      break;\n    case 3: /* row 0 top, col 0 lhs */\n      prop->m_bitsPerPixel.setValue(L\"32(RGBM)\");\n      break;\n    case 4: /* row 0 top, col 0 lhs */\n      prop->m_bitsPerPixel.setValue(L\"32(RGBM)\");\n      break;\n    }\n\n  else if (bps == 1)\n    switch (spp) {\n    case 1: /* row 0 top, col 0 lhs */\n      prop->m_bitsPerPixel.setValue(L\" 1(BW)\");\n      break;\n    case 3: /* row 0 top, col 0 lhs */\n      prop->m_bitsPerPixel.setValue(L\"32(RGBM)\");\n      break;\n    case 4: /* row 0 top, col 0 lhs */\n      prop->m_bitsPerPixel.setValue(L\"32(RGBM)\");\n      break;\n    }\n\n  else if (bps == 4)\n    switch (spp) {\n    case 1: /* row 0 top, col 0 lhs */\n      prop->m_bitsPerPixel.setValue(L\" 8(GREYTONES)\");\n      break;\n    case 3: /* row 0 top, col 0 lhs */\n      prop->m_bitsPerPixel.setValue(L\"32(RGBM)\");\n      break;\n    case 4: /* row 0 top, col 0 lhs */\n      prop->m_bitsPerPixel.setValue(L\"32(RGBM)\");\n      break;\n    }\n\n  else if (bps == 64 && spp == 3)\n    prop->m_bitsPerPixel.setValue(L\"64(RGBM)\");\n\n  else\n    assert(false);\n\n  if (TIFFIsTiled(m_tiff)) {\n    m_rowsPerStrip  = tileLength;\n    int tilesPerRow = (w + tileWidth - 1) / tileWidth;\n    // m_rowLength = tileWidth * tilesPerRow;\n    m_rowLength   = m_info.m_lx;\n    int pixelSize = bps == 16 ? 8 : 4;\n    int stripSize = m_rowsPerStrip * m_rowLength * pixelSize;\n\n    m_tmpRas = TRasterGR8P(stripSize, 1);\n    m_tmpRas->lock();\n\n    m_stripBuffer = m_tmpRas->getRawData();\n  } else {\n    m_rowsPerStrip = rps;\n    // if(m_rowsPerStrip<=0) m_rowsPerStrip = 1;\t\t\t//potrei\n    // mettere\n    // qualsiasi\n    // valore\n    // purch sia lo stesso in tif_getimage.c linea 2512\n    // if(m_rowsPerStrip==-1) assert(0);\n\n    if (m_rowsPerStrip <= 0) m_rowsPerStrip = m_info.m_ly;\n\n    int stripSize = m_rowsPerStrip * w * 4;  // + 4096;  TIFFStripSize(m_tiff);\n\n    if (bps == 16) stripSize *= 2;\n\n    m_tmpRas = TRasterGR8P(stripSize, 1);\n    m_tmpRas->lock();\n\n    m_stripBuffer = m_tmpRas->getRawData();\n\n    m_rowLength = m_info.m_lx;  // w;\n  }\n\n  /*\nint TIFFTileRowSize(m_tiff);\n\nm_rowsPerStrip = 0;\nif(TIFFGetField(m_tiff, TIFFTAG_ROWSPERSTRIP, &rps) )\n{\nint stripSize = TIFFStripSize(m_tiff);\nif(stripSize>0)\n {\n }\n}\n*/\n  if (m_isTzi) {\n    USHORT risCount  = 0;\n    USHORT *risArray = 0;\n\n    if (TIFFGetField(m_tiff, TIFFTAG_TOONZWINDOW, &risCount, &risArray)) {\n      if (m_info.m_lx == risArray[2] &&\n          m_info.m_ly ==\n              risArray[3])  // se sono diverse, la lettura tif crasha....\n      {\n        // m_info.m_lx = risArray[2];\n        // m_info.m_ly = risArray[3];\n        m_info.m_x0 = risArray[0];\n        m_info.m_y0 = risArray[1];\n      }\n      //      USHORT extraMask = risArray[4];\n      // bool isEduFile = risArray[TOONZWINDOW_COUNT - 1] & 1;\n    } else {\n      m_info.m_x0 = 0;\n      m_info.m_y0 = 0;\n    }\n    if (swapxy) {\n      std::swap(m_info.m_x0, m_info.m_y0);\n      std::swap(m_info.m_lx, m_info.m_ly);\n    }\n    m_info.m_x1 = m_info.m_x0 + w;\n    m_info.m_y1 = m_info.m_y0 + h;\n  } else {\n    m_info.m_x0 = m_info.m_y0 = 0;\n    m_info.m_x1               = m_info.m_x0 + m_info.m_lx - 1;\n    m_info.m_y1               = m_info.m_y0 + m_info.m_ly - 1;\n  }\n}\n\n//------------------------------------------------------------\n\nint TifReader::skipLines(int lineCount) {\n  m_row += lineCount;\n  return lineCount;\n}\n\n//------------------------------------------------------------\n\n#include \"timage_io.h\"\n\nvoid TifReader::readLine(short *buffer, int x0, int x1, int shrink) {\n  assert(shrink > 0);\n\n  const int pixelSize = 8;\n  int stripRowSize    = m_rowLength * pixelSize;\n\n  if (m_row < m_info.m_y0 || m_row > m_info.m_y1) {\n    memset(buffer, 0, (x1 - x0 + 1) * pixelSize);\n    m_row++;\n    return;\n  }\n\n  int stripIndex = m_row / m_rowsPerStrip;\n  if (m_stripIndex != stripIndex) {\n    // Retrieve the strip holding current row. Please, observe that\n    // TIFF functions will return the strip buffer in the BOTTOM-UP orientation,\n    // no matter the internal tif's orientation storage\n\n    m_stripIndex = stripIndex;\n\n    if (TIFFIsTiled(m_tiff)) {\n      // Retrieve tiles size\n      uint32 tileWidth = 0, tileHeight = 0;\n      TIFFGetField(m_tiff, TIFFTAG_TILEWIDTH, &tileWidth);\n      TIFFGetField(m_tiff, TIFFTAG_TILELENGTH, &tileHeight);\n      assert(tileWidth > 0 && tileHeight > 0);\n\n      // Allocate a sufficient buffer to store a single tile\n      int tileSize = tileWidth * tileHeight;\n      std::unique_ptr<uint64[]> tile(new uint64[tileSize]);\n\n      int x = 0;\n      int y = tileHeight * m_stripIndex;\n\n      // In case it's the last tiles row, the tile size might exceed the image\n      // bounds\n      int lastTy = std::min((int)tileHeight, m_info.m_ly - y);\n\n      // Traverse the tiles row\n      while (x < m_info.m_lx) {\n        int ret = TIFFReadRGBATile_64(m_tiff, x, y, tile.get());\n        assert(ret);\n\n        int tileRowSize = std::min((int)tileWidth, m_info.m_lx - x) * pixelSize;\n\n        // Copy the tile rows in the corresponding output strip rows\n        for (int ty = 0; ty < lastTy; ++ty) {\n          memcpy(m_stripBuffer + (ty * m_rowLength + x) * pixelSize,\n                 (UCHAR *)tile.get() + ty * tileWidth * pixelSize, tileRowSize);\n        }\n\n        x += tileWidth;\n      }\n    } else {\n      int y  = m_rowsPerStrip * m_stripIndex;\n      int ok = TIFFReadRGBAStrip_64(m_tiff, y, (uint64 *)m_stripBuffer);\n      assert(ok);\n    }\n  }\n\n  uint16 orient = ORIENTATION_TOPLEFT;\n  TIFFGetField(m_tiff, TIFFTAG_ORIENTATION, &orient);\n\n  int r = m_rowsPerStrip - 1 - (m_row % m_rowsPerStrip);\n  switch (orient)  // Pretty weak check for top/bottom orientation\n  {\n  case ORIENTATION_TOPLEFT:\n  case ORIENTATION_TOPRIGHT:\n  case ORIENTATION_LEFTTOP:\n  case ORIENTATION_RIGHTTOP:\n    // We have to invert the fixed BOTTOM-UP returned by TIFF functions - since\n    // this function is\n    // supposed to ignore orientation issues (which are managed outside).\n\n    // The last tiles row will actually start at the END OF THE IMAGE (not\n    // necessarily at\n    // m_rowsPerStrip multiples). So, we must adjust for that.\n\n    r = std::min(m_rowsPerStrip, m_info.m_ly - m_rowsPerStrip * m_stripIndex) -\n        1 - (m_row % m_rowsPerStrip);\n    break;\n\n  case ORIENTATION_BOTRIGHT:\n  case ORIENTATION_BOTLEFT:\n  case ORIENTATION_RIGHTBOT:\n  case ORIENTATION_LEFTBOT:\n    r = m_row % m_rowsPerStrip;\n    break;\n  }\n\n  // Finally, copy the strip row to the output row buffer\n  TPixel64 *pix = (TPixel64 *)buffer;\n  USHORT *v     = (USHORT *)(m_stripBuffer + r * stripRowSize);\n\n  pix += x0;\n  v += 4 * x0;\n\n  int width =\n      (x1 < x0) ? (m_info.m_lx - 1) / shrink + 1 : (x1 - x0) / shrink + 1;\n\n  for (int i = 0; i < width; i++) {\n    USHORT c = *v++;\n    pix->r   = c;\n    c        = *v++;\n    pix->g   = c;\n    c        = *v++;\n    pix->b   = c;\n    c        = *v++;\n    pix->m   = c;\n\n    pix += shrink;\n    v += 4 * (shrink - 1);\n  }\n\n  m_row++;\n}\n\n//===============================================================\n\nvoid TifReader::readLine(char *buffer, int x0, int x1, int shrink) {\n  if (this->m_info.m_bitsPerSample == 16 &&\n      this->m_info.m_samplePerPixel >= 3) {\n    std::vector<short> app(4 * (m_info.m_lx));\n    readLine(&app[0], x0, x1, shrink);\n\n    TPixel64 *pixin = (TPixel64 *)&app[0];\n\n    TPixel32 *pixout = (TPixel32 *)buffer;\n    for (int j = 0; j < x0; j++) {\n      pixout++;\n      pixin++;\n    }\n\n    for (int i = 0; i < (x1 - x0) + 1; i++)\n      *pixout++ = PixelConverter<TPixel32>::from(*pixin++);\n\n    return;\n  }\n\n  assert(shrink > 0);\n\n  const int pixelSize = 4;\n  int stripRowSize    = m_rowLength * pixelSize;\n\n  if (m_row < m_info.m_y0 || m_row > m_info.m_y1) {\n    memset(buffer, 0, (x1 - x0 + 1) * pixelSize);\n    m_row++;\n    return;\n  }\n\n  int stripIndex = m_row / m_rowsPerStrip;\n  if (m_stripIndex != stripIndex) {\n    m_stripIndex = stripIndex;\n\n    if (TIFFIsTiled(m_tiff)) {\n      uint32 tileWidth = 0, tileHeight = 0;\n      TIFFGetField(m_tiff, TIFFTAG_TILEWIDTH, &tileWidth);\n      TIFFGetField(m_tiff, TIFFTAG_TILELENGTH, &tileHeight);\n      assert(tileWidth > 0 && tileHeight > 0);\n\n      int tileSize = tileWidth * tileHeight;\n      std::unique_ptr<uint32[]> tile(new uint32[tileSize]);\n\n      int x = 0;\n      int y = tileHeight * m_stripIndex;\n\n      int lastTy = std::min((int)tileHeight, m_info.m_ly - y);\n\n      while (x < m_info.m_lx) {\n        int ret = TIFFReadRGBATile(m_tiff, x, y, tile.get());\n        assert(ret);\n\n        int tileRowSize =\n            std::min((int)tileWidth, (int)(m_info.m_lx - x)) * pixelSize;\n\n        for (int ty = 0; ty < lastTy; ++ty) {\n          memcpy(m_stripBuffer + (ty * m_rowLength + x) * pixelSize,\n                 (UCHAR *)tile.get() + ty * tileWidth * pixelSize, tileRowSize);\n        }\n\n        x += tileWidth;\n      }\n    } else {\n      int y  = m_rowsPerStrip * m_stripIndex;\n      int ok = TIFFReadRGBAStrip(m_tiff, y, (uint32 *)m_stripBuffer);\n      assert(ok);\n    }\n  }\n\n  uint16 orient = ORIENTATION_TOPLEFT;\n  TIFFGetField(m_tiff, TIFFTAG_ORIENTATION, &orient);\n\n  int r = m_rowsPerStrip - 1 - (m_row % m_rowsPerStrip);\n  switch (orient)  // Pretty weak check for top/bottom orientation\n  {\n  case ORIENTATION_TOPLEFT:\n  case ORIENTATION_TOPRIGHT:\n  case ORIENTATION_LEFTTOP:\n  case ORIENTATION_RIGHTTOP:\n    // We have to invert the fixed BOTTOM-UP returned by TIFF functions - since\n    // this function is\n    // supposed to ignore orientation issues (which are managed outside).\n\n    // The last tiles row will actually start at the END OF THE IMAGE (not\n    // necessarily at\n    // m_rowsPerStrip multiples). So, we must adjust for that.\n\n    r = std::min(m_rowsPerStrip, m_info.m_ly - m_rowsPerStrip * m_stripIndex) -\n        1 - (m_row % m_rowsPerStrip);\n    break;\n\n  case ORIENTATION_BOTRIGHT:\n  case ORIENTATION_BOTLEFT:\n  case ORIENTATION_RIGHTBOT:\n  case ORIENTATION_LEFTBOT:\n    r = m_row % m_rowsPerStrip;\n    break;\n  }\n\n  TPixel32 *pix = (TPixel32 *)buffer;\n  uint32 *v     = (uint32 *)(m_stripBuffer + r * stripRowSize);\n\n  pix += x0;\n  v += x0;\n\n  int width =\n      (x1 < x0) ? (m_info.m_lx - 1) / shrink + 1 : (x1 - x0) / shrink + 1;\n\n  for (int i = 0; i < width; i++) {\n    uint32 c = *v;\n    pix->r   = (UCHAR)TIFFGetR(c);\n    pix->g   = (UCHAR)TIFFGetG(c);\n    pix->b   = (UCHAR)TIFFGetB(c);\n    pix->m   = (UCHAR)TIFFGetA(c);\n\n    v += shrink;\n    pix += shrink;\n  }\n\n  m_row++;\n}\n\n//============================================================\n\nTiio::TifWriterProperties::TifWriterProperties()\n    : m_byteOrdering(\"Byte Ordering\")\n    , m_compressionType(\"Compression Type\")\n    , m_bitsPerPixel(\"Bits Per Pixel\")\n    , m_orientation(\"Orientation\") {\n  m_byteOrdering.addValue(L\"IBM PC\");\n  m_byteOrdering.addValue(L\"Mac\");\n#ifdef _WIN32\n  m_byteOrdering.setValue(L\"IBM PC\");\n#else\n  m_byteOrdering.setValue(L\"Mac\");\n#endif\n  m_compressionType.addValue(TNZ_INFO_COMPRESS_LZW);\n  m_compressionType.addValue(TNZ_INFO_COMPRESS_NONE);\n  m_compressionType.addValue(TNZ_INFO_COMPRESS_PACKBITS);\n  m_compressionType.addValue(TNZ_INFO_COMPRESS_THUNDERSCAN);\n  m_compressionType.addValue(TNZ_INFO_COMPRESS_CCITTFAX3);\n  m_compressionType.addValue(TNZ_INFO_COMPRESS_CCITTFAX4);\n  m_compressionType.addValue(TNZ_INFO_COMPRESS_CCITTRLE);\n  m_compressionType.addValue(TNZ_INFO_COMPRESS_JPEG);\n  m_compressionType.addValue(TNZ_INFO_COMPRESS_OJPEG);\n\n  m_compressionType.addValue(TNZ_INFO_COMPRESS_SGILOG);\n  m_compressionType.addValue(TNZ_INFO_COMPRESS_SGILOG24);\n  m_compressionType.addValue(TNZ_INFO_COMPRESS_ADOBE_DEFLATE);\n  m_compressionType.addValue(TNZ_INFO_COMPRESS_DEFLATE);\n  m_compressionType.addValue(TNZ_INFO_COMPRESS_UNKNOWN);\n\n  m_compressionType.setValue(TNZ_INFO_COMPRESS_LZW);\n\n  m_bitsPerPixel.addValue(L\"24(RGB)\");\n  m_bitsPerPixel.addValue(L\"48(RGB)\");\n  m_bitsPerPixel.addValue(\n      L\" 1(BW)\");  // WATCH OUT! If you reorder this remember to look for\n  m_bitsPerPixel.addValue(L\" 8(GREYTONES)\");  // TRasterImage::isScanBW() usage\n                                              // that bpp choice index\n  // m_bitsPerPixel.addValue(L\"16(GREYTONES)\");                  // is HARDCODED\n  // nearby...                   -.-'\n  m_bitsPerPixel.addValue(L\"32(RGBM)\");\n  m_bitsPerPixel.addValue(L\"64(RGBM)\");\n\n  m_bitsPerPixel.setValue(L\"32(RGBM)\");\n\n  m_orientation.addValue(TNZ_INFO_ORIENT_TOPLEFT);\n  m_orientation.addValue(TNZ_INFO_ORIENT_TOPRIGHT);\n  m_orientation.addValue(TNZ_INFO_ORIENT_BOTRIGHT);\n  m_orientation.addValue(TNZ_INFO_ORIENT_BOTLEFT);\n  m_orientation.addValue(TNZ_INFO_ORIENT_LEFTTOP);\n  m_orientation.addValue(TNZ_INFO_ORIENT_RIGHTTOP);\n  m_orientation.addValue(TNZ_INFO_ORIENT_RIGHTBOT);\n  m_orientation.addValue(TNZ_INFO_ORIENT_LEFTBOT);\n\n  // m_orientation.setValue(TNZ_INFO_ORIENT_TOPLEFT);\n\n  bind(m_byteOrdering);\n  bind(m_compressionType);\n  bind(m_bitsPerPixel);\n  bind(m_orientation);\n}\n\nvoid Tiio::TifWriterProperties::updateTranslation() {\n  m_byteOrdering.setQStringName(tr(\"Byte Ordering\"));\n  m_compressionType.setQStringName(tr(\"Compression Type\"));\n  m_bitsPerPixel.setQStringName(tr(\"Bits Per Pixel\"));\n  m_bitsPerPixel.setItemUIName(L\"24(RGB)\", tr(\"24(RGB)\"));\n  m_bitsPerPixel.setItemUIName(L\"48(RGB)\", tr(\"48(RGB)\"));\n  m_bitsPerPixel.setItemUIName(L\" 1(BW)\", tr(\" 1(BW)\"));\n  m_bitsPerPixel.setItemUIName(L\" 8(GREYTONES)\", tr(\" 8(GREYTONES)\"));\n  m_bitsPerPixel.setItemUIName(L\"32(RGBM)\", tr(\"32(RGBA)\"));\n  m_bitsPerPixel.setItemUIName(L\"64(RGBM)\", tr(\"64(RGBA)\"));\n  m_orientation.setQStringName(tr(\"Orientation\"));\n  m_orientation.setItemUIName(TNZ_INFO_ORIENT_TOPLEFT, tr(\"Top Left\"));\n  m_orientation.setItemUIName(TNZ_INFO_ORIENT_TOPRIGHT, tr(\"Top Right\"));\n  m_orientation.setItemUIName(TNZ_INFO_ORIENT_BOTRIGHT, tr(\"Bottom Right\"));\n  m_orientation.setItemUIName(TNZ_INFO_ORIENT_BOTLEFT, tr(\"Bottom Left\"));\n  m_orientation.setItemUIName(TNZ_INFO_ORIENT_LEFTTOP, tr(\"Left Top\"));\n  m_orientation.setItemUIName(TNZ_INFO_ORIENT_RIGHTTOP, tr(\"Left Bottom\"));\n  m_orientation.setItemUIName(TNZ_INFO_ORIENT_RIGHTBOT, tr(\"Right Top\"));\n  m_orientation.setItemUIName(TNZ_INFO_ORIENT_LEFTBOT, tr(\"Right Bottom\"));\n}\n\n//============================================================\n\nclass TifWriter final : public Tiio::Writer {\n  TIFF *m_tiff;\n  int m_row;\n  // Tiio::TifWriterProperties m_properties;\n  unsigned char *m_lineBuffer;\n  Tiio::RowOrder m_rowOrder;\n  int m_bpp;\n  int m_RightToLeft;\n  void fillBits(UCHAR *bufout, UCHAR *bufin, int lx, int incr);\n\npublic:\n  TifWriter();\n  ~TifWriter();\n\n  void open(FILE *file, const TImageInfo &info) override;\n  void writeLine(char *buffer) override;\n  void writeLine(short *buffer) override;\n\n  void flush() override;\n\n  Tiio::RowOrder getRowOrder() const override { return m_rowOrder; }\n\n  // m_bpp is set to \"Bits Per Pixel\" property value in the function open()\n  bool writeAlphaSupported() const override {\n    return (m_bpp == 32 || m_bpp == 64);\n  }\n};\n\n//------------------------------------------------------------\n\nTifWriter::TifWriter()\n    : m_tiff(0), m_row(-1), m_lineBuffer(0), m_RightToLeft(false) {\n  TIFFSetWarningHandler(0);\n}\n\n//------------------------------------------------------------\n\nTifWriter::~TifWriter() {\n  if (m_tiff) TIFFClose(m_tiff);\n\n  delete[] m_lineBuffer;\n  delete m_properties;\n}\n\n//------------------------------------------------------------\n\nvoid TifWriter::open(FILE *file, const TImageInfo &info) {\n  m_info           = info;\n  std::string mode = \"w\";\n\n  if (!m_properties) m_properties = new Tiio::TifWriterProperties();\n\n  std::wstring byteOrdering =\n      ((TEnumProperty *)(m_properties->getProperty(\"Byte Ordering\")))\n          ->getValue();\n  if (byteOrdering == L\"IBM PC\")\n    mode += \"l\";\n  else\n    mode += \"b\";\n\n  TEnumProperty *p =\n      (TEnumProperty *)(m_properties->getProperty(\"Bits Per Pixel\"));\n  assert(p);\n  std::string str = ::to_string(p->getValue());\n  m_bpp           = atoi(str.c_str());\n  assert(m_bpp == 1 || m_bpp == 8 || m_bpp == 16 || m_bpp == 24 ||\n         m_bpp == 32 || m_bpp == 48 || m_bpp == 64);\n\n  int fd = fileno(file);\n#if 0\n\tm_tiff = TIFFFdOpenNoCloseProc(fd, \"\", mode.c_str());\n#elif defined(_WIN32) && defined(__GNUC__)\n  m_tiff = TIFFFdOpen((int)_get_osfhandle(dup(fd)), \"\", mode.c_str());\n#else\n  m_tiff = TIFFFdOpen(dup(fd), \"\", mode.c_str());\n#endif\n  if (!m_tiff) return;\n\n  std::wstring worientation =\n      ((TEnumProperty *)(m_properties->getProperty(\"Orientation\")))->getValue();\n\n  int orientation;\n  if (worientation == TNZ_INFO_ORIENT_TOPLEFT)\n    orientation = ORIENTATION_TOPLEFT;\n  else if (worientation == TNZ_INFO_ORIENT_TOPRIGHT)\n    orientation = ORIENTATION_TOPRIGHT;\n  else if (worientation == TNZ_INFO_ORIENT_BOTRIGHT)\n    orientation = ORIENTATION_BOTRIGHT;\n  else if (worientation == TNZ_INFO_ORIENT_BOTLEFT)\n    orientation = ORIENTATION_BOTLEFT;\n  else if (worientation == TNZ_INFO_ORIENT_LEFTTOP)\n    orientation = ORIENTATION_LEFTTOP;\n  else if (worientation == TNZ_INFO_ORIENT_RIGHTTOP)\n    orientation = ORIENTATION_RIGHTTOP;\n  else if (worientation == TNZ_INFO_ORIENT_RIGHTBOT)\n    orientation = ORIENTATION_RIGHTBOT;\n  else if (worientation == TNZ_INFO_ORIENT_LEFTBOT)\n    orientation = ORIENTATION_LEFTBOT;\n  else\n    assert(0);\n\n  switch (orientation) {\n  case ORIENTATION_TOPLEFT: /* row 0 top, col 0 lhs */\n    m_rowOrder = Tiio::TOP2BOTTOM;\n    break;\n  case ORIENTATION_TOPRIGHT: /* row 0 top, col 0 rhs */\n    m_rowOrder = Tiio::TOP2BOTTOM;\n    break;\n  case ORIENTATION_LEFTTOP: /* row 0 lhs, col 0 top */\n    m_rowOrder = Tiio::TOP2BOTTOM;\n    break;\n  case ORIENTATION_RIGHTTOP: /* row 0 rhs, col 0 top */\n    m_rowOrder = Tiio::TOP2BOTTOM;\n    break;\n\n  case ORIENTATION_BOTRIGHT: /* row 0 bottom, col 0 rhs */\n    m_rowOrder = Tiio::BOTTOM2TOP;\n    break;\n  case ORIENTATION_BOTLEFT: /* row 0 bottom, col 0 lhs */\n    m_rowOrder = Tiio::BOTTOM2TOP;\n    break;\n  case ORIENTATION_RIGHTBOT: /* row 0 rhs, col 0 bottom */\n    m_rowOrder = Tiio::BOTTOM2TOP;\n    break;\n  case ORIENTATION_LEFTBOT: /* row 0 lhs, col 0 bottom */\n    m_rowOrder = Tiio::BOTTOM2TOP;\n    break;\n  default:\n    m_rowOrder = Tiio::TOP2BOTTOM;\n    break;\n  }\n  m_RightToLeft = false;\n  if (orientation == ORIENTATION_TOPRIGHT ||\n      orientation == ORIENTATION_BOTRIGHT ||\n      orientation == ORIENTATION_RIGHTTOP ||\n      orientation == ORIENTATION_RIGHTBOT)\n    m_RightToLeft = true;\n\n  int bitsPerSample =\n      (m_bpp == 1) ? 1 : ((m_bpp == 8 || m_bpp == 24 || m_bpp == 32) ? 8 : 16);\n\n  TIFFSetField(m_tiff, TIFFTAG_IMAGEWIDTH, m_info.m_lx);\n  TIFFSetField(m_tiff, TIFFTAG_IMAGELENGTH, m_info.m_ly);\n  TIFFSetField(m_tiff, TIFFTAG_BITSPERSAMPLE, bitsPerSample);\n  TIFFSetField(m_tiff, TIFFTAG_SAMPLESPERPIXEL, m_bpp / bitsPerSample);\n  TIFFSetField(m_tiff, TIFFTAG_ORIENTATION, orientation);\n\n  if (m_bpp == 1)\n    TIFFSetField(m_tiff, TIFFTAG_COMPRESSION, COMPRESSION_CCITTFAX4);\n  else {\n    std::wstring compressionType =\n        ((TEnumProperty *)(m_properties->getProperty(\"Compression Type\")))\n            ->getValue();\n    if (compressionType == TNZ_INFO_COMPRESS_LZW || compressionType == TNZ_INFO_COMPRESS_LZW_LEG)\n      TIFFSetField(m_tiff, TIFFTAG_COMPRESSION, COMPRESSION_LZW);\n    else if (compressionType == TNZ_INFO_COMPRESS_PACKBITS)\n      TIFFSetField(m_tiff, TIFFTAG_COMPRESSION, COMPRESSION_PACKBITS);\n    else if (compressionType == TNZ_INFO_COMPRESS_CCITTFAX3)\n      TIFFSetField(m_tiff, TIFFTAG_COMPRESSION, COMPRESSION_CCITTFAX3);\n    else if (compressionType == TNZ_INFO_COMPRESS_CCITTFAX4)\n      TIFFSetField(m_tiff, TIFFTAG_COMPRESSION, COMPRESSION_CCITTFAX4);\n    else if (compressionType == TNZ_INFO_COMPRESS_CCITTRLE)\n      TIFFSetField(m_tiff, TIFFTAG_COMPRESSION, COMPRESSION_CCITTRLE);\n    else if (compressionType == TNZ_INFO_COMPRESS_JPEG)\n      TIFFSetField(m_tiff, TIFFTAG_COMPRESSION, COMPRESSION_JPEG);\n    else if (compressionType == TNZ_INFO_COMPRESS_OJPEG)\n      TIFFSetField(m_tiff, TIFFTAG_COMPRESSION, COMPRESSION_OJPEG);\n    else if (compressionType == TNZ_INFO_COMPRESS_NONE)\n      TIFFSetField(m_tiff, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n    else if (compressionType == TNZ_INFO_COMPRESS_THUNDERSCAN)\n      TIFFSetField(m_tiff, TIFFTAG_COMPRESSION, COMPRESSION_THUNDERSCAN);\n    else if (compressionType == TNZ_INFO_COMPRESS_ADOBE_DEFLATE)\n      TIFFSetField(m_tiff, TIFFTAG_COMPRESSION, COMPRESSION_ADOBE_DEFLATE);\n    else if (compressionType == TNZ_INFO_COMPRESS_DEFLATE)\n      TIFFSetField(m_tiff, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);\n    else\n      assert(false);\n  }\n  TIFFSetField(m_tiff, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n  TIFFSetField(m_tiff, TIFFTAG_PHOTOMETRIC, (m_bpp == 8 || m_bpp == 1)\n                                                ? PHOTOMETRIC_MINISBLACK\n                                                : PHOTOMETRIC_RGB);\n  TIFFSetField(m_tiff, TIFFTAG_XRESOLUTION, m_info.m_dpix);\n  TIFFSetField(m_tiff, TIFFTAG_YRESOLUTION, m_info.m_dpiy);\n  TIFFSetField(m_tiff, TIFFTAG_RESOLUTIONUNIT, RESUNIT_INCH);\n  TIFFSetField(m_tiff, TIFFTAG_ROWSPERSTRIP, TIFFDefaultStripSize(m_tiff, 0));\n\n  m_row = 0;\n  if (m_bpp == 1)\n    m_lineBuffer = new unsigned char[m_info.m_lx / 8 + 1];\n  else\n    m_lineBuffer =\n        new unsigned char[(m_bpp == 1 ? 1 : m_bpp / 8) * m_info.m_lx];\n}\n\n//------------------------------------------------------------\n\nvoid TifWriter::flush() { TIFFFlush(m_tiff); }\n\n//------------------------------------------------------------\n\nvoid TifWriter::writeLine(short *buffer) {\n  int delta = 1;\n  int start = 0;\n  if (m_RightToLeft) {\n    delta = -1;\n    start = m_info.m_lx - 1;\n  }\n  if (m_bpp == 16) {\n    unsigned short *pix = ((unsigned short *)buffer) + start;\n    for (int i = 0; i < m_info.m_lx; i++) {\n      unsigned short *b = (unsigned short *)m_lineBuffer + i * 2;\n      b[0]              = pix[0];\n      b[1]              = pix[1];\n      pix               = pix + delta;\n    }\n  } else {\n    assert(m_bpp == 48 || m_bpp == 64);\n    TPixel64 *pix = ((TPixel64 *)buffer) + start;\n\n    if (m_bpp == 64)\n      for (int i = 0; i < m_info.m_lx; i++) {\n        unsigned short *b = (unsigned short *)m_lineBuffer + i * 4;\n        b[0]              = pix->r;\n        b[1]              = pix->g;\n        b[2]              = pix->b;\n        b[3]              = pix->m;\n        pix               = pix + delta;\n      }\n    else if (m_bpp == 48)\n      for (int i = 0; i < m_info.m_lx; i++) {\n        unsigned short *b = (unsigned short *)m_lineBuffer + i * 3;\n        b[0]              = pix->r;\n        b[1]              = pix->g;\n        b[2]              = pix->b;\n        pix               = pix + delta;\n      }\n  }\n  TIFFWriteScanline(m_tiff, m_lineBuffer, m_row++, 0);\n}\n\n//------------------------------------------------------------\n\nvoid TifWriter::fillBits(UCHAR *bufout, UCHAR *bufin, int lx, int incr) {\n  int lx1 = lx / 8 + ((lx % 8) ? 1 : 0);\n\n  for (int i = 0; i < lx1; i++, bufout++) {\n    UCHAR pix = 0xff;\n    for (int j = 0; j < 8; j++, bufin += incr)\n      if (*bufin < m_bwThreshold) pix &= ~(0x1 << (7 - j));\n    *bufout = pix;\n  }\n}\n\n//------------------------------------------------------\n\nvoid TifWriter::writeLine(char *buffer) {\n  int delta = 1;\n  int start = 0;\n  if (m_RightToLeft) {\n    delta = -1;\n    start = m_info.m_lx - 1;\n  }\n  if (m_bpp == 1)\n    fillBits(m_lineBuffer, ((unsigned char *)buffer) + start, m_info.m_lx,\n             delta);\n  else if (m_bpp == 8) {\n    unsigned char *pix = ((unsigned char *)buffer) + start;\n    for (int i = 0; i < m_info.m_lx; i++) {\n      unsigned char *b = m_lineBuffer + i;\n      b[0]             = pix[0];\n      pix              = pix + delta;\n    }\n  } else {\n    assert(m_bpp == 24 || m_bpp == 32);\n    TPixel32 *pix = ((TPixel32 *)buffer) + start;\n\n    if (m_bpp == 32)\n      for (int i = 0; i < m_info.m_lx; i++) {\n        unsigned char *b = m_lineBuffer + i * 4;\n        b[0]             = pix->r;\n        b[1]             = pix->g;\n        b[2]             = pix->b;\n        b[3]             = pix->m;\n        pix              = pix + delta;\n      }\n    else if (m_bpp == 24)\n      for (int i = 0; i < m_info.m_lx; i++) {\n        unsigned char *b = m_lineBuffer + i * 3;\n        b[0]             = pix->r;\n        b[1]             = pix->g;\n        b[2]             = pix->b;\n        pix              = pix + delta;\n      }\n  }\n  TIFFWriteScanline(m_tiff, m_lineBuffer, m_row++, 0);\n}\n\n//============================================================\n#ifdef _DEBUG\n/* Error & Warning Handler per debug */\n\nextern \"C\" {\nstatic void MyWarningHandler(const char *module, const char *fmt, va_list ap) {\n  std::string outMsg;\n  char msg[2048];\n  msg[0]                     = 0;\n  if (module != NULL) outMsg = std::string(module);\n  outMsg += \"Warning, \";\n\n  _vsnprintf(msg, 2048, fmt, ap);\n  strcat(msg, \".\\n\");\n\n  outMsg += msg;\n  TSystem::outputDebug(outMsg);\n}\n\nstatic void MyErrorHandler(const char *module, const char *fmt, va_list ap) {\n  std::string outMsg;\n  char msg[2048];\n  msg[0]                     = 0;\n  if (module != NULL) outMsg = std::string(module);\n  // outMsg += \"Warning, \";\n\n  _vsnprintf(msg, 2048, fmt, ap);\n  strcat(msg, \".\\n\");\n\n  outMsg += msg;\n  TSystem::outputDebug(outMsg);\n}\n}\n\n#endif\n\nTiio::Reader *Tiio::makeTifReader() {\n#ifdef _DEBUG\n  TIFFSetErrorHandler(MyErrorHandler);\n  TIFFSetWarningHandler(MyWarningHandler);\n#endif\n  return new TifReader(false);\n}\n\n//------------------------------------------------------------\n\nTiio::Reader *Tiio::makeTziReader() {\n#ifdef _DEBUG\n  TIFFSetErrorHandler(MyErrorHandler);\n  TIFFSetWarningHandler(MyWarningHandler);\n#endif\n  return new TifReader(true);\n}\n\n//------------------------------------------------------------\n\nTiio::Writer *Tiio::makeTifWriter() {\n#ifdef _DEBUG\n  TIFFSetErrorHandler(MyErrorHandler);\n  TIFFSetWarningHandler(MyWarningHandler);\n#endif\n\n  return new TifWriter();\n}\n",
                "name": "tiio_tif.cpp",
                "path": "toonz/sources/image/tif/tiio_tif.cpp",
                "url": "/github.com/tahoma2d/tahoma2d/-/blob/toonz/sources/image/tif/tiio_tif.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 465,
                    "offsetAndLengths": [
                        [
                            18,
                            16
                        ]
                    ],
                    "preview": "        int ret = TIFFReadRGBATile_64(m_tiff, x, y, tile.get());"
                },
                {
                    "limitHit": false,
                    "lineNumber": 594,
                    "offsetAndLengths": [
                        [
                            18,
                            16
                        ]
                    ],
                    "preview": "        int ret = TIFFReadRGBATile(m_tiff, x, y, tile.get());"
                }
            ],
            "repository": {
                "name": "github.com/tahoma2d/tahoma2d",
                "url": "/github.com/tahoma2d/tahoma2d"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "757df93e6f42f021e801d818970e9f19215df35f"
                },
                "content": "/******************************************************************************\n *\n * Project:  GeoTIFF Driver\n * Purpose:  GDAL GeoTIFF support.\n * Author:   Frank Warmerdam, warmerdam@pobox.com\n *\n ******************************************************************************\n * Copyright (c) 1998, 2002, Frank Warmerdam <warmerdam@pobox.com>\n * Copyright (c) 2007-2015, Even Rouault <even dot rouault at spatialys dot com>\n *\n * SPDX-License-Identifier: MIT\n ****************************************************************************/\n\n#include \"gtiffrgbaband.h\"\n#include \"gtiffdataset.h\"\n\n#include \"tiffio.h\"\n\n/************************************************************************/\n/*                           GTiffRGBABand()                            */\n/************************************************************************/\n\nGTiffRGBABand::GTiffRGBABand(GTiffDataset *poDSIn, int nBandIn)\n    : GTiffRasterBand(poDSIn, nBandIn)\n{\n    eDataType = GDT_Byte;\n}\n\n/************************************************************************/\n/*                       IGetDataCoverageStatus()                       */\n/************************************************************************/\n\nint GTiffRGBABand::IGetDataCoverageStatus(int, int, int, int, int, double *)\n{\n    return GDAL_DATA_COVERAGE_STATUS_UNIMPLEMENTED |\n           GDAL_DATA_COVERAGE_STATUS_DATA;\n}\n\n/************************************************************************/\n/*                            IWriteBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffRGBABand::IWriteBlock(int, int, void *)\n\n{\n    ReportError(CE_Failure, CPLE_AppDefined,\n                \"RGBA interpreted raster bands are read-only.\");\n    return CE_Failure;\n}\n\n/************************************************************************/\n/*                             IReadBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffRGBABand::IReadBlock(int nBlockXOff, int nBlockYOff, void *pImage)\n\n{\n    m_poGDS->Crystalize();\n\n    const auto nBlockBufSize =\n        4 * static_cast<GPtrDiff_t>(nBlockXSize) * nBlockYSize;\n    const int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n\n    if (m_poGDS->m_nPlanarConfig == PLANARCONFIG_SEPARATE)\n    {\n        for (int iBand = 0; iBand < m_poGDS->m_nSamplesPerPixel; iBand++)\n        {\n            int nBlockIdBand = nBlockId + iBand * m_poGDS->m_nBlocksPerBand;\n            if (!m_poGDS->IsBlockAvailable(nBlockIdBand, nullptr, nullptr,\n                                           nullptr))\n                return CE_Failure;\n        }\n    }\n    else\n    {\n        if (!m_poGDS->IsBlockAvailable(nBlockId, nullptr, nullptr, nullptr))\n            return CE_Failure;\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Allocate a temporary buffer for this strip.                     */\n    /* -------------------------------------------------------------------- */\n    if (m_poGDS->m_pabyBlockBuf == nullptr)\n    {\n        m_poGDS->m_pabyBlockBuf = static_cast<GByte *>(\n            VSI_MALLOC3_VERBOSE(4, nBlockXSize, nBlockYSize));\n        if (m_poGDS->m_pabyBlockBuf == nullptr)\n            return CE_Failure;\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Read the strip                                                  */\n    /* -------------------------------------------------------------------- */\n    CPLErr eErr = CE_None;\n\n    if (m_poGDS->m_nLoadedBlock != nBlockId)\n    {\n        if (TIFFIsTiled(m_poGDS->m_hTIFF))\n        {\n            if (TIFFReadRGBATileExt(\n                    m_poGDS->m_hTIFF, nBlockXOff * nBlockXSize,\n                    nBlockYOff * nBlockYSize,\n                    reinterpret_cast<uint32_t *>(m_poGDS->m_pabyBlockBuf),\n                    !m_poGDS->m_bIgnoreReadErrors) == 0 &&\n                !m_poGDS->m_bIgnoreReadErrors)\n            {\n                // Once TIFFError() is properly hooked, this can go away.\n                ReportError(CE_Failure, CPLE_AppDefined,\n                            \"TIFFReadRGBATile() failed.\");\n\n                memset(m_poGDS->m_pabyBlockBuf, 0, nBlockBufSize);\n\n                eErr = CE_Failure;\n            }\n        }\n        else\n        {\n            if (TIFFReadRGBAStripExt(\n                    m_poGDS->m_hTIFF, nBlockId * nBlockYSize,\n                    reinterpret_cast<uint32_t *>(m_poGDS->m_pabyBlockBuf),\n                    !m_poGDS->m_bIgnoreReadErrors) == 0 &&\n                !m_poGDS->m_bIgnoreReadErrors)\n            {\n                // Once TIFFError() is properly hooked, this can go away.\n                ReportError(CE_Failure, CPLE_AppDefined,\n                            \"TIFFReadRGBAStrip() failed.\");\n\n                memset(m_poGDS->m_pabyBlockBuf, 0, nBlockBufSize);\n\n                eErr = CE_Failure;\n            }\n        }\n    }\n\n    m_poGDS->m_nLoadedBlock = eErr == CE_None ? nBlockId : -1;\n\n    /* -------------------------------------------------------------------- */\n    /*      Handle simple case of eight bit data, and pixel interleaving.   */\n    /* -------------------------------------------------------------------- */\n    int nThisBlockYSize = nBlockYSize;\n\n    if (nBlockYOff * nBlockYSize > GetYSize() - nBlockYSize &&\n        !TIFFIsTiled(m_poGDS->m_hTIFF))\n        nThisBlockYSize = GetYSize() - nBlockYOff * nBlockYSize;\n\n#ifdef CPL_LSB\n    const int nBO = nBand - 1;\n#else\n    const int nBO = 4 - nBand;\n#endif\n\n    for (int iDestLine = 0; iDestLine < nThisBlockYSize; ++iDestLine)\n    {\n        const auto nSrcOffset =\n            static_cast<GPtrDiff_t>(nThisBlockYSize - iDestLine - 1) *\n            nBlockXSize * 4;\n\n        GDALCopyWords(m_poGDS->m_pabyBlockBuf + nBO + nSrcOffset, GDT_Byte, 4,\n                      static_cast<GByte *>(pImage) +\n                          static_cast<GPtrDiff_t>(iDestLine) * nBlockXSize,\n                      GDT_Byte, 1, nBlockXSize);\n    }\n\n    if (eErr == CE_None)\n        eErr = FillCacheForOtherBands(nBlockXOff, nBlockYOff);\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                       GetColorInterpretation()                       */\n/************************************************************************/\n\nGDALColorInterp GTiffRGBABand::GetColorInterpretation()\n\n{\n    if (nBand == 1)\n        return GCI_RedBand;\n    if (nBand == 2)\n        return GCI_GreenBand;\n    if (nBand == 3)\n        return GCI_BlueBand;\n\n    return GCI_AlphaBand;\n}\n",
                "name": "gtiffrgbaband.cpp",
                "path": "frmts/gtiff/gtiffrgbaband.cpp",
                "url": "/github.com/OSGeo/gdal/-/blob/frmts/gtiff/gtiffrgbaband.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 99,
                    "offsetAndLengths": [
                        [
                            16,
                            16
                        ]
                    ],
                    "preview": "            if (TIFFReadRGBATileExt("
                },
                {
                    "limitHit": false,
                    "lineNumber": 108,
                    "offsetAndLengths": [
                        [
                            29,
                            16
                        ]
                    ],
                    "preview": "                            \"TIFFReadRGBATile() failed.\");"
                }
            ],
            "repository": {
                "name": "github.com/OSGeo/gdal",
                "url": "/github.com/OSGeo/gdal"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "8207549638c60d46ebe85af7b3a3f50bb5ef49d5"
                },
                "content": "/*M///////////////////////////////////////////////////////////////////////////////////////\n//\n//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.\n//\n//  By downloading, copying, installing or using the software you agree to this license.\n//  If you do not agree to this license, do not download, install,\n//  copy or use the software.\n//\n//\n//                           License Agreement\n//                For Open Source Computer Vision Library\n//\n// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.\n// Copyright (C) 2009, Willow Garage Inc., all rights reserved.\n// Third party copyrights are property of their respective owners.\n//\n// Redistribution and use in source and binary forms, with or without modification,\n// are permitted provided that the following conditions are met:\n//\n//   * Redistribution's of source code must retain the above copyright notice,\n//     this list of conditions and the following disclaimer.\n//\n//   * Redistribution's in binary form must reproduce the above copyright notice,\n//     this list of conditions and the following disclaimer in the documentation\n//     and/or other materials provided with the distribution.\n//\n//   * The name of the copyright holders may not be used to endorse or promote products\n//     derived from this software without specific prior written permission.\n//\n// This software is provided by the copyright holders and contributors \"as is\" and\n// any express or implied warranties, including, but not limited to, the implied\n// warranties of merchantability and fitness for a particular purpose are disclaimed.\n// In no event shall the Intel Corporation or contributors be liable for any direct,\n// indirect, incidental, special, exemplary, or consequential damages\n// (including, but not limited to, procurement of substitute goods or services;\n// loss of use, data, or profits; or business interruption) however caused\n// and on any theory of liability, whether in contract, strict liability,\n// or tort (including negligence or otherwise) arising in any way out of\n// the use of this software, even if advised of the possibility of such damage.\n//\n//M*/\n\n/****************************************************************************************\\\n    A part of the file implements TIFF reader on base of libtiff library\n    (see otherlibs/_graphics/readme.txt for copyright notice)\n\\****************************************************************************************/\n\n#include \"precomp.hpp\"\n\n#ifdef HAVE_TIFF\n#include <opencv2/core/utils/logger.hpp>\n\n#include \"grfmt_tiff.hpp\"\n#include <limits>\n\n#include \"tiff.h\"\n#include \"tiffio.h\"\n\nnamespace cv\n{\n\n// to extend cvtColor() to support CV_8S, CV_16S, CV_32S and CV_64F.\nstatic void extend_cvtColor( InputArray _src, OutputArray _dst, int code );\n\n#define CV_TIFF_CHECK_CALL(call) \\\n    if (0 == (call)) { \\\n        CV_LOG_WARNING(NULL, \"OpenCV TIFF(line \" << __LINE__ << \"): failed \" #call); \\\n        CV_Error(Error::StsError, \"OpenCV TIFF: failed \" #call); \\\n    }\n\n#define CV_TIFF_CHECK_CALL_DEBUG(call) \\\n    if (0 == (call)) { \\\n        CV_LOG_DEBUG(NULL, \"OpenCV TIFF(line \" << __LINE__ << \"): failed optional call: \" #call \", ignoring\"); \\\n    }\n\nstatic void cv_tiffCloseHandle(void* handle)\n{\n    TIFFClose((TIFF*)handle);\n}\n\nstatic void cv_tiffErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    if (cv::utils::logging::getLogLevel() < cv::utils::logging::LOG_LEVEL_DEBUG)\n        return;\n    // TODO cv::vformat() with va_list parameter\n    fprintf(stderr, \"OpenCV TIFF: \");\n    if (module != NULL)\n        fprintf(stderr, \"%s: \", module);\n    fprintf(stderr, \"Warning, \");\n    vfprintf(stderr, fmt, ap);\n    fprintf(stderr, \".\\n\");\n}\n\nstatic bool cv_tiffSetErrorHandler_()\n{\n    TIFFSetErrorHandler(cv_tiffErrorHandler);\n    TIFFSetWarningHandler(cv_tiffErrorHandler);\n    return true;\n}\n\nstatic bool cv_tiffSetErrorHandler()\n{\n    static bool v = cv_tiffSetErrorHandler_();\n    return v;\n}\n\nstatic const char fmtSignTiffII[] = \"II\\x2a\\x00\";\nstatic const char fmtSignTiffMM[] = \"MM\\x00\\x2a\";\nstatic const char fmtSignBigTiffII[] = \"II\\x2b\\x00\";\nstatic const char fmtSignBigTiffMM[] = \"MM\\x00\\x2b\";\n\nTiffDecoder::TiffDecoder()\n{\n    m_hdr = false;\n    m_buf_supported = true;\n    m_buf_pos = 0;\n}\n\n\nvoid TiffDecoder::close()\n{\n    m_tif.release();\n}\n\nTiffDecoder::~TiffDecoder()\n{\n    close();\n}\n\nsize_t TiffDecoder::signatureLength() const\n{\n    return 4;\n}\n\nbool TiffDecoder::checkSignature( const String& signature ) const\n{\n    return signature.size() >= 4 &&\n        (memcmp(signature.c_str(), fmtSignTiffII, 4) == 0 ||\n        memcmp(signature.c_str(), fmtSignTiffMM, 4) == 0 ||\n        memcmp(signature.c_str(), fmtSignBigTiffII, 4) == 0 ||\n        memcmp(signature.c_str(), fmtSignBigTiffMM, 4) == 0);\n}\n\nint TiffDecoder::normalizeChannelsNumber(int channels) const\n{\n    CV_Check(channels, channels >= 1 && channels <= 4, \"Unsupported number of channels\");\n    return channels;\n}\n\nImageDecoder TiffDecoder::newDecoder() const\n{\n    cv_tiffSetErrorHandler();\n    return makePtr<TiffDecoder>();\n}\n\nclass TiffDecoderBufHelper\n{\n    Mat& m_buf;\n    size_t& m_buf_pos;\npublic:\n    TiffDecoderBufHelper(Mat& buf, size_t& buf_pos) :\n        m_buf(buf), m_buf_pos(buf_pos)\n    {}\n    static tmsize_t read( thandle_t handle, void* buffer, tmsize_t n )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        const Mat& buf = helper->m_buf;\n        const tmsize_t size = buf.cols*buf.rows*buf.elemSize();\n        tmsize_t pos = helper->m_buf_pos;\n        if ( n > (size - pos) )\n        {\n            n = size - pos;\n        }\n        std::memcpy(buffer, buf.ptr() + pos, n);\n        helper->m_buf_pos += n;\n        return n;\n    }\n\n    static tmsize_t write( thandle_t /*handle*/, void* /*buffer*/, tmsize_t /*n*/ )\n    {\n        // Not used for decoding.\n        return 0;\n    }\n\n    static toff_t seek( thandle_t handle, toff_t offset, int whence )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        const Mat& buf = helper->m_buf;\n        const toff_t size = buf.cols*buf.rows*buf.elemSize();\n        toff_t new_pos = helper->m_buf_pos;\n        switch (whence)\n        {\n            case SEEK_SET:\n                new_pos = offset;\n                break;\n            case SEEK_CUR:\n                new_pos += offset;\n                break;\n            case SEEK_END:\n                new_pos = size + offset;\n                break;\n        }\n        new_pos = std::min(new_pos, size);\n        helper->m_buf_pos = (size_t)new_pos;\n        return new_pos;\n    }\n\n    static int map( thandle_t handle, void** base, toff_t* size )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        Mat& buf = helper->m_buf;\n        *base = buf.ptr();\n        *size = buf.cols*buf.rows*buf.elemSize();\n        return 0;\n    }\n\n    static toff_t size( thandle_t handle )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        const Mat& buf = helper->m_buf;\n        return buf.cols*buf.rows*buf.elemSize();\n    }\n\n    static int close( thandle_t handle )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        delete helper;\n        return 0;\n    }\n};\n\nbool TiffDecoder::readHeader()\n{\n    bool result = false;\n    TIFF* tif = static_cast<TIFF*>(m_tif.get());\n    if (!tif)\n    {\n        // TIFFOpen() mode flags are different to fopen().  A 'b' in mode \"rb\" has no effect when reading.\n        // http://www.simplesystems.org/libtiff/functions/TIFFOpen.html\n        if ( !m_buf.empty() )\n        {\n            m_buf_pos = 0;\n            TiffDecoderBufHelper* buf_helper = new TiffDecoderBufHelper(this->m_buf, this->m_buf_pos);\n            tif = TIFFClientOpen( \"\", \"r\", reinterpret_cast<thandle_t>(buf_helper), &TiffDecoderBufHelper::read,\n                                  &TiffDecoderBufHelper::write, &TiffDecoderBufHelper::seek,\n                                  &TiffDecoderBufHelper::close, &TiffDecoderBufHelper::size,\n                                  &TiffDecoderBufHelper::map, /*unmap=*/0 );\n            if (!tif)\n                delete buf_helper;\n        }\n        else\n        {\n            tif = TIFFOpen(m_filename.c_str(), \"r\");\n        }\n        if (tif)\n            m_tif.reset(tif, cv_tiffCloseHandle);\n        else\n            m_tif.release();\n    }\n\n    if (tif)\n    {\n        uint32_t wdth = 0, hght = 0;\n        uint16_t photometric = 0;\n\n        CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &wdth));\n        CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &hght));\n        CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric));\n\n        {\n            bool isGrayScale = photometric == PHOTOMETRIC_MINISWHITE || photometric == PHOTOMETRIC_MINISBLACK;\n            uint16_t bpp = 8, ncn = isGrayScale ? 1 : 3;\n            if (0 == TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bpp))\n            {\n                // TIFF bi-level images don't require TIFFTAG_BITSPERSAMPLE tag\n                bpp = 1;\n            }\n            CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &ncn));\n\n            m_width = wdth;\n            m_height = hght;\n            m_frame_count = TIFFNumberOfDirectories(tif);\n            if (ncn == 3 && photometric == PHOTOMETRIC_LOGLUV)\n            {\n                m_type = CV_32FC3;\n                m_hdr = true;\n                return true;\n            }\n            m_hdr = false;\n\n            if( bpp > 8 &&\n               ((photometric > 2) ||\n                (ncn != 1 && ncn != 3 && ncn != 4)))\n                bpp = 8;\n\n            uint16_t sample_format = SAMPLEFORMAT_UINT;\n            TIFFGetField(tif, TIFFTAG_SAMPLEFORMAT, &sample_format);\n            int wanted_channels = normalizeChannelsNumber(ncn);\n            switch (bpp)\n            {\n            case 1:\n            {\n                CV_Check((int)sample_format, sample_format == SAMPLEFORMAT_UINT || sample_format == SAMPLEFORMAT_INT, \"\");\n                int depth = sample_format == SAMPLEFORMAT_INT ? CV_8S : CV_8U;\n                m_type = CV_MAKETYPE(depth, !isGrayScale ? wanted_channels : 1);\n                result = true;\n                break;\n            }\n            case 4:\n                //support 4-bit palette.\n                if (photometric == PHOTOMETRIC_PALETTE)\n                {\n                    CV_Check((int)sample_format, sample_format == SAMPLEFORMAT_UINT || sample_format == SAMPLEFORMAT_INT, \"\");\n                    int depth = sample_format == SAMPLEFORMAT_INT ? CV_8S : CV_8U;\n                    m_type = CV_MAKETYPE(depth, 3);\n                    result = true;\n                }\n                else\n                    CV_Error(cv::Error::StsError, \"bitsperpixel value is 4 should be palette.\");\n                break;\n            case 8:\n            {\n                //Palette color, the value of the component is used as an index into the red,\n                //green and blue curves in the ColorMap field to retrieve an RGB triplet that defines the color.\n                CV_Check((int)sample_format, sample_format == SAMPLEFORMAT_UINT || sample_format == SAMPLEFORMAT_INT, \"\");\n                int depth = sample_format == SAMPLEFORMAT_INT ? CV_8S : CV_8U;\n                if (photometric == PHOTOMETRIC_PALETTE)\n                    m_type = CV_MAKETYPE(depth, 3);\n                else\n                    m_type = CV_MAKETYPE(depth, !isGrayScale ? wanted_channels : 1);\n                result = true;\n                break;\n            }\n            case 10:\n            case 12:\n            case 14:\n            case 16:\n            {\n                CV_Check((int)sample_format, sample_format == SAMPLEFORMAT_UINT || sample_format == SAMPLEFORMAT_INT, \"\");\n                int depth = sample_format == SAMPLEFORMAT_INT ? CV_16S : CV_16U;\n                m_type = CV_MAKETYPE(depth, !isGrayScale ? wanted_channels : 1);\n                result = true;\n                break;\n            }\n            case 32:\n            {\n                CV_Check((int)sample_format, sample_format == SAMPLEFORMAT_IEEEFP || sample_format == SAMPLEFORMAT_INT, \"\");\n                int depth = sample_format == SAMPLEFORMAT_IEEEFP ? CV_32F : CV_32S;\n                m_type = CV_MAKETYPE(depth, wanted_channels);\n                result = true;\n                break;\n            }\n            case 64:\n                CV_CheckEQ((int)sample_format, SAMPLEFORMAT_IEEEFP, \"\");\n                m_type = CV_MAKETYPE(CV_64F, wanted_channels);\n                result = true;\n                break;\n            default:\n                CV_Error(cv::Error::StsError, \"Invalid bitsperpixel value read from TIFF header! Must be 1, 8, 10, 12, 14, 16, 32 or 64.\");\n            }\n        }\n    }\n\n    if( !result )\n        close();\n\n    return result;\n}\n\nbool TiffDecoder::nextPage()\n{\n    // Prepare the next page, if any.\n    return !m_tif.empty() &&\n           TIFFReadDirectory(static_cast<TIFF*>(m_tif.get())) &&\n           readHeader();\n}\n\nstatic void fixOrientationPartial(Mat &img, uint16_t orientation)\n{\n    switch(orientation) {\n        case ORIENTATION_RIGHTTOP:\n        case ORIENTATION_LEFTBOT:\n            flip(img, img, -1);\n            /* fall through */\n\n        case ORIENTATION_LEFTTOP:\n        case ORIENTATION_RIGHTBOT:\n            transpose(img, img);\n            break;\n    }\n}\n\nstatic void fixOrientationFull(Mat &img, int orientation)\n{\n    switch(orientation) {\n        case ORIENTATION_TOPRIGHT:\n            flip(img, img, 1);\n            break;\n\n        case ORIENTATION_BOTRIGHT:\n            flip(img, img, -1);\n            break;\n\n        case ORIENTATION_BOTLEFT:\n            flip(img, img, 0);\n            break;\n\n        case ORIENTATION_LEFTTOP:\n            transpose(img, img);\n            break;\n\n        case ORIENTATION_RIGHTTOP:\n            transpose(img, img);\n            flip(img, img, 1);\n            break;\n\n        case ORIENTATION_RIGHTBOT:\n            transpose(img, img);\n            flip(img, img, -1);\n            break;\n\n        case ORIENTATION_LEFTBOT:\n            transpose(img, img);\n            flip(img, img, 0);\n            break;\n    }\n}\n\n/**\n * Fix orientation defined in tag 274.\n * For 8 bit some corrections are done by TIFFReadRGBAStrip/Tile already.\n * Not so for 16/32/64 bit.\n */\nstatic void fixOrientation(Mat &img, uint16_t orientation, bool isOrientationFull)\n{\n    if( isOrientationFull )\n    {\n        fixOrientationFull(img, orientation);\n    }\n    else\n    {\n        fixOrientationPartial(img, orientation);\n    }\n}\n\nstatic void _unpack10To16(const uchar* src, const uchar* srcEnd, ushort* dst, ushort* dstEnd, size_t expectedDstElements)\n{\n    //5*8b=4*10b : 5 src for 4 dst\n    constexpr const size_t packedBitsCount = 10;\n    constexpr const size_t packedBitsMask = ((1<<packedBitsCount)-1);\n    constexpr const size_t srcElementsPerPacket = 5;\n    constexpr const size_t dstElementsPerPacket = 4;\n    constexpr const size_t bitsPerPacket = dstElementsPerPacket*packedBitsCount;\n    const size_t fullPacketsCount = std::min({\n      expectedDstElements/dstElementsPerPacket,\n      (static_cast<size_t>(srcEnd-src)/srcElementsPerPacket),\n      (static_cast<size_t>(dstEnd-dst)/dstElementsPerPacket)\n    });\n    union {\n      uint64_t u64;\n      uint8_t  u8[8];\n    } buf = {0};\n    for(size_t i = 0 ; i<fullPacketsCount ; ++i)\n    {\n        for(size_t j = 0 ; j<srcElementsPerPacket ; ++j)\n          buf.u8[srcElementsPerPacket-1-j] = *src++;\n        for(size_t j = 0 ; j<dstElementsPerPacket ; ++j)\n        {\n          dst[dstElementsPerPacket-1-j] = static_cast<ushort>(buf.u64 & packedBitsMask);\n          buf.u64 >>= packedBitsCount;\n        }\n        dst += dstElementsPerPacket;\n    }\n    size_t remainingDstElements = std::min(\n        expectedDstElements-fullPacketsCount*dstElementsPerPacket,\n        static_cast<size_t>(dstEnd-dst)\n    );\n    bool stop = !remainingDstElements;\n    while(!stop)\n    {\n        for(size_t j = 0 ; j<srcElementsPerPacket ; ++j)\n            buf.u8[srcElementsPerPacket-1-j] = (src<srcEnd) ? *src++ : 0;\n        for(size_t j = 0 ; j<dstElementsPerPacket ; ++j)\n        {\n            stop |= !(remainingDstElements--);\n            if (!stop)\n              *dst++ = static_cast<ushort>((buf.u64 >> (bitsPerPacket-(j+1)*packedBitsCount)) & packedBitsMask);\n        }\n    }//end while(!stop)\n}\n//end _unpack10To16()\n\nstatic void _unpack12To16(const uchar* src, const uchar* srcEnd, ushort* dst, ushort* dstEnd, size_t expectedDstElements)\n{\n  //3*8b=2*12b : 3 src for 2 dst\n  constexpr const size_t packedBitsCount = 12;\n  constexpr const size_t packedBitsMask = ((1<<packedBitsCount)-1);\n  constexpr const size_t srcElementsPerPacket = 3;\n  constexpr const size_t dstElementsPerPacket = 2;\n  constexpr const size_t bitsPerPacket = dstElementsPerPacket*packedBitsCount;\n  const size_t fullPacketsCount = std::min({\n    expectedDstElements/dstElementsPerPacket,\n    (static_cast<size_t>(srcEnd-src)/srcElementsPerPacket),\n    (static_cast<size_t>(dstEnd-dst)/dstElementsPerPacket)\n  });\n  union {\n      uint32_t u32;\n      uint8_t  u8[4];\n  } buf = {0};\n  for(size_t i = 0 ; i<fullPacketsCount ; ++i)\n  {\n      for(size_t j = 0 ; j<srcElementsPerPacket ; ++j)\n          buf.u8[srcElementsPerPacket-1-j] = *src++;\n      for(size_t j = 0 ; j<dstElementsPerPacket ; ++j)\n      {\n          dst[dstElementsPerPacket-1-j] = static_cast<ushort>(buf.u32 & packedBitsMask);\n          buf.u32 >>= packedBitsCount;\n      }\n      dst += dstElementsPerPacket;\n  }\n  size_t remainingDstElements = std::min(\n      expectedDstElements-fullPacketsCount*dstElementsPerPacket,\n      static_cast<size_t>(dstEnd-dst)\n  );\n  bool stop = !remainingDstElements;\n  while(!stop)\n  {\n      for(size_t j = 0 ; j<srcElementsPerPacket ; ++j)\n          buf.u8[srcElementsPerPacket-1-j] = (src<srcEnd) ? *src++ : 0;\n      for(size_t j = 0 ; j<dstElementsPerPacket ; ++j)\n      {\n          stop |= !(remainingDstElements--);\n          if (!stop)\n              *dst++ = static_cast<ushort>((buf.u32 >> (bitsPerPacket-(j+1)*packedBitsCount)) & packedBitsMask);\n      }\n  }//end while(!stop)\n}\n//end _unpack12To16()\n\nstatic void _unpack14To16(const uchar* src, const uchar* srcEnd, ushort* dst, ushort* dstEnd, size_t expectedDstElements)\n{\n    //7*8b=4*14b : 7 src for 4 dst\n    constexpr const size_t packedBitsCount = 14;\n    constexpr const size_t packedBitsMask = ((1<<packedBitsCount)-1);\n    constexpr const size_t srcElementsPerPacket = 7;\n    constexpr const size_t dstElementsPerPacket = 4;\n    constexpr const size_t bitsPerPacket = dstElementsPerPacket*packedBitsCount;\n    const size_t fullPacketsCount = std::min({\n      expectedDstElements/dstElementsPerPacket,\n      (static_cast<size_t>(srcEnd-src)/srcElementsPerPacket),\n      (static_cast<size_t>(dstEnd-dst)/dstElementsPerPacket)\n    });\n    union {\n        uint64_t u64;\n        uint8_t  u8[8];\n    } buf = {0};\n    for(size_t i = 0 ; i<fullPacketsCount ; ++i)\n    {\n        for(size_t j = 0 ; j<srcElementsPerPacket ; ++j)\n            buf.u8[srcElementsPerPacket-1-j] = *src++;\n        for(size_t j = 0 ; j<dstElementsPerPacket ; ++j)\n        {\n            dst[dstElementsPerPacket-1-j] = static_cast<ushort>(buf.u64 & packedBitsMask);\n            buf.u64 >>= packedBitsCount;\n        }\n        dst += dstElementsPerPacket;\n    }\n    size_t remainingDstElements = std::min(\n        expectedDstElements-fullPacketsCount*dstElementsPerPacket,\n        static_cast<size_t>(dstEnd-dst)\n    );\n    bool stop = !remainingDstElements;\n    while(!stop)\n    {\n        for(size_t j = 0 ; j<srcElementsPerPacket ; ++j)\n            buf.u8[srcElementsPerPacket-1-j] = (src<srcEnd) ? *src++ : 0;\n        for(size_t j = 0 ; j<dstElementsPerPacket ; ++j)\n        {\n            stop |= !(remainingDstElements--);\n            if (!stop)\n                *dst++ = static_cast<ushort>((buf.u64 >> (bitsPerPacket-(j+1)*packedBitsCount)) & packedBitsMask);\n        }\n    }//end while(!stop)\n}\n//end _unpack14To16()\n\nbool  TiffDecoder::readData( Mat& img )\n{\n    int type = img.type();\n    int depth = CV_MAT_DEPTH(type);\n\n    CV_Assert(!m_tif.empty());\n    TIFF* tif = (TIFF*)m_tif.get();\n\n    uint16_t photometric = (uint16_t)-1;\n    CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric));\n\n    if (m_hdr && depth >= CV_32F)\n    {\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_FLOAT));\n    }\n\n    bool color = img.channels() > 1;\n\n    CV_CheckType(type, depth == CV_8U || depth == CV_8S || depth == CV_16U || depth == CV_16S || depth == CV_32S || depth == CV_32F || depth == CV_64F, \"\");\n\n    if (m_width && m_height)\n    {\n        int is_tiled = TIFFIsTiled(tif) != 0;\n        bool isGrayScale = photometric == PHOTOMETRIC_MINISWHITE || photometric == PHOTOMETRIC_MINISBLACK;\n        uint16_t bpp = 8, ncn = isGrayScale ? 1 : 3;\n        if (0 == TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bpp))\n        {\n            // TIFF bi-level images don't require TIFFTAG_BITSPERSAMPLE tag\n            bpp = 1;\n        }\n        CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &ncn));\n        uint16_t img_orientation = ORIENTATION_TOPLEFT;\n        CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_ORIENTATION, &img_orientation));\n        constexpr const int bitsPerByte = 8;\n        int dst_bpp = (int)(img.elemSize1() * bitsPerByte);\n        bool vert_flip = dst_bpp == 8 &&\n                        (img_orientation == ORIENTATION_BOTRIGHT || img_orientation == ORIENTATION_RIGHTBOT ||\n                         img_orientation == ORIENTATION_BOTLEFT || img_orientation == ORIENTATION_LEFTBOT);\n        int wanted_channels = normalizeChannelsNumber(img.channels());\n        bool doReadScanline = false;\n\n        uint32_t tile_width0 = m_width, tile_height0 = 0;\n\n        if (is_tiled)\n        {\n            CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_TILEWIDTH, &tile_width0));\n            CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_TILELENGTH, &tile_height0));\n        }\n        else\n        {\n            // optional\n            CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &tile_height0));\n        }\n\n        {\n            if (tile_width0 == 0)\n                tile_width0 = m_width;\n\n            if (tile_height0 == 0 ||\n                    (!is_tiled && tile_height0 == std::numeric_limits<uint32_t>::max()) )\n                tile_height0 = m_height;\n\n            const int TILE_MAX_WIDTH = (1 << 24);\n            const int TILE_MAX_HEIGHT = (1 << 24);\n            CV_Assert((int)tile_width0 > 0 && (int)tile_width0 <= TILE_MAX_WIDTH);\n            CV_Assert((int)tile_height0 > 0 && (int)tile_height0 <= TILE_MAX_HEIGHT);\n            const uint64_t MAX_TILE_SIZE = (CV_BIG_UINT(1) << 30);\n            CV_CheckLE((int)ncn, 4, \"\");\n            CV_CheckLE((int)bpp, 64, \"\");\n\n            if (dst_bpp == 8)\n            {\n                const int _ncn = 4; // Read RGBA\n                const int _bpp = 8; // Read 8bit\n\n                // if buffer_size(as 32bit RGBA) >= MAX_TILE_SIZE*95%,\n                // we will use TIFFReadScanline function.\n\n                if (\n                    (uint64_t)tile_width0 * tile_height0 * _ncn * std::max(1, (int)(_bpp / bitsPerByte))\n                    >=\n                    ( (uint64_t) MAX_TILE_SIZE * 95 / 100)\n                )\n                {\n                    uint16_t planerConfig = (uint16_t)-1;\n                    CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_PLANARCONFIG, &planerConfig));\n\n                    doReadScanline = (!is_tiled) // no tile\n                                     &&\n                                     ( ( ncn == 1 ) || ( ncn == 3 ) || ( ncn == 4 ) )\n                                     &&\n                                     ( ( bpp == 8 ) || ( bpp == 16 ) )\n                                     &&\n                                     (tile_height0 == (uint32_t) m_height) // single strip\n                                     &&\n                                     (\n                                         (photometric == PHOTOMETRIC_MINISWHITE)\n                                         ||\n                                         (photometric == PHOTOMETRIC_MINISBLACK)\n                                         ||\n                                         (photometric == PHOTOMETRIC_RGB)\n                                     )\n                                     &&\n                                     (planerConfig != PLANARCONFIG_SEPARATE);\n\n                    // Currently only EXTRASAMPLE_ASSOCALPHA is supported.\n                    if ( doReadScanline && ( ncn == 4 ) )\n                    {\n                        uint16_t extra_samples_num;\n                        uint16_t *extra_samples = NULL;\n                        CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_EXTRASAMPLES, &extra_samples_num, &extra_samples ));\n                        doReadScanline = ( extra_samples_num == 1 ) && ( extra_samples[0] == EXTRASAMPLE_ASSOCALPHA );\n                    }\n                }\n\n                if ( !doReadScanline )\n                {\n                    // we will use TIFFReadRGBA* functions, so allocate temporary buffer for 32bit RGBA\n                    bpp = 8;\n                    ncn = 4;\n\n                    char errmsg[1024];\n                    if (!TIFFRGBAImageOK(tif, errmsg))\n                    {\n                        CV_LOG_WARNING(NULL, \"OpenCV TIFF: TIFFRGBAImageOK: \" << errmsg);\n                        close();\n                        return false;\n                    }\n                }\n            }\n            else if (dst_bpp == 16)\n            {\n                // if buffer_size >= MAX_TILE_SIZE*95%,\n                // we will use TIFFReadScanline function.\n                if (\n                    (uint64_t)tile_width0 * tile_height0 * ncn * std::max(1, (int)(bpp / bitsPerByte))\n                    >=\n                    MAX_TILE_SIZE * 95 / 100\n                )\n                {\n                    uint16_t planerConfig = (uint16_t)-1;\n                    CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_PLANARCONFIG, &planerConfig));\n\n                    doReadScanline = (!is_tiled) // no tile\n                                     &&\n                                     ( ( ncn == 1 ) || ( ncn == 3 ) || ( ncn == 4 ) )\n                                     &&\n                                     ( ( bpp == 8 ) || ( bpp == 16 ) )\n                                     &&\n                                     (tile_height0 == (uint32_t) m_height) // single strip\n                                     &&\n                                     (\n                                         (photometric == PHOTOMETRIC_MINISWHITE)\n                                         ||\n                                         (photometric == PHOTOMETRIC_MINISBLACK)\n                                         ||\n                                         (photometric == PHOTOMETRIC_RGB)\n                                     )\n                                     &&\n                                     (planerConfig != PLANARCONFIG_SEPARATE);\n\n                    // Currently only EXTRASAMPLE_ASSOCALPHA is supported.\n                    if ( doReadScanline && ( ncn == 4 ) )\n                    {\n                        uint16_t extra_samples_num;\n                        uint16_t *extra_samples = NULL;\n                        CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_EXTRASAMPLES, &extra_samples_num, &extra_samples ));\n                        doReadScanline = ( extra_samples_num == 1 ) && ( extra_samples[0] == EXTRASAMPLE_ASSOCALPHA );\n                    }\n                }\n            }\n            else if (dst_bpp == 32 || dst_bpp == 64)\n            {\n                CV_Assert(ncn == img.channels());\n                CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP));\n            }\n\n            if ( doReadScanline )\n            {\n                // Read each scanlines.\n                tile_height0 = 1;\n            }\n\n            const size_t src_buffer_bytes_per_row = divUp(static_cast<size_t>(ncn * tile_width0 * bpp), static_cast<size_t>(bitsPerByte));\n            const size_t src_buffer_size = tile_height0 * src_buffer_bytes_per_row;\n            CV_CheckLT(src_buffer_size, MAX_TILE_SIZE, \"buffer_size is too large: >= 1Gb\");\n            const size_t src_buffer_unpacked_bytes_per_row = divUp(static_cast<size_t>(ncn * tile_width0 * dst_bpp), static_cast<size_t>(bitsPerByte));\n            const size_t src_buffer_unpacked_size = tile_height0 * src_buffer_unpacked_bytes_per_row;\n            const bool needsUnpacking = (bpp < dst_bpp);\n            AutoBuffer<uchar> _src_buffer(src_buffer_size);\n            uchar* src_buffer = _src_buffer.data();\n            AutoBuffer<uchar> _src_buffer_unpacked(needsUnpacking ? src_buffer_unpacked_size : 0);\n            uchar* src_buffer_unpacked = needsUnpacking ? _src_buffer_unpacked.data() : nullptr;\n\n            if ( doReadScanline )\n            {\n                CV_CheckGE(src_buffer_size,\n                           static_cast<size_t>(TIFFScanlineSize(tif)),\n                           \"src_buffer_size is smaller than TIFFScanlineSize().\");\n            }\n\n            int tileidx = 0;\n\n            #define MAKE_FLAG(a,b) ( (a << 8) | b )\n            const int  convert_flag = MAKE_FLAG( ncn, wanted_channels );\n            const bool isNeedConvert16to8 = ( doReadScanline ) && ( bpp == 16 ) && ( dst_bpp == 8);\n\n            for (int y = 0; y < m_height; y += (int)tile_height0)\n            {\n                int tile_height = std::min((int)tile_height0, m_height - y);\n\n                const int img_y = vert_flip ? m_height - y - tile_height : y;\n\n                for(int x = 0; x < m_width; x += (int)tile_width0, tileidx++)\n                {\n                    int tile_width = std::min((int)tile_width0, m_width - x);\n\n                    switch (dst_bpp)\n                    {\n                        case 8:\n                        {\n                            uchar* bstart = src_buffer;\n                            if (doReadScanline)\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadScanline(tif, (uint32_t*)src_buffer, y) >= 0);\n\n                                if ( isNeedConvert16to8 )\n                                {\n                                    // Convert buffer image from 16bit to 8bit.\n                                    int ix;\n                                    for ( ix = 0 ; ix < tile_width * ncn - 4; ix += 4 )\n                                    {\n                                        src_buffer[ ix     ] = src_buffer[ ix * 2 + 1 ];\n                                        src_buffer[ ix + 1 ] = src_buffer[ ix * 2 + 3 ];\n                                        src_buffer[ ix + 2 ] = src_buffer[ ix * 2 + 5 ];\n                                        src_buffer[ ix + 3 ] = src_buffer[ ix * 2 + 7 ];\n                                    }\n\n                                    for (        ; ix < tile_width * ncn ; ix ++ )\n                                    {\n                                        src_buffer[ ix ] = src_buffer[ ix * 2 + 1];\n                                    }\n                                }\n                            }\n                            else if (!is_tiled)\n                            {\n                                CV_TIFF_CHECK_CALL(TIFFReadRGBAStrip(tif, y, (uint32_t*)src_buffer));\n                            }\n                            else\n                            {\n                                CV_TIFF_CHECK_CALL(TIFFReadRGBATile(tif, x, y, (uint32_t*)src_buffer));\n                                // Tiles fill the buffer from the bottom up\n                                bstart += (tile_height0 - tile_height) * tile_width0 * 4;\n                            }\n\n                            uchar* img_line_buffer = (uchar*) img.ptr(y, 0);\n\n                            for (int i = 0; i < tile_height; i++)\n                            {\n                                if (doReadScanline)\n                                {\n                                    switch ( convert_flag )\n                                    {\n                                    case MAKE_FLAG( 1, 1 ): // GRAY to GRAY\n                                        std::memcpy( (void*) img_line_buffer,\n                                                     (void*) bstart,\n                                                     tile_width * sizeof(uchar) );\n                                        break;\n\n                                    case MAKE_FLAG( 1, 3 ): // GRAY to BGR\n                                        icvCvt_Gray2BGR_8u_C1C3R( bstart, 0,\n                                                img_line_buffer, 0,\n                                                Size(tile_width, 1) );\n                                        break;\n\n                                    case MAKE_FLAG( 3, 1): // RGB to GRAY\n                                        icvCvt_BGR2Gray_8u_C3C1R( bstart, 0,\n                                                img_line_buffer, 0,\n                                                Size(tile_width, 1) );\n                                        break;\n\n                                    case MAKE_FLAG( 3, 3 ): // RGB to BGR\n                                        if (m_use_rgb)\n                                            std::memcpy( (void*) img_line_buffer,\n                                                         (void*) bstart,\n                                                         tile_width * sizeof(uchar) );\n                                        else\n                                            icvCvt_BGR2RGB_8u_C3R( bstart, 0,\n                                                    img_line_buffer, 0,\n                                                    Size(tile_width, 1) );\n                                        break;\n\n                                    case MAKE_FLAG( 4, 1 ): // RGBA to GRAY\n                                        icvCvt_BGRA2Gray_8u_C4C1R( bstart, 0,\n                                                img_line_buffer, 0,\n                                                Size(tile_width, 1) );\n                                        break;\n\n                                    case MAKE_FLAG( 4, 3 ): // RGBA to BGR\n                                        icvCvt_BGRA2BGR_8u_C4C3R( bstart, 0,\n                                                img_line_buffer, 0,\n                                                Size(tile_width, 1), m_use_rgb ? 0 : 2);\n                                        break;\n\n                                    case MAKE_FLAG( 4, 4 ): // RGBA to BGRA\n                                        icvCvt_BGRA2RGBA_8u_C4R(bstart, 0,\n                                                img_line_buffer, 0,\n                                                Size(tile_width, 1) );\n                                        break;\n\n                                    default:\n                                        CV_LOG_ONCE_ERROR(NULL, \"OpenCV TIFF(line \" << __LINE__ << \"): Unsupported convertion :\"\n                                                               << \" bpp = \" << bpp << \" ncn = \" << (int)ncn\n                                                               << \" wanted_channels =\" << wanted_channels  );\n                                        break;\n                                    }\n                                    #undef MAKE_FLAG\n                                }\n                                else if (color)\n                                {\n                                    if (wanted_channels == 4)\n                                    {\n                                        icvCvt_BGRA2RGBA_8u_C4R(bstart + i*tile_width0*4, 0,\n                                                img.ptr(img_y + tile_height - i - 1, x), 0,\n                                                Size(tile_width, 1) );\n                                    }\n                                    else\n                                    {\n                                        CV_CheckEQ(wanted_channels, 3, \"TIFF-8bpp: BGR/BGRA images are supported only\");\n                                        icvCvt_BGRA2BGR_8u_C4C3R(bstart + i*tile_width0*4, 0,\n                                                img.ptr(img_y + tile_height - i - 1, x), 0,\n                                                Size(tile_width, 1), m_use_rgb ? 0 : 2);\n                                    }\n                                }\n                                else\n                                {\n                                    CV_CheckEQ(wanted_channels, 1, \"\");\n                                    icvCvt_BGRA2Gray_8u_C4C1R( bstart + i*tile_width0*4, 0,\n                                            img.ptr(img_y + tile_height - i - 1, x), 0,\n                                            Size(tile_width, 1), 2);\n                                }\n                            }\n                            break;\n                        }\n\n                        case 16:\n                        {\n                            if (doReadScanline)\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadScanline(tif, (uint32_t*)src_buffer, y) >= 0);\n                            }\n                            else if (!is_tiled)\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedStrip(tif, tileidx, (uint32_t*)src_buffer, src_buffer_size) >= 0);\n                            }\n                            else\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedTile(tif, tileidx, (uint32_t*)src_buffer, src_buffer_size) >= 0);\n                            }\n\n                            for (int i = 0; i < tile_height; i++)\n                            {\n                                ushort* buffer16 = (ushort*)(src_buffer+i*src_buffer_bytes_per_row);\n                                if (needsUnpacking)\n                                {\n                                    const uchar* src_packed = src_buffer+i*src_buffer_bytes_per_row;\n                                    uchar* dst_unpacked = src_buffer_unpacked+i*src_buffer_unpacked_bytes_per_row;\n                                    if (bpp == 10)\n                                        _unpack10To16(src_packed, src_packed+src_buffer_bytes_per_row,\n                                                      (ushort*)dst_unpacked, (ushort*)(dst_unpacked+src_buffer_unpacked_bytes_per_row),\n                                                      ncn * tile_width0);\n                                    else if (bpp == 12)\n                                        _unpack12To16(src_packed, src_packed+src_buffer_bytes_per_row,\n                                                      (ushort*)dst_unpacked, (ushort*)(dst_unpacked+src_buffer_unpacked_bytes_per_row),\n                                                      ncn * tile_width0);\n                                    else if (bpp == 14)\n                                        _unpack14To16(src_packed, src_packed+src_buffer_bytes_per_row,\n                                                      (ushort*)dst_unpacked, (ushort*)(dst_unpacked+src_buffer_unpacked_bytes_per_row),\n                                                      ncn * tile_width0);\n                                    buffer16 = (ushort*)dst_unpacked;\n                                }\n\n                                if (color)\n                                {\n                                    if (ncn == 1)\n                                    {\n                                        CV_CheckEQ(wanted_channels, 3, \"\");\n                                        icvCvt_Gray2BGR_16u_C1C3R(buffer16, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1));\n                                    }\n                                    else if (ncn == 3)\n                                    {\n                                        CV_CheckEQ(wanted_channels, 3, \"\");\n                                        if (m_use_rgb)\n                                            std::memcpy(buffer16, img.ptr<ushort>(img_y + i, x), tile_width * sizeof(ushort));\n                                        else\n                                            icvCvt_RGB2BGR_16u_C3R(buffer16, 0,\n                                                    img.ptr<ushort>(img_y + i, x), 0,\n                                                    Size(tile_width, 1));\n                                    }\n                                    else if (ncn == 4)\n                                    {\n                                        if (wanted_channels == 4)\n                                        {\n                                            icvCvt_BGRA2RGBA_16u_C4R(buffer16, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1));\n                                        }\n                                        else\n                                        {\n                                            CV_CheckEQ(wanted_channels, 3, \"TIFF-16bpp: BGR/BGRA images are supported only\");\n                                            icvCvt_BGRA2BGR_16u_C4C3R(buffer16, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1), m_use_rgb ? 0 : 2);\n                                        }\n                                    }\n                                    else\n                                    {\n                                        CV_Error(Error::StsError, \"Not supported\");\n                                    }\n                                }\n                                else\n                                {\n                                    CV_CheckEQ(wanted_channels, 1, \"\");\n                                    if( ncn == 1 )\n                                    {\n                                        std::memcpy(img.ptr<ushort>(img_y + i, x),\n                                                    buffer16,\n                                                    tile_width*sizeof(ushort));\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2Gray_16u_CnC1R(buffer16, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1), ncn, 2);\n                                    }\n                                }\n                            }\n                            break;\n                        }\n\n                        case 32:\n                        case 64:\n                        {\n                            if( !is_tiled )\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedStrip(tif, tileidx, src_buffer, src_buffer_size) >= 0);\n                            }\n                            else\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedTile(tif, tileidx, src_buffer, src_buffer_size) >= 0);\n                            }\n\n                            Mat m_tile(Size(tile_width0, tile_height0), CV_MAKETYPE((dst_bpp == 32) ? (depth == CV_32S ? CV_32S : CV_32F) : CV_64F, ncn), src_buffer);\n                            Rect roi_tile(0, 0, tile_width, tile_height);\n                            Rect roi_img(x, img_y, tile_width, tile_height);\n                            if (!m_hdr && ncn == 3 && !m_use_rgb)\n                                extend_cvtColor(m_tile(roi_tile), img(roi_img), COLOR_RGB2BGR);\n                            else if (!m_hdr && ncn == 4)\n                                extend_cvtColor(m_tile(roi_tile), img(roi_img), COLOR_RGBA2BGRA);\n                            else\n                                m_tile(roi_tile).copyTo(img(roi_img));\n                            break;\n                        }\n                        default:\n                        {\n                            CV_Assert(0 && \"OpenCV TIFF: unsupported depth\");\n                        }\n                    }  // switch (dst_bpp)\n                }  // for x\n            }  // for y\n        }\n        if (bpp < dst_bpp)\n          img *= (1<<(dst_bpp-bpp));\n\n        // If TIFFReadRGBA* function is used -> fixOrientationPartial().\n        // Otherwise                         -> fixOrientationFull().\n        fixOrientation(img, img_orientation,\n                       ( ( dst_bpp != 8 ) && ( !doReadScanline ) ) );\n    }\n\n    if (m_hdr && depth >= CV_32F)\n    {\n        CV_Assert(photometric == PHOTOMETRIC_LOGLUV);\n        if (m_use_rgb)\n            cvtColor(img, img, COLOR_XYZ2RGB);\n        else\n            cvtColor(img, img, COLOR_XYZ2BGR);\n    }\n    return true;\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////\n\nTiffEncoder::TiffEncoder()\n{\n    m_description = \"TIFF Files (*.tiff;*.tif)\";\n    m_buf_supported = true;\n}\n\nTiffEncoder::~TiffEncoder()\n{\n}\n\nImageEncoder TiffEncoder::newEncoder() const\n{\n    cv_tiffSetErrorHandler();\n    return makePtr<TiffEncoder>();\n}\n\nbool TiffEncoder::isFormatSupported( int depth ) const\n{\n    return depth == CV_8U || depth == CV_8S || depth == CV_16U || depth == CV_16S || depth == CV_32S || depth == CV_32F || depth == CV_64F;\n}\n\nclass TiffEncoderBufHelper\n{\npublic:\n\n    TiffEncoderBufHelper(std::vector<uchar> *buf)\n            : m_buf(buf), m_buf_pos(0)\n    {}\n\n    TIFF* open ()\n    {\n        // do NOT put \"wb\" as the mode, because the b means \"big endian\" mode, not \"binary\" mode.\n        // http://www.simplesystems.org/libtiff/functions/TIFFOpen.html\n        return TIFFClientOpen( \"\", \"w\", reinterpret_cast<thandle_t>(this), &TiffEncoderBufHelper::read,\n                               &TiffEncoderBufHelper::write, &TiffEncoderBufHelper::seek,\n                               &TiffEncoderBufHelper::close, &TiffEncoderBufHelper::size,\n                               /*map=*/0, /*unmap=*/0 );\n    }\n\n    static tmsize_t read( thandle_t handle, void* buffer, tmsize_t n )\n    {\n        // Used for imencodemulti() to stores multi-images.\n        TiffEncoderBufHelper *helper = reinterpret_cast<TiffEncoderBufHelper*>(handle);\n        size_t begin = (size_t)helper->m_buf_pos;\n        size_t end = begin + n;\n        CV_CheckGT( helper->m_buf->size(), end , \"do not be over-run buffer\");\n        std::memcpy(buffer, &(*helper->m_buf)[begin], n);\n        helper->m_buf_pos = end;\n        return n;\n    }\n\n    static tmsize_t write( thandle_t handle, void* buffer, tmsize_t n )\n    {\n        TiffEncoderBufHelper *helper = reinterpret_cast<TiffEncoderBufHelper*>(handle);\n        size_t begin = (size_t)helper->m_buf_pos;\n        size_t end = begin + n;\n        if ( helper->m_buf->size() < end )\n        {\n            helper->m_buf->resize(end);\n        }\n        std::memcpy(&(*helper->m_buf)[begin], buffer, n);\n        helper->m_buf_pos = end;\n        return n;\n    }\n\n    static toff_t seek( thandle_t handle, toff_t offset, int whence )\n    {\n        TiffEncoderBufHelper *helper = reinterpret_cast<TiffEncoderBufHelper*>(handle);\n        const toff_t size = helper->m_buf->size();\n        toff_t new_pos = helper->m_buf_pos;\n        switch (whence)\n        {\n            case SEEK_SET:\n                new_pos = offset;\n                break;\n            case SEEK_CUR:\n                new_pos += offset;\n                break;\n            case SEEK_END:\n                new_pos = size + offset;\n                break;\n        }\n        helper->m_buf_pos = new_pos;\n        return new_pos;\n    }\n\n    static toff_t size( thandle_t handle )\n    {\n        TiffEncoderBufHelper *helper = reinterpret_cast<TiffEncoderBufHelper*>(handle);\n        return helper->m_buf->size();\n    }\n\n    static int close( thandle_t /*handle*/ )\n    {\n        // Do nothing.\n        return 0;\n    }\n\nprivate:\n\n    std::vector<uchar>* m_buf;\n    toff_t m_buf_pos;\n};\n\nstatic bool readParam(const std::vector<int>& params, int key, int& value)\n{\n    for (size_t i = 0; i + 1 < params.size(); i += 2)\n    {\n        if (params[i] == key)\n        {\n            value = params[i + 1];\n            return true;\n        }\n    }\n    return false;\n}\n\nbool TiffEncoder::writeLibTiff( const std::vector<Mat>& img_vec, const std::vector<int>& params)\n{\n    // do NOT put \"wb\" as the mode, because the b means \"big endian\" mode, not \"binary\" mode.\n    // http://www.simplesystems.org/libtiff/functions/TIFFOpen.html\n    TIFF* tif = NULL;\n\n    TiffEncoderBufHelper buf_helper(m_buf);\n    if ( m_buf )\n    {\n        tif = buf_helper.open();\n    }\n    else\n    {\n        tif = TIFFOpen(m_filename.c_str(), \"w\");\n    }\n    if (!tif)\n    {\n        return false;\n    }\n    cv::Ptr<void> tif_cleanup(tif, cv_tiffCloseHandle);\n\n    //Settings that matter to all images\n    int compression = COMPRESSION_LZW;\n    int predictor = PREDICTOR_HORIZONTAL;\n    int resUnit = -1, dpiX = -1, dpiY = -1;\n\n    readParam(params, IMWRITE_TIFF_COMPRESSION, compression);\n    readParam(params, IMWRITE_TIFF_PREDICTOR, predictor);\n    readParam(params, IMWRITE_TIFF_RESUNIT, resUnit);\n    readParam(params, IMWRITE_TIFF_XDPI, dpiX);\n    readParam(params, IMWRITE_TIFF_YDPI, dpiY);\n\n    //Iterate through each image in the vector and write them out as Tiff directories\n    for (size_t page = 0; page < img_vec.size(); page++)\n    {\n        const Mat& img = img_vec[page];\n        CV_Assert(!img.empty());\n        int channels = img.channels();\n        int width = img.cols, height = img.rows;\n        int type = img.type();\n        int depth = CV_MAT_DEPTH(type);\n        CV_CheckType(type, depth == CV_8U || depth == CV_8S || depth == CV_16U || depth == CV_16S || depth == CV_32S || depth == CV_32F || depth == CV_64F, \"\");\n        CV_CheckType(type, channels >= 1 && channels <= 4, \"\");\n\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, width));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_IMAGELENGTH, height));\n\n        if (img_vec.size() > 1)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE));\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PAGENUMBER, page, img_vec.size()));\n        }\n\n        int compression_param = -1;  // OPENCV_FUTURE\n        if (type == CV_32FC3 && (!readParam(params, IMWRITE_TIFF_COMPRESSION, compression_param) || compression_param == COMPRESSION_SGILOG))\n        {\n            if (!write_32FC3_SGILOG(img, tif))\n                return false;\n            continue;\n        }\n\n        int page_compression = compression;\n\n        int bitsPerChannel = -1;\n        uint16_t sample_format = SAMPLEFORMAT_INT;\n        switch (depth)\n        {\n            case CV_8U:\n                sample_format = SAMPLEFORMAT_UINT;\n                /* FALLTHRU */\n            case CV_8S:\n            {\n                bitsPerChannel = 8;\n                break;\n            }\n\n            case CV_16U:\n                sample_format = SAMPLEFORMAT_UINT;\n                /* FALLTHRU */\n            case CV_16S:\n            {\n                bitsPerChannel = 16;\n                break;\n            }\n\n            case CV_32S:\n            {\n                bitsPerChannel = 32;\n                sample_format = SAMPLEFORMAT_INT;\n                break;\n            }\n            case CV_32F:\n            {\n                bitsPerChannel = 32;\n                page_compression = COMPRESSION_NONE;\n                sample_format = SAMPLEFORMAT_IEEEFP;\n                break;\n            }\n            case CV_64F:\n            {\n                bitsPerChannel = 64;\n                page_compression = COMPRESSION_NONE;\n                sample_format = SAMPLEFORMAT_IEEEFP;\n                break;\n            }\n            default:\n            {\n                return false;\n            }\n        }\n\n        const int bitsPerByte = 8;\n        size_t fileStep = (width * channels * bitsPerChannel) / bitsPerByte;\n        CV_Assert(fileStep > 0);\n\n        int rowsPerStrip = (int)((1 << 13) / fileStep);\n        readParam(params, IMWRITE_TIFF_ROWSPERSTRIP, rowsPerStrip);\n        rowsPerStrip = std::max(1, std::min(height, rowsPerStrip));\n\n        int colorspace = channels > 1 ? PHOTOMETRIC_RGB : PHOTOMETRIC_MINISBLACK;\n\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, bitsPerChannel));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_COMPRESSION, page_compression));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, colorspace));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, channels));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, rowsPerStrip));\n\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, sample_format));\n\n        if (page_compression == COMPRESSION_LZW || page_compression == COMPRESSION_ADOBE_DEFLATE || page_compression == COMPRESSION_DEFLATE)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PREDICTOR, predictor));\n        }\n\n        if (resUnit >= RESUNIT_NONE && resUnit <= RESUNIT_CENTIMETER)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_RESOLUTIONUNIT, resUnit));\n        }\n        if (dpiX >= 0)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_XRESOLUTION, (float)dpiX));\n        }\n        if (dpiY >= 0)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_YRESOLUTION, (float)dpiY));\n        }\n\n        // row buffer, because TIFFWriteScanline modifies the original data!\n        size_t scanlineSize = TIFFScanlineSize(tif);\n        AutoBuffer<uchar> _buffer(scanlineSize + 32);\n        uchar* buffer = _buffer.data(); CV_DbgAssert(buffer);\n        Mat m_buffer(Size(width, 1), CV_MAKETYPE(depth, channels), buffer, (size_t)scanlineSize);\n\n        for (int y = 0; y < height; ++y)\n        {\n            switch (channels)\n            {\n                case 1:\n                {\n                    std::memcpy(buffer, img.ptr(y), scanlineSize);\n                    break;\n                }\n\n                case 3:\n                {\n                    extend_cvtColor(img(Rect(0, y, width, 1)), (const Mat&)m_buffer, COLOR_BGR2RGB);\n                    break;\n                }\n\n                case 4:\n                {\n                    extend_cvtColor(img(Rect(0, y, width, 1)), (const Mat&)m_buffer, COLOR_BGRA2RGBA);\n                    break;\n                }\n\n                default:\n                {\n                    CV_Assert(0);\n                }\n            }\n\n            CV_TIFF_CHECK_CALL(TIFFWriteScanline(tif, buffer, y, 0) == 1);\n        }\n\n        CV_TIFF_CHECK_CALL(TIFFWriteDirectory(tif));\n    }\n\n    return true;\n}\n\nbool TiffEncoder::write_32FC3_SGILOG(const Mat& _img, void* tif_)\n{\n    TIFF* tif = (TIFF*)tif_;\n    CV_Assert(tif);\n\n    Mat img;\n    cvtColor(_img, img, COLOR_BGR2XYZ);\n\n    //done by caller: CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, img.cols));\n    //done by caller: CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_IMAGELENGTH, img.rows));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 3));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 32));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_SGILOG));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_LOGLUV));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_FLOAT));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, 1));\n    const int strip_size = 3 * img.cols;\n    for (int i = 0; i < img.rows; i++)\n    {\n        CV_TIFF_CHECK_CALL(TIFFWriteEncodedStrip(tif, i, (tdata_t)img.ptr<float>(i), strip_size * sizeof(float)) != (tsize_t)-1);\n    }\n    CV_TIFF_CHECK_CALL(TIFFWriteDirectory(tif));\n    return true;\n}\n\nbool TiffEncoder::writemulti(const std::vector<Mat>& img_vec, const std::vector<int>& params)\n{\n    return writeLibTiff(img_vec, params);\n}\n\nbool  TiffEncoder::write( const Mat& img, const std::vector<int>& params)\n{\n    int type = img.type();\n    int depth = CV_MAT_DEPTH(type);\n\n    CV_CheckType(type, depth == CV_8U || depth == CV_8S || depth == CV_16U || depth == CV_16S || depth == CV_32S || depth == CV_32F || depth == CV_64F, \"\");\n\n    std::vector<Mat> img_vec;\n    img_vec.push_back(img);\n    return writeLibTiff(img_vec, params);\n}\n\nstatic void extend_cvtColor( InputArray _src, OutputArray _dst, int code )\n{\n    CV_Assert( !_src.empty() );\n    CV_Assert( _src.dims() == 2 );\n\n    // This function extend_cvtColor reorders the src channels with only thg limited condition.\n    // Otherwise, it calls cvtColor.\n\n    const int stype = _src.type();\n    if(!\n        (\n            (\n                ( stype == CV_8SC3  ) || ( stype == CV_8SC4  ) ||\n                ( stype == CV_16SC3 ) || ( stype == CV_16SC4 ) ||\n                ( stype == CV_32SC3 ) || ( stype == CV_32SC4 ) ||\n                ( stype == CV_64FC3 ) || ( stype == CV_64FC4 )\n            )\n            &&\n            (\n                ( code == COLOR_BGR2RGB ) || ( code == COLOR_BGRA2RGBA )\n            )\n        )\n    )\n    {\n        cvtColor( _src, _dst, code );\n        return;\n    }\n\n    Mat src = _src.getMat();\n\n    // cv::mixChannels requires the output arrays to be pre-allocated before calling the function.\n    _dst.create( _src.size(), stype );\n    Mat dst = _dst.getMat();\n\n    // BGR to RGB or BGRA to RGBA\n    //   src[0] -> dst[2]\n    //   src[1] -> dst[1]\n    //   src[2] -> dst[0]\n    //   src[3] -> dst[3] if src has alpha channel.\n    std::vector<int> fromTo;\n    fromTo.push_back(0); fromTo.push_back(2);\n    fromTo.push_back(1); fromTo.push_back(1);\n    fromTo.push_back(2); fromTo.push_back(0);\n    if ( code == COLOR_BGRA2RGBA )\n    {\n        fromTo.push_back(3); fromTo.push_back(3);\n    }\n\n    cv::mixChannels( src, dst, fromTo );\n}\n\n} // namespace\n\n#endif\n",
                "name": "grfmt_tiff.cpp",
                "path": "modules/imgcodecs/src/grfmt_tiff.cpp",
                "url": "/github.com/opencv/opencv/-/blob/modules/imgcodecs/src/grfmt_tiff.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 836,
                    "offsetAndLengths": [
                        [
                            51,
                            16
                        ]
                    ],
                    "preview": "                                CV_TIFF_CHECK_CALL(TIFFReadRGBATile(tif, x, y, (uint32_t*)src_buffer));"
                }
            ],
            "repository": {
                "name": "github.com/opencv/opencv",
                "url": "/github.com/opencv/opencv"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "24efe29f302f8780144eea622bdbd30a244e5a0b"
                },
                "content": "// Copyright 2020 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#include \"contrib/libtiff/wrapper/func.h\"\n\n#include <cstdint>\n\n// Work around the linker not including this symbol in the final sandboxee\n// binary.\nstatic volatile auto unused_reference_function =\n    reinterpret_cast<uintptr_t>(&TIFFReadRGBATile);\n\nint TIFFGetField1(TIFF* tif, uint32_t tag, void* param) {\n  return TIFFGetField(tif, tag, param);\n}\n\nint TIFFGetField2(TIFF* tif, uint32_t tag, void* param1, void* param2) {\n  return TIFFGetField(tif, tag, param1, param2);\n}\n\nint TIFFGetField3(TIFF* tif, uint32_t tag, void* param1, void* param2,\n                  void* param3) {\n  return TIFFGetField(tif, tag, param1, param2, param3);\n}\n\nint TIFFSetFieldUChar1(TIFF* tif, uint32_t tag, uint8_t param) {\n  return TIFFSetField(tif, tag, param);\n}\n\nint TIFFSetFieldUChar2(TIFF* tif, uint32_t tag, uint8_t param1,\n                       uint8_t param2) {\n  return TIFFSetField(tif, tag, param1, param2);\n}\n\nint TIFFSetFieldUChar3(TIFF* tif, uint32_t tag, uint8_t param1, uint8_t param2,\n                       uint8_t param3) {\n  return TIFFSetField(tif, tag, param1, param2, param3);\n}\n\nint TIFFSetFieldSChar1(TIFF* tif, uint32_t tag, int8_t param) {\n  return TIFFSetField(tif, tag, param);\n}\n\nint TIFFSetFieldSChar2(TIFF* tif, uint32_t tag, int8_t param1, int8_t param2) {\n  return TIFFSetField(tif, tag, param1, param2);\n}\n\nint TIFFSetFieldSChar3(TIFF* tif, uint32_t tag, int8_t param1, int8_t param2,\n                       int8_t param3) {\n  return TIFFSetField(tif, tag, param1, param2, param3);\n}\n\nint TIFFSetFieldU1(TIFF* tif, uint32_t tag, uint32_t param) {\n  return TIFFSetField(tif, tag, param);\n}\n\nint TIFFSetFieldU2(TIFF* tif, uint32_t tag, uint32_t param1, uint32_t param2) {\n  return TIFFSetField(tif, tag, param1, param2);\n}\n\nint TIFFSetFieldU3(TIFF* tif, uint32_t tag, uint32_t param1, uint32_t param2,\n                   uint32_t param3) {\n  return TIFFSetField(tif, tag, param1, param2, param3);\n}\n\nint TIFFSetFieldS1(TIFF* tif, uint32_t tag, int param) {\n  return TIFFSetField(tif, tag, param);\n}\n\nint TIFFSetFieldS2(TIFF* tif, uint32_t tag, int param1, int param2) {\n  return TIFFSetField(tif, tag, param1, param2);\n}\n\nint TIFFSetFieldS3(TIFF* tif, uint32_t tag, int param1, int param2,\n                   int param3) {\n  return TIFFSetField(tif, tag, param1, param2, param3);\n}\n\nint TIFFSetFieldUShort1(TIFF* tif, uint32_t tag, uint16_t param) {\n  return TIFFSetField(tif, tag, param);\n}\n\nint TIFFSetFieldUShort2(TIFF* tif, uint32_t tag, uint16_t param1,\n                        uint16_t param2) {\n  return TIFFSetField(tif, tag, param1, param2);\n}\n\nint TIFFSetFieldUShort3(TIFF* tif, uint32_t tag, uint16_t param1,\n                        uint16_t param2, uint16_t param3) {\n  return TIFFSetField(tif, tag, param1, param2, param3);\n}\n\nint TIFFSetFieldSShort1(TIFF* tif, uint32_t tag, int16_t param) {\n  return TIFFSetField(tif, tag, param);\n}\n\nint TIFFSetFieldSShort2(TIFF* tif, uint32_t tag, int16_t param1,\n                        int16_t param2) {\n  return TIFFSetField(tif, tag, param1, param2);\n}\n\nint TIFFSetFieldSShort3(TIFF* tif, uint32_t tag, int16_t param1, int16_t param2,\n                        int16_t param3) {\n  return TIFFSetField(tif, tag, param1, param2, param3);\n}\n\nint TIFFSetFieldULLong1(TIFF* tif, uint32_t tag, uint64_t param) {\n  return TIFFSetField(tif, tag, param);\n}\n\nint TIFFSetFieldULLong2(TIFF* tif, uint32_t tag, uint64_t param1,\n                        uint64_t param2) {\n  return TIFFSetField(tif, tag, param1, param2);\n}\n\nint TIFFSetFieldULLong3(TIFF* tif, uint32_t tag, uint64_t param1,\n                        uint64_t param2, uint64_t param3) {\n  return TIFFSetField(tif, tag, param1, param2, param3);\n}\n\nint TIFFSetFieldSLLong1(TIFF* tif, uint32_t tag, int64_t param) {\n  return TIFFSetField(tif, tag, param);\n}\n\nint TIFFSetFieldSLLong2(TIFF* tif, uint32_t tag, int64_t param1,\n                        int64_t param2) {\n  return TIFFSetField(tif, tag, param1, param2);\n}\n\nint TIFFSetFieldSLLong3(TIFF* tif, uint32_t tag, int64_t param1, int64_t param2,\n                        int64_t param3) {\n  return TIFFSetField(tif, tag, param1, param2, param3);\n}\n\nint TIFFSetFieldFloat1(TIFF* tif, uint32_t tag, float param) {\n  return TIFFSetField(tif, tag, param);\n}\n\nint TIFFSetFieldFloat2(TIFF* tif, uint32_t tag, float param1, float param2) {\n  return TIFFSetField(tif, tag, param1, param2);\n}\n\nint TIFFSetFieldFloat3(TIFF* tif, uint32_t tag, float param1, float param2,\n                       float param3) {\n  return TIFFSetField(tif, tag, param1, param2, param3);\n}\n\nint TIFFSetFieldDouble1(TIFF* tif, uint32_t tag, double param) {\n  return TIFFSetField(tif, tag, param);\n}\n\nint TIFFSetFieldDouble2(TIFF* tif, uint32_t tag, double param1, double param2) {\n  return TIFFSetField(tif, tag, param1, param2);\n}\n\nint TIFFSetFieldDouble3(TIFF* tif, uint32_t tag, double param1, double param2,\n                        double param3) {\n  return TIFFSetField(tif, tag, param1, param2, param3);\n}\n",
                "name": "func.cc",
                "path": "contrib/libtiff/wrapper/func.cc",
                "url": "/github.com/google/sandboxed-api/-/blob/contrib/libtiff/wrapper/func.cc"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 21,
                    "offsetAndLengths": [
                        [
                            33,
                            16
                        ]
                    ],
                    "preview": "    reinterpret_cast<uintptr_t>(&TIFFReadRGBATile);"
                }
            ],
            "repository": {
                "name": "github.com/google/sandboxed-api",
                "url": "/github.com/google/sandboxed-api"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "415fe634ba1e37953c31cc507f0282b6f96ba046"
                },
                "content": "// Copyright Contributors to the OpenImageIO project.\n// SPDX-License-Identifier: Apache-2.0\n// https://github.com/AcademySoftwareFoundation/OpenImageIO\n\n\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n\n#define AVOID_WIN32_FILEIO\n#include <tiffio.h>\n#include <zlib.h>\n\n#include <OpenImageIO/dassert.h>\n#include <OpenImageIO/filesystem.h>\n#include <OpenImageIO/fmath.h>\n#include <OpenImageIO/imageio.h>\n#include <OpenImageIO/parallel.h>\n#include <OpenImageIO/strutil.h>\n#include <OpenImageIO/thread.h>\n#include <OpenImageIO/tiffutils.h>\n#include <OpenImageIO/typedesc.h>\n\n#include \"imageio_pvt.h\"\n\n\n// General TIFF information:\n// TIFF 6.0 spec:\n//     http://partners.adobe.com/public/developer/en/tiff/TIFF6.pdf\n// Other Adobe TIFF docs:\n//     http://partners.adobe.com/public/developer/tiff/index.html\n// Adobe extensions to allow 16 (and 24) bit float in TIFF (ugh, not on\n// their developer page, only on Chris Cox's web site?):\n//     http://chriscox.org/TIFFTN3d1.pdf\n// Libtiff:\n//     http://remotesensing.org/libtiff/\n\n\n// clang-format off\n#ifdef TIFFLIB_MAJOR_VERSION\n// libtiff >= 4.5 defines versions by number -- use them.\n#    define OIIO_TIFFLIB_VERSION (TIFFLIB_MAJOR_VERSION * 10000 \\\n                                  + TIFFLIB_MINOR_VERSION * 100 \\\n                                  + TIFFLIB_MICRO_VERSION)\n// For older libtiff, we need to figure it out by date.\n#elif TIFFLIB_VERSION >= 20220520\n#    define OIIO_TIFFLIB_VERSION 40400\n#elif TIFFLIB_VERSION >= 20210416\n#    define OIIO_TIFFLIB_VERSION 40300\n#elif TIFFLIB_VERSION >= 20201219\n#    define OIIO_TIFFLIB_VERSION 40200\n#elif TIFFLIB_VERSION >= 20191103\n#    define OIIO_TIFFLIB_VERSION 40100\n#elif TIFFLIB_VERSION >= 20120922\n#    define OIIO_TIFFLIB_VERSION 40003\n#elif TIFFLIB_VERSION >= 20111221\n#    define OIIO_TIFFLIB_VERSION 40000\n#else\n#    error \"libtiff 4.0.0 or later is required\"\n#endif\n// clang-format on\n\n\nOIIO_PLUGIN_NAMESPACE_BEGIN\n\n\n// Helper struct for constructing tables of TIFF tags\nstruct TIFF_tag_info {\n    int tifftag;            // TIFF tag used for this info\n    const char* name;       // Attribute name we use, or NULL to ignore the tag\n    TIFFDataType tifftype;  // Data type that TIFF wants\n};\n\n\n\n// Note about MIP-maps versus subimages:\n//\n// TIFF files support subimages, but do not explicitly support\n// multiresolution/MIP maps.  So we have always used subimages to store\n// MIP levels.\n//\n// At present, TIFF is the only format people use for multires textures\n// that don't explicitly support it, so rather than make the\n// TextureSystem have to handle both cases, we choose instead to emulate\n// MIP with subimage in a way that's purely within the TIFFInput class.\n// To the outside world, it really does look MIP-mapped.  This only\n// kicks in for TIFF files that have the \"textureformat\" metadata set.\n//\n// The internal m_subimage really does contain the subimage, but for the\n// MIP emulation case, we report the subimage as the MIP level, and 0 as\n// the subimage.  It is indeed a tangled web of deceit we weave.\n\n\n\nclass TIFFInput final : public ImageInput {\npublic:\n    TIFFInput();\n    ~TIFFInput() override;\n    const char* format_name(void) const override { return \"tiff\"; }\n    bool valid_file(Filesystem::IOProxy* ioproxy) const override;\n    int supports(string_view feature) const override\n    {\n        return (feature == \"exif\" || feature == \"iptc\" || feature == \"ioproxy\"\n                || feature == \"multiimage\");\n        // N.B. No support for arbitrary metadata.\n    }\n    bool open(const std::string& name, ImageSpec& newspec) override;\n    bool open(const std::string& name, ImageSpec& newspec,\n              const ImageSpec& config) override;\n    bool close() override;\n    int current_subimage(void) const override\n    {\n        // If m_emulate_mipmap is true, pretend subimages are mipmap levels\n        lock_guard lock(*this);\n        return m_emulate_mipmap ? 0 : m_subimage;\n    }\n    int current_miplevel(void) const override\n    {\n        // If m_emulate_mipmap is true, pretend subimages are mipmap levels\n        lock_guard lock(*this);\n        return m_emulate_mipmap ? m_subimage : 0;\n    }\n    bool seek_subimage(int subimage, int miplevel) override;\n    ImageSpec spec(int subimage, int miplevel) override;\n    ImageSpec spec_dimensions(int subimage, int miplevel) override;\n    const ImageSpec& spec(void) const override { return m_spec; }\n    bool read_native_scanline(int subimage, int miplevel, int y, int z,\n                              void* data) override;\n    bool read_native_scanlines(int subimage, int miplevel, int ybegin, int yend,\n                               int z, void* data) override;\n    bool read_native_tile(int subimage, int miplevel, int x, int y, int z,\n                          void* data) override;\n    bool read_native_tiles(int subimage, int miplevel, int xbegin, int xend,\n                           int ybegin, int yend, int zbegin, int zend,\n                           void* data) override;\n    bool read_scanline(int y, int z, TypeDesc format, void* data,\n                       stride_t xstride) override;\n    bool read_scanlines(int subimage, int miplevel, int ybegin, int yend, int z,\n                        int chbegin, int chend, TypeDesc format, void* data,\n                        stride_t xstride, stride_t ystride) override;\n    bool read_tile(int x, int y, int z, TypeDesc format, void* data,\n                   stride_t xstride, stride_t ystride,\n                   stride_t zstride) override;\n    bool read_tiles(int subimage, int miplevel, int xbegin, int xend,\n                    int ybegin, int yend, int zbegin, int zend, int chbegin,\n                    int chend, TypeDesc format, void* data, stride_t xstride,\n                    stride_t ystride, stride_t zstride) override;\n\nprivate:\n    TIFF* m_tif;                            ///< libtiff handle\n    std::string m_filename;                 ///< Stash the filename\n    std::vector<unsigned char> m_scratch;   ///< Scratch space for us to use\n    std::vector<unsigned char> m_scratch2;  ///< More scratch\n    int m_subimage;           ///< What subimage are we looking at?\n    int m_next_scanline;      ///< Next scanline we'll read, relative to ymin\n    bool m_no_random_access;  ///< Should we avoid random access?\n    bool m_emulate_mipmap;    ///< Should we emulate mip with subimage?\n    bool m_keep_unassociated_alpha;  ///< If the image is unassociated, please\n                                     ///<   try to keep it that way!\n    bool m_raw_color;                ///< If the image is not RGB, don't\n                                     ///<   transform the color.\n    bool m_convert_alpha;            ///< Do we need to associate alpha?\n    bool m_separate;                 ///< Separate planarconfig?\n    bool m_testopenconfig;           ///< Debug aid to test open-with-config\n    bool m_use_rgba_interface;       ///< Sometimes we punt\n    bool m_is_byte_swapped;          ///< Is the file opposite our endian?\n    int m_rowsperstrip;              ///< For scanline imgs, rows per strip\n    unsigned short m_planarconfig;   ///< Planar config of the file\n    unsigned short m_bitspersample;  ///< Of the *file*, not the client's view\n    unsigned short m_photometric;    ///< Of the *file*, not the client's view\n    unsigned short m_compression;    ///< TIFF compression tag\n    unsigned short m_predictor;      ///< TIFF compression predictor tag\n    unsigned short m_inputchannels;  ///< Channels in the file (careful with CMYK)\n    std::vector<unsigned short> m_colormap;   ///< Color map for palette images\n    std::vector<uint32_t> m_rgbadata;         ///< Sometimes we punt\n    std::vector<ImageSpec> m_subimage_specs;  ///< Cached subimage specs\n\n    // Reset everything to initial state\n    void init()\n    {\n        m_tif                     = NULL;\n        m_subimage                = -1;\n        m_emulate_mipmap          = false;\n        m_keep_unassociated_alpha = false;\n        m_raw_color               = false;\n        m_convert_alpha           = false;\n        m_separate                = false;\n        m_inputchannels           = 0;\n        m_testopenconfig          = false;\n        m_colormap.clear();\n        m_use_rgba_interface = false;\n        m_subimage_specs.clear();\n        ioproxy_clear();\n    }\n\n    // Just close the TIFF file handle, but don't forget anything we\n    // learned about the contents of the file or any configuration hints.\n    void close_tif()\n    {\n        if (m_tif) {\n            TIFFClose(m_tif);\n            m_tif = NULL;\n            m_rgbadata.clear();\n            m_rgbadata.shrink_to_fit();\n        }\n    }\n\n    // Read tags from the current directory of m_tif and fill out spec.\n    // If read_meta is false, assume that m_spec already contains valid\n    // metadata and should not be cleared or rewritten.\n    // Return true if all is fine, false if something really bad happens,\n    // like we think the file is hopelessly corrupted.\n    bool readspec(bool read_meta = true);\n\n    // Figure out all the photometric-related aspects of the header\n    void readspec_photometric();\n\n    // Convert planar separate to contiguous data format\n    void separate_to_contig(int nplanes, int nvals,\n                            const unsigned char* separate,\n                            unsigned char* contig);\n\n    // Convert palette to RGB\n    void palette_to_rgb(int n, const unsigned char* palettepels,\n                        unsigned char* rgb);\n    void palette_to_rgb(int n, const uint16_t* palettepels, unsigned char* rgb);\n\n    // Convert in-bits to out-bits (outbits must be 8, 16, 32, and\n    // inbits < outbits)\n    void bit_convert(int n, const unsigned char* in, int inbits, void* out,\n                     int outbits);\n\n    void invert_photometric(int n, void* data);\n\n    const TIFFField* find_field(int tifftag, TIFFDataType tifftype = TIFF_ANY)\n    {\n        return TIFFFindField(m_tif, tifftag, tifftype);\n    }\n\n    OIIO_NODISCARD\n    TypeDesc tiffgetfieldtype(int tag)\n    {\n        auto field = find_field(tag);\n        if (!field)\n            return TypeUnknown;\n        TIFFDataType tiffdatatype = TIFFFieldDataType(field);\n        int passcount             = TIFFFieldPassCount(field);\n        int readcount             = TIFFFieldReadCount(field);\n        if (!passcount && readcount > 0)\n            return tiff_datatype_to_typedesc(tiffdatatype, readcount);\n        return TypeUnknown;\n    }\n\n    OIIO_NODISCARD\n    bool safe_tiffgetfield(string_view name OIIO_MAYBE_UNUSED, int tag,\n                           TypeDesc expected, void* dest)\n    {\n        TypeDesc type = tiffgetfieldtype(tag);\n        // Caller expects a specific type and the tag doesn't match? Punt.\n        if (expected != TypeUnknown && !equivalent(expected, type))\n            return false;\n        auto field = find_field(tag);\n        if (!field)\n            return false;\n\n        // TIFFDataType tiffdatatype = TIFFFieldDataType(field);\n        int passcount = TIFFFieldPassCount(field);\n        int readcount = TIFFFieldReadCount(field);\n        if (!passcount && readcount > 0) {\n            return TIFFGetField(m_tif, tag, dest);\n        }\n        // OIIO::debugfmt(\" stgf {} tag {} {} datatype {} passcount {} readcount {}\\n\",\n        //                name, tag, type, int(TIFFFieldDataType(field)), passcount, readcount);\n        return false;\n    }\n\n    // Get a string tiff tag field and save it it as a string_view. The\n    // return value will be true if the tag was found, otherwise false.\n    OIIO_NODISCARD\n    bool tiff_get_string_field(int tag, string_view name OIIO_MAYBE_UNUSED,\n                               string_view& result)\n    {\n        auto field = find_field(tag);\n        if (!field)\n            return false;\n        TIFFDataType tiffdatatype = TIFFFieldDataType(field);\n        int passcount             = TIFFFieldPassCount(field);\n        int readcount             = TIFFFieldReadCount(field);\n        // Strutil::printf(\" tgsf %s tag %d datatype %d passcount %d readcount %d\\n\",\n        //                 name, tag, int(tiffdatatype), passcount, readcount);\n        char* s        = nullptr;\n        uint32_t count = 0;\n        bool ok        = false;\n        if (tiffdatatype == TIFF_ASCII && passcount\n            && readcount == TIFF_VARIABLE) {\n            uint16_t shortcount = 0;\n            ok                  = TIFFGetField(m_tif, tag, &shortcount, &s);\n            count               = shortcount;\n        } else if (tiffdatatype == TIFF_ASCII && passcount\n                   && readcount == TIFF_VARIABLE2) {\n            ok = TIFFGetField(m_tif, tag, &count, &s);\n        } else if (readcount > 0) {\n            ok    = TIFFGetField(m_tif, tag, &s);\n            count = readcount;\n        } else if (tiffdatatype == TIFF_ASCII) {\n            ok = TIFFGetField(m_tif, tag, &s);\n            if (ok && s && *s)\n                count = Strutil::safe_strlen(s, 64 * 1024);\n        } else {\n            // Some other type, we should not have been asking for this\n            // as ASCII, or maybe the tag is just the wrong data type in\n            // the file. Punt.\n        }\n        if (ok && s && *s) {\n            result = Strutil::safe_string_view(s, count);\n        }\n        return ok;\n    }\n\n    // Get a string tiff tag field and put it into extra_params\n    void get_string_attribute(string_view name, int tag)\n    {\n        string_view s;\n        if (tiff_get_string_field(tag, name, s)) {\n            if (s.size())\n                m_spec.attribute(name, s);\n            else\n                m_spec.erase_attribute(name);\n        }\n    }\n\n    // Get a matrix tiff tag field and put it into extra_params\n    void get_matrix_attribute(string_view name, int tag)\n    {\n        float* f = nullptr;\n        if (safe_tiffgetfield(name, tag, TypeUnknown, &f) && f)\n            m_spec.attribute(name, TypeMatrix, f);\n    }\n\n    // Get a float tiff tag field and put it into extra_params\n    void get_float_attribute(string_view name, int tag)\n    {\n        float f[16];\n        if (safe_tiffgetfield(name, tag, TypeUnknown, f))\n            m_spec.attribute(name, f[0]);\n    }\n\n    // Get an int tiff tag field and put it into extra_params\n    void get_int_attribute(string_view name, int tag)\n    {\n        int i = 0;\n        if (safe_tiffgetfield(name, tag, TypeUnknown, &i))\n            m_spec.attribute(name, i);\n    }\n\n    // Get an int tiff tag field and put it into extra_params\n    void get_short_attribute(string_view name, int tag)\n    {\n        // Make room for two shorts, in case the tag is not the type we\n        // expect, and libtiff writes a long instead.\n        unsigned short s[2] = { 0, 0 };\n        if (safe_tiffgetfield(name, tag, TypeUInt16, &s)) {\n            int i = s[0];\n            m_spec.attribute(name, i);\n        }\n    }\n\n    // Search for TIFF tag having type 'tifftype', and if found,\n    // add it in the obvious way to m_spec under the name 'oiioname'.\n    void find_tag(int tifftag, TIFFDataType tifftype, string_view oiioname)\n    {\n        auto info = find_field(tifftag, tifftype);\n        if (!info) {\n            // Something has gone wrong, libtiff doesn't think the field type\n            // is the same as we do.\n            return;\n        }\n        if (tifftype == TIFF_ASCII)\n            get_string_attribute(oiioname, tifftag);\n        else if (tifftype == TIFF_SHORT)\n            get_short_attribute(oiioname, tifftag);\n        else if (tifftype == TIFF_LONG)\n            get_int_attribute(oiioname, tifftag);\n        else if (tifftype == TIFF_RATIONAL || tifftype == TIFF_SRATIONAL\n                 || tifftype == TIFF_FLOAT || tifftype == TIFF_DOUBLE)\n            get_float_attribute(oiioname, tifftag);\n    }\n\n    // If we're at scanline y, where does the next strip start?\n    int next_strip_boundary(int y)\n    {\n        return round_to_multiple(y - m_spec.y, m_rowsperstrip) + m_spec.y;\n    }\n\n    bool is_strip_boundary(int y)\n    {\n        return y == next_strip_boundary(y) || y == m_spec.height;\n    }\n\n    // Copy a height x width x chans region of src to dst, un-applying a\n    // horizontal predictor to each row. It is permitted for src and dst to\n    // be the same.\n    template<typename T>\n    void undo_horizontal_predictor(T* dst, const T* src, int chans, int width,\n                                   int height)\n    {\n        for (int y = 0; y < height;\n             ++y, src += chans * width, dst += chans * width)\n            for (int c = 0; c < chans; ++c) {\n                dst[c] = src[c];  // element 0\n                for (int x = 1; x < width; ++x)\n                    dst[x * chans + c] = src[(x - 1) * chans + c]\n                                         + src[x * chans + c];\n            }\n    }\n\n    void uncompress_one_strip(const void* compressed_buf, unsigned long csize,\n                              void* uncompressed_buf, size_t strip_bytes,\n                              int channels, int width, int height, bool* ok)\n    {\n        OIIO_DASSERT (m_compression == COMPRESSION_ADOBE_DEFLATE /*||\n                      m_compression == COMPRESSION_NONE*/);\n        size_t nvals = size_t(width) * size_t(height) * size_t(channels);\n        if (m_compression == COMPRESSION_NONE) {\n            // just copy if there's no compression\n            memcpy(uncompressed_buf, compressed_buf, csize);\n            if (m_is_byte_swapped && m_spec.format == TypeUInt16)\n                TIFFSwabArrayOfShort((unsigned short*)uncompressed_buf, nvals);\n            return;\n        }\n        uLong uncompressed_size = (uLong)strip_bytes;\n        auto zok = uncompress((Bytef*)uncompressed_buf, &uncompressed_size,\n                              (const Bytef*)compressed_buf, csize);\n        if (zok != Z_OK || uncompressed_size != strip_bytes) {\n            *ok = false;\n            return;\n        }\n        if (m_is_byte_swapped && m_spec.format == TypeUInt16)\n            TIFFSwabArrayOfShort((unsigned short*)uncompressed_buf, nvals);\n        if (m_predictor == PREDICTOR_HORIZONTAL) {\n            if (m_spec.format == TypeUInt8)\n                undo_horizontal_predictor((unsigned char*)uncompressed_buf,\n                                          (unsigned char*)uncompressed_buf,\n                                          channels, width, height);\n            else if (m_spec.format == TypeUInt16)\n                undo_horizontal_predictor((unsigned short*)uncompressed_buf,\n                                          (unsigned short*)uncompressed_buf,\n                                          channels, width, height);\n        }\n    }\n\n    int tile_index(int x, int y, int z)\n    {\n        int xtile   = (x - m_spec.x) / m_spec.tile_width;\n        int ytile   = (y - m_spec.y) / m_spec.tile_height;\n        int ztile   = (z - m_spec.z) / m_spec.tile_depth;\n        int nxtiles = (m_spec.width + m_spec.tile_width - 1)\n                      / m_spec.tile_width;\n        int nytiles = (m_spec.height + m_spec.tile_height - 1)\n                      / m_spec.tile_height;\n        return xtile + ytile * nxtiles + ztile * nxtiles * nytiles;\n    }\n\n#if OIIO_TIFFLIB_VERSION >= 40500\n    std::string m_last_error;\n    spin_mutex m_last_error_mutex;\n\n    std::string oiio_tiff_last_error()\n    {\n        spin_lock lock(m_last_error_mutex);\n        return m_last_error;\n    }\n\n    // TIFF 4.5+ has a mechanism for per-file thread-safe error handlers.\n    // Use it.\n    static int my_error_handler(TIFF* tif, void* user_data,\n                                const char* /*module*/, const char* fmt,\n                                va_list ap)\n    {\n        TIFFInput* self = (TIFFInput*)user_data;\n        spin_lock lock(self->m_last_error_mutex);\n        OIIO_PRAGMA_WARNING_PUSH\n        OIIO_GCC_PRAGMA(GCC diagnostic ignored \"-Wformat-nonliteral\")\n        self->m_last_error = Strutil::vsprintf(fmt, ap);\n        OIIO_PRAGMA_WARNING_POP\n        return 1;\n    }\n\n    static int my_warning_handler(TIFF* tif, void* user_data,\n                                  const char* /*module*/, const char* fmt,\n                                  va_list ap)\n    {\n        TIFFInput* self = (TIFFInput*)user_data;\n        spin_lock lock(self->m_last_error_mutex);\n        OIIO_PRAGMA_WARNING_PUSH\n        OIIO_GCC_PRAGMA(GCC diagnostic ignored \"-Wformat-nonliteral\")\n        self->m_last_error = Strutil::vsprintf(fmt, ap);\n        OIIO_PRAGMA_WARNING_POP\n        return 1;\n    }\n#endif\n};\n\n\n\n// Obligatory material to make this a recognizable imageio plugin:\nOIIO_PLUGIN_EXPORTS_BEGIN\n\nOIIO_EXPORT ImageInput*\ntiff_input_imageio_create()\n{\n    return new TIFFInput;\n}\n\n// OIIO_EXPORT int tiff_imageio_version = OIIO_PLUGIN_VERSION; // it's in tiffoutput.cpp\n\nOIIO_EXPORT const char* tiff_input_extensions[]\n    = { \"tif\", \"tiff\", \"tx\", \"env\", \"sm\", \"vsm\", nullptr };\n\nOIIO_PLUGIN_EXPORTS_END\n\n\n#if OIIO_TIFFLIB_VERSION < 40500\n// For TIFF 4.4 and earlier, we need someplace to store an error message from\n// the global TIFF error handler. To avoid thread oddities, we have the\n// storage area buffering error messages be thread-specific.\nstatic thread_local std::string thread_error_msg;\nstatic atomic_int handler_set;\nstatic spin_mutex handler_mutex;\n\n\n\nstd::string&\noiio_tiff_last_error()\n{\n    return thread_error_msg;\n}\n\n\n\nstatic void\nmy_error_handler(const char* /*str*/, const char* format, va_list ap)\n{\n    OIIO_PRAGMA_WARNING_PUSH\n    OIIO_GCC_PRAGMA(GCC diagnostic ignored \"-Wformat-nonliteral\")\n    oiio_tiff_last_error() = Strutil::vsprintf(format, ap);\n    OIIO_PRAGMA_WARNING_POP\n}\n\n\n\nvoid\noiio_tiff_set_error_handler()\n{\n    if (!handler_set) {\n        spin_lock lock(handler_mutex);\n        if (!handler_set) {\n            TIFFSetErrorHandler(my_error_handler);\n            TIFFSetWarningHandler(my_error_handler);\n            handler_set = 1;\n        }\n    }\n}\n#endif\n\n\nstatic tsize_t\nreader_readproc(thandle_t handle, tdata_t data, tsize_t size)\n{\n    auto io = static_cast<Filesystem::IOProxy*>(handle);\n    // Strutil::print(\"iop read {} {} @ {}\\n\",\n    //                io->filename(), size, io->tell());\n    auto r = io->read(data, size);\n    // for (size_t i = 0; i < r; ++i)\n    //     Strutil::print(\" {:02x}\",\n    //                    int(((unsigned char *)data)[i]));\n    // Strutil::print(\"\\n\");\n    return tsize_t(r);\n}\n\nstatic tsize_t\nreader_writeproc(thandle_t, tdata_t, tsize_t size)\n{\n    return tsize_t(0);\n}\n\nstatic toff_t\nreader_seekproc(thandle_t handle, toff_t offset, int origin)\n{\n    auto io = static_cast<Filesystem::IOProxy*>(handle);\n    // Strutil::print(\"iop seek {} {} ({})\\n\",\n    //                io->filename(), offset, origin);\n    return (io->seek(offset, origin)) ? toff_t(io->tell()) : toff_t(-1);\n}\n\nstatic int\nreader_closeproc(thandle_t handle)\n{\n    // auto io = static_cast<Filesystem::IOProxy*>(handle);\n    // if (io && io->opened()) {\n    //     // Strutil::print(\"iop close {}\\n\\n\",\n    //     //                io->filename());\n    //     // io->seek(0);\n    //     io->close();\n    // }\n    return 0;\n}\n\nstatic toff_t\nreader_sizeproc(thandle_t handle)\n{\n    auto io = static_cast<Filesystem::IOProxy*>(handle);\n    // Strutil::print(\"iop size\\n\");\n    return toff_t(io->size());\n}\n\nstatic int\nreader_mapproc(thandle_t, tdata_t*, toff_t*)\n{\n    return 0;\n}\n\nstatic void\nreader_unmapproc(thandle_t, tdata_t, toff_t)\n{\n}\n\n\n\n// clang-format off\n\nstatic std::pair<int, const char*>  tiff_input_compressions[] = {\n    { COMPRESSION_NONE,          \"none\" },        // no compression\n    { COMPRESSION_LZW,           \"lzw\" },         // LZW\n    { COMPRESSION_ADOBE_DEFLATE, \"zip\" },         // deflate / zip\n    { COMPRESSION_DEFLATE,       \"zip\" },         // deflate / zip\n    { COMPRESSION_CCITTRLE,      \"ccittrle\" },    // CCITT RLE\n    { COMPRESSION_CCITTFAX3,     \"ccittfax3\" },   // CCITT group 3 fax\n    { COMPRESSION_CCITT_T4,      \"ccitt_t4\" },    // CCITT T.4\n    { COMPRESSION_CCITTFAX4,     \"ccittfax4\" },   // CCITT group 4 fax\n    { COMPRESSION_CCITT_T6,      \"ccitt_t6\" },    // CCITT T.6\n    { COMPRESSION_OJPEG,         \"ojpeg\" },       // old (pre-TIFF6.0) JPEG\n    { COMPRESSION_JPEG,          \"jpeg\" },        // JPEG\n    { COMPRESSION_NEXT,          \"next\" },        // NeXT 2-bit RLE\n    { COMPRESSION_CCITTRLEW,     \"ccittrle2\" },   // #1 w/ word alignment\n    { COMPRESSION_PACKBITS,      \"packbits\" },    // Macintosh RLE\n    { COMPRESSION_THUNDERSCAN,   \"thunderscan\" }, // ThundeScan RLE\n    { COMPRESSION_IT8CTPAD,      \"IT8CTPAD\" },    // IT8 CT w/ patting\n    { COMPRESSION_IT8LW,         \"IT8LW\" },       // IT8 linework RLE\n    { COMPRESSION_IT8MP,         \"IT8MP\" },       // IT8 monochrome picture\n    { COMPRESSION_IT8BL,         \"IT8BL\" },       // IT8 binary line art\n    { COMPRESSION_PIXARFILM,     \"pixarfilm\" },   // Pixar 10 bit LZW\n    { COMPRESSION_PIXARLOG,      \"pixarlog\" },    // Pixar 11 bit ZIP\n    { COMPRESSION_DCS,           \"dcs\" },         // Kodak DCS encoding\n    { COMPRESSION_JBIG,          \"isojbig\" },     // ISO JBIG\n    { COMPRESSION_SGILOG,        \"sgilog\" },      // SGI log luminance RLE\n    { COMPRESSION_SGILOG24,      \"sgilog24\" },    // SGI log 24bit\n    { COMPRESSION_JP2000,        \"jp2000\" },      // Leadtools JPEG2000\n#if defined(TIFF_VERSION_BIG) && OIIO_TIFFLIB_VERSION >= 40003\n    // Others supported in more recent TIFF library versions.\n    { COMPRESSION_T85,           \"T85\" },         // TIFF/FX T.85 JBIG\n    { COMPRESSION_T43,           \"T43\" },         // TIFF/FX T.43 color layered JBIG\n    { COMPRESSION_LZMA,          \"lzma\" },        // LZMA2\n#endif\n};\n\n// clang-format on\n\nstatic const char*\ntiff_compression_name(int code)\n{\n    for (const auto& c : tiff_input_compressions)\n        if (c.first == code)\n            return c.second;\n    return nullptr;\n}\n\n\n\nTIFFInput::TIFFInput()\n{\n#if OIIO_TIFFLIB_VERSION < 40500\n    oiio_tiff_set_error_handler();\n#endif\n    init();\n}\n\n\n\nTIFFInput::~TIFFInput()\n{\n    // Close, if not already done.\n    close();\n}\n\n\n\nbool\nTIFFInput::valid_file(Filesystem::IOProxy* ioproxy) const\n{\n    if (!ioproxy || ioproxy->mode() != Filesystem::IOProxy::Mode::Read)\n        return false;\n\n    uint16_t magic[2] {};\n    const size_t numRead = ioproxy->pread(magic, sizeof(magic), 0);\n    if (numRead != sizeof(magic))  // read failed\n        return false;\n    if (magic[0] != TIFF_LITTLEENDIAN && magic[0] != TIFF_BIGENDIAN)\n        return false;  // not the right byte order\n    if ((magic[0] == TIFF_LITTLEENDIAN) != littleendian())\n        swap_endian(&magic[1], 1);\n    return (magic[1] == 42 /* Classic TIFF */ || magic[1] == 43 /* Big TIFF */);\n    // local_io, if used, will automatically close and free. A passed in\n    // proxy will remain in its prior state.\n}\n\n\n\nbool\nTIFFInput::open(const std::string& name, ImageSpec& newspec)\n{\n    m_filename = name;\n    m_subimage = -1;\n\n    bool ok = seek_subimage(0, 0);\n    newspec = spec();\n    return ok;\n}\n\n\n\nbool\nTIFFInput::open(const std::string& name, ImageSpec& newspec,\n                const ImageSpec& config)\n{\n    // Check 'config' for any special requests\n    ioproxy_retrieve_from_config(config);\n    if (config.get_int_attribute(\"oiio:UnassociatedAlpha\", 0) == 1)\n        m_keep_unassociated_alpha = true;\n    if (config.get_int_attribute(\"oiio:RawColor\", 0) == 1)\n        m_raw_color = true;\n    // This configuration hint has no function other than as a debugging aid\n    // for testing whether configurations are received properly from other\n    // OIIO components.\n    if (config.get_int_attribute(\"oiio:DebugOpenConfig!\", 0))\n        m_testopenconfig = true;\n    return open(name, newspec);\n}\n\n\n\nbool\nTIFFInput::seek_subimage(int subimage, int miplevel)\n{\n    if (subimage < 0)  // Illegal\n        return false;\n    if (m_emulate_mipmap) {\n        // Emulating MIPmap?  Pretend one subimage, many MIP levels.\n        if (subimage != 0)\n            return false;\n        subimage = miplevel;\n    } else {\n        // No MIPmap emulation\n        if (miplevel != 0)\n            return false;\n    }\n\n    if (subimage == m_subimage) {\n        // We're already pointing to the right subimage\n        return true;\n    }\n\n    // If we're emulating a MIPmap, only resolution is allowed to change\n    // between MIP levels, so if we already have a valid level in m_spec,\n    // we don't need to re-parse metadata, it's guaranteed to be the same.\n    bool read_meta = !(m_emulate_mipmap && m_tif && m_subimage >= 0);\n\n    if (!m_tif) {\n#if OIIO_TIFFLIB_VERSION >= 40500\n        auto openopts = TIFFOpenOptionsAlloc();\n        TIFFOpenOptionsSetErrorHandlerExtR(openopts, my_error_handler, this);\n        TIFFOpenOptionsSetWarningHandlerExtR(openopts, my_warning_handler,\n                                             this);\n#endif\n        if (ioproxy_opened()) {\n            static_assert(sizeof(thandle_t) == sizeof(void*),\n                          \"thandle_t must be same size as void*\");\n            // Strutil::print(\"\\n\\nOpening client \\\"{}\\\"\\n\", m_filename);\n            ioseek(0);\n#if OIIO_TIFFLIB_VERSION >= 40500\n            m_tif = TIFFClientOpen(m_filename.c_str(), \"rm\", ioproxy(),\n                                   reader_readproc, reader_writeproc,\n                                   reader_seekproc, reader_closeproc,\n                                   reader_sizeproc, reader_mapproc,\n                                   reader_unmapproc);\n#else\n            m_tif = TIFFClientOpen(m_filename.c_str(), \"rm\", ioproxy(),\n                                   reader_readproc, reader_writeproc,\n                                   reader_seekproc, reader_closeproc,\n                                   reader_sizeproc, reader_mapproc,\n                                   reader_unmapproc);\n#endif\n        } else {\n#if OIIO_TIFFLIB_VERSION >= 40500\n#    ifdef _WIN32\n            std::wstring wfilename = Strutil::utf8_to_utf16wstring(m_filename);\n            m_tif = TIFFOpenWExt(wfilename.c_str(), \"rm\", openopts);\n#    else\n            m_tif = TIFFOpenExt(m_filename.c_str(), \"rm\", openopts);\n#    endif\n#else\n#    ifdef _WIN32\n            std::wstring wfilename = Strutil::utf8_to_utf16wstring(m_filename);\n            m_tif                  = TIFFOpenW(wfilename.c_str(), \"rm\");\n#    else\n            m_tif = TIFFOpen(m_filename.c_str(), \"rm\");\n#    endif\n#endif\n        }\n#if OIIO_TIFFLIB_VERSION >= 40500\n        TIFFOpenOptionsFree(openopts);\n#endif\n        if (m_tif == NULL) {\n            std::string e = oiio_tiff_last_error();\n            errorfmt(\"Could not open file: {}\", e.length() ? e : m_filename);\n            close_tif();\n            return false;\n        }\n        m_is_byte_swapped = TIFFIsByteSwapped(m_tif);\n        m_subimage        = 0;\n    }\n\n    m_next_scanline = 0;  // next scanline we'll read\n    if (subimage == m_subimage || TIFFSetDirectory(m_tif, subimage)) {\n        m_subimage = subimage;\n        if (!readspec(read_meta))\n            return false;\n\n        char emsg[1024];\n        if (m_use_rgba_interface && !TIFFRGBAImageOK(m_tif, emsg)) {\n            errorfmt(\"No support for this flavor of TIFF file ({})\", emsg);\n            return false;\n        }\n        if (size_t(subimage) >= m_subimage_specs.size())  // make room\n            m_subimage_specs.resize(\n                subimage > 0 ? round_to_multiple(subimage + 1, 4) : 1);\n        if (m_subimage_specs[subimage].undefined()) {\n            // haven't cached this spec yet\n            m_subimage_specs[subimage] = m_spec;\n        }\n        if (m_spec.format == TypeDesc::UNKNOWN) {\n            errorfmt(\"No support for data format of \\\"{}\\\"\", m_filename);\n            return false;\n        }\n        if (!check_open(m_spec,\n                        { 0, 1 << 20, 0, 1 << 20, 0, 1 << 16, 0, 1 << 16 }))\n            return false;\n        return true;\n    } else {\n        std::string e = oiio_tiff_last_error();\n        errorfmt(\"Err: {}\", e.length() ? e : m_filename);\n        m_subimage = -1;\n        return false;\n    }\n}\n\n\n\nImageSpec\nTIFFInput::spec(int subimage, int miplevel)\n{\n    ImageSpec ret;\n\n    // s == index of the spec list to retrieve. Start by presuming it's\n    // the sublevel number.\n    int s = subimage;\n    if (m_emulate_mipmap) {\n        // This is the kind of TIFF file where we are emulating MIPmap\n        // levels with TIFF subimages.\n        if (subimage != 0)\n            return ret;  // Invalid subimage request, return the empty spec\n        // Index into the spec list by miplevel instead, because that's\n        // what it really contains.\n        s = miplevel;\n    }\n\n    lock_guard lock(*this);\n    if (s >= 0 && s < int(m_subimage_specs.size())\n        && !m_subimage_specs[s].undefined()) {\n        // If we've cached this spec, we don't need to seek and read\n        ret = m_subimage_specs[s];\n    } else {\n        if (seek_subimage(subimage, miplevel))\n            ret = m_spec;\n    }\n    return ret;\n}\n\n\n\nImageSpec\nTIFFInput::spec_dimensions(int subimage, int miplevel)\n{\n    ImageSpec ret;\n\n    // s == index of the spec list to retrieve. Start by presuming it's\n    // the sublevel number.\n    int s = subimage;\n    if (m_emulate_mipmap) {\n        // This is the kind of TIFF file where we are emulating MIPmap\n        // levels with TIFF subimages.\n        if (subimage != 0)\n            return ret;  // Invalid subimage request, return the empty spec\n        // Index into the spec list by miplevel instead, because that's\n        // what it really contains.\n        s = miplevel;\n    }\n\n    lock_guard lock(*this);\n    if (s >= 0 && s < int(m_subimage_specs.size())\n        && !m_subimage_specs[s].undefined()) {\n        // If we've cached this spec, we don't need to seek and read\n        ret.copy_dimensions(m_subimage_specs[s]);\n    } else {\n        if (seek_subimage(subimage, miplevel))\n            ret.copy_dimensions(m_spec);\n    }\n    return ret;\n}\n\n\n\n#define ICC_PROFILE_ATTR \"ICCProfile\"\n\n\nbool\nTIFFInput::readspec(bool read_meta)\n{\n    uint32_t width = 0, height = 0, depth = 0;\n    TIFFGetField(m_tif, TIFFTAG_IMAGEWIDTH, &width);\n    TIFFGetField(m_tif, TIFFTAG_IMAGELENGTH, &height);\n    TIFFGetFieldDefaulted(m_tif, TIFFTAG_IMAGEDEPTH, &depth);\n    TIFFGetFieldDefaulted(m_tif, TIFFTAG_SAMPLESPERPIXEL, &m_inputchannels);\n\n    if (read_meta) {\n        // clear the whole m_spec and start fresh\n        m_spec = ImageSpec((int)width, (int)height, (int)m_inputchannels);\n    } else {\n        // assume m_spec is valid, except for things that might differ\n        // between MIP levels\n        m_spec.width     = (int)width;\n        m_spec.height    = (int)height;\n        m_spec.depth     = (int)depth;\n        m_spec.nchannels = (int)m_inputchannels;\n    }\n\n    float xpos = 0, ypos = 0;\n    TIFFGetField(m_tif, TIFFTAG_XPOSITION, &xpos);\n    TIFFGetField(m_tif, TIFFTAG_YPOSITION, &ypos);\n    if (xpos || ypos) {\n        // In the TIFF files, the positions are in resolutionunit. But we\n        // didn't used to interpret it that way, hence the mess below.\n        float xres = 1, yres = 1;\n        TIFFGetField(m_tif, TIFFTAG_XRESOLUTION, &xres);\n        TIFFGetField(m_tif, TIFFTAG_YRESOLUTION, &yres);\n        // See if the 'Software' field has a clue about what version of OIIO\n        // wrote the TIFF file. This can save us from embarrassing mistakes\n        // misinterpreting the image offset.\n        int oiio_write_version = 0;\n        string_view software;\n        if (tiff_get_string_field(TIFFTAG_SOFTWARE, \"Software\", software)\n            && Strutil::parse_prefix(software, \"OpenImageIO\")) {\n            int major = 0, minor = 0, patch = 0;\n            if (Strutil::parse_int(software, major)\n                && Strutil::parse_char(software, '.')\n                && Strutil::parse_int(software, minor)\n                && Strutil::parse_char(software, '.')\n                && Strutil::parse_int(software, patch)) {  // NOSONAR\n                oiio_write_version = major * 10000 + minor * 100 + patch;\n            }\n        }\n        // Old version of OIIO did not write the field correctly, so try\n        // to compensate.\n        if (oiio_write_version && oiio_write_version < 10803) {\n            xres = yres = 1.0f;\n        }\n        m_spec.x = (int)(xpos * xres);\n        m_spec.y = (int)(ypos * yres);\n    } else {\n        m_spec.x = 0;\n        m_spec.y = 0;\n    }\n    m_spec.z = 0;\n\n    // Start by assuming the \"full\" (aka display) window is the same as the\n    // data window. That's what we'll stick to if there is no further\n    // information in the file. But if the file has tags for the \"full\"\n    // size, assume a display window with origin (0,0) and those dimensions.\n    // (Unfortunately, there are no TIFF tags for \"full\" origin.)\n    m_spec.full_x      = m_spec.x;\n    m_spec.full_y      = m_spec.y;\n    m_spec.full_z      = m_spec.z;\n    m_spec.full_width  = m_spec.width;\n    m_spec.full_height = m_spec.height;\n    m_spec.full_depth  = m_spec.depth;\n    if (TIFFGetField(m_tif, TIFFTAG_PIXAR_IMAGEFULLWIDTH, &width) == 1\n        && TIFFGetField(m_tif, TIFFTAG_PIXAR_IMAGEFULLLENGTH, &height) == 1\n        && width > 0 && height > 0) {\n        m_spec.full_width  = width;\n        m_spec.full_height = height;\n        m_spec.full_x      = 0;\n        m_spec.full_y      = 0;\n    }\n\n    if (TIFFIsTiled(m_tif)) {\n        TIFFGetField(m_tif, TIFFTAG_TILEWIDTH, &m_spec.tile_width);\n        TIFFGetField(m_tif, TIFFTAG_TILELENGTH, &m_spec.tile_height);\n        TIFFGetFieldDefaulted(m_tif, TIFFTAG_TILEDEPTH, &m_spec.tile_depth);\n    } else {\n        m_spec.tile_width  = 0;\n        m_spec.tile_height = 0;\n        m_spec.tile_depth  = 0;\n    }\n\n    TIFFGetFieldDefaulted(m_tif, TIFFTAG_BITSPERSAMPLE, &m_bitspersample);\n    m_spec.attribute(\"oiio:BitsPerSample\", (int)m_bitspersample);\n\n    unsigned short sampleformat = SAMPLEFORMAT_UINT;\n    TIFFGetFieldDefaulted(m_tif, TIFFTAG_SAMPLEFORMAT, &sampleformat);\n    switch (m_bitspersample) {\n    case 1:\n    case 2:\n    case 4:\n    case 6:\n        // Make 1, 2, 4, 6 bpp look like byte images\n    case 8:\n        if (sampleformat == SAMPLEFORMAT_UINT)\n            m_spec.set_format(TypeDesc::UINT8);\n        else if (sampleformat == SAMPLEFORMAT_INT)\n            m_spec.set_format(TypeDesc::INT8);\n        else\n            m_spec.set_format(TypeDesc::UINT8);  // punt\n        break;\n    case 10:\n    case 12:\n    case 14:\n        // Make 10, 12, 14 bpp look like 16 bit images\n    case 16:\n        if (sampleformat == SAMPLEFORMAT_UINT)\n            m_spec.set_format(TypeDesc::UINT16);\n        else if (sampleformat == SAMPLEFORMAT_INT)\n            m_spec.set_format(TypeDesc::INT16);\n        else if (sampleformat == SAMPLEFORMAT_IEEEFP) {\n            m_spec.set_format(TypeDesc::HALF);\n            // Adobe extension, see http://chriscox.org/TIFFTN3d1.pdf\n        } else\n            m_spec.set_format(TypeDesc::UNKNOWN);\n        break;\n    case 24:\n        // Make 24 bit look like 32 bit\n    case 32:\n        if (sampleformat == SAMPLEFORMAT_IEEEFP)\n            m_spec.set_format(TypeDesc::FLOAT);\n        else if (sampleformat == SAMPLEFORMAT_UINT)\n            m_spec.set_format(TypeDesc::UINT32);\n        else if (sampleformat == SAMPLEFORMAT_INT)\n            m_spec.set_format(TypeDesc::INT32);\n        else\n            m_spec.set_format(TypeDesc::UNKNOWN);\n        break;\n    case 64:\n        if (sampleformat == SAMPLEFORMAT_IEEEFP)\n            m_spec.set_format(TypeDesc::DOUBLE);\n        else\n            m_spec.set_format(TypeDesc::UNKNOWN);\n        break;\n    default: m_spec.set_format(TypeDesc::UNKNOWN); break;\n    }\n\n    // Use the table for all the obvious things that can be mindlessly\n    // shoved into the image spec.\n    if (read_meta) {\n        for (const auto& tag : tag_table(\"TIFF\"))\n            find_tag(tag.tifftag, tag.tifftype, tag.name);\n        for (const auto& tag : tag_table(\"Exif\"))\n            find_tag(tag.tifftag, tag.tifftype, tag.name);\n    }\n\n    // Now we need to get fields \"by hand\" for anything else that is less\n    // straightforward...\n\n    m_compression = 0;\n    TIFFGetFieldDefaulted(m_tif, TIFFTAG_COMPRESSION, &m_compression);\n    m_spec.attribute(\"tiff:Compression\", (int)m_compression);\n\n    m_photometric = (m_spec.nchannels == 1 ? PHOTOMETRIC_MINISBLACK\n                                           : PHOTOMETRIC_RGB);\n    TIFFGetField(m_tif, TIFFTAG_PHOTOMETRIC, &m_photometric);\n    m_spec.attribute(\"tiff:PhotometricInterpretation\", (int)m_photometric);\n\n    readspec_photometric();\n\n    TIFFGetFieldDefaulted(m_tif, TIFFTAG_PLANARCONFIG, &m_planarconfig);\n    m_separate = (m_planarconfig == PLANARCONFIG_SEPARATE\n                  && m_spec.nchannels > 1\n                  && m_photometric != PHOTOMETRIC_PALETTE);\n    m_spec.attribute(\"tiff:PlanarConfiguration\", (int)m_planarconfig);\n    if (m_planarconfig == PLANARCONFIG_SEPARATE)\n        m_spec.attribute(\"planarconfig\", \"separate\");\n    else\n        m_spec.attribute(\"planarconfig\", \"contig\");\n\n    if (const char* compressname = tiff_compression_name(m_compression))\n        m_spec.attribute(\"compression\", compressname);\n    m_predictor = PREDICTOR_NONE;\n    if (!safe_tiffgetfield(\"Predictor\", TIFFTAG_PREDICTOR, TypeUInt16,\n                           &m_predictor))\n        m_predictor = PREDICTOR_NONE;\n\n    m_rowsperstrip = -1;\n    if (!m_spec.tile_width) {\n        TIFFGetField(m_tif, TIFFTAG_ROWSPERSTRIP, &m_rowsperstrip);\n        if (m_rowsperstrip > 0)\n            m_spec.attribute(\"tiff:RowsPerStrip\", m_rowsperstrip);\n    }\n\n    // The libtiff docs say that only uncompressed images, or those with\n    // rowsperstrip==1, support random access to scanlines.\n    m_no_random_access = (m_compression != COMPRESSION_NONE\n                          && m_rowsperstrip != 1);\n\n    // Do we care about fillorder?  No, the TIFF spec says, \"We\n    // recommend that FillOrder=2 (lsb-to-msb) be used only in\n    // special-purpose applications\".  So OIIO will assume msb-to-lsb\n    // convention until somebody finds a TIFF file in the wild that\n    // breaks this assumption.\n\n    unsigned short* sampleinfo  = NULL;\n    unsigned short extrasamples = 0;\n    TIFFGetField(m_tif, TIFFTAG_EXTRASAMPLES, &extrasamples, &sampleinfo);\n    // std::cerr << \"Extra samples = \" << extrasamples << \"\\n\";\n    bool alpha_is_unassociated = false;  // basic assumption\n    if (extrasamples) {\n        // If the TIFF ExtraSamples tag was specified, use that to figure\n        // out the meaning of alpha.\n        int colorchannels = 3;\n        if (m_photometric == PHOTOMETRIC_MINISWHITE\n            || m_photometric == PHOTOMETRIC_MINISBLACK\n            || m_photometric == PHOTOMETRIC_PALETTE\n            || m_photometric == PHOTOMETRIC_MASK)\n            colorchannels = 1;\n        for (int i = 0, c = colorchannels;\n             i < extrasamples && c < m_inputchannels; ++i, ++c) {\n            // std::cerr << \"   extra \" << i << \" \" << sampleinfo[i] << \"\\n\";\n            if (sampleinfo[i] == EXTRASAMPLE_ASSOCALPHA) {\n                // This is the alpha channel, associated as usual\n                m_spec.alpha_channel = c;\n            } else if (sampleinfo[i] == EXTRASAMPLE_UNASSALPHA) {\n                // This is the alpha channel, but color is unassociated\n                m_spec.alpha_channel  = c;\n                alpha_is_unassociated = true;\n                if (m_keep_unassociated_alpha)\n                    m_spec.attribute(\"oiio:UnassociatedAlpha\", 1);\n            } else {\n                OIIO_DASSERT(sampleinfo[i] == EXTRASAMPLE_UNSPECIFIED);\n                // This extra channel is not alpha at all.  Undo any\n                // assumptions we previously made about this channel.\n                if (m_spec.alpha_channel == c) {\n                    m_spec.channelnames[c] = Strutil::fmt::format(\"channel{}\",\n                                                                  c);\n                    m_spec.alpha_channel   = -1;\n                }\n            }\n        }\n        if (m_photometric == PHOTOMETRIC_SEPARATED)\n            m_spec.alpha_channel = -1;  // ignore alpha in CMYK\n        if (m_spec.alpha_channel >= 0\n            && m_spec.alpha_channel < m_spec.nchannels) {\n            while (m_spec.channelnames.size() < size_t(m_spec.nchannels))\n                m_spec.channelnames.push_back(\n                    Strutil::fmt::format(\"channel{}\", m_spec.nchannels));\n            m_spec.channelnames[m_spec.alpha_channel] = \"A\";\n            // Special case: \"R\",\"A\" should really be named \"Y\",\"A\", since\n            // the first channel is luminance, not red.\n            if (m_spec.nchannels == 2 && m_spec.alpha_channel == 1)\n                m_spec.channelnames[0] = \"Y\";\n        }\n    }\n    if (alpha_is_unassociated)\n        m_spec.attribute(\"tiff:UnassociatedAlpha\", 1);\n    // Will we need to do alpha conversions?\n    m_convert_alpha = (m_spec.alpha_channel >= 0 && alpha_is_unassociated\n                       && !m_keep_unassociated_alpha);\n\n    // N.B. we currently ignore the following TIFF fields:\n    // GrayResponseCurve GrayResponseUnit\n    // MaxSampleValue MinSampleValue\n    // NewSubfileType SubfileType(deprecated)\n    // Colorimetry fields\n\n    // If we've been instructed to skip reading metadata, because it is\n    // assumed to be identical to what we already have in m_spec,\n    // skip everything following.\n    if (!read_meta)\n        return true;\n\n    short resunit = -1;\n    TIFFGetField(m_tif, TIFFTAG_RESOLUTIONUNIT, &resunit);\n    switch (resunit) {\n    case RESUNIT_NONE: m_spec.attribute(\"ResolutionUnit\", \"none\"); break;\n    case RESUNIT_INCH: m_spec.attribute(\"ResolutionUnit\", \"in\"); break;\n    case RESUNIT_CENTIMETER: m_spec.attribute(\"ResolutionUnit\", \"cm\"); break;\n    }\n    float xdensity = m_spec.get_float_attribute(\"XResolution\", 0.0f);\n    float ydensity = m_spec.get_float_attribute(\"YResolution\", 0.0f);\n    if (xdensity && ydensity)\n        m_spec.attribute(\"PixelAspectRatio\", ydensity / xdensity);\n\n    get_matrix_attribute(\"worldtocamera\", TIFFTAG_PIXAR_MATRIX_WORLDTOCAMERA);\n    get_matrix_attribute(\"worldtoscreen\", TIFFTAG_PIXAR_MATRIX_WORLDTOSCREEN);\n    get_int_attribute(\"tiff:subfiletype\", TIFFTAG_SUBFILETYPE);\n    // FIXME -- should subfiletype be \"conventionized\" and used for all\n    // plugins uniformly?\n\n    // Special names for shadow maps\n    char* s = NULL;\n    TIFFGetField(m_tif, TIFFTAG_PIXAR_TEXTUREFORMAT, &s);\n    if (s)\n        m_emulate_mipmap = true;\n    if (s && !strcmp(s, \"Shadow\")) {\n        for (int c = 0; c < m_spec.nchannels; ++c)\n            m_spec.channelnames[c] = \"z\";\n    }\n\n    /// read color profile\n    unsigned int icc_datasize = 0;\n    uint8_t* icc_buf          = NULL;\n    TIFFGetField(m_tif, TIFFTAG_ICCPROFILE, &icc_datasize, &icc_buf);\n    if (icc_datasize && icc_buf) {\n        m_spec.attribute(ICC_PROFILE_ATTR,\n                         TypeDesc(TypeDesc::UINT8, icc_datasize), icc_buf);\n        std::string errormsg;\n        bool ok = decode_icc_profile(cspan<uint8_t>(icc_buf, icc_datasize),\n                                     m_spec, errormsg);\n        if (!ok && OIIO::get_int_attribute(\"imageinput:strict\")) {\n            errorfmt(\"Possible corrupt file, could not decode ICC profile: {}\\n\",\n                     errormsg);\n            return false;\n        }\n    }\n\n    // Search for an EXIF IFD in the TIFF file, and if found, rummage\n    // around for Exif fields.\n    toff_t exifoffset = 0;\n    if (TIFFGetField(m_tif, TIFFTAG_EXIFIFD, &exifoffset)) {\n        if (TIFFReadEXIFDirectory(m_tif, exifoffset)) {\n            for (const auto& tag : tag_table(\"Exif\"))\n                find_tag(tag.tifftag, tag.tifftype, tag.name);\n            // Look for a Makernote\n            auto makerfield = find_field(EXIF_MAKERNOTE, TIFF_UNDEFINED);\n            // std::unique_ptr<uint32_t[]> buf (new uint32_t[]);\n            if (makerfield) {\n                // bool ok = TIFFGetField (m_tif, tag, dest, &ptr);\n                unsigned int mn_datasize = 0;\n                unsigned char* mn_buf    = NULL;\n                TIFFGetField(m_tif, EXIF_MAKERNOTE, &mn_datasize, &mn_buf);\n            }\n            // Exif spec says that anything other than 0xffff==uncalibrated\n            // should be interpreted to be sRGB.\n            if (m_spec.get_int_attribute(\"Exif:ColorSpace\") != 0xffff)\n                m_spec.attribute(\"oiio:ColorSpace\", \"sRGB\");\n            // NOTE: We must set \"oiio:ColorSpace\" explicitly, not call\n            // set_colorspace, or it will erase several other TIFF attribs we\n            // need to preserve.\n        }\n        // TIFFReadEXIFDirectory seems to do something to the internal state\n        // that requires a TIFFSetDirectory to set things straight again.\n        TIFFSetDirectory(m_tif, m_subimage);\n    }\n\n    // Search for IPTC metadata in IIM form -- but older versions of\n    // libtiff botch the size, so ignore it for very old libtiff.\n    int iptcsize         = 0;\n    const char* iptcdata = nullptr;\n    TypeDesc iptctype    = tiffgetfieldtype(TIFFTAG_RICHTIFFIPTC);\n    if (TIFFGetField(m_tif, TIFFTAG_RICHTIFFIPTC, &iptcsize, &iptcdata)\n        && iptcsize > 0) {\n        std::vector<char> iptc;\n        if (iptctype.size() == 4) {\n            // Some TIFF files in the wild inexplicably think their IPTC\n            // data are stored as longs, and we have to undo any byte\n            // swapping that may have occurred.\n            iptcsize *= 4;\n            iptc.assign(iptcdata, iptcdata + iptcsize);\n            if (TIFFIsByteSwapped(m_tif))\n                TIFFSwabArrayOfLong((uint32_t*)&iptc[0], iptcsize / 4);\n        } else {\n            iptc.assign(iptcdata, iptcdata + iptcsize);\n        }\n        decode_iptc_iim(&iptc[0], iptcsize, m_spec);\n    }\n\n    // Search for an XML packet containing XMP (IPTC, Exif, etc.)\n    int xmlsize         = 0;\n    const void* xmldata = NULL;\n    if (TIFFGetField(m_tif, TIFFTAG_XMLPACKET, &xmlsize, &xmldata)) {\n        // std::cerr << \"Found XML data, size \" << xmlsize << \"\\n\";\n        if (xmldata && xmlsize) {\n            std::string xml((const char*)xmldata, xmlsize);\n            decode_xmp(xml, m_spec);\n        }\n    }\n\n#if 0\n    // Experimental -- look for photoshop data\n    int photoshopsize = 0;\n    const void *photoshopdata = NULL;\n    if (TIFFGetField (m_tif, TIFFTAG_PHOTOSHOP, &photoshopsize, &photoshopdata)) {\n        std::cerr << \"Found PHOTOSHOP data, size \" << photoshopsize << \"\\n\";\n        if (photoshopdata && photoshopsize) {\n//            std::string photoshop ((const char *)photoshopdata, photoshopsize);\n//            std::cerr << \"PHOTOSHOP:\\n\" << photoshop << \"\\n---\\n\";\n        }\n    }\n#endif\n\n    // If Software and IPTC:OriginatingProgram are identical, kill the latter\n    if (m_spec.get_string_attribute(\"Software\")\n        == m_spec.get_string_attribute(\"IPTC:OriginatingProgram\"))\n        m_spec.erase_attribute(\"IPTC:OriginatingProgram\");\n\n    std::string desc = m_spec.get_string_attribute(\"ImageDescription\");\n    // If ImageDescription and IPTC:Caption are identical, kill the latter\n    if (desc == m_spec.get_string_attribute(\"IPTC:Caption\"))\n        m_spec.erase_attribute(\"IPTC:Caption\");\n\n    // Because TIFF doesn't support arbitrary metadata, we look for certain\n    // hints in the ImageDescription and turn them into metadata, also\n    // removing them from the ImageDescrption.\n    bool updatedDesc = false;\n    auto cc = Strutil::excise_string_after_head(desc, \"oiio:ConstantColor=\");\n    if (cc.size()) {\n        m_spec.attribute(\"oiio:ConstantColor\", cc);\n        updatedDesc = true;\n    }\n    auto ac = Strutil::excise_string_after_head(desc, \"oiio:AverageColor=\");\n    if (ac.size()) {\n        m_spec.attribute(\"oiio:AverageColor\", ac);\n        updatedDesc = true;\n    }\n    std::string sha = Strutil::excise_string_after_head(desc, \"oiio:SHA-1=\");\n    if (sha.empty())  // back compatibility with OIIO < 1.5\n        sha = Strutil::excise_string_after_head(desc, \"SHA-1=\");\n    if (sha.size()) {\n        m_spec.attribute(\"oiio:SHA-1\", sha);\n        updatedDesc = true;\n    }\n    std::string handed = Strutil::excise_string_after_head(desc,\n                                                           \"oiio:handed=\");\n    if (handed.size() && (handed == \"left\" || handed == \"right\")) {\n        m_spec.attribute(\"handed\", handed);\n        updatedDesc = true;\n    }\n\n    if (updatedDesc) {\n        string_view d(desc);\n        Strutil::skip_whitespace(d);  // erase if it's only whitespace\n        if (d.size())\n            m_spec.attribute(\"ImageDescription\", desc);\n        else\n            m_spec.erase_attribute(\"ImageDescription\");\n    }\n\n    // Squash some problematic texture metadata if we suspect it's wrong\n    pvt::check_texture_metadata_sanity(m_spec);\n\n    if (m_testopenconfig)  // open-with-config debugging\n        m_spec.attribute(\"oiio:DebugOpenConfig!\", 42);\n\n    return true;\n}\n\n\n\nvoid\nTIFFInput::readspec_photometric()\n{\n    switch (m_photometric) {\n    case PHOTOMETRIC_SEPARATED: {\n        // Photometric \"separated\" is \"usually CMYK\".\n        m_spec.channelnames.clear();\n        short inkset       = INKSET_CMYK;\n        short numberofinks = 0;\n        TIFFGetFieldDefaulted(m_tif, TIFFTAG_INKSET, &inkset);\n        TIFFGetFieldDefaulted(m_tif, TIFFTAG_NUMBEROFINKS, &numberofinks);\n        if (inkset == INKSET_CMYK && m_spec.nchannels == 4) {\n            // True CMYK\n            m_spec.attribute(\"tiff:ColorSpace\", \"CMYK\");\n            if (m_raw_color) {\n                m_spec.channelnames.resize(4);\n                m_spec.channelnames[0] = \"C\";\n                m_spec.channelnames[1] = \"M\";\n                m_spec.channelnames[2] = \"Y\";\n                m_spec.channelnames[3] = \"K\";\n                m_spec.attribute(\"oiio:ColorSpace\", \"CMYK\");\n            } else {\n                // Silently convert to RGB\n                m_spec.nchannels = 3;\n                m_spec.default_channel_names();\n            }\n        } else {\n            // Non-CMYK ink set\n            m_spec.attribute(\"tiff:ColorSpace\", \"color separated\");\n            m_spec.attribute(\"oiio:ColorSpace\", \"color separated\");\n            m_raw_color = true;  // Conversion to RGB doesn't make sense\n            const char* inknames = NULL;\n            if (safe_tiffgetfield(\"tiff:InkNames\", TIFFTAG_INKNAMES,\n                                  TypeUnknown, &inknames)\n                && inknames && inknames[0] && numberofinks) {\n                m_spec.channelnames.clear();\n                // Decode the ink names, which are all concatenated together.\n                for (int i = 0; i < int(numberofinks); ++i) {\n                    string_view ink(inknames);\n                    if (ink.size()) {\n                        m_spec.channelnames.emplace_back(ink);\n                        inknames += ink.size() + 1;\n                    } else {\n                        // Run out of road\n                        numberofinks = i;\n                    }\n                }\n            } else {\n                numberofinks = 0;\n            }\n            // No ink names. Make it up.\n            for (int i = numberofinks; i < m_spec.nchannels; ++i)\n                m_spec.channelnames.emplace_back(\n                    Strutil::fmt::format(\"ink{}\", i));\n        }\n        break;\n    }\n    case PHOTOMETRIC_YCBCR: m_spec.attribute(\"tiff:ColorSpace\", \"YCbCr\"); break;\n    case PHOTOMETRIC_CIELAB:\n        m_spec.attribute(\"tiff:ColorSpace\", \"CIELAB\");\n        break;\n    case PHOTOMETRIC_ICCLAB:\n        m_spec.attribute(\"tiff:ColorSpace\", \"ICCLAB\");\n        break;\n    case PHOTOMETRIC_ITULAB:\n        m_spec.attribute(\"tiff:ColorSpace\", \"ITULAB\");\n        break;\n    case PHOTOMETRIC_LOGL: m_spec.attribute(\"tiff:ColorSpace\", \"LOGL\"); break;\n    case PHOTOMETRIC_LOGLUV:\n        m_spec.attribute(\"tiff:ColorSpace\", \"LOGLUV\");\n        break;\n    case PHOTOMETRIC_PALETTE: {\n        m_spec.attribute(\"tiff:ColorSpace\", \"palette\");\n        // Read the color map\n        unsigned short *r = NULL, *g = NULL, *b = NULL;\n        TIFFGetField(m_tif, TIFFTAG_COLORMAP, &r, &g, &b);\n        OIIO_ASSERT(r != NULL && g != NULL && b != NULL);\n        m_colormap.clear();\n        m_colormap.reserve(3 * (1 << m_bitspersample));\n        m_colormap.insert(m_colormap.end(), r, r + (1 << m_bitspersample));\n        m_colormap.insert(m_colormap.end(), g, g + (1 << m_bitspersample));\n        m_colormap.insert(m_colormap.end(), b, b + (1 << m_bitspersample));\n        // Palette TIFF images are always 3 channels, uint8 (to the client)\n        m_spec.nchannels = 3;\n        m_spec.set_format(TypeUInt8);\n        m_spec.default_channel_names();\n        if (m_bitspersample < m_spec.format.size() * 8) {\n            // For palette images with unusual bits per sample, set\n            // oiio:BitsPerSample to the \"full\" version, to avoid problems\n            // when copying the file back to a TIFF file (we don't write\n            // palette images), but do leave \"tiff:BitsPerSample\" to reflect\n            // the original file.\n            m_spec.attribute(\"tiff:BitsPerSample\", (int)m_bitspersample);\n            m_spec.attribute(\"oiio:BitsPerSample\",\n                             (int)m_spec.format.size() * 8);\n        }\n        // FIXME - what about palette + extra (alpha?) channels?  Is that\n        // allowed?  And if so, ever encountered in the wild?\n        break;\n    }\n    }\n\n    // For some PhotometricInterpretation modes that are both rare and hairy\n    // to handle, we use libtiff's TIFFRGBA interface and have it give us 8\n    // bit RGB values.\n    bool is_jpeg         = (m_compression == COMPRESSION_JPEG\n                    || m_compression == COMPRESSION_OJPEG);\n    bool is_nonspectral  = (m_photometric == PHOTOMETRIC_YCBCR\n                           || m_photometric == PHOTOMETRIC_CIELAB\n                           || m_photometric == PHOTOMETRIC_ICCLAB\n                           || m_photometric == PHOTOMETRIC_ITULAB\n                           || m_photometric == PHOTOMETRIC_LOGL\n                           || m_photometric == PHOTOMETRIC_LOGLUV);\n    m_use_rgba_interface = false;\n    m_rgbadata.clear();\n    if ((is_jpeg && m_spec.nchannels != 3)\n        || (is_nonspectral && !m_raw_color)) {\n        m_use_rgba_interface = true;\n        // This falls back to looking like uint8 images\n        m_spec.format = TypeDesc::UINT8;\n        m_spec.channelformats.clear();\n        m_photometric = PHOTOMETRIC_RGB;\n    }\n\n    // If we're not using the RGBA interface, but we have one of these\n    // non-spectral color spaces, set the OIIO color space attribute to\n    // the tiff:colorspace value.\n    if (is_nonspectral && !m_use_rgba_interface) {\n        m_spec.attribute(\"oiio:ColorSpace\",\n                         m_spec.get_string_attribute(\"tiff:ColorSpace\"));\n    }\n}\n\n\n\nbool\nTIFFInput::close()\n{\n    close_tif();\n    init();  // Reset to initial state\n    return true;\n}\n\n\n\n/// Helper: Convert n pixels from separate (RRRGGGBBB) to contiguous\n/// (RGBRGBRGB) planarconfig.\nvoid\nTIFFInput::separate_to_contig(int nplanes, int nvals,\n                              const unsigned char* separate,\n                              unsigned char* contig)\n{\n    int channelbytes = m_spec.channel_bytes();\n    for (int p = 0; p < nvals; ++p)                 // loop over pixels\n        for (int c = 0; c < nplanes; ++c)           // loop over channels\n            for (int i = 0; i < channelbytes; ++i)  // loop over data bytes\n                contig[(p * nplanes + c) * channelbytes + i]\n                    = separate[(c * nvals + p) * channelbytes + i];\n}\n\n\n\n// palette_to_rgb for <= 8 bit palette addressing\nvoid\nTIFFInput::palette_to_rgb(int n, const unsigned char* palettepels,\n                          unsigned char* rgb)\n{\n    size_t vals_per_byte = 8 / m_bitspersample;\n    size_t entries       = 1 << m_bitspersample;\n    int highest          = entries - 1;\n    OIIO_DASSERT(m_spec.nchannels == 3);\n    OIIO_DASSERT(m_colormap.size() == 3 * entries);\n    for (int x = 0; x < n; ++x) {\n        int i = palettepels[x / vals_per_byte];\n        i >>= (m_bitspersample * (vals_per_byte - 1 - (x % vals_per_byte)));\n        i &= highest;\n        *rgb++ = m_colormap[0 * entries + i] / 257;\n        *rgb++ = m_colormap[1 * entries + i] / 257;\n        *rgb++ = m_colormap[2 * entries + i] / 257;\n    }\n}\n\n\n\n// palette_to_rgb, for 16 bit palette addressing\nvoid\nTIFFInput::palette_to_rgb(int n, const uint16_t* palettepels,\n                          unsigned char* rgb)\n{\n    size_t entries = 1 << m_bitspersample;\n    OIIO_DASSERT(m_spec.nchannels == 3);\n    OIIO_DASSERT(m_colormap.size() == 3 * entries);\n    for (int x = 0; x < n; ++x) {\n        int i  = palettepels[x];\n        *rgb++ = m_colormap[0 * entries + i] / 257;\n        *rgb++ = m_colormap[1 * entries + i] / 257;\n        *rgb++ = m_colormap[2 * entries + i] / 257;\n    }\n}\n\n\n\nvoid\nTIFFInput::bit_convert(int n, const unsigned char* in, int inbits, void* out,\n                       int outbits)\n{\n    OIIO_DASSERT(inbits >= 1 && inbits < 32);  // surely bugs if not\n    uint32_t highest = (1 << inbits) - 1;\n    int B = 0, b = 0;\n    // Invariant:\n    // So far, we have used in[0..B-1] and the high b bits of in[B].\n    for (int i = 0; i < n; ++i) {\n        long long val = 0;\n        int valbits   = 0;  // bits so far we've accumulated in val\n        while (valbits < inbits) {\n            // Invariant: we have already accumulated valbits of the next\n            // needed value (of a total of inbits), living in the valbits\n            // low bits of val.\n            int out_left = inbits - valbits;  // How much more we still need\n            int in_left  = 8 - b;             // Bits still available in in[B].\n            if (in_left <= out_left) {\n                // Eat the rest of this byte:\n                //   |---------|--------|\n                //        b      in_left\n                val <<= in_left;\n                val |= in[B] & ~(0xffffffff << in_left);\n                ++B;\n                b = 0;\n                valbits += in_left;\n            } else {\n                // Eat just the bits we need:\n                //   |--|---------|-----|\n                //     b  out_left  extra\n                val <<= out_left;\n                int extra = 8 - b - out_left;\n                val |= (in[B] >> extra) & ~(0xffffffff << out_left);\n                b += out_left;\n                valbits = inbits;\n            }\n        }\n        if (outbits == 8)\n            ((unsigned char*)out)[i] = (unsigned char)((val * 0xff) / highest);\n        else if (outbits == 16)\n            ((unsigned short*)out)[i] = (unsigned short)((val * 0xffff)\n                                                         / highest);\n        else\n            ((unsigned int*)out)[i] = (unsigned int)((val * 0xffffffff)\n                                                     / highest);\n    }\n}\n\n\n\nvoid\nTIFFInput::invert_photometric(int n, void* data)\n{\n    switch (m_spec.format.basetype) {\n    case TypeDesc::UINT8: {\n        unsigned char* d = (unsigned char*)data;\n        for (int i = 0; i < n; ++i)\n            d[i] = 255 - d[i];\n        break;\n    }\n    default: break;\n    }\n}\n\n\n\ntemplate<typename T>\nstatic void\ncmyk_to_rgb(int n, const T* cmyk, size_t cmyk_stride, T* rgb, size_t rgb_stride)\n{\n    for (; n; --n, cmyk += cmyk_stride, rgb += rgb_stride) {\n        float C = convert_type<T, float>(cmyk[0]);\n        float M = convert_type<T, float>(cmyk[1]);\n        float Y = convert_type<T, float>(cmyk[2]);\n        float K = convert_type<T, float>(cmyk[3]);\n        float R = (1.0f - C) * (1.0f - K);\n        float G = (1.0f - M) * (1.0f - K);\n        float B = (1.0f - Y) * (1.0f - K);\n        rgb[0]  = convert_type<float, T>(R);\n        rgb[1]  = convert_type<float, T>(G);\n        rgb[2]  = convert_type<float, T>(B);\n    }\n}\n\n\n\nbool\nTIFFInput::read_native_scanline(int subimage, int miplevel, int y, int /*z*/,\n                                void* data)\n{\n    lock_guard lock(*this);\n    if (!seek_subimage(subimage, miplevel))\n        return false;\n    y -= m_spec.y;\n\n    if (m_use_rgba_interface) {\n        // We punted and used the RGBA image interface -- copy from buffer.\n        // libtiff has no way to read just one scanline as RGBA. So we\n        // buffer the whole image.\n        if (!m_rgbadata.size()) {  // first time through: allocate & read\n            m_rgbadata.resize(m_spec.image_pixels());\n            bool ok = TIFFReadRGBAImageOriented(m_tif, m_spec.width,\n                                                m_spec.height,\n                                                m_rgbadata.data(),\n                                                ORIENTATION_TOPLEFT, 0);\n            if (!ok) {\n                std::string err = oiio_tiff_last_error();\n                errorfmt(\"Unknown error trying to read TIFF as RGBA ({})\",\n                         err.size() ? err.c_str() : \"unknown error\");\n                return false;\n            }\n        }\n        copy_image(m_spec.nchannels, m_spec.width, 1, 1,\n                   &m_rgbadata[y * size_t(m_spec.width)], m_spec.nchannels, 4,\n                   4 * m_spec.width, AutoStride, data, m_spec.nchannels,\n                   m_spec.width * m_spec.nchannels, AutoStride);\n        return true;\n    }\n\n    // Make sure there's enough scratch space\n    int nvals = m_spec.width * m_inputchannels;\n    if (m_photometric == PHOTOMETRIC_PALETTE && m_bitspersample > 8)\n        m_scratch.resize(nvals * 2);  // special case for 16 bit palette\n    else\n        m_scratch.resize(nvals * m_spec.format.size());\n\n    // How many color planes to read\n    int planes = m_separate ? m_inputchannels : 1;\n\n    // For compression modes that don't support random access to scanlines\n    // (which I *think* is only LZW), we need to emulate random access by\n    // re-seeking.\n    if (m_no_random_access && m_next_scanline != y) {\n        if (m_next_scanline > y) {\n            // User is trying to read an earlier scanline than the one we're\n            // up to.  Easy fix: start over.\n            // FIXME: I'm too tired to look into it now, but I wonder if\n            // it is able to randomly seek to the first line in any\n            // \"strip\", in which case we don't need to start from 0, just\n            // start from the beginning of the strip we need.\n            ImageSpec dummyspec;\n            int old_subimage = current_subimage();\n            int old_miplevel = current_miplevel();\n            // We need to close the TIFF file s that we can re-open and\n            // seek back to the beginning of this subimage. The close_tif()\n            // accomplishes that. It's important not to do a full close()\n            // here, because that would also call init() to fully reset\n            // to a fresh ImageInput, thus forgetting any configuration\n            // settings such as raw_color or keep_unassociated_alpha.\n            close_tif();\n            if (!open(m_filename, dummyspec)\n                || !seek_subimage(old_subimage, old_miplevel)) {\n                return false;  // Somehow, the re-open failed\n            }\n            OIIO_DASSERT(m_next_scanline == 0\n                         && current_subimage() == old_subimage\n                         && current_miplevel() == old_miplevel);\n        }\n        while (m_next_scanline < y) {\n            // Keep reading until we're read the scanline we really need\n            for (int c = 0; c < planes; ++c) { /* planes==1 for contig */\n                if (TIFFReadScanline(m_tif, &m_scratch[0], m_next_scanline, c)\n                    < 0) {\n#if OIIO_TIFFLIB_VERSION < 40500\n                    errorfmt(\"{}\", oiio_tiff_last_error());\n#endif\n                    return false;\n                }\n            }\n            ++m_next_scanline;\n        }\n    }\n    m_next_scanline = y + 1;\n\n    bool need_bit_convert = (m_bitspersample != 8 && m_bitspersample != 16\n                             && m_bitspersample != 32);\n    if (m_photometric == PHOTOMETRIC_PALETTE) {\n        // Convert from palette to RGB\n        if (TIFFReadScanline(m_tif, &m_scratch[0], y) < 0) {\n#if OIIO_TIFFLIB_VERSION < 40500\n            errorfmt(\"{}\", oiio_tiff_last_error());\n#endif\n            return false;\n        }\n        if (m_bitspersample <= 8)\n            palette_to_rgb(m_spec.width, &m_scratch[0], (unsigned char*)data);\n        else if (m_bitspersample == 16)\n            palette_to_rgb(m_spec.width, (uint16_t*)&m_scratch[0],\n                           (unsigned char*)data);\n        return true;\n    }\n    // Not palette...\n\n    size_t plane_bytes = m_spec.width * m_spec.format.size();\n    size_t input_bytes = plane_bytes * m_inputchannels;\n    // Where to read?  Directly into user data if no channel shuffling, bit\n    // shifting, or CMYK conversion is needed, otherwise into scratch space.\n    unsigned char* readbuf = (unsigned char*)data;\n    if (need_bit_convert || m_separate\n        || (m_photometric == PHOTOMETRIC_SEPARATED && !m_raw_color))\n        readbuf = &m_scratch[0];\n    // Perform the reads.  Note that for contig, planes==1, so it will\n    // only do one TIFFReadScanline.\n    for (int c = 0; c < planes; ++c) { /* planes==1 for contig */\n        if (TIFFReadScanline(m_tif, &readbuf[plane_bytes * c], y, c) < 0) {\n#if OIIO_TIFFLIB_VERSION < 40500\n            errorfmt(\"{}\", oiio_tiff_last_error());\n#endif\n            return false;\n        }\n    }\n\n    // Handle less-than-full bit depths\n    if (m_bitspersample < 8) {\n        // m_scratch now holds nvals n-bit values, contig or separate\n        m_scratch2.resize(input_bytes);\n        m_scratch.swap(m_scratch2);\n        for (int c = 0; c < planes; ++c) /* planes==1 for contig */\n            bit_convert(m_separate ? m_spec.width : nvals,\n                        &m_scratch2[plane_bytes * c], m_bitspersample,\n                        m_separate ? &m_scratch[plane_bytes * c]\n                                   : (unsigned char*)data + plane_bytes * c,\n                        8);\n    } else if (m_bitspersample > 8 && m_bitspersample < 16) {\n        // m_scratch now holds nvals n-bit values, contig or separate\n        m_scratch2.resize(input_bytes);\n        m_scratch.swap(m_scratch2);\n        for (int c = 0; c < planes; ++c) /* planes==1 for contig */\n            bit_convert(m_separate ? m_spec.width : nvals,\n                        &m_scratch2[plane_bytes * c], m_bitspersample,\n                        m_separate ? &m_scratch[plane_bytes * c]\n                                   : (unsigned char*)data + plane_bytes * c,\n                        16);\n    } else if (m_bitspersample > 16 && m_bitspersample < 32) {\n        // m_scratch now holds nvals n-bit values, contig or separate\n        m_scratch2.resize(input_bytes);\n        m_scratch.swap(m_scratch2);\n        for (int c = 0; c < planes; ++c) /* planes==1 for contig */\n            bit_convert(m_separate ? m_spec.width : nvals,\n                        &m_scratch2[plane_bytes * c], m_bitspersample,\n                        m_separate ? &m_scratch[plane_bytes * c]\n                                   : (unsigned char*)data + plane_bytes * c,\n                        32);\n    }\n\n    // Handle \"separate\" planarconfig\n    if (m_separate) {\n        // Convert from separate (RRRGGGBBB) to contiguous (RGBRGBRGB).\n        // We know the data is in m_scratch at this point, so\n        // contiguize it into the user data area.\n        if (m_photometric == PHOTOMETRIC_SEPARATED && !m_raw_color) {\n            // CMYK->RGB means we need temp storage.\n            m_scratch2.resize(input_bytes);\n            separate_to_contig(planes, m_spec.width, &m_scratch[0],\n                               &m_scratch2[0]);\n            m_scratch.swap(m_scratch2);\n        } else {\n            // If no CMYK->RGB conversion is necessary, we can \"separate\"\n            // straight into the data area.\n            separate_to_contig(planes, m_spec.width, &m_scratch[0],\n                               (unsigned char*)data);\n        }\n    }\n\n    // Handle CMYK\n    if (m_photometric == PHOTOMETRIC_SEPARATED && !m_raw_color) {\n        // The CMYK will be in m_scratch.\n        if (spec().format == TypeDesc::UINT8) {\n            cmyk_to_rgb(m_spec.width, (unsigned char*)&m_scratch[0],\n                        m_inputchannels, (unsigned char*)data,\n                        m_spec.nchannels);\n        } else if (spec().format == TypeDesc::UINT16) {\n            cmyk_to_rgb(m_spec.width, (unsigned short*)&m_scratch[0],\n                        m_inputchannels, (unsigned short*)data,\n                        m_spec.nchannels);\n        } else {\n            errorfmt(\"CMYK only supported for UINT8, UINT16\");\n            return false;\n        }\n    }\n\n    if (m_photometric == PHOTOMETRIC_MINISWHITE)\n        invert_photometric(nvals, data);\n\n    return true;\n}\n\n\n\nbool\nTIFFInput::read_native_scanlines(int subimage, int miplevel, int ybegin,\n                                 int yend, int z, void* data)\n{\n    // If the stars all align properly, try to read strips, and use the\n    // thread pool to parallelize the decompression. This can give a large\n    // speedup (5x or more!) because the zip decompression dwarfs the\n    // actual raw I/O. But libtiff is totally serialized, so we can only\n    // parallelize by reading raw (compressed) strips then making calls to\n    // zlib ourselves to decompress. Don't bother trying to handle any of\n    // the uncommon cases with strips. This covers most real-world cases.\n    lock_guard lock(*this);\n    if (!seek_subimage(subimage, miplevel))\n        return false;\n    yend        = std::min(yend, spec().y + spec().height);\n    int nstrips = (yend - ybegin + m_rowsperstrip - 1) / m_rowsperstrip;\n\n    // See if it's easy to read this scanline range as strips. For edge\n    // cases we don't with to deal with here, we just call the base class\n    // read_native_scanlines, which in turn will loop over each scanline in\n    // the range to call our read_native_scanline, which does handle the\n    // full range of cases.\n    bool read_as_strips =\n        // we're reading more than one scanline\n        (yend - ybegin) > 1  // no advantage to strips for single scanlines\n        // scanline range must be complete strips\n        && is_strip_boundary(ybegin)\n        && is_strip_boundary(yend)\n        // and not palette or cmyk color separated conversions\n        && (m_photometric != PHOTOMETRIC_SEPARATED\n            && m_photometric != PHOTOMETRIC_PALETTE)\n        // no non-multiple-of-8 bits per sample\n        && (spec().format.size() * 8 == m_bitspersample)\n        // No other unusual cases\n        && !m_use_rgba_interface;\n    if (!read_as_strips) {\n        // Punt and call the base class, which loops over scanlines.\n        return ImageInput::read_native_scanlines(subimage, miplevel, ybegin,\n                                                 yend, z, data);\n    }\n\n    // Are we reading raw (compressed) strips and doing the decompression\n    // ourselves?\n    bool read_raw_strips =\n        // only deflate/zip compression\n        (m_compression\n         == COMPRESSION_ADOBE_DEFLATE /*|| m_compression == COMPRESSION_NONE*/)\n        // only horizontal predictor (or none)\n        && (m_predictor == PREDICTOR_HORIZONTAL\n            || m_predictor == PREDICTOR_NONE)\n        // contig planarconfig only (for now?)\n        && !m_separate\n        // only uint8, uint16\n        && (m_spec.format == TypeUInt8 || m_spec.format == TypeUInt16);\n\n    // We know we wish to read as strips. But additionally, there are some\n    // circumstances in which we want to read RAW strips, and do the\n    // decompression ourselves, which we can feed to the thread pool to\n    // perform in parallel.\n    thread_pool* pool = default_thread_pool();\n    bool parallelize =\n        // and more than one, or no point parallelizing\n        nstrips > 1\n        // only if we are reading scanlines in order\n        && ybegin == (m_next_scanline + m_spec.y)\n        // only if we're threading and don't enter the thread pool recursively!\n        && pool->size() > 1\n        && !pool->is_worker()\n        // and not if the feature is turned off\n        && m_spec.get_int_attribute(\"tiff:multithread\",\n                                    OIIO::get_int_attribute(\"tiff:multithread\"));\n\n    // Make room for, and read the raw (still compressed) strips. As each\n    // one is read, kick off the decompress and any other extras, to execute\n    // in parallel.\n    task_set tasks(pool);\n    bool ok        = true;  // failed compression will stash a false here\n    int y          = ybegin;\n    size_t ystride = m_spec.scanline_bytes(true);\n    int stripchans = m_separate ? 1 : m_spec.nchannels;  // chans in each strip\n    int planes     = m_separate ? m_spec.nchannels : 1;  // color planes\n        // N.B. \"separate\" planarconfig stores only one channel in a strip\n    int stripvals = m_spec.width * stripchans\n                    * m_rowsperstrip;  // values in a strip\n    imagesize_t strip_bytes = stripvals * m_spec.format.size();\n    size_t cbound           = compressBound((uLong)strip_bytes);\n    std::unique_ptr<char[]> compressed_scratch;\n    std::unique_ptr<char[]> separate_tmp(\n        m_separate ? new char[strip_bytes * nstrips * planes] : nullptr);\n\n    if (read_raw_strips) {\n        // Make room for, and read the raw (still compressed) strips. As each\n        // one is read, kick off the decompress and any other extras, to execute\n        // in parallel.\n        compressed_scratch.reset(new char[cbound * nstrips * planes]);\n        for (size_t stripidx = 0; y + m_rowsperstrip <= yend;\n             y += m_rowsperstrip, ++stripidx) {\n            char* cbuf        = compressed_scratch.get() + stripidx * cbound;\n            tstrip_t stripnum = (y - m_spec.y) / m_rowsperstrip;\n            tsize_t csize     = TIFFReadRawStrip(m_tif, stripnum, cbuf,\n                                                 tmsize_t(cbound));\n            if (csize < 0) {\n                std::string err = oiio_tiff_last_error();\n                errorfmt(\"TIFFRead{}Strip failed reading line y={},z={}: {}\",\n                         read_raw_strips ? \"Raw\" : \"Encoded\", y, z,\n                         err.size() ? err.c_str() : \"unknown error\");\n                ok = false;\n            }\n            auto out            = this;\n            auto uncompress_etc = [=, &ok](int /*id*/) {\n                out->uncompress_one_strip(cbuf, (unsigned long)csize, data,\n                                          strip_bytes, out->m_spec.nchannels,\n                                          out->m_spec.width,\n                                          out->m_rowsperstrip, &ok);\n                if (out->m_photometric == PHOTOMETRIC_MINISWHITE)\n                    out->invert_photometric(stripvals * stripchans, data);\n            };\n            if (parallelize) {\n                // Push the rest of the work onto the thread pool queue\n                tasks.push(pool->push(uncompress_etc));\n            } else {\n                uncompress_etc(0);\n            }\n            data = (char*)data + strip_bytes * planes;\n        }\n\n    } else {\n        // One of the cases where we don't bother reading raw, we read\n        // encoded strips. Still can be a lot more efficient than reading\n        // individual scanlines. This is the clause that has to handle\n        // \"separate\" planarconfig.\n        int strips_in_file = (m_spec.height + m_rowsperstrip - 1)\n                             / m_rowsperstrip;\n        for (size_t stripidx = 0; y < yend; y += m_rowsperstrip, ++stripidx) {\n            int myrps       = std::min(yend - y, m_rowsperstrip);\n            int strip_endy  = std::min(y + m_rowsperstrip, yend);\n            int mystripvals = m_spec.width * stripchans * (strip_endy - y);\n            imagesize_t mystrip_bytes = mystripvals * m_spec.format.size();\n            for (int c = 0; c < planes; ++c) {\n                tstrip_t stripnum = ((y - m_spec.y) / m_rowsperstrip)\n                                    + c * strips_in_file;\n                tsize_t csize = TIFFReadEncodedStrip(m_tif, stripnum,\n                                                     (char*)data\n                                                         + c * mystrip_bytes,\n                                                     tmsize_t(mystrip_bytes));\n                if (csize < 0) {\n                    std::string err = oiio_tiff_last_error();\n                    errorfmt(\n                        \"TIFFReadEncodedStrip failed reading line y={},z={}: {}\",\n                        y, z, err.size() ? err.c_str() : \"unknown error\");\n                    ok = false;\n                }\n            }\n            if (m_photometric == PHOTOMETRIC_MINISWHITE)\n                invert_photometric(mystripvals * planes, data);\n            if (m_separate) {\n                // handle \"separate\" planarconfig: copy to temp area, then\n                // separate_to_contig it back.\n                char* sepbuf = separate_tmp.get()\n                               + stripidx * mystrip_bytes * planes;\n                memcpy(sepbuf, data, mystrip_bytes * planes);\n                separate_to_contig(planes, m_spec.width * myrps,\n                                   (unsigned char*)sepbuf,\n                                   (unsigned char*)data);\n            }\n            data = (char*)data + mystrip_bytes * planes;\n        }\n    }\n\n    // If we have left over scanlines, read them serially\n    m_next_scanline = y - m_spec.y;\n    for (; y < yend; ++y) {\n        bool ok = read_native_scanline(subimage, miplevel, y, z, data);\n        if (!ok)\n            return false;\n        data = (char*)data + ystride;\n    }\n    tasks.wait();\n    return true;\n}\n\n\n\nbool\nTIFFInput::read_native_tile(int subimage, int miplevel, int x, int y, int z,\n                            void* data)\n{\n    lock_guard lock(*this);\n    if (!seek_subimage(subimage, miplevel))\n        return false;\n    x -= m_spec.x;\n    y -= m_spec.y;\n\n    if (m_use_rgba_interface) {\n        // We punted and used the RGBA image interface\n        // libtiff has a call to read just one tile as RGBA. So that's all\n        // we need to do, not buffer the whole image.\n        m_rgbadata.resize(m_spec.tile_pixels());\n        bool ok = TIFFReadRGBATile(m_tif, x, y, m_rgbadata.data());\n        if (!ok) {\n            std::string err = oiio_tiff_last_error();\n            errorfmt(\"Unknown error trying to read TIFF as RGBA ({})\",\n                     err.size() ? err.c_str() : \"unknown error\");\n            return false;\n        }\n        // Copy, and use stride magic to reverse top-to-bottom, because\n        // TIFFReadRGBATile always returns data in bottom-to-top order.\n        int tw = std::min(m_spec.tile_width, m_spec.width - x);\n        int th = std::min(m_spec.tile_height, m_spec.height - y);\n\n        // When the vertical read size is smaller that the tile size\n        // the actual data is in the bottom end of the tile\n        // so copy_image should start from tile_height - read_height.\n        // (Again, because TIFFReadRGBATile reverses the scanline order.)\n        int vert_offset = m_spec.tile_height - th;\n\n        copy_image(m_spec.nchannels, tw, th, 1,\n                   &m_rgbadata[vert_offset * m_spec.tile_width\n                               + (th - 1) * m_spec.tile_width],\n                   m_spec.nchannels, 4, -m_spec.tile_width * 4, AutoStride,\n                   data, m_spec.nchannels,\n                   m_spec.nchannels * imagesize_t(m_spec.tile_width),\n                   AutoStride);\n        return true;\n    }\n\n    imagesize_t tile_pixels = m_spec.tile_pixels();\n    imagesize_t nvals       = tile_pixels * m_inputchannels;\n    if (m_photometric == PHOTOMETRIC_PALETTE && m_bitspersample > 8)\n        m_scratch.resize(nvals * 2);  // special case for 16 bit palette\n    else\n        m_scratch.resize(nvals * m_spec.format.size());\n    bool no_bit_convert = (m_bitspersample == 8 || m_bitspersample == 16\n                           || m_bitspersample == 32);\n    if (m_photometric == PHOTOMETRIC_PALETTE) {\n        // Convert from palette to RGB\n        if (TIFFReadTile(m_tif, &m_scratch[0], x, y, z, 0) < 0) {\n#if OIIO_TIFFLIB_VERSION < 40500\n            errorfmt(\"{}\", oiio_tiff_last_error());\n#endif\n            return false;\n        }\n        if (m_bitspersample <= 8)\n            palette_to_rgb(tile_pixels, &m_scratch[0], (unsigned char*)data);\n        else if (m_bitspersample == 16)\n            palette_to_rgb(tile_pixels, (uint16_t*)&m_scratch[0],\n                           (unsigned char*)data);\n    } else {\n        // Not palette\n        imagesize_t plane_bytes = m_spec.tile_pixels() * m_spec.format.size();\n        int planes              = m_separate ? m_inputchannels : 1;\n        std::vector<unsigned char> scratch2(m_separate ? m_spec.tile_bytes()\n                                                       : 0);\n        // Where to read?  Directly into user data if no channel shuffling\n        // or bit shifting is needed, otherwise into scratch space.\n        unsigned char* readbuf = (no_bit_convert && !m_separate)\n                                     ? (unsigned char*)data\n                                     : &m_scratch[0];\n        // Perform the reads.  Note that for contig, planes==1, so it will\n        // only do one TIFFReadTile.\n        for (int c = 0; c < planes; ++c) /* planes==1 for contig */\n            if (TIFFReadTile(m_tif, &readbuf[plane_bytes * c], x, y, z, c)\n                < 0) {\n#if OIIO_TIFFLIB_VERSION < 40500\n                errorfmt(\"{}\", oiio_tiff_last_error());\n#endif\n                return false;\n            }\n        if (m_bitspersample < 8) {\n            // m_scratch now holds nvals n-bit values, contig or separate\n            std::swap(m_scratch, scratch2);\n            for (int c = 0; c < planes; ++c) /* planes==1 for contig */\n                bit_convert(m_separate ? tile_pixels : nvals,\n                            &scratch2[plane_bytes * c], m_bitspersample,\n                            m_separate ? &m_scratch[plane_bytes * c]\n                                       : (unsigned char*)data + plane_bytes * c,\n                            8);\n        } else if (m_bitspersample > 8 && m_bitspersample < 16) {\n            // m_scratch now holds nvals n-bit values, contig or separate\n            std::swap(m_scratch, scratch2);\n            for (int c = 0; c < planes; ++c) /* planes==1 for contig */\n                bit_convert(m_separate ? tile_pixels : nvals,\n                            &scratch2[plane_bytes * c], m_bitspersample,\n                            m_separate ? &m_scratch[plane_bytes * c]\n                                       : (unsigned char*)data + plane_bytes * c,\n                            16);\n        }\n        if (m_separate) {\n            // Convert from separate (RRRGGGBBB) to contiguous (RGBRGBRGB).\n            // We know the data is in m_scratch at this point, so\n            // contiguize it into the user data area.\n            separate_to_contig(planes, tile_pixels, &m_scratch[0],\n                               (unsigned char*)data);\n        }\n    }\n\n    if (m_photometric == PHOTOMETRIC_MINISWHITE)\n        invert_photometric(nvals, data);\n\n    return true;\n}\n\n\n\nbool\nTIFFInput::read_native_tiles(int subimage, int miplevel, int xbegin, int xend,\n                             int ybegin, int yend, int zbegin, int zend,\n                             void* data)\n{\n    lock_guard lock(*this);\n    if (!seek_subimage(subimage, miplevel))\n        return false;\n    if (!m_spec.valid_tile_range(xbegin, xend, ybegin, yend, zbegin, zend))\n        return false;\n\n    // If the stars all align properly, use the thread pool to parallelize\n    // the decompression. This can give a large speedup (5x or more!)\n    // because the zip decompression dwarfs the actual raw I/O. But libtiff\n    // is totally serialized, so we can only parallelize by making calls to\n    // zlib ourselves and then writing \"raw\" (compressed) strips. Don't\n    // bother trying to handle any of the uncommon cases with strips. This\n    // covers most real-world cases.\n    thread_pool* pool = default_thread_pool();\n    OIIO_DASSERT(m_spec.tile_depth >= 1);\n    size_t ntiles = size_t(\n        (xend - xbegin + m_spec.tile_width - 1) / m_spec.tile_width\n        * (yend - ybegin + m_spec.tile_height - 1) / m_spec.tile_height\n        * (zend - zbegin + m_spec.tile_depth - 1) / m_spec.tile_depth);\n    bool parallelize =\n        // more than one tile, or no point parallelizing\n        ntiles > 1\n        // and not palette or cmyk color separated conversions\n        && (m_photometric != PHOTOMETRIC_SEPARATED\n            && m_photometric != PHOTOMETRIC_PALETTE)\n        // no non-multiple-of-8 bits per sample\n        && (spec().format.size() * 8 == m_bitspersample)\n        // contig planarconfig only (for now?)\n        && !m_separate\n        // only deflate/zip compression with horizontal predictor\n        && m_compression == COMPRESSION_ADOBE_DEFLATE\n        && m_predictor == PREDICTOR_HORIZONTAL\n        // only uint8, uint16\n        && (m_spec.format == TypeUInt8 || m_spec.format == TypeUInt16)\n        // No other unusual cases\n        && !m_use_rgba_interface\n        // only if we're threading and don't enter the thread pool recursively!\n        && pool->size() > 1\n        && !pool->is_worker()\n        // only if this ImageInput wasn't asked to be single-threaded\n        && this->threads() != 1\n        // and not if the feature is turned off\n        && m_spec.get_int_attribute(\"tiff:multithread\",\n                                    OIIO::get_int_attribute(\"tiff:multithread\"));\n\n    // If we're not parallelizing, just call the parent class default\n    // implementation of read_native_tiles, which will loop over the tiles\n    // and read each one individually.\n    if (!parallelize) {\n        return ImageInput::read_native_tiles(subimage, miplevel, xbegin, xend,\n                                             ybegin, yend, zbegin, zend, data);\n    }\n\n    // Make room for, and read the raw (still compressed) tiles. As each one\n    // is read, kick off the decompress and any other extras, to execute in\n    // parallel.\n    stride_t pixel_bytes   = (stride_t)m_spec.pixel_bytes(true);\n    stride_t tileystride   = pixel_bytes * m_spec.tile_width;\n    stride_t tilezstride   = tileystride * m_spec.tile_height;\n    stride_t ystride       = (xend - xbegin) * pixel_bytes;\n    stride_t zstride       = (yend - ybegin) * ystride;\n    imagesize_t tile_bytes = m_spec.tile_bytes(true);\n    int tilevals           = m_spec.tile_pixels() * m_spec.nchannels;\n    size_t cbound          = compressBound((uLong)tile_bytes);\n    std::unique_ptr<char[]> compressed_scratch(new char[cbound * ntiles]);\n    std::unique_ptr<char[]> scratch(new char[tile_bytes * ntiles]);\n    task_set tasks(pool);\n    bool ok = true;  // failed compression will stash a false here\n\n    // Strutil::printf (\"Parallel tile case %d %d  %d %d  %d %d\\n\",\n    //                  xbegin, xend, ybegin, yend, zbegin, zend);\n    size_t tileidx = 0;\n    for (int z = zbegin; z < zend; z += m_spec.tile_depth) {\n        for (int y = ybegin; ok && y < yend; y += m_spec.tile_height) {\n            for (int x = xbegin; ok && x < xend;\n                 x += m_spec.tile_width, ++tileidx) {\n                char* cbuf = compressed_scratch.get() + tileidx * cbound;\n                char* ubuf = scratch.get() + tileidx * tile_bytes;\n                auto csize = TIFFReadRawTile(m_tif, tile_index(x, y, z), cbuf,\n                                             tmsize_t(cbound));\n                if (csize < 0) {\n                    std::string err = oiio_tiff_last_error();\n                    errorfmt(\n                        \"TIFFReadRawTile failed reading tile x={},y={},z={}: {}\",\n                        x, y, z, err.size() ? err.c_str() : \"unknown error\");\n                    ok = false;\n                    break;\n                }\n                // Push the rest of the work onto the thread pool queue\n                auto out = this;\n                tasks.push(pool->push([=, &ok](int /*id*/) {\n                    out->uncompress_one_strip(cbuf, (unsigned long)csize, ubuf,\n                                              tile_bytes, out->m_spec.nchannels,\n                                              out->m_spec.tile_width,\n                                              out->m_spec.tile_height\n                                                  * out->m_spec.tile_depth,\n                                              &ok);\n                    if (out->m_photometric == PHOTOMETRIC_MINISWHITE)\n                        out->invert_photometric(tilevals, ubuf);\n                    copy_image(out->m_spec.nchannels, out->m_spec.tile_width,\n                               out->m_spec.tile_height, out->m_spec.tile_depth,\n                               ubuf, size_t(pixel_bytes), pixel_bytes,\n                               tileystride, tilezstride,\n                               (char*)data + (z - zbegin) * zstride\n                                   + (y - ybegin) * ystride\n                                   + (x - xbegin) * pixel_bytes,\n                               pixel_bytes, ystride, zstride);\n                }));\n            }\n        }\n    }\n    tasks.wait();\n    return ok;\n}\n\n\n\nbool\nTIFFInput::read_scanline(int y, int z, TypeDesc format, void* data,\n                         stride_t xstride)\n{\n    bool ok = ImageInput::read_scanline(y, z, format, data, xstride);\n    if (ok && m_convert_alpha) {\n        // If alpha is unassociated and we aren't requested to keep it that\n        // way, multiply the colors by alpha per the usual OIIO conventions\n        // to deliver associated color & alpha.  Any auto-premultiplication\n        // by alpha should happen after we've already done data format\n        // conversions. That's why we do it here, rather than in\n        // read_native_blah.\n        {\n            lock_guard lock(*this);\n            if (format\n                == TypeUnknown)  // unknown means retrieve the native type\n                format = m_spec.format;\n        }\n        OIIO::premult(m_spec.nchannels, m_spec.width, 1, 1, 0 /*chbegin*/,\n                      m_spec.nchannels /*chend*/, format, data, xstride,\n                      AutoStride, AutoStride, m_spec.alpha_channel,\n                      m_spec.z_channel);\n    }\n    return ok;\n}\n\n\n\nbool\nTIFFInput::read_scanlines(int subimage, int miplevel, int ybegin, int yend,\n                          int z, int chbegin, int chend, TypeDesc format,\n                          void* data, stride_t xstride, stride_t ystride)\n{\n    bool ok = ImageInput::read_scanlines(subimage, miplevel, ybegin, yend, z,\n                                         chbegin, chend, format, data, xstride,\n                                         ystride);\n    if (ok && m_convert_alpha) {\n        // If alpha is unassociated and we aren't requested to keep it that\n        // way, multiply the colors by alpha per the usual OIIO conventions\n        // to deliver associated color & alpha.  Any auto-premultiplication\n        // by alpha should happen after we've already done data format\n        // conversions. That's why we do it here, rather than in\n        // read_native_blah.\n        int nchannels, alpha_channel, z_channel, width;\n        {\n            lock_guard lock(*this);\n            seek_subimage(subimage, miplevel);\n            nchannels     = m_spec.nchannels;\n            alpha_channel = m_spec.alpha_channel;\n            z_channel     = m_spec.z_channel;\n            width         = m_spec.width;\n            if (format == TypeUnknown)  // unknown == native type\n                format = m_spec.format;\n        }\n        // NOTE: if the channel range we read doesn't include the alpha\n        // channel, we don't have the alpha data to do the premult, so skip\n        // this. Pity the hapless soul who tries to read only the first\n        // three channels of an RGBA file with unassociated alpha. They will\n        // not get the premultiplication they deserve.\n        if (alpha_channel >= chbegin && alpha_channel < chend)\n            OIIO::premult(nchannels, width, yend - ybegin, 1, chbegin, chend,\n                          format, data, xstride, ystride, AutoStride,\n                          alpha_channel, z_channel);\n    }\n    return ok;\n}\n\n\n\nbool\nTIFFInput::read_tile(int x, int y, int z, TypeDesc format, void* data,\n                     stride_t xstride, stride_t ystride, stride_t zstride)\n{\n    bool ok = ImageInput::read_tile(x, y, z, format, data, xstride, ystride,\n                                    zstride);\n    if (ok && m_convert_alpha) {\n        // If alpha is unassociated and we aren't requested to keep it that\n        // way, multiply the colors by alpha per the usual OIIO conventions\n        // to deliver associated color & alpha.  Any auto-premultiplication\n        // by alpha should happen after we've already done data format\n        // conversions. That's why we do it here, rather than in\n        // read_native_blah.\n        {\n            lock_guard lock(*this);\n            if (format\n                == TypeUnknown)  // unknown means retrieve the native type\n                format = m_spec.format;\n        }\n        OIIO::premult(m_spec.nchannels, m_spec.tile_width, m_spec.tile_height,\n                      std::max(1, m_spec.tile_depth), 0, m_spec.nchannels,\n                      format, data, xstride, ystride, zstride,\n                      m_spec.alpha_channel, m_spec.z_channel);\n    }\n    return ok;\n}\n\n\n\nbool\nTIFFInput::read_tiles(int subimage, int miplevel, int xbegin, int xend,\n                      int ybegin, int yend, int zbegin, int zend, int chbegin,\n                      int chend, TypeDesc format, void* data, stride_t xstride,\n                      stride_t ystride, stride_t zstride)\n{\n    bool ok = ImageInput::read_tiles(subimage, miplevel, xbegin, xend, ybegin,\n                                     yend, zbegin, zend, chbegin, chend, format,\n                                     data, xstride, ystride, zstride);\n    if (ok && m_convert_alpha) {\n        // If alpha is unassociated and we aren't requested to keep it that\n        // way, multiply the colors by alpha per the usual OIIO conventions\n        // to deliver associated color & alpha.  Any auto-premultiplication\n        // by alpha should happen after we've already done data format\n        // conversions. That's why we do it here, rather than in\n        // read_native_blah.\n        int nchannels, alpha_channel, z_channel;\n        {\n            lock_guard lock(*this);\n            seek_subimage(subimage, miplevel);\n            nchannels     = m_spec.nchannels;\n            alpha_channel = m_spec.alpha_channel;\n            z_channel     = m_spec.z_channel;\n            if (format == TypeUnknown)  // unknown == native type\n                format = m_spec.format;\n        }\n        // NOTE: if the channel range we read doesn't include the alpha\n        // channel, we don't have the alpha data to do the premult, so skip\n        // this. Pity the hapless soul who tries to read only the first\n        // three channels of an RGBA file with unassociated alpha. They will\n        // not get the premultiplication they deserve.\n        if (alpha_channel >= chbegin && alpha_channel < chend)\n            OIIO::premult(nchannels, xend - xbegin, yend - ybegin,\n                          zend - zbegin, chbegin, chend, format, data, xstride,\n                          ystride, zstride, alpha_channel, z_channel);\n    }\n    return ok;\n}\n\nOIIO_PLUGIN_NAMESPACE_END\n",
                "name": "tiffinput.cpp",
                "path": "src/tiff.imageio/tiffinput.cpp",
                "url": "/github.com/AcademySoftwareFoundation/OpenImageIO/-/blob/src/tiff.imageio/tiffinput.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 2075,
                    "offsetAndLengths": [
                        [
                            18,
                            16
                        ]
                    ],
                    "preview": "        bool ok = TIFFReadRGBATile(m_tif, x, y, m_rgbadata.data());"
                },
                {
                    "limitHit": false,
                    "lineNumber": 2083,
                    "offsetAndLengths": [
                        [
                            11,
                            16
                        ]
                    ],
                    "preview": "        // TIFFReadRGBATile always returns data in bottom-to-top order."
                },
                {
                    "limitHit": false,
                    "lineNumber": 2090,
                    "offsetAndLengths": [
                        [
                            27,
                            16
                        ]
                    ],
                    "preview": "        // (Again, because TIFFReadRGBATile reverses the scanline order.)"
                }
            ],
            "repository": {
                "name": "github.com/AcademySoftwareFoundation/OpenImageIO",
                "url": "/github.com/AcademySoftwareFoundation/OpenImageIO"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "21e6bb359b8ba2df6385a493ac17a522c0996702"
                },
                "content": "/*M///////////////////////////////////////////////////////////////////////////////////////\n//\n//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.\n//\n//  By downloading, copying, installing or using the software you agree to this license.\n//  If you do not agree to this license, do not download, install,\n//  copy or use the software.\n//\n//\n//                           License Agreement\n//                For Open Source Computer Vision Library\n//\n// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.\n// Copyright (C) 2009, Willow Garage Inc., all rights reserved.\n// Third party copyrights are property of their respective owners.\n//\n// Redistribution and use in source and binary forms, with or without modification,\n// are permitted provided that the following conditions are met:\n//\n//   * Redistribution's of source code must retain the above copyright notice,\n//     this list of conditions and the following disclaimer.\n//\n//   * Redistribution's in binary form must reproduce the above copyright notice,\n//     this list of conditions and the following disclaimer in the documentation\n//     and/or other materials provided with the distribution.\n//\n//   * The name of the copyright holders may not be used to endorse or promote products\n//     derived from this software without specific prior written permission.\n//\n// This software is provided by the copyright holders and contributors \"as is\" and\n// any express or implied warranties, including, but not limited to, the implied\n// warranties of merchantability and fitness for a particular purpose are disclaimed.\n// In no event shall the Intel Corporation or contributors be liable for any direct,\n// indirect, incidental, special, exemplary, or consequential damages\n// (including, but not limited to, procurement of substitute goods or services;\n// loss of use, data, or profits; or business interruption) however caused\n// and on any theory of liability, whether in contract, strict liability,\n// or tort (including negligence or otherwise) arising in any way out of\n// the use of this software, even if advised of the possibility of such damage.\n//\n//M*/\n\n/****************************************************************************************\\\n    A part of the file implements TIFF reader on base of libtiff library\n    (see otherlibs/_graphics/readme.txt for copyright notice)\n\\****************************************************************************************/\n\n#include \"precomp.hpp\"\n\n#ifdef HAVE_TIFF\n#include <opencv2/core/utils/logger.hpp>\n\n#include \"grfmt_tiff.hpp\"\n#include <limits>\n\n// TODO FIXIT Conflict declarations for common types like int64/uint64\nnamespace tiff_dummy_namespace {\n#include \"tiff.h\"\n#include \"tiffio.h\"\n}\nusing namespace tiff_dummy_namespace;\n\nnamespace cv\n{\n\n// to extend cvtColor() to support CV_8S, CV_16S, CV_32S and CV_64F.\nstatic void extend_cvtColor( InputArray _src, OutputArray _dst, int code );\n\n#define CV_TIFF_CHECK_CALL(call) \\\n    if (0 == (call)) { \\\n        CV_LOG_WARNING(NULL, \"OpenCV TIFF(line \" << __LINE__ << \"): failed \" #call); \\\n        CV_Error(Error::StsError, \"OpenCV TIFF: failed \" #call); \\\n    }\n\n#define CV_TIFF_CHECK_CALL_INFO(call) \\\n    if (0 == (call)) { \\\n        CV_LOG_INFO(NULL, \"OpenCV TIFF(line \" << __LINE__ << \"): failed optional call: \" #call \", ignoring\"); \\\n    }\n\n#define CV_TIFF_CHECK_CALL_DEBUG(call) \\\n    if (0 == (call)) { \\\n        CV_LOG_DEBUG(NULL, \"OpenCV TIFF(line \" << __LINE__ << \"): failed optional call: \" #call \", ignoring\"); \\\n    }\n\nstatic void cv_tiffCloseHandle(void* handle)\n{\n    TIFFClose((TIFF*)handle);\n}\n\nstatic void cv_tiffErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    if (cv::utils::logging::getLogLevel() < cv::utils::logging::LOG_LEVEL_DEBUG)\n        return;\n    // TODO cv::vformat() with va_list parameter\n    fprintf(stderr, \"OpenCV TIFF: \");\n    if (module != NULL)\n        fprintf(stderr, \"%s: \", module);\n    fprintf(stderr, \"Warning, \");\n    vfprintf(stderr, fmt, ap);\n    fprintf(stderr, \".\\n\");\n}\n\nstatic bool cv_tiffSetErrorHandler_()\n{\n    TIFFSetErrorHandler(cv_tiffErrorHandler);\n    TIFFSetWarningHandler(cv_tiffErrorHandler);\n    return true;\n}\n\nstatic bool cv_tiffSetErrorHandler()\n{\n    static bool v = cv_tiffSetErrorHandler_();\n    return v;\n}\n\nstatic const char fmtSignTiffII[] = \"II\\x2a\\x00\";\nstatic const char fmtSignTiffMM[] = \"MM\\x00\\x2a\";\nstatic const char fmtSignBigTiffII[] = \"II\\x2b\\x00\";\nstatic const char fmtSignBigTiffMM[] = \"MM\\x00\\x2b\";\n\nTiffDecoder::TiffDecoder()\n{\n    m_hdr = false;\n    m_buf_supported = true;\n    m_buf_pos = 0;\n}\n\n\nvoid TiffDecoder::close()\n{\n    m_tif.release();\n}\n\nTiffDecoder::~TiffDecoder()\n{\n    close();\n}\n\nsize_t TiffDecoder::signatureLength() const\n{\n    return 4;\n}\n\nbool TiffDecoder::checkSignature( const String& signature ) const\n{\n    return signature.size() >= 4 &&\n        (memcmp(signature.c_str(), fmtSignTiffII, 4) == 0 ||\n        memcmp(signature.c_str(), fmtSignTiffMM, 4) == 0 ||\n        memcmp(signature.c_str(), fmtSignBigTiffII, 4) == 0 ||\n        memcmp(signature.c_str(), fmtSignBigTiffMM, 4) == 0);\n}\n\nint TiffDecoder::normalizeChannelsNumber(int channels) const\n{\n    CV_Check(channels, channels >= 1 && channels <= 4, \"Unsupported number of channels\");\n    return channels;\n}\n\nImageDecoder TiffDecoder::newDecoder() const\n{\n    cv_tiffSetErrorHandler();\n    return makePtr<TiffDecoder>();\n}\n\nclass TiffDecoderBufHelper\n{\n    Mat& m_buf;\n    size_t& m_buf_pos;\npublic:\n    TiffDecoderBufHelper(Mat& buf, size_t& buf_pos) :\n        m_buf(buf), m_buf_pos(buf_pos)\n    {}\n    static tmsize_t read( thandle_t handle, void* buffer, tmsize_t n )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        const Mat& buf = helper->m_buf;\n        const tmsize_t size = buf.cols*buf.rows*buf.elemSize();\n        tmsize_t pos = helper->m_buf_pos;\n        if ( n > (size - pos) )\n        {\n            n = size - pos;\n        }\n        memcpy(buffer, buf.ptr() + pos, n);\n        helper->m_buf_pos += n;\n        return n;\n    }\n\n    static tmsize_t write( thandle_t /*handle*/, void* /*buffer*/, tmsize_t /*n*/ )\n    {\n        // Not used for decoding.\n        return 0;\n    }\n\n    static toff_t seek( thandle_t handle, toff_t offset, int whence )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        const Mat& buf = helper->m_buf;\n        const toff_t size = buf.cols*buf.rows*buf.elemSize();\n        toff_t new_pos = helper->m_buf_pos;\n        switch (whence)\n        {\n            case SEEK_SET:\n                new_pos = offset;\n                break;\n            case SEEK_CUR:\n                new_pos += offset;\n                break;\n            case SEEK_END:\n                new_pos = size + offset;\n                break;\n        }\n        new_pos = std::min(new_pos, size);\n        helper->m_buf_pos = (size_t)new_pos;\n        return new_pos;\n    }\n\n    static int map( thandle_t handle, void** base, toff_t* size )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        Mat& buf = helper->m_buf;\n        *base = buf.ptr();\n        *size = buf.cols*buf.rows*buf.elemSize();\n        return 0;\n    }\n\n    static toff_t size( thandle_t handle )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        const Mat& buf = helper->m_buf;\n        return buf.cols*buf.rows*buf.elemSize();\n    }\n\n    static int close( thandle_t handle )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        delete helper;\n        return 0;\n    }\n};\n\nbool TiffDecoder::readHeader()\n{\n    bool result = false;\n    TIFF* tif = static_cast<TIFF*>(m_tif.get());\n    if (!tif)\n    {\n        // TIFFOpen() mode flags are different to fopen().  A 'b' in mode \"rb\" has no effect when reading.\n        // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n        if ( !m_buf.empty() )\n        {\n            m_buf_pos = 0;\n            TiffDecoderBufHelper* buf_helper = new TiffDecoderBufHelper(this->m_buf, this->m_buf_pos);\n            tif = TIFFClientOpen( \"\", \"r\", reinterpret_cast<thandle_t>(buf_helper), &TiffDecoderBufHelper::read,\n                                  &TiffDecoderBufHelper::write, &TiffDecoderBufHelper::seek,\n                                  &TiffDecoderBufHelper::close, &TiffDecoderBufHelper::size,\n                                  &TiffDecoderBufHelper::map, /*unmap=*/0 );\n            if (!tif)\n                delete buf_helper;\n        }\n        else\n        {\n            tif = TIFFOpen(m_filename.c_str(), \"r\");\n        }\n        if (tif)\n            m_tif.reset(tif, cv_tiffCloseHandle);\n        else\n            m_tif.release();\n    }\n\n    if (tif)\n    {\n        uint32 wdth = 0, hght = 0;\n        uint16 photometric = 0;\n\n        CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &wdth));\n        CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &hght));\n        CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric));\n\n        {\n            bool isGrayScale = photometric == PHOTOMETRIC_MINISWHITE || photometric == PHOTOMETRIC_MINISBLACK;\n            uint16 bpp = 8, ncn = isGrayScale ? 1 : 3;\n            if (0 == TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bpp))\n            {\n                // TIFF bi-level images don't require TIFFTAG_BITSPERSAMPLE tag\n                bpp = 1;\n            }\n            CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &ncn));\n\n            m_width = wdth;\n            m_height = hght;\n            if (ncn == 3 && photometric == PHOTOMETRIC_LOGLUV)\n            {\n                m_type = CV_32FC3;\n                m_hdr = true;\n                return true;\n            }\n            m_hdr = false;\n\n            if( bpp > 8 &&\n               ((photometric > 2) ||\n                (ncn != 1 && ncn != 3 && ncn != 4)))\n                bpp = 8;\n\n            uint16 sample_format = SAMPLEFORMAT_UINT;\n            TIFFGetField(tif, TIFFTAG_SAMPLEFORMAT, &sample_format);\n            int wanted_channels = normalizeChannelsNumber(ncn);\n            switch (bpp)\n            {\n            case 1:\n            {\n                CV_Check((int)sample_format, sample_format == SAMPLEFORMAT_UINT || sample_format == SAMPLEFORMAT_INT, \"\");\n                int depth = sample_format == SAMPLEFORMAT_INT ? CV_8S : CV_8U;\n                m_type = CV_MAKETYPE(depth, !isGrayScale ? wanted_channels : 1);\n                result = true;\n                break;\n            }\n            case 4:\n                //support 4-bit palette.\n                if (photometric == PHOTOMETRIC_PALETTE)\n                {\n                    CV_Check((int)sample_format, sample_format == SAMPLEFORMAT_UINT || sample_format == SAMPLEFORMAT_INT, \"\");\n                    int depth = sample_format == SAMPLEFORMAT_INT ? CV_8S : CV_8U;\n                    m_type = CV_MAKETYPE(depth, 3);\n                    result = true;\n                }\n                else\n                    CV_Error(cv::Error::StsError, \"bitsperpixel value is 4 should be palette.\");\n                break;\n            case 8:\n            {\n                //Palette color, the value of the component is used as an index into the red,\n                //green and blue curves in the ColorMap field to retrieve an RGB triplet that defines the color.\n                CV_Check((int)sample_format, sample_format == SAMPLEFORMAT_UINT || sample_format == SAMPLEFORMAT_INT, \"\");\n                int depth = sample_format == SAMPLEFORMAT_INT ? CV_8S : CV_8U;\n                if (photometric == PHOTOMETRIC_PALETTE)\n                    m_type = CV_MAKETYPE(depth, 3);\n                else\n                    m_type = CV_MAKETYPE(depth, !isGrayScale ? wanted_channels : 1);\n                result = true;\n                break;\n            }\n            case 10:\n            case 12:\n            case 14:\n            case 16:\n            {\n                CV_Check((int)sample_format, sample_format == SAMPLEFORMAT_UINT || sample_format == SAMPLEFORMAT_INT, \"\");\n                int depth = sample_format == SAMPLEFORMAT_INT ? CV_16S : CV_16U;\n                m_type = CV_MAKETYPE(depth, !isGrayScale ? wanted_channels : 1);\n                result = true;\n                break;\n            }\n            case 32:\n            {\n                CV_Check((int)sample_format, sample_format == SAMPLEFORMAT_IEEEFP || sample_format == SAMPLEFORMAT_INT, \"\");\n                int depth = sample_format == SAMPLEFORMAT_IEEEFP ? CV_32F : CV_32S;\n                m_type = CV_MAKETYPE(depth, wanted_channels);\n                result = true;\n                break;\n            }\n            case 64:\n                CV_CheckEQ((int)sample_format, SAMPLEFORMAT_IEEEFP, \"\");\n                m_type = CV_MAKETYPE(CV_64F, wanted_channels);\n                result = true;\n                break;\n            default:\n                CV_Error(cv::Error::StsError, \"Invalid bitsperpixel value read from TIFF header! Must be 1, 8, 10, 12, 14, 16, 32 or 64.\");\n            }\n        }\n    }\n\n    if( !result )\n        close();\n\n    return result;\n}\n\nbool TiffDecoder::nextPage()\n{\n    // Prepare the next page, if any.\n    return !m_tif.empty() &&\n           TIFFReadDirectory(static_cast<TIFF*>(m_tif.get())) &&\n           readHeader();\n}\n\nstatic void fixOrientationPartial(Mat &img, uint16 orientation)\n{\n    switch(orientation) {\n        case ORIENTATION_RIGHTTOP:\n        case ORIENTATION_LEFTBOT:\n            flip(img, img, -1);\n            /* fall through */\n\n        case ORIENTATION_LEFTTOP:\n        case ORIENTATION_RIGHTBOT:\n            transpose(img, img);\n            break;\n    }\n}\n\nstatic void fixOrientationFull(Mat &img, int orientation)\n{\n    switch(orientation) {\n        case ORIENTATION_TOPRIGHT:\n            flip(img, img, 1);\n            break;\n\n        case ORIENTATION_BOTRIGHT:\n            flip(img, img, -1);\n            break;\n\n        case ORIENTATION_BOTLEFT:\n            flip(img, img, 0);\n            break;\n\n        case ORIENTATION_LEFTTOP:\n            transpose(img, img);\n            break;\n\n        case ORIENTATION_RIGHTTOP:\n            transpose(img, img);\n            flip(img, img, 1);\n            break;\n\n        case ORIENTATION_RIGHTBOT:\n            transpose(img, img);\n            flip(img, img, -1);\n            break;\n\n        case ORIENTATION_LEFTBOT:\n            transpose(img, img);\n            flip(img, img, 0);\n            break;\n    }\n}\n\n/**\n * Fix orientation defined in tag 274.\n * For 8 bit some corrections are done by TIFFReadRGBAStrip/Tile already.\n * Not so for 16/32/64 bit.\n */\nstatic void fixOrientation(Mat &img, uint16 orientation, bool isOrientationFull)\n{\n    if( isOrientationFull )\n    {\n        fixOrientationFull(img, orientation);\n    }\n    else\n    {\n        fixOrientationPartial(img, orientation);\n    }\n}\n\nstatic void _unpack10To16(const uchar* src, const uchar* srcEnd, ushort* dst, ushort* dstEnd, size_t expectedDstElements)\n{\n    //5*8b=4*10b : 5 src for 4 dst\n    constexpr const size_t packedBitsCount = 10;\n    constexpr const size_t packedBitsMask = ((1<<packedBitsCount)-1);\n    constexpr const size_t srcElementsPerPacket = 5;\n    constexpr const size_t dstElementsPerPacket = 4;\n    constexpr const size_t bitsPerPacket = dstElementsPerPacket*packedBitsCount;\n    const size_t fullPacketsCount = std::min({\n      expectedDstElements/dstElementsPerPacket,\n      (static_cast<size_t>(srcEnd-src)/srcElementsPerPacket),\n      (static_cast<size_t>(dstEnd-dst)/dstElementsPerPacket)\n    });\n    union {\n      uint64_t u64;\n      uint8_t  u8[8];\n    } buf = {0};\n    for(size_t i = 0 ; i<fullPacketsCount ; ++i)\n    {\n        for(size_t j = 0 ; j<srcElementsPerPacket ; ++j)\n          buf.u8[srcElementsPerPacket-1-j] = *src++;\n        for(size_t j = 0 ; j<dstElementsPerPacket ; ++j)\n        {\n          dst[dstElementsPerPacket-1-j] = static_cast<ushort>(buf.u64 & packedBitsMask);\n          buf.u64 >>= packedBitsCount;\n        }\n        dst += dstElementsPerPacket;\n    }\n    size_t remainingDstElements = std::min(\n        expectedDstElements-fullPacketsCount*dstElementsPerPacket,\n        static_cast<size_t>(dstEnd-dst)\n    );\n    bool stop = !remainingDstElements;\n    while(!stop)\n    {\n        for(size_t j = 0 ; j<srcElementsPerPacket ; ++j)\n            buf.u8[srcElementsPerPacket-1-j] = (src<srcEnd) ? *src++ : 0;\n        for(size_t j = 0 ; j<dstElementsPerPacket ; ++j)\n        {\n            stop |= !(remainingDstElements--);\n            if (!stop)\n              *dst++ = static_cast<ushort>((buf.u64 >> (bitsPerPacket-(j+1)*packedBitsCount)) & packedBitsMask);\n        }\n    }//end while(!stop)\n}\n//end _unpack10To16()\n\nstatic void _unpack12To16(const uchar* src, const uchar* srcEnd, ushort* dst, ushort* dstEnd, size_t expectedDstElements)\n{\n  //3*8b=2*12b : 3 src for 2 dst\n  constexpr const size_t packedBitsCount = 12;\n  constexpr const size_t packedBitsMask = ((1<<packedBitsCount)-1);\n  constexpr const size_t srcElementsPerPacket = 3;\n  constexpr const size_t dstElementsPerPacket = 2;\n  constexpr const size_t bitsPerPacket = dstElementsPerPacket*packedBitsCount;\n  const size_t fullPacketsCount = std::min({\n    expectedDstElements/dstElementsPerPacket,\n    (static_cast<size_t>(srcEnd-src)/srcElementsPerPacket),\n    (static_cast<size_t>(dstEnd-dst)/dstElementsPerPacket)\n  });\n  union {\n      uint32_t u32;\n      uint8_t  u8[4];\n  } buf = {0};\n  for(size_t i = 0 ; i<fullPacketsCount ; ++i)\n  {\n      for(size_t j = 0 ; j<srcElementsPerPacket ; ++j)\n          buf.u8[srcElementsPerPacket-1-j] = *src++;\n      for(size_t j = 0 ; j<dstElementsPerPacket ; ++j)\n      {\n          dst[dstElementsPerPacket-1-j] = static_cast<ushort>(buf.u32 & packedBitsMask);\n          buf.u32 >>= packedBitsCount;\n      }\n      dst += dstElementsPerPacket;\n  }\n  size_t remainingDstElements = std::min(\n      expectedDstElements-fullPacketsCount*dstElementsPerPacket,\n      static_cast<size_t>(dstEnd-dst)\n  );\n  bool stop = !remainingDstElements;\n  while(!stop)\n  {\n      for(size_t j = 0 ; j<srcElementsPerPacket ; ++j)\n          buf.u8[srcElementsPerPacket-1-j] = (src<srcEnd) ? *src++ : 0;\n      for(size_t j = 0 ; j<dstElementsPerPacket ; ++j)\n      {\n          stop |= !(remainingDstElements--);\n          if (!stop)\n              *dst++ = static_cast<ushort>((buf.u32 >> (bitsPerPacket-(j+1)*packedBitsCount)) & packedBitsMask);\n      }\n  }//end while(!stop)\n}\n//end _unpack12To16()\n\nstatic void _unpack14To16(const uchar* src, const uchar* srcEnd, ushort* dst, ushort* dstEnd, size_t expectedDstElements)\n{\n    //7*8b=4*14b : 7 src for 4 dst\n    constexpr const size_t packedBitsCount = 14;\n    constexpr const size_t packedBitsMask = ((1<<packedBitsCount)-1);\n    constexpr const size_t srcElementsPerPacket = 7;\n    constexpr const size_t dstElementsPerPacket = 4;\n    constexpr const size_t bitsPerPacket = dstElementsPerPacket*packedBitsCount;\n    const size_t fullPacketsCount = std::min({\n      expectedDstElements/dstElementsPerPacket,\n      (static_cast<size_t>(srcEnd-src)/srcElementsPerPacket),\n      (static_cast<size_t>(dstEnd-dst)/dstElementsPerPacket)\n    });\n    union {\n        uint64_t u64;\n        uint8_t  u8[8];\n    } buf = {0};\n    for(size_t i = 0 ; i<fullPacketsCount ; ++i)\n    {\n        for(size_t j = 0 ; j<srcElementsPerPacket ; ++j)\n            buf.u8[srcElementsPerPacket-1-j] = *src++;\n        for(size_t j = 0 ; j<dstElementsPerPacket ; ++j)\n        {\n            dst[dstElementsPerPacket-1-j] = static_cast<ushort>(buf.u64 & packedBitsMask);\n            buf.u64 >>= packedBitsCount;\n        }\n        dst += dstElementsPerPacket;\n    }\n    size_t remainingDstElements = std::min(\n        expectedDstElements-fullPacketsCount*dstElementsPerPacket,\n        static_cast<size_t>(dstEnd-dst)\n    );\n    bool stop = !remainingDstElements;\n    while(!stop)\n    {\n        for(size_t j = 0 ; j<srcElementsPerPacket ; ++j)\n            buf.u8[srcElementsPerPacket-1-j] = (src<srcEnd) ? *src++ : 0;\n        for(size_t j = 0 ; j<dstElementsPerPacket ; ++j)\n        {\n            stop |= !(remainingDstElements--);\n            if (!stop)\n                *dst++ = static_cast<ushort>((buf.u64 >> (bitsPerPacket-(j+1)*packedBitsCount)) & packedBitsMask);\n        }\n    }//end while(!stop)\n}\n//end _unpack14To16()\n\nbool  TiffDecoder::readData( Mat& img )\n{\n    int type = img.type();\n    int depth = CV_MAT_DEPTH(type);\n\n    CV_Assert(!m_tif.empty());\n    TIFF* tif = (TIFF*)m_tif.get();\n\n    uint16 photometric = (uint16)-1;\n    CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric));\n\n    if (m_hdr && depth >= CV_32F)\n    {\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_FLOAT));\n    }\n\n    bool color = img.channels() > 1;\n\n    CV_CheckType(type, depth == CV_8U || depth == CV_8S || depth == CV_16U || depth == CV_16S || depth == CV_32S || depth == CV_32F || depth == CV_64F, \"\");\n\n    if (m_width && m_height)\n    {\n        int is_tiled = TIFFIsTiled(tif) != 0;\n        bool isGrayScale = photometric == PHOTOMETRIC_MINISWHITE || photometric == PHOTOMETRIC_MINISBLACK;\n        uint16 bpp = 8, ncn = isGrayScale ? 1 : 3;\n        if (0 == TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bpp))\n        {\n            // TIFF bi-level images don't require TIFFTAG_BITSPERSAMPLE tag\n            bpp = 1;\n        }\n        CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &ncn));\n        uint16 img_orientation = ORIENTATION_TOPLEFT;\n        CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_ORIENTATION, &img_orientation));\n        constexpr const int bitsPerByte = 8;\n        int dst_bpp = (int)(img.elemSize1() * bitsPerByte);\n        bool vert_flip = dst_bpp == 8 &&\n                        (img_orientation == ORIENTATION_BOTRIGHT || img_orientation == ORIENTATION_RIGHTBOT ||\n                         img_orientation == ORIENTATION_BOTLEFT || img_orientation == ORIENTATION_LEFTBOT);\n        int wanted_channels = normalizeChannelsNumber(img.channels());\n        bool doReadScanline = false;\n\n        uint32 tile_width0 = m_width, tile_height0 = 0;\n\n        if (is_tiled)\n        {\n            CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_TILEWIDTH, &tile_width0));\n            CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_TILELENGTH, &tile_height0));\n        }\n        else\n        {\n            // optional\n            CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &tile_height0));\n        }\n\n        {\n            if (tile_width0 == 0)\n                tile_width0 = m_width;\n\n            if (tile_height0 == 0 ||\n                    (!is_tiled && tile_height0 == std::numeric_limits<uint32>::max()) )\n                tile_height0 = m_height;\n\n            const int TILE_MAX_WIDTH = (1 << 24);\n            const int TILE_MAX_HEIGHT = (1 << 24);\n            CV_Assert((int)tile_width0 > 0 && (int)tile_width0 <= TILE_MAX_WIDTH);\n            CV_Assert((int)tile_height0 > 0 && (int)tile_height0 <= TILE_MAX_HEIGHT);\n            const uint64_t MAX_TILE_SIZE = (CV_BIG_UINT(1) << 30);\n            CV_CheckLE((int)ncn, 4, \"\");\n            CV_CheckLE((int)bpp, 64, \"\");\n\n            if (dst_bpp == 8)\n            {\n                const int _ncn = 4; // Read RGBA\n                const int _bpp = 8; // Read 8bit\n\n                // if buffer_size(as 32bit RGBA) >= MAX_TILE_SIZE*95%,\n                // we will use TIFFReadScanline function.\n\n                if (\n                    (uint64_t)tile_width0 * tile_height0 * _ncn * std::max(1, (int)(_bpp / bitsPerByte))\n                    >=\n                    ( (uint64_t) MAX_TILE_SIZE * 95 / 100)\n                )\n                {\n                    uint16_t planerConfig = (uint16)-1;\n                    CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_PLANARCONFIG, &planerConfig));\n\n                    doReadScanline = (!is_tiled) // no tile\n                                     &&\n                                     ( ( ncn == 1 ) || ( ncn == 3 ) || ( ncn == 4 ) )\n                                     &&\n                                     ( ( bpp == 8 ) || ( bpp == 16 ) )\n                                     &&\n                                     (tile_height0 == (uint32_t) m_height) // single strip\n                                     &&\n                                     (\n                                         (photometric == PHOTOMETRIC_MINISWHITE)\n                                         ||\n                                         (photometric == PHOTOMETRIC_MINISBLACK)\n                                         ||\n                                         (photometric == PHOTOMETRIC_RGB)\n                                     )\n                                     &&\n                                     (planerConfig != PLANARCONFIG_SEPARATE);\n\n                    // Currently only EXTRASAMPLE_ASSOCALPHA is supported.\n                    if ( doReadScanline && ( ncn == 4 ) )\n                    {\n                        uint16_t extra_samples_num;\n                        uint16_t *extra_samples = NULL;\n                        CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_EXTRASAMPLES, &extra_samples_num, &extra_samples ));\n                        doReadScanline = ( extra_samples_num == 1 ) && ( extra_samples[0] == EXTRASAMPLE_ASSOCALPHA );\n                    }\n                }\n\n                if ( !doReadScanline )\n                {\n                    // we will use TIFFReadRGBA* functions, so allocate temporary buffer for 32bit RGBA\n                    bpp = 8;\n                    ncn = 4;\n\n                    char errmsg[1024];\n                    if (!TIFFRGBAImageOK(tif, errmsg))\n                    {\n                        CV_LOG_WARNING(NULL, \"OpenCV TIFF: TIFFRGBAImageOK: \" << errmsg);\n                        close();\n                        return false;\n                    }\n                }\n            }\n            else if (dst_bpp == 16)\n            {\n                // if buffer_size >= MAX_TILE_SIZE*95%,\n                // we will use TIFFReadScanline function.\n                if (\n                    (uint64_t)tile_width0 * tile_height0 * ncn * std::max(1, (int)(bpp / bitsPerByte))\n                    >=\n                    MAX_TILE_SIZE * 95 / 100\n                )\n                {\n                    uint16_t planerConfig = (uint16)-1;\n                    CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_PLANARCONFIG, &planerConfig));\n\n                    doReadScanline = (!is_tiled) // no tile\n                                     &&\n                                     ( ( ncn == 1 ) || ( ncn == 3 ) || ( ncn == 4 ) )\n                                     &&\n                                     ( ( bpp == 8 ) || ( bpp == 16 ) )\n                                     &&\n                                     (tile_height0 == (uint32_t) m_height) // single strip\n                                     &&\n                                     (\n                                         (photometric == PHOTOMETRIC_MINISWHITE)\n                                         ||\n                                         (photometric == PHOTOMETRIC_MINISBLACK)\n                                         ||\n                                         (photometric == PHOTOMETRIC_RGB)\n                                     )\n                                     &&\n                                     (planerConfig != PLANARCONFIG_SEPARATE);\n\n                    // Currently only EXTRASAMPLE_ASSOCALPHA is supported.\n                    if ( doReadScanline && ( ncn == 4 ) )\n                    {\n                        uint16_t extra_samples_num;\n                        uint16_t *extra_samples = NULL;\n                        CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_EXTRASAMPLES, &extra_samples_num, &extra_samples ));\n                        doReadScanline = ( extra_samples_num == 1 ) && ( extra_samples[0] == EXTRASAMPLE_ASSOCALPHA );\n                    }\n                }\n            }\n            else if (dst_bpp == 32 || dst_bpp == 64)\n            {\n                CV_Assert(ncn == img.channels());\n                CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP));\n            }\n\n            if ( doReadScanline )\n            {\n                // Read each scanlines.\n                tile_height0 = 1;\n            }\n\n            const size_t src_buffer_bytes_per_row = divUp(static_cast<size_t>(ncn * tile_width0 * bpp), static_cast<size_t>(bitsPerByte));\n            const size_t src_buffer_size = tile_height0 * src_buffer_bytes_per_row;\n            CV_CheckLT(src_buffer_size, MAX_TILE_SIZE, \"buffer_size is too large: >= 1Gb\");\n            const size_t src_buffer_unpacked_bytes_per_row = divUp(static_cast<size_t>(ncn * tile_width0 * dst_bpp), static_cast<size_t>(bitsPerByte));\n            const size_t src_buffer_unpacked_size = tile_height0 * src_buffer_unpacked_bytes_per_row;\n            const bool needsUnpacking = (bpp < dst_bpp);\n            AutoBuffer<uchar> _src_buffer(src_buffer_size);\n            uchar* src_buffer = _src_buffer.data();\n            AutoBuffer<uchar> _src_buffer_unpacked(needsUnpacking ? src_buffer_unpacked_size : 0);\n            uchar* src_buffer_unpacked = needsUnpacking ? _src_buffer_unpacked.data() : nullptr;\n\n            if ( doReadScanline )\n            {\n                CV_CheckGE(src_buffer_size,\n                           static_cast<size_t>(TIFFScanlineSize(tif)),\n                           \"src_buffer_size is smaller than TIFFScanlineSize().\");\n            }\n\n            int tileidx = 0;\n\n            #define MAKE_FLAG(a,b) ( (a << 8) | b )\n            const int  convert_flag = MAKE_FLAG( ncn, wanted_channels );\n            const bool isNeedConvert16to8 = ( doReadScanline ) && ( bpp == 16 ) && ( dst_bpp == 8);\n\n            for (int y = 0; y < m_height; y += (int)tile_height0)\n            {\n                int tile_height = std::min((int)tile_height0, m_height - y);\n\n                const int img_y = vert_flip ? m_height - y - tile_height : y;\n\n                for(int x = 0; x < m_width; x += (int)tile_width0, tileidx++)\n                {\n                    int tile_width = std::min((int)tile_width0, m_width - x);\n\n                    switch (dst_bpp)\n                    {\n                        case 8:\n                        {\n                            uchar* bstart = src_buffer;\n                            if (doReadScanline)\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadScanline(tif, (uint32*)src_buffer, y) >= 0);\n\n                                if ( isNeedConvert16to8 )\n                                {\n                                    // Convert buffer image from 16bit to 8bit.\n                                    int ix;\n                                    for ( ix = 0 ; ix < tile_width * ncn - 4; ix += 4 )\n                                    {\n                                        src_buffer[ ix     ] = src_buffer[ ix * 2 + 1 ];\n                                        src_buffer[ ix + 1 ] = src_buffer[ ix * 2 + 3 ];\n                                        src_buffer[ ix + 2 ] = src_buffer[ ix * 2 + 5 ];\n                                        src_buffer[ ix + 3 ] = src_buffer[ ix * 2 + 7 ];\n                                    }\n\n                                    for (        ; ix < tile_width * ncn ; ix ++ )\n                                    {\n                                        src_buffer[ ix ] = src_buffer[ ix * 2 + 1];\n                                    }\n                                }\n                            }\n                            else if (!is_tiled)\n                            {\n                                CV_TIFF_CHECK_CALL(TIFFReadRGBAStrip(tif, y, (uint32*)src_buffer));\n                            }\n                            else\n                            {\n                                CV_TIFF_CHECK_CALL(TIFFReadRGBATile(tif, x, y, (uint32*)src_buffer));\n                                // Tiles fill the buffer from the bottom up\n                                bstart += (tile_height0 - tile_height) * tile_width0 * 4;\n                            }\n\n                            uchar* img_line_buffer = (uchar*) img.ptr(y, 0);\n\n                            for (int i = 0; i < tile_height; i++)\n                            {\n                                if (doReadScanline)\n                                {\n                                    switch ( convert_flag )\n                                    {\n                                    case MAKE_FLAG( 1, 1 ): // GRAY to GRAY\n                                        memcpy( (void*) img_line_buffer,\n                                                (void*) bstart,\n                                                tile_width * sizeof(uchar) );\n                                        break;\n\n                                    case MAKE_FLAG( 1, 3 ): // GRAY to BGR\n                                        icvCvt_Gray2BGR_8u_C1C3R( bstart, 0,\n                                                img_line_buffer, 0,\n                                                Size(tile_width, 1) );\n                                        break;\n\n                                    case MAKE_FLAG( 3, 1): // RGB to GRAY\n                                        icvCvt_BGR2Gray_8u_C3C1R( bstart, 0,\n                                                img_line_buffer, 0,\n                                                Size(tile_width, 1) );\n                                        break;\n\n                                    case MAKE_FLAG( 3, 3 ): // RGB to BGR\n                                        icvCvt_BGR2RGB_8u_C3R( bstart, 0,\n                                                img_line_buffer, 0,\n                                                Size(tile_width, 1) );\n                                        break;\n\n                                    case MAKE_FLAG( 4, 1 ): // RGBA to GRAY\n                                        icvCvt_BGRA2Gray_8u_C4C1R( bstart, 0,\n                                                img_line_buffer, 0,\n                                                Size(tile_width, 1) );\n                                        break;\n\n                                    case MAKE_FLAG( 4, 3 ): // RGBA to BGR\n                                        icvCvt_BGRA2BGR_8u_C4C3R( bstart, 0,\n                                                img_line_buffer, 0,\n                                                Size(tile_width, 1), 2 );\n                                        break;\n\n                                    case MAKE_FLAG( 4, 4 ): // RGBA to BGRA\n                                        icvCvt_BGRA2RGBA_8u_C4R(bstart, 0,\n                                                img_line_buffer, 0,\n                                                Size(tile_width, 1) );\n                                        break;\n\n                                    default:\n                                        CV_LOG_ONCE_ERROR(NULL, \"OpenCV TIFF(line \" << __LINE__ << \"): Unsupported convertion :\"\n                                                               << \" bpp = \" << bpp << \" ncn = \" << (int)ncn\n                                                               << \" wanted_channels =\" << wanted_channels  );\n                                        break;\n                                    }\n                                    #undef MAKE_FLAG\n                                }\n                                else if (color)\n                                {\n                                    if (wanted_channels == 4)\n                                    {\n                                        icvCvt_BGRA2RGBA_8u_C4R(bstart + i*tile_width0*4, 0,\n                                                img.ptr(img_y + tile_height - i - 1, x), 0,\n                                                Size(tile_width, 1) );\n                                    }\n                                    else\n                                    {\n                                        CV_CheckEQ(wanted_channels, 3, \"TIFF-8bpp: BGR/BGRA images are supported only\");\n                                        icvCvt_BGRA2BGR_8u_C4C3R(bstart + i*tile_width0*4, 0,\n                                                img.ptr(img_y + tile_height - i - 1, x), 0,\n                                                Size(tile_width, 1), 2);\n                                    }\n                                }\n                                else\n                                {\n                                    CV_CheckEQ(wanted_channels, 1, \"\");\n                                    icvCvt_BGRA2Gray_8u_C4C1R( bstart + i*tile_width0*4, 0,\n                                            img.ptr(img_y + tile_height - i - 1, x), 0,\n                                            Size(tile_width, 1), 2);\n                                }\n                            }\n                            break;\n                        }\n\n                        case 16:\n                        {\n                            if (doReadScanline)\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadScanline(tif, (uint32*)src_buffer, y) >= 0);\n                            }\n                            else if (!is_tiled)\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedStrip(tif, tileidx, (uint32*)src_buffer, src_buffer_size) >= 0);\n                            }\n                            else\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedTile(tif, tileidx, (uint32*)src_buffer, src_buffer_size) >= 0);\n                            }\n\n                            for (int i = 0; i < tile_height; i++)\n                            {\n                                ushort* buffer16 = (ushort*)(src_buffer+i*src_buffer_bytes_per_row);\n                                if (needsUnpacking)\n                                {\n                                    const uchar* src_packed = src_buffer+i*src_buffer_bytes_per_row;\n                                    uchar* dst_unpacked = src_buffer_unpacked+i*src_buffer_unpacked_bytes_per_row;\n                                    if (bpp == 10)\n                                        _unpack10To16(src_packed, src_packed+src_buffer_bytes_per_row,\n                                                      (ushort*)dst_unpacked, (ushort*)(dst_unpacked+src_buffer_unpacked_bytes_per_row),\n                                                      ncn * tile_width0);\n                                    else if (bpp == 12)\n                                        _unpack12To16(src_packed, src_packed+src_buffer_bytes_per_row,\n                                                      (ushort*)dst_unpacked, (ushort*)(dst_unpacked+src_buffer_unpacked_bytes_per_row),\n                                                      ncn * tile_width0);\n                                    else if (bpp == 14)\n                                        _unpack14To16(src_packed, src_packed+src_buffer_bytes_per_row,\n                                                      (ushort*)dst_unpacked, (ushort*)(dst_unpacked+src_buffer_unpacked_bytes_per_row),\n                                                      ncn * tile_width0);\n                                    buffer16 = (ushort*)dst_unpacked;\n                                }\n\n                                if (color)\n                                {\n                                    if (ncn == 1)\n                                    {\n                                        CV_CheckEQ(wanted_channels, 3, \"\");\n                                        icvCvt_Gray2BGR_16u_C1C3R(buffer16, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1));\n                                    }\n                                    else if (ncn == 3)\n                                    {\n                                        CV_CheckEQ(wanted_channels, 3, \"\");\n                                        icvCvt_RGB2BGR_16u_C3R(buffer16, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1));\n                                    }\n                                    else if (ncn == 4)\n                                    {\n                                        if (wanted_channels == 4)\n                                        {\n                                            icvCvt_BGRA2RGBA_16u_C4R(buffer16, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1));\n                                        }\n                                        else\n                                        {\n                                            CV_CheckEQ(wanted_channels, 3, \"TIFF-16bpp: BGR/BGRA images are supported only\");\n                                            icvCvt_BGRA2BGR_16u_C4C3R(buffer16, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1), 2);\n                                        }\n                                    }\n                                    else\n                                    {\n                                        CV_Error(Error::StsError, \"Not supported\");\n                                    }\n                                }\n                                else\n                                {\n                                    CV_CheckEQ(wanted_channels, 1, \"\");\n                                    if( ncn == 1 )\n                                    {\n                                        memcpy(img.ptr<ushort>(img_y + i, x),\n                                               buffer16,\n                                               tile_width*sizeof(ushort));\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2Gray_16u_CnC1R(buffer16, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1), ncn, 2);\n                                    }\n                                }\n                            }\n                            break;\n                        }\n\n                        case 32:\n                        case 64:\n                        {\n                            if( !is_tiled )\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedStrip(tif, tileidx, src_buffer, src_buffer_size) >= 0);\n                            }\n                            else\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedTile(tif, tileidx, src_buffer, src_buffer_size) >= 0);\n                            }\n\n                            Mat m_tile(Size(tile_width0, tile_height0), CV_MAKETYPE((dst_bpp == 32) ? (depth == CV_32S ? CV_32S : CV_32F) : CV_64F, ncn), src_buffer);\n                            Rect roi_tile(0, 0, tile_width, tile_height);\n                            Rect roi_img(x, img_y, tile_width, tile_height);\n                            if (!m_hdr && ncn == 3)\n                                extend_cvtColor(m_tile(roi_tile), img(roi_img), COLOR_RGB2BGR);\n                            else if (!m_hdr && ncn == 4)\n                                extend_cvtColor(m_tile(roi_tile), img(roi_img), COLOR_RGBA2BGRA);\n                            else\n                                m_tile(roi_tile).copyTo(img(roi_img));\n                            break;\n                        }\n                        default:\n                        {\n                            CV_Assert(0 && \"OpenCV TIFF: unsupported depth\");\n                        }\n                    }  // switch (dst_bpp)\n                }  // for x\n            }  // for y\n        }\n        if (bpp < dst_bpp)\n          img *= (1<<(dst_bpp-bpp));\n\n        // If TIFFReadRGBA* function is used -> fixOrientationPartial().\n        // Otherwise                         -> fixOrientationFull().\n        fixOrientation(img, img_orientation,\n                       ( ( dst_bpp != 8 ) && ( !doReadScanline ) ) );\n    }\n\n    if (m_hdr && depth >= CV_32F)\n    {\n        CV_Assert(photometric == PHOTOMETRIC_LOGLUV);\n        cvtColor(img, img, COLOR_XYZ2BGR);\n    }\n    return true;\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////\n\nTiffEncoder::TiffEncoder()\n{\n    m_description = \"TIFF Files (*.tiff;*.tif)\";\n    m_buf_supported = true;\n}\n\nTiffEncoder::~TiffEncoder()\n{\n}\n\nImageEncoder TiffEncoder::newEncoder() const\n{\n    cv_tiffSetErrorHandler();\n    return makePtr<TiffEncoder>();\n}\n\nbool TiffEncoder::isFormatSupported( int depth ) const\n{\n    return depth == CV_8U || depth == CV_8S || depth == CV_16U || depth == CV_16S || depth == CV_32S || depth == CV_32F || depth == CV_64F;\n}\n\nvoid  TiffEncoder::writeTag( WLByteStream& strm, TiffTag tag,\n                             TiffFieldType fieldType,\n                             int count, int value )\n{\n    strm.putWord( tag );\n    strm.putWord( fieldType );\n    strm.putDWord( count );\n    strm.putDWord( value );\n}\n\nclass TiffEncoderBufHelper\n{\npublic:\n\n    TiffEncoderBufHelper(std::vector<uchar> *buf)\n            : m_buf(buf), m_buf_pos(0)\n    {}\n\n    TIFF* open ()\n    {\n        // do NOT put \"wb\" as the mode, because the b means \"big endian\" mode, not \"binary\" mode.\n        // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n        return TIFFClientOpen( \"\", \"w\", reinterpret_cast<thandle_t>(this), &TiffEncoderBufHelper::read,\n                               &TiffEncoderBufHelper::write, &TiffEncoderBufHelper::seek,\n                               &TiffEncoderBufHelper::close, &TiffEncoderBufHelper::size,\n                               /*map=*/0, /*unmap=*/0 );\n    }\n\n    static tmsize_t read( thandle_t /*handle*/, void* /*buffer*/, tmsize_t /*n*/ )\n    {\n        // Not used for encoding.\n        return 0;\n    }\n\n    static tmsize_t write( thandle_t handle, void* buffer, tmsize_t n )\n    {\n        TiffEncoderBufHelper *helper = reinterpret_cast<TiffEncoderBufHelper*>(handle);\n        size_t begin = (size_t)helper->m_buf_pos;\n        size_t end = begin + n;\n        if ( helper->m_buf->size() < end )\n        {\n            helper->m_buf->resize(end);\n        }\n        memcpy(&(*helper->m_buf)[begin], buffer, n);\n        helper->m_buf_pos = end;\n        return n;\n    }\n\n    static toff_t seek( thandle_t handle, toff_t offset, int whence )\n    {\n        TiffEncoderBufHelper *helper = reinterpret_cast<TiffEncoderBufHelper*>(handle);\n        const toff_t size = helper->m_buf->size();\n        toff_t new_pos = helper->m_buf_pos;\n        switch (whence)\n        {\n            case SEEK_SET:\n                new_pos = offset;\n                break;\n            case SEEK_CUR:\n                new_pos += offset;\n                break;\n            case SEEK_END:\n                new_pos = size + offset;\n                break;\n        }\n        helper->m_buf_pos = new_pos;\n        return new_pos;\n    }\n\n    static toff_t size( thandle_t handle )\n    {\n        TiffEncoderBufHelper *helper = reinterpret_cast<TiffEncoderBufHelper*>(handle);\n        return helper->m_buf->size();\n    }\n\n    static int close( thandle_t /*handle*/ )\n    {\n        // Do nothing.\n        return 0;\n    }\n\nprivate:\n\n    std::vector<uchar>* m_buf;\n    toff_t m_buf_pos;\n};\n\nstatic bool readParam(const std::vector<int>& params, int key, int& value)\n{\n    for (size_t i = 0; i + 1 < params.size(); i += 2)\n    {\n        if (params[i] == key)\n        {\n            value = params[i + 1];\n            return true;\n        }\n    }\n    return false;\n}\n\nbool TiffEncoder::writeLibTiff( const std::vector<Mat>& img_vec, const std::vector<int>& params)\n{\n    // do NOT put \"wb\" as the mode, because the b means \"big endian\" mode, not \"binary\" mode.\n    // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n    TIFF* tif = NULL;\n\n    TiffEncoderBufHelper buf_helper(m_buf);\n    if ( m_buf )\n    {\n        tif = buf_helper.open();\n    }\n    else\n    {\n        tif = TIFFOpen(m_filename.c_str(), \"w\");\n    }\n    if (!tif)\n    {\n        return false;\n    }\n    cv::Ptr<void> tif_cleanup(tif, cv_tiffCloseHandle);\n\n    //Settings that matter to all images\n    int compression = COMPRESSION_LZW;\n    int predictor = PREDICTOR_HORIZONTAL;\n    int resUnit = -1, dpiX = -1, dpiY = -1;\n\n    readParam(params, IMWRITE_TIFF_COMPRESSION, compression);\n    readParam(params, TIFFTAG_PREDICTOR, predictor);\n    readParam(params, IMWRITE_TIFF_RESUNIT, resUnit);\n    readParam(params, IMWRITE_TIFF_XDPI, dpiX);\n    readParam(params, IMWRITE_TIFF_YDPI, dpiY);\n\n    //Iterate through each image in the vector and write them out as Tiff directories\n    for (size_t page = 0; page < img_vec.size(); page++)\n    {\n        const Mat& img = img_vec[page];\n        CV_Assert(!img.empty());\n        int channels = img.channels();\n        int width = img.cols, height = img.rows;\n        int type = img.type();\n        int depth = CV_MAT_DEPTH(type);\n        CV_CheckType(type, depth == CV_8U || depth == CV_8S || depth == CV_16U || depth == CV_16S || depth == CV_32S || depth == CV_32F || depth == CV_64F, \"\");\n        CV_CheckType(type, channels >= 1 && channels <= 4, \"\");\n\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, width));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_IMAGELENGTH, height));\n\n        if (img_vec.size() > 1)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE));\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PAGENUMBER, page, img_vec.size()));\n        }\n\n        int compression_param = -1;  // OPENCV_FUTURE\n        if (type == CV_32FC3 && (!readParam(params, IMWRITE_TIFF_COMPRESSION, compression_param) || compression_param == COMPRESSION_SGILOG))\n        {\n            if (!write_32FC3_SGILOG(img, tif))\n                return false;\n            continue;\n        }\n\n        int page_compression = compression;\n\n        int bitsPerChannel = -1;\n        uint16 sample_format = SAMPLEFORMAT_INT;\n        switch (depth)\n        {\n            case CV_8U:\n                sample_format = SAMPLEFORMAT_UINT;\n                /* FALLTHRU */\n            case CV_8S:\n            {\n                bitsPerChannel = 8;\n                break;\n            }\n\n            case CV_16U:\n                sample_format = SAMPLEFORMAT_UINT;\n                /* FALLTHRU */\n            case CV_16S:\n            {\n                bitsPerChannel = 16;\n                break;\n            }\n\n            case CV_32S:\n            {\n                bitsPerChannel = 32;\n                sample_format = SAMPLEFORMAT_INT;\n                break;\n            }\n            case CV_32F:\n            {\n                bitsPerChannel = 32;\n                page_compression = COMPRESSION_NONE;\n                sample_format = SAMPLEFORMAT_IEEEFP;\n                break;\n            }\n            case CV_64F:\n            {\n                bitsPerChannel = 64;\n                page_compression = COMPRESSION_NONE;\n                sample_format = SAMPLEFORMAT_IEEEFP;\n                break;\n            }\n            default:\n            {\n                return false;\n            }\n        }\n\n        const int bitsPerByte = 8;\n        size_t fileStep = (width * channels * bitsPerChannel) / bitsPerByte;\n        CV_Assert(fileStep > 0);\n\n        int rowsPerStrip = (int)((1 << 13) / fileStep);\n        readParam(params, TIFFTAG_ROWSPERSTRIP, rowsPerStrip);\n        rowsPerStrip = std::max(1, std::min(height, rowsPerStrip));\n\n        int colorspace = channels > 1 ? PHOTOMETRIC_RGB : PHOTOMETRIC_MINISBLACK;\n\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, bitsPerChannel));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_COMPRESSION, page_compression));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, colorspace));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, channels));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, rowsPerStrip));\n\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, sample_format));\n\n        if (page_compression == COMPRESSION_LZW || page_compression == COMPRESSION_ADOBE_DEFLATE || page_compression == COMPRESSION_DEFLATE)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PREDICTOR, predictor));\n        }\n\n        if (resUnit >= RESUNIT_NONE && resUnit <= RESUNIT_CENTIMETER)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_RESOLUTIONUNIT, resUnit));\n        }\n        if (dpiX >= 0)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_XRESOLUTION, (float)dpiX));\n        }\n        if (dpiY >= 0)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_YRESOLUTION, (float)dpiY));\n        }\n\n        // row buffer, because TIFFWriteScanline modifies the original data!\n        size_t scanlineSize = TIFFScanlineSize(tif);\n        AutoBuffer<uchar> _buffer(scanlineSize + 32);\n        uchar* buffer = _buffer.data(); CV_DbgAssert(buffer);\n        Mat m_buffer(Size(width, 1), CV_MAKETYPE(depth, channels), buffer, (size_t)scanlineSize);\n\n        for (int y = 0; y < height; ++y)\n        {\n            switch (channels)\n            {\n                case 1:\n                {\n                    memcpy(buffer, img.ptr(y), scanlineSize);\n                    break;\n                }\n\n                case 3:\n                {\n                    extend_cvtColor(img(Rect(0, y, width, 1)), (const Mat&)m_buffer, COLOR_BGR2RGB);\n                    break;\n                }\n\n                case 4:\n                {\n                    extend_cvtColor(img(Rect(0, y, width, 1)), (const Mat&)m_buffer, COLOR_BGRA2RGBA);\n                    break;\n                }\n\n                default:\n                {\n                    CV_Assert(0);\n                }\n            }\n\n            CV_TIFF_CHECK_CALL(TIFFWriteScanline(tif, buffer, y, 0) == 1);\n        }\n\n        CV_TIFF_CHECK_CALL(TIFFWriteDirectory(tif));\n    }\n\n    return true;\n}\n\nbool TiffEncoder::write_32FC3_SGILOG(const Mat& _img, void* tif_)\n{\n    TIFF* tif = (TIFF*)tif_;\n    CV_Assert(tif);\n\n    Mat img;\n    cvtColor(_img, img, COLOR_BGR2XYZ);\n\n    //done by caller: CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, img.cols));\n    //done by caller: CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_IMAGELENGTH, img.rows));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 3));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 32));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_SGILOG));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_LOGLUV));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_FLOAT));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, 1));\n    const int strip_size = 3 * img.cols;\n    for (int i = 0; i < img.rows; i++)\n    {\n        CV_TIFF_CHECK_CALL(TIFFWriteEncodedStrip(tif, i, (tdata_t)img.ptr<float>(i), strip_size * sizeof(float)) != (tsize_t)-1);\n    }\n    CV_TIFF_CHECK_CALL(TIFFWriteDirectory(tif));\n    return true;\n}\n\nbool TiffEncoder::writemulti(const std::vector<Mat>& img_vec, const std::vector<int>& params)\n{\n    return writeLibTiff(img_vec, params);\n}\n\nbool  TiffEncoder::write( const Mat& img, const std::vector<int>& params)\n{\n    int type = img.type();\n    int depth = CV_MAT_DEPTH(type);\n\n    CV_CheckType(type, depth == CV_8U || depth == CV_8S || depth == CV_16U || depth == CV_16S || depth == CV_32S || depth == CV_32F || depth == CV_64F, \"\");\n\n    std::vector<Mat> img_vec;\n    img_vec.push_back(img);\n    return writeLibTiff(img_vec, params);\n}\n\nstatic void extend_cvtColor( InputArray _src, OutputArray _dst, int code )\n{\n    CV_Assert( !_src.empty() );\n    CV_Assert( _src.dims() == 2 );\n\n    // This function extend_cvtColor reorders the src channels with only thg limited condition.\n    // Otherwise, it calls cvtColor.\n\n    const int stype = _src.type();\n    if(!\n        (\n            (\n                ( stype == CV_8SC3  ) || ( stype == CV_8SC4  ) ||\n                ( stype == CV_16SC3 ) || ( stype == CV_16SC4 ) ||\n                ( stype == CV_32SC3 ) || ( stype == CV_32SC4 ) ||\n                ( stype == CV_64FC3 ) || ( stype == CV_64FC4 )\n            )\n            &&\n            (\n                ( code == COLOR_BGR2RGB ) || ( code == COLOR_BGRA2RGBA )\n            )\n        )\n    )\n    {\n        cvtColor( _src, _dst, code );\n        return;\n    }\n\n    Mat src = _src.getMat();\n\n    // cv::mixChannels requires the output arrays to be pre-allocated before calling the function.\n    _dst.create( _src.size(), stype );\n    Mat dst = _dst.getMat();\n\n    // BGR to RGB or BGRA to RGBA\n    //   src[0] -> dst[2]\n    //   src[1] -> dst[1]\n    //   src[2] -> dst[0]\n    //   src[3] -> dst[3] if src has alpha channel.\n    std::vector<int> fromTo;\n    fromTo.push_back(0); fromTo.push_back(2);\n    fromTo.push_back(1); fromTo.push_back(1);\n    fromTo.push_back(2); fromTo.push_back(0);\n    if ( code == COLOR_BGRA2RGBA )\n    {\n        fromTo.push_back(3); fromTo.push_back(3);\n    }\n\n    cv::mixChannels( src, dst, fromTo );\n}\n\n} // namespace\n\n#endif\n",
                "name": "grfmt_tiff.cpp",
                "path": "Frame/Source/ThirdParty/opencv/modules/imgcodecs/src/grfmt_tiff.cpp",
                "url": "/github.com/roeas/GAMES101-Premake/-/blob/Frame/Source/ThirdParty/opencv/modules/imgcodecs/src/grfmt_tiff.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 844,
                    "offsetAndLengths": [
                        [
                            51,
                            16
                        ]
                    ],
                    "preview": "                                CV_TIFF_CHECK_CALL(TIFFReadRGBATile(tif, x, y, (uint32*)src_buffer));"
                }
            ],
            "repository": {
                "name": "github.com/roeas/GAMES101-Premake",
                "url": "/github.com/roeas/GAMES101-Premake"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "24efe29f302f8780144eea622bdbd30a244e5a0b"
                },
                "content": "// Copyright 2020 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#include <array>\n#include <cstdint>\n#include <cstring>\n\n#include \"helper.h\"  // NOLINT(build/include)\n#include \"gtest/gtest.h\"\n#include \"tiffio.h\"  // NOLINT(build/include)\n\nusing ::sapi::IsOk;\nusing ::testing::Eq;\nusing ::testing::IsFalse;\nusing ::testing::IsTrue;\nusing ::testing::NotNull;\n\n// sapi functions:\n//    TIFFOpen\n//    TIFFClose\n//    TIFFGetField\n//    TIFFSetField\n//    TIFFTileSize\n//    TIFFReadRGBATile\n//    TIFFReadEncodedTile\n\nnamespace {\n\nconstexpr std::array<uint8_t, 6> kCluster0 = {0, 0, 2, 0, 138, 139};\nconstexpr std::array<uint8_t, 6> kCluster64 = {0, 0, 9, 6, 134, 119};\nconstexpr std::array<uint8_t, 6> kCluster128 = {44, 40, 63, 59, 230, 95};\n\ntemplate <typename ArrayT>\nint CheckCluster(int cluster, const sapi::v::Array<uint8_t>& buffer,\n                 const ArrayT& expected_cluster) {\n  uint8_t* target = buffer.GetData() + cluster * 6;\n\n  bool comp = !(std::memcmp(target, expected_cluster.data(), 6) == 0);\n\n  EXPECT_THAT(comp, IsFalse())\n      << \"Cluster \" << cluster << \" did not match expected results.\\n\"\n      << \"Expect: \" << expected_cluster[0] << \"\\t\" << expected_cluster[1]\n      << \"\\t\" << expected_cluster[4] << \"\\t\" << expected_cluster[5] << \"\\t\"\n      << expected_cluster[2] << \"\\t\" << expected_cluster[3] << \"\\n\"\n      << \"Got: \" << target[0] << \"\\t\" << target[1] << \"\\t\" << target[4] << \"\\t\"\n      << target[5] << \"\\t\" << target[2] << \"\\t\" << target[3];\n\n  return comp;\n}\n\nint CheckRgbPixel(int pixel, int min_red, int max_red, int min_green,\n                  int max_green, int min_blue, int max_blue,\n                  const sapi::v::Array<uint8_t>& buffer) {\n  uint8_t* rgb = buffer.GetData() + 3 * pixel;\n\n  bool comp =\n      !(rgb[0] >= min_red && rgb[0] <= max_red && rgb[1] >= min_green &&\n        rgb[1] <= max_green && rgb[2] >= min_blue && rgb[2] <= max_blue);\n\n  EXPECT_THAT(comp, IsFalse())\n      << \"Pixel \" << pixel << \" did not match expected results.\\n\"\n      << \"Got R=\" << rgb[0] << \" (expected \" << min_red << \"..\" << max_red\n      << \"), G=\" << rgb[1] << \" (expected \" << min_green << \"..\" << max_green\n      << \"), B=\" << rgb[2] << \" (expected \" << min_blue << \"..\" << max_blue\n      << \")\";\n  return comp;\n}\n\nint CheckRgbaPixel(int pixel, int min_red, int max_red, int min_green,\n                   int max_green, int min_blue, int max_blue, int min_alpha,\n                   int max_alpha, const sapi::v::Array<uint32_t>& buffer) {\n  // RGBA images are upside down - adjust for normal ordering\n  int adjusted_pixel = pixel % 128 + (127 - (pixel / 128)) * 128;\n  unsigned rgba = buffer[adjusted_pixel];\n\n  bool comp = !(TIFFGetR(rgba) >= static_cast<uint32_t>(min_red) &&\n                TIFFGetR(rgba) <= static_cast<uint32_t>(max_red) &&\n                TIFFGetG(rgba) >= static_cast<uint32_t>(min_green) &&\n                TIFFGetG(rgba) <= static_cast<uint32_t>(max_green) &&\n                TIFFGetB(rgba) >= static_cast<uint32_t>(min_blue) &&\n                TIFFGetB(rgba) <= static_cast<uint32_t>(max_blue) &&\n                TIFFGetA(rgba) >= static_cast<uint32_t>(min_alpha) &&\n                TIFFGetA(rgba) <= static_cast<uint32_t>(max_alpha));\n\n  EXPECT_THAT(comp, IsFalse())\n      << \"Pixel \" << pixel << \" did not match expected results.\\n\"\n      << \"Got R=\" << TIFFGetR(rgba) << \" (expected \" << min_red << \"..\"\n      << max_red << \"), G=\" << TIFFGetG(rgba) << \" (expected \" << min_green\n      << \"..\" << max_green << \"), B=\" << TIFFGetB(rgba) << \" (expected \"\n      << min_blue << \"..\" << max_blue << \"), A=\" << TIFFGetA(rgba)\n      << \" (expected \" << min_alpha << \"..\" << max_alpha << \")\";\n  return comp;\n}\n\nTEST(SandboxTest, RawDecode) {\n  std::string srcfile = GetFilePath(\"test/images/quad-tile.jpg.tiff\");\n\n  TiffSapiSandbox sandbox(\"\", srcfile);\n  ASSERT_THAT(sandbox.Init(), IsOk()) << \"Couldn't initialize Sandboxed API\";\n\n  tsize_t sz;\n  unsigned int pixel_status = 0;\n  sapi::v::UShort h;\n  sapi::v::UShort v;\n\n  TiffApi api(&sandbox);\n  sapi::v::ConstCStr srcfile_var(srcfile.c_str());\n  sapi::v::ConstCStr r_var(\"r\");\n\n  absl::StatusOr<TIFF*> status_or_tif =\n      api.TIFFOpen(srcfile_var.PtrBefore(), r_var.PtrBefore());\n  ASSERT_THAT(status_or_tif, IsOk()) << \"Could not open \" << srcfile;\n\n  sapi::v::RemotePtr tif(status_or_tif.value());\n  ASSERT_THAT(tif.GetValue(), NotNull())\n      << \"Could not open \" << srcfile << \", TIFFOpen return NULL\";\n\n  absl::StatusOr<int> status_or_int = api.TIFFGetField2(\n      &tif, TIFFTAG_YCBCRSUBSAMPLING, h.PtrBoth(), v.PtrBoth());\n  ASSERT_THAT(status_or_int, IsOk()) << \"TIFFGetField2 fatal error\";\n  EXPECT_THAT(\n      status_or_int.value() == 0 || h.GetValue() != 2 || v.GetValue() != 2,\n      IsFalse())\n      << \"Could not retrieve subsampling tag\";\n\n  absl::StatusOr<tmsize_t> status_or_long = api.TIFFTileSize(&tif);\n  ASSERT_THAT(status_or_int, IsOk()) << \"TIFFTileSize fatal error\";\n  EXPECT_THAT(status_or_long.value(), Eq(24576))\n      << \"tiles are \" << status_or_long.value() << \" bytes\";\n  sz = status_or_long.value();\n\n  sapi::v::Array<uint8_t> buffer_(sz);\n  status_or_long = api.TIFFReadEncodedTile(&tif, 9, buffer_.PtrBoth(), sz);\n  ASSERT_THAT(status_or_long, IsOk()) << \"TIFFReadEncodedTile fatal error\";\n  EXPECT_THAT(status_or_long.value(), Eq(sz))\n      << \"Did not get expected result code from TIFFReadEncodedTile()(\"\n      << static_cast<int>(status_or_long.value()) << \" instead of \" << (int)sz\n      << \")\";\n\n  ASSERT_FALSE(CheckCluster(0, buffer_, kCluster0) ||\n               CheckCluster(64, buffer_, kCluster64) ||\n               CheckCluster(128, buffer_, kCluster128))\n      << \"Clusters did not match expected results\";\n\n  status_or_int =\n      api.TIFFSetFieldU1(&tif, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n  ASSERT_THAT(status_or_int, IsOk()) << \"TIFFSetFieldU1 fatal error\";\n  EXPECT_THAT(status_or_int.value(), IsTrue())\n      << \"TIFFSetFieldU1 not available\";\n\n  status_or_long = api.TIFFTileSize(&tif);\n  ASSERT_THAT(status_or_long, IsOk()) << \"TIFFTileSize fatal error\";\n  EXPECT_THAT(status_or_long.value(), Eq(128 * 128 * 3))\n      << \"tiles are \" << status_or_long.value() << \" bytes\";\n  sz = status_or_long.value();\n\n  sapi::v::Array<uint8_t> buffer2_(sz);\n  status_or_long = api.TIFFReadEncodedTile(&tif, 9, buffer2_.PtrBoth(), sz);\n  ASSERT_THAT(status_or_long, IsOk()) << \"TIFFReadEncodedTile fatal error\";\n  EXPECT_THAT(status_or_long.value(), Eq(sz))\n      << \"Did not get expected result code from TIFFReadEncodedTile()(\"\n      << status_or_long.value() << \" instead of \" << sz;\n\n  pixel_status |= CheckRgbPixel(0, 15, 18, 0, 0, 18, 41, buffer2_);\n  pixel_status |= CheckRgbPixel(64, 0, 0, 0, 0, 0, 2, buffer2_);\n  pixel_status |= CheckRgbPixel(512, 5, 6, 34, 36, 182, 196, buffer2_);\n\n  ASSERT_THAT(api.TIFFClose(&tif), IsOk()) << \"TIFFClose fatal error\";\n\n  status_or_tif = api.TIFFOpen(srcfile_var.PtrBefore(), r_var.PtrBefore());\n  ASSERT_THAT(status_or_tif, IsOk()) << \"TIFFOpen fatal error\";\n\n  sapi::v::RemotePtr tif2(status_or_tif.value());\n  ASSERT_THAT(tif2.GetValue(), NotNull())\n      << \"Could not open \" << srcfile << \", TIFFOpen return NULL\";\n\n  sapi::v::Array<uint32_t> rgba_buffer_(128 * 128);\n\n  status_or_int =\n      api.TIFFReadRGBATile(&tif2, 1 * 128, 2 * 128, rgba_buffer_.PtrBoth());\n  ASSERT_THAT(status_or_int, IsOk()) << \"TIFFReadRGBATile fatal error\";\n  EXPECT_THAT(status_or_int.value(), IsTrue())\n      << \"TIFFReadRGBATile() returned failure code\";\n\n  pixel_status |=\n      CheckRgbaPixel(0, 15, 18, 0, 0, 18, 41, 255, 255, rgba_buffer_);\n  pixel_status |= CheckRgbaPixel(64, 0, 0, 0, 0, 0, 2, 255, 255, rgba_buffer_);\n  pixel_status |=\n      CheckRgbaPixel(512, 5, 6, 34, 36, 182, 196, 255, 255, rgba_buffer_);\n\n  EXPECT_THAT(api.TIFFClose(&tif2), IsOk()) << \"TIFFClose fatal error\";\n\n  EXPECT_THAT(pixel_status, IsFalse()) << \"wrong encoding\";\n}\n\n}  // namespace\n",
                "name": "raw_decode.cc",
                "path": "contrib/libtiff/test/raw_decode.cc",
                "url": "/github.com/google/sandboxed-api/-/blob/contrib/libtiff/test/raw_decode.cc"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 34,
                    "offsetAndLengths": [
                        [
                            6,
                            16
                        ]
                    ],
                    "preview": "//    TIFFReadRGBATile"
                },
                {
                    "limitHit": false,
                    "lineNumber": 190,
                    "offsetAndLengths": [
                        [
                            10,
                            16
                        ]
                    ],
                    "preview": "      api.TIFFReadRGBATile(&tif2, 1 * 128, 2 * 128, rgba_buffer_.PtrBoth());"
                },
                {
                    "limitHit": false,
                    "lineNumber": 191,
                    "offsetAndLengths": [
                        [
                            41,
                            16
                        ]
                    ],
                    "preview": "  ASSERT_THAT(status_or_int, IsOk()) << \"TIFFReadRGBATile fatal error\";"
                },
                {
                    "limitHit": false,
                    "lineNumber": 193,
                    "offsetAndLengths": [
                        [
                            10,
                            16
                        ]
                    ],
                    "preview": "      << \"TIFFReadRGBATile() returned failure code\";"
                }
            ],
            "repository": {
                "name": "github.com/google/sandboxed-api",
                "url": "/github.com/google/sandboxed-api"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "79c77eb1ab736cfceb5adc6ee591de44dbdf2af8"
                },
                "content": "// This file is part of slideio project.\n// It is subject to the license terms in the LICENSE file found in the top-level directory\n// of this distribution and at http://slideio.com/license.html.\n//\n#include \"slideio/imagetools/tifftools.hpp\"\n\n#include <codecvt>\n\n#include \"slideio/imagetools/imagetools.hpp\"\n#include \"slideio/core/tools/cvtools.hpp\"\n#include <opencv2/core.hpp>\n#include \"slideio/imagetools/libtiff.hpp\"\n#include <filesystem>\n#include \"slideio/base/log.hpp\"\n#include \"slideio/core/tools/endian.hpp\"\n#include \"slideio/core/tools/tools.hpp\"\n\nusing namespace slideio;\n\nstatic DataType dataTypeFromTIFFDataType(libtiff::TIFFDataType dt)\n{\n    switch(dt)\n    {\n    case libtiff::TIFF_NOTYPE:\n        return DataType::DT_None;\n    case libtiff::TIFF_LONG8:\n    case libtiff::TIFF_BYTE:\n        return DataType::DT_Byte;\n    case libtiff::TIFF_ASCII:\n        return DataType::DT_None;\n    case libtiff::TIFF_SHORT:\n        return DataType::DT_UInt16;\n    case libtiff::TIFF_SLONG8:\n    case libtiff::TIFF_SBYTE:\n        return DataType::DT_Int8;\n    case libtiff::TIFF_UNDEFINED:\n        return DataType::DT_Unknown;\n    case libtiff::TIFF_SSHORT:\n        return DataType::DT_Int16;\n    case libtiff::TIFF_SRATIONAL:\n        return DataType::DT_Unknown;\n    case libtiff::TIFF_FLOAT:\n        return DataType::DT_Float32;\n    case libtiff::TIFF_DOUBLE:\n        return DataType::DT_Float64;\n    case libtiff::TIFF_IFD:\n    case libtiff::TIFF_RATIONAL:\n    case libtiff::TIFF_IFD8:\n    default: ;\n        RAISE_RUNTIME_ERROR << \"Invalid tiff data type \" << dt;\n    }\n}\n\nlibtiff::TIFFDataType TIFFDataTypeFromDataType(DataType dt)\n{\n    switch (dt)\n    {\n    case DataType::DT_None:\n        return libtiff::TIFF_NOTYPE;\n    case DataType::DT_Byte:\n        return libtiff::TIFF_BYTE;\n    case DataType::DT_UInt16:\n        return libtiff::TIFF_SHORT;\n    case DataType::DT_Int8:\n        return libtiff::TIFF_SBYTE;\n    case DataType::DT_Unknown:\n        return libtiff::TIFF_UNDEFINED;\n    case DataType::DT_Int16:\n        return libtiff::TIFF_SSHORT;\n    case DataType::DT_Float32:\n        return libtiff::TIFF_FLOAT;\n    case DataType::DT_Float64:\n        return libtiff::TIFF_DOUBLE;\n    default:\n        RAISE_RUNTIME_ERROR << \"Invalid data type: \" << dt;\n    }\n}\n\nstatic Compression compressTiffToSlideio(int tiffCompression)\n{\n    Compression compression = Compression::Unknown;\n    switch(tiffCompression)\n    {\n    case 0x1:\n        compression = Compression::Uncompressed;\n        break;\n    case 0x2:\n        compression = Compression::HuffmanRL;\n        break;\n    case 0x3:\n        compression = Compression::CCITT_T4;\n        break;\n    case 0x4:\n        compression = Compression::CCITT_T6;\n        break;\n    case 0x5:\n        compression = Compression::LZW;\n        break;\n    case 0x6:\n        compression = Compression::JpegOld;\n        break;\n    case 0x7:\n        compression = Compression::Jpeg;\n        break;\n    case 0x8:\n        compression = Compression::Zlib;\n        break;\n    case 0x9:\n        compression = Compression::JBIG85;\n        break;\n    case 0xa:\n        compression = Compression::JBIG43;\n        break;\n    case 0x7ffe:\n        compression = Compression::NextRLE;\n        break;\n    case 0x8005:\n        compression = Compression::PackBits;\n        break;\n    case 0x8029:\n        compression = Compression::ThunderScanRLE;\n        break;\n    case 0x807f:\n        compression = Compression::RasterPadding;\n        break;\n    case 0x8080:\n        compression = Compression::RLE_LW;\n        break;\n    case 0x8081:\n        compression = Compression::RLE_HC;\n        break;\n    case 0x8082:\n        compression = Compression::RLE_BL;\n        break;\n    case 0x80b2:\n        compression = Compression::PKZIP;\n        break;\n    case 0x80b3:\n        compression = Compression::KodakDCS;\n        break;\n    case 0x8765:\n        compression = Compression::JBIG;\n        break;\n    case 0x8798:\n    case 0x80ED:\n    case 0x80EB:\n    case 0x80EA:\n        compression = Compression::Jpeg2000;\n        break;\n    case 0x8799:\n        compression = Compression::NikonNEF;\n        break;\n    case 0x879b:\n        compression = Compression::JBIG2;\n        break;\n    default:\n        RAISE_RUNTIME_ERROR << \"Invalid compression type: \" << tiffCompression;\n    }\n    return compression;\n}\n\nint compressSlideioToTiff(Compression compression)\n{\n    int tiffCompression = -1;\n    switch (compression)\n    {\n    case Compression::Uncompressed:\n        tiffCompression = 0x1;\n        break;\n    case Compression::HuffmanRL:\n        tiffCompression = 0x2;\n        break;\n    case Compression::CCITT_T4:\n        tiffCompression = 0x3;\n        break;\n    case Compression::CCITT_T6:\n        tiffCompression = 0x4;\n        break;\n    case Compression::LZW:\n        tiffCompression = 0x5;\n        break;\n    case Compression::JpegOld:\n        tiffCompression = 0x6;\n        break;\n    case Compression::Jpeg:\n        tiffCompression = 0x7;\n        break;\n    case Compression::Zlib:\n        tiffCompression = 0x8;\n        break;\n    case Compression::JBIG85:\n        tiffCompression = 0x9;\n        break;\n    case Compression::JBIG43:\n        tiffCompression = 0xa;\n        break;\n    case Compression::NextRLE:\n        tiffCompression = 0x7ffe;\n        break;\n    case Compression::PackBits:\n        tiffCompression = 0x8005;\n        break;\n    case Compression::ThunderScanRLE:\n        tiffCompression = 0x8029;\n        break;\n    case Compression::RasterPadding:\n        tiffCompression = 0x807f;\n        break;\n    case Compression::RLE_LW:\n        tiffCompression = 0x8080;\n        break;\n    case Compression::RLE_HC:\n        tiffCompression = 0x8081;\n        break;\n    case Compression::RLE_BL:\n        tiffCompression = 0x8082;\n        break;\n    case Compression::PKZIP:\n        tiffCompression = 0x80b2;\n        break;\n    case Compression::KodakDCS:\n        tiffCompression = 0x80b3;\n        break;\n    case Compression::JBIG:\n        tiffCompression = 0x8765;\n        break;\n    case Compression::Jpeg2000:\n        //tiffCompression = 0x8798;\n        tiffCompression = 33005;\n        break;\n    case Compression::NikonNEF:\n        tiffCompression = 0x8799;\n        break;\n    case Compression::JBIG2:\n        tiffCompression = 0x879b;\n        break;\n    default:\n        RAISE_RUNTIME_ERROR << \"Invalid compression type: \" << compression;\n    }\n    return tiffCompression;\n}\n\n//std::ostream& operator<<(std::ostream& os, const TiffDirectory& dir)\n//{\n//    os << \"---Tiff directory \" << dir.dirIndex << std::endl;\n//    os << \"width:\" << dir.width << std::endl;\n//    os << \"height:\" << dir.height << std::endl;\n//    os << \"tiled:\" << dir.tiled << std::endl;\n//    os << \"tileWidth:\" << dir.tileWidth << std::endl;\n//    os << \"tileHeight:\" << dir.tileHeight << std::endl;\n//    os << \"channels:\" << dir.channels << std::endl;\n//    os << \"bitsPerSample:\" << dir.bitsPerSample << std::endl;\n//    os << \"photometric:\" << dir.photometric << std::endl;\n//    os << \"YcbCrSubsampling:\" << dir.YCbCrSubsampling[0] << \",\" << dir.YCbCrSubsampling[1] << std::endl;\n//    os << \"compression:\" << dir.compression << std::endl;\n//    os << \"slideioCompression\" << dir.slideioCompression << std::endl;\n//    os << \"offset:\" << dir.offset << std::endl;\n//    os << \"description\" << dir.description << std::endl;\n//    os << \"Number of subdirectories:\" << dir.subdirectories.size() << std::endl;\n//    os << \"Resoulution:\" << dir.res.x << \",\" << dir.res.y << std::endl;\n//    os << \"interleaved:\" << dir.interleaved << std::endl;\n//    os << \"rowsPerStrip:\" << dir.rowsPerStrip << std::endl;\n//    os << \"dataType:\" << dir.dataType << std::endl;\n//    os << \"stripSize:\" << dir.stripSize << std::endl;\n//\n//    for(size_t subDirIndex=0; subDirIndex<dir.subdirectories.size(); ++subDirIndex) {\n//        os << \"--Sub-directory:\" << subDirIndex << std::endl;\n//        os << dir.subdirectories[subDirIndex];\n//    }\n//    return os;\n//}\n//\n//std::ostream& operator<<(std::ostream& os, const std::vector<TiffDirectory>& dirs) {\n//    os << \"---Tiff directories. Size:\" << dirs.size() << std::endl;\n//    std::vector<TiffDirectory>::const_iterator iDir;\n//    for (iDir = dirs.begin(); iDir != dirs.end(); ++iDir) {\n//        auto& dir = *iDir;\n//        os << dir;\n//    }\n//    return os;\n//}\n\nlibtiff::TIFF* TiffTools::openTiffFile(const std::string& path, bool readOnly)\n{\n    namespace fs = std::filesystem;\n    libtiff::TIFF* hfile(nullptr);\n#if defined(WIN32)\n    std::wstring wsPath = Tools::toWstring(path);\n    fs::path filePath(wsPath);\n    if (readOnly && !fs::exists(wsPath)) {\n        RAISE_RUNTIME_ERROR << \"File \" << path << \" does not exist\";\n    }\n    hfile = libtiff::TIFFOpenW(wsPath.c_str(), readOnly ? \"r\" : \"w\");\n#else\n    fs::path filePath(path);\n    if (readOnly && !fs::exists(filePath)) {\n        RAISE_RUNTIME_ERROR << \"File \" << path << \" does not exist\";\n    }\n    hfile = libtiff::TIFFOpen(path.c_str(),  readOnly ? \"r\" : \"w\");\n#endif\n    if(!hfile) {\n        RAISE_RUNTIME_ERROR << \"Cannot open file \" << path << \" for \" << (readOnly ? \"reading\" : \"writing.\");\n    }\n    SLIDEIO_LOG(INFO) << \"File \" << path << \" successfully opened for \" << (readOnly ? \"reading\" : \"writing\");\n    return hfile;\n}\n\nvoid TiffTools::closeTiffFile(libtiff::TIFF* file)\n{\n    if(file)\n        libtiff::TIFFClose(file);\n}\n\n\nstatic DataType retrieveTiffDataType(libtiff::TIFF* tiff)\n{\n    uint16_t bitsPerSample = 0;\n    uint16_t sampleFormat = 0;\n\n    DataType dataType = DataType::DT_Unknown;\n    if (!libtiff::TIFFGetField(tiff, TIFFTAG_BITSPERSAMPLE, &bitsPerSample)) {\n        RAISE_RUNTIME_ERROR << \"Cannot retrieve bits per sample from tiff image\";\n    }\n    if (!libtiff::TIFFGetField(tiff, TIFFTAG_SAMPLEFORMAT, &sampleFormat)) {\n        sampleFormat = SAMPLEFORMAT_UINT;\n    }\n\n    if (bitsPerSample == 8) {\n        if(sampleFormat == SAMPLEFORMAT_UINT) {\n            dataType = DataType::DT_Byte;\n        }\n        else if(sampleFormat == SAMPLEFORMAT_INT) {\n            dataType = DataType::DT_Int8;\n        }\n        else {\n            RAISE_RUNTIME_ERROR << \"Unsupported sample format for 8bit images: \" << sampleFormat;\n        }\n    }\n    else if (bitsPerSample == 16) {\n        if(sampleFormat == SAMPLEFORMAT_UINT) {\n            dataType = DataType::DT_UInt16;\n        }\n        else if (sampleFormat == SAMPLEFORMAT_INT) {\n            dataType = DataType::DT_Int16;\n        }\n        else if (sampleFormat == SAMPLEFORMAT_IEEEFP) {\n            dataType = DataType::DT_Float16;\n        }\n        else {\n            RAISE_RUNTIME_ERROR << \"Unsupported sample format for 16bit images: \" << sampleFormat;\n        }\n    }\n    else if (bitsPerSample == 32) {\n        if (sampleFormat == SAMPLEFORMAT_INT) {\n            dataType = DataType::DT_Int32;\n        }\n        else if (sampleFormat == SAMPLEFORMAT_IEEEFP) {\n            dataType = DataType::DT_Float32;\n        }\n        else {\n            RAISE_RUNTIME_ERROR << \"Unsupported sample format for 32bit images: \" << sampleFormat;\n        }\n    }\n    else if (bitsPerSample == 64) {\n        if (sampleFormat == SAMPLEFORMAT_IEEEFP) {\n            dataType = DataType::DT_Float64;\n        }\n        else {\n            RAISE_RUNTIME_ERROR << \"Unsupported sample format for 64bit images: \" << sampleFormat;\n        }\n    }\n    else {\n        RAISE_RUNTIME_ERROR << \"Unsupported bits per sample: \" << bitsPerSample;\n    }\n    return dataType;\n}\n\nstatic void setTiffDataType(libtiff::TIFF* tiff, DataType dataType)\n{\n    int sampleFormat = 0;\n    int bitsPerSample = 0;\n\n    switch (dataType)\n    {\n    case DataType::DT_Byte:\n        sampleFormat = SAMPLEFORMAT_UINT;\n        bitsPerSample = 8;\n        break;\n    case DataType::DT_Int8:\n        sampleFormat = SAMPLEFORMAT_INT;\n        bitsPerSample = 8;\n        break;\n    case DataType::DT_UInt16:\n        sampleFormat = SAMPLEFORMAT_UINT;\n        bitsPerSample = 16;\n        break;\n    case DataType::DT_Int16:\n        sampleFormat = SAMPLEFORMAT_INT;\n        bitsPerSample = 16;\n        break;\n    case DataType::DT_Float16:\n        sampleFormat = SAMPLEFORMAT_IEEEFP;\n        bitsPerSample = 16;\n        break;\n    case DataType::DT_Int32:\n        sampleFormat = SAMPLEFORMAT_INT;\n        bitsPerSample = 32;\n        break;\n    case DataType::DT_Float32:\n        sampleFormat = SAMPLEFORMAT_IEEEFP;\n        bitsPerSample = 32;\n        break;\n    case DataType::DT_Float64:\n        sampleFormat = SAMPLEFORMAT_IEEEFP;\n        bitsPerSample = 64;\n        break;\n    default:\n        RAISE_RUNTIME_ERROR << \"Unsupported data type: \" << dataType;\n        return;\n    }\n    // Set the TIFF tags\n    TIFFSetField(tiff, TIFFTAG_SAMPLEFORMAT, sampleFormat);\n    TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, bitsPerSample);\n}\n\nvoid  TiffTools::scanTiffDirTags(libtiff::TIFF* tiff, int dirIndex, int64_t dirOffset, TiffDirectory& dir)\n{\n    if (libtiff::TIFFCurrentDirectory(tiff) != dirIndex) {\n        libtiff::TIFFSetDirectory(tiff, (short)dirIndex);\n    }\n    if(dirOffset)\n        libtiff::TIFFSetSubDirectory(tiff, dirOffset);\n\n    dir.dirIndex = dirIndex;\n    dir.offset = dirOffset;\n    dir.compressionQuality = 0;\n\n    char *description(nullptr);\n    uint16_t dirchnls(0), dirbits(0);\n    uint16_t compress(0);\n    uint16_t  planar_config(0);\n    uint32_t width(0), height(0), tile_width(0), tile_height(0);\n    libtiff::TIFFGetField(tiff, TIFFTAG_SAMPLESPERPIXEL, &dirchnls);\n    libtiff::TIFFGetField(tiff, TIFFTAG_BITSPERSAMPLE, &dirbits);\n    libtiff::TIFFGetField(tiff, TIFFTAG_COMPRESSION, &compress);\n    libtiff::TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, &width);\n    libtiff::TIFFGetField(tiff, TIFFTAG_IMAGELENGTH, &height);\n    libtiff::TIFFGetField(tiff,TIFFTAG_TILEWIDTH ,&tile_width);\n    libtiff::TIFFGetField(tiff,TIFFTAG_TILELENGTH,&tile_height);\n    libtiff::TIFFGetField(tiff, TIFFTAG_IMAGEDESCRIPTION, &description);\n    libtiff::TIFFGetField(tiff, TIFFTAG_PLANARCONFIG ,&planar_config);\n    float resx(0), resy(0);\n    uint16_t units(0);\n    libtiff::TIFFGetField(tiff, TIFFTAG_XRESOLUTION, &resx);\n    libtiff::TIFFGetField(tiff, TIFFTAG_YRESOLUTION, &resy);\n    libtiff::TIFFGetField(tiff, TIFFTAG_RESOLUTIONUNIT, &units);\n    dir.interleaved = planar_config==PLANARCONFIG_CONTIG;\n    float posx(0), posy(0);\n    libtiff::TIFFGetField(tiff, TIFFTAG_XPOSITION, &posx);\n    libtiff::TIFFGetField(tiff, TIFFTAG_YPOSITION, &posy);\n    int32_t rowsPerStripe(0);\n    libtiff::TIFFGetField(tiff, TIFFTAG_ROWSPERSTRIP, &rowsPerStripe);\n    int32_t compressionQuality = 0;\n    libtiff::TIFFGetField(tiff, TIFFTAG_JPEGQUALITY, &compressionQuality);\n    uint16_t ph(0);\n    libtiff::TIFFGetField(tiff, TIFFTAG_PHOTOMETRIC, &ph);\n    dir.photometric = ph;\n    dir.stripSize = (int)libtiff::TIFFStripSize(tiff);\n    dir.dataType = retrieveTiffDataType(tiff);\n    uint16_t YCbCrSubsampling[2] = { 2,2 };\n    libtiff::TIFFGetField(tiff, TIFFTAG_YCBCRSUBSAMPLING, &YCbCrSubsampling[0], &YCbCrSubsampling[0]);\n    dir.YCbCrSubsampling[0] = YCbCrSubsampling[0];\n    dir.YCbCrSubsampling[1] = YCbCrSubsampling[1];\n\n    if(units==RESUNIT_INCH && resx>0 && resy>0){\n        dir.res.x = 0.01/resx;\n        dir.res.y = 0.01/resy;\n    }\n    else if(units==RESUNIT_INCH && resx>0 && resy>0){\n        dir.res.x = 0.0254/resx;\n        dir.res.y = 0.0254/resy;\n    }\n    else if (units == RESUNIT_CENTIMETER && resx > 0 && resy > 0) {\n        dir.res.x = 0.01 / resx;\n        dir.res.y = 0.01 / resy;\n    }\n    else {\n        dir.res.x = resx;\n        dir.res.y = resy;\n    }\n    dir.position = {posx, posy};\n    bool tiled = libtiff::TIFFIsTiled(tiff);\n    if(description)\n        dir.description = description;\n    dir.bitsPerSample = dirbits;\n    dir.channels = dirchnls;\n    dir.height = height;\n    dir.width = width;\n    dir.tileHeight = tile_height;\n    dir.tileWidth = tile_width;\n    dir.tiled = tiled;\n    dir.compression = compress;\n    dir.rowsPerStrip = rowsPerStripe;\n    dir.slideioCompression = compressTiffToSlideio(compress);\n    dir.compressionQuality = compressionQuality;\n\n\n}\n\nvoid TiffTools::scanTiffDir(libtiff::TIFF* tiff, int dirIndex, int64_t dirOffset, TiffDirectory& dir)\n{\n    if(libtiff::TIFFCurrentDirectory(tiff) != dirIndex) {\n        libtiff::TIFFSetDirectory(tiff, (short)dirIndex);\n    }\n    if(dirOffset>0)\n        libtiff::TIFFSetSubDirectory(tiff, dirOffset);\n\n    dir.dirIndex = dirIndex;\n    dir.offset = dirOffset;\n\n    scanTiffDirTags(tiff, dirIndex, dirOffset, dir);\n    dir.offset = 0;\n    long subdirs(0);\n    int64 *offsets_raw(nullptr);\n    if(libtiff::TIFFGetField(tiff, TIFFTAG_SUBIFD, &subdirs, &offsets_raw))\n    {\n        std::vector<int64> offsets(offsets_raw, offsets_raw+subdirs);\n        if(subdirs>0)\n        {\n            dir.subdirectories.resize(subdirs);\n        }\n        for(int subdir=0; subdir<subdirs; subdir++)\n        {\n            if(libtiff::TIFFSetSubDirectory(tiff, offsets[subdir]))\n            {\n                scanTiffDirTags(tiff, dirIndex, dir.subdirectories[subdir].offset, dir.subdirectories[subdir]);\n            }\n        }\n    }\n}\n\nvoid TiffTools::scanFile(libtiff::TIFF* tiff, std::vector<TiffDirectory>& directories)\n{\n    int dirs = libtiff::TIFFNumberOfDirectories(tiff);\n    directories.resize(dirs);\n    for(int dir=0; dir<dirs; dir++)\n    {\n        directories[dir].dirIndex = dir;\n        scanTiffDir(tiff, dir, 0, directories[dir]);\n    }\n}\n\nvoid TiffTools::scanFile(const std::string& filePath, std::vector<TiffDirectory>& directories)\n{\n    libtiff::TIFF* file(nullptr);\n    try\n    {\n        file = openTiffFile(filePath);\n        if(file==nullptr)\n            throw std::runtime_error(std::string(\"TiffTools: cannot open tiff file\") + filePath);\n        scanFile(file, directories);\n    }\n    catch(std::exception& ex)\n    {\n        if(file)\n            closeTiffFile(file);\n        throw ex;\n    }\n    if(file)\n        closeTiffFile(file);\n}\n\nvoid TiffTools::readNotRGBStripedDir(libtiff::TIFF* file, const TiffDirectory& dir, cv::_OutputArray output)\n{\n    std::vector<uint8_t> rgbaRaster(4 * dir.rowsPerStrip * dir.width);\n\n    int buff_size = dir.width * dir.height * dir.channels * Tools::dataTypeSize(dir.dataType);\n    cv::Size sizeImage = { dir.width, dir.height };\n    DataType dt = dir.dataType;\n    output.create(sizeImage, CV_MAKETYPE(CVTools::toOpencvType(dt), dir.channels));\n    cv::Mat imageRaster = output.getMat();\n    setCurrentDirectory(file, dir);\n    if (dir.offset > 0) {\n        libtiff::TIFFSetSubDirectory(file, dir.offset);\n    }\n    uint8_t* buffBegin = imageRaster.data;\n    int stripBuffSize = dir.stripSize;\n    const int imageWidth3 = dir.width * 3;\n    const int imageWidth4 = dir.width * 4;\n\n    for (int strip = 0, row = 0; row < dir.height; strip++, row += dir.rowsPerStrip, buffBegin += stripBuffSize)\n    {\n        if ((strip + stripBuffSize) > buff_size)\n            stripBuffSize = buff_size - strip;\n\n            int stripeRows = dir.rowsPerStrip;\n            if (row + stripeRows > dir.height) {\n                stripeRows = dir.height - row;\n            }\n\n            int read = libtiff::TIFFReadRGBAStrip(file, row, (uint32_t*)rgbaRaster.data());\n            if (read != 1) {\n                throw std::runtime_error(\"TiffTools: Error by reading of tif strip\");\n            }\n            uint8_t* lineBegin = buffBegin;\n            uint8_t* stripeLineBegin = rgbaRaster.data();\n            for (int stripeRow = 0; stripeRow < stripeRows; ++stripeRow) {\n                uint8_t* pixelBegin = lineBegin;\n                uint8_t* stripePixelBegin = stripeLineBegin;\n                for (int column = 0; column < dir.width; ++column, pixelBegin += 3, stripePixelBegin += 4) {\n                    memcpy(pixelBegin, stripePixelBegin, 3);\n                }\n                lineBegin += imageWidth3;\n                stripeLineBegin += imageWidth4;\n            }\n    }\n}\n\nvoid TiffTools::readRegularStripedDir(libtiff::TIFF* file, const TiffDirectory& dir, cv::OutputArray output)\n{\n\n    int buff_size = dir.width * dir.height * dir.channels * Tools::dataTypeSize(dir.dataType);\n    cv::Size sizeImage = { dir.width, dir.height };\n    DataType dt = dir.dataType;\n    output.create(sizeImage, CV_MAKETYPE(CVTools::toOpencvType(dt), dir.channels));\n    cv::Mat imageRaster = output.getMat();\n    setCurrentDirectory(file, dir);\n    if (dir.offset > 0) {\n        libtiff::TIFFSetSubDirectory(file, dir.offset);\n    }\n    uint8_t* buffBegin = imageRaster.data;\n    int stripBuffSize = dir.stripSize;\n\n    for (int strip = 0, row = 0; row < dir.height; strip++, row += dir.rowsPerStrip, buffBegin += stripBuffSize)\n    {\n        if ((strip + stripBuffSize) > buff_size)\n            stripBuffSize = buff_size - strip;\n\n        int read = (int)libtiff::TIFFReadEncodedStrip(file, strip, buffBegin, stripBuffSize);\n        if (read <= 0) {\n            throw std::runtime_error(\"TiffTools: Error by reading of tif strip\");\n        }\n    }\n    return;\n}\n\n\nvoid TiffTools::readStripedDir(libtiff::TIFF* file, const TiffDirectory& dir, cv::OutputArray output)\n{\n    if(!dir.interleaved)\n        throw std::runtime_error(\"Planar striped images are not supported\");\n\n    std::vector<uint8_t> rgbaRaster;\n    bool notRGB = dir.photometric == 6 || dir.photometric == 8 || dir.photometric == 9 || dir.photometric == 10;\n    if (notRGB) {\n        readNotRGBStripedDir(file, dir, output);\n    }\n    else {\n        readRegularStripedDir(file, dir, output);\n    }\n\n    return;\n}\n\n\nvoid TiffTools::readTile(libtiff::TIFF* hFile, const TiffDirectory& dir, int tile,\n    const std::vector<int>& channelIndices, cv::OutputArray output)\n{\n    if(!dir.tiled){\n        throw std::runtime_error(\"TiffTools: Expected tiled configuration, received striped\");\n    }\n    setCurrentDirectory(hFile, dir);\n\n    if(dir.compression==34712 || dir.compression==33003 || dir.compression == 33005)\n    {\n        readJ2KTile(hFile, dir, tile, channelIndices, output);\n    }\n    else if(dir.photometric==6 || dir.photometric==8 || dir.photometric==9 || dir.photometric==10)\n    {\n        readNotRGBTile(hFile, dir, tile, channelIndices, output);\n    }\n    else\n    {\n        readRegularTile(hFile, dir, tile, channelIndices, output);\n    }\n}\n\nvoid TiffTools::readRegularTile(libtiff::TIFF* hFile, const TiffDirectory& dir, int tile,\n            const std::vector<int>& channelIndices, cv::OutputArray output)\n{\n    cv::Size tileSize = { dir.tileWidth, dir.tileHeight };\n    DataType dt = dir.dataType;\n    cv::Mat tileRaster;\n    tileRaster.create(tileSize, CV_MAKETYPE(CVTools::toOpencvType(dt), dir.channels));\n    setCurrentDirectory(hFile, dir);\n    if (dir.offset > 0) {\n        libtiff::TIFFSetSubDirectory(hFile, dir.offset);\n    }\n    // if(dir.compression==7) {\n    //     std::vector<uint8_t> buff(libtiff::TIFFTileSize(hFile));\n    //     int64_t size = libtiff::TIFFReadRawTile(hFile, tile, buff.data(), buff.size());\n    //     buff.resize(size);\n    //     ImageTools::decodeJpegStream(buff.data(), buff.size(), tileRaster);\n    // }\n    else \n    {\n        uint8_t* buff_begin = tileRaster.data;\n        auto buf_size = tileRaster.total() * tileRaster.elemSize();\n        auto readBytes = libtiff::TIFFReadEncodedTile(hFile, tile, buff_begin, buf_size);\n        if (readBytes <= 0){\n            RAISE_RUNTIME_ERROR << \"TiffTools: Error reading encoded tiff tile \"\n                << tile << \" of directory \" << dir.dirIndex << \". Compression: \" << dir.compression;\n        }\n    }\n    if(channelIndices.empty() || (channelIndices.size() == 1 && dir.channels==1))\n    {\n        tileRaster.copyTo(output);\n    }\n    else if(channelIndices.size()==1)\n    {\n        cv::extractChannel(tileRaster, output, channelIndices[0]);\n    }\n    else\n    {\n        std::vector<cv::Mat> channelRasters;\n        channelRasters.resize(channelIndices.size());\n        for(int channelIndex : channelIndices)\n        {\n            cv::extractChannel(tileRaster, channelRasters[channelIndex], channelIndices[channelIndex]);\n        }\n        cv::merge(channelRasters, output);\n    }\n}\n\n\nvoid TiffTools::readJ2KTile(libtiff::TIFF* hFile, const TiffDirectory& dir, int tile,\n                                     const std::vector<int>& channelIndices, cv::OutputArray output)\n{\n    const auto tileSize = libtiff::TIFFTileSize(hFile);\n    std::vector<uint8_t> rawTile(tileSize);\n    if(dir.interleaved || dir.channels == 1)\n    {\n        // process interleaved channels\n        libtiff::tmsize_t readBytes = libtiff::TIFFReadRawTile(hFile, tile, rawTile.data(), (int)rawTile.size());\n        if(readBytes<=0){\n            throw std::runtime_error(\"TiffTools: Error reading raw tile\");\n        }\n        bool yuv = dir.channels==3 && dir.compression==33003;\n        ImageTools::decodeJp2KStream(rawTile, output, channelIndices, yuv);\n    }\n    else\n    {\n        throw std::runtime_error(\"Not implemented\");\n    }\n}\n\nvoid TiffTools::readNotRGBTile(libtiff::TIFF* hFile, const TiffDirectory& dir, int tile,\n    const std::vector<int>& channelIndices, cv::OutputArray output)\n{\n    cv::Size tileSize = { dir.tileWidth, dir.tileHeight };\n    DataType dt = dir.dataType;\n    cv::Mat tileRaster;\n    tileRaster.create(tileSize, CV_MAKETYPE(CVTools::toOpencvType(dt), 4));\n    setCurrentDirectory(hFile, dir);\n    uint32_t* buffBegin = reinterpret_cast<uint32_t*>(tileRaster.data);\n\n    int cols = (dir.width - 1) / dir.tileWidth + 1;\n    int rows = (dir.height - 1) / dir.tileHeight + 1;\n    int row = tile / cols;\n    int col = tile - row * cols;\n    int tileX = col * dir.tileWidth;\n    int tileY = row * dir.tileHeight;\n    SLIDEIO_LOG(INFO) << \"TiffTools::readNotRGBTile: Reading tile \" << tile \n        << \" from directory:\" << dir.dirIndex << \" at position \" << tileX << \",\" << tileY;\n    auto readBytes = libtiff::TIFFReadRGBATile(hFile, tileX, tileY, buffBegin);\n    if (readBytes <= 0) {\n        RAISE_RUNTIME_ERROR << \"TiffTools: Error reading encoded tiff tile \"\n            << tile << \" of directory \" << dir.dirIndex << \". Compression: \" << dir.compression;\n    }\n\n    std::vector<int> channelMapping = { 0, 1, 2, 3 };\n    if(!Endian::isLittleEndian()) {\n        std::reverse(channelMapping.begin(), channelMapping.end());\n    }\n    cv::Mat flipped;\n\n    if (channelIndices.empty())\n    {\n        std::vector<cv::Mat> channelRasters;\n        channelRasters.resize(3);\n        for (int channelIndex=0; channelIndex<3; ++channelIndex)\n        {\n            const int correctedIndex = channelMapping[channelIndex]; // correct the channel index for big endian\n            cv::extractChannel(tileRaster, channelRasters[channelIndex], correctedIndex);\n        }\n        cv::merge(channelRasters, flipped);\n    }\n    else if (channelIndices.size() == 1)\n    {\n        const int correctedIndex = channelMapping[channelIndices[0]]; // correct the channel index for big endian\n        cv::extractChannel(tileRaster, flipped, correctedIndex);\n    }\n    else\n    {\n        std::vector<cv::Mat> channelRasters;\n        channelRasters.resize(channelIndices.size());\n        for (int channelIndex : channelIndices)\n        {\n            const int correctedIndex = channelMapping[channelIndices[channelIndex]]; // correct the channel index for big endian\n            cv::extractChannel(tileRaster, channelRasters[channelIndex], correctedIndex);\n        }\n        cv::merge(channelRasters, flipped);\n    }\n    cv::flip(flipped, output, 0);\n}\n\nvoid TiffTools::writeDirectory(libtiff::TIFF* tiff)\n{\n    libtiff::TIFFWriteDirectory(tiff);\n}\n\ninline uint16_t bitsPerSampleDataType(DataType dt)\n{\n    int ds = Tools::dataTypeSize(dt);\n    return (uint16_t)(ds * 8);\n}\n\nuint16_t computeDirectoryPhotometric(TiffDirectory dir)\n{\n    const DataType dt = dir.dataType;\n    const int numChannels = dir.channels;\n    uint16_t photometric = PHOTOMETRIC_SEPARATED;\n    if(dt==DataType::DT_Byte && numChannels==3) {\n        photometric = PHOTOMETRIC_RGB;\n    }\n    return photometric;\n}\n\n\nvoid TiffTools::setTags(libtiff::TIFF* tiff, const TiffDirectory& dir, bool newDirectory)\n{\n    if(newDirectory) {\n        writeDirectory(tiff);\n    }\n\n    const uint16_t numChannels = (uint16_t)dir.channels;\n    libtiff::TIFFSetField(tiff, TIFFTAG_SAMPLESPERPIXEL, numChannels);\n    const uint16_t bitsPerSample = bitsPerSampleDataType(dir.dataType);\n    libtiff::TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, bitsPerSample);\n    const uint16_t compression = compressSlideioToTiff(dir.slideioCompression);\n    libtiff::TIFFSetField(tiff, TIFFTAG_COMPRESSION, compression);\n    libtiff::TIFFSetField(tiff, TIFFTAG_IMAGEWIDTH, dir.width);\n    libtiff::TIFFSetField(tiff, TIFFTAG_IMAGELENGTH, dir.height);\n    libtiff::TIFFSetField(tiff, TIFFTAG_TILEWIDTH, dir.tileWidth);\n    libtiff::TIFFSetField(tiff, TIFFTAG_TILELENGTH, dir.tileHeight);;\n    libtiff::TIFFSetField(tiff, TIFFTAG_IMAGEDESCRIPTION, dir.description.c_str());\n    libtiff::TIFFSetField(tiff, TIFFTAG_PLANARCONFIG, ((numChannels==1)?2:1));\n    auto res = dir.res;\n    libtiff::TIFFSetField(tiff, TIFFTAG_XRESOLUTION, (float)res.x);\n    libtiff::TIFFSetField(tiff, TIFFTAG_YRESOLUTION, (float)res.y);\n    libtiff::TIFFSetField(tiff, TIFFTAG_RESOLUTIONUNIT, 1);\n    libtiff::TIFFSetField(tiff, TIFFTAG_XPOSITION, 0);\n    libtiff::TIFFSetField(tiff, TIFFTAG_YPOSITION, 0);\n    setTiffDataType(tiff, dir.dataType);\n    uint16_t phm = computeDirectoryPhotometric(dir);\n    libtiff::TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, phm);\n    libtiff::TIFFSetField(tiff, TIFFTAG_JPEGQUALITY, dir.compressionQuality);\n}\n\nvoid TiffTools::writeTile(libtiff::TIFF* tiff, int x, int y, Compression compression, \n                        const cv::Mat& tileRaster, const EncodeParameters& parameters,\n                        uint8_t* buffer, int bufferSize)\n{\n    if(compression==Compression::Jpeg) {\n        const uint32_t tile = libtiff::TIFFComputeTile(tiff, x, y, 0, 0);\n        const size_t dataSize = tileRaster.total() * tileRaster.elemSize();\n        const int64_t written = libtiff::TIFFWriteEncodedTile(tiff, tile, tileRaster.data, dataSize);\n        if ((int64_t)dataSize != written) {\n            RAISE_RUNTIME_ERROR << \"Error by writing tiff tile\";\n        }\n    }\n    else if(compression==Compression::Jpeg2000) {\n        const uint32_t tile = libtiff::TIFFComputeTile(tiff, x, y, 0, 0);\n        std::vector<uint8_t> buff;\n        if(buffer==nullptr || bufferSize<=0) {\n            const size_t dataSize = tileRaster.total() * tileRaster.elemSize();\n            buff.resize(dataSize);\n            buffer = buff.data();\n            bufferSize = (int)dataSize;\n        }\n        const JP2KEncodeParameters& jp2param = \n            static_cast<const JP2KEncodeParameters &>(parameters);\n        int dataSize = ImageTools::encodeJp2KStream(tileRaster, buffer, bufferSize, jp2param);\n        if(dataSize <= 0) {\n            RAISE_RUNTIME_ERROR << \"JPEG 2000 Encoding failed\";\n        }\n        libtiff::TIFFWriteRawTile(tiff, tile, buffer, dataSize);\n    }\n    else {\n        RAISE_RUNTIME_ERROR << \"Unsupported compression: \" << compression;\n    }\n    // uint32_t tile = libtiff::TIFFComputeTile(tiff, x, y, 0, 0);\n    // int64_t written = libtiff::TIFFWriteRawTile(tiff, tile, encodedStream.data(), encodedStream.size());\n    // if((int64_t)encodedStream.size() != written) {\n    //      RAISE_RUNTIME_ERROR << \"Error by writing tiff tile\";\n    //}\n}\n\nstd::string TiffTools::readStringTag(libtiff::TIFF* tiff, uint16_t tag)\n{\n    std::string result;\n    char* value = nullptr;\n    if (libtiff::TIFFGetField(tiff, tag, &value)) {\n               result = value;\n    }\n    return result;  \n}\n\nint TiffTools::getNumberOfDirectories(libtiff::TIFF* tiff) {\n\treturn libtiff::TIFFNumberOfDirectories(tiff);\n}\n\n\nvoid TiffTools::setCurrentDirectory(libtiff::TIFF* hFile, const TiffDirectory& dir)\n{\n    if(libtiff::TIFFCurrentDirectory(hFile) != static_cast<uint16_t>(dir.dirIndex)) {\n        if (!libtiff::TIFFSetDirectory(hFile, static_cast<uint16_t>(dir.dirIndex))) {\n            throw std::runtime_error(\"TiffTools: error by setting current directory\");\n        }\n    }\n    if(dir.offset>0){\n        if(!libtiff::TIFFSetSubDirectory(hFile, dir.offset)){\n            throw std::runtime_error(\"TiffTools: error by setting current sub-directory\");\n        }\n    }\n}\n\nvoid TiffTools::scaleBlockToDirectory(const TiffDirectory& basisDir,  const TiffDirectory& dir, const cv::Rect& basisDirRect, cv::Rect& dirBlockRect)\n{\n    RAISE_RUNTIME_ERROR << \"Not tested\";\n    // scale coefficients to scale original image to the directory image\n    const double zoomImageToDirX = static_cast<double>(dir.width) / static_cast<double>(dir.width);\n    const double zoomImageToDirY = static_cast<double>(dir.height) / static_cast<double>(dir.height);\n\n    // rectangle on the directory zoom level\n    dirBlockRect.x = static_cast<int>(std::floor(static_cast<double>(basisDirRect.x) * zoomImageToDirX));\n    dirBlockRect.y = static_cast<int>(std::floor(static_cast<double>(basisDirRect.y) * zoomImageToDirY));\n    int xn = basisDirRect.x + basisDirRect.width;\n    int yn = basisDirRect.y + basisDirRect.height;\n    int dxn = static_cast<int>(std::ceil(static_cast<double>(xn) * zoomImageToDirX));\n    int dyn = static_cast<int>(std::ceil(static_cast<double>(yn) * zoomImageToDirY));\n    dirBlockRect.width = dxn - dirBlockRect.x;\n    dirBlockRect.height = dyn - dirBlockRect.y;\n}\n",
                "name": "tifftools.cpp",
                "path": "src/slideio/imagetools/tifftools.cpp",
                "url": "/github.com/Booritas/slideio/-/blob/src/slideio/imagetools/tifftools.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 774,
                    "offsetAndLengths": [
                        [
                            30,
                            16
                        ]
                    ],
                    "preview": "    auto readBytes = libtiff::TIFFReadRGBATile(hFile, tileX, tileY, buffBegin);"
                }
            ],
            "repository": {
                "name": "github.com/Booritas/slideio",
                "url": "/github.com/Booritas/slideio"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "437e5578fdb8273f21d43c84191d63d7aa181b11"
                },
                "content": "/*M///////////////////////////////////////////////////////////////////////////////////////\n//\n//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.\n//\n//  By downloading, copying, installing or using the software you agree to this license.\n//  If you do not agree to this license, do not download, install,\n//  copy or use the software.\n//\n//\n//                           License Agreement\n//                For Open Source Computer Vision Library\n//\n// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.\n// Copyright (C) 2009, Willow Garage Inc., all rights reserved.\n// Third party copyrights are property of their respective owners.\n//\n// Redistribution and use in source and binary forms, with or without modification,\n// are permitted provided that the following conditions are met:\n//\n//   * Redistribution's of source code must retain the above copyright notice,\n//     this list of conditions and the following disclaimer.\n//\n//   * Redistribution's in binary form must reproduce the above copyright notice,\n//     this list of conditions and the following disclaimer in the documentation\n//     and/or other materials provided with the distribution.\n//\n//   * The name of the copyright holders may not be used to endorse or promote products\n//     derived from this software without specific prior written permission.\n//\n// This software is provided by the copyright holders and contributors \"as is\" and\n// any express or implied warranties, including, but not limited to, the implied\n// warranties of merchantability and fitness for a particular purpose are disclaimed.\n// In no event shall the Intel Corporation or contributors be liable for any direct,\n// indirect, incidental, special, exemplary, or consequential damages\n// (including, but not limited to, procurement of substitute goods or services;\n// loss of use, data, or profits; or business interruption) however caused\n// and on any theory of liability, whether in contract, strict liability,\n// or tort (including negligence or otherwise) arising in any way out of\n// the use of this software, even if advised of the possibility of such damage.\n//\n//M*/\n\n/****************************************************************************************\\\n    A part of the file implements TIFF reader on base of libtiff library\n    (see otherlibs/_graphics/readme.txt for copyright notice)\n\\****************************************************************************************/\n\n#include \"precomp.hpp\"\n\n#ifdef HAVE_TIFF\n#include <opencv2/core/utils/logger.hpp>\n\n#include \"grfmt_tiff.hpp\"\n#include <limits>\n\n// TODO FIXIT Conflict declarations for common types like int64/uint64\nnamespace tiff_dummy_namespace {\n#include \"tiff.h\"\n#include \"tiffio.h\"\n}\nusing namespace tiff_dummy_namespace;\n\nnamespace cv\n{\n\n#define CV_TIFF_CHECK_CALL(call) \\\n    if (0 == (call)) { \\\n        CV_LOG_WARNING(NULL, \"OpenCV TIFF(line \" << __LINE__ << \"): failed \" #call); \\\n        CV_Error(Error::StsError, \"OpenCV TIFF: failed \" #call); \\\n    }\n\n#define CV_TIFF_CHECK_CALL_INFO(call) \\\n    if (0 == (call)) { \\\n        CV_LOG_INFO(NULL, \"OpenCV TIFF(line \" << __LINE__ << \"): failed optional call: \" #call \", ignoring\"); \\\n    }\n\n#define CV_TIFF_CHECK_CALL_DEBUG(call) \\\n    if (0 == (call)) { \\\n        CV_LOG_DEBUG(NULL, \"OpenCV TIFF(line \" << __LINE__ << \"): failed optional call: \" #call \", ignoring\"); \\\n    }\n\nstatic void cv_tiffCloseHandle(void* handle)\n{\n    TIFFClose((TIFF*)handle);\n}\n\nstatic void cv_tiffErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    if (cv::utils::logging::getLogLevel() < cv::utils::logging::LOG_LEVEL_DEBUG)\n        return;\n    // TODO cv::vformat() with va_list parameter\n    fprintf(stderr, \"OpenCV TIFF: \");\n    if (module != NULL)\n        fprintf(stderr, \"%s: \", module);\n    fprintf(stderr, \"Warning, \");\n    vfprintf(stderr, fmt, ap);\n    fprintf(stderr, \".\\n\");\n}\n\nstatic bool cv_tiffSetErrorHandler_()\n{\n    TIFFSetErrorHandler(cv_tiffErrorHandler);\n    TIFFSetWarningHandler(cv_tiffErrorHandler);\n    return true;\n}\n\nstatic bool cv_tiffSetErrorHandler()\n{\n    static bool v = cv_tiffSetErrorHandler_();\n    return v;\n}\n\nstatic const char fmtSignTiffII[] = \"II\\x2a\\x00\";\nstatic const char fmtSignTiffMM[] = \"MM\\x00\\x2a\";\n\nTiffDecoder::TiffDecoder()\n{\n    m_hdr = false;\n    m_buf_supported = true;\n    m_buf_pos = 0;\n}\n\n\nvoid TiffDecoder::close()\n{\n    m_tif.release();\n}\n\nTiffDecoder::~TiffDecoder()\n{\n    close();\n}\n\nsize_t TiffDecoder::signatureLength() const\n{\n    return 4;\n}\n\nbool TiffDecoder::checkSignature( const String& signature ) const\n{\n    return signature.size() >= 4 &&\n        (memcmp(signature.c_str(), fmtSignTiffII, 4) == 0 ||\n        memcmp(signature.c_str(), fmtSignTiffMM, 4) == 0);\n}\n\nint TiffDecoder::normalizeChannelsNumber(int channels) const\n{\n    CV_Assert(channels <= 4);\n    return channels > 4 ? 4 : channels;\n}\n\nImageDecoder TiffDecoder::newDecoder() const\n{\n    cv_tiffSetErrorHandler();\n    return makePtr<TiffDecoder>();\n}\n\nclass TiffDecoderBufHelper\n{\n    Mat& m_buf;\n    size_t& m_buf_pos;\npublic:\n    TiffDecoderBufHelper(Mat& buf, size_t& buf_pos) :\n        m_buf(buf), m_buf_pos(buf_pos)\n    {}\n    static tmsize_t read( thandle_t handle, void* buffer, tmsize_t n )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        const Mat& buf = helper->m_buf;\n        const tmsize_t size = buf.cols*buf.rows*buf.elemSize();\n        tmsize_t pos = helper->m_buf_pos;\n        if ( n > (size - pos) )\n        {\n            n = size - pos;\n        }\n        memcpy(buffer, buf.ptr() + pos, n);\n        helper->m_buf_pos += n;\n        return n;\n    }\n\n    static tmsize_t write( thandle_t /*handle*/, void* /*buffer*/, tmsize_t /*n*/ )\n    {\n        // Not used for decoding.\n        return 0;\n    }\n\n    static toff_t seek( thandle_t handle, toff_t offset, int whence )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        const Mat& buf = helper->m_buf;\n        const toff_t size = buf.cols*buf.rows*buf.elemSize();\n        toff_t new_pos = helper->m_buf_pos;\n        switch (whence)\n        {\n            case SEEK_SET:\n                new_pos = offset;\n                break;\n            case SEEK_CUR:\n                new_pos += offset;\n                break;\n            case SEEK_END:\n                new_pos = size + offset;\n                break;\n        }\n        new_pos = std::min(new_pos, size);\n        helper->m_buf_pos = (size_t)new_pos;\n        return new_pos;\n    }\n\n    static int map( thandle_t handle, void** base, toff_t* size )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        Mat& buf = helper->m_buf;\n        *base = buf.ptr();\n        *size = buf.cols*buf.rows*buf.elemSize();\n        return 0;\n    }\n\n    static toff_t size( thandle_t handle )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        const Mat& buf = helper->m_buf;\n        return buf.cols*buf.rows*buf.elemSize();\n    }\n\n    static int close( thandle_t handle )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        delete helper;\n        return 0;\n    }\n};\n\nbool TiffDecoder::readHeader()\n{\n    bool result = false;\n\n    TIFF* tif = static_cast<TIFF*>(m_tif.get());\n    if (!tif)\n    {\n        // TIFFOpen() mode flags are different to fopen().  A 'b' in mode \"rb\" has no effect when reading.\n        // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n        if ( !m_buf.empty() )\n        {\n            m_buf_pos = 0;\n            TiffDecoderBufHelper* buf_helper = new TiffDecoderBufHelper(this->m_buf, this->m_buf_pos);\n            tif = TIFFClientOpen( \"\", \"r\", reinterpret_cast<thandle_t>(buf_helper), &TiffDecoderBufHelper::read,\n                                  &TiffDecoderBufHelper::write, &TiffDecoderBufHelper::seek,\n                                  &TiffDecoderBufHelper::close, &TiffDecoderBufHelper::size,\n                                  &TiffDecoderBufHelper::map, /*unmap=*/0 );\n            if (!tif)\n                delete buf_helper;\n        }\n        else\n        {\n            tif = TIFFOpen(m_filename.c_str(), \"r\");\n        }\n        if (tif)\n            m_tif.reset(tif, cv_tiffCloseHandle);\n        else\n            m_tif.release();\n    }\n\n    if (tif)\n    {\n        uint32 wdth = 0, hght = 0;\n        uint16 photometric = 0;\n\n        CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &wdth));\n        CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &hght));\n        CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric));\n\n        {\n            bool isGrayScale = photometric == PHOTOMETRIC_MINISWHITE || photometric == PHOTOMETRIC_MINISBLACK;\n            uint16 bpp = 8, ncn = isGrayScale ? 1 : 3;\n            if (0 == TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bpp))\n            {\n                // TIFF bi-level images don't require TIFFTAG_BITSPERSAMPLE tag\n                bpp = 1;\n            }\n            CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &ncn));\n\n            m_width = wdth;\n            m_height = hght;\n            if (ncn == 3 && photometric == PHOTOMETRIC_LOGLUV)\n            {\n                m_type = CV_32FC3;\n                m_hdr = true;\n                return true;\n            }\n            m_hdr = false;\n\n            if( bpp > 8 &&\n               ((photometric > 2) ||\n                (ncn != 1 && ncn != 3 && ncn != 4)))\n                bpp = 8;\n\n            int wanted_channels = normalizeChannelsNumber(ncn);\n            switch(bpp)\n            {\n                case 1:\n                    m_type = CV_MAKETYPE(CV_8U, !isGrayScale ? wanted_channels : 1);\n                    result = true;\n                    break;\n                case 8:\n                    m_type = CV_MAKETYPE(CV_8U, !isGrayScale ? wanted_channels : 1);\n                    result = true;\n                    break;\n                case 16:\n                    m_type = CV_MAKETYPE(CV_16U, !isGrayScale ? wanted_channels : 1);\n                    result = true;\n                    break;\n                case 32:\n                    m_type = CV_MAKETYPE(CV_32F, wanted_channels);\n                    result = true;\n                    break;\n                case 64:\n                    m_type = CV_MAKETYPE(CV_64F, wanted_channels);\n                    result = true;\n                    break;\n            default:\n                CV_Error(cv::Error::StsError, \"Invalid bitsperpixel value read from TIFF header! Must be 1, 8, 16, 32 or 64.\");\n            }\n        }\n    }\n\n    if( !result )\n        close();\n\n    return result;\n}\n\nbool TiffDecoder::nextPage()\n{\n    // Prepare the next page, if any.\n    return !m_tif.empty() &&\n           TIFFReadDirectory(static_cast<TIFF*>(m_tif.get())) &&\n           readHeader();\n}\n\nstatic void fixOrientationPartial(Mat &img, uint16 orientation)\n{\n    switch(orientation) {\n        case ORIENTATION_RIGHTTOP:\n        case ORIENTATION_LEFTBOT:\n            flip(img, img, -1);\n            /* fall through */\n\n        case ORIENTATION_LEFTTOP:\n        case ORIENTATION_RIGHTBOT:\n            transpose(img, img);\n            break;\n    }\n}\n\nstatic void fixOrientationFull(Mat &img, int orientation)\n{\n    switch(orientation) {\n        case ORIENTATION_TOPRIGHT:\n            flip(img, img, 1);\n            break;\n\n        case ORIENTATION_BOTRIGHT:\n            flip(img, img, -1);\n            break;\n\n        case ORIENTATION_BOTLEFT:\n            flip(img, img, 0);\n            break;\n\n        case ORIENTATION_LEFTTOP:\n            transpose(img, img);\n            break;\n\n        case ORIENTATION_RIGHTTOP:\n            transpose(img, img);\n            flip(img, img, 1);\n            break;\n\n        case ORIENTATION_RIGHTBOT:\n            transpose(img, img);\n            flip(img, img, -1);\n            break;\n\n        case ORIENTATION_LEFTBOT:\n            transpose(img, img);\n            flip(img, img, 0);\n            break;\n    }\n}\n\n/**\n * Fix orientation defined in tag 274.\n * For 8 bit some corrections are done by TIFFReadRGBAStrip/Tile already.\n * Not so for 16/32/64 bit.\n */\nstatic void fixOrientation(Mat &img, uint16 orientation, int dst_bpp)\n{\n    switch(dst_bpp) {\n        case 8:\n            fixOrientationPartial(img, orientation);\n            break;\n\n        case 16:\n        case 32:\n        case 64:\n            fixOrientationFull(img, orientation);\n            break;\n    }\n}\n\nbool  TiffDecoder::readData( Mat& img )\n{\n    int type = img.type();\n    int depth = CV_MAT_DEPTH(type);\n\n    CV_Assert(!m_tif.empty());\n    TIFF* tif = (TIFF*)m_tif.get();\n\n    uint16 photometric = (uint16)-1;\n    CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric));\n\n    if (m_hdr && depth >= CV_32F)\n    {\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_FLOAT));\n    }\n\n    bool color = img.channels() > 1;\n\n    CV_CheckType(type, depth == CV_8U || depth == CV_16U || depth == CV_32F || depth == CV_64F, \"\");\n\n    if (m_width && m_height)\n    {\n        int is_tiled = TIFFIsTiled(tif) != 0;\n        bool isGrayScale = photometric == PHOTOMETRIC_MINISWHITE || photometric == PHOTOMETRIC_MINISBLACK;\n        uint16 bpp = 8, ncn = isGrayScale ? 1 : 3;\n        if (0 == TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bpp))\n        {\n            // TIFF bi-level images don't require TIFFTAG_BITSPERSAMPLE tag\n            bpp = 1;\n        }\n        CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &ncn));\n        uint16 img_orientation = ORIENTATION_TOPLEFT;\n        CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_ORIENTATION, &img_orientation));\n        const int bitsPerByte = 8;\n        int dst_bpp = (int)(img.elemSize1() * bitsPerByte);\n        bool vert_flip = dst_bpp == 8 &&\n                        (img_orientation == ORIENTATION_BOTRIGHT || img_orientation == ORIENTATION_RIGHTBOT ||\n                         img_orientation == ORIENTATION_BOTLEFT || img_orientation == ORIENTATION_LEFTBOT);\n        int wanted_channels = normalizeChannelsNumber(img.channels());\n\n        if (dst_bpp == 8)\n        {\n            char errmsg[1024];\n            if (!TIFFRGBAImageOK(tif, errmsg))\n            {\n                CV_LOG_WARNING(NULL, \"OpenCV TIFF: TIFFRGBAImageOK: \" << errmsg);\n                close();\n                return false;\n            }\n        }\n\n        uint32 tile_width0 = m_width, tile_height0 = 0;\n\n        if (is_tiled)\n        {\n            CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_TILEWIDTH, &tile_width0));\n            CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_TILELENGTH, &tile_height0));\n        }\n        else\n        {\n            // optional\n            CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &tile_height0));\n        }\n\n        {\n            if (tile_width0 == 0)\n                tile_width0 = m_width;\n\n            if (tile_height0 == 0 ||\n                    (!is_tiled && tile_height0 == std::numeric_limits<uint32>::max()) )\n                tile_height0 = m_height;\n\n            const int TILE_MAX_WIDTH = (1 << 24);\n            const int TILE_MAX_HEIGHT = (1 << 24);\n            CV_Assert((int)tile_width0 > 0 && (int)tile_width0 <= TILE_MAX_WIDTH);\n            CV_Assert((int)tile_height0 > 0 && (int)tile_height0 <= TILE_MAX_HEIGHT);\n            const uint64_t MAX_TILE_SIZE = (CV_BIG_UINT(1) << 30);\n            CV_CheckLE((int)ncn, 4, \"\");\n            CV_CheckLE((int)bpp, 64, \"\");\n            CV_Assert(((uint64_t)tile_width0 * tile_height0 * ncn * std::max(1, (int)(bpp / bitsPerByte)) < MAX_TILE_SIZE) && \"TIFF tile size is too large: >= 1Gb\");\n\n            if (dst_bpp == 8)\n            {\n                // we will use TIFFReadRGBA* functions, so allocate temporary buffer for 32bit RGBA\n                bpp = 8;\n                ncn = 4;\n            }\n            else if (dst_bpp == 32 || dst_bpp == 64)\n            {\n                CV_Assert(ncn == img.channels());\n                CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP));\n            }\n            const size_t buffer_size = (bpp / bitsPerByte) * ncn * tile_height0 * tile_width0;\n            AutoBuffer<uchar> _buffer(buffer_size);\n            uchar* buffer = _buffer.data();\n            ushort* buffer16 = (ushort*)buffer;\n            int tileidx = 0;\n\n            for (int y = 0; y < m_height; y += (int)tile_height0)\n            {\n                int tile_height = std::min((int)tile_height0, m_height - y);\n\n                const int img_y = vert_flip ? m_height - y - tile_height : y;\n\n                for(int x = 0; x < m_width; x += (int)tile_width0, tileidx++)\n                {\n                    int tile_width = std::min((int)tile_width0, m_width - x);\n\n                    switch (dst_bpp)\n                    {\n                        case 8:\n                        {\n                            uchar* bstart = buffer;\n                            if (!is_tiled)\n                            {\n                                CV_TIFF_CHECK_CALL(TIFFReadRGBAStrip(tif, y, (uint32*)buffer));\n                            }\n                            else\n                            {\n                                CV_TIFF_CHECK_CALL(TIFFReadRGBATile(tif, x, y, (uint32*)buffer));\n                                // Tiles fill the buffer from the bottom up\n                                bstart += (tile_height0 - tile_height) * tile_width0 * 4;\n                            }\n\n                            for (int i = 0; i < tile_height; i++)\n                            {\n                                if (color)\n                                {\n                                    if (wanted_channels == 4)\n                                    {\n                                        icvCvt_BGRA2RGBA_8u_C4R(bstart + i*tile_width0*4, 0,\n                                                img.ptr(img_y + tile_height - i - 1, x), 0,\n                                                Size(tile_width, 1) );\n                                    }\n                                    else\n                                    {\n                                        CV_CheckEQ(wanted_channels, 3, \"TIFF-8bpp: BGR/BGRA images are supported only\");\n                                        icvCvt_BGRA2BGR_8u_C4C3R(bstart + i*tile_width0*4, 0,\n                                                img.ptr(img_y + tile_height - i - 1, x), 0,\n                                                Size(tile_width, 1), 2);\n                                    }\n                                }\n                                else\n                                {\n                                    CV_CheckEQ(wanted_channels, 1, \"\");\n                                    icvCvt_BGRA2Gray_8u_C4C1R( bstart + i*tile_width0*4, 0,\n                                            img.ptr(img_y + tile_height - i - 1, x), 0,\n                                            Size(tile_width, 1), 2);\n                                }\n                            }\n                            break;\n                        }\n\n                        case 16:\n                        {\n                            if (!is_tiled)\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedStrip(tif, tileidx, (uint32*)buffer, buffer_size) >= 0);\n                            }\n                            else\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedTile(tif, tileidx, (uint32*)buffer, buffer_size) >= 0);\n                            }\n\n                            for (int i = 0; i < tile_height; i++)\n                            {\n                                if (color)\n                                {\n                                    if (ncn == 1)\n                                    {\n                                        CV_CheckEQ(wanted_channels, 3, \"\");\n                                        icvCvt_Gray2BGR_16u_C1C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1));\n                                    }\n                                    else if (ncn == 3)\n                                    {\n                                        CV_CheckEQ(wanted_channels, 3, \"\");\n                                        icvCvt_RGB2BGR_16u_C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1));\n                                    }\n                                    else if (ncn == 4)\n                                    {\n                                        if (wanted_channels == 4)\n                                        {\n                                            icvCvt_BGRA2RGBA_16u_C4R(buffer16 + i*tile_width0*ncn, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1));\n                                        }\n                                        else\n                                        {\n                                            CV_CheckEQ(wanted_channels, 3, \"TIFF-16bpp: BGR/BGRA images are supported only\");\n                                            icvCvt_BGRA2BGR_16u_C4C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1), 2);\n                                        }\n                                    }\n                                    else\n                                    {\n                                        CV_Error(Error::StsError, \"Not supported\");\n                                    }\n                                }\n                                else\n                                {\n                                    CV_CheckEQ(wanted_channels, 1, \"\");\n                                    if( ncn == 1 )\n                                    {\n                                        memcpy(img.ptr<ushort>(img_y + i, x),\n                                               buffer16 + i*tile_width0*ncn,\n                                               tile_width*sizeof(ushort));\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2Gray_16u_CnC1R(buffer16 + i*tile_width0*ncn, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1), ncn, 2);\n                                    }\n                                }\n                            }\n                            break;\n                        }\n\n                        case 32:\n                        case 64:\n                        {\n                            if( !is_tiled )\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedStrip(tif, tileidx, buffer, buffer_size) >= 0);\n                            }\n                            else\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedTile(tif, tileidx, buffer, buffer_size) >= 0);\n                            }\n\n                            Mat m_tile(Size(tile_width0, tile_height0), CV_MAKETYPE((dst_bpp == 32) ? CV_32F : CV_64F, ncn), buffer);\n                            Rect roi_tile(0, 0, tile_width, tile_height);\n                            Rect roi_img(x, img_y, tile_width, tile_height);\n                            if (!m_hdr && ncn == 3)\n                                cvtColor(m_tile(roi_tile), img(roi_img), COLOR_RGB2BGR);\n                            else if (!m_hdr && ncn == 4)\n                                cvtColor(m_tile(roi_tile), img(roi_img), COLOR_RGBA2BGRA);\n                            else\n                                m_tile(roi_tile).copyTo(img(roi_img));\n                            break;\n                        }\n                        default:\n                        {\n                            CV_Assert(0 && \"OpenCV TIFF: unsupported depth\");\n                        }\n                    }  // switch (dst_bpp)\n                }  // for x\n            }  // for y\n        }\n        fixOrientation(img, img_orientation, dst_bpp);\n    }\n\n    if (m_hdr && depth >= CV_32F)\n    {\n        CV_Assert(photometric == PHOTOMETRIC_LOGLUV);\n        cvtColor(img, img, COLOR_XYZ2BGR);\n    }\n    return true;\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////\n\nTiffEncoder::TiffEncoder()\n{\n    m_description = \"TIFF Files (*.tiff;*.tif)\";\n    m_buf_supported = true;\n}\n\nTiffEncoder::~TiffEncoder()\n{\n}\n\nImageEncoder TiffEncoder::newEncoder() const\n{\n    return makePtr<TiffEncoder>();\n}\n\nbool TiffEncoder::isFormatSupported( int depth ) const\n{\n    return depth == CV_8U || depth == CV_16U || depth == CV_32F || depth == CV_64F;\n}\n\nvoid  TiffEncoder::writeTag( WLByteStream& strm, TiffTag tag,\n                             TiffFieldType fieldType,\n                             int count, int value )\n{\n    strm.putWord( tag );\n    strm.putWord( fieldType );\n    strm.putDWord( count );\n    strm.putDWord( value );\n}\n\nclass TiffEncoderBufHelper\n{\npublic:\n\n    TiffEncoderBufHelper(std::vector<uchar> *buf)\n            : m_buf(buf), m_buf_pos(0)\n    {}\n\n    TIFF* open ()\n    {\n        // do NOT put \"wb\" as the mode, because the b means \"big endian\" mode, not \"binary\" mode.\n        // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n        return TIFFClientOpen( \"\", \"w\", reinterpret_cast<thandle_t>(this), &TiffEncoderBufHelper::read,\n                               &TiffEncoderBufHelper::write, &TiffEncoderBufHelper::seek,\n                               &TiffEncoderBufHelper::close, &TiffEncoderBufHelper::size,\n                               /*map=*/0, /*unmap=*/0 );\n    }\n\n    static tmsize_t read( thandle_t /*handle*/, void* /*buffer*/, tmsize_t /*n*/ )\n    {\n        // Not used for encoding.\n        return 0;\n    }\n\n    static tmsize_t write( thandle_t handle, void* buffer, tmsize_t n )\n    {\n        TiffEncoderBufHelper *helper = reinterpret_cast<TiffEncoderBufHelper*>(handle);\n        size_t begin = (size_t)helper->m_buf_pos;\n        size_t end = begin + n;\n        if ( helper->m_buf->size() < end )\n        {\n            helper->m_buf->resize(end);\n        }\n        memcpy(&(*helper->m_buf)[begin], buffer, n);\n        helper->m_buf_pos = end;\n        return n;\n    }\n\n    static toff_t seek( thandle_t handle, toff_t offset, int whence )\n    {\n        TiffEncoderBufHelper *helper = reinterpret_cast<TiffEncoderBufHelper*>(handle);\n        const toff_t size = helper->m_buf->size();\n        toff_t new_pos = helper->m_buf_pos;\n        switch (whence)\n        {\n            case SEEK_SET:\n                new_pos = offset;\n                break;\n            case SEEK_CUR:\n                new_pos += offset;\n                break;\n            case SEEK_END:\n                new_pos = size + offset;\n                break;\n        }\n        helper->m_buf_pos = new_pos;\n        return new_pos;\n    }\n\n    static toff_t size( thandle_t handle )\n    {\n        TiffEncoderBufHelper *helper = reinterpret_cast<TiffEncoderBufHelper*>(handle);\n        return helper->m_buf->size();\n    }\n\n    static int close( thandle_t /*handle*/ )\n    {\n        // Do nothing.\n        return 0;\n    }\n\nprivate:\n\n    std::vector<uchar>* m_buf;\n    toff_t m_buf_pos;\n};\n\nstatic bool readParam(const std::vector<int>& params, int key, int& value)\n{\n    for (size_t i = 0; i + 1 < params.size(); i += 2)\n    {\n        if (params[i] == key)\n        {\n            value = params[i + 1];\n            return true;\n        }\n    }\n    return false;\n}\n\nbool TiffEncoder::writeLibTiff( const std::vector<Mat>& img_vec, const std::vector<int>& params)\n{\n    // do NOT put \"wb\" as the mode, because the b means \"big endian\" mode, not \"binary\" mode.\n    // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n    TIFF* tif = NULL;\n\n    TiffEncoderBufHelper buf_helper(m_buf);\n    if ( m_buf )\n    {\n        tif = buf_helper.open();\n    }\n    else\n    {\n        tif = TIFFOpen(m_filename.c_str(), \"w\");\n    }\n    if (!tif)\n    {\n        return false;\n    }\n    cv::Ptr<void> tif_cleanup(tif, cv_tiffCloseHandle);\n\n    //Settings that matter to all images\n    int compression = COMPRESSION_LZW;\n    int predictor = PREDICTOR_HORIZONTAL;\n    int resUnit = -1, dpiX = -1, dpiY = -1;\n\n    readParam(params, IMWRITE_TIFF_COMPRESSION, compression);\n    readParam(params, TIFFTAG_PREDICTOR, predictor);\n    readParam(params, IMWRITE_TIFF_RESUNIT, resUnit);\n    readParam(params, IMWRITE_TIFF_XDPI, dpiX);\n    readParam(params, IMWRITE_TIFF_YDPI, dpiY);\n\n    //Iterate through each image in the vector and write them out as Tiff directories\n    for (size_t page = 0; page < img_vec.size(); page++)\n    {\n        const Mat& img = img_vec[page];\n        CV_Assert(!img.empty());\n        int channels = img.channels();\n        int width = img.cols, height = img.rows;\n        int type = img.type();\n        int depth = CV_MAT_DEPTH(type);\n        CV_CheckType(type, depth == CV_8U || depth == CV_16U || depth == CV_32F || depth == CV_64F, \"\");\n        CV_CheckType(type, channels >= 1 && channels <= 4, \"\");\n\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, width));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_IMAGELENGTH, height));\n\n        if (img_vec.size() > 1)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE));\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PAGENUMBER, page, img_vec.size()));\n        }\n\n        int compression_param = -1;  // OPENCV_FUTURE\n        if (type == CV_32FC3 && (!readParam(params, IMWRITE_TIFF_COMPRESSION, compression_param) || compression_param == COMPRESSION_SGILOG))\n        {\n            if (!write_32FC3_SGILOG(img, tif))\n                return false;\n            continue;\n        }\n\n        int page_compression = compression;\n\n        int bitsPerChannel = -1;\n        switch (depth)\n        {\n            case CV_8U:\n            {\n                bitsPerChannel = 8;\n                break;\n            }\n            case CV_16U:\n            {\n                bitsPerChannel = 16;\n                break;\n            }\n            case CV_32F:\n            {\n                bitsPerChannel = 32;\n                page_compression = COMPRESSION_NONE;\n                break;\n            }\n            case CV_64F:\n            {\n                bitsPerChannel = 64;\n                page_compression = COMPRESSION_NONE;\n                break;\n            }\n            default:\n            {\n                return false;\n            }\n        }\n\n        const int bitsPerByte = 8;\n        size_t fileStep = (width * channels * bitsPerChannel) / bitsPerByte;\n        CV_Assert(fileStep > 0);\n\n        int rowsPerStrip = (int)((1 << 13) / fileStep);\n        readParam(params, TIFFTAG_ROWSPERSTRIP, rowsPerStrip);\n        rowsPerStrip = std::max(1, std::min(height, rowsPerStrip));\n\n        int colorspace = channels > 1 ? PHOTOMETRIC_RGB : PHOTOMETRIC_MINISBLACK;\n\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, bitsPerChannel));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_COMPRESSION, page_compression));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, colorspace));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, channels));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, rowsPerStrip));\n\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, depth >= CV_32F ? SAMPLEFORMAT_IEEEFP : SAMPLEFORMAT_UINT));\n\n        if (page_compression != COMPRESSION_NONE)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PREDICTOR, predictor));\n        }\n\n        if (resUnit >= RESUNIT_NONE && resUnit <= RESUNIT_CENTIMETER)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_RESOLUTIONUNIT, resUnit));\n        }\n        if (dpiX >= 0)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_XRESOLUTION, (float)dpiX));\n        }\n        if (dpiY >= 0)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_YRESOLUTION, (float)dpiY));\n        }\n\n        // row buffer, because TIFFWriteScanline modifies the original data!\n        size_t scanlineSize = TIFFScanlineSize(tif);\n        AutoBuffer<uchar> _buffer(scanlineSize + 32);\n        uchar* buffer = _buffer.data(); CV_DbgAssert(buffer);\n        Mat m_buffer(Size(width, 1), CV_MAKETYPE(depth, channels), buffer, (size_t)scanlineSize);\n\n        for (int y = 0; y < height; ++y)\n        {\n            switch (channels)\n            {\n                case 1:\n                {\n                    memcpy(buffer, img.ptr(y), scanlineSize);\n                    break;\n                }\n\n                case 3:\n                {\n                    cvtColor(img(Rect(0, y, width, 1)), (const Mat&)m_buffer, COLOR_BGR2RGB);\n                    break;\n                }\n\n                case 4:\n                {\n                    cvtColor(img(Rect(0, y, width, 1)), (const Mat&)m_buffer, COLOR_BGRA2RGBA);\n                    break;\n                }\n\n                default:\n                {\n                    CV_Assert(0);\n                }\n            }\n\n            CV_TIFF_CHECK_CALL(TIFFWriteScanline(tif, buffer, y, 0) == 1);\n        }\n\n        CV_TIFF_CHECK_CALL(TIFFWriteDirectory(tif));\n    }\n\n    return true;\n}\n\nbool TiffEncoder::write_32FC3_SGILOG(const Mat& _img, void* tif_)\n{\n    TIFF* tif = (TIFF*)tif_;\n    CV_Assert(tif);\n\n    Mat img;\n    cvtColor(_img, img, COLOR_BGR2XYZ);\n\n    //done by caller: CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, img.cols));\n    //done by caller: CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_IMAGELENGTH, img.rows));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 3));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 32));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_SGILOG));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_LOGLUV));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_FLOAT));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, 1));\n    const int strip_size = 3 * img.cols;\n    for (int i = 0; i < img.rows; i++)\n    {\n        CV_TIFF_CHECK_CALL(TIFFWriteEncodedStrip(tif, i, (tdata_t)img.ptr<float>(i), strip_size * sizeof(float)) != (tsize_t)-1);\n    }\n    CV_TIFF_CHECK_CALL(TIFFWriteDirectory(tif));\n    return true;\n}\n\nbool TiffEncoder::writemulti(const std::vector<Mat>& img_vec, const std::vector<int>& params)\n{\n    return writeLibTiff(img_vec, params);\n}\n\nbool  TiffEncoder::write( const Mat& img, const std::vector<int>& params)\n{\n    int type = img.type();\n    int depth = CV_MAT_DEPTH(type);\n\n    CV_CheckType(type, depth == CV_8U || depth == CV_16U || depth == CV_32F || depth == CV_64F, \"\");\n\n    std::vector<Mat> img_vec;\n    img_vec.push_back(img);\n    return writeLibTiff(img_vec, params);\n}\n\n} // namespace\n\n#endif\n",
                "name": "grfmt_tiff.cpp",
                "path": "shell/bc/OCRServer/3rdparty/opencv-4.5.4/modules/imgcodecs/src/grfmt_tiff.cpp",
                "url": "/github.com/LingmoOS/LingmoOS/-/blob/shell/bc/OCRServer/3rdparty/opencv-4.5.4/modules/imgcodecs/src/grfmt_tiff.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 530,
                    "offsetAndLengths": [
                        [
                            51,
                            16
                        ]
                    ],
                    "preview": "                                CV_TIFF_CHECK_CALL(TIFFReadRGBATile(tif, x, y, (uint32*)buffer));"
                }
            ],
            "repository": {
                "name": "github.com/LingmoOS/LingmoOS",
                "url": "/github.com/LingmoOS/LingmoOS"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "22ff7bd0737352c22f9c4cea3b75110ab1f121e3"
                },
                "content": "////////////////////////////////////////////////////////////////////\n// ImageTIFF.cpp\n//\n// Copyright 2007 cDc@seacave\n// Distributed under the Boost Software License, Version 1.0\n// (See http://www.boost.org/LICENSE_1_0.txt)\n\n#include \"Common.h\"\n\n#ifdef _IMAGE_TIFF\n#include \"ImageTIFF.h\"\n\nextern \"C\" {\n#if !defined(_MSC_VER) && !defined(__BORLANDC__)\n#include <tiffconf.h>\n#undef TIFF_INT64_T\n#define TIFF_INT64_T int64_t\n#undef TIFF_UINT64_T\n#define TIFF_UINT64_T uint64_t\n#endif\n#include <tiffio.h>\n}\n\nusing namespace SEACAVE;\n\n\n// D E F I N E S ///////////////////////////////////////////////////\n\n/*\n  ISO C++ uses a 'std::streamsize' type to define counts.  This makes\n  it similar to, (but perhaps not the same as) size_t.\n\n  The std::ios::pos_type is used to represent stream positions as used\n  by tellg(), tellp(), seekg(), and seekp().  This makes it similar to\n  (but perhaps not the same as) 'off_t'.  The std::ios::streampos type\n  is used for character streams, but is documented to not be an\n  integral type anymore, so it should *not* be assigned to an integral\n  type.\n\n  The std::ios::off_type is used to specify relative offsets needed by\n  the variants of seekg() and seekp() which accept a relative offset\n  argument.\n\n  Useful prototype knowledge:\n\n  Obtain read position\n    ios::pos_type basic_istream::tellg()\n\n  Set read position\n    basic_istream& basic_istream::seekg(ios::pos_type)\n    basic_istream& basic_istream::seekg(ios::off_type, ios_base::seekdir)\n\n  Read data\n    basic_istream& istream::read(char *str, streamsize count)\n\n  Number of characters read in last unformatted read\n    streamsize istream::gcount();\n\n  Obtain write position\n    ios::pos_type basic_ostream::tellp()\n\n  Set write position\n    basic_ostream& basic_ostream::seekp(ios::pos_type)\n    basic_ostream& basic_ostream::seekp(ios::off_type, ios_base::seekdir)\n\n  Write data\n    basic_ostream& ostream::write(const char *str, streamsize count)\n*/\n\nstruct tiffis_data;\nstruct tiffos_data;\n\nextern \"C\" {\n\n\tstatic tmsize_t _tiffosReadProc(thandle_t, void*, tmsize_t);\n\tstatic tmsize_t _tiffisReadProc(thandle_t fd, void* buf, tmsize_t size);\n\tstatic tmsize_t _tiffosWriteProc(thandle_t fd, void* buf, tmsize_t size);\n\tstatic tmsize_t _tiffisWriteProc(thandle_t, void*, tmsize_t);\n\tstatic uint64_t _tiffosSeekProc(thandle_t fd, uint64_t off, int whence);\n\tstatic uint64_t _tiffisSeekProc(thandle_t fd, uint64_t off, int whence);\n\tstatic uint64_t _tiffosSizeProc(thandle_t fd);\n\tstatic uint64_t _tiffisSizeProc(thandle_t fd);\n\tstatic int      _tiffosCloseProc(thandle_t fd);\n\tstatic int      _tiffisCloseProc(thandle_t fd);\n\tstatic int \t    _tiffDummyMapProc(thandle_t, void** base, toff_t* size);\n\tstatic void     _tiffDummyUnmapProc(thandle_t, void* base, toff_t size);\n\tstatic TIFF*    _tiffStreamOpen(const char* name, const char* mode, void *fd);\n\n\tstruct tiffis_data\n\t{\n\t\tISTREAM* stream;\n\t\tsize_f_t start_pos;\n\t};\n\n\tstruct tiffos_data\n\t{\n\t\tOSTREAM* stream;\n\t\tsize_f_t start_pos;\n\t};\n\n\tstatic tmsize_t _tiffosReadProc(thandle_t, void*, tmsize_t)\n\t{\n\t\treturn 0;\n\t}\n\n\tstatic tmsize_t _tiffisReadProc(thandle_t fd, void* buf, tmsize_t size)\n\t{\n\t\ttiffis_data\t*data = reinterpret_cast<tiffis_data *>(fd);\n\n\t\t// Verify that type does not overflow.\n\t\tsize_t request_size = size;\n\t\tif (static_cast<tmsize_t>(request_size) != size)\n\t\t\treturn static_cast<tmsize_t>(-1);\n\n\t\treturn static_cast<tmsize_t>(data->stream->read(buf, request_size));\n\t}\n\n\tstatic tmsize_t _tiffosWriteProc(thandle_t fd, void* buf, tmsize_t size)\n\t{\n\t\ttiffos_data\t*data = reinterpret_cast<tiffos_data *>(fd);\n\n\t\t// Verify that type does not overflow.\n\t\tsize_t request_size = size;\n\t\tif (static_cast<tmsize_t>(request_size) != size)\n\t\t\treturn static_cast<tmsize_t>(-1);\n\n\t\treturn static_cast<tmsize_t>(data->stream->write(buf, request_size));\n\t}\n\n\tstatic tmsize_t _tiffisWriteProc(thandle_t, void*, tmsize_t)\n\t{\n\t\treturn 0;\n\t}\n\n\tstatic uint64_t _tiffosSeekProc(thandle_t fd, uint64_t off, int whence)\n\t{\n\t\ttiffos_data\t*data = reinterpret_cast<tiffos_data *>(fd);\n\t\tOSTREAM* os = data->stream;\n\n\t\t// if the stream has already failed, don't do anything\n\t\tif (os == NULL)\n\t\t\treturn static_cast<uint64_t>(-1);\n\n\t\tbool bSucceeded(true);\n\t\tswitch (whence) {\n\t\tcase SEEK_SET:\n\t\t{\n\t\t\t// Compute 64-bit offset\n\t\t\tuint64_t new_offset = static_cast<uint64_t>(data->start_pos) + off;\n\n\t\t\t// Verify that value does not overflow\n\t\t\tsize_f_t offset = static_cast<size_f_t>(new_offset);\n\t\t\tif (static_cast<uint64_t>(offset) != new_offset)\n\t\t\t\treturn static_cast<uint64_t>(-1);\n\n\t\t\tbSucceeded = os->setPos(offset);\n\t\t\tbreak;\n\t\t}\n\t\tcase SEEK_CUR:\n\t\t{\n\t\t\t// Verify that value does not overflow\n\t\t\tsize_f_t offset = static_cast<size_f_t>(off);\n\t\t\tif (static_cast<uint64_t>(offset) != off)\n\t\t\t\treturn static_cast<uint64_t>(-1);\n\n\t\t\tbSucceeded = os->setPos(os->getPos()+offset);\n\t\t\tbreak;\n\t\t}\n\t\tcase SEEK_END:\n\t\t{\n\t\t\t// Verify that value does not overflow\n\t\t\tsize_f_t offset = static_cast<size_f_t>(off);\n\t\t\tif (static_cast<uint64_t>(offset) != off)\n\t\t\t\treturn static_cast<uint64_t>(-1);\n\n\t\t\tbSucceeded = os->setPos(os->getSize()-offset);\n\t\t\tbreak;\n\t\t}\n\t\t}\n\n\t\t// Attempt to workaround problems with seeking past the end of the\n\t\t// stream.  ofstream doesn't have a problem with this but\n\t\t// ostrstream/ostringstream does. In that situation, add intermediate\n\t\t// '\\0' characters.\n\t\tif (!bSucceeded) {\n\t\t\tsize_f_t origin;\n\t\t\tswitch (whence) {\n\t\t\tcase SEEK_SET:\n\t\t\tdefault:\n\t\t\t\torigin = data->start_pos;\n\t\t\t\tbreak;\n\t\t\tcase SEEK_CUR:\n\t\t\t\torigin = os->getPos();\n\t\t\t\tbreak;\n\t\t\tcase SEEK_END:\n\t\t\t\tos->setPos(os->getSize());\n\t\t\t\torigin = os->getPos();\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// only do something if desired seek position is valid\n\t\t\tif ((static_cast<uint64_t>(origin) + off) > static_cast<uint64_t>(data->start_pos)) {\n\t\t\t\tuint64_t\tnum_fill;\n\t\t\t\t// extend the stream to the expected size\n\t\t\t\tos->setPos(os->getSize());\n\t\t\t\tnum_fill = (static_cast<uint64_t>(origin)) + off - os->getPos();\n\t\t\t\tconst char dummy = '\\0';\n\t\t\t\tfor (uint64_t i = 0; i < num_fill; i++)\n\t\t\t\t\tos->write(&dummy, 1);\n\t\t\t\t// retry the seek\n\t\t\t\tos->setPos(static_cast<size_f_t>(static_cast<uint64_t>(origin) + off));\n\t\t\t}\n\t\t}\n\n\t\treturn static_cast<uint64_t>(os->getPos());\n\t}\n\n\tstatic uint64_t _tiffisSeekProc(thandle_t fd, uint64_t off, int whence)\n\t{\n\t\ttiffis_data\t*data = reinterpret_cast<tiffis_data *>(fd);\n\t\tISTREAM* is = data->stream;\n\n\t\tswitch (whence) {\n\t\tcase SEEK_SET:\n\t\t{\n\t\t\t// Compute 64-bit offset\n\t\t\tuint64_t new_offset = static_cast<uint64_t>(data->start_pos) + off;\n\n\t\t\t// Verify that value does not overflow\n\t\t\tsize_f_t offset = static_cast<size_f_t>(new_offset);\n\t\t\tif (static_cast<uint64_t>(offset) != new_offset)\n\t\t\t\treturn static_cast<uint64_t>(-1);\n\n\t\t\tis->setPos(offset);\n\t\t\tbreak;\n\t\t}\n\t\tcase SEEK_CUR:\n\t\t{\n\t\t\t// Verify that value does not overflow\n\t\t\tsize_f_t offset = static_cast<size_f_t>(off);\n\t\t\tif (static_cast<uint64_t>(offset) != off)\n\t\t\t\treturn static_cast<uint64_t>(-1);\n\n\t\t\tis->setPos(is->getPos()+offset);\n\t\t\tbreak;\n\t\t}\n\t\tcase SEEK_END:\n\t\t{\n\t\t\t// Verify that value does not overflow\n\t\t\tsize_f_t offset = static_cast<size_f_t>(off);\n\t\t\tif (static_cast<uint64_t>(offset) != off)\n\t\t\t\treturn static_cast<uint64_t>(-1);\n\n\t\t\tis->setPos(is->getSize()-offset);\n\t\t\tbreak;\n\t\t}\n\t\t}\n\n\t\treturn (uint64_t)(is->getPos() - data->start_pos);\n\t}\n\n\tstatic uint64_t _tiffosSizeProc(thandle_t fd)\n\t{\n\t\ttiffos_data\t*data = reinterpret_cast<tiffos_data *>(fd);\n\t\treturn (uint64_t)data->stream->getSize();\n\t}\n\n\tstatic uint64_t _tiffisSizeProc(thandle_t fd)\n\t{\n\t\ttiffis_data\t*data = reinterpret_cast<tiffis_data *>(fd);\n\t\treturn (uint64_t)data->stream->getSize();\n\t}\n\n\tstatic int _tiffosCloseProc(thandle_t fd)\n\t{\n\t\t// Our stream was not allocated by us, so it shouldn't be closed by us.\n\t\tdelete reinterpret_cast<tiffos_data *>(fd);\n\t\treturn 0;\n\t}\n\n\tstatic int _tiffisCloseProc(thandle_t fd)\n\t{\n\t\t// Our stream was not allocated by us, so it shouldn't be closed by us.\n\t\tdelete reinterpret_cast<tiffis_data *>(fd);\n\t\treturn 0;\n\t}\n\n\tstatic int _tiffDummyMapProc(thandle_t, void** /*base*/, toff_t* /*size*/)\n\t{\n\t\treturn (0);\n\t}\n\n\tstatic void _tiffDummyUnmapProc(thandle_t, void* /*base*/, toff_t /*size*/)\n\t{\n\t}\n\n\t/*\n\t * Open a TIFF file descriptor for read/writing.\n\t */\n\tstatic TIFF* _tiffStreamOpen(const char* name, const char* mode, void *fd)\n\t{\n\t\tTIFF*\ttif;\n\n\t\tif (strchr(mode, 'w')) {\n\t\t\ttiffos_data\t*data = new tiffos_data;\n\t\t\tdata->stream = reinterpret_cast<OSTREAM*>(fd);\n\t\t\tdata->start_pos = data->stream->getPos();\n\n\t\t\t// Open for writing.\n\t\t\ttif = TIFFClientOpen(name, mode,\n\t\t\t\t\t\t\t\t reinterpret_cast<thandle_t>(data),\n\t\t\t\t\t\t\t\t _tiffosReadProc,\n\t\t\t\t\t\t\t\t _tiffosWriteProc,\n\t\t\t\t\t\t\t\t _tiffosSeekProc,\n\t\t\t\t\t\t\t\t _tiffosCloseProc,\n\t\t\t\t\t\t\t\t _tiffosSizeProc,\n\t\t\t\t\t\t\t\t _tiffDummyMapProc,\n\t\t\t\t\t\t\t\t _tiffDummyUnmapProc);\n\t\t} else {\n\t\t\ttiffis_data\t*data = new tiffis_data;\n\t\t\tdata->stream = reinterpret_cast<ISTREAM*>(fd);\n\t\t\tdata->start_pos = data->stream->getPos();\n\t\t\t// Open for reading.\n\t\t\ttif = TIFFClientOpen(name, mode,\n\t\t\t\t\t\t\t\t reinterpret_cast<thandle_t>(data),\n\t\t\t\t\t\t\t\t _tiffisReadProc,\n\t\t\t\t\t\t\t\t _tiffisWriteProc,\n\t\t\t\t\t\t\t\t _tiffisSeekProc,\n\t\t\t\t\t\t\t\t _tiffisCloseProc,\n\t\t\t\t\t\t\t\t _tiffisSizeProc,\n\t\t\t\t\t\t\t\t _tiffDummyMapProc,\n\t\t\t\t\t\t\t\t _tiffDummyUnmapProc);\n\t\t}\n\n\t\treturn (tif);\n\t}\n\n} /* extern \"C\" */\n\n// TIFFOpen() mode flags are different to fopen().  A 'b' in mode \"rb\" has no effect when reading.\n// http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n// NB: We don't support mapped files with streams so add 'm'\nTIFF* TIFFStreamOpen(const char* name, OSTREAM* os)\n{\n\treturn _tiffStreamOpen(name, \"wm\", os);\n}\nTIFF* TIFFStreamOpen(const char* name, ISTREAM* is)\n{\n\treturn _tiffStreamOpen(name, \"rm\", is);\n}\n\n\n// S T R U C T S ///////////////////////////////////////////////////\n\nCImageTIFF::CImageTIFF() : m_state(NULL)\n{\n} // Constructor\n\nCImageTIFF::~CImageTIFF()\n{\n\t//clean up\n\tClose();\n} // Destructor\n/*----------------------------------------------------------------*/\n\nvoid CImageTIFF::Close()\n{\n\tif (m_state)\n\t{\n\t\tTIFF* tif = static_cast<TIFF*>(m_state);\n\t\tTIFFClose(tif);\n\t\tm_state = NULL;\n\t}\n\tm_width = m_height = 0;\n\tCImage::Close();\n}\n/*----------------------------------------------------------------*/\n\nHRESULT CImageTIFF::ReadHeader()\n{\n\tTIFF* tif = static_cast<TIFF*>(m_state);\n\tif (!tif) {\n\t\ttif = TIFFStreamOpen(\"ReadTIFF\", (ISTREAM*)m_pStream);\n\t\tif (!tif) {\n\t\t\tLOG(LT_IMAGE, \"error: unsupported TIFF image\");\n\t\t\treturn _INVALIDFILE;\n\t\t}\n\t}\n\tm_state = tif;\n\n\tuint16 photometric = 0;\n\tif (TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &m_width) &&\n\t\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &m_height) &&\n\t\tTIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric))\n\t{\n\t\tuint16 bpp=8, ncn = photometric > 1 ? 3 : 1;\n\t\tTIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bpp);\n\t\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &ncn);\n\n\t\tm_dataWidth = m_width;\n\t\tm_dataHeight= m_height;\n\t\tm_numLevels = 0;\n\t\tm_level     = 0;\n\n\t\tif ((bpp == 32 && ncn == 3) || photometric == PHOTOMETRIC_LOGLUV) {\n\t\t\t// this is HDR format with 3 floats per pixel\n\t\t\t//TODO: implement\n\t\t\tASSERT(\"error: not implemented\" == NULL);\n\t\t\tClose();\n\t\t\treturn _FAIL;\n\t\t}\n\t\tif (bpp > 8 &&\n\t\t\t((photometric != 2 && photometric != 1) ||\n\t\t\t\t(ncn != 1 && ncn != 3 && ncn != 4)))\n\t\t\tbpp = 8;\n\t\tswitch (bpp) {\n\t\tcase 8:\n\t\t\tm_stride = 4;\n\t\t\tm_format = PF_B8G8R8A8;\n\t\t\tbreak;\n\t\t//case 16:\n\t\t//\tm_type = CV_MAKETYPE(CV_16U, photometric > 1 ? 3 : 1);\n\t\t//\tbreak;\n\t\t//case 32:\n\t\t//\tm_type = CV_MAKETYPE(CV_32F, photometric > 1 ? 3 : 1);\n\t\t//\tbreak;\n\t\t//case 64:\n\t\t//\tm_type = CV_MAKETYPE(CV_64F, photometric > 1 ? 3 : 1);\n\t\t//\tbreak;\n\t\tdefault:\n\t\t\t//TODO: implement\n\t\t\tASSERT(\"error: not implemented\" == NULL);\n\t\t\tLOG(LT_IMAGE, \"error: unsupported TIFF image\");\n\t\t\tClose();\n\t\t\treturn _INVALIDFILE;\n\t\t}\n\t\tm_lineWidth = m_width * m_stride;\n\n\t\treturn _OK;\n\t}\n\n\tClose();\n\treturn _FAIL;\n} // ReadHeader\n/*----------------------------------------------------------------*/\n\nHRESULT CImageTIFF::ReadData(void* pData, PIXELFORMAT dataFormat, Size nStride, Size lineWidth)\n{\n\tif (m_state && m_width && m_height) {\n\t\tTIFF* tif = (TIFF*)m_state;\n\t\tuint32_t tile_width0 = m_width, tile_height0 = 0;\n\t\tint is_tiled = TIFFIsTiled(tif);\n\t\tuint16 photometric;\n\t\tTIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric);\n\t\tuint16 bpp = 8, ncn = photometric > 1 ? 3 : 1;\n\t\tTIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bpp);\n\t\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &ncn);\n\t\tconst int bitsPerByte = 8;\n\t\tint dst_bpp = (int)(1 * bitsPerByte);\n\t\tif (dst_bpp == 8) {\n\t\t\tchar errmsg[1024];\n\t\t\tif (!TIFFRGBAImageOK(tif, errmsg)) {\n\t\t\t\tClose();\n\t\t\t\treturn _INVALIDFILE;\n\t\t\t}\n\t\t}\n\n\t\tif ((!is_tiled) ||\n\t\t\t(is_tiled &&\n\t\t\t TIFFGetField(tif, TIFFTAG_TILEWIDTH, &tile_width0) &&\n\t\t\t TIFFGetField(tif, TIFFTAG_TILELENGTH, &tile_height0)))\n\t\t{\n\t\t\tif (!is_tiled)\n\t\t\t\tTIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &tile_height0);\n\n\t\t\tif (tile_width0 <= 0)\n\t\t\t\ttile_width0 = m_width;\n\n\t\t\tif (tile_height0 <= 0 ||\n\t\t\t\t(!is_tiled && tile_height0 == std::numeric_limits<uint32_t>::max()))\n\t\t\t\ttile_height0 = m_height;\n\n\t\t\tuint8_t* data = (uint8_t*)pData;\n\t\t\tif (!is_tiled && tile_height0 == 1 && dataFormat == m_format && nStride == m_stride) {\n\t\t\t\t// read image directly to the data buffer\n\t\t\t\tfor (Size j=0; j<m_height; ++j, data+=lineWidth)\n\t\t\t\t\tif (!TIFFReadRGBAStrip(tif, j, (uint32_t*)data)) {\n\t\t\t\t\t\tClose();\n\t\t\t\t\t\treturn _INVALIDFILE;\n\t\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// read image to a buffer and convert it\n\t\t\t\tconst size_t buffer_size = 4 * tile_height0 * tile_width0;\n\t\t\t\tCLISTDEF0(uint8_t) _buffer(buffer_size);\n\t\t\t\tuint8_t* buffer = _buffer.Begin();\n\n\t\t\t\tfor (uint32_t y = 0; y < m_height; y += tile_height0, data += lineWidth*tile_height0) {\n\t\t\t\t\tuint32_t tile_height = tile_height0;\n\t\t\t\t\tif (y + tile_height > m_height)\n\t\t\t\t\t\ttile_height = m_height - y;\n\n\t\t\t\t\tfor (uint32_t x = 0; x < m_width; x += tile_width0) {\n\t\t\t\t\t\tuint32_t tile_width = tile_width0;\n\t\t\t\t\t\tif (x + tile_width > m_width)\n\t\t\t\t\t\t\ttile_width = m_width - x;\n\n\t\t\t\t\t\tint ok;\n\t\t\t\t\t\tswitch (dst_bpp) {\n\t\t\t\t\t\tcase 8:\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tuint8_t* bstart = buffer;\n\t\t\t\t\t\t\tif (!is_tiled)\n\t\t\t\t\t\t\t\tok = TIFFReadRGBAStrip(tif, y, (uint32_t*)buffer);\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tok = TIFFReadRGBATile(tif, x, y, (uint32_t*)buffer);\n\t\t\t\t\t\t\t\t//Tiles fill the buffer from the bottom up\n\t\t\t\t\t\t\t\tbstart += (tile_height0 - tile_height) * tile_width0 * 4;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!ok) {\n\t\t\t\t\t\t\t\tClose();\n\t\t\t\t\t\t\t\treturn _INVALIDFILE;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tfor (uint32_t i = 0; i < tile_height; ++i) {\n\t\t\t\t\t\t\t\tuint8_t* dst = data + x*3 + lineWidth*(tile_height - i - 1);\n\t\t\t\t\t\t\t\tuint8_t* src = bstart + i*tile_width0*4;\n\t\t\t\t\t\t\t\tif (!FilterFormat(dst, dataFormat, nStride, src, m_format, m_stride, tile_width)) {\n\t\t\t\t\t\t\t\t\tClose();\n\t\t\t\t\t\t\t\t\treturn _FAIL;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tClose();\n\t\t\t\t\t\t\treturn _INVALIDFILE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn _OK;\n\t\t}\n\t}\n\n\tClose();\n\treturn _FAIL;\n} // Read\n/*----------------------------------------------------------------*/\n\nHRESULT CImageTIFF::WriteHeader(PIXELFORMAT imageFormat, Size width, Size height, BYTE numLevels)\n{\n\t//TODO: to implement the TIFF encoder\n\treturn _OK;\n} // WriteHeader\n/*----------------------------------------------------------------*/\n\nHRESULT CImageTIFF::WriteData(void* pData, PIXELFORMAT dataFormat, Size nStride, Size lineWidth)\n{\n\t//TODO: to implement the TIFF encoder\n\treturn _OK;\n} // WriteData\n/*----------------------------------------------------------------*/\n\n#endif // _IMAGE_TIFF\n",
                "name": "ImageTIFF.cpp",
                "path": "libs/IO/ImageTIFF.cpp",
                "url": "/github.com/cdcseacave/openMVS/-/blob/libs/IO/ImageTIFF.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 514,
                    "offsetAndLengths": [
                        [
                            13,
                            16
                        ]
                    ],
                    "preview": "\t\t\t\t\t\t\t\tok = TIFFReadRGBATile(tif, x, y, (uint32_t*)buffer);"
                }
            ],
            "repository": {
                "name": "github.com/cdcseacave/openMVS",
                "url": "/github.com/cdcseacave/openMVS"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "24efe29f302f8780144eea622bdbd30a244e5a0b"
                },
                "content": "// Copyright 2020 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#include <array>\n#include <cstdint>\n#include <cstring>\n#include <iostream>\n#include <vector>\n\n#include \"../sandboxed.h\"  // NOLINT(build/include)\n#include \"absl/flags/parse.h\"\n#include \"absl/log/globals.h\"\n#include \"absl/log/initialize.h\"\n#include \"sandboxed_api/util/fileops.h\"\n#include \"sandboxed_api/util/path.h\"\n#include \"sandboxed_api/vars.h\"\n#include \"tiffio.h\"  // NOLINT(build/include)\n\n// sapi functions:\n//    TIFFTileSize\n//    TIFFOpen\n//    TIFFReadEncodedTile\n//    TIFFSetField\n//    TIFFClose\n//    TIFFReadRGBATile\n//    TIFFGetField\n\nnamespace {\n\nconstexpr std::array<uint8_t, 6> kCluster0 = {0, 0, 2, 0, 138, 139};\nconstexpr std::array<uint8_t, 6> kCluster64 = {0, 0, 9, 6, 134, 119};\nconstexpr std::array<uint8_t, 6> kCluster128 = {44, 40, 63, 59, 230, 95};\n\ntemplate <typename ArrayT>\nint CheckCluster(int cluster, const sapi::v::Array<uint8_t>& buffer,\n                 const ArrayT& expected_cluster) {\n  uint8_t* target = buffer.GetData() + cluster * 6;\n\n  if (!std::memcmp(target, expected_cluster.data(), 6)) {\n    return 0;\n  }\n\n  std::cerr << \"Cluster \" << cluster << \" did not match expected results.\\n\"\n            << \"Expect: \" << expected_cluster[0] << \"\\t\" << expected_cluster[1]\n            << \"\\t\" << expected_cluster[4] << \"\\t\" << expected_cluster[5]\n            << \"\\t\" << expected_cluster[2] << \"\\t\" << expected_cluster[3]\n            << \"\\n\"\n            << \"Got: \" << target[0] << \"\\t\" << target[1] << \"\\t\" << target[4]\n            << \"\\t\" << target[5] << \"\\t\" << target[2] << \"\\t\" << target[3]\n            << '\\n';\n\n  return 1;\n}\n\nint CheckRgbPixel(int pixel, int min_red, int max_red, int min_green,\n                  int max_green, int min_blue, int max_blue,\n                  const sapi::v::Array<uint8_t>& buffer) {\n  uint8_t* rgb = buffer.GetData() + 3 * pixel;\n\n  if (rgb[0] >= min_red && rgb[0] <= max_red && rgb[1] >= min_green &&\n      rgb[1] <= max_green && rgb[2] >= min_blue && rgb[2] <= max_blue) {\n    return 0;\n  }\n\n  std::cerr << \"Pixel \" << pixel << \" did not match expected results.\\n\"\n            << \"Got R=\" << rgb[0] << \" (expected \" << min_red << \"..\" << max_red\n            << \"), G=\" << rgb[1] << \" (expected \" << min_green << \"..\"\n            << max_green << \"), B=\" << rgb[2] << \" (expected \" << min_blue\n            << \"..\" << max_blue << \")\\n\";\n  return 1;\n}\n\nint CheckRgbaPixel(int pixel, int min_red, int max_red, int min_green,\n                   int max_green, int min_blue, int max_blue, int min_alpha,\n                   int max_alpha, const sapi::v::Array<uint32_t>& buffer) {\n  // RGBA images are upside down - adjust for normal ordering\n  int adjusted_pixel = pixel % 128 + (127 - (pixel / 128)) * 128;\n  uint32_t rgba = buffer[adjusted_pixel];\n\n  if (TIFFGetR(rgba) >= static_cast<uint32_t>(min_red) &&\n      TIFFGetR(rgba) <= static_cast<uint32_t>(max_red) &&\n      TIFFGetG(rgba) >= static_cast<uint32_t>(min_green) &&\n      TIFFGetG(rgba) <= static_cast<uint32_t>(max_green) &&\n      TIFFGetB(rgba) >= static_cast<uint32_t>(min_blue) &&\n      TIFFGetB(rgba) <= static_cast<uint32_t>(max_blue) &&\n      TIFFGetA(rgba) >= static_cast<uint32_t>(min_alpha) &&\n      TIFFGetA(rgba) <= static_cast<uint32_t>(max_alpha)) {\n    return 0;\n  }\n\n  std::cerr << \"Pixel \" << pixel << \" did not match expected results.\\n\"\n            << \"Got R=\" << TIFFGetR(rgba) << \" (expected \" << min_red << \"..\"\n            << max_red << \"), G=\" << TIFFGetG(rgba) << \" (expected \"\n            << min_green << \"..\" << max_green << \"), B=\" << TIFFGetB(rgba)\n            << \" (expected \" << min_blue << \"..\" << max_blue\n            << \"), A=\" << TIFFGetA(rgba) << \" (expected \" << min_alpha << \"..\"\n            << max_alpha << \")\\n\";\n  return 1;\n}\nstd::string GetFilePath(const std::string& dir, const std::string& filename) {\n  return sapi::file::JoinPath(dir, \"test\", \"images\", filename);\n}\n\nstd::string GetCWD() {\n  char cwd[PATH_MAX];\n  getcwd(cwd, sizeof(cwd));\n  return cwd;\n}\n\nstd::string GetFilePath(const std::string filename) {\n  std::string cwd = GetCWD();\n  auto find = cwd.rfind(\"build\");\n\n  std::string project_path;\n  if (find == std::string::npos) {\n    std::cerr << \"Something went wrong: CWD don't contain build dir. \"\n              << \"Please run tests from build dir or send project dir as a \"\n              << \"parameter: ./sandboxed /absolute/path/to/project/dir \\n\";\n    project_path = cwd;\n  } else {\n    project_path = cwd.substr(0, find);\n  }\n\n  return sapi::file::JoinPath(project_path, \"test\", \"images\", filename);\n}\n\n}  // namespace\n\nint main(int argc, char* argv[]) {\n  absl::SetStderrThreshold(absl::LogSeverityAtLeast::kInfo);\n  absl::ParseCommandLine(argc, argv);\n  absl::InitializeLog();\n\n  std::string srcfile;\n  // \"test/images/quad-tile.jpg.tiff\"\n  std::string srcfilerel = \"quad-tile.jpg.tiff\";\n\n  if (argc < 2) {\n    srcfile = GetFilePath(srcfilerel);\n  } else {\n    srcfile = GetFilePath(argv[1], srcfilerel);\n  }\n\n  // without addDir to sandbox. to add dir use\n  // sandbox(absolute_path_to_dir, srcfile) or\n  // sandbox(absolute_path_to_dir). file and dir should be exists.\n  // srcfile must also be absolute_path_to_file\n  TiffSapiSandbox sandbox(\"\", srcfile);\n\n  // initialize sapi vars after constructing TiffSapiSandbox\n  sapi::v::UShort h, v;\n  absl::StatusOr<TIFF*> status_or_tif;\n  absl::StatusOr<int> status_or_int;\n  absl::StatusOr<tmsize_t> status_or_long;\n\n  auto status = sandbox.Init();\n  if (!status.ok()) {\n    fprintf(stderr, \"Couldn't initialize Sandboxed API: %s\\n\", status);\n  }\n\n  TiffApi api(&sandbox);\n  sapi::v::ConstCStr srcfile_var(srcfile.c_str());\n  sapi::v::ConstCStr r_var(\"r\");\n\n  status_or_tif = api.TIFFOpen(srcfile_var.PtrBefore(), r_var.PtrBefore());\n  if (!status_or_tif.ok()) {\n    std::cerr << \"Could not open \" << srcfile << \", TIFFError\\n\";\n    return 1;\n  }\n\n  sapi::v::RemotePtr tif(status_or_tif.value());\n  if (!tif.GetValue()) {\n    // tif is NULL\n    std::cerr << \"Could not open \" << srcfile << \"\\n\";\n    return 1;\n  }\n\n  status_or_int = api.TIFFGetField2(&tif, TIFFTAG_YCBCRSUBSAMPLING, h.PtrBoth(),\n                                    v.PtrBoth());\n  if (!status_or_int.ok() || status_or_int.value() == 0 || h.GetValue() != 2 ||\n      v.GetValue() != 2) {\n    std::cerr << \"Could not retrieve subsampling tag\\n\";\n    return 1;\n  }\n\n  status_or_long = api.TIFFTileSize(&tif);\n  if (!status_or_int.ok() || status_or_long.value() != 24576) {\n    std::cerr << \"tiles are \" << status_or_long.value() << \" bytes\\n\";\n    exit(1);\n  }\n  tsize_t sz = status_or_long.value();\n\n  sapi::v::Array<uint8_t> buffer_(sz);\n  status_or_long = api.TIFFReadEncodedTile(&tif, 9, buffer_.PtrBoth(), sz);\n  if (!status_or_long.ok() || status_or_long.value() != sz) {\n    std::cerr << \"Did not get expected result code from\"\n              << \"TIFFReadEncodedTile(): (\" << status_or_long.value()\n              << \" instead of \" << sz << \")\\n\";\n    return 1;\n  }\n\n  if (CheckCluster(0, buffer_, kCluster0) ||\n      CheckCluster(64, buffer_, kCluster64) ||\n      CheckCluster(128, buffer_, kCluster128)) {\n    return 1;\n  }\n\n  status_or_int =\n      api.TIFFSetFieldU1(&tif, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n  if (!status_or_int.ok() || !status_or_int.value()) {\n    std::cerr << \"TIFFSetFieldU1 not available\\n\";\n  }\n\n  status_or_long = api.TIFFTileSize(&tif);\n  if (!status_or_long.ok() || status_or_long.value() != 128 * 128 * 3) {\n    std::cerr << \"tiles are \" << status_or_long.value() << \" bytes\\n\";\n    return 1;\n  }\n  sz = status_or_long.value();\n\n  sapi::v::Array<uint8_t> buffer2_(sz);\n\n  status_or_long = api.TIFFReadEncodedTile(&tif, 9, buffer2_.PtrBoth(), sz);\n  if (!status_or_long.ok() || status_or_long.value() != sz) {\n    std::cerr << \"Did not get expected result code from \"\n              << \"TIFFReadEncodedTile(): (\" << status_or_long.value()\n              << \" instead of \" << sz << \")\\n\";\n    return 1;\n  }\n\n  uint32_t pixel_status = 0;\n  pixel_status |= CheckRgbPixel(0, 15, 18, 0, 0, 18, 41, buffer2_);\n  pixel_status |= CheckRgbPixel(64, 0, 0, 0, 0, 0, 2, buffer2_);\n  pixel_status |= CheckRgbPixel(512, 5, 6, 34, 36, 182, 196, buffer2_);\n\n  if (!api.TIFFClose(&tif).ok()) {\n    std::cerr << \"TIFFClose error\\n\";\n  }\n\n  status_or_tif = api.TIFFOpen(srcfile_var.PtrBefore(), r_var.PtrBefore());\n  if (!status_or_tif.ok()) {\n    std::cerr << \"Could not reopen \" << srcfile << \"\\n\";\n    return 1;\n  }\n\n  sapi::v::RemotePtr tif2(status_or_tif.value());\n  if (!tif2.GetValue()) {  // tif is NULL\n    std::cerr << \"Could not reopen \" << srcfile << \"\\n\";\n    return 1;\n  }\n\n  sapi::v::Array<uint32> rgba_buffer_(128 * 128);\n\n  status_or_int =\n      api.TIFFReadRGBATile(&tif2, 1 * 128, 2 * 128, rgba_buffer_.PtrBoth());\n  if (!status_or_int.ok() || !status_or_int.value()) {\n    fprintf(stderr, \"TIFFReadRGBATile() returned failure code.\\n\");\n    return 1;\n  }\n\n  pixel_status |=\n      CheckRgbaPixel(0, 15, 18, 0, 0, 18, 41, 255, 255, rgba_buffer_);\n  pixel_status |= CheckRgbaPixel(64, 0, 0, 0, 0, 0, 2, 255, 255, rgba_buffer_);\n  pixel_status |=\n      CheckRgbaPixel(512, 5, 6, 34, 36, 182, 196, 255, 255, rgba_buffer_);\n\n  if (!api.TIFFClose(&tif2).ok()) {\n    std::cerr << \"TIFFClose erro\\n\";\n  }\n\n  if (pixel_status) {\n    std::cerr << \"pixel_status is true, expected false\";\n    return 1;\n  }\n\n  return 0;\n}\n",
                "name": "main_sandboxed.cc",
                "path": "contrib/libtiff/example/main_sandboxed.cc",
                "url": "/github.com/google/sandboxed-api/-/blob/contrib/libtiff/example/main_sandboxed.cc"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 35,
                    "offsetAndLengths": [
                        [
                            6,
                            16
                        ]
                    ],
                    "preview": "//    TIFFReadRGBATile"
                },
                {
                    "limitHit": false,
                    "lineNumber": 265,
                    "offsetAndLengths": [
                        [
                            10,
                            16
                        ]
                    ],
                    "preview": "      api.TIFFReadRGBATile(&tif2, 1 * 128, 2 * 128, rgba_buffer_.PtrBoth());"
                },
                {
                    "limitHit": false,
                    "lineNumber": 267,
                    "offsetAndLengths": [
                        [
                            21,
                            16
                        ]
                    ],
                    "preview": "    fprintf(stderr, \"TIFFReadRGBATile() returned failure code.\\n\");"
                }
            ],
            "repository": {
                "name": "github.com/google/sandboxed-api",
                "url": "/github.com/google/sandboxed-api"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "94700bd96ffbe6160b1d0a1e98ff91d24a997208"
                },
                "content": "/******************************************************************************\n *\n * Project:  GeoTIFF Driver\n * Purpose:  GDAL GeoTIFF support.\n * Author:   Frank Warmerdam, warmerdam@pobox.com\n *\n ******************************************************************************\n * Copyright (c) 1998, 2002, Frank Warmerdam <warmerdam@pobox.com>\n * Copyright (c) 2007-2015, Even Rouault <even dot rouault at spatialys dot com>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n ****************************************************************************/\n\n#include \"gtiffrgbaband.h\"\n#include \"gtiffdataset.h\"\n\n#include \"tiffio.h\"\n\n/************************************************************************/\n/*                           GTiffRGBABand()                            */\n/************************************************************************/\n\nGTiffRGBABand::GTiffRGBABand(GTiffDataset *poDSIn, int nBandIn)\n    : GTiffRasterBand(poDSIn, nBandIn)\n{\n    eDataType = GDT_Byte;\n}\n\n/************************************************************************/\n/*                       IGetDataCoverageStatus()                       */\n/************************************************************************/\n\nint GTiffRGBABand::IGetDataCoverageStatus(int, int, int, int, int, double *)\n{\n    return GDAL_DATA_COVERAGE_STATUS_UNIMPLEMENTED |\n           GDAL_DATA_COVERAGE_STATUS_DATA;\n}\n\n/************************************************************************/\n/*                            IWriteBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffRGBABand::IWriteBlock(int, int, void *)\n\n{\n    ReportError(CE_Failure, CPLE_AppDefined,\n                \"RGBA interpreted raster bands are read-only.\");\n    return CE_Failure;\n}\n\n/************************************************************************/\n/*                             IReadBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffRGBABand::IReadBlock(int nBlockXOff, int nBlockYOff, void *pImage)\n\n{\n    m_poGDS->Crystalize();\n\n    const auto nBlockBufSize =\n        4 * static_cast<GPtrDiff_t>(nBlockXSize) * nBlockYSize;\n    const int nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n\n    if (m_poGDS->m_nPlanarConfig == PLANARCONFIG_SEPARATE)\n    {\n        for (int iBand = 0; iBand < m_poGDS->m_nSamplesPerPixel; iBand++)\n        {\n            int nBlockIdBand = nBlockId + iBand * m_poGDS->m_nBlocksPerBand;\n            if (!m_poGDS->IsBlockAvailable(nBlockIdBand))\n                return CE_Failure;\n        }\n    }\n    else\n    {\n        if (!m_poGDS->IsBlockAvailable(nBlockId))\n            return CE_Failure;\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Allocate a temporary buffer for this strip.                     */\n    /* -------------------------------------------------------------------- */\n    if (m_poGDS->m_pabyBlockBuf == nullptr)\n    {\n        m_poGDS->m_pabyBlockBuf = static_cast<GByte *>(\n            VSI_MALLOC3_VERBOSE(4, nBlockXSize, nBlockYSize));\n        if (m_poGDS->m_pabyBlockBuf == nullptr)\n            return CE_Failure;\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Read the strip                                                  */\n    /* -------------------------------------------------------------------- */\n    CPLErr eErr = CE_None;\n\n    if (m_poGDS->m_nLoadedBlock != nBlockId)\n    {\n        if (TIFFIsTiled(m_poGDS->m_hTIFF))\n        {\n            if (TIFFReadRGBATileExt(\n                    m_poGDS->m_hTIFF, nBlockXOff * nBlockXSize,\n                    nBlockYOff * nBlockYSize,\n                    reinterpret_cast<uint32_t *>(m_poGDS->m_pabyBlockBuf),\n                    !m_poGDS->m_bIgnoreReadErrors) == 0 &&\n                !m_poGDS->m_bIgnoreReadErrors)\n            {\n                // Once TIFFError() is properly hooked, this can go away.\n                ReportError(CE_Failure, CPLE_AppDefined,\n                            \"TIFFReadRGBATile() failed.\");\n\n                memset(m_poGDS->m_pabyBlockBuf, 0, nBlockBufSize);\n\n                eErr = CE_Failure;\n            }\n        }\n        else\n        {\n            if (TIFFReadRGBAStripExt(\n                    m_poGDS->m_hTIFF, nBlockId * nBlockYSize,\n                    reinterpret_cast<uint32_t *>(m_poGDS->m_pabyBlockBuf),\n                    !m_poGDS->m_bIgnoreReadErrors) == 0 &&\n                !m_poGDS->m_bIgnoreReadErrors)\n            {\n                // Once TIFFError() is properly hooked, this can go away.\n                ReportError(CE_Failure, CPLE_AppDefined,\n                            \"TIFFReadRGBAStrip() failed.\");\n\n                memset(m_poGDS->m_pabyBlockBuf, 0, nBlockBufSize);\n\n                eErr = CE_Failure;\n            }\n        }\n    }\n\n    m_poGDS->m_nLoadedBlock = eErr == CE_None ? nBlockId : -1;\n\n    /* -------------------------------------------------------------------- */\n    /*      Handle simple case of eight bit data, and pixel interleaving.   */\n    /* -------------------------------------------------------------------- */\n    int nThisBlockYSize = nBlockYSize;\n\n    if (nBlockYOff * nBlockYSize > GetYSize() - nBlockYSize &&\n        !TIFFIsTiled(m_poGDS->m_hTIFF))\n        nThisBlockYSize = GetYSize() - nBlockYOff * nBlockYSize;\n\n#ifdef CPL_LSB\n    const int nBO = nBand - 1;\n#else\n    const int nBO = 4 - nBand;\n#endif\n\n    for (int iDestLine = 0; iDestLine < nThisBlockYSize; ++iDestLine)\n    {\n        const auto nSrcOffset =\n            static_cast<GPtrDiff_t>(nThisBlockYSize - iDestLine - 1) *\n            nBlockXSize * 4;\n\n        GDALCopyWords(m_poGDS->m_pabyBlockBuf + nBO + nSrcOffset, GDT_Byte, 4,\n                      static_cast<GByte *>(pImage) +\n                          static_cast<GPtrDiff_t>(iDestLine) * nBlockXSize,\n                      GDT_Byte, 1, nBlockXSize);\n    }\n\n    if (eErr == CE_None)\n        eErr = FillCacheForOtherBands(nBlockXOff, nBlockYOff);\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                       GetColorInterpretation()                       */\n/************************************************************************/\n\nGDALColorInterp GTiffRGBABand::GetColorInterpretation()\n\n{\n    if (nBand == 1)\n        return GCI_RedBand;\n    if (nBand == 2)\n        return GCI_GreenBand;\n    if (nBand == 3)\n        return GCI_BlueBand;\n\n    return GCI_AlphaBand;\n}\n",
                "name": "gtiffrgbaband.cpp",
                "path": "3rdParty/Harlinn.gdal/frmts/gtiff/gtiffrgbaband.cpp",
                "url": "/github.com/Harlinn/Harlinn.Windows/-/blob/3rdParty/Harlinn.gdal/frmts/gtiff/gtiffrgbaband.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 114,
                    "offsetAndLengths": [
                        [
                            16,
                            16
                        ]
                    ],
                    "preview": "            if (TIFFReadRGBATileExt("
                },
                {
                    "limitHit": false,
                    "lineNumber": 123,
                    "offsetAndLengths": [
                        [
                            29,
                            16
                        ]
                    ],
                    "preview": "                            \"TIFFReadRGBATile() failed.\");"
                }
            ],
            "repository": {
                "name": "github.com/Harlinn/Harlinn.Windows",
                "url": "/github.com/Harlinn/Harlinn.Windows"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "79c77eb1ab736cfceb5adc6ee591de44dbdf2af8"
                },
                "content": "// This file is part of slideio project.\n// It is subject to the license terms in the LICENSE file found in the top-level directory\n// of this distribution and at http://slideio.com/license.html.\n//\n#include \"slideio/base/exceptions.hpp\"\n#include \"slideio/core/tools/tools.hpp\"\n#include \"slideio/drivers/ndpi/ndpilibtiff.hpp\"\n#include \"slideio/drivers/ndpi/ndpitifftools.hpp\"\n#include \"slideio/base/log.hpp\"\n#include \"slideio/core/tools/cvtools.hpp\"\n#include <jpeglib.h>\n#include \"ndpifile.hpp\"\n#include \"slideio/core/tools/blocktiler.hpp\"\n#include \"slideio/core/tools/endian.hpp\"\n\n\n#include <codecvt>\n#include <opencv2/imgproc.hpp>\n#include <setjmp.h>\n#include <opencv2/core.hpp>\n#include <jxrcodec/jxrcodec.hpp>\n\n\nconst int NDPI_RESTART_MARKERS = 65426;\n\nusing namespace slideio;\n\n\nstatic int getCvType(jpegxr_image_info& info)\n{\n    int type = -1;\n    if (info.sample_type == jpegxr_sample_type::Uint) {\n        switch (info.sample_size) {\n        case 1:\n            type = CV_8U;\n            break;\n        case 2:\n            type = CV_16U;\n            break;\n        }\n    }\n    else if (info.sample_type == jpegxr_sample_type::Int) {\n        switch (info.sample_size) {\n        case 2:\n            type = CV_16S;\n            break;\n        case 4:\n            type = CV_32S;\n            break;\n        }\n    }\n    else if (info.sample_type == jpegxr_sample_type::Float) {\n        switch (info.sample_size) {\n        case 2:\n            type = CV_16F;\n            break;\n        case 4:\n            type = CV_32F;\n            break;\n        }\n    }\n    if (type < 0) {\n        RAISE_RUNTIME_ERROR << \"Unsupported type of jpegxr compression: \" << (int)info.sample_type;\n    }\n\n    return type;\n}\n\nstatic DataType getSlideioType(jpegxr_image_info& info)\n{\n    DataType type = DataType::DT_Unknown;\n    if (info.sample_type == jpegxr_sample_type::Uint) {\n        switch (info.sample_size) {\n        case 1:\n            type = DataType::DT_Byte;\n            break;\n        case 2:\n            type = DataType::DT_UInt16;\n            break;\n        }\n    }\n    else if (info.sample_type == jpegxr_sample_type::Int) {\n        switch (info.sample_size) {\n        case 2:\n            type = DataType::DT_Int16;\n            break;\n        case 4:\n            type = DataType::DT_Int32;\n            break;\n        }\n    }\n    else if (info.sample_type == jpegxr_sample_type::Float) {\n        switch (info.sample_size) {\n        case 2:\n            type = DataType::DT_Float16;\n            break;\n        case 4:\n            type = DataType::DT_Float32;\n            break;\n        }\n    }\n    if (type == DataType::DT_Unknown) {\n        RAISE_RUNTIME_ERROR << \"Unsupported type of jpegxr compression: \" << (int)info.sample_type;\n    }\n\n    return type;\n}\n\n\nstatic slideio::Compression compressTiffToSlideio(int tiffCompression)\n{\n    Compression compression = Compression::Unknown;\n    switch (tiffCompression) {\n    case 0x1:\n        compression = Compression::Uncompressed;\n        break;\n    case 0x2:\n        compression = Compression::HuffmanRL;\n        break;\n    case 0x3:\n        compression = Compression::CCITT_T4;\n        break;\n    case 0x4:\n        compression = Compression::CCITT_T6;\n        break;\n    case 0x5:\n        compression = Compression::LZW;\n        break;\n    case 0x6:\n        compression = Compression::JpegOld;\n        break;\n    case 0x7:\n        compression = Compression::Jpeg;\n        break;\n    case 0x8:\n        compression = Compression::Zlib;\n        break;\n    case 0x9:\n        compression = Compression::JBIG85;\n        break;\n    case 0xa:\n        compression = Compression::JBIG43;\n        break;\n    case 0x7ffe:\n        compression = Compression::NextRLE;\n        break;\n    case 0x8005:\n        compression = Compression::PackBits;\n        break;\n    case 0x8029:\n        compression = Compression::ThunderScanRLE;\n        break;\n    case 0x807f:\n        compression = Compression::RasterPadding;\n        break;\n    case 0x8080:\n        compression = Compression::RLE_LW;\n        break;\n    case 0x8081:\n        compression = Compression::RLE_HC;\n        break;\n    case 0x8082:\n        compression = Compression::RLE_BL;\n        break;\n    case 0x80b2:\n        compression = Compression::PKZIP;\n        break;\n    case 0x80b3:\n        compression = Compression::KodakDCS;\n        break;\n    case 0x8765:\n        compression = Compression::JBIG;\n        break;\n    case 0x8798:\n        compression = Compression::Jpeg2000;\n        break;\n    case 0x8799:\n        compression = Compression::NikonNEF;\n        break;\n    case 0x879b:\n        compression = Compression::JBIG2;\n        break;\n    case 0x5852:\n        compression = Compression::JpegXR;\n        break;\n    }\n    return compression;\n}\n\n//std::ostream& operator<<(std::ostream& os, const NDPITiffDirectory& dir)\n//{\n//    os << \"---Tiff directory \" << dir.dirIndex << std::endl;\n//    os << \"width:\" << dir.width << std::endl;\n//    os << \"height:\" << dir.height << std::endl;\n//    os << \"tiled:\" << dir.tiled << std::endl;\n//    os << \"tileWidth:\" << dir.tileWidth << std::endl;\n//    os << \"tileHeight:\" << dir.tileHeight << std::endl;\n//    os << \"channels:\" << dir.channels << std::endl;\n//    os << \"bitsPerSample:\" << dir.bitsPerSample << std::endl;\n//    os << \"photometric:\" << dir.photometric << std::endl;\n//    os << \"YcbCrSubsampling:\" << dir.YCbCrSubsampling[0] << \",\" << dir.YCbCrSubsampling[1] << std::endl;\n//    os << \"compression:\" << dir.compression << std::endl;\n//    os << \"slideioCompression\" << dir.slideioCompression << std::endl;\n//    os << \"offset:\" << dir.offset << std::endl;\n//    os << \"description\" << dir.description << std::endl;\n//    os << \"Number of subdirectories:\" << dir.subdirectories.size() << std::endl;\n//    os << \"Resoulution:\" << dir.res.x << \",\" << dir.res.y << std::endl;\n//    os << \"interleaved:\" << dir.interleaved << std::endl;\n//    os << \"rowsPerStrip:\" << dir.rowsPerStrip << std::endl;\n//    os << \"dataType:\" << dir.dataType << std::endl;\n//    os << \"stripSize:\" << dir.stripSize << std::endl;\n//\n//    for(size_t subDirIndex=0; subDirIndex<dir.subdirectories.size(); ++subDirIndex) {\n//        os << \"--Sub-directory:\" << subDirIndex << std::endl;\n//        os << dir.subdirectories[subDirIndex];\n//    }\n//    return os;\n//}\n//\n//std::ostream& operator<<(std::ostream& os, const std::vector<slideio::NDPITiffDirectory>& dirs) {\n//    os << \"---Tiff directories. Size:\" << dirs.size() << std::endl;\n//    std::vector<slideio::NDPITiffDirectory>::const_iterator iDir;\n//    for (iDir = dirs.begin(); iDir != dirs.end(); ++iDir) {\n//        auto& dir = *iDir;\n//        os << dir;\n//    }\n//    return os;\n//}\n\nstd::ostream& slideio::operator<<(std::ostream& os, const NDPITiffDirectory::Type& type) {\n    switch (type) {\n    case NDPITiffDirectory::Type::Tiled:\n        os << \"Tiled\";\n        break;\n    case NDPITiffDirectory::Type::SingleStripe:\n        os << \"SingleStripe\";\n        break;\n    case NDPITiffDirectory::Type::SingleStripeMCU:\n        os << \"SingleStripeMCU\";\n        break;\n    case NDPITiffDirectory::Type::Striped:\n        os << \"Striped\";\n        break;\n    default:\n        os << \"Unknown \" << static_cast<int>(type);\n        break;\n    }\n    return os;\n}\n\nlibtiff::TIFF* slideio::NDPITiffTools::openTiffFile(const std::string& path)\n{\n    Tools::throwIfPathNotExist(path, \"NDPITiffTools::openTiffFile\");\n    libtiff::TIFF* hfile(nullptr);\n#if defined(WIN32)\n    std::wstring wsPath = Tools::toWstring(path);\n    hfile = libtiff::TIFFOpenW(wsPath.c_str(), \"r\");\n#else\n    hfile = libtiff::TIFFOpen(path.c_str(), \"r\");\n#endif\n    return hfile;\n}\n\nvoid slideio::NDPITiffTools::closeTiffFile(libtiff::TIFF* file)\n{\n    libtiff::TIFFClose(file);\n}\n\n\nstatic slideio::DataType retrieveTiffDataType(libtiff::TIFF* tiff)\n{\n    uint16_t bitsPerSample = 0;\n    uint16_t sampleFormat = 0;\n\n    slideio::DataType dataType = slideio::DataType::DT_Unknown;\n    if (!libtiff::TIFFGetField(tiff, TIFFTAG_BITSPERSAMPLE, &bitsPerSample)) {\n        RAISE_RUNTIME_ERROR << \"Cannot retrieve bits per sample from tiff image\";\n    }\n    if (!libtiff::TIFFGetField(tiff, TIFFTAG_SAMPLEFORMAT, &sampleFormat)) {\n        sampleFormat = SAMPLEFORMAT_UINT;\n    }\n\n    if (bitsPerSample == 8) {\n        if (sampleFormat == SAMPLEFORMAT_UINT) {\n            dataType = slideio::DataType::DT_Byte;\n        }\n        else if (sampleFormat == SAMPLEFORMAT_INT) {\n            dataType = slideio::DataType::DT_Int8;\n        }\n        else {\n            RAISE_RUNTIME_ERROR << \"Unsupported sample format for 8bit images: \" << sampleFormat;\n        }\n    }\n    else if (bitsPerSample == 16) {\n        if (sampleFormat == SAMPLEFORMAT_UINT) {\n            dataType = slideio::DataType::DT_UInt16;\n        }\n        else if (sampleFormat == SAMPLEFORMAT_INT) {\n            dataType = slideio::DataType::DT_Int16;\n        }\n        else if (sampleFormat == SAMPLEFORMAT_IEEEFP) {\n            dataType = slideio::DataType::DT_Float16;\n        }\n        else {\n            RAISE_RUNTIME_ERROR << \"Unsupported sample format for 16bit images: \" << sampleFormat;\n        }\n    }\n    else if (bitsPerSample == 32) {\n        if (sampleFormat == SAMPLEFORMAT_INT) {\n            dataType = slideio::DataType::DT_Int32;\n        }\n        else if (sampleFormat == SAMPLEFORMAT_IEEEFP) {\n            dataType = slideio::DataType::DT_Float32;\n        }\n        else {\n            RAISE_RUNTIME_ERROR << \"Unsupported sample format for 32bit images: \" << sampleFormat;\n        }\n    }\n    else if (bitsPerSample == 64) {\n        if (sampleFormat == SAMPLEFORMAT_IEEEFP) {\n            dataType = slideio::DataType::DT_Float64;\n        }\n        else {\n            RAISE_RUNTIME_ERROR << \"Unsupported sample format for 64bit images: \" << sampleFormat;\n        }\n    }\n    else {\n        RAISE_RUNTIME_ERROR << \"Unsupported bits per sample: \" << bitsPerSample;\n    }\n    return dataType;\n}\n\nvoid slideio::NDPITiffTools::scanTiffDirTags(libtiff::TIFF* tiff, int dirIndex, int64_t dirOffset,\n                                             slideio::NDPITiffDirectory& dir)\n{\n    SLIDEIO_LOG(INFO) << \"NDPITiffTools::scanTiffDirTags-begin \" << dirIndex;\n\n    if (libtiff::TIFFCurrentDirectory(tiff) != dirIndex) {\n        libtiff::TIFFSetDirectory(tiff, (short)dirIndex);\n    }\n    if (dirOffset)\n        libtiff::TIFFSetSubDirectory(tiff, dirOffset);\n\n\n    dir.dirIndex = dirIndex;\n    dir.offset = dirOffset;\n\n    char* description(nullptr);\n    char* userLabel(nullptr);\n    char* comments(nullptr);\n    uint16_t dirchnls(0), dirbits(0);\n    uint32_t *blankLines(nullptr), nblanklines(0);\n    uint16_t compress(0);\n    uint16_t planar_config(0);\n    uint32_t width(0), height(0), tile_width(0), tile_height(0);\n\n    float magnification(0);\n    SLIDEIO_LOG(INFO) << \"NDPITiffTools::scanTiffDirTags-start scanning \" << dirIndex;\n\n    libtiff::TIFFGetField(tiff, TIFFTAG_SAMPLESPERPIXEL, &dirchnls);\n    SLIDEIO_LOG(INFO) << \"NDPITiffTools::scanTiffDirTags TIFFTAG_SAMPLESPERPIXEL: \" << dirchnls;\n    libtiff::TIFFGetField(tiff, TIFFTAG_BITSPERSAMPLE, &dirbits);\n    SLIDEIO_LOG(INFO) << \"NDPITiffTools::scanTiffDirTags TIFFTAG_BITSPERSAMPLE: \" << dirbits;\n    libtiff::TIFFGetField(tiff, TIFFTAG_COMPRESSION, &compress);\n    SLIDEIO_LOG(INFO) << \"NDPITiffTools::scanTiffDirTags TIFFTAG_COMPRESSION: \" << compress;\n\n\n    libtiff::TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, &width);\n    SLIDEIO_LOG(INFO) << \"NDPITiffTools::scanTiffDirTags TIFFTAG_IMAGEWIDTH: \" << width;\n    libtiff::TIFFGetField(tiff, TIFFTAG_IMAGELENGTH, &height);\n    SLIDEIO_LOG(INFO) << \"NDPITiffTools::scanTiffDirTags TIFFTAG_IMAGELENGTH: \" << height;\n    libtiff::TIFFGetField(tiff,TIFFTAG_TILEWIDTH, &tile_width);\n    SLIDEIO_LOG(INFO) << \"NDPITiffTools::scanTiffDirTags TIFFTAG_TILEWIDTH: \" << tile_width;\n    libtiff::TIFFGetField(tiff,TIFFTAG_TILELENGTH, &tile_height);\n    SLIDEIO_LOG(INFO) << \"NDPITiffTools::scanTiffDirTags TIFFTAG_TILELENGTH: \" << tile_height;\n    libtiff::TIFFGetField(tiff, TIFFTAG_IMAGEDESCRIPTION, &description);\n    if(description) {\n        SLIDEIO_LOG(INFO) << \"NDPITiffTools::scanTiffDirTags TIFFTAG_IMAGEDESCRIPTION: \" << description;\n    }\n    libtiff::TIFFGetField(tiff, NDPITAG_USERGIVENSLIDELABEL, &userLabel);\n    if (userLabel) {\n        SLIDEIO_LOG(INFO) << \"NDPITiffTools::scanTiffDirTags NDPITAG_USERGIVENSLIDELABEL: \" << userLabel;\n    }\n    libtiff::TIFFGetField(tiff, NDPITAG_COMMENTS, &comments);\n    if (comments) {\n        SLIDEIO_LOG(INFO) << \"NDPITiffTools::scanTiffDirTags NDPITAG_COMMENTS: \" << comments;\n    }\n    libtiff::TIFFGetField(tiff, TIFFTAG_PLANARCONFIG, &planar_config);\n    SLIDEIO_LOG(INFO) << \"NDPITiffTools::scanTiffDirTags TIFFTAG_PLANARCONFIG: \" << planar_config;\n    if(libtiff::TIFFGetField(tiff, NDPITAG_MAGNIFICATION, &magnification) ==1 ) {\n        SLIDEIO_LOG(INFO) << \"NDPITiffTools::scanTiffDirTags NDPITAG_MAGNIFICATION: \" << magnification;\n        if(magnification<0) {\n            dir.auxImage = true;\n        }\n    }\n    libtiff::TIFFGetField(tiff, NDPITAG_BLANKLANES, &nblanklines, &blankLines);\n    SLIDEIO_LOG(INFO) << \"NDPITiffTools::scanTiffDirTags NDPITAG_BLANKLANES: \" << nblanklines;\n\n\n    float resx(0), resy(0);\n    uint16_t units(0);\n    libtiff::TIFFGetField(tiff, TIFFTAG_XRESOLUTION, &resx);\n    libtiff::TIFFGetField(tiff, TIFFTAG_YRESOLUTION, &resy);\n    libtiff::TIFFGetField(tiff, TIFFTAG_RESOLUTIONUNIT, &units);\n    dir.interleaved = planar_config == PLANARCONFIG_CONTIG;\n    float posx(0), posy(0);\n    libtiff::TIFFGetField(tiff, TIFFTAG_XPOSITION, &posx);\n    libtiff::TIFFGetField(tiff, TIFFTAG_YPOSITION, &posy);\n\n    uint64_t* stripOffset = nullptr;\n    libtiff::TIFFGetField(tiff, TIFFTAG_STRIPOFFSETS, &stripOffset);\n\n    uint64_t* stripSizes = nullptr;\n    libtiff::TIFFGetField(tiff, TIFFTAG_STRIPBYTECOUNTS, &stripSizes);\n    uint32_t rowsPerStripe(0);\n    libtiff::TIFFGetField(tiff, TIFFTAG_ROWSPERSTRIP, &rowsPerStripe);\n    libtiff::TIFFDataType dt(libtiff::TIFF_NOTYPE);\n    libtiff::TIFFGetField(tiff, TIFFTAG_DATATYPE, &dt);\n    uint16_t ph(0);\n    libtiff::TIFFGetField(tiff, TIFFTAG_PHOTOMETRIC, &ph);\n    dir.photometric = ph;\n    dir.stripSize = (int)libtiff::TIFFStripSize(tiff);\n    dir.dataType = retrieveTiffDataType(tiff);\n\n    uint16_t YCbCrSubsampling[2] = {2, 2};\n    libtiff::TIFFGetField(tiff, TIFFTAG_YCBCRSUBSAMPLING, &YCbCrSubsampling[0], &YCbCrSubsampling[0]);\n    dir.YCbCrSubsampling[0] = YCbCrSubsampling[0];\n    dir.YCbCrSubsampling[1] = YCbCrSubsampling[1];\n\n    if (units == RESUNIT_INCH && resx > 0 && resy > 0) {\n        dir.res.x = 0.01 / resx;\n        dir.res.y = 0.01 / resy;\n    }\n    else if (units == RESUNIT_INCH && resx > 0 && resy > 0) {\n        dir.res.x = 0.0254 / resx;\n        dir.res.y = 0.0254 / resy;\n    }\n    else if (units == RESUNIT_CENTIMETER && resx > 0 && resy > 0) {\n        dir.res.x = 0.01 / resx;\n        dir.res.y = 0.01 / resy;\n    }\n    else {\n        dir.res.x = resx;\n        dir.res.y = resy;\n    }\n    dir.position = {posx, posy};\n    bool tiled = libtiff::TIFFIsTiled(tiff);\n    if (description)\n        dir.description = description;\n    if(dirchnls == 0 && (ph == 0 || ph == 1)) {\n        dirchnls = 1;\n    }\n    dir.bitsPerSample = dirbits;\n    dir.channels = dirchnls;\n    dir.height = height;\n    dir.width = width;\n    dir.tileHeight = tile_height;\n    dir.tileWidth = tile_width;\n    dir.tiled = tiled;\n    dir.compression = compress;\n    dir.rowsPerStrip = rowsPerStripe;\n    dir.slideioCompression = compressTiffToSlideio(compress);\n    dir.magnification = magnification;\n    if (comments)\n        dir.comments = comments;\n    if (userLabel)\n        dir.userLabel = userLabel;\n    dir.blankLines = nblanklines;\n    if (stripSizes) {\n        dir.rawStripSize = static_cast<uint32_t>(stripSizes[0]);\n    }\n\n    int32_t markers = 0;\n    uint32_t *offsets(nullptr);\n    libtiff::TIFFGetField(tiff, NDPI_RESTART_MARKERS, &markers, &offsets);\n    for(int index = 0; index < markers; ++index) {\n        dir.mcuStarts.push_back(offsets[index] + *stripOffset);\n    }\n\n    SLIDEIO_LOG(INFO) << \"NDPITiffTools::scanTiffDirTags-end \" << dirIndex;\n}\n\nvoid NDPITiffTools::updateJpegXRCompressedDirectoryMedatata(libtiff::TIFF* tiff, NDPITiffDirectory& dir)\n{\n    if (dir.tiled) {\n        const int tile = 0;\n        cv::Size tileSize = computeTileSize(dir, tile);\n        const int tileBufferSize = dir.channels * tileSize.width * tileSize.height * Tools::dataTypeSize(dir.dataType);\n        std::vector<uint8_t> rawTile(tileBufferSize);\n        libtiff::tmsize_t readBytes = libtiff::TIFFReadRawTile(tiff, tile, rawTile.data(), (int)rawTile.size());\n        if (readBytes <= 0) {\n            RAISE_RUNTIME_ERROR << \"TiffTools: Error reading raw tile\";\n        }\n        jpegxr_image_info info;\n        jpegxr_get_image_info((uint8_t*)rawTile.data(), (uint32_t)rawTile.size(), info);\n        dir.channels = info.channels;\n        dir.dataType = getSlideioType(info);\n    }\n}\n\nvoid slideio::NDPITiffTools::scanTiffDir(libtiff::TIFF* tiff, int dirIndex, int64_t dirOffset,\n                                         slideio::NDPITiffDirectory& dir)\n{\n    SLIDEIO_LOG(INFO) << \"NDPITiffTools::scanTiffDir-begin \" << dir.dirIndex;\n\n    if (libtiff::TIFFCurrentDirectory(tiff) != dirIndex) {\n        libtiff::TIFFSetDirectory(tiff, (short)dirIndex);\n    }\n    if (dirOffset > 0)\n        libtiff::TIFFSetSubDirectory(tiff, dirOffset);\n\n    dir.dirIndex = dirIndex;\n    dir.offset = dirOffset;\n\n    scanTiffDirTags(tiff, dirIndex, dirOffset, dir);\n    // check if we have to refine data for jpegxr compressed files\n    if(dir.slideioCompression == Compression::JpegXR) {\n        updateJpegXRCompressedDirectoryMedatata(tiff, dir);\n    }\n    dir.offset = 0;\n    long subdirs(0);\n    int64* offsets_raw(nullptr);\n    if (libtiff::TIFFGetField(tiff, TIFFTAG_SUBIFD, &subdirs, &offsets_raw)) {\n        std::vector<int64> offsets(offsets_raw, offsets_raw + subdirs);\n        if (subdirs > 0) {\n            dir.subdirectories.resize(subdirs);\n        }\n        for (int subdir = 0; subdir < subdirs; subdir++) {\n            if (libtiff::TIFFSetSubDirectory(tiff, offsets[subdir])) {\n                scanTiffDirTags(tiff, dirIndex, dir.subdirectories[subdir].offset, dir.subdirectories[subdir]);\n            }\n        }\n    }\n    SLIDEIO_LOG(INFO) << \"NDPITiffTools::scanTiffDir-end \" << dir.dirIndex;\n}\n\n\nvoid NDPITiffTools::readNotRGBStripedDir(libtiff::TIFF* file, const NDPITiffDirectory& dir, cv::_OutputArray output)\n{\n    std::vector<uint8_t> rgbaRaster(4 * dir.rowsPerStrip * dir.width);\n\n    int buff_size = dir.width * dir.height * dir.channels * Tools::dataTypeSize(dir.dataType);\n    cv::Size sizeImage = {dir.width, dir.height};\n    slideio::DataType dt = dir.dataType;\n    output.create(sizeImage, CV_MAKETYPE(slideio::CVTools::toOpencvType(dt), dir.channels));\n    cv::Mat imageRaster = output.getMat();\n    setCurrentDirectory(file, dir);\n    if (dir.offset > 0) {\n        libtiff::TIFFSetSubDirectory(file, dir.offset);\n    }\n    uint8_t* buffBegin = imageRaster.data;\n    int stripBuffSize = dir.stripSize;\n    const int imageWidth3 = dir.width * 3;\n    const int imageWidth4 = dir.width * 4;\n\n    for (int strip = 0, row = 0; row < dir.height; strip++, row += dir.rowsPerStrip, buffBegin += stripBuffSize) {\n        if ((strip + stripBuffSize) > buff_size)\n            stripBuffSize = buff_size - strip;\n\n        int stripeRows = dir.rowsPerStrip;\n        if (row + stripeRows > dir.height) {\n            stripeRows = dir.height - row;\n        }\n\n        int read = libtiff::TIFFReadRGBAStrip(file, row, (uint32_t*)rgbaRaster.data());\n        if (read != 1) {\n            RAISE_RUNTIME_ERROR << \"NDPITiffTools: Error by reading of tif strip \" << strip;\n        }\n        uint8_t* lineBegin = buffBegin;\n        uint8_t* stripeLineBegin = rgbaRaster.data();\n        for (int stripeRow = 0; stripeRow < stripeRows; ++stripeRow) {\n            uint8_t* pixelBegin = lineBegin;\n            uint8_t* stripePixelBegin = stripeLineBegin;\n            for (int column = 0; column < dir.width; ++column, pixelBegin += 3, stripePixelBegin += 4) {\n                memcpy(pixelBegin, stripePixelBegin, 3);\n            }\n            lineBegin += imageWidth3;\n            stripeLineBegin += imageWidth4;\n        }\n    }\n}\n\nvoid slideio::NDPITiffTools::readRegularStripedDir(libtiff::TIFF* file, const slideio::NDPITiffDirectory& dir,\n                                                   cv::OutputArray output)\n{\n    int buff_size = dir.width * dir.height * dir.channels * Tools::dataTypeSize(dir.dataType);\n    cv::Size sizeImage = {dir.width, dir.height};\n    slideio::DataType dt = dir.dataType;\n    output.create(sizeImage, CV_MAKETYPE(slideio::CVTools::toOpencvType(dt), dir.channels));\n    cv::Mat imageRaster = output.getMat();\n    setCurrentDirectory(file, dir);\n    if (dir.offset > 0) {\n        libtiff::TIFFSetSubDirectory(file, dir.offset);\n    }\n    uint8_t* buffBegin = imageRaster.data;\n    int stripBuffSize = dir.stripSize;\n\n    for (int strip = 0, row = 0; row < dir.height; strip++, row += dir.rowsPerStrip, buffBegin += stripBuffSize) {\n        if ((strip + stripBuffSize) > buff_size)\n            stripBuffSize = buff_size - strip;\n\n        int read = (int)libtiff::TIFFReadEncodedStrip(file, strip, buffBegin, stripBuffSize);\n        if (read <= 0) {\n            RAISE_RUNTIME_ERROR << \"NDPITiffTools: Error by reading of tif striped directory\";\n        }\n    }\n    return;\n}\n\nvoid NDPITiffTools::readJpegXRStripedDir(libtiff::TIFF* tiff, const NDPITiffDirectory& dir, cv::_OutputArray output) {\n    if (dir.interleaved) {\n        setCurrentDirectory(tiff, dir);\n    \t// process interleaved channels\n\t\tconst int tileBufferSize = dir.channels * dir.width * dir.height * Tools::dataTypeSize(dir.dataType);\n\t\tstd::vector<uint8_t> rawTile(tileBufferSize);\n\t\tconst size_t readBytes = libtiff::TIFFReadRawStrip(tiff, 0, rawTile.data(), static_cast<int>(rawTile.size()));\n\t\tif (readBytes <= 0) {\n\t\t    RAISE_RUNTIME_ERROR << \"TiffTools: Error reading raw tile\";\n\t\t}\n\t\tdecodeJxrBlock(rawTile.data(), readBytes, output);\n\t}\n\telse {\n\t    RAISE_RUNTIME_ERROR << \"TiffTools: jpegxr compressed directory must be interleaved!\";\n\t}   \n}\n\n\nvoid slideio::NDPITiffTools::readStripedDir(libtiff::TIFF* file, const slideio::NDPITiffDirectory& dir,\n                                            cv::OutputArray output)\n{\n    if (!dir.interleaved) {\n        RAISE_RUNTIME_ERROR << \"Planar striped images are not supported\";\n    }\n    if(dir.slideioCompression == Compression::JpegXR) {\n        readJpegXRStripedDir(file, dir, output);\n    }\n    else {\n        readRegularStripedDir(file, dir, output);\n        if (dir.photometric == 6) {\n            const cv::Mat imageYCbCr = output.getMat();\n            cv::Mat image;\n            cv::cvtColor(imageYCbCr, image, cv::COLOR_YCrCb2BGR);\n            output.assign(image);\n        }\n    }\n\n    return;\n}\n\nvoid NDPITiffTools::readJpegXRTile(libtiff::TIFF* tiff, const slideio::NDPITiffDirectory& dir, int tile,\n                                   const std::vector<int>& vector, cv::OutputArray output)\n{\n    cv::Size tileSize = computeTileSize(dir, tile);\n    const int tileBufferSize = dir.channels * tileSize.width * tileSize.height * Tools::dataTypeSize(dir.dataType);\n    std::vector<uint8_t> rawTile(tileBufferSize);\n    if (dir.interleaved) {\n        // process interleaved channels\n        libtiff::tmsize_t readBytes = libtiff::TIFFReadRawTile(tiff, tile, rawTile.data(), (int)rawTile.size());\n        if (readBytes <= 0) {\n            RAISE_RUNTIME_ERROR << \"TiffTools: Error reading raw tile\";\n        }\n        decodeJxrBlock(rawTile.data(), readBytes, output);\n    }\n    else {\n        RAISE_RUNTIME_ERROR << \"TiffTools: jpegxr compressed directory must be interleaved!\";\n    }\n}\n\n\nvoid slideio::NDPITiffTools::readTile(libtiff::TIFF* hFile, const slideio::NDPITiffDirectory& dir, int tile,\n                                      const std::vector<int>& channelIndices, cv::OutputArray output)\n{\n    if (!dir.tiled) {\n        RAISE_RUNTIME_ERROR << \"NDPITiffTools: Expected tiled configuration, received striped\";\n    }\n    setCurrentDirectory(hFile, dir);\n\n    if (dir.compression == 0x5852) {\n        readJpegXRTile(hFile, dir, tile, channelIndices, output);\n    }\n    else if (dir.photometric == 6 || dir.photometric == 8 || dir.photometric == 9 || dir.photometric == 10) {\n        readNotRGBTile(hFile, dir, tile, channelIndices, output);\n    }\n    else {\n        readRegularTile(hFile, dir, tile, channelIndices, output);\n    }\n}\n\nint NDPITiffTools::computeStripHeight(int height, int rowsPerStrip, int strip)\n{\n    const int stripCount = (height - 1) / rowsPerStrip + 1;\n    if (strip >= stripCount || strip < 0) {\n        RAISE_RUNTIME_ERROR << \"Invalid strip number: \" << strip << \". Number of strips: \" << stripCount;\n    }\n    int lineCount = rowsPerStrip;\n    if (strip == (stripCount - 1)) {\n        lineCount = height - strip * rowsPerStrip;\n    }\n    return lineCount;\n}\n\ncv::Size NDPITiffTools::computeTileSize(const NDPITiffDirectory& dir, int tile)\n{\n    cv::Size const tileCounts = computeTileCounts(dir);\n    const int tileCount = tileCounts.width * tileCounts.height;\n    if (tile >= tileCount || tile < 0) {\n        RAISE_RUNTIME_ERROR << \"Invalid tile number: \" << tile << \". Number of tiles: \" << tileCount;\n    }\n    const int tileRows = tileCounts.height;\n    const int tileCols = tileCounts.width;\n    const int tileRow = tile / tileCols;\n    const int tileCol = tile - tileRow * tileCols;\n    cv::Size tileSize(dir.tileWidth, dir.tileHeight);\n    if (tileRow == (tileRows - 1)) {\n        tileSize.height = dir.height - dir.tileHeight * tileRow;\n\n    }\n    if (tileCol == (tileCols - 1)) {\n        tileSize.width = dir.width - dir.tileWidth * tileCol;\n    }\n    return tileSize;\n}\n\ncv::Size NDPITiffTools::computeTileCounts(const NDPITiffDirectory& dir)\n{\n    const int tileRows = (dir.height - 1) / dir.tileHeight + 1;\n    const int tileCols = (dir.width - 1) / dir.tileWidth + 1;\n    cv::Size tileCounts(tileCols, tileRows);\n    return tileCounts;\n}\n\nstruct ErrorManager\n{\n    struct jpeg_error_mgr pub; /* \"public\" fields */\n    jmp_buf setjmp_buffer; /* for return to caller */\n};\n\ntypedef struct ErrorManager* my_error_ptr;\n\nvoid ErrorExit(j_common_ptr cinfo)\n{\n    /* cinfo->err really points to a ErrorManager struct, so coerce pointer */\n    my_error_ptr myerr = (my_error_ptr)cinfo->err;\n    /* Always display the message. */\n    /* We could postpone this until after returning, if we chose. */\n    (*cinfo->err->output_message)(cinfo);\n    /* Return control to the setjmp point */\n    longjmp(myerr->setjmp_buffer, 1);\n}\n\nvoid NDPITiffTools::readJpegScanlines(libtiff::TIFF* tiff, FILE* file, const NDPITiffDirectory& dir, int firstScanline,\n                                  int numberScanlines, const std::vector<int>& channelIndices, cv::_OutputArray output)\n{\n    if(tiff == nullptr) {\n        RAISE_RUNTIME_ERROR << \"NDPITiffTools::readJpegScanlines tiff pointer is not set\";\n    }\n    if(file == nullptr) {\n        RAISE_RUNTIME_ERROR << \"NDPITiffTools::readJpegScanlines file pointer is not set\";\n    }\n    if(dir.slideioCompression != Compression::Jpeg) {\n        RAISE_RUNTIME_ERROR << \"NDPITiffTools::readJpegScanlines: Attempt to read jpeg scanlines from non jpeg directory\";\n    }\n\n    setCurrentDirectory(tiff, dir);\n\n    uint64_t stripeOffset = libtiff::TIFFGetStrileOffset(tiff, 0);\n    int ret = Tools::setFilePos(file, stripeOffset, SEEK_SET);\n    jpeg_decompress_struct cinfo;\n    ErrorManager jerr;\n\n    cinfo.err = jpeg_std_error(&jerr.pub);\n    jerr.pub.error_exit = ErrorExit;\n\n    if (setjmp(jerr.setjmp_buffer)) {\n        /* If we get here, the JPEG code has signaled an error.\n         * We need to clean up the JPEG object, close the input file, and return.*/\n        jpeg_destroy_decompress(&cinfo);\n        return;\n    }\n\n    jpeg_create_decompress(&cinfo);\n    jpeg_stdio_src(&cinfo, file);\n    cinfo.image_width = dir.width;\n    cinfo.image_height = dir.height;\n    jpeg_read_header(&cinfo, TRUE);\n    jpeg_start_decompress(&cinfo);\n    int row_stride = cinfo.output_width * cinfo.output_components;\n\n    if (firstScanline) {\n        int skipped = jpeg_skip_scanlines(&cinfo, firstScanline);\n        if (skipped != firstScanline) {\n            RAISE_RUNTIME_ERROR << \"NDPIImageDriver: error by skipping scanlines. Expected:\" << firstScanline <<\n                \". Skipped: \" << skipped;\n        }\n    }\n    output.create(numberScanlines, cinfo.output_width, CV_MAKETYPE(CV_8U, cinfo.output_components));\n    cv::Mat mat = output.getMat();\n    mat.setTo(cv::Scalar(0));\n    uint8_t* rowBegin = mat.data;\n\n    for (int scanline = 0; scanline < numberScanlines; ++scanline) {\n        int read = jpeg_read_scanlines(&cinfo, &rowBegin, 1);\n        if (read != 1) {\n            RAISE_RUNTIME_ERROR << \"NDPIImageDriver: error by reading scanline \" << scanline << \" of \" <<\n                numberScanlines;\n        }\n        rowBegin += row_stride;\n    }\n    const int rowsLeft = dir.height - firstScanline - numberScanlines;\n    if (rowsLeft > 0) {\n        jpeg_skip_scanlines(&cinfo, rowsLeft);\n    }\n    jpeg_finish_decompress(&cinfo);\n    jpeg_destroy_decompress(&cinfo);\n}\n\n\nvoid NDPITiffTools::readJpegDirectoryRegion(libtiff::TIFF* tiff, const std::string& filePath, const cv::Rect& region,\n                                            const NDPITiffDirectory& dir, const std::vector<int>& channelIndices,\n                                            cv::_OutputArray output)\n{\n    SLIDEIO_LOG(INFO)   << \"NDPITiffTools::readJpegDirectoryRegion:\"\n                        << \"Reading JPEG directory region: (\"\n                        << region.x << \",\" << region.y << \", \"\n                        << region.width << \", \" << region.height << \")\";\n    if (dir.tiled) {\n        RAISE_RUNTIME_ERROR << \"Stripped directory expected\";\n    }\n    if (dir.rowsPerStrip != dir.height) {\n        RAISE_RUNTIME_ERROR << \"One strip directory is expected. Rows per strip: \" << dir.rowsPerStrip << \". Height:\" <<\n            dir.height;\n    }\n    setCurrentDirectory(tiff, dir);\n\n    std::unique_ptr<FILE, Tools::FileDeleter> sfile(Tools::openFile(filePath.c_str(), \"rb\"));\n    FILE* file = sfile.get();\n    if (!file) {\n        RAISE_RUNTIME_ERROR << \"NDPI Image Driver: Cannot open file \" << filePath;\n    }\n\n    const bool allChannels = Tools::isCompleteChannelList(channelIndices, dir.channels);\n\n    const slideio::DataType dt = dir.dataType;\n    const int dataSize = slideio::Tools::dataTypeSize(dt);\n    const int cvType = slideio::CVTools::toOpencvType(dt);\n    output.create(region.size(), CV_MAKETYPE(cvType, allChannels?dir.channels:static_cast<int>(channelIndices.size())));\n    cv::Mat outputMat = output.getMat();\n    outputMat.setTo(0);\n\n    const int firstScanline = region.y;\n    const int numberScanlines = region.height;\n\n    uint64_t stripeOffset = libtiff::TIFFGetStrileOffset(tiff, 0);\n    int ret = Tools::setFilePos(file, stripeOffset, SEEK_SET);\n    jpeg_decompress_struct cinfo{};\n    ErrorManager jErr{};\n\n    cinfo.err = jpeg_std_error(&jErr.pub);\n    jErr.pub.error_exit = ErrorExit;\n\n    if (setjmp(jErr.setjmp_buffer)) {\n        /* If we get here, the JPEG code has signaled an error.\n         * We need to clean up the JPEG object, close the input file, and return.*/\n        jpeg_destroy_decompress(&cinfo);\n        return;\n    }\n\n    jpeg_create_decompress(&cinfo);\n    jpeg_stdio_src(&cinfo, file);\n    cinfo.image_width = dir.width;\n    cinfo.image_height = dir.height;\n    jpeg_read_header(&cinfo, TRUE);\n    jpeg_start_decompress(&cinfo);\n\n\n    if (firstScanline) {\n        SLIDEIO_LOG(INFO) << \"NDPITiffTools::readJpegDirectoryRegion: skipping \" << firstScanline << \" scanlines\";\n        int skipped = jpeg_skip_scanlines(&cinfo, firstScanline);\n        if (skipped != firstScanline) {\n            RAISE_RUNTIME_ERROR << \"NDPIImageDriver: error by skipping scanlines. Expected:\" << firstScanline <<\n                \". Skipped: \" << skipped;\n        }\n    }\n    int bufferRowStride = cinfo.output_width * cinfo.output_components * slideio::Tools::dataTypeSize(dt);\n    const int MAX_BUFFER_SIZE = 10 * 1024 * 1024;\n    const int numBufferLines = std::min(dir.height, MAX_BUFFER_SIZE / bufferRowStride);\n    cv::Mat imageBuffer(numBufferLines, dir.width, CV_MAKETYPE(cvType, cinfo.output_components));\n    imageBuffer.setTo(cv::Scalar(255, 255, 255));\n\n    // channel mapping\n    std::vector<int> fromTo(channelIndices.size() * 2);\n    for (int index = 0; index < channelIndices.size(); ++index) {\n        int location = index * 2;\n        fromTo[location] = channelIndices[index];\n        fromTo[location + 1] = index;\n    }\n\n    uint8_t* rowBegin = imageBuffer.data;\n    int imageLine(0), bufferLine(0), bufferIndex(0);\n    bool startNewBlock(true);\n    SLIDEIO_LOG(INFO) << \"NDPITiffTools::readJpegDirectoryRegion: reading \" << numberScanlines << \" scanlines\";\n    for (; imageLine < numberScanlines; ++imageLine, ++bufferLine, rowBegin += bufferRowStride) {\n        if(startNewBlock) {\n            startNewBlock = false;\n            rowBegin = imageBuffer.data;\n            bufferLine = 0;\n        }\n        int read = jpeg_read_scanlines(&cinfo, &rowBegin, 1);\n        if (read != 1) {\n            RAISE_RUNTIME_ERROR << \"NDPIImageDriver: error by reading scanline \" << imageLine << \" of \" <<\n                numberScanlines;\n        }\n        if (bufferLine == (numBufferLines - 1) || imageLine == (numberScanlines - 1)) {\n            // copy buffer to output raster\n            const int firstLine = bufferIndex * numBufferLines;\n            const int numbLeftLines = numberScanlines - firstLine;\n            const int numValidLines = std::min(numbLeftLines, numBufferLines);\n\n            cv::Rect srcRoi = {region.x, 0, region.width, numValidLines };\n            cv::Rect dstRoi = {0, firstLine, region.width, numValidLines };\n            cv::Mat srcImage(imageBuffer, srcRoi);\n            cv::Mat dstImage(outputMat, dstRoi);\n            if (allChannels) {\n                srcImage.copyTo(dstImage);\n            }\n            else {\n                cv::mixChannels(&srcImage, 1, &dstImage, 1, fromTo.data(), channelIndices.size());\n            }\n            bufferIndex++;\n            startNewBlock = true;\n        }\n    }\n    const int rowsLeft = dir.height - firstScanline - numberScanlines;\n    if (rowsLeft > 0) {\n        jpeg_skip_scanlines(&cinfo, rowsLeft);\n    }\n\n    jpeg_finish_decompress(&cinfo);\n    jpeg_destroy_decompress(&cinfo);\n}\n\nvoid NDPITiffTools::readDirectoryJpegHeaders(NDPIFile* ndpi, NDPITiffDirectory& dir)\n{\n    if (dir.height == dir.rowsPerStrip && !dir.mcuStarts.empty()) {\n        const auto dirIndex = dir.dirIndex;\n\n        libtiff::TIFF* tiff = ndpi->getTiffHandle();\n        setCurrentDirectory(tiff, dir);\n\n        std::unique_ptr<FILE, Tools::FileDeleter> sfile(Tools::openFile(ndpi->getFilePath(), \"rb\"));\n        FILE* file = sfile.get();\n        if (!file) {\n            RAISE_RUNTIME_ERROR << \"NDPI Image Driver: Cannot open file \" << ndpi->getFilePath();\n        }\n\n        const auto stripeOffset = libtiff::TIFFGetStrileOffset(tiff, 0);\n\n        int ret = Tools::setFilePos(file, stripeOffset, SEEK_SET);\n        if (ret) {\n            RAISE_RUNTIME_ERROR << \"NDPI Image Driver: Cannot seek file \" << ndpi->getFilePath() << \" to offset \"\n                << stripeOffset << \". For directory \" << dirIndex << \". Code: \" << ret;\n        }\n        cv::Size tileSize = NDPITiffTools::computeMCUTileSize(file, cv::Size(dir.width, dir.height));\n\n        ret = Tools::setFilePos(file, stripeOffset, SEEK_SET);\n        if (ret) {\n            RAISE_RUNTIME_ERROR << \"NDPI Image Driver: Cannot seek file \" << ndpi->getFilePath() << \" to offset \"\n                << stripeOffset << \". For directory \" << dirIndex << \". Code: \" << ret;\n        }\n        const std::pair<uint64_t, uint64_t> headerInfo = NDPITiffTools::getJpegHeaderPos(file);\n        dir.tileWidth = tileSize.width;\n        dir.tileHeight = tileSize.height;\n        dir.jpegHeaderOffset = stripeOffset;\n        dir.jpegHeaderSize = static_cast<uint32_t>(headerInfo.second - stripeOffset);\n        dir.jpegSOFMarker = headerInfo.first;\n\n    }\n}\n\nvoid NDPITiffTools::readUncompressedScanlines(libtiff::TIFF* tiff, FILE* file, const NDPITiffDirectory& dir, int firstScanline,\n    int numberScanlines, const std::vector<int>& vector, cv::_OutputArray tileRaster) {\n    if(tiff == nullptr) {\n        RAISE_RUNTIME_ERROR << \"NDPITiffTools::readUncompressedScanlines tiff pointer is not set\";\n    }\n    if(dir.slideioCompression != Compression::Uncompressed) {\n        RAISE_RUNTIME_ERROR << \"NDPITiffTools::readUncompressedScanlines: Attempt to read uncompressed scanlines from non uncompressed directory\";\n    }\n    if(dir.tiled) {\n        RAISE_RUNTIME_ERROR << \"NDPITiffTools::readUncompressedScanlines: Attempt to read uncompressed scanlines from tiled directory\";\n    }\n    if(file == nullptr) {\n        RAISE_RUNTIME_ERROR << \"NDPITiffTools::readUncompressedScanlines file pointer is not set\";\n    }\n}\n\nvoid NDPITiffTools::readJpegXRStrip(libtiff::TIFF* tiff, const NDPITiffDirectory& dir, int strip,\n                                    const std::vector<int>& vector, cv::_OutputArray output)\n{\n    const int lineCount = computeStripHeight(dir.height, dir.rowsPerStrip, strip);\n    const int stripSize = dir.channels * lineCount * dir.width * Tools::dataTypeSize(dir.dataType);\n    std::vector<uint8_t> rawStrip(stripSize);\n    if (dir.interleaved) {\n        // process interleaved channels\n        libtiff::tmsize_t readBytes = libtiff::TIFFReadRawStrip(tiff, strip, rawStrip.data(), (int)rawStrip.size());\n        if (readBytes <= 0) {\n            RAISE_RUNTIME_ERROR << \"TiffTools: Error reading raw strip!\";\n        }\n        decodeJxrBlock(rawStrip.data(), readBytes, output);\n    }\n    else {\n        RAISE_RUNTIME_ERROR << \"JpegXR compressed strip must be interleaved\";\n    }\n}\n\nvoid NDPITiffTools::readNotRGBStrip(libtiff::TIFF* hFile, const NDPITiffDirectory& dir, int strip,\n                                    const std::vector<int>& channelIndices, cv::_OutputArray output)\n{\n    const int lineCount = computeStripHeight(dir.height, dir.rowsPerStrip, strip);\n    cv::Size stripSize = {dir.width, lineCount};\n    slideio::DataType dt = dir.dataType;\n    cv::Mat stripRaster;\n    stripRaster.create(stripSize, CV_MAKETYPE(slideio::CVTools::toOpencvType(dt), 4));\n    setCurrentDirectory(hFile, dir);\n    if (dir.offset > 0) {\n        libtiff::TIFFSetSubDirectory(hFile, dir.offset);\n    }\n    uint32_t* buffBegin = reinterpret_cast<uint32_t*>(stripRaster.data);\n    auto readBytes = libtiff::TIFFReadRGBAStrip(hFile, strip, buffBegin);\n    if (readBytes <= 0) {\n        RAISE_RUNTIME_ERROR << \"NDPITiffTools: error reading encoded strip \" << strip\n            << \" of directory \" << dir.dirIndex << \". Compression: \" << (int)(dir.compression);\n\n    }\n\n    if (channelIndices.empty()) {\n        std::vector<cv::Mat> channelRasters;\n        channelRasters.resize(3);\n        for (int channelIndex = 0; channelIndex < 3; ++channelIndex) {\n            cv::extractChannel(stripRaster, channelRasters[channelIndex], channelIndex);\n        }\n        cv::merge(channelRasters, output);\n    }\n    else if (channelIndices.size() == 1) {\n        cv::extractChannel(stripRaster, output, channelIndices[0]);\n    }\n    else {\n        std::vector<cv::Mat> channelRasters;\n        channelRasters.resize(channelIndices.size());\n        for (int channelIndex : channelIndices) {\n            cv::extractChannel(stripRaster, channelRasters[channelIndex], channelIndices[channelIndex]);\n        }\n        cv::merge(channelRasters, output);\n    }\n}\n\nvoid NDPITiffTools::readRegularStrip(libtiff::TIFF* tiff, const NDPITiffDirectory& dir, int strip,\n                                     const std::vector<int>& channelIndices, cv::_OutputArray output)\n{\n    const int lineCount = computeStripHeight(dir.height, dir.rowsPerStrip, strip);\n    cv::Size stripSize = {dir.width, lineCount};\n    slideio::DataType dt = dir.dataType;\n    cv::Mat stripRaster;\n    stripRaster.create(stripSize, CV_MAKETYPE(slideio::CVTools::toOpencvType(dt), dir.channels));\n    setCurrentDirectory(tiff, dir);\n    if (dir.offset > 0) {\n        libtiff::TIFFSetSubDirectory(tiff, dir.offset);\n    }\n    uint8_t* buff_begin = stripRaster.data;\n    auto buf_size = stripRaster.total() * stripRaster.elemSize();\n    auto readBytes = libtiff::TIFFReadEncodedStrip(tiff, strip, buff_begin, buf_size);\n    if (readBytes <= 0) {\n        RAISE_RUNTIME_ERROR << \"NDPITiffTools: error reading encoded strip \" << strip\n            << \" of directory \" << dir.dirIndex << \". Compression: \" << (int)(dir.compression);\n    }\n    if (channelIndices.empty()) {\n        stripRaster.copyTo(output);\n    }\n    else if (channelIndices.size() == 1) {\n        cv::extractChannel(stripRaster, output, channelIndices[0]);\n    }\n    else {\n        std::vector<cv::Mat> channelRasters;\n        channelRasters.resize(channelIndices.size());\n        for (int channelIndex : channelIndices) {\n            cv::extractChannel(stripRaster, channelRasters[channelIndex], channelIndices[channelIndex]);\n        }\n        cv::merge(channelRasters, output);\n    }\n}\n\nvoid NDPITiffTools::readStripe(libtiff::TIFF* hFile, const slideio::NDPITiffDirectory& dir, int strip,\n                              const std::vector<int>& channelIndices, cv::OutputArray output)\n{\n    if (dir.tiled) {\n        RAISE_RUNTIME_ERROR << \"NDPITiffTools: Expected tiled configuration, received striped\";\n    }\n    setCurrentDirectory(hFile, dir);\n\n    if (dir.compression == 0x5852) {\n        readJpegXRStrip(hFile, dir, strip, channelIndices, output);\n    }\n    else {\n        readRegularStrip(hFile, dir, strip, channelIndices, output);\n        if (dir.photometric == 6) {\n            const cv::Mat imageYCbCr = output.getMat();\n            cv::Mat image;\n            cv::cvtColor(imageYCbCr, image, cv::COLOR_YCrCb2RGB);\n            output.assign(image);\n        }\n    }\n}\n\nvoid slideio::NDPITiffTools::readRegularTile(libtiff::TIFF* hFile, const slideio::NDPITiffDirectory& dir, int tile,\n                                             const std::vector<int>& channelIndices, cv::OutputArray output)\n{\n    cv::Size tileSize = {dir.tileWidth, dir.tileHeight};\n    slideio::DataType dt = dir.dataType;\n    cv::Mat tileRaster;\n    tileRaster.create(tileSize, CV_MAKETYPE(slideio::CVTools::toOpencvType(dt), dir.channels));\n    setCurrentDirectory(hFile, dir);\n    if (dir.offset > 0) {\n        libtiff::TIFFSetSubDirectory(hFile, dir.offset);\n    }\n    uint8_t* buff_begin = tileRaster.data;\n    auto buf_size = tileRaster.total() * tileRaster.elemSize();\n    auto readBytes = libtiff::TIFFReadEncodedTile(hFile, tile, buff_begin, buf_size);\n    if (readBytes <= 0) {\n        RAISE_RUNTIME_ERROR << \"NDPITiffTools: error reading encoded tiff tile \" << tile\n            << \" of directory \" << dir.dirIndex << \". Compression: \" << dir.compression;\n    }\n    if (channelIndices.empty()) {\n        tileRaster.copyTo(output);\n    }\n    else if (channelIndices.size() == 1) {\n        cv::extractChannel(tileRaster, output, channelIndices[0]);\n    }\n    else {\n        std::vector<cv::Mat> channelRasters;\n        channelRasters.resize(channelIndices.size());\n        for (int channelIndex : channelIndices) {\n            cv::extractChannel(tileRaster, channelRasters[channelIndex], channelIndices[channelIndex]);\n        }\n        cv::merge(channelRasters, output);\n    }\n}\n\n\nvoid NDPITiffTools::readNotRGBTile(libtiff::TIFF* hFile, const slideio::NDPITiffDirectory& dir, int tile,\n                                   const std::vector<int>& channelIndices, cv::OutputArray output)\n{\n    cv::Size tileSize = computeTileSize(dir, tile);\n    slideio::DataType dt = dir.dataType;\n    cv::Mat tileRaster;\n    tileRaster.create(tileSize, CV_MAKETYPE(slideio::CVTools::toOpencvType(dt), 4));\n    setCurrentDirectory(hFile, dir);\n    if (dir.offset > 0) {\n        libtiff::TIFFSetSubDirectory(hFile, dir.offset);\n    }\n    uint32_t* buffBegin = reinterpret_cast<uint32_t*>(tileRaster.data);\n\n    int cols = (dir.width - 1) / dir.tileWidth + 1;\n    int rows = (dir.height - 1) / dir.tileHeight + 1;\n    int row = tile / cols;\n    int col = tile - row * cols;\n    int tileX = col * dir.tileWidth;\n    int tileY = row * dir.tileHeight;\n    auto readBytes = libtiff::TIFFReadRGBATile(hFile, tileX, tileY, buffBegin);\n    if (readBytes <= 0) {\n        RAISE_RUNTIME_ERROR << \"NDPITiffTools: error reading encoded tiff tile \" << tile\n            << \" of directory \" << dir.dirIndex << \" Compression: \" << dir.compression;\n    }\n    cv::Mat flipped;\n    if (channelIndices.empty()) {\n        std::vector<cv::Mat> channelRasters;\n        channelRasters.resize(3);\n        for (int channelIndex = 0; channelIndex < 3; ++channelIndex) {\n            cv::extractChannel(tileRaster, channelRasters[channelIndex], channelIndex);\n        }\n        cv::merge(channelRasters, flipped);\n    }\n    else if (channelIndices.size() == 1) {\n        cv::extractChannel(tileRaster, flipped, channelIndices[0]);\n    }\n    else {\n        std::vector<cv::Mat> channelRasters;\n        channelRasters.resize(channelIndices.size());\n        for (int channelIndex : channelIndices) {\n            cv::extractChannel(tileRaster, channelRasters[channelIndex], channelIndices[channelIndex]);\n        }\n        cv::merge(channelRasters, flipped);\n    }\n    cv::flip(flipped, output, 0);\n}\n\n\nvoid slideio::NDPITiffTools::setCurrentDirectory(libtiff::TIFF* hFile, const slideio::NDPITiffDirectory& dir)\n{\n    if (!libtiff::TIFFSetDirectory(hFile, static_cast<uint16_t>(dir.dirIndex))) {\n        RAISE_RUNTIME_ERROR << \"NDPITiffTools: error by setting current directory \" << dir.dirIndex;\n    }\n    if (dir.offset > 0) {\n        if (!libtiff::TIFFSetSubDirectory(hFile, dir.offset)) {\n            RAISE_RUNTIME_ERROR << \"NDPITiffTools: error by setting current sub-directory. Directory:\"\n                << dir.dirIndex\n                << \".Offset:\" << dir.offset;\n        }\n    }\n}\n\nvoid slideio::NDPITiffTools::decodeJxrBlock(const uint8_t* data, size_t dataBlockSize, cv::OutputArray output)\n{\n    jpegxr_image_info info = {};\n    jpegxr_get_image_info((uint8_t*)data, (uint32_t)dataBlockSize, info);\n    int type = getCvType(info);\n    output.create(info.height, info.width, CV_MAKETYPE(type, info.channels));\n    cv::Mat mat = output.getMat();\n    mat.setTo(cv::Scalar(0));\n    uint8_t* outputBuff = mat.data;\n    uint32_t ouputBuffSize = (int)(mat.total() * mat.elemSize());\n    jpegxr_decompress((uint8_t*)data, (uint32_t)dataBlockSize, outputBuff, ouputBuffSize);\n}\n\ncv::Size NDPITiffTools::computeMCUTileSize(FILE* file, const cv::Size& dirSize)\n{\n    int tileWidth = 0;\n    int tileHeight = 0;\n    jpeg_decompress_struct cinfo = {};\n    ErrorManager jerr = {};\n    cinfo.err = jpeg_std_error(&jerr.pub);\n    jerr.pub.error_exit = ErrorExit;\n    jpeg_create_decompress(&cinfo);\n    jpeg_stdio_src(&cinfo, file);\n    cinfo.image_width = dirSize.width;\n    cinfo.image_height = dirSize.height;\n    jpeg_read_header(&cinfo, TRUE);\n    jpeg_start_decompress(&cinfo);\n    cinfo.output_scanline = cinfo.output_width;\n    uint32_t mcuWidth = cinfo.max_h_samp_factor * DCTSIZE;\n    uint32_t mcuHeight = cinfo.max_v_samp_factor * DCTSIZE;\n    uint32_t mcuPerRow = (dirSize.width + mcuWidth - 1) / mcuWidth;\n    if(cinfo.restart_interval >0 && cinfo.restart_interval <= mcuPerRow) {\n        if ((mcuPerRow % cinfo.restart_interval) == 0) {\n            tileWidth = mcuWidth * cinfo.restart_interval;\n            tileHeight = mcuHeight;\n        }\n    }\n    cinfo.output_scanline = cinfo.output_height; // otherwise libjpeg crashes\n    jpeg_finish_decompress(&cinfo);\n    jpeg_destroy_decompress(&cinfo);\n    return {tileWidth, tileHeight};\n}\n\nstd::pair<uint64_t, uint64_t> NDPITiffTools::getJpegHeaderPos(FILE* file)\n{\n    uint64_t headerStop = 0;\n    uint64_t SOFmarker = 0;\n    uint8_t buff[2];\n    while(true) {\n        uint64_t pos = Tools::getFilePos(file);\n        size_t count = fread(buff, sizeof(uint8_t), 2, file);\n        if(count != 2) {\n            RAISE_RUNTIME_ERROR << \"NDPITiffTools: error by reading marker from jpeg stream.\";\n        }\n        if (buff[0] != 0xFF) {\n            RAISE_RUNTIME_ERROR << \"NDPITiffTools: error by reading jpeg stream. Expected 0xFF\";\n        }\n        uint8_t marker = buff[1];\n        if(marker == 0xD8) {\n           continue;  // SOI marker\n        }\n        // SOF marker\n        if ((marker >= 0xC0 && marker <= 0xC3) ||\n            (marker >= 0xC5 && marker <= 0xC7) ||\n            (marker >= 0xC9 && marker <= 0xCB) ||\n            (marker >= 0xCD && marker <= 0xCF)) {\n            SOFmarker = pos;\n        }\n        uint16_t length = 0;\n        count = fread(&length, sizeof(length), 1, file);\n        if(count != 1) {\n            RAISE_RUNTIME_ERROR << \"NDPITiffTools: error by reading marker length from jpeg stream.\";\n        }\n        if(Endian::isLittleEndian()) {\n            length = Endian::bigToLittleEndian16(length);\n        }\n        Tools::setFilePos(file, pos + sizeof(buff) + length, SEEK_SET);\n        if(marker == 0xDA) {\n            headerStop = Tools::getFilePos(file);\n            break;\n        }\n    }\n\n    return {SOFmarker, headerStop };\n}\n\nvoid NDPITiffTools::fixJpegHeader(const NDPITiffDirectory& dir, uint8_t* data) {\n    const uint16_t jpegMaxDimension = 65500L;\n    const uint8_t  jpegMaxDimensionHigh = ((jpegMaxDimension >> 8) & 0xff);\n    const uint8_t  jpegMaxDimensionLow = (jpegMaxDimension & 0xff);\n\n    const int64_t sizeOffset = dir.jpegSOFMarker - dir.jpegHeaderOffset + 5;\n    const uint16_t height = (data[sizeOffset + 0] << 8) + data[sizeOffset + 1];\n    if (height > jpegMaxDimension || height == 0) {\n        data[sizeOffset + 0] = jpegMaxDimensionHigh;\n        data[sizeOffset + 1] = jpegMaxDimensionLow;\n    }\n    const uint16_t width = (data[sizeOffset + 2] << 8) + data[sizeOffset + 3];\n    if (width > jpegMaxDimension || width == 0) {\n        data[sizeOffset + 2] = jpegMaxDimensionHigh;\n        data[sizeOffset + 3] = jpegMaxDimensionLow;\n    }\n}\n\nvoid NDPITiffTools::readMCUTile(FILE* file, const NDPITiffDirectory& dir, int tile, cv::OutputArray output)\n{\n    if(tile>=dir.mcuStarts.size()) {\n        RAISE_RUNTIME_ERROR << \"NDPITiffTools: tile index is out of range (0-\"\n            << dir.mcuStarts.size() << \"). Received:\" << tile;\n    }\n    if(file ==nullptr) {\n        RAISE_RUNTIME_ERROR << \"NDPITiffTools: file pointer is not set\";\n    }\n    // read jpeg header\n    const uint64_t headerOffset = dir.jpegHeaderOffset;\n    const uint32_t headerSize = dir.jpegHeaderSize;\n    const uint64_t tileOffset = dir.mcuStarts[tile];\n\n    uint32_t tileSize = 0;\n    if(tile < dir.mcuStarts.size()-1) {\n        tileSize = static_cast<uint32_t>(dir.mcuStarts[tile + 1] - tileOffset);\n    }\n    else {\n        uint64_t stripEndOffset = dir.jpegHeaderOffset + dir.rawStripSize;\n        tileSize = static_cast<uint32_t>(stripEndOffset - tileOffset);\n    }\n    std::vector<uint8_t> tileData(headerSize + tileSize);\n\n    Tools::setFilePos(file, headerOffset, SEEK_SET);\n    auto count = fread(tileData.data(), sizeof(uint8_t), headerSize, file);\n    if(count != headerSize) {\n        RAISE_RUNTIME_ERROR << \"NDPITiffTools: error by reading jpeg header. Expected:\" << headerSize << \". Read:\" << count;\n    }\n\n    Tools::setFilePos(file, tileOffset, SEEK_SET);\n    count = fread(tileData.data() + headerSize, sizeof(uint8_t), tileSize, file);\n    if(count != tileSize) {\n        RAISE_RUNTIME_ERROR << \"NDPITiffTools: error by reading jpeg tile. Expected:\" << tileSize << \". Read:\" << count;\n    }\n    if(tileData[tileData.size() - 2] != 0xFF) {\n        RAISE_RUNTIME_ERROR << \"NDPITiffTools: error by reading jpeg tile. Expected 0xFF.\";\n    }\n\n    tileData[tileData.size() - 1] = JPEG_EOI; // End of image marker\n\n    fixJpegHeader(dir, (uint8_t*)tileData.data());\n    jpeglibDecodeTile(tileData.data(), tileData.size(), cv::Size(dir.tileWidth, dir.tileHeight), output);\n\n}\n\nvoid NDPITiffTools::jpeglibDecodeTile(const uint8_t* jpg_buffer, size_t jpg_size, const cv::Size& tileSize, cv::OutputArray output)\n{\n    // code derived from: https://gist.github.com/PhirePhly/3080633\n    struct jpeg_decompress_struct cinfo {};\n    struct jpeg_error_mgr jerr {};\n\n    cinfo.err = jpeg_std_error(&jerr);\n    // Allocate a new decompress struct, with the default error handler.\n    // The default error handler will exit() on pretty much any issue,\n    // so it's likely you'll want to replace it or supplement it with\n    // your own.\n    jpeg_create_decompress(&cinfo);\n    jpeg_mem_src(&cinfo, jpg_buffer, static_cast<unsigned long>(jpg_size));\n    // Have the decompressor scan the jpeg header. This won't populate\n    // the cinfo struct output fields, but will indicate if the\n    // jpeg is valid.\n    auto rc = jpeg_read_header(&cinfo, TRUE);\n    cinfo.scale_num = 1;\n    cinfo.scale_denom = 1;\n    cinfo.image_width = tileSize.width;\n    cinfo.image_height = tileSize.height;\n    cinfo.out_color_space = JCS_EXT_RGB;\n\n    if (rc != 1) {\n        jpeg_destroy_decompress(&cinfo);\n        RAISE_RUNTIME_ERROR << \"Invalid jpeg stream. JpegLib returns code: \" << rc;\n    }\n\n    // By calling jpeg_start_decompress, you populate cinfo\n    // and can then allocate your output bitmap buffers for\n    // each scanline.\n    jpeg_start_decompress(&cinfo);\n\n    const JDIMENSION width = cinfo.output_width;\n    const JDIMENSION height = cinfo.output_height;\n    const int channels = cinfo.output_components;\n\n    const size_t bmpSize = width * height * channels;\n\n    output.create(height, width, CV_MAKETYPE(CV_8U, channels));\n    cv::Mat mat = output.getMat();\n\n    // The row_stride is the total number of bytes it takes to store an\n    // entire scanline (row). \n    const unsigned int rowStride = width * channels;\n\n    // Now that you have the decompressor entirely configured, it's time\n    // to read out all of the scanlines of the jpeg.\n    //\n    // By default, scanlines will come out in RGBRGBRGB...  order, \n    // but this can be changed by setting cinfo.out_color_space\n    //\n    // jpeg_read_scanlines takes an array of buffers, one for each scanline.\n    // Even if you give it a complete set of buffers for the whole image,\n    // it will only ever decompress a few lines at a time. For best \n    // performance, you should pass it an array with cinfo.rec_outbuf_height\n    // scanline buffers. rec_outbuf_height is typically 1, 2, or 4, and \n    // at the default high quality decompression setting is always 1.\n    while (cinfo.output_scanline < cinfo.output_height)\n    {\n        unsigned char* bufferArray[1];\n        bufferArray[0] = mat.data +\n            (cinfo.output_scanline) * rowStride;\n\n        jpeg_read_scanlines(&cinfo, bufferArray, 1);\n    }\n    // Once done reading *all* scanlines, release all internal buffers,\n    // etc by calling jpeg_finish_decompress. This lets you go back and\n    // reuse the same cinfo object with the same settings, if you\n    // want to decompress several jpegs in a row.\n    //\n    // If you didn't read all the scanlines, but want to stop early,\n    // you instead need to call jpeg_abort_decompress(&cinfo)\n    jpeg_finish_decompress(&cinfo);\n\n    // At this point, optionally go back and either load a new jpg into\n    // the jpg_buffer, or define a new jpeg_mem_src, and then start \n    // another decompress operation.\n\n    // Once you're really really done, destroy the object to free everything\n    jpeg_destroy_decompress(&cinfo);\n}\n\n\nslideio::NDPITIFFKeeper::NDPITIFFKeeper(libtiff::TIFF* hfile) : m_hFile(hfile)\n{\n}\n\n\nNDPITIFFKeeper::~NDPITIFFKeeper()\n{\n    if (m_hFile)\n        libtiff::TIFFClose(m_hFile);\n}\n\n",
                "name": "ndpitifftools.cpp",
                "path": "src/slideio/drivers/ndpi/ndpitifftools.cpp",
                "url": "/github.com/Booritas/slideio/-/blob/src/slideio/drivers/ndpi/ndpitifftools.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 1166,
                    "offsetAndLengths": [
                        [
                            30,
                            16
                        ]
                    ],
                    "preview": "    auto readBytes = libtiff::TIFFReadRGBATile(hFile, tileX, tileY, buffBegin);"
                }
            ],
            "repository": {
                "name": "github.com/Booritas/slideio",
                "url": "/github.com/Booritas/slideio"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "ee34d813bda65f8a03eec2477abb9ce8f2a6978d"
                },
                "content": "/*M///////////////////////////////////////////////////////////////////////////////////////\n//\n//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.\n//\n//  By downloading, copying, installing or using the software you agree to this license.\n//  If you do not agree to this license, do not download, install,\n//  copy or use the software.\n//\n//\n//                           License Agreement\n//                For Open Source Computer Vision Library\n//\n// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.\n// Copyright (C) 2009, Willow Garage Inc., all rights reserved.\n// Third party copyrights are property of their respective owners.\n//\n// Redistribution and use in source and binary forms, with or without modification,\n// are permitted provided that the following conditions are met:\n//\n//   * Redistribution's of source code must retain the above copyright notice,\n//     this list of conditions and the following disclaimer.\n//\n//   * Redistribution's in binary form must reproduce the above copyright notice,\n//     this list of conditions and the following disclaimer in the documentation\n//     and/or other materials provided with the distribution.\n//\n//   * The name of the copyright holders may not be used to endorse or promote products\n//     derived from this software without specific prior written permission.\n//\n// This software is provided by the copyright holders and contributors \"as is\" and\n// any express or implied warranties, including, but not limited to, the implied\n// warranties of merchantability and fitness for a particular purpose are disclaimed.\n// In no event shall the Intel Corporation or contributors be liable for any direct,\n// indirect, incidental, special, exemplary, or consequential damages\n// (including, but not limited to, procurement of substitute goods or services;\n// loss of use, data, or profits; or business interruption) however caused\n// and on any theory of liability, whether in contract, strict liability,\n// or tort (including negligence or otherwise) arising in any way out of\n// the use of this software, even if advised of the possibility of such damage.\n//\n//M*/\n\n/****************************************************************************************\\\n    A part of the file implements TIFF reader on base of libtiff library\n    (see otherlibs/_graphics/readme.txt for copyright notice)\n\\****************************************************************************************/\n\n#include \"precomp.hpp\"\n\n#ifdef HAVE_TIFF\n#include <opencv2/core/utils/logger.hpp>\n\n#include \"grfmt_tiff.hpp\"\n#include <limits>\n\n// TODO FIXIT Conflict declarations for common types like int64/uint64\nnamespace tiff_dummy_namespace {\n#include \"tiff.h\"\n#include \"tiffio.h\"\n}\nusing namespace tiff_dummy_namespace;\n\nnamespace cv\n{\n\n#define CV_TIFF_CHECK_CALL(call) \\\n    if (0 == (call)) { \\\n        CV_LOG_WARNING(NULL, \"OpenCV TIFF(line \" << __LINE__ << \"): failed \" #call); \\\n        CV_Error(Error::StsError, \"OpenCV TIFF: failed \" #call); \\\n    }\n\n#define CV_TIFF_CHECK_CALL_INFO(call) \\\n    if (0 == (call)) { \\\n        CV_LOG_INFO(NULL, \"OpenCV TIFF(line \" << __LINE__ << \"): failed optional call: \" #call \", ignoring\"); \\\n    }\n\n#define CV_TIFF_CHECK_CALL_DEBUG(call) \\\n    if (0 == (call)) { \\\n        CV_LOG_DEBUG(NULL, \"OpenCV TIFF(line \" << __LINE__ << \"): failed optional call: \" #call \", ignoring\"); \\\n    }\n\nstatic void cv_tiffCloseHandle(void* handle)\n{\n    TIFFClose((TIFF*)handle);\n}\n\nstatic void cv_tiffErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    if (cv::utils::logging::getLogLevel() < cv::utils::logging::LOG_LEVEL_DEBUG)\n        return;\n    // TODO cv::vformat() with va_list parameter\n    fprintf(stderr, \"OpenCV TIFF: \");\n    if (module != NULL)\n        fprintf(stderr, \"%s: \", module);\n    fprintf(stderr, \"Warning, \");\n    vfprintf(stderr, fmt, ap);\n    fprintf(stderr, \".\\n\");\n}\n\nstatic bool cv_tiffSetErrorHandler_()\n{\n    TIFFSetErrorHandler(cv_tiffErrorHandler);\n    TIFFSetWarningHandler(cv_tiffErrorHandler);\n    return true;\n}\n\nstatic bool cv_tiffSetErrorHandler()\n{\n    static bool v = cv_tiffSetErrorHandler_();\n    return v;\n}\n\nstatic const char fmtSignTiffII[] = \"II\\x2a\\x00\";\nstatic const char fmtSignTiffMM[] = \"MM\\x00\\x2a\";\n\nTiffDecoder::TiffDecoder()\n{\n    m_hdr = false;\n    m_buf_supported = true;\n    m_buf_pos = 0;\n}\n\n\nvoid TiffDecoder::close()\n{\n    m_tif.release();\n}\n\nTiffDecoder::~TiffDecoder()\n{\n    close();\n}\n\nsize_t TiffDecoder::signatureLength() const\n{\n    return 4;\n}\n\nbool TiffDecoder::checkSignature( const String& signature ) const\n{\n    return signature.size() >= 4 &&\n        (memcmp(signature.c_str(), fmtSignTiffII, 4) == 0 ||\n        memcmp(signature.c_str(), fmtSignTiffMM, 4) == 0);\n}\n\nint TiffDecoder::normalizeChannelsNumber(int channels) const\n{\n    CV_Assert(channels <= 4);\n    return channels > 4 ? 4 : channels;\n}\n\nImageDecoder TiffDecoder::newDecoder() const\n{\n    cv_tiffSetErrorHandler();\n    return makePtr<TiffDecoder>();\n}\n\nclass TiffDecoderBufHelper\n{\n    Mat& m_buf;\n    size_t& m_buf_pos;\npublic:\n    TiffDecoderBufHelper(Mat& buf, size_t& buf_pos) :\n        m_buf(buf), m_buf_pos(buf_pos)\n    {}\n    static tmsize_t read( thandle_t handle, void* buffer, tmsize_t n )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        const Mat& buf = helper->m_buf;\n        const tmsize_t size = buf.cols*buf.rows*buf.elemSize();\n        tmsize_t pos = helper->m_buf_pos;\n        if ( n > (size - pos) )\n        {\n            n = size - pos;\n        }\n        memcpy(buffer, buf.ptr() + pos, n);\n        helper->m_buf_pos += n;\n        return n;\n    }\n\n    static tmsize_t write( thandle_t /*handle*/, void* /*buffer*/, tmsize_t /*n*/ )\n    {\n        // Not used for decoding.\n        return 0;\n    }\n\n    static toff_t seek( thandle_t handle, toff_t offset, int whence )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        const Mat& buf = helper->m_buf;\n        const toff_t size = buf.cols*buf.rows*buf.elemSize();\n        toff_t new_pos = helper->m_buf_pos;\n        switch (whence)\n        {\n            case SEEK_SET:\n                new_pos = offset;\n                break;\n            case SEEK_CUR:\n                new_pos += offset;\n                break;\n            case SEEK_END:\n                new_pos = size + offset;\n                break;\n        }\n        new_pos = std::min(new_pos, size);\n        helper->m_buf_pos = (size_t)new_pos;\n        return new_pos;\n    }\n\n    static int map( thandle_t handle, void** base, toff_t* size )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        Mat& buf = helper->m_buf;\n        *base = buf.ptr();\n        *size = buf.cols*buf.rows*buf.elemSize();\n        return 0;\n    }\n\n    static toff_t size( thandle_t handle )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        const Mat& buf = helper->m_buf;\n        return buf.cols*buf.rows*buf.elemSize();\n    }\n\n    static int close( thandle_t handle )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        delete helper;\n        return 0;\n    }\n};\n\nbool TiffDecoder::readHeader()\n{\n    bool result = false;\n\n    TIFF* tif = static_cast<TIFF*>(m_tif.get());\n    if (!tif)\n    {\n        // TIFFOpen() mode flags are different to fopen().  A 'b' in mode \"rb\" has no effect when reading.\n        // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n        if ( !m_buf.empty() )\n        {\n            m_buf_pos = 0;\n            TiffDecoderBufHelper* buf_helper = new TiffDecoderBufHelper(this->m_buf, this->m_buf_pos);\n            tif = TIFFClientOpen( \"\", \"r\", reinterpret_cast<thandle_t>(buf_helper), &TiffDecoderBufHelper::read,\n                                  &TiffDecoderBufHelper::write, &TiffDecoderBufHelper::seek,\n                                  &TiffDecoderBufHelper::close, &TiffDecoderBufHelper::size,\n                                  &TiffDecoderBufHelper::map, /*unmap=*/0 );\n            if (!tif)\n                delete buf_helper;\n        }\n        else\n        {\n            tif = TIFFOpen(m_filename.c_str(), \"r\");\n        }\n        if (tif)\n            m_tif.reset(tif, cv_tiffCloseHandle);\n        else\n            m_tif.release();\n    }\n\n    if (tif)\n    {\n        uint32 wdth = 0, hght = 0;\n        uint16 photometric = 0;\n\n        CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &wdth));\n        CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &hght));\n        CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric));\n\n        {\n            bool isGrayScale = photometric == PHOTOMETRIC_MINISWHITE || photometric == PHOTOMETRIC_MINISBLACK;\n            uint16 bpp = 8, ncn = isGrayScale ? 1 : 3;\n            CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bpp));\n            CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &ncn));\n\n            m_width = wdth;\n            m_height = hght;\n            if (ncn == 3 && photometric == PHOTOMETRIC_LOGLUV)\n            {\n                m_type = CV_32FC3;\n                m_hdr = true;\n                return true;\n            }\n            m_hdr = false;\n\n            if( bpp > 8 &&\n               ((photometric > 2) ||\n                (ncn != 1 && ncn != 3 && ncn != 4)))\n                bpp = 8;\n\n            int wanted_channels = normalizeChannelsNumber(ncn);\n            switch(bpp)\n            {\n                case 1:\n                    m_type = CV_MAKETYPE(CV_8U, !isGrayScale ? wanted_channels : 1);\n                    result = true;\n                    break;\n                case 8:\n                    m_type = CV_MAKETYPE(CV_8U, !isGrayScale ? wanted_channels : 1);\n                    result = true;\n                    break;\n                case 16:\n                    m_type = CV_MAKETYPE(CV_16U, !isGrayScale ? wanted_channels : 1);\n                    result = true;\n                    break;\n                case 32:\n                    m_type = CV_MAKETYPE(CV_32F, wanted_channels);\n                    result = true;\n                    break;\n                case 64:\n                    m_type = CV_MAKETYPE(CV_64F, wanted_channels);\n                    result = true;\n                    break;\n            default:\n                CV_Error(cv::Error::StsError, \"Invalid bitsperpixel value read from TIFF header! Must be 1, 8, 16, 32 or 64.\");\n            }\n        }\n    }\n\n    if( !result )\n        close();\n\n    return result;\n}\n\nbool TiffDecoder::nextPage()\n{\n    // Prepare the next page, if any.\n    return !m_tif.empty() &&\n           TIFFReadDirectory(static_cast<TIFF*>(m_tif.get())) &&\n           readHeader();\n}\n\nstatic void fixOrientationPartial(Mat &img, uint16 orientation)\n{\n    switch(orientation) {\n        case ORIENTATION_RIGHTTOP:\n        case ORIENTATION_LEFTBOT:\n            flip(img, img, -1);\n            /* fall through */\n\n        case ORIENTATION_LEFTTOP:\n        case ORIENTATION_RIGHTBOT:\n            transpose(img, img);\n            break;\n    }\n}\n\nstatic void fixOrientationFull(Mat &img, int orientation)\n{\n    switch(orientation) {\n        case ORIENTATION_TOPRIGHT:\n            flip(img, img, 1);\n            break;\n\n        case ORIENTATION_BOTRIGHT:\n            flip(img, img, -1);\n            break;\n\n        case ORIENTATION_BOTLEFT:\n            flip(img, img, 0);\n            break;\n\n        case ORIENTATION_LEFTTOP:\n            transpose(img, img);\n            break;\n\n        case ORIENTATION_RIGHTTOP:\n            transpose(img, img);\n            flip(img, img, 1);\n            break;\n\n        case ORIENTATION_RIGHTBOT:\n            transpose(img, img);\n            flip(img, img, -1);\n            break;\n\n        case ORIENTATION_LEFTBOT:\n            transpose(img, img);\n            flip(img, img, 0);\n            break;\n    }\n}\n\n/**\n * Fix orientation defined in tag 274.\n * For 8 bit some corrections are done by TIFFReadRGBAStrip/Tile already.\n * Not so for 16/32/64 bit.\n */\nstatic void fixOrientation(Mat &img, uint16 orientation, int dst_bpp)\n{\n    switch(dst_bpp) {\n        case 8:\n            fixOrientationPartial(img, orientation);\n            break;\n\n        case 16:\n        case 32:\n        case 64:\n            fixOrientationFull(img, orientation);\n            break;\n    }\n}\n\nbool  TiffDecoder::readData( Mat& img )\n{\n    int type_ = img.type();\n    int depth = CV_MAT_DEPTH(type_);\n\n    CV_Assert(!m_tif.empty());\n    TIFF* tif = (TIFF*)m_tif.get();\n\n    uint16 photometric = (uint16)-1;\n    CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric));\n\n    if (m_hdr && depth >= CV_32F)\n    {\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_FLOAT));\n    }\n\n    bool color = img.channels() > 1;\n\n    CV_CheckType(type_, depth == CV_8U || depth == CV_16U || depth == CV_32F || depth == CV_64F, \"\");\n\n    if (m_width && m_height)\n    {\n        int is_tiled = TIFFIsTiled(tif) != 0;\n        bool isGrayScale = photometric == PHOTOMETRIC_MINISWHITE || photometric == PHOTOMETRIC_MINISBLACK;\n        uint16 bpp = 8, ncn = isGrayScale ? 1 : 3;\n        CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bpp));\n        CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &ncn));\n        uint16 img_orientation = ORIENTATION_TOPLEFT;\n        CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_ORIENTATION, &img_orientation));\n        const int bitsPerByte = 8;\n        int dst_bpp = (int)(img.elemSize1() * bitsPerByte);\n        bool vert_flip = dst_bpp == 8 &&\n                        (img_orientation == ORIENTATION_BOTRIGHT || img_orientation == ORIENTATION_RIGHTBOT ||\n                         img_orientation == ORIENTATION_BOTLEFT || img_orientation == ORIENTATION_LEFTBOT);\n        int wanted_channels = normalizeChannelsNumber(img.channels());\n\n        if (dst_bpp == 8)\n        {\n            char errmsg[1024];\n            if (!TIFFRGBAImageOK(tif, errmsg))\n            {\n                CV_LOG_WARNING(NULL, \"OpenCV TIFF: TIFFRGBAImageOK: \" << errmsg);\n                close();\n                return false;\n            }\n        }\n\n        uint32 tile_width0 = m_width, tile_height0 = 0;\n\n        if (is_tiled)\n        {\n            CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_TILEWIDTH, &tile_width0));\n            CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_TILELENGTH, &tile_height0));\n        }\n        else\n        {\n            // optional\n            CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &tile_height0));\n        }\n\n        {\n            if (tile_width0 == 0)\n                tile_width0 = m_width;\n\n            if (tile_height0 == 0 ||\n                    (!is_tiled && tile_height0 == std::numeric_limits<uint32>::max()) )\n                tile_height0 = m_height;\n\n            const int TILE_MAX_WIDTH = (1 << 24);\n            const int TILE_MAX_HEIGHT = (1 << 24);\n            CV_Assert((int)tile_width0 > 0 && (int)tile_width0 <= TILE_MAX_WIDTH);\n            CV_Assert((int)tile_height0 > 0 && (int)tile_height0 <= TILE_MAX_HEIGHT);\n            const uint64_t MAX_TILE_SIZE = (CV_BIG_UINT(1) << 30);\n            CV_CheckLE((int)ncn, 4, \"\");\n            CV_CheckLE((int)bpp, 64, \"\");\n            CV_Assert(((uint64_t)tile_width0 * tile_height0 * ncn * std::max(1, (int)(bpp / bitsPerByte)) < MAX_TILE_SIZE) && \"TIFF tile size is too large: >= 1Gb\");\n\n            if (dst_bpp == 8)\n            {\n                // we will use TIFFReadRGBA* functions, so allocate temporary buffer for 32bit RGBA\n                bpp = 8;\n                ncn = 4;\n            }\n            else if (dst_bpp == 32 || dst_bpp == 64)\n            {\n                CV_Assert(ncn == img.channels());\n                CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP));\n            }\n            const size_t buffer_size = (bpp / bitsPerByte) * ncn * tile_height0 * tile_width0;\n            AutoBuffer<uchar> _buffer(buffer_size);\n            uchar* buffer = _buffer.data();\n            ushort* buffer16 = (ushort*)buffer;\n            int tileidx = 0;\n\n            for (int y = 0; y < m_height; y += (int)tile_height0)\n            {\n                int tile_height = std::min((int)tile_height0, m_height - y);\n\n                const int img_y = vert_flip ? m_height - y - tile_height : y;\n\n                for(int x = 0; x < m_width; x += (int)tile_width0, tileidx++)\n                {\n                    int tile_width = std::min((int)tile_width0, m_width - x);\n\n                    switch (dst_bpp)\n                    {\n                        case 8:\n                        {\n                            uchar* bstart = buffer;\n                            if (!is_tiled)\n                            {\n                                CV_TIFF_CHECK_CALL(TIFFReadRGBAStrip(tif, y, (uint32*)buffer));\n                            }\n                            else\n                            {\n                                CV_TIFF_CHECK_CALL(TIFFReadRGBATile(tif, x, y, (uint32*)buffer));\n                                // Tiles fill the buffer from the bottom up\n                                bstart += (tile_height0 - tile_height) * tile_width0 * 4;\n                            }\n\n                            for (int i = 0; i < tile_height; i++)\n                            {\n                                if (color)\n                                {\n                                    if (wanted_channels == 4)\n                                    {\n                                        icvCvt_BGRA2RGBA_8u_C4R(bstart + i*tile_width0*4, 0,\n                                                img.ptr(img_y + tile_height - i - 1, x), 0,\n                                                Size(tile_width, 1) );\n                                    }\n                                    else\n                                    {\n                                        CV_CheckEQ(wanted_channels, 3, \"TIFF-8bpp: BGR/BGRA images are supported only\");\n                                        icvCvt_BGRA2BGR_8u_C4C3R(bstart + i*tile_width0*4, 0,\n                                                img.ptr(img_y + tile_height - i - 1, x), 0,\n                                                Size(tile_width, 1), 2);\n                                    }\n                                }\n                                else\n                                {\n                                    CV_CheckEQ(wanted_channels, 1, \"\");\n                                    icvCvt_BGRA2Gray_8u_C4C1R( bstart + i*tile_width0*4, 0,\n                                            img.ptr(img_y + tile_height - i - 1, x), 0,\n                                            Size(tile_width, 1), 2);\n                                }\n                            }\n                            break;\n                        }\n\n                        case 16:\n                        {\n                            if (!is_tiled)\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedStrip(tif, tileidx, (uint32*)buffer, buffer_size) >= 0);\n                            }\n                            else\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedTile(tif, tileidx, (uint32*)buffer, buffer_size) >= 0);\n                            }\n\n                            for (int i = 0; i < tile_height; i++)\n                            {\n                                if (color)\n                                {\n                                    if (ncn == 1)\n                                    {\n                                        CV_CheckEQ(wanted_channels, 3, \"\");\n                                        icvCvt_Gray2BGR_16u_C1C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1));\n                                    }\n                                    else if (ncn == 3)\n                                    {\n                                        CV_CheckEQ(wanted_channels, 3, \"\");\n                                        icvCvt_RGB2BGR_16u_C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1));\n                                    }\n                                    else if (ncn == 4)\n                                    {\n                                        if (wanted_channels == 4)\n                                        {\n                                            icvCvt_BGRA2RGBA_16u_C4R(buffer16 + i*tile_width0*ncn, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1));\n                                        }\n                                        else\n                                        {\n                                            CV_CheckEQ(wanted_channels, 3, \"TIFF-16bpp: BGR/BGRA images are supported only\");\n                                            icvCvt_BGRA2BGR_16u_C4C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1), 2);\n                                        }\n                                    }\n                                    else\n                                    {\n                                        CV_Error(Error::StsError, \"Not supported\");\n                                    }\n                                }\n                                else\n                                {\n                                    CV_CheckEQ(wanted_channels, 1, \"\");\n                                    if( ncn == 1 )\n                                    {\n                                        memcpy(img.ptr<ushort>(img_y + i, x),\n                                               buffer16 + i*tile_width0*ncn,\n                                               tile_width*sizeof(ushort));\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2Gray_16u_CnC1R(buffer16 + i*tile_width0*ncn, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1), ncn, 2);\n                                    }\n                                }\n                            }\n                            break;\n                        }\n\n                        case 32:\n                        case 64:\n                        {\n                            if( !is_tiled )\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedStrip(tif, tileidx, buffer, buffer_size) >= 0);\n                            }\n                            else\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedTile(tif, tileidx, buffer, buffer_size) >= 0);\n                            }\n\n                            Mat m_tile(Size(tile_width0, tile_height0), CV_MAKETYPE((dst_bpp == 32) ? CV_32F : CV_64F, ncn), buffer);\n                            Rect roi_tile(0, 0, tile_width, tile_height);\n                            Rect roi_img(x, img_y, tile_width, tile_height);\n                            if (!m_hdr && ncn == 3)\n                                cvtColor(m_tile(roi_tile), img(roi_img), COLOR_RGB2BGR);\n                            else if (!m_hdr && ncn == 4)\n                                cvtColor(m_tile(roi_tile), img(roi_img), COLOR_RGBA2BGRA);\n                            else\n                                m_tile(roi_tile).copyTo(img(roi_img));\n                            break;\n                        }\n                        default:\n                        {\n                            CV_Assert(0 && \"OpenCV TIFF: unsupported depth\");\n                        }\n                    }  // switch (dst_bpp)\n                }  // for x\n            }  // for y\n        }\n        fixOrientation(img, img_orientation, dst_bpp);\n    }\n\n    if (m_hdr && depth >= CV_32F)\n    {\n        CV_Assert(photometric == PHOTOMETRIC_LOGLUV);\n        cvtColor(img, img, COLOR_XYZ2BGR);\n    }\n    return true;\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////\n\nTiffEncoder::TiffEncoder()\n{\n    m_description = \"TIFF Files (*.tiff;*.tif)\";\n    m_buf_supported = true;\n}\n\nTiffEncoder::~TiffEncoder()\n{\n}\n\nImageEncoder TiffEncoder::newEncoder() const\n{\n    return makePtr<TiffEncoder>();\n}\n\nbool TiffEncoder::isFormatSupported( int depth ) const\n{\n    return depth == CV_8U || depth == CV_16U || depth == CV_32F || depth == CV_64F;\n}\n\nvoid  TiffEncoder::writeTag( WLByteStream& strm, TiffTag tag,\n                             TiffFieldType fieldType,\n                             int count, int value )\n{\n    strm.putWord( tag );\n    strm.putWord( fieldType );\n    strm.putDWord( count );\n    strm.putDWord( value );\n}\n\nclass TiffEncoderBufHelper\n{\npublic:\n\n    TiffEncoderBufHelper(std::vector<uchar> *buf)\n            : m_buf(buf), m_buf_pos(0)\n    {}\n\n    TIFF* open ()\n    {\n        // do NOT put \"wb\" as the mode, because the b means \"big endian\" mode, not \"binary\" mode.\n        // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n        return TIFFClientOpen( \"\", \"w\", reinterpret_cast<thandle_t>(this), &TiffEncoderBufHelper::read,\n                               &TiffEncoderBufHelper::write, &TiffEncoderBufHelper::seek,\n                               &TiffEncoderBufHelper::close, &TiffEncoderBufHelper::size,\n                               /*map=*/0, /*unmap=*/0 );\n    }\n\n    static tmsize_t read( thandle_t /*handle*/, void* /*buffer*/, tmsize_t /*n*/ )\n    {\n        // Not used for encoding.\n        return 0;\n    }\n\n    static tmsize_t write( thandle_t handle, void* buffer, tmsize_t n )\n    {\n        TiffEncoderBufHelper *helper = reinterpret_cast<TiffEncoderBufHelper*>(handle);\n        size_t begin = (size_t)helper->m_buf_pos;\n        size_t end = begin + n;\n        if ( helper->m_buf->size() < end )\n        {\n            helper->m_buf->resize(end);\n        }\n        memcpy(&(*helper->m_buf)[begin], buffer, n);\n        helper->m_buf_pos = end;\n        return n;\n    }\n\n    static toff_t seek( thandle_t handle, toff_t offset, int whence )\n    {\n        TiffEncoderBufHelper *helper = reinterpret_cast<TiffEncoderBufHelper*>(handle);\n        const toff_t size = helper->m_buf->size();\n        toff_t new_pos = helper->m_buf_pos;\n        switch (whence)\n        {\n            case SEEK_SET:\n                new_pos = offset;\n                break;\n            case SEEK_CUR:\n                new_pos += offset;\n                break;\n            case SEEK_END:\n                new_pos = size + offset;\n                break;\n        }\n        helper->m_buf_pos = new_pos;\n        return new_pos;\n    }\n\n    static toff_t size( thandle_t handle )\n    {\n        TiffEncoderBufHelper *helper = reinterpret_cast<TiffEncoderBufHelper*>(handle);\n        return helper->m_buf->size();\n    }\n\n    static int close( thandle_t /*handle*/ )\n    {\n        // Do nothing.\n        return 0;\n    }\n\nprivate:\n\n    std::vector<uchar>* m_buf;\n    toff_t m_buf_pos;\n};\n\nstatic bool readParam(const std::vector<int>& params, int key, int& value)\n{\n    for (size_t i = 0; i + 1 < params.size(); i += 2)\n    {\n        if (params[i] == key)\n        {\n            value = params[i + 1];\n            return true;\n        }\n    }\n    return false;\n}\n\nbool TiffEncoder::writeLibTiff( const std::vector<Mat>& img_vec, const std::vector<int>& params)\n{\n    // do NOT put \"wb\" as the mode, because the b means \"big endian\" mode, not \"binary\" mode.\n    // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n    TIFF* tif = NULL;\n\n    TiffEncoderBufHelper buf_helper(m_buf);\n    if ( m_buf )\n    {\n        tif = buf_helper.open();\n    }\n    else\n    {\n        tif = TIFFOpen(m_filename.c_str(), \"w\");\n    }\n    if (!tif)\n    {\n        return false;\n    }\n    cv::Ptr<void> tif_cleanup(tif, cv_tiffCloseHandle);\n\n    //Settings that matter to all images\n    int compression = COMPRESSION_LZW;\n    int predictor = PREDICTOR_HORIZONTAL;\n    int resUnit = -1, dpiX = -1, dpiY = -1;\n\n    readParam(params, IMWRITE_TIFF_COMPRESSION, compression);\n    readParam(params, TIFFTAG_PREDICTOR, predictor);\n    readParam(params, IMWRITE_TIFF_RESUNIT, resUnit);\n    readParam(params, IMWRITE_TIFF_XDPI, dpiX);\n    readParam(params, IMWRITE_TIFF_YDPI, dpiY);\n\n    //Iterate through each image in the vector and write them out as Tiff directories\n    for (size_t page = 0; page < img_vec.size(); page++)\n    {\n        const Mat& img = img_vec[page];\n        int channels = img.channels();\n        int width = img.cols, height = img.rows;\n        int type = img.type();\n        int depth = CV_MAT_DEPTH(type);\n        CV_CheckType(type, depth == CV_8U || depth == CV_16U || depth == CV_32F || depth == CV_64F, \"\");\n        CV_CheckType(type, channels >= 1 && channels <= 4, \"\");\n\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, width));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_IMAGELENGTH, height));\n\n        if (img_vec.size() > 1)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE));\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PAGENUMBER, page, img_vec.size()));\n        }\n\n        int compression_param = -1;  // OPENCV_FUTURE\n        if (type == CV_32FC3 && (!readParam(params, IMWRITE_TIFF_COMPRESSION, compression_param) || compression_param == COMPRESSION_SGILOG))\n        {\n            if (!write_32FC3_SGILOG(img, tif))\n                return false;\n            continue;\n        }\n\n        int page_compression = compression;\n\n        int bitsPerChannel = -1;\n        switch (depth)\n        {\n            case CV_8U:\n            {\n                bitsPerChannel = 8;\n                break;\n            }\n            case CV_16U:\n            {\n                bitsPerChannel = 16;\n                break;\n            }\n            case CV_32F:\n            {\n                bitsPerChannel = 32;\n                page_compression = COMPRESSION_NONE;\n                break;\n            }\n            case CV_64F:\n            {\n                bitsPerChannel = 64;\n                page_compression = COMPRESSION_NONE;\n                break;\n            }\n            default:\n            {\n                return false;\n            }\n        }\n\n        const int bitsPerByte = 8;\n        size_t fileStep = (width * channels * bitsPerChannel) / bitsPerByte;\n\n        int rowsPerStrip = (int)((1 << 13) / fileStep);\n        readParam(params, TIFFTAG_ROWSPERSTRIP, rowsPerStrip);\n        rowsPerStrip = std::max(1, std::min(height, rowsPerStrip));\n\n        int colorspace = channels > 1 ? PHOTOMETRIC_RGB : PHOTOMETRIC_MINISBLACK;\n\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, bitsPerChannel));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_COMPRESSION, page_compression));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, colorspace));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, channels));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, rowsPerStrip));\n\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, depth >= CV_32F ? SAMPLEFORMAT_IEEEFP : SAMPLEFORMAT_UINT));\n\n        if (page_compression != COMPRESSION_NONE)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PREDICTOR, predictor));\n        }\n\n        if (resUnit >= RESUNIT_NONE && resUnit <= RESUNIT_CENTIMETER)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_RESOLUTIONUNIT, resUnit));\n        }\n        if (dpiX >= 0)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_XRESOLUTION, (float)dpiX));\n        }\n        if (dpiY >= 0)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_YRESOLUTION, (float)dpiY));\n        }\n\n        // row buffer, because TIFFWriteScanline modifies the original data!\n        size_t scanlineSize = TIFFScanlineSize(tif);\n        AutoBuffer<uchar> _buffer(scanlineSize + 32);\n        uchar* buffer = _buffer.data(); CV_DbgAssert(buffer);\n        Mat m_buffer(Size(width, 1), CV_MAKETYPE(depth, channels), buffer, (size_t)scanlineSize);\n\n        for (int y = 0; y < height; ++y)\n        {\n            switch (channels)\n            {\n                case 1:\n                {\n                    memcpy(buffer, img.ptr(y), scanlineSize);\n                    break;\n                }\n\n                case 3:\n                {\n                    cvtColor(img(Rect(0, y, width, 1)), (const Mat&)m_buffer, COLOR_BGR2RGB);\n                    break;\n                }\n\n                case 4:\n                {\n                    cvtColor(img(Rect(0, y, width, 1)), (const Mat&)m_buffer, COLOR_BGRA2RGBA);\n                    break;\n                }\n\n                default:\n                {\n                    CV_Assert(0);\n                }\n            }\n\n            CV_TIFF_CHECK_CALL(TIFFWriteScanline(tif, buffer, y, 0) == 1);\n        }\n\n        CV_TIFF_CHECK_CALL(TIFFWriteDirectory(tif));\n    }\n\n    return true;\n}\n\nbool TiffEncoder::write_32FC3_SGILOG(const Mat& _img, void* tif_)\n{\n    TIFF* tif = (TIFF*)tif_;\n    CV_Assert(tif);\n\n    Mat img;\n    cvtColor(_img, img, COLOR_BGR2XYZ);\n\n    //done by caller: CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, img.cols));\n    //done by caller: CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_IMAGELENGTH, img.rows));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 3));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 32));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_SGILOG));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_LOGLUV));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_FLOAT));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, 1));\n    const int strip_size = 3 * img.cols;\n    for (int i = 0; i < img.rows; i++)\n    {\n        CV_TIFF_CHECK_CALL(TIFFWriteEncodedStrip(tif, i, (tdata_t)img.ptr<float>(i), strip_size * sizeof(float)) != (tsize_t)-1);\n    }\n    CV_TIFF_CHECK_CALL(TIFFWriteDirectory(tif));\n    return true;\n}\n\nbool TiffEncoder::writemulti(const std::vector<Mat>& img_vec, const std::vector<int>& params)\n{\n    return writeLibTiff(img_vec, params);\n}\n\nbool  TiffEncoder::write( const Mat& img, const std::vector<int>& params)\n{\n    int type = img.type();\n    int depth = CV_MAT_DEPTH(type);\n\n    CV_CheckType(type, depth == CV_8U || depth == CV_16U || depth == CV_32F || depth == CV_64F, \"\");\n\n    std::vector<Mat> img_vec;\n    img_vec.push_back(img);\n    return writeLibTiff(img_vec, params);\n}\n\n} // namespace\n\n#endif\n",
                "name": "grfmt_tiff.cpp",
                "path": "Boss2D/addon/opencv-3.4.7_for_boss/modules/imgcodecs/src/grfmt_tiff.cpp",
                "url": "/github.com/BonexGoo/Boss2D/-/blob/Boss2D/addon/opencv-3.4.7_for_boss/modules/imgcodecs/src/grfmt_tiff.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 522,
                    "offsetAndLengths": [
                        [
                            51,
                            16
                        ]
                    ],
                    "preview": "                                CV_TIFF_CHECK_CALL(TIFFReadRGBATile(tif, x, y, (uint32*)buffer));"
                }
            ],
            "repository": {
                "name": "github.com/BonexGoo/Boss2D",
                "url": "/github.com/BonexGoo/Boss2D"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "8f1491bdec0ca1c3bdef4efa9ff7471b692098dd"
                },
                "content": "/*M///////////////////////////////////////////////////////////////////////////////////////\n//\n//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.\n//\n//  By downloading, copying, installing or using the software you agree to this license.\n//  If you do not agree to this license, do not download, install,\n//  copy or use the software.\n//\n//\n//                           License Agreement\n//                For Open Source Computer Vision Library\n//\n// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.\n// Copyright (C) 2009, Willow Garage Inc., all rights reserved.\n// Third party copyrights are property of their respective owners.\n//\n// Redistribution and use in source and binary forms, with or without modification,\n// are permitted provided that the following conditions are met:\n//\n//   * Redistribution's of source code must retain the above copyright notice,\n//     this list of conditions and the following disclaimer.\n//\n//   * Redistribution's in binary form must reproduce the above copyright notice,\n//     this list of conditions and the following disclaimer in the documentation\n//     and/or other materials provided with the distribution.\n//\n//   * The name of the copyright holders may not be used to endorse or promote products\n//     derived from this software without specific prior written permission.\n//\n// This software is provided by the copyright holders and contributors \"as is\" and\n// any express or implied warranties, including, but not limited to, the implied\n// warranties of merchantability and fitness for a particular purpose are disclaimed.\n// In no event shall the Intel Corporation or contributors be liable for any direct,\n// indirect, incidental, special, exemplary, or consequential damages\n// (including, but not limited to, procurement of substitute goods or services;\n// loss of use, data, or profits; or business interruption) however caused\n// and on any theory of liability, whether in contract, strict liability,\n// or tort (including negligence or otherwise) arising in any way out of\n// the use of this software, even if advised of the possibility of such damage.\n//\n//M*/\n\n/****************************************************************************************\\\n    A part of the file implements TIFF reader on base of libtiff library\n    (see otherlibs/_graphics/readme.txt for copyright notice)\n\\****************************************************************************************/\n\n#include \"precomp.hpp\"\n\n#ifdef HAVE_TIFF\n#include <opencv2/core/utils/logger.hpp>\n\n#include \"grfmt_tiff.hpp\"\n#include <limits>\n\n// TODO FIXIT Conflict declarations for common types like int64/uint64\nnamespace tiff_dummy_namespace {\n#include \"tiff.h\"\n#include \"tiffio.h\"\n}\nusing namespace tiff_dummy_namespace;\n\nnamespace cv\n{\n\n#define CV_TIFF_CHECK_CALL(call) \\\n    if (0 == (call)) { \\\n        CV_LOG_WARNING(NULL, \"OpenCV TIFF(line \" << __LINE__ << \"): failed \" #call); \\\n        CV_Error(Error::StsError, \"OpenCV TIFF: failed \" #call); \\\n    }\n\n#define CV_TIFF_CHECK_CALL_INFO(call) \\\n    if (0 == (call)) { \\\n        CV_LOG_INFO(NULL, \"OpenCV TIFF(line \" << __LINE__ << \"): failed optional call: \" #call \", ignoring\"); \\\n    }\n\n#define CV_TIFF_CHECK_CALL_DEBUG(call) \\\n    if (0 == (call)) { \\\n        CV_LOG_DEBUG(NULL, \"OpenCV TIFF(line \" << __LINE__ << \"): failed optional call: \" #call \", ignoring\"); \\\n    }\n\nstatic void cv_tiffCloseHandle(void* handle)\n{\n    TIFFClose((TIFF*)handle);\n}\n\nstatic void cv_tiffErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    if (cv::utils::logging::getLogLevel() < cv::utils::logging::LOG_LEVEL_DEBUG)\n        return;\n    // TODO cv::vformat() with va_list parameter\n    fprintf(stderr, \"OpenCV TIFF: \");\n    if (module != NULL)\n        fprintf(stderr, \"%s: \", module);\n    fprintf(stderr, \"Warning, \");\n    vfprintf(stderr, fmt, ap);\n    fprintf(stderr, \".\\n\");\n}\n\nstatic bool cv_tiffSetErrorHandler_()\n{\n    TIFFSetErrorHandler(cv_tiffErrorHandler);\n    TIFFSetWarningHandler(cv_tiffErrorHandler);\n    return true;\n}\n\nstatic bool cv_tiffSetErrorHandler()\n{\n    static bool v = cv_tiffSetErrorHandler_();\n    return v;\n}\n\nstatic const char fmtSignTiffII[] = \"II\\x2a\\x00\";\nstatic const char fmtSignTiffMM[] = \"MM\\x00\\x2a\";\n\nTiffDecoder::TiffDecoder()\n{\n    m_hdr = false;\n    m_buf_supported = true;\n    m_buf_pos = 0;\n}\n\n\nvoid TiffDecoder::close()\n{\n    m_tif.release();\n}\n\nTiffDecoder::~TiffDecoder()\n{\n    close();\n}\n\nsize_t TiffDecoder::signatureLength() const\n{\n    return 4;\n}\n\nbool TiffDecoder::checkSignature( const String& signature ) const\n{\n    return signature.size() >= 4 &&\n        (memcmp(signature.c_str(), fmtSignTiffII, 4) == 0 ||\n        memcmp(signature.c_str(), fmtSignTiffMM, 4) == 0);\n}\n\nint TiffDecoder::normalizeChannelsNumber(int channels) const\n{\n    CV_Assert(channels <= 4);\n    return channels > 4 ? 4 : channels;\n}\n\nImageDecoder TiffDecoder::newDecoder() const\n{\n    cv_tiffSetErrorHandler();\n    return makePtr<TiffDecoder>();\n}\n\nclass TiffDecoderBufHelper\n{\n    Mat& m_buf;\n    size_t& m_buf_pos;\npublic:\n    TiffDecoderBufHelper(Mat& buf, size_t& buf_pos) :\n        m_buf(buf), m_buf_pos(buf_pos)\n    {}\n    static tmsize_t read( thandle_t handle, void* buffer, tmsize_t n )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        const Mat& buf = helper->m_buf;\n        const tmsize_t size = buf.cols*buf.rows*buf.elemSize();\n        tmsize_t pos = helper->m_buf_pos;\n        if ( n > (size - pos) )\n        {\n            n = size - pos;\n        }\n        memcpy(buffer, buf.ptr() + pos, n);\n        helper->m_buf_pos += n;\n        return n;\n    }\n\n    static tmsize_t write( thandle_t /*handle*/, void* /*buffer*/, tmsize_t /*n*/ )\n    {\n        // Not used for decoding.\n        return 0;\n    }\n\n    static toff_t seek( thandle_t handle, toff_t offset, int whence )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        const Mat& buf = helper->m_buf;\n        const toff_t size = buf.cols*buf.rows*buf.elemSize();\n        toff_t new_pos = helper->m_buf_pos;\n        switch (whence)\n        {\n            case SEEK_SET:\n                new_pos = offset;\n                break;\n            case SEEK_CUR:\n                new_pos += offset;\n                break;\n            case SEEK_END:\n                new_pos = size + offset;\n                break;\n        }\n        new_pos = std::min(new_pos, size);\n        helper->m_buf_pos = (size_t)new_pos;\n        return new_pos;\n    }\n\n    static int map( thandle_t handle, void** base, toff_t* size )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        Mat& buf = helper->m_buf;\n        *base = buf.ptr();\n        *size = buf.cols*buf.rows*buf.elemSize();\n        return 0;\n    }\n\n    static toff_t size( thandle_t handle )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        const Mat& buf = helper->m_buf;\n        return buf.cols*buf.rows*buf.elemSize();\n    }\n\n    static int close( thandle_t handle )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        delete helper;\n        return 0;\n    }\n};\n\nbool TiffDecoder::readHeader()\n{\n    bool result = false;\n\n    TIFF* tif = static_cast<TIFF*>(m_tif.get());\n    if (!tif)\n    {\n        // TIFFOpen() mode flags are different to fopen().  A 'b' in mode \"rb\" has no effect when reading.\n        // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n        if ( !m_buf.empty() )\n        {\n            m_buf_pos = 0;\n            TiffDecoderBufHelper* buf_helper = new TiffDecoderBufHelper(this->m_buf, this->m_buf_pos);\n            tif = TIFFClientOpen( \"\", \"r\", reinterpret_cast<thandle_t>(buf_helper), &TiffDecoderBufHelper::read,\n                                  &TiffDecoderBufHelper::write, &TiffDecoderBufHelper::seek,\n                                  &TiffDecoderBufHelper::close, &TiffDecoderBufHelper::size,\n                                  &TiffDecoderBufHelper::map, /*unmap=*/0 );\n            if (!tif)\n                delete buf_helper;\n        }\n        else\n        {\n            tif = TIFFOpen(m_filename.c_str(), \"r\");\n        }\n        if (tif)\n            m_tif.reset(tif, cv_tiffCloseHandle);\n        else\n            m_tif.release();\n    }\n\n    if (tif)\n    {\n        uint32 wdth = 0, hght = 0;\n        uint16 photometric = 0;\n\n        CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &wdth));\n        CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &hght));\n        CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric));\n\n        {\n            bool isGrayScale = photometric == PHOTOMETRIC_MINISWHITE || photometric == PHOTOMETRIC_MINISBLACK;\n            uint16 bpp = 8, ncn = isGrayScale ? 1 : 3;\n            CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bpp));\n            CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &ncn));\n\n            m_width = wdth;\n            m_height = hght;\n            if (ncn == 3 && photometric == PHOTOMETRIC_LOGLUV)\n            {\n                m_type = CV_32FC3;\n                m_hdr = true;\n                return true;\n            }\n            m_hdr = false;\n\n            if( bpp > 8 &&\n               ((photometric > 2) ||\n                (ncn != 1 && ncn != 3 && ncn != 4)))\n                bpp = 8;\n\n            int wanted_channels = normalizeChannelsNumber(ncn);\n            switch(bpp)\n            {\n                case 1:\n                    m_type = CV_MAKETYPE(CV_8U, !isGrayScale ? wanted_channels : 1);\n                    result = true;\n                    break;\n                case 8:\n                    m_type = CV_MAKETYPE(CV_8U, !isGrayScale ? wanted_channels : 1);\n                    result = true;\n                    break;\n                case 16:\n                    m_type = CV_MAKETYPE(CV_16U, !isGrayScale ? wanted_channels : 1);\n                    result = true;\n                    break;\n                case 32:\n                    m_type = CV_MAKETYPE(CV_32F, wanted_channels);\n                    result = true;\n                    break;\n                case 64:\n                    m_type = CV_MAKETYPE(CV_64F, wanted_channels);\n                    result = true;\n                    break;\n            default:\n                CV_Error(cv::Error::StsError, \"Invalid bitsperpixel value read from TIFF header! Must be 1, 8, 16, 32 or 64.\");\n            }\n        }\n    }\n\n    if( !result )\n        close();\n\n    return result;\n}\n\nbool TiffDecoder::nextPage()\n{\n    // Prepare the next page, if any.\n    return !m_tif.empty() &&\n           TIFFReadDirectory(static_cast<TIFF*>(m_tif.get())) &&\n           readHeader();\n}\n\nstatic void fixOrientationPartial(Mat &img, uint16 orientation)\n{\n    switch(orientation) {\n        case ORIENTATION_RIGHTTOP:\n        case ORIENTATION_LEFTBOT:\n            flip(img, img, -1);\n            /* fall through */\n\n        case ORIENTATION_LEFTTOP:\n        case ORIENTATION_RIGHTBOT:\n            transpose(img, img);\n            break;\n    }\n}\n\nstatic void fixOrientationFull(Mat &img, int orientation)\n{\n    switch(orientation) {\n        case ORIENTATION_TOPRIGHT:\n            flip(img, img, 1);\n            break;\n\n        case ORIENTATION_BOTRIGHT:\n            flip(img, img, -1);\n            break;\n\n        case ORIENTATION_BOTLEFT:\n            flip(img, img, 0);\n            break;\n\n        case ORIENTATION_LEFTTOP:\n            transpose(img, img);\n            break;\n\n        case ORIENTATION_RIGHTTOP:\n            transpose(img, img);\n            flip(img, img, 1);\n            break;\n\n        case ORIENTATION_RIGHTBOT:\n            transpose(img, img);\n            flip(img, img, -1);\n            break;\n\n        case ORIENTATION_LEFTBOT:\n            transpose(img, img);\n            flip(img, img, 0);\n            break;\n    }\n}\n\n/**\n * Fix orientation defined in tag 274.\n * For 8 bit some corrections are done by TIFFReadRGBAStrip/Tile already.\n * Not so for 16/32/64 bit.\n */\nstatic void fixOrientation(Mat &img, uint16 orientation, int dst_bpp)\n{\n    switch(dst_bpp) {\n        case 8:\n            fixOrientationPartial(img, orientation);\n            break;\n\n        case 16:\n        case 32:\n        case 64:\n            fixOrientationFull(img, orientation);\n            break;\n    }\n}\n\nbool  TiffDecoder::readData( Mat& img )\n{\n    int type_ = img.type();\n    int depth = CV_MAT_DEPTH(type_);\n\n    CV_Assert(!m_tif.empty());\n    TIFF* tif = (TIFF*)m_tif.get();\n\n    uint16 photometric = (uint16)-1;\n    CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric));\n\n    if (m_hdr && depth >= CV_32F)\n    {\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_FLOAT));\n    }\n\n    bool color = img.channels() > 1;\n\n    CV_CheckType(type_, depth == CV_8U || depth == CV_16U || depth == CV_32F || depth == CV_64F, \"\");\n\n    if (m_width && m_height)\n    {\n        int is_tiled = TIFFIsTiled(tif) != 0;\n        bool isGrayScale = photometric == PHOTOMETRIC_MINISWHITE || photometric == PHOTOMETRIC_MINISBLACK;\n        uint16 bpp = 8, ncn = isGrayScale ? 1 : 3;\n        CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bpp));\n        CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &ncn));\n        uint16 img_orientation = ORIENTATION_TOPLEFT;\n        CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_ORIENTATION, &img_orientation));\n        const int bitsPerByte = 8;\n        int dst_bpp = (int)(img.elemSize1() * bitsPerByte);\n        bool vert_flip = dst_bpp == 8 &&\n                        (img_orientation == ORIENTATION_BOTRIGHT || img_orientation == ORIENTATION_RIGHTBOT ||\n                         img_orientation == ORIENTATION_BOTLEFT || img_orientation == ORIENTATION_LEFTBOT);\n        int wanted_channels = normalizeChannelsNumber(img.channels());\n\n        if (dst_bpp == 8)\n        {\n            char errmsg[1024];\n            if (!TIFFRGBAImageOK(tif, errmsg))\n            {\n                CV_LOG_WARNING(NULL, \"OpenCV TIFF: TIFFRGBAImageOK: \" << errmsg);\n                close();\n                return false;\n            }\n        }\n\n        uint32 tile_width0 = m_width, tile_height0 = 0;\n\n        if (is_tiled)\n        {\n            CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_TILEWIDTH, &tile_width0));\n            CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_TILELENGTH, &tile_height0));\n        }\n        else\n        {\n            // optional\n            CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &tile_height0));\n        }\n\n        {\n            if (tile_width0 == 0)\n                tile_width0 = m_width;\n\n            if (tile_height0 == 0 ||\n                    (!is_tiled && tile_height0 == std::numeric_limits<uint32>::max()) )\n                tile_height0 = m_height;\n\n            const int TILE_MAX_WIDTH = (1 << 24);\n            const int TILE_MAX_HEIGHT = (1 << 24);\n            CV_Assert((int)tile_width0 > 0 && (int)tile_width0 <= TILE_MAX_WIDTH);\n            CV_Assert((int)tile_height0 > 0 && (int)tile_height0 <= TILE_MAX_HEIGHT);\n            const uint64_t MAX_TILE_SIZE = (CV_BIG_UINT(1) << 30);\n            CV_CheckLE((int)ncn, 4, \"\");\n            CV_CheckLE((int)bpp, 64, \"\");\n            CV_Assert(((uint64_t)tile_width0 * tile_height0 * ncn * std::max(1, (int)(bpp / bitsPerByte)) < MAX_TILE_SIZE) && \"TIFF tile size is too large: >= 1Gb\");\n\n            if (dst_bpp == 8)\n            {\n                // we will use TIFFReadRGBA* functions, so allocate temporary buffer for 32bit RGBA\n                bpp = 8;\n                ncn = 4;\n            }\n            else if (dst_bpp == 32 || dst_bpp == 64)\n            {\n                CV_Assert(ncn == img.channels());\n                CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP));\n            }\n            const size_t buffer_size = (bpp / bitsPerByte) * ncn * tile_height0 * tile_width0;\n            AutoBuffer<uchar> _buffer(buffer_size);\n            uchar* buffer = _buffer.data();\n            ushort* buffer16 = (ushort*)buffer;\n            int tileidx = 0;\n\n            for (int y = 0; y < m_height; y += (int)tile_height0)\n            {\n                int tile_height = std::min((int)tile_height0, m_height - y);\n\n                const int img_y = vert_flip ? m_height - y - tile_height : y;\n\n                for(int x = 0; x < m_width; x += (int)tile_width0, tileidx++)\n                {\n                    int tile_width = std::min((int)tile_width0, m_width - x);\n\n                    switch (dst_bpp)\n                    {\n                        case 8:\n                        {\n                            uchar* bstart = buffer;\n                            if (!is_tiled)\n                            {\n                                CV_TIFF_CHECK_CALL(TIFFReadRGBAStrip(tif, y, (uint32*)buffer));\n                            }\n                            else\n                            {\n                                CV_TIFF_CHECK_CALL(TIFFReadRGBATile(tif, x, y, (uint32*)buffer));\n                                // Tiles fill the buffer from the bottom up\n                                bstart += (tile_height0 - tile_height) * tile_width0 * 4;\n                            }\n\n                            for (int i = 0; i < tile_height; i++)\n                            {\n                                if (color)\n                                {\n                                    if (wanted_channels == 4)\n                                    {\n                                        icvCvt_BGRA2RGBA_8u_C4R(bstart + i*tile_width0*4, 0,\n                                                img.ptr(img_y + tile_height - i - 1, x), 0,\n                                                Size(tile_width, 1) );\n                                    }\n                                    else\n                                    {\n                                        CV_CheckEQ(wanted_channels, 3, \"TIFF-8bpp: BGR/BGRA images are supported only\");\n                                        icvCvt_BGRA2BGR_8u_C4C3R(bstart + i*tile_width0*4, 0,\n                                                img.ptr(img_y + tile_height - i - 1, x), 0,\n                                                Size(tile_width, 1), 2);\n                                    }\n                                }\n                                else\n                                {\n                                    CV_CheckEQ(wanted_channels, 1, \"\");\n                                    icvCvt_BGRA2Gray_8u_C4C1R( bstart + i*tile_width0*4, 0,\n                                            img.ptr(img_y + tile_height - i - 1, x), 0,\n                                            Size(tile_width, 1), 2);\n                                }\n                            }\n                            break;\n                        }\n\n                        case 16:\n                        {\n                            if (!is_tiled)\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedStrip(tif, tileidx, (uint32*)buffer, buffer_size) >= 0);\n                            }\n                            else\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedTile(tif, tileidx, (uint32*)buffer, buffer_size) >= 0);\n                            }\n\n                            for (int i = 0; i < tile_height; i++)\n                            {\n                                if (color)\n                                {\n                                    if (ncn == 1)\n                                    {\n                                        CV_CheckEQ(wanted_channels, 3, \"\");\n                                        icvCvt_Gray2BGR_16u_C1C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1));\n                                    }\n                                    else if (ncn == 3)\n                                    {\n                                        CV_CheckEQ(wanted_channels, 3, \"\");\n                                        icvCvt_RGB2BGR_16u_C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1));\n                                    }\n                                    else if (ncn == 4)\n                                    {\n                                        if (wanted_channels == 4)\n                                        {\n                                            icvCvt_BGRA2RGBA_16u_C4R(buffer16 + i*tile_width0*ncn, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1));\n                                        }\n                                        else\n                                        {\n                                            CV_CheckEQ(wanted_channels, 3, \"TIFF-16bpp: BGR/BGRA images are supported only\");\n                                            icvCvt_BGRA2BGR_16u_C4C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1), 2);\n                                        }\n                                    }\n                                    else\n                                    {\n                                        CV_Error(Error::StsError, \"Not supported\");\n                                    }\n                                }\n                                else\n                                {\n                                    CV_CheckEQ(wanted_channels, 1, \"\");\n                                    if( ncn == 1 )\n                                    {\n                                        memcpy(img.ptr<ushort>(img_y + i, x),\n                                               buffer16 + i*tile_width0*ncn,\n                                               tile_width*sizeof(ushort));\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2Gray_16u_CnC1R(buffer16 + i*tile_width0*ncn, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1), ncn, 2);\n                                    }\n                                }\n                            }\n                            break;\n                        }\n\n                        case 32:\n                        case 64:\n                        {\n                            if( !is_tiled )\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedStrip(tif, tileidx, buffer, buffer_size) >= 0);\n                            }\n                            else\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedTile(tif, tileidx, buffer, buffer_size) >= 0);\n                            }\n\n                            Mat m_tile(Size(tile_width0, tile_height0), CV_MAKETYPE((dst_bpp == 32) ? CV_32F : CV_64F, ncn), buffer);\n                            Rect roi_tile(0, 0, tile_width, tile_height);\n                            Rect roi_img(x, img_y, tile_width, tile_height);\n                            if (!m_hdr && ncn == 3)\n                                cvtColor(m_tile(roi_tile), img(roi_img), COLOR_RGB2BGR);\n                            else if (!m_hdr && ncn == 4)\n                                cvtColor(m_tile(roi_tile), img(roi_img), COLOR_RGBA2BGRA);\n                            else\n                                m_tile(roi_tile).copyTo(img(roi_img));\n                            break;\n                        }\n                        default:\n                        {\n                            CV_Assert(0 && \"OpenCV TIFF: unsupported depth\");\n                        }\n                    }  // switch (dst_bpp)\n                }  // for x\n            }  // for y\n        }\n        fixOrientation(img, img_orientation, dst_bpp);\n    }\n\n    if (m_hdr && depth >= CV_32F)\n    {\n        CV_Assert(photometric == PHOTOMETRIC_LOGLUV);\n        cvtColor(img, img, COLOR_XYZ2BGR);\n    }\n    return true;\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////\n\nTiffEncoder::TiffEncoder()\n{\n    m_description = \"TIFF Files (*.tiff;*.tif)\";\n    m_buf_supported = true;\n}\n\nTiffEncoder::~TiffEncoder()\n{\n}\n\nImageEncoder TiffEncoder::newEncoder() const\n{\n    return makePtr<TiffEncoder>();\n}\n\nbool TiffEncoder::isFormatSupported( int depth ) const\n{\n    return depth == CV_8U || depth == CV_16U || depth == CV_32F || depth == CV_64F;\n}\n\nvoid  TiffEncoder::writeTag( WLByteStream& strm, TiffTag tag,\n                             TiffFieldType fieldType,\n                             int count, int value )\n{\n    strm.putWord( tag );\n    strm.putWord( fieldType );\n    strm.putDWord( count );\n    strm.putDWord( value );\n}\n\nclass TiffEncoderBufHelper\n{\npublic:\n\n    TiffEncoderBufHelper(std::vector<uchar> *buf)\n            : m_buf(buf), m_buf_pos(0)\n    {}\n\n    TIFF* open ()\n    {\n        // do NOT put \"wb\" as the mode, because the b means \"big endian\" mode, not \"binary\" mode.\n        // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n        return TIFFClientOpen( \"\", \"w\", reinterpret_cast<thandle_t>(this), &TiffEncoderBufHelper::read,\n                               &TiffEncoderBufHelper::write, &TiffEncoderBufHelper::seek,\n                               &TiffEncoderBufHelper::close, &TiffEncoderBufHelper::size,\n                               /*map=*/0, /*unmap=*/0 );\n    }\n\n    static tmsize_t read( thandle_t /*handle*/, void* /*buffer*/, tmsize_t /*n*/ )\n    {\n        // Not used for encoding.\n        return 0;\n    }\n\n    static tmsize_t write( thandle_t handle, void* buffer, tmsize_t n )\n    {\n        TiffEncoderBufHelper *helper = reinterpret_cast<TiffEncoderBufHelper*>(handle);\n        size_t begin = (size_t)helper->m_buf_pos;\n        size_t end = begin + n;\n        if ( helper->m_buf->size() < end )\n        {\n            helper->m_buf->resize(end);\n        }\n        memcpy(&(*helper->m_buf)[begin], buffer, n);\n        helper->m_buf_pos = end;\n        return n;\n    }\n\n    static toff_t seek( thandle_t handle, toff_t offset, int whence )\n    {\n        TiffEncoderBufHelper *helper = reinterpret_cast<TiffEncoderBufHelper*>(handle);\n        const toff_t size = helper->m_buf->size();\n        toff_t new_pos = helper->m_buf_pos;\n        switch (whence)\n        {\n            case SEEK_SET:\n                new_pos = offset;\n                break;\n            case SEEK_CUR:\n                new_pos += offset;\n                break;\n            case SEEK_END:\n                new_pos = size + offset;\n                break;\n        }\n        helper->m_buf_pos = new_pos;\n        return new_pos;\n    }\n\n    static toff_t size( thandle_t handle )\n    {\n        TiffEncoderBufHelper *helper = reinterpret_cast<TiffEncoderBufHelper*>(handle);\n        return helper->m_buf->size();\n    }\n\n    static int close( thandle_t /*handle*/ )\n    {\n        // Do nothing.\n        return 0;\n    }\n\nprivate:\n\n    std::vector<uchar>* m_buf;\n    toff_t m_buf_pos;\n};\n\nstatic bool readParam(const std::vector<int>& params, int key, int& value)\n{\n    for (size_t i = 0; i + 1 < params.size(); i += 2)\n    {\n        if (params[i] == key)\n        {\n            value = params[i + 1];\n            return true;\n        }\n    }\n    return false;\n}\n\nbool TiffEncoder::writeLibTiff( const std::vector<Mat>& img_vec, const std::vector<int>& params)\n{\n    // do NOT put \"wb\" as the mode, because the b means \"big endian\" mode, not \"binary\" mode.\n    // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n    TIFF* tif = NULL;\n\n    TiffEncoderBufHelper buf_helper(m_buf);\n    if ( m_buf )\n    {\n        tif = buf_helper.open();\n    }\n    else\n    {\n        tif = TIFFOpen(m_filename.c_str(), \"w\");\n    }\n    if (!tif)\n    {\n        return false;\n    }\n    cv::Ptr<void> tif_cleanup(tif, cv_tiffCloseHandle);\n\n    //Settings that matter to all images\n    int compression = COMPRESSION_LZW;\n    int predictor = PREDICTOR_HORIZONTAL;\n    int resUnit = -1, dpiX = -1, dpiY = -1;\n\n    readParam(params, IMWRITE_TIFF_COMPRESSION, compression);\n    readParam(params, TIFFTAG_PREDICTOR, predictor);\n    readParam(params, IMWRITE_TIFF_RESUNIT, resUnit);\n    readParam(params, IMWRITE_TIFF_XDPI, dpiX);\n    readParam(params, IMWRITE_TIFF_YDPI, dpiY);\n\n    //Iterate through each image in the vector and write them out as Tiff directories\n    for (size_t page = 0; page < img_vec.size(); page++)\n    {\n        const Mat& img = img_vec[page];\n        CV_Assert(!img.empty());\n        int channels = img.channels();\n        int width = img.cols, height = img.rows;\n        int type = img.type();\n        int depth = CV_MAT_DEPTH(type);\n        CV_CheckType(type, depth == CV_8U || depth == CV_16U || depth == CV_32F || depth == CV_64F, \"\");\n        CV_CheckType(type, channels >= 1 && channels <= 4, \"\");\n\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, width));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_IMAGELENGTH, height));\n\n        if (img_vec.size() > 1)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE));\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PAGENUMBER, page, img_vec.size()));\n        }\n\n        int compression_param = -1;  // OPENCV_FUTURE\n        if (type == CV_32FC3 && (!readParam(params, IMWRITE_TIFF_COMPRESSION, compression_param) || compression_param == COMPRESSION_SGILOG))\n        {\n            if (!write_32FC3_SGILOG(img, tif))\n                return false;\n            continue;\n        }\n\n        int page_compression = compression;\n\n        int bitsPerChannel = -1;\n        switch (depth)\n        {\n            case CV_8U:\n            {\n                bitsPerChannel = 8;\n                break;\n            }\n            case CV_16U:\n            {\n                bitsPerChannel = 16;\n                break;\n            }\n            case CV_32F:\n            {\n                bitsPerChannel = 32;\n                page_compression = COMPRESSION_NONE;\n                break;\n            }\n            case CV_64F:\n            {\n                bitsPerChannel = 64;\n                page_compression = COMPRESSION_NONE;\n                break;\n            }\n            default:\n            {\n                return false;\n            }\n        }\n\n        const int bitsPerByte = 8;\n        size_t fileStep = (width * channels * bitsPerChannel) / bitsPerByte;\n        CV_Assert(fileStep > 0);\n\n        int rowsPerStrip = (int)((1 << 13) / fileStep);\n        readParam(params, TIFFTAG_ROWSPERSTRIP, rowsPerStrip);\n        rowsPerStrip = std::max(1, std::min(height, rowsPerStrip));\n\n        int colorspace = channels > 1 ? PHOTOMETRIC_RGB : PHOTOMETRIC_MINISBLACK;\n\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, bitsPerChannel));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_COMPRESSION, page_compression));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, colorspace));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, channels));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, rowsPerStrip));\n\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, depth >= CV_32F ? SAMPLEFORMAT_IEEEFP : SAMPLEFORMAT_UINT));\n\n        if (page_compression != COMPRESSION_NONE)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PREDICTOR, predictor));\n        }\n\n        if (resUnit >= RESUNIT_NONE && resUnit <= RESUNIT_CENTIMETER)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_RESOLUTIONUNIT, resUnit));\n        }\n        if (dpiX >= 0)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_XRESOLUTION, (float)dpiX));\n        }\n        if (dpiY >= 0)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_YRESOLUTION, (float)dpiY));\n        }\n\n        // row buffer, because TIFFWriteScanline modifies the original data!\n        size_t scanlineSize = TIFFScanlineSize(tif);\n        AutoBuffer<uchar> _buffer(scanlineSize + 32);\n        uchar* buffer = _buffer.data(); CV_DbgAssert(buffer);\n        Mat m_buffer(Size(width, 1), CV_MAKETYPE(depth, channels), buffer, (size_t)scanlineSize);\n\n        for (int y = 0; y < height; ++y)\n        {\n            switch (channels)\n            {\n                case 1:\n                {\n                    memcpy(buffer, img.ptr(y), scanlineSize);\n                    break;\n                }\n\n                case 3:\n                {\n                    cvtColor(img(Rect(0, y, width, 1)), (const Mat&)m_buffer, COLOR_BGR2RGB);\n                    break;\n                }\n\n                case 4:\n                {\n                    cvtColor(img(Rect(0, y, width, 1)), (const Mat&)m_buffer, COLOR_BGRA2RGBA);\n                    break;\n                }\n\n                default:\n                {\n                    CV_Assert(0);\n                }\n            }\n\n            CV_TIFF_CHECK_CALL(TIFFWriteScanline(tif, buffer, y, 0) == 1);\n        }\n\n        CV_TIFF_CHECK_CALL(TIFFWriteDirectory(tif));\n    }\n\n    return true;\n}\n\nbool TiffEncoder::write_32FC3_SGILOG(const Mat& _img, void* tif_)\n{\n    TIFF* tif = (TIFF*)tif_;\n    CV_Assert(tif);\n\n    Mat img;\n    cvtColor(_img, img, COLOR_BGR2XYZ);\n\n    //done by caller: CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, img.cols));\n    //done by caller: CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_IMAGELENGTH, img.rows));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 3));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 32));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_SGILOG));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_LOGLUV));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_FLOAT));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, 1));\n    const int strip_size = 3 * img.cols;\n    for (int i = 0; i < img.rows; i++)\n    {\n        CV_TIFF_CHECK_CALL(TIFFWriteEncodedStrip(tif, i, (tdata_t)img.ptr<float>(i), strip_size * sizeof(float)) != (tsize_t)-1);\n    }\n    CV_TIFF_CHECK_CALL(TIFFWriteDirectory(tif));\n    return true;\n}\n\nbool TiffEncoder::writemulti(const std::vector<Mat>& img_vec, const std::vector<int>& params)\n{\n    return writeLibTiff(img_vec, params);\n}\n\nbool  TiffEncoder::write( const Mat& img, const std::vector<int>& params)\n{\n    int type = img.type();\n    int depth = CV_MAT_DEPTH(type);\n\n    CV_CheckType(type, depth == CV_8U || depth == CV_16U || depth == CV_32F || depth == CV_64F, \"\");\n\n    std::vector<Mat> img_vec;\n    img_vec.push_back(img);\n    return writeLibTiff(img_vec, params);\n}\n\n} // namespace\n\n#endif\n",
                "name": "grfmt_tiff.cpp",
                "path": "deps/src/opencv-imgcodecs/grfmt_tiff.cpp",
                "url": "/github.com/neuromore/studio/-/blob/deps/src/opencv-imgcodecs/grfmt_tiff.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 522,
                    "offsetAndLengths": [
                        [
                            51,
                            16
                        ]
                    ],
                    "preview": "                                CV_TIFF_CHECK_CALL(TIFFReadRGBATile(tif, x, y, (uint32*)buffer));"
                }
            ],
            "repository": {
                "name": "github.com/neuromore/studio",
                "url": "/github.com/neuromore/studio"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "ee34d813bda65f8a03eec2477abb9ce8f2a6978d"
                },
                "content": "/*M///////////////////////////////////////////////////////////////////////////////////////\n//\n//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.\n//\n//  By downloading, copying, installing or using the software you agree to this license.\n//  If you do not agree to this license, do not download, install,\n//  copy or use the software.\n//\n//\n//                           License Agreement\n//                For Open Source Computer Vision Library\n//\n// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.\n// Copyright (C) 2009, Willow Garage Inc., all rights reserved.\n// Third party copyrights are property of their respective owners.\n//\n// Redistribution and use in source and binary forms, with or without modification,\n// are permitted provided that the following conditions are met:\n//\n//   * Redistribution's of source code must retain the above copyright notice,\n//     this list of conditions and the following disclaimer.\n//\n//   * Redistribution's in binary form must reproduce the above copyright notice,\n//     this list of conditions and the following disclaimer in the documentation\n//     and/or other materials provided with the distribution.\n//\n//   * The name of the copyright holders may not be used to endorse or promote products\n//     derived from this software without specific prior written permission.\n//\n// This software is provided by the copyright holders and contributors \"as is\" and\n// any express or implied warranties, including, but not limited to, the implied\n// warranties of merchantability and fitness for a particular purpose are disclaimed.\n// In no event shall the Intel Corporation or contributors be liable for any direct,\n// indirect, incidental, special, exemplary, or consequential damages\n// (including, but not limited to, procurement of substitute goods or services;\n// loss of use, data, or profits; or business interruption) however caused\n// and on any theory of liability, whether in contract, strict liability,\n// or tort (including negligence or otherwise) arising in any way out of\n// the use of this software, even if advised of the possibility of such damage.\n//\n//M*/\n\n/****************************************************************************************\\\n    A part of the file implements TIFF reader on base of libtiff library\n    (see otherlibs/_graphics/readme.txt for copyright notice)\n\\****************************************************************************************/\n\n#include \"precomp.hpp\"\n#include \"grfmt_tiff.hpp\"\n#include BOSS_OPENCV_V_opencv2__imgproc_hpp //original-code:<opencv2/imgproc.hpp>\n#include <limits>\n\nnamespace cv\n{\nstatic const char fmtSignTiffII[] = \"II\\x2a\\x00\";\n\n#ifdef HAVE_TIFF\n\nstatic const char fmtSignTiffMM[] = \"MM\\x00\\x2a\";\n\n#include \"tiff.h\"\n#include \"tiffio.h\"\n\nstatic int grfmt_tiff_err_handler_init = 0;\nstatic void GrFmtSilentTIFFErrorHandler( const char*, const char*, va_list ) {}\n\nTiffDecoder::TiffDecoder()\n{\n    m_tif = 0;\n    if( !grfmt_tiff_err_handler_init )\n    {\n        grfmt_tiff_err_handler_init = 1;\n\n        TIFFSetErrorHandler( GrFmtSilentTIFFErrorHandler );\n        TIFFSetWarningHandler( GrFmtSilentTIFFErrorHandler );\n    }\n    m_hdr = false;\n}\n\n\nvoid TiffDecoder::close()\n{\n    if( m_tif )\n    {\n        TIFF* tif = (TIFF*)m_tif;\n        TIFFClose( tif );\n        m_tif = 0;\n    }\n}\n\nTiffDecoder::~TiffDecoder()\n{\n    close();\n}\n\nsize_t TiffDecoder::signatureLength() const\n{\n    return 4;\n}\n\nbool TiffDecoder::checkSignature( const String& signature ) const\n{\n    return signature.size() >= 4 &&\n        (memcmp(signature.c_str(), fmtSignTiffII, 4) == 0 ||\n        memcmp(signature.c_str(), fmtSignTiffMM, 4) == 0);\n}\n\nint TiffDecoder::normalizeChannelsNumber(int channels) const\n{\n    return channels > 4 ? 4 : channels;\n}\n\nImageDecoder TiffDecoder::newDecoder() const\n{\n    return makePtr<TiffDecoder>();\n}\n\nbool TiffDecoder::readHeader()\n{\n    bool result = false;\n\n    TIFF* tif = static_cast<TIFF*>(m_tif);\n    if (!m_tif)\n    {\n        // TIFFOpen() mode flags are different to fopen().  A 'b' in mode \"rb\" has no effect when reading.\n        // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n        tif = TIFFOpen(m_filename.c_str(), \"r\");\n    }\n\n    if( tif )\n    {\n        uint32 wdth = 0, hght = 0;\n        uint16 photometric = 0;\n        m_tif = tif;\n\n        if( TIFFGetField( tif, TIFFTAG_IMAGEWIDTH, &wdth ) &&\n            TIFFGetField( tif, TIFFTAG_IMAGELENGTH, &hght ) &&\n            TIFFGetField( tif, TIFFTAG_PHOTOMETRIC, &photometric ))\n        {\n            uint16 bpp=8, ncn = photometric > 1 ? 3 : 1;\n            TIFFGetField( tif, TIFFTAG_BITSPERSAMPLE, &bpp );\n            TIFFGetField( tif, TIFFTAG_SAMPLESPERPIXEL, &ncn );\n\n            m_width = wdth;\n            m_height = hght;\n            if((bpp == 32 && ncn == 3) || photometric == PHOTOMETRIC_LOGLUV)\n            {\n                m_type = CV_32FC3;\n                m_hdr = true;\n                return true;\n            }\n            m_hdr = false;\n\n            if( bpp > 8 &&\n               ((photometric != 2 && photometric != 1) ||\n                (ncn != 1 && ncn != 3 && ncn != 4)))\n                bpp = 8;\n\n            int wanted_channels = normalizeChannelsNumber(ncn);\n            switch(bpp)\n            {\n                case 8:\n                    m_type = CV_MAKETYPE(CV_8U, photometric > 1 ? wanted_channels : 1);\n                    break;\n                case 16:\n                    m_type = CV_MAKETYPE(CV_16U, photometric > 1 ? wanted_channels : 1);\n                    break;\n\n                case 32:\n                    m_type = CV_MAKETYPE(CV_32F, photometric > 1 ? 3 : 1);\n                    break;\n                case 64:\n                    m_type = CV_MAKETYPE(CV_64F, photometric > 1 ? 3 : 1);\n                    break;\n\n                default:\n                    result = false;\n            }\n            result = true;\n        }\n    }\n\n    if( !result )\n        close();\n\n    return result;\n}\n\nbool TiffDecoder::nextPage()\n{\n    // Prepare the next page, if any.\n    return m_tif &&\n           TIFFReadDirectory(static_cast<TIFF*>(m_tif)) &&\n           readHeader();\n}\n\nbool  TiffDecoder::readData( Mat& img )\n{\n    if(m_hdr && img.type() == CV_32FC3)\n    {\n        return readHdrData(img);\n    }\n    bool result = false;\n    bool color = img.channels() > 1;\n    uchar* data = img.ptr();\n\n    if( img.depth() != CV_8U && img.depth() != CV_16U && img.depth() != CV_32F && img.depth() != CV_64F )\n        return false;\n\n    if( m_tif && m_width && m_height )\n    {\n        TIFF* tif = (TIFF*)m_tif;\n        uint32 tile_width0 = m_width, tile_height0 = 0;\n        int x, y, i;\n        int is_tiled = TIFFIsTiled(tif);\n        uint16 photometric;\n        TIFFGetField( tif, TIFFTAG_PHOTOMETRIC, &photometric );\n        uint16 bpp = 8, ncn = photometric > 1 ? 3 : 1;\n        TIFFGetField( tif, TIFFTAG_BITSPERSAMPLE, &bpp );\n        TIFFGetField( tif, TIFFTAG_SAMPLESPERPIXEL, &ncn );\n        const int bitsPerByte = 8;\n        int dst_bpp = (int)(img.elemSize1() * bitsPerByte);\n        int wanted_channels = normalizeChannelsNumber(img.channels());\n\n        if(dst_bpp == 8)\n        {\n            char errmsg[1024];\n            if(!TIFFRGBAImageOK( tif, errmsg ))\n            {\n                close();\n                return false;\n            }\n        }\n\n        if( (!is_tiled) ||\n            (is_tiled &&\n            TIFFGetField( tif, TIFFTAG_TILEWIDTH, &tile_width0 ) &&\n            TIFFGetField( tif, TIFFTAG_TILELENGTH, &tile_height0 )))\n        {\n            if(!is_tiled)\n                TIFFGetField( tif, TIFFTAG_ROWSPERSTRIP, &tile_height0 );\n\n            if( tile_width0 <= 0 )\n                tile_width0 = m_width;\n\n            if( tile_height0 <= 0 ||\n               (!is_tiled && tile_height0 == std::numeric_limits<uint32>::max()) )\n                tile_height0 = m_height;\n\n            if(dst_bpp == 8) {\n                // we will use TIFFReadRGBA* functions, so allocate temporary buffer for 32bit RGBA\n                bpp = 8;\n                ncn = 4;\n            }\n            const size_t buffer_size = (bpp/bitsPerByte) * ncn * tile_height0 * tile_width0;\n            AutoBuffer<uchar> _buffer( buffer_size );\n            uchar* buffer = _buffer;\n            ushort* buffer16 = (ushort*)buffer;\n            float* buffer32 = (float*)buffer;\n            double* buffer64 = (double*)buffer;\n            int tileidx = 0;\n\n            for( y = 0; y < m_height; y += tile_height0, data += img.step*tile_height0 )\n            {\n                int tile_height = tile_height0;\n\n                if( y + tile_height > m_height )\n                    tile_height = m_height - y;\n\n                for( x = 0; x < m_width; x += tile_width0, tileidx++ )\n                {\n                    int tile_width = tile_width0, ok;\n\n                    if( x + tile_width > m_width )\n                        tile_width = m_width - x;\n\n                    switch(dst_bpp)\n                    {\n                        case 8:\n                        {\n                            uchar * bstart = buffer;\n                            if( !is_tiled )\n                                ok = TIFFReadRGBAStrip( tif, y, (uint32*)buffer );\n                            else\n                            {\n                                ok = TIFFReadRGBATile( tif, x, y, (uint32*)buffer );\n                                //Tiles fill the buffer from the bottom up\n                                bstart += (tile_height0 - tile_height) * tile_width0 * 4;\n                            }\n                            if( !ok )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                                if( color )\n                                {\n                                    if (wanted_channels == 4)\n                                    {\n                                        icvCvt_BGRA2RGBA_8u_C4R( bstart + i*tile_width0*4, 0,\n                                                             data + x*4 + img.step*(tile_height - i - 1), 0,\n                                                             cvSize(tile_width,1) );\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2BGR_8u_C4C3R( bstart + i*tile_width0*4, 0,\n                                                             data + x*3 + img.step*(tile_height - i - 1), 0,\n                                                             cvSize(tile_width,1), 2 );\n                                    }\n                                }\n                                else\n                                    icvCvt_BGRA2Gray_8u_C4C1R( bstart + i*tile_width0*4, 0,\n                                                              data + x + img.step*(tile_height - i - 1), 0,\n                                                              cvSize(tile_width,1), 2 );\n                            break;\n                        }\n\n                        case 16:\n                        {\n                            if( !is_tiled )\n                                ok = (int)TIFFReadEncodedStrip( tif, tileidx, (uint32*)buffer, buffer_size ) >= 0;\n                            else\n                                ok = (int)TIFFReadEncodedTile( tif, tileidx, (uint32*)buffer, buffer_size ) >= 0;\n\n                            if( !ok )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                            {\n                                if( color )\n                                {\n                                    if( ncn == 1 )\n                                    {\n                                        icvCvt_Gray2BGR_16u_C1C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                                  (ushort*)(data + img.step*i) + x*3, 0,\n                                                                  cvSize(tile_width,1) );\n                                    }\n                                    else if( ncn == 3 )\n                                    {\n                                        icvCvt_RGB2BGR_16u_C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                               (ushort*)(data + img.step*i) + x*3, 0,\n                                                               cvSize(tile_width,1) );\n                                    }\n                                    else if (ncn == 4)\n                                    {\n                                        if (wanted_channels == 4)\n                                        {\n                                            icvCvt_BGRA2RGBA_16u_C4R(buffer16 + i*tile_width0*ncn, 0,\n                                                (ushort*)(data + img.step*i) + x * 4, 0,\n                                                cvSize(tile_width, 1));\n                                        }\n                                        else\n                                        {\n                                            icvCvt_BGRA2BGR_16u_C4C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                (ushort*)(data + img.step*i) + x * 3, 0,\n                                                cvSize(tile_width, 1), 2);\n                                        }\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2BGR_16u_C4C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                               (ushort*)(data + img.step*i) + x*3, 0,\n                                                               cvSize(tile_width,1), 2 );\n                                    }\n                                }\n                                else\n                                {\n                                    if( ncn == 1 )\n                                    {\n                                        memcpy((ushort*)(data + img.step*i)+x,\n                                               buffer16 + i*tile_width0*ncn,\n                                               tile_width*sizeof(buffer16[0]));\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2Gray_16u_CnC1R(buffer16 + i*tile_width0*ncn, 0,\n                                                               (ushort*)(data + img.step*i) + x, 0,\n                                                               cvSize(tile_width,1), ncn, 2 );\n                                    }\n                                }\n                            }\n                            break;\n                        }\n\n                        case 32:\n                        case 64:\n                        {\n                            if( !is_tiled )\n                                ok = (int)TIFFReadEncodedStrip( tif, tileidx, buffer, buffer_size ) >= 0;\n                            else\n                                ok = (int)TIFFReadEncodedTile( tif, tileidx, buffer, buffer_size ) >= 0;\n\n                            if( !ok || ncn != 1 )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                            {\n                                if(dst_bpp == 32)\n                                {\n                                    memcpy((float*)(data + img.step*i)+x,\n                                           buffer32 + i*tile_width0*ncn,\n                                           tile_width*sizeof(buffer32[0]));\n                                }\n                                else\n                                {\n                                    memcpy((double*)(data + img.step*i)+x,\n                                         buffer64 + i*tile_width0*ncn,\n                                         tile_width*sizeof(buffer64[0]));\n                                }\n                            }\n\n                            break;\n                        }\n                        default:\n                        {\n                            close();\n                            return false;\n                        }\n                    }\n                }\n            }\n\n            result = true;\n        }\n    }\n\n    return result;\n}\n\nbool TiffDecoder::readHdrData(Mat& img)\n{\n    int rows_per_strip = 0, photometric = 0;\n    if(!m_tif)\n    {\n        return false;\n    }\n    TIFF *tif = static_cast<TIFF*>(m_tif);\n    TIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &rows_per_strip);\n    TIFFGetField( tif, TIFFTAG_PHOTOMETRIC, &photometric );\n    TIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_FLOAT);\n    int size = 3 * m_width * m_height * sizeof (float);\n    tstrip_t strip_size = 3 * m_width * rows_per_strip;\n    float *ptr = img.ptr<float>();\n    for (tstrip_t i = 0; i < TIFFNumberOfStrips(tif); i++, ptr += strip_size)\n    {\n        TIFFReadEncodedStrip(tif, i, ptr, size);\n        size -= strip_size * sizeof(float);\n    }\n    close();\n    if(photometric == PHOTOMETRIC_LOGLUV)\n    {\n        cvtColor(img, img, COLOR_XYZ2BGR);\n    }\n    else\n    {\n        cvtColor(img, img, COLOR_RGB2BGR);\n    }\n    return true;\n}\n\n#endif\n\n//////////////////////////////////////////////////////////////////////////////////////////\n\nTiffEncoder::TiffEncoder()\n{\n    m_description = \"TIFF Files (*.tiff;*.tif)\";\n#ifdef HAVE_TIFF\n    m_buf_supported = false;\n#else\n    m_buf_supported = true;\n#endif\n}\n\nTiffEncoder::~TiffEncoder()\n{\n}\n\nImageEncoder TiffEncoder::newEncoder() const\n{\n    return makePtr<TiffEncoder>();\n}\n\nbool TiffEncoder::isFormatSupported( int depth ) const\n{\n#ifdef HAVE_TIFF\n    return depth == CV_8U || depth == CV_16U || depth == CV_32F;\n#else\n    return depth == CV_8U || depth == CV_16U;\n#endif\n}\n\nvoid  TiffEncoder::writeTag( WLByteStream& strm, TiffTag tag,\n                             TiffFieldType fieldType,\n                             int count, int value )\n{\n    strm.putWord( tag );\n    strm.putWord( fieldType );\n    strm.putDWord( count );\n    strm.putDWord( value );\n}\n\n#ifdef HAVE_TIFF\n\nstatic void readParam(const std::vector<int>& params, int key, int& value)\n{\n    for(size_t i = 0; i + 1 < params.size(); i += 2)\n        if(params[i] == key)\n        {\n            value = params[i+1];\n            break;\n        }\n}\n\nbool  TiffEncoder::writeLibTiff( const Mat& img, const std::vector<int>& params)\n{\n    int channels = img.channels();\n    int width = img.cols, height = img.rows;\n    int depth = img.depth();\n\n    int bitsPerChannel = -1;\n    switch (depth)\n    {\n        case CV_8U:\n        {\n            bitsPerChannel = 8;\n            break;\n        }\n        case CV_16U:\n        {\n            bitsPerChannel = 16;\n            break;\n        }\n        default:\n        {\n            return false;\n        }\n    }\n\n    const int bitsPerByte = 8;\n    size_t fileStep = (width * channels * bitsPerChannel) / bitsPerByte;\n\n    int rowsPerStrip = (int)((1 << 13)/fileStep);\n    readParam(params, TIFFTAG_ROWSPERSTRIP, rowsPerStrip);\n\n    if( rowsPerStrip < 1 )\n        rowsPerStrip = 1;\n\n    if( rowsPerStrip > height )\n        rowsPerStrip = height;\n\n\n    // do NOT put \"wb\" as the mode, because the b means \"big endian\" mode, not \"binary\" mode.\n    // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n    TIFF* pTiffHandle = TIFFOpen(m_filename.c_str(), \"w\");\n    if (!pTiffHandle)\n    {\n        return false;\n    }\n\n    // defaults for now, maybe base them on params in the future\n    int   compression  = COMPRESSION_LZW;\n    int   predictor    = PREDICTOR_HORIZONTAL;\n\n    readParam(params, TIFFTAG_COMPRESSION, compression);\n    readParam(params, TIFFTAG_PREDICTOR, predictor);\n\n    int   colorspace = channels > 1 ? PHOTOMETRIC_RGB : PHOTOMETRIC_MINISBLACK;\n\n    if ( !TIFFSetField(pTiffHandle, TIFFTAG_IMAGEWIDTH, width)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_IMAGELENGTH, height)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_BITSPERSAMPLE, bitsPerChannel)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_COMPRESSION, compression)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_PHOTOMETRIC, colorspace)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_SAMPLESPERPIXEL, channels)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_ROWSPERSTRIP, rowsPerStrip)\n       )\n    {\n        TIFFClose(pTiffHandle);\n        return false;\n    }\n\n    if (compression != COMPRESSION_NONE && !TIFFSetField(pTiffHandle, TIFFTAG_PREDICTOR, predictor) )\n    {\n        TIFFClose(pTiffHandle);\n        return false;\n    }\n\n    // row buffer, because TIFFWriteScanline modifies the original data!\n    size_t scanlineSize = TIFFScanlineSize(pTiffHandle);\n    AutoBuffer<uchar> _buffer(scanlineSize+32);\n    uchar* buffer = _buffer;\n    if (!buffer)\n    {\n        TIFFClose(pTiffHandle);\n        return false;\n    }\n\n    for (int y = 0; y < height; ++y)\n    {\n        switch(channels)\n        {\n            case 1:\n            {\n                memcpy(buffer, img.ptr(y), scanlineSize);\n                break;\n            }\n\n            case 3:\n            {\n                if (depth == CV_8U)\n                    icvCvt_BGR2RGB_8u_C3R( img.ptr(y), 0, buffer, 0, cvSize(width,1) );\n                else\n                    icvCvt_BGR2RGB_16u_C3R( img.ptr<ushort>(y), 0, (ushort*)buffer, 0, cvSize(width,1) );\n                break;\n            }\n\n            case 4:\n            {\n                if (depth == CV_8U)\n                    icvCvt_BGRA2RGBA_8u_C4R( img.ptr(y), 0, buffer, 0, cvSize(width,1) );\n                else\n                    icvCvt_BGRA2RGBA_16u_C4R( img.ptr<ushort>(y), 0, (ushort*)buffer, 0, cvSize(width,1) );\n                break;\n            }\n\n            default:\n            {\n                TIFFClose(pTiffHandle);\n                return false;\n            }\n        }\n\n        int writeResult = TIFFWriteScanline(pTiffHandle, buffer, y, 0);\n        if (writeResult != 1)\n        {\n            TIFFClose(pTiffHandle);\n            return false;\n        }\n    }\n\n    TIFFClose(pTiffHandle);\n    return true;\n}\n\nbool TiffEncoder::writeHdr(const Mat& _img)\n{\n    Mat img;\n    cvtColor(_img, img, COLOR_BGR2XYZ);\n    TIFF* tif = TIFFOpen(m_filename.c_str(), \"w\");\n    if (!tif)\n    {\n        return false;\n    }\n    TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, img.cols);\n    TIFFSetField(tif, TIFFTAG_IMAGELENGTH, img.rows);\n    TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 3);\n    TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_SGILOG);\n    TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_LOGLUV);\n    TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    TIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_FLOAT);\n    TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, 1);\n    int strip_size = 3 * img.cols;\n    float *ptr = const_cast<float*>(img.ptr<float>());\n    for (int i = 0; i < img.rows; i++, ptr += strip_size)\n    {\n        TIFFWriteEncodedStrip(tif, i, ptr, strip_size * sizeof(float));\n    }\n    TIFFClose(tif);\n    return true;\n}\n\n#endif\n\n#ifdef HAVE_TIFF\nbool  TiffEncoder::write( const Mat& img, const std::vector<int>& params)\n#else\nbool  TiffEncoder::write( const Mat& img, const std::vector<int>& /*params*/)\n#endif\n{\n    int channels = img.channels();\n    int width = img.cols, height = img.rows;\n    int depth = img.depth();\n#ifdef HAVE_TIFF\n    if(img.type() == CV_32FC3)\n    {\n        return writeHdr(img);\n    }\n#endif\n\n    if (depth != CV_8U && depth != CV_16U)\n        return false;\n\n    int bytesPerChannel = depth == CV_8U ? 1 : 2;\n    int fileStep = width * channels * bytesPerChannel;\n\n    WLByteStream strm;\n\n    if( m_buf )\n    {\n        if( !strm.open(*m_buf) )\n            return false;\n    }\n    else\n    {\n#ifdef HAVE_TIFF\n      return writeLibTiff(img, params);\n#else\n      if( !strm.open(m_filename) )\n          return false;\n#endif\n    }\n\n    int rowsPerStrip = (1 << 13)/fileStep;\n\n    if( rowsPerStrip < 1 )\n        rowsPerStrip = 1;\n\n    if( rowsPerStrip > height )\n        rowsPerStrip = height;\n\n    int i, stripCount = (height + rowsPerStrip - 1) / rowsPerStrip;\n\n    if( m_buf )\n        m_buf->reserve( alignSize(stripCount*8 + fileStep*height + 256, 256) );\n\n/*#if defined _DEBUG || !defined WIN32\n    int uncompressedRowSize = rowsPerStrip * fileStep;\n#endif*/\n    int directoryOffset = 0;\n\n    AutoBuffer<int> stripOffsets(stripCount);\n    AutoBuffer<short> stripCounts(stripCount);\n    AutoBuffer<uchar> _buffer(fileStep+32);\n    uchar* buffer = _buffer;\n    int  stripOffsetsOffset = 0;\n    int  stripCountsOffset = 0;\n    int  bitsPerSample = 8 * bytesPerChannel;\n    int  y = 0;\n\n    strm.putBytes( fmtSignTiffII, 4 );\n    strm.putDWord( directoryOffset );\n\n    // write an image data first (the most reasonable way\n    // for compressed images)\n    for( i = 0; i < stripCount; i++ )\n    {\n        int limit = y + rowsPerStrip;\n\n        if( limit > height )\n            limit = height;\n\n        stripOffsets[i] = strm.getPos();\n\n        for( ; y < limit; y++ )\n        {\n            if( channels == 3 )\n            {\n                if (depth == CV_8U)\n                    icvCvt_BGR2RGB_8u_C3R( img.ptr(y), 0, buffer, 0, cvSize(width,1) );\n                else\n                    icvCvt_BGR2RGB_16u_C3R( img.ptr<ushort>(y), 0, (ushort*)buffer, 0, cvSize(width,1) );\n            }\n            else\n            {\n              if( channels == 4 )\n              {\n                if (depth == CV_8U)\n                    icvCvt_BGRA2RGBA_8u_C4R( img.ptr(y), 0, buffer, 0, cvSize(width,1) );\n                else\n                    icvCvt_BGRA2RGBA_16u_C4R( img.ptr<ushort>(y), 0, (ushort*)buffer, 0, cvSize(width,1) );\n              }\n            }\n\n            strm.putBytes( channels > 1 ? buffer : img.ptr(y), fileStep );\n        }\n\n        stripCounts[i] = (short)(strm.getPos() - stripOffsets[i]);\n        /*assert( stripCounts[i] == uncompressedRowSize ||\n                stripCounts[i] < uncompressedRowSize &&\n                i == stripCount - 1);*/\n    }\n\n    if( stripCount > 2 )\n    {\n        stripOffsetsOffset = strm.getPos();\n        for( i = 0; i < stripCount; i++ )\n            strm.putDWord( stripOffsets[i] );\n\n        stripCountsOffset = strm.getPos();\n        for( i = 0; i < stripCount; i++ )\n            strm.putWord( stripCounts[i] );\n    }\n    else if(stripCount == 2)\n    {\n        stripOffsetsOffset = strm.getPos();\n        for (i = 0; i < stripCount; i++)\n        {\n            strm.putDWord (stripOffsets [i]);\n        }\n        stripCountsOffset = stripCounts [0] + (stripCounts [1] << 16);\n    }\n    else\n    {\n        stripOffsetsOffset = stripOffsets[0];\n        stripCountsOffset = stripCounts[0];\n    }\n\n    if( channels > 1 )\n    {\n        int bitsPerSamplePos = strm.getPos();\n        strm.putWord(bitsPerSample);\n        strm.putWord(bitsPerSample);\n        strm.putWord(bitsPerSample);\n        if( channels == 4 )\n            strm.putWord(bitsPerSample);\n        bitsPerSample = bitsPerSamplePos;\n    }\n\n    directoryOffset = strm.getPos();\n\n    // write header\n    strm.putWord( 9 );\n\n    /* warning: specification 5.0 of Tiff want to have tags in\n       ascending order. This is a non-fatal error, but this cause\n       warning with some tools. So, keep this in ascending order */\n\n    writeTag( strm, TIFF_TAG_WIDTH, TIFF_TYPE_LONG, 1, width );\n    writeTag( strm, TIFF_TAG_HEIGHT, TIFF_TYPE_LONG, 1, height );\n    writeTag( strm, TIFF_TAG_BITS_PER_SAMPLE,\n              TIFF_TYPE_SHORT, channels, bitsPerSample );\n    writeTag( strm, TIFF_TAG_COMPRESSION, TIFF_TYPE_LONG, 1, TIFF_UNCOMP );\n    writeTag( strm, TIFF_TAG_PHOTOMETRIC, TIFF_TYPE_SHORT, 1, channels > 1 ? 2 : 1 );\n\n    writeTag( strm, TIFF_TAG_STRIP_OFFSETS, TIFF_TYPE_LONG,\n              stripCount, stripOffsetsOffset );\n\n    writeTag( strm, TIFF_TAG_SAMPLES_PER_PIXEL, TIFF_TYPE_SHORT, 1, channels );\n    writeTag( strm, TIFF_TAG_ROWS_PER_STRIP, TIFF_TYPE_LONG, 1, rowsPerStrip );\n\n    writeTag( strm, TIFF_TAG_STRIP_COUNTS,\n              stripCount > 1 ? TIFF_TYPE_SHORT : TIFF_TYPE_LONG,\n              stripCount, stripCountsOffset );\n\n    strm.putDWord(0);\n    strm.close();\n\n    if( m_buf )\n    {\n        (*m_buf)[4] = (uchar)directoryOffset;\n        (*m_buf)[5] = (uchar)(directoryOffset >> 8);\n        (*m_buf)[6] = (uchar)(directoryOffset >> 16);\n        (*m_buf)[7] = (uchar)(directoryOffset >> 24);\n    }\n    else\n    {\n        // write directory offset\n        FILE* f = fopen( m_filename.c_str(), \"r+b\" );\n        buffer[0] = (uchar)directoryOffset;\n        buffer[1] = (uchar)(directoryOffset >> 8);\n        buffer[2] = (uchar)(directoryOffset >> 16);\n        buffer[3] = (uchar)(directoryOffset >> 24);\n\n        fseek( f, 4, SEEK_SET );\n        fwrite( buffer, 1, 4, f );\n        fclose(f);\n    }\n\n    return true;\n}\n\n}\n",
                "name": "grfmt_tiff.cpp",
                "path": "Boss2D/addon/opencv-3.1.0_for_boss/modules/imgcodecs/src/grfmt_tiff.cpp",
                "url": "/github.com/BonexGoo/Boss2D/-/blob/Boss2D/addon/opencv-3.1.0_for_boss/modules/imgcodecs/src/grfmt_tiff.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 285,
                    "offsetAndLengths": [
                        [
                            37,
                            16
                        ]
                    ],
                    "preview": "                                ok = TIFFReadRGBATile( tif, x, y, (uint32*)buffer );"
                }
            ],
            "repository": {
                "name": "github.com/BonexGoo/Boss2D",
                "url": "/github.com/BonexGoo/Boss2D"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "ee34d813bda65f8a03eec2477abb9ce8f2a6978d"
                },
                "content": "/*M///////////////////////////////////////////////////////////////////////////////////////\n//\n//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.\n//\n//  By downloading, copying, installing or using the software you agree to this license.\n//  If you do not agree to this license, do not download, install,\n//  copy or use the software.\n//\n//\n//                           License Agreement\n//                For Open Source Computer Vision Library\n//\n// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.\n// Copyright (C) 2009, Willow Garage Inc., all rights reserved.\n// Third party copyrights are property of their respective owners.\n//\n// Redistribution and use in source and binary forms, with or without modification,\n// are permitted provided that the following conditions are met:\n//\n//   * Redistribution's of source code must retain the above copyright notice,\n//     this list of conditions and the following disclaimer.\n//\n//   * Redistribution's in binary form must reproduce the above copyright notice,\n//     this list of conditions and the following disclaimer in the documentation\n//     and/or other materials provided with the distribution.\n//\n//   * The name of the copyright holders may not be used to endorse or promote products\n//     derived from this software without specific prior written permission.\n//\n// This software is provided by the copyright holders and contributors \"as is\" and\n// any express or implied warranties, including, but not limited to, the implied\n// warranties of merchantability and fitness for a particular purpose are disclaimed.\n// In no event shall the Intel Corporation or contributors be liable for any direct,\n// indirect, incidental, special, exemplary, or consequential damages\n// (including, but not limited to, procurement of substitute goods or services;\n// loss of use, data, or profits; or business interruption) however caused\n// and on any theory of liability, whether in contract, strict liability,\n// or tort (including negligence or otherwise) arising in any way out of\n// the use of this software, even if advised of the possibility of such damage.\n//\n//M*/\n\n/****************************************************************************************\\\n    A part of the file implements TIFF reader on base of libtiff library\n    (see otherlibs/_graphics/readme.txt for copyright notice)\n\\****************************************************************************************/\n\n#include \"precomp.hpp\"\n\n#ifdef HAVE_TIFF\n#include <opencv2/core/utils/logger.hpp>\n\n#include \"grfmt_tiff.hpp\"\n#include <limits>\n\n// TODO FIXIT Conflict declarations for common types like int64/uint64\nnamespace tiff_dummy_namespace {\n#include \"tiff.h\"\n#include \"tiffio.h\"\n}\nusing namespace tiff_dummy_namespace;\n\nnamespace cv\n{\n\n#define CV_TIFF_CHECK_CALL(call) \\\n    if (0 == (call)) { \\\n        CV_LOG_WARNING(NULL, \"OpenCV TIFF(line \" << __LINE__ << \"): failed \" #call); \\\n        CV_Error(Error::StsError, \"OpenCV TIFF: failed \" #call); \\\n    }\n\n#define CV_TIFF_CHECK_CALL_INFO(call) \\\n    if (0 == (call)) { \\\n        CV_LOG_INFO(NULL, \"OpenCV TIFF(line \" << __LINE__ << \"): failed optional call: \" #call \", ignoring\"); \\\n    }\n\n#define CV_TIFF_CHECK_CALL_DEBUG(call) \\\n    if (0 == (call)) { \\\n        CV_LOG_DEBUG(NULL, \"OpenCV TIFF(line \" << __LINE__ << \"): failed optional call: \" #call \", ignoring\"); \\\n    }\n\nstatic void cv_tiffCloseHandle(void* handle)\n{\n    TIFFClose((TIFF*)handle);\n}\n\nstatic void cv_tiffErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    if (cv::utils::logging::getLogLevel() < cv::utils::logging::LOG_LEVEL_DEBUG)\n        return;\n    // TODO cv::vformat() with va_list parameter\n    fprintf(stderr, \"OpenCV TIFF: \");\n    if (module != NULL)\n        fprintf(stderr, \"%s: \", module);\n    fprintf(stderr, \"Warning, \");\n    vfprintf(stderr, fmt, ap);\n    fprintf(stderr, \".\\n\");\n}\n\nstatic bool cv_tiffSetErrorHandler_()\n{\n    TIFFSetErrorHandler(cv_tiffErrorHandler);\n    TIFFSetWarningHandler(cv_tiffErrorHandler);\n    return true;\n}\n\nstatic bool cv_tiffSetErrorHandler()\n{\n    static bool v = cv_tiffSetErrorHandler_();\n    return v;\n}\n\nstatic const char fmtSignTiffII[] = \"II\\x2a\\x00\";\nstatic const char fmtSignTiffMM[] = \"MM\\x00\\x2a\";\n\nTiffDecoder::TiffDecoder()\n{\n    m_hdr = false;\n    m_buf_supported = true;\n    m_buf_pos = 0;\n}\n\n\nvoid TiffDecoder::close()\n{\n    m_tif.release();\n}\n\nTiffDecoder::~TiffDecoder()\n{\n    close();\n}\n\nsize_t TiffDecoder::signatureLength() const\n{\n    return 4;\n}\n\nbool TiffDecoder::checkSignature( const String& signature ) const\n{\n    return signature.size() >= 4 &&\n        (memcmp(signature.c_str(), fmtSignTiffII, 4) == 0 ||\n        memcmp(signature.c_str(), fmtSignTiffMM, 4) == 0);\n}\n\nint TiffDecoder::normalizeChannelsNumber(int channels) const\n{\n    CV_Assert(channels <= 4);\n    return channels > 4 ? 4 : channels;\n}\n\nImageDecoder TiffDecoder::newDecoder() const\n{\n    cv_tiffSetErrorHandler();\n    return makePtr<TiffDecoder>();\n}\n\nclass TiffDecoderBufHelper\n{\n    Mat& m_buf;\n    size_t& m_buf_pos;\npublic:\n    TiffDecoderBufHelper(Mat& buf, size_t& buf_pos) :\n        m_buf(buf), m_buf_pos(buf_pos)\n    {}\n    static tmsize_t read( thandle_t handle, void* buffer, tmsize_t n )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        const Mat& buf = helper->m_buf;\n        const tmsize_t size = buf.cols*buf.rows*buf.elemSize();\n        tmsize_t pos = helper->m_buf_pos;\n        if ( n > (size - pos) )\n        {\n            n = size - pos;\n        }\n        memcpy(buffer, buf.ptr() + pos, n);\n        helper->m_buf_pos += n;\n        return n;\n    }\n\n    static tmsize_t write( thandle_t /*handle*/, void* /*buffer*/, tmsize_t /*n*/ )\n    {\n        // Not used for decoding.\n        return 0;\n    }\n\n    static toff_t seek( thandle_t handle, toff_t offset, int whence )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        const Mat& buf = helper->m_buf;\n        const toff_t size = buf.cols*buf.rows*buf.elemSize();\n        toff_t new_pos = helper->m_buf_pos;\n        switch (whence)\n        {\n            case SEEK_SET:\n                new_pos = offset;\n                break;\n            case SEEK_CUR:\n                new_pos += offset;\n                break;\n            case SEEK_END:\n                new_pos = size + offset;\n                break;\n        }\n        new_pos = std::min(new_pos, size);\n        helper->m_buf_pos = (size_t)new_pos;\n        return new_pos;\n    }\n\n    static int map( thandle_t handle, void** base, toff_t* size )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        Mat& buf = helper->m_buf;\n        *base = buf.ptr();\n        *size = buf.cols*buf.rows*buf.elemSize();\n        return 0;\n    }\n\n    static toff_t size( thandle_t handle )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        const Mat& buf = helper->m_buf;\n        return buf.cols*buf.rows*buf.elemSize();\n    }\n\n    static int close( thandle_t handle )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        delete helper;\n        return 0;\n    }\n};\n\nbool TiffDecoder::readHeader()\n{\n    bool result = false;\n\n    TIFF* tif = static_cast<TIFF*>(m_tif.get());\n    if (!tif)\n    {\n        // TIFFOpen() mode flags are different to fopen().  A 'b' in mode \"rb\" has no effect when reading.\n        // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n        if ( !m_buf.empty() )\n        {\n            m_buf_pos = 0;\n            TiffDecoderBufHelper* buf_helper = new TiffDecoderBufHelper(this->m_buf, this->m_buf_pos);\n            tif = TIFFClientOpen( \"\", \"r\", reinterpret_cast<thandle_t>(buf_helper), &TiffDecoderBufHelper::read,\n                                  &TiffDecoderBufHelper::write, &TiffDecoderBufHelper::seek,\n                                  &TiffDecoderBufHelper::close, &TiffDecoderBufHelper::size,\n                                  &TiffDecoderBufHelper::map, /*unmap=*/0 );\n            if (!tif)\n                delete buf_helper;\n        }\n        else\n        {\n            tif = TIFFOpen(m_filename.c_str(), \"r\");\n        }\n        if (tif)\n            m_tif.reset(tif, cv_tiffCloseHandle);\n        else\n            m_tif.release();\n    }\n\n    if (tif)\n    {\n        uint32 wdth = 0, hght = 0;\n        uint16 photometric = 0;\n\n        CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &wdth));\n        CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &hght));\n        CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric));\n\n        {\n            bool isGrayScale = photometric == PHOTOMETRIC_MINISWHITE || photometric == PHOTOMETRIC_MINISBLACK;\n            uint16 bpp = 8, ncn = isGrayScale ? 1 : 3;\n            CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bpp));\n            CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &ncn));\n\n            m_width = wdth;\n            m_height = hght;\n            if (ncn == 3 && photometric == PHOTOMETRIC_LOGLUV)\n            {\n                m_type = CV_32FC3;\n                m_hdr = true;\n                return true;\n            }\n            m_hdr = false;\n\n            if( bpp > 8 &&\n               ((photometric > 2) ||\n                (ncn != 1 && ncn != 3 && ncn != 4)))\n                bpp = 8;\n\n            int wanted_channels = normalizeChannelsNumber(ncn);\n            switch(bpp)\n            {\n                case 1:\n                    m_type = CV_MAKETYPE(CV_8U, !isGrayScale ? wanted_channels : 1);\n                    result = true;\n                    break;\n                case 8:\n                    m_type = CV_MAKETYPE(CV_8U, !isGrayScale ? wanted_channels : 1);\n                    result = true;\n                    break;\n                case 16:\n                    m_type = CV_MAKETYPE(CV_16U, !isGrayScale ? wanted_channels : 1);\n                    result = true;\n                    break;\n                case 32:\n                    m_type = CV_MAKETYPE(CV_32F, wanted_channels);\n                    result = true;\n                    break;\n                case 64:\n                    m_type = CV_MAKETYPE(CV_64F, wanted_channels);\n                    result = true;\n                    break;\n            default:\n                CV_Error(cv::Error::StsError, \"Invalid bitsperpixel value read from TIFF header! Must be 1, 8, 16, 32 or 64.\");\n            }\n        }\n    }\n\n    if( !result )\n        close();\n\n    return result;\n}\n\nbool TiffDecoder::nextPage()\n{\n    // Prepare the next page, if any.\n    return !m_tif.empty() &&\n           TIFFReadDirectory(static_cast<TIFF*>(m_tif.get())) &&\n           readHeader();\n}\n\nstatic void fixOrientationPartial(Mat &img, uint16 orientation)\n{\n    switch(orientation) {\n        case ORIENTATION_RIGHTTOP:\n        case ORIENTATION_LEFTBOT:\n            flip(img, img, -1);\n            /* fall through */\n\n        case ORIENTATION_LEFTTOP:\n        case ORIENTATION_RIGHTBOT:\n            transpose(img, img);\n            break;\n    }\n}\n\nstatic void fixOrientationFull(Mat &img, int orientation)\n{\n    switch(orientation) {\n        case ORIENTATION_TOPRIGHT:\n            flip(img, img, 1);\n            break;\n\n        case ORIENTATION_BOTRIGHT:\n            flip(img, img, -1);\n            break;\n\n        case ORIENTATION_BOTLEFT:\n            flip(img, img, 0);\n            break;\n\n        case ORIENTATION_LEFTTOP:\n            transpose(img, img);\n            break;\n\n        case ORIENTATION_RIGHTTOP:\n            transpose(img, img);\n            flip(img, img, 1);\n            break;\n\n        case ORIENTATION_RIGHTBOT:\n            transpose(img, img);\n            flip(img, img, -1);\n            break;\n\n        case ORIENTATION_LEFTBOT:\n            transpose(img, img);\n            flip(img, img, 0);\n            break;\n    }\n}\n\n/**\n * Fix orientation defined in tag 274.\n * For 8 bit some corrections are done by TIFFReadRGBAStrip/Tile already.\n * Not so for 16/32/64 bit.\n */\nstatic void fixOrientation(Mat &img, uint16 orientation, int dst_bpp)\n{\n    switch(dst_bpp) {\n        case 8:\n            fixOrientationPartial(img, orientation);\n            break;\n\n        case 16:\n        case 32:\n        case 64:\n            fixOrientationFull(img, orientation);\n            break;\n    }\n}\n\nbool  TiffDecoder::readData( Mat& img )\n{\n    int type = img.type();\n    int depth = CV_MAT_DEPTH(type);\n\n    CV_Assert(!m_tif.empty());\n    TIFF* tif = (TIFF*)m_tif.get();\n\n    uint16 photometric = (uint16)-1;\n    CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric));\n\n    if (m_hdr && depth >= CV_32F)\n    {\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_FLOAT));\n    }\n\n    bool color = img.channels() > 1;\n\n    CV_CheckType(type, depth == CV_8U || depth == CV_16U || depth == CV_32F || depth == CV_64F, \"\");\n\n    if (m_width && m_height)\n    {\n        int is_tiled = TIFFIsTiled(tif) != 0;\n        bool isGrayScale = photometric == PHOTOMETRIC_MINISWHITE || photometric == PHOTOMETRIC_MINISBLACK;\n        uint16 bpp = 8, ncn = isGrayScale ? 1 : 3;\n        CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bpp));\n        CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &ncn));\n        uint16 img_orientation = ORIENTATION_TOPLEFT;\n        CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_ORIENTATION, &img_orientation));\n        const int bitsPerByte = 8;\n        int dst_bpp = (int)(img.elemSize1() * bitsPerByte);\n        bool vert_flip = dst_bpp == 8 &&\n                        (img_orientation == ORIENTATION_BOTRIGHT || img_orientation == ORIENTATION_RIGHTBOT ||\n                         img_orientation == ORIENTATION_BOTLEFT || img_orientation == ORIENTATION_LEFTBOT);\n        int wanted_channels = normalizeChannelsNumber(img.channels());\n\n        if (dst_bpp == 8)\n        {\n            char errmsg[1024];\n            if (!TIFFRGBAImageOK(tif, errmsg))\n            {\n                CV_LOG_WARNING(NULL, \"OpenCV TIFF: TIFFRGBAImageOK: \" << errmsg);\n                close();\n                return false;\n            }\n        }\n\n        uint32 tile_width0 = m_width, tile_height0 = 0;\n\n        if (is_tiled)\n        {\n            CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_TILEWIDTH, &tile_width0));\n            CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_TILELENGTH, &tile_height0));\n        }\n        else\n        {\n            // optional\n            CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &tile_height0));\n        }\n\n        {\n            if (tile_width0 == 0)\n                tile_width0 = m_width;\n\n            if (tile_height0 == 0 ||\n                    (!is_tiled && tile_height0 == std::numeric_limits<uint32>::max()) )\n                tile_height0 = m_height;\n\n            const int TILE_MAX_WIDTH = (1 << 24);\n            const int TILE_MAX_HEIGHT = (1 << 24);\n            CV_Assert((int)tile_width0 > 0 && (int)tile_width0 <= TILE_MAX_WIDTH);\n            CV_Assert((int)tile_height0 > 0 && (int)tile_height0 <= TILE_MAX_HEIGHT);\n            const uint64_t MAX_TILE_SIZE = (CV_BIG_UINT(1) << 30);\n            CV_CheckLE((int)ncn, 4, \"\");\n            CV_CheckLE((int)bpp, 64, \"\");\n            CV_Assert(((uint64_t)tile_width0 * tile_height0 * ncn * std::max(1, (int)(bpp / bitsPerByte)) < MAX_TILE_SIZE) && \"TIFF tile size is too large: >= 1Gb\");\n\n            if (dst_bpp == 8)\n            {\n                // we will use TIFFReadRGBA* functions, so allocate temporary buffer for 32bit RGBA\n                bpp = 8;\n                ncn = 4;\n            }\n            else if (dst_bpp == 32 || dst_bpp == 64)\n            {\n                CV_Assert(ncn == img.channels());\n                CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP));\n            }\n            const size_t buffer_size = (bpp / bitsPerByte) * ncn * tile_height0 * tile_width0;\n            AutoBuffer<uchar> _buffer(buffer_size);\n            uchar* buffer = _buffer.data();\n            ushort* buffer16 = (ushort*)buffer;\n            int tileidx = 0;\n\n            for (int y = 0; y < m_height; y += (int)tile_height0)\n            {\n                int tile_height = std::min((int)tile_height0, m_height - y);\n\n                const int img_y = vert_flip ? m_height - y - tile_height : y;\n\n                for(int x = 0; x < m_width; x += (int)tile_width0, tileidx++)\n                {\n                    int tile_width = std::min((int)tile_width0, m_width - x);\n\n                    switch (dst_bpp)\n                    {\n                        case 8:\n                        {\n                            uchar* bstart = buffer;\n                            if (!is_tiled)\n                            {\n                                CV_TIFF_CHECK_CALL(TIFFReadRGBAStrip(tif, y, (uint32*)buffer));\n                            }\n                            else\n                            {\n                                CV_TIFF_CHECK_CALL(TIFFReadRGBATile(tif, x, y, (uint32*)buffer));\n                                // Tiles fill the buffer from the bottom up\n                                bstart += (tile_height0 - tile_height) * tile_width0 * 4;\n                            }\n\n                            for (int i = 0; i < tile_height; i++)\n                            {\n                                if (color)\n                                {\n                                    if (wanted_channels == 4)\n                                    {\n                                        icvCvt_BGRA2RGBA_8u_C4R(bstart + i*tile_width0*4, 0,\n                                                img.ptr(img_y + tile_height - i - 1, x), 0,\n                                                Size(tile_width, 1) );\n                                    }\n                                    else\n                                    {\n                                        CV_CheckEQ(wanted_channels, 3, \"TIFF-8bpp: BGR/BGRA images are supported only\");\n                                        icvCvt_BGRA2BGR_8u_C4C3R(bstart + i*tile_width0*4, 0,\n                                                img.ptr(img_y + tile_height - i - 1, x), 0,\n                                                Size(tile_width, 1), 2);\n                                    }\n                                }\n                                else\n                                {\n                                    CV_CheckEQ(wanted_channels, 1, \"\");\n                                    icvCvt_BGRA2Gray_8u_C4C1R( bstart + i*tile_width0*4, 0,\n                                            img.ptr(img_y + tile_height - i - 1, x), 0,\n                                            Size(tile_width, 1), 2);\n                                }\n                            }\n                            break;\n                        }\n\n                        case 16:\n                        {\n                            if (!is_tiled)\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedStrip(tif, tileidx, (uint32*)buffer, buffer_size) >= 0);\n                            }\n                            else\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedTile(tif, tileidx, (uint32*)buffer, buffer_size) >= 0);\n                            }\n\n                            for (int i = 0; i < tile_height; i++)\n                            {\n                                if (color)\n                                {\n                                    if (ncn == 1)\n                                    {\n                                        CV_CheckEQ(wanted_channels, 3, \"\");\n                                        icvCvt_Gray2BGR_16u_C1C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1));\n                                    }\n                                    else if (ncn == 3)\n                                    {\n                                        CV_CheckEQ(wanted_channels, 3, \"\");\n                                        icvCvt_RGB2BGR_16u_C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1));\n                                    }\n                                    else if (ncn == 4)\n                                    {\n                                        if (wanted_channels == 4)\n                                        {\n                                            icvCvt_BGRA2RGBA_16u_C4R(buffer16 + i*tile_width0*ncn, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1));\n                                        }\n                                        else\n                                        {\n                                            CV_CheckEQ(wanted_channels, 3, \"TIFF-16bpp: BGR/BGRA images are supported only\");\n                                            icvCvt_BGRA2BGR_16u_C4C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1), 2);\n                                        }\n                                    }\n                                    else\n                                    {\n                                        CV_Error(Error::StsError, \"Not supported\");\n                                    }\n                                }\n                                else\n                                {\n                                    CV_CheckEQ(wanted_channels, 1, \"\");\n                                    if( ncn == 1 )\n                                    {\n                                        memcpy(img.ptr<ushort>(img_y + i, x),\n                                               buffer16 + i*tile_width0*ncn,\n                                               tile_width*sizeof(ushort));\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2Gray_16u_CnC1R(buffer16 + i*tile_width0*ncn, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1), ncn, 2);\n                                    }\n                                }\n                            }\n                            break;\n                        }\n\n                        case 32:\n                        case 64:\n                        {\n                            if( !is_tiled )\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedStrip(tif, tileidx, buffer, buffer_size) >= 0);\n                            }\n                            else\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedTile(tif, tileidx, buffer, buffer_size) >= 0);\n                            }\n\n                            Mat m_tile(Size(tile_width0, tile_height0), CV_MAKETYPE((dst_bpp == 32) ? CV_32F : CV_64F, ncn), buffer);\n                            Rect roi_tile(0, 0, tile_width, tile_height);\n                            Rect roi_img(x, img_y, tile_width, tile_height);\n                            if (!m_hdr && ncn == 3)\n                                cvtColor(m_tile(roi_tile), img(roi_img), COLOR_RGB2BGR);\n                            else if (!m_hdr && ncn == 4)\n                                cvtColor(m_tile(roi_tile), img(roi_img), COLOR_RGBA2BGRA);\n                            else\n                                m_tile(roi_tile).copyTo(img(roi_img));\n                            break;\n                        }\n                        default:\n                        {\n                            CV_Assert(0 && \"OpenCV TIFF: unsupported depth\");\n                        }\n                    }  // switch (dst_bpp)\n                }  // for x\n            }  // for y\n        }\n        fixOrientation(img, img_orientation, dst_bpp);\n    }\n\n    if (m_hdr && depth >= CV_32F)\n    {\n        CV_Assert(photometric == PHOTOMETRIC_LOGLUV);\n        cvtColor(img, img, COLOR_XYZ2BGR);\n    }\n    return true;\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////\n\nTiffEncoder::TiffEncoder()\n{\n    m_description = \"TIFF Files (*.tiff;*.tif)\";\n    m_buf_supported = true;\n}\n\nTiffEncoder::~TiffEncoder()\n{\n}\n\nImageEncoder TiffEncoder::newEncoder() const\n{\n    return makePtr<TiffEncoder>();\n}\n\nbool TiffEncoder::isFormatSupported( int depth ) const\n{\n    return depth == CV_8U || depth == CV_16U || depth == CV_32F || depth == CV_64F;\n}\n\nvoid  TiffEncoder::writeTag( WLByteStream& strm, TiffTag tag,\n                             TiffFieldType fieldType,\n                             int count, int value )\n{\n    strm.putWord( tag );\n    strm.putWord( fieldType );\n    strm.putDWord( count );\n    strm.putDWord( value );\n}\n\nclass TiffEncoderBufHelper\n{\npublic:\n\n    TiffEncoderBufHelper(std::vector<uchar> *buf)\n            : m_buf(buf), m_buf_pos(0)\n    {}\n\n    TIFF* open ()\n    {\n        // do NOT put \"wb\" as the mode, because the b means \"big endian\" mode, not \"binary\" mode.\n        // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n        return TIFFClientOpen( \"\", \"w\", reinterpret_cast<thandle_t>(this), &TiffEncoderBufHelper::read,\n                               &TiffEncoderBufHelper::write, &TiffEncoderBufHelper::seek,\n                               &TiffEncoderBufHelper::close, &TiffEncoderBufHelper::size,\n                               /*map=*/0, /*unmap=*/0 );\n    }\n\n    static tmsize_t read( thandle_t /*handle*/, void* /*buffer*/, tmsize_t /*n*/ )\n    {\n        // Not used for encoding.\n        return 0;\n    }\n\n    static tmsize_t write( thandle_t handle, void* buffer, tmsize_t n )\n    {\n        TiffEncoderBufHelper *helper = reinterpret_cast<TiffEncoderBufHelper*>(handle);\n        size_t begin = (size_t)helper->m_buf_pos;\n        size_t end = begin + n;\n        if ( helper->m_buf->size() < end )\n        {\n            helper->m_buf->resize(end);\n        }\n        memcpy(&(*helper->m_buf)[begin], buffer, n);\n        helper->m_buf_pos = end;\n        return n;\n    }\n\n    static toff_t seek( thandle_t handle, toff_t offset, int whence )\n    {\n        TiffEncoderBufHelper *helper = reinterpret_cast<TiffEncoderBufHelper*>(handle);\n        const toff_t size = helper->m_buf->size();\n        toff_t new_pos = helper->m_buf_pos;\n        switch (whence)\n        {\n            case SEEK_SET:\n                new_pos = offset;\n                break;\n            case SEEK_CUR:\n                new_pos += offset;\n                break;\n            case SEEK_END:\n                new_pos = size + offset;\n                break;\n        }\n        helper->m_buf_pos = new_pos;\n        return new_pos;\n    }\n\n    static toff_t size( thandle_t handle )\n    {\n        TiffEncoderBufHelper *helper = reinterpret_cast<TiffEncoderBufHelper*>(handle);\n        return helper->m_buf->size();\n    }\n\n    static int close( thandle_t /*handle*/ )\n    {\n        // Do nothing.\n        return 0;\n    }\n\nprivate:\n\n    std::vector<uchar>* m_buf;\n    toff_t m_buf_pos;\n};\n\nstatic bool readParam(const std::vector<int>& params, int key, int& value)\n{\n    for (size_t i = 0; i + 1 < params.size(); i += 2)\n    {\n        if (params[i] == key)\n        {\n            value = params[i + 1];\n            return true;\n        }\n    }\n    return false;\n}\n\nbool TiffEncoder::writeLibTiff( const std::vector<Mat>& img_vec, const std::vector<int>& params)\n{\n    // do NOT put \"wb\" as the mode, because the b means \"big endian\" mode, not \"binary\" mode.\n    // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n    TIFF* tif = NULL;\n\n    TiffEncoderBufHelper buf_helper(m_buf);\n    if ( m_buf )\n    {\n        tif = buf_helper.open();\n    }\n    else\n    {\n        tif = TIFFOpen(m_filename.c_str(), \"w\");\n    }\n    if (!tif)\n    {\n        return false;\n    }\n    cv::Ptr<void> tif_cleanup(tif, cv_tiffCloseHandle);\n\n    //Settings that matter to all images\n    int compression = COMPRESSION_LZW;\n    int predictor = PREDICTOR_HORIZONTAL;\n    int resUnit = -1, dpiX = -1, dpiY = -1;\n\n    readParam(params, IMWRITE_TIFF_COMPRESSION, compression);\n    readParam(params, TIFFTAG_PREDICTOR, predictor);\n    readParam(params, IMWRITE_TIFF_RESUNIT, resUnit);\n    readParam(params, IMWRITE_TIFF_XDPI, dpiX);\n    readParam(params, IMWRITE_TIFF_YDPI, dpiY);\n\n    //Iterate through each image in the vector and write them out as Tiff directories\n    for (size_t page = 0; page < img_vec.size(); page++)\n    {\n        const Mat& img = img_vec[page];\n        int channels = img.channels();\n        int width = img.cols, height = img.rows;\n        int type = img.type();\n        int depth = CV_MAT_DEPTH(type);\n        CV_CheckType(type, depth == CV_8U || depth == CV_16U || depth == CV_32F || depth == CV_64F, \"\");\n        CV_CheckType(type, channels >= 1 && channels <= 4, \"\");\n\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, width));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_IMAGELENGTH, height));\n\n        if (img_vec.size() > 1)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE));\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PAGENUMBER, page, img_vec.size()));\n        }\n\n        int compression_param = -1;  // OPENCV_FUTURE\n        if (type == CV_32FC3 && (!readParam(params, IMWRITE_TIFF_COMPRESSION, compression_param) || compression_param == COMPRESSION_SGILOG))\n        {\n            if (!write_32FC3_SGILOG(img, tif))\n                return false;\n            continue;\n        }\n\n        int page_compression = compression;\n\n        int bitsPerChannel = -1;\n        switch (depth)\n        {\n            case CV_8U:\n            {\n                bitsPerChannel = 8;\n                break;\n            }\n            case CV_16U:\n            {\n                bitsPerChannel = 16;\n                break;\n            }\n            case CV_32F:\n            {\n                bitsPerChannel = 32;\n                page_compression = COMPRESSION_NONE;\n                break;\n            }\n            case CV_64F:\n            {\n                bitsPerChannel = 64;\n                page_compression = COMPRESSION_NONE;\n                break;\n            }\n            default:\n            {\n                return false;\n            }\n        }\n\n        const int bitsPerByte = 8;\n        size_t fileStep = (width * channels * bitsPerChannel) / bitsPerByte;\n\n        int rowsPerStrip = (int)((1 << 13) / fileStep);\n        readParam(params, TIFFTAG_ROWSPERSTRIP, rowsPerStrip);\n        rowsPerStrip = std::max(1, std::min(height, rowsPerStrip));\n\n        int colorspace = channels > 1 ? PHOTOMETRIC_RGB : PHOTOMETRIC_MINISBLACK;\n\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, bitsPerChannel));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_COMPRESSION, page_compression));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, colorspace));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, channels));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, rowsPerStrip));\n\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, depth >= CV_32F ? SAMPLEFORMAT_IEEEFP : SAMPLEFORMAT_UINT));\n\n        if (page_compression != COMPRESSION_NONE)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PREDICTOR, predictor));\n        }\n\n        if (resUnit >= RESUNIT_NONE && resUnit <= RESUNIT_CENTIMETER)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_RESOLUTIONUNIT, resUnit));\n        }\n        if (dpiX >= 0)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_XRESOLUTION, (float)dpiX));\n        }\n        if (dpiY >= 0)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_YRESOLUTION, (float)dpiY));\n        }\n\n        // row buffer, because TIFFWriteScanline modifies the original data!\n        size_t scanlineSize = TIFFScanlineSize(tif);\n        AutoBuffer<uchar> _buffer(scanlineSize + 32);\n        uchar* buffer = _buffer.data(); CV_DbgAssert(buffer);\n        Mat m_buffer(Size(width, 1), CV_MAKETYPE(depth, channels), buffer, (size_t)scanlineSize);\n\n        for (int y = 0; y < height; ++y)\n        {\n            switch (channels)\n            {\n                case 1:\n                {\n                    memcpy(buffer, img.ptr(y), scanlineSize);\n                    break;\n                }\n\n                case 3:\n                {\n                    cvtColor(img(Rect(0, y, width, 1)), (const Mat&)m_buffer, COLOR_BGR2RGB);\n                    break;\n                }\n\n                case 4:\n                {\n                    cvtColor(img(Rect(0, y, width, 1)), (const Mat&)m_buffer, COLOR_BGRA2RGBA);\n                    break;\n                }\n\n                default:\n                {\n                    CV_Assert(0);\n                }\n            }\n\n            CV_TIFF_CHECK_CALL(TIFFWriteScanline(tif, buffer, y, 0) == 1);\n        }\n\n        CV_TIFF_CHECK_CALL(TIFFWriteDirectory(tif));\n    }\n\n    return true;\n}\n\nbool TiffEncoder::write_32FC3_SGILOG(const Mat& _img, void* tif_)\n{\n    TIFF* tif = (TIFF*)tif_;\n    CV_Assert(tif);\n\n    Mat img;\n    cvtColor(_img, img, COLOR_BGR2XYZ);\n\n    //done by caller: CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, img.cols));\n    //done by caller: CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_IMAGELENGTH, img.rows));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 3));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 32));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_SGILOG));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_LOGLUV));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_FLOAT));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, 1));\n    const int strip_size = 3 * img.cols;\n    for (int i = 0; i < img.rows; i++)\n    {\n        CV_TIFF_CHECK_CALL(TIFFWriteEncodedStrip(tif, i, (tdata_t)img.ptr<float>(i), strip_size * sizeof(float)) != (tsize_t)-1);\n    }\n    CV_TIFF_CHECK_CALL(TIFFWriteDirectory(tif));\n    return true;\n}\n\nbool TiffEncoder::writemulti(const std::vector<Mat>& img_vec, const std::vector<int>& params)\n{\n    return writeLibTiff(img_vec, params);\n}\n\nbool  TiffEncoder::write( const Mat& img, const std::vector<int>& params)\n{\n    int type = img.type();\n    int depth = CV_MAT_DEPTH(type);\n\n    CV_CheckType(type, depth == CV_8U || depth == CV_16U || depth == CV_32F || depth == CV_64F, \"\");\n\n    std::vector<Mat> img_vec;\n    img_vec.push_back(img);\n    return writeLibTiff(img_vec, params);\n}\n\n} // namespace\n\n#endif\n",
                "name": "grfmt_tiff.cpp",
                "path": "Boss2D/addon/opencv-4.1.1_for_boss/modules/imgcodecs/src/grfmt_tiff.cpp",
                "url": "/github.com/BonexGoo/Boss2D/-/blob/Boss2D/addon/opencv-4.1.1_for_boss/modules/imgcodecs/src/grfmt_tiff.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 522,
                    "offsetAndLengths": [
                        [
                            51,
                            16
                        ]
                    ],
                    "preview": "                                CV_TIFF_CHECK_CALL(TIFFReadRGBATile(tif, x, y, (uint32*)buffer));"
                }
            ],
            "repository": {
                "name": "github.com/BonexGoo/Boss2D",
                "url": "/github.com/BonexGoo/Boss2D"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "6628708caa5a8976aa077b37f5ad16e4d4b841b9"
                },
                "content": "/*M///////////////////////////////////////////////////////////////////////////////////////\n//\n//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.\n//\n//  By downloading, copying, installing or using the software you agree to this license.\n//  If you do not agree to this license, do not download, install,\n//  copy or use the software.\n//\n//\n//                           License Agreement\n//                For Open Source Computer Vision Library\n//\n// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.\n// Copyright (C) 2009, Willow Garage Inc., all rights reserved.\n// Third party copyrights are property of their respective owners.\n//\n// Redistribution and use in source and binary forms, with or without modification,\n// are permitted provided that the following conditions are met:\n//\n//   * Redistribution's of source code must retain the above copyright notice,\n//     this list of conditions and the following disclaimer.\n//\n//   * Redistribution's in binary form must reproduce the above copyright notice,\n//     this list of conditions and the following disclaimer in the documentation\n//     and/or other materials provided with the distribution.\n//\n//   * The name of the copyright holders may not be used to endorse or promote products\n//     derived from this software without specific prior written permission.\n//\n// This software is provided by the copyright holders and contributors \"as is\" and\n// any express or implied warranties, including, but not limited to, the implied\n// warranties of merchantability and fitness for a particular purpose are disclaimed.\n// In no event shall the Intel Corporation or contributors be liable for any direct,\n// indirect, incidental, special, exemplary, or consequential damages\n// (including, but not limited to, procurement of substitute goods or services;\n// loss of use, data, or profits; or business interruption) however caused\n// and on any theory of liability, whether in contract, strict liability,\n// or tort (including negligence or otherwise) arising in any way out of\n// the use of this software, even if advised of the possibility of such damage.\n//\n//M*/\n\n/****************************************************************************************\\\n    A part of the file implements TIFF reader on base of libtiff library\n    (see otherlibs/_graphics/readme.txt for copyright notice)\n\\****************************************************************************************/\n\n#include \"precomp.hpp\"\n\n#ifdef HAVE_TIFF\n#include <opencv2/core/utils/logger.hpp>\n\n#include \"grfmt_tiff.hpp\"\n#include <limits>\n\n// TODO FIXIT Conflict declarations for common types like int64/uint64\nnamespace tiff_dummy_namespace {\n#include \"tiff.h\"\n#include \"tiffio.h\"\n}\nusing namespace tiff_dummy_namespace;\n\nnamespace cv\n{\n\n#define CV_TIFF_CHECK_CALL(call) \\\n    if (0 == (call)) { \\\n        CV_LOG_WARNING(NULL, \"OpenCV TIFF(line \" << __LINE__ << \"): failed \" #call); \\\n        CV_Error(Error::StsError, \"OpenCV TIFF: failed \" #call); \\\n    }\n\n#define CV_TIFF_CHECK_CALL_INFO(call) \\\n    if (0 == (call)) { \\\n        CV_LOG_INFO(NULL, \"OpenCV TIFF(line \" << __LINE__ << \"): failed optional call: \" #call \", ignoring\"); \\\n    }\n\n#define CV_TIFF_CHECK_CALL_DEBUG(call) \\\n    if (0 == (call)) { \\\n        CV_LOG_DEBUG(NULL, \"OpenCV TIFF(line \" << __LINE__ << \"): failed optional call: \" #call \", ignoring\"); \\\n    }\n\nstatic void cv_tiffCloseHandle(void* handle)\n{\n    TIFFClose((TIFF*)handle);\n}\n\nstatic void cv_tiffErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    if (cv::utils::logging::getLogLevel() < cv::utils::logging::LOG_LEVEL_DEBUG)\n        return;\n    // TODO cv::vformat() with va_list parameter\n    fprintf(stderr, \"OpenCV TIFF: \");\n    if (module != NULL)\n        fprintf(stderr, \"%s: \", module);\n    fprintf(stderr, \"Warning, \");\n    vfprintf(stderr, fmt, ap);\n    fprintf(stderr, \".\\n\");\n}\n\nstatic bool cv_tiffSetErrorHandler_()\n{\n    TIFFSetErrorHandler(cv_tiffErrorHandler);\n    TIFFSetWarningHandler(cv_tiffErrorHandler);\n    return true;\n}\n\nstatic bool cv_tiffSetErrorHandler()\n{\n    static bool v = cv_tiffSetErrorHandler_();\n    return v;\n}\n\nstatic const char fmtSignTiffII[] = \"II\\x2a\\x00\";\nstatic const char fmtSignTiffMM[] = \"MM\\x00\\x2a\";\n\nTiffDecoder::TiffDecoder()\n{\n    m_hdr = false;\n    m_buf_supported = true;\n    m_buf_pos = 0;\n}\n\n\nvoid TiffDecoder::close()\n{\n    m_tif.release();\n}\n\nTiffDecoder::~TiffDecoder()\n{\n    close();\n}\n\nsize_t TiffDecoder::signatureLength() const\n{\n    return 4;\n}\n\nbool TiffDecoder::checkSignature( const String& signature ) const\n{\n    return signature.size() >= 4 &&\n        (memcmp(signature.c_str(), fmtSignTiffII, 4) == 0 ||\n        memcmp(signature.c_str(), fmtSignTiffMM, 4) == 0);\n}\n\nint TiffDecoder::normalizeChannelsNumber(int channels) const\n{\n    CV_Assert(channels <= 4);\n    return channels > 4 ? 4 : channels;\n}\n\nImageDecoder TiffDecoder::newDecoder() const\n{\n    cv_tiffSetErrorHandler();\n    return makePtr<TiffDecoder>();\n}\n\nclass TiffDecoderBufHelper\n{\n    Mat& m_buf;\n    size_t& m_buf_pos;\npublic:\n    TiffDecoderBufHelper(Mat& buf, size_t& buf_pos) :\n        m_buf(buf), m_buf_pos(buf_pos)\n    {}\n    static tmsize_t read( thandle_t handle, void* buffer, tmsize_t n )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        const Mat& buf = helper->m_buf;\n        const tmsize_t size = buf.cols*buf.rows*buf.elemSize();\n        tmsize_t pos = helper->m_buf_pos;\n        if ( n > (size - pos) )\n        {\n            n = size - pos;\n        }\n        memcpy(buffer, buf.ptr() + pos, n);\n        helper->m_buf_pos += n;\n        return n;\n    }\n\n    static tmsize_t write( thandle_t /*handle*/, void* /*buffer*/, tmsize_t /*n*/ )\n    {\n        // Not used for decoding.\n        return 0;\n    }\n\n    static toff_t seek( thandle_t handle, toff_t offset, int whence )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        const Mat& buf = helper->m_buf;\n        const toff_t size = buf.cols*buf.rows*buf.elemSize();\n        toff_t new_pos = helper->m_buf_pos;\n        switch (whence)\n        {\n            case SEEK_SET:\n                new_pos = offset;\n                break;\n            case SEEK_CUR:\n                new_pos += offset;\n                break;\n            case SEEK_END:\n                new_pos = size + offset;\n                break;\n        }\n        new_pos = std::min(new_pos, size);\n        helper->m_buf_pos = (size_t)new_pos;\n        return new_pos;\n    }\n\n    static int map( thandle_t handle, void** base, toff_t* size )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        Mat& buf = helper->m_buf;\n        *base = buf.ptr();\n        *size = buf.cols*buf.rows*buf.elemSize();\n        return 0;\n    }\n\n    static toff_t size( thandle_t handle )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        const Mat& buf = helper->m_buf;\n        return buf.cols*buf.rows*buf.elemSize();\n    }\n\n    static int close( thandle_t handle )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        delete helper;\n        return 0;\n    }\n};\n\nbool TiffDecoder::readHeader()\n{\n    bool result = false;\n\n    TIFF* tif = static_cast<TIFF*>(m_tif.get());\n    if (!tif)\n    {\n        // TIFFOpen() mode flags are different to fopen().  A 'b' in mode \"rb\" has no effect when reading.\n        // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n        if ( !m_buf.empty() )\n        {\n            m_buf_pos = 0;\n            TiffDecoderBufHelper* buf_helper = new TiffDecoderBufHelper(this->m_buf, this->m_buf_pos);\n            tif = TIFFClientOpen( \"\", \"r\", reinterpret_cast<thandle_t>(buf_helper), &TiffDecoderBufHelper::read,\n                                  &TiffDecoderBufHelper::write, &TiffDecoderBufHelper::seek,\n                                  &TiffDecoderBufHelper::close, &TiffDecoderBufHelper::size,\n                                  &TiffDecoderBufHelper::map, /*unmap=*/0 );\n            if (!tif)\n                delete buf_helper;\n        }\n        else\n        {\n            tif = TIFFOpen(m_filename.c_str(), \"r\");\n        }\n        if (tif)\n            m_tif.reset(tif, cv_tiffCloseHandle);\n        else\n            m_tif.release();\n    }\n\n    if (tif)\n    {\n        uint32 wdth = 0, hght = 0;\n        uint16 photometric = 0;\n\n        CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &wdth));\n        CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &hght));\n        CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric));\n\n        {\n            bool isGrayScale = photometric == PHOTOMETRIC_MINISWHITE || photometric == PHOTOMETRIC_MINISBLACK;\n            uint16 bpp = 8, ncn = isGrayScale ? 1 : 3;\n            if (0 == TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bpp))\n            {\n                // TIFF bi-level images don't require TIFFTAG_BITSPERSAMPLE tag\n                bpp = 1;\n            }\n            CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &ncn));\n\n            m_width = wdth;\n            m_height = hght;\n            if (ncn == 3 && photometric == PHOTOMETRIC_LOGLUV)\n            {\n                m_type = CV_32FC3;\n                m_hdr = true;\n                return true;\n            }\n            m_hdr = false;\n\n            if( bpp > 8 &&\n               ((photometric > 2) ||\n                (ncn != 1 && ncn != 3 && ncn != 4)))\n                bpp = 8;\n\n            int wanted_channels = normalizeChannelsNumber(ncn);\n            switch(bpp)\n            {\n                case 1:\n                    m_type = CV_MAKETYPE(CV_8U, !isGrayScale ? wanted_channels : 1);\n                    result = true;\n                    break;\n                case 8:\n                    m_type = CV_MAKETYPE(CV_8U, !isGrayScale ? wanted_channels : 1);\n                    result = true;\n                    break;\n                case 16:\n                    m_type = CV_MAKETYPE(CV_16U, !isGrayScale ? wanted_channels : 1);\n                    result = true;\n                    break;\n                case 32:\n                    m_type = CV_MAKETYPE(CV_32F, wanted_channels);\n                    result = true;\n                    break;\n                case 64:\n                    m_type = CV_MAKETYPE(CV_64F, wanted_channels);\n                    result = true;\n                    break;\n            default:\n                CV_Error(cv::Error::StsError, \"Invalid bitsperpixel value read from TIFF header! Must be 1, 8, 16, 32 or 64.\");\n            }\n        }\n    }\n\n    if( !result )\n        close();\n\n    return result;\n}\n\nbool TiffDecoder::nextPage()\n{\n    // Prepare the next page, if any.\n    return !m_tif.empty() &&\n           TIFFReadDirectory(static_cast<TIFF*>(m_tif.get())) &&\n           readHeader();\n}\n\nstatic void fixOrientationPartial(Mat &img, uint16 orientation)\n{\n    switch(orientation) {\n        case ORIENTATION_RIGHTTOP:\n        case ORIENTATION_LEFTBOT:\n            flip(img, img, -1);\n            /* fall through */\n\n        case ORIENTATION_LEFTTOP:\n        case ORIENTATION_RIGHTBOT:\n            transpose(img, img);\n            break;\n    }\n}\n\nstatic void fixOrientationFull(Mat &img, int orientation)\n{\n    switch(orientation) {\n        case ORIENTATION_TOPRIGHT:\n            flip(img, img, 1);\n            break;\n\n        case ORIENTATION_BOTRIGHT:\n            flip(img, img, -1);\n            break;\n\n        case ORIENTATION_BOTLEFT:\n            flip(img, img, 0);\n            break;\n\n        case ORIENTATION_LEFTTOP:\n            transpose(img, img);\n            break;\n\n        case ORIENTATION_RIGHTTOP:\n            transpose(img, img);\n            flip(img, img, 1);\n            break;\n\n        case ORIENTATION_RIGHTBOT:\n            transpose(img, img);\n            flip(img, img, -1);\n            break;\n\n        case ORIENTATION_LEFTBOT:\n            transpose(img, img);\n            flip(img, img, 0);\n            break;\n    }\n}\n\n/**\n * Fix orientation defined in tag 274.\n * For 8 bit some corrections are done by TIFFReadRGBAStrip/Tile already.\n * Not so for 16/32/64 bit.\n */\nstatic void fixOrientation(Mat &img, uint16 orientation, int dst_bpp)\n{\n    switch(dst_bpp) {\n        case 8:\n            fixOrientationPartial(img, orientation);\n            break;\n\n        case 16:\n        case 32:\n        case 64:\n            fixOrientationFull(img, orientation);\n            break;\n    }\n}\n\nbool  TiffDecoder::readData( Mat& img )\n{\n    int type = img.type();\n    int depth = CV_MAT_DEPTH(type);\n\n    CV_Assert(!m_tif.empty());\n    TIFF* tif = (TIFF*)m_tif.get();\n\n    uint16 photometric = (uint16)-1;\n    CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric));\n\n    if (m_hdr && depth >= CV_32F)\n    {\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_FLOAT));\n    }\n\n    bool color = img.channels() > 1;\n\n    CV_CheckType(type, depth == CV_8U || depth == CV_16U || depth == CV_32F || depth == CV_64F, \"\");\n\n    if (m_width && m_height)\n    {\n        int is_tiled = TIFFIsTiled(tif) != 0;\n        bool isGrayScale = photometric == PHOTOMETRIC_MINISWHITE || photometric == PHOTOMETRIC_MINISBLACK;\n        uint16 bpp = 8, ncn = isGrayScale ? 1 : 3;\n        if (0 == TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bpp))\n        {\n            // TIFF bi-level images don't require TIFFTAG_BITSPERSAMPLE tag\n            bpp = 1;\n        }\n        CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &ncn));\n        uint16 img_orientation = ORIENTATION_TOPLEFT;\n        CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_ORIENTATION, &img_orientation));\n        const int bitsPerByte = 8;\n        int dst_bpp = (int)(img.elemSize1() * bitsPerByte);\n        bool vert_flip = dst_bpp == 8 &&\n                        (img_orientation == ORIENTATION_BOTRIGHT || img_orientation == ORIENTATION_RIGHTBOT ||\n                         img_orientation == ORIENTATION_BOTLEFT || img_orientation == ORIENTATION_LEFTBOT);\n        int wanted_channels = normalizeChannelsNumber(img.channels());\n\n        if (dst_bpp == 8)\n        {\n            char errmsg[1024];\n            if (!TIFFRGBAImageOK(tif, errmsg))\n            {\n                CV_LOG_WARNING(NULL, \"OpenCV TIFF: TIFFRGBAImageOK: \" << errmsg);\n                close();\n                return false;\n            }\n        }\n\n        uint32 tile_width0 = m_width, tile_height0 = 0;\n\n        if (is_tiled)\n        {\n            CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_TILEWIDTH, &tile_width0));\n            CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_TILELENGTH, &tile_height0));\n        }\n        else\n        {\n            // optional\n            CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &tile_height0));\n        }\n\n        {\n            if (tile_width0 == 0)\n                tile_width0 = m_width;\n\n            if (tile_height0 == 0 ||\n                    (!is_tiled && tile_height0 == std::numeric_limits<uint32>::max()) )\n                tile_height0 = m_height;\n\n            const int TILE_MAX_WIDTH = (1 << 24);\n            const int TILE_MAX_HEIGHT = (1 << 24);\n            CV_Assert((int)tile_width0 > 0 && (int)tile_width0 <= TILE_MAX_WIDTH);\n            CV_Assert((int)tile_height0 > 0 && (int)tile_height0 <= TILE_MAX_HEIGHT);\n            const uint64_t MAX_TILE_SIZE = (CV_BIG_UINT(1) << 30);\n            CV_CheckLE((int)ncn, 4, \"\");\n            CV_CheckLE((int)bpp, 64, \"\");\n            CV_Assert(((uint64_t)tile_width0 * tile_height0 * ncn * std::max(1, (int)(bpp / bitsPerByte)) < MAX_TILE_SIZE) && \"TIFF tile size is too large: >= 1Gb\");\n\n            if (dst_bpp == 8)\n            {\n                // we will use TIFFReadRGBA* functions, so allocate temporary buffer for 32bit RGBA\n                bpp = 8;\n                ncn = 4;\n            }\n            else if (dst_bpp == 32 || dst_bpp == 64)\n            {\n                CV_Assert(ncn == img.channels());\n                CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP));\n            }\n            const size_t buffer_size = (bpp / bitsPerByte) * ncn * tile_height0 * tile_width0;\n            AutoBuffer<uchar> _buffer(buffer_size);\n            uchar* buffer = _buffer.data();\n            ushort* buffer16 = (ushort*)buffer;\n            int tileidx = 0;\n\n            for (int y = 0; y < m_height; y += (int)tile_height0)\n            {\n                int tile_height = std::min((int)tile_height0, m_height - y);\n\n                const int img_y = vert_flip ? m_height - y - tile_height : y;\n\n                for(int x = 0; x < m_width; x += (int)tile_width0, tileidx++)\n                {\n                    int tile_width = std::min((int)tile_width0, m_width - x);\n\n                    switch (dst_bpp)\n                    {\n                        case 8:\n                        {\n                            uchar* bstart = buffer;\n                            if (!is_tiled)\n                            {\n                                CV_TIFF_CHECK_CALL(TIFFReadRGBAStrip(tif, y, (uint32*)buffer));\n                            }\n                            else\n                            {\n                                CV_TIFF_CHECK_CALL(TIFFReadRGBATile(tif, x, y, (uint32*)buffer));\n                                // Tiles fill the buffer from the bottom up\n                                bstart += (tile_height0 - tile_height) * tile_width0 * 4;\n                            }\n\n                            for (int i = 0; i < tile_height; i++)\n                            {\n                                if (color)\n                                {\n                                    if (wanted_channels == 4)\n                                    {\n                                        icvCvt_BGRA2RGBA_8u_C4R(bstart + i*tile_width0*4, 0,\n                                                img.ptr(img_y + tile_height - i - 1, x), 0,\n                                                Size(tile_width, 1) );\n                                    }\n                                    else\n                                    {\n                                        CV_CheckEQ(wanted_channels, 3, \"TIFF-8bpp: BGR/BGRA images are supported only\");\n                                        icvCvt_BGRA2BGR_8u_C4C3R(bstart + i*tile_width0*4, 0,\n                                                img.ptr(img_y + tile_height - i - 1, x), 0,\n                                                Size(tile_width, 1), 2);\n                                    }\n                                }\n                                else\n                                {\n                                    CV_CheckEQ(wanted_channels, 1, \"\");\n                                    icvCvt_BGRA2Gray_8u_C4C1R( bstart + i*tile_width0*4, 0,\n                                            img.ptr(img_y + tile_height - i - 1, x), 0,\n                                            Size(tile_width, 1), 2);\n                                }\n                            }\n                            break;\n                        }\n\n                        case 16:\n                        {\n                            if (!is_tiled)\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedStrip(tif, tileidx, (uint32*)buffer, buffer_size) >= 0);\n                            }\n                            else\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedTile(tif, tileidx, (uint32*)buffer, buffer_size) >= 0);\n                            }\n\n                            for (int i = 0; i < tile_height; i++)\n                            {\n                                if (color)\n                                {\n                                    if (ncn == 1)\n                                    {\n                                        CV_CheckEQ(wanted_channels, 3, \"\");\n                                        icvCvt_Gray2BGR_16u_C1C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1));\n                                    }\n                                    else if (ncn == 3)\n                                    {\n                                        CV_CheckEQ(wanted_channels, 3, \"\");\n                                        icvCvt_RGB2BGR_16u_C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1));\n                                    }\n                                    else if (ncn == 4)\n                                    {\n                                        if (wanted_channels == 4)\n                                        {\n                                            icvCvt_BGRA2RGBA_16u_C4R(buffer16 + i*tile_width0*ncn, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1));\n                                        }\n                                        else\n                                        {\n                                            CV_CheckEQ(wanted_channels, 3, \"TIFF-16bpp: BGR/BGRA images are supported only\");\n                                            icvCvt_BGRA2BGR_16u_C4C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1), 2);\n                                        }\n                                    }\n                                    else\n                                    {\n                                        CV_Error(Error::StsError, \"Not supported\");\n                                    }\n                                }\n                                else\n                                {\n                                    CV_CheckEQ(wanted_channels, 1, \"\");\n                                    if( ncn == 1 )\n                                    {\n                                        memcpy(img.ptr<ushort>(img_y + i, x),\n                                               buffer16 + i*tile_width0*ncn,\n                                               tile_width*sizeof(ushort));\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2Gray_16u_CnC1R(buffer16 + i*tile_width0*ncn, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1), ncn, 2);\n                                    }\n                                }\n                            }\n                            break;\n                        }\n\n                        case 32:\n                        case 64:\n                        {\n                            if( !is_tiled )\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedStrip(tif, tileidx, buffer, buffer_size) >= 0);\n                            }\n                            else\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedTile(tif, tileidx, buffer, buffer_size) >= 0);\n                            }\n\n                            Mat m_tile(Size(tile_width0, tile_height0), CV_MAKETYPE((dst_bpp == 32) ? CV_32F : CV_64F, ncn), buffer);\n                            Rect roi_tile(0, 0, tile_width, tile_height);\n                            Rect roi_img(x, img_y, tile_width, tile_height);\n                            if (!m_hdr && ncn == 3)\n                                cvtColor(m_tile(roi_tile), img(roi_img), COLOR_RGB2BGR);\n                            else if (!m_hdr && ncn == 4)\n                                cvtColor(m_tile(roi_tile), img(roi_img), COLOR_RGBA2BGRA);\n                            else\n                                m_tile(roi_tile).copyTo(img(roi_img));\n                            break;\n                        }\n                        default:\n                        {\n                            CV_Assert(0 && \"OpenCV TIFF: unsupported depth\");\n                        }\n                    }  // switch (dst_bpp)\n                }  // for x\n            }  // for y\n        }\n        fixOrientation(img, img_orientation, dst_bpp);\n    }\n\n    if (m_hdr && depth >= CV_32F)\n    {\n        CV_Assert(photometric == PHOTOMETRIC_LOGLUV);\n        cvtColor(img, img, COLOR_XYZ2BGR);\n    }\n    return true;\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////\n\nTiffEncoder::TiffEncoder()\n{\n    m_description = \"TIFF Files (*.tiff;*.tif)\";\n    m_buf_supported = true;\n}\n\nTiffEncoder::~TiffEncoder()\n{\n}\n\nImageEncoder TiffEncoder::newEncoder() const\n{\n    return makePtr<TiffEncoder>();\n}\n\nbool TiffEncoder::isFormatSupported( int depth ) const\n{\n    return depth == CV_8U || depth == CV_16U || depth == CV_32F || depth == CV_64F;\n}\n\nvoid  TiffEncoder::writeTag( WLByteStream& strm, TiffTag tag,\n                             TiffFieldType fieldType,\n                             int count, int value )\n{\n    strm.putWord( tag );\n    strm.putWord( fieldType );\n    strm.putDWord( count );\n    strm.putDWord( value );\n}\n\nclass TiffEncoderBufHelper\n{\npublic:\n\n    TiffEncoderBufHelper(std::vector<uchar> *buf)\n            : m_buf(buf), m_buf_pos(0)\n    {}\n\n    TIFF* open ()\n    {\n        // do NOT put \"wb\" as the mode, because the b means \"big endian\" mode, not \"binary\" mode.\n        // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n        return TIFFClientOpen( \"\", \"w\", reinterpret_cast<thandle_t>(this), &TiffEncoderBufHelper::read,\n                               &TiffEncoderBufHelper::write, &TiffEncoderBufHelper::seek,\n                               &TiffEncoderBufHelper::close, &TiffEncoderBufHelper::size,\n                               /*map=*/0, /*unmap=*/0 );\n    }\n\n    static tmsize_t read( thandle_t /*handle*/, void* /*buffer*/, tmsize_t /*n*/ )\n    {\n        // Not used for encoding.\n        return 0;\n    }\n\n    static tmsize_t write( thandle_t handle, void* buffer, tmsize_t n )\n    {\n        TiffEncoderBufHelper *helper = reinterpret_cast<TiffEncoderBufHelper*>(handle);\n        size_t begin = (size_t)helper->m_buf_pos;\n        size_t end = begin + n;\n        if ( helper->m_buf->size() < end )\n        {\n            helper->m_buf->resize(end);\n        }\n        memcpy(&(*helper->m_buf)[begin], buffer, n);\n        helper->m_buf_pos = end;\n        return n;\n    }\n\n    static toff_t seek( thandle_t handle, toff_t offset, int whence )\n    {\n        TiffEncoderBufHelper *helper = reinterpret_cast<TiffEncoderBufHelper*>(handle);\n        const toff_t size = helper->m_buf->size();\n        toff_t new_pos = helper->m_buf_pos;\n        switch (whence)\n        {\n            case SEEK_SET:\n                new_pos = offset;\n                break;\n            case SEEK_CUR:\n                new_pos += offset;\n                break;\n            case SEEK_END:\n                new_pos = size + offset;\n                break;\n        }\n        helper->m_buf_pos = new_pos;\n        return new_pos;\n    }\n\n    static toff_t size( thandle_t handle )\n    {\n        TiffEncoderBufHelper *helper = reinterpret_cast<TiffEncoderBufHelper*>(handle);\n        return helper->m_buf->size();\n    }\n\n    static int close( thandle_t /*handle*/ )\n    {\n        // Do nothing.\n        return 0;\n    }\n\nprivate:\n\n    std::vector<uchar>* m_buf;\n    toff_t m_buf_pos;\n};\n\nstatic bool readParam(const std::vector<int>& params, int key, int& value)\n{\n    for (size_t i = 0; i + 1 < params.size(); i += 2)\n    {\n        if (params[i] == key)\n        {\n            value = params[i + 1];\n            return true;\n        }\n    }\n    return false;\n}\n\nbool TiffEncoder::writeLibTiff( const std::vector<Mat>& img_vec, const std::vector<int>& params)\n{\n    // do NOT put \"wb\" as the mode, because the b means \"big endian\" mode, not \"binary\" mode.\n    // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n    TIFF* tif = NULL;\n\n    TiffEncoderBufHelper buf_helper(m_buf);\n    if ( m_buf )\n    {\n        tif = buf_helper.open();\n    }\n    else\n    {\n        tif = TIFFOpen(m_filename.c_str(), \"w\");\n    }\n    if (!tif)\n    {\n        return false;\n    }\n    cv::Ptr<void> tif_cleanup(tif, cv_tiffCloseHandle);\n\n    //Settings that matter to all images\n    int compression = COMPRESSION_LZW;\n    int predictor = PREDICTOR_HORIZONTAL;\n    int resUnit = -1, dpiX = -1, dpiY = -1;\n\n    readParam(params, IMWRITE_TIFF_COMPRESSION, compression);\n    readParam(params, TIFFTAG_PREDICTOR, predictor);\n    readParam(params, IMWRITE_TIFF_RESUNIT, resUnit);\n    readParam(params, IMWRITE_TIFF_XDPI, dpiX);\n    readParam(params, IMWRITE_TIFF_YDPI, dpiY);\n\n    //Iterate through each image in the vector and write them out as Tiff directories\n    for (size_t page = 0; page < img_vec.size(); page++)\n    {\n        const Mat& img = img_vec[page];\n        CV_Assert(!img.empty());\n        int channels = img.channels();\n        int width = img.cols, height = img.rows;\n        int type = img.type();\n        int depth = CV_MAT_DEPTH(type);\n        CV_CheckType(type, depth == CV_8U || depth == CV_16U || depth == CV_32F || depth == CV_64F, \"\");\n        CV_CheckType(type, channels >= 1 && channels <= 4, \"\");\n\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, width));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_IMAGELENGTH, height));\n\n        if (img_vec.size() > 1)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE));\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PAGENUMBER, page, img_vec.size()));\n        }\n\n        int compression_param = -1;  // OPENCV_FUTURE\n        if (type == CV_32FC3 && (!readParam(params, IMWRITE_TIFF_COMPRESSION, compression_param) || compression_param == COMPRESSION_SGILOG))\n        {\n            if (!write_32FC3_SGILOG(img, tif))\n                return false;\n            continue;\n        }\n\n        int page_compression = compression;\n\n        int bitsPerChannel = -1;\n        switch (depth)\n        {\n            case CV_8U:\n            {\n                bitsPerChannel = 8;\n                break;\n            }\n            case CV_16U:\n            {\n                bitsPerChannel = 16;\n                break;\n            }\n            case CV_32F:\n            {\n                bitsPerChannel = 32;\n                page_compression = COMPRESSION_NONE;\n                break;\n            }\n            case CV_64F:\n            {\n                bitsPerChannel = 64;\n                page_compression = COMPRESSION_NONE;\n                break;\n            }\n            default:\n            {\n                return false;\n            }\n        }\n\n        const int bitsPerByte = 8;\n        size_t fileStep = (width * channels * bitsPerChannel) / bitsPerByte;\n        CV_Assert(fileStep > 0);\n\n        int rowsPerStrip = (int)((1 << 13) / fileStep);\n        readParam(params, TIFFTAG_ROWSPERSTRIP, rowsPerStrip);\n        rowsPerStrip = std::max(1, std::min(height, rowsPerStrip));\n\n        int colorspace = channels > 1 ? PHOTOMETRIC_RGB : PHOTOMETRIC_MINISBLACK;\n\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, bitsPerChannel));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_COMPRESSION, page_compression));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, colorspace));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, channels));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, rowsPerStrip));\n\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, depth >= CV_32F ? SAMPLEFORMAT_IEEEFP : SAMPLEFORMAT_UINT));\n\n        if (page_compression != COMPRESSION_NONE)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PREDICTOR, predictor));\n        }\n\n        if (resUnit >= RESUNIT_NONE && resUnit <= RESUNIT_CENTIMETER)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_RESOLUTIONUNIT, resUnit));\n        }\n        if (dpiX >= 0)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_XRESOLUTION, (float)dpiX));\n        }\n        if (dpiY >= 0)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_YRESOLUTION, (float)dpiY));\n        }\n\n        // row buffer, because TIFFWriteScanline modifies the original data!\n        size_t scanlineSize = TIFFScanlineSize(tif);\n        AutoBuffer<uchar> _buffer(scanlineSize + 32);\n        uchar* buffer = _buffer.data(); CV_DbgAssert(buffer);\n        Mat m_buffer(Size(width, 1), CV_MAKETYPE(depth, channels), buffer, (size_t)scanlineSize);\n\n        for (int y = 0; y < height; ++y)\n        {\n            switch (channels)\n            {\n                case 1:\n                {\n                    memcpy(buffer, img.ptr(y), scanlineSize);\n                    break;\n                }\n\n                case 3:\n                {\n                    cvtColor(img(Rect(0, y, width, 1)), (const Mat&)m_buffer, COLOR_BGR2RGB);\n                    break;\n                }\n\n                case 4:\n                {\n                    cvtColor(img(Rect(0, y, width, 1)), (const Mat&)m_buffer, COLOR_BGRA2RGBA);\n                    break;\n                }\n\n                default:\n                {\n                    CV_Assert(0);\n                }\n            }\n\n            CV_TIFF_CHECK_CALL(TIFFWriteScanline(tif, buffer, y, 0) == 1);\n        }\n\n        CV_TIFF_CHECK_CALL(TIFFWriteDirectory(tif));\n    }\n\n    return true;\n}\n\nbool TiffEncoder::write_32FC3_SGILOG(const Mat& _img, void* tif_)\n{\n    TIFF* tif = (TIFF*)tif_;\n    CV_Assert(tif);\n\n    Mat img;\n    cvtColor(_img, img, COLOR_BGR2XYZ);\n\n    //done by caller: CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, img.cols));\n    //done by caller: CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_IMAGELENGTH, img.rows));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 3));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 32));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_SGILOG));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_LOGLUV));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_FLOAT));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, 1));\n    const int strip_size = 3 * img.cols;\n    for (int i = 0; i < img.rows; i++)\n    {\n        CV_TIFF_CHECK_CALL(TIFFWriteEncodedStrip(tif, i, (tdata_t)img.ptr<float>(i), strip_size * sizeof(float)) != (tsize_t)-1);\n    }\n    CV_TIFF_CHECK_CALL(TIFFWriteDirectory(tif));\n    return true;\n}\n\nbool TiffEncoder::writemulti(const std::vector<Mat>& img_vec, const std::vector<int>& params)\n{\n    return writeLibTiff(img_vec, params);\n}\n\nbool  TiffEncoder::write( const Mat& img, const std::vector<int>& params)\n{\n    int type = img.type();\n    int depth = CV_MAT_DEPTH(type);\n\n    CV_CheckType(type, depth == CV_8U || depth == CV_16U || depth == CV_32F || depth == CV_64F, \"\");\n\n    std::vector<Mat> img_vec;\n    img_vec.push_back(img);\n    return writeLibTiff(img_vec, params);\n}\n\n} // namespace\n\n#endif\n",
                "name": "grfmt_tiff.cpp",
                "path": "//OpenCV/opencv/modules/imgcodecs/src/grfmt_tiff.cpp",
                "url": "/github.com/lxiao217/study428/-/blob/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%BA%90%E7%A0%81/OpenCV/opencv/modules/imgcodecs/src/grfmt_tiff.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 530,
                    "offsetAndLengths": [
                        [
                            51,
                            16
                        ]
                    ],
                    "preview": "                                CV_TIFF_CHECK_CALL(TIFFReadRGBATile(tif, x, y, (uint32*)buffer));"
                }
            ],
            "repository": {
                "name": "github.com/lxiao217/study428",
                "url": "/github.com/lxiao217/study428"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "7796af500ee92001ac2a9888363ff64d7a3bee75"
                },
                "content": "/*M///////////////////////////////////////////////////////////////////////////////////////\n//\n//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.\n//\n//  By downloading, copying, installing or using the software you agree to this license.\n//  If you do not agree to this license, do not download, install,\n//  copy or use the software.\n//\n//\n//                           License Agreement\n//                For Open Source Computer Vision Library\n//\n// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.\n// Copyright (C) 2009, Willow Garage Inc., all rights reserved.\n// Third party copyrights are property of their respective owners.\n//\n// Redistribution and use in source and binary forms, with or without modification,\n// are permitted provided that the following conditions are met:\n//\n//   * Redistribution's of source code must retain the above copyright notice,\n//     this list of conditions and the following disclaimer.\n//\n//   * Redistribution's in binary form must reproduce the above copyright notice,\n//     this list of conditions and the following disclaimer in the documentation\n//     and/or other materials provided with the distribution.\n//\n//   * The name of the copyright holders may not be used to endorse or promote products\n//     derived from this software without specific prior written permission.\n//\n// This software is provided by the copyright holders and contributors \"as is\" and\n// any express or implied warranties, including, but not limited to, the implied\n// warranties of merchantability and fitness for a particular purpose are disclaimed.\n// In no event shall the Intel Corporation or contributors be liable for any direct,\n// indirect, incidental, special, exemplary, or consequential damages\n// (including, but not limited to, procurement of substitute goods or services;\n// loss of use, data, or profits; or business interruption) however caused\n// and on any theory of liability, whether in contract, strict liability,\n// or tort (including negligence or otherwise) arising in any way out of\n// the use of this software, even if advised of the possibility of such damage.\n//\n//M*/\n\n/****************************************************************************************\\\n    A part of the file implements TIFF reader on base of libtiff library\n    (see otherlibs/_graphics/readme.txt for copyright notice)\n\\****************************************************************************************/\n\n#include \"precomp.hpp\"\n\n#ifdef HAVE_TIFF\n#include <opencv2/core/utils/logger.hpp>\n\n#include \"grfmt_tiff.hpp\"\n#include <limits>\n\n// TODO FIXIT Conflict declarations for common types like int64/uint64\nnamespace tiff_dummy_namespace {\n#include \"tiff.h\"\n#include \"tiffio.h\"\n}\nusing namespace tiff_dummy_namespace;\n\nnamespace cv\n{\n\n#define CV_TIFF_CHECK_CALL(call) \\\n    if (0 == (call)) { \\\n        CV_LOG_WARNING(NULL, \"OpenCV TIFF(line \" << __LINE__ << \"): failed \" #call); \\\n        CV_Error(Error::StsError, \"OpenCV TIFF: failed \" #call); \\\n    }\n\n#define CV_TIFF_CHECK_CALL_INFO(call) \\\n    if (0 == (call)) { \\\n        CV_LOG_INFO(NULL, \"OpenCV TIFF(line \" << __LINE__ << \"): failed optional call: \" #call \", ignoring\"); \\\n    }\n\n#define CV_TIFF_CHECK_CALL_DEBUG(call) \\\n    if (0 == (call)) { \\\n        CV_LOG_DEBUG(NULL, \"OpenCV TIFF(line \" << __LINE__ << \"): failed optional call: \" #call \", ignoring\"); \\\n    }\n\nstatic void cv_tiffCloseHandle(void* handle)\n{\n    TIFFClose((TIFF*)handle);\n}\n\nstatic void cv_tiffErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    if (cv::utils::logging::getLogLevel() < cv::utils::logging::LOG_LEVEL_DEBUG)\n        return;\n    // TODO cv::vformat() with va_list parameter\n    fprintf(stderr, \"OpenCV TIFF: \");\n    if (module != NULL)\n        fprintf(stderr, \"%s: \", module);\n    fprintf(stderr, \"Warning, \");\n    vfprintf(stderr, fmt, ap);\n    fprintf(stderr, \".\\n\");\n}\n\nstatic bool cv_tiffSetErrorHandler_()\n{\n    TIFFSetErrorHandler(cv_tiffErrorHandler);\n    TIFFSetWarningHandler(cv_tiffErrorHandler);\n    return true;\n}\n\nstatic bool cv_tiffSetErrorHandler()\n{\n    static bool v = cv_tiffSetErrorHandler_();\n    return v;\n}\n\nstatic const char fmtSignTiffII[] = \"II\\x2a\\x00\";\nstatic const char fmtSignTiffMM[] = \"MM\\x00\\x2a\";\n\nTiffDecoder::TiffDecoder()\n{\n    m_hdr = false;\n    m_buf_supported = true;\n    m_buf_pos = 0;\n}\n\n\nvoid TiffDecoder::close()\n{\n    m_tif.release();\n}\n\nTiffDecoder::~TiffDecoder()\n{\n    close();\n}\n\nsize_t TiffDecoder::signatureLength() const\n{\n    return 4;\n}\n\nbool TiffDecoder::checkSignature( const String& signature ) const\n{\n    return signature.size() >= 4 &&\n        (memcmp(signature.c_str(), fmtSignTiffII, 4) == 0 ||\n        memcmp(signature.c_str(), fmtSignTiffMM, 4) == 0);\n}\n\nint TiffDecoder::normalizeChannelsNumber(int channels) const\n{\n    CV_Assert(channels <= 4);\n    return channels > 4 ? 4 : channels;\n}\n\nImageDecoder TiffDecoder::newDecoder() const\n{\n    cv_tiffSetErrorHandler();\n    return makePtr<TiffDecoder>();\n}\n\nclass TiffDecoderBufHelper\n{\n    Mat& m_buf;\n    size_t& m_buf_pos;\npublic:\n    TiffDecoderBufHelper(Mat& buf, size_t& buf_pos) :\n        m_buf(buf), m_buf_pos(buf_pos)\n    {}\n    static tmsize_t read( thandle_t handle, void* buffer, tmsize_t n )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        const Mat& buf = helper->m_buf;\n        const tmsize_t size = buf.cols*buf.rows*buf.elemSize();\n        tmsize_t pos = helper->m_buf_pos;\n        if ( n > (size - pos) )\n        {\n            n = size - pos;\n        }\n        memcpy(buffer, buf.ptr() + pos, n);\n        helper->m_buf_pos += n;\n        return n;\n    }\n\n    static tmsize_t write( thandle_t /*handle*/, void* /*buffer*/, tmsize_t /*n*/ )\n    {\n        // Not used for decoding.\n        return 0;\n    }\n\n    static toff_t seek( thandle_t handle, toff_t offset, int whence )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        const Mat& buf = helper->m_buf;\n        const toff_t size = buf.cols*buf.rows*buf.elemSize();\n        toff_t new_pos = helper->m_buf_pos;\n        switch (whence)\n        {\n            case SEEK_SET:\n                new_pos = offset;\n                break;\n            case SEEK_CUR:\n                new_pos += offset;\n                break;\n            case SEEK_END:\n                new_pos = size + offset;\n                break;\n        }\n        new_pos = std::min(new_pos, size);\n        helper->m_buf_pos = (size_t)new_pos;\n        return new_pos;\n    }\n\n    static int map( thandle_t handle, void** base, toff_t* size )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        Mat& buf = helper->m_buf;\n        *base = buf.ptr();\n        *size = buf.cols*buf.rows*buf.elemSize();\n        return 0;\n    }\n\n    static toff_t size( thandle_t handle )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        const Mat& buf = helper->m_buf;\n        return buf.cols*buf.rows*buf.elemSize();\n    }\n\n    static int close( thandle_t handle )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        delete helper;\n        return 0;\n    }\n};\n\nbool TiffDecoder::readHeader()\n{\n    bool result = false;\n\n    TIFF* tif = static_cast<TIFF*>(m_tif.get());\n    if (!tif)\n    {\n        // TIFFOpen() mode flags are different to fopen().  A 'b' in mode \"rb\" has no effect when reading.\n        // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n        if ( !m_buf.empty() )\n        {\n            m_buf_pos = 0;\n            TiffDecoderBufHelper* buf_helper = new TiffDecoderBufHelper(this->m_buf, this->m_buf_pos);\n            tif = TIFFClientOpen( \"\", \"r\", reinterpret_cast<thandle_t>(buf_helper), &TiffDecoderBufHelper::read,\n                                  &TiffDecoderBufHelper::write, &TiffDecoderBufHelper::seek,\n                                  &TiffDecoderBufHelper::close, &TiffDecoderBufHelper::size,\n                                  &TiffDecoderBufHelper::map, /*unmap=*/0 );\n            if (!tif)\n                delete buf_helper;\n        }\n        else\n        {\n            tif = TIFFOpen(m_filename.c_str(), \"r\");\n        }\n        if (tif)\n            m_tif.reset(tif, cv_tiffCloseHandle);\n        else\n            m_tif.release();\n    }\n\n    if (tif)\n    {\n        uint32 wdth = 0, hght = 0;\n        uint16 photometric = 0;\n\n        CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &wdth));\n        CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &hght));\n        CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric));\n\n        {\n            bool isGrayScale = photometric == PHOTOMETRIC_MINISWHITE || photometric == PHOTOMETRIC_MINISBLACK;\n            uint16 bpp = 8, ncn = isGrayScale ? 1 : 3;\n            if (0 == TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bpp))\n            {\n                // TIFF bi-level images don't require TIFFTAG_BITSPERSAMPLE tag\n                bpp = 1;\n            }\n            CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &ncn));\n\n            m_width = wdth;\n            m_height = hght;\n            if (ncn == 3 && photometric == PHOTOMETRIC_LOGLUV)\n            {\n                m_type = CV_32FC3;\n                m_hdr = true;\n                return true;\n            }\n            m_hdr = false;\n\n            if( bpp > 8 &&\n               ((photometric > 2) ||\n                (ncn != 1 && ncn != 3 && ncn != 4)))\n                bpp = 8;\n\n            int wanted_channels = normalizeChannelsNumber(ncn);\n            switch(bpp)\n            {\n                case 1:\n                    m_type = CV_MAKETYPE(CV_8U, !isGrayScale ? wanted_channels : 1);\n                    result = true;\n                    break;\n                case 8:\n                    //Palette color, the value of the component is used as an index into the red,\n                    //green and blue curves in the ColorMap field to retrieve an RGB triplet that defines the color.\n                    if(photometric == PHOTOMETRIC_PALETTE)\n                        m_type = CV_MAKETYPE(CV_8U, 3);\n                    else\n                        m_type = CV_MAKETYPE(CV_8U, !isGrayScale ? wanted_channels : 1);\n                    result = true;\n                    break;\n                case 16:\n                    m_type = CV_MAKETYPE(CV_16U, !isGrayScale ? wanted_channels : 1);\n                    result = true;\n                    break;\n                case 32:\n                    m_type = CV_MAKETYPE(CV_32F, wanted_channels);\n                    result = true;\n                    break;\n                case 64:\n                    m_type = CV_MAKETYPE(CV_64F, wanted_channels);\n                    result = true;\n                    break;\n            default:\n                CV_Error(cv::Error::StsError, \"Invalid bitsperpixel value read from TIFF header! Must be 1, 8, 16, 32 or 64.\");\n            }\n        }\n    }\n\n    if( !result )\n        close();\n\n    return result;\n}\n\nbool TiffDecoder::nextPage()\n{\n    // Prepare the next page, if any.\n    return !m_tif.empty() &&\n           TIFFReadDirectory(static_cast<TIFF*>(m_tif.get())) &&\n           readHeader();\n}\n\nstatic void fixOrientationPartial(Mat &img, uint16 orientation)\n{\n    switch(orientation) {\n        case ORIENTATION_RIGHTTOP:\n        case ORIENTATION_LEFTBOT:\n            flip(img, img, -1);\n            /* fall through */\n\n        case ORIENTATION_LEFTTOP:\n        case ORIENTATION_RIGHTBOT:\n            transpose(img, img);\n            break;\n    }\n}\n\nstatic void fixOrientationFull(Mat &img, int orientation)\n{\n    switch(orientation) {\n        case ORIENTATION_TOPRIGHT:\n            flip(img, img, 1);\n            break;\n\n        case ORIENTATION_BOTRIGHT:\n            flip(img, img, -1);\n            break;\n\n        case ORIENTATION_BOTLEFT:\n            flip(img, img, 0);\n            break;\n\n        case ORIENTATION_LEFTTOP:\n            transpose(img, img);\n            break;\n\n        case ORIENTATION_RIGHTTOP:\n            transpose(img, img);\n            flip(img, img, 1);\n            break;\n\n        case ORIENTATION_RIGHTBOT:\n            transpose(img, img);\n            flip(img, img, -1);\n            break;\n\n        case ORIENTATION_LEFTBOT:\n            transpose(img, img);\n            flip(img, img, 0);\n            break;\n    }\n}\n\n/**\n * Fix orientation defined in tag 274.\n * For 8 bit some corrections are done by TIFFReadRGBAStrip/Tile already.\n * Not so for 16/32/64 bit.\n */\nstatic void fixOrientation(Mat &img, uint16 orientation, int dst_bpp)\n{\n    switch(dst_bpp) {\n        case 8:\n            fixOrientationPartial(img, orientation);\n            break;\n\n        case 16:\n        case 32:\n        case 64:\n            fixOrientationFull(img, orientation);\n            break;\n    }\n}\n\nbool  TiffDecoder::readData( Mat& img )\n{\n    int type = img.type();\n    int depth = CV_MAT_DEPTH(type);\n\n    CV_Assert(!m_tif.empty());\n    TIFF* tif = (TIFF*)m_tif.get();\n\n    uint16 photometric = (uint16)-1;\n    CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric));\n\n    if (m_hdr && depth >= CV_32F)\n    {\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_FLOAT));\n    }\n\n    bool color = img.channels() > 1;\n\n    CV_CheckType(type, depth == CV_8U || depth == CV_16U || depth == CV_32F || depth == CV_64F, \"\");\n\n    if (m_width && m_height)\n    {\n        int is_tiled = TIFFIsTiled(tif) != 0;\n        bool isGrayScale = photometric == PHOTOMETRIC_MINISWHITE || photometric == PHOTOMETRIC_MINISBLACK;\n        uint16 bpp = 8, ncn = isGrayScale ? 1 : 3;\n        if (0 == TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bpp))\n        {\n            // TIFF bi-level images don't require TIFFTAG_BITSPERSAMPLE tag\n            bpp = 1;\n        }\n        CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &ncn));\n        uint16 img_orientation = ORIENTATION_TOPLEFT;\n        CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_ORIENTATION, &img_orientation));\n        const int bitsPerByte = 8;\n        int dst_bpp = (int)(img.elemSize1() * bitsPerByte);\n        bool vert_flip = dst_bpp == 8 &&\n                        (img_orientation == ORIENTATION_BOTRIGHT || img_orientation == ORIENTATION_RIGHTBOT ||\n                         img_orientation == ORIENTATION_BOTLEFT || img_orientation == ORIENTATION_LEFTBOT);\n        int wanted_channels = normalizeChannelsNumber(img.channels());\n\n        if (dst_bpp == 8)\n        {\n            char errmsg[1024];\n            if (!TIFFRGBAImageOK(tif, errmsg))\n            {\n                CV_LOG_WARNING(NULL, \"OpenCV TIFF: TIFFRGBAImageOK: \" << errmsg);\n                close();\n                return false;\n            }\n        }\n\n        uint32 tile_width0 = m_width, tile_height0 = 0;\n\n        if (is_tiled)\n        {\n            CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_TILEWIDTH, &tile_width0));\n            CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_TILELENGTH, &tile_height0));\n        }\n        else\n        {\n            // optional\n            CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &tile_height0));\n        }\n\n        {\n            if (tile_width0 == 0)\n                tile_width0 = m_width;\n\n            if (tile_height0 == 0 ||\n                    (!is_tiled && tile_height0 == std::numeric_limits<uint32>::max()) )\n                tile_height0 = m_height;\n\n            const int TILE_MAX_WIDTH = (1 << 24);\n            const int TILE_MAX_HEIGHT = (1 << 24);\n            CV_Assert((int)tile_width0 > 0 && (int)tile_width0 <= TILE_MAX_WIDTH);\n            CV_Assert((int)tile_height0 > 0 && (int)tile_height0 <= TILE_MAX_HEIGHT);\n            const uint64_t MAX_TILE_SIZE = (CV_BIG_UINT(1) << 30);\n            CV_CheckLE((int)ncn, 4, \"\");\n            CV_CheckLE((int)bpp, 64, \"\");\n            CV_Assert(((uint64_t)tile_width0 * tile_height0 * ncn * std::max(1, (int)(bpp / bitsPerByte)) < MAX_TILE_SIZE) && \"TIFF tile size is too large: >= 1Gb\");\n\n            if (dst_bpp == 8)\n            {\n                // we will use TIFFReadRGBA* functions, so allocate temporary buffer for 32bit RGBA\n                bpp = 8;\n                ncn = 4;\n            }\n            else if (dst_bpp == 32 || dst_bpp == 64)\n            {\n                CV_Assert(ncn == img.channels());\n                CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP));\n            }\n            const size_t buffer_size = (bpp / bitsPerByte) * ncn * tile_height0 * tile_width0;\n            AutoBuffer<uchar> _buffer(buffer_size);\n            uchar* buffer = _buffer.data();\n            ushort* buffer16 = (ushort*)buffer;\n            int tileidx = 0;\n\n            for (int y = 0; y < m_height; y += (int)tile_height0)\n            {\n                int tile_height = std::min((int)tile_height0, m_height - y);\n\n                const int img_y = vert_flip ? m_height - y - tile_height : y;\n\n                for(int x = 0; x < m_width; x += (int)tile_width0, tileidx++)\n                {\n                    int tile_width = std::min((int)tile_width0, m_width - x);\n\n                    switch (dst_bpp)\n                    {\n                        case 8:\n                        {\n                            uchar* bstart = buffer;\n                            if (!is_tiled)\n                            {\n                                CV_TIFF_CHECK_CALL(TIFFReadRGBAStrip(tif, y, (uint32*)buffer));\n                            }\n                            else\n                            {\n                                CV_TIFF_CHECK_CALL(TIFFReadRGBATile(tif, x, y, (uint32*)buffer));\n                                // Tiles fill the buffer from the bottom up\n                                bstart += (tile_height0 - tile_height) * tile_width0 * 4;\n                            }\n\n                            for (int i = 0; i < tile_height; i++)\n                            {\n                                if (color)\n                                {\n                                    if (wanted_channels == 4)\n                                    {\n                                        icvCvt_BGRA2RGBA_8u_C4R(bstart + i*tile_width0*4, 0,\n                                                img.ptr(img_y + tile_height - i - 1, x), 0,\n                                                Size(tile_width, 1) );\n                                    }\n                                    else\n                                    {\n                                        CV_CheckEQ(wanted_channels, 3, \"TIFF-8bpp: BGR/BGRA images are supported only\");\n                                        icvCvt_BGRA2BGR_8u_C4C3R(bstart + i*tile_width0*4, 0,\n                                                img.ptr(img_y + tile_height - i - 1, x), 0,\n                                                Size(tile_width, 1), 2);\n                                    }\n                                }\n                                else\n                                {\n                                    CV_CheckEQ(wanted_channels, 1, \"\");\n                                    icvCvt_BGRA2Gray_8u_C4C1R( bstart + i*tile_width0*4, 0,\n                                            img.ptr(img_y + tile_height - i - 1, x), 0,\n                                            Size(tile_width, 1), 2);\n                                }\n                            }\n                            break;\n                        }\n\n                        case 16:\n                        {\n                            if (!is_tiled)\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedStrip(tif, tileidx, (uint32*)buffer, buffer_size) >= 0);\n                            }\n                            else\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedTile(tif, tileidx, (uint32*)buffer, buffer_size) >= 0);\n                            }\n\n                            for (int i = 0; i < tile_height; i++)\n                            {\n                                if (color)\n                                {\n                                    if (ncn == 1)\n                                    {\n                                        CV_CheckEQ(wanted_channels, 3, \"\");\n                                        icvCvt_Gray2BGR_16u_C1C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1));\n                                    }\n                                    else if (ncn == 3)\n                                    {\n                                        CV_CheckEQ(wanted_channels, 3, \"\");\n                                        icvCvt_RGB2BGR_16u_C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1));\n                                    }\n                                    else if (ncn == 4)\n                                    {\n                                        if (wanted_channels == 4)\n                                        {\n                                            icvCvt_BGRA2RGBA_16u_C4R(buffer16 + i*tile_width0*ncn, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1));\n                                        }\n                                        else\n                                        {\n                                            CV_CheckEQ(wanted_channels, 3, \"TIFF-16bpp: BGR/BGRA images are supported only\");\n                                            icvCvt_BGRA2BGR_16u_C4C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1), 2);\n                                        }\n                                    }\n                                    else\n                                    {\n                                        CV_Error(Error::StsError, \"Not supported\");\n                                    }\n                                }\n                                else\n                                {\n                                    CV_CheckEQ(wanted_channels, 1, \"\");\n                                    if( ncn == 1 )\n                                    {\n                                        memcpy(img.ptr<ushort>(img_y + i, x),\n                                               buffer16 + i*tile_width0*ncn,\n                                               tile_width*sizeof(ushort));\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2Gray_16u_CnC1R(buffer16 + i*tile_width0*ncn, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1), ncn, 2);\n                                    }\n                                }\n                            }\n                            break;\n                        }\n\n                        case 32:\n                        case 64:\n                        {\n                            if( !is_tiled )\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedStrip(tif, tileidx, buffer, buffer_size) >= 0);\n                            }\n                            else\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedTile(tif, tileidx, buffer, buffer_size) >= 0);\n                            }\n\n                            Mat m_tile(Size(tile_width0, tile_height0), CV_MAKETYPE((dst_bpp == 32) ? CV_32F : CV_64F, ncn), buffer);\n                            Rect roi_tile(0, 0, tile_width, tile_height);\n                            Rect roi_img(x, img_y, tile_width, tile_height);\n                            if (!m_hdr && ncn == 3)\n                                cvtColor(m_tile(roi_tile), img(roi_img), COLOR_RGB2BGR);\n                            else if (!m_hdr && ncn == 4)\n                                cvtColor(m_tile(roi_tile), img(roi_img), COLOR_RGBA2BGRA);\n                            else\n                                m_tile(roi_tile).copyTo(img(roi_img));\n                            break;\n                        }\n                        default:\n                        {\n                            CV_Assert(0 && \"OpenCV TIFF: unsupported depth\");\n                        }\n                    }  // switch (dst_bpp)\n                }  // for x\n            }  // for y\n        }\n        fixOrientation(img, img_orientation, dst_bpp);\n    }\n\n    if (m_hdr && depth >= CV_32F)\n    {\n        CV_Assert(photometric == PHOTOMETRIC_LOGLUV);\n        cvtColor(img, img, COLOR_XYZ2BGR);\n    }\n    return true;\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////\n\nTiffEncoder::TiffEncoder()\n{\n    m_description = \"TIFF Files (*.tiff;*.tif)\";\n    m_buf_supported = true;\n}\n\nTiffEncoder::~TiffEncoder()\n{\n}\n\nImageEncoder TiffEncoder::newEncoder() const\n{\n    return makePtr<TiffEncoder>();\n}\n\nbool TiffEncoder::isFormatSupported( int depth ) const\n{\n    return depth == CV_8U || depth == CV_16U || depth == CV_32F || depth == CV_64F;\n}\n\nvoid  TiffEncoder::writeTag( WLByteStream& strm, TiffTag tag,\n                             TiffFieldType fieldType,\n                             int count, int value )\n{\n    strm.putWord( tag );\n    strm.putWord( fieldType );\n    strm.putDWord( count );\n    strm.putDWord( value );\n}\n\nclass TiffEncoderBufHelper\n{\npublic:\n\n    TiffEncoderBufHelper(std::vector<uchar> *buf)\n            : m_buf(buf), m_buf_pos(0)\n    {}\n\n    TIFF* open ()\n    {\n        // do NOT put \"wb\" as the mode, because the b means \"big endian\" mode, not \"binary\" mode.\n        // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n        return TIFFClientOpen( \"\", \"w\", reinterpret_cast<thandle_t>(this), &TiffEncoderBufHelper::read,\n                               &TiffEncoderBufHelper::write, &TiffEncoderBufHelper::seek,\n                               &TiffEncoderBufHelper::close, &TiffEncoderBufHelper::size,\n                               /*map=*/0, /*unmap=*/0 );\n    }\n\n    static tmsize_t read( thandle_t /*handle*/, void* /*buffer*/, tmsize_t /*n*/ )\n    {\n        // Not used for encoding.\n        return 0;\n    }\n\n    static tmsize_t write( thandle_t handle, void* buffer, tmsize_t n )\n    {\n        TiffEncoderBufHelper *helper = reinterpret_cast<TiffEncoderBufHelper*>(handle);\n        size_t begin = (size_t)helper->m_buf_pos;\n        size_t end = begin + n;\n        if ( helper->m_buf->size() < end )\n        {\n            helper->m_buf->resize(end);\n        }\n        memcpy(&(*helper->m_buf)[begin], buffer, n);\n        helper->m_buf_pos = end;\n        return n;\n    }\n\n    static toff_t seek( thandle_t handle, toff_t offset, int whence )\n    {\n        TiffEncoderBufHelper *helper = reinterpret_cast<TiffEncoderBufHelper*>(handle);\n        const toff_t size = helper->m_buf->size();\n        toff_t new_pos = helper->m_buf_pos;\n        switch (whence)\n        {\n            case SEEK_SET:\n                new_pos = offset;\n                break;\n            case SEEK_CUR:\n                new_pos += offset;\n                break;\n            case SEEK_END:\n                new_pos = size + offset;\n                break;\n        }\n        helper->m_buf_pos = new_pos;\n        return new_pos;\n    }\n\n    static toff_t size( thandle_t handle )\n    {\n        TiffEncoderBufHelper *helper = reinterpret_cast<TiffEncoderBufHelper*>(handle);\n        return helper->m_buf->size();\n    }\n\n    static int close( thandle_t /*handle*/ )\n    {\n        // Do nothing.\n        return 0;\n    }\n\nprivate:\n\n    std::vector<uchar>* m_buf;\n    toff_t m_buf_pos;\n};\n\nstatic bool readParam(const std::vector<int>& params, int key, int& value)\n{\n    for (size_t i = 0; i + 1 < params.size(); i += 2)\n    {\n        if (params[i] == key)\n        {\n            value = params[i + 1];\n            return true;\n        }\n    }\n    return false;\n}\n\nbool TiffEncoder::writeLibTiff( const std::vector<Mat>& img_vec, const std::vector<int>& params)\n{\n    // do NOT put \"wb\" as the mode, because the b means \"big endian\" mode, not \"binary\" mode.\n    // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n    TIFF* tif = NULL;\n\n    TiffEncoderBufHelper buf_helper(m_buf);\n    if ( m_buf )\n    {\n        tif = buf_helper.open();\n    }\n    else\n    {\n        tif = TIFFOpen(m_filename.c_str(), \"w\");\n    }\n    if (!tif)\n    {\n        return false;\n    }\n    cv::Ptr<void> tif_cleanup(tif, cv_tiffCloseHandle);\n\n    //Settings that matter to all images\n    int compression = COMPRESSION_LZW;\n    int predictor = PREDICTOR_HORIZONTAL;\n    int resUnit = -1, dpiX = -1, dpiY = -1;\n\n    readParam(params, IMWRITE_TIFF_COMPRESSION, compression);\n    readParam(params, TIFFTAG_PREDICTOR, predictor);\n    readParam(params, IMWRITE_TIFF_RESUNIT, resUnit);\n    readParam(params, IMWRITE_TIFF_XDPI, dpiX);\n    readParam(params, IMWRITE_TIFF_YDPI, dpiY);\n\n    //Iterate through each image in the vector and write them out as Tiff directories\n    for (size_t page = 0; page < img_vec.size(); page++)\n    {\n        const Mat& img = img_vec[page];\n        CV_Assert(!img.empty());\n        int channels = img.channels();\n        int width = img.cols, height = img.rows;\n        int type = img.type();\n        int depth = CV_MAT_DEPTH(type);\n        CV_CheckType(type, depth == CV_8U || depth == CV_16U || depth == CV_32F || depth == CV_64F, \"\");\n        CV_CheckType(type, channels >= 1 && channels <= 4, \"\");\n\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, width));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_IMAGELENGTH, height));\n\n        if (img_vec.size() > 1)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE));\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PAGENUMBER, page, img_vec.size()));\n        }\n\n        int compression_param = -1;  // OPENCV_FUTURE\n        if (type == CV_32FC3 && (!readParam(params, IMWRITE_TIFF_COMPRESSION, compression_param) || compression_param == COMPRESSION_SGILOG))\n        {\n            if (!write_32FC3_SGILOG(img, tif))\n                return false;\n            continue;\n        }\n\n        int page_compression = compression;\n\n        int bitsPerChannel = -1;\n        switch (depth)\n        {\n            case CV_8U:\n            {\n                bitsPerChannel = 8;\n                break;\n            }\n            case CV_16U:\n            {\n                bitsPerChannel = 16;\n                break;\n            }\n            case CV_32F:\n            {\n                bitsPerChannel = 32;\n                page_compression = COMPRESSION_NONE;\n                break;\n            }\n            case CV_64F:\n            {\n                bitsPerChannel = 64;\n                page_compression = COMPRESSION_NONE;\n                break;\n            }\n            default:\n            {\n                return false;\n            }\n        }\n\n        const int bitsPerByte = 8;\n        size_t fileStep = (width * channels * bitsPerChannel) / bitsPerByte;\n        CV_Assert(fileStep > 0);\n\n        int rowsPerStrip = (int)((1 << 13) / fileStep);\n        readParam(params, TIFFTAG_ROWSPERSTRIP, rowsPerStrip);\n        rowsPerStrip = std::max(1, std::min(height, rowsPerStrip));\n\n        int colorspace = channels > 1 ? PHOTOMETRIC_RGB : PHOTOMETRIC_MINISBLACK;\n\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, bitsPerChannel));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_COMPRESSION, page_compression));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, colorspace));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, channels));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, rowsPerStrip));\n\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, depth >= CV_32F ? SAMPLEFORMAT_IEEEFP : SAMPLEFORMAT_UINT));\n\n        if (page_compression != COMPRESSION_NONE)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PREDICTOR, predictor));\n        }\n\n        if (resUnit >= RESUNIT_NONE && resUnit <= RESUNIT_CENTIMETER)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_RESOLUTIONUNIT, resUnit));\n        }\n        if (dpiX >= 0)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_XRESOLUTION, (float)dpiX));\n        }\n        if (dpiY >= 0)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_YRESOLUTION, (float)dpiY));\n        }\n\n        // row buffer, because TIFFWriteScanline modifies the original data!\n        size_t scanlineSize = TIFFScanlineSize(tif);\n        AutoBuffer<uchar> _buffer(scanlineSize + 32);\n        uchar* buffer = _buffer.data(); CV_DbgAssert(buffer);\n        Mat m_buffer(Size(width, 1), CV_MAKETYPE(depth, channels), buffer, (size_t)scanlineSize);\n\n        for (int y = 0; y < height; ++y)\n        {\n            switch (channels)\n            {\n                case 1:\n                {\n                    memcpy(buffer, img.ptr(y), scanlineSize);\n                    break;\n                }\n\n                case 3:\n                {\n                    cvtColor(img(Rect(0, y, width, 1)), (const Mat&)m_buffer, COLOR_BGR2RGB);\n                    break;\n                }\n\n                case 4:\n                {\n                    cvtColor(img(Rect(0, y, width, 1)), (const Mat&)m_buffer, COLOR_BGRA2RGBA);\n                    break;\n                }\n\n                default:\n                {\n                    CV_Assert(0);\n                }\n            }\n\n            CV_TIFF_CHECK_CALL(TIFFWriteScanline(tif, buffer, y, 0) == 1);\n        }\n\n        CV_TIFF_CHECK_CALL(TIFFWriteDirectory(tif));\n    }\n\n    return true;\n}\n\nbool TiffEncoder::write_32FC3_SGILOG(const Mat& _img, void* tif_)\n{\n    TIFF* tif = (TIFF*)tif_;\n    CV_Assert(tif);\n\n    Mat img;\n    cvtColor(_img, img, COLOR_BGR2XYZ);\n\n    //done by caller: CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, img.cols));\n    //done by caller: CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_IMAGELENGTH, img.rows));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 3));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 32));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_SGILOG));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_LOGLUV));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_FLOAT));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, 1));\n    const int strip_size = 3 * img.cols;\n    for (int i = 0; i < img.rows; i++)\n    {\n        CV_TIFF_CHECK_CALL(TIFFWriteEncodedStrip(tif, i, (tdata_t)img.ptr<float>(i), strip_size * sizeof(float)) != (tsize_t)-1);\n    }\n    CV_TIFF_CHECK_CALL(TIFFWriteDirectory(tif));\n    return true;\n}\n\nbool TiffEncoder::writemulti(const std::vector<Mat>& img_vec, const std::vector<int>& params)\n{\n    return writeLibTiff(img_vec, params);\n}\n\nbool  TiffEncoder::write( const Mat& img, const std::vector<int>& params)\n{\n    int type = img.type();\n    int depth = CV_MAT_DEPTH(type);\n\n    CV_CheckType(type, depth == CV_8U || depth == CV_16U || depth == CV_32F || depth == CV_64F, \"\");\n\n    std::vector<Mat> img_vec;\n    img_vec.push_back(img);\n    return writeLibTiff(img_vec, params);\n}\n\n} // namespace\n\n#endif\n",
                "name": "grfmt_tiff.cpp",
                "path": "src/libs/opencv/modules/imgcodecs/src/grfmt_tiff.cpp",
                "url": "/github.com/alanross/AlvaAR/-/blob/src/libs/opencv/modules/imgcodecs/src/grfmt_tiff.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 535,
                    "offsetAndLengths": [
                        [
                            51,
                            16
                        ]
                    ],
                    "preview": "                                CV_TIFF_CHECK_CALL(TIFFReadRGBATile(tif, x, y, (uint32*)buffer));"
                }
            ],
            "repository": {
                "name": "github.com/alanross/AlvaAR",
                "url": "/github.com/alanross/AlvaAR"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "f0e41fd1fcb2db185d90dd280ebf73b58e2e66ef"
                },
                "content": "/*M///////////////////////////////////////////////////////////////////////////////////////\n//\n//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.\n//\n//  By downloading, copying, installing or using the software you agree to this license.\n//  If you do not agree to this license, do not download, install,\n//  copy or use the software.\n//\n//\n//                           License Agreement\n//                For Open Source Computer Vision Library\n//\n// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.\n// Copyright (C) 2009, Willow Garage Inc., all rights reserved.\n// Third party copyrights are property of their respective owners.\n//\n// Redistribution and use in source and binary forms, with or without modification,\n// are permitted provided that the following conditions are met:\n//\n//   * Redistribution's of source code must retain the above copyright notice,\n//     this list of conditions and the following disclaimer.\n//\n//   * Redistribution's in binary form must reproduce the above copyright notice,\n//     this list of conditions and the following disclaimer in the documentation\n//     and/or other materials provided with the distribution.\n//\n//   * The name of the copyright holders may not be used to endorse or promote products\n//     derived from this software without specific prior written permission.\n//\n// This software is provided by the copyright holders and contributors \"as is\" and\n// any express or implied warranties, including, but not limited to, the implied\n// warranties of merchantability and fitness for a particular purpose are disclaimed.\n// In no event shall the Intel Corporation or contributors be liable for any direct,\n// indirect, incidental, special, exemplary, or consequential damages\n// (including, but not limited to, procurement of substitute goods or services;\n// loss of use, data, or profits; or business interruption) however caused\n// and on any theory of liability, whether in contract, strict liability,\n// or tort (including negligence or otherwise) arising in any way out of\n// the use of this software, even if advised of the possibility of such damage.\n//\n//M*/\n\n/****************************************************************************************\\\n    A part of the file implements TIFF reader on base of libtiff library\n    (see otherlibs/_graphics/readme.txt for copyright notice)\n\\****************************************************************************************/\n\n#include \"precomp.hpp\"\n\n#ifdef HAVE_TIFF\n#include <opencv2/core/utils/logger.hpp>\n\n#include \"grfmt_tiff.hpp\"\n#include <limits>\n\n// TODO FIXIT Conflict declarations for common types like int64/uint64\nnamespace tiff_dummy_namespace {\n#include \"tiff.h\"\n#include \"tiffio.h\"\n}\nusing namespace tiff_dummy_namespace;\n\nnamespace cv\n{\n\n#define CV_TIFF_CHECK_CALL(call) \\\n    if (0 == (call)) { \\\n        CV_LOG_WARNING(NULL, \"OpenCV TIFF(line \" << __LINE__ << \"): failed \" #call); \\\n        CV_Error(Error::StsError, \"OpenCV TIFF: failed \" #call); \\\n    }\n\n#define CV_TIFF_CHECK_CALL_INFO(call) \\\n    if (0 == (call)) { \\\n        CV_LOG_INFO(NULL, \"OpenCV TIFF(line \" << __LINE__ << \"): failed optional call: \" #call \", ignoring\"); \\\n    }\n\n#define CV_TIFF_CHECK_CALL_DEBUG(call) \\\n    if (0 == (call)) { \\\n        CV_LOG_DEBUG(NULL, \"OpenCV TIFF(line \" << __LINE__ << \"): failed optional call: \" #call \", ignoring\"); \\\n    }\n\nstatic void cv_tiffCloseHandle(void* handle)\n{\n    TIFFClose((TIFF*)handle);\n}\n\nstatic void cv_tiffErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    if (cv::utils::logging::getLogLevel() < cv::utils::logging::LOG_LEVEL_DEBUG)\n        return;\n    // TODO cv::vformat() with va_list parameter\n    fprintf(stderr, \"OpenCV TIFF: \");\n    if (module != NULL)\n        fprintf(stderr, \"%s: \", module);\n    fprintf(stderr, \"Warning, \");\n    vfprintf(stderr, fmt, ap);\n    fprintf(stderr, \".\\n\");\n}\n\nstatic bool cv_tiffSetErrorHandler_()\n{\n    TIFFSetErrorHandler(cv_tiffErrorHandler);\n    TIFFSetWarningHandler(cv_tiffErrorHandler);\n    return true;\n}\n\nstatic bool cv_tiffSetErrorHandler()\n{\n    static bool v = cv_tiffSetErrorHandler_();\n    return v;\n}\n\nstatic const char fmtSignTiffII[] = \"II\\x2a\\x00\";\nstatic const char fmtSignTiffMM[] = \"MM\\x00\\x2a\";\nstatic const char fmtSignBigTiffII[] = \"II\\x2b\\x00\";\nstatic const char fmtSignBigTiffMM[] = \"MM\\x00\\x2b\";\n\nTiffDecoder::TiffDecoder()\n{\n    m_hdr = false;\n    m_buf_supported = true;\n    m_buf_pos = 0;\n}\n\n\nvoid TiffDecoder::close()\n{\n    m_tif.release();\n}\n\nTiffDecoder::~TiffDecoder()\n{\n    close();\n}\n\nsize_t TiffDecoder::signatureLength() const\n{\n    return 4;\n}\n\nbool TiffDecoder::checkSignature( const String& signature ) const\n{\n    return signature.size() >= 4 &&\n        (memcmp(signature.c_str(), fmtSignTiffII, 4) == 0 ||\n        memcmp(signature.c_str(), fmtSignTiffMM, 4) == 0 ||\n        memcmp(signature.c_str(), fmtSignBigTiffII, 4) == 0 ||\n        memcmp(signature.c_str(), fmtSignBigTiffMM, 4) == 0);\n}\n\nint TiffDecoder::normalizeChannelsNumber(int channels) const\n{\n    CV_Check(channels, channels >= 1 && channels <= 4, \"Unsupported number of channels\");\n    return channels;\n}\n\nImageDecoder TiffDecoder::newDecoder() const\n{\n    cv_tiffSetErrorHandler();\n    return makePtr<TiffDecoder>();\n}\n\nclass TiffDecoderBufHelper\n{\n    Mat& m_buf;\n    size_t& m_buf_pos;\npublic:\n    TiffDecoderBufHelper(Mat& buf, size_t& buf_pos) :\n        m_buf(buf), m_buf_pos(buf_pos)\n    {}\n    static tmsize_t read( thandle_t handle, void* buffer, tmsize_t n )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        const Mat& buf = helper->m_buf;\n        const tmsize_t size = buf.cols*buf.rows*buf.elemSize();\n        tmsize_t pos = helper->m_buf_pos;\n        if ( n > (size - pos) )\n        {\n            n = size - pos;\n        }\n        memcpy(buffer, buf.ptr() + pos, n);\n        helper->m_buf_pos += n;\n        return n;\n    }\n\n    static tmsize_t write( thandle_t /*handle*/, void* /*buffer*/, tmsize_t /*n*/ )\n    {\n        // Not used for decoding.\n        return 0;\n    }\n\n    static toff_t seek( thandle_t handle, toff_t offset, int whence )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        const Mat& buf = helper->m_buf;\n        const toff_t size = buf.cols*buf.rows*buf.elemSize();\n        toff_t new_pos = helper->m_buf_pos;\n        switch (whence)\n        {\n            case SEEK_SET:\n                new_pos = offset;\n                break;\n            case SEEK_CUR:\n                new_pos += offset;\n                break;\n            case SEEK_END:\n                new_pos = size + offset;\n                break;\n        }\n        new_pos = std::min(new_pos, size);\n        helper->m_buf_pos = (size_t)new_pos;\n        return new_pos;\n    }\n\n    static int map( thandle_t handle, void** base, toff_t* size )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        Mat& buf = helper->m_buf;\n        *base = buf.ptr();\n        *size = buf.cols*buf.rows*buf.elemSize();\n        return 0;\n    }\n\n    static toff_t size( thandle_t handle )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        const Mat& buf = helper->m_buf;\n        return buf.cols*buf.rows*buf.elemSize();\n    }\n\n    static int close( thandle_t handle )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        delete helper;\n        return 0;\n    }\n};\n\nbool TiffDecoder::readHeader()\n{\n    bool result = false;\n\n    TIFF* tif = static_cast<TIFF*>(m_tif.get());\n    if (!tif)\n    {\n        // TIFFOpen() mode flags are different to fopen().  A 'b' in mode \"rb\" has no effect when reading.\n        // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n        if ( !m_buf.empty() )\n        {\n            m_buf_pos = 0;\n            TiffDecoderBufHelper* buf_helper = new TiffDecoderBufHelper(this->m_buf, this->m_buf_pos);\n            tif = TIFFClientOpen( \"\", \"r\", reinterpret_cast<thandle_t>(buf_helper), &TiffDecoderBufHelper::read,\n                                  &TiffDecoderBufHelper::write, &TiffDecoderBufHelper::seek,\n                                  &TiffDecoderBufHelper::close, &TiffDecoderBufHelper::size,\n                                  &TiffDecoderBufHelper::map, /*unmap=*/0 );\n            if (!tif)\n                delete buf_helper;\n        }\n        else\n        {\n            tif = TIFFOpen(m_filename.c_str(), \"r\");\n        }\n        if (tif)\n            m_tif.reset(tif, cv_tiffCloseHandle);\n        else\n            m_tif.release();\n    }\n\n    if (tif)\n    {\n        uint32 wdth = 0, hght = 0;\n        uint16 photometric = 0;\n\n        CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &wdth));\n        CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &hght));\n        CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric));\n\n        {\n            bool isGrayScale = photometric == PHOTOMETRIC_MINISWHITE || photometric == PHOTOMETRIC_MINISBLACK;\n            uint16 bpp = 8, ncn = isGrayScale ? 1 : 3;\n            if (0 == TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bpp))\n            {\n                // TIFF bi-level images don't require TIFFTAG_BITSPERSAMPLE tag\n                bpp = 1;\n            }\n            CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &ncn));\n\n            m_width = wdth;\n            m_height = hght;\n            if (ncn == 3 && photometric == PHOTOMETRIC_LOGLUV)\n            {\n                m_type = CV_32FC3;\n                m_hdr = true;\n                return true;\n            }\n            m_hdr = false;\n\n            if( bpp > 8 &&\n               ((photometric > 2) ||\n                (ncn != 1 && ncn != 3 && ncn != 4)))\n                bpp = 8;\n\n            uint16 sample_format = SAMPLEFORMAT_UINT;\n            TIFFGetField(tif, TIFFTAG_SAMPLEFORMAT, &sample_format);\n            int wanted_channels = normalizeChannelsNumber(ncn);\n            switch (bpp)\n            {\n            case 1:\n            {\n                CV_Check((int)sample_format, sample_format == SAMPLEFORMAT_UINT || sample_format == SAMPLEFORMAT_INT, \"\");\n                int depth = sample_format == SAMPLEFORMAT_INT ? CV_8S : CV_8U;\n                m_type = CV_MAKETYPE(depth, !isGrayScale ? wanted_channels : 1);\n                result = true;\n                break;\n            }\n            case 8:\n            {\n                //Palette color, the value of the component is used as an index into the red,\n                //green and blue curves in the ColorMap field to retrieve an RGB triplet that defines the color.\n                CV_Check((int)sample_format, sample_format == SAMPLEFORMAT_UINT || sample_format == SAMPLEFORMAT_INT, \"\");\n                int depth = sample_format == SAMPLEFORMAT_INT ? CV_8S : CV_8U;\n                if (photometric == PHOTOMETRIC_PALETTE)\n                    m_type = CV_MAKETYPE(depth, 3);\n                else\n                    m_type = CV_MAKETYPE(depth, !isGrayScale ? wanted_channels : 1);\n                result = true;\n                break;\n            }\n            case 10:\n            case 12:\n            case 14:\n            case 16:\n            {\n                CV_Check((int)sample_format, sample_format == SAMPLEFORMAT_UINT || sample_format == SAMPLEFORMAT_INT, \"\");\n                int depth = sample_format == SAMPLEFORMAT_INT ? CV_16S : CV_16U;\n                m_type = CV_MAKETYPE(depth, !isGrayScale ? wanted_channels : 1);\n                result = true;\n                break;\n            }\n            case 32:\n            {\n                CV_Check((int)sample_format, sample_format == SAMPLEFORMAT_IEEEFP || sample_format == SAMPLEFORMAT_INT, \"\");\n                int depth = sample_format == SAMPLEFORMAT_IEEEFP ? CV_32F : CV_32S;\n                m_type = CV_MAKETYPE(depth, wanted_channels);\n                result = true;\n                break;\n            }\n            case 64:\n                CV_CheckEQ((int)sample_format, SAMPLEFORMAT_IEEEFP, \"\");\n                m_type = CV_MAKETYPE(CV_64F, wanted_channels);\n                result = true;\n                break;\n            default:\n                CV_Error(cv::Error::StsError, \"Invalid bitsperpixel value read from TIFF header! Must be 1, 8, 10, 12, 14, 16, 32 or 64.\");\n            }\n        }\n    }\n\n    if( !result )\n        close();\n\n    return result;\n}\n\nbool TiffDecoder::nextPage()\n{\n    // Prepare the next page, if any.\n    return !m_tif.empty() &&\n           TIFFReadDirectory(static_cast<TIFF*>(m_tif.get())) &&\n           readHeader();\n}\n\nstatic void fixOrientationPartial(Mat &img, uint16 orientation)\n{\n    switch(orientation) {\n        case ORIENTATION_RIGHTTOP:\n        case ORIENTATION_LEFTBOT:\n            flip(img, img, -1);\n            /* fall through */\n\n        case ORIENTATION_LEFTTOP:\n        case ORIENTATION_RIGHTBOT:\n            transpose(img, img);\n            break;\n    }\n}\n\nstatic void fixOrientationFull(Mat &img, int orientation)\n{\n    switch(orientation) {\n        case ORIENTATION_TOPRIGHT:\n            flip(img, img, 1);\n            break;\n\n        case ORIENTATION_BOTRIGHT:\n            flip(img, img, -1);\n            break;\n\n        case ORIENTATION_BOTLEFT:\n            flip(img, img, 0);\n            break;\n\n        case ORIENTATION_LEFTTOP:\n            transpose(img, img);\n            break;\n\n        case ORIENTATION_RIGHTTOP:\n            transpose(img, img);\n            flip(img, img, 1);\n            break;\n\n        case ORIENTATION_RIGHTBOT:\n            transpose(img, img);\n            flip(img, img, -1);\n            break;\n\n        case ORIENTATION_LEFTBOT:\n            transpose(img, img);\n            flip(img, img, 0);\n            break;\n    }\n}\n\n/**\n * Fix orientation defined in tag 274.\n * For 8 bit some corrections are done by TIFFReadRGBAStrip/Tile already.\n * Not so for 16/32/64 bit.\n */\nstatic void fixOrientation(Mat &img, uint16 orientation, int dst_bpp)\n{\n    switch(dst_bpp) {\n        case 8:\n            fixOrientationPartial(img, orientation);\n            break;\n\n        case 16:\n        case 32:\n        case 64:\n            fixOrientationFull(img, orientation);\n            break;\n    }\n}\n\nstatic void _unpack10To16(const uchar* src, const uchar* srcEnd, ushort* dst, ushort* dstEnd, size_t expectedDstElements)\n{\n    //5*8b=4*10b : 5 src for 4 dst\n    constexpr const size_t packedBitsCount = 10;\n    constexpr const size_t packedBitsMask = ((1<<packedBitsCount)-1);\n    constexpr const size_t srcElementsPerPacket = 5;\n    constexpr const size_t dstElementsPerPacket = 4;\n    constexpr const size_t bitsPerPacket = dstElementsPerPacket*packedBitsCount;\n    const size_t fullPacketsCount = std::min({\n      expectedDstElements/dstElementsPerPacket,\n      (static_cast<size_t>(srcEnd-src)/srcElementsPerPacket),\n      (static_cast<size_t>(dstEnd-dst)/dstElementsPerPacket)\n    });\n    union {\n      uint64_t u64;\n      uint8_t  u8[8];\n    } buf = {0};\n    for(size_t i = 0 ; i<fullPacketsCount ; ++i)\n    {\n        for(size_t j = 0 ; j<srcElementsPerPacket ; ++j)\n          buf.u8[srcElementsPerPacket-1-j] = *src++;\n        for(size_t j = 0 ; j<dstElementsPerPacket ; ++j)\n        {\n          dst[dstElementsPerPacket-1-j] = static_cast<ushort>(buf.u64 & packedBitsMask);\n          buf.u64 >>= packedBitsCount;\n        }\n        dst += dstElementsPerPacket;\n    }\n    size_t remainingDstElements = std::min(\n        expectedDstElements-fullPacketsCount*dstElementsPerPacket,\n        static_cast<size_t>(dstEnd-dst)\n    );\n    bool stop = !remainingDstElements;\n    while(!stop)\n    {\n        for(size_t j = 0 ; j<srcElementsPerPacket ; ++j)\n            buf.u8[srcElementsPerPacket-1-j] = (src<srcEnd) ? *src++ : 0;\n        for(size_t j = 0 ; j<dstElementsPerPacket ; ++j)\n        {\n            stop |= !(remainingDstElements--);\n            if (!stop)\n              *dst++ = static_cast<ushort>((buf.u64 >> (bitsPerPacket-(j+1)*packedBitsCount)) & packedBitsMask);\n        }\n    }//end while(!stop)\n}\n//end _unpack10To16()\n\nstatic void _unpack12To16(const uchar* src, const uchar* srcEnd, ushort* dst, ushort* dstEnd, size_t expectedDstElements)\n{\n  //3*8b=2*12b : 3 src for 2 dst\n  constexpr const size_t packedBitsCount = 12;\n  constexpr const size_t packedBitsMask = ((1<<packedBitsCount)-1);\n  constexpr const size_t srcElementsPerPacket = 3;\n  constexpr const size_t dstElementsPerPacket = 2;\n  constexpr const size_t bitsPerPacket = dstElementsPerPacket*packedBitsCount;\n  const size_t fullPacketsCount = std::min({\n    expectedDstElements/dstElementsPerPacket,\n    (static_cast<size_t>(srcEnd-src)/srcElementsPerPacket),\n    (static_cast<size_t>(dstEnd-dst)/dstElementsPerPacket)\n  });\n  union {\n      uint32_t u32;\n      uint8_t  u8[4];\n  } buf = {0};\n  for(size_t i = 0 ; i<fullPacketsCount ; ++i)\n  {\n      for(size_t j = 0 ; j<srcElementsPerPacket ; ++j)\n          buf.u8[srcElementsPerPacket-1-j] = *src++;\n      for(size_t j = 0 ; j<dstElementsPerPacket ; ++j)\n      {\n          dst[dstElementsPerPacket-1-j] = static_cast<ushort>(buf.u32 & packedBitsMask);\n          buf.u32 >>= packedBitsCount;\n      }\n      dst += dstElementsPerPacket;\n  }\n  size_t remainingDstElements = std::min(\n      expectedDstElements-fullPacketsCount*dstElementsPerPacket,\n      static_cast<size_t>(dstEnd-dst)\n  );\n  bool stop = !remainingDstElements;\n  while(!stop)\n  {\n      for(size_t j = 0 ; j<srcElementsPerPacket ; ++j)\n          buf.u8[srcElementsPerPacket-1-j] = (src<srcEnd) ? *src++ : 0;\n      for(size_t j = 0 ; j<dstElementsPerPacket ; ++j)\n      {\n          stop |= !(remainingDstElements--);\n          if (!stop)\n              *dst++ = static_cast<ushort>((buf.u32 >> (bitsPerPacket-(j+1)*packedBitsCount)) & packedBitsMask);\n      }\n  }//end while(!stop)\n}\n//end _unpack12To16()\n\nstatic void _unpack14To16(const uchar* src, const uchar* srcEnd, ushort* dst, ushort* dstEnd, size_t expectedDstElements)\n{\n    //7*8b=4*14b : 7 src for 4 dst\n    constexpr const size_t packedBitsCount = 14;\n    constexpr const size_t packedBitsMask = ((1<<packedBitsCount)-1);\n    constexpr const size_t srcElementsPerPacket = 7;\n    constexpr const size_t dstElementsPerPacket = 4;\n    constexpr const size_t bitsPerPacket = dstElementsPerPacket*packedBitsCount;\n    const size_t fullPacketsCount = std::min({\n      expectedDstElements/dstElementsPerPacket,\n      (static_cast<size_t>(srcEnd-src)/srcElementsPerPacket),\n      (static_cast<size_t>(dstEnd-dst)/dstElementsPerPacket)\n    });\n    union {\n        uint64_t u64;\n        uint8_t  u8[8];\n    } buf = {0};\n    for(size_t i = 0 ; i<fullPacketsCount ; ++i)\n    {\n        for(size_t j = 0 ; j<srcElementsPerPacket ; ++j)\n            buf.u8[srcElementsPerPacket-1-j] = *src++;\n        for(size_t j = 0 ; j<dstElementsPerPacket ; ++j)\n        {\n            dst[dstElementsPerPacket-1-j] = static_cast<ushort>(buf.u64 & packedBitsMask);\n            buf.u64 >>= packedBitsCount;\n        }\n        dst += dstElementsPerPacket;\n    }\n    size_t remainingDstElements = std::min(\n        expectedDstElements-fullPacketsCount*dstElementsPerPacket,\n        static_cast<size_t>(dstEnd-dst)\n    );\n    bool stop = !remainingDstElements;\n    while(!stop)\n    {\n        for(size_t j = 0 ; j<srcElementsPerPacket ; ++j)\n            buf.u8[srcElementsPerPacket-1-j] = (src<srcEnd) ? *src++ : 0;\n        for(size_t j = 0 ; j<dstElementsPerPacket ; ++j)\n        {\n            stop |= !(remainingDstElements--);\n            if (!stop)\n                *dst++ = static_cast<ushort>((buf.u64 >> (bitsPerPacket-(j+1)*packedBitsCount)) & packedBitsMask);\n        }\n    }//end while(!stop)\n}\n//end _unpack14To16()\n\nbool  TiffDecoder::readData( Mat& img )\n{\n    int type = img.type();\n    int depth = CV_MAT_DEPTH(type);\n\n    CV_Assert(!m_tif.empty());\n    TIFF* tif = (TIFF*)m_tif.get();\n\n    uint16 photometric = (uint16)-1;\n    CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric));\n\n    if (m_hdr && depth >= CV_32F)\n    {\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_FLOAT));\n    }\n\n    bool color = img.channels() > 1;\n\n    CV_CheckType(type, depth == CV_8U || depth == CV_8S || depth == CV_16U || depth == CV_16S || depth == CV_32S || depth == CV_32F || depth == CV_64F, \"\");\n\n    if (m_width && m_height)\n    {\n        int is_tiled = TIFFIsTiled(tif) != 0;\n        bool isGrayScale = photometric == PHOTOMETRIC_MINISWHITE || photometric == PHOTOMETRIC_MINISBLACK;\n        uint16 bpp = 8, ncn = isGrayScale ? 1 : 3;\n        if (0 == TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bpp))\n        {\n            // TIFF bi-level images don't require TIFFTAG_BITSPERSAMPLE tag\n            bpp = 1;\n        }\n        CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &ncn));\n        uint16 img_orientation = ORIENTATION_TOPLEFT;\n        CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_ORIENTATION, &img_orientation));\n        constexpr const int bitsPerByte = 8;\n        int dst_bpp = (int)(img.elemSize1() * bitsPerByte);\n        bool vert_flip = dst_bpp == 8 &&\n                        (img_orientation == ORIENTATION_BOTRIGHT || img_orientation == ORIENTATION_RIGHTBOT ||\n                         img_orientation == ORIENTATION_BOTLEFT || img_orientation == ORIENTATION_LEFTBOT);\n        int wanted_channels = normalizeChannelsNumber(img.channels());\n\n        if (dst_bpp == 8)\n        {\n            char errmsg[1024];\n            if (!TIFFRGBAImageOK(tif, errmsg))\n            {\n                CV_LOG_WARNING(NULL, \"OpenCV TIFF: TIFFRGBAImageOK: \" << errmsg);\n                close();\n                return false;\n            }\n        }\n\n        uint32 tile_width0 = m_width, tile_height0 = 0;\n\n        if (is_tiled)\n        {\n            CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_TILEWIDTH, &tile_width0));\n            CV_TIFF_CHECK_CALL(TIFFGetField(tif, TIFFTAG_TILELENGTH, &tile_height0));\n        }\n        else\n        {\n            // optional\n            CV_TIFF_CHECK_CALL_DEBUG(TIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &tile_height0));\n        }\n\n        {\n            if (tile_width0 == 0)\n                tile_width0 = m_width;\n\n            if (tile_height0 == 0 ||\n                    (!is_tiled && tile_height0 == std::numeric_limits<uint32>::max()) )\n                tile_height0 = m_height;\n\n            const int TILE_MAX_WIDTH = (1 << 24);\n            const int TILE_MAX_HEIGHT = (1 << 24);\n            CV_Assert((int)tile_width0 > 0 && (int)tile_width0 <= TILE_MAX_WIDTH);\n            CV_Assert((int)tile_height0 > 0 && (int)tile_height0 <= TILE_MAX_HEIGHT);\n            const uint64_t MAX_TILE_SIZE = (CV_BIG_UINT(1) << 30);\n            CV_CheckLE((int)ncn, 4, \"\");\n            CV_CheckLE((int)bpp, 64, \"\");\n            CV_Assert(((uint64_t)tile_width0 * tile_height0 * ncn * std::max(1, (int)(bpp / bitsPerByte)) < MAX_TILE_SIZE) && \"TIFF tile size is too large: >= 1Gb\");\n\n            if (dst_bpp == 8)\n            {\n                // we will use TIFFReadRGBA* functions, so allocate temporary buffer for 32bit RGBA\n                bpp = 8;\n                ncn = 4;\n            }\n            else if (dst_bpp == 32 || dst_bpp == 64)\n            {\n                CV_Assert(ncn == img.channels());\n                CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP));\n            }\n            const size_t src_buffer_bytes_per_row = divUp(static_cast<size_t>(ncn * tile_width0 * bpp), static_cast<size_t>(bitsPerByte));\n            const size_t src_buffer_size = tile_height0 * src_buffer_bytes_per_row;\n            const size_t src_buffer_unpacked_bytes_per_row = divUp(static_cast<size_t>(ncn * tile_width0 * dst_bpp), static_cast<size_t>(bitsPerByte));\n            const size_t src_buffer_unpacked_size = tile_height0 * src_buffer_unpacked_bytes_per_row;\n            const bool needsUnpacking = (bpp < dst_bpp);\n            AutoBuffer<uchar> _src_buffer(src_buffer_size);\n            uchar* src_buffer = _src_buffer.data();\n            AutoBuffer<uchar> _src_buffer_unpacked(needsUnpacking ? src_buffer_unpacked_size : 0);\n            uchar* src_buffer_unpacked = needsUnpacking ? _src_buffer_unpacked.data() : nullptr;\n            int tileidx = 0;\n\n            for (int y = 0; y < m_height; y += (int)tile_height0)\n            {\n                int tile_height = std::min((int)tile_height0, m_height - y);\n\n                const int img_y = vert_flip ? m_height - y - tile_height : y;\n\n                for(int x = 0; x < m_width; x += (int)tile_width0, tileidx++)\n                {\n                    int tile_width = std::min((int)tile_width0, m_width - x);\n\n                    switch (dst_bpp)\n                    {\n                        case 8:\n                        {\n                            uchar* bstart = src_buffer;\n                            if (!is_tiled)\n                            {\n                                CV_TIFF_CHECK_CALL(TIFFReadRGBAStrip(tif, y, (uint32*)src_buffer));\n                            }\n                            else\n                            {\n                                CV_TIFF_CHECK_CALL(TIFFReadRGBATile(tif, x, y, (uint32*)src_buffer));\n                                // Tiles fill the buffer from the bottom up\n                                bstart += (tile_height0 - tile_height) * tile_width0 * 4;\n                            }\n\n                            for (int i = 0; i < tile_height; i++)\n                            {\n                                if (color)\n                                {\n                                    if (wanted_channels == 4)\n                                    {\n                                        icvCvt_BGRA2RGBA_8u_C4R(bstart + i*tile_width0*4, 0,\n                                                img.ptr(img_y + tile_height - i - 1, x), 0,\n                                                Size(tile_width, 1) );\n                                    }\n                                    else\n                                    {\n                                        CV_CheckEQ(wanted_channels, 3, \"TIFF-8bpp: BGR/BGRA images are supported only\");\n                                        icvCvt_BGRA2BGR_8u_C4C3R(bstart + i*tile_width0*4, 0,\n                                                img.ptr(img_y + tile_height - i - 1, x), 0,\n                                                Size(tile_width, 1), 2);\n                                    }\n                                }\n                                else\n                                {\n                                    CV_CheckEQ(wanted_channels, 1, \"\");\n                                    icvCvt_BGRA2Gray_8u_C4C1R( bstart + i*tile_width0*4, 0,\n                                            img.ptr(img_y + tile_height - i - 1, x), 0,\n                                            Size(tile_width, 1), 2);\n                                }\n                            }\n                            break;\n                        }\n\n                        case 16:\n                        {\n                            if (!is_tiled)\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedStrip(tif, tileidx, (uint32*)src_buffer, src_buffer_size) >= 0);\n                            }\n                            else\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedTile(tif, tileidx, (uint32*)src_buffer, src_buffer_size) >= 0);\n                            }\n\n                            for (int i = 0; i < tile_height; i++)\n                            {\n                                ushort* buffer16 = (ushort*)(src_buffer+i*src_buffer_bytes_per_row);\n                                if (needsUnpacking)\n                                {\n                                    const uchar* src_packed = src_buffer+i*src_buffer_bytes_per_row;\n                                    uchar* dst_unpacked = src_buffer_unpacked+i*src_buffer_unpacked_bytes_per_row;\n                                    if (bpp == 10)\n                                        _unpack10To16(src_packed, src_packed+src_buffer_bytes_per_row,\n                                                      (ushort*)dst_unpacked, (ushort*)(dst_unpacked+src_buffer_unpacked_bytes_per_row),\n                                                      ncn * tile_width0);\n                                    else if (bpp == 12)\n                                        _unpack12To16(src_packed, src_packed+src_buffer_bytes_per_row,\n                                                      (ushort*)dst_unpacked, (ushort*)(dst_unpacked+src_buffer_unpacked_bytes_per_row),\n                                                      ncn * tile_width0);\n                                    else if (bpp == 14)\n                                        _unpack14To16(src_packed, src_packed+src_buffer_bytes_per_row,\n                                                      (ushort*)dst_unpacked, (ushort*)(dst_unpacked+src_buffer_unpacked_bytes_per_row),\n                                                      ncn * tile_width0);\n                                    buffer16 = (ushort*)dst_unpacked;\n                                }\n\n                                if (color)\n                                {\n                                    if (ncn == 1)\n                                    {\n                                        CV_CheckEQ(wanted_channels, 3, \"\");\n                                        icvCvt_Gray2BGR_16u_C1C3R(buffer16, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1));\n                                    }\n                                    else if (ncn == 3)\n                                    {\n                                        CV_CheckEQ(wanted_channels, 3, \"\");\n                                        icvCvt_RGB2BGR_16u_C3R(buffer16, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1));\n                                    }\n                                    else if (ncn == 4)\n                                    {\n                                        if (wanted_channels == 4)\n                                        {\n                                            icvCvt_BGRA2RGBA_16u_C4R(buffer16, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1));\n                                        }\n                                        else\n                                        {\n                                            CV_CheckEQ(wanted_channels, 3, \"TIFF-16bpp: BGR/BGRA images are supported only\");\n                                            icvCvt_BGRA2BGR_16u_C4C3R(buffer16, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1), 2);\n                                        }\n                                    }\n                                    else\n                                    {\n                                        CV_Error(Error::StsError, \"Not supported\");\n                                    }\n                                }\n                                else\n                                {\n                                    CV_CheckEQ(wanted_channels, 1, \"\");\n                                    if( ncn == 1 )\n                                    {\n                                        memcpy(img.ptr<ushort>(img_y + i, x),\n                                               buffer16,\n                                               tile_width*sizeof(ushort));\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2Gray_16u_CnC1R(buffer16, 0,\n                                                img.ptr<ushort>(img_y + i, x), 0,\n                                                Size(tile_width, 1), ncn, 2);\n                                    }\n                                }\n                            }\n                            break;\n                        }\n\n                        case 32:\n                        case 64:\n                        {\n                            if( !is_tiled )\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedStrip(tif, tileidx, src_buffer, src_buffer_size) >= 0);\n                            }\n                            else\n                            {\n                                CV_TIFF_CHECK_CALL((int)TIFFReadEncodedTile(tif, tileidx, src_buffer, src_buffer_size) >= 0);\n                            }\n\n                            Mat m_tile(Size(tile_width0, tile_height0), CV_MAKETYPE((dst_bpp == 32) ? (depth == CV_32S ? CV_32S : CV_32F) : CV_64F, ncn), src_buffer);\n                            Rect roi_tile(0, 0, tile_width, tile_height);\n                            Rect roi_img(x, img_y, tile_width, tile_height);\n                            if (!m_hdr && ncn == 3)\n                                cvtColor(m_tile(roi_tile), img(roi_img), COLOR_RGB2BGR);\n                            else if (!m_hdr && ncn == 4)\n                                cvtColor(m_tile(roi_tile), img(roi_img), COLOR_RGBA2BGRA);\n                            else\n                                m_tile(roi_tile).copyTo(img(roi_img));\n                            break;\n                        }\n                        default:\n                        {\n                            CV_Assert(0 && \"OpenCV TIFF: unsupported depth\");\n                        }\n                    }  // switch (dst_bpp)\n                }  // for x\n            }  // for y\n        }\n        if (bpp < dst_bpp)\n          img *= (1<<(dst_bpp-bpp));\n        fixOrientation(img, img_orientation, dst_bpp);\n    }\n\n    if (m_hdr && depth >= CV_32F)\n    {\n        CV_Assert(photometric == PHOTOMETRIC_LOGLUV);\n        cvtColor(img, img, COLOR_XYZ2BGR);\n    }\n    return true;\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////\n\nTiffEncoder::TiffEncoder()\n{\n    m_description = \"TIFF Files (*.tiff;*.tif)\";\n    m_buf_supported = true;\n}\n\nTiffEncoder::~TiffEncoder()\n{\n}\n\nImageEncoder TiffEncoder::newEncoder() const\n{\n    return makePtr<TiffEncoder>();\n}\n\nbool TiffEncoder::isFormatSupported( int depth ) const\n{\n    return depth == CV_8U || depth == CV_8S || depth == CV_16U || depth == CV_16S || depth == CV_32S || depth == CV_32F || depth == CV_64F;\n}\n\nvoid  TiffEncoder::writeTag( WLByteStream& strm, TiffTag tag,\n                             TiffFieldType fieldType,\n                             int count, int value )\n{\n    strm.putWord( tag );\n    strm.putWord( fieldType );\n    strm.putDWord( count );\n    strm.putDWord( value );\n}\n\nclass TiffEncoderBufHelper\n{\npublic:\n\n    TiffEncoderBufHelper(std::vector<uchar> *buf)\n            : m_buf(buf), m_buf_pos(0)\n    {}\n\n    TIFF* open ()\n    {\n        // do NOT put \"wb\" as the mode, because the b means \"big endian\" mode, not \"binary\" mode.\n        // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n        return TIFFClientOpen( \"\", \"w\", reinterpret_cast<thandle_t>(this), &TiffEncoderBufHelper::read,\n                               &TiffEncoderBufHelper::write, &TiffEncoderBufHelper::seek,\n                               &TiffEncoderBufHelper::close, &TiffEncoderBufHelper::size,\n                               /*map=*/0, /*unmap=*/0 );\n    }\n\n    static tmsize_t read( thandle_t /*handle*/, void* /*buffer*/, tmsize_t /*n*/ )\n    {\n        // Not used for encoding.\n        return 0;\n    }\n\n    static tmsize_t write( thandle_t handle, void* buffer, tmsize_t n )\n    {\n        TiffEncoderBufHelper *helper = reinterpret_cast<TiffEncoderBufHelper*>(handle);\n        size_t begin = (size_t)helper->m_buf_pos;\n        size_t end = begin + n;\n        if ( helper->m_buf->size() < end )\n        {\n            helper->m_buf->resize(end);\n        }\n        memcpy(&(*helper->m_buf)[begin], buffer, n);\n        helper->m_buf_pos = end;\n        return n;\n    }\n\n    static toff_t seek( thandle_t handle, toff_t offset, int whence )\n    {\n        TiffEncoderBufHelper *helper = reinterpret_cast<TiffEncoderBufHelper*>(handle);\n        const toff_t size = helper->m_buf->size();\n        toff_t new_pos = helper->m_buf_pos;\n        switch (whence)\n        {\n            case SEEK_SET:\n                new_pos = offset;\n                break;\n            case SEEK_CUR:\n                new_pos += offset;\n                break;\n            case SEEK_END:\n                new_pos = size + offset;\n                break;\n        }\n        helper->m_buf_pos = new_pos;\n        return new_pos;\n    }\n\n    static toff_t size( thandle_t handle )\n    {\n        TiffEncoderBufHelper *helper = reinterpret_cast<TiffEncoderBufHelper*>(handle);\n        return helper->m_buf->size();\n    }\n\n    static int close( thandle_t /*handle*/ )\n    {\n        // Do nothing.\n        return 0;\n    }\n\nprivate:\n\n    std::vector<uchar>* m_buf;\n    toff_t m_buf_pos;\n};\n\nstatic bool readParam(const std::vector<int>& params, int key, int& value)\n{\n    for (size_t i = 0; i + 1 < params.size(); i += 2)\n    {\n        if (params[i] == key)\n        {\n            value = params[i + 1];\n            return true;\n        }\n    }\n    return false;\n}\n\nbool TiffEncoder::writeLibTiff( const std::vector<Mat>& img_vec, const std::vector<int>& params)\n{\n    // do NOT put \"wb\" as the mode, because the b means \"big endian\" mode, not \"binary\" mode.\n    // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n    TIFF* tif = NULL;\n\n    TiffEncoderBufHelper buf_helper(m_buf);\n    if ( m_buf )\n    {\n        tif = buf_helper.open();\n    }\n    else\n    {\n        tif = TIFFOpen(m_filename.c_str(), \"w\");\n    }\n    if (!tif)\n    {\n        return false;\n    }\n    cv::Ptr<void> tif_cleanup(tif, cv_tiffCloseHandle);\n\n    //Settings that matter to all images\n    int compression = COMPRESSION_LZW;\n    int predictor = PREDICTOR_HORIZONTAL;\n    int resUnit = -1, dpiX = -1, dpiY = -1;\n\n    readParam(params, IMWRITE_TIFF_COMPRESSION, compression);\n    readParam(params, TIFFTAG_PREDICTOR, predictor);\n    readParam(params, IMWRITE_TIFF_RESUNIT, resUnit);\n    readParam(params, IMWRITE_TIFF_XDPI, dpiX);\n    readParam(params, IMWRITE_TIFF_YDPI, dpiY);\n\n    //Iterate through each image in the vector and write them out as Tiff directories\n    for (size_t page = 0; page < img_vec.size(); page++)\n    {\n        const Mat& img = img_vec[page];\n        CV_Assert(!img.empty());\n        int channels = img.channels();\n        int width = img.cols, height = img.rows;\n        int type = img.type();\n        int depth = CV_MAT_DEPTH(type);\n        CV_CheckType(type, depth == CV_8U || depth == CV_8S || depth == CV_16U || depth == CV_16S || depth == CV_32S || depth == CV_32F || depth == CV_64F, \"\");\n        CV_CheckType(type, channels >= 1 && channels <= 4, \"\");\n\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, width));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_IMAGELENGTH, height));\n\n        if (img_vec.size() > 1)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE));\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PAGENUMBER, page, img_vec.size()));\n        }\n\n        int compression_param = -1;  // OPENCV_FUTURE\n        if (type == CV_32FC3 && (!readParam(params, IMWRITE_TIFF_COMPRESSION, compression_param) || compression_param == COMPRESSION_SGILOG))\n        {\n            if (!write_32FC3_SGILOG(img, tif))\n                return false;\n            continue;\n        }\n\n        int page_compression = compression;\n\n        int bitsPerChannel = -1;\n        uint16 sample_format = SAMPLEFORMAT_INT;\n        switch (depth)\n        {\n            case CV_8U:\n                sample_format = SAMPLEFORMAT_UINT;\n                /* FALLTHRU */\n            case CV_8S:\n            {\n                bitsPerChannel = 8;\n                break;\n            }\n\n            case CV_16U:\n                sample_format = SAMPLEFORMAT_UINT;\n                /* FALLTHRU */\n            case CV_16S:\n            {\n                bitsPerChannel = 16;\n                break;\n            }\n\n            case CV_32F:\n                sample_format = SAMPLEFORMAT_IEEEFP;\n                /* FALLTHRU */\n            case CV_32S:\n            {\n                bitsPerChannel = 32;\n                page_compression = COMPRESSION_NONE;\n                break;\n            }\n            case CV_64F:\n            {\n                bitsPerChannel = 64;\n                page_compression = COMPRESSION_NONE;\n                sample_format = SAMPLEFORMAT_IEEEFP;\n                break;\n            }\n            default:\n            {\n                return false;\n            }\n        }\n\n        const int bitsPerByte = 8;\n        size_t fileStep = (width * channels * bitsPerChannel) / bitsPerByte;\n        CV_Assert(fileStep > 0);\n\n        int rowsPerStrip = (int)((1 << 13) / fileStep);\n        readParam(params, TIFFTAG_ROWSPERSTRIP, rowsPerStrip);\n        rowsPerStrip = std::max(1, std::min(height, rowsPerStrip));\n\n        int colorspace = channels > 1 ? PHOTOMETRIC_RGB : PHOTOMETRIC_MINISBLACK;\n\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, bitsPerChannel));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_COMPRESSION, page_compression));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, colorspace));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, channels));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, rowsPerStrip));\n\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, sample_format));\n\n        if (page_compression == COMPRESSION_LZW || page_compression == COMPRESSION_ADOBE_DEFLATE || page_compression == COMPRESSION_DEFLATE)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PREDICTOR, predictor));\n        }\n\n        if (resUnit >= RESUNIT_NONE && resUnit <= RESUNIT_CENTIMETER)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_RESOLUTIONUNIT, resUnit));\n        }\n        if (dpiX >= 0)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_XRESOLUTION, (float)dpiX));\n        }\n        if (dpiY >= 0)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_YRESOLUTION, (float)dpiY));\n        }\n\n        // row buffer, because TIFFWriteScanline modifies the original data!\n        size_t scanlineSize = TIFFScanlineSize(tif);\n        AutoBuffer<uchar> _buffer(scanlineSize + 32);\n        uchar* buffer = _buffer.data(); CV_DbgAssert(buffer);\n        Mat m_buffer(Size(width, 1), CV_MAKETYPE(depth, channels), buffer, (size_t)scanlineSize);\n\n        for (int y = 0; y < height; ++y)\n        {\n            switch (channels)\n            {\n                case 1:\n                {\n                    memcpy(buffer, img.ptr(y), scanlineSize);\n                    break;\n                }\n\n                case 3:\n                {\n                    cvtColor(img(Rect(0, y, width, 1)), (const Mat&)m_buffer, COLOR_BGR2RGB);\n                    break;\n                }\n\n                case 4:\n                {\n                    cvtColor(img(Rect(0, y, width, 1)), (const Mat&)m_buffer, COLOR_BGRA2RGBA);\n                    break;\n                }\n\n                default:\n                {\n                    CV_Assert(0);\n                }\n            }\n\n            CV_TIFF_CHECK_CALL(TIFFWriteScanline(tif, buffer, y, 0) == 1);\n        }\n\n        CV_TIFF_CHECK_CALL(TIFFWriteDirectory(tif));\n    }\n\n    return true;\n}\n\nbool TiffEncoder::write_32FC3_SGILOG(const Mat& _img, void* tif_)\n{\n    TIFF* tif = (TIFF*)tif_;\n    CV_Assert(tif);\n\n    Mat img;\n    cvtColor(_img, img, COLOR_BGR2XYZ);\n\n    //done by caller: CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, img.cols));\n    //done by caller: CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_IMAGELENGTH, img.rows));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 3));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 32));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_SGILOG));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_LOGLUV));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_FLOAT));\n    CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, 1));\n    const int strip_size = 3 * img.cols;\n    for (int i = 0; i < img.rows; i++)\n    {\n        CV_TIFF_CHECK_CALL(TIFFWriteEncodedStrip(tif, i, (tdata_t)img.ptr<float>(i), strip_size * sizeof(float)) != (tsize_t)-1);\n    }\n    CV_TIFF_CHECK_CALL(TIFFWriteDirectory(tif));\n    return true;\n}\n\nbool TiffEncoder::writemulti(const std::vector<Mat>& img_vec, const std::vector<int>& params)\n{\n    return writeLibTiff(img_vec, params);\n}\n\nbool  TiffEncoder::write( const Mat& img, const std::vector<int>& params)\n{\n    int type = img.type();\n    int depth = CV_MAT_DEPTH(type);\n\n    CV_CheckType(type, depth == CV_8U || depth == CV_8S || depth == CV_16U || depth == CV_16S || depth == CV_32S || depth == CV_32F || depth == CV_64F, \"\");\n\n    std::vector<Mat> img_vec;\n    img_vec.push_back(img);\n    return writeLibTiff(img_vec, params);\n}\n\n} // namespace\n\n#endif\n",
                "name": "grfmt_tiff.cpp",
                "path": "third/opencv-4.6.0/modules/imgcodecs/src/grfmt_tiff.cpp",
                "url": "/github.com/kallaballa/Poppy/-/blob/third/opencv-4.6.0/modules/imgcodecs/src/grfmt_tiff.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 707,
                    "offsetAndLengths": [
                        [
                            51,
                            16
                        ]
                    ],
                    "preview": "                                CV_TIFF_CHECK_CALL(TIFFReadRGBATile(tif, x, y, (uint32*)src_buffer));"
                }
            ],
            "repository": {
                "name": "github.com/kallaballa/Poppy",
                "url": "/github.com/kallaballa/Poppy"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "9ef574cb82a9d83ed972334cb0b7e1bd7b1a870d"
                },
                "content": "/*M///////////////////////////////////////////////////////////////////////////////////////\n//\n//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.\n//\n//  By downloading, copying, installing or using the software you agree to this license.\n//  If you do not agree to this license, do not download, install,\n//  copy or use the software.\n//\n//\n//                           License Agreement\n//                For Open Source Computer Vision Library\n//\n// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.\n// Copyright (C) 2009, Willow Garage Inc., all rights reserved.\n// Third party copyrights are property of their respective owners.\n//\n// Redistribution and use in source and binary forms, with or without modification,\n// are permitted provided that the following conditions are met:\n//\n//   * Redistribution's of source code must retain the above copyright notice,\n//     this list of conditions and the following disclaimer.\n//\n//   * Redistribution's in binary form must reproduce the above copyright notice,\n//     this list of conditions and the following disclaimer in the documentation\n//     and/or other materials provided with the distribution.\n//\n//   * The name of the copyright holders may not be used to endorse or promote products\n//     derived from this software without specific prior written permission.\n//\n// This software is provided by the copyright holders and contributors \"as is\" and\n// any express or implied warranties, including, but not limited to, the implied\n// warranties of merchantability and fitness for a particular purpose are disclaimed.\n// In no event shall the Intel Corporation or contributors be liable for any direct,\n// indirect, incidental, special, exemplary, or consequential damages\n// (including, but not limited to, procurement of substitute goods or services;\n// loss of use, data, or profits; or business interruption) however caused\n// and on any theory of liability, whether in contract, strict liability,\n// or tort (including negligence or otherwise) arising in any way out of\n// the use of this software, even if advised of the possibility of such damage.\n//\n//M*/\n\n/****************************************************************************************\\\n    A part of the file implements TIFF reader on base of libtiff library\n    (see otherlibs/_graphics/readme.txt for copyright notice)\n\\****************************************************************************************/\n\n#include \"precomp.hpp\"\n\n#ifdef HAVE_TIFF\n#include \"grfmt_tiff.hpp\"\n#include <limits>\n\n// TODO FIXIT Conflict declarations for common types like int64/uint64\nnamespace tiff_dummy_namespace {\n#include \"tiff.h\"\n#include \"tiffio.h\"\n}\nusing namespace tiff_dummy_namespace;\n\nnamespace cv\n{\n\n\nstatic const char fmtSignTiffII[] = \"II\\x2a\\x00\";\nstatic const char fmtSignTiffMM[] = \"MM\\x00\\x2a\";\n\nstatic int grfmt_tiff_err_handler_init = 0;\nstatic void GrFmtSilentTIFFErrorHandler( const char*, const char*, va_list ) {}\n\nTiffDecoder::TiffDecoder()\n{\n    m_tif = 0;\n    if( !grfmt_tiff_err_handler_init )\n    {\n        grfmt_tiff_err_handler_init = 1;\n\n        TIFFSetErrorHandler( GrFmtSilentTIFFErrorHandler );\n        TIFFSetWarningHandler( GrFmtSilentTIFFErrorHandler );\n    }\n    m_hdr = false;\n    m_buf_supported = true;\n    m_buf_pos = 0;\n}\n\n\nvoid TiffDecoder::close()\n{\n    if( m_tif )\n    {\n        TIFF* tif = (TIFF*)m_tif;\n        TIFFClose( tif );\n        m_tif = 0;\n    }\n}\n\nTiffDecoder::~TiffDecoder()\n{\n    close();\n}\n\nsize_t TiffDecoder::signatureLength() const\n{\n    return 4;\n}\n\nbool TiffDecoder::checkSignature( const String& signature ) const\n{\n    return signature.size() >= 4 &&\n        (memcmp(signature.c_str(), fmtSignTiffII, 4) == 0 ||\n        memcmp(signature.c_str(), fmtSignTiffMM, 4) == 0);\n}\n\nint TiffDecoder::normalizeChannelsNumber(int channels) const\n{\n    return channels > 4 ? 4 : channels;\n}\n\nImageDecoder TiffDecoder::newDecoder() const\n{\n    return makePtr<TiffDecoder>();\n}\n\nclass TiffDecoderBufHelper\n{\n    Mat& m_buf;\n    size_t& m_buf_pos;\npublic:\n    TiffDecoderBufHelper(Mat& buf, size_t& buf_pos) :\n        m_buf(buf), m_buf_pos(buf_pos)\n    {}\n    static tmsize_t read( thandle_t handle, void* buffer, tmsize_t n )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        const Mat& buf = helper->m_buf;\n        const tmsize_t size = buf.cols*buf.rows*buf.elemSize();\n        tmsize_t pos = helper->m_buf_pos;\n        if ( n > (size - pos) )\n        {\n            n = size - pos;\n        }\n        memcpy(buffer, buf.ptr() + pos, n);\n        helper->m_buf_pos += n;\n        return n;\n    }\n\n    static tmsize_t write( thandle_t /*handle*/, void* /*buffer*/, tmsize_t /*n*/ )\n    {\n        // Not used for decoding.\n        return 0;\n    }\n\n    static toff_t seek( thandle_t handle, toff_t offset, int whence )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        const Mat& buf = helper->m_buf;\n        const toff_t size = buf.cols*buf.rows*buf.elemSize();\n        toff_t new_pos = helper->m_buf_pos;\n        switch (whence)\n        {\n            case SEEK_SET:\n                new_pos = offset;\n                break;\n            case SEEK_CUR:\n                new_pos += offset;\n                break;\n            case SEEK_END:\n                new_pos = size + offset;\n                break;\n        }\n        new_pos = std::min(new_pos, size);\n        helper->m_buf_pos = (size_t)new_pos;\n        return new_pos;\n    }\n\n    static int map( thandle_t handle, void** base, toff_t* size )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        Mat& buf = helper->m_buf;\n        *base = buf.ptr();\n        *size = buf.cols*buf.rows*buf.elemSize();\n        return 0;\n    }\n\n    static toff_t size( thandle_t handle )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        const Mat& buf = helper->m_buf;\n        return buf.cols*buf.rows*buf.elemSize();\n    }\n\n    static int close( thandle_t handle )\n    {\n        TiffDecoderBufHelper *helper = reinterpret_cast<TiffDecoderBufHelper*>(handle);\n        delete helper;\n        return 0;\n    }\n};\n\nbool TiffDecoder::readHeader()\n{\n    bool result = false;\n\n    TIFF* tif = static_cast<TIFF*>(m_tif);\n    if (!m_tif)\n    {\n        // TIFFOpen() mode flags are different to fopen().  A 'b' in mode \"rb\" has no effect when reading.\n        // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n        if ( !m_buf.empty() )\n        {\n            m_buf_pos = 0;\n            TiffDecoderBufHelper* buf_helper = new TiffDecoderBufHelper(this->m_buf, this->m_buf_pos);\n            tif = TIFFClientOpen( \"\", \"r\", reinterpret_cast<thandle_t>(buf_helper), &TiffDecoderBufHelper::read,\n                                  &TiffDecoderBufHelper::write, &TiffDecoderBufHelper::seek,\n                                  &TiffDecoderBufHelper::close, &TiffDecoderBufHelper::size,\n                                  &TiffDecoderBufHelper::map, /*unmap=*/0 );\n        }\n        else\n        {\n            tif = TIFFOpen(m_filename.c_str(), \"r\");\n        }\n    }\n\n    if( tif )\n    {\n        uint32 wdth = 0, hght = 0;\n        uint16 photometric = 0;\n        m_tif = tif;\n\n        if( TIFFGetField( tif, TIFFTAG_IMAGEWIDTH, &wdth ) &&\n            TIFFGetField( tif, TIFFTAG_IMAGELENGTH, &hght ) &&\n            TIFFGetField( tif, TIFFTAG_PHOTOMETRIC, &photometric ))\n        {\n            uint16 bpp=8, ncn = photometric > 1 ? 3 : 1;\n            TIFFGetField( tif, TIFFTAG_BITSPERSAMPLE, &bpp );\n            TIFFGetField( tif, TIFFTAG_SAMPLESPERPIXEL, &ncn );\n\n            m_width = wdth;\n            m_height = hght;\n            if((bpp == 32 && ncn == 3) || photometric == PHOTOMETRIC_LOGLUV)\n            {\n                m_type = CV_32FC3;\n                m_hdr = true;\n                return true;\n            }\n            m_hdr = false;\n\n            if( bpp > 8 &&\n               ((photometric > 2) ||\n                (ncn != 1 && ncn != 3 && ncn != 4)))\n                bpp = 8;\n\n            int wanted_channels = normalizeChannelsNumber(ncn);\n            switch(bpp)\n            {\n                case 8:\n                    m_type = CV_MAKETYPE(CV_8U, photometric > 1 ? wanted_channels : 1);\n                    break;\n                case 16:\n                    m_type = CV_MAKETYPE(CV_16U, photometric > 1 ? wanted_channels : 1);\n                    break;\n\n                case 32:\n                    m_type = CV_MAKETYPE(CV_32F, photometric > 1 ? 3 : 1);\n                    break;\n                case 64:\n                    m_type = CV_MAKETYPE(CV_64F, photometric > 1 ? 3 : 1);\n                    break;\n\n                default:\n                    result = false;\n            }\n            result = true;\n        }\n    }\n\n    if( !result )\n        close();\n\n    return result;\n}\n\nbool TiffDecoder::nextPage()\n{\n    // Prepare the next page, if any.\n    return m_tif &&\n           TIFFReadDirectory(static_cast<TIFF*>(m_tif)) &&\n           readHeader();\n}\n\nbool  TiffDecoder::readData( Mat& img )\n{\n    if(m_hdr && img.type() == CV_32FC3)\n    {\n        return readHdrData(img);\n    }\n    bool result = false;\n    bool color = img.channels() > 1;\n    uchar* data = img.ptr();\n\n    if( img.depth() != CV_8U && img.depth() != CV_16U && img.depth() != CV_32F && img.depth() != CV_64F )\n        return false;\n\n    if( m_tif && m_width && m_height )\n    {\n        TIFF* tif = (TIFF*)m_tif;\n        uint32 tile_width0 = m_width, tile_height0 = 0;\n        int x, y, i;\n        int is_tiled = TIFFIsTiled(tif);\n        uint16 photometric;\n        TIFFGetField( tif, TIFFTAG_PHOTOMETRIC, &photometric );\n        uint16 bpp = 8, ncn = photometric > 1 ? 3 : 1;\n        TIFFGetField( tif, TIFFTAG_BITSPERSAMPLE, &bpp );\n        TIFFGetField( tif, TIFFTAG_SAMPLESPERPIXEL, &ncn );\n        const int bitsPerByte = 8;\n        int dst_bpp = (int)(img.elemSize1() * bitsPerByte);\n        int wanted_channels = normalizeChannelsNumber(img.channels());\n\n        if(dst_bpp == 8)\n        {\n            char errmsg[1024];\n            if(!TIFFRGBAImageOK( tif, errmsg ))\n            {\n                close();\n                return false;\n            }\n        }\n\n        if( (!is_tiled) ||\n            (is_tiled &&\n            TIFFGetField( tif, TIFFTAG_TILEWIDTH, &tile_width0 ) &&\n            TIFFGetField( tif, TIFFTAG_TILELENGTH, &tile_height0 )))\n        {\n            if(!is_tiled)\n                TIFFGetField( tif, TIFFTAG_ROWSPERSTRIP, &tile_height0 );\n\n            if( tile_width0 <= 0 )\n                tile_width0 = m_width;\n\n            if( tile_height0 <= 0 ||\n               (!is_tiled && tile_height0 == std::numeric_limits<uint32>::max()) )\n                tile_height0 = m_height;\n\n            if(dst_bpp == 8) {\n                // we will use TIFFReadRGBA* functions, so allocate temporary buffer for 32bit RGBA\n                bpp = 8;\n                ncn = 4;\n            }\n            const size_t buffer_size = (bpp/bitsPerByte) * ncn * tile_height0 * tile_width0;\n            AutoBuffer<uchar> _buffer( buffer_size );\n            uchar* buffer = _buffer;\n            ushort* buffer16 = (ushort*)buffer;\n            float* buffer32 = (float*)buffer;\n            double* buffer64 = (double*)buffer;\n            int tileidx = 0;\n\n            for( y = 0; y < m_height; y += tile_height0, data += img.step*tile_height0 )\n            {\n                int tile_height = tile_height0;\n\n                if( y + tile_height > m_height )\n                    tile_height = m_height - y;\n\n                for( x = 0; x < m_width; x += tile_width0, tileidx++ )\n                {\n                    int tile_width = tile_width0, ok;\n\n                    if( x + tile_width > m_width )\n                        tile_width = m_width - x;\n\n                    switch(dst_bpp)\n                    {\n                        case 8:\n                        {\n                            uchar * bstart = buffer;\n                            if( !is_tiled )\n                                ok = TIFFReadRGBAStrip( tif, y, (uint32*)buffer );\n                            else\n                            {\n                                ok = TIFFReadRGBATile( tif, x, y, (uint32*)buffer );\n                                //Tiles fill the buffer from the bottom up\n                                bstart += (tile_height0 - tile_height) * tile_width0 * 4;\n                            }\n                            if( !ok )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                                if( color )\n                                {\n                                    if (wanted_channels == 4)\n                                    {\n                                        icvCvt_BGRA2RGBA_8u_C4R( bstart + i*tile_width0*4, 0,\n                                                             data + x*4 + img.step*(tile_height - i - 1), 0,\n                                                             cvSize(tile_width,1) );\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2BGR_8u_C4C3R( bstart + i*tile_width0*4, 0,\n                                                             data + x*3 + img.step*(tile_height - i - 1), 0,\n                                                             cvSize(tile_width,1), 2 );\n                                    }\n                                }\n                                else\n                                    icvCvt_BGRA2Gray_8u_C4C1R( bstart + i*tile_width0*4, 0,\n                                                              data + x + img.step*(tile_height - i - 1), 0,\n                                                              cvSize(tile_width,1), 2 );\n                            break;\n                        }\n\n                        case 16:\n                        {\n                            if( !is_tiled )\n                                ok = (int)TIFFReadEncodedStrip( tif, tileidx, (uint32*)buffer, buffer_size ) >= 0;\n                            else\n                                ok = (int)TIFFReadEncodedTile( tif, tileidx, (uint32*)buffer, buffer_size ) >= 0;\n\n                            if( !ok )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                            {\n                                if( color )\n                                {\n                                    if( ncn == 1 )\n                                    {\n                                        icvCvt_Gray2BGR_16u_C1C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                                  (ushort*)(data + img.step*i) + x*3, 0,\n                                                                  cvSize(tile_width,1) );\n                                    }\n                                    else if( ncn == 3 )\n                                    {\n                                        icvCvt_RGB2BGR_16u_C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                               (ushort*)(data + img.step*i) + x*3, 0,\n                                                               cvSize(tile_width,1) );\n                                    }\n                                    else if (ncn == 4)\n                                    {\n                                        if (wanted_channels == 4)\n                                        {\n                                            icvCvt_BGRA2RGBA_16u_C4R(buffer16 + i*tile_width0*ncn, 0,\n                                                (ushort*)(data + img.step*i) + x * 4, 0,\n                                                cvSize(tile_width, 1));\n                                        }\n                                        else\n                                        {\n                                            icvCvt_BGRA2BGR_16u_C4C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                (ushort*)(data + img.step*i) + x * 3, 0,\n                                                cvSize(tile_width, 1), 2);\n                                        }\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2BGR_16u_C4C3R(buffer16 + i*tile_width0*ncn, 0,\n                                                               (ushort*)(data + img.step*i) + x*3, 0,\n                                                               cvSize(tile_width,1), 2 );\n                                    }\n                                }\n                                else\n                                {\n                                    if( ncn == 1 )\n                                    {\n                                        memcpy((ushort*)(data + img.step*i)+x,\n                                               buffer16 + i*tile_width0*ncn,\n                                               tile_width*sizeof(buffer16[0]));\n                                    }\n                                    else\n                                    {\n                                        icvCvt_BGRA2Gray_16u_CnC1R(buffer16 + i*tile_width0*ncn, 0,\n                                                               (ushort*)(data + img.step*i) + x, 0,\n                                                               cvSize(tile_width,1), ncn, 2 );\n                                    }\n                                }\n                            }\n                            break;\n                        }\n\n                        case 32:\n                        case 64:\n                        {\n                            if( !is_tiled )\n                                ok = (int)TIFFReadEncodedStrip( tif, tileidx, buffer, buffer_size ) >= 0;\n                            else\n                                ok = (int)TIFFReadEncodedTile( tif, tileidx, buffer, buffer_size ) >= 0;\n\n                            if( !ok || ncn != 1 )\n                            {\n                                close();\n                                return false;\n                            }\n\n                            for( i = 0; i < tile_height; i++ )\n                            {\n                                if(dst_bpp == 32)\n                                {\n                                    memcpy((float*)(data + img.step*i)+x,\n                                           buffer32 + i*tile_width0*ncn,\n                                           tile_width*sizeof(buffer32[0]));\n                                }\n                                else\n                                {\n                                    memcpy((double*)(data + img.step*i)+x,\n                                         buffer64 + i*tile_width0*ncn,\n                                         tile_width*sizeof(buffer64[0]));\n                                }\n                            }\n\n                            break;\n                        }\n                        default:\n                        {\n                            close();\n                            return false;\n                        }\n                    }\n                }\n            }\n\n            result = true;\n        }\n    }\n\n    return result;\n}\n\nbool TiffDecoder::readHdrData(Mat& img)\n{\n    int rows_per_strip = 0, photometric = 0;\n    if(!m_tif)\n    {\n        return false;\n    }\n    TIFF *tif = static_cast<TIFF*>(m_tif);\n    TIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &rows_per_strip);\n    TIFFGetField( tif, TIFFTAG_PHOTOMETRIC, &photometric );\n    TIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_FLOAT);\n    int size = 3 * m_width * m_height * sizeof (float);\n    tstrip_t strip_size = 3 * m_width * rows_per_strip;\n    float *ptr = img.ptr<float>();\n    for (tstrip_t i = 0; i < TIFFNumberOfStrips(tif); i++, ptr += strip_size)\n    {\n        TIFFReadEncodedStrip(tif, i, ptr, size);\n        size -= strip_size * sizeof(float);\n    }\n    close();\n    if(photometric == PHOTOMETRIC_LOGLUV)\n    {\n        cvtColor(img, img, COLOR_XYZ2BGR);\n    }\n    else\n    {\n        cvtColor(img, img, COLOR_RGB2BGR);\n    }\n    return true;\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////\n\nTiffEncoder::TiffEncoder()\n{\n    m_description = \"TIFF Files (*.tiff;*.tif)\";\n    m_buf_supported = true;\n}\n\nTiffEncoder::~TiffEncoder()\n{\n}\n\nImageEncoder TiffEncoder::newEncoder() const\n{\n    return makePtr<TiffEncoder>();\n}\n\nbool TiffEncoder::isFormatSupported( int depth ) const\n{\n    return depth == CV_8U || depth == CV_16U || depth == CV_32F;\n}\n\nvoid  TiffEncoder::writeTag( WLByteStream& strm, TiffTag tag,\n                             TiffFieldType fieldType,\n                             int count, int value )\n{\n    strm.putWord( tag );\n    strm.putWord( fieldType );\n    strm.putDWord( count );\n    strm.putDWord( value );\n}\n\nclass TiffEncoderBufHelper\n{\npublic:\n\n    TiffEncoderBufHelper(std::vector<uchar> *buf)\n            : m_buf(buf), m_buf_pos(0)\n    {}\n\n    TIFF* open ()\n    {\n        return TIFFClientOpen( \"\", \"w\", reinterpret_cast<thandle_t>(this), &TiffEncoderBufHelper::read,\n                               &TiffEncoderBufHelper::write, &TiffEncoderBufHelper::seek,\n                               &TiffEncoderBufHelper::close, &TiffEncoderBufHelper::size,\n                               /*map=*/0, /*unmap=*/0 );\n    }\n\n    static tmsize_t read( thandle_t /*handle*/, void* /*buffer*/, tmsize_t /*n*/ )\n    {\n        // Not used for encoding.\n        return 0;\n    }\n\n    static tmsize_t write( thandle_t handle, void* buffer, tmsize_t n )\n    {\n        TiffEncoderBufHelper *helper = reinterpret_cast<TiffEncoderBufHelper*>(handle);\n        size_t begin = (size_t)helper->m_buf_pos;\n        size_t end = begin + n;\n        if ( helper->m_buf->size() < end )\n        {\n            helper->m_buf->resize(end);\n        }\n        memcpy(&(*helper->m_buf)[begin], buffer, n);\n        helper->m_buf_pos = end;\n        return n;\n    }\n\n    static toff_t seek( thandle_t handle, toff_t offset, int whence )\n    {\n        TiffEncoderBufHelper *helper = reinterpret_cast<TiffEncoderBufHelper*>(handle);\n        const toff_t size = helper->m_buf->size();\n        toff_t new_pos = helper->m_buf_pos;\n        switch (whence)\n        {\n            case SEEK_SET:\n                new_pos = offset;\n                break;\n            case SEEK_CUR:\n                new_pos += offset;\n                break;\n            case SEEK_END:\n                new_pos = size + offset;\n                break;\n        }\n        helper->m_buf_pos = new_pos;\n        return new_pos;\n    }\n\n    static toff_t size( thandle_t handle )\n    {\n        TiffEncoderBufHelper *helper = reinterpret_cast<TiffEncoderBufHelper*>(handle);\n        return helper->m_buf->size();\n    }\n\n    static int close( thandle_t /*handle*/ )\n    {\n        // Do nothing.\n        return 0;\n    }\n\nprivate:\n\n    std::vector<uchar>* m_buf;\n    toff_t m_buf_pos;\n};\n\nstatic void readParam(const std::vector<int>& params, int key, int& value)\n{\n    for(size_t i = 0; i + 1 < params.size(); i += 2)\n        if(params[i] == key)\n        {\n            value = params[i+1];\n            break;\n        }\n}\n\nbool  TiffEncoder::writeLibTiff( const Mat& img, const std::vector<int>& params)\n{\n    int channels = img.channels();\n    int width = img.cols, height = img.rows;\n    int depth = img.depth();\n\n    int bitsPerChannel = -1;\n    switch (depth)\n    {\n        case CV_8U:\n        {\n            bitsPerChannel = 8;\n            break;\n        }\n        case CV_16U:\n        {\n            bitsPerChannel = 16;\n            break;\n        }\n        default:\n        {\n            return false;\n        }\n    }\n\n    const int bitsPerByte = 8;\n    size_t fileStep = (width * channels * bitsPerChannel) / bitsPerByte;\n\n    int rowsPerStrip = (int)((1 << 13)/fileStep);\n    readParam(params, TIFFTAG_ROWSPERSTRIP, rowsPerStrip);\n\n    if( rowsPerStrip < 1 )\n        rowsPerStrip = 1;\n\n    if( rowsPerStrip > height )\n        rowsPerStrip = height;\n\n\n    // do NOT put \"wb\" as the mode, because the b means \"big endian\" mode, not \"binary\" mode.\n    // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n    TIFF* pTiffHandle;\n\n    TiffEncoderBufHelper buf_helper(m_buf);\n    if ( m_buf )\n    {\n        pTiffHandle = buf_helper.open();\n    }\n    else\n    {\n        pTiffHandle = TIFFOpen(m_filename.c_str(), \"w\");\n    }\n    if (!pTiffHandle)\n    {\n        return false;\n    }\n\n    // defaults for now, maybe base them on params in the future\n    int   compression  = COMPRESSION_LZW;\n    int   predictor    = PREDICTOR_HORIZONTAL;\n\n    readParam(params, TIFFTAG_COMPRESSION, compression);\n    readParam(params, TIFFTAG_PREDICTOR, predictor);\n\n    int   colorspace = channels > 1 ? PHOTOMETRIC_RGB : PHOTOMETRIC_MINISBLACK;\n\n    if ( !TIFFSetField(pTiffHandle, TIFFTAG_IMAGEWIDTH, width)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_IMAGELENGTH, height)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_BITSPERSAMPLE, bitsPerChannel)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_COMPRESSION, compression)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_PHOTOMETRIC, colorspace)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_SAMPLESPERPIXEL, channels)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_ROWSPERSTRIP, rowsPerStrip)\n       )\n    {\n        TIFFClose(pTiffHandle);\n        return false;\n    }\n\n    if (compression != COMPRESSION_NONE && !TIFFSetField(pTiffHandle, TIFFTAG_PREDICTOR, predictor) )\n    {\n        TIFFClose(pTiffHandle);\n        return false;\n    }\n\n    // row buffer, because TIFFWriteScanline modifies the original data!\n    size_t scanlineSize = TIFFScanlineSize(pTiffHandle);\n    AutoBuffer<uchar> _buffer(scanlineSize+32);\n    uchar* buffer = _buffer;\n    if (!buffer)\n    {\n        TIFFClose(pTiffHandle);\n        return false;\n    }\n\n    for (int y = 0; y < height; ++y)\n    {\n        switch(channels)\n        {\n            case 1:\n            {\n                memcpy(buffer, img.ptr(y), scanlineSize);\n                break;\n            }\n\n            case 3:\n            {\n                if (depth == CV_8U)\n                    icvCvt_BGR2RGB_8u_C3R( img.ptr(y), 0, buffer, 0, cvSize(width,1) );\n                else\n                    icvCvt_BGR2RGB_16u_C3R( img.ptr<ushort>(y), 0, (ushort*)buffer, 0, cvSize(width,1) );\n                break;\n            }\n\n            case 4:\n            {\n                if (depth == CV_8U)\n                    icvCvt_BGRA2RGBA_8u_C4R( img.ptr(y), 0, buffer, 0, cvSize(width,1) );\n                else\n                    icvCvt_BGRA2RGBA_16u_C4R( img.ptr<ushort>(y), 0, (ushort*)buffer, 0, cvSize(width,1) );\n                break;\n            }\n\n            default:\n            {\n                TIFFClose(pTiffHandle);\n                return false;\n            }\n        }\n\n        int writeResult = TIFFWriteScanline(pTiffHandle, buffer, y, 0);\n        if (writeResult != 1)\n        {\n            TIFFClose(pTiffHandle);\n            return false;\n        }\n    }\n\n    TIFFClose(pTiffHandle);\n    return true;\n}\n\nbool TiffEncoder::writeHdr(const Mat& _img)\n{\n    Mat img;\n    cvtColor(_img, img, COLOR_BGR2XYZ);\n\n    TIFF* tif;\n\n    TiffEncoderBufHelper buf_helper(m_buf);\n    if ( m_buf )\n    {\n        tif = buf_helper.open();\n    }\n    else\n    {\n        tif = TIFFOpen(m_filename.c_str(), \"w\");\n    }\n\n    if (!tif)\n    {\n        return false;\n    }\n    TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, img.cols);\n    TIFFSetField(tif, TIFFTAG_IMAGELENGTH, img.rows);\n    TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 3);\n    TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_SGILOG);\n    TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_LOGLUV);\n    TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    TIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_FLOAT);\n    TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, 1);\n    int strip_size = 3 * img.cols;\n    float *ptr = const_cast<float*>(img.ptr<float>());\n    for (int i = 0; i < img.rows; i++, ptr += strip_size)\n    {\n        TIFFWriteEncodedStrip(tif, i, ptr, strip_size * sizeof(float));\n    }\n    TIFFClose(tif);\n    return true;\n}\n\nbool  TiffEncoder::write( const Mat& img, const std::vector<int>& params)\n{\n    int depth = img.depth();\n\n    if(img.type() == CV_32FC3)\n    {\n        return writeHdr(img); // TODO Rename\n    }\n\n    CV_Assert(depth == CV_8U || depth == CV_16U);\n\n    return writeLibTiff(img, params);\n}\n\n} // namespace\n\n#endif\n",
                "name": "grfmt_tiff.cpp",
                "path": "CVE/CVE-2017-17760/project_code/opencv/modules/imgcodecs/src/grfmt_tiff.cpp",
                "url": "/github.com/elManto/SAST_on_Decompilers/-/blob/CVE/CVE-2017-17760/project_code/opencv/modules/imgcodecs/src/grfmt_tiff.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 379,
                    "offsetAndLengths": [
                        [
                            37,
                            16
                        ]
                    ],
                    "preview": "                                ok = TIFFReadRGBATile( tif, x, y, (uint32*)buffer );"
                }
            ],
            "repository": {
                "name": "github.com/elManto/SAST_on_Decompilers",
                "url": "/github.com/elManto/SAST_on_Decompilers"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "7b7c5e98f82c82571cd1d0f306cecf05452315d5"
                },
                "content": "/******************************************************************************\n * $Id: geotiff.cpp 22001 2011-03-21 00:33:18Z rouault $\n *\n * Project:  GeoTIFF Driver\n * Purpose:  GDAL GeoTIFF support.\n * Author:   Frank Warmerdam, warmerdam@pobox.com\n *\n ******************************************************************************\n * Copyright (c) 1998, 2002, Frank Warmerdam <warmerdam@pobox.com>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n ****************************************************************************/\n\n/* If we use sunpro compiler on linux. Weird idea indeed ! */\n#if defined(__SUNPRO_CC) && defined(__linux__)\n#define _GNU_SOURCE\n#endif\n\n#include \"gdal_pam.h\"\n#define CPL_SERV_H_INCLUDED\n\n#include \"xtiffio.h\"\n#include \"geovalues.h\"\n#include \"cpl_string.h\"\n#include \"cpl_csv.h\"\n#include \"cpl_minixml.h\"\n#include \"gt_overview.h\"\n#include \"ogr_spatialref.h\"\n#include \"tif_float.h\"\n#include \"gtiff.h\"\n#include \"gdal_csv.h\"\n#include \"gt_wkt_srs.h\"\n#include \"tifvsi.h\"\n#include \"cpl_multiproc.h\"\n\nCPL_CVSID(\"$Id: geotiff.cpp 22001 2011-03-21 00:33:18Z rouault $\");\n\n/************************************************************************/\n/* ==================================================================== */\n/*                                GDALOverviewDS                        */\n/* ==================================================================== */\n/************************************************************************/\n\n/* GDALOverviewDS is not specific to GTiff and could probably be moved */\n/* in gcore. It is currently used to generate a fake */\n/* dataset from the overview levels of the source dataset that is taken */\n/* by CreateCopy() */\n\n#include \"gdal_proxy.h\"\n\nclass GDALOverviewBand;\n\nclass GDALOverviewDS : public GDALDataset\n{\n    private:\n\n        friend class GDALOverviewBand;\n\n        GDALDataset* poDS;\n        GDALDataset* poOvrDS;\n        int          nOvrLevel;\n\n    public:\n                        GDALOverviewDS(GDALDataset* poDS, int nOvrLevel);\n        virtual        ~GDALOverviewDS();\n\n        virtual char  **GetMetadata( const char * pszDomain = \"\" );\n        virtual const char *GetMetadataItem( const char * pszName,\n                                             const char * pszDomain = \"\" );\n};\n\nclass GDALOverviewBand : public GDALProxyRasterBand\n{\n    protected:\n        GDALRasterBand*         poUnderlyingBand;\n        virtual GDALRasterBand* RefUnderlyingRasterBand();\n\n    public:\n                    GDALOverviewBand(GDALOverviewDS* poDS, int nBand);\n        virtual    ~GDALOverviewBand();\n};\n\nGDALOverviewDS::GDALOverviewDS(GDALDataset* poDS, int nOvrLevel)\n{\n    this->poDS = poDS;\n    this->nOvrLevel = nOvrLevel;\n    eAccess = poDS->GetAccess();\n    nRasterXSize = poDS->GetRasterBand(1)->GetOverview(nOvrLevel)->GetXSize();\n    nRasterYSize = poDS->GetRasterBand(1)->GetOverview(nOvrLevel)->GetYSize();\n    poOvrDS = poDS->GetRasterBand(1)->GetOverview(nOvrLevel)->GetDataset();\n    nBands = poDS->GetRasterCount();\n    int i;\n    for(i=0;i<nBands;i++)\n        SetBand(i+1, new GDALOverviewBand(this, i+1));\n}\n\nGDALOverviewDS::~GDALOverviewDS()\n{\n    FlushCache();\n}\n\nchar  **GDALOverviewDS::GetMetadata( const char * pszDomain )\n{\n    if (poOvrDS != NULL)\n        return poOvrDS->GetMetadata(pszDomain);\n\n    return poDS->GetMetadata(pszDomain);\n}\n\nconst char *GDALOverviewDS::GetMetadataItem( const char * pszName, const char * pszDomain )\n{\n    if (poOvrDS != NULL)\n        return poOvrDS->GetMetadataItem(pszName, pszDomain);\n\n    return poDS->GetMetadataItem(pszName, pszDomain);\n}\n\nGDALOverviewBand::GDALOverviewBand(GDALOverviewDS* poDS, int nBand)\n{\n    this->poDS = poDS;\n    this->nBand = nBand;\n    poUnderlyingBand = poDS->poDS->GetRasterBand(nBand)->GetOverview(poDS->nOvrLevel);\n    nRasterXSize = poDS->nRasterXSize;\n    nRasterYSize = poDS->nRasterYSize;\n    eDataType = poUnderlyingBand->GetRasterDataType();\n    poUnderlyingBand->GetBlockSize(&nBlockXSize, &nBlockYSize);\n}\n\nGDALOverviewBand::~GDALOverviewBand()\n{\n    FlushCache();\n}\n\nGDALRasterBand* GDALOverviewBand::RefUnderlyingRasterBand()\n{\n    return poUnderlyingBand;\n}\n\n/************************************************************************/\n/*                            IsPowerOfTwo()                            */\n/************************************************************************/\n\nstatic int IsPowerOfTwo(unsigned int i)\n{\n    int nBitSet = 0;\n    while(i != 0)\n    {\n        if ((i & 1))\n            nBitSet ++;\n        i >>= 1;\n    }\n    return nBitSet == 1;\n}\n\n/************************************************************************/\n/*                     GTIFFGetOverviewBlockSize()                      */\n/************************************************************************/\n\nvoid GTIFFGetOverviewBlockSize(int* pnBlockXSize, int* pnBlockYSize)\n{\n    static int bHasWarned = FALSE;\n    const char* pszVal = CPLGetConfigOption(\"GDAL_TIFF_OVR_BLOCKSIZE\", \"128\");\n    int nOvrBlockSize = atoi(pszVal);\n    if (nOvrBlockSize < 64 || nOvrBlockSize > 4096 ||\n        !IsPowerOfTwo(nOvrBlockSize))\n    {\n        if (!bHasWarned)\n        {\n            CPLError(CE_Warning, CPLE_NotSupported,\n                    \"Wrong value for GDAL_TIFF_OVR_BLOCKSIZE : %s. \"\n                    \"Should be a power of 2 between 64 and 4096. Defaulting to 128\",\n                    pszVal);\n            bHasWarned = TRUE;\n        }\n        nOvrBlockSize = 128;\n    }\n\n    *pnBlockXSize = nOvrBlockSize;\n    *pnBlockYSize = nOvrBlockSize;\n}\n\nenum\n{\n    ENDIANNESS_NATIVE,\n    ENDIANNESS_LITTLE,\n    ENDIANNESS_BIG\n};\n\n/************************************************************************/\n/* ==================================================================== */\n/*\t\t\t\tGTiffDataset\t\t\t\t*/\n/* ==================================================================== */\n/************************************************************************/\n\nclass GTiffRasterBand;\nclass GTiffRGBABand;\nclass GTiffBitmapBand;\n\nclass GTiffDataset : public GDALPamDataset\n{\n    friend class GTiffRasterBand;\n    friend class GTiffSplitBand;\n    friend class GTiffRGBABand;\n    friend class GTiffBitmapBand;\n    friend class GTiffSplitBitmapBand;\n    friend class GTiffOddBitsBand;\n\n    friend void    GTIFFSetJpegQuality(GDALDatasetH hGTIFFDS, int nJpegQuality);\n    \n    TIFF\t*hTIFF;\n    GTiffDataset **ppoActiveDSRef;\n    GTiffDataset *poActiveDS; /* only used in actual base */\n\n    toff_t      nDirOffset;\n    int\t\tbBase;\n    int         bCloseTIFFHandle; /* usefull for closing TIFF handle opened by GTIFF_DIR: */\n\n    uint16\tnPlanarConfig;\n    uint16\tnSamplesPerPixel;\n    uint16\tnBitsPerSample;\n    uint32\tnRowsPerStrip;\n    uint16\tnPhotometric;\n    uint16      nSampleFormat;\n    uint16      nCompression;\n    \n    int\t\tnBlocksPerBand;\n\n    uint32      nBlockXSize;\n    uint32\tnBlockYSize;\n\n    int\t\tnLoadedBlock;\t\t/* or tile */\n    int         bLoadedBlockDirty;  \n    GByte\t*pabyBlockBuf;\n\n    CPLErr      LoadBlockBuf( int nBlockId, int bReadFromDisk = TRUE );\n    CPLErr      FlushBlockBuf();\n    int         bWriteErrorInFlushBlockBuf;\n\n    char\t*pszProjection;\n    int         bLookedForProjection;\n\n    void        LookForProjection();\n#ifdef ESRI_BUILD\n    void        AdjustLinearUnit( short UOMLength );\n#endif\n\n    double\tadfGeoTransform[6];\n    int\t\tbGeoTransformValid;\n\n    int         bTreatAsRGBA;\n    int         bCrystalized;\n\n    void\tCrystalize();\n\n    GDALColorTable *poColorTable;\n\n    void\tWriteGeoTIFFInfo();\n    int\t\tSetDirectory( toff_t nDirOffset = 0 );\n\n    int\t\tnOverviewCount;\n    GTiffDataset **papoOverviewDS;\n\n    int\t\tnGCPCount;\n    GDAL_GCP\t*pasGCPList;\n\n    int         IsBlockAvailable( int nBlockId );\n\n    int         bGeoTIFFInfoChanged;\n    int         bNoDataSet;\n    double      dfNoDataValue;\n\n    int\t        bMetadataChanged;\n\n    int         bNeedsRewrite;\n\n    void        ApplyPamInfo();\n    void        PushMetadataToPam();\n\n    GDALMultiDomainMetadata oGTiffMDMD;\n\n    CPLString   osProfile;\n    char      **papszCreationOptions;\n\n    int         bLoadingOtherBands;\n\n    static void WriteRPCTag( TIFF *, char ** );\n    void        ReadRPCTag();\n\n    void*        pabyTempWriteBuffer;\n    int          nTempWriteBufferSize;\n    int          WriteEncodedTile(uint32 tile, void* data, int bPreserveDataBuffer);\n    int          WriteEncodedStrip(uint32 strip, void* data, int bPreserveDataBuffer);\n\n    GTiffDataset* poMaskDS;\n    GTiffDataset* poBaseDS;\n\n    CPLString    osFilename;\n\n    int          bFillEmptyTiles;\n    void         FillEmptyTiles(void);\n\n    void         FlushDirectory();\n    CPLErr       CleanOverviews();\n\n    /* Used for the all-in-on-strip case */\n    int           nLastLineRead;\n    int           nLastBandRead;\n    int           bTreatAsSplit;\n    int           bTreatAsSplitBitmap;\n\n    int           bClipWarn;\n\n    CPLString     osRPBFile;\n    int           FindRPBFile();\n    CPLString     osRPCFile;\n    int           FindRPCFile();\n    CPLString     osIMDFile;\n    int           FindIMDFile();\n    int           bHasSearchedRPC;\n    void          LoadRPCRPB();\n    int           bHasSearchedIMD;\n    void          LoadIMD();\n\n    int           bHasWarnedDisableAggressiveBandCaching;\n\n    int           bDontReloadFirstBlock; /* Hack for libtiff 3.X and #3633 */\n\n    int           nZLevel;\n    int           nLZMAPreset;\n    int           nJpegQuality;\n    \n    int           bPromoteTo8Bits;\n\n    int           bDebugDontWriteBlocks;\n\n    CPLErr        RegisterNewOverviewDataset(toff_t nOverviewOffset);\n    CPLErr        CreateOverviewsFromSrcOverviews(GDALDataset* poSrcDS);\n    CPLErr        CreateInternalMaskOverviews(int nOvrBlockXSize,\n                                              int nOvrBlockYSize);\n\n    int           bIsFinalized;\n    int           Finalize();\n\n    int           bIgnoreReadErrors;\n\n    CPLString     osWldFilename;\n\n  protected:\n    virtual int         CloseDependentDatasets();\n\n  public:\n                 GTiffDataset();\n                 ~GTiffDataset();\n\n    virtual const char *GetProjectionRef(void);\n    virtual CPLErr SetProjection( const char * );\n    virtual CPLErr GetGeoTransform( double * );\n    virtual CPLErr SetGeoTransform( double * );\n\n    virtual int    GetGCPCount();\n    virtual const char *GetGCPProjection();\n    virtual const GDAL_GCP *GetGCPs();\n    CPLErr         SetGCPs( int, const GDAL_GCP *, const char * );\n\n    virtual char **GetFileList(void);\n\n    virtual CPLErr IBuildOverviews( const char *, int, int *, int, int *, \n                                    GDALProgressFunc, void * );\n\n    CPLErr\t   OpenOffset( TIFF *, GTiffDataset **ppoActiveDSRef, \n                               toff_t nDirOffset, int bBaseIn, GDALAccess, \n                               int bAllowRGBAInterface = TRUE, int bReadGeoTransform = FALSE,\n                               char** papszSiblingFiles = NULL);\n\n    static GDALDataset *OpenDir( GDALOpenInfo * );\n    static GDALDataset *Open( GDALOpenInfo * );\n    static int          Identify( GDALOpenInfo * );\n    static GDALDataset *Create( const char * pszFilename,\n                                int nXSize, int nYSize, int nBands,\n                                GDALDataType eType, char ** papszParmList );\n    static GDALDataset *CreateCopy( const char * pszFilename, \n                                    GDALDataset *poSrcDS, \n                                    int bStrict, char ** papszOptions, \n                                    GDALProgressFunc pfnProgress, \n                                    void * pProgressData );\n    virtual void    FlushCache( void );\n\n    virtual CPLErr  SetMetadata( char **, const char * = \"\" );\n    virtual char  **GetMetadata( const char * pszDomain = \"\" );\n    virtual CPLErr  SetMetadataItem( const char*, const char*, \n                                     const char* = \"\" );\n    virtual const char *GetMetadataItem( const char * pszName,\n                                         const char * pszDomain = \"\" );\n    virtual void   *GetInternalHandle( const char * );\n\n    virtual CPLErr          CreateMaskBand( int nFlags );\n\n    // only needed by createcopy and close code.\n    static int\t    WriteMetadata( GDALDataset *, TIFF *, int, const char *,\n                                   const char *, char **, int bExcludeRPBandIMGFileWriting = FALSE );\n    static void\t    WriteNoDataValue( TIFF *, double );\n\n    static TIFF *   CreateLL( const char * pszFilename,\n                              int nXSize, int nYSize, int nBands,\n                              GDALDataType eType,\n                              double dfExtraSpaceForOverviews,\n                              char **papszParmList );\n\n    CPLErr   WriteEncodedTileOrStrip(uint32 tile_or_strip, void* data, int bPreserveDataBuffer);\n};\n\n/************************************************************************/\n/*                        GTIFFSetJpegQuality()                         */\n/* Called by GTIFFBuildOverviews() to set the jpeg quality on the IFD   */\n/* of the .ovr file                                                     */\n/************************************************************************/\n\nvoid    GTIFFSetJpegQuality(GDALDatasetH hGTIFFDS, int nJpegQuality)\n{\n    CPLAssert(EQUAL(GDALGetDriverShortName(GDALGetDatasetDriver(hGTIFFDS)), \"GTIFF\"));\n\n    GTiffDataset* poDS = (GTiffDataset*)hGTIFFDS;\n    poDS->nJpegQuality = nJpegQuality;\n    int i;\n    for(i=0;i<poDS->nOverviewCount;i++)\n        poDS->papoOverviewDS[i]->nJpegQuality = nJpegQuality;\n}\n\n/************************************************************************/\n/* ==================================================================== */\n/*                            GTiffRasterBand                           */\n/* ==================================================================== */\n/************************************************************************/\n\nclass GTiffRasterBand : public GDALPamRasterBand\n{\n    friend class GTiffDataset;\n\n    GDALColorInterp    eBandInterp;\n\n    int                bHaveOffsetScale;\n    double             dfOffset;\n    double             dfScale;\n    CPLString          osUnitType;\n\nprotected:\n    GTiffDataset       *poGDS;\n    GDALMultiDomainMetadata oGTiffMDMD;\n\n    int                bNoDataSet;\n    double             dfNoDataValue;\n\n    void NullBlock( void *pData );\n\npublic:\n                   GTiffRasterBand( GTiffDataset *, int );\n\n    virtual CPLErr IReadBlock( int, int, void * );\n    virtual CPLErr IWriteBlock( int, int, void * );\n\n    virtual CPLErr IRasterIO( GDALRWFlag eRWFlag,\n                                  int nXOff, int nYOff, int nXSize, int nYSize,\n                                  void * pData, int nBufXSize, int nBufYSize,\n                                  GDALDataType eBufType,\n                                  int nPixelSpace, int nLineSpace );\n\n    virtual GDALColorInterp GetColorInterpretation();\n    virtual GDALColorTable *GetColorTable();\n    virtual CPLErr          SetColorTable( GDALColorTable * );\n    virtual double\t    GetNoDataValue( int * );\n    virtual CPLErr\t    SetNoDataValue( double );\n\n    virtual double GetOffset( int *pbSuccess = NULL );\n    virtual CPLErr SetOffset( double dfNewValue );\n    virtual double GetScale( int *pbSuccess = NULL );\n    virtual CPLErr SetScale( double dfNewValue );\n    virtual const char* GetUnitType();\n    virtual CPLErr SetUnitType( const char *pszNewValue );\n    virtual CPLErr SetColorInterpretation( GDALColorInterp );\n\n    virtual CPLErr  SetMetadata( char **, const char * = \"\" );\n    virtual char  **GetMetadata( const char * pszDomain = \"\" );\n    virtual CPLErr  SetMetadataItem( const char*, const char*, \n                                     const char* = \"\" );\n    virtual const char *GetMetadataItem( const char * pszName,\n                                         const char * pszDomain = \"\" );\n    virtual int    GetOverviewCount();\n    virtual GDALRasterBand *GetOverview( int );\n\n    virtual GDALRasterBand *GetMaskBand();\n    virtual int             GetMaskFlags();\n    virtual CPLErr          CreateMaskBand( int nFlags );\n};\n\n/************************************************************************/\n/*                           GTiffRasterBand()                          */\n/************************************************************************/\n\nGTiffRasterBand::GTiffRasterBand( GTiffDataset *poDS, int nBand )\n\n{\n    poGDS = poDS;\n\n    this->poDS = poDS;\n    this->nBand = nBand;\n\n    bHaveOffsetScale = FALSE;\n    dfOffset = 0.0;\n    dfScale = 1.0;\n\n/* -------------------------------------------------------------------- */\n/*      Get the GDAL data type.                                         */\n/* -------------------------------------------------------------------- */\n    uint16\t\tnSampleFormat = poDS->nSampleFormat;\n\n    eDataType = GDT_Unknown;\n\n    if( poDS->nBitsPerSample <= 8 )\n    {\n        eDataType = GDT_Byte;\n        if( nSampleFormat == SAMPLEFORMAT_INT )\n            SetMetadataItem( \"PIXELTYPE\", \"SIGNEDBYTE\", \"IMAGE_STRUCTURE\" );\n            \n    }\n    else if( poDS->nBitsPerSample <= 16 )\n    {\n        if( nSampleFormat == SAMPLEFORMAT_INT )\n            eDataType = GDT_Int16;\n        else\n            eDataType = GDT_UInt16;\n    }\n    else if( poDS->nBitsPerSample == 32 )\n    {\n        if( nSampleFormat == SAMPLEFORMAT_COMPLEXINT )\n            eDataType = GDT_CInt16;\n        else if( nSampleFormat == SAMPLEFORMAT_IEEEFP )\n            eDataType = GDT_Float32;\n        else if( nSampleFormat == SAMPLEFORMAT_INT )\n            eDataType = GDT_Int32;\n        else\n            eDataType = GDT_UInt32;\n    }\n    else if( poDS->nBitsPerSample == 64 )\n    {\n        if( nSampleFormat == SAMPLEFORMAT_IEEEFP )\n            eDataType = GDT_Float64;\n        else if( nSampleFormat == SAMPLEFORMAT_COMPLEXIEEEFP )\n            eDataType = GDT_CFloat32;\n        else if( nSampleFormat == SAMPLEFORMAT_COMPLEXINT )\n            eDataType = GDT_CInt32;\n    }\n    else if( poDS->nBitsPerSample == 128 )\n    {\n        if( nSampleFormat == SAMPLEFORMAT_COMPLEXIEEEFP )\n            eDataType = GDT_CFloat64;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Try to work out band color interpretation.                      */\n/* -------------------------------------------------------------------- */\n    if( poDS->poColorTable != NULL && nBand == 1 ) \n        eBandInterp = GCI_PaletteIndex;\n    else if( poDS->nPhotometric == PHOTOMETRIC_RGB \n             || (poDS->nPhotometric == PHOTOMETRIC_YCBCR \n                 && poDS->nCompression == COMPRESSION_JPEG \n                 && CSLTestBoolean( CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\",\n                                                       \"YES\") )) )\n    {\n        if( nBand == 1 )\n            eBandInterp = GCI_RedBand;\n        else if( nBand == 2 )\n            eBandInterp = GCI_GreenBand;\n        else if( nBand == 3 )\n            eBandInterp = GCI_BlueBand;\n        else\n        {\n            uint16 *v;\n            uint16 count = 0;\n\n            if( TIFFGetField( poDS->hTIFF, TIFFTAG_EXTRASAMPLES, &count, &v) )\n            {\n                if( nBand - 3 <= count && v[nBand-4] == EXTRASAMPLE_ASSOCALPHA )\n                    eBandInterp = GCI_AlphaBand;\n                else\n                    eBandInterp = GCI_Undefined;\n            }\n            else if( nBand == 4 )\n                eBandInterp = GCI_AlphaBand;\n            else\n                eBandInterp = GCI_Undefined;\n        }\n    }\n    else if( poDS->nPhotometric == PHOTOMETRIC_YCBCR )\n    {\n        if( nBand == 1 )\n            eBandInterp = GCI_YCbCr_YBand;\n        else if( nBand == 2 )\n            eBandInterp = GCI_YCbCr_CbBand;\n        else if( nBand == 3 )\n            eBandInterp = GCI_YCbCr_CrBand;\n        else\n        {\n            uint16 *v;\n            uint16 count = 0;\n\n            if( TIFFGetField( poDS->hTIFF, TIFFTAG_EXTRASAMPLES, &count, &v) )\n            {\n                if( nBand - 3 <= count && v[nBand-4] == EXTRASAMPLE_ASSOCALPHA )\n                    eBandInterp = GCI_AlphaBand;\n                else\n                    eBandInterp = GCI_Undefined;\n            }\n            else if( nBand == 4 )\n                eBandInterp = GCI_AlphaBand;\n            else\n                eBandInterp = GCI_Undefined;\n        }\n    }\n    else if( poDS->nPhotometric == PHOTOMETRIC_SEPARATED )\n    {\n        if( nBand == 1 )\n            eBandInterp = GCI_CyanBand;\n        else if( nBand == 2 )\n            eBandInterp = GCI_MagentaBand;\n        else if( nBand == 3 )\n            eBandInterp = GCI_YellowBand;\n        else\n            eBandInterp = GCI_BlackBand;\n    }\n    else if( poDS->nPhotometric == PHOTOMETRIC_MINISBLACK && nBand == 1 )\n        eBandInterp = GCI_GrayIndex;\n    else\n    {\n        uint16 *v;\n        uint16 count = 0;\n\n        if( TIFFGetField( poDS->hTIFF, TIFFTAG_EXTRASAMPLES, &count, &v ) )\n        {\n            int nBaseSamples;\n            nBaseSamples = poDS->nSamplesPerPixel - count;\n\n            if( nBand > nBaseSamples \n                && v[nBand-nBaseSamples-1] == EXTRASAMPLE_ASSOCALPHA )\n                eBandInterp = GCI_AlphaBand;\n            else\n                eBandInterp = GCI_Undefined;\n        }\n        else\n            eBandInterp = GCI_Undefined;\n    }\n\n/* -------------------------------------------------------------------- */\n/*\tEstablish block size for strip or tiles.\t\t\t*/\n/* -------------------------------------------------------------------- */\n    nBlockXSize = poDS->nBlockXSize;\n    nBlockYSize = poDS->nBlockYSize;\n\n    bNoDataSet = FALSE;\n    dfNoDataValue = -9999.0;\n}\n\n/************************************************************************/\n/*                            IRasterIO()                               */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::IRasterIO( GDALRWFlag eRWFlag,\n                                  int nXOff, int nYOff, int nXSize, int nYSize,\n                                  void * pData, int nBufXSize, int nBufYSize,\n                                  GDALDataType eBufType,\n                                  int nPixelSpace, int nLineSpace )\n{\n    CPLErr eErr;\n\n    if (poGDS->nBands != 1 &&\n        poGDS->nPlanarConfig == PLANARCONFIG_CONTIG &&\n        eRWFlag == GF_Read &&\n        nXSize == nBufXSize && nYSize == nBufYSize)\n    {\n        int nBlockX1 = nXOff / nBlockXSize;\n        int nBlockY1 = nYOff / nBlockYSize;\n        int nBlockX2 = (nXOff + nXSize - 1) / nBlockXSize;\n        int nBlockY2 = (nYOff + nYSize - 1) / nBlockYSize;\n        int nXBlocks = nBlockX2 - nBlockX1 + 1;\n        int nYBlocks = nBlockY2 - nBlockY1 + 1;\n        GIntBig nRequiredMem = (GIntBig)poGDS->nBands * nXBlocks * nYBlocks *\n                                nBlockXSize * nBlockYSize *\n                               (GDALGetDataTypeSize(eDataType) / 8);\n        if (nRequiredMem > GDALGetCacheMax64())\n        {\n            if (!poGDS->bHasWarnedDisableAggressiveBandCaching)\n            {\n                CPLDebug(\"GTiff\", \"Disable aggressive band caching. Cache not big enough. \"\n                         \"At least \" CPL_FRMT_GIB \" bytes necessary\", nRequiredMem);\n                poGDS->bHasWarnedDisableAggressiveBandCaching = TRUE;\n            }\n            poGDS->bLoadingOtherBands = TRUE;\n        }\n    }\n\n    eErr = GDALPamRasterBand::IRasterIO(eRWFlag, nXOff, nYOff, nXSize, nYSize,\n                                        pData, nBufXSize, nBufYSize, eBufType,\n                                        nPixelSpace, nLineSpace);\n\n    poGDS->bLoadingOtherBands = FALSE;\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                             IReadBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::IReadBlock( int nBlockXOff, int nBlockYOff,\n                                    void * pImage )\n\n{\n    int\t\t\tnBlockBufSize, nBlockId, nBlockIdBand0;\n    CPLErr\t\teErr = CE_None;\n\n    if (!poGDS->SetDirectory())\n        return CE_Failure;\n\n    if( TIFFIsTiled(poGDS->hTIFF) )\n        nBlockBufSize = TIFFTileSize( poGDS->hTIFF );\n    else\n    {\n        CPLAssert( nBlockXOff == 0 );\n        nBlockBufSize = TIFFStripSize( poGDS->hTIFF );\n    }\n\n    CPLAssert(nBlocksPerRow != 0);\n    nBlockIdBand0 = nBlockXOff + nBlockYOff * nBlocksPerRow;\n    if( poGDS->nPlanarConfig == PLANARCONFIG_SEPARATE )\n        nBlockId = nBlockIdBand0 + (nBand-1) * poGDS->nBlocksPerBand;\n    else\n        nBlockId = nBlockIdBand0;\n        \n/* -------------------------------------------------------------------- */\n/*      The bottom most partial tiles and strips are sometimes only     */\n/*      partially encoded.  This code reduces the requested data so     */\n/*      an error won't be reported in this case. (#1179)                */\n/* -------------------------------------------------------------------- */\n    int nBlockReqSize = nBlockBufSize;\n\n    if( (nBlockYOff+1) * nBlockYSize > nRasterYSize )\n    {\n        nBlockReqSize = (nBlockBufSize / nBlockYSize) \n            * (nBlockYSize - (((nBlockYOff+1) * nBlockYSize) % nRasterYSize));\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Handle the case of a strip or tile that doesn't exist yet.      */\n/*      Just set to zeros and return.                                   */\n/* -------------------------------------------------------------------- */\n    if( !poGDS->IsBlockAvailable(nBlockId) )\n    {\n        NullBlock( pImage );\n        return CE_None;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Handle simple case (separate, onesampleperpixel)\t\t*/\n/* -------------------------------------------------------------------- */\n    if( poGDS->nBands == 1\n        || poGDS->nPlanarConfig == PLANARCONFIG_SEPARATE )\n    {\n        if( nBlockReqSize < nBlockBufSize )\n            memset( pImage, 0, nBlockBufSize );\n\n        if( TIFFIsTiled( poGDS->hTIFF ) )\n        {\n            if( TIFFReadEncodedTile( poGDS->hTIFF, nBlockId, pImage,\n                                     nBlockReqSize ) == -1\n                && !poGDS->bIgnoreReadErrors )\n            {\n                memset( pImage, 0, nBlockBufSize );\n                CPLError( CE_Failure, CPLE_AppDefined,\n                          \"TIFFReadEncodedTile() failed.\\n\" );\n                \n                eErr = CE_Failure;\n            }\n        }\n        else\n        {\n            if( TIFFReadEncodedStrip( poGDS->hTIFF, nBlockId, pImage,\n                                      nBlockReqSize ) == -1\n                && !poGDS->bIgnoreReadErrors )\n            {\n                memset( pImage, 0, nBlockBufSize );\n                CPLError( CE_Failure, CPLE_AppDefined,\n                        \"TIFFReadEncodedStrip() failed.\\n\" );\n\n                eErr = CE_Failure;\n            }\n        }\n\n        return eErr;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Load desired block                                              */\n/* -------------------------------------------------------------------- */\n    eErr = poGDS->LoadBlockBuf( nBlockId );\n    if( eErr != CE_None )\n    {\n        memset( pImage, 0,\n                nBlockXSize * nBlockYSize\n                * (GDALGetDataTypeSize(eDataType) / 8) );\n        return eErr;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Special case for YCbCr subsampled data.                         */\n/* -------------------------------------------------------------------- */\n#ifdef notdef\n    if( (eBandInterp == GCI_YCbCr_YBand \n         || eBandInterp == GCI_YCbCr_CbBand\n         ||  eBandInterp == GCI_YCbCr_CrBand)\n        && poGDS->nBitsPerSample == 8 )\n    {\n\tuint16 hs, vs;\n        int iX, iY;\n\n\tTIFFGetFieldDefaulted( poGDS->hTIFF, TIFFTAG_YCBCRSUBSAMPLING, \n                               &hs, &vs);\n        \n        for( iY = 0; iY < nBlockYSize; iY++ )\n        {\n            for( iX = 0; iX < nBlockXSize; iX++ )\n            {\n                int iBlock = (iY / vs) * (nBlockXSize/hs) + (iX / hs);\n                GByte *pabySrcBlock = poGDS->pabyBlockBuf + \n                    (vs * hs + 2) * iBlock;\n                \n                if( eBandInterp == GCI_YCbCr_YBand )\n                    ((GByte *)pImage)[iY*nBlockXSize + iX] = \n                        pabySrcBlock[(iX % hs) + (iY % vs) * hs];\n                else if( eBandInterp == GCI_YCbCr_CbBand )\n                    ((GByte *)pImage)[iY*nBlockXSize + iX] = \n                        pabySrcBlock[vs * hs + 0];\n                else if( eBandInterp == GCI_YCbCr_CrBand )\n                    ((GByte *)pImage)[iY*nBlockXSize + iX] = \n                        pabySrcBlock[vs * hs + 1];\n            }\n        }\n\n        return CE_None;\n    }\n#endif\n        \n/* -------------------------------------------------------------------- */\n/*      Handle simple case of eight bit data, and pixel interleaving.   */\n/* -------------------------------------------------------------------- */\n    if( poGDS->nBitsPerSample == 8 )\n    {\n        int\ti, nBlockPixels;\n        GByte\t*pabyImage;\n        GByte   *pabyImageDest = (GByte*)pImage;\n        int      nBands = poGDS->nBands;\n\n        pabyImage = poGDS->pabyBlockBuf + nBand - 1;\n\n        nBlockPixels = nBlockXSize * nBlockYSize;\n\n/* ==================================================================== */\n/*     Optimization for high number of words to transfer and some       */\n/*     typical band numbers : we unroll the loop.                       */\n/* ==================================================================== */\n#define COPY_TO_DST_BUFFER(nBands) \\\n        if (nBlockPixels > 100) \\\n        { \\\n            for ( i = nBlockPixels / 16; i != 0; i -- ) \\\n            { \\\n                pabyImageDest[0] = pabyImage[0*nBands]; \\\n                pabyImageDest[1] = pabyImage[1*nBands]; \\\n                pabyImageDest[2] = pabyImage[2*nBands]; \\\n                pabyImageDest[3] = pabyImage[3*nBands]; \\\n                pabyImageDest[4] = pabyImage[4*nBands]; \\\n                pabyImageDest[5] = pabyImage[5*nBands]; \\\n                pabyImageDest[6] = pabyImage[6*nBands]; \\\n                pabyImageDest[7] = pabyImage[7*nBands]; \\\n                pabyImageDest[8] = pabyImage[8*nBands]; \\\n                pabyImageDest[9] = pabyImage[9*nBands]; \\\n                pabyImageDest[10] = pabyImage[10*nBands]; \\\n                pabyImageDest[11] = pabyImage[11*nBands]; \\\n                pabyImageDest[12] = pabyImage[12*nBands]; \\\n                pabyImageDest[13] = pabyImage[13*nBands]; \\\n                pabyImageDest[14] = pabyImage[14*nBands]; \\\n                pabyImageDest[15] = pabyImage[15*nBands]; \\\n                pabyImageDest += 16; \\\n                pabyImage += 16*nBands; \\\n            } \\\n            nBlockPixels = nBlockPixels % 16; \\\n        } \\\n        for( i = 0; i < nBlockPixels; i++ ) \\\n        { \\\n            pabyImageDest[i] = *pabyImage; \\\n            pabyImage += nBands; \\\n        }\n\n        switch (nBands)\n        {\n            case 3:  COPY_TO_DST_BUFFER(3); break;\n            case 4:  COPY_TO_DST_BUFFER(4); break;\n            default:\n            {\n                for( i = 0; i < nBlockPixels; i++ )\n                {\n                    pabyImageDest[i] = *pabyImage;\n                    pabyImage += nBands;\n                }\n            }\n        }\n#undef COPY_TO_DST_BUFFER\n    }\n\n    else\n    {\n        int\ti, nBlockPixels, nWordBytes;\n        GByte\t*pabyImage;\n\n        nWordBytes = poGDS->nBitsPerSample / 8;\n        pabyImage = poGDS->pabyBlockBuf + (nBand - 1) * nWordBytes;\n\n        nBlockPixels = nBlockXSize * nBlockYSize;\n        for( i = 0; i < nBlockPixels; i++ )\n        {\n            for( int j = 0; j < nWordBytes; j++ )\n            {\n                ((GByte *) pImage)[i*nWordBytes + j] = pabyImage[j];\n            }\n            pabyImage += poGDS->nBands * nWordBytes;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      In the fairly common case of pixel interleaved 8bit data        */\n/*      that is multi-band, lets push the rest of the data into the     */\n/*      block cache too, to avoid (hopefully) having to redecode it.    */\n/*                                                                      */\n/*      Our following logic actually depends on the fact that the       */\n/*      this block is already loaded, so subsequent calls will end      */\n/*      up back in this method and pull from the loaded block.          */\n/*                                                                      */\n/*      Be careful not entering this portion of code from               */\n/*      the other bands, otherwise we'll get very deep nested calls     */\n/*      and O(nBands^2) performance !                                   */\n/*                                                                      */\n/*      If there are many bands and the block cache size is not big     */\n/*      enough to accomodate the size of all the blocks, don't enter    */\n/* -------------------------------------------------------------------- */\n    if( poGDS->nBands != 1 && eErr == CE_None && !poGDS->bLoadingOtherBands &&\n        nBlockXSize * nBlockYSize * (GDALGetDataTypeSize(eDataType) / 8) < GDALGetCacheMax64() / poGDS->nBands)\n    {\n        int iOtherBand;\n\n        poGDS->bLoadingOtherBands = TRUE;\n\n        for( iOtherBand = 1; iOtherBand <= poGDS->nBands; iOtherBand++ )\n        {\n            if( iOtherBand == nBand )\n                continue;\n\n            GDALRasterBlock *poBlock;\n\n            poBlock = poGDS->GetRasterBand(iOtherBand)->\n                GetLockedBlockRef(nBlockXOff,nBlockYOff);\n            if (poBlock == NULL)\n            {\n                eErr = CE_Failure;\n                break;\n            }\n            poBlock->DropLock();\n        }\n\n        poGDS->bLoadingOtherBands = FALSE;\n    }\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                            IWriteBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::IWriteBlock( int nBlockXOff, int nBlockYOff,\n                                     void * pImage )\n\n{\n    int\t\tnBlockId;\n    CPLErr      eErr = CE_None;\n\n    if (poGDS->bDebugDontWriteBlocks)\n        return CE_None;\n\n    if (poGDS->bWriteErrorInFlushBlockBuf)\n    {\n        /* Report as an error if a previously loaded block couldn't be */\n        /* written correctly */\n        poGDS->bWriteErrorInFlushBlockBuf = FALSE;\n        return CE_Failure;\n    }\n\n    if (!poGDS->SetDirectory())\n        return CE_Failure;\n\n    CPLAssert( poGDS != NULL\n               && nBlockXOff >= 0\n               && nBlockYOff >= 0\n               && pImage != NULL );\n    CPLAssert(nBlocksPerRow != 0);\n\n/* -------------------------------------------------------------------- */\n/*      Handle case of \"separate\" images                                */\n/* -------------------------------------------------------------------- */\n    if( poGDS->nPlanarConfig == PLANARCONFIG_SEPARATE\n        || poGDS->nBands == 1 )\n    {\n        nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow\n            + (nBand-1) * poGDS->nBlocksPerBand;\n\n        eErr = poGDS->WriteEncodedTileOrStrip(nBlockId, pImage, TRUE);\n\n        return eErr;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Handle case of pixel interleaved (PLANARCONFIG_CONTIG) images.  */\n/* -------------------------------------------------------------------- */\n    nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n        \n    eErr = poGDS->LoadBlockBuf( nBlockId );\n    if( eErr != CE_None )\n        return eErr;\n\n/* -------------------------------------------------------------------- */\n/*      On write of pixel interleaved data, we might as well flush      */\n/*      out any other bands that are dirty in our cache.  This is       */\n/*      especially helpful when writing compressed blocks.              */\n/* -------------------------------------------------------------------- */\n    int iBand; \n    int nWordBytes = poGDS->nBitsPerSample / 8;\n    int nBands = poGDS->nBands;\n\n    for( iBand = 0; iBand < nBands; iBand++ )\n    {\n        const GByte *pabyThisImage = NULL;\n        GDALRasterBlock *poBlock = NULL;\n\n        if( iBand+1 == nBand )\n            pabyThisImage = (GByte *) pImage;\n        else\n        {\n            poBlock = ((GTiffRasterBand *)poGDS->GetRasterBand( iBand+1 ))\n                ->TryGetLockedBlockRef( nBlockXOff, nBlockYOff );\n\n            if( poBlock == NULL )\n                continue;\n\n            if( !poBlock->GetDirty() )\n            {\n                poBlock->DropLock();\n                continue;\n            }\n\n            pabyThisImage = (GByte *) poBlock->GetDataRef();\n        }\n\n        int i, nBlockPixels = nBlockXSize * nBlockYSize;\n        GByte *pabyOut = poGDS->pabyBlockBuf + iBand*nWordBytes;\n\n        if (nWordBytes == 1)\n        {\n\n/* ==================================================================== */\n/*     Optimization for high number of words to transfer and some       */\n/*     typical band numbers : we unroll the loop.                       */\n/* ==================================================================== */\n#define COPY_TO_DST_BUFFER(nBands) \\\n            if (nBlockPixels > 100) \\\n            { \\\n                for ( i = nBlockPixels / 16; i != 0; i -- ) \\\n                { \\\n                    pabyOut[0*nBands] = pabyThisImage[0]; \\\n                    pabyOut[1*nBands] = pabyThisImage[1]; \\\n                    pabyOut[2*nBands] = pabyThisImage[2]; \\\n                    pabyOut[3*nBands] = pabyThisImage[3]; \\\n                    pabyOut[4*nBands] = pabyThisImage[4]; \\\n                    pabyOut[5*nBands] = pabyThisImage[5]; \\\n                    pabyOut[6*nBands] = pabyThisImage[6]; \\\n                    pabyOut[7*nBands] = pabyThisImage[7]; \\\n                    pabyOut[8*nBands] = pabyThisImage[8]; \\\n                    pabyOut[9*nBands] = pabyThisImage[9]; \\\n                    pabyOut[10*nBands] = pabyThisImage[10]; \\\n                    pabyOut[11*nBands] = pabyThisImage[11]; \\\n                    pabyOut[12*nBands] = pabyThisImage[12]; \\\n                    pabyOut[13*nBands] = pabyThisImage[13]; \\\n                    pabyOut[14*nBands] = pabyThisImage[14]; \\\n                    pabyOut[15*nBands] = pabyThisImage[15]; \\\n                    pabyThisImage += 16; \\\n                    pabyOut += 16*nBands; \\\n                } \\\n                nBlockPixels = nBlockPixels % 16; \\\n            } \\\n            for( i = 0; i < nBlockPixels; i++ ) \\\n            { \\\n                *pabyOut = pabyThisImage[i]; \\\n                pabyOut += nBands; \\\n            }\n\n            switch (nBands)\n            {\n                case 3:  COPY_TO_DST_BUFFER(3); break;\n                case 4:  COPY_TO_DST_BUFFER(4); break;\n                default:\n                {\n                    for( i = 0; i < nBlockPixels; i++ )\n                    {\n                        *pabyOut = pabyThisImage[i];\n                        pabyOut += nBands;\n                    }\n                }\n            }\n#undef COPY_TO_DST_BUFFER\n        }\n        else\n        {\n            for( i = 0; i < nBlockPixels; i++ )\n            {\n                memcpy( pabyOut, pabyThisImage, nWordBytes );\n\n                pabyOut += nWordBytes * nBands;\n                pabyThisImage += nWordBytes;\n            }\n        }\n        \n        if( poBlock != NULL )\n        {\n            poBlock->MarkClean();\n            poBlock->DropLock();\n        }\n    }\n\n    poGDS->bLoadedBlockDirty = TRUE;\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                             GetOffset()                              */\n/************************************************************************/\n\ndouble GTiffRasterBand::GetOffset( int *pbSuccess )\n\n{\n    if( pbSuccess )\n        *pbSuccess = bHaveOffsetScale;\n    return dfOffset;\n}\n\n/************************************************************************/\n/*                             SetOffset()                              */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::SetOffset( double dfNewValue )\n\n{\n    if( !bHaveOffsetScale || dfNewValue != dfOffset )\n        poGDS->bMetadataChanged = TRUE;\n\n    bHaveOffsetScale = TRUE;\n    dfOffset = dfNewValue;\n    return CE_None;\n}\n\n/************************************************************************/\n/*                              GetScale()                              */\n/************************************************************************/\n\ndouble GTiffRasterBand::GetScale( int *pbSuccess )\n\n{\n    if( pbSuccess )\n        *pbSuccess = bHaveOffsetScale;\n    return dfScale;\n}\n\n/************************************************************************/\n/*                              SetScale()                              */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::SetScale( double dfNewValue )\n\n{\n    if( !bHaveOffsetScale || dfNewValue != dfScale )\n        poGDS->bMetadataChanged = TRUE;\n\n    bHaveOffsetScale = TRUE;\n    dfScale = dfNewValue;\n    return CE_None;\n}\n\n/************************************************************************/\n/*                            GetUnitType()                             */\n/************************************************************************/\n\nconst char* GTiffRasterBand::GetUnitType()\n\n{\n    return osUnitType.c_str();\n}\n\n/************************************************************************/\n/*                           SetUnitType()                              */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::SetUnitType( const char* pszNewValue )\n\n{\n    CPLString osNewValue(pszNewValue ? pszNewValue : \"\");\n    if( osNewValue.compare(osUnitType) != 0 )\n        poGDS->bMetadataChanged = TRUE;\n\n    osUnitType = osNewValue;\n    return CE_None;\n}\n\n/************************************************************************/\n/*                            GetMetadata()                             */\n/************************************************************************/\n\nchar **GTiffRasterBand::GetMetadata( const char * pszDomain )\n\n{\n    return oGTiffMDMD.GetMetadata( pszDomain );\n}\n\n/************************************************************************/\n/*                            SetMetadata()                             */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::SetMetadata( char ** papszMD, const char *pszDomain )\n\n{\n    if( pszDomain == NULL || !EQUAL(pszDomain,\"_temporary_\") )\n    {\n        if( papszMD != NULL )\n            poGDS->bMetadataChanged = TRUE;\n    }\n\n    return oGTiffMDMD.SetMetadata( papszMD, pszDomain );\n}\n\n/************************************************************************/\n/*                          GetMetadataItem()                           */\n/************************************************************************/\n\nconst char *GTiffRasterBand::GetMetadataItem( const char * pszName, \n                                              const char * pszDomain )\n\n{\n    return oGTiffMDMD.GetMetadataItem( pszName, pszDomain );\n}\n\n/************************************************************************/\n/*                          SetMetadataItem()                           */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::SetMetadataItem( const char *pszName, \n                                         const char *pszValue,\n                                         const char *pszDomain )\n\n{\n    if( pszDomain == NULL || !EQUAL(pszDomain,\"_temporary_\") )\n        poGDS->bMetadataChanged = TRUE;\n\n    return oGTiffMDMD.SetMetadataItem( pszName, pszValue, pszDomain );\n}\n\n/************************************************************************/\n/*                       GetColorInterpretation()                       */\n/************************************************************************/\n\nGDALColorInterp GTiffRasterBand::GetColorInterpretation()\n\n{\n    return eBandInterp;\n}\n\n/************************************************************************/\n/*                       SetColorInterpretation()                       */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::SetColorInterpretation( GDALColorInterp eInterp )\n\n{\n    if( eInterp == eBandInterp )\n        return CE_None;\n    \n    if( poGDS->bCrystalized )\n        return GDALPamRasterBand::SetColorInterpretation( eInterp );\n\n    /* greyscale + alpha */\n    else if( eInterp == GCI_AlphaBand \n        && nBand == 2 \n        && poGDS->nSamplesPerPixel == 2 \n        && poGDS->nPhotometric == PHOTOMETRIC_MINISBLACK )\n    {\n        uint16 v[1] = { EXTRASAMPLE_ASSOCALPHA };\n\n        TIFFSetField(poGDS->hTIFF, TIFFTAG_EXTRASAMPLES, 1, v);\n        eBandInterp = eInterp;\n        return CE_None;\n    }\n\n    /* RGB + alpha */\n    else if( eInterp == GCI_AlphaBand \n             && nBand == 4 \n             && poGDS->nSamplesPerPixel == 4\n             && poGDS->nPhotometric == PHOTOMETRIC_RGB )\n    {\n        uint16 v[1] = { EXTRASAMPLE_ASSOCALPHA };\n\n        TIFFSetField(poGDS->hTIFF, TIFFTAG_EXTRASAMPLES, 1, v);\n        eBandInterp = eInterp;\n        return CE_None;\n    }\n    \n    else\n        return GDALPamRasterBand::SetColorInterpretation( eInterp );\n}\n\n/************************************************************************/\n/*                           GetColorTable()                            */\n/************************************************************************/\n\nGDALColorTable *GTiffRasterBand::GetColorTable()\n\n{\n    if( nBand == 1 )\n        return poGDS->poColorTable;\n    else\n        return NULL;\n}\n\n/************************************************************************/\n/*                           SetColorTable()                            */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::SetColorTable( GDALColorTable * poCT )\n\n{\n/* -------------------------------------------------------------------- */\n/*      Check if this is even a candidate for applying a PCT.           */\n/* -------------------------------------------------------------------- */\n    if( nBand != 1)\n    {\n        CPLError( CE_Failure, CPLE_NotSupported, \n                  \"SetColorTable() can only be called on band 1.\" );\n        return CE_Failure;\n    }\n\n    if( poGDS->nSamplesPerPixel != 1 && poGDS->nSamplesPerPixel != 2)\n    {\n        CPLError( CE_Failure, CPLE_NotSupported, \n                  \"SetColorTable() not supported for multi-sample TIFF files.\" );\n        return CE_Failure;\n    }\n        \n    if( eDataType != GDT_Byte && eDataType != GDT_UInt16 )\n    {\n        CPLError( CE_Failure, CPLE_NotSupported, \n                  \"SetColorTable() only supported for Byte or UInt16 bands in TIFF format.\" );\n        return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      We are careful about calling SetDirectory() to avoid            */\n/*      prematurely crystalizing the directory.  (#2820)                */\n/* -------------------------------------------------------------------- */\n    if( poGDS->bCrystalized )\n    {\n        if (!poGDS->SetDirectory())\n            return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Is this really a request to clear the color table?              */\n/* -------------------------------------------------------------------- */\n    if( poCT == NULL || poCT->GetColorEntryCount() == 0 )\n    {\n        TIFFSetField( poGDS->hTIFF, TIFFTAG_PHOTOMETRIC, \n                      PHOTOMETRIC_MINISBLACK );\n\n#ifdef HAVE_UNSETFIELD\n        TIFFUnsetField( poGDS->hTIFF, TIFFTAG_COLORMAP );\n#else\n        CPLDebug( \"GTiff\", \n                  \"TIFFUnsetField() not supported, colormap may not be cleared.\" );\n#endif\n        \n        if( poGDS->poColorTable )\n        {\n            delete poGDS->poColorTable;\n            poGDS->poColorTable = NULL;\n        }\n\n        return CE_None;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Write out the colortable, and update the configuration.         */\n/* -------------------------------------------------------------------- */\n    int nColors;\n\n    if( eDataType == GDT_Byte )\n        nColors = 256;\n    else\n        nColors = 65536;\n\n    unsigned short *panTRed, *panTGreen, *panTBlue;\n\n    panTRed = (unsigned short *) CPLMalloc(sizeof(unsigned short)*nColors);\n    panTGreen = (unsigned short *) CPLMalloc(sizeof(unsigned short)*nColors);\n    panTBlue = (unsigned short *) CPLMalloc(sizeof(unsigned short)*nColors);\n\n    for( int iColor = 0; iColor < nColors; iColor++ )\n    {\n        if( iColor < poCT->GetColorEntryCount() )\n        {\n            GDALColorEntry  sRGB;\n            \n            poCT->GetColorEntryAsRGB( iColor, &sRGB );\n            \n            panTRed[iColor] = (unsigned short) (257 * sRGB.c1);\n            panTGreen[iColor] = (unsigned short) (257 * sRGB.c2);\n            panTBlue[iColor] = (unsigned short) (257 * sRGB.c3);\n        }\n        else\n        {\n            panTRed[iColor] = panTGreen[iColor] = panTBlue[iColor] = 0;\n        }\n    }\n\n    TIFFSetField( poGDS->hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_PALETTE );\n    TIFFSetField( poGDS->hTIFF, TIFFTAG_COLORMAP,\n                  panTRed, panTGreen, panTBlue );\n\n    CPLFree( panTRed );\n    CPLFree( panTGreen );\n    CPLFree( panTBlue );\n\n    if( poGDS->poColorTable )\n        delete poGDS->poColorTable;\n\n    /* libtiff 3.X needs setting this in all cases (creation or update) */\n    /* whereas libtiff 4.X would just need it if there */\n    /* was no color table before */\n#if 0\n    else\n#endif\n        poGDS->bNeedsRewrite = TRUE;\n\n    poGDS->poColorTable = poCT->Clone();\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                           GetNoDataValue()                           */\n/************************************************************************/\n\ndouble GTiffRasterBand::GetNoDataValue( int * pbSuccess )\n\n{\n    if( bNoDataSet )\n    {\n        if( pbSuccess )\n            *pbSuccess = TRUE;\n\n        return dfNoDataValue;\n    }\n   \n    if( poGDS->bNoDataSet )\n    {\n        if( pbSuccess )\n            *pbSuccess = TRUE;\n\n        return poGDS->dfNoDataValue;\n    }\n\n    return GDALPamRasterBand::GetNoDataValue( pbSuccess );\n}\n\n/************************************************************************/\n/*                           SetNoDataValue()                           */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::SetNoDataValue( double dfNoData )\n\n{\n    if( poGDS->bNoDataSet && poGDS->dfNoDataValue == dfNoData )\n        return CE_None;\n\n    if (!poGDS->SetDirectory())  // needed to call TIFFSetField().\n        return CE_Failure;\n\n    poGDS->bNoDataSet = TRUE;\n    poGDS->dfNoDataValue = dfNoData;\n\n    poGDS->WriteNoDataValue( poGDS->hTIFF, dfNoData );\n    poGDS->bNeedsRewrite = TRUE;\n\n    bNoDataSet = TRUE;\n    dfNoDataValue = dfNoData;\n    return CE_None;\n}\n\n/************************************************************************/\n/*                             NullBlock()                              */\n/*                                                                      */\n/*      Set the block data to the null value if it is set, or zero      */\n/*      if there is no null data value.                                 */\n/************************************************************************/\n\nvoid GTiffRasterBand::NullBlock( void *pData )\n\n{\n    int nWords = nBlockXSize * nBlockYSize;\n    int nChunkSize = MAX(1,GDALGetDataTypeSize(eDataType)/8);\n\n    int bNoDataSet;\n    double dfNoData = GetNoDataValue( &bNoDataSet );\n    if( !bNoDataSet )\n    {\n#ifdef ESRI_BUILD\n        if ( poGDS->nBitsPerSample >= 2 )\n            memset( pData, 0, nWords*nChunkSize );\n        else\n            memset( pData, 1, nWords*nChunkSize );\n#else\n        memset( pData, 0, nWords*nChunkSize );\n#endif\n    }\n    else\n    {\n        /* Will convert nodata value to the right type and copy efficiently */\n        GDALCopyWords( &dfNoData, GDT_Float64, 0,\n                       pData, eDataType, nChunkSize, nWords);\n    }\n}\n\n/************************************************************************/\n/*                          GetOverviewCount()                          */\n/************************************************************************/\n\nint GTiffRasterBand::GetOverviewCount()\n\n{\n    if( poGDS->nOverviewCount > 0 )\n        return poGDS->nOverviewCount;\n    else\n        return GDALRasterBand::GetOverviewCount();\n}\n\n/************************************************************************/\n/*                            GetOverview()                             */\n/************************************************************************/\n\nGDALRasterBand *GTiffRasterBand::GetOverview( int i )\n\n{\n    if( poGDS->nOverviewCount > 0 )\n    {\n        if( i < 0 || i >= poGDS->nOverviewCount )\n            return NULL;\n        else\n            return poGDS->papoOverviewDS[i]->GetRasterBand(nBand);\n    }\n    else\n        return GDALRasterBand::GetOverview( i );\n}\n\n/************************************************************************/\n/*                           GetMaskFlags()                             */\n/************************************************************************/\n\nint GTiffRasterBand::GetMaskFlags()\n{\n    if( poGDS->poMaskDS != NULL )\n    {\n        if( poGDS->poMaskDS->GetRasterCount() == 1)\n        {\n            return GMF_PER_DATASET;\n        }\n        else\n        {\n            return 0;\n        }\n    }\n    else\n        return GDALPamRasterBand::GetMaskFlags();\n}\n\n/************************************************************************/\n/*                            GetMaskBand()                             */\n/************************************************************************/\n\nGDALRasterBand *GTiffRasterBand::GetMaskBand()\n{\n    if( poGDS->poMaskDS != NULL )\n    {\n        if( poGDS->poMaskDS->GetRasterCount() == 1)\n            return poGDS->poMaskDS->GetRasterBand(1);\n        else\n            return poGDS->poMaskDS->GetRasterBand(nBand);\n    }\n    else\n        return GDALPamRasterBand::GetMaskBand();\n}\n\n/************************************************************************/\n/* ==================================================================== */\n/*                             GTiffSplitBand                            */\n/* ==================================================================== */\n/************************************************************************/\n\nclass GTiffSplitBand : public GTiffRasterBand\n{\n    friend class GTiffDataset;\n\n  public:\n\n                   GTiffSplitBand( GTiffDataset *, int );\n    virtual       ~GTiffSplitBand();\n\n    virtual CPLErr IReadBlock( int, int, void * );\n    virtual CPLErr IWriteBlock( int, int, void * );\n};\n\n/************************************************************************/\n/*                           GTiffSplitBand()                           */\n/************************************************************************/\n\nGTiffSplitBand::GTiffSplitBand( GTiffDataset *poDS, int nBand )\n        : GTiffRasterBand( poDS, nBand )\n\n{\n    nBlockXSize = poDS->GetRasterXSize();\n    nBlockYSize = 1;\n}\n\n/************************************************************************/\n/*                          ~GTiffSplitBand()                          */\n/************************************************************************/\n\nGTiffSplitBand::~GTiffSplitBand()\n{\n}\n\n/************************************************************************/\n/*                             IReadBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffSplitBand::IReadBlock( int nBlockXOff, int nBlockYOff,\n                                   void * pImage )\n\n{\n    (void) nBlockXOff;\n    \n    /* Optimization when reading the same line in a contig multi-band TIFF */\n    if( poGDS->nPlanarConfig == PLANARCONFIG_CONTIG && poGDS->nBands > 1 &&\n        poGDS->nLastLineRead == nBlockYOff )\n    {\n        goto extract_band_data;\n    }\n\n    if (!poGDS->SetDirectory())\n        return CE_Failure;\n        \n    if (poGDS->nPlanarConfig == PLANARCONFIG_CONTIG &&\n        poGDS->nBands > 1)\n    {\n        if (poGDS->pabyBlockBuf == NULL)\n            poGDS->pabyBlockBuf = (GByte *) CPLMalloc(TIFFScanlineSize(poGDS->hTIFF));\n    }\n    else\n    {\n        CPLAssert(TIFFScanlineSize(poGDS->hTIFF) == nBlockXSize);\n    }\n    \n/* -------------------------------------------------------------------- */\n/*      Read through to target scanline.                                */\n/* -------------------------------------------------------------------- */\n    if( poGDS->nLastLineRead >= nBlockYOff )\n        poGDS->nLastLineRead = -1;\n\n    if( poGDS->nPlanarConfig == PLANARCONFIG_SEPARATE && poGDS->nBands > 1 )\n    {\n        /* If we change of band, we must start reading the */\n        /* new strip from its beginning */\n        if ( poGDS->nLastBandRead != nBand )\n            poGDS->nLastLineRead = -1;\n        poGDS->nLastBandRead = nBand;\n    }\n    \n    while( poGDS->nLastLineRead < nBlockYOff )\n    {\n        if( TIFFReadScanline( poGDS->hTIFF,\n                              poGDS->pabyBlockBuf ? poGDS->pabyBlockBuf : pImage,\n                              ++poGDS->nLastLineRead,\n                              (poGDS->nPlanarConfig == PLANARCONFIG_SEPARATE) ? (uint16) (nBand-1) : 0 ) == -1\n            && !poGDS->bIgnoreReadErrors )\n        {\n            CPLError( CE_Failure, CPLE_AppDefined,\n                      \"TIFFReadScanline() failed.\" );\n            return CE_Failure;\n        }\n    }\n    \nextract_band_data:\n/* -------------------------------------------------------------------- */\n/*      Extract band data from contig buffer.                           */\n/* -------------------------------------------------------------------- */\n    if ( poGDS->pabyBlockBuf != NULL )\n    {\n        int\t  iPixel, iSrcOffset= nBand - 1, iDstOffset=0;\n\n        for( iPixel = 0; iPixel < nBlockXSize; iPixel++, iSrcOffset+=poGDS->nBands, iDstOffset++ )\n        {\n            ((GByte *) pImage)[iDstOffset] = poGDS->pabyBlockBuf[iSrcOffset];\n        }\n    }\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                            IWriteBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffSplitBand::IWriteBlock( int nBlockXOff, int nBlockYOff,\n                                    void * pImage )\n\n{\n    (void) nBlockXOff;\n    (void) nBlockYOff;\n    (void) pImage;\n\n    CPLError( CE_Failure, CPLE_AppDefined, \n              \"Split bands are read-only.\" );\n    return CE_Failure;\n}\n\n/************************************************************************/\n/* ==================================================================== */\n/*                             GTiffRGBABand                            */\n/* ==================================================================== */\n/************************************************************************/\n\nclass GTiffRGBABand : public GTiffRasterBand\n{\n    friend class GTiffDataset;\n\n  public:\n\n                   GTiffRGBABand( GTiffDataset *, int );\n\n    virtual CPLErr IReadBlock( int, int, void * );\n    virtual CPLErr IWriteBlock( int, int, void * );\n\n    virtual GDALColorInterp GetColorInterpretation();\n};\n\n\n/************************************************************************/\n/*                           GTiffRGBABand()                            */\n/************************************************************************/\n\nGTiffRGBABand::GTiffRGBABand( GTiffDataset *poDS, int nBand )\n        : GTiffRasterBand( poDS, nBand )\n\n{\n    eDataType = GDT_Byte;\n}\n\n/************************************************************************/\n/*                            IWriteBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffRGBABand::IWriteBlock( int, int, void * )\n\n{\n    CPLError( CE_Failure, CPLE_AppDefined, \n              \"RGBA interpreted raster bands are read-only.\" );\n    return CE_Failure;\n}\n\n/************************************************************************/\n/*                             IReadBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffRGBABand::IReadBlock( int nBlockXOff, int nBlockYOff,\n                                    void * pImage )\n\n{\n    int\t\t\tnBlockBufSize, nBlockId;\n    CPLErr\t\teErr = CE_None;\n\n    if (!poGDS->SetDirectory())\n        return CE_Failure;\n\n    CPLAssert(nBlocksPerRow != 0);\n    nBlockBufSize = 4 * nBlockXSize * nBlockYSize;\n    nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n\n/* -------------------------------------------------------------------- */\n/*      Allocate a temporary buffer for this strip.                     */\n/* -------------------------------------------------------------------- */\n    if( poGDS->pabyBlockBuf == NULL )\n    {\n        poGDS->pabyBlockBuf = (GByte *) VSIMalloc3( 4, nBlockXSize, nBlockYSize );\n        if( poGDS->pabyBlockBuf == NULL )\n            return( CE_Failure );\n    }\n    \n/* -------------------------------------------------------------------- */\n/*      Read the strip                                                  */\n/* -------------------------------------------------------------------- */\n    if( poGDS->nLoadedBlock != nBlockId )\n    {\n        if( TIFFIsTiled( poGDS->hTIFF ) )\n        {\n            if( TIFFReadRGBATile(poGDS->hTIFF, \n                                 nBlockXOff * nBlockXSize, \n                                 nBlockYOff * nBlockYSize,\n                                 (uint32 *) poGDS->pabyBlockBuf) == -1\n                && !poGDS->bIgnoreReadErrors )\n            {\n                /* Once TIFFError() is properly hooked, this can go away */\n                CPLError( CE_Failure, CPLE_AppDefined,\n                          \"TIFFReadRGBATile() failed.\" );\n                \n                memset( poGDS->pabyBlockBuf, 0, nBlockBufSize );\n                \n                eErr = CE_Failure;\n            }\n        }\n        else\n        {\n            if( TIFFReadRGBAStrip(poGDS->hTIFF, \n                                  nBlockId * nBlockYSize,\n                                  (uint32 *) poGDS->pabyBlockBuf) == -1\n                && !poGDS->bIgnoreReadErrors )\n            {\n                /* Once TIFFError() is properly hooked, this can go away */\n                CPLError( CE_Failure, CPLE_AppDefined,\n                          \"TIFFReadRGBAStrip() failed.\" );\n                \n                memset( poGDS->pabyBlockBuf, 0, nBlockBufSize );\n                \n                eErr = CE_Failure;\n            }\n        }\n    }\n\n    poGDS->nLoadedBlock = nBlockId;\n                              \n/* -------------------------------------------------------------------- */\n/*      Handle simple case of eight bit data, and pixel interleaving.   */\n/* -------------------------------------------------------------------- */\n    int   iDestLine, nBO;\n    int   nThisBlockYSize;\n\n    if( (nBlockYOff+1) * nBlockYSize > GetYSize()\n        && !TIFFIsTiled( poGDS->hTIFF ) )\n        nThisBlockYSize = GetYSize() - nBlockYOff * nBlockYSize;\n    else\n        nThisBlockYSize = nBlockYSize;\n\n#ifdef CPL_LSB\n    nBO = nBand - 1;\n#else\n    nBO = 4 - nBand;\n#endif\n\n    for( iDestLine = 0; iDestLine < nThisBlockYSize; iDestLine++ )\n    {\n        int\tnSrcOffset;\n\n        nSrcOffset = (nThisBlockYSize - iDestLine - 1) * nBlockXSize * 4;\n\n        GDALCopyWords( poGDS->pabyBlockBuf + nBO + nSrcOffset, GDT_Byte, 4,\n                       ((GByte *) pImage)+iDestLine*nBlockXSize, GDT_Byte, 1, \n                       nBlockXSize );\n    }\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                       GetColorInterpretation()                       */\n/************************************************************************/\n\nGDALColorInterp GTiffRGBABand::GetColorInterpretation()\n\n{\n    if( nBand == 1 )\n        return GCI_RedBand;\n    else if( nBand == 2 )\n        return GCI_GreenBand;\n    else if( nBand == 3 )\n        return GCI_BlueBand;\n    else\n        return GCI_AlphaBand;\n}\n\n/************************************************************************/\n/* ==================================================================== */\n/*                             GTiffOddBitsBand                         */\n/* ==================================================================== */\n/************************************************************************/\n\nclass GTiffOddBitsBand : public GTiffRasterBand\n{\n    friend class GTiffDataset;\n  public:\n\n                   GTiffOddBitsBand( GTiffDataset *, int );\n    virtual       ~GTiffOddBitsBand();\n\n    virtual CPLErr IReadBlock( int, int, void * );\n    virtual CPLErr IWriteBlock( int, int, void * );\n};\n\n\n/************************************************************************/\n/*                           GTiffOddBitsBand()                         */\n/************************************************************************/\n\nGTiffOddBitsBand::GTiffOddBitsBand( GTiffDataset *poGDS, int nBand )\n        : GTiffRasterBand( poGDS, nBand )\n\n{\n    eDataType = GDT_Byte;\n    if( poGDS->nSampleFormat == SAMPLEFORMAT_IEEEFP )\n        eDataType = GDT_Float32;\n    else if( poGDS->nBitsPerSample > 8 && poGDS->nBitsPerSample < 16 )\n        eDataType = GDT_UInt16;\n    else if( poGDS->nBitsPerSample > 16 )\n        eDataType = GDT_UInt32;\n}\n\n/************************************************************************/\n/*                          ~GTiffOddBitsBand()                          */\n/************************************************************************/\n\nGTiffOddBitsBand::~GTiffOddBitsBand()\n\n{\n}\n\n/************************************************************************/\n/*                            IWriteBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffOddBitsBand::IWriteBlock( int nBlockXOff, int nBlockYOff, \n                                      void *pImage )\n\n{\n    int\t\tnBlockId;\n    CPLErr      eErr = CE_None;\n\n    if (poGDS->bWriteErrorInFlushBlockBuf)\n    {\n        /* Report as an error if a previously loaded block couldn't be */\n        /* written correctly */\n        poGDS->bWriteErrorInFlushBlockBuf = FALSE;\n        return CE_Failure;\n    }\n\n    if (!poGDS->SetDirectory())\n        return CE_Failure;\n\n    CPLAssert( poGDS != NULL\n               && nBlockXOff >= 0\n               && nBlockYOff >= 0\n               && pImage != NULL );\n\n    if( eDataType == GDT_Float32 && poGDS->nBitsPerSample < 32 )\n    {\n        CPLError(CE_Failure, CPLE_NotSupported,\n                 \"Writing float data with nBitsPerSample < 32 is unsupported\");\n        return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Load the block buffer.                                          */\n/* -------------------------------------------------------------------- */\n    CPLAssert(nBlocksPerRow != 0);\n    nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n\n    if( poGDS->nPlanarConfig == PLANARCONFIG_SEPARATE )\n        nBlockId += (nBand-1) * poGDS->nBlocksPerBand;\n\n    /* Only read content from disk in the CONTIG case */\n    eErr = poGDS->LoadBlockBuf( nBlockId, \n                                poGDS->nPlanarConfig == PLANARCONFIG_CONTIG && poGDS->nBands > 1 );\n    if( eErr != CE_None )\n        return eErr;\n\n    GUInt32 nMaxVal = (1 << poGDS->nBitsPerSample) - 1;\n\n/* -------------------------------------------------------------------- */\n/*      Handle case of \"separate\" images or single band images where    */\n/*      no interleaving with other data is required.                    */\n/* -------------------------------------------------------------------- */\n    if( poGDS->nPlanarConfig == PLANARCONFIG_SEPARATE\n        || poGDS->nBands == 1 )\n    {\n        int\tiBit, iPixel, iBitOffset = 0;\n        int     iX, iY, nBitsPerLine;\n\n        // bits per line rounds up to next byte boundary.\n        nBitsPerLine = nBlockXSize * poGDS->nBitsPerSample;\n        if( (nBitsPerLine & 7) != 0 )\n            nBitsPerLine = (nBitsPerLine + 7) & (~7);\n\n        /* Initialize to zero as we set the buffer with binary or operations */\n        if (poGDS->nBitsPerSample != 24)\n            memset(poGDS->pabyBlockBuf, 0, (nBitsPerLine / 8) * nBlockYSize);\n\n        iPixel = 0;\n        for( iY = 0; iY < nBlockYSize; iY++ )\n        {\n            iBitOffset = iY * nBitsPerLine;\n\n            /* Small optimization in 1 bit case */\n            if (poGDS->nBitsPerSample == 1)\n            {\n                for( iX = 0; iX < nBlockXSize; iX++ )\n                {\n                    if (((GByte *) pImage)[iPixel++])\n                        poGDS->pabyBlockBuf[iBitOffset>>3] |= (0x80 >>(iBitOffset & 7));\n                    iBitOffset++;\n                }\n\n                continue;\n            }\n\n            for( iX = 0; iX < nBlockXSize; iX++ )\n            {\n                GUInt32  nInWord = 0;\n                if( eDataType == GDT_Byte )\n                    nInWord = ((GByte *) pImage)[iPixel++];\n                else if( eDataType == GDT_UInt16 )\n                    nInWord = ((GUInt16 *) pImage)[iPixel++];\n                else if( eDataType == GDT_UInt32 )\n                    nInWord = ((GUInt32 *) pImage)[iPixel++];\n                else\n                    CPLAssert(0);\n\n                if (nInWord > nMaxVal)\n                {\n                    nInWord = nMaxVal;\n                    if( !poGDS->bClipWarn )\n                    {\n                        poGDS->bClipWarn = TRUE;\n                        CPLError( CE_Warning, CPLE_AppDefined,\n                                  \"One or more pixels clipped to fit %d bit domain.\", poGDS->nBitsPerSample );\n                    }\n                }\n\n                if (poGDS->nBitsPerSample == 24)\n                {\n/* -------------------------------------------------------------------- */\n/*      Special case for 24bit data which is pre-byteswapped since      */\n/*      the size falls on a byte boundary ... ugg (#2361).              */\n/* -------------------------------------------------------------------- */\n#ifdef CPL_MSB\n                    poGDS->pabyBlockBuf[(iBitOffset>>3) + 0] = \n                        (GByte) nInWord;\n                    poGDS->pabyBlockBuf[(iBitOffset>>3) + 1] = \n                        (GByte) (nInWord >> 8);\n                    poGDS->pabyBlockBuf[(iBitOffset>>3) + 2] = \n                        (GByte) (nInWord >> 16);\n#else\n                    poGDS->pabyBlockBuf[(iBitOffset>>3) + 0] = \n                        (GByte) (nInWord >> 16);\n                    poGDS->pabyBlockBuf[(iBitOffset>>3) + 1] = \n                        (GByte) (nInWord >> 8);\n                    poGDS->pabyBlockBuf[(iBitOffset>>3) + 2] = \n                        (GByte) nInWord;\n#endif\n                    iBitOffset += 24;\n                }\n                else\n                {\n                    for( iBit = 0; iBit < poGDS->nBitsPerSample; iBit++ )\n                    {\n                        if (nInWord & (1 << (poGDS->nBitsPerSample - 1 - iBit)))\n                            poGDS->pabyBlockBuf[iBitOffset>>3] |= (0x80 >>(iBitOffset & 7));\n                        iBitOffset++;\n                    }\n                } \n            }\n        }\n\n        poGDS->bLoadedBlockDirty = TRUE;\n\n        return eErr;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Handle case of pixel interleaved (PLANARCONFIG_CONTIG) images.  */\n/* -------------------------------------------------------------------- */\n\n/* -------------------------------------------------------------------- */\n/*      On write of pixel interleaved data, we might as well flush      */\n/*      out any other bands that are dirty in our cache.  This is       */\n/*      especially helpful when writing compressed blocks.              */\n/* -------------------------------------------------------------------- */\n    int iBand; \n\n    for( iBand = 0; iBand < poGDS->nBands; iBand++ )\n    {\n        const GByte *pabyThisImage = NULL;\n        GDALRasterBlock *poBlock = NULL;\n        int\tiBit, iPixel, iBitOffset = 0;\n        int     iPixelBitSkip, iBandBitOffset, iX, iY, nBitsPerLine;\n\n        if( iBand+1 == nBand )\n            pabyThisImage = (GByte *) pImage;\n        else\n        {\n            poBlock = ((GTiffOddBitsBand *)poGDS->GetRasterBand( iBand+1 ))\n                ->TryGetLockedBlockRef( nBlockXOff, nBlockYOff );\n\n            if( poBlock == NULL )\n                continue;\n\n            if( !poBlock->GetDirty() )\n            {\n                poBlock->DropLock();\n                continue;\n            }\n\n            pabyThisImage = (GByte *) poBlock->GetDataRef();\n        }\n\n        iPixelBitSkip = poGDS->nBitsPerSample * poGDS->nBands;\n        iBandBitOffset = iBand * poGDS->nBitsPerSample;\n\n        // bits per line rounds up to next byte boundary.\n        nBitsPerLine = nBlockXSize * iPixelBitSkip;\n        if( (nBitsPerLine & 7) != 0 )\n            nBitsPerLine = (nBitsPerLine + 7) & (~7);\n\n        iPixel = 0;\n        for( iY = 0; iY < nBlockYSize; iY++ )\n        {\n            iBitOffset = iBandBitOffset + iY * nBitsPerLine;\n\n            for( iX = 0; iX < nBlockXSize; iX++ )\n            {\n                GUInt32  nInWord = 0;\n                if( eDataType == GDT_Byte )\n                    nInWord = ((GByte *) pabyThisImage)[iPixel++];\n                else if( eDataType == GDT_UInt16 )\n                    nInWord = ((GUInt16 *) pabyThisImage)[iPixel++];\n                else if( eDataType == GDT_UInt32 )\n                    nInWord = ((GUInt32 *) pabyThisImage)[iPixel++];\n                else\n                    CPLAssert(0);\n\n                if (nInWord > nMaxVal)\n                {\n                    nInWord = nMaxVal;\n                    if( !poGDS->bClipWarn )\n                    {\n                        poGDS->bClipWarn = TRUE;\n                        CPLError( CE_Warning, CPLE_AppDefined,\n                                  \"One or more pixels clipped to fit %d bit domain.\", poGDS->nBitsPerSample );\n                    }\n                }\n\n                if (poGDS->nBitsPerSample == 24)\n                {\n/* -------------------------------------------------------------------- */\n/*      Special case for 24bit data which is pre-byteswapped since      */\n/*      the size falls on a byte boundary ... ugg (#2361).              */\n/* -------------------------------------------------------------------- */\n#ifdef CPL_MSB\n                    poGDS->pabyBlockBuf[(iBitOffset>>3) + 0] = \n                        (GByte) nInWord;\n                    poGDS->pabyBlockBuf[(iBitOffset>>3) + 1] = \n                        (GByte) (nInWord >> 8);\n                    poGDS->pabyBlockBuf[(iBitOffset>>3) + 2] = \n                        (GByte) (nInWord >> 16);\n#else\n                    poGDS->pabyBlockBuf[(iBitOffset>>3) + 0] = \n                        (GByte) (nInWord >> 16);\n                    poGDS->pabyBlockBuf[(iBitOffset>>3) + 1] = \n                        (GByte) (nInWord >> 8);\n                    poGDS->pabyBlockBuf[(iBitOffset>>3) + 2] = \n                        (GByte) nInWord;\n#endif\n                    iBitOffset += 24;\n                }\n                else\n                {\n                    for( iBit = 0; iBit < poGDS->nBitsPerSample; iBit++ )\n                    {\n                        if (nInWord & (1 << (poGDS->nBitsPerSample - 1 - iBit)))\n                            poGDS->pabyBlockBuf[iBitOffset>>3] |= (0x80 >>(iBitOffset & 7));\n                        else\n                        {\n                            /* We must explictly unset the bit as we may update an existing block */\n                            poGDS->pabyBlockBuf[iBitOffset>>3] &= ~(0x80 >>(iBitOffset & 7));\n                        }\n\n                        iBitOffset++;\n                    }\n                } \n\n                iBitOffset= iBitOffset + iPixelBitSkip - poGDS->nBitsPerSample;\n            }\n        }\n\n        if( poBlock != NULL )\n        {\n            poBlock->MarkClean();\n            poBlock->DropLock();\n        }\n    }\n\n    poGDS->bLoadedBlockDirty = TRUE;\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                             IReadBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffOddBitsBand::IReadBlock( int nBlockXOff, int nBlockYOff,\n                                    void * pImage )\n\n{\n    int\t\t\tnBlockId;\n    CPLErr\t\teErr = CE_None;\n\n    if (!poGDS->SetDirectory())\n        return CE_Failure;\n\n    CPLAssert(nBlocksPerRow != 0);\n    nBlockId = nBlockXOff + nBlockYOff * nBlocksPerRow;\n\n    if( poGDS->nPlanarConfig == PLANARCONFIG_SEPARATE )\n        nBlockId += (nBand-1) * poGDS->nBlocksPerBand;\n\n/* -------------------------------------------------------------------- */\n/*\tHandle the case of a strip in a writable file that doesn't\t*/\n/*\texist yet, but that we want to read.  Just set to zeros and\t*/\n/*\treturn.\t\t\t\t\t\t\t\t*/\n/* -------------------------------------------------------------------- */\n    if( !poGDS->IsBlockAvailable(nBlockId) )\n    {\n        NullBlock( pImage );\n        return CE_None;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Load the block buffer.                                          */\n/* -------------------------------------------------------------------- */\n    eErr = poGDS->LoadBlockBuf( nBlockId );\n    if( eErr != CE_None )\n        return eErr;\n\n    if (  poGDS->nBitsPerSample == 1 && (poGDS->nBands == 1 || poGDS->nPlanarConfig == PLANARCONFIG_SEPARATE ) )\n    {\n/* -------------------------------------------------------------------- */\n/*      Translate 1bit data to eight bit.                               */\n/* -------------------------------------------------------------------- */\n        int\t  iDstOffset=0, iLine;\n        register GByte *pabyBlockBuf = poGDS->pabyBlockBuf;\n\n        for( iLine = 0; iLine < nBlockYSize; iLine++ )\n        {\n            int iSrcOffset, iPixel;\n\n            iSrcOffset = ((nBlockXSize+7) >> 3) * 8 * iLine;\n            \n            GByte bSetVal = (poGDS->bPromoteTo8Bits) ? 255 : 1;\n\n            for( iPixel = 0; iPixel < nBlockXSize; iPixel++, iSrcOffset++ )\n            {\n                if( pabyBlockBuf[iSrcOffset >>3] & (0x80 >> (iSrcOffset & 0x7)) )\n                    ((GByte *) pImage)[iDstOffset++] = bSetVal;\n                else\n                    ((GByte *) pImage)[iDstOffset++] = 0;\n            }\n        }\n    }\n/* -------------------------------------------------------------------- */\n/*      Handle the case of 16- and 24-bit floating point data as per    */\n/*      TIFF Technical Note 3.                                          */\n/* -------------------------------------------------------------------- */\n    else if( eDataType == GDT_Float32 && poGDS->nBitsPerSample < 32 )\n    {\n        int\ti, nBlockPixels, nWordBytes, iSkipBytes;\n        GByte\t*pabyImage;\n\n        nWordBytes = poGDS->nBitsPerSample / 8;\n        pabyImage = poGDS->pabyBlockBuf + (nBand - 1) * nWordBytes;\n        iSkipBytes = ( poGDS->nPlanarConfig == PLANARCONFIG_SEPARATE ) ?\n            nWordBytes : poGDS->nBands * nWordBytes;\n\n        nBlockPixels = nBlockXSize * nBlockYSize;\n        if ( poGDS->nBitsPerSample == 16 )\n        {\n            for( i = 0; i < nBlockPixels; i++ )\n            {\n                ((GUInt32 *) pImage)[i] =\n                    HalfToFloat( *((GUInt16 *)pabyImage) );\n                pabyImage += iSkipBytes;\n            }\n        }\n        else if ( poGDS->nBitsPerSample == 24 )\n        {\n            for( i = 0; i < nBlockPixels; i++ )\n            {\n#ifdef CPL_MSB\n                ((GUInt32 *) pImage)[i] =\n                    TripleToFloat( ((GUInt32)*(pabyImage + 0) << 16)\n                                   | ((GUInt32)*(pabyImage + 1) << 8)\n                                   | (GUInt32)*(pabyImage + 2) );\n#else\n                ((GUInt32 *) pImage)[i] =\n                    TripleToFloat( ((GUInt32)*(pabyImage + 2) << 16)\n                                   | ((GUInt32)*(pabyImage + 1) << 8)\n                                   | (GUInt32)*pabyImage );\n#endif\n                pabyImage += iSkipBytes;\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Special case for moving 12bit data somewhat more efficiently.   */\n/* -------------------------------------------------------------------- */\n    else if( poGDS->nBitsPerSample == 12 )\n    {\n        int\tiPixel, iBitOffset = 0;\n        int     iPixelBitSkip, iBandBitOffset, iX, iY, nBitsPerLine;\n\n        if( poGDS->nPlanarConfig == PLANARCONFIG_CONTIG )\n        {\n            iPixelBitSkip = poGDS->nBands * poGDS->nBitsPerSample;\n            iBandBitOffset = (nBand-1) * poGDS->nBitsPerSample;\n        }\n        else\n        {\n            iPixelBitSkip = poGDS->nBitsPerSample;\n            iBandBitOffset = 0;\n        }\n\n        // bits per line rounds up to next byte boundary.\n        nBitsPerLine = nBlockXSize * iPixelBitSkip;\n        if( (nBitsPerLine & 7) != 0 )\n            nBitsPerLine = (nBitsPerLine + 7) & (~7);\n\n        iPixel = 0;\n        for( iY = 0; iY < nBlockYSize; iY++ )\n        {\n            iBitOffset = iBandBitOffset + iY * nBitsPerLine;\n\n            for( iX = 0; iX < nBlockXSize; iX++ )\n            {\n                int iByte = iBitOffset>>3;\n\n                if( (iBitOffset & 0x7) == 0 )\n                {\n                    /* starting on byte boundary */\n                    \n                    ((GUInt16 *) pImage)[iPixel++] = \n                        (poGDS->pabyBlockBuf[iByte] << 4)\n                        | (poGDS->pabyBlockBuf[iByte+1] >> 4);\n                }\n                else\n                {\n                    /* starting off byte boundary */\n                    \n                    ((GUInt16 *) pImage)[iPixel++] = \n                        ((poGDS->pabyBlockBuf[iByte] & 0xf) << 8)\n                        | (poGDS->pabyBlockBuf[iByte+1]);\n                }\n                iBitOffset += iPixelBitSkip;\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Special case for 24bit data which is pre-byteswapped since      */\n/*      the size falls on a byte boundary ... ugg (#2361).              */\n/* -------------------------------------------------------------------- */\n    else if( poGDS->nBitsPerSample == 24 )\n    {\n        int\tiPixel;\n        int     iPixelByteSkip, iBandByteOffset, iX, iY, nBytesPerLine;\n\n        if( poGDS->nPlanarConfig == PLANARCONFIG_CONTIG )\n        {\n            iPixelByteSkip = (poGDS->nBands * poGDS->nBitsPerSample) / 8;\n            iBandByteOffset = ((nBand-1) * poGDS->nBitsPerSample) / 8;\n        }\n        else\n        {\n            iPixelByteSkip = poGDS->nBitsPerSample / 8;\n            iBandByteOffset = 0;\n        }\n\n        nBytesPerLine = nBlockXSize * iPixelByteSkip;\n\n        iPixel = 0;\n        for( iY = 0; iY < nBlockYSize; iY++ )\n        {\n            GByte *pabyImage = \n                poGDS->pabyBlockBuf + iBandByteOffset + iY * nBytesPerLine;\n\n            for( iX = 0; iX < nBlockXSize; iX++ )\n            {\n#ifdef CPL_MSB\n                ((GUInt32 *) pImage)[iPixel++] = \n                    ((GUInt32)*(pabyImage + 2) << 16)\n                    | ((GUInt32)*(pabyImage + 1) << 8)\n                    | (GUInt32)*(pabyImage + 0);\n#else\n                ((GUInt32 *) pImage)[iPixel++] = \n                    ((GUInt32)*(pabyImage + 0) << 16)\n                    | ((GUInt32)*(pabyImage + 1) << 8)\n                    | (GUInt32)*(pabyImage + 2);\n#endif\n                pabyImage += iPixelByteSkip;\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Handle 1-32 bit integer data.                                   */\n/* -------------------------------------------------------------------- */\n    else\n    {\n        int\tiBit, iPixel, iBitOffset = 0;\n        int     iPixelBitSkip, iBandBitOffset, iX, iY, nBitsPerLine;\n\n        if( poGDS->nPlanarConfig == PLANARCONFIG_CONTIG )\n        {\n            iPixelBitSkip = poGDS->nBands * poGDS->nBitsPerSample;\n            iBandBitOffset = (nBand-1) * poGDS->nBitsPerSample;\n        }\n        else\n        {\n            iPixelBitSkip = poGDS->nBitsPerSample;\n            iBandBitOffset = 0;\n        }\n\n        // bits per line rounds up to next byte boundary.\n        nBitsPerLine = nBlockXSize * iPixelBitSkip;\n        if( (nBitsPerLine & 7) != 0 )\n            nBitsPerLine = (nBitsPerLine + 7) & (~7);\n\n        register GByte *pabyBlockBuf = poGDS->pabyBlockBuf;\n        iPixel = 0;\n\n        for( iY = 0; iY < nBlockYSize; iY++ )\n        {\n            iBitOffset = iBandBitOffset + iY * nBitsPerLine;\n\n            for( iX = 0; iX < nBlockXSize; iX++ )\n            {\n                int  nOutWord = 0;\n\n                for( iBit = 0; iBit < poGDS->nBitsPerSample; iBit++ )\n                {\n                    if( pabyBlockBuf[iBitOffset>>3] \n                        & (0x80 >>(iBitOffset & 7)) )\n                        nOutWord |= (1 << (poGDS->nBitsPerSample - 1 - iBit));\n                    iBitOffset++;\n                } \n\n                iBitOffset= iBitOffset + iPixelBitSkip - poGDS->nBitsPerSample;\n                \n                if( eDataType == GDT_Byte )\n                    ((GByte *) pImage)[iPixel++] = (GByte) nOutWord;\n                else if( eDataType == GDT_UInt16 )\n                    ((GUInt16 *) pImage)[iPixel++] = (GUInt16) nOutWord;\n                else if( eDataType == GDT_UInt32 )\n                    ((GUInt32 *) pImage)[iPixel++] = nOutWord;\n                else\n                    CPLAssert(0);\n            }\n        }\n    }\n\n    return CE_None;\n}\n\n\n/************************************************************************/\n/* ==================================================================== */\n/*                             GTiffBitmapBand                          */\n/* ==================================================================== */\n/************************************************************************/\n\nclass GTiffBitmapBand : public GTiffOddBitsBand\n{\n    friend class GTiffDataset;\n\n    GDALColorTable *poColorTable;\n\n  public:\n\n                   GTiffBitmapBand( GTiffDataset *, int );\n    virtual       ~GTiffBitmapBand();\n\n    virtual GDALColorInterp GetColorInterpretation();\n    virtual GDALColorTable *GetColorTable();\n};\n\n\n/************************************************************************/\n/*                           GTiffBitmapBand()                          */\n/************************************************************************/\n\nGTiffBitmapBand::GTiffBitmapBand( GTiffDataset *poDS, int nBand )\n        : GTiffOddBitsBand( poDS, nBand )\n\n{\n    eDataType = GDT_Byte;\n\n    if( poDS->poColorTable != NULL )\n        poColorTable = poDS->poColorTable->Clone();\n    else\n    {\n#ifdef ESRI_BUILD\n        poColorTable = NULL;\n#else\n        GDALColorEntry\toWhite, oBlack;\n\n        oWhite.c1 = 255;\n        oWhite.c2 = 255;\n        oWhite.c3 = 255;\n        oWhite.c4 = 255;\n\n        oBlack.c1 = 0;\n        oBlack.c2 = 0;\n        oBlack.c3 = 0;\n        oBlack.c4 = 255;\n\n        poColorTable = new GDALColorTable();\n        \n        if( poDS->nPhotometric == PHOTOMETRIC_MINISWHITE )\n        {\n            poColorTable->SetColorEntry( 0, &oWhite );\n            poColorTable->SetColorEntry( 1, &oBlack );\n        }\n        else\n        {\n            poColorTable->SetColorEntry( 0, &oBlack );\n            poColorTable->SetColorEntry( 1, &oWhite );\n        }\n#endif /* not defined ESRI_BUILD */\n    }\n}\n\n/************************************************************************/\n/*                          ~GTiffBitmapBand()                          */\n/************************************************************************/\n\nGTiffBitmapBand::~GTiffBitmapBand()\n\n{\n    delete poColorTable;\n}\n\n/************************************************************************/\n/*                       GetColorInterpretation()                       */\n/************************************************************************/\n\nGDALColorInterp GTiffBitmapBand::GetColorInterpretation()\n\n{\n    if (poGDS->bPromoteTo8Bits)\n        return GCI_Undefined;\n    else\n        return GCI_PaletteIndex;\n}\n\n/************************************************************************/\n/*                           GetColorTable()                            */\n/************************************************************************/\n\nGDALColorTable *GTiffBitmapBand::GetColorTable()\n\n{\n    if (poGDS->bPromoteTo8Bits)\n        return NULL;\n    else\n        return poColorTable;\n}\n\n/************************************************************************/\n/* ==================================================================== */\n/*                          GTiffSplitBitmapBand                        */\n/* ==================================================================== */\n/************************************************************************/\n\nclass GTiffSplitBitmapBand : public GTiffBitmapBand\n{\n    friend class GTiffDataset;\n\n  public:\n\n                   GTiffSplitBitmapBand( GTiffDataset *, int );\n    virtual       ~GTiffSplitBitmapBand();\n\n    virtual CPLErr IReadBlock( int, int, void * );\n    virtual CPLErr IWriteBlock( int, int, void * );\n};\n\n\n/************************************************************************/\n/*                       GTiffSplitBitmapBand()                         */\n/************************************************************************/\n\nGTiffSplitBitmapBand::GTiffSplitBitmapBand( GTiffDataset *poDS, int nBand )\n        : GTiffBitmapBand( poDS, nBand )\n\n{\n    nBlockXSize = poDS->GetRasterXSize();\n    nBlockYSize = 1;\n}\n\n/************************************************************************/\n/*                      ~GTiffSplitBitmapBand()                         */\n/************************************************************************/\n\nGTiffSplitBitmapBand::~GTiffSplitBitmapBand()\n\n{\n}\n\n\n/************************************************************************/\n/*                             IReadBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffSplitBitmapBand::IReadBlock( int nBlockXOff, int nBlockYOff,\n                                         void * pImage )\n\n{\n    (void) nBlockXOff;\n\n    if (!poGDS->SetDirectory())\n        return CE_Failure;\n        \n    if (poGDS->pabyBlockBuf == NULL)\n        poGDS->pabyBlockBuf = (GByte *) CPLMalloc(TIFFScanlineSize(poGDS->hTIFF));\n\n/* -------------------------------------------------------------------- */\n/*      Read through to target scanline.                                */\n/* -------------------------------------------------------------------- */\n    if( poGDS->nLastLineRead >= nBlockYOff )\n        poGDS->nLastLineRead = -1;\n\n    while( poGDS->nLastLineRead < nBlockYOff )\n    {\n        if( TIFFReadScanline( poGDS->hTIFF, poGDS->pabyBlockBuf, ++poGDS->nLastLineRead, 0 ) == -1\n            && !poGDS->bIgnoreReadErrors )\n        {\n            CPLError( CE_Failure, CPLE_AppDefined,\n                      \"TIFFReadScanline() failed.\" );\n            return CE_Failure;\n        }\n    }\n    \n/* -------------------------------------------------------------------- */\n/*      Translate 1bit data to eight bit.                               */\n/* -------------------------------------------------------------------- */\n    int\t  iPixel, iSrcOffset=0, iDstOffset=0;\n\n    for( iPixel = 0; iPixel < nBlockXSize; iPixel++, iSrcOffset++ )\n    {\n        if( poGDS->pabyBlockBuf[iSrcOffset >>3] & (0x80 >> (iSrcOffset & 0x7)) )\n            ((GByte *) pImage)[iDstOffset++] = 1;\n        else\n            ((GByte *) pImage)[iDstOffset++] = 0;\n    }\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                            IWriteBlock()                             */\n/************************************************************************/\n\nCPLErr GTiffSplitBitmapBand::IWriteBlock( int nBlockXOff, int nBlockYOff,\n                                          void * pImage )\n\n{\n    (void) nBlockXOff;\n    (void) nBlockYOff;\n    (void) pImage;\n\n    CPLError( CE_Failure, CPLE_AppDefined, \n              \"Split bitmap bands are read-only.\" );\n    return CE_Failure;\n}\n\n/************************************************************************/\n/* ==================================================================== */\n/*                            GTiffDataset                              */\n/* ==================================================================== */\n/************************************************************************/\n\n\n/************************************************************************/\n/*                            GTiffDataset()                            */\n/************************************************************************/\n\nGTiffDataset::GTiffDataset()\n\n{\n    nLoadedBlock = -1;\n    bLoadedBlockDirty = FALSE;\n    pabyBlockBuf = NULL;\n    bWriteErrorInFlushBlockBuf = FALSE;\n    hTIFF = NULL;\n    bNeedsRewrite = FALSE;\n    bMetadataChanged = FALSE;\n    bGeoTIFFInfoChanged = FALSE;\n    bCrystalized = TRUE;\n    poColorTable = NULL;\n    bNoDataSet = FALSE;\n    dfNoDataValue = -9999.0;\n    pszProjection = CPLStrdup(\"\");\n    bLookedForProjection = FALSE;\n    bBase = TRUE;\n    bCloseTIFFHandle = FALSE;\n    bTreatAsRGBA = FALSE;\n    nOverviewCount = 0;\n    papoOverviewDS = NULL;\n    nDirOffset = 0;\n    poActiveDS = NULL;\n    ppoActiveDSRef = NULL;\n\n    bGeoTransformValid = FALSE;\n    adfGeoTransform[0] = 0.0;\n    adfGeoTransform[1] = 1.0;\n    adfGeoTransform[2] = 0.0;\n    adfGeoTransform[3] = 0.0;\n    adfGeoTransform[4] = 0.0;\n    adfGeoTransform[5] = 1.0;\n\n    nGCPCount = 0;\n    pasGCPList = NULL;\n\n    osProfile = \"GDALGeoTIFF\";\n\n    papszCreationOptions = NULL;\n\n    nTempWriteBufferSize = 0;\n    pabyTempWriteBuffer = NULL;\n\n    poMaskDS = NULL;\n    poBaseDS = NULL;\n\n    bFillEmptyTiles = FALSE;\n    bLoadingOtherBands = FALSE;\n    nLastLineRead = -1;\n    nLastBandRead = -1;\n    bTreatAsSplit = FALSE;\n    bTreatAsSplitBitmap = FALSE;\n    bClipWarn = FALSE;\n    bHasWarnedDisableAggressiveBandCaching = FALSE;\n    bDontReloadFirstBlock = FALSE;\n\n    nZLevel = -1;\n    nLZMAPreset = -1;\n    nJpegQuality = -1;\n    \n    bPromoteTo8Bits = FALSE;\n\n    bDebugDontWriteBlocks = CSLTestBoolean(CPLGetConfigOption(\"GTIFF_DONT_WRITE_BLOCKS\", \"NO\"));\n\n    bIsFinalized = FALSE;\n    bIgnoreReadErrors = CSLTestBoolean(CPLGetConfigOption(\"GTIFF_IGNORE_READ_ERRORS\", \"NO\"));\n\n    bHasSearchedRPC = FALSE;\n    bHasSearchedIMD = FALSE;\n}\n\n/************************************************************************/\n/*                           ~GTiffDataset()                            */\n/************************************************************************/\n\nGTiffDataset::~GTiffDataset()\n\n{\n    Finalize();\n}\n\n/************************************************************************/\n/*                             Finalize()                               */\n/************************************************************************/\n\nint GTiffDataset::Finalize()\n{\n    if (bIsFinalized)\n        return FALSE;\n\n    int bHasDroppedRef = FALSE;\n\n    Crystalize();\n\n/* -------------------------------------------------------------------- */\n/*      Handle forcing xml:ESRI data to be written to PAM.              */\n/* -------------------------------------------------------------------- */\n    if( CSLTestBoolean(CPLGetConfigOption( \"ESRI_XML_PAM\", \"NO\" )) )\n    {\n        char **papszESRIMD = GetMetadata(\"xml:ESRI\");\n        if( papszESRIMD )\n        {\n            GDALPamDataset::SetMetadata( papszESRIMD, \"xml:ESRI\");\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Ensure any blocks write cached by GDAL gets pushed through libtiff.*/\n/* -------------------------------------------------------------------- */\n    GDALPamDataset::FlushCache();\n\n/* -------------------------------------------------------------------- */\n/*      Fill in missing blocks with empty data.                         */\n/* -------------------------------------------------------------------- */\n    if( bFillEmptyTiles )\n    {\n        FillEmptyTiles();\n        bFillEmptyTiles = FALSE;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Force a complete flush, including either rewriting(moving)      */\n/*      of writing in place the current directory.                      */\n/* -------------------------------------------------------------------- */\n    FlushCache();\n\n/* -------------------------------------------------------------------- */\n/*      If there is still changed metadata, then presumably we want     */\n/*      to push it into PAM.                                            */\n/* -------------------------------------------------------------------- */\n    if( bMetadataChanged )\n    {\n        PushMetadataToPam();\n        bMetadataChanged = FALSE;\n        GDALPamDataset::FlushCache();\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Cleanup overviews.                                              */\n/* -------------------------------------------------------------------- */\n    if( bBase )\n    {\n        for( int i = 0; i < nOverviewCount; i++ )\n        {\n            delete papoOverviewDS[i];\n            bHasDroppedRef = TRUE;\n        }\n        nOverviewCount = 0;\n    }\n\n    /* If we are a mask dataset, we can have overviews, but we don't */\n    /* own them. We can only free the array, not the overviews themselves */\n    CPLFree( papoOverviewDS );\n    papoOverviewDS = NULL;\n\n    /* poMaskDS is owned by the main image and the overviews */\n    /* so because of the latter case, we can delete it even if */\n    /* we are not the base image */\n    if (poMaskDS)\n    {\n        delete poMaskDS;\n        poMaskDS = NULL;\n        bHasDroppedRef = TRUE;\n    }\n\n    if( poColorTable != NULL )\n        delete poColorTable;\n    poColorTable = NULL;\n\n    if( bBase || bCloseTIFFHandle )\n    {\n        XTIFFClose( hTIFF );\n        hTIFF = NULL;\n    }\n\n    if( nGCPCount > 0 )\n    {\n        GDALDeinitGCPs( nGCPCount, pasGCPList );\n        CPLFree( pasGCPList );\n        pasGCPList = NULL;\n        nGCPCount = 0;\n    }\n\n    CPLFree( pszProjection );\n    pszProjection = NULL;\n\n    CSLDestroy( papszCreationOptions );\n    papszCreationOptions = NULL;\n\n    CPLFree(pabyTempWriteBuffer);\n    pabyTempWriteBuffer = NULL;\n\n    if( *ppoActiveDSRef == this )\n        *ppoActiveDSRef = NULL;\n    ppoActiveDSRef = NULL;\n\n    bIsFinalized = TRUE;\n\n    return bHasDroppedRef;\n}\n\n/************************************************************************/\n/*                        CloseDependentDatasets()                      */\n/************************************************************************/\n\nint GTiffDataset::CloseDependentDatasets()\n{\n    if (!bBase)\n        return FALSE;\n\n    int bHasDroppedRef = GDALPamDataset::CloseDependentDatasets();\n\n    bHasDroppedRef |= Finalize();\n\n    return bHasDroppedRef;\n}\n\n/************************************************************************/\n/*                           FillEmptyTiles()                           */\n/************************************************************************/\n\nvoid GTiffDataset::FillEmptyTiles()\n\n{\n    toff_t *panByteCounts = NULL;\n    int    nBlockCount, iBlock;\n\n    if (!SetDirectory())\n        return;\n\n/* -------------------------------------------------------------------- */\n/*      How many blocks are there in this file?                         */\n/* -------------------------------------------------------------------- */\n    if( nPlanarConfig == PLANARCONFIG_SEPARATE )\n        nBlockCount = nBlocksPerBand * nBands;\n    else\n        nBlockCount = nBlocksPerBand;\n\n/* -------------------------------------------------------------------- */\n/*      Fetch block maps.                                               */\n/* -------------------------------------------------------------------- */\n    if( TIFFIsTiled( hTIFF ) )\n        TIFFGetField( hTIFF, TIFFTAG_TILEBYTECOUNTS, &panByteCounts );\n    else\n        TIFFGetField( hTIFF, TIFFTAG_STRIPBYTECOUNTS, &panByteCounts );\n\n    if (panByteCounts == NULL)\n    {\n        /* Got here with libtiff 3.9.3 and tiff_write_8 test */\n        CPLError(CE_Failure, CPLE_AppDefined, \"FillEmptyTiles() failed because panByteCounts == NULL\");\n        return;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Prepare a blank data buffer to write for uninitialized blocks.  */\n/* -------------------------------------------------------------------- */\n    int nBlockBytes;\n\n    if( TIFFIsTiled( hTIFF ) )\n        nBlockBytes = TIFFTileSize(hTIFF);\n    else\n        nBlockBytes = TIFFStripSize(hTIFF);\n\n    GByte *pabyData = (GByte *) VSICalloc(nBlockBytes,1);\n    if (pabyData == NULL)\n    {\n        CPLError(CE_Failure, CPLE_OutOfMemory,\n                 \"Cannot allocate %d bytes\", nBlockBytes);\n        return;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Check all blocks, writing out data for uninitialized blocks.    */\n/* -------------------------------------------------------------------- */\n    for( iBlock = 0; iBlock < nBlockCount; iBlock++ )\n    {\n        if( panByteCounts[iBlock] == 0 )\n        {\n            if( WriteEncodedTileOrStrip( iBlock, pabyData, FALSE ) != CE_None )\n                break;\n        }\n    }\n\n    CPLFree( pabyData );\n}\n\n/************************************************************************/\n/*                        WriteEncodedTile()                            */\n/************************************************************************/\n\nint GTiffDataset::WriteEncodedTile(uint32 tile, void* data,\n                                   int bPreserveDataBuffer)\n{\n    /* TIFFWriteEncodedTile can alter the passed buffer if byte-swapping is necessary */\n    /* so we use a temporary buffer before calling it */\n    int cc = TIFFTileSize( hTIFF );\n    if (bPreserveDataBuffer && TIFFIsByteSwapped(hTIFF))\n    {\n        if (cc != nTempWriteBufferSize)\n        {\n            pabyTempWriteBuffer = CPLRealloc(pabyTempWriteBuffer, cc);\n            nTempWriteBufferSize = cc;\n        }\n        memcpy(pabyTempWriteBuffer, data, cc);\n        return TIFFWriteEncodedTile(hTIFF, tile, pabyTempWriteBuffer, cc);\n    }\n    else\n        return TIFFWriteEncodedTile(hTIFF, tile, data, cc);\n}\n\n/************************************************************************/\n/*                        WriteEncodedStrip()                           */\n/************************************************************************/\n\nint  GTiffDataset::WriteEncodedStrip(uint32 strip, void* data,\n                                     int bPreserveDataBuffer)\n{\n    int cc = TIFFStripSize( hTIFF );\n    \n/* -------------------------------------------------------------------- */\n/*      If this is the last strip in the image, and is partial, then    */\n/*      we need to trim the number of scanlines written to the          */\n/*      amount of valid data we have. (#2748)                           */\n/* -------------------------------------------------------------------- */\n    int nStripWithinBand = strip % nBlocksPerBand;\n    \n    if( (int) ((nStripWithinBand+1) * nRowsPerStrip) > GetRasterYSize() )\n    {\n        cc = (cc / nRowsPerStrip)\n            * (GetRasterYSize() - nStripWithinBand * nRowsPerStrip);\n        CPLDebug( \"GTiff\", \"Adjusted bytes to write from %d to %d.\", \n                  (int) TIFFStripSize(hTIFF), cc );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      TIFFWriteEncodedStrip can alter the passed buffer if            */\n/*      byte-swapping is necessary so we use a temporary buffer         */\n/*      before calling it.                                              */\n/* -------------------------------------------------------------------- */\n    if (bPreserveDataBuffer && TIFFIsByteSwapped(hTIFF))\n    {\n        if (cc != nTempWriteBufferSize)\n        {\n            pabyTempWriteBuffer = CPLRealloc(pabyTempWriteBuffer, cc);\n            nTempWriteBufferSize = cc;\n        }\n        memcpy(pabyTempWriteBuffer, data, cc);\n        return TIFFWriteEncodedStrip(hTIFF, strip, pabyTempWriteBuffer, cc);\n    }\n    else\n        return TIFFWriteEncodedStrip(hTIFF, strip, data, cc);\n}\n\n/************************************************************************/\n/*                  WriteEncodedTileOrStrip()                           */\n/************************************************************************/\n\nCPLErr  GTiffDataset::WriteEncodedTileOrStrip(uint32 tile_or_strip, void* data,\n                                              int bPreserveDataBuffer)\n{\n    CPLErr eErr = CE_None;\n\n    if( TIFFIsTiled( hTIFF ) )\n    {\n        if( WriteEncodedTile(tile_or_strip, data, bPreserveDataBuffer) == -1 )\n        {\n            eErr = CE_Failure;\n        }\n    }\n    else\n    {\n        if( WriteEncodedStrip(tile_or_strip, data, bPreserveDataBuffer) == -1 )\n        {\n            eErr = CE_Failure;\n        }\n    }\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                           FlushBlockBuf()                            */\n/************************************************************************/\n\nCPLErr GTiffDataset::FlushBlockBuf()\n\n{\n    CPLErr      eErr = CE_None;\n\n    if( nLoadedBlock < 0 || !bLoadedBlockDirty )\n        return CE_None;\n\n    bLoadedBlockDirty = FALSE;\n\n    if (!SetDirectory())\n        return CE_Failure;\n\n    eErr = WriteEncodedTileOrStrip(nLoadedBlock, pabyBlockBuf, TRUE);\n    if (eErr != CE_None)\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                    \"WriteEncodedTile/Strip() failed.\" );\n        bWriteErrorInFlushBlockBuf = TRUE;\n    }\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                            LoadBlockBuf()                            */\n/*                                                                      */\n/*      Load working block buffer with request block (tile/strip).      */\n/************************************************************************/\n\nCPLErr GTiffDataset::LoadBlockBuf( int nBlockId, int bReadFromDisk )\n\n{\n    int\tnBlockBufSize;\n    CPLErr\teErr = CE_None;\n\n    if( nLoadedBlock == nBlockId )\n        return CE_None;\n\n/* -------------------------------------------------------------------- */\n/*      If we have a dirty loaded block, flush it out first.            */\n/* -------------------------------------------------------------------- */\n    if( nLoadedBlock != -1 && bLoadedBlockDirty )\n    {\n        eErr = FlushBlockBuf();\n        if( eErr != CE_None )\n            return eErr;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Get block size.                                                 */\n/* -------------------------------------------------------------------- */\n    if( TIFFIsTiled(hTIFF) )\n        nBlockBufSize = TIFFTileSize( hTIFF );\n    else\n        nBlockBufSize = TIFFStripSize( hTIFF );\n\n    if ( !nBlockBufSize )\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                  \"Bogus block size; unable to allocate a buffer.\");\n        return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Allocate a temporary buffer for this strip.                     */\n/* -------------------------------------------------------------------- */\n    if( pabyBlockBuf == NULL )\n    {\n        pabyBlockBuf = (GByte *) VSICalloc( 1, nBlockBufSize );\n        if( pabyBlockBuf == NULL )\n        {\n            CPLError( CE_Failure, CPLE_OutOfMemory,\n                      \"Unable to allocate %d bytes for a temporary strip \"\n                      \"buffer in GTIFF driver.\",\n                      nBlockBufSize );\n            \n            return( CE_Failure );\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*  When called from ::IWriteBlock in separate cases (or in single band */\n/*  geotiffs), the ::IWriteBlock will override the content of the buffer*/\n/*  with pImage, so we don't need to read data from disk                */\n/* -------------------------------------------------------------------- */\n    if( !bReadFromDisk )\n    {\n        nLoadedBlock = nBlockId;\n        return CE_None;\n    }\n\n    /* libtiff 3.X doesn't like mixing read&write of JPEG compressed blocks */\n    /* The below hack is necessary due to another hack that consist in */\n    /* writing zero block to force creation of JPEG tables */\n    if( nBlockId == 0 && bDontReloadFirstBlock )\n    {\n        bDontReloadFirstBlock = FALSE;\n        memset( pabyBlockBuf, 0, nBlockBufSize );\n        nLoadedBlock = nBlockId;\n        return CE_None;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      The bottom most partial tiles and strips are sometimes only     */\n/*      partially encoded.  This code reduces the requested data so     */\n/*      an error won't be reported in this case. (#1179)                */\n/* -------------------------------------------------------------------- */\n    int nBlockReqSize = nBlockBufSize;\n    int nBlocksPerRow = (nRasterXSize + nBlockXSize - 1) / nBlockXSize;\n    int nBlockYOff = (nBlockId % nBlocksPerBand) / nBlocksPerRow;\n\n    if( (int)((nBlockYOff+1) * nBlockYSize) > nRasterYSize )\n    {\n        nBlockReqSize = (nBlockBufSize / nBlockYSize) \n            * (nBlockYSize - (((nBlockYOff+1) * nBlockYSize) % nRasterYSize));\n        memset( pabyBlockBuf, 0, nBlockBufSize );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If we don't have this block already loaded, and we know it      */\n/*      doesn't yet exist on disk, just zero the memory buffer and      */\n/*      pretend we loaded it.                                           */\n/* -------------------------------------------------------------------- */\n    if( !IsBlockAvailable( nBlockId ) )\n    {\n        memset( pabyBlockBuf, 0, nBlockBufSize );\n        nLoadedBlock = nBlockId;\n        return CE_None;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Load the block, if it isn't our current block.                  */\n/* -------------------------------------------------------------------- */\n    if( TIFFIsTiled( hTIFF ) )\n    {\n        if( TIFFReadEncodedTile(hTIFF, nBlockId, pabyBlockBuf,\n                                nBlockReqSize) == -1\n            && !bIgnoreReadErrors )\n        {\n            /* Once TIFFError() is properly hooked, this can go away */\n            CPLError( CE_Failure, CPLE_AppDefined,\n                      \"TIFFReadEncodedTile() failed.\" );\n                \n            memset( pabyBlockBuf, 0, nBlockBufSize );\n                \n            eErr = CE_Failure;\n        }\n    }\n    else\n    {\n        if( TIFFReadEncodedStrip(hTIFF, nBlockId, pabyBlockBuf,\n                                 nBlockReqSize) == -1\n            && !bIgnoreReadErrors )\n        {\n            /* Once TIFFError() is properly hooked, this can go away */\n            CPLError( CE_Failure, CPLE_AppDefined,\n                      \"TIFFReadEncodedStrip() failed.\" );\n                \n            memset( pabyBlockBuf, 0, nBlockBufSize );\n                \n            eErr = CE_Failure;\n        }\n    }\n\n    nLoadedBlock = nBlockId;\n    bLoadedBlockDirty = FALSE;\n\n    return eErr;\n}\n\n\n/************************************************************************/\n/*                             Crystalize()                             */\n/*                                                                      */\n/*      Make sure that the directory information is written out for     */\n/*      a new file, require before writing any imagery data.            */\n/************************************************************************/\n\nvoid GTiffDataset::Crystalize()\n\n{\n    if( !bCrystalized )\n    {\n        WriteMetadata( this, hTIFF, TRUE, osProfile, osFilename,\n                       papszCreationOptions );\n        WriteGeoTIFFInfo();\n\n        bMetadataChanged = FALSE;\n        bGeoTIFFInfoChanged = FALSE;\n        bNeedsRewrite = FALSE;\n\n        bCrystalized = TRUE;\n\n        TIFFWriteCheck( hTIFF, TIFFIsTiled(hTIFF), \"GTiffDataset::Crystalize\");\n\n        // Keep zip and tiff quality, and jpegcolormode which get reset when we call \n        // TIFFWriteDirectory \n        int jquality = -1, zquality = -1, nColorMode = -1; \n        TIFFGetField(hTIFF, TIFFTAG_JPEGQUALITY, &jquality); \n        TIFFGetField(hTIFF, TIFFTAG_ZIPQUALITY, &zquality); \n        TIFFGetField( hTIFF, TIFFTAG_JPEGCOLORMODE, &nColorMode );\n\n        TIFFWriteDirectory( hTIFF );\n        TIFFSetDirectory( hTIFF, 0 );\n\n\n        // Now, reset zip and tiff quality and jpegcolormode. \n        if(jquality > 0) \n            TIFFSetField(hTIFF, TIFFTAG_JPEGQUALITY, jquality); \n        if(zquality > 0) \n            TIFFSetField(hTIFF, TIFFTAG_ZIPQUALITY, zquality);\n        if (nColorMode >= 0)\n            TIFFSetField(hTIFF, TIFFTAG_JPEGCOLORMODE, nColorMode);\n\n        nDirOffset = TIFFCurrentDirOffset( hTIFF );\n    }\n}\n\n\n/************************************************************************/\n/*                          IsBlockAvailable()                          */\n/*                                                                      */\n/*      Return TRUE if the indicated strip/tile is available.  We       */\n/*      establish this by testing if the stripbytecount is zero.  If    */\n/*      zero then the block has never been committed to disk.           */\n/************************************************************************/\n\nint GTiffDataset::IsBlockAvailable( int nBlockId )\n\n{\n    toff_t *panByteCounts = NULL;\n\n    if( ( TIFFIsTiled( hTIFF ) \n          && TIFFGetField( hTIFF, TIFFTAG_TILEBYTECOUNTS, &panByteCounts ) )\n        || ( !TIFFIsTiled( hTIFF ) \n          && TIFFGetField( hTIFF, TIFFTAG_STRIPBYTECOUNTS, &panByteCounts ) ) )\n    {\n        if( panByteCounts == NULL )\n            return FALSE;\n        else\n            return panByteCounts[nBlockId] != 0;\n    }\n    else\n        return FALSE;\n}\n\n/************************************************************************/\n/*                             FlushCache()                             */\n/*                                                                      */\n/*      We override this so we can also flush out local tiff strip      */\n/*      cache if need be.                                               */\n/************************************************************************/\n\nvoid GTiffDataset::FlushCache()\n\n{\n    if (bIsFinalized)\n        return;\n\n    GDALPamDataset::FlushCache();\n\n    if( bLoadedBlockDirty && nLoadedBlock != -1 )\n        FlushBlockBuf();\n\n    CPLFree( pabyBlockBuf );\n    pabyBlockBuf = NULL;\n    nLoadedBlock = -1;\n    bLoadedBlockDirty = FALSE;\n\n    if (!SetDirectory())\n        return;\n    FlushDirectory();\n}\n\n/************************************************************************/\n/*                           FlushDirectory()                           */\n/************************************************************************/\n\nvoid GTiffDataset::FlushDirectory()\n\n{\n    if( GetAccess() == GA_Update )\n    {\n        if( bMetadataChanged )\n        {\n            if (!SetDirectory())\n                return;\n            bNeedsRewrite = \n                WriteMetadata( this, hTIFF, TRUE, osProfile, osFilename,\n                               papszCreationOptions );\n            bMetadataChanged = FALSE;\n        }\n        \n        if( bGeoTIFFInfoChanged )\n        {\n            if (!SetDirectory())\n                return;\n            WriteGeoTIFFInfo();\n        }\n\n        if( bNeedsRewrite )\n        {\n#if defined(TIFFLIB_VERSION)\n#if defined(HAVE_TIFFGETSIZEPROC)\n            if (!SetDirectory())\n                return;\n\n            TIFFSizeProc pfnSizeProc = TIFFGetSizeProc( hTIFF );\n\n            nDirOffset = pfnSizeProc( TIFFClientdata( hTIFF ) );\n            if( (nDirOffset % 2) == 1 )\n                nDirOffset++;\n\n            TIFFRewriteDirectory( hTIFF );\n\n            TIFFSetSubDirectory( hTIFF, nDirOffset );\n#elif  TIFFLIB_VERSION > 20010925 && TIFFLIB_VERSION != 20011807\n            if (!SetDirectory())\n                return;\n\n            TIFFRewriteDirectory( hTIFF );\n#endif\n#endif\n            bNeedsRewrite = FALSE;\n        }\n    }\n\n    // there are some circumstances in which we can reach this point\n    // without having made this our directory (SetDirectory()) in which\n    // case we should not risk a flush. \n    if( GetAccess() == GA_Update && TIFFCurrentDirOffset(hTIFF) == nDirOffset )\n    {\n#if defined(BIGTIFF_SUPPORT)\n        TIFFSizeProc pfnSizeProc = TIFFGetSizeProc( hTIFF );\n\n        toff_t nNewDirOffset = pfnSizeProc( TIFFClientdata( hTIFF ) );\n        if( (nNewDirOffset % 2) == 1 )\n            nNewDirOffset++;\n\n        TIFFFlush( hTIFF );\n\n        if( nDirOffset != TIFFCurrentDirOffset( hTIFF ) )\n        {\n            nDirOffset = nNewDirOffset;\n            CPLDebug( \"GTiff\", \n                      \"directory moved during flush in FlushDirectory()\" );\n        }\n#else\n        /* For libtiff 3.X, the above causes regressions and crashes in */\n        /* tiff_write.py and tiff_ovr.py */\n        TIFFFlush( hTIFF );\n#endif\n    }\n}\n\n/************************************************************************/\n/*                         TIFF_OvLevelAdjust()                         */\n/*                                                                      */\n/*      Some overview levels cannot be achieved closely enough to be    */\n/*      recognised as the desired overview level.  This function        */\n/*      will adjust an overview level to one that is achievable on      */\n/*      the given raster size.                                          */\n/*                                                                      */\n/*      For instance a 1200x1200 image on which a 256 level overview    */\n/*      is request will end up generating a 5x5 overview.  However,     */\n/*      this will appear to the system be a level 240 overview.         */\n/*      This function will adjust 256 to 240 based on knowledge of      */\n/*      the image size.                                                 */\n/*                                                                      */\n/*      This is a copy of the GDALOvLevelAdjust() function in           */\n/*      gdaldefaultoverviews.cpp.                                       */\n/************************************************************************/\n\nstatic int TIFF_OvLevelAdjust( int nOvLevel, int nXSize )\n\n{\n    int\tnOXSize = (nXSize + nOvLevel - 1) / nOvLevel;\n    \n    return (int) (0.5 + nXSize / (double) nOXSize);\n}\n\n/************************************************************************/\n/*                           CleanOverviews()                           */\n/************************************************************************/\n\nCPLErr GTiffDataset::CleanOverviews()\n\n{\n    CPLAssert( bBase );\n\n    FlushDirectory();\n    *ppoActiveDSRef = NULL;\n\n/* -------------------------------------------------------------------- */\n/*      Cleanup overviews objects, and get offsets to all overview      */\n/*      directories.                                                    */\n/* -------------------------------------------------------------------- */\n    std::vector<toff_t>  anOvDirOffsets;\n    int i;\n\n    for( i = 0; i < nOverviewCount; i++ )\n    {\n        anOvDirOffsets.push_back( papoOverviewDS[i]->nDirOffset );\n        delete papoOverviewDS[i];\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Loop through all the directories, translating the offsets       */\n/*      into indexes we can use with TIFFUnlinkDirectory().             */\n/* -------------------------------------------------------------------- */\n    std::vector<uint16> anOvDirIndexes;\n    int iThisOffset = 1;\n\n    TIFFSetDirectory( hTIFF, 0 );\n    \n    for( ; TRUE; ) \n    {\n        for( i = 0; i < nOverviewCount; i++ )\n        {\n            if( anOvDirOffsets[i] == TIFFCurrentDirOffset( hTIFF ) )\n            {\n                CPLDebug( \"GTiff\", \"%d -> %d\", \n                          (int) anOvDirOffsets[i], iThisOffset );\n                anOvDirIndexes.push_back( (uint16) iThisOffset );\n            }\n        }\n        \n        if( TIFFLastDirectory( hTIFF ) )\n            break;\n\n        TIFFReadDirectory( hTIFF );\n        iThisOffset++;\n    } \n\n/* -------------------------------------------------------------------- */\n/*      Actually unlink the target directories.  Note that we do        */\n/*      this from last to first so as to avoid renumbering any of       */\n/*      the earlier directories we need to remove.                      */\n/* -------------------------------------------------------------------- */\n    while( !anOvDirIndexes.empty() )\n    {\n        TIFFUnlinkDirectory( hTIFF, anOvDirIndexes.back() );\n        anOvDirIndexes.pop_back();\n    }\n\n    CPLFree( papoOverviewDS );\n\n    nOverviewCount = 0;\n    papoOverviewDS = NULL;\n\n    if (!SetDirectory())\n        return CE_Failure;\n\n    return CE_None;\n}\n\n\n/************************************************************************/\n/*                   RegisterNewOverviewDataset()                       */\n/************************************************************************/\n\nCPLErr GTiffDataset::RegisterNewOverviewDataset(toff_t nOverviewOffset)\n{\n    GTiffDataset* poODS = new GTiffDataset();\n    poODS->nJpegQuality = nJpegQuality;\n    poODS->nZLevel = nZLevel;\n    poODS->nLZMAPreset = nLZMAPreset;\n\n    if( nCompression == COMPRESSION_JPEG )\n    {\n        if ( CPLGetConfigOption( \"JPEG_QUALITY_OVERVIEW\", NULL ) != NULL )\n        {\n            poODS->nJpegQuality =  atoi(CPLGetConfigOption(\"JPEG_QUALITY_OVERVIEW\",\"75\"));\n        }\n        TIFFSetField( hTIFF, TIFFTAG_JPEGQUALITY,\n                        poODS->nJpegQuality );\n    }\n\n    if( poODS->OpenOffset( hTIFF, ppoActiveDSRef, nOverviewOffset, FALSE,\n                            GA_Update ) != CE_None )\n    {\n        delete poODS;\n        return CE_Failure;\n    }\n    else\n    {\n        nOverviewCount++;\n        papoOverviewDS = (GTiffDataset **)\n            CPLRealloc(papoOverviewDS,\n                        nOverviewCount * (sizeof(void*)));\n        papoOverviewDS[nOverviewCount-1] = poODS;\n        poODS->poBaseDS = this;\n        return CE_None;\n    }\n}\n\n/************************************************************************/\n/*                  CreateOverviewsFromSrcOverviews()                   */\n/************************************************************************/\n\nCPLErr GTiffDataset::CreateOverviewsFromSrcOverviews(GDALDataset* poSrcDS)\n{\n    CPLAssert(poSrcDS->GetRasterCount() != 0);\n    CPLAssert(nOverviewCount == 0);\n\n/* -------------------------------------------------------------------- */\n/*      Move to the directory for this dataset.                         */\n/* -------------------------------------------------------------------- */\n    if (!SetDirectory())\n        return CE_Failure;\n    FlushDirectory();\n\n    int nOvBitsPerSample = nBitsPerSample;\n\n/* -------------------------------------------------------------------- */\n/*      Do we have a palette?  If so, create a TIFF compatible version. */\n/* -------------------------------------------------------------------- */\n    std::vector<unsigned short> anTRed, anTGreen, anTBlue;\n    unsigned short      *panRed=NULL, *panGreen=NULL, *panBlue=NULL;\n\n    if( nPhotometric == PHOTOMETRIC_PALETTE && poColorTable != NULL )\n    {\n        int nColors;\n\n        if( nOvBitsPerSample == 8 )\n            nColors = 256;\n        else if( nOvBitsPerSample < 8 )\n            nColors = 1 << nOvBitsPerSample;\n        else\n            nColors = 65536;\n\n        anTRed.resize(nColors,0);\n        anTGreen.resize(nColors,0);\n        anTBlue.resize(nColors,0);\n\n        for( int iColor = 0; iColor < nColors; iColor++ )\n        {\n            if( iColor < poColorTable->GetColorEntryCount() )\n            {\n                GDALColorEntry  sRGB;\n\n                poColorTable->GetColorEntryAsRGB( iColor, &sRGB );\n\n                anTRed[iColor] = (unsigned short) (256 * sRGB.c1);\n                anTGreen[iColor] = (unsigned short) (256 * sRGB.c2);\n                anTBlue[iColor] = (unsigned short) (256 * sRGB.c3);\n            }\n            else\n            {\n                anTRed[iColor] = anTGreen[iColor] = anTBlue[iColor] = 0;\n            }\n        }\n\n        panRed = &(anTRed[0]);\n        panGreen = &(anTGreen[0]);\n        panBlue = &(anTBlue[0]);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Do we need some metadata for the overviews?                     */\n/* -------------------------------------------------------------------- */\n    CPLString osMetadata;\n\n    GTIFFBuildOverviewMetadata( \"NONE\", this, osMetadata );\n\n/* -------------------------------------------------------------------- */\n/*      Fetch extra sample tag                                          */\n/* -------------------------------------------------------------------- */\n    uint16 *panExtraSampleValues = NULL;\n    uint16 nExtraSamples = 0;\n\n    if( TIFFGetField( hTIFF, TIFFTAG_EXTRASAMPLES, &nExtraSamples, &panExtraSampleValues) )\n    {\n        uint16* panExtraSampleValuesNew = (uint16*) CPLMalloc(nExtraSamples * sizeof(uint16));\n        memcpy(panExtraSampleValuesNew, panExtraSampleValues, nExtraSamples * sizeof(uint16));\n        panExtraSampleValues = panExtraSampleValuesNew;\n    }\n    else\n    {\n        panExtraSampleValues = NULL;\n        nExtraSamples = 0;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Fetch predictor tag                                             */\n/* -------------------------------------------------------------------- */\n    uint16 nPredictor = PREDICTOR_NONE;\n    if ( nCompression == COMPRESSION_LZW ||\n         nCompression == COMPRESSION_ADOBE_DEFLATE )\n        TIFFGetField( hTIFF, TIFFTAG_PREDICTOR, &nPredictor );\n    int nOvrBlockXSize, nOvrBlockYSize;\n    GTIFFGetOverviewBlockSize(&nOvrBlockXSize, &nOvrBlockYSize);\n\n    int nSrcOverviews = poSrcDS->GetRasterBand(1)->GetOverviewCount();\n    int i;\n    CPLErr eErr = CE_None;\n\n    for(i=0;i<nSrcOverviews && eErr == CE_None;i++)\n    {\n        GDALRasterBand* poOvrBand = poSrcDS->GetRasterBand(1)->GetOverview(i);\n\n        int         nOXSize = poOvrBand->GetXSize(), nOYSize = poOvrBand->GetYSize();\n\n        toff_t nOverviewOffset =\n                GTIFFWriteDirectory(hTIFF, FILETYPE_REDUCEDIMAGE,\n                                    nOXSize, nOYSize,\n                                    nOvBitsPerSample, nPlanarConfig,\n                                    nSamplesPerPixel, nOvrBlockXSize, nOvrBlockYSize, TRUE,\n                                    nCompression, nPhotometric, nSampleFormat,\n                                    nPredictor,\n                                    panRed, panGreen, panBlue,\n                                    nExtraSamples, panExtraSampleValues,\n                                    osMetadata );\n\n        if( nOverviewOffset == 0 )\n            eErr = CE_Failure;\n        else\n            eErr = RegisterNewOverviewDataset(nOverviewOffset);\n    }\n\n    CPLFree(panExtraSampleValues);\n    panExtraSampleValues = NULL;\n\n/* -------------------------------------------------------------------- */\n/*      Create overviews for the mask.                                  */\n/* -------------------------------------------------------------------- */\n    if (eErr == CE_None)\n        eErr = CreateInternalMaskOverviews(nOvrBlockXSize, nOvrBlockYSize);\n\n    return eErr;\n}\n\n\n/************************************************************************/\n/*                       CreateInternalMaskOverviews()                  */\n/************************************************************************/\n\nCPLErr GTiffDataset::CreateInternalMaskOverviews(int nOvrBlockXSize,\n                                                 int nOvrBlockYSize)\n{\n    GTiffDataset *poODS;\n/* -------------------------------------------------------------------- */\n/*      Create overviews for the mask.                                  */\n/* -------------------------------------------------------------------- */\n    CPLErr eErr = CE_None;\n\n    if (poMaskDS != NULL &&\n        poMaskDS->GetRasterCount() == 1 &&\n        CSLTestBoolean(CPLGetConfigOption(\"GDAL_TIFF_INTERNAL_MASK\", \"NO\")))\n    {\n        int nMaskOvrCompression;\n        if( strstr(GDALGetMetadataItem(GDALGetDriverByName( \"GTiff\" ),\n                                       GDAL_DMD_CREATIONOPTIONLIST, NULL ),\n                   \"<Value>DEFLATE</Value>\") != NULL )\n            nMaskOvrCompression = COMPRESSION_ADOBE_DEFLATE;\n        else\n            nMaskOvrCompression = COMPRESSION_PACKBITS;\n\n        int i;\n        for( i = 0; i < nOverviewCount; i++ )\n        {\n            if (papoOverviewDS[i]->poMaskDS == NULL)\n            {\n                toff_t  nOverviewOffset;\n\n                nOverviewOffset =\n                    GTIFFWriteDirectory(hTIFF, FILETYPE_REDUCEDIMAGE | FILETYPE_MASK,\n                                        papoOverviewDS[i]->nRasterXSize, papoOverviewDS[i]->nRasterYSize,\n                                        1, PLANARCONFIG_CONTIG,\n                                        1, nOvrBlockXSize, nOvrBlockYSize, TRUE,\n                                        nMaskOvrCompression, PHOTOMETRIC_MASK, SAMPLEFORMAT_UINT, PREDICTOR_NONE,\n                                        NULL, NULL, NULL, 0, NULL,\n                                        \"\" );\n\n                if( nOverviewOffset == 0 )\n                {\n                    eErr = CE_Failure;\n                    continue;\n                }\n\n                poODS = new GTiffDataset();\n                if( poODS->OpenOffset( hTIFF, ppoActiveDSRef,\n                                       nOverviewOffset, FALSE,\n                                       GA_Update ) != CE_None )\n                {\n                    delete poODS;\n                    eErr = CE_Failure;\n                }\n                else\n                {\n                    poODS->bPromoteTo8Bits = CSLTestBoolean(CPLGetConfigOption(\"GDAL_TIFF_INTERNAL_MASK_TO_8BIT\", \"YES\"));\n                    poODS->poBaseDS = this;\n                    papoOverviewDS[i]->poMaskDS = poODS;\n                    poMaskDS->nOverviewCount++;\n                    poMaskDS->papoOverviewDS = (GTiffDataset **)\n                    CPLRealloc(poMaskDS->papoOverviewDS,\n                               poMaskDS->nOverviewCount * (sizeof(void*)));\n                    poMaskDS->papoOverviewDS[poMaskDS->nOverviewCount-1] = poODS;\n                }\n            }\n        }\n    }\n\n    return eErr;\n}\n\n/************************************************************************/\n/*                          IBuildOverviews()                           */\n/************************************************************************/\n\nCPLErr GTiffDataset::IBuildOverviews( \n    const char * pszResampling, \n    int nOverviews, int * panOverviewList,\n    int nBands, int * panBandList,\n    GDALProgressFunc pfnProgress, void * pProgressData )\n\n{\n    CPLErr       eErr = CE_None;\n    int          i;\n    GTiffDataset *poODS;\n\n/* -------------------------------------------------------------------- */\n/*      If RRD or external OVR overviews requested, then invoke         */\n/*      generic handling.                                               */\n/* -------------------------------------------------------------------- */\n    if( CSLTestBoolean(CPLGetConfigOption( \"USE_RRD\", \"NO\" )) \n        || CSLTestBoolean(CPLGetConfigOption( \"TIFF_USE_OVR\", \"NO\" )) )\n    {\n        return GDALDataset::IBuildOverviews( \n            pszResampling, nOverviews, panOverviewList, \n            nBands, panBandList, pfnProgress, pProgressData );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If we don't have read access, then create the overviews         */\n/*      externally.                                                     */\n/* -------------------------------------------------------------------- */\n    if( GetAccess() != GA_Update )\n    {\n        CPLDebug( \"GTiff\",\n                  \"File open for read-only accessing, \"\n                  \"creating overviews externally.\" );\n\n        return GDALDataset::IBuildOverviews( \n            pszResampling, nOverviews, panOverviewList, \n            nBands, panBandList, pfnProgress, pProgressData );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Our TIFF overview support currently only works safely if all    */\n/*      bands are handled at the same time.                             */\n/* -------------------------------------------------------------------- */\n    if( nBands != GetRasterCount() )\n    {\n        CPLError( CE_Failure, CPLE_NotSupported,\n                  \"Generation of overviews in TIFF currently only\"\n                  \" supported when operating on all bands.\\n\" \n                  \"Operation failed.\\n\" );\n        return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Initialize progress counter.                                    */\n/* -------------------------------------------------------------------- */\n    if( !pfnProgress( 0.0, NULL, pProgressData ) )\n    {\n        CPLError( CE_Failure, CPLE_UserInterrupt, \"User terminated\" );\n        return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If zero overviews were requested, we need to clear all          */\n/*      existing overviews.                                             */\n/* -------------------------------------------------------------------- */\n    if( nOverviews == 0 )\n    {\n        if( nOverviewCount == 0 )\n            return GDALDataset::IBuildOverviews( \n                pszResampling, nOverviews, panOverviewList, \n                nBands, panBandList, pfnProgress, pProgressData );\n        else\n            return CleanOverviews();\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Move to the directory for this dataset.                         */\n/* -------------------------------------------------------------------- */\n    if (!SetDirectory())\n        return CE_Failure;\n    FlushDirectory();\n\n/* -------------------------------------------------------------------- */\n/*      If we are averaging bit data to grayscale we need to create     */\n/*      8bit overviews.                                                 */\n/* -------------------------------------------------------------------- */\n    int nOvBitsPerSample = nBitsPerSample;\n\n    if( EQUALN(pszResampling,\"AVERAGE_BIT2\",12) )\n        nOvBitsPerSample = 8;\n\n/* -------------------------------------------------------------------- */\n/*      Do we have a palette?  If so, create a TIFF compatible version. */\n/* -------------------------------------------------------------------- */\n    std::vector<unsigned short> anTRed, anTGreen, anTBlue;\n    unsigned short      *panRed=NULL, *panGreen=NULL, *panBlue=NULL;\n\n    if( nPhotometric == PHOTOMETRIC_PALETTE && poColorTable != NULL )\n    {\n        int nColors;\n\n        if( nOvBitsPerSample == 8 )\n            nColors = 256;\n        else if( nOvBitsPerSample < 8 )\n            nColors = 1 << nOvBitsPerSample;\n        else\n            nColors = 65536;\n        \n        anTRed.resize(nColors,0);\n        anTGreen.resize(nColors,0);\n        anTBlue.resize(nColors,0);\n        \n        for( int iColor = 0; iColor < nColors; iColor++ )\n        {\n            if( iColor < poColorTable->GetColorEntryCount() )\n            {\n                GDALColorEntry  sRGB;\n\n                poColorTable->GetColorEntryAsRGB( iColor, &sRGB );\n\n                anTRed[iColor] = (unsigned short) (256 * sRGB.c1);\n                anTGreen[iColor] = (unsigned short) (256 * sRGB.c2);\n                anTBlue[iColor] = (unsigned short) (256 * sRGB.c3);\n            }\n            else\n            {\n                anTRed[iColor] = anTGreen[iColor] = anTBlue[iColor] = 0;\n            }\n        }\n\n        panRed = &(anTRed[0]);\n        panGreen = &(anTGreen[0]);\n        panBlue = &(anTBlue[0]);\n    }\n        \n/* -------------------------------------------------------------------- */\n/*      Do we need some metadata for the overviews?                     */\n/* -------------------------------------------------------------------- */\n    CPLString osMetadata;\n\n    GTIFFBuildOverviewMetadata( pszResampling, this, osMetadata );\n\n/* -------------------------------------------------------------------- */\n/*      Fetch extra sample tag                                          */\n/* -------------------------------------------------------------------- */\n    uint16 *panExtraSampleValues = NULL;\n    uint16 nExtraSamples = 0;\n\n    if( TIFFGetField( hTIFF, TIFFTAG_EXTRASAMPLES, &nExtraSamples, &panExtraSampleValues) )\n    {\n        uint16* panExtraSampleValuesNew = (uint16*) CPLMalloc(nExtraSamples * sizeof(uint16));\n        memcpy(panExtraSampleValuesNew, panExtraSampleValues, nExtraSamples * sizeof(uint16));\n        panExtraSampleValues = panExtraSampleValuesNew;\n    }\n    else\n    {\n        panExtraSampleValues = NULL;\n        nExtraSamples = 0;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Fetch predictor tag                                             */\n/* -------------------------------------------------------------------- */\n    uint16 nPredictor = PREDICTOR_NONE;\n    if ( nCompression == COMPRESSION_LZW ||\n         nCompression == COMPRESSION_ADOBE_DEFLATE )\n        TIFFGetField( hTIFF, TIFFTAG_PREDICTOR, &nPredictor );\n\n/* -------------------------------------------------------------------- */\n/*      Establish which of the overview levels we already have, and     */\n/*      which are new.  We assume that band 1 of the file is            */\n/*      representative.                                                 */\n/* -------------------------------------------------------------------- */\n    int nOvrBlockXSize, nOvrBlockYSize;\n    GTIFFGetOverviewBlockSize(&nOvrBlockXSize, &nOvrBlockYSize);\n    for( i = 0; i < nOverviews && eErr == CE_None; i++ )\n    {\n        int   j;\n\n        for( j = 0; j < nOverviewCount && eErr == CE_None; j++ )\n        {\n            int    nOvFactor;\n\n            poODS = papoOverviewDS[j];\n\n            nOvFactor = (int) \n                (0.5 + GetRasterXSize() / (double) poODS->GetRasterXSize());\n\n            if( nOvFactor == panOverviewList[i] \n                || nOvFactor == TIFF_OvLevelAdjust( panOverviewList[i],\n                                                    GetRasterXSize() ) )\n                panOverviewList[i] *= -1;\n        }\n\n        if( panOverviewList[i] > 0 )\n        {\n            toff_t\tnOverviewOffset;\n            int         nOXSize, nOYSize;\n\n            nOXSize = (GetRasterXSize() + panOverviewList[i] - 1) \n                / panOverviewList[i];\n            nOYSize = (GetRasterYSize() + panOverviewList[i] - 1)\n                / panOverviewList[i];\n\n            nOverviewOffset = \n                GTIFFWriteDirectory(hTIFF, FILETYPE_REDUCEDIMAGE,\n                                    nOXSize, nOYSize, \n                                    nOvBitsPerSample, nPlanarConfig,\n                                    nSamplesPerPixel, nOvrBlockXSize, nOvrBlockYSize, TRUE,\n                                    nCompression, nPhotometric, nSampleFormat, \n                                    nPredictor,\n                                    panRed, panGreen, panBlue,\n                                    nExtraSamples, panExtraSampleValues,\n                                    osMetadata );\n\n\n            if( nOverviewOffset == 0 )\n                eErr = CE_Failure;\n            else\n                eErr = RegisterNewOverviewDataset(nOverviewOffset);\n        }\n        else\n            panOverviewList[i] *= -1;\n    }\n\n    CPLFree(panExtraSampleValues);\n    panExtraSampleValues = NULL;\n\n/* -------------------------------------------------------------------- */\n/*      Create overviews for the mask.                                  */\n/* -------------------------------------------------------------------- */\n    if (eErr == CE_None)\n        eErr = CreateInternalMaskOverviews(nOvrBlockXSize, nOvrBlockYSize);\n    else\n        return eErr;\n\n/* -------------------------------------------------------------------- */\n/*      Refresh overviews for the mask                                  */\n/* -------------------------------------------------------------------- */\n    if (poMaskDS != NULL &&\n        poMaskDS->GetRasterCount() == 1)\n    {\n        GDALRasterBand **papoOverviewBands;\n        int nMaskOverviews = 0;\n\n        papoOverviewBands = (GDALRasterBand **) CPLCalloc(sizeof(void*),nOverviewCount);\n        for( i = 0; i < nOverviewCount; i++ )\n        {\n            if (papoOverviewDS[i]->poMaskDS != NULL)\n            {\n                papoOverviewBands[nMaskOverviews ++] =\n                        papoOverviewDS[i]->poMaskDS->GetRasterBand(1);\n            }\n        }\n        eErr = GDALRegenerateOverviews( (GDALRasterBandH) \n                                        poMaskDS->GetRasterBand(1),\n                                        nMaskOverviews, \n                                        (GDALRasterBandH *) papoOverviewBands,\n                                        pszResampling, GDALDummyProgress, NULL);\n        CPLFree(papoOverviewBands);\n    }\n\n\n/* -------------------------------------------------------------------- */\n/*      Refresh old overviews that were listed.                         */\n/* -------------------------------------------------------------------- */\n    if (nCompression != COMPRESSION_NONE &&\n        nPlanarConfig == PLANARCONFIG_CONTIG &&\n        GDALDataTypeIsComplex(GetRasterBand( panBandList[0] )->GetRasterDataType()) == FALSE &&\n        GetRasterBand( panBandList[0] )->GetColorTable() == NULL &&\n        (EQUALN(pszResampling, \"NEAR\", 4) || EQUAL(pszResampling, \"AVERAGE\") || EQUAL(pszResampling, \"GAUSS\")))\n    {\n        /* In the case of pixel interleaved compressed overviews, we want to generate */\n        /* the overviews for all the bands block by block, and not band after band, */\n        /* in order to write the block once and not loose space in the TIFF file */\n\n        GDALRasterBand ***papapoOverviewBands;\n        GDALRasterBand  **papoBandList;\n\n        int nNewOverviews = 0;\n        int iBand;\n\n        papapoOverviewBands = (GDALRasterBand ***) CPLCalloc(sizeof(void*),nBands);\n        papoBandList = (GDALRasterBand **) CPLCalloc(sizeof(void*),nBands);\n        for( iBand = 0; iBand < nBands; iBand++ )\n        {\n            GDALRasterBand* poBand = GetRasterBand( panBandList[iBand] );\n\n            papoBandList[iBand] = poBand;\n            papapoOverviewBands[iBand] = (GDALRasterBand **) CPLCalloc(sizeof(void*), poBand->GetOverviewCount());\n\n            int iCurOverview = 0;\n            for( i = 0; i < nOverviews; i++ )\n            {\n                int   j;\n\n                for( j = 0; j < poBand->GetOverviewCount(); j++ )\n                {\n                    int    nOvFactor;\n                    GDALRasterBand * poOverview = poBand->GetOverview( j );\n\n                    nOvFactor = (int) \n                    (0.5 + poBand->GetXSize() / (double) poOverview->GetXSize());\n\n                    int bHasNoData;\n                    double noDataValue = poBand->GetNoDataValue(&bHasNoData);\n\n                    if (bHasNoData)\n                        poOverview->SetNoDataValue(noDataValue);\n\n                    if( nOvFactor == panOverviewList[i] \n                        || nOvFactor == TIFF_OvLevelAdjust( panOverviewList[i],\n                                                            poBand->GetXSize() ) )\n                    {\n                        papapoOverviewBands[iBand][iCurOverview] = poOverview;\n                        iCurOverview++ ;\n                        break;\n                    }\n                }\n            }\n\n            if (nNewOverviews == 0)\n                nNewOverviews = iCurOverview;\n            else if (nNewOverviews != iCurOverview)\n            {\n                CPLAssert(0);\n                return CE_Failure;\n            }\n        }\n\n        GDALRegenerateOverviewsMultiBand(nBands, papoBandList,\n                                         nNewOverviews, papapoOverviewBands,\n                                         pszResampling, pfnProgress, pProgressData );\n\n        for( iBand = 0; iBand < nBands; iBand++ )\n        {\n            CPLFree(papapoOverviewBands[iBand]);\n        }\n        CPLFree(papapoOverviewBands);\n        CPLFree(papoBandList);\n    }\n    else\n    {\n        GDALRasterBand **papoOverviewBands;\n\n        papoOverviewBands = (GDALRasterBand **) \n            CPLCalloc(sizeof(void*),nOverviews);\n\n        for( int iBand = 0; iBand < nBands && eErr == CE_None; iBand++ )\n        {\n            GDALRasterBand *poBand;\n            int            nNewOverviews;\n\n            poBand = GetRasterBand( panBandList[iBand] );\n\n            nNewOverviews = 0;\n            for( i = 0; i < nOverviews && poBand != NULL; i++ )\n            {\n                int   j;\n\n                for( j = 0; j < poBand->GetOverviewCount(); j++ )\n                {\n                    int    nOvFactor;\n                    GDALRasterBand * poOverview = poBand->GetOverview( j );\n\n                    int bHasNoData;\n                    double noDataValue = poBand->GetNoDataValue(&bHasNoData);\n\n                    if (bHasNoData)\n                        poOverview->SetNoDataValue(noDataValue);\n\n                    nOvFactor = (int) \n                    (0.5 + poBand->GetXSize() / (double) poOverview->GetXSize());\n\n                    if( nOvFactor == panOverviewList[i] \n                        || nOvFactor == TIFF_OvLevelAdjust( panOverviewList[i],\n                                                            poBand->GetXSize() ) )\n                    {\n                        papoOverviewBands[nNewOverviews++] = poOverview;\n                        break;\n                    }\n                }\n            }\n\n            void         *pScaledProgressData;\n\n            pScaledProgressData = \n                GDALCreateScaledProgress( iBand / (double) nBands, \n                                        (iBand+1) / (double) nBands,\n                                        pfnProgress, pProgressData );\n\n            eErr = GDALRegenerateOverviews( (GDALRasterBandH) poBand,\n                                            nNewOverviews, \n                                            (GDALRasterBandH *) papoOverviewBands,\n                                            pszResampling, \n                                            GDALScaledProgress, \n                                            pScaledProgressData);\n\n            GDALDestroyScaledProgress( pScaledProgressData );\n        }\n\n    /* -------------------------------------------------------------------- */\n    /*      Cleanup                                                         */\n    /* -------------------------------------------------------------------- */\n        CPLFree( papoOverviewBands );\n    }\n\n\n    pfnProgress( 1.0, NULL, pProgressData );\n\n    return eErr;\n}\n\n\n/************************************************************************/\n/*                          WriteGeoTIFFInfo()                          */\n/************************************************************************/\n\nvoid GTiffDataset::WriteGeoTIFFInfo()\n\n{\n    bool bPixelIsPoint = false;\n    int  bPointGeoIgnore = FALSE;\n\n    if( GetMetadataItem( GDALMD_AREA_OR_POINT ) \n        && EQUAL(GetMetadataItem(GDALMD_AREA_OR_POINT),\n                 GDALMD_AOP_POINT) )\n    {\n        bPixelIsPoint = true;\n        bPointGeoIgnore = \n            CSLTestBoolean( CPLGetConfigOption(\"GTIFF_POINT_GEO_IGNORE\",\n                                               \"FALSE\") );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If the geotransform is the default, don't bother writing it.    */\n/* -------------------------------------------------------------------- */\n    if( adfGeoTransform[0] != 0.0 || adfGeoTransform[1] != 1.0\n        || adfGeoTransform[2] != 0.0 || adfGeoTransform[3] != 0.0\n        || adfGeoTransform[4] != 0.0 || ABS(adfGeoTransform[5]) != 1.0 )\n    {\n        bNeedsRewrite = TRUE;\n\n/* -------------------------------------------------------------------- */\n/*      Clear old tags to ensure we don't end up with conflicting       */\n/*      information. (#2625)                                            */\n/* -------------------------------------------------------------------- */\n#ifdef HAVE_UNSETFIELD\n        TIFFUnsetField( hTIFF, TIFFTAG_GEOPIXELSCALE );\n        TIFFUnsetField( hTIFF, TIFFTAG_GEOTIEPOINTS );\n        TIFFUnsetField( hTIFF, TIFFTAG_GEOTRANSMATRIX );\n#endif\n\n/* -------------------------------------------------------------------- */\n/*      Write the transform.  If we have a normal north-up image we     */\n/*      use the tiepoint plus pixelscale otherwise we use a matrix.     */\n/* -------------------------------------------------------------------- */\n\tif( adfGeoTransform[2] == 0.0 && adfGeoTransform[4] == 0.0 \n            && adfGeoTransform[5] < 0.0 )\n\t{\n\t    double\tadfPixelScale[3], adfTiePoints[6];\n\n\t    adfPixelScale[0] = adfGeoTransform[1];\n\t    adfPixelScale[1] = fabs(adfGeoTransform[5]);\n\t    adfPixelScale[2] = 0.0;\n\n            if( !EQUAL(osProfile,\"BASELINE\") )\n                TIFFSetField( hTIFF, TIFFTAG_GEOPIXELSCALE, 3, adfPixelScale );\n\t    \n\t    adfTiePoints[0] = 0.0;\n\t    adfTiePoints[1] = 0.0;\n\t    adfTiePoints[2] = 0.0;\n\t    adfTiePoints[3] = adfGeoTransform[0];\n\t    adfTiePoints[4] = adfGeoTransform[3];\n\t    adfTiePoints[5] = 0.0;\n\n            if( bPixelIsPoint && !bPointGeoIgnore )\n            {\n                adfTiePoints[3] += adfGeoTransform[1] * 0.5 + adfGeoTransform[2] * 0.5;\n                adfTiePoints[4] += adfGeoTransform[4] * 0.5 + adfGeoTransform[5] * 0.5;\n            }\n\t    \n            if( !EQUAL(osProfile,\"BASELINE\") )\n                TIFFSetField( hTIFF, TIFFTAG_GEOTIEPOINTS, 6, adfTiePoints );\n\t}\n\telse\n\t{\n\t    double\tadfMatrix[16];\n\t    \n\t    memset(adfMatrix,0,sizeof(double) * 16);\n\t    \n\t    adfMatrix[0] = adfGeoTransform[1];\n\t    adfMatrix[1] = adfGeoTransform[2];\n\t    adfMatrix[3] = adfGeoTransform[0];\n\t    adfMatrix[4] = adfGeoTransform[4];\n\t    adfMatrix[5] = adfGeoTransform[5];\n\t    adfMatrix[7] = adfGeoTransform[3];\n\t    adfMatrix[15] = 1.0;\n\t    \n            if( bPixelIsPoint && !bPointGeoIgnore )\n            {\n                adfMatrix[3] += adfGeoTransform[1] * 0.5 + adfGeoTransform[2] * 0.5;\n                adfMatrix[7] += adfGeoTransform[4] * 0.5 + adfGeoTransform[5] * 0.5;\n            }\n\n            if( !EQUAL(osProfile,\"BASELINE\") )\n                TIFFSetField( hTIFF, TIFFTAG_GEOTRANSMATRIX, 16, adfMatrix );\n\t}\n\n        // Do we need a world file?\n        if( CSLFetchBoolean( papszCreationOptions, \"TFW\", FALSE ) )\n            GDALWriteWorldFile( osFilename, \"tfw\", adfGeoTransform );\n        else if( CSLFetchBoolean( papszCreationOptions, \"WORLDFILE\", FALSE ) )\n            GDALWriteWorldFile( osFilename, \"wld\", adfGeoTransform );\n    }\n    else if( GetGCPCount() > 0 )\n    {\n\tdouble\t*padfTiePoints;\n\tint\t\tiGCP;\n        bNeedsRewrite = TRUE;\n\t\n\tpadfTiePoints = (double *) \n\t    CPLMalloc( 6 * sizeof(double) * GetGCPCount() );\n\n\tfor( iGCP = 0; iGCP < GetGCPCount(); iGCP++ )\n\t{\n\n\t    padfTiePoints[iGCP*6+0] = pasGCPList[iGCP].dfGCPPixel;\n\t    padfTiePoints[iGCP*6+1] = pasGCPList[iGCP].dfGCPLine;\n\t    padfTiePoints[iGCP*6+2] = 0;\n\t    padfTiePoints[iGCP*6+3] = pasGCPList[iGCP].dfGCPX;\n\t    padfTiePoints[iGCP*6+4] = pasGCPList[iGCP].dfGCPY;\n\t    padfTiePoints[iGCP*6+5] = pasGCPList[iGCP].dfGCPZ;\n\n            if( bPixelIsPoint && !bPointGeoIgnore )\n            {\n                padfTiePoints[iGCP*6+0] += 0.5;\n                padfTiePoints[iGCP*6+1] += 0.5;\n            }\n\t}\n\n        if( !EQUAL(osProfile,\"BASELINE\") )\n            TIFFSetField( hTIFF, TIFFTAG_GEOTIEPOINTS, \n                          6 * GetGCPCount(), padfTiePoints );\n\tCPLFree( padfTiePoints );\n    }\n\n/* -------------------------------------------------------------------- */\n/*\tWrite out projection definition.\t\t\t\t*/\n/* -------------------------------------------------------------------- */\n    if( pszProjection != NULL && !EQUAL( pszProjection, \"\" )\n        && !EQUAL(osProfile,\"BASELINE\") )\n    {\n        GTIF\t*psGTIF;\n\n        bNeedsRewrite = TRUE;\n\n        // If we have existing geokeys, try to wipe them\n        // by writing a dummy goekey directory. (#2546)\n        uint16 *panVI = NULL;\n        uint16 nKeyCount;\n\n        if( TIFFGetField( hTIFF, TIFFTAG_GEOKEYDIRECTORY, \n                          &nKeyCount, &panVI ) )\n        {\n            GUInt16 anGKVersionInfo[4] = { 1, 1, 0, 0 };\n            double  adfDummyDoubleParams[1] = { 0.0 };\n            TIFFSetField( hTIFF, TIFFTAG_GEOKEYDIRECTORY, \n                          4, anGKVersionInfo );\n            TIFFSetField( hTIFF, TIFFTAG_GEODOUBLEPARAMS, \n                          1, adfDummyDoubleParams );\n            TIFFSetField( hTIFF, TIFFTAG_GEOASCIIPARAMS, \"\" );\n        }\n\n        psGTIF = GTIFNew( hTIFF );  \n\n        // set according to coordinate system.\n        GTIFSetFromOGISDefn( psGTIF, pszProjection );\n\n        if( bPixelIsPoint )\n        {\n            GTIFKeySet(psGTIF, GTRasterTypeGeoKey, TYPE_SHORT, 1,\n                       RasterPixelIsPoint);\n        }\n\n        GTIFWriteKeys( psGTIF );\n        GTIFFree( psGTIF );\n    }\n}\n\n/************************************************************************/\n/*                         AppendMetadataItem()                         */\n/************************************************************************/\n\nstatic void AppendMetadataItem( CPLXMLNode **ppsRoot, CPLXMLNode **ppsTail,\n                                const char *pszKey, const char *pszValue,\n                                int nBand, const char *pszRole, \n                                const char *pszDomain )\n\n{\n    char szBandId[32];\n    CPLXMLNode *psItem;\n\n/* -------------------------------------------------------------------- */\n/*      Create the Item element, and subcomponents.                     */\n/* -------------------------------------------------------------------- */\n    psItem = CPLCreateXMLNode( NULL, CXT_Element, \"Item\" );\n    CPLCreateXMLNode( CPLCreateXMLNode( psItem, CXT_Attribute, \"name\"),\n                      CXT_Text, pszKey );\n\n    if( nBand > 0 )\n    {\n        sprintf( szBandId, \"%d\", nBand - 1 );\n        CPLCreateXMLNode( CPLCreateXMLNode( psItem,CXT_Attribute,\"sample\"),\n                          CXT_Text, szBandId );\n    }\n\n    if( pszRole != NULL )\n        CPLCreateXMLNode( CPLCreateXMLNode( psItem,CXT_Attribute,\"role\"),\n                          CXT_Text, pszRole );\n\n    if( pszDomain != NULL && strlen(pszDomain) > 0 )\n        CPLCreateXMLNode( CPLCreateXMLNode( psItem,CXT_Attribute,\"domain\"),\n                          CXT_Text, pszDomain );\n\n    char *pszEscapedItemValue = CPLEscapeString(pszValue,-1,CPLES_XML);\n    CPLCreateXMLNode( psItem, CXT_Text, pszEscapedItemValue );\n    CPLFree( pszEscapedItemValue );\n\n/* -------------------------------------------------------------------- */\n/*      Create root, if missing.                                        */\n/* -------------------------------------------------------------------- */\n    if( *ppsRoot == NULL )\n        *ppsRoot = CPLCreateXMLNode( NULL, CXT_Element, \"GDALMetadata\" );\n\n/* -------------------------------------------------------------------- */\n/*      Append item to tail.  We keep track of the tail to avoid        */\n/*      O(nsquared) time as the list gets longer.                       */\n/* -------------------------------------------------------------------- */\n    if( *ppsTail == NULL )\n        CPLAddXMLChild( *ppsRoot, psItem );\n    else\n        CPLAddXMLSibling( *ppsTail, psItem );\n    \n    *ppsTail = psItem;\n}\n\n/************************************************************************/\n/*                         WriteMDMDMetadata()                          */\n/************************************************************************/\n\nstatic void WriteMDMetadata( GDALMultiDomainMetadata *poMDMD, TIFF *hTIFF,\n                             CPLXMLNode **ppsRoot, CPLXMLNode **ppsTail, \n                             int nBand, const char *pszProfile )\n\n{\n    int iDomain;\n    char **papszDomainList;\n\n    (void) pszProfile;\n\n/* ==================================================================== */\n/*      Process each domain.                                            */\n/* ==================================================================== */\n    papszDomainList = poMDMD->GetDomainList();\n    for( iDomain = 0; papszDomainList && papszDomainList[iDomain]; iDomain++ )\n    {\n        char **papszMD = poMDMD->GetMetadata( papszDomainList[iDomain] );\n        int iItem;\n        int bIsXML = FALSE;\n\n        if( EQUAL(papszDomainList[iDomain], \"IMAGE_STRUCTURE\") )\n            continue; // ignored\n        if( EQUAL(papszDomainList[iDomain], \"RPC\") )\n            continue; // handled elsewhere\n        if( EQUAL(papszDomainList[iDomain], \"xml:ESRI\") \n            && CSLTestBoolean(CPLGetConfigOption( \"ESRI_XML_PAM\", \"NO\" )) )\n            continue; // handled elsewhere\n\n        if( EQUALN(papszDomainList[iDomain], \"xml:\",4 ) )\n            bIsXML = TRUE;\n\n/* -------------------------------------------------------------------- */\n/*      Process each item in this domain.                               */\n/* -------------------------------------------------------------------- */\n        for( iItem = 0; papszMD && papszMD[iItem]; iItem++ )\n        {\n            const char *pszItemValue;\n            char *pszItemName = NULL;\n\n            if( bIsXML )\n            {\n                pszItemName = CPLStrdup(\"doc\");\n                pszItemValue = papszMD[iItem];\n            }\n            else\n            {\n                pszItemValue = CPLParseNameValue( papszMD[iItem], &pszItemName);\n            }\n            \n/* -------------------------------------------------------------------- */\n/*      Convert into XML item or handle as a special TIFF tag.          */\n/* -------------------------------------------------------------------- */\n            if( strlen(papszDomainList[iDomain]) == 0 \n                && nBand == 0 && EQUALN(pszItemName,\"TIFFTAG_\",8) )\n            {\n                if( EQUAL(pszItemName,\"TIFFTAG_DOCUMENTNAME\") )\n                    TIFFSetField( hTIFF, TIFFTAG_DOCUMENTNAME, pszItemValue );\n                else if( EQUAL(pszItemName,\"TIFFTAG_IMAGEDESCRIPTION\") )\n                    TIFFSetField( hTIFF, TIFFTAG_IMAGEDESCRIPTION, pszItemValue );\n                else if( EQUAL(pszItemName,\"TIFFTAG_SOFTWARE\") )\n                    TIFFSetField( hTIFF, TIFFTAG_SOFTWARE, pszItemValue );\n                else if( EQUAL(pszItemName,\"TIFFTAG_DATETIME\") )\n                    TIFFSetField( hTIFF, TIFFTAG_DATETIME, pszItemValue );\n                else if( EQUAL(pszItemName,\"TIFFTAG_ARTIST\") )\n                    TIFFSetField( hTIFF, TIFFTAG_ARTIST, pszItemValue );\n                else if( EQUAL(pszItemName,\"TIFFTAG_HOSTCOMPUTER\") )\n                    TIFFSetField( hTIFF, TIFFTAG_HOSTCOMPUTER, pszItemValue );\n                else if( EQUAL(pszItemName,\"TIFFTAG_COPYRIGHT\") )\n                    TIFFSetField( hTIFF, TIFFTAG_COPYRIGHT, pszItemValue );\n                else if( EQUAL(pszItemName,\"TIFFTAG_XRESOLUTION\") )\n                    TIFFSetField( hTIFF, TIFFTAG_XRESOLUTION, CPLAtof(pszItemValue) );\n                else if( EQUAL(pszItemName,\"TIFFTAG_YRESOLUTION\") )\n                    TIFFSetField( hTIFF, TIFFTAG_YRESOLUTION, CPLAtof(pszItemValue) );\n                else if( EQUAL(pszItemName,\"TIFFTAG_RESOLUTIONUNIT\") )\n                    TIFFSetField( hTIFF, TIFFTAG_RESOLUTIONUNIT, atoi(pszItemValue) );\n                else\n                    CPLError(CE_Warning, CPLE_NotSupported,\n                             \"%s metadata item is unhandled and will not be written\",\n                             pszItemName);\n            }\n            else if( nBand == 0 && EQUAL(pszItemName,GDALMD_AREA_OR_POINT) )\n                /* do nothing, handled elsewhere */;\n            else\n                AppendMetadataItem( ppsRoot, ppsTail, \n                                    pszItemName, pszItemValue, \n                                    nBand, NULL, papszDomainList[iDomain] );\n\n            CPLFree( pszItemName );\n        }\n    }\n}\n\n/************************************************************************/\n/*                           WriteMetadata()                            */\n/************************************************************************/\n\nint  GTiffDataset::WriteMetadata( GDALDataset *poSrcDS, TIFF *hTIFF,\n                                  int bSrcIsGeoTIFF,\n                                  const char *pszProfile,\n                                  const char *pszTIFFFilename,\n                                  char **papszCreationOptions,\n                                  int bExcludeRPBandIMGFileWriting)\n\n{\n/* -------------------------------------------------------------------- */\n/*      Convert all the remaining metadata into a simple XML            */\n/*      format.                                                         */\n/* -------------------------------------------------------------------- */\n    CPLXMLNode *psRoot = NULL, *psTail = NULL;\n\n    if( bSrcIsGeoTIFF )\n    {\n        WriteMDMetadata( &(((GTiffDataset *)poSrcDS)->oGTiffMDMD), \n                         hTIFF, &psRoot, &psTail, 0, pszProfile );\n    }\n    else\n    {\n        char **papszMD = poSrcDS->GetMetadata();\n\n        if( CSLCount(papszMD) > 0 )\n        {\n            GDALMultiDomainMetadata oMDMD;\n            oMDMD.SetMetadata( papszMD );\n\n            WriteMDMetadata( &oMDMD, hTIFF, &psRoot, &psTail, 0, pszProfile );\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Handle RPC data written to an RPB file.                         */\n/* -------------------------------------------------------------------- */\n    char **papszRPCMD = poSrcDS->GetMetadata(\"RPC\");\n    if( papszRPCMD != NULL && !bExcludeRPBandIMGFileWriting )\n    {\n        if( EQUAL(pszProfile,\"GDALGeoTIFF\") )\n            WriteRPCTag( hTIFF, papszRPCMD );\n\n        if( !EQUAL(pszProfile,\"GDALGeoTIFF\") \n            || CSLFetchBoolean( papszCreationOptions, \"RPB\", FALSE ) )\n        {\n            GDALWriteRPBFile( pszTIFFFilename, papszRPCMD );\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Handle metadata data written to an IMD file.                    */\n/* -------------------------------------------------------------------- */\n    char **papszIMDMD = poSrcDS->GetMetadata(\"IMD\");\n    if( papszIMDMD != NULL && !bExcludeRPBandIMGFileWriting)\n    {\n        GDALWriteIMDFile( pszTIFFFilename, papszIMDMD );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      We also need to address band specific metadata, and special     */\n/*      \"role\" metadata.                                                */\n/* -------------------------------------------------------------------- */\n    int nBand;\n    for( nBand = 1; nBand <= poSrcDS->GetRasterCount(); nBand++ )\n    {\n        GDALRasterBand *poBand = poSrcDS->GetRasterBand( nBand );\n\n        if( bSrcIsGeoTIFF )\n        {\n            WriteMDMetadata( &(((GTiffRasterBand *)poBand)->oGTiffMDMD), \n                             hTIFF, &psRoot, &psTail, nBand, pszProfile );\n        }\n        else\n        {\n            char **papszMD = poBand->GetMetadata();\n            \n            if( CSLCount(papszMD) > 0 )\n            {\n                GDALMultiDomainMetadata oMDMD;\n                oMDMD.SetMetadata( papszMD );\n                \n                WriteMDMetadata( &oMDMD, hTIFF, &psRoot, &psTail, nBand,\n                                 pszProfile );\n            }\n        }\n\n        int bSuccess;\n        double dfOffset = poBand->GetOffset( &bSuccess );\n        double dfScale = poBand->GetScale();\n\n        if( bSuccess && (dfOffset != 0.0 || dfScale != 1.0) )\n        {\n            char szValue[128];\n\n            sprintf( szValue, \"%.18g\", dfOffset );\n            AppendMetadataItem( &psRoot, &psTail, \"OFFSET\", szValue, nBand, \n                                \"offset\", \"\" );\n            sprintf( szValue, \"%.18g\", dfScale );\n            AppendMetadataItem( &psRoot, &psTail, \"SCALE\", szValue, nBand, \n                                \"scale\", \"\" );\n        }\n\n        const char* pszUnitType = poBand->GetUnitType();\n        if (pszUnitType != NULL && pszUnitType[0] != '\\0')\n            AppendMetadataItem( &psRoot, &psTail, \"UNITTYPE\", pszUnitType, nBand, \n                                \"unittype\", \"\" );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Write out the generic XML metadata if there is any.             */\n/* -------------------------------------------------------------------- */\n    if( psRoot != NULL )\n    {\n        int bRet = TRUE;\n\n        if( EQUAL(pszProfile,\"GDALGeoTIFF\") )\n        {\n            char *pszXML_MD = CPLSerializeXMLTree( psRoot );\n            if( strlen(pszXML_MD) > 32000 )\n            {\n                if( bSrcIsGeoTIFF )\n                    ((GTiffDataset *) poSrcDS)->PushMetadataToPam();\n                else\n                    bRet = FALSE;\n                CPLError( CE_Warning, CPLE_AppDefined, \n                          \"Lost metadata writing to GeoTIFF ... too large to fit in tag.\" );\n            }\n            else\n            {\n                TIFFSetField( hTIFF, TIFFTAG_GDAL_METADATA, pszXML_MD );\n            }\n            CPLFree( pszXML_MD );\n        }\n        else\n        {\n            if( bSrcIsGeoTIFF )\n                ((GTiffDataset *) poSrcDS)->PushMetadataToPam();\n            else\n                bRet = FALSE;\n        }\n\n        CPLDestroyXMLNode( psRoot );\n\n        return bRet;\n    }\n    else\n    {\n        /* If we have no more metadata but it existed before, remove the GDAL_METADATA tag */\n        if( EQUAL(pszProfile,\"GDALGeoTIFF\") )\n        {\n            char* pszText = NULL;\n            if( TIFFGetField( hTIFF, TIFFTAG_GDAL_METADATA, &pszText ) )\n            {\n#ifdef HAVE_UNSETFIELD\n                TIFFUnsetField( hTIFF, TIFFTAG_GDAL_METADATA );\n#else\n                TIFFSetField( hTIFF, TIFFTAG_GDAL_METADATA, \"\" );\n#endif\n            }\n        }\n    }\n\n    return TRUE;\n}\n\n/************************************************************************/\n/*                         PushMetadataToPam()                          */\n/*                                                                      */\n/*      When producing a strict profile TIFF or if our aggregate        */\n/*      metadata is too big for a single tiff tag we may end up         */\n/*      needing to write it via the PAM mechanisms.  This method        */\n/*      copies all the appropriate metadata into the PAM level          */\n/*      metadata object but with special care to avoid copying          */\n/*      metadata handled in other ways in TIFF format.                  */\n/************************************************************************/\n\nvoid GTiffDataset::PushMetadataToPam()\n\n{\n    int nBand;\n    for( nBand = 0; nBand <= GetRasterCount(); nBand++ )\n    {\n        GDALMultiDomainMetadata *poSrcMDMD;\n        GTiffRasterBand *poBand = NULL;\n\n        if( nBand == 0 )\n            poSrcMDMD = &(this->oGTiffMDMD);\n        else\n        {\n            poBand = (GTiffRasterBand *) GetRasterBand(nBand);\n            poSrcMDMD = &(poBand->oGTiffMDMD);\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Loop over the available domains.                                */\n/* -------------------------------------------------------------------- */\n        int iDomain, i;\n        char **papszDomainList;\n\n        papszDomainList = poSrcMDMD->GetDomainList();\n        for( iDomain = 0; \n             papszDomainList && papszDomainList[iDomain]; \n             iDomain++ )\n        {\n            char **papszMD = poSrcMDMD->GetMetadata( papszDomainList[iDomain] );\n\n            if( EQUAL(papszDomainList[iDomain],\"RPC\")\n                || EQUAL(papszDomainList[iDomain],\"IMD\") \n                || EQUAL(papszDomainList[iDomain],\"_temporary_\")\n                || EQUAL(papszDomainList[iDomain],\"IMAGE_STRUCTURE\") )\n                continue;\n\n            papszMD = CSLDuplicate(papszMD);\n\n            for( i = CSLCount(papszMD)-1; i >= 0; i-- )\n            {\n                if( EQUALN(papszMD[i],\"TIFFTAG_\",8)\n                    || EQUALN(papszMD[i],GDALMD_AREA_OR_POINT,\n                              strlen(GDALMD_AREA_OR_POINT)) )\n                    papszMD = CSLRemoveStrings( papszMD, i, 1, NULL );\n            }\n\n            if( nBand == 0 )\n                GDALPamDataset::SetMetadata( papszMD, papszDomainList[iDomain]);\n            else\n                poBand->GDALPamRasterBand::SetMetadata( papszMD, papszDomainList[iDomain]);\n\n            CSLDestroy( papszMD );\n        }\n            \n/* -------------------------------------------------------------------- */\n/*      Handle some \"special domain\" stuff.                             */\n/* -------------------------------------------------------------------- */\n        if( poBand != NULL )\n        {\n            poBand->GDALPamRasterBand::SetOffset( poBand->GetOffset() );\n            poBand->GDALPamRasterBand::SetScale( poBand->GetScale() );\n            poBand->GDALPamRasterBand::SetUnitType( poBand->GetUnitType() );\n        }\n    }\n}\n\n/************************************************************************/\n/*                            WriteRPCTag()                             */\n/*                                                                      */\n/*      Format a TAG according to:                                      */\n/*                                                                      */\n/*      http://geotiff.maptools.org/rpc_prop.html                       */\n/************************************************************************/\n\n/* static */\nvoid GTiffDataset::WriteRPCTag( TIFF *hTIFF, char **papszRPCMD )\n\n{\n    double adfRPCTag[92];\n    GDALRPCInfo sRPC;\n\n    if( !GDALExtractRPCInfo( papszRPCMD, &sRPC ) )\n        return;\n\n    adfRPCTag[0] = -1.0;  // Error Bias \n    adfRPCTag[1] = -1.0;  // Error Random\n\n    adfRPCTag[2] = sRPC.dfLINE_OFF;\n    adfRPCTag[3] = sRPC.dfSAMP_OFF;\n    adfRPCTag[4] = sRPC.dfLAT_OFF;\n    adfRPCTag[5] = sRPC.dfLONG_OFF;\n    adfRPCTag[6] = sRPC.dfHEIGHT_OFF;\n    adfRPCTag[7] = sRPC.dfLINE_SCALE;\n    adfRPCTag[8] = sRPC.dfSAMP_SCALE;\n    adfRPCTag[9] = sRPC.dfLAT_SCALE;\n    adfRPCTag[10] = sRPC.dfLONG_SCALE;\n    adfRPCTag[11] = sRPC.dfHEIGHT_SCALE;\n\n    memcpy( adfRPCTag + 12, sRPC.adfLINE_NUM_COEFF, sizeof(double) * 20 );\n    memcpy( adfRPCTag + 32, sRPC.adfLINE_DEN_COEFF, sizeof(double) * 20 );\n    memcpy( adfRPCTag + 52, sRPC.adfSAMP_NUM_COEFF, sizeof(double) * 20 );\n    memcpy( adfRPCTag + 72, sRPC.adfSAMP_DEN_COEFF, sizeof(double) * 20 );\n\n    TIFFSetField( hTIFF, TIFFTAG_RPCCOEFFICIENT, 92, adfRPCTag );\n}\n\n/************************************************************************/\n/*                             ReadRPCTag()                             */\n/*                                                                      */\n/*      Format a TAG according to:                                      */\n/*                                                                      */\n/*      http://geotiff.maptools.org/rpc_prop.html                       */\n/************************************************************************/\n\nvoid GTiffDataset::ReadRPCTag()\n\n{\n    double *padfRPCTag;\n    char **papszMD = NULL;\n    CPLString osField;\n    CPLString osMultiField;\n    int i;\n    uint16 nCount;\n\n    if( !TIFFGetField( hTIFF, TIFFTAG_RPCCOEFFICIENT, &nCount, &padfRPCTag ) \n        || nCount != 92 )\n        return;\n\n    osField.Printf( \"%.15g\", padfRPCTag[2] );\n    papszMD = CSLSetNameValue( papszMD, \"LINE_OFF\", osField );\n\n    osField.Printf( \"%.15g\", padfRPCTag[3] );\n    papszMD = CSLSetNameValue( papszMD, \"SAMP_OFF\", osField );\n\n    osField.Printf( \"%.15g\", padfRPCTag[4] );\n    papszMD = CSLSetNameValue( papszMD, \"LAT_OFF\", osField );\n\n    osField.Printf( \"%.15g\", padfRPCTag[5] );\n    papszMD = CSLSetNameValue( papszMD, \"LONG_OFF\", osField );\n\n    osField.Printf( \"%.15g\", padfRPCTag[6] );\n    papszMD = CSLSetNameValue( papszMD, \"HEIGHT_OFF\", osField );\n\n    osField.Printf( \"%.15g\", padfRPCTag[7] );\n    papszMD = CSLSetNameValue( papszMD, \"LINE_SCALE\", osField );\n\n    osField.Printf( \"%.15g\", padfRPCTag[8] );\n    papszMD = CSLSetNameValue( papszMD, \"SAMP_SCALE\", osField );\n\n    osField.Printf( \"%.15g\", padfRPCTag[9] );\n    papszMD = CSLSetNameValue( papszMD, \"LAT_SCALE\", osField );\n\n    osField.Printf( \"%.15g\", padfRPCTag[10] );\n    papszMD = CSLSetNameValue( papszMD, \"LONG_SCALE\", osField );\n\n    osField.Printf( \"%.15g\", padfRPCTag[11] );\n    papszMD = CSLSetNameValue( papszMD, \"HEIGHT_SCALE\", osField );\n\n    for( i = 0; i < 20; i++ )\n    {\n        osField.Printf( \"%.15g\", padfRPCTag[12+i] );\n        if( i > 0 )\n            osMultiField += \" \";\n        else\n            osMultiField = \"\";\n        osMultiField += osField;\n    }\n    papszMD = CSLSetNameValue( papszMD, \"LINE_NUM_COEFF\", osMultiField );\n\n    for( i = 0; i < 20; i++ )\n    {\n        osField.Printf( \"%.15g\", padfRPCTag[32+i] );\n        if( i > 0 )\n            osMultiField += \" \";\n        else\n            osMultiField = \"\";\n        osMultiField += osField;\n    }\n    papszMD = CSLSetNameValue( papszMD, \"LINE_DEN_COEFF\", osMultiField );\n\n    for( i = 0; i < 20; i++ )\n    {\n        osField.Printf( \"%.15g\", padfRPCTag[52+i] );\n        if( i > 0 )\n            osMultiField += \" \";\n        else\n            osMultiField = \"\";\n        osMultiField += osField;\n    }\n    papszMD = CSLSetNameValue( papszMD, \"SAMP_NUM_COEFF\", osMultiField );\n\n    for( i = 0; i < 20; i++ )\n    {\n        osField.Printf( \"%.15g\", padfRPCTag[72+i] );\n        if( i > 0 )\n            osMultiField += \" \";\n        else\n            osMultiField = \"\";\n        osMultiField += osField;\n    }\n    papszMD = CSLSetNameValue( papszMD, \"SAMP_DEN_COEFF\", osMultiField );\n\n    oGTiffMDMD.SetMetadata( papszMD, \"RPC\" );\n    CSLDestroy( papszMD );\n}\n\n/************************************************************************/\n/*                         WriteNoDataValue()                           */\n/************************************************************************/\n\nvoid GTiffDataset::WriteNoDataValue( TIFF *hTIFF, double dfNoData )\n\n{\n    char szVal[400];\n    if (CPLIsNan(dfNoData))\n        strcpy(szVal, \"nan\");\n\telse\n        snprintf(szVal, sizeof(szVal), \"%.18g\", dfNoData);\n    TIFFSetField( hTIFF, TIFFTAG_GDAL_NODATA, szVal );\n}\n\n/************************************************************************/\n/*                            SetDirectory()                            */\n/************************************************************************/\n\nint GTiffDataset::SetDirectory( toff_t nNewOffset )\n\n{\n    Crystalize();\n\n    FlushBlockBuf();\n\n    if( nNewOffset == 0 )\n        nNewOffset = nDirOffset;\n\n    if( TIFFCurrentDirOffset(hTIFF) == nNewOffset )\n    {\n        CPLAssert( *ppoActiveDSRef == this || *ppoActiveDSRef == NULL );\n        *ppoActiveDSRef = this;\n        return TRUE;\n    }\n\n    if( GetAccess() == GA_Update )\n    {\n        if( *ppoActiveDSRef != NULL )\n            (*ppoActiveDSRef)->FlushDirectory();\n    }\n    \n    if( nNewOffset == 0)\n        return TRUE;\n\n    (*ppoActiveDSRef) = this;\n\n    int nSetDirResult = TIFFSetSubDirectory( hTIFF, nNewOffset );\n    if (!nSetDirResult)\n        return nSetDirResult;\n\n/* -------------------------------------------------------------------- */\n/*      YCbCr JPEG compressed images should be translated on the fly    */\n/*      to RGB by libtiff/libjpeg unless specifically requested         */\n/*      otherwise.                                                      */\n/* -------------------------------------------------------------------- */\n    if( !TIFFGetField( hTIFF, TIFFTAG_COMPRESSION, &(nCompression) ) )\n        nCompression = COMPRESSION_NONE;\n\n    if( !TIFFGetField( hTIFF, TIFFTAG_PHOTOMETRIC, &(nPhotometric) ) )\n        nPhotometric = PHOTOMETRIC_MINISBLACK;\n    \n    if( nCompression == COMPRESSION_JPEG \n        && nPhotometric == PHOTOMETRIC_YCBCR \n        && CSLTestBoolean( CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\",\n                                              \"YES\") ) )\n    {\n        int nColorMode;\n\n        TIFFGetField( hTIFF, TIFFTAG_JPEGCOLORMODE, &nColorMode );\n        if( nColorMode != JPEGCOLORMODE_RGB )\n            TIFFSetField(hTIFF, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Propogate any quality settings.                                 */\n/* -------------------------------------------------------------------- */\n    if( GetAccess() == GA_Update )\n    {\n        // Now, reset zip and jpeg quality.\n        if(nJpegQuality > 0 && nCompression == COMPRESSION_JPEG)\n        {\n            CPLDebug( \"GTiff\", \"Propgate JPEG_QUALITY(%d) in SetDirectory()\",\n                      nJpegQuality );\n            TIFFSetField(hTIFF, TIFFTAG_JPEGQUALITY, nJpegQuality); \n        }\n        if(nZLevel > 0 && nCompression == COMPRESSION_ADOBE_DEFLATE)\n            TIFFSetField(hTIFF, TIFFTAG_ZIPQUALITY, nZLevel);\n        if(nLZMAPreset > 0 && nCompression == COMPRESSION_LZMA)\n            TIFFSetField(hTIFF, TIFFTAG_LZMAPRESET, nLZMAPreset);\n    }\n\n    return nSetDirResult;\n}\n\n/************************************************************************/\n/*                              Identify()                              */\n/************************************************************************/\n\nint GTiffDataset::Identify( GDALOpenInfo * poOpenInfo )\n\n{\n    const char  *pszFilename = poOpenInfo->pszFilename;\n    if( EQUALN(pszFilename,\"GTIFF_RAW:\", strlen(\"GTIFF_RAW:\")) )\n    {\n        pszFilename += strlen(\"GTIFF_RAW:\");\n        GDALOpenInfo oOpenInfo( pszFilename, poOpenInfo->eAccess );\n        return Identify(&oOpenInfo);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      We have a special hook for handling opening a specific          */\n/*      directory of a TIFF file.                                       */\n/* -------------------------------------------------------------------- */\n    if( EQUALN(pszFilename,\"GTIFF_DIR:\",strlen(\"GTIFF_DIR:\")) )\n        return TRUE;\n\n/* -------------------------------------------------------------------- */\n/*\tFirst we check to see if the file has the expected header\t*/\n/*\tbytes.\t\t\t\t\t\t\t\t*/    \n/* -------------------------------------------------------------------- */\n    if( poOpenInfo->nHeaderBytes < 2 )\n        return FALSE;\n\n    if( (poOpenInfo->pabyHeader[0] != 'I' || poOpenInfo->pabyHeader[1] != 'I')\n        && (poOpenInfo->pabyHeader[0] != 'M' || poOpenInfo->pabyHeader[1] != 'M'))\n        return FALSE;\n\n#ifndef BIGTIFF_SUPPORT\n    if( (poOpenInfo->pabyHeader[2] == 0x2B && poOpenInfo->pabyHeader[3] == 0) ||\n        (poOpenInfo->pabyHeader[2] == 0 && poOpenInfo->pabyHeader[3] == 0x2B) )\n    {\n        CPLError( CE_Failure, CPLE_OpenFailed,\n                  \"This is a BigTIFF file.  BigTIFF is not supported by this\\n\"\n                  \"version of GDAL and libtiff.\" );\n        return FALSE;\n    }\n#endif\n\n    if( (poOpenInfo->pabyHeader[2] != 0x2A || poOpenInfo->pabyHeader[3] != 0)\n        && (poOpenInfo->pabyHeader[3] != 0x2A || poOpenInfo->pabyHeader[2] != 0)\n        && (poOpenInfo->pabyHeader[2] != 0x2B || poOpenInfo->pabyHeader[3] != 0)\n        && (poOpenInfo->pabyHeader[3] != 0x2B || poOpenInfo->pabyHeader[2] != 0))\n        return FALSE;\n\n    return TRUE;\n}\n\n/************************************************************************/\n/*                                Open()                                */\n/************************************************************************/\n\nGDALDataset *GTiffDataset::Open( GDALOpenInfo * poOpenInfo )\n\n{\n    TIFF\t*hTIFF;\n    int          bAllowRGBAInterface = TRUE;\n    const char  *pszFilename = poOpenInfo->pszFilename;\n\n/* -------------------------------------------------------------------- */\n/*      Check if it looks like a TIFF file.                             */\n/* -------------------------------------------------------------------- */\n    if (!Identify(poOpenInfo))\n        return NULL;\n\n    if( EQUALN(pszFilename,\"GTIFF_RAW:\", strlen(\"GTIFF_RAW:\")) )\n    {\n        bAllowRGBAInterface = FALSE;\n        pszFilename +=  strlen(\"GTIFF_RAW:\");\n    }\n\n/* -------------------------------------------------------------------- */\n/*      We have a special hook for handling opening a specific          */\n/*      directory of a TIFF file.                                       */\n/* -------------------------------------------------------------------- */\n    if( EQUALN(pszFilename,\"GTIFF_DIR:\",strlen(\"GTIFF_DIR:\")) )\n        return OpenDir( poOpenInfo );\n\n    if (!GTiffOneTimeInit())\n        return NULL;\n\n/* -------------------------------------------------------------------- */\n/*      Try opening the dataset.                                        */\n/* -------------------------------------------------------------------- */\n    if( poOpenInfo->eAccess == GA_ReadOnly )\n\thTIFF = VSI_TIFFOpen( pszFilename, \"r\" );\n    else\n        hTIFF = VSI_TIFFOpen( pszFilename, \"r+\" );\n    \n    if( hTIFF == NULL )\n        return( NULL );\n\n/* -------------------------------------------------------------------- */\n/*      Create a corresponding GDALDataset.                             */\n/* -------------------------------------------------------------------- */\n    GTiffDataset \t*poDS;\n\n    poDS = new GTiffDataset();\n    poDS->SetDescription( pszFilename );\n    poDS->osFilename = pszFilename;\n    poDS->poActiveDS = poDS;\n\n    if( poDS->OpenOffset( hTIFF, &(poDS->poActiveDS),\n                          TIFFCurrentDirOffset(hTIFF), TRUE,\n                          poOpenInfo->eAccess, \n                          bAllowRGBAInterface, TRUE,\n                          poOpenInfo->papszSiblingFiles) != CE_None )\n    {\n        delete poDS;\n        return NULL;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Initialize any PAM information.                                 */\n/* -------------------------------------------------------------------- */\n    poDS->TryLoadXML( poOpenInfo->papszSiblingFiles);\n    poDS->ApplyPamInfo();\n\n    int i;\n    for(i=1;i<=poDS->nBands;i++)\n    {\n        GTiffRasterBand* poBand = (GTiffRasterBand*) poDS->GetRasterBand(i);\n\n        /* Load scale, offset and unittype from PAM if available */\n        if (!poBand->bHaveOffsetScale)\n        {\n            poBand->dfScale = poBand->GDALPamRasterBand::GetScale(&poBand->bHaveOffsetScale);\n            poBand->dfOffset = poBand->GDALPamRasterBand::GetOffset();\n        }\n        if (poBand->osUnitType.size() == 0)\n        {\n            const char* pszUnitType = poBand->GDALPamRasterBand::GetUnitType();\n            if (pszUnitType)\n                poBand->osUnitType = pszUnitType;\n        }\n    }\n\n    poDS->bMetadataChanged = FALSE;\n    poDS->bGeoTIFFInfoChanged = FALSE;\n\n/* -------------------------------------------------------------------- */\n/*      Check for external overviews.                                   */\n/* -------------------------------------------------------------------- */\n    poDS->oOvManager.Initialize( poDS, pszFilename, poOpenInfo->papszSiblingFiles );\n    \n    return poDS;\n}\n\n/************************************************************************/\n/*                         LookForProjection()                          */\n/************************************************************************/\n\nvoid GTiffDataset::LookForProjection()\n\n{\n    if( bLookedForProjection )\n        return;\n\n    bLookedForProjection = TRUE;\n    if (!SetDirectory())\n        return;\n\n/* -------------------------------------------------------------------- */\n/*      Capture the GeoTIFF projection, if available.                   */\n/* -------------------------------------------------------------------- */\n    GTIF \t*hGTIF;\n    GTIFDefn\tsGTIFDefn;\n\n    CPLFree( pszProjection );\n    pszProjection = NULL;\n    \n    hGTIF = GTIFNew(hTIFF);\n\n    if ( !hGTIF )\n    {\n        CPLError( CE_Warning, CPLE_AppDefined,\n                  \"GeoTIFF tags apparently corrupt, they are being ignored.\" );\n    }\n    else\n    {\n        if( GTIFGetDefn( hGTIF, &sGTIFDefn ) )\n        {\n            pszProjection = GTIFGetOGISDefn( hGTIF, &sGTIFDefn );\n            \n            // Should we simplify away vertical CS stuff?\n            if( EQUALN(pszProjection,\"COMPD_CS\",8)\n                && !CSLTestBoolean( CPLGetConfigOption(\"GTIFF_REPORT_COMPD_CS\",\n                                                       \"NO\") ) )\n            {\n                OGRSpatialReference oSRS;\n\n                CPLDebug( \"GTiff\", \"Got COMPD_CS, but stripping it.\" );\n                char *pszWKT = pszProjection;\n                oSRS.importFromWkt( &pszWKT );\n                CPLFree( pszProjection );\n\n                oSRS.StripVertical();\n                oSRS.exportToWkt( &pszProjection );\n            }\n        }\n\n        // Is this a pixel-is-point dataset?\n        short nRasterType;\n\n        // check the tif linear unit and the CS linear unit \n#ifdef ESRI_BUILD\n        AdjustLinearUnit(sGTIFDefn.UOMLength); \n#endif\n\n        if( GTIFKeyGet(hGTIF, GTRasterTypeGeoKey, &nRasterType, \n                       0, 1 ) == 1 )\n        {\n            if( nRasterType == (short) RasterPixelIsPoint )\n                oGTiffMDMD.SetMetadataItem( GDALMD_AREA_OR_POINT, GDALMD_AOP_POINT );\n            else\n                oGTiffMDMD.SetMetadataItem( GDALMD_AREA_OR_POINT, GDALMD_AOP_AREA );\n        }\n\n        GTIFFree( hGTIF );\n    }\n\n    if( pszProjection == NULL )\n    {\n        pszProjection = CPLStrdup( \"\" );\n    }\n\n    bGeoTIFFInfoChanged = FALSE;\n}\n\n/************************************************************************/\n/*                          AdjustLinearUnit()                          */\n/*                                                                      */\n/*      The following code is only used in ESRI Builds and there is     */\n/*      outstanding discussion on whether it is even appropriate        */\n/*      then.                                                           */\n/************************************************************************/\n#ifdef ESRI_BUILD\n\nvoid GTiffDataset::AdjustLinearUnit(short UOMLength)\n{\n    if (!pszProjection || strlen(pszProjection) == 0)\n        return;\n    if( UOMLength == 9001)\n    {\n        char* pstr = strstr(pszProjection, \"PARAMETER\");\n        if (!pstr)\n            return;\n        pstr = strstr(pstr, \"UNIT[\");\n        if (!pstr)\n            return;\n        pstr = strchr(pstr, ',') + 1;\n        if (!pstr)\n            return;\n        char* pstr1 = strchr(pstr, ']');\n        if (!pstr1 || pstr1 - pstr >= 128)\n            return;\n        char csUnitStr[128];\n        strncpy(csUnitStr, pstr, pstr1-pstr);\n        csUnitStr[pstr1-pstr] = '\\0';\n        double csUnit = CPLAtof(csUnitStr);\n        if(fabs(csUnit - 1.0) > 0.000001)\n        {\n            for(long i=0; i<6; i++)\n                adfGeoTransform[i] /= csUnit;\n        }\n    }\n}\n\n#endif /* def ESRI_BUILD */\n\n/************************************************************************/\n/*                            ApplyPamInfo()                            */\n/*                                                                      */\n/*      PAM Information, if available, overrides the GeoTIFF            */\n/*      geotransform and projection definition.  Check for them         */\n/*      now.                                                            */\n/************************************************************************/\n\nvoid GTiffDataset::ApplyPamInfo()\n\n{\n    double adfPamGeoTransform[6];\n\n    if( GDALPamDataset::GetGeoTransform( adfPamGeoTransform ) == CE_None \n        && (adfPamGeoTransform[0] != 0.0 || adfPamGeoTransform[1] != 1.0\n            || adfPamGeoTransform[2] != 0.0 || adfPamGeoTransform[3] != 0.0\n            || adfPamGeoTransform[4] != 0.0 || adfPamGeoTransform[5] != 1.0 ))\n    {\n        memcpy( adfGeoTransform, adfPamGeoTransform, sizeof(double)*6 );\n        bGeoTransformValid = TRUE;\n    }\n\n    const char *pszPamSRS = GDALPamDataset::GetProjectionRef();\n\n    if( pszPamSRS != NULL && strlen(pszPamSRS) > 0 )\n    {\n        CPLFree( pszProjection );\n        pszProjection = CPLStrdup( pszPamSRS );\n        bLookedForProjection = TRUE;\n    }\n\n    int nPamGCPCount = GDALPamDataset::GetGCPCount();\n    if( nPamGCPCount > 0 )\n    {\n        if( nGCPCount > 0 )\n        {\n            GDALDeinitGCPs( nGCPCount, pasGCPList );\n            CPLFree( pasGCPList );\n            pasGCPList = NULL;\n        }\n\n        nGCPCount = nPamGCPCount;\n        pasGCPList = GDALDuplicateGCPs(nGCPCount, GDALPamDataset::GetGCPs());\n\n        CPLFree( pszProjection );\n        pszProjection = NULL;\n\n        const char *pszPamGCPProjection = GDALPamDataset::GetGCPProjection();\n        if( pszPamGCPProjection != NULL && strlen(pszPamGCPProjection) > 0 )\n            pszProjection = CPLStrdup(pszPamGCPProjection);\n\n        bLookedForProjection = TRUE;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Copy any PAM metadata into our GeoTIFF context, and with        */\n/*      the PAM info overriding the GeoTIFF context.                    */\n/* -------------------------------------------------------------------- */\n    char **papszPamDomains = oMDMD.GetDomainList();\n\n    for( int iDomain = 0; papszPamDomains && papszPamDomains[iDomain] != NULL; iDomain++ )\n    {\n        const char *pszDomain = papszPamDomains[iDomain];\n        char **papszGT_MD = CSLDuplicate(oGTiffMDMD.GetMetadata( pszDomain ));\n        char **papszPAM_MD = oMDMD.GetMetadata( pszDomain );\n\n        papszGT_MD = CSLMerge( papszGT_MD, papszPAM_MD );\n\n        oGTiffMDMD.SetMetadata( papszGT_MD, pszDomain );\n        CSLDestroy( papszGT_MD );\n    }\n\n    for( int i = 1; i <= GetRasterCount(); i++)\n    {\n        GTiffRasterBand* poBand = (GTiffRasterBand *)GetRasterBand(i);\n        papszPamDomains = poBand->oMDMD.GetDomainList();\n\n        for( int iDomain = 0; papszPamDomains && papszPamDomains[iDomain] != NULL; iDomain++ )\n        {\n            const char *pszDomain = papszPamDomains[iDomain];\n            char **papszGT_MD = CSLDuplicate(poBand->oGTiffMDMD.GetMetadata( pszDomain ));\n            char **papszPAM_MD = poBand->oMDMD.GetMetadata( pszDomain );\n\n            papszGT_MD = CSLMerge( papszGT_MD, papszPAM_MD );\n\n            poBand->oGTiffMDMD.SetMetadata( papszGT_MD, pszDomain );\n            CSLDestroy( papszGT_MD );\n        }\n    }\n}\n\n/************************************************************************/\n/*                              OpenDir()                               */\n/*                                                                      */\n/*      Open a specific directory as encoded into a filename.           */\n/************************************************************************/\n\nGDALDataset *GTiffDataset::OpenDir( GDALOpenInfo * poOpenInfo )\n\n{\n    int bAllowRGBAInterface = TRUE;\n    const char* pszFilename = poOpenInfo->pszFilename;\n    if( EQUALN(pszFilename,\"GTIFF_RAW:\", strlen(\"GTIFF_RAW:\")) )\n    {\n        bAllowRGBAInterface = FALSE;\n        pszFilename += strlen(\"GTIFF_RAW:\");\n    }\n\n    if( !EQUALN(pszFilename,\"GTIFF_DIR:\",strlen(\"GTIFF_DIR:\")) )\n        return NULL;\n    \n/* -------------------------------------------------------------------- */\n/*      Split out filename, and dir#/offset.                            */\n/* -------------------------------------------------------------------- */\n    pszFilename += strlen(\"GTIFF_DIR:\");\n    int        bAbsolute = FALSE;\n    toff_t     nOffset;\n    \n    if( EQUALN(pszFilename,\"off:\",4) )\n    {\n        bAbsolute = TRUE;\n        pszFilename += 4;\n    }\n\n    nOffset = atol(pszFilename);\n    pszFilename += 1;\n\n    while( *pszFilename != '\\0' && pszFilename[-1] != ':' )\n        pszFilename++;\n\n    if( *pszFilename == '\\0' || nOffset == 0 )\n    {\n        CPLError( CE_Failure, CPLE_OpenFailed,\n                  \"Unable to extract offset or filename, should take the form\\n\"\n                  \"GTIFF_DIR:<dir>:filename or GTIFF_DIR:off:<dir_offset>:filename\" );\n        return NULL;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Try opening the dataset.                                        */\n/* -------------------------------------------------------------------- */\n    TIFF\t*hTIFF;\n\n    if (!GTiffOneTimeInit())\n        return NULL;\n\n    hTIFF = VSI_TIFFOpen( pszFilename, \"r\" );\n    if( hTIFF == NULL )\n        return( NULL );\n\n/* -------------------------------------------------------------------- */\n/*      If a directory was requested by index, advance to it now.       */\n/* -------------------------------------------------------------------- */\n    if( !bAbsolute )\n    {\n        while( nOffset > 1 )\n        {\n            if( TIFFReadDirectory( hTIFF ) == 0 )\n            {\n                XTIFFClose( hTIFF );\n                CPLError( CE_Failure, CPLE_OpenFailed, \n                          \"Requested directory %lu not found.\", (long unsigned int)nOffset );\n                return NULL;\n            }\n            nOffset--;\n        }\n\n        nOffset = TIFFCurrentDirOffset( hTIFF );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Create a corresponding GDALDataset.                             */\n/* -------------------------------------------------------------------- */\n    GTiffDataset \t*poDS;\n\n    poDS = new GTiffDataset();\n    poDS->SetDescription( poOpenInfo->pszFilename );\n    poDS->osFilename = poOpenInfo->pszFilename;\n    poDS->poActiveDS = poDS;\n\n    if( !EQUAL(pszFilename,poOpenInfo->pszFilename) \n        && !EQUALN(poOpenInfo->pszFilename,\"GTIFF_RAW:\",10) )\n    {\n        poDS->SetPhysicalFilename( pszFilename );\n        poDS->SetSubdatasetName( poOpenInfo->pszFilename );\n        poDS->osFilename = pszFilename;\n    }\n\n    if (poOpenInfo->eAccess == GA_Update)\n    {\n        CPLError( CE_Warning, CPLE_AppDefined,\n                  \"Opening a specific TIFF directory is not supported in update mode. Switching to read-only\" );\n    }\n\n    if( poDS->OpenOffset( hTIFF, &(poDS->poActiveDS),\n                          nOffset, FALSE, GA_ReadOnly,\n                          bAllowRGBAInterface, TRUE,\n                          poOpenInfo->papszSiblingFiles ) != CE_None )\n    {\n        delete poDS;\n        return NULL;\n    }\n    else\n    {\n        poDS->bCloseTIFFHandle = TRUE;\n        return poDS;\n    }\n}\n\n/************************************************************************/\n/*                             OpenOffset()                             */\n/*                                                                      */\n/*      Initialize the GTiffDataset based on a passed in file           */\n/*      handle, and directory offset to utilize.  This is called for    */\n/*      full res, and overview pages.                                   */\n/************************************************************************/\n\nCPLErr GTiffDataset::OpenOffset( TIFF *hTIFFIn, \n                                 GTiffDataset **ppoActiveDSRef,\n                                 toff_t nDirOffsetIn, \n\t\t\t\t int bBaseIn, GDALAccess eAccess,\n                                 int bAllowRGBAInterface,\n                                 int bReadGeoTransform,\n                                 char** papszSiblingFiles )\n\n{\n    uint32\tnXSize, nYSize;\n    int\t\tbTreatAsBitmap = FALSE;\n    int         bTreatAsOdd = FALSE;\n\n    this->eAccess = eAccess;\n\n    hTIFF = hTIFFIn;\n    this->ppoActiveDSRef = ppoActiveDSRef;\n\n    nDirOffset = nDirOffsetIn;\n\n    if (!SetDirectory( nDirOffsetIn ))\n        return CE_Failure;\n\n    bBase = bBaseIn;\n\n    this->eAccess = eAccess;\n\n/* -------------------------------------------------------------------- */\n/*      Capture some information from the file that is of interest.     */\n/* -------------------------------------------------------------------- */\n    TIFFGetField( hTIFF, TIFFTAG_IMAGEWIDTH, &nXSize );\n    TIFFGetField( hTIFF, TIFFTAG_IMAGELENGTH, &nYSize );\n    nRasterXSize = nXSize;\n    nRasterYSize = nYSize;\n\n    if( !TIFFGetField(hTIFF, TIFFTAG_SAMPLESPERPIXEL, &nSamplesPerPixel ) )\n        nBands = 1;\n    else\n        nBands = nSamplesPerPixel;\n    \n    if( !TIFFGetField(hTIFF, TIFFTAG_BITSPERSAMPLE, &(nBitsPerSample)) )\n        nBitsPerSample = 1;\n    \n    if( !TIFFGetField( hTIFF, TIFFTAG_PLANARCONFIG, &(nPlanarConfig) ) )\n        nPlanarConfig = PLANARCONFIG_CONTIG;\n    \n    if( !TIFFGetField( hTIFF, TIFFTAG_PHOTOMETRIC, &(nPhotometric) ) )\n        nPhotometric = PHOTOMETRIC_MINISBLACK;\n    \n    if( !TIFFGetField( hTIFF, TIFFTAG_SAMPLEFORMAT, &(nSampleFormat) ) )\n        nSampleFormat = SAMPLEFORMAT_UINT;\n    \n    if( !TIFFGetField( hTIFF, TIFFTAG_COMPRESSION, &(nCompression) ) )\n        nCompression = COMPRESSION_NONE;\n    \n#if defined(TIFFLIB_VERSION) && TIFFLIB_VERSION > 20031007 /* 3.6.0 */\n    if (nCompression != COMPRESSION_NONE &&\n        !TIFFIsCODECConfigured(nCompression))\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                  \"Cannot open TIFF file due to missing codec.\" );\n        return CE_Failure;\n    }\n#endif\n\n/* -------------------------------------------------------------------- */\n/*      YCbCr JPEG compressed images should be translated on the fly    */\n/*      to RGB by libtiff/libjpeg unless specifically requested         */\n/*      otherwise.                                                      */\n/* -------------------------------------------------------------------- */\n    if( nCompression == COMPRESSION_JPEG \n        && nPhotometric == PHOTOMETRIC_YCBCR \n        && CSLTestBoolean( CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\",\n                                              \"YES\") ) )\n    {\n        int nColorMode;\n\n        SetMetadataItem( \"SOURCE_COLOR_SPACE\", \"YCbCr\", \"IMAGE_STRUCTURE\" );\n        if ( !TIFFGetField( hTIFF, TIFFTAG_JPEGCOLORMODE, &nColorMode ) ||\n              nColorMode != JPEGCOLORMODE_RGB )\n            TIFFSetField(hTIFF, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Get strip/tile layout.                                          */\n/* -------------------------------------------------------------------- */\n    if( TIFFIsTiled(hTIFF) )\n    {\n        TIFFGetField( hTIFF, TIFFTAG_TILEWIDTH, &(nBlockXSize) );\n        TIFFGetField( hTIFF, TIFFTAG_TILELENGTH, &(nBlockYSize) );\n    }\n    else\n    {\n        if( !TIFFGetField( hTIFF, TIFFTAG_ROWSPERSTRIP,\n                           &(nRowsPerStrip) ) )\n        {\n            CPLError( CE_Warning, CPLE_AppDefined, \n                      \"RowsPerStrip not defined ... assuming all one strip.\" );\n            nRowsPerStrip = nYSize; /* dummy value */\n        }\n\n        nBlockXSize = nRasterXSize;\n        nBlockYSize = MIN(nRowsPerStrip,nYSize);\n    }\n        \n    nBlocksPerBand =\n        ((nYSize + nBlockYSize - 1) / nBlockYSize)\n        * ((nXSize + nBlockXSize  - 1) / nBlockXSize);\n\n/* -------------------------------------------------------------------- */\n/*      Should we handle this using the GTiffBitmapBand?                */\n/* -------------------------------------------------------------------- */\n    if( nBitsPerSample == 1 && nBands == 1 )\n    {\n        bTreatAsBitmap = TRUE;\n\n        // Lets treat large \"one row\" bitmaps using the scanline api.\n        if( !TIFFIsTiled(hTIFF) \n            && nBlockYSize == nYSize \n            && nYSize > 2000 \n            && bAllowRGBAInterface )\n            bTreatAsSplitBitmap = TRUE;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Should we treat this via the RGBA interface?                    */\n/* -------------------------------------------------------------------- */\n    if( bAllowRGBAInterface &&\n        !bTreatAsBitmap && !(nBitsPerSample > 8) \n        && (nPhotometric == PHOTOMETRIC_CIELAB ||\n            nPhotometric == PHOTOMETRIC_LOGL ||\n            nPhotometric == PHOTOMETRIC_LOGLUV ||\n            nPhotometric == PHOTOMETRIC_SEPARATED ||\n            ( nPhotometric == PHOTOMETRIC_YCBCR \n              && nCompression != COMPRESSION_JPEG )) )\n    {\n        char\tszMessage[1024];\n\n        if( TIFFRGBAImageOK( hTIFF, szMessage ) == 1 )\n        {\n            const char* pszSourceColorSpace = NULL;\n            switch (nPhotometric)\n            {\n                case PHOTOMETRIC_CIELAB:\n                    pszSourceColorSpace = \"CIELAB\";\n                    break;\n                case PHOTOMETRIC_LOGL:\n                    pszSourceColorSpace = \"LOGL\";\n                    break;\n                case PHOTOMETRIC_LOGLUV:\n                    pszSourceColorSpace = \"LOGLUV\";\n                    break;\n                case PHOTOMETRIC_SEPARATED:\n                    pszSourceColorSpace = \"CMYK\";\n                    break;\n                case PHOTOMETRIC_YCBCR:\n                    pszSourceColorSpace = \"YCbCr\";\n                    break;\n            }\n            if (pszSourceColorSpace)\n                SetMetadataItem( \"SOURCE_COLOR_SPACE\", pszSourceColorSpace, \"IMAGE_STRUCTURE\" );\n            bTreatAsRGBA = TRUE;\n            nBands = 4;\n        }\n        else\n        {\n            CPLDebug( \"GTiff\", \"TIFFRGBAImageOK says:\\n%s\", szMessage );\n        }\n    }\n    \n/* -------------------------------------------------------------------- */\n/*      Should we treat this via the split interface?                   */\n/* -------------------------------------------------------------------- */\n    if( !TIFFIsTiled(hTIFF) \n        && nBitsPerSample == 8\n        && nBlockYSize == nYSize \n        && nYSize > 2000\n        && !bTreatAsRGBA \n        && CSLTestBoolean(CPLGetConfigOption(\"GDAL_ENABLE_TIFF_SPLIT\", \"YES\")))\n    {\n        /* libtiff 3.9.2 (20091104) and older, libtiff 4.0.0beta5 (also 20091104) */\n        /* and older will crash when trying to open a all-in-one-strip */\n        /* YCbCr JPEG compressed TIFF (see #3259). */\n#if (TIFFLIB_VERSION <= 20091104 && !defined(BIGTIFF_SUPPORT)) || \\\n    (TIFFLIB_VERSION <= 20091104 && defined(BIGTIFF_SUPPORT))\n        if (nPhotometric == PHOTOMETRIC_YCBCR  &&\n            nCompression == COMPRESSION_JPEG)\n        {\n            CPLDebug(\"GTiff\", \"Avoid using split band to open all-in-one-strip \"\n                              \"YCbCr JPEG compressed TIFF because of older libtiff\");\n        }\n        else\n#endif\n            bTreatAsSplit = TRUE;\n    }\n    \n/* -------------------------------------------------------------------- */\n/*      Should we treat this via the odd bits interface?                */\n/* -------------------------------------------------------------------- */\n    if ( nSampleFormat == SAMPLEFORMAT_IEEEFP )\n    {\n        if ( nBitsPerSample == 16 || nBitsPerSample == 24 )\n            bTreatAsOdd = TRUE;\n    }\n    else if ( !bTreatAsRGBA && !bTreatAsBitmap\n              && nBitsPerSample != 8\n              && nBitsPerSample != 16\n              && nBitsPerSample != 32\n              && nBitsPerSample != 64 \n              && nBitsPerSample != 128 )\n        bTreatAsOdd = TRUE;\n\n    int bMinIsWhite = nPhotometric == PHOTOMETRIC_MINISWHITE;\n\n/* -------------------------------------------------------------------- */\n/*      Capture the color table if there is one.                        */\n/* -------------------------------------------------------------------- */\n    unsigned short\t*panRed, *panGreen, *panBlue;\n\n    if( bTreatAsRGBA \n        || TIFFGetField( hTIFF, TIFFTAG_COLORMAP, \n                         &panRed, &panGreen, &panBlue) == 0 )\n    {\n\t// Build inverted palette if we have inverted photometric.\n\t// Pixel values remains unchanged.  Avoid doing this for *deep*\n        // data types (per #1882)\n\tif( nBitsPerSample <= 16 && nPhotometric == PHOTOMETRIC_MINISWHITE )\n\t{\n\t    GDALColorEntry  oEntry;\n\t    int\t\t    iColor, nColorCount;\n\t    \n\t    poColorTable = new GDALColorTable();\n\t    nColorCount = 1 << nBitsPerSample;\n\n\t    for ( iColor = 0; iColor < nColorCount; iColor++ )\n\t    {\n\t\toEntry.c1 = oEntry.c2 = oEntry.c3 = (short) \n                    ((255 * (nColorCount - 1 - iColor)) / (nColorCount-1));\n\t\toEntry.c4 = 255;\n\t\tpoColorTable->SetColorEntry( iColor, &oEntry );\n\t    }\n\n\t    nPhotometric = PHOTOMETRIC_PALETTE;\n\t}\n\telse\n\t    poColorTable = NULL;\n    }\n    else\n    {\n        int\tnColorCount, nMaxColor = 0;\n        GDALColorEntry oEntry;\n\n        poColorTable = new GDALColorTable();\n\n        nColorCount = 1 << nBitsPerSample;\n\n        for( int iColor = nColorCount - 1; iColor >= 0; iColor-- )\n        {\n            oEntry.c1 = panRed[iColor] / 256;\n            oEntry.c2 = panGreen[iColor] / 256;\n            oEntry.c3 = panBlue[iColor] / 256;\n            oEntry.c4 = 255;\n\n            poColorTable->SetColorEntry( iColor, &oEntry );\n\n            nMaxColor = MAX(nMaxColor,panRed[iColor]);\n            nMaxColor = MAX(nMaxColor,panGreen[iColor]);\n            nMaxColor = MAX(nMaxColor,panBlue[iColor]);\n        }\n\n        // Bug 1384 - Some TIFF files are generated with color map entry\n        // values in range 0-255 instead of 0-65535 - try to handle these\n        // gracefully.\n        if( nMaxColor > 0 && nMaxColor < 256 )\n        {\n            CPLDebug( \"GTiff\", \"TIFF ColorTable seems to be improperly scaled, fixing up.\" );\n            \n            for( int iColor = nColorCount - 1; iColor >= 0; iColor-- )\n            {\n                oEntry.c1 = panRed[iColor];\n                oEntry.c2 = panGreen[iColor];\n                oEntry.c3 = panBlue[iColor];\n                oEntry.c4 = 255;\n                \n                poColorTable->SetColorEntry( iColor, &oEntry );\n            }\n        }\n    }\n    \n/* -------------------------------------------------------------------- */\n/*      Create band information objects.                                */\n/* -------------------------------------------------------------------- */\n    for( int iBand = 0; iBand < nBands; iBand++ )\n    {\n        if( bTreatAsRGBA )\n            SetBand( iBand+1, new GTiffRGBABand( this, iBand+1 ) );\n        else if( bTreatAsSplitBitmap )\n            SetBand( iBand+1, new GTiffSplitBitmapBand( this, iBand+1 ) );\n        else if( bTreatAsSplit )\n            SetBand( iBand+1, new GTiffSplitBand( this, iBand+1 ) );\n        else if( bTreatAsBitmap )\n            SetBand( iBand+1, new GTiffBitmapBand( this, iBand+1 ) );\n        else if( bTreatAsOdd )\n            SetBand( iBand+1, new GTiffOddBitsBand( this, iBand+1 ) );\n        else\n            SetBand( iBand+1, new GTiffRasterBand( this, iBand+1 ) );\n    }\n\n    if( GetRasterBand(1)->GetRasterDataType() == GDT_Unknown )\n    {\n        CPLError( CE_Failure, CPLE_NotSupported,\n                  \"Unsupported TIFF configuration.\" );\n        return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Get the transform or gcps from the GeoTIFF file.                */\n/* -------------------------------------------------------------------- */\n    if( bReadGeoTransform )\n    {\n        char    *pszTabWKT = NULL;\n        double\t*padfTiePoints, *padfScale, *padfMatrix;\n        uint16\tnCount;\n        bool    bPixelIsPoint = false;\n        short nRasterType;\n        GTIF\t*psGTIF;\n        int     bPointGeoIgnore = FALSE;\n\n        psGTIF = GTIFNew( hTIFF ); // I wonder how expensive this is?\n\n        if( psGTIF )\n        {\n            if( GTIFKeyGet(psGTIF, GTRasterTypeGeoKey, &nRasterType,\n                        0, 1 ) == 1\n                && nRasterType == (short) RasterPixelIsPoint )\n            {\n                bPixelIsPoint = true;\n                bPointGeoIgnore =\n                    CSLTestBoolean( CPLGetConfigOption(\"GTIFF_POINT_GEO_IGNORE\",\n                                                    \"FALSE\") );\n            }\n\n            GTIFFree( psGTIF );\n        }\n\n        adfGeoTransform[0] = 0.0;\n        adfGeoTransform[1] = 1.0;\n        adfGeoTransform[2] = 0.0;\n        adfGeoTransform[3] = 0.0;\n        adfGeoTransform[4] = 0.0;\n        adfGeoTransform[5] = 1.0;\n    \n        if( TIFFGetField(hTIFF,TIFFTAG_GEOPIXELSCALE,&nCount,&padfScale )\n            && nCount >= 2 \n            && padfScale[0] != 0.0 && padfScale[1] != 0.0 )\n        {\n            adfGeoTransform[1] = padfScale[0];\n            adfGeoTransform[5] = - ABS(padfScale[1]);\n\n            if( TIFFGetField(hTIFF,TIFFTAG_GEOTIEPOINTS,&nCount,&padfTiePoints )\n                && nCount >= 6 )\n            {\n                adfGeoTransform[0] =\n                    padfTiePoints[3] - padfTiePoints[0] * adfGeoTransform[1];\n                adfGeoTransform[3] =\n                    padfTiePoints[4] - padfTiePoints[1] * adfGeoTransform[5];\n\n                if( bPixelIsPoint && !bPointGeoIgnore )\n                {\n                    adfGeoTransform[0] -= (adfGeoTransform[1] * 0.5 + adfGeoTransform[2] * 0.5);\n                    adfGeoTransform[3] -= (adfGeoTransform[4] * 0.5 + adfGeoTransform[5] * 0.5);\n                }\n\n                bGeoTransformValid = TRUE;\n            }\n        }\n\n        else if( TIFFGetField(hTIFF,TIFFTAG_GEOTRANSMATRIX,&nCount,&padfMatrix ) \n                 && nCount == 16 )\n        {\n            adfGeoTransform[0] = padfMatrix[3];\n            adfGeoTransform[1] = padfMatrix[0];\n            adfGeoTransform[2] = padfMatrix[1];\n            adfGeoTransform[3] = padfMatrix[7];\n            adfGeoTransform[4] = padfMatrix[4];\n            adfGeoTransform[5] = padfMatrix[5];\n\n            if( bPixelIsPoint && !bPointGeoIgnore )\n            {\n                adfGeoTransform[0] -= (adfGeoTransform[1] * 0.5 + adfGeoTransform[2] * 0.5);\n                adfGeoTransform[3] -= (adfGeoTransform[4] * 0.5 + adfGeoTransform[5] * 0.5);\n            }\n\n            bGeoTransformValid = TRUE;\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Otherwise try looking for a .tfw, .tifw or .wld file.           */\n/* -------------------------------------------------------------------- */\n        else\n        {\n            char* pszWldFilename = NULL;\n\n            bGeoTransformValid =\n                GDALReadWorldFile2( osFilename, NULL, adfGeoTransform,\n                                    papszSiblingFiles, &pszWldFilename);\n\n            if( !bGeoTransformValid )\n            {\n                bGeoTransformValid =\n                    GDALReadWorldFile2( osFilename, \"wld\", adfGeoTransform,\n                                        papszSiblingFiles, &pszWldFilename);\n            }\n\n            if( !bGeoTransformValid )\n            {\n                int bTabFileOK =\n                    GDALReadTabFile2( osFilename, adfGeoTransform,\n                                      &pszTabWKT, &nGCPCount, &pasGCPList,\n                                      papszSiblingFiles, &pszWldFilename );\n\n                if( bTabFileOK && nGCPCount == 0 )\n                    bGeoTransformValid = TRUE;\n            }\n\n            if (pszWldFilename)\n            {\n                osWldFilename = pszWldFilename;\n                CPLFree(pszWldFilename);\n            }\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Check for GCPs.  Note, we will allow there to be GCPs and a     */\n/*      transform in some circumstances.                                */\n/* -------------------------------------------------------------------- */\n        if( TIFFGetField(hTIFF,TIFFTAG_GEOTIEPOINTS,&nCount,&padfTiePoints )\n            && !bGeoTransformValid )\n        {\n            nGCPCount = nCount / 6;\n            pasGCPList = (GDAL_GCP *) CPLCalloc(sizeof(GDAL_GCP),nGCPCount);\n        \n            for( int iGCP = 0; iGCP < nGCPCount; iGCP++ )\n            {\n                char\tszID[32];\n\n                sprintf( szID, \"%d\", iGCP+1 );\n                pasGCPList[iGCP].pszId = CPLStrdup( szID );\n                pasGCPList[iGCP].pszInfo = CPLStrdup(\"\");\n                pasGCPList[iGCP].dfGCPPixel = padfTiePoints[iGCP*6+0];\n                pasGCPList[iGCP].dfGCPLine = padfTiePoints[iGCP*6+1];\n                pasGCPList[iGCP].dfGCPX = padfTiePoints[iGCP*6+3];\n                pasGCPList[iGCP].dfGCPY = padfTiePoints[iGCP*6+4];\n                pasGCPList[iGCP].dfGCPZ = padfTiePoints[iGCP*6+5];\n\n                if( bPixelIsPoint && !bPointGeoIgnore )\n                {\n                    pasGCPList[iGCP].dfGCPPixel -= 0.5;\n                    pasGCPList[iGCP].dfGCPLine -= 0.5;\n                }\n            }\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Did we find a tab file?  If so we will use it's coordinate      */\n/*      system and give it precidence.                                  */\n/* -------------------------------------------------------------------- */\n        if( pszTabWKT != NULL \n            && (pszProjection == NULL || pszProjection[0] == '\\0') )\n        {\n            CPLFree( pszProjection );\n            pszProjection = pszTabWKT;\n            pszTabWKT = NULL;\n            bLookedForProjection = TRUE;\n        }\n        \n        CPLFree( pszTabWKT );\n        bGeoTIFFInfoChanged = FALSE;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Capture some other potentially interesting information.         */\n/* -------------------------------------------------------------------- */\n    char\t*pszText, szWorkMDI[200];\n    float   fResolution;\n    uint16  nShort;\n\n    if( TIFFGetField( hTIFF, TIFFTAG_DOCUMENTNAME, &pszText ) )\n        SetMetadataItem( \"TIFFTAG_DOCUMENTNAME\",  pszText );\n\n    if( TIFFGetField( hTIFF, TIFFTAG_IMAGEDESCRIPTION, &pszText ) )\n        SetMetadataItem( \"TIFFTAG_IMAGEDESCRIPTION\", pszText );\n\n    if( TIFFGetField( hTIFF, TIFFTAG_SOFTWARE, &pszText ) )\n        SetMetadataItem( \"TIFFTAG_SOFTWARE\", pszText );\n\n    if( TIFFGetField( hTIFF, TIFFTAG_DATETIME, &pszText ) )\n        SetMetadataItem( \"TIFFTAG_DATETIME\", pszText );\n\n    if( TIFFGetField( hTIFF, TIFFTAG_ARTIST, &pszText ) )\n        SetMetadataItem( \"TIFFTAG_ARTIST\", pszText );\n\n    if( TIFFGetField( hTIFF, TIFFTAG_HOSTCOMPUTER, &pszText ) )\n        SetMetadataItem( \"TIFFTAG_HOSTCOMPUTER\", pszText );\n\n    if( TIFFGetField( hTIFF, TIFFTAG_COPYRIGHT, &pszText ) )\n        SetMetadataItem( \"TIFFTAG_COPYRIGHT\", pszText );\n\n    if( TIFFGetField( hTIFF, TIFFTAG_XRESOLUTION, &fResolution ) )\n    {\n        sprintf( szWorkMDI, \"%.8g\", fResolution );\n        SetMetadataItem( \"TIFFTAG_XRESOLUTION\", szWorkMDI );\n    }\n\n    if( TIFFGetField( hTIFF, TIFFTAG_YRESOLUTION, &fResolution ) )\n    {\n        sprintf( szWorkMDI, \"%.8g\", fResolution );\n        SetMetadataItem( \"TIFFTAG_YRESOLUTION\", szWorkMDI );\n    }\n\n    if( TIFFGetField( hTIFF, TIFFTAG_MINSAMPLEVALUE, &nShort ) )\n    {\n        sprintf( szWorkMDI, \"%d\", nShort );\n        SetMetadataItem( \"TIFFTAG_MINSAMPLEVALUE\", szWorkMDI );\n    }\n\n    if( TIFFGetField( hTIFF, TIFFTAG_MAXSAMPLEVALUE, &nShort ) )\n    {\n        sprintf( szWorkMDI, \"%d\", nShort );\n        SetMetadataItem( \"TIFFTAG_MAXSAMPLEVALUE\", szWorkMDI );\n    }\n\n    if( TIFFGetField( hTIFF, TIFFTAG_RESOLUTIONUNIT, &nShort ) )\n    {\n        if( nShort == RESUNIT_NONE )\n            sprintf( szWorkMDI, \"%d (unitless)\", nShort );\n        else if( nShort == RESUNIT_INCH )\n            sprintf( szWorkMDI, \"%d (pixels/inch)\", nShort );\n        else if( nShort == RESUNIT_CENTIMETER )\n            sprintf( szWorkMDI, \"%d (pixels/cm)\", nShort );\n        else\n            sprintf( szWorkMDI, \"%d\", nShort );\n        SetMetadataItem( \"TIFFTAG_RESOLUTIONUNIT\", szWorkMDI );\n    }\n\n    if( nCompression == COMPRESSION_NONE )\n        /* no compression tag */;\n    else if( nCompression == COMPRESSION_CCITTRLE )\n        SetMetadataItem( \"COMPRESSION\", \"CCITTRLE\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_CCITTFAX3 )\n        SetMetadataItem( \"COMPRESSION\", \"CCITTFAX3\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_CCITTFAX4 )\n        SetMetadataItem( \"COMPRESSION\", \"CCITTFAX4\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_LZW )\n        SetMetadataItem( \"COMPRESSION\", \"LZW\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_OJPEG )\n        SetMetadataItem( \"COMPRESSION\", \"OJPEG\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_JPEG )\n    {  \n        if ( nPhotometric == PHOTOMETRIC_YCBCR )\n            SetMetadataItem( \"COMPRESSION\", \"YCbCr JPEG\", \"IMAGE_STRUCTURE\" );\n        else\n            SetMetadataItem( \"COMPRESSION\", \"JPEG\", \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_NEXT )\n        SetMetadataItem( \"COMPRESSION\", \"NEXT\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_CCITTRLEW )\n        SetMetadataItem( \"COMPRESSION\", \"CCITTRLEW\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_PACKBITS )\n        SetMetadataItem( \"COMPRESSION\", \"PACKBITS\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_THUNDERSCAN )\n        SetMetadataItem( \"COMPRESSION\", \"THUNDERSCAN\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_PIXARFILM )\n        SetMetadataItem( \"COMPRESSION\", \"PIXARFILM\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_PIXARLOG )\n        SetMetadataItem( \"COMPRESSION\", \"PIXARLOG\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_DEFLATE )\n        SetMetadataItem( \"COMPRESSION\", \"DEFLATE\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_ADOBE_DEFLATE )\n        SetMetadataItem( \"COMPRESSION\", \"DEFLATE\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_DCS )\n        SetMetadataItem( \"COMPRESSION\", \"DCS\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_JBIG )\n        SetMetadataItem( \"COMPRESSION\", \"JBIG\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_SGILOG )\n        SetMetadataItem( \"COMPRESSION\", \"SGILOG\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_SGILOG24 )\n        SetMetadataItem( \"COMPRESSION\", \"SGILOG24\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_JP2000 )\n        SetMetadataItem( \"COMPRESSION\", \"JP2000\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_LZMA )\n        SetMetadataItem( \"COMPRESSION\", \"LZMA\", \"IMAGE_STRUCTURE\" );\n\n    else\n    {\n        CPLString oComp;\n        SetMetadataItem( \"COMPRESSION\", \n                         (const char *) oComp.Printf( \"%d\", nCompression));\n    }\n\n    if( nPlanarConfig == PLANARCONFIG_CONTIG && nBands != 1 )\n        SetMetadataItem( \"INTERLEAVE\", \"PIXEL\", \"IMAGE_STRUCTURE\" );\n    else\n        SetMetadataItem( \"INTERLEAVE\", \"BAND\", \"IMAGE_STRUCTURE\" );\n\n    if(  (GetRasterBand(1)->GetRasterDataType() == GDT_Byte   && nBitsPerSample != 8 ) ||\n         (GetRasterBand(1)->GetRasterDataType() == GDT_UInt16 && nBitsPerSample != 16) ||\n         (GetRasterBand(1)->GetRasterDataType() == GDT_UInt32 && nBitsPerSample != 32) )\n    {\n        for (int i = 0; i < nBands; ++i)\n            GetRasterBand(i+1)->SetMetadataItem( \"NBITS\", \n                                                 CPLString().Printf( \"%d\", (int)nBitsPerSample ),\n                                                 \"IMAGE_STRUCTURE\" );\n    }\n        \n    if( bMinIsWhite )\n        SetMetadataItem( \"MINISWHITE\", \"YES\", \"IMAGE_STRUCTURE\" );\n\n    if( TIFFGetField( hTIFF, TIFFTAG_GDAL_METADATA, &pszText ) )\n    {\n        CPLXMLNode *psRoot = CPLParseXMLString( pszText );\n        CPLXMLNode *psItem = NULL;\n\n        if( psRoot != NULL && psRoot->eType == CXT_Element\n            && EQUAL(psRoot->pszValue,\"GDALMetadata\") )\n            psItem = psRoot->psChild;\n\n        for( ; psItem != NULL; psItem = psItem->psNext )\n        {\n            const char *pszKey, *pszValue, *pszRole, *pszDomain; \n            char *pszUnescapedValue;\n            int nBand, bIsXML = FALSE;\n\n            if( psItem->eType != CXT_Element\n                || !EQUAL(psItem->pszValue,\"Item\") )\n                continue;\n\n            pszKey = CPLGetXMLValue( psItem, \"name\", NULL );\n            pszValue = CPLGetXMLValue( psItem, NULL, NULL );\n            nBand = atoi(CPLGetXMLValue( psItem, \"sample\", \"-1\" )) + 1;\n            pszRole = CPLGetXMLValue( psItem, \"role\", \"\" );\n            pszDomain = CPLGetXMLValue( psItem, \"domain\", \"\" );\n                \n            if( pszKey == NULL || pszValue == NULL )\n                continue;\n\n            if( EQUALN(pszDomain,\"xml:\",4) )\n                bIsXML = TRUE;\n\n            pszUnescapedValue = CPLUnescapeString( pszValue, NULL, \n                                                   CPLES_XML );\n            if( nBand == 0 )\n            {\n                if( bIsXML )\n                {\n                    char *apszMD[2] = { pszUnescapedValue, NULL };\n                    SetMetadata( apszMD, pszDomain );\n                }\n                else\n                    SetMetadataItem( pszKey, pszUnescapedValue, pszDomain );\n            }\n            else\n            {\n                GDALRasterBand *poBand = GetRasterBand(nBand);\n                if( poBand != NULL )\n                {\n                    if( EQUAL(pszRole,\"scale\") )\n                        poBand->SetScale( CPLAtofM(pszUnescapedValue) );\n                    else if( EQUAL(pszRole,\"offset\") )\n                        poBand->SetOffset( CPLAtofM(pszUnescapedValue) );\n                    else if( EQUAL(pszRole,\"unittype\") )\n                        poBand->SetUnitType( pszUnescapedValue );\n                    else\n                    {\n                        if( bIsXML )\n                        {\n                            char *apszMD[2] = { pszUnescapedValue, NULL };\n                            poBand->SetMetadata( apszMD, pszDomain );\n                        }\n                        else\n                            poBand->SetMetadataItem(pszKey,pszUnescapedValue,\n                                                    pszDomain );\n                    }\n                }\n            }\n            CPLFree( pszUnescapedValue );\n        }\n\n        CPLDestroyXMLNode( psRoot );\n    }\n\n    bMetadataChanged = FALSE;\n\n/* -------------------------------------------------------------------- */\n/*      Check for NODATA                                                */\n/* -------------------------------------------------------------------- */\n    if( TIFFGetField( hTIFF, TIFFTAG_GDAL_NODATA, &pszText ) )\n    {\n        bNoDataSet = TRUE;\n        dfNoDataValue = CPLAtofM( pszText );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If this is a \"base\" raster, we should scan for any              */\n/*      associated overviews, internal mask bands and subdatasets.      */\n/* -------------------------------------------------------------------- */\n    if( bBase )\n    {\n        char **papszSubdatasets = NULL;\n        int  iDirIndex = 0;\n\n        FlushDirectory();  \n        while( !TIFFLastDirectory( hTIFF ) \n               && (iDirIndex == 0 || TIFFReadDirectory( hTIFF ) != 0) )\n        {\n            toff_t\tnThisDir = TIFFCurrentDirOffset(hTIFF);\n            uint32\tnSubType = 0;\n\n            *ppoActiveDSRef = NULL; // our directory no longer matches this ds\n            \n            iDirIndex++;\n\n            if( !TIFFGetField(hTIFF, TIFFTAG_SUBFILETYPE, &nSubType) )\n                nSubType = 0;\n\n            /* Embedded overview of the main image */\n            if ((nSubType & FILETYPE_REDUCEDIMAGE) != 0 &&\n                (nSubType & FILETYPE_MASK) == 0 &&\n                iDirIndex != 1 )\n            {\n                GTiffDataset\t*poODS;\n                \n                poODS = new GTiffDataset();\n                if( poODS->OpenOffset( hTIFF, ppoActiveDSRef, nThisDir, FALSE, \n                                       eAccess ) != CE_None \n                    || poODS->GetRasterCount() != GetRasterCount() )\n                {\n                    delete poODS;\n                }\n                else\n                {\n                    CPLDebug( \"GTiff\", \"Opened %dx%d overview.\\n\", \n                              poODS->GetRasterXSize(), poODS->GetRasterYSize());\n                    nOverviewCount++;\n                    papoOverviewDS = (GTiffDataset **)\n                        CPLRealloc(papoOverviewDS, \n                                   nOverviewCount * (sizeof(void*)));\n                    papoOverviewDS[nOverviewCount-1] = poODS;\n                    poODS->poBaseDS = this;\n                }\n            }\n            \n            /* Embedded mask of the main image */\n            else if ((nSubType & FILETYPE_MASK) != 0 &&\n                     (nSubType & FILETYPE_REDUCEDIMAGE) == 0 &&\n                     poMaskDS == NULL )\n            {\n                poMaskDS = new GTiffDataset();\n                \n                /* The TIFF6 specification - page 37 - only allows 1 SamplesPerPixel and 1 BitsPerSample\n                   Here we support either 1 or 8 bit per sample\n                   and we support either 1 sample per pixel or as many samples as in the main image\n                   We don't check the value of the PhotometricInterpretation tag, which should be\n                   set to \"Transparency mask\" (4) according to the specification (page 36)\n                   ... But the TIFF6 specification allows image masks to have a higher resolution than\n                   the main image, what we don't support here\n                */\n\n                if( poMaskDS->OpenOffset( hTIFF, ppoActiveDSRef, nThisDir, \n                                          FALSE, eAccess ) != CE_None \n                    || poMaskDS->GetRasterCount() == 0\n                    || !(poMaskDS->GetRasterCount() == 1 || poMaskDS->GetRasterCount() == GetRasterCount())\n                    || poMaskDS->GetRasterXSize() != GetRasterXSize()\n                    || poMaskDS->GetRasterYSize() != GetRasterYSize()\n                    || poMaskDS->GetRasterBand(1)->GetRasterDataType() != GDT_Byte)\n                {\n                    delete poMaskDS;\n                    poMaskDS = NULL;\n                }\n                else\n                {\n                    CPLDebug( \"GTiff\", \"Opened band mask.\\n\");\n                    poMaskDS->poBaseDS = this;\n                    \n                    poMaskDS->bPromoteTo8Bits = CSLTestBoolean(CPLGetConfigOption(\"GDAL_TIFF_INTERNAL_MASK_TO_8BIT\", \"YES\"));\n                }\n            }\n            \n            /* Embedded mask of an overview */\n            /* The TIFF6 specification allows the combination of the FILETYPE_xxxx masks */\n            else if ((nSubType & FILETYPE_REDUCEDIMAGE) != 0 &&\n                     (nSubType & FILETYPE_MASK) != 0)\n            {\n                GTiffDataset* poDS = new GTiffDataset();\n                if( poDS->OpenOffset( hTIFF, ppoActiveDSRef, nThisDir, FALSE, \n                                      eAccess ) != CE_None\n                    || poDS->GetRasterCount() == 0\n                    || poDS->GetRasterBand(1)->GetRasterDataType() != GDT_Byte)\n                {\n                    delete poDS;\n                }\n                else\n                {\n                    int i;\n                    for(i=0;i<nOverviewCount;i++)\n                    {\n                        if (((GTiffDataset*)papoOverviewDS[i])->poMaskDS == NULL &&\n                            poDS->GetRasterXSize() == papoOverviewDS[i]->GetRasterXSize() &&\n                            poDS->GetRasterYSize() == papoOverviewDS[i]->GetRasterYSize() &&\n                            (poDS->GetRasterCount() == 1 || poDS->GetRasterCount() == GetRasterCount()))\n                        {\n                            CPLDebug( \"GTiff\", \"Opened band mask for %dx%d overview.\\n\",\n                                      poDS->GetRasterXSize(), poDS->GetRasterYSize());\n                            ((GTiffDataset*)papoOverviewDS[i])->poMaskDS = poDS;\n                            poDS->bPromoteTo8Bits = CSLTestBoolean(CPLGetConfigOption(\"GDAL_TIFF_INTERNAL_MASK_TO_8BIT\", \"YES\"));\n                            poDS->poBaseDS = this;\n                            break;\n                        }\n                    }\n                    if (i == nOverviewCount)\n                    {\n                        delete poDS;\n                    }\n                }\n            }\n            else if( nSubType == 0 ) {\n                CPLString osName, osDesc;\n                uint32\tnXSize, nYSize;\n                uint16  nSPP;\n\n                TIFFGetField( hTIFF, TIFFTAG_IMAGEWIDTH, &nXSize );\n                TIFFGetField( hTIFF, TIFFTAG_IMAGELENGTH, &nYSize );\n                if( !TIFFGetField(hTIFF, TIFFTAG_SAMPLESPERPIXEL, &nSPP ) )\n                    nSPP = 1;\n\n                osName.Printf( \"SUBDATASET_%d_NAME=GTIFF_DIR:%d:%s\", \n                               iDirIndex, iDirIndex, osFilename.c_str() );\n                osDesc.Printf( \"SUBDATASET_%d_DESC=Page %d (%dP x %dL x %dB)\", \n                               iDirIndex, iDirIndex, \n                               (int)nXSize, (int)nYSize, nSPP );\n\n                papszSubdatasets = \n                    CSLAddString( papszSubdatasets, osName );\n                papszSubdatasets = \n                    CSLAddString( papszSubdatasets, osDesc );\n            }\n\n            // Make sure we are stepping from the expected directory regardless\n            // of churn done processing the above.\n            if( TIFFCurrentDirOffset(hTIFF) != nThisDir )\n                TIFFSetSubDirectory( hTIFF, nThisDir );\n            *ppoActiveDSRef = NULL;\n        }\n\n        /* If we have a mask for the main image, loop over the overviews, and if they */\n        /* have a mask, let's set this mask as an overview of the main mask... */\n        if (poMaskDS != NULL)\n        {\n            int i;\n            for(i=0;i<nOverviewCount;i++)\n            {\n                if (((GTiffDataset*)papoOverviewDS[i])->poMaskDS != NULL)\n                {\n                    poMaskDS->nOverviewCount++;\n                    poMaskDS->papoOverviewDS = (GTiffDataset **)\n                        CPLRealloc(poMaskDS->papoOverviewDS, \n                                poMaskDS->nOverviewCount * (sizeof(void*)));\n                    poMaskDS->papoOverviewDS[poMaskDS->nOverviewCount-1] =\n                            ((GTiffDataset*)papoOverviewDS[i])->poMaskDS;\n                }\n            }\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Only keep track of subdatasets if we have more than one         */\n/*      subdataset (pair).                                              */\n/* -------------------------------------------------------------------- */\n        if( CSLCount(papszSubdatasets) > 2 )\n        {\n            oGTiffMDMD.SetMetadata( papszSubdatasets, \"SUBDATASETS\" );\n        }\n        CSLDestroy( papszSubdatasets );\n    }\n\n    return( CE_None );\n}\n\nstatic int GTiffGetLZMAPreset(char** papszOptions)\n{\n    int nLZMAPreset = -1;\n    const char* pszValue = CSLFetchNameValue( papszOptions, \"LZMA_PRESET\" );\n    if( pszValue  != NULL )\n    {\n        nLZMAPreset =  atoi( pszValue );\n        if (!(nLZMAPreset >= 0 && nLZMAPreset <= 9))\n        {\n            CPLError( CE_Warning, CPLE_IllegalArg,\n                    \"LZMA_PRESET=%s value not recognised, ignoring.\",\n                    pszValue );\n            nLZMAPreset = -1;\n        }\n    }\n    return nLZMAPreset;\n}\n\n\nstatic int GTiffGetZLevel(char** papszOptions)\n{\n    int nZLevel = -1;\n    const char* pszValue = CSLFetchNameValue( papszOptions, \"ZLEVEL\" );\n    if( pszValue  != NULL )\n    {\n        nZLevel =  atoi( pszValue );\n        if (!(nZLevel >= 1 && nZLevel <= 9))\n        {\n            CPLError( CE_Warning, CPLE_IllegalArg, \n                    \"ZLEVEL=%s value not recognised, ignoring.\",\n                    pszValue );\n            nZLevel = -1;\n        }\n    }\n    return nZLevel;\n}\n\nstatic int GTiffGetJpegQuality(char** papszOptions)\n{\n    int nJpegQuality = -1;\n    const char* pszValue = CSLFetchNameValue( papszOptions, \"JPEG_QUALITY\" );\n    if( pszValue  != NULL )\n    {\n        nJpegQuality = atoi( pszValue );\n        if (!(nJpegQuality >= 1 && nJpegQuality <= 100))\n        {\n            CPLError( CE_Warning, CPLE_IllegalArg, \n                    \"JPEG_QUALITY=%s value not recognised, ignoring.\",\n                    pszValue );\n            nJpegQuality = -1;\n        }\n    }\n    return nJpegQuality;\n}\n\n/************************************************************************/\n/*                            GTiffCreate()                             */\n/*                                                                      */\n/*      Shared functionality between GTiffDataset::Create() and         */\n/*      GTiffCreateCopy() for creating TIFF file based on a set of      */\n/*      options and a configuration.                                    */\n/************************************************************************/\n\nTIFF *GTiffDataset::CreateLL( const char * pszFilename,\n                              int nXSize, int nYSize, int nBands,\n                              GDALDataType eType,\n                              double dfExtraSpaceForOverviews,\n                              char **papszParmList )\n\n{\n    TIFF\t\t*hTIFF;\n    int                 nBlockXSize = 0, nBlockYSize = 0;\n    int                 bTiled = FALSE;\n    int                 nCompression = COMPRESSION_NONE;\n    int                 nPredictor = PREDICTOR_NONE, nJpegQuality = -1, nZLevel = -1,\n                        nLZMAPreset = -1;\n    uint16              nSampleFormat;\n    int\t\t\tnPlanar;\n    const char          *pszValue;\n    const char          *pszProfile;\n    int                 bCreateBigTIFF = FALSE;\n\n    if (!GTiffOneTimeInit())\n        return NULL;\n\n/* -------------------------------------------------------------------- */\n/*      Blow on a few errors.                                           */\n/* -------------------------------------------------------------------- */\n    if( nXSize < 1 || nYSize < 1 || nBands < 1 )\n    {\n        CPLError( CE_Failure, CPLE_AppDefined, \n                  \"Attempt to create %dx%dx%d TIFF file, but width, height and bands\\n\"\n                  \"must be positive.\", \n                  nXSize, nYSize, nBands );\n\n        return NULL;\n    }\n\n    if (nBands > 65535)\n    {\n        CPLError( CE_Failure, CPLE_AppDefined, \n                  \"Attempt to create %dx%dx%d TIFF file, but bands\\n\"\n                  \"must be lesser or equal to 65535.\", \n                  nXSize, nYSize, nBands );\n\n        return NULL;\n    }\n\n/* -------------------------------------------------------------------- */\n/*\tSetup values based on options.\t\t\t\t\t*/\n/* -------------------------------------------------------------------- */\n    pszProfile = CSLFetchNameValue(papszParmList,\"PROFILE\");\n    if( pszProfile == NULL )\n        pszProfile = \"GDALGeoTIFF\";\n\n    if( CSLFetchBoolean( papszParmList, \"TILED\", FALSE ) )\n        bTiled = TRUE;\n\n    pszValue = CSLFetchNameValue(papszParmList,\"BLOCKXSIZE\");\n    if( pszValue != NULL )\n        nBlockXSize = atoi( pszValue );\n\n    pszValue = CSLFetchNameValue(papszParmList,\"BLOCKYSIZE\");\n    if( pszValue != NULL )\n        nBlockYSize = atoi( pszValue );\n\n    pszValue = CSLFetchNameValue(papszParmList,\"INTERLEAVE\");\n    if( pszValue != NULL )\n    {\n        if( EQUAL( pszValue, \"PIXEL\" ) )\n            nPlanar = PLANARCONFIG_CONTIG;\n        else if( EQUAL( pszValue, \"BAND\" ) )\n            nPlanar = PLANARCONFIG_SEPARATE;\n        else\n        {\n            CPLError( CE_Failure, CPLE_AppDefined, \n                      \"INTERLEAVE=%s unsupported, value must be PIXEL or BAND.\",\n                      pszValue );\n            return NULL;\n        }\n    }\n    else \n    {\n        nPlanar = PLANARCONFIG_CONTIG;\n    }\n\n    pszValue = CSLFetchNameValue( papszParmList, \"COMPRESS\" );\n    if( pszValue  != NULL )\n    {\n        nCompression = GTIFFGetCompressionMethod(pszValue, \"COMPRESS\");\n        if (nCompression < 0)\n            return NULL;\n    }\n\n    pszValue = CSLFetchNameValue( papszParmList, \"PREDICTOR\" );\n    if( pszValue  != NULL )\n        nPredictor =  atoi( pszValue );\n\n    nZLevel = GTiffGetZLevel(papszParmList);\n    nLZMAPreset = GTiffGetLZMAPreset(papszParmList);\n    nJpegQuality = GTiffGetJpegQuality(papszParmList);\n\n/* -------------------------------------------------------------------- */\n/*      Compute the uncompressed size.                                  */\n/* -------------------------------------------------------------------- */\n    double  dfUncompressedImageSize;\n\n    dfUncompressedImageSize = \n        nXSize * ((double)nYSize) * nBands * (GDALGetDataTypeSize(eType)/8);\n    dfUncompressedImageSize += dfExtraSpaceForOverviews;\n\n    if( nCompression == COMPRESSION_NONE \n        && dfUncompressedImageSize > 4200000000.0 )\n    {\n#ifndef BIGTIFF_SUPPORT\n        CPLError( CE_Failure, CPLE_NotSupported, \n                  \"A %d pixels x %d lines x %d bands %s image would be larger than 4GB\\n\"\n                  \"but this is the largest size a TIFF can be, and BigTIFF is unavailable.\\n\"\n                  \"Creation failed.\",\n                  nXSize, nYSize, nBands, GDALGetDataTypeName(eType) );\n        return NULL;\n#endif\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Should the file be created as a bigtiff file?                   */\n/* -------------------------------------------------------------------- */\n    const char *pszBIGTIFF = CSLFetchNameValue(papszParmList, \"BIGTIFF\");\n\n    if( pszBIGTIFF == NULL )\n        pszBIGTIFF = \"IF_NEEDED\";\n\n    if( EQUAL(pszBIGTIFF,\"IF_NEEDED\") )\n    {\n        if( nCompression == COMPRESSION_NONE \n            && dfUncompressedImageSize > 4200000000.0 )\n            bCreateBigTIFF = TRUE;\n    }\n    else if( EQUAL(pszBIGTIFF,\"IF_SAFER\") )\n    {\n        if( dfUncompressedImageSize > 2000000000.0 )\n            bCreateBigTIFF = TRUE;\n    }\n\n    else\n    {\n        bCreateBigTIFF = CSLTestBoolean( pszBIGTIFF );\n        if (!bCreateBigTIFF && nCompression == COMPRESSION_NONE &&\n             dfUncompressedImageSize > 4200000000.0 )\n        {\n            CPLError( CE_Failure, CPLE_NotSupported, \n                \"The TIFF file will be larger than 4GB, so BigTIFF is necessary.\\n\"\n                \"Creation failed.\");\n            return NULL;\n        }\n    }\n\n#ifndef BIGTIFF_SUPPORT\n    if( bCreateBigTIFF )\n    {\n        CPLError( CE_Warning, CPLE_NotSupported,\n                  \"BigTIFF requested, but GDAL built without BigTIFF\\n\"\n                  \"enabled libtiff, request ignored.\" );\n        bCreateBigTIFF = FALSE;\n    }\n#endif\n\n    if( bCreateBigTIFF )\n        CPLDebug( \"GTiff\", \"File being created as a BigTIFF.\" );\n    \n/* -------------------------------------------------------------------- */\n/*      Check if the user wishes a particular endianness                */\n/* -------------------------------------------------------------------- */\n\n    int eEndianness = ENDIANNESS_NATIVE;\n    pszValue = CSLFetchNameValue(papszParmList, \"ENDIANNESS\");\n    if ( pszValue == NULL )\n        pszValue = CPLGetConfigOption( \"GDAL_TIFF_ENDIANNESS\", NULL );\n    if ( pszValue != NULL )\n    {\n        if (EQUAL(pszValue, \"LITTLE\"))\n            eEndianness = ENDIANNESS_LITTLE;\n        else if (EQUAL(pszValue, \"BIG\"))\n            eEndianness = ENDIANNESS_BIG;\n        else if (EQUAL(pszValue, \"INVERTED\"))\n        {\n#ifdef CPL_LSB\n            eEndianness = ENDIANNESS_BIG;\n#else\n            eEndianness = ENDIANNESS_LITTLE;\n#endif\n        }\n        else if (!EQUAL(pszValue, \"NATIVE\"))\n        {\n            CPLError( CE_Warning, CPLE_NotSupported,\n                      \"ENDIANNESS=%s not supported. Defaulting to NATIVE\", pszValue );\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Try opening the dataset.                                        */\n/* -------------------------------------------------------------------- */\n\n    char szOpeningFlag[5];\n    strcpy(szOpeningFlag, \"w+\");\n    if (bCreateBigTIFF)\n        strcat(szOpeningFlag, \"8\");\n    if (eEndianness == ENDIANNESS_BIG)\n        strcat(szOpeningFlag, \"b\");\n    else if (eEndianness == ENDIANNESS_LITTLE)\n        strcat(szOpeningFlag, \"l\");\n    hTIFF = VSI_TIFFOpen( pszFilename, szOpeningFlag );\n    if( hTIFF == NULL )\n    {\n        if( CPLGetLastErrorNo() == 0 )\n            CPLError( CE_Failure, CPLE_OpenFailed,\n                      \"Attempt to create new tiff file `%s'\\n\"\n                      \"failed in XTIFFOpen().\\n\",\n                      pszFilename );\n        return NULL;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      How many bits per sample?  We have a special case if NBITS      */\n/*      specified for GDT_Byte, GDT_UInt16, GDT_UInt32.                 */\n/* -------------------------------------------------------------------- */\n    int nBitsPerSample = GDALGetDataTypeSize(eType);\n    if (CSLFetchNameValue(papszParmList, \"NBITS\") != NULL)\n    {\n        int nMinBits = 0, nMaxBits = 0;\n        nBitsPerSample = atoi(CSLFetchNameValue(papszParmList, \"NBITS\"));\n        if( eType == GDT_Byte  )\n        {\n            nMinBits = 1;\n            nMaxBits = 8;\n        }\n        else if( eType == GDT_UInt16 )\n        {\n            nMinBits = 9;\n            nMaxBits = 16;\n        }\n        else if( eType == GDT_UInt32  )\n        {\n            nMinBits = 17;\n            nMaxBits = 32;\n        }\n        else\n        {\n            CPLError(CE_Warning, CPLE_NotSupported,\n                     \"NBITS is not supported for data type %s\",\n                     GDALGetDataTypeName(eType));\n            nBitsPerSample = GDALGetDataTypeSize(eType);\n        }\n\n        if (nMinBits != 0)\n        {\n            if (nBitsPerSample < nMinBits)\n            {\n                CPLError(CE_Warning, CPLE_AppDefined,\n                         \"NBITS=%d is invalid for data type %s. Using NBITS=%d\",\n                         nBitsPerSample, GDALGetDataTypeName(eType), nMinBits);\n                nBitsPerSample = nMinBits;\n            }\n            else if (nBitsPerSample > nMaxBits)\n            {\n                CPLError(CE_Warning, CPLE_AppDefined,\n                         \"NBITS=%d is invalid for data type %s. Using NBITS=%d\",\n                         nBitsPerSample, GDALGetDataTypeName(eType), nMaxBits);\n                nBitsPerSample = nMaxBits;\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Do we have a custom pixel type (just used for signed byte now). */\n/* -------------------------------------------------------------------- */\n    const char *pszPixelType = CSLFetchNameValue( papszParmList, \"PIXELTYPE\" );\n    if( pszPixelType == NULL )\n        pszPixelType = \"\";\n\n/* -------------------------------------------------------------------- */\n/*      Setup some standard flags.                                      */\n/* -------------------------------------------------------------------- */\n    TIFFSetField( hTIFF, TIFFTAG_IMAGEWIDTH, nXSize );\n    TIFFSetField( hTIFF, TIFFTAG_IMAGELENGTH, nYSize );\n    TIFFSetField( hTIFF, TIFFTAG_BITSPERSAMPLE, nBitsPerSample );\n\n    if( (eType == GDT_Byte && EQUAL(pszPixelType,\"SIGNEDBYTE\"))\n        || eType == GDT_Int16 || eType == GDT_Int32 )\n        nSampleFormat = SAMPLEFORMAT_INT;\n    else if( eType == GDT_CInt16 || eType == GDT_CInt32 )\n        nSampleFormat = SAMPLEFORMAT_COMPLEXINT;\n    else if( eType == GDT_Float32 || eType == GDT_Float64 )\n        nSampleFormat = SAMPLEFORMAT_IEEEFP;\n    else if( eType == GDT_CFloat32 || eType == GDT_CFloat64 )\n        nSampleFormat = SAMPLEFORMAT_COMPLEXIEEEFP;\n    else\n        nSampleFormat = SAMPLEFORMAT_UINT;\n\n    TIFFSetField( hTIFF, TIFFTAG_SAMPLEFORMAT, nSampleFormat );\n    TIFFSetField( hTIFF, TIFFTAG_SAMPLESPERPIXEL, nBands );\n    TIFFSetField( hTIFF, TIFFTAG_PLANARCONFIG, nPlanar );\n\n/* -------------------------------------------------------------------- */\n/*      Setup Photometric Interpretation. Take this value from the user */\n/*      passed option or guess correct value otherwise.                 */\n/* -------------------------------------------------------------------- */\n    int nSamplesAccountedFor = 1;\n    int bForceColorTable = FALSE;\n\n    pszValue = CSLFetchNameValue(papszParmList,\"PHOTOMETRIC\");\n    if( pszValue != NULL )\n    {\n        if( EQUAL( pszValue, \"MINISBLACK\" ) )\n            TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK );\n        else if( EQUAL( pszValue, \"MINISWHITE\" ) )\n            TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISWHITE );\n        else if( EQUAL( pszValue, \"PALETTE\" ))\n        {\n            TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_PALETTE );\n            nSamplesAccountedFor = 1;\n            bForceColorTable = TRUE;\n        }\n        else if( EQUAL( pszValue, \"RGB\" ))\n        {\n            TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB );\n            nSamplesAccountedFor = 3;\n        }\n        else if( EQUAL( pszValue, \"CMYK\" ))\n        {\n            TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_SEPARATED );\n            nSamplesAccountedFor = 4;\n        }\n        else if( EQUAL( pszValue, \"YCBCR\" ))\n        {\n            /* Because of subsampling, setting YCBCR without JPEG compression leads */\n            /* to a crash currently. Would need to make GTiffRasterBand::IWriteBlock() */\n            /* aware of subsampling so that it doesn't overrun buffer size returned */\n            /* by libtiff */\n            if ( nCompression != COMPRESSION_JPEG )\n            {\n                CPLError(CE_Failure, CPLE_NotSupported,\n                         \"Currently, PHOTOMETRIC=YCBCR requires COMPRESS=JPEG\");\n                XTIFFClose(hTIFF);\n                return NULL;\n            }\n\n            if ( nPlanar == PLANARCONFIG_SEPARATE )\n            {\n                CPLError(CE_Failure, CPLE_NotSupported,\n                         \"PHOTOMETRIC=YCBCR requires INTERLEAVE=PIXEL\");\n                XTIFFClose(hTIFF);\n                return NULL;\n            }\n\n            /* YCBCR strictly requires 3 bands. Not less, not more */\n            /* Issue an explicit error message as libtiff one is a bit cryptic : */\n            /* TIFFVStripSize64:Invalid td_samplesperpixel value */\n            if ( nBands != 3 )\n            {\n                CPLError(CE_Failure, CPLE_NotSupported,\n                         \"PHOTOMETRIC=YCBCR requires a source raster with only 3 bands (RGB)\");\n                XTIFFClose(hTIFF);\n                return NULL;\n            }\n\n            TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR );\n            nSamplesAccountedFor = 3;\n        }\n        else if( EQUAL( pszValue, \"CIELAB\" ))\n        {\n            TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_CIELAB );\n            nSamplesAccountedFor = 3;\n        }\n        else if( EQUAL( pszValue, \"ICCLAB\" ))\n        {\n            TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_ICCLAB );\n            nSamplesAccountedFor = 3;\n        }\n        else if( EQUAL( pszValue, \"ITULAB\" ))\n        {\n            TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_ITULAB );\n            nSamplesAccountedFor = 3;\n        }\n        else\n        {\n            CPLError( CE_Warning, CPLE_IllegalArg, \n                      \"PHOTOMETRIC=%s value not recognised, ignoring.\\n\"\n                      \"Set the Photometric Interpretation as MINISBLACK.\", \n                      pszValue );\n            TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK );\n        }\n\n        if ( nBands < nSamplesAccountedFor )\n        {\n            CPLError( CE_Warning, CPLE_IllegalArg, \n                      \"PHOTOMETRIC=%s value does not correspond to number \"\n                      \"of bands (%d), ignoring.\\n\"\n                      \"Set the Photometric Interpretation as MINISBLACK.\", \n                      pszValue, nBands );\n            TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK );\n        }\n    }\n    else\n    {\n        /* \n         * If image contains 3 or 4 bands and datatype is Byte then we will\n         * assume it is RGB. In all other cases assume it is MINISBLACK.\n         */\n        if( nBands == 3 && eType == GDT_Byte )\n        {\n            TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB );\n            nSamplesAccountedFor = 3;\n        }\n        else if( nBands == 4 && eType == GDT_Byte )\n        {\n            uint16 v[1];\n\n            v[0] = EXTRASAMPLE_ASSOCALPHA;\n            TIFFSetField(hTIFF, TIFFTAG_EXTRASAMPLES, 1, v);\n            TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB );\n            nSamplesAccountedFor = 4;\n        }\n        else\n        {\n            TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK );\n            nSamplesAccountedFor = 1;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If there are extra samples, we need to mark them with an        */\n/*      appropriate extrasamples definition here.                       */\n/* -------------------------------------------------------------------- */\n    if( nBands > nSamplesAccountedFor )\n    {\n        uint16 *v;\n        int i;\n        int nExtraSamples = nBands - nSamplesAccountedFor;\n\n        v = (uint16 *) CPLMalloc( sizeof(uint16) * nExtraSamples );\n\n        if( CSLFetchBoolean(papszParmList,\"ALPHA\",FALSE) )\n            v[0] = EXTRASAMPLE_ASSOCALPHA;\n        else\n            v[0] = EXTRASAMPLE_UNSPECIFIED;\n            \n        for( i = 1; i < nExtraSamples; i++ )\n            v[i] = EXTRASAMPLE_UNSPECIFIED;\n\n        TIFFSetField(hTIFF, TIFFTAG_EXTRASAMPLES, nExtraSamples, v );\n        \n        CPLFree(v);\n    }\n    \n    /* Set the compression method before asking the default strip size */\n    /* This is usefull when translating to a JPEG-In-TIFF file where */\n    /* the default strip size is 8 or 16 depending on the photometric value */\n    TIFFSetField( hTIFF, TIFFTAG_COMPRESSION, nCompression );\n\n/* -------------------------------------------------------------------- */\n/*      Setup tiling/stripping flags.                                   */\n/* -------------------------------------------------------------------- */\n    if( bTiled )\n    {\n        if( nBlockXSize == 0 )\n            nBlockXSize = 256;\n        \n        if( nBlockYSize == 0 )\n            nBlockYSize = 256;\n\n        if (!TIFFSetField( hTIFF, TIFFTAG_TILEWIDTH, nBlockXSize ) ||\n            !TIFFSetField( hTIFF, TIFFTAG_TILELENGTH, nBlockYSize ))\n        {\n            XTIFFClose(hTIFF);\n            return NULL;\n        }\n    }\n    else\n    {\n        uint32 nRowsPerStrip;\n\n        if( nBlockYSize == 0 )\n            nRowsPerStrip = MIN(nYSize, (int)TIFFDefaultStripSize(hTIFF,0));\n        else\n            nRowsPerStrip = nBlockYSize;\n        \n        TIFFSetField( hTIFF, TIFFTAG_ROWSPERSTRIP, nRowsPerStrip );\n    }\n    \n/* -------------------------------------------------------------------- */\n/*      Set compression related tags.                                   */\n/* -------------------------------------------------------------------- */\n    if ( nCompression == COMPRESSION_LZW ||\n         nCompression == COMPRESSION_ADOBE_DEFLATE )\n        TIFFSetField( hTIFF, TIFFTAG_PREDICTOR, nPredictor );\n    if (nCompression == COMPRESSION_ADOBE_DEFLATE\n        && nZLevel != -1)\n        TIFFSetField( hTIFF, TIFFTAG_ZIPQUALITY, nZLevel );\n    else if( nCompression == COMPRESSION_JPEG \n        && nJpegQuality != -1 )\n        TIFFSetField( hTIFF, TIFFTAG_JPEGQUALITY, nJpegQuality );\n    else if( nCompression == COMPRESSION_LZMA && nLZMAPreset != -1)\n        TIFFSetField( hTIFF, TIFFTAG_LZMAPRESET, nLZMAPreset );\n\n/* -------------------------------------------------------------------- */\n/*      If we forced production of a file with photometric=palette,     */\n/*      we need to push out a default color table.                      */\n/* -------------------------------------------------------------------- */\n    if( bForceColorTable )\n    {\n        int nColors;\n        \n        if( eType == GDT_Byte )\n            nColors = 256;\n        else\n            nColors = 65536;\n        \n        unsigned short *panTRed, *panTGreen, *panTBlue;\n\n        panTRed = (unsigned short *) CPLMalloc(sizeof(unsigned short)*nColors);\n        panTGreen = (unsigned short *) CPLMalloc(sizeof(unsigned short)*nColors);\n        panTBlue = (unsigned short *) CPLMalloc(sizeof(unsigned short)*nColors);\n\n        for( int iColor = 0; iColor < nColors; iColor++ )\n        {\n            if( eType == GDT_Byte )\n            {                \n                panTRed[iColor] = (unsigned short) (257 * iColor);\n                panTGreen[iColor] = (unsigned short) (257 * iColor);\n                panTBlue[iColor] = (unsigned short) (257 * iColor);\n            }\n            else\n            {\n                panTRed[iColor] = (unsigned short) iColor;\n                panTGreen[iColor] = (unsigned short) iColor;\n                panTBlue[iColor] = (unsigned short) iColor;\n            }\n        }\n        \n        TIFFSetField( hTIFF, TIFFTAG_COLORMAP,\n                      panTRed, panTGreen, panTBlue );\n        \n        CPLFree( panTRed );\n        CPLFree( panTGreen );\n        CPLFree( panTBlue );\n    }\n\n    return( hTIFF );\n}\n\n/************************************************************************/\n/*                               Create()                               */\n/*                                                                      */\n/*      Create a new GeoTIFF or TIFF file.                              */\n/************************************************************************/\n\nGDALDataset *GTiffDataset::Create( const char * pszFilename,\n                                   int nXSize, int nYSize, int nBands,\n                                   GDALDataType eType,\n                                   char **papszParmList )\n\n{\n    GTiffDataset *\tpoDS;\n    TIFF\t\t*hTIFF;\n\n/* -------------------------------------------------------------------- */\n/*      Create the underlying TIFF file.                                */\n/* -------------------------------------------------------------------- */\n    hTIFF = CreateLL( pszFilename, nXSize, nYSize, nBands, \n                      eType, 0, papszParmList );\n\n    if( hTIFF == NULL )\n        return NULL;\n\n/* -------------------------------------------------------------------- */\n/*      Create the new GTiffDataset object.                             */\n/* -------------------------------------------------------------------- */\n    poDS = new GTiffDataset();\n    poDS->hTIFF = hTIFF;\n    poDS->poActiveDS = poDS;\n    poDS->ppoActiveDSRef = &(poDS->poActiveDS);\n\n    poDS->nRasterXSize = nXSize;\n    poDS->nRasterYSize = nYSize;\n    poDS->eAccess = GA_Update;\n    poDS->bCrystalized = FALSE;\n    poDS->nSamplesPerPixel = (uint16) nBands;\n    poDS->osFilename = pszFilename;\n\n    /* Avoid premature crystalization that will cause directory re-writting */\n    /* if GetProjectionRef() or GetGeoTransform() are called on the newly created GeoTIFF */\n    poDS->bLookedForProjection = TRUE;\n\n    TIFFGetField( hTIFF, TIFFTAG_SAMPLEFORMAT, &(poDS->nSampleFormat) );\n    TIFFGetField( hTIFF, TIFFTAG_PLANARCONFIG, &(poDS->nPlanarConfig) );\n    TIFFGetField( hTIFF, TIFFTAG_PHOTOMETRIC, &(poDS->nPhotometric) );\n    TIFFGetField( hTIFF, TIFFTAG_BITSPERSAMPLE, &(poDS->nBitsPerSample) );\n    TIFFGetField( hTIFF, TIFFTAG_COMPRESSION, &(poDS->nCompression) );\n\n    if( TIFFIsTiled(hTIFF) )\n    {\n        TIFFGetField( hTIFF, TIFFTAG_TILEWIDTH, &(poDS->nBlockXSize) );\n        TIFFGetField( hTIFF, TIFFTAG_TILELENGTH, &(poDS->nBlockYSize) );\n    }\n    else\n    {\n        if( !TIFFGetField( hTIFF, TIFFTAG_ROWSPERSTRIP,\n                           &(poDS->nRowsPerStrip) ) )\n            poDS->nRowsPerStrip = 1; /* dummy value */\n\n        poDS->nBlockXSize = nXSize;\n        poDS->nBlockYSize = MIN((int)poDS->nRowsPerStrip,nYSize);\n    }\n\n    poDS->nBlocksPerBand =\n        ((nYSize + poDS->nBlockYSize - 1) / poDS->nBlockYSize)\n        * ((nXSize + poDS->nBlockXSize - 1) / poDS->nBlockXSize);\n\n    if( CSLFetchNameValue( papszParmList, \"PROFILE\" ) != NULL )\n        poDS->osProfile = CSLFetchNameValue( papszParmList, \"PROFILE\" );\n\n/* -------------------------------------------------------------------- */\n/*      YCbCr JPEG compressed images should be translated on the fly    */\n/*      to RGB by libtiff/libjpeg unless specifically requested         */\n/*      otherwise.                                                      */\n/* -------------------------------------------------------------------- */\n    if( poDS->nCompression == COMPRESSION_JPEG \n        && poDS->nPhotometric == PHOTOMETRIC_YCBCR \n        && CSLTestBoolean( CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\",\n                                              \"YES\") ) )\n    {\n        int nColorMode;\n\n        poDS->SetMetadataItem( \"SOURCE_COLOR_SPACE\", \"YCbCr\", \"IMAGE_STRUCTURE\" );\n        if ( !TIFFGetField( hTIFF, TIFFTAG_JPEGCOLORMODE, &nColorMode ) ||\n             nColorMode != JPEGCOLORMODE_RGB )\n            TIFFSetField(hTIFF, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Read palette back as a color table if it has one.               */\n/* -------------------------------------------------------------------- */\n    unsigned short\t*panRed, *panGreen, *panBlue;\n    \n    if( poDS->nPhotometric == PHOTOMETRIC_PALETTE\n        && TIFFGetField( hTIFF, TIFFTAG_COLORMAP, \n                         &panRed, &panGreen, &panBlue) )\n    {\n        int\tnColorCount;\n        GDALColorEntry oEntry;\n\n        poDS->poColorTable = new GDALColorTable();\n\n        nColorCount = 1 << poDS->nBitsPerSample;\n\n        for( int iColor = nColorCount - 1; iColor >= 0; iColor-- )\n        {\n            oEntry.c1 = panRed[iColor] / 256;\n            oEntry.c2 = panGreen[iColor] / 256;\n            oEntry.c3 = panBlue[iColor] / 256;\n            oEntry.c4 = 255;\n\n            poDS->poColorTable->SetColorEntry( iColor, &oEntry );\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Do we want to ensure all blocks get written out on close to     */\n/*      avoid sparse files?                                             */\n/* -------------------------------------------------------------------- */\n    if( !CSLFetchBoolean( papszParmList, \"SPARSE_OK\", FALSE ) )\n        poDS->bFillEmptyTiles = TRUE;\n        \n/* -------------------------------------------------------------------- */\n/*      Preserve creation options for consulting later (for instance    */\n/*      to decide if a TFW file should be written).                     */\n/* -------------------------------------------------------------------- */\n    poDS->papszCreationOptions = CSLDuplicate( papszParmList );\n\n    poDS->nZLevel = GTiffGetZLevel(papszParmList);\n    poDS->nLZMAPreset = GTiffGetLZMAPreset(papszParmList);\n    poDS->nJpegQuality = GTiffGetJpegQuality(papszParmList);\n\n/* -------------------------------------------------------------------- */\n/*      If we are writing jpeg compression we need to write some        */\n/*      imagery to force the jpegtables to get created.  This is,       */\n/*      likely only needed with libtiff >= 3.9.3 (#3633)                */\n/* -------------------------------------------------------------------- */\n    if( poDS->nCompression == COMPRESSION_JPEG\n        && strstr(TIFFLIB_VERSION_STR, \"Version 3.9\") != NULL )\n    {\n        CPLDebug( \"GDAL\",\n                  \"Writing zero block to force creation of JPEG tables.\" );\n        if( TIFFIsTiled( hTIFF ) )\n        {\n            int cc = TIFFTileSize( hTIFF );\n            unsigned char *pabyZeros = (unsigned char *) CPLCalloc(cc,1);\n            TIFFWriteEncodedTile(hTIFF, 0, pabyZeros, cc);\n            CPLFree( pabyZeros );\n        }\n        else\n        {\n            int cc = TIFFStripSize( hTIFF );\n            unsigned char *pabyZeros = (unsigned char *) CPLCalloc(cc,1);\n            TIFFWriteEncodedStrip(hTIFF, 0, pabyZeros, cc);\n            CPLFree( pabyZeros );\n        }\n        poDS->bDontReloadFirstBlock = TRUE;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Create band information objects.                                */\n/* -------------------------------------------------------------------- */\n    int\t\tiBand;\n\n    for( iBand = 0; iBand < nBands; iBand++ )\n    {\n        if( poDS->nBitsPerSample == 8 ||\n            poDS->nBitsPerSample == 16 ||\n            poDS->nBitsPerSample == 32 ||\n            poDS->nBitsPerSample == 64 ||\n            poDS->nBitsPerSample == 128)\n            poDS->SetBand( iBand+1, new GTiffRasterBand( poDS, iBand+1 ) );\n        else\n        {\n            poDS->SetBand( iBand+1, new GTiffOddBitsBand( poDS, iBand+1 ) );\n            poDS->GetRasterBand( iBand+1 )->\n                SetMetadataItem( \"NBITS\", \n                                 CPLString().Printf(\"%d\",poDS->nBitsPerSample),\n                                 \"IMAGE_STRUCTURE\" );\n        }\n    }\n\n    poDS->oOvManager.Initialize( poDS, pszFilename );\n\n    return( poDS );\n}\n\n/************************************************************************/\n/*                             CreateCopy()                             */\n/************************************************************************/\n\nGDALDataset *\nGTiffDataset::CreateCopy( const char * pszFilename, GDALDataset *poSrcDS, \n                          int bStrict, char ** papszOptions, \n                          GDALProgressFunc pfnProgress, void * pProgressData )\n\n{\n    TIFF\t*hTIFF;\n    int\t\tnXSize = poSrcDS->GetRasterXSize();\n    int\t\tnYSize = poSrcDS->GetRasterYSize();\n    int\t\tnBands = poSrcDS->GetRasterCount();\n    int         iBand;\n    CPLErr      eErr = CE_None;\n    uint16\tnPlanarConfig;\n    uint16\tnBitsPerSample;\n    GDALRasterBand *poPBand;\n\n    if( poSrcDS->GetRasterCount() == 0 )\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                  \"Unable to export GeoTIFF files with zero bands.\" );\n        return NULL;\n    }\n        \n    poPBand = poSrcDS->GetRasterBand(1);\n    GDALDataType eType = poPBand->GetRasterDataType();\n\n/* -------------------------------------------------------------------- */\n/*      Check, whether all bands in input dataset has the same type.    */\n/* -------------------------------------------------------------------- */\n    for ( iBand = 2; iBand <= nBands; iBand++ )\n    {\n        if ( eType != poSrcDS->GetRasterBand(iBand)->GetRasterDataType() )\n        {\n            if ( bStrict )\n            {\n                CPLError( CE_Failure, CPLE_AppDefined,\n                          \"Unable to export GeoTIFF file with different datatypes per\\n\"\n                          \"different bands. All bands should have the same types in TIFF.\" );\n                return NULL;\n            }\n            else\n            {\n                CPLError( CE_Warning, CPLE_AppDefined,\n                          \"Unable to export GeoTIFF file with different datatypes per\\n\"\n                          \"different bands. All bands should have the same types in TIFF.\" );\n            }\n        }\n    }\n\n    if( !pfnProgress( 0.0, NULL, pProgressData ) )\n        return NULL;\n\n/* -------------------------------------------------------------------- */\n/*      Capture the profile.                                            */\n/* -------------------------------------------------------------------- */\n    const char          *pszProfile;\n    int                 bGeoTIFF;\n\n    pszProfile = CSLFetchNameValue(papszOptions,\"PROFILE\");\n    if( pszProfile == NULL )\n        pszProfile = \"GDALGeoTIFF\";\n\n    if( !EQUAL(pszProfile,\"BASELINE\") \n        && !EQUAL(pszProfile,\"GeoTIFF\") \n        && !EQUAL(pszProfile,\"GDALGeoTIFF\") )\n    {\n        CPLError( CE_Failure, CPLE_AppDefined, \n                  \"PROFILE=%s not supported in GTIFF driver.\", \n                  pszProfile );\n        return NULL;\n    }\n    \n    if( EQUAL(pszProfile,\"BASELINE\") )\n        bGeoTIFF = FALSE;\n    else\n        bGeoTIFF = TRUE;\n\n/* -------------------------------------------------------------------- */\n/*      Special handling for NBITS.  Copy from band metadata if found.  */\n/* -------------------------------------------------------------------- */\n    char     **papszCreateOptions = CSLDuplicate( papszOptions );\n\n    if( poPBand->GetMetadataItem( \"NBITS\", \"IMAGE_STRUCTURE\" ) != NULL \n        && atoi(poPBand->GetMetadataItem( \"NBITS\", \"IMAGE_STRUCTURE\" )) > 0\n        && CSLFetchNameValue( papszCreateOptions, \"NBITS\") == NULL )\n    {\n        papszCreateOptions = \n            CSLSetNameValue( papszCreateOptions, \"NBITS\",\n                             poPBand->GetMetadataItem( \"NBITS\", \n                                                       \"IMAGE_STRUCTURE\" ) );\n    }\n\n    if( CSLFetchNameValue( papszOptions, \"PIXELTYPE\" ) == NULL\n        && eType == GDT_Byte\n        && poPBand->GetMetadataItem( \"PIXELTYPE\", \"IMAGE_STRUCTURE\" ) )\n    {\n        papszCreateOptions = \n            CSLSetNameValue( papszCreateOptions, \"PIXELTYPE\", \n                             poPBand->GetMetadataItem( \n                                 \"PIXELTYPE\", \"IMAGE_STRUCTURE\" ) );\n    }\n    \n    int nSrcOverviews = poSrcDS->GetRasterBand(1)->GetOverviewCount();\n    double dfExtraSpaceForOverviews = 0;\n    if (nSrcOverviews != 0 &&\n        CSLFetchBoolean(papszOptions, \"COPY_SRC_OVERVIEWS\", FALSE))\n    {\n        int i;\n        for(i=0;i<nSrcOverviews;i++)\n        {\n            dfExtraSpaceForOverviews += ((double)poSrcDS->GetRasterBand(1)->GetOverview(i)->GetXSize()) *\n                                        poSrcDS->GetRasterBand(1)->GetOverview(i)->GetYSize();\n        }\n        dfExtraSpaceForOverviews *= nBands * (GDALGetDataTypeSize(eType) / 8);\n    }\n    \n/* -------------------------------------------------------------------- */\n/*      Create the file.                                                */\n/* -------------------------------------------------------------------- */\n    hTIFF = CreateLL( pszFilename, nXSize, nYSize, nBands, \n                      eType, dfExtraSpaceForOverviews, papszCreateOptions );\n\n    CSLDestroy( papszCreateOptions );\n\n    if( hTIFF == NULL )\n        return NULL;\n\n    TIFFGetField( hTIFF, TIFFTAG_PLANARCONFIG, &nPlanarConfig );\n    TIFFGetField(hTIFF, TIFFTAG_BITSPERSAMPLE, &nBitsPerSample );\n\n/* -------------------------------------------------------------------- */\n/*      Are we really producing an RGBA image?  If so, set the          */\n/*      associated alpha information.                                   */\n/* -------------------------------------------------------------------- */\n    int bForcePhotometric = \n        CSLFetchNameValue(papszOptions,\"PHOTOMETRIC\") != NULL;\n\n    if( nBands == 4 && !bForcePhotometric\n        && poSrcDS->GetRasterBand(4)->GetColorInterpretation()==GCI_AlphaBand)\n    {\n        uint16 v[1];\n\n        v[0] = EXTRASAMPLE_ASSOCALPHA;\n\tTIFFSetField(hTIFF, TIFFTAG_EXTRASAMPLES, 1, v);\n        TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If the output is jpeg compressed, and the input is RGB make     */\n/*      sure we note that.                                              */\n/* -------------------------------------------------------------------- */\n    uint16      nCompression;\n\n    if( !TIFFGetField( hTIFF, TIFFTAG_COMPRESSION, &(nCompression) ) )\n        nCompression = COMPRESSION_NONE;\n\n    if( nCompression == COMPRESSION_JPEG )\n    {\n        if( nBands >= 3 \n            && (poSrcDS->GetRasterBand(1)->GetColorInterpretation() \n                == GCI_YCbCr_YBand)\n            && (poSrcDS->GetRasterBand(2)->GetColorInterpretation() \n                == GCI_YCbCr_CbBand)\n            && (poSrcDS->GetRasterBand(3)->GetColorInterpretation() \n                == GCI_YCbCr_CrBand) )\n        {\n            /* do nothing ... */\n        }\n        else\n        {\n            /* we assume RGB if it isn't explicitly YCbCr */\n            CPLDebug( \"GTiff\", \"Setting JPEGCOLORMODE_RGB\" );\n            TIFFSetField( hTIFF, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB );\n        }\n    }\n        \n/* -------------------------------------------------------------------- */\n/*      Does the source image consist of one band, with a palette?      */\n/*      If so, copy over.                                               */\n/* -------------------------------------------------------------------- */\n    if( (nBands == 1 || nBands == 2) && poSrcDS->GetRasterBand(1)->GetColorTable() != NULL \n        && eType == GDT_Byte )\n    {\n        unsigned short\tanTRed[256], anTGreen[256], anTBlue[256];\n        GDALColorTable *poCT;\n\n        poCT = poSrcDS->GetRasterBand(1)->GetColorTable();\n        \n        for( int iColor = 0; iColor < 256; iColor++ )\n        {\n            if( iColor < poCT->GetColorEntryCount() )\n            {\n                GDALColorEntry  sRGB;\n\n                poCT->GetColorEntryAsRGB( iColor, &sRGB );\n\n                anTRed[iColor] = (unsigned short) (257 * sRGB.c1);\n                anTGreen[iColor] = (unsigned short) (257 * sRGB.c2);\n                anTBlue[iColor] = (unsigned short) (257 * sRGB.c3);\n            }\n            else\n            {\n                anTRed[iColor] = anTGreen[iColor] = anTBlue[iColor] = 0;\n            }\n        }\n\n        if( !bForcePhotometric )\n            TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_PALETTE );\n        TIFFSetField( hTIFF, TIFFTAG_COLORMAP, anTRed, anTGreen, anTBlue );\n    }\n    else if( (nBands == 1 || nBands == 2) \n             && poSrcDS->GetRasterBand(1)->GetColorTable() != NULL \n             && eType == GDT_UInt16 )\n    {\n        unsigned short\t*panTRed, *panTGreen, *panTBlue;\n        GDALColorTable *poCT;\n\n        panTRed   = (unsigned short *) CPLMalloc(65536*sizeof(unsigned short));\n        panTGreen = (unsigned short *) CPLMalloc(65536*sizeof(unsigned short));\n        panTBlue  = (unsigned short *) CPLMalloc(65536*sizeof(unsigned short));\n\n        poCT = poSrcDS->GetRasterBand(1)->GetColorTable();\n        \n        for( int iColor = 0; iColor < 65536; iColor++ )\n        {\n            if( iColor < poCT->GetColorEntryCount() )\n            {\n                GDALColorEntry  sRGB;\n\n                poCT->GetColorEntryAsRGB( iColor, &sRGB );\n\n                panTRed[iColor] = (unsigned short) (256 * sRGB.c1);\n                panTGreen[iColor] = (unsigned short) (256 * sRGB.c2);\n                panTBlue[iColor] = (unsigned short) (256 * sRGB.c3);\n            }\n            else\n            {\n                panTRed[iColor] = panTGreen[iColor] = panTBlue[iColor] = 0;\n            }\n        }\n\n        if( !bForcePhotometric )\n            TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_PALETTE );\n        TIFFSetField( hTIFF, TIFFTAG_COLORMAP, panTRed, panTGreen, panTBlue );\n\n        CPLFree( panTRed );\n        CPLFree( panTGreen );\n        CPLFree( panTBlue );\n    }\n    else if( poSrcDS->GetRasterBand(1)->GetColorTable() != NULL )\n        CPLError( CE_Warning, CPLE_AppDefined,\n                  \"Unable to export color table to GeoTIFF file.  Color tables\\n\"\n                  \"can only be written to 1 band or 2 bands Byte or UInt16 GeoTIFF files.\" );\n\n    if( nBands == 2\n        && poSrcDS->GetRasterBand(1)->GetColorTable() != NULL \n        && (eType == GDT_Byte || eType == GDT_UInt16) )\n    {\n        uint16 v[1] = { EXTRASAMPLE_UNASSALPHA };\n\n        TIFFSetField(hTIFF, TIFFTAG_EXTRASAMPLES, 1, v );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Transfer some TIFF specific metadata, if available.             */\n/*      The return value will tell us if we need to try again later with*/\n/*      PAM because the profile doesn't allow to write some metadata    */\n/*      as TIFF tag                                                     */\n/* -------------------------------------------------------------------- */\n    int bHasWrittenMDInGeotiffTAG =\n            GTiffDataset::WriteMetadata( poSrcDS, hTIFF, FALSE, pszProfile,\n                                 pszFilename, papszOptions );\n\n/* -------------------------------------------------------------------- */\n/* \tWrite NoData value, if exist.                                   */\n/* -------------------------------------------------------------------- */\n    if( EQUAL(pszProfile,\"GDALGeoTIFF\") )\n    {\n        int\t\tbSuccess;\n        double\tdfNoData;\n    \n        dfNoData = poSrcDS->GetRasterBand(1)->GetNoDataValue( &bSuccess );\n        if ( bSuccess )\n            GTiffDataset::WriteNoDataValue( hTIFF, dfNoData );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Are we addressing PixelIsPoint mode?                            */\n/* -------------------------------------------------------------------- */\n    bool bPixelIsPoint = false;\n    int  bPointGeoIgnore = FALSE;\n\n    if( poSrcDS->GetMetadataItem( GDALMD_AREA_OR_POINT ) \n        && EQUAL(poSrcDS->GetMetadataItem(GDALMD_AREA_OR_POINT),\n                 GDALMD_AOP_POINT) )\n    {\n        bPixelIsPoint = true;\n        bPointGeoIgnore = \n            CSLTestBoolean( CPLGetConfigOption(\"GTIFF_POINT_GEO_IGNORE\",\n                                               \"FALSE\") );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Write affine transform if it is meaningful.                     */\n/* -------------------------------------------------------------------- */\n    const char *pszProjection = NULL;\n    double      adfGeoTransform[6];\n    \n    if( poSrcDS->GetGeoTransform( adfGeoTransform ) == CE_None\n        && (adfGeoTransform[0] != 0.0 || adfGeoTransform[1] != 1.0\n            || adfGeoTransform[2] != 0.0 || adfGeoTransform[3] != 0.0\n            || adfGeoTransform[4] != 0.0 || adfGeoTransform[5] != 1.0 ))\n    {\n        if( bGeoTIFF )\n        {\n            if( adfGeoTransform[2] == 0.0 && adfGeoTransform[4] == 0.0 \n                && adfGeoTransform[5] < 0.0 )\n            {\n\n                double\tadfPixelScale[3], adfTiePoints[6];\n\n                adfPixelScale[0] = adfGeoTransform[1];\n                adfPixelScale[1] = fabs(adfGeoTransform[5]);\n                adfPixelScale[2] = 0.0;\n\n                TIFFSetField( hTIFF, TIFFTAG_GEOPIXELSCALE, 3, adfPixelScale );\n            \n                adfTiePoints[0] = 0.0;\n                adfTiePoints[1] = 0.0;\n                adfTiePoints[2] = 0.0;\n                adfTiePoints[3] = adfGeoTransform[0];\n                adfTiePoints[4] = adfGeoTransform[3];\n                adfTiePoints[5] = 0.0;\n                \n                if( bPixelIsPoint && !bPointGeoIgnore )\n                {\n                    adfTiePoints[3] += adfGeoTransform[1] * 0.5 + adfGeoTransform[2] * 0.5;\n                    adfTiePoints[4] += adfGeoTransform[4] * 0.5 + adfGeoTransform[5] * 0.5;\n                }\n\t    \n                TIFFSetField( hTIFF, TIFFTAG_GEOTIEPOINTS, 6, adfTiePoints );\n            }\n            else\n            {\n                double\tadfMatrix[16];\n\n                memset(adfMatrix,0,sizeof(double) * 16);\n\n                adfMatrix[0] = adfGeoTransform[1];\n                adfMatrix[1] = adfGeoTransform[2];\n                adfMatrix[3] = adfGeoTransform[0];\n                adfMatrix[4] = adfGeoTransform[4];\n                adfMatrix[5] = adfGeoTransform[5];\n                adfMatrix[7] = adfGeoTransform[3];\n                adfMatrix[15] = 1.0;\n                \n                if( bPixelIsPoint && !bPointGeoIgnore )\n                {\n                    adfMatrix[3] += adfGeoTransform[1] * 0.5 + adfGeoTransform[2] * 0.5;\n                    adfMatrix[7] += adfGeoTransform[4] * 0.5 + adfGeoTransform[5] * 0.5;\n                }\n\n                TIFFSetField( hTIFF, TIFFTAG_GEOTRANSMATRIX, 16, adfMatrix );\n            }\n            \n            pszProjection = poSrcDS->GetProjectionRef();\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Do we need a TFW file?                                          */\n/* -------------------------------------------------------------------- */\n        if( CSLFetchBoolean( papszOptions, \"TFW\", FALSE ) )\n            GDALWriteWorldFile( pszFilename, \"tfw\", adfGeoTransform );\n        else if( CSLFetchBoolean( papszOptions, \"WORLDFILE\", FALSE ) )\n            GDALWriteWorldFile( pszFilename, \"wld\", adfGeoTransform );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Otherwise write tiepoints if they are available.                */\n/* -------------------------------------------------------------------- */\n    else if( poSrcDS->GetGCPCount() > 0 && bGeoTIFF )\n    {\n        const GDAL_GCP *pasGCPs = poSrcDS->GetGCPs();\n        double\t*padfTiePoints;\n\n        padfTiePoints = (double *) \n            CPLMalloc(6*sizeof(double)*poSrcDS->GetGCPCount());\n\n        for( int iGCP = 0; iGCP < poSrcDS->GetGCPCount(); iGCP++ )\n        {\n\n            padfTiePoints[iGCP*6+0] = pasGCPs[iGCP].dfGCPPixel;\n            padfTiePoints[iGCP*6+1] = pasGCPs[iGCP].dfGCPLine;\n            padfTiePoints[iGCP*6+2] = 0;\n            padfTiePoints[iGCP*6+3] = pasGCPs[iGCP].dfGCPX;\n            padfTiePoints[iGCP*6+4] = pasGCPs[iGCP].dfGCPY;\n            padfTiePoints[iGCP*6+5] = pasGCPs[iGCP].dfGCPZ;\n\n            if( bPixelIsPoint && !bPointGeoIgnore )\n            {\n                padfTiePoints[iGCP*6+0] += 0.5;\n                padfTiePoints[iGCP*6+1] += 0.5;\n            }\n        }\n\n        TIFFSetField( hTIFF, TIFFTAG_GEOTIEPOINTS, \n                      6*poSrcDS->GetGCPCount(), padfTiePoints );\n        CPLFree( padfTiePoints );\n        \n        pszProjection = poSrcDS->GetGCPProjection();\n        \n        if( CSLFetchBoolean( papszOptions, \"TFW\", FALSE ) \n            || CSLFetchBoolean( papszOptions, \"WORLDFILE\", FALSE ) )\n        {\n            CPLError(CE_Warning, CPLE_AppDefined,\n                     \"TFW=ON or WORLDFILE=ON creation options are ignored when GCPs are available\");\n        }\n    }\n\n    else\n        pszProjection = poSrcDS->GetProjectionRef();\n\n/* -------------------------------------------------------------------- */\n/*      Write the projection information, if possible.                  */\n/* -------------------------------------------------------------------- */\n    if( pszProjection != NULL && strlen(pszProjection) > 0 && bGeoTIFF )\n    {\n        GTIF\t*psGTIF;\n\n        psGTIF = GTIFNew( hTIFF );\n        GTIFSetFromOGISDefn( psGTIF, pszProjection );\n\n        if( poSrcDS->GetMetadataItem( GDALMD_AREA_OR_POINT ) \n            && EQUAL(poSrcDS->GetMetadataItem(GDALMD_AREA_OR_POINT),\n                     GDALMD_AOP_POINT) )\n        {\n            GTIFKeySet(psGTIF, GTRasterTypeGeoKey, TYPE_SHORT, 1,\n                       RasterPixelIsPoint);\n        }\n\n        GTIFWriteKeys( psGTIF );\n        GTIFFree( psGTIF );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If we are writing jpeg compression we need to write some        */\n/*      imagery to force the jpegtables to get created.  This is,       */\n/*      likely only needed with libtiff >= 3.9.3 (#3633)                */\n/* -------------------------------------------------------------------- */\n    int bDontReloadFirstBlock = FALSE;\n    if( nCompression == COMPRESSION_JPEG\n        && strstr(TIFFLIB_VERSION_STR, \"Version 3.9\") != NULL )\n    {\n        CPLDebug( \"GDAL\", \n                  \"Writing zero block to force creation of JPEG tables.\" );\n        if( TIFFIsTiled( hTIFF ) )\n        {\n            int cc = TIFFTileSize( hTIFF );\n            unsigned char *pabyZeros = (unsigned char *) CPLCalloc(cc,1);\n            TIFFWriteEncodedTile(hTIFF, 0, pabyZeros, cc);\n            CPLFree( pabyZeros );\n        }\n        else\n        {\n            int cc = TIFFStripSize( hTIFF );\n            unsigned char *pabyZeros = (unsigned char *) CPLCalloc(cc,1);\n            TIFFWriteEncodedStrip(hTIFF, 0, pabyZeros, cc);\n            CPLFree( pabyZeros );\n        }\n        bDontReloadFirstBlock = TRUE;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Cleanup                                                         */\n/* -------------------------------------------------------------------- */\n    \n    TIFFWriteCheck( hTIFF, TIFFIsTiled(hTIFF), \"GTiffCreateCopy()\");\n    TIFFWriteDirectory( hTIFF );\n    TIFFFlush( hTIFF );\n    XTIFFClose( hTIFF );\n    hTIFF = NULL;\n\n    if( eErr != CE_None )\n    {\n        VSIUnlink( pszFilename );\n        return NULL;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Re-open as a dataset and copy over missing metadata using       */\n/*      PAM facilities.                                                 */\n/* -------------------------------------------------------------------- */\n    GTiffDataset *poDS;\n    CPLString osFileName(\"GTIFF_RAW:\");\n\n    osFileName += pszFilename;\n\n    poDS = (GTiffDataset *) GDALOpen( osFileName, GA_Update );\n    if( poDS == NULL )\n        poDS = (GTiffDataset *) GDALOpen( osFileName, GA_ReadOnly );\n\n    if ( poDS == NULL )\n    {\n        VSIUnlink( pszFilename );\n        return NULL;\n    }\n\n    poDS->osProfile = pszProfile;\n    poDS->CloneInfo( poSrcDS, GCIF_PAM_DEFAULT & ~GCIF_MASK );\n    poDS->papszCreationOptions = CSLDuplicate( papszOptions );\n    poDS->bDontReloadFirstBlock = bDontReloadFirstBlock;\n\n/* -------------------------------------------------------------------- */\n/*      CloneInfo() doesn't merge metadata, it just replaces it totally */\n/*      So we have to merge it                                          */\n/* -------------------------------------------------------------------- */\n\n    char **papszSRC_MD = poSrcDS->GetMetadata();\n    char **papszDST_MD = CSLDuplicate(poDS->GetMetadata());\n\n    papszDST_MD = CSLMerge( papszDST_MD, papszSRC_MD );\n\n    poDS->SetMetadata( papszDST_MD );\n    CSLDestroy( papszDST_MD );\n\n    /* Depending on the PHOTOMETRIC tag, the TIFF file may not have */\n    /* the same band count as the source. Will fail later in GDALDatasetCopyWholeRaster anyway... */\n    for( int nBand = 1;\n         nBand <= MIN(poDS->GetRasterCount(), poSrcDS->GetRasterCount()) ;\n         nBand++ )\n    {\n        char **papszSRC_MD = poSrcDS->GetRasterBand(nBand)->GetMetadata();\n        char **papszDST_MD = CSLDuplicate(poDS->GetRasterBand(nBand)->GetMetadata());\n\n        papszDST_MD = CSLMerge( papszDST_MD, papszSRC_MD );\n\n        poDS->GetRasterBand(nBand)->SetMetadata( papszDST_MD );\n        CSLDestroy( papszDST_MD );\n    }\n\n    hTIFF = (TIFF*) poDS->GetInternalHandle(NULL);\n\n/* -------------------------------------------------------------------- */\n/*      Handle forcing xml:ESRI data to be written to PAM.              */\n/* -------------------------------------------------------------------- */\n    if( CSLTestBoolean(CPLGetConfigOption( \"ESRI_XML_PAM\", \"NO\" )) )\n    {\n        char **papszESRIMD = poSrcDS->GetMetadata(\"xml:ESRI\");\n        if( papszESRIMD )\n        {\n            poDS->SetMetadata( papszESRIMD, \"xml:ESRI\");\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Second chance : now that we have a PAM dataset, it is possible  */\n/*      to write metadata that we couldn't be writen as TIFF tag        */\n/* -------------------------------------------------------------------- */\n    if (!bHasWrittenMDInGeotiffTAG)\n        GTiffDataset::WriteMetadata( poDS, hTIFF, TRUE, pszProfile,\n                                     pszFilename, papszOptions, TRUE /* don't write RPC and IMD file again */);\n\n    /* To avoid unnecessary directory rewriting */\n    poDS->bMetadataChanged = FALSE;\n    poDS->bGeoTIFFInfoChanged = FALSE;\n\n    /* We must re-set the compression level at this point, since it has */\n    /* been lost a few lines above when closing the newly create TIFF file */\n    /* The TIFFTAG_ZIPQUALITY & TIFFTAG_JPEGQUALITY are not store in the TIFF file. */\n    /* They are just TIFF session parameters */\n\n    poDS->nZLevel = GTiffGetZLevel(papszOptions);\n    poDS->nLZMAPreset = GTiffGetLZMAPreset(papszOptions);\n    poDS->nJpegQuality = GTiffGetJpegQuality(papszOptions);\n\n    if (nCompression == COMPRESSION_ADOBE_DEFLATE)\n    {\n        if (poDS->nZLevel != -1)\n        {\n            TIFFSetField( hTIFF, TIFFTAG_ZIPQUALITY, poDS->nZLevel );\n        }\n    }\n    else if( nCompression == COMPRESSION_JPEG)\n    {\n        if (poDS->nJpegQuality != -1)\n        {\n            TIFFSetField( hTIFF, TIFFTAG_JPEGQUALITY, poDS->nJpegQuality );\n        }\n    }\n    else if( nCompression == COMPRESSION_LZMA)\n    {\n        if (poDS->nLZMAPreset != -1)\n        {\n            TIFFSetField( hTIFF, TIFFTAG_LZMAPRESET, poDS->nLZMAPreset );\n        }\n    }\n\n    /* Precreate (internal) mask, so that the IBuildOverviews() below */\n    /* has a chance to create also the overviews of the mask */\n    int nMaskFlags = poSrcDS->GetRasterBand(1)->GetMaskFlags();\n    if( eErr == CE_None\n        && !(nMaskFlags & (GMF_ALL_VALID|GMF_ALPHA|GMF_NODATA) )\n        && (nMaskFlags & GMF_PER_DATASET) )\n    {\n        eErr = poDS->CreateMaskBand( nMaskFlags );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Create and then copy existing overviews if requested            */\n/*  We do it such that all the IFDs are at the beginning of the file,   */\n/*  and that the imagery data for the smallest overview is written      */\n/*  first, that way the file is more usable when embedded in a          */\n/*  compressed stream.                                                  */\n/* -------------------------------------------------------------------- */\n\n    /* For scaled progress due to overview copying */\n    double dfTotalPixels = ((double)nXSize) * nYSize;\n    double dfCurPixels = 0;\n\n    if (eErr == CE_None &&\n        nSrcOverviews != 0 &&\n        CSLFetchBoolean(papszOptions, \"COPY_SRC_OVERVIEWS\", FALSE))\n    {\n        eErr = poDS->CreateOverviewsFromSrcOverviews(poSrcDS);\n\n        if (poDS->nOverviewCount != nSrcOverviews)\n        {\n            CPLError(CE_Failure, CPLE_AppDefined,\n                     \"Did only manage to instanciate %d overview levels, whereas source contains %d\",\n                     poDS->nOverviewCount, nSrcOverviews);\n            eErr = CE_Failure;\n        }\n\n        int i;\n        for(i=0;i<nSrcOverviews;i++)\n        {\n            GDALRasterBand* poOvrBand = poSrcDS->GetRasterBand(1)->GetOverview(i);\n            dfTotalPixels += ((double)poOvrBand->GetXSize()) *\n                                      poOvrBand->GetYSize();\n        }\n\n        char* papszCopyWholeRasterOptions[2] = { NULL, NULL };\n        if (nCompression != COMPRESSION_NONE)\n            papszCopyWholeRasterOptions[0] = (char*) \"COMPRESSED=YES\";\n        /* Now copy the imagery */\n        for(i=0;eErr == CE_None && i<nSrcOverviews;i++)\n        {\n            /* Begin with the smallest overview */\n            int iOvrLevel = nSrcOverviews-1-i;\n            \n            /* Create a fake dataset with the source overview level so that */\n            /* GDALDatasetCopyWholeRaster can cope with it */\n            GDALDataset* poSrcOvrDS = new GDALOverviewDS(poSrcDS, iOvrLevel);\n            \n            GDALRasterBand* poOvrBand =\n                    poSrcDS->GetRasterBand(1)->GetOverview(iOvrLevel);\n            double dfNextCurPixels = dfCurPixels +\n                    ((double)poOvrBand->GetXSize()) * poOvrBand->GetYSize();\n\n            void* pScaledData = GDALCreateScaledProgress( dfCurPixels / dfTotalPixels,\n                                      dfNextCurPixels / dfTotalPixels,\n                                      pfnProgress, pProgressData);\n                                \n            eErr = GDALDatasetCopyWholeRaster( (GDALDatasetH) poSrcOvrDS,\n                                                (GDALDatasetH) poDS->papoOverviewDS[iOvrLevel],\n                                                papszCopyWholeRasterOptions,\n                                                GDALScaledProgress, pScaledData );\n                                                \n            dfCurPixels = dfNextCurPixels;\n            GDALDestroyScaledProgress(pScaledData);\n\n            delete poSrcOvrDS;\n            poDS->papoOverviewDS[iOvrLevel]->FlushCache();\n\n            /* Copy mask of the overview */\n            if (eErr == CE_None && poDS->poMaskDS != NULL)\n            {\n                eErr = GDALRasterBandCopyWholeRaster( poOvrBand->GetMaskBand(),\n                                                    poDS->papoOverviewDS[iOvrLevel]->poMaskDS->GetRasterBand(1),\n                                                    papszCopyWholeRasterOptions,\n                                                    GDALDummyProgress, NULL);\n                poDS->papoOverviewDS[iOvrLevel]->poMaskDS->FlushCache();\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Copy actual imagery.                                            */\n/* -------------------------------------------------------------------- */\n    void* pScaledData = GDALCreateScaledProgress( dfCurPixels / dfTotalPixels,\n                                                  1.0,\n                                                  pfnProgress, pProgressData);\n\n    if (poDS->bTreatAsSplit || poDS->bTreatAsSplitBitmap)\n    {\n        /* For split bands, we use TIFFWriteScanline() interface */\n        CPLAssert(poDS->nBitsPerSample == 8 || poDS->nBitsPerSample == 1);\n        \n        if (poDS->nPlanarConfig == PLANARCONFIG_CONTIG && poDS->nBands > 1)\n        {\n            int j;\n            GByte* pabyScanline = (GByte *) CPLMalloc(TIFFScanlineSize(hTIFF));\n            for(j=0;j<nYSize && eErr == CE_None;j++)\n            {\n                eErr = poSrcDS->RasterIO(GF_Read, 0, j, nXSize, 1,\n                                         pabyScanline, nXSize, 1,\n                                         GDT_Byte, nBands, NULL, poDS->nBands, 0, 1);\n                if (eErr == CE_None &&\n                    TIFFWriteScanline( hTIFF, pabyScanline, j, 0) == -1)\n                {\n                    CPLError( CE_Failure, CPLE_AppDefined,\n                              \"TIFFWriteScanline() failed.\" );\n                    eErr = CE_Failure;\n                }\n                if( !GDALScaledProgress( (j+1) * 1.0 / nYSize, NULL, pScaledData ) )\n                    eErr = CE_Failure;\n            }\n            CPLFree(pabyScanline);\n        }\n        else\n        {\n            int iBand, j;\n            GByte* pabyScanline = (GByte *) CPLMalloc(TIFFScanlineSize(hTIFF));\n            eErr = CE_None;\n            for(iBand=1;iBand<=nBands && eErr == CE_None;iBand++)\n            {\n                for(j=0;j<nYSize && eErr == CE_None;j++)\n                {\n                    eErr = poSrcDS->GetRasterBand(iBand)->RasterIO(\n                                                    GF_Read, 0, j, nXSize, 1,\n                                                    pabyScanline, nXSize, 1,\n                                                    GDT_Byte, 0, 0);\n                    if (poDS->bTreatAsSplitBitmap)\n                    {\n                        for(int i=0;i<nXSize;i++)\n                        {\n                            GByte byVal = pabyScanline[i];\n                            if ((i & 0x7) == 0)\n                                pabyScanline[i >> 3] = 0;\n                            if (byVal)\n                                pabyScanline[i >> 3] |= (0x80 >> (i & 0x7));\n                        }\n                    }\n                    if (eErr == CE_None &&\n                        TIFFWriteScanline( hTIFF, pabyScanline, j, (uint16) (iBand-1)) == -1)\n                    {\n                        CPLError( CE_Failure, CPLE_AppDefined,\n                                  \"TIFFWriteScanline() failed.\" );\n                        eErr = CE_Failure;\n                    }\n                    if( !GDALScaledProgress( (j+1 + (iBand - 1) * nYSize) * 1.0 /\n                                      (nBands * nYSize), NULL, pScaledData ) )\n                        eErr = CE_Failure;\n                }\n            }\n            CPLFree(pabyScanline);\n        }\n        \n        /* Necessary to be able to read the file without re-opening */\n#if defined(HAVE_TIFFGETSIZEPROC)\n        TIFFSizeProc pfnSizeProc = TIFFGetSizeProc( hTIFF );\n\n        TIFFFlushData( hTIFF );\n\n        toff_t nNewDirOffset = pfnSizeProc( TIFFClientdata( hTIFF ) );\n        if( (nNewDirOffset % 2) == 1 )\n            nNewDirOffset++;\n#endif\n\n        TIFFFlush( hTIFF );\n\n#if defined(HAVE_TIFFGETSIZEPROC)\n        if( poDS->nDirOffset != TIFFCurrentDirOffset( hTIFF ) )\n        {\n            poDS->nDirOffset = nNewDirOffset;\n            CPLDebug( \"GTiff\", \"directory moved during flush.\" );\n        }\n#endif\n    }\n    else if (eErr == CE_None)\n    {\n        char* papszCopyWholeRasterOptions[2] = { NULL, NULL };\n        if (nCompression != COMPRESSION_NONE)\n            papszCopyWholeRasterOptions[0] = (char*) \"COMPRESSED=YES\";\n        eErr = GDALDatasetCopyWholeRaster( (GDALDatasetH) poSrcDS, \n                                            (GDALDatasetH) poDS,\n                                            papszCopyWholeRasterOptions,\n                                            GDALScaledProgress, pScaledData );\n    }\n    \n    GDALDestroyScaledProgress(pScaledData);\n\n    if (eErr == CE_None)\n    {\n        if (poDS->poMaskDS)\n        {\n            const char* papszOptions[2] = { \"COMPRESSED=YES\", NULL };\n            eErr = GDALRasterBandCopyWholeRaster(\n                                    poSrcDS->GetRasterBand(1)->GetMaskBand(),\n                                    poDS->GetRasterBand(1)->GetMaskBand(),\n                                    (char**)papszOptions,\n                                    GDALDummyProgress, NULL);\n        }\n        else\n            eErr = GDALDriver::DefaultCopyMasks( poSrcDS, poDS, bStrict );\n    }\n\n    if( eErr == CE_Failure )\n    {\n        delete poDS;\n        poDS = NULL;\n\n        if (CSLTestBoolean(CPLGetConfigOption(\"GTIFF_DELETE_ON_ERROR\", \"YES\")))\n            VSIUnlink( pszFilename ); // should really delete more carefully.\n    }\n\n    return poDS;\n}\n\n/************************************************************************/\n/*                          GetProjectionRef()                          */\n/************************************************************************/\n\nconst char *GTiffDataset::GetProjectionRef()\n\n{\n    if( nGCPCount == 0 )\n    {\n        LookForProjection();\n\n        if( EQUAL(pszProjection,\"\") )\n            return GDALPamDataset::GetProjectionRef();\n        else\n            return( pszProjection );\n    }\n    else\n        return \"\";\n}\n\n/************************************************************************/\n/*                           SetProjection()                            */\n/************************************************************************/\n\nCPLErr GTiffDataset::SetProjection( const char * pszNewProjection )\n\n{\n    LookForProjection();\n\n    if( !EQUALN(pszNewProjection,\"GEOGCS\",6)\n        && !EQUALN(pszNewProjection,\"PROJCS\",6)\n        && !EQUALN(pszNewProjection,\"LOCAL_CS\",8)\n        && !EQUALN(pszNewProjection,\"COMPD_CS\",8)\n        && !EQUALN(pszNewProjection,\"GEOCCS\",6)\n        && !EQUAL(pszNewProjection,\"\") )\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                \"Only OGC WKT Projections supported for writing to GeoTIFF.\\n\"\n                \"%s not supported.\",\n                  pszNewProjection );\n        \n        return CE_Failure;\n    }\n    \n    CPLFree( pszProjection );\n    pszProjection = CPLStrdup( pszNewProjection );\n\n    bGeoTIFFInfoChanged = TRUE;\n\n    return CE_None;\n}\n\n/************************************************************************/\n/*                          GetGeoTransform()                           */\n/************************************************************************/\n\nCPLErr GTiffDataset::GetGeoTransform( double * padfTransform )\n\n{\n    memcpy( padfTransform, adfGeoTransform, sizeof(double)*6 );\n    \n    if( !bGeoTransformValid )\n        return CE_Failure;\n    else\n        return CE_None;\n}\n\n/************************************************************************/\n/*                          SetGeoTransform()                           */\n/************************************************************************/\n\nCPLErr GTiffDataset::SetGeoTransform( double * padfTransform )\n\n{\n    if( GetAccess() == GA_Update )\n    {\n        memcpy( adfGeoTransform, padfTransform, sizeof(double)*6 );\n        bGeoTransformValid = TRUE;\n        bGeoTIFFInfoChanged = TRUE;\n\n        return( CE_None );\n    }\n    else\n    {\n        CPLError( CE_Failure, CPLE_NotSupported,\n                  \"Attempt to call SetGeoTransform() on a read-only GeoTIFF file.\" );\n        return CE_Failure;\n    }\n}\n\n/************************************************************************/\n/*                            GetGCPCount()                             */\n/************************************************************************/\n\nint GTiffDataset::GetGCPCount()\n\n{\n    return nGCPCount;\n}\n\n/************************************************************************/\n/*                          GetGCPProjection()                          */\n/************************************************************************/\n\nconst char *GTiffDataset::GetGCPProjection()\n\n{\n    if( nGCPCount > 0 )\n    {\n        LookForProjection();\n    }\n    if (pszProjection != NULL)\n        return pszProjection;\n    else\n        return \"\";\n}\n\n/************************************************************************/\n/*                               GetGCPs()                              */\n/************************************************************************/\n\nconst GDAL_GCP *GTiffDataset::GetGCPs()\n\n{\n    return pasGCPList;\n}\n\n/************************************************************************/\n/*                               SetGCPs()                              */\n/************************************************************************/\n\nCPLErr GTiffDataset::SetGCPs( int nGCPCount, const GDAL_GCP *pasGCPList,\n                              const char *pszGCPProjection )\n{\n    if( GetAccess() == GA_Update )\n    {\n        bLookedForProjection = TRUE;\n\n        if( this->nGCPCount > 0 )\n        {\n            GDALDeinitGCPs( this->nGCPCount, this->pasGCPList );\n            CPLFree( this->pasGCPList );\n        }\n\n\tthis->nGCPCount = nGCPCount;\n\tthis->pasGCPList = GDALDuplicateGCPs(nGCPCount, pasGCPList);\n\n        CPLFree( this->pszProjection );\n\tthis->pszProjection = CPLStrdup( pszGCPProjection );\n        bGeoTIFFInfoChanged = TRUE;\n\n\treturn CE_None;\n    }\n    else\n    {\n        CPLError( CE_Failure, CPLE_NotSupported,\n            \"SetGCPs() is only supported on newly created GeoTIFF files.\" );\n        return CE_Failure;\n    }\n}\n\n/************************************************************************/\n/*                            GetMetadata()                             */\n/************************************************************************/\n\nchar **GTiffDataset::GetMetadata( const char * pszDomain )\n\n{\n    if( pszDomain != NULL && EQUAL(pszDomain,\"ProxyOverviewRequest\") )\n        return GDALPamDataset::GetMetadata( pszDomain );\n\n    else if( pszDomain != NULL && EQUAL(pszDomain,\"RPC\") )\n        LoadRPCRPB();\n\n    else if( pszDomain != NULL && EQUAL(pszDomain,\"IMD\") )\n        LoadIMD();\n\n    /* FIXME ? Should we call LookForProjection() to load GDALMD_AREA_OR_POINT ? */\n    /* This can impact performances */\n\n    return oGTiffMDMD.GetMetadata( pszDomain );\n}\n\n/************************************************************************/\n/*                            SetMetadata()                             */\n/************************************************************************/\nCPLErr GTiffDataset::SetMetadata( char ** papszMD, const char *pszDomain )\n\n{\n    if( pszDomain == NULL || !EQUAL(pszDomain,\"_temporary_\") )\n        bMetadataChanged = TRUE;\n\n    if( (pszDomain == NULL || EQUAL(pszDomain, \"\")) &&\n        CSLFetchNameValue(papszMD, GDALMD_AREA_OR_POINT) != NULL )\n    {\n        const char* pszPrevValue = \n                GetMetadataItem(GDALMD_AREA_OR_POINT);\n        const char* pszNewValue = \n                CSLFetchNameValue(papszMD, GDALMD_AREA_OR_POINT);\n        if (pszPrevValue == NULL || pszNewValue == NULL ||\n            !EQUAL(pszPrevValue, pszNewValue))\n        {\n            LookForProjection();\n            bGeoTIFFInfoChanged = TRUE;\n        }\n    }\n\n    return oGTiffMDMD.SetMetadata( papszMD, pszDomain );\n}\n\n/************************************************************************/\n/*                          GetMetadataItem()                           */\n/************************************************************************/\n\nconst char *GTiffDataset::GetMetadataItem( const char * pszName, \n                                           const char * pszDomain )\n\n{\n    if( pszDomain != NULL && EQUAL(pszDomain,\"ProxyOverviewRequest\") )\n        return GDALPamDataset::GetMetadataItem( pszName, pszDomain );\n\n    else if( pszDomain != NULL && EQUAL(pszDomain,\"RPC\") )\n        LoadRPCRPB();\n\n    else if( pszDomain != NULL && EQUAL(pszDomain,\"IMD\") )\n        LoadIMD();\n\n    else if( (pszDomain == NULL || EQUAL(pszDomain, \"\")) &&\n        pszName != NULL && EQUAL(pszName, GDALMD_AREA_OR_POINT) )\n    {\n        LookForProjection();\n    }\n\n    return oGTiffMDMD.GetMetadataItem( pszName, pszDomain );\n}\n\n/************************************************************************/\n/*                          SetMetadataItem()                           */\n/************************************************************************/\n\nCPLErr GTiffDataset::SetMetadataItem( const char *pszName, \n                                      const char *pszValue,\n                                      const char *pszDomain )\n\n{\n    if( pszDomain == NULL || !EQUAL(pszDomain,\"_temporary_\") )\n        bMetadataChanged = TRUE;\n\n    if( (pszDomain == NULL || EQUAL(pszDomain, \"\")) &&\n        pszName != NULL && EQUAL(pszName, GDALMD_AREA_OR_POINT) )\n    {\n        LookForProjection();\n        bGeoTIFFInfoChanged = TRUE;\n    }\n\n    return oGTiffMDMD.SetMetadataItem( pszName, pszValue, pszDomain );\n}\n\n/************************************************************************/\n/*                         GetInternalHandle()                          */\n/************************************************************************/\n\nvoid *GTiffDataset::GetInternalHandle( const char * /* pszHandleName */ )\n\n{\n    return hTIFF;\n}\n\n\n/************************************************************************/\n/*                           FindRPBFile()                             */\n/************************************************************************/\n\nint GTiffDataset::FindRPBFile()\n{\n    CPLString osTarget = CPLResetExtension( osFilename, \"RPB\" );\n\n    char** papszSiblingFiles = oOvManager.GetSiblingFiles();\n    if( papszSiblingFiles == NULL )\n    {\n        VSIStatBufL sStatBuf;\n\n        if( VSIStatExL( osTarget, &sStatBuf, VSI_STAT_EXISTS_FLAG ) != 0 )\n        {\n            osTarget = CPLResetExtension( osFilename, \"rpb\" );\n\n            if( VSIStatExL( osTarget, &sStatBuf, VSI_STAT_EXISTS_FLAG ) != 0 )\n                return FALSE;\n        }\n    }\n    else\n    {\n        int iSibling = CSLFindString( papszSiblingFiles, \n                                      CPLGetFilename(osTarget) );\n        if( iSibling < 0 )\n            return FALSE;\n\n        osTarget.resize(osTarget.size() - strlen(papszSiblingFiles[iSibling]));\n        osTarget += papszSiblingFiles[iSibling];\n    }\n\n    osRPBFile = osTarget;\n    return TRUE;\n}\n\n\n/************************************************************************/\n/*                           FindRPCFile()                             */\n/************************************************************************/\n\nint GTiffDataset::FindRPCFile()\n{\n    CPLString osSrcPath = osFilename;\n    CPLString soPt(\".\");\n    size_t found = osSrcPath.rfind(soPt);\n    if (found == CPLString::npos)\n        return FALSE;\n    osSrcPath.replace (found, osSrcPath.size() - found, \"_rpc.txt\");\n    CPLString osTarget = osSrcPath; \n\n    char** papszSiblingFiles = oOvManager.GetSiblingFiles();\n    if( papszSiblingFiles == NULL )\n    {\n        VSIStatBufL sStatBuf;\n\n        if( VSIStatExL( osTarget, &sStatBuf, VSI_STAT_EXISTS_FLAG ) != 0 )\n        {\n            osSrcPath = osFilename;\n            osSrcPath.replace (found, osSrcPath.size() - found, \"_RPC.TXT\");\n            osTarget = osSrcPath; \n\n            if( VSIStatExL( osTarget, &sStatBuf, VSI_STAT_EXISTS_FLAG ) != 0 )\n            {\n                osSrcPath = osFilename;\n                osSrcPath.replace (found, osSrcPath.size() - found, \"_rpc.TXT\");\n                osTarget = osSrcPath; \n\n                if( VSIStatExL( osTarget, &sStatBuf, VSI_STAT_EXISTS_FLAG ) != 0 )\n                {\n                    return FALSE;\n                }\n            }\n        }\n    }\n    else\n    {\n        int iSibling = CSLFindString( papszSiblingFiles, \n                                    CPLGetFilename(osTarget) );\n        if( iSibling < 0 )\n            return FALSE;\n\n        osTarget.resize(osTarget.size() - strlen(papszSiblingFiles[iSibling]));\n        osTarget += papszSiblingFiles[iSibling];\n    }\n\n    osRPCFile = osTarget;\n    return TRUE;\n}\n\n/************************************************************************/\n/*                           FindIMDFile()                             */\n/************************************************************************/\n\nint GTiffDataset::FindIMDFile()\n{\n    CPLString osTarget = CPLResetExtension( osFilename, \"IMD\" );\n\n    char** papszSiblingFiles = oOvManager.GetSiblingFiles();\n    if( papszSiblingFiles == NULL )\n    {\n        VSIStatBufL sStatBuf;\n\n        if( VSIStatExL( osTarget, &sStatBuf, VSI_STAT_EXISTS_FLAG ) != 0 )\n        {\n            osTarget = CPLResetExtension( osFilename, \"imd\" );\n\n            if( VSIStatExL( osTarget, &sStatBuf, VSI_STAT_EXISTS_FLAG ) != 0 )\n                return FALSE;\n        }\n    }\n    else\n    {\n        int iSibling = CSLFindString( papszSiblingFiles, \n                                      CPLGetFilename(osTarget) );\n        if( iSibling < 0 )\n            return FALSE;\n\n        osTarget.resize(osTarget.size() - strlen(papszSiblingFiles[iSibling]));\n        osTarget += papszSiblingFiles[iSibling];\n    }\n\n    osIMDFile = osTarget;\n    return TRUE;\n}\n\n/************************************************************************/\n/*                            LoadRPCRPB()                              */\n/************************************************************************/\n\nvoid GTiffDataset::LoadRPCRPB()\n{\n    if (bHasSearchedRPC)\n        return;\n\n    bHasSearchedRPC = TRUE;\n\n    char **papszRPCMD = NULL;\n    /* Read Digital Globe .RPB file */\n    if (FindRPBFile())\n        papszRPCMD = GDALLoadRPBFile( osRPBFile.c_str(), NULL );\n\n    /* Read GeoEye _rpc.txt file */\n    if(papszRPCMD == NULL && FindRPCFile())\n        papszRPCMD = GDALLoadRPCFile( osRPCFile.c_str(), NULL );\n\n    if( papszRPCMD != NULL )\n    {\n        oGTiffMDMD.SetMetadata( papszRPCMD, \"RPC\" );\n        CSLDestroy( papszRPCMD );\n    }\n    else\n        ReadRPCTag();\n}\n\n/************************************************************************/\n/*                              LoadIMD()                               */\n/************************************************************************/\n\nvoid GTiffDataset::LoadIMD()\n{\n    if (bHasSearchedIMD)\n        return;\n\n    bHasSearchedIMD = TRUE;\n\n    if (FindIMDFile())\n    {\n        char **papszIMDMD = GDALLoadIMDFile( osIMDFile.c_str(), NULL );\n\n        if( papszIMDMD != NULL )\n        {\n            oGTiffMDMD.SetMetadata( papszIMDMD, \"IMD\" );\n            CSLDestroy( papszIMDMD );\n        }\n    }\n}\n\n/************************************************************************/\n/*                            GetFileList()                             */\n/************************************************************************/\n\nchar **GTiffDataset::GetFileList()\n\n{\n    char **papszFileList = GDALPamDataset::GetFileList();\n\n    LoadRPCRPB();\n    LoadIMD();\n\n    if (osIMDFile.size() != 0)\n        papszFileList = CSLAddString( papszFileList, osIMDFile );\n    if (osRPBFile.size() != 0)\n        papszFileList = CSLAddString( papszFileList, osRPBFile );\n    if (osRPCFile.size() != 0)\n        papszFileList = CSLAddString( papszFileList, osRPCFile );\n\n    if (osWldFilename.size() != 0 &&\n        CSLFindString(papszFileList, osWldFilename) == -1)\n    {\n        papszFileList = CSLAddString( papszFileList, osWldFilename );\n    }\n\n    return papszFileList;\n}\n\n/************************************************************************/\n/*                         CreateMaskBand()                             */\n/************************************************************************/\n\nCPLErr GTiffDataset::CreateMaskBand(int nFlags)\n{\n    if (poMaskDS != NULL)\n    {\n        CPLError(CE_Failure, CPLE_AppDefined,\n                 \"This TIFF dataset has already an internal mask band\");\n        return CE_Failure;\n    }\n    else if (CSLTestBoolean(CPLGetConfigOption(\"GDAL_TIFF_INTERNAL_MASK\", \"NO\")))\n    {\n        toff_t  nOffset;\n        int     bIsTiled;\n        int     bIsOverview = FALSE;\n        uint32\tnSubType;\n        int     nCompression;\n\n        if (nFlags != GMF_PER_DATASET)\n        {\n            CPLError(CE_Failure, CPLE_AppDefined,\n                     \"The only flag value supported for internal mask is GMF_PER_DATASET\");\n            return CE_Failure;\n        }\n\n        if( strstr(GDALGetMetadataItem(GDALGetDriverByName( \"GTiff\" ),\n                                       GDAL_DMD_CREATIONOPTIONLIST, NULL ),\n                   \"<Value>DEFLATE</Value>\") != NULL )\n            nCompression = COMPRESSION_ADOBE_DEFLATE;\n        else\n            nCompression = COMPRESSION_PACKBITS;\n\n    /* -------------------------------------------------------------------- */\n    /*      If we don't have read access, then create the mask externally.  */\n    /* -------------------------------------------------------------------- */\n        if( GetAccess() != GA_Update )\n        {\n            CPLError( CE_Warning, CPLE_AppDefined,\n                    \"File open for read-only accessing, \"\n                    \"creating mask externally.\" );\n\n            return GDALPamDataset::CreateMaskBand(nFlags);\n        }\n\n        if (poBaseDS)\n        {\n            if (!poBaseDS->SetDirectory())\n                return CE_Failure;\n        }\n        if (!SetDirectory())\n            return CE_Failure;\n\n        if( TIFFGetField(hTIFF, TIFFTAG_SUBFILETYPE, &nSubType))\n        {\n            bIsOverview = (nSubType & FILETYPE_REDUCEDIMAGE) != 0;\n\n            if ((nSubType & FILETYPE_MASK) != 0)\n            {\n                CPLError( CE_Failure, CPLE_AppDefined,\n                          \"Cannot create a mask on a TIFF mask IFD !\" );\n                return CE_Failure;\n            }\n        }\n\n        bIsTiled = TIFFIsTiled(hTIFF);\n        \n        FlushDirectory();\n        \n        nOffset = GTIFFWriteDirectory(hTIFF,\n                                      (bIsOverview) ? FILETYPE_REDUCEDIMAGE | FILETYPE_MASK : FILETYPE_MASK,\n                                      nRasterXSize, nRasterYSize,\n                                      1, PLANARCONFIG_CONTIG, 1,\n                                      nBlockXSize, nBlockYSize,\n                                      bIsTiled, nCompression, \n                                      PHOTOMETRIC_MASK, PREDICTOR_NONE,\n                                      SAMPLEFORMAT_UINT, NULL, NULL, NULL, 0, NULL, \"\");\n        if (nOffset == 0)\n            return CE_Failure;\n\n        poMaskDS = new GTiffDataset();\n        poMaskDS->bPromoteTo8Bits = CSLTestBoolean(CPLGetConfigOption(\"GDAL_TIFF_INTERNAL_MASK_TO_8BIT\", \"YES\"));\n        if( poMaskDS->OpenOffset( hTIFF, ppoActiveDSRef, nOffset, \n                                  FALSE, GA_Update ) != CE_None)\n        {\n            delete poMaskDS;\n            poMaskDS = NULL;\n            return CE_Failure;\n        }\n\n        return CE_None;\n    }\n    else\n    {\n        return GDALPamDataset::CreateMaskBand(nFlags);\n    }\n}\n\n/************************************************************************/\n/*                         CreateMaskBand()                             */\n/************************************************************************/\n\nCPLErr GTiffRasterBand::CreateMaskBand(int nFlags)\n{\n    if (poGDS->poMaskDS != NULL)\n    {\n        CPLError(CE_Failure, CPLE_AppDefined,\n                 \"This TIFF dataset has already an internal mask band\");\n        return CE_Failure;\n    }\n    else if (CSLTestBoolean(CPLGetConfigOption(\"GDAL_TIFF_INTERNAL_MASK\", \"NO\")))\n    {\n        return poGDS->CreateMaskBand(nFlags);\n    }\n    else\n    {\n        return GDALPamRasterBand::CreateMaskBand(nFlags);\n    }\n}\n\n/************************************************************************/\n/*                       PrepareTIFFErrorFormat()                       */\n/*                                                                      */\n/*      sometimes the \"module\" has stuff in it that has special         */\n/*      meaning in a printf() style format, so we try to escape it.     */\n/*      For now we hope the only thing we have to escape is %'s.        */\n/************************************************************************/\n\nstatic char *PrepareTIFFErrorFormat( const char *module, const char *fmt )\n\n{\n    char      *pszModFmt;\n    int       iIn, iOut;\n\n    pszModFmt = (char *) CPLMalloc( strlen(module)*2 + strlen(fmt) + 2 );\n    for( iOut = 0, iIn = 0; module[iIn] != '\\0'; iIn++ )\n    {\n        if( module[iIn] == '%' )\n        {\n            pszModFmt[iOut++] = '%';\n            pszModFmt[iOut++] = '%';\n        }\n        else\n            pszModFmt[iOut++] = module[iIn];\n    }\n    pszModFmt[iOut] = '\\0';\n    strcat( pszModFmt, \":\" );\n    strcat( pszModFmt, fmt );\n\n    return pszModFmt;\n}\n\n/************************************************************************/\n/*                        GTiffWarningHandler()                         */\n/************************************************************************/\nvoid\nGTiffWarningHandler(const char* module, const char* fmt, va_list ap )\n{\n    char\t*pszModFmt;\n\n    if( strstr(fmt,\"nknown field\") != NULL )\n        return;\n\n    pszModFmt = PrepareTIFFErrorFormat( module, fmt );\n    if( strstr(fmt, \"does not end in null byte\") != NULL )\n    {\n        CPLString osMsg;\n        osMsg.vPrintf(pszModFmt, ap);\n        CPLDebug( \"GTiff\", \"%s\", osMsg.c_str() );\n    }\n    else\n        CPLErrorV( CE_Warning, CPLE_AppDefined, pszModFmt, ap );\n    CPLFree( pszModFmt );\n}\n\n/************************************************************************/\n/*                         GTiffErrorHandler()                          */\n/************************************************************************/\nvoid\nGTiffErrorHandler(const char* module, const char* fmt, va_list ap )\n{\n    char *pszModFmt;\n\n    pszModFmt = PrepareTIFFErrorFormat( module, fmt );\n    CPLErrorV( CE_Failure, CPLE_AppDefined, pszModFmt, ap );\n    CPLFree( pszModFmt );\n}\n\n/************************************************************************/\n/*                          GTiffTagExtender()                          */\n/*                                                                      */\n/*      Install tags specially known to GDAL.                           */\n/************************************************************************/\n\nstatic TIFFExtendProc _ParentExtender = NULL;\n\nstatic void GTiffTagExtender(TIFF *tif)\n\n{\n    static const TIFFFieldInfo xtiffFieldInfo[] = {\n        { TIFFTAG_GDAL_METADATA,    -1,-1, TIFF_ASCII,\tFIELD_CUSTOM,\n          TRUE,\tFALSE,\t(char*) \"GDALMetadata\" },\n        { TIFFTAG_GDAL_NODATA,\t    -1,-1, TIFF_ASCII,\tFIELD_CUSTOM,\n          TRUE,\tFALSE,\t(char*) \"GDALNoDataValue\" },\n        { TIFFTAG_RPCCOEFFICIENT,   -1,-1, TIFF_DOUBLE,\tFIELD_CUSTOM,\n          TRUE,\tTRUE,\t(char*) \"RPCCoefficient\" }\n    };\n\n    if (_ParentExtender) \n        (*_ParentExtender)(tif);\n\n    TIFFMergeFieldInfo( tif, xtiffFieldInfo,\n\t\t        sizeof(xtiffFieldInfo) / sizeof(xtiffFieldInfo[0]) );\n}\n\n/************************************************************************/\n/*                          GTiffOneTimeInit()                          */\n/*                                                                      */\n/*      This is stuff that is initialized for the TIFF library just     */\n/*      once.  We deliberately defer the initialization till the        */\n/*      first time we are likely to call into libtiff to avoid          */\n/*      unnecessary paging in of the library for GDAL apps that         */\n/*      don't use it.                                                   */\n/************************************************************************/\n#if defined(HAVE_DLFCN_H) && !defined(WIN32)\n#include <dlfcn.h>\n#endif\n\nint GTiffOneTimeInit()\n\n{\n    static int bInitIsOk = TRUE;\n    static int bOneTimeInitDone = FALSE;\n    static void* hMutex = NULL;\n    CPLMutexHolder oHolder( &hMutex);\n    if( bOneTimeInitDone )\n        return bInitIsOk;\n\n    bOneTimeInitDone = TRUE;\n\n    /* This is a frequent configuration error that is difficult to track down */\n    /* for people unaware of the issue : GDAL built against internal libtiff (4.X) */\n    /* but used by an application that links with external libtiff (3.X) */\n    /* Note: on my conf, the order that cause GDAL to crash - and that is detected */\n    /* by the following code - is \"-ltiff -lgdal\". \"-lgdal -ltiff\" works for the */\n    /* GTiff driver but probably breaks the application that believes it uses libtiff 3.X */\n    /* but we cannot detect that... */\n#ifdef BIGTIFF_SUPPORT\n#if defined(HAVE_DLFCN_H) && !defined(WIN32)\n    const char* (*pfnVersion)(void);\n    pfnVersion = (const char* (*)(void)) dlsym(RTLD_DEFAULT, \"TIFFGetVersion\");\n    if (pfnVersion)\n    {\n        const char* pszVersion = pfnVersion();\n        if (pszVersion && strstr(pszVersion, \"Version 3.\") != NULL)\n        {\n            CPLError(CE_Failure, CPLE_AppDefined,\n                     \"WARNING ! libtiff version mismatch : You're linking against libtiff 3.X but GDAL has been compiled against libtiff >= 4.0.0\");\n            bInitIsOk = FALSE;\n            return FALSE;\n        }\n    }\n#endif\n#endif\n\n    _ParentExtender = TIFFSetTagExtender(GTiffTagExtender);\n\n    TIFFSetWarningHandler( GTiffWarningHandler );\n    TIFFSetErrorHandler( GTiffErrorHandler );\n\n    // This only really needed if we are linked to an external libgeotiff\n    // with its own (lame) file searching logic. \n    SetCSVFilenameHook( GDALDefaultCSVFilename );\n\n    return TRUE;\n}\n\n/************************************************************************/\n/*                        GDALDeregister_GTiff()                        */\n/************************************************************************/\n\nvoid GDALDeregister_GTiff( GDALDriver * )\n\n{\n    CSVDeaccess( NULL );\n\n#if defined(LIBGEOTIFF_VERSION) && LIBGEOTIFF_VERSION > 1150\n    GTIFDeaccessCSV();\n#endif\n}\n\n/************************************************************************/\n/*                   GTIFFGetCompressionMethod()                        */\n/************************************************************************/\n\nint GTIFFGetCompressionMethod(const char* pszValue, const char* pszVariableName)\n{\n    int nCompression = COMPRESSION_NONE;\n    if( EQUAL( pszValue, \"NONE\" ) )\n        nCompression = COMPRESSION_NONE;\n    else if( EQUAL( pszValue, \"JPEG\" ) )\n        nCompression = COMPRESSION_JPEG;\n    else if( EQUAL( pszValue, \"LZW\" ) )\n        nCompression = COMPRESSION_LZW;\n    else if( EQUAL( pszValue, \"PACKBITS\" ))\n        nCompression = COMPRESSION_PACKBITS;\n    else if( EQUAL( pszValue, \"DEFLATE\" ) || EQUAL( pszValue, \"ZIP\" ))\n        nCompression = COMPRESSION_ADOBE_DEFLATE;\n    else if( EQUAL( pszValue, \"FAX3\" )\n                || EQUAL( pszValue, \"CCITTFAX3\" ))\n        nCompression = COMPRESSION_CCITTFAX3;\n    else if( EQUAL( pszValue, \"FAX4\" )\n                || EQUAL( pszValue, \"CCITTFAX4\" ))\n        nCompression = COMPRESSION_CCITTFAX4;\n    else if( EQUAL( pszValue, \"CCITTRLE\" ) )\n        nCompression = COMPRESSION_CCITTRLE;\n    else if( EQUAL( pszValue, \"LZMA\" ) )\n        nCompression = COMPRESSION_LZMA;\n    else\n        CPLError( CE_Warning, CPLE_IllegalArg,\n                    \"%s=%s value not recognised, ignoring.\",\n                    pszVariableName,pszValue );\n\n#if defined(TIFFLIB_VERSION) && TIFFLIB_VERSION > 20031007 /* 3.6.0 */\n    if (nCompression != COMPRESSION_NONE &&\n        !TIFFIsCODECConfigured((uint16) nCompression))\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                \"Cannot create TIFF file due to missing codec for %s.\", pszValue );\n        return -1;\n    }\n#endif\n\n    return nCompression;\n}\n/************************************************************************/\n/*                          GDALRegister_GTiff()                        */\n/************************************************************************/\n\nvoid GDALRegister_GTiff()\n\n{\n    if( GDALGetDriverByName( \"GTiff\" ) == NULL )\n    {\n        GDALDriver\t*poDriver;\n        char szCreateOptions[3072];\n        char szOptionalCompressItems[500];\n        int bHasJPEG = FALSE, bHasLZW = FALSE, bHasDEFLATE = FALSE, bHasLZMA = FALSE;\n\n        poDriver = new GDALDriver();\n        \n/* -------------------------------------------------------------------- */\n/*      Determine which compression codecs are available that we        */\n/*      want to advertise.  If we are using an old libtiff we won't     */\n/*      be able to find out so we just assume all are available.        */\n/* -------------------------------------------------------------------- */\n        strcpy( szOptionalCompressItems, \n                \"       <Value>NONE</Value>\" );\n\n#if TIFFLIB_VERSION <= 20040919\n        strcat( szOptionalCompressItems, \n                \"       <Value>PACKBITS</Value>\"\n                \"       <Value>JPEG</Value>\"\n                \"       <Value>LZW</Value>\"\n                \"       <Value>DEFLATE</Value>\" );\n        bHasLZW = bHasDEFLATE = TRUE;\n#else\n        TIFFCodec\t*c, *codecs = TIFFGetConfiguredCODECs();\n\n        for( c = codecs; c->name; c++ )\n        {\n            if( c->scheme == COMPRESSION_PACKBITS )\n                strcat( szOptionalCompressItems,\n                        \"       <Value>PACKBITS</Value>\" );\n            else if( c->scheme == COMPRESSION_JPEG )\n            {\n                bHasJPEG = TRUE;\n                strcat( szOptionalCompressItems,\n                        \"       <Value>JPEG</Value>\" );\n            }\n            else if( c->scheme == COMPRESSION_LZW )\n            {\n                bHasLZW = TRUE;\n                strcat( szOptionalCompressItems,\n                        \"       <Value>LZW</Value>\" );\n            }\n            else if( c->scheme == COMPRESSION_ADOBE_DEFLATE )\n            {\n                bHasDEFLATE = TRUE;\n                strcat( szOptionalCompressItems,\n                        \"       <Value>DEFLATE</Value>\" );\n            }\n            else if( c->scheme == COMPRESSION_CCITTRLE )\n                strcat( szOptionalCompressItems,\n                        \"       <Value>CCITTRLE</Value>\" );\n            else if( c->scheme == COMPRESSION_CCITTFAX3 )\n                strcat( szOptionalCompressItems,\n                        \"       <Value>CCITTFAX3</Value>\" );\n            else if( c->scheme == COMPRESSION_CCITTFAX4 )\n                strcat( szOptionalCompressItems,\n                        \"       <Value>CCITTFAX4</Value>\" );\n            else if( c->scheme == COMPRESSION_LZMA )\n            {\n                bHasLZMA = TRUE;\n                strcat( szOptionalCompressItems,\n                        \"       <Value>LZMA</Value>\" );\n            }\n        }\n        _TIFFfree( codecs );\n#endif        \n\n/* -------------------------------------------------------------------- */\n/*      Build full creation option list.                                */\n/* -------------------------------------------------------------------- */\n        sprintf( szCreateOptions, \"%s%s%s\", \n\"<CreationOptionList>\"\n\"   <Option name='COMPRESS' type='string-select'>\",\n                 szOptionalCompressItems,\n\"   </Option>\");\n        if (bHasLZW || bHasDEFLATE)\n            strcat( szCreateOptions, \"\"        \n\"   <Option name='PREDICTOR' type='int' description='Predictor Type'/>\");\n        if (bHasJPEG)\n            strcat( szCreateOptions, \"\"\n\"   <Option name='JPEG_QUALITY' type='int' description='JPEG quality 1-100' default='75'/>\");\n        if (bHasDEFLATE)\n            strcat( szCreateOptions, \"\"\n\"   <Option name='ZLEVEL' type='int' description='DEFLATE compression level 1-9' default='6'/>\");\n        if (bHasLZMA)\n            strcat( szCreateOptions, \"\"\n\"   <Option name='LZMA_PRESET' type='int' description='LZMA compression level 0(fast)-9(slow)' default='6'/>\");\n        strcat( szCreateOptions, \"\"\n\"   <Option name='NBITS' type='int' description='BITS for sub-byte files (1-7), sub-uint16 (9-15), sub-uint32 (17-31)'/>\"\n\"   <Option name='INTERLEAVE' type='string-select' default='PIXEL'>\"\n\"       <Value>BAND</Value>\"\n\"       <Value>PIXEL</Value>\"\n\"   </Option>\"\n\"   <Option name='TILED' type='boolean' description='Switch to tiled format'/>\"\n\"   <Option name='TFW' type='boolean' description='Write out world file'/>\"\n\"   <Option name='RPB' type='boolean' description='Write out .RPB (RPC) file'/>\"\n\"   <Option name='BLOCKXSIZE' type='int' description='Tile Width'/>\"\n\"   <Option name='BLOCKYSIZE' type='int' description='Tile/Strip Height'/>\"\n\"   <Option name='PHOTOMETRIC' type='string-select'>\"\n\"       <Value>MINISBLACK</Value>\"\n\"       <Value>MINISWHITE</Value>\"\n\"       <Value>PALETTE</Value>\"\n\"       <Value>RGB</Value>\"\n\"       <Value>CMYK</Value>\"\n\"       <Value>YCBCR</Value>\"\n\"       <Value>CIELAB</Value>\"\n\"       <Value>ICCLAB</Value>\"\n\"       <Value>ITULAB</Value>\"\n\"   </Option>\"\n\"   <Option name='SPARSE_OK' type='boolean' description='Can newly created files have missing blocks?' default='FALSE'/>\"\n\"   <Option name='ALPHA' type='boolean' description='Mark first extrasample as being alpha'/>\"\n\"   <Option name='PROFILE' type='string-select' default='GDALGeoTIFF'>\"\n\"       <Value>GDALGeoTIFF</Value>\"\n\"       <Value>GeoTIFF</Value>\"\n\"       <Value>BASELINE</Value>\"\n\"   </Option>\"\n\"   <Option name='PIXELTYPE' type='string-select'>\"\n\"       <Value>DEFAULT</Value>\"\n\"       <Value>SIGNEDBYTE</Value>\"\n\"   </Option>\"\n#ifdef BIGTIFF_SUPPORT\n\"   <Option name='BIGTIFF' type='string-select' description='Force creation of BigTIFF file'>\"\n\"     <Value>YES</Value>\"\n\"     <Value>NO</Value>\"\n\"     <Value>IF_NEEDED</Value>\"\n\"     <Value>IF_SAFER</Value>\"\n\"   </Option>\"\n#endif\n\"   <Option name='ENDIANNESS' type='string-select' default='NATIVE' description='Force endianness of created file. For DEBUG purpose mostly'>\"\n\"       <Value>NATIVE</Value>\"\n\"       <Value>INVERTED</Value>\"\n\"       <Value>LITTLE</Value>\"\n\"       <Value>BIG</Value>\"\n\"   </Option>\"\n\"   <Option name='COPY_SRC_OVERVIEWS' type='boolean' default='NO' description='Force copy of overviews of source dataset (CreateCopy())'/>\"\n\"</CreationOptionList>\" );\n                 \n/* -------------------------------------------------------------------- */\n/*      Set the driver details.                                         */\n/* -------------------------------------------------------------------- */\n        poDriver->SetDescription( \"GTiff\" );\n        poDriver->SetMetadataItem( GDAL_DMD_LONGNAME, \"GeoTIFF\" );\n        poDriver->SetMetadataItem( GDAL_DMD_HELPTOPIC, \"frmt_gtiff.html\" );\n        poDriver->SetMetadataItem( GDAL_DMD_MIMETYPE, \"image/tiff\" );\n        poDriver->SetMetadataItem( GDAL_DMD_EXTENSION, \"tif\" );\n        poDriver->SetMetadataItem( GDAL_DMD_CREATIONDATATYPES, \n                                   \"Byte UInt16 Int16 UInt32 Int32 Float32 \"\n                                   \"Float64 CInt16 CInt32 CFloat32 CFloat64\" );\n        poDriver->SetMetadataItem( GDAL_DMD_CREATIONOPTIONLIST, \n                                   szCreateOptions );\n\n        poDriver->SetMetadataItem( GDAL_DCAP_VIRTUALIO, \"YES\" );\n\n        poDriver->pfnOpen = GTiffDataset::Open;\n        poDriver->pfnCreate = GTiffDataset::Create;\n        poDriver->pfnCreateCopy = GTiffDataset::CreateCopy;\n        poDriver->pfnUnloadDriver = GDALDeregister_GTiff;\n        poDriver->pfnIdentify = GTiffDataset::Identify;\n\n        GetGDALDriverManager()->RegisterDriver( poDriver );\n    }\n}\n",
                "name": "geotiff.cpp",
                "path": "environment/build/3rdParty/gdal/frmts/gtiff/geotiff.cpp",
                "url": "/github.com/haozzzzzzzz/osgEarthX/-/blob/environment/build/3rdParty/gdal/frmts/gtiff/geotiff.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 1849,
                    "offsetAndLengths": [
                        [
                            16,
                            16
                        ]
                    ],
                    "preview": "            if( TIFFReadRGBATile(poGDS->hTIFF, "
                },
                {
                    "limitHit": false,
                    "lineNumber": 1857,
                    "offsetAndLengths": [
                        [
                            27,
                            16
                        ]
                    ],
                    "preview": "                          \"TIFFReadRGBATile() failed.\" );"
                }
            ],
            "repository": {
                "name": "github.com/haozzzzzzzz/osgEarthX",
                "url": "/github.com/haozzzzzzzz/osgEarthX"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "276b5b03d63f49235db74f2c501057abb9e79d89"
                },
                "content": "/*M///////////////////////////////////////////////////////////////////////////////////////\n//\n//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.\n//\n//  By downloading, copying, installing or using the software you agree to this license.\n//  If you do not agree to this license, do not download, install,\n//  copy or use the software.\n//\n//\n//                        Intel License Agreement\n//                For Open Source Computer Vision Library\n//\n// Copyright (C) 2000, Intel Corporation, all rights reserved.\n// Third party copyrights are property of their respective owners.\n//\n// Redistribution and use in source and binary forms, with or without modification,\n// are permitted provided that the following conditions are met:\n//\n//   * Redistribution's of source code must retain the above copyright notice,\n//     this list of conditions and the following disclaimer.\n//\n//   * Redistribution's in binary form must reproduce the above copyright notice,\n//     this list of conditions and the following disclaimer in the documentation\n//     and/or other materials provided with the distribution.\n//\n//   * The name of Intel Corporation may not be used to endorse or promote products\n//     derived from this software without specific prior written permission.\n//\n// This software is provided by the copyright holders and contributors \"as is\" and\n// any express or implied warranties, including, but not limited to, the implied\n// warranties of merchantability and fitness for a particular purpose are disclaimed.\n// In no event shall the Intel Corporation or contributors be liable for any direct,\n// indirect, incidental, special, exemplary, or consequential damages\n// (including, but not limited to, procurement of substitute goods or services;\n// loss of use, data, or profits; or business interruption) however caused\n// and on any theory of liability, whether in contract, strict liability,\n// or tort (including negligence or otherwise) arising in any way out of\n// the use of this software, even if advised of the possibility of such damage.\n//\n//M*/\n\n/****************************************************************************************\\\n    A part of the file implements TIFF reader on base of libtiff library\n    (see otherlibs/_graphics/readme.txt for copyright notice)\n\\****************************************************************************************/\n\n#include \"_highgui.h\"\n#include \"grfmt_tiff.h\"\n\nstatic const char fmtSignTiffII[] = \"II\\x2a\\x00\";\nstatic const char fmtSignTiffMM[] = \"MM\\x00\\x2a\";\n\nGrFmtTiff::GrFmtTiff()\n{\n    m_sign_len = 4;\n    m_signature = \"\";\n    m_description = \"TIFF Files (*.tiff;*.tif)\";\n}\n\nGrFmtTiff::~GrFmtTiff()\n{\n}\n\nbool GrFmtTiff::CheckSignature( const char* signature )\n{\n    return memcmp( signature, fmtSignTiffII, 4 ) == 0 ||\n           memcmp( signature, fmtSignTiffMM, 4 ) == 0;\n}\n\n\nGrFmtReader* GrFmtTiff::NewReader( const char* filename )\n{\n    return new GrFmtTiffReader( filename );\n}\n\n\nGrFmtWriter* GrFmtTiff::NewWriter( const char* filename )\n{\n    return new GrFmtTiffWriter( filename );\n}\n\n\n#ifdef HAVE_TIFF\n\n#include \"tiff.h\"\n#include \"tiffio.h\"\n\nstatic int grfmt_tiff_err_handler_init = 0;\n\nstatic void GrFmtSilentTIFFErrorHandler( const char*, const char*, va_list ) {}\n\nGrFmtTiffReader::GrFmtTiffReader( const char* filename ) : GrFmtReader( filename )\n{\n    m_tif = 0;\n\n    if( !grfmt_tiff_err_handler_init )\n    {\n        grfmt_tiff_err_handler_init = 1;\n\n        TIFFSetErrorHandler( GrFmtSilentTIFFErrorHandler );\n        TIFFSetWarningHandler( GrFmtSilentTIFFErrorHandler );\n    }\n}\n\n\nGrFmtTiffReader::~GrFmtTiffReader()\n{\n}\n\n\nvoid  GrFmtTiffReader::Close()\n{\n    if( m_tif )\n    {\n        TIFF* tif = (TIFF*)m_tif;\n        TIFFClose( tif );\n        m_tif = 0;\n    }\n}\n\n\nbool  GrFmtTiffReader::CheckFormat( const char* signature )\n{\n    return memcmp( signature, fmtSignTiffII, 4 ) == 0 ||\n           memcmp( signature, fmtSignTiffMM, 4 ) == 0;\n}\n\n\nbool  GrFmtTiffReader::ReadHeader()\n{\n    char errmsg[1024];\n    bool result = false;\n\n    Close();\n    TIFF* tif = TIFFOpen( m_filename, \"r\" );\n\n    if( tif )\n    {\n        int width = 0, height = 0, photometric = 0, compression = 0;\n        m_tif = tif;\n\n        if( TIFFRGBAImageOK( tif, errmsg ) &&\n            TIFFGetField( tif, TIFFTAG_IMAGEWIDTH, &width ) &&\n            TIFFGetField( tif, TIFFTAG_IMAGELENGTH, &height ) &&\n            TIFFGetField( tif, TIFFTAG_PHOTOMETRIC, &photometric ) && \n            (!TIFFGetField( tif, TIFFTAG_COMPRESSION, &compression ) ||\n            (compression != COMPRESSION_LZW &&\n             compression != COMPRESSION_OJPEG)))\n        {\n            m_width = width;\n            m_height = height;\n            m_iscolor = photometric > 1;\n            \n            result = true;\n        }\n    }\n\n    if( !result )\n        Close();\n\n    return result;\n}\n\n\nbool  GrFmtTiffReader::ReadData( uchar* data, int step, int color )\n{\n    bool result = false;\n    uchar* buffer = 0;\n\n    color = color > 0 || (color < 0 && m_iscolor);\n\n    if( m_tif && m_width && m_height )\n    {\n        TIFF* tif = (TIFF*)m_tif;\n        int tile_width0 = m_width, tile_height0 = 0;\n        int x, y, i;\n        int is_tiled = TIFFIsTiled(tif);\n        \n        if( !is_tiled &&\n            TIFFGetField( tif, TIFFTAG_ROWSPERSTRIP, &tile_height0 ) ||\n            is_tiled &&\n            TIFFGetField( tif, TIFFTAG_TILEWIDTH, &tile_width0 ) &&\n            TIFFGetField( tif, TIFFTAG_TILELENGTH, &tile_height0 ))\n        {\n            if( tile_width0 <= 0 )\n                tile_width0 = m_width;\n\n            if( tile_height0 <= 0 )\n                tile_height0 = m_height;\n            \n            buffer = new uchar[tile_height0*tile_width0*4];\n\n            for( y = 0; y < m_height; y += tile_height0, data += step*tile_height0 )\n            {\n                int tile_height = tile_height0;\n\n                if( y + tile_height > m_height )\n                    tile_height = m_height - y;\n\n                for( x = 0; x < m_width; x += tile_width0 )\n                {\n                    int tile_width = tile_width0, ok;\n\n                    if( x + tile_width > m_width )\n                        tile_width = m_width - x;\n\n                    if( !is_tiled )\n                        ok = TIFFReadRGBAStrip( tif, y, (uint32*)buffer );\n                    else\n                        ok = TIFFReadRGBATile( tif, x, y, (uint32*)buffer );\n\n                    if( !ok )\n                        goto exit_func;\n\n                    for( i = 0; i < tile_height; i++ )\n                        if( color )\n                            icvCvt_BGRA2BGR_8u_C4C3R( buffer + i*tile_width*4, 0,\n                                          data + x*3 + step*(tile_height - i - 1), 0,\n                                          cvSize(tile_width,1), 2 );\n                        else\n                            icvCvt_BGRA2Gray_8u_C4C1R( buffer + i*tile_width*4, 0,\n                                           data + x + step*(tile_height - i - 1), 0,\n                                           cvSize(tile_width,1), 2 );\n                }\n            }\n\n            result = true;\n        }\n    }\n\nexit_func:\n\n    Close();\n    delete[] buffer;\n\n    return result;\n}\n\n#else\n\nstatic const int  tiffMask[] = { 0xff, 0xff, 0xffffffff, 0xffff, 0xffffffff };\n\n/************************ TIFF reader *****************************/\n\nGrFmtTiffReader::GrFmtTiffReader( const char* filename ) : GrFmtReader( filename )\n{\n    m_offsets = 0;\n    m_maxoffsets = 0;\n    m_strips = -1;\n    m_max_pal_length = 0;\n    m_temp_palette = 0;\n}\n\n\nGrFmtTiffReader::~GrFmtTiffReader()\n{\n    Close();\n\n    delete[] m_offsets;\n    delete[] m_temp_palette;\n}\n\nvoid  GrFmtTiffReader::Close()\n{\n    m_strm.Close();\n}\n\n\nbool  GrFmtTiffReader::CheckFormat( const char* signature )\n{\n    return memcmp( signature, fmtSignTiffII, 4 ) == 0 ||\n           memcmp( signature, fmtSignTiffMM, 4 ) == 0;\n}\n\n\nint   GrFmtTiffReader::GetWordEx()\n{\n    int val = m_strm.GetWord();\n    if( m_byteorder == TIFF_ORDER_MM )\n        val = ((val)>>8)|(((val)&0xff)<<8);\n    return val;\n}\n\n\nint   GrFmtTiffReader::GetDWordEx()\n{\n    int val = m_strm.GetDWord();\n    if( m_byteorder == TIFF_ORDER_MM )\n        val = BSWAP( val );\n    return val;\n}\n\n\nint  GrFmtTiffReader::ReadTable( int offset, int count,\n                                 TiffFieldType fieldType,\n                                 int*& array, int& arraysize )\n{\n    int i;\n    \n    if( count < 0 )\n        return RBS_BAD_HEADER;\n    \n    if( fieldType != TIFF_TYPE_SHORT &&\n        fieldType != TIFF_TYPE_LONG &&\n        fieldType != TIFF_TYPE_BYTE )\n        return RBS_BAD_HEADER;\n\n    if( count > arraysize )\n    {\n        delete[] array;\n        arraysize = arraysize*3/2;\n        if( arraysize < count )\n            arraysize = count;\n        array = new int[arraysize];\n    }\n\n    if( count > 1 )\n    {\n        int pos = m_strm.GetPos();\n        m_strm.SetPos( offset );\n\n        if( fieldType == TIFF_TYPE_LONG )\n        {\n            if( m_byteorder == TIFF_ORDER_MM )\n                for( i = 0; i < count; i++ )\n                    array[i] = ((RMByteStream&)m_strm).GetDWord();\n            else\n                for( i = 0; i < count; i++ )\n                    array[i] = ((RLByteStream&)m_strm).GetDWord();\n        }\n        else if( fieldType == TIFF_TYPE_SHORT )\n        {\n            if( m_byteorder == TIFF_ORDER_MM )\n                for( i = 0; i < count; i++ )\n                    array[i] = ((RMByteStream&)m_strm).GetWord();\n            else\n                for( i = 0; i < count; i++ )\n                    array[i] = ((RLByteStream&)m_strm).GetWord();\n        }\n        else // fieldType == TIFF_TYPE_BYTE\n            for( i = 0; i < count; i++ )\n                array[i] = m_strm.GetByte();\n\n        m_strm.SetPos(pos);\n    }\n    else\n    {\n        assert( (offset & ~tiffMask[fieldType]) == 0 );\n        array[0] = offset;\n    }\n\n    return 0;\n}\n\n\nbool  GrFmtTiffReader::ReadHeader()\n{\n    bool result = false;\n    int  photometric = -1;\n    int  channels = 1;\n    int  pal_length = -1;\n\n    const int MAX_CHANNELS = 4;\n    int  bpp_arr[MAX_CHANNELS];\n\n    assert( strlen(m_filename) != 0 );\n    if( !m_strm.Open( m_filename )) return false;\n\n    m_width = -1;\n    m_height = -1;\n    m_strips = -1;\n    m_bpp = 1;\n    m_compression = TIFF_UNCOMP;\n    m_rows_per_strip = -1;\n    m_iscolor = false;\n\n    if( setjmp( m_strm.JmpBuf()) == 0 )\n    {\n        m_byteorder = (TiffByteOrder)m_strm.GetWord();\n        m_strm.Skip( 2 );\n        int header_offset = GetDWordEx();\n\n        m_strm.SetPos( header_offset );\n\n        // read the first tag directory\n        int i, j, count = GetWordEx();\n\n        for( i = 0; i < count; i++ )\n        {\n            // read tag\n            TiffTag tag = (TiffTag)GetWordEx();\n            TiffFieldType fieldType = (TiffFieldType)GetWordEx();\n            int count = GetDWordEx();\n            int value = GetDWordEx();\n            if( count == 1 )\n            {\n                if( m_byteorder == TIFF_ORDER_MM )\n                {\n                    if( fieldType == TIFF_TYPE_SHORT )\n                        value = (unsigned)value >> 16;\n                    else if( fieldType == TIFF_TYPE_BYTE )\n                        value = (unsigned)value >> 24;\n                }\n\n                value &= tiffMask[fieldType];\n            }\n\n            switch( tag )\n            {\n            case  TIFF_TAG_WIDTH:\n                m_width = value;\n                break;\n\n            case  TIFF_TAG_HEIGHT:\n                m_height = value;\n                break;\n\n            case  TIFF_TAG_BITS_PER_SAMPLE:\n                {\n                    int* bpp_arr_ref = bpp_arr;\n\n                    if( count > MAX_CHANNELS )\n                        BAD_HEADER_ERR();\n\n                    if( ReadTable( value, count, fieldType, bpp_arr_ref, count ) < 0 )\n                        BAD_HEADER_ERR();\n                \n                    for( j = 1; j < count; j++ )\n                    {\n                        if( bpp_arr[j] != bpp_arr[0] )\n                            BAD_HEADER_ERR();\n                    }\n\n                    m_bpp = bpp_arr[0];\n                }\n\n                break;\n\n            case  TIFF_TAG_COMPRESSION:\n                m_compression = (TiffCompression)value;\n                if( m_compression != TIFF_UNCOMP &&\n                    m_compression != TIFF_HUFFMAN &&\n                    m_compression != TIFF_PACKBITS )\n                    BAD_HEADER_ERR();\n                break;\n\n            case  TIFF_TAG_PHOTOMETRIC:\n                photometric = value;\n                if( (unsigned)photometric > 3 )\n                    BAD_HEADER_ERR();\n                break;\n\n            case  TIFF_TAG_STRIP_OFFSETS:\n                m_strips = count;\n                if( ReadTable( value, count, fieldType, m_offsets, m_maxoffsets ) < 0 )\n                    BAD_HEADER_ERR();\n                break;\n\n            case  TIFF_TAG_SAMPLES_PER_PIXEL:\n                channels = value;\n                if( channels != 1 && channels != 3 && channels != 4 )\n                    BAD_HEADER_ERR();\n                break;\n\n            case  TIFF_TAG_ROWS_PER_STRIP:\n                m_rows_per_strip = value;\n                break;\n\n            case  TIFF_TAG_PLANAR_CONFIG:\n                {\n                int planar_config = value;\n                if( planar_config != 1 )\n                    BAD_HEADER_ERR();\n                }\n                break;\n\n            case  TIFF_TAG_COLOR_MAP:\n                if( fieldType != TIFF_TYPE_SHORT || count < 2 )\n                    BAD_HEADER_ERR();\n                if( ReadTable( value, count, fieldType,\n                               m_temp_palette, m_max_pal_length ) < 0 )\n                    BAD_HEADER_ERR();\n                pal_length = count / 3;\n                if( pal_length > 256 )\n                    BAD_HEADER_ERR();\n                for( i = 0; i < pal_length; i++ )\n                {\n                    m_palette[i].r = (uchar)(m_temp_palette[i] >> 8);\n                    m_palette[i].g = (uchar)(m_temp_palette[i + pal_length] >> 8);\n                    m_palette[i].b = (uchar)(m_temp_palette[i + pal_length*2] >> 8);\n                }\n                break;\n            case  TIFF_TAG_STRIP_COUNTS:\n                break;\n            }\n        }\n\n        if( m_strips == 1 && m_rows_per_strip == -1 )\n            m_rows_per_strip = m_height;\n\n        if( m_width > 0 && m_height > 0 && m_strips > 0 &&\n            (m_height + m_rows_per_strip - 1)/m_rows_per_strip == m_strips )\n        {\n            switch( m_bpp )\n            {\n            case 1:\n                if( photometric == 0 || photometric == 1 && channels == 1 )\n                {\n                    FillGrayPalette( m_palette, m_bpp, photometric == 0 );\n                    result = true;\n                    m_iscolor = false;\n                }\n                break;\n            case 4:\n            case 8:\n                if( (photometric == 0 || photometric == 1 ||\n                     photometric == 3 && pal_length == (1 << m_bpp)) &&\n                    m_compression != TIFF_HUFFMAN && channels == 1 )\n                {\n                    if( pal_length < 0 )\n                    {\n                        FillGrayPalette( m_palette, m_bpp, photometric == 0 );\n                        m_iscolor = false;\n                    }\n                    else\n                    {\n                        m_iscolor = IsColorPalette( m_palette, m_bpp );\n                    }\n                    result = true;\n                }\n                else if( photometric == 2 && pal_length < 0 &&\n                         (channels == 3 || channels == 4) &&\n                         m_compression == TIFF_UNCOMP )\n                {\n                    m_bpp = 8*channels;\n                    m_iscolor = true;\n                    result = true;\n                }\n                break;\n            default:\n                BAD_HEADER_ERR();\n            }\n        }\nbad_header_exit:\n        ;\n    }\n\n    if( !result )\n    {\n        m_strips = -1;\n        m_width = m_height = -1;\n        m_strm.Close();\n    }\n\n    return result;\n}\n\n\nbool  GrFmtTiffReader::ReadData( uchar* data, int step, int color )\n{\n    const  int buffer_size = 1 << 12;\n    uchar  buffer[buffer_size];\n    uchar  gray_palette[256];\n    bool   result = false;\n    uchar* src = buffer;\n    int    src_pitch = (m_width*m_bpp + 7)/8;\n    int    y = 0;\n\n    if( m_strips < 0 || !m_strm.IsOpened())\n        return false;\n    \n    if( src_pitch+32 > buffer_size )\n        src = new uchar[src_pitch+32];\n\n    if( !color )\n        if( m_bpp <= 8 )\n        {\n            CvtPaletteToGray( m_palette, gray_palette, 1 << m_bpp );\n        }\n\n    if( setjmp( m_strm.JmpBuf()) == 0 )\n    {\n        for( int s = 0; s < m_strips; s++ )\n        {\n            int y_limit = m_rows_per_strip;\n\n            y_limit += y;\n            if( y_limit > m_height ) y_limit = m_height;\n\n            m_strm.SetPos( m_offsets[s] );\n\n            if( m_compression == TIFF_UNCOMP )\n            {\n                for( ; y < y_limit; y++, data += step )\n                {\n                    m_strm.GetBytes( src, src_pitch );\n                    if( color )\n                        switch( m_bpp )\n                        {\n                        case 1:\n                            FillColorRow1( data, src, m_width, m_palette );\n                            break;\n                        case 4:\n                            FillColorRow4( data, src, m_width, m_palette );\n                            break;\n                        case 8:\n                            FillColorRow8( data, src, m_width, m_palette );\n                            break;\n                        case 24:\n                            icvCvt_RGB2BGR_8u_C3R( src, 0, data, 0, cvSize(m_width,1) );\n                            break;\n                        case 32:\n                            icvCvt_BGRA2BGR_8u_C4C3R( src, 0, data, 0, cvSize(m_width,1), 2 );\n                            break;\n                        default:\n                            assert(0);\n                            goto bad_decoding_end;\n                        }\n                    else\n                        switch( m_bpp )\n                        {\n                        case 1:\n                            FillGrayRow1( data, src, m_width, gray_palette );\n                            break;\n                        case 4:\n                            FillGrayRow4( data, src, m_width, gray_palette );\n                            break;\n                        case 8:\n                            FillGrayRow8( data, src, m_width, gray_palette );\n                            break;\n                        case 24:\n                            icvCvt_BGR2Gray_8u_C3C1R( src, 0, data, 0, cvSize(m_width,1), 2 );\n                            break;\n                        case 32:\n                            icvCvt_BGRA2Gray_8u_C4C1R( src, 0, data, 0, cvSize(m_width,1), 2 );\n                            break;\n                        default:\n                            assert(0);\n                            goto bad_decoding_end;\n                        }\n                }\n            }\n            else\n            {\n            }\n\n            result = true;\n\nbad_decoding_end:\n\n            ;\n        }\n    }\n\n    if( src != buffer ) delete[] src; \n    return result;\n}\n\n#endif\n\n//////////////////////////////////////////////////////////////////////////////////////////\n\nGrFmtTiffWriter::GrFmtTiffWriter( const char* filename ) : GrFmtWriter( filename )\n{\n}\n\nGrFmtTiffWriter::~GrFmtTiffWriter()\n{\n}\n\nvoid  GrFmtTiffWriter::WriteTag( TiffTag tag, TiffFieldType fieldType,\n                                 int count, int value )\n{\n    m_strm.PutWord( tag );\n    m_strm.PutWord( fieldType );\n    m_strm.PutDWord( count );\n    m_strm.PutDWord( value );\n}\n\n\nbool  GrFmtTiffWriter::WriteImage( const uchar* data, int step,\n                                   int width, int height, int /*depth*/, int channels )\n{\n    bool result = false;\n    int fileStep = width*channels;\n\n    assert( data && width > 0 && height > 0 && step >= fileStep);\n\n    if( m_strm.Open( m_filename ) )\n    {\n        int rowsPerStrip = (1 << 13)/fileStep;\n\n        if( rowsPerStrip < 1 )\n            rowsPerStrip = 1;\n\n        if( rowsPerStrip > height )\n            rowsPerStrip = height;\n\n        int i, stripCount = (height + rowsPerStrip - 1) / rowsPerStrip;\n/*#if defined _DEBUG || !defined WIN32\n        int uncompressedRowSize = rowsPerStrip * fileStep;\n#endif*/\n        int directoryOffset = 0;\n\n        int* stripOffsets = new int[stripCount];\n        short* stripCounts = new short[stripCount];\n        uchar* buffer = new uchar[fileStep + 32];\n        int  stripOffsetsOffset = 0;\n        int  stripCountsOffset = 0;\n        int  bitsPerSample = 8; // TODO support 16 bit\n        int  y = 0;\n\n        m_strm.PutBytes( fmtSignTiffII, 4 );\n        m_strm.PutDWord( directoryOffset );\n\n        // write an image data first (the most reasonable way\n        // for compressed images)\n        for( i = 0; i < stripCount; i++ )\n        {\n            int limit = y + rowsPerStrip;\n\n            if( limit > height )\n                limit = height;\n\n            stripOffsets[i] = m_strm.GetPos();\n\n            for( ; y < limit; y++, data += step )\n            {\n                if( channels == 3 )\n                    icvCvt_BGR2RGB_8u_C3R( data, 0, buffer, 0, cvSize(width,1) );\n                else if( channels == 4 )\n                    icvCvt_BGRA2RGBA_8u_C4R( data, 0, buffer, 0, cvSize(width,1) );\n\n                m_strm.PutBytes( channels > 1 ? buffer : data, fileStep );\n            }\n\n            stripCounts[i] = (short)(m_strm.GetPos() - stripOffsets[i]);\n            /*assert( stripCounts[i] == uncompressedRowSize ||\n                    stripCounts[i] < uncompressedRowSize &&\n                    i == stripCount - 1);*/\n        }\n\n        if( stripCount > 2 )\n        {\n            stripOffsetsOffset = m_strm.GetPos();\n            for( i = 0; i < stripCount; i++ )\n                m_strm.PutDWord( stripOffsets[i] );\n\n            stripCountsOffset = m_strm.GetPos();\n            for( i = 0; i < stripCount; i++ )\n                m_strm.PutWord( stripCounts[i] );\n        }\n        else if(stripCount == 2)\n        {\n            stripOffsetsOffset = m_strm.GetPos();\n            for (i = 0; i < stripCount; i++)\n            {\n                m_strm.PutDWord (stripOffsets [i]);\n            }\n            stripCountsOffset = stripCounts [0] + (stripCounts [1] << 16);\n        }\n        else\n        {\n            stripOffsetsOffset = stripOffsets[0];\n            stripCountsOffset = stripCounts[0];\n        }\n\n        if( channels > 1 )\n        {\n            bitsPerSample = m_strm.GetPos();\n            m_strm.PutWord(8);\n            m_strm.PutWord(8);\n            m_strm.PutWord(8);\n            if( channels == 4 )\n                m_strm.PutWord(8);\n        }\n\n        directoryOffset = m_strm.GetPos();\n\n        // write header\n        m_strm.PutWord( 9 );\n\n        /* warning: specification 5.0 of Tiff want to have tags in\n           ascending order. This is a non-fatal error, but this cause\n           warning with some tools. So, keep this in ascending order */\n\n        WriteTag( TIFF_TAG_WIDTH, TIFF_TYPE_LONG, 1, width );\n        WriteTag( TIFF_TAG_HEIGHT, TIFF_TYPE_LONG, 1, height );\n        WriteTag( TIFF_TAG_BITS_PER_SAMPLE,\n                  TIFF_TYPE_SHORT, channels, bitsPerSample );\n        WriteTag( TIFF_TAG_COMPRESSION, TIFF_TYPE_LONG, 1, TIFF_UNCOMP );\n        WriteTag( TIFF_TAG_PHOTOMETRIC, TIFF_TYPE_SHORT, 1, channels > 1 ? 2 : 1 );\n\n        WriteTag( TIFF_TAG_STRIP_OFFSETS, TIFF_TYPE_LONG,\n                  stripCount, stripOffsetsOffset );\n\n        WriteTag( TIFF_TAG_SAMPLES_PER_PIXEL, TIFF_TYPE_SHORT, 1, channels );\n        WriteTag( TIFF_TAG_ROWS_PER_STRIP, TIFF_TYPE_LONG, 1, rowsPerStrip );\n        \n        WriteTag( TIFF_TAG_STRIP_COUNTS,\n                  stripCount > 1 ? TIFF_TYPE_SHORT : TIFF_TYPE_LONG,\n                  stripCount, stripCountsOffset );\n\n        m_strm.PutDWord(0);\n        m_strm.Close();\n\n        // write directory offset\n        FILE* f = fopen( m_filename, \"r+b\" );\n        buffer[0] = (uchar)directoryOffset;\n        buffer[1] = (uchar)(directoryOffset >> 8);\n        buffer[2] = (uchar)(directoryOffset >> 16);\n        buffer[3] = (uchar)(directoryOffset >> 24);\n\n        fseek( f, 4, SEEK_SET );\n        fwrite( buffer, 1, 4, f );\n        fclose(f);\n\n        delete[]  stripOffsets;\n        delete[]  stripCounts;\n        delete[] buffer;\n\n        result = true;\n    }\n    return result;\n}\n\n",
                "name": "grfmt_tiff.cpp",
                "path": "external/opencv/otherlibs/highgui/grfmt_tiff.cpp",
                "url": "/github.com/CyFI-Lab-Public/RetroScope/-/blob/external/opencv/otherlibs/highgui/grfmt_tiff.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 209,
                    "offsetAndLengths": [
                        [
                            29,
                            16
                        ]
                    ],
                    "preview": "                        ok = TIFFReadRGBATile( tif, x, y, (uint32*)buffer );"
                }
            ],
            "repository": {
                "name": "github.com/CyFI-Lab-Public/RetroScope",
                "url": "/github.com/CyFI-Lab-Public/RetroScope"
            }
        }
    ],
    "LimitHit": false,
    "Cloning": [],
    "Missing": [],
    "Timedout": [],
    "ResultCount": 96,
    "ElapsedMilliseconds": 978,
    "Alert": {
        "Title": "",
        "Description": "",
        "ProposedQueries": null
    }
}