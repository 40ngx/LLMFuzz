[
    "static int DLL_CALLCONV\nPageCount(FreeImageIO *io, fi_handle handle, void *data) {\n\tif(data) {\n\t\tfi_TIFFIO *fio = (fi_TIFFIO*)data;\n\t\tTIFF *tif = (TIFF *)fio->tif;\n\t\tint nr_ifd = 0;\n\n\t\tdo {\n\t\t\tnr_ifd++;\n\t\t} while (TIFFReadDirectory(tif));\n\t\t\t\t\n\t\treturn nr_ifd;\n\t}\n\n\treturn 0;\n}",
    "EerIO::EerIO(const string & fname, IOMode rw, Decoder &dec)\n:\tImageIO(fname, rw), decoder(dec)\n{\n\tTIFFSetWarningHandler(TIFFOutputWarning);\n\n\ttiff_file = TIFFOpen(filename.c_str(), \"r\");\n\n\tauto acquisition_metadata = read_acquisition_metadata(tiff_file);\n\tacquisition_data_dict = parse_acquisition_data(acquisition_metadata);\n\n\tfor( ; TIFFReadDirectory(tiff_file); )\n\t\tnum_frames = TIFFCurrentDirectory(tiff_file) + 1;\n\n}",
    "void TiffIO::init()\n{\n\tENTERFUNC;\n\n\tif (initialized) {\n\t\treturn;\n\t}\n\n\tinitialized = true;\n\n\tbool is_new_file = false;\n\n\tFILE * tmp_in = sfopen(filename, rw_mode, & is_new_file, true);\n\n\tif (! tmp_in) {\n\t\tthrow ImageReadException(filename, \"open TIFF\");\n\t}\n\n\tif (! is_new_file) {\n\t\tchar buf[64];\n\n\t\tif (fread(buf, sizeof(buf), 1, tmp_in) != 1) {\n\t\t\tthrow ImageReadException(filename, \"first block\");\n\t\t}\n\n\t\tif (!is_valid(&buf)) {\n\t\t\tthrow ImageReadException(filename, \"invalid TIFF\");\n\t\t}\n\n        is_big_endian = (buf[0] == TIFF_BIG_ENDIAN);\n\t}\n\n\tfclose(tmp_in);\n\ttmp_in = 0;\n\n\tTIFFSetWarningHandler(0);\n\n\tif (rw_mode == ImageIO::READ_ONLY) {\n\t\ttiff_file = TIFFOpen(filename.c_str(), \"r\");\n\n\t\tif (! tiff_file) {\n\t\t\tthrow ImageReadException(filename, \"open TIFF\");\n\t\t}\n\n\t\tTIFFGetField(tiff_file, TIFFTAG_BITSPERSAMPLE, &bitspersample);\n\n\t\tif (bitspersample != CHAR_BIT &&\n\t\t\tbitspersample != (CHAR_BIT * sizeof(short)) &&\n\t\t\tbitspersample != (CHAR_BIT * sizeof(float)) ) {\n\n\t\t\tchar desc[256];\n\t\t\tsprintf(desc, \"invalid %d bits. only %d-bit and %d-bit TIFF are supported\",\n\t\t\t\t\tbitspersample, CHAR_BIT, (int)(CHAR_BIT * sizeof(short)));\n\t\t\tthrow ImageReadException(filename, desc);\n\t\t}\n\t}\n\telse {\n\t\ttiff_file = TIFFOpen(filename.c_str(), \"w\");\n\n\t\tif (! tiff_file) {\n\t\t\tthrow ImageReadException(filename, \"open TIFF\");\n\t\t}\n\t}\n\n\tif (tiff_file) {\n\t\tnimg = 0;\n\n\t\tdo {\n\t\t\tnimg++;\n\t\t} while (TIFFReadDirectory(tiff_file));\n\t}\n\n\tEXITFUNC;\n}",
    "int wxTIFFHandler::DoGetImageCount( wxInputStream& stream )\n{\n    TIFF *tif = TIFFwxOpen( stream, \"image\", \"r\" );\n\n    if (!tif)\n        return 0;\n\n    int dircount = 0;  // according to the libtiff docs, dircount should be set to 1 here???\n    do {\n        dircount++;\n    } while (TIFFReadDirectory(tif));\n\n    TIFFClose( tif );\n\n    // NOTE: this function modifies the current stream position but it's ok\n    //       (see wxImageHandler::GetImageCount)\n\n    return dircount;\n}",
    "void LavaVu::readVolumeTIFF(const FilePath& fn)\n{\n#ifdef HAVE_LIBTIFF\n  TIFF* tif = TIFFOpen(fn.full.c_str(), \"r\");\n  if (tif)\n  {\n    unsigned int width, height;\n    size_t npixels;\n    int channels = 4;\n    GLubyte* imageData;\n    int count = 0;\n    TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n    TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n    npixels = width * height;\n    imageData = (GLubyte*)_TIFFmalloc(npixels * channels * sizeof(GLubyte));\n    if (imageData)\n    {\n      json volss = session.global(\"volsubsample\");\n      int d = TIFFNumberOfDirectories(tif);\n      int ds = volss[2];\n      if (d > 1) std::cout << \"TIFF contains \" << d << \" pages, sub-sampling z \" << ds << std::endl;\n      do\n      {\n        if (TIFFReadRGBAImage(tif, width, height, (uint32_t*)imageData, 0))\n        {\n          //Subsample\n          if (count % ds != 0) {count++; continue;}\n          readVolumeSlice(fn.base, imageData, width, height, channels, true);\n        }\n        count++;\n      }\n      while (TIFFReadDirectory(tif));\n      _TIFFfree(imageData);\n    }\n    TIFFClose(tif);\n  }\n#else\n  abort_program(\"Require libTIFF to load TIFF images\\n\");\n#endif\n}",
    "bool tImageTIFF::Load(const tString& tiffFile)\n{\n\tClear();\n\n\tif (tSystem::tGetFileType(tiffFile) != tSystem::tFileType::TIFF)\n\t\treturn false;\n\n\tif (!tFileExists(tiffFile))\n\t\treturn false;\n\n\tTIFF* tiff = TIFFOpen(tiffFile.Chr(), \"rb\");\n\tif (!tiff)\n\t\treturn false;\n\n\t// Create all frames.\n\ttPixelFormat srcFormat = tPixelFormat::R8G8B8A8;\n\tdo\n\t{\n\t\tint width = 0; int height = 0;\n\t\tTIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, &width);\n\t\tTIFFGetField(tiff, TIFFTAG_IMAGELENGTH, &height);\n\t\tif ((width <= 0) || (height <= 0))\n\t\t\tbreak;\n\n\t\tint numPixels = width*height;\n\t\tint durationMilliSeconds = ReadSoftwarePageDuration(tiff);\n\n\t\tuint32* pixels = (uint32*)_TIFFmalloc(numPixels * sizeof(uint32));\n\t\tint successCode = TIFFReadRGBAImage(tiff, width, height, pixels, 0);\n\t\tif (!successCode)\n\t\t{\n\t\t\t_TIFFfree(pixels);\n\t\t\tbreak;\n\t\t}\n\n\t\ttFrame* frame = new tFrame;\n\t\tframe->Width = width;\n\t\tframe->Height = height;\n\t\tframe->Pixels = new tPixel4b[width*height];\n\t\tframe->PixelFormatSrc = srcFormat;\n\n\t\t// If duration not set we use a default of 1 second.\n\t\tframe->Duration = (durationMilliSeconds >= 0) ? float(durationMilliSeconds)/1000.0f : 1.0f;\n\n\t\tfor (int p = 0; p < width*height; p++)\n\t\t\tframe->Pixels[p] = pixels[p];\n\n\t\t_TIFFfree(pixels);\n\t\tFrames.Append(frame);\n\t} while (TIFFReadDirectory(tiff));\n\n\tTIFFClose(tiff);\n\tif (Frames.GetNumItems() == 0)\n\t\treturn false;\n\n\tPixelFormatSrc = srcFormat;\n\tPixelFormat = tPixelFormat::R8G8B8A8;\n\n\t// TIFF files are assumed to be in sRGB.\n\tColourProfileSrc = tColourProfile::sRGB;\n\tColourProfile = tColourProfile::sRGB;\n\n\treturn true;\n}",
    "void CqShadowMapOld::ReadMatrices()\n{\n\t// Read the transform matrices.\n\tTqFloat*\tWToC;\n\tTqFloat*\tWToS;\n\tCqMatrix\tmatWToC, matWToS;\n\n\t// Set the number of shadow maps initially to 0.\n\tm_NumberOfMaps = 0;\n\n\tCqMatrix matCToW;\n\tQGetRenderContextI() ->matSpaceToSpace( \"camera\", \"world\", NULL, NULL, QGetRenderContextI()->Time(), matCToW );\n\n\tTqDouble minz;\n\n\twhile(1)\n\t{\n\t\tTqInt reta = TIFFGetField( m_pImage, TIFFTAG_PIXAR_MATRIX_WORLDTOCAMERA, &WToC );\n\t\tTqInt retb = TIFFGetField( m_pImage, TIFFTAG_PIXAR_MATRIX_WORLDTOSCREEN, &WToS );\n\t\tif ( !reta || !retb )\n\t\t\tSetInvalid();\n\t\telse\n\t\t{\n\t\t\tTqInt r, c;\n\t\t\tfor ( r = 0; r < 4; r++ )\n\t\t\t{\n\t\t\t\tfor ( c = 0; c < 4; c++ )\n\t\t\t\t{\n\t\t\t\t\tmatWToC[ r ][ c ] = WToC[ ( r * 4 ) + c ];\n\t\t\t\t\tmatWToS[ r ][ c ] = WToS[ ( r * 4 ) + c ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Set the matrixes to general, not Identity as default.\n\t\tmatWToC.SetfIdentity( false );\n\t\tmatWToS.SetfIdentity( false );\n\n\t\tmatWToC *= matCToW;\n\t\tmatWToS *= matCToW;\n\n\t\t// Generate normal conversion matrices to save time.\n\t\tCqMatrix matITTCToL = matWToC;\n\t\tmatITTCToL[ 3 ][ 0 ] = matITTCToL[ 3 ][ 1 ] = matITTCToL[ 3 ][ 2 ] = matITTCToL[ 0 ][ 3 ] = matITTCToL[ 1 ][ 3 ] = matITTCToL[ 2 ][ 3 ] = 0.0;\n\t\tmatITTCToL[ 3 ][ 3 ] = 1.0;\n\t\tmatITTCToL.Inverse();\n\t\tmatITTCToL.Transpose();\n\n\t\tm_WorldToCameraMatrices.push_back( matWToC );\n\t\tm_WorldToScreenMatrices.push_back( matWToS );\n\t\tm_ITTCameraToLightMatrices.push_back( matITTCToL );\n\n\t\tif (TIFFGetField( m_pImage, TIFFTAG_SMINSAMPLEVALUE, &minz ))\n\t\t{\n\t\t\tm_MinZ.push_back( minz );\n\t\t}\n    \n\t\tm_NumberOfMaps++;\t// Increment the number of maps.\n\n\t\tif( TIFFReadDirectory( m_pImage ) == 0 )\n\t\t\tbreak;\n\t}\n}",
    "void TPTImage::loadImageInfo( int seq, int ang )\n{\n  tdir_t current_dir;\n  int count = 0;\n  uint16_t colour, samplesperpixel, bitspersample, sampleformat;\n  double *sminvalue = NULL, *smaxvalue = NULL;\n  double scale;\n  unsigned int tw, th, w, h;\n  string filename;\n  const char *tmp = NULL;\n\n  currentX = seq;\n  currentY = ang;\n\n  // Get various essential image parameters\n  TIFFGetField( tiff, TIFFTAG_IMAGEWIDTH, &w );\n  TIFFGetField( tiff, TIFFTAG_IMAGELENGTH, &h );\n  TIFFGetField( tiff, TIFFTAG_SAMPLESPERPIXEL, &samplesperpixel );\n  TIFFGetField( tiff, TIFFTAG_BITSPERSAMPLE, &bitspersample );\n  TIFFGetField( tiff, TIFFTAG_PHOTOMETRIC, &colour );\n  TIFFGetField( tiff, TIFFTAG_SAMPLEFORMAT, &sampleformat );\n  TIFFGetField( tiff, TIFFTAG_XRESOLUTION, &dpi_x );\n  TIFFGetField( tiff, TIFFTAG_YRESOLUTION, &dpi_y );\n  TIFFGetField( tiff, TIFFTAG_RESOLUTIONUNIT, &dpi_units );\n\n  // If image is untiled, set tile sizes to zero\n  if( TIFFGetField( tiff, TIFFTAG_TILEWIDTH, &tw ) == 0 ) tw = 0;\n  if( TIFFGetField( tiff, TIFFTAG_TILEWIDTH, &th ) == 0 ) th = 0;\n\n  // Units for libtiff are 1=unknown, 2=DPI and 3=pixels/cm, whereas we want 0=unknown, 1=DPI and 2=pixels/cm\n  dpi_units--;\n\n  // We have to do this conversion explicitly to avoid problems on Mac OS X\n  channels = (unsigned int) samplesperpixel;\n  bpc = (unsigned int) bitspersample;\n  sampleType = (sampleformat==3) ? SampleType::FLOATINGPOINT : SampleType::FIXEDPOINT;\n\n  // Check for the no. of resolutions in the pyramidal image\n  current_dir = TIFFCurrentDirectory( tiff );\n\n  // In order to get our list of image sizes, make sure we start in the first TIFF directory\n  if( current_dir != 0 ){\n    if( !TIFFSetDirectory( tiff, 0 ) ) throw file_error( \"TPTImage :: TIFFSetDirectory() failed\" );\n  }\n\n\n  // Empty any existing list of available resolution sizes\n  image_widths.clear();\n  image_heights.clear();\n  tile_widths.clear();\n  tile_heights.clear();\n\n  // Store the list of image dimensions available, starting with the full resolution\n  image_widths.push_back( w );\n  image_heights.push_back( h );\n  tile_widths.push_back( tw );\n  tile_heights.push_back( th );\n\n  // Add this to our list of valid resolutions\n  resolution_ids.push_back( 0 );\n\n  // Sub-resolutions can either be stored within the SubIFDs of a top-level IFD or in separate top-level IFDs.\n  // Check first for sub-resolution levels stored within SubIFDs (as used by OME-TIFF).\n  // In these files, the full resolution image is stored in the first IFD and subsequent\n  // resolutions are stored in SubIFDs\n  loadSubIFDs();\n  subifd_ifd = 0;\n\n  if( subifds.size() > 0 ){\n    // Start from 1 as the top-level IFD already holds the full resolution image\n    for( unsigned int n = 1; n<subifds.size(); n++ ){\n      if( TIFFSetSubDirectory( tiff, subifds[n] ) ){\n\tuint32_t stype;\n\t// Only use valid reduced image subfile types\n\tif( (TIFFGetField( tiff, TIFFTAG_SUBFILETYPE, &stype ) == 1) && (stype == 0x01) ){\n\n\t  // Store exact image size for each resolution level\n\t  TIFFGetField( tiff, TIFFTAG_IMAGEWIDTH, &w );\n\t  TIFFGetField( tiff, TIFFTAG_IMAGELENGTH, &h );\n\t  image_widths.push_back( w );\n\t  image_heights.push_back( h );\n\n\t  // Tile sizes can vary between resolutions\n\t  TIFFGetField( tiff, TIFFTAG_TILEWIDTH, &tw );\n\t  TIFFGetField( tiff, TIFFTAG_TILELENGTH, &th );\n\t  tile_widths.push_back( tw );\n\t  tile_heights.push_back( th );\n\n\t  count++;\n\t}\n      }\n    }\n\n    // If there are valid SubIFDs, tag this image appropriately and check whether we have a stack of images\n    if( count > 0 ){\n      pyramid = SUBIFD;\n      loadStackInfo();\n    }\n\n    // Reset to first TIFF directory\n    if( !TIFFSetDirectory( tiff, 0 ) ) throw file_error( \"TPTImage :: TIFFSetDirectory() failed\" );\n  }\n\n  // If there are no SubIFD resolutions, look for them in the main sequence of IFD TIFF directories\n  if( pyramid == NORMAL ){\n    for( count = 0; TIFFReadDirectory( tiff ); count++ ){\n\n      // Only use tiled IFD directories\n      if( ( TIFFGetField( tiff, TIFFTAG_TILEWIDTH, &tw ) == 1 ) &&\n\t  ( TIFFGetField( tiff, TIFFTAG_TILELENGTH, &th ) == 1 ) ){\n\n\t// Tile sizes can vary between resolutions\n\ttile_widths.push_back( tw );\n\ttile_heights.push_back( th );\n\n\t// Store exact image size for each resolution level\n\tTIFFGetField( tiff, TIFFTAG_IMAGEWIDTH, &w );\n\tTIFFGetField( tiff, TIFFTAG_IMAGELENGTH, &h );\n\timage_widths.push_back( w );\n\timage_heights.push_back( h );\n\n\t// Add this index to our list of valid resolutions\n\tresolution_ids.push_back( count+1 );\n      }\n\n    }\n\n    // Check whether this is in fact a stack from an image too small to have SubIFD resolutions\n    if( (image_widths.size() > 0) && (image_widths[0] == image_widths[1]) && (image_heights[0] == image_heights[1]) ){\n      loadStackInfo();\n      if( stack.size() > 0 ){\n\t// Remove duplicate sizes\n\timage_widths.resize(1);\n\timage_heights.resize(1);\n\ttile_widths.resize(1);\n\ttile_heights.resize(1);\n\tcount = 0;\n      }\n    }\n  }\n\n\n  // Total number of available resolutions\n  numResolutions = image_widths.size();\n\n\n  // Reset the TIFF directory to where it was\n  if( !TIFFSetDirectory( tiff, current_dir ) ) throw file_error( \"TPTImage :: TIFFSetDirectory() failed\" );\n\n\n  // Handle various colour spaces\n  if( colour == PHOTOMETRIC_CIELAB ) colorspace = ColorSpace::CIELAB;\n  else if( colour == PHOTOMETRIC_MINISBLACK ){\n    colorspace = (bpc==1)? ColorSpace::BINARY : ColorSpace::GREYSCALE;\n  }\n  else if( colour == PHOTOMETRIC_PALETTE ){\n    // Watch out for colourmapped images. These are stored as 1 sample per pixel,\n    // but are decoded to 3 channels by libtiff, so declare them as sRGB\n    colorspace = ColorSpace::sRGB;\n    channels = 3;\n  }\n  else if( colour == PHOTOMETRIC_YCBCR ){\n    // JPEG encoded tiles can be subsampled YCbCr encoded. Ask to decode these to RGB\n    TIFFSetField( tiff, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB );\n    colorspace = ColorSpace::sRGB;\n  }\n  else colorspace = ColorSpace::sRGB;\n\n\n  // Get the max and min values for our data (important for float data)\n  // First initialize default values to zero in case\n  double *default_min = new double[channels];\n  double *default_max = new double[channels];\n  for( unsigned int k=0; k<channels; k++ ){\n    default_min[k] = 0.0;\n    default_max[k] = 0.0;\n  }\n\n  // These max and min values can either be single values per image, or as from libtiff > 4.0.2\n  // per channel (see: http://www.asmail.be/msg0055458208.html)\n#ifdef TIFFTAG_PERSAMPLE\n\n  TIFFSetField( tiff, TIFFTAG_PERSAMPLE, PERSAMPLE_MULTI ); // Need to activate per sample mode\n  TIFFGetField( tiff, TIFFTAG_SMINSAMPLEVALUE, &sminvalue );\n  TIFFGetField( tiff, TIFFTAG_SMAXSAMPLEVALUE, &smaxvalue );\n\n  if( !sminvalue ) sminvalue = default_min;\n  if( !smaxvalue ) smaxvalue = default_max;\n\n#else\n  // Set defaults\n  sminvalue = default_min;\n  smaxvalue = default_max;\n\n  // Add the single min/max header value to each channel if tag exists\n  double minmax;\n  if( TIFFGetField( tiff, TIFFTAG_SMINSAMPLEVALUE, &minmax ) == 1 ){\n    for( unsigned int k=0; k<channels; k++ ) sminvalue[k] = minmax;\n  }\n  if( TIFFGetField( tiff, TIFFTAG_SMAXSAMPLEVALUE, &minmax ) == 1 ){\n    for( unsigned int k=0; k<channels; k++ ) smaxvalue[k] = minmax;\n  }\n#endif\n\n  // Make sure our min and max arrays are empty\n  min.clear();\n  max.clear();\n\n  for( unsigned int i=0; i<channels; i++ ){\n    // Set our max to the full bit range if max not set in header\n    if( smaxvalue[i] == 0 ){\n      if( bpc <= 8 ) smaxvalue[i] = 255.0;\n      else if( bpc == 12 ) smaxvalue[i] = 4095.0;\n      else if( bpc == 16 ) smaxvalue[i] = 65535.0;\n      else if( bpc == 32 && sampleType == SampleType::FIXEDPOINT ) smaxvalue[i] = 4294967295.0;\n      else if( bpc == 32 && sampleType == SampleType::FLOATINGPOINT ) smaxvalue[i] = 1.0;  // Set dummy value for float\n    }\n    min.push_back( (float)sminvalue[i] );\n    max.push_back( (float)smaxvalue[i] );\n  }\n  // Don't forget to delete our allocated arrays\n  delete[] default_min;\n  delete[] default_max;\n\n  // Also get some basic metadata\n  if( TIFFGetField( tiff, TIFFTAG_ARTIST, &tmp ) ) metadata.insert( {\"creator\",tmp} );\n  if( TIFFGetField( tiff, TIFFTAG_COPYRIGHT, &tmp ) ) metadata.insert( {\"rights\",tmp} );\n  if( TIFFGetField( tiff, TIFFTAG_DATETIME, &tmp ) ) metadata.insert( {\"date\",tmp} );\n  if( TIFFGetField( tiff, TIFFTAG_IMAGEDESCRIPTION, &tmp ) ) metadata.insert( {\"description\",tmp} );\n  if( TIFFGetField( tiff, TIFFTAG_DOCUMENTNAME, &tmp ) ) metadata.insert( {\"title\",tmp} );\n  if( TIFFGetField( tiff, TIFFTAG_PAGENAME, &tmp ) ) metadata.insert( {\"pagename\",tmp} );\n  if( TIFFGetField( tiff, TIFFTAG_SOFTWARE, &tmp ) ) metadata.insert( {\"software\",tmp} );\n  if( TIFFGetField( tiff, TIFFTAG_MAKE, &tmp ) ) metadata.insert( {\"make\",tmp} );\n  if( TIFFGetField( tiff, TIFFTAG_MODEL, &tmp ) ) metadata.insert( {\"model\",tmp} );\n  if( TIFFGetField( tiff, TIFFTAG_XMLPACKET, &count, &tmp ) ) metadata.insert( {\"xmp\",string(tmp,count)} );\n  if( TIFFGetField( tiff, TIFFTAG_ICCPROFILE, &count, &tmp ) ) metadata.insert( {\"icc\",string(tmp,count)} );\n  if( TIFFGetField( tiff, TIFFTAG_STONITS, &scale ) ){\n    char buffer[32];\n    snprintf( buffer, sizeof(buffer), \"%g\", scale );\n    metadata.insert( {\"scale\",buffer} );\n  }\n}",
    "void TPTImage::loadStackInfo()\n{\n  double scale;\n  const char *tmp = NULL;\n\n  // Reset to first TIFF directory\n  if( !TIFFSetDirectory( tiff, 0 ) ) throw file_error( \"TPTImage :: TIFFSetDirectory() failed\" );\n\n  // Start from 1 as horizontalAnglesList is initialized with 0 by default\n  int n = 1;\n\n  // Loop through our IFDs and get the name and scaling factor for each\n  do {\n    uint32_t stype;\n\n    // Stack layers should really be in multi-page type sub file types\n    if( (TIFFGetField( tiff, TIFFTAG_SUBFILETYPE, &stype ) == 1) && (stype == 0x02) ){\n      Stack s;\n      horizontalAnglesList.push_back(n++);\n      if( TIFFGetField( tiff, TIFFTAG_DOCUMENTNAME, &tmp ) ) s.name = string(tmp);\n      if( TIFFGetField( tiff, TIFFTAG_STONITS, &scale ) ) s.scale = (float) scale;\n      stack.push_back( s );\n    }\n  } while( TIFFReadDirectory(tiff) );\n\n  // Need to remove last item from stack list\n  if( horizontalAnglesList.size() > 1 ) horizontalAnglesList.pop_back();\n}",
    "err_info *Desk::test_compare_with_tiff (QString &fname)\n   {\n   max_info *max;\n   cpoint size, true_size;\n   int bpp, pagenum;\n   byte *im;\n   TIFF *tif;\n\tunsigned imagelength;\n\tbyte *buf, *ptr;\n\tunsigned row;\n\tint stride, im_size, tif_size;\n   int config, nstrips;\n   int imageWidth, imageLength, tileWidth, tileLength;\n\n   CALL (max_open (fname.latin1 (), &max));\n\n   QString ext;\n   QString newname = removeExtension (fname, ext);\n\n   newname += \".tif\";\n\n   printf (\"name=%s\\n\", newname.latin1 ());\n\n   tif = TIFFOpen (newname.latin1 (), \"r\");\n\n   // compare each page\n   for (pagenum = 0; pagenum < max_get_pagecount (max); pagenum++)\n      {\n      printf (\"page %d / %d: \", pagenum, max_get_pagecount (max));\n\n\t   if (pagenum && !TIFFReadDirectory(tif))\n\t      {\n\t      printf (\"ran out of pages\\n\");\n\t      exit (1);\n\t      }   err_info *test_decomp_comp (QString &fname);\n\n\n//      printf (\"\\nTIFF\\n\");\n    \tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &imagelength);\n      TIFFGetField(tif, TIFFTAG_PLANARCONFIG, &config);\n   \tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n\t   TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &imageLength);\n//   \tTIFFGetField(tif, TIFFTAG_TILEWIDTH, &tileWidth);\n//   \tTIFFGetField(tif, TIFFTAG_TILELENGTH, &tileLength);\n\n      tileWidth = tileLength = 0;\n\n      nstrips = TIFFNumberOfStrips(tif);\n//      printf (\"strips=%d, image=%dx%d, tile=%dx%d: %d\\n\", nstrips, imageWidth, imageLength,\n//            tileWidth, tileLength, TIFFNumberOfTiles(tif));\n\n    \tstride = ((TIFFScanlineSize(tif) + 3) & ~3);;\n//      stride = imageWidth / 8;\n    \ttif_size = stride * imagelength;\n     \tbuf = (byte *)malloc (tif_size);\n     \tprintf (\"   stride=%d, \", stride);\n   \tfor (row = 0, ptr = buf; row < imagelength; row++, ptr += stride)\n\t      if (TIFFReadScanline(tif, ptr, row) != 1)\n\t         {\n\t         printf (\"\\nreadscanline error\\n\");\n\t         break;\n\t         }\n      CALL (max_get_image (max, pagenum, &size, &true_size, &bpp, &im, &im_size));\n\n   \tfor (row = 0, ptr = buf; row < imagelength; row++, ptr += stride)\n   \t   if (0 != memcmp (ptr, im + (ptr - buf), stride))\n   \t      {\n   \t      printf (\"\\n- error line %d\\n\", row);\n   \t      dump (\"tif\", ptr, stride, im + (ptr - buf));\n   \t      dump (\"max\", im + (ptr - buf), stride, ptr);\n   \t      }\n\n\t   free (buf);\n\t   printf (\"    lines=%d/%d, %d %d\\n\", imagelength, row, im_size, tif_size);\n\t   }\n   TIFFClose (tif);\n   max_close (max);\n\n   return NULL;\n   }",
    "int imageIO::getTiffCount(){\n  int cnt = 0;\n  TIFF * image;\n\n  image = TIFFOpen(filename.c_str(), \"r\");\n\n  if (image != NULL) {\n    do {\n      ++cnt;\n    }while (TIFFReadDirectory(image));\n  }else{\n    cnt = -1;\n  }\n  \n  (void) TIFFClose(image);\n\n  return cnt;\n}",
    "int imageIO::readTiff(){\n  TIFF * image;\n  uint width, height, depth, planesize;\n  uint offset = 0;\n  int unit;\n\n  // Open the TIFF image\n  image = TIFFOpen(filename.c_str(), \"r\");\n\n  // Find the width and height of the image\n  TIFFGetField(image, TIFFTAG_IMAGEWIDTH, &width);\n  TIFFGetField(image, TIFFTAG_IMAGELENGTH, &height);\n  depth = getTiffCount();\n\n  img.height = height;\n  img.width  = width;\n  img.depth  = depth;\n  img.image_stack = (uchar *) malloc (height * width * depth * sizeof(uchar));\n\n  if (img.image_stack == NULL){\n    cerr << \"Error, could not allocate enough memory for image stack.\\n\";\n    return 0;\n  }\n\n  TIFFGetField(image, TIFFTAG_RESOLUTIONUNIT, &unit);\n  TIFFGetField(image, TIFFTAG_XRESOLUTION, &img.xy_dist);\n\n  if (unit == RESUNIT_CENTIMETER){\n    /*\n     * divide by 10,000 to convert from centimeters to microns\n     * take inverse to get microns/pixel\n     */\n    img.xy_dist = (1 / (img.xy_dist / 10000));\n  }else if (unit == RESUNIT_INCH){\n    // divide by 24,500 to convert from inches to microns \n    img.xy_dist = (1 / (img.xy_dist / 25400));\n  }\n  \n  planesize = height * width;\n\n  if (image != NULL) {\n\n    uint bufsize= TIFFStripSize(image);\n    uchar * buf = (uchar *) _TIFFmalloc(bufsize);\n    uint s, ns  = TIFFNumberOfStrips(image);\n    uint *bytecounts;\n\n    do {\n      \n      TIFFGetField(image, TIFFTAG_STRIPBYTECOUNTS, &bytecounts);\n      for (s = 0; s < ns; s++) {\n\t\n\t// check to see if we need to resize the buffer\n\tif (bytecounts[s] != (uint)bufsize){\n\t  buf = (uchar *)_TIFFrealloc(buf, bytecounts[s]);\n\t  if (!buf){\n\t    return 0;\n\t  }\n\t  bufsize = bytecounts[s];\n\t}\n\t\n\t// try to read the strip\n\tif (TIFFReadRawStrip(image, s, buf, bytecounts[s]) < 0){\n\t  // if we encounter an error, free the buffer and return\n\t  _TIFFfree(buf);\n\t  return 0;\n\t}else{\n\t  memcpy(&img.image_stack[offset], buf, (bufsize * sizeof(uchar)));\n\t  offset += bufsize;\n\t}\n      }\n      \n    } while (TIFFReadDirectory(image));\n    _TIFFfree(buf);\n  }\n\n  /*\n    // DEBUG\n    tstrip_t strip;\n    uint32* bc;\n    \n    TIFFGetField(image, TIFFTAG_STRIPBYTECOUNTS, &bc);\n\n      \n    int cnt = 0;\n\n\n    do {\n      cout << \"strip byte counts: \" << bc[cnt++] << endl;\n\n      // Read the image into the memory buffer\n      if(TIFFReadRGBAStrip(image, 0, raster) == 0){\n\tfprintf(stderr, \"Could not read image\\n\");\n\treturn 0;\n      }\n\n      for (i = 0; i < planesize; ++i){\n\timg.image_stack[offset + i] = ((uchar) TIFFGetR(raster[i]));\n      }\n      offset += planesize;\n\n      cout << \"raster[\" << offset - 1 << \"] = \" << TIFFGetR(raster[offset - 1]) << endl;      \n      printf(\"img[%i] = %i\\n\", offset - 1, img.image_stack[offset - 1]);\n\n    } while (TIFFReadDirectory(image));\n\n    free(raster);\n    (void) TIFFClose(image);\n  }\n  */\n  return 1;\n}",
    "TiffFile::TiffFile(absl::string_view path, const int32_t dirIndex) :\ntiffFilePath_(path), currentDirectoryIndex_(dirIndex) {\n  initalized_ = false;\n  tileReadBufSize_  = 0;\n  openslide_level_ = 0;\n  std::string path_str = std::move(static_cast<std::string>(path));\n  tiffFile_ = TIFFOpen(path_str.c_str(), \"r\");\n  if (tiffFile_ == nullptr) {\n      return;\n  }\n  do {\n    // Uncomment to print description of tiff dir to stdio.\n    // TIFFPrintDirectory(tiffFile_, stdout);\n    tiffDir_.push_back(std::move(std::make_unique<TiffDirectory>(tiffFile_)));\n  } while (TIFFReadDirectory(tiffFile_));\n  TIFFSetDirectory(tiffFile_, currentDirectoryIndex_);\n  tileReadBufSize_ = TIFFTileSize(tiffFile_);\n  initalized_ = true;\n}",
    "JNIEXPORT jboolean JNICALL LCTIFFWriter_METHOD(append)\n    ( JNIEnv *env, jobject jLCTIFFWriter, jbyteArray jFileNameUtf8 )\n{\n    TIFF *const destTIFF = getNativePtr( env, jLCTIFFWriter );\n    TIFFSetField( destTIFF, TIFFTAG_PAGENUMBER, 0, 2 );\n    int result = TIFFWriteDirectory( destTIFF );\n    if ( !result )\n        return JNI_FALSE;\n    jbyteArray_to_c const cFileName( env, jFileNameUtf8 );\n    TIFF *const srcTIFF = LC_TIFFOpen( cFileName, \"r\" );\n    if ( !srcTIFF )\n        return JNI_FALSE;\n    if ( isLightZoneLayeredTIFF( srcTIFF ) )\n        TIFFReadDirectory( srcTIFF );\n    result = tiffcp( srcTIFF, destTIFF );\n    TIFFSetField( destTIFF, TIFFTAG_PAGENUMBER, 1, 2 );\n    TIFFClose( srcTIFF );\n    return result ? JNI_TRUE : JNI_FALSE;\n}",
    "JNIEXPORT jboolean JNICALL LCTIFFReader_METHOD(nextDirectory)\n    ( JNIEnv *env, jobject jLCTIFFReader )\n{\n    return TIFFReadDirectory( getNativePtr( env, jLCTIFFReader ) );\n}",
    "ImageMetadataLoader::Status\nTiffReader::readMetadata(\n    QIODevice& device,\n    VirtualFunction1<void, ImageMetadata const&>& out)\n{\n    if (!device.isReadable()) {\n        return ImageMetadataLoader::GENERIC_ERROR;\n    }\n    if (device.isSequential()) {\n        // libtiff needs to be able to seek.\n        return ImageMetadataLoader::GENERIC_ERROR;\n    }\n\n    if (!checkHeader(TiffHeader(readHeader(device)))) {\n        return ImageMetadataLoader::FORMAT_NOT_RECOGNIZED;\n    }\n\n    TiffHandle tif(\n        TIFFClientOpen(\n            \"file\", \"rBm\", &device, &deviceRead, &deviceWrite,\n            &deviceSeek, &deviceClose, &deviceSize,\n            &deviceMap, &deviceUnmap\n        )\n    );\n    if (!tif.handle()) {\n        return ImageMetadataLoader::GENERIC_ERROR;\n    }\n\n    do {\n        out(currentPageMetadata(tif));\n    } while (TIFFReadDirectory(tif.handle()));\n\n    return ImageMetadataLoader::LOADED;\n}",
    "std::unique_ptr<image_list> TIFFFormat::do_read(byte_source* src, ImageFactory* factory, bool is_multi) {\n    tiff_warn_error twe;\n    tif_holder t = read_client(src);\n    std::unique_ptr<image_list> images(new image_list);\n    do {\n        const uint32_t h = tiff_get<uint32_t>(t, TIFFTAG_IMAGELENGTH);\n        const uint32_t w = tiff_get<uint32_t>(t, TIFFTAG_IMAGEWIDTH);\n        const uint16_t nr_samples = tiff_get<uint16_t>(t, TIFFTAG_SAMPLESPERPIXEL);\n        const uint16_t bits_per_sample = tiff_get<uint16_t>(t, TIFFTAG_BITSPERSAMPLE);\n        const int depth = nr_samples > 1 ? nr_samples : -1;\n\n        std::unique_ptr<Image> output = factory->create(bits_per_sample, h, w, depth);\n        if (ImageWithMetadata* metaout = dynamic_cast<ImageWithMetadata*>(output.get())) {\n            std::string description = tiff_get<std::string>(t, TIFFTAG_IMAGEDESCRIPTION, \"\");\n            metaout->set_meta(description);\n        }\n        for (uint32_t r = 0; r != h; ++r) {\n            if(TIFFReadScanline(t.tif, output->rowp_as<byte>(r), r) == -1) {\n                throw CannotReadError(\"imread.imread._tiff: Error reading scanline\");\n            }\n        }\n        images->push_back(std::move(output));\n    } while (is_multi && TIFFReadDirectory(t.tif));\n    return images;\n}",
    "void Compute(OpKernelContext* context) override {\n    const Tensor* input_tensor;\n    OP_REQUIRES_OK(context, context->input(\"input\", &input_tensor));\n\n    std::istringstream input_stream(input_tensor->scalar<tstring>()(),\n                                    std::ios_base::in | std::ios_base::binary);\n\n    std::unique_ptr<TIFF, void (*)(TIFF*)> tiff(\n        XTIFFStreamOpen(\"memory\", &input_stream), [](TIFF* p) {\n          if (p != nullptr) {\n            XTIFFClose(p);\n          }\n        });\n    OP_REQUIRES(context, (tiff.get() != nullptr),\n                errors::InvalidArgument(\"unable to open TIFF from memory\"));\n\n    std::vector<TensorShape> shape;\n    std::vector<DataType> dtype;\n    do {\n      unsigned int height, width;\n      TIFFGetField(tiff.get(), TIFFTAG_IMAGELENGTH, &height);\n      TIFFGetField(tiff.get(), TIFFTAG_IMAGEWIDTH, &width);\n\n      unsigned short channels;\n      TIFFGetField(tiff.get(), TIFFTAG_SAMPLESPERPIXEL, &channels);\n\n      shape.push_back(\n          TensorShape({static_cast<int64>(height), static_cast<int64>(width),\n                       static_cast<int64>(channels)}));\n\n      unsigned short format, bits;\n      if (!TIFFGetField(tiff.get(), TIFFTAG_SAMPLEFORMAT, &format)) {\n        // If format is not defined, then we assume format is SAMPLEFORMAT_UINT\n        format = SAMPLEFORMAT_UINT;\n      }\n      TIFFGetField(tiff.get(), TIFFTAG_BITSPERSAMPLE, &bits);\n      DataType pixel_dtype;\n      switch (format) {\n        case SAMPLEFORMAT_UINT:\n          switch (bits) {\n            case 8:\n              pixel_dtype = DT_UINT8;\n              break;\n            case 16:\n              pixel_dtype = DT_UINT16;\n              break;\n            default:\n              OP_REQUIRES(context, false,\n                          errors::InvalidArgument(\"unsupported bits \", bits,\n                                                  \" for uint\"));\n          }\n          break;\n        case SAMPLEFORMAT_INT:\n          switch (bits) {\n            default:\n              OP_REQUIRES(context, false,\n                          errors::InvalidArgument(\"unsupported bits \", bits,\n                                                  \" for int\"));\n          }\n          break;\n        case SAMPLEFORMAT_IEEEFP:\n          switch (bits) {\n            case 16:\n              pixel_dtype = DT_HALF;\n              break;\n            default:\n              OP_REQUIRES(context, false,\n                          errors::InvalidArgument(\"unsupported bits \", bits,\n                                                  \" for fp\"));\n          }\n          break;\n        default:\n          OP_REQUIRES(context, false,\n                      errors::InvalidArgument(\"unsupported format \", format));\n      }\n      dtype.push_back(pixel_dtype);\n\n      // GeoTIFF specifi information\n      // std::unique_ptr<GTIF, void(*)(GTIF*)> gtif(GTIFNew(tiff.get()),\n      // [](GTIF* p) { if (p != nullptr) { GTIFFree(p); } });\n      // OP_REQUIRES(context, (gtif.get() != nullptr),\n      // errors::InvalidArgument(\"unable to read GeoTIFF information\"));\n      // GTIFPrint(gtif,0,0);\n    } while (TIFFReadDirectory(tiff.get()));\n\n    Tensor* shape_tensor = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(\n                       0, TensorShape({static_cast<int64>(shape.size()), 3}),\n                       &shape_tensor));\n    for (size_t i = 0; i < shape.size(); i++) {\n      shape_tensor->flat<int64>()(i * 3) = shape[i].dim_size(0);\n      shape_tensor->flat<int64>()(i * 3 + 1) = shape[i].dim_size(1);\n      shape_tensor->flat<int64>()(i * 3 + 2) = shape[i].dim_size(2);\n    }\n    Tensor* dtype_tensor = nullptr;\n    OP_REQUIRES_OK(\n        context,\n        context->allocate_output(\n            1, TensorShape({static_cast<int64>(dtype.size())}), &dtype_tensor));\n    for (size_t i = 0; i < dtype.size(); i++) {\n      dtype_tensor->flat<int64>()(i) = dtype[i];\n    }\n  }",
    "uint32_t TIFFCountDirectories(TIFF* tif) {\n    TIFFSetDirectory(tif,0);\n    uint32_t n_images =0;\n    do ++n_images; while (TIFFReadDirectory(tif));\n    TIFFSetDirectory(tif,0);\n    return n_images;\n}",
    "void TEST_AGAINST_LIBTIFF(const std::string& filename, std::vector<TestResult>& test_results) {\r\n#ifdef TINYTIFF_TEST_LIBTIFF\r\n    HighResTimer timer, timer1;\r\n    bool ok=false;\r\n    std::cout<<\"\\n\\nreading '\"<<std::string(filename)<<\"' with tinytiff and libtiff and checking read contents ... filesize = \"<<bytestostr(get_filesize(filename.c_str()))<<\"\\n\";\r\n    test_results.emplace_back();\r\n    test_results.back().name=std::string(\"TEST_AGAINST_LIBTIFF(\")+std::string(filename)+std::string(\")\");\r\n    test_results.back().success=ok=false;\r\n    test_results.back().numImages=0;\r\n    try {\r\n        timer.start();\r\n        std::cout<<\"    libTIFF: opening file with     [duration: \"<<floattounitstr(double(timer.get_time())/1.0e6, \"s\")<<\" ]\\n\";\r\n        TIFF* ltiff=TIFFOpen(filename.c_str(), \"r\");\r\n        if (!ltiff) {\r\n            TESTFAIL(\"libTIFF ERROR: reading (not existent, not accessible or no TIFF file)\", test_results.back())\r\n        } else {\r\n            timer.start();\r\n            uint32_t libTIFF_frames=TIFFCountDirectories(ltiff);\r\n            double duration=timer.get_time();\r\n            std::cout<<\"    libTIFF: frames: \"<<libTIFF_frames<<\"     [duration: \"<<duration<<\" us  =  \"<<floattounitstr(duration/1.0e6, \"s\")<<\" ]\\n\";\r\n            std::cout<<\"    TinyTIFF: opening file with     [duration: \"<<floattounitstr(double(timer.get_time())/1.0e6, \"s\")<<\" ]\\n\";\r\n            TinyTIFFReaderFile* tiffr=TinyTIFFReader_open(filename.c_str());\r\n            if (!tiffr) {\r\n                TESTFAIL(\"TinyTIFF ERROR: reading (not existent, not accessible or no TIFF file)\", test_results.back())\r\n                ok=false;\r\n            } else if (TinyTIFFReader_wasError(tiffr)) {\r\n                TESTFAIL(\"TinyTIFF ERROR: \"<<TinyTIFFReader_getLastError(tiffr)<<\"\", test_results.back())\r\n                ok=false;\r\n            } else {\r\n                timer.start();\r\n                uint32_t tinyTIFF_frames=TinyTIFFReader_countFrames(tiffr);\r\n                duration=timer.get_time();\r\n                std::cout<<\"    TinyTIFF: frames: \"<<tinyTIFF_frames<<\"     [duration: \"<<duration<<\" us  =  \"<<floattounitstr(duration/1.0e6, \"s\")<<\" ]\\n\";\r\n                if (TinyTIFFReader_wasError(tiffr)) {\r\n                    TESTFAIL(\"TinyTIFF ERROR: \"<<TinyTIFFReader_getLastError(tiffr)<<\"\", test_results.back())\r\n                    ok=false;\r\n                } else {\r\n                    if (libTIFF_frames!=tinyTIFF_frames) {\r\n                        TESTFAIL(\"number of frames, read with TinyTIFF (\"<<tinyTIFF_frames<<\") and libTIFF (\"<<libTIFF_frames<<\") are not equal!\", test_results.back())\r\n                        ok=false;\r\n                    } else {\r\n                        timer.start();\r\n                        size_t frame=0;\r\n                        ok=true;\r\n                        do {\r\n                            std::cout<<\"   frame: \"<<frame<<std::endl;\r\n                            uint32_t tinyTIFF_width=TinyTIFFReader_getWidth(tiffr);\r\n                            uint32_t tinyTIFF_height=TinyTIFFReader_getHeight(tiffr);\r\n                            uint16_t tinyTIFF_bitspersample=TinyTIFFReader_getBitsPerSample(tiffr, 0);\r\n                            uint16_t tinyTIFF_samplesperpixel=TinyTIFFReader_getSamplesPerPixel(tiffr);\r\n                            const char* tinyTIFF_imagedesc=TinyTIFFReader_getImageDescription(tiffr);\r\n                            std::cout<<\"     tinyTIFF: width=\"<<tinyTIFF_width<<\", height=\"<<tinyTIFF_height<<\", bitspersample=\"<<tinyTIFF_bitspersample<<\", samplesperpixel=\"<<tinyTIFF_samplesperpixel<<\"\\n\";\r\n                            if (frame==0) {\r\n                                const std::string desc=std::to_string(tinyTIFF_width)+\"x\"+std::to_string(tinyTIFF_height)+\"pix/\"+std::to_string(sizeof(TIMAGESAMPLETYPE)*8)+\"bit/\"+std::to_string(tinyTIFF_samplesperpixel)+\"ch/\"+std::to_string(tinyTIFF_frames)+\"frames\";\r\n                                test_results.back().name=std::string(\"TEST_AGAINST_LIBTIFF(\")+desc+\", \"+std::string(filename)+std::string(\")\");\r\n                            }\r\n\r\n                            uint32_t libTIFF_width=0;\r\n                            uint32_t libTIFF_height=0;\r\n                            uint32_t libTIFF_bitspersample=0;\r\n                            uint32_t libTIFF_samplesperpixel=0;\r\n                            char*libtiff_imagedesc;\r\n                            TIFFGetField(ltiff,TIFFTAG_SAMPLESPERPIXEL,&libTIFF_samplesperpixel);\r\n                            TIFFGetField(ltiff,TIFFTAG_BITSPERSAMPLE,&libTIFF_bitspersample);\r\n                            TIFFGetField(ltiff,TIFFTAG_IMAGEWIDTH,&libTIFF_width);\r\n                            TIFFGetField(ltiff,TIFFTAG_IMAGELENGTH,&libTIFF_height);\r\n                            TIFFGetField(ltiff,TIFFTAG_IMAGEDESCRIPTION,&libtiff_imagedesc);\r\n                            TIFFPrintDirectory(ltiff, stdout,TIFFPRINT_STRIPS|TIFFPRINT_COLORMAP);\r\n                            std::cout<<\"     libTIFF:  width=\"<<libTIFF_width<<\", height=\"<<libTIFF_height<<\", bitspersample=\"<<libTIFF_bitspersample<<\", samplesperpixel=\"<<libTIFF_samplesperpixel<<\"\\n\";\r\n\r\n                            if (tinyTIFF_width!=libTIFF_width) {\r\n                                TESTFAIL(\"in frame \"<<frame<<\": TinyTIFF and libTIFF read different widths (TinyTIFF: \"<<tinyTIFF_width<<\" != libTIFF: \"<<libTIFF_width<<\")\", test_results.back())\r\n                                ok=false;\r\n                                break;\r\n                            }\r\n                            if (tinyTIFF_height!=libTIFF_height) {\r\n                                TESTFAIL(\"in frame \"<<frame<<\": TinyTIFF and libTIFF read different heights (TinyTIFF: \"<<tinyTIFF_height<<\" != libTIFF: \"<<libTIFF_height<<\")\", test_results.back())\r\n                                ok=false;\r\n                                break;\r\n                            }\r\n                            if (tinyTIFF_bitspersample!=libTIFF_bitspersample) {\r\n                                TESTFAIL(\"in frame \"<<frame<<\": TinyTIFF and libTIFF read different bitspersamples (TinyTIFF: \"<<tinyTIFF_bitspersample<<\" != libTIFF: \"<<libTIFF_bitspersample<<\")\", test_results.back())\r\n                                ok=false;\r\n                                break;\r\n                            }\r\n                            if (tinyTIFF_samplesperpixel!=libTIFF_samplesperpixel) {\r\n                                TESTFAIL(\"in frame \"<<frame<<\": TinyTIFF and libTIFF read different samplesperpixels (TinyTIFF: \"<<tinyTIFF_samplesperpixel<<\" != libTIFF: \"<<libTIFF_samplesperpixel<<\")\", test_results.back())\r\n                                ok=false;\r\n                                break;\r\n                            }\r\n                            if (tinyTIFF_imagedesc==nullptr || libtiff_imagedesc==nullptr || strcmp(tinyTIFF_imagedesc, libtiff_imagedesc)!=0) {\r\n                                std::cout<<\"       WARNING in frame \"<<frame<<\": TinyTIFF and libTIFF read different descriptions (TinyTIFF: '\"<<tinyTIFF_imagedesc<<\"' != libTIFF: '\"<<libtiff_imagedesc<<\"')\\n\";\r\n                                //ok=false;\r\n                                //break;\r\n                            }\r\n                            if (ok) {\r\n                                for (size_t sample=0; sample<libTIFF_samplesperpixel; sample++) {\r\n                                    std::vector<TIMAGESAMPLETYPE> tinyTIFF_data(tinyTIFF_width*tinyTIFF_height*sizeof(TIMAGESAMPLETYPE)*2, 0);\r\n                                    TinyTIFFReader_getSampleData(tiffr,tinyTIFF_data.data(), sample);\r\n                                    if (TinyTIFFReader_wasError(tiffr)) {\r\n                                        TESTFAIL(\"TinyTIFF ERROR: reading frame \"<<frame<<\", sample \"<<sample<<\":\"<<TinyTIFFReader_getLastError(tiffr)<<\"\", test_results.back())\r\n                                        ok=false;\r\n                                        break;\r\n                                    }\r\n                                    std::vector<TIMAGESAMPLETYPE> libTIFF_data(libTIFF_width*libTIFF_height*sizeof(TIMAGESAMPLETYPE)*2, 0);\r\n                                    if (!TIFFReadFrame(ltiff, libTIFF_data.data(), sample)) {\r\n                                        TESTFAIL(\"libTIFF ERROR: reading frame \"<<frame<<\", sample \"<<sample<<\"\", test_results.back())\r\n                                        ok=false;\r\n                                        break;\r\n                                    }\r\n                                    for (size_t i=0; i<libTIFF_data.size(); i++) {\r\n                                        if (i<=8) std::cout<<\"          f\"<<frame<<\"s\"<<sample<<\"i\"<<i<<\": tiny=\"<<std::dec<<static_cast<typename atleast_int<TIMAGESAMPLETYPE>::TPrint>(tinyTIFF_data[i])<<\" lib=\"<<static_cast<typename atleast_int<TIMAGESAMPLETYPE>::TPrint>(libTIFF_data[i])<<\"\\n\";\r\n                                        if (libTIFF_data[i]!=tinyTIFF_data[i]) {\r\n                                            TESTFAIL(\"in frame \"<<frame<<\", sample \"<<sample<<\": TinyTIFF and libTIFF read different sample values (I=\"<<i<<\": TinyTIFF: \"<<std::dec<<static_cast<typename atleast_int<TIMAGESAMPLETYPE>::TPrint>(tinyTIFF_data[i])<<\" != libTIFF: \"<<std::dec<<static_cast<typename atleast_int<TIMAGESAMPLETYPE>::TPrint>(libTIFF_data[i])<<\")\", test_results.back())\r\n                                            ok=false;\r\n                                            break;\r\n                                        }\r\n                                    }\r\n                                    if (!ok) {\r\n                                        SAVE_TIFF(std::string(std::string(filename)+\".tinytiff.error_sample\"+std::to_string(sample)+\".tif\").c_str(), tinyTIFF_data.data(), tinyTIFF_width, tinyTIFF_height);\r\n                                        SAVE_TIFF(std::string(std::string(filename)+\".libtiff.error_sample\"+std::to_string(sample)+\".tif\").c_str(), libTIFF_data.data(), tinyTIFF_width, tinyTIFF_height);\r\n                                    }\r\n                                }\r\n                            }\r\n\r\n\r\n                            frame++;\r\n                        } while (ok && TIFFReadDirectory(ltiff) && TinyTIFFReader_readNext(tiffr));\r\n\r\n                        test_results.back().success=ok;\r\n                        test_results.back().numImages=frame;\r\n                        duration=timer.get_time();\r\n                        test_results.back().duration_ms=duration/1.0e3;\r\n                        std::cout<<\"    read and checked all \"<<frame<<\" frames: \"<<((ok)?std::string(\"SUCCESS\"):std::string(\"ERROR\"))<<\"     [duration: \"<<duration<<\" us  =  \"<<floattounitstr(duration/1.0e6, \"s\")<<\" ]\\n\";\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    } catch(...) {\r\n        ok=false;\r\n        std::cout<<\"       CRASH While reading file\\n\";\r\n    }\r\n\r\n    test_results.back().success=ok;\r\n    if (ok) std::cout<<\"  => SUCCESS\\n\";\r\n    else std::cout<<\"  => NOT CORRECTLY READ\\n\";\r\n#endif\r\n}",
    "bool libtiffTestRead(const char* filename, const T* writteneven, const T* writtenodd, uint32_t width, uint32_t height, uint16_t samples=1, uint32_t frames_expected=0, TinyTIFFSampleLayout inputOrg=TinyTIFF_Chunky, std::string* description_out=nullptr)  {\r\n    bool ok=true;\r\n#ifdef TINYTIFF_TEST_LIBTIFF\r\n    TIFF* tif = TIFFOpen(filename, \"r\");\r\n    T* data=(T*)malloc(width*height*sizeof(T));\r\n    if (tif) {\r\n        uint32_t frame=0;\r\n        do {\r\n            uint32_t nx,ny;\r\n            uint16_t ns,bs;\r\n            TIFFGetField(tif,TIFFTAG_IMAGEWIDTH,&nx);\r\n            TIFFGetField(tif,TIFFTAG_IMAGELENGTH,&ny);\r\n            TIFFGetField(tif,TIFFTAG_SAMPLESPERPIXEL,&ns);\r\n            TIFFGetField(tif,TIFFTAG_BITSPERSAMPLE,&bs);\r\n            char* val=NULL;\r\n            TIFFGetField(tif,TIFFTAG_IMAGEDESCRIPTION,&val);\r\n            if (val) {\r\n                std::cout<<\"    ImageDescription(\"<<strlen(val)<<\"):\\n\"<<val<<\"\\n\";\r\n                if (description_out) *description_out=val;\r\n            } else {\r\n                if (description_out) description_out->clear();\r\n            }\r\n            TIFFPrintDirectory(tif, stdout);\r\n            if (nx==width && ny==height && ns==samples && bs==sizeof(T)*8) {\r\n                size_t errcnt=0;\r\n                size_t pixcnt=0;\r\n                for (uint16_t samp=0; samp<samples; samp++) {\r\n                    if (TIFFReadFrame(tif, data, samp)) {\r\n                        ok=true;\r\n                        const T* written=writteneven;\r\n                        if (writtenodd && frame%2==1) written=writtenodd;\r\n                        if (inputOrg==TinyTIFF_Chunky) {\r\n                            for (uint32_t i=0; i<width*height; i++) {\r\n                                if (data[i]!=written[i*samples+samp]) {\r\n                                    ok=false;\r\n                                    errcnt++;\r\n                                    if (errcnt<50) std::cout<<\" -- READ-ERROR: pixel-value differs in frame \"<<frame<<\" for pixel (\"<<i%width<<\",\"<<i/width<<\"): file: \"<<static_cast<typename atleast_int<T>::TPrint>(data[i])<<\" expected: \"<<static_cast<typename atleast_int<T>::TPrint>(written[i*samples+samp])<<\"\\n\";\r\n                                    if (errcnt==50) std::cout<<\" -- READ-ERROR: ...\\n\";\r\n                                } else {\r\n                                    pixcnt++;\r\n                                }\r\n                            }\r\n                        } else {\r\n                            for (uint32_t i=0; i<width*height; i++) {\r\n                                if (data[i]!=written[i+samp*width*height]) {\r\n                                    ok=false;\r\n                                    errcnt++;\r\n                                    if (errcnt<50) std::cout<<\" -- READ-ERROR: pixel-value differs in frame \"<<frame<<\" for pixel (\"<<i%width<<\",\"<<i/width<<\"): file: \"<<static_cast<typename atleast_int<T>::TPrint>(data[i])<<\" expected: \"<<static_cast<typename atleast_int<T>::TPrint>(written[i+samp*width*height])<<\"\\n\";\r\n                                    if (errcnt==50) std::cout<<\" -- READ-ERROR: ...\\n\";\r\n                                } else {\r\n                                    pixcnt++;\r\n                                }\r\n                            }\r\n                        }\r\n                        if (!ok) {\r\n                            std::cout<<\" -- TEST READ WITH LIBTIFF: READ WRONG DATA for \"<<errcnt<<\" pixels in frame \"<<frame<<\"!!!\\n\";\r\n                        }\r\n                    } else {\r\n                        std::cout<<\" -- TEST READ WITH LIBTIFF: COULD NOT READ FRAME \"<<frame<<\"!\\n\";\r\n                        ok=false;\r\n                    }\r\n                }\r\n                if (ok) {\r\n                    std::cout<<\" -- TEST READ WITH LIBTIFF: SUCCESS FOR FRAME \"<<frame<<\"! All \"<<pixcnt<<\" pixels&samples as expected!\\n\";\r\n                }\r\n            } else {\r\n                std::cout<<\" -- TEST READ WITH LIBTIFF: FRAME SIZE OF FRAME \"<<frame<<\" DOES NOT MATCH (width: file:\"<<nx<<\"/expected:\"<<width<<\",   height: file:\"<<ny<<\"/expected:\"<<height<<\",   samples: file:\"<<ns<<\"/expected:\"<<samples<<\",   bitspersample: file:\"<<bs<<\"/expected:\"<<(sizeof(T)*8)<<\")!\\n\";\r\n                ok=false;\r\n            }\r\n            frame++;\r\n        } while (ok && TIFFReadDirectory(tif));\r\n        if (frames_expected>0 && frames_expected!=frame) {\r\n            std::cout<<\" -- ERROR IN TEST READ WITH LIBTIFF: number of frames (\"<<frame<<\")does not match expected number of frames (\"<<frames_expected<<\")\\n\";\r\n            ok=false;\r\n        }\r\n        TIFFClose(tif);\r\n    } else {\r\n        std::cout<<\" -- TEST READ WITH LIBTIFF: COULD NOT OPEN FILE!\\n\";\r\n        ok=false;\r\n    }\r\n    free(data);\r\n#endif\r\n    return ok;\r\n}",
    "int NativeDecoder::getDyrectoryCount()\n{\n    int dircount = 0;\n    do {\n        dircount++;\n    } while (TIFFReadDirectory(image));\n    return dircount;\n}",
    "char *loadTiff3D2Metadata ( char * filename, unsigned int &sz0, unsigned int  &sz1, unsigned int  &sz2, unsigned int  &sz3, int &datatype, int &b_swap, void * &fhandle, int &header_len ) {\r\n\r\n    // 2015-01-30. Alessandro. @ADDED performance (time) measurement in all most time-consuming methods.\r\n    #ifdef _VAA3D_TERAFLY_PLUGIN_MODE\r\n    TERAFLY_TIME_START(TiffLoadMetadata)\r\n    #endif\r\n\r\n\tuint32 XSIZE;\r\n\tuint32 YSIZE;\r\n\tuint16 bpp;\r\n\tuint16 spp;\r\n\tuint16 Cpage;\r\n\tuint16 Npages;\r\n    TIFF *input;\r\n    int check;\r\n\r\n\t//disable warning and error handlers to avoid messages on unrecognized tags\r\n\tTIFFSetWarningHandler(0);\r\n\tTIFFSetErrorHandler(0);\r\n\r\n\tinput=TIFFOpen(filename,\"r\");\r\n\tif (!input)\r\n    {\r\n\t\t//throw iim::IOException(strprintf(\"in IOManager::readTiffMultipage(...): Cannot open the file %s\",finName).c_str());\r\n\t\treturn ((char *) \"Cannot open the file.\");\r\n    }\r\n\r\n\tcheck=TIFFGetField(input, TIFFTAG_IMAGEWIDTH, &XSIZE);\r\n\tif (!check)\r\n\t{\r\n\t\tTIFFClose(input);\r\n\t\t//throw iim::IOException(strprintf(\"in IOManager::readTiffMultipage(...): Image length of %s undefined\\n\", finName).c_str());\r\n\t\treturn ((char *) \"Image width of undefined.\");\r\n\t}\t\t\r\n    \r\n\tcheck=TIFFGetField(input, TIFFTAG_IMAGELENGTH, &YSIZE);\r\n\tif (!check)\r\n\t{\r\n\t\tTIFFClose(input);\r\n\t\t//throw iim::IOException(strprintf(\"in IOManager::readTiffMultipage(...): Image length of %s undefined\\n\", finName).c_str());\r\n\t\treturn ((char *) \"Image length of undefined.\");\r\n\t}\t\t\r\n    \r\n\tcheck=TIFFGetField(input, TIFFTAG_BITSPERSAMPLE, &bpp); \r\n\tif (!check)\r\n\t{\r\n\t\tTIFFClose(input);\r\n\t\t//throw iim::IOException(strprintf(\"in IOManager::readTiffMultipage(...): Undefined bits per sample in %s \\n\", finName).c_str());\r\n\t\treturn ((char *) \"Undefined bits per sample.\");\r\n\t}\r\n\r\n\tcheck=TIFFGetField(input, TIFFTAG_SAMPLESPERPIXEL, &spp);\r\n\tif (!check)\r\n\t{\r\n\t\tspp = 1;\r\n\t\t//TIFFClose(input);\r\n\t\t//throw iim::IOException(strprintf(\"in IOManager::readTiffMultipage(...): Undefined bits per sample in %s \\n\", finName).c_str());\r\n\t\t//return ((char *) \"Undefined samples per pixel.\");\r\n\t}\r\n\r\n\t// 2021-02-10. Giulio. when it is compiled as a Vaa3D plugin does not check the tag TIFFTAG_PAGENUMBER to avoid exceptions on inconsistent files  \r\n\t#ifdef _VAA3D_TERAFLY_PLUGIN_MODE\r\n\tcheck = 0;\r\n\t#else\r\n\t// Onofri\r\n\tcheck=TIFFGetField(input, TIFFTAG_PAGENUMBER, &Cpage, &Npages);\r\n\t#endif\r\n\tif (check!=1 || Npages==0) { // the tag has not been read correctly\r\n\t\t// Add warning?\r\n\t\tNpages = 0;\r\n\t\tdo {\r\n\t\t\tNpages++;\r\n\t\t} while ( TIFFReadDirectory(input) );\r\n\t}\r\n\r\n\tsz0 = XSIZE;\r\n\tsz1 = YSIZE;\r\n\tsz2 = Npages;\r\n\tsz3 = spp;\r\n\tdatatype = bpp/8;\r\n\r\n\t//b_swap = 0;\r\n\tb_swap=TIFFIsByteSwapped(input);\r\n\tfhandle = (void *) input;\r\n\theader_len = -1;\r\n\r\n\t// the file must non be closed (it is responsibility of the caller)\r\n\t//TIFFClose(input);\r\n\r\n    // 2015-01-30. Alessandro. @ADDED performance (time) measurement in all most time-consuming methods.\r\n    #ifdef _VAA3D_TERAFLY_PLUGIN_MODE\r\n    TERAFLY_TIME_STOP(TiffLoadMetadata, tf::IO, tf::strprintf(\"successfully loaded metadata from file \\\"%s\\\"\", filename))\r\n    #endif\r\n\r\n\treturn ((char *) 0);\r\n}",
    "char *readTiff3DFile2Buffer ( void *fhandler, unsigned char *img, unsigned int img_width, unsigned int img_height, unsigned int first, unsigned int last, \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   int b_swap, int downsamplingFactor, int starti, int endi, int startj, int endj ) {\r\n\tuint32 rps;\r\n    uint16 spp, bpp, orientation, photo, comp, planar_config;\r\n    int check, StripsPerImage,LastStripSize;\r\n\tuint32 XSIZE;\r\n\tuint32 YSIZE;\r\n\r\n    TIFF *input = (TIFF *) fhandler;\r\n\r\n\tcheck=TIFFGetField(input, TIFFTAG_BITSPERSAMPLE, &bpp); \r\n\tif (!check)\r\n\t{\r\n\t\treturn ((char *) \"Undefined bits per sample.\");\r\n\t}\r\n\r\n\tcheck=TIFFGetField(input, TIFFTAG_SAMPLESPERPIXEL, &spp);\r\n\tif (!check)\r\n\t{\r\n\t\tspp = 1;\r\n\t\t//return ((char *) \"Undefined samples per pixel.\");\r\n\t}\r\n\r\n\tcheck=TIFFGetField(input, TIFFTAG_PHOTOMETRIC, &photo);\r\n\tif (!check)\r\n\t{\r\n\t\treturn ((char *) \"Cannot determine photometric interpretation.\");\r\n\t}\r\n\r\n\tcheck=TIFFGetField(input, TIFFTAG_COMPRESSION, &comp);\r\n\tif (!check)\r\n\t{\r\n\t\treturn ((char *) \"Cannot determine compression technique.\");\r\n\t}\r\n\r\n\tcheck=TIFFGetField(input, TIFFTAG_PLANARCONFIG, &planar_config);\r\n\tif (!check)\r\n\t{\r\n\t\treturn ((char *) \"Cannot determine planar configuration.\");\r\n\t}\r\n\r\n\tstarti = (starti == -1) ? 0 : starti;\r\n\tendi   = (endi == -1) ? img_height-1 : endi;\r\n\tstartj = (startj == -1) ? 0 : startj;\r\n\tendj   = (endj == -1) ? img_width-1 : endj;\r\n\r\n\tcheck=TIFFIsTiled(input);\r\n\tif (check) // file is internally tiled\r\n\t{\r\n\t\tuint32 tilewidth;\r\n\t\tuint32 tilelength;\r\n\t\tuint32 tiledepth;\r\n\t\ttsize_t tilenum;\r\n\t\ttsize_t tilesize;\r\n\t\ttsize_t tilenum_width;\r\n\t\ttsize_t tilenum_length;\r\n\t\tttile_t tile;\r\n\t\ttdata_t data;\r\n\t\tunsigned char *psrc; // pointer in the tile buffer to the top left pixel of the current block to be copied\r\n\t\tunsigned char *pdst; // pointer in the image buffer to the top left pixel of the current block to be filled\r\n\t\tuint32 stride_src;\r\n\t\tuint32 stride_dst;\r\n\t\tint i; // row index in the slice of the top left pixel of the current block to be filled\r\n\t\tint j; // column index in the slice of the top left pixel of the current block to be filled \r\n\t\tuint32 width; // width of the current block to be filled (in pixels)\r\n\t\tuint32 len; // length of the current block to be filled (in pixels)\r\n\t\tint page;\r\n\r\n\t\t// checks\r\n\t\tif ( TIFFGetField(input, TIFFTAG_TILEDEPTH, &tiledepth) )\r\n\t\t\treturn ((char *) \"Tiling among slices (z direction) not supported.\");\r\n\t\tif ( spp > 1 )\r\n\t\t\tif ( TIFFGetField(input, TIFFTAG_PLANARCONFIG, &planar_config) )\r\n\t\t\t\tif ( planar_config > 1 )\r\n\t\t\t\t\treturn ((char *) \"Non-interleaved multiple channels not supported with tiling.\");\r\n\r\n\t\t// tiling is in x,y only\r\n\t\tTIFFGetField(input, TIFFTAG_TILEWIDTH, &tilewidth);\r\n\t\tTIFFGetField(input, TIFFTAG_TILELENGTH, &tilelength);\r\n\t\ttilenum = TIFFNumberOfTiles(input);\r\n\t\ttilesize = TIFFTileSize(input);\r\n\t\ttilenum_width  = (img_width % tilewidth) ? (img_width / tilewidth) + 1 : img_width / tilewidth;\r\n\t\ttilenum_length = (img_height % tilelength) ? (img_height / tilelength) + 1 : img_height / tilelength;\r\n\r\n\t\tdata = new unsigned char[tilesize];\r\n\t\tstride_src = tilewidth * spp; // width of tile (in bytes)\r\n\t\tstride_dst = (endj - startj + 1) * spp; // width of subregion (in bytes)\r\n\r\n\t\tpage = 0;\r\n\t\tdo {\r\n\r\n\t\t\tpsrc = ((unsigned char *)data) + ((starti % tilelength)*tilewidth + (startj % tilewidth)) * spp; // in the first tile skip (starti % tilelength) rows plus (startj % tilewidth) pixels\r\n\t\t\tpdst = img; // the buffer has the size of the subregion\r\n\t\t\tlen = tilelength - (starti % tilelength); // rows to be copied for the first row of tiles \r\n\t\t\ttile = TIFFComputeTile(input,startj,starti,0,0); // index of the first tile to be copied in the current row of tiles\r\n\t\t\tfor ( i=starti; i<=endi; ) {\r\n\t\t\t\twidth = tilewidth - (startj%tilewidth); // width of the first block to be copied/filled\r\n\t\t\t\tfor ( j=startj; j<=endj; ) {\r\n\t\t\t\t\tTIFFReadEncodedTile(input,tile,data,(tsize_t) -1); // read tile into tile buffer\r\n\t\t\t\t\tcopydata (psrc,stride_src,pdst,stride_dst,(width * spp),len); // copy the block \r\n\t\t\t\t\tj += width;\r\n\t\t\t\t\ttile++; // index of the next tile in the same row of tiles\r\n\t\t\t\t\tpsrc = ((unsigned char *)data) + ((i % tilelength)*tilewidth) * spp; // the block in the next tile begins just after (i % tilelength) rows\r\n\t\t\t\t\tpdst += width * spp; // the block in the image buffer move forward of width pixels\r\n\t\t\t\t\twidth = (((tile%tilenum_width) + 1) * tilewidth <= (endj+1)) ? tilewidth : ((endj+1)%tilewidth); // if the next tile in the row is all within the subregion, width is tilewidth otherwise it is shorter\r\n\t\t\t\t}\r\n\t\t\t\ti += len;\r\n\t\t\t\ttile = TIFFComputeTile(input,startj,i,0,0); // index of the first tile to be copied in the current row of tiles\r\n\t\t\t\tpsrc = ((unsigned char *)data) + ((i % tilelength)*tilewidth + (startj % tilewidth)) * spp; // in the first tile of the next row of tiles skip (i % tilelength) rows plus (startj % tilewidth) pixels\r\n\t\t\t\tpdst = img + ((i-starti) * stride_dst); // the block in the image buffer begin after (i-starti) rows\r\n\t\t\t\tlen = (((tile/tilenum_width) + 1) * tilelength <= (endi+1)) ? tilelength : ((endi+1)%tilelength); // if the next row of tiles is all within the subregion, len is tilelength otherwise it is shorter\r\n\t\t\t}\r\n\r\n\t\t\tpage++;\r\n\t\r\n\t\t}while ( page < static_cast<int>(last-first+1) && TIFFReadDirectory(input));\r\n\r\n\t\treturn (char *) 0;\r\n\t}\r\n\r\n\t// 2018-08-22. Giulio. @CHANGED if TIFFTAG_ROWSPERSTRIP is missing it is assumed that all rows are packed into only one strip\r\n\tif ( !TIFFGetField(input, TIFFTAG_ROWSPERSTRIP, &rps) )\r\n\t\trps = img_height;\t\r\n// \tcheck=TIFFGetField(input, TIFFTAG_ROWSPERSTRIP, &rps);\r\n// \tif (!check)\r\n// \t{\r\n// \t\treturn ((char *) \"Undefined rows per strip.\");\r\n// \t}\r\n\r\n    \r\n\t//check=TIFFGetField(input, TIFFTAG_ORIENTATION, &orientation); \r\n\t//if (!check)\r\n\t//{\r\n\t//\treturn ((char *) \"Image orientation undefined.\");\r\n\t//}\t\r\n    \r\n\tStripsPerImage =  (img_height + rps - 1) / rps;\r\n\tLastStripSize = img_height % rps;\r\n\tif (LastStripSize==0)\r\n\t\tLastStripSize=rps;\r\n\r\n\tunsigned char *buf = img;\r\n\tint page=0;\r\n\r\n\tif ( downsamplingFactor == 1 ) { // read without downsampling\r\n\r\n\t\tif ( starti < 0 || endi >= img_height || startj < 0 || endj >= img_width || starti >= endi || startj >= endj )\r\n\t\t{\r\n\t\t\treturn ((char *) \"Wrong substack indices.\");\r\n\t\t}\r\n\r\n\t\tif ( starti == 0 && endi == (img_height-1) && startj == 0 && endj == (img_width-1) ) { // read whole images from files \r\n\r\n\t\t\tcheck=TIFFSetDirectory(input, first);\r\n\t\t\tif (!check)\r\n\t\t\t{\r\n\t\t\t\treturn ((char *) \"Cannot open the requested first strip.\");\r\n\t\t\t}\r\n\r\n\t\t\tdo{\r\n\r\n\t\t\t\tfor (int i=0; i < StripsPerImage-1; i++){\r\n\t\t\t\t\tif (comp==1) {\r\n\t\t\t\t\t\tTIFFReadRawStrip(input, i, buf, spp * rps * img_width * (bpp/8));\r\n\t\t\t\t\t\tbuf = buf + spp * rps * img_width * (bpp/8);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse{\r\n\t\t\t\t\t\tTIFFReadEncodedStrip(input, i, buf, spp * rps * img_width * (bpp/8));\r\n\t\t\t\t\t\tbuf = buf + spp * rps * img_width * (bpp/8);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (comp==1) {\r\n\t\t\t\t\tTIFFReadRawStrip(input, StripsPerImage-1, buf, spp * LastStripSize * img_width * (bpp/8));\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\tTIFFReadEncodedStrip(input, StripsPerImage-1, buf, spp * LastStripSize * img_width * (bpp/8));\r\n\t\t\t\t}\r\n\t\t\t\tbuf = buf + spp * LastStripSize * img_width * (bpp/8);\r\n\r\n\t\t\t\tpage++;\r\n\t\r\n\t\t\t}while ( page < static_cast<int>(last-first+1) && TIFFReadDirectory(input));//while (TIFFReadDirectory(input));\r\n\r\n\t\t}\r\n\t\telse { // read only a subregion of images from files\r\n\r\n\t\t\tcheck=TIFFGetField(input, TIFFTAG_IMAGEWIDTH, &XSIZE);\r\n\t\t\tif (!check)\r\n\t\t\t{\r\n\t\t\t\treturn ((char *) \"Image width of undefined.\");\r\n\t\t\t}\t\t    \r\n\t\t\tcheck=TIFFGetField(input, TIFFTAG_IMAGELENGTH, &YSIZE);\r\n\t\t\tif (!check)\r\n\t\t\t{\r\n\t\t\t\treturn ((char *) \"Image length of undefined.\");\r\n\t\t\t}\r\n\r\n\t\t\tunsigned char *rowbuf = new unsigned char[spp * rps * XSIZE * (bpp/8)];\r\n\t\t\tunsigned char *bufptr;\r\n\r\n\t\t\tdo{\r\n\t\t\t\tcheck=TIFFSetDirectory(input, first + page);\r\n\t\t\t\tif (!check)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn ((char *) \"Cannot open next requested strip.\");\r\n\t\t\t\t}\r\n\r\n\t\t\t\tint stripIndex = (starti / rps) - 1; // the strip preceeding the first one\r\n\t\t\t\tfor (int i=starti; i <= endi; i++) {\r\n\t\t\t\t\tif ( floor((double)i / rps) > stripIndex ) { // read a new strip\r\n\t\t\t\t\t\tstripIndex = (int)floor((double)i / rps);\r\n\t\t\t\t\t\tif (comp==1) {\r\n\t\t\t\t\t\t\tTIFFReadRawStrip(input, stripIndex, rowbuf, spp * ((stripIndex < StripsPerImage) ? rps :LastStripSize) * XSIZE * (bpp/8));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse{\r\n\t\t\t\t\t\t\tTIFFReadEncodedStrip(input, stripIndex, rowbuf, spp * ((stripIndex < StripsPerImage) ? rps :LastStripSize) * XSIZE * (bpp/8));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbufptr = rowbuf + (i % rps) * (spp * XSIZE * (bpp/8));\r\n\t\t\t\t\tif ( bpp == 8 )\r\n\t\t\t\t\t\tfor (int j=0, j1=startj; j<=(endj-startj); j++, j1++) {\r\n\t\t\t\t\t\t\tfor (int c=0; c<spp; c++) {\r\n\t\t\t\t\t\t\t\tbuf[j * spp + c] = bufptr[j1 * spp + c];\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tfor (int j=0 , j1=startj; j<=(endj-startj); j++, j1++) {\r\n\t\t\t\t\t\t\tfor (int c=0; c<spp; c++) {\r\n\t\t\t\t\t\t\t\t((uint16 *)buf)[j * spp + c] = ((uint16 *)bufptr)[j1 * spp + c];\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\tbuf = buf + spp * (endj-startj+1) * (bpp/8);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tpage++;\r\n\r\n\t\t\t}while ( page < static_cast<int>(last-first+1) );\r\n\r\n\t\t\tdelete []rowbuf;\r\n\r\n\t\t}\r\n\r\n\t\t// input file is assumed to be already open and it is provided as an handler; the file should be closed by caller\r\n\t\t//TIFFClose(input); \r\n\r\n\t\t// 2021. Giulio. The following code seems useless since the condition should be always false\r\n// \t\tif ( page < static_cast<int>(last-first+1) ){\r\n// \t\t\treturn ((char *) \"Cannot read all the pages.\");\r\n// \t\t}\r\n\t}\r\n\telse { // read with downsampling\r\n\r\n\t\t// preliminary checks\r\n\t\tif ( starti != 0 || endi != (img_height-1) || startj != 0 || endj != (img_width-1) ) { // a subregion has been requested \r\n\t\t\treturn ((char *) \"Subregion extraction not supported with downsampling.\");\r\n\t\t}\t\t    \r\n\t\tcheck=TIFFGetField(input, TIFFTAG_IMAGEWIDTH, &XSIZE);\r\n\t\tif (!check)\r\n\t\t{\r\n\t\t\treturn ((char *) \"Image width of undefined.\");\r\n\t\t}\t\t    \r\n\t\tcheck=TIFFGetField(input, TIFFTAG_IMAGELENGTH, &YSIZE);\r\n\t\tif (!check)\r\n\t\t{\r\n\t\t\treturn ((char *) \"Image length of undefined.\");\r\n\t\t}\r\n\r\n\t\tif ( (int)ceil((double)XSIZE/downsamplingFactor) < img_width ) \r\n\t\t{\r\n\t\t\treturn ((char *) \"Requested image width too large.\");\r\n\t\t}\r\n\t\tif ( (int)ceil((double)YSIZE/downsamplingFactor) < img_height ) \r\n\t\t{\r\n\t\t\treturn ((char *) \"Requested image height too large.\");\r\n\t\t}\r\n\r\n\t\tunsigned char *rowbuf = new unsigned char[spp * rps * XSIZE * (bpp/8)];\r\n\t\tunsigned char *bufptr;\r\n\r\n\t\tdo{\r\n\t\t\tcheck=TIFFSetDirectory(input, ((first + page) * downsamplingFactor));\r\n\t\t\tif (!check)\r\n\t\t\t{\r\n\t\t\t\treturn ((char *) \"Cannot open next requested strip.\");\r\n\t\t\t}\r\n\r\n\t\t\tint stripIndex = -1; // the strip preceeding the first one\r\n\t\t\tfor (int i=0; i < img_height; i++) {\r\n\t\t\t\tif ( floor(i * downsamplingFactor / (double)rps) > stripIndex ) { // read a new strip\r\n\t\t\t\t\tstripIndex = (int)floor(i * downsamplingFactor / (double)rps);\r\n\t\t\t\t\tif (comp==1) {\r\n\t\t\t\t\t\tTIFFReadRawStrip(input, stripIndex, rowbuf, spp * ((stripIndex < StripsPerImage) ? rps :LastStripSize) * XSIZE * (bpp/8));\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse{\r\n\t\t\t\t\t\tTIFFReadEncodedStrip(input, stripIndex, rowbuf, spp * ((stripIndex < StripsPerImage) ? rps :LastStripSize) * XSIZE * (bpp/8));\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbufptr = rowbuf + ((i * downsamplingFactor) % rps) * (spp * XSIZE * (bpp/8));\r\n\t\t\t\tif ( bpp == 8 )\r\n\t\t\t\t\tfor (int j=0; j<img_width; j++) {\r\n\t\t\t\t\t\tfor (int c=0; c<spp; c++) {\r\n\t\t\t\t\t\t\tbuf[j * spp + c] = bufptr[j * spp * downsamplingFactor + c];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t\tfor (int j=0; j<img_width; j++) {\r\n\t\t\t\t\t\tfor (int c=0; c<spp; c++) {\r\n\t\t\t\t\t\t\t((uint16 *)buf)[j * spp + c] = ((uint16 *)bufptr)[j * spp * downsamplingFactor + c];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\tbuf = buf + spp * img_width * (bpp/8);\r\n\t\t\t}\r\n\r\n\t\t\tpage++;\r\n\r\n\t\t}while ( page < static_cast<int>(last-first+1) );\r\n\r\n\t\tdelete []rowbuf;\r\n\t}\r\n    \r\n\t// swap the data bytes if necessary \t\r\n\tif (b_swap)\r\n\t{\r\n\t\tint i;\r\n\t\tsize_t total = img_width * img_height * spp * (last-first+1);\r\n\t\tif (bpp/8 == 2)\r\n\t\t{\r\n\t\t\tfor (i=0;i<total; i++)\r\n\t\t\t{\r\n                iim::swap2bytes((void *)(img+2*i));\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (bpp/8 == 4)\r\n\t\t{\r\n\t\t\tfor (i=0;i<total; i++)\r\n\t\t\t{\r\n                iim::swap4bytes((void *)(img+4*i));\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn (char *) 0;\r\n}",
    "void \r\n\tiomanager::tiff3D::readMetadata(\r\n\tstd::string img_path,\t\t// (INPUT)\timage filepath\r\n\tint & img_width,\t\t\t// (OUTPUT) image width  (in pixels)\r\n\tint & img_height,\t\t\t// (OUTPUT) image height (in pixels)\r\n\tint & img_depth,\t\t\t// (OUTPUT) image depth (in pixels)\r\n\tint & img_bytes_x_chan,\t// (OUTPUT) number of bytes per channel\r\n\tint & img_chans,\t\t\t// (OUTPUT) number of channels\r\n\tconst std::string & params)\t// (INPUT)\tadditional parameters <param1=val, param2=val, ...> \r\nthrow (iom::exception)\r\n{\r\n\t/**/iom::debug(iom::LEV3, iom::strprintf(\"img_path = %s, img_width = %d, img_height = %d, img_depth = %d, img_bytes_x_chan = %d, img_chans = %d, params = \\\"%s\\\"\",\r\n\t\timg_path.c_str(), img_width, img_height, img_depth,\timg_bytes_x_chan, img_chans, params.c_str()).c_str(), __iom__current__function__);\r\n\r\n\t//disable warning and error handlers to avoid messages on unrecognized tags\r\n\tTIFFSetWarningHandler(0);\r\n\tTIFFSetErrorHandler(0);\r\n\r\n\tTIFF* input=TIFFOpen(img_path.c_str(),\"r\");\r\n\tif (!input)\r\n\t\tthrow iom::exception(iom::strprintf(\"unable to open image \\\"%s\\\". Possible unsupported format or it isn't an image.\\nSupported format is 3DTIFF\", img_path.c_str()), __iom__current__function__);\r\n\r\n\tif (!TIFFGetField(input, TIFFTAG_IMAGEWIDTH, &img_width))\r\n\t\tthrow iom::exception(iom::strprintf(\"unable to determine 'TIFFTAG_IMAGEWIDTH' from image \\\"%s\\\". \", img_path.c_str()), __iom__current__function__);\r\n\r\n\tif (!TIFFGetField(input, TIFFTAG_IMAGELENGTH, &img_height))\r\n\t\tthrow iom::exception(iom::strprintf(\"unable to determine 'TIFFTAG_IMAGELENGTH' from image \\\"%s\\\". \", img_path.c_str()), __iom__current__function__);\r\n\r\n\tif (!TIFFGetField(input, TIFFTAG_BITSPERSAMPLE, &img_bytes_x_chan))\r\n\t\tthrow iom::exception(iom::strprintf(\"unable to determine 'TIFFTAG_BITSPERSAMPLE' from image \\\"%s\\\". \", img_path.c_str()), __iom__current__function__);\r\n\timg_bytes_x_chan /= 8;\r\n\r\n\tif (!TIFFGetField(input, TIFFTAG_SAMPLESPERPIXEL, &img_chans)) \r\n\t\timg_chans = 1;\r\n\t\t//throw iom::exception(iom::strprintf(\"unable to determine 'TIFFTAG_SAMPLESPERPIXEL' from image \\\"%s\\\". \", img_path.c_str()), __iom__current__function__);\r\n\r\n\t// Onofri\r\n\tuint16 cpage;  // Current page. We do not actually need it.\r\n\tuint16 npages; // Number of pages. \r\n\tint PNcheck=TIFFGetField(input, TIFFTAG_PAGENUMBER, &cpage, &npages);\r\n\tif (!PNcheck || npages==0) { // the tag has not been read correctly\r\n\t\t//iom::warning(iom::strprintf(\"unable to determine 'TIFFTAG_PAGENUMBER' from image file \\\"%s\\\". \", img_path.c_str()).c_str(),__iom__current__function__);\r\n\t\timg_depth = 0;\r\n\t\tdo {\r\n\t\t\timg_depth++;\r\n\t\t} while (TIFFReadDirectory(input));\r\n\t}\r\n\telse\r\n\t\timg_depth = npages;\r\n\r\n\tTIFFClose(input);\r\n}",
    "void \r\n\tiomanager::tiff2D::readMetadata(\r\n\tstd::string img_path,\t\t\t// (INPUT)  image filepath\r\n\tint & img_width,\t\t\t\t// (OUTPUT) image width  (in pixels)\r\n\tint & img_height,\t\t\t\t// (OUTPUT) image height (in pixels)\r\n\tint & img_bytes_x_chan,\t\t\t// (OUTPUT) number of bytes per channel\r\n\tint & img_chans,\t\t\t\t// (OUTPUT) number of channels\r\n\tconst std::string & params)\t\t// (INPUT)  additional parameters <param1=val, param2=val, ...> \r\nthrow (iom::exception)\r\n{\r\n\t/**/iom::debug(iom::LEV3, iom::strprintf(\"img_path = \\\"%s\\\", params = \\\"%s\\\"\",img_path.c_str(), params.c_str()).c_str(), __iom__current__function__);\r\n\r\n\tuint16 bpp;\r\n\tuint16 spp;\r\n\r\n\t//disable warning and error handlers to avoid messages on unrecognized tags\r\n\tTIFFSetWarningHandler(0);\r\n\tTIFFSetErrorHandler(0);\r\n\r\n\tTIFF* input=TIFFOpen(img_path.c_str(),\"r\");\r\n\tif (!input)\r\n\t\tthrow iom::exception(iom::strprintf(\"unable to open image \\\"%s\\\". Possible unsupported format or it isn't an image.\\nSupported format is 2DTIFF\", img_path.c_str()), __iom__current__function__);\r\n\r\n\tif (!TIFFGetField(input, TIFFTAG_IMAGEWIDTH, &img_width))\r\n\t\tthrow iom::exception(iom::strprintf(\"unable to determine 'TIFFTAG_IMAGEWIDTH' from image \\\"%s\\\". \", img_path.c_str()), __iom__current__function__);\r\n\r\n\tif (!TIFFGetField(input, TIFFTAG_IMAGELENGTH, &img_height))\r\n\t\tthrow iom::exception(iom::strprintf(\"unable to determine 'TIFFTAG_IMAGELENGTH' from image \\\"%s\\\". \", img_path.c_str()), __iom__current__function__);\r\n\r\n\tif (!TIFFGetField(input, TIFFTAG_BITSPERSAMPLE, &bpp))\r\n\t\tthrow iom::exception(iom::strprintf(\"unable to determine 'TIFFTAG_BITSPERSAMPLE' from image \\\"%s\\\". \", img_path.c_str()), __iom__current__function__);\r\n\timg_bytes_x_chan = bpp/8;\r\n\r\n\tif (!TIFFGetField(input, TIFFTAG_SAMPLESPERPIXEL, &spp)) \r\n\t\tspp = 1;\r\n\t\t//throw iom::exception(iom::strprintf(\"unable to determine 'TIFFTAG_SAMPLESPERPIXEL' from image \\\"%s\\\". \", img_path.c_str()), __iom__current__function__);\r\n\timg_chans = spp;\r\n\r\n\t// Onofri\r\n\tint img_depth;\t\t\t// image depth (in pixels)\r\n\tuint16 cpage;  // Current page. We do not actually need it.\r\n\tuint16 npages; // Number of pages. \r\n\tint PNcheck=TIFFGetField(input, TIFFTAG_PAGENUMBER, &cpage, &npages);\r\n\tif (!PNcheck || npages==0) { // the tag has not been read correctly\r\n\t\t//iom::warning(iom::strprintf(\"unable to determine 'TIFFTAG_PAGENUMBER' from image file \\\"%s\\\". \", img_path.c_str()).c_str(),__iom__current__function__);\r\n\t\timg_depth = 0;\r\n\t\tdo {\r\n\t\t\timg_depth++;\r\n\t\t} while (TIFFReadDirectory(input));\r\n\t}\r\n\telse\r\n\t\timg_depth = npages;\r\n\r\n\tTIFFClose(input);\r\n\t\r\n\t// check the exception after closing the file\r\n\tif ( img_depth > 1 ) \r\n\t\tthrow iom::exception(iom::strprintf(\"image \\\"%s\\\" has more than one page.\\nSupported format is 2DTIFF\", img_path.c_str()), __iom__current__function__);\r\n}",
    "bool Import_3DTiff_Workspace::sizeOfDomain() {\n    uint32 bitsPerSample = 0;\n    uint16 rgb_check;\n\n    TIFF* input_Image;\n    TIFFSetWarningHandler(nullptr);\n    if((input_Image = TIFFOpen(fileName.c_str(), \"r\")) == nullptr){\n        X=-1;\n        return false;\n    }\n\n\n    if(input_Image) {\n        TIFFGetField(input_Image, TIFFTAG_IMAGEWIDTH, &X);\n        TIFFGetField(input_Image, TIFFTAG_IMAGELENGTH, &Y);\n        TIFFGetField(input_Image, TIFFTAG_BITSPERSAMPLE, &bitsPerSample);\n        TIFFGetField(input_Image, TIFFTAG_SAMPLESPERPIXEL, &rgb_check);\n    }\n\n    if(rgb_check == 3){\n        std::cout << \"Image must be grayscale, input is RGB.\" << std::endl;\n        X=-1;\n        return false;\n    }\n\n    if(bitsPerSample!=8){\n        if(bitsPerSample == 16 || bitsPerSample == 32){\n            std::cout << \"Image must be 8-bit\" << std::endl;\n            X=-1;\n            return false;\n        }\n        else {\n            bitsPerSample = 8;\n        }\n    }\n\n    int page=0;\n    while(true){\n        TIFFSetDirectory(input_Image, page);\n        page++;\n        if(!TIFFReadDirectory(input_Image)) {\n            break;\n        }\n    }\n    Z=page;\n\n    xMin = 0;\n    yMin = 0;\n    zMin = 0;\n    xMax = X-1;\n    yMax = Y-1;\n    zMax = Z-1;\n\n    TIFFClose(input_Image);\n\n    return true;\n}",
    "bool TiffDecoder::nextPage()\n{\n    // Prepare the next page, if any.\n    return !m_tif.empty() &&\n           TIFFReadDirectory(static_cast<TIFF*>(m_tif.get())) &&\n           readHeader();\n}",
    "bool getInfo(TIFF* tif, Vec3c& dimensions, ImageDataType& dataType, size_t& pixelSizeBytes, uint64_t& rawDataOffset, string& reason)\n\t\t\t{\n\t\t\t\t// Read information from all .tif directories and make sure that all of them match.\n\n\t\t\t\tcoord_t imageJDepth;\n\t\t\t\tuint64_t imageJOffset;\n\t\t\t\tif (!getCurrentDirectoryInfo(tif, dimensions, dataType, pixelSizeBytes, imageJDepth, imageJOffset, reason))\n\t\t\t\t\treturn false;\n\n\t\t\t\tcoord_t dirCount = 1;\n\n\t\t\t\tif (TIFFLastDirectory(tif) == 0)\n\t\t\t\t{\n\t\t\t\t\tdo\n\t\t\t\t\t{\n\t\t\t\t\t\tif (TIFFReadDirectory(tif) != 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treason = \"Unable to read TIFF directory. The file is invalid.\";\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (dimensions.z > 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treason = \"TIFF file contains 3D slices.\";\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tVec3c currDims;\n\t\t\t\t\t\tImageDataType currDT;\n\t\t\t\t\t\tsize_t currPixelSizeBytes;\n\t\t\t\t\t\tcoord_t dummy1;\n\t\t\t\t\t\tuint64_t dummy2;\n\t\t\t\t\t\tif (!getCurrentDirectoryInfo(tif, currDims, currDT, currPixelSizeBytes, dummy1, dummy2, reason))\n\t\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t\tif (currDims != dimensions || currDims.z > 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdimensions = Vec3c(0, 0, 0);\n\t\t\t\t\t\t\treason = \"TIFF file contains slices of different dimensions.\";\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (currDT != dataType)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treason = \"TIFF file contains data of unsupported pixel data type.\";\n\t\t\t\t\t\t\tdataType = ImageDataType::Unknown;\n\t\t\t\t\t\t\tcurrPixelSizeBytes = 0;\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (currPixelSizeBytes != pixelSizeBytes)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treason = \"TIFF file contains slices of multiple pixel data types.\";\n\t\t\t\t\t\t\tpixelSizeBytes = 0;\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdirCount++;\n\n\t\t\t\t\t} while (TIFFLastDirectory(tif) == 0);\n\t\t\t\t}\n\n\t\t\t\tTIFFSetDirectory(tif, 0);\n\n\t\t\t\tif (imageJDepth > dirCount)\n\t\t\t\t{\n\t\t\t\t\t// This is an ImageJ fake tiff.\n\t\t\t\t\tdimensions.z = imageJDepth;\n\t\t\t\t\trawDataOffset = imageJOffset;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// This is a normal tiff where each slice is in separate tiff directory.\n\t\t\t\t\tdimensions.z = dirCount;\n\t\t\t\t\trawDataOffset = 0;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}",
    "ILboolean iLoadTiffInternal()\n{\n\tTIFF\t *tif;\n\tuint16\t photometric, planarconfig, orientation;\n\tuint16\t samplesperpixel, bitspersample, *sampleinfo, extrasamples;\n\tuint32\t w, h, d, linesize, tilewidth, tilelength;\n\tILubyte  *pImageData;\n\tILuint\t i, ProfileLen, DirCount = 0;\n\tvoid\t *Buffer;\n\tILimage  *Image, *TempImage;\n\tILushort si;\n        ILfloat  x_position, x_resolution, y_position, y_resolution;\n\t//TIFFRGBAImage img;\n\t//char emsg[1024];\n\n\t// to avoid high order bits garbage when used as shorts\n\tw = h = d = linesize = tilewidth = tilelength = 0;\n\n\tif (iCurImage == NULL) {\n\t\tilSetError(IL_ILLEGAL_OPERATION);\n\t\treturn IL_FALSE;\n\t}\n\n\tTIFFSetWarningHandler (NULL);\n\tTIFFSetErrorHandler   (NULL);\n\n\t//for debugging only\n\t//TIFFSetWarningHandler(warningHandler);\n\t//TIFFSetErrorHandler(errorHandler);\n\n\ttif = iTIFFOpen((char*)\"r\");\n\tif (tif == NULL) {\n\t\tilSetError(IL_COULD_NOT_OPEN_FILE);\n\t\treturn IL_FALSE;\n\t}\n\n\tdo {\n\t\tDirCount++;\n\t} while (TIFFReadDirectory(tif));\n\n\t/*\n\t if (!ilTexImage(1, 1, 1, 1, IL_RGBA, IL_UNSIGNED_BYTE, NULL)) {\n\t\t TIFFClose(tif);\n\t\t return IL_FALSE;\n\t}\n\tImage = iCurImage;\n\tfor (i = 1; i < DirCount; i++) {\n\t\t Image->Next = ilNewImage(1, 1, 1, 1, 1);\n\t\tif (Image->Next == NULL) {\n\t\t\tTIFFClose(tif);\n\t\t\treturn IL_FALSE;\n\t\t}\n\t\tImage = Image->Next;\n\t}\n\tiCurImage->NumNext = DirCount - 1;\n\t*/\n\tImage = NULL;\n\tfor (i = 0; i < DirCount; i++) {\n\t\tTIFFSetDirectory(tif, (tdir_t)i);\n\t\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH,  &w);\n\t\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\n\n\t\tTIFFGetFieldDefaulted(tif, TIFFTAG_IMAGEDEPTH,\t\t&d); //TODO: d is ignored...\n\t\tTIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLESPERPIXEL, &samplesperpixel);\n\t\tTIFFGetFieldDefaulted(tif, TIFFTAG_BITSPERSAMPLE,\t&bitspersample);\n\t\tTIFFGetFieldDefaulted(tif, TIFFTAG_EXTRASAMPLES,\t&extrasamples, &sampleinfo);\n\t\tTIFFGetFieldDefaulted(tif, TIFFTAG_ORIENTATION, \t&orientation);\n\n\t\tlinesize = (uint32)TIFFScanlineSize(tif);\n\t\t\n\t\t//added 2003-08-31\n\t\t//1 bpp tiffs are not neccessarily greyscale, they can\n\t\t//have a palette (photometric == 3)...get this information\n\t\tTIFFGetFieldDefaulted(tif, TIFFTAG_PHOTOMETRIC,  &photometric);\n\t\tTIFFGetFieldDefaulted(tif, TIFFTAG_PLANARCONFIG, &planarconfig);\n\n\t\t//special-case code for frequent data cases that may be read more\n\t\t//efficiently than with the TIFFReadRGBAImage() interface.\n\t\t\n\t\t//added 2004-05-12\n\t\t//Get tile sizes and use TIFFReadRGBAImage() for tiled images for now\n\t\ttilewidth = w; tilelength = h;\n\t\tTIFFGetFieldDefaulted(tif, TIFFTAG_TILEWIDTH,  &tilewidth);\n\t\tTIFFGetFieldDefaulted(tif, TIFFTAG_TILELENGTH, &tilelength);\n\n\n\t\tif (extrasamples == 0\n\t\t\t&& samplesperpixel == 1  //luminance or palette\n\t\t\t&& (bitspersample == 8 || bitspersample == 1 || bitspersample == 16)\n\t\t\t&& (photometric == PHOTOMETRIC_MINISWHITE\n\t\t\t\t|| photometric == PHOTOMETRIC_MINISBLACK\n\t\t\t\t|| photometric == PHOTOMETRIC_PALETTE)\n\t\t\t&& (orientation == ORIENTATION_TOPLEFT || orientation == ORIENTATION_BOTLEFT)\n\t\t\t&& tilewidth == w && tilelength == h\n\t\t\t) {\n\t\t\tILubyte* strip;\n\t\t\ttsize_t stripsize;\n\t\t\tILuint y;\n\t\t\tuint32 rowsperstrip, j, linesread;\n\n\t\t\t//TODO: 1 bit/pixel images should not be stored as 8 bits...\n\t\t\t//(-> add new format)\n\t\t\tif (!Image) {\n\t\t\t\tint type = IL_UNSIGNED_BYTE;\n\t\t\t\tif (bitspersample == 16) type = IL_UNSIGNED_SHORT;\n\t\t\t\tif (!ilTexImage(w, h, 1, 1, IL_LUMINANCE, type, NULL)) {\n\t\t\t\t\tTIFFClose(tif);\n\t\t\t\t\treturn IL_FALSE;\n\t\t\t\t}\n\t\t\t\tImage = iCurImage;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tImage->Next = ilNewImage(w, h, 1, 1, 1);\n\t\t\t\tif (Image->Next == NULL) {\n\t\t\t\t\tTIFFClose(tif);\n\t\t\t\t\treturn IL_FALSE;\n\t\t\t\t}\n\t\t\t\tImage = Image->Next;\n\t\t\t}\n\n\t\t\tif (photometric == PHOTOMETRIC_PALETTE) { //read palette\n\t\t\t\tuint16 *red, *green, *blue;\n\t\t\t\t//ILboolean is16bitpalette = IL_FALSE;\n\t\t\t\tILubyte *entry;\n\t\t\t\tuint32 count = 1 << bitspersample, j;\n\t\t\n\t\t\t\tTIFFGetField(tif, TIFFTAG_COLORMAP, &red, &green, &blue);\n\n\t\t\t\tImage->Format = IL_COLOUR_INDEX;\n\t\t\t\tImage->Pal.PalSize = (count)*3;\n\t\t\t\tImage->Pal.PalType = IL_PAL_RGB24;\n\t\t\t\tImage->Pal.Palette = (ILubyte*)ialloc(Image->Pal.PalSize);\n\t\t\t\tentry = Image->Pal.Palette;\n\t\t\t\tfor (j = 0; j < count; ++j) {\n\t\t\t\t\tentry[0] = (ILubyte)(red[j] >> 8);\n\t\t\t\t\tentry[1] = (ILubyte)(green[j] >> 8);\n\t\t\t\t\tentry[2] = (ILubyte)(blue[j] >> 8);\n\n\t\t\t\t\tentry += 3;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tTIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n\t\t\tstripsize = TIFFStripSize(tif);\n\n\t\t\tstrip = (ILubyte*)ialloc(stripsize);\n\n\t\t\tif (bitspersample == 8 || bitspersample == 16) {\n\t\t\t\tILubyte *dat = Image->Data;\n\t\t\t\tfor (y = 0; y < h; y += rowsperstrip) {\n\t\t\t\t\t//the last strip may contain less data if the image\n\t\t\t\t\t//height is not evenly divisible by rowsperstrip\n\t\t\t\t\tif (y + rowsperstrip > h) {\n\t\t\t\t\t\tstripsize = linesize*(h - y);\n\t\t\t\t\t\tlinesread = h - y;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tlinesread = rowsperstrip;\n\n\t\t\t\t\tif (TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, y, 0), strip, stripsize) == -1) {\n\t\t\t\t\t\tilSetError(IL_LIB_TIFF_ERROR);\n\t\t\t\t\t\tifree(strip);\n\t\t\t\t\t\tTIFFClose(tif);\n\t\t\t\t\t\treturn IL_FALSE;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (photometric == PHOTOMETRIC_MINISWHITE) { //invert channel\n\t\t\t\t\t\tuint32 k, t2;\n\t\t\t\t\t\tfor (j = 0; j < linesread; ++j) {\n\t\t\t\t\t\t\tt2 = j*linesize;\n\t\t\t\t\t\t\t//this works for 16bit images as well: the two bytes\n\t\t\t\t\t\t\t//making up a pixel can be inverted independently\n\t\t\t\t\t\t\tfor (k = 0; k < Image->Bps; ++k)\n\t\t\t\t\t\t\t\tdat[k] = ~strip[t2 + k];\n\t\t\t\t\t\t\tdat += w;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tfor(j = 0; j < linesread; ++j)\n\t\t\t\t\t\t\tmemcpy(&Image->Data[(y + j)*Image->Bps], &strip[j*linesize], Image->Bps);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (bitspersample == 1) {\n\t\t\t\t//TODO: add a native format to devil, so we don't have to\n\t\t\t\t//unpack the values here\n\t\t\t\tILubyte mask, curr, *dat = Image->Data;\n\t\t\t\tuint32 k, sx, t2;\n\t\t\t\tfor (y = 0; y < h; y += rowsperstrip) {\n\t\t\t\t\t//the last strip may contain less data if the image\n\t\t\t\t\t//height is not evenly divisible by rowsperstrip\n\t\t\t\t\tif (y + rowsperstrip > h) {\n\t\t\t\t\t\tstripsize = linesize*(h - y);\n\t\t\t\t\t\tlinesread = h - y;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tlinesread = rowsperstrip;\n\n\t\t\t\t\tif (TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, y, 0), strip, stripsize) == -1) {\n\t\t\t\t\t\tilSetError(IL_LIB_TIFF_ERROR);\n\t\t\t\t\t\tifree(strip);\n\t\t\t\t\t\tTIFFClose(tif);\n\t\t\t\t\t\treturn IL_FALSE;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (j = 0; j < linesread; ++j) {\n\t\t\t\t\t\tk = 0;\n\t\t\t\t\t\tsx = 0;\n\t\t\t\t\t\tt2 = j*linesize;\n\t\t\t\t\t\twhile (k < w) {\n\t\t\t\t\t\t\tcurr = strip[t2 + sx];\n\t\t\t\t\t\t\tif (photometric == PHOTOMETRIC_MINISWHITE)\n\t\t\t\t\t\t\t\tcurr = ~curr;\n\t\t\t\t\t\t\tfor (mask = 0x80; mask != 0 && k < w; mask >>= 1){\n\t\t\t\t\t\t\t\tif((curr & mask) != 0)\n\t\t\t\t\t\t\t\t\tdat[k] = 255;\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tdat[k] = 0;\n\t\t\t\t\t\t\t\t++k;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t++sx;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdat += w;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tifree(strip);\n\n\t\t\tif(orientation == ORIENTATION_TOPLEFT)\n\t\t\t\tImage->Origin = IL_ORIGIN_UPPER_LEFT;\n\t\t\telse if(orientation == ORIENTATION_BOTLEFT)\n\t\t\t\tImage->Origin = IL_ORIGIN_LOWER_LEFT;\n\t\t}\n\t\t//for 16bit rgb images:\n\t\telse if (extrasamples == 0\n\t\t\t&& samplesperpixel == 3\n\t\t\t&& (bitspersample == 8 || bitspersample == 16)\n\t\t\t&& photometric == PHOTOMETRIC_RGB\n\t\t\t&& planarconfig == 1\n\t\t\t&& (orientation == ORIENTATION_TOPLEFT || orientation == ORIENTATION_BOTLEFT)\n\t\t\t&& tilewidth == w && tilelength == h\n\t\t\t) {\n\t\t\tILubyte *strip, *dat;\n\t\t\ttsize_t stripsize;\n\t\t\tILuint y;\n\t\t\tuint32 rowsperstrip, j, linesread;\n\n\t\t\tif (!Image) {\n\t\t\t\tint type = IL_UNSIGNED_BYTE;\n\t\t\t\tif (bitspersample == 16) type = IL_UNSIGNED_SHORT;\n\t\t\t\tif(!ilTexImage(w, h, 1, 3, IL_RGB, type, NULL)) {\n\t\t\t\t\tTIFFClose(tif);\n\t\t\t\t\treturn IL_FALSE;\n\t\t\t\t}\n\t\t\t\tImage = iCurImage;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tImage->Next = ilNewImage(w, h, 1, 1, 1);\n\t\t\t\tif(Image->Next == NULL) {\n\t\t\t\t\tTIFFClose(tif);\n\t\t\t\t\treturn IL_FALSE;\n\t\t\t\t}\n\t\t\t\tImage = Image->Next;\n\t\t\t}\n\n\t\t\tTIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n\t\t\tstripsize = TIFFStripSize(tif);\n\n\t\t\tstrip = (ILubyte*)ialloc(stripsize);\n\n\t\t\tdat = Image->Data;\n\t\t\tfor (y = 0; y < h; y += rowsperstrip) {\n\t\t\t\t//the last strip may contain less data if the image\n\t\t\t\t//height is not evenly divisible by rowsperstrip\n\t\t\t\tif (y + rowsperstrip > h) {\n\t\t\t\t\tstripsize = linesize*(h - y);\n\t\t\t\t\tlinesread = h - y;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tlinesread = rowsperstrip;\n\n\t\t\t\tif (TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, y, 0), strip, stripsize) == -1) {\n\t\t\t\t\tilSetError(IL_LIB_TIFF_ERROR);\n\t\t\t\t\tifree(strip);\n\t\t\t\t\tTIFFClose(tif);\n\t\t\t\t\treturn IL_FALSE;\n\t\t\t\t}\n\n\t\t\t\tfor(j = 0; j < linesread; ++j)\n\t\t\t\t\t\tmemcpy(&Image->Data[(y + j)*Image->Bps], &strip[j*linesize], Image->Bps);\n\t\t\t}\n\n\t\t\tifree(strip);\n\t\t\t\n\t\t\tif(orientation == ORIENTATION_TOPLEFT)\n\t\t\t\tImage->Origin = IL_ORIGIN_UPPER_LEFT;\n\t\t\telse if(orientation == ORIENTATION_BOTLEFT)\n\t\t\t\tImage->Origin = IL_ORIGIN_LOWER_LEFT;\n\t\t}/*\n\t\telse if (extrasamples == 0 && samplesperpixel == 3  //rgb\n\t\t\t\t\t&& (bitspersample == 8 || bitspersample == 1 || bitspersample == 16)\n\t\t\t\t\t&& photometric == PHOTOMETRIC_RGB\n\t\t\t\t\t&& (planarconfig == PLANARCONFIG_CONTIG || planarcon\n\t\t\t\t\t\t&& (orientation == ORIENTATION_TOPLEFT || orientation == ORIENTATION_BOTLEFT)\n\t\t\t\t\t) {\n\t\t}\n\t\t\t\t*/\n\t\telse {\n\t\t\t\t//not direclty supported format\n\t\t\tif(!Image) {\n\t\t\t\tif(!ilTexImage(w, h, 1, 4, IL_RGBA, IL_UNSIGNED_BYTE, NULL)) {\n\t\t\t\t\tTIFFClose(tif);\n\t\t\t\t\treturn IL_FALSE;\n\t\t\t\t}\n\t\t\t\tImage = iCurImage;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tImage->Next = ilNewImage(w, h, 1, 4, 1);\n\t\t\t\tif(Image->Next == NULL) {\n\t\t\t\t\tTIFFClose(tif);\n\t\t\t\t\treturn IL_FALSE;\n\t\t\t\t}\n\t\t\t\tImage = Image->Next;\n\t\t\t}\n\n\t\t\tif (samplesperpixel == 4) {\n\t\t\t\tTIFFGetFieldDefaulted(tif, TIFFTAG_EXTRASAMPLES, &extrasamples, &sampleinfo);\n\t\t\t\tif (!sampleinfo || sampleinfo[0] == EXTRASAMPLE_UNSPECIFIED) {\n\t\t\t\t\tsi = EXTRASAMPLE_ASSOCALPHA;\n\t\t\t\t\tTIFFSetField(tif, TIFFTAG_EXTRASAMPLES, 1, &si);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\t if (!ilResizeImage(Image, Image->Width, Image->Height, 1, 4, 1)) {\n\t\t\t\t TIFFClose(tif);\n\t\t\t\t return IL_FALSE;\n\t\t\t }\n\t\t\t */\n\t\t\tImage->Format = IL_RGBA;\n\t\t\tImage->Type = IL_UNSIGNED_BYTE;\n\t\n\t\t\t// Siigron: added u_long cast to shut up compiler warning\n\t\t\t//2003-08-31: changed flag from 1 (exit on error) to 0 (keep decoding)\n\t\t\t//this lets me view text.tif, but can give crashes with unsupported\n\t\t\t//tiffs...\n\t\t\t//2003-09-04: keep flag 1 for official version for now\n\t\t\tif (!TIFFReadRGBAImage(tif, Image->Width, Image->Height, (uint32*)Image->Data, 0)) {\n\t\t\t\tTIFFClose(tif);\n\t\t\t\tilSetError(IL_LIB_TIFF_ERROR);\n\t\t\t\treturn IL_FALSE;\n\t\t\t}\n\t\t\tImage->Origin = IL_ORIGIN_LOWER_LEFT;  // eiu...dunno if this is right\n\n#ifdef __BIG_ENDIAN__ //TIFFReadRGBAImage reads abgr on big endian, convert to rgba\n\t\t\tEndianSwapData(Image);\n#endif\n\n\t\t\t/*\n\t\t\t The following switch() should not be needed,\n\t\t\t because we take care of the special cases that needed\n\t\t\t these conversions. But since not all special cases\n\t\t\t are handled right now, keep it :)\n\t\t\t */\n\t\t\t//TODO: put switch into the loop??\n\t\t\tTempImage = iCurImage;\n\t\t\tiCurImage = Image; //ilConvertImage() converts iCurImage\n\t\t\tswitch (samplesperpixel)\n\t\t\t{\n\t\t\t\tcase 1:\n\t\t\t\t\t//added 2003-08-31 to keep palettized tiffs colored\n\t\t\t\t\tif(photometric != 3)\n\t\t\t\t\t\tilConvertImage(IL_LUMINANCE, IL_UNSIGNED_BYTE);\n\t\t\t\t\telse //strip alpha as tiff supports no alpha palettes\n\t\t\t\t\t\tilConvertImage(IL_RGB, IL_UNSIGNED_BYTE);\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase 3:\n\t\t\t\t\t//TODO: why the ifdef??\n#ifdef __LITTLE_ENDIAN__\n\t\t\t\t\tilConvertImage(IL_RGB, IL_UNSIGNED_BYTE);\n#endif\t\t\t\n\t\t\t\t\tbreak; \n\t\t\t\t\t\n\t\t\t\tcase 4:\n\t\t\t\t\tpImageData = Image->Data;\n\t\t\t\t\t//removed on 2003-08-26...why was this here? libtiff should and does\n\t\t\t\t\t//take care of these things???\n\t\t\t\t\t/*\t\t\t\n\t\t\t\t\t//invert alpha\n#ifdef __LITTLE_ENDIAN__\n\t\t\t\t\tpImageData += 3;\n#endif\t\t\t\n\t\t\t\t\tfor (i = Image->Width * Image->Height; i > 0; i--) {\n\t\t\t\t\t\t*pImageData ^= 255;\n\t\t\t\t\t\tpImageData += 4;\n\t\t\t\t\t}\n\t\t\t\t\t*/\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tiCurImage = TempImage;\n\t\t\t\n\t\t} //else not directly supported format\n\n\t\tif (TIFFGetField(tif, TIFFTAG_ICCPROFILE, &ProfileLen, &Buffer)) {\n\t\t\tif (Image->Profile && Image->ProfileSize)\n\t\t\t\tifree(Image->Profile);\n\t\t\tImage->Profile = (ILubyte*)ialloc(ProfileLen);\n\t\t\tif (Image->Profile == NULL) {\n\t\t\t\tTIFFClose(tif);\n\t\t\t\treturn IL_FALSE;\n\t\t\t}\n\n\t\t\tmemcpy(Image->Profile, Buffer, ProfileLen);\n\t\t\tImage->ProfileSize = ProfileLen;\n\n\t\t\t//removed on 2003-08-24 as explained in bug 579574 on sourceforge\n\t\t\t//_TIFFfree(Buffer);\n\t\t}\n\n                // dangelo: read offset from tiff tags.\n                //If nothing is stored in these tags, then this must be an \"uncropped\" TIFF \n                //file, in which case, the \"full size\" width/height is the same as the \n                //\"cropped\" width and height\n                //\n                // the full size is currently not supported by DevIL\n                //if (TIFFGetField(tif, TIFFTAG_PIXAR_IMAGEFULLWIDTH, &(c->full_width)) ==\n                //        0)\n                //    (c->full_width = c->cropped_width);\n                //if (TIFFGetField(tif, TIFFTAG_PIXAR_IMAGEFULLLENGTH, &(c->full_height)) ==\n                //        0)\n                //    (c->full_height = c->cropped_height);\n\n                if (TIFFGetField(tif, TIFFTAG_XPOSITION, &x_position) == 0)\n                    x_position = 0;\n                if (TIFFGetField(tif, TIFFTAG_XRESOLUTION, &x_resolution) == 0)\n                    x_resolution = 0;\n                if (TIFFGetField(tif, TIFFTAG_YPOSITION, &y_position) == 0)\n                    y_position = 0;\n                if (TIFFGetField(tif, TIFFTAG_YRESOLUTION, &y_resolution) == 0)\n                    y_resolution = 0;\n\n                //offset in pixels of \"cropped\" image from top left corner of \n                //full image (rounded to nearest integer)\n                Image->OffX = (uint32) ((x_position * x_resolution) + 0.49);\n                Image->OffY = (uint32) ((y_position * y_resolution) + 0.49);\n                \n\n\t\t/*\n\t\t Image = Image->Next;\n\t\t if (Image == NULL)  // Should never happen except when we reach the end, but check anyway.\n\t\t break;\n\t\t */ \n\t} //for tiff directories\n\n\tTIFFClose(tif);\n\n\treturn ilFixImage();\n}",
    "uint TiffPyramidReader::findLevel(const QSize& imageSize)\n{\n    TIFFSetDirectory(_impl->tif.get(), 0);\n\n    uint level = 0;\n    while (getImageSize() > imageSize && TIFFReadDirectory(_impl->tif.get()))\n        ++level;\n\n    return level;\n}",
    "CPLErr GTiffDataset::CleanOverviews()\n\n{\n    CPLAssert( bBase );\n\n    ScanDirectories();\n\n    FlushDirectory();\n    *ppoActiveDSRef = nullptr;\n\n/* -------------------------------------------------------------------- */\n/*      Cleanup overviews objects, and get offsets to all overview      */\n/*      directories.                                                    */\n/* -------------------------------------------------------------------- */\n    std::vector<toff_t> anOvDirOffsets;\n\n    for( int i = 0; i < nOverviewCount; ++i )\n    {\n        anOvDirOffsets.push_back( papoOverviewDS[i]->nDirOffset );\n        delete papoOverviewDS[i];\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Loop through all the directories, translating the offsets       */\n/*      into indexes we can use with TIFFUnlinkDirectory().             */\n/* -------------------------------------------------------------------- */\n    std::vector<uint16> anOvDirIndexes;\n    int iThisOffset = 1;\n\n    TIFFSetDirectory( hTIFF, 0 );\n\n    while( true )\n    {\n        for( int i = 0; i < nOverviewCount; ++i )\n        {\n            if( anOvDirOffsets[i] == TIFFCurrentDirOffset( hTIFF ) )\n            {\n                CPLDebug( \"GTiff\", \"%d -> %d\",\n                          static_cast<int>(anOvDirOffsets[i]), iThisOffset );\n                anOvDirIndexes.push_back( static_cast<uint16>(iThisOffset) );\n            }\n        }\n\n        if( TIFFLastDirectory( hTIFF ) )\n            break;\n\n        TIFFReadDirectory( hTIFF );\n        ++iThisOffset;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Actually unlink the target directories.  Note that we do        */\n/*      this from last to first so as to avoid renumbering any of       */\n/*      the earlier directories we need to remove.                      */\n/* -------------------------------------------------------------------- */\n    while( !anOvDirIndexes.empty() )\n    {\n        TIFFUnlinkDirectory( hTIFF, anOvDirIndexes.back() );\n        anOvDirIndexes.pop_back();\n    }\n\n    CPLFree( papoOverviewDS );\n\n    nOverviewCount = 0;\n    papoOverviewDS = nullptr;\n\n    if( !SetDirectory() )\n        return CE_Failure;\n\n    return CE_None;\n}",
    "GDALDataset *GTiffDataset::OpenDir( GDALOpenInfo * poOpenInfo )\n\n{\n    bool bAllowRGBAInterface = true;\n    const char* pszFilename = poOpenInfo->pszFilename;\n    if( STARTS_WITH_CI(pszFilename, \"GTIFF_RAW:\") )\n    {\n        bAllowRGBAInterface = false;\n        pszFilename += strlen(\"GTIFF_RAW:\");\n    }\n\n    if( !STARTS_WITH_CI(pszFilename, \"GTIFF_DIR:\") ||\n        pszFilename[strlen(\"GTIFF_DIR:\")] == '\\0' )\n    {\n        return nullptr;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Split out filename, and dir#/offset.                            */\n/* -------------------------------------------------------------------- */\n    pszFilename += strlen(\"GTIFF_DIR:\");\n    bool bAbsolute = false;\n\n    if( STARTS_WITH_CI(pszFilename, \"off:\") )\n    {\n        bAbsolute = true;\n        pszFilename += 4;\n    }\n\n    toff_t nOffset = atol(pszFilename);\n    pszFilename += 1;\n\n    while( *pszFilename != '\\0' && pszFilename[-1] != ':' )\n        ++pszFilename;\n\n    if( *pszFilename == '\\0' || nOffset == 0 )\n    {\n        CPLError(\n            CE_Failure, CPLE_OpenFailed,\n            \"Unable to extract offset or filename, should take the form:\\n\"\n            \"GTIFF_DIR:<dir>:filename or GTIFF_DIR:off:<dir_offset>:filename\" );\n        return nullptr;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Try opening the dataset.                                        */\n/* -------------------------------------------------------------------- */\n    if( !GTiffOneTimeInit() )\n        return nullptr;\n\n    VSILFILE* l_fpL = VSIFOpenL(pszFilename, \"r\");\n    if( l_fpL == nullptr )\n        return nullptr;\n    TIFF *l_hTIFF = VSI_TIFFOpen( pszFilename, \"r\", l_fpL );\n    if( l_hTIFF == nullptr )\n    {\n        CPL_IGNORE_RET_VAL(VSIFCloseL(l_fpL));\n        return nullptr;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If a directory was requested by index, advance to it now.       */\n/* -------------------------------------------------------------------- */\n    if( !bAbsolute )\n    {\n        const toff_t nOffsetRequested = nOffset;\n        while( nOffset > 1 )\n        {\n            if( TIFFReadDirectory( l_hTIFF ) == 0 )\n            {\n                XTIFFClose( l_hTIFF );\n                CPLError(\n                    CE_Failure, CPLE_OpenFailed,\n                    \"Requested directory %lu not found.\",\n                    static_cast<long unsigned int>(nOffsetRequested));\n                CPL_IGNORE_RET_VAL(VSIFCloseL(l_fpL));\n                return nullptr;\n            }\n            nOffset--;\n        }\n\n        nOffset = TIFFCurrentDirOffset( l_hTIFF );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Create a corresponding GDALDataset.                             */\n/* -------------------------------------------------------------------- */\n    GTiffDataset *poDS = new GTiffDataset();\n    poDS->SetDescription( poOpenInfo->pszFilename );\n    poDS->osFilename = poOpenInfo->pszFilename;\n    poDS->poActiveDS = poDS;\n    poDS->fpL = l_fpL;\n    poDS->hTIFF = l_hTIFF;\n    poDS->bCloseTIFFHandle = true;\n\n    if( !EQUAL(pszFilename,poOpenInfo->pszFilename)\n        && !STARTS_WITH_CI(poOpenInfo->pszFilename, \"GTIFF_RAW:\") )\n    {\n        poDS->SetPhysicalFilename( pszFilename );\n        poDS->SetSubdatasetName( poOpenInfo->pszFilename );\n        poDS->osFilename = pszFilename;\n    }\n\n    if( poOpenInfo->eAccess == GA_Update )\n    {\n        CPLError(\n            CE_Warning, CPLE_AppDefined,\n            \"Opening a specific TIFF directory is not supported in \"\n            \"update mode. Switching to read-only\" );\n    }\n\n    if( poOpenInfo->AreSiblingFilesLoaded() )\n        poDS->oOvManager.TransferSiblingFiles(\n            poOpenInfo->StealSiblingFiles() );\n\n    if( poDS->OpenOffset( l_hTIFF, &(poDS->poActiveDS),\n                          nOffset, false, GA_ReadOnly,\n                          bAllowRGBAInterface, true ) != CE_None )\n    {\n        delete poDS;\n        return nullptr;\n    }\n\n    return poDS;\n}",
    "void GTiffDataset::ScanDirectories()\n\n{\n/* -------------------------------------------------------------------- */\n/*      We only scan once.  We do not scan for non-base datasets.       */\n/* -------------------------------------------------------------------- */\n    if( !bScanDeferred )\n        return;\n\n    bScanDeferred = false;\n\n    if( !bBase )\n        return;\n\n    if( TIFFLastDirectory( hTIFF ) )\n        return;\n\n    CPLDebug( \"GTiff\", \"ScanDirectories()\" );\n\n/* ==================================================================== */\n/*      Scan all directories.                                           */\n/* ==================================================================== */\n    CPLStringList aosSubdatasets;\n    int iDirIndex = 0;\n\n    FlushDirectory();\n    while( !TIFFLastDirectory( hTIFF )\n           && (iDirIndex == 0 || TIFFReadDirectory( hTIFF ) != 0) )\n    {\n        // Only libtiff 4.0.4 can handle between 32768 and 65535 directories.\n#if !defined(SUPPORTS_MORE_THAN_32768_DIRECTORIES)\n        if( iDirIndex == 32768 )\n            break;\n#endif\n        toff_t nThisDir = TIFFCurrentDirOffset(hTIFF);\n        uint32 nSubType = 0;\n\n        *ppoActiveDSRef = nullptr; // Our directory no longer matches this ds.\n\n        ++iDirIndex;\n\n        if( !TIFFGetField(hTIFF, TIFFTAG_SUBFILETYPE, &nSubType) )\n            nSubType = 0;\n\n        /* Embedded overview of the main image */\n        if( (nSubType & FILETYPE_REDUCEDIMAGE) != 0 &&\n            (nSubType & FILETYPE_MASK) == 0 &&\n            iDirIndex != 1 &&\n            nOverviewCount < 30 /* to avoid DoS */ )\n        {\n            GTiffDataset *poODS = new GTiffDataset();\n            poODS->osFilename = osFilename;\n            if( poODS->OpenOffset( hTIFF, ppoActiveDSRef, nThisDir, false,\n                                   eAccess ) != CE_None\n                || poODS->GetRasterCount() != GetRasterCount() )\n            {\n                delete poODS;\n            }\n            else\n            {\n                CPLDebug( \"GTiff\", \"Opened %dx%d overview.\",\n                          poODS->GetRasterXSize(), poODS->GetRasterYSize());\n                ++nOverviewCount;\n                papoOverviewDS = static_cast<GTiffDataset **>(\n                    CPLRealloc(papoOverviewDS,\n                               nOverviewCount * (sizeof(void*))) );\n                papoOverviewDS[nOverviewCount-1] = poODS;\n                poODS->poBaseDS = this;\n                poODS->bIsOverview_ = true;\n            }\n        }\n        // Embedded mask of the main image.\n        else if( (nSubType & FILETYPE_MASK) != 0 &&\n                 (nSubType & FILETYPE_REDUCEDIMAGE) == 0 &&\n                 iDirIndex != 1 &&\n                 poMaskDS == nullptr )\n        {\n            poMaskDS = new GTiffDataset();\n            poMaskDS->osFilename = osFilename;\n\n            // The TIFF6 specification - page 37 - only allows 1\n            // SamplesPerPixel and 1 BitsPerSample Here we support either 1 or\n            // 8 bit per sample and we support either 1 sample per pixel or as\n            // many samples as in the main image We don't check the value of\n            // the PhotometricInterpretation tag, which should be set to\n            // \"Transparency mask\" (4) according to the specification (page\n            // 36).  However, the TIFF6 specification allows image masks to\n            // have a higher resolution than the main image, what we don't\n            // support here.\n\n            if( poMaskDS->OpenOffset( hTIFF, ppoActiveDSRef, nThisDir,\n                                      false, eAccess ) != CE_None\n                || poMaskDS->GetRasterCount() == 0\n                || !(poMaskDS->GetRasterCount() == 1\n                     || poMaskDS->GetRasterCount() == GetRasterCount())\n                || poMaskDS->GetRasterXSize() != GetRasterXSize()\n                || poMaskDS->GetRasterYSize() != GetRasterYSize()\n                || poMaskDS->GetRasterBand(1)->GetRasterDataType() != GDT_Byte)\n            {\n                delete poMaskDS;\n                poMaskDS = nullptr;\n            }\n            else\n            {\n                CPLDebug( \"GTiff\", \"Opened band mask.\");\n                poMaskDS->poBaseDS = this;\n\n                poMaskDS->bPromoteTo8Bits =\n                    CPLTestBool(\n                        CPLGetConfigOption( \"GDAL_TIFF_INTERNAL_MASK_TO_8BIT\",\n                                            \"YES\" ) );\n            }\n        }\n\n        // Embedded mask of an overview.  The TIFF6 specification allows the\n        // combination of the FILETYPE_xxxx masks.\n        else if( (nSubType & FILETYPE_REDUCEDIMAGE) != 0 &&\n                 (nSubType & FILETYPE_MASK) != 0 &&\n                 iDirIndex != 1 )\n        {\n            GTiffDataset* poDS = new GTiffDataset();\n            poDS->osFilename = osFilename;\n            if( poDS->OpenOffset( hTIFF, ppoActiveDSRef, nThisDir, FALSE,\n                                  eAccess ) != CE_None\n                || poDS->GetRasterCount() == 0\n                || poDS->GetRasterBand(1)->GetRasterDataType() != GDT_Byte)\n            {\n                delete poDS;\n            }\n            else\n            {\n                int i = 0;  // Used after for.\n                for( ; i < nOverviewCount; ++i )\n                {\n                    if( cpl::down_cast<GTiffDataset *>(GDALDataset::FromHandle(\n                           papoOverviewDS[i]))->poMaskDS == nullptr &&\n                        poDS->GetRasterXSize() ==\n                        papoOverviewDS[i]->GetRasterXSize() &&\n                        poDS->GetRasterYSize() ==\n                        papoOverviewDS[i]->GetRasterYSize() &&\n                        (poDS->GetRasterCount() == 1 ||\n                         poDS->GetRasterCount() == GetRasterCount()))\n                    {\n                        CPLDebug(\n                            \"GTiff\", \"Opened band mask for %dx%d overview.\",\n                            poDS->GetRasterXSize(), poDS->GetRasterYSize());\n                        cpl::down_cast<GTiffDataset*>(GDALDataset::FromHandle(\n                            papoOverviewDS[i]))->\n                            poMaskDS = poDS;\n                        poDS->bPromoteTo8Bits =\n                            CPLTestBool(\n                                CPLGetConfigOption(\n                                    \"GDAL_TIFF_INTERNAL_MASK_TO_8BIT\",\n                                    \"YES\" ) );\n                        poDS->poBaseDS = this;\n                        break;\n                    }\n                }\n                if( i == nOverviewCount )\n                {\n                    delete poDS;\n                }\n            }\n        }\n        else if( nSubType == 0 || nSubType == FILETYPE_PAGE )\n        {\n            uint32 nXSize = 0;\n            uint32 nYSize = 0;\n\n            TIFFGetField( hTIFF, TIFFTAG_IMAGEWIDTH, &nXSize );\n            TIFFGetField( hTIFF, TIFFTAG_IMAGELENGTH, &nYSize );\n\n            if( nXSize > INT_MAX || nYSize > INT_MAX )\n            {\n                CPLDebug(\"GTiff\",\n                         \"Skipping directory with too large image: %u x %u\",\n                         nXSize, nYSize);\n            }\n            else\n            {\n                uint16 nSPP = 0;\n                if( !TIFFGetField(hTIFF, TIFFTAG_SAMPLESPERPIXEL, &nSPP ) )\n                    nSPP = 1;\n\n                CPLString osName, osDesc;\n                osName.Printf( \"SUBDATASET_%d_NAME=GTIFF_DIR:%d:%s\",\n                            iDirIndex, iDirIndex, osFilename.c_str() );\n                osDesc.Printf( \"SUBDATASET_%d_DESC=Page %d (%dP x %dL x %dB)\",\n                            iDirIndex, iDirIndex,\n                            static_cast<int>(nXSize),\n                            static_cast<int>(nYSize),\n                            nSPP );\n\n                aosSubdatasets.AddString(osName);\n                aosSubdatasets.AddString(osDesc);\n            }\n        }\n\n        // Make sure we are stepping from the expected directory regardless\n        // of churn done processing the above.\n        if( TIFFCurrentDirOffset(hTIFF) != nThisDir )\n            TIFFSetSubDirectory( hTIFF, nThisDir );\n        *ppoActiveDSRef = nullptr;\n    }\n\n    // Nasty hack. Probably something that should be fixed in libtiff\n    // In case the last directory cycles to the first directory, we have\n    // TIFFCurrentDirOffset(hTIFF) == nDirOffset, but the TIFFReadDirectory()\n    // hasn't done its job, so SetDirectory() would be confused and think it\n    // has nothing to do. To avoid that reset to a fake offset before calling\n    // SetDirectory()\n    // This can also occur if the last directory cycles to the IFD of the\n    // mask dataset and we activate this mask dataset.\n    // So always completely reset\n    TIFFSetSubDirectory( hTIFF, 0 );\n    *ppoActiveDSRef = nullptr;\n    CPL_IGNORE_RET_VAL( SetDirectory() );\n\n    // If we have a mask for the main image, loop over the overviews, and if\n    // they have a mask, let's set this mask as an overview of the main mask.\n    if( poMaskDS != nullptr )\n    {\n        for( int i = 0; i < nOverviewCount; ++i )\n        {\n            if( cpl::down_cast<GTiffDataset *>(GDALDataset::FromHandle(\n                   papoOverviewDS[i]))->poMaskDS != nullptr)\n            {\n                ++poMaskDS->nOverviewCount;\n                poMaskDS->papoOverviewDS = static_cast<GTiffDataset **>(\n                    CPLRealloc(poMaskDS->papoOverviewDS,\n                               poMaskDS->nOverviewCount * (sizeof(void*))) );\n                poMaskDS->papoOverviewDS[poMaskDS->nOverviewCount-1] =\n                    cpl::down_cast<GTiffDataset*>(GDALDataset::FromHandle(\n                        papoOverviewDS[i]))->poMaskDS;\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Only keep track of subdatasets if we have more than one         */\n/*      subdataset (pair).                                              */\n/* -------------------------------------------------------------------- */\n    if( aosSubdatasets.size() > 2 )\n    {\n        oGTiffMDMD.SetMetadata( aosSubdatasets.List(), \"SUBDATASETS\" );\n    }\n}",
    "bool TiffDecoder::nextPage()\n{\n    // Prepare the next page, if any.\n    return m_tif &&\n           TIFFReadDirectory(static_cast<TIFF*>(m_tif)) &&\n           readHeader();\n}",
    "std::unique_ptr<GTiffGrid> GTiffDataset::nextGrid() {\n    if (!m_hasNextGrid)\n        return nullptr;\n    if (m_nextDirOffset) {\n        TIFFSetSubDirectory(m_hTIFF, m_nextDirOffset);\n    }\n\n    uint32 width = 0;\n    uint32 height = 0;\n    TIFFGetField(m_hTIFF, TIFFTAG_IMAGEWIDTH, &width);\n    TIFFGetField(m_hTIFF, TIFFTAG_IMAGELENGTH, &height);\n    if (width == 0 || height == 0 || width > INT_MAX || height > INT_MAX) {\n        pj_log(m_ctx, PJ_LOG_ERROR, \"Invalid image size\");\n        return nullptr;\n    }\n\n    uint16 samplesPerPixel = 0;\n    if (!TIFFGetField(m_hTIFF, TIFFTAG_SAMPLESPERPIXEL, &samplesPerPixel)) {\n        pj_log(m_ctx, PJ_LOG_ERROR, \"Missing SamplesPerPixel tag\");\n        return nullptr;\n    }\n    if (samplesPerPixel == 0) {\n        pj_log(m_ctx, PJ_LOG_ERROR, \"Invalid SamplesPerPixel value\");\n        return nullptr;\n    }\n\n    uint16 bitsPerSample = 0;\n    if (!TIFFGetField(m_hTIFF, TIFFTAG_BITSPERSAMPLE, &bitsPerSample)) {\n        pj_log(m_ctx, PJ_LOG_ERROR, \"Missing BitsPerSample tag\");\n        return nullptr;\n    }\n\n    uint16 planarConfig = 0;\n    if (!TIFFGetField(m_hTIFF, TIFFTAG_PLANARCONFIG, &planarConfig)) {\n        pj_log(m_ctx, PJ_LOG_ERROR, \"Missing PlanarConfig tag\");\n        return nullptr;\n    }\n\n    uint16 sampleFormat = 0;\n    if (!TIFFGetField(m_hTIFF, TIFFTAG_SAMPLEFORMAT, &sampleFormat)) {\n        pj_log(m_ctx, PJ_LOG_ERROR, \"Missing SampleFormat tag\");\n        return nullptr;\n    }\n\n    TIFFDataType dt;\n    if (sampleFormat == SAMPLEFORMAT_INT && bitsPerSample == 16)\n        dt = TIFFDataType::Int16;\n    else if (sampleFormat == SAMPLEFORMAT_UINT && bitsPerSample == 16)\n        dt = TIFFDataType::UInt16;\n    else if (sampleFormat == SAMPLEFORMAT_INT && bitsPerSample == 32)\n        dt = TIFFDataType::Int32;\n    else if (sampleFormat == SAMPLEFORMAT_UINT && bitsPerSample == 32)\n        dt = TIFFDataType::UInt32;\n    else if (sampleFormat == SAMPLEFORMAT_IEEEFP && bitsPerSample == 32)\n        dt = TIFFDataType::Float32;\n    else if (sampleFormat == SAMPLEFORMAT_IEEEFP && bitsPerSample == 64)\n        dt = TIFFDataType::Float64;\n    else {\n        pj_log(\n            m_ctx, PJ_LOG_ERROR,\n            \"Unsupported combination of SampleFormat and BitsPerSample values\");\n        return nullptr;\n    }\n\n    uint16 photometric = PHOTOMETRIC_MINISBLACK;\n    if (!TIFFGetField(m_hTIFF, TIFFTAG_PHOTOMETRIC, &photometric))\n        photometric = PHOTOMETRIC_MINISBLACK;\n    if (photometric != PHOTOMETRIC_MINISBLACK) {\n        pj_log(m_ctx, PJ_LOG_ERROR, \"Unsupported Photometric value\");\n        return nullptr;\n    }\n\n    uint16 compression = COMPRESSION_NONE;\n    if (!TIFFGetField(m_hTIFF, TIFFTAG_COMPRESSION, &compression))\n        compression = COMPRESSION_NONE;\n\n    if (compression != COMPRESSION_NONE &&\n        !TIFFIsCODECConfigured(compression)) {\n        pj_log(m_ctx, PJ_LOG_ERROR,\n               \"Cannot open TIFF file due to missing codec.\");\n        return nullptr;\n    }\n    // We really don't want to try dealing with old-JPEG images\n    if (compression == COMPRESSION_OJPEG) {\n        pj_log(m_ctx, PJ_LOG_ERROR, \"Unsupported compression method.\");\n        return nullptr;\n    }\n\n    const auto blockSize = TIFFIsTiled(m_hTIFF) ? TIFFTileSize64(m_hTIFF)\n                                                : TIFFStripSize64(m_hTIFF);\n    if (blockSize == 0 || blockSize > 64 * 1024 * 2014) {\n        pj_log(m_ctx, PJ_LOG_ERROR, \"Unsupported block size.\");\n        return nullptr;\n    }\n\n    unsigned short count = 0;\n    unsigned short *geokeys = nullptr;\n    bool pixelIsArea = false;\n\n    ExtentAndRes extent;\n    extent.isGeographic = true;\n\n    if (!TIFFGetField(m_hTIFF, TIFFTAG_GEOKEYDIRECTORY, &count, &geokeys)) {\n        pj_log(m_ctx, PJ_LOG_DEBUG_MINOR, \"No GeoKeys tag\");\n    } else {\n        if (count < 4 || (count % 4) != 0) {\n            pj_log(m_ctx, PJ_LOG_ERROR,\n                   \"Wrong number of values in GeoKeys tag\");\n            return nullptr;\n        }\n\n        if (geokeys[0] != 1) {\n            pj_log(m_ctx, PJ_LOG_ERROR, \"Unsupported GeoTIFF major version\");\n            return nullptr;\n        }\n        // We only know that we support GeoTIFF 1.0 and 1.1 at that time\n        if (geokeys[1] != 1 || geokeys[2] > 1) {\n            pj_log(m_ctx, PJ_LOG_DEBUG_MINOR,\n                   \"GeoTIFF %d.%d possibly not handled\", geokeys[1],\n                   geokeys[2]);\n        }\n\n        for (unsigned int i = 4; i + 3 < count; i += 4) {\n            constexpr unsigned short GTModelTypeGeoKey = 1024;\n            constexpr unsigned short ModelTypeProjected = 1;\n            constexpr unsigned short ModelTypeGeographic = 2;\n\n            constexpr unsigned short GTRasterTypeGeoKey = 1025;\n            constexpr unsigned short RasterPixelIsArea = 1;\n            // constexpr unsigned short RasterPixelIsPoint = 2;\n\n            if (geokeys[i] == GTModelTypeGeoKey) {\n                if (geokeys[i + 3] == ModelTypeProjected) {\n                    extent.isGeographic = false;\n                } else if (geokeys[i + 3] != ModelTypeGeographic) {\n                    pj_log(m_ctx, PJ_LOG_ERROR,\n                           \"Only GTModelTypeGeoKey = \"\n                           \"ModelTypeGeographic or ModelTypeProjected are \"\n                           \"supported\");\n                    return nullptr;\n                }\n            } else if (geokeys[i] == GTRasterTypeGeoKey) {\n                if (geokeys[i + 3] == RasterPixelIsArea) {\n                    pixelIsArea = true;\n                }\n            }\n        }\n    }\n\n    double hRes = 0;\n    double vRes = 0;\n    double west = 0;\n    double north = 0;\n\n    double *matrix = nullptr;\n    if (TIFFGetField(m_hTIFF, TIFFTAG_GEOTRANSMATRIX, &count, &matrix) &&\n        count == 16) {\n        // If using GDAL to produce a bottom-up georeferencing, it will produce\n        // a GeoTransformationMatrix, since negative values in GeoPixelScale\n        // have historically been implementation bugs.\n        if (matrix[1] != 0 || matrix[4] != 0) {\n            pj_log(m_ctx, PJ_LOG_ERROR, \"Rotational terms not supported in \"\n                                        \"GeoTransformationMatrix tag\");\n            return nullptr;\n        }\n\n        west = matrix[3];\n        hRes = matrix[0];\n        north = matrix[7];\n        vRes = -matrix[5]; // negation to simulate GeoPixelScale convention\n    } else {\n        double *geopixelscale = nullptr;\n        if (TIFFGetField(m_hTIFF, TIFFTAG_GEOPIXELSCALE, &count,\n                         &geopixelscale) != 1) {\n            pj_log(m_ctx, PJ_LOG_ERROR, \"No GeoPixelScale tag\");\n            return nullptr;\n        }\n        if (count != 3) {\n            pj_log(m_ctx, PJ_LOG_ERROR,\n                   \"Wrong number of values in GeoPixelScale tag\");\n            return nullptr;\n        }\n        hRes = geopixelscale[0];\n        vRes = geopixelscale[1];\n\n        double *geotiepoints = nullptr;\n        if (TIFFGetField(m_hTIFF, TIFFTAG_GEOTIEPOINTS, &count,\n                         &geotiepoints) != 1) {\n            pj_log(m_ctx, PJ_LOG_ERROR, \"No GeoTiePoints tag\");\n            return nullptr;\n        }\n        if (count != 6) {\n            pj_log(m_ctx, PJ_LOG_ERROR,\n                   \"Wrong number of values in GeoTiePoints tag\");\n            return nullptr;\n        }\n\n        west = geotiepoints[3] - geotiepoints[0] * hRes;\n        north = geotiepoints[4] + geotiepoints[1] * vRes;\n    }\n\n    if (pixelIsArea) {\n        west += 0.5 * hRes;\n        north -= 0.5 * vRes;\n    }\n\n    const double mulFactor = extent.isGeographic ? DEG_TO_RAD : 1;\n    extent.west = west * mulFactor;\n    extent.north = north * mulFactor;\n    extent.resX = hRes * mulFactor;\n    extent.resY = fabs(vRes) * mulFactor;\n    extent.east = (west + hRes * (width - 1)) * mulFactor;\n    extent.south = (north - vRes * (height - 1)) * mulFactor;\n\n    if (vRes < 0) {\n        std::swap(extent.north, extent.south);\n    }\n\n    if (!((!extent.isGeographic ||\n           (fabs(extent.west) <= 4 * M_PI && fabs(extent.east) <= 4 * M_PI &&\n            fabs(extent.north) <= M_PI + 1e-5 &&\n            fabs(extent.south) <= M_PI + 1e-5)) &&\n          extent.west < extent.east && extent.south < extent.north &&\n          extent.resX > 1e-10 && extent.resY > 1e-10)) {\n        pj_log(m_ctx, PJ_LOG_ERROR, \"Inconsistent georeferencing for %s\",\n               m_filename.c_str());\n        return nullptr;\n    }\n\n    auto ret = std::unique_ptr<GTiffGrid>(new GTiffGrid(\n        m_ctx, m_hTIFF, m_cache, m_fp.get(), m_ifdIdx, m_filename, width,\n        height, extent, dt, samplesPerPixel, planarConfig, vRes < 0));\n    m_ifdIdx++;\n    m_hasNextGrid = TIFFReadDirectory(m_hTIFF) != 0;\n    m_nextDirOffset = TIFFCurrentDirOffset(m_hTIFF);\n    return ret;\n}",
    "CPLErr GTiffDataset::CleanOverviews()\n\n{\n    CPLAssert( !m_poBaseDS );\n\n    ScanDirectories();\n\n    FlushDirectory();\n\n/* -------------------------------------------------------------------- */\n/*      Cleanup overviews objects, and get offsets to all overview      */\n/*      directories.                                                    */\n/* -------------------------------------------------------------------- */\n    std::vector<toff_t> anOvDirOffsets;\n\n    for( int i = 0; i < m_nOverviewCount; ++i )\n    {\n        anOvDirOffsets.push_back( m_papoOverviewDS[i]->m_nDirOffset );\n        delete m_papoOverviewDS[i];\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Loop through all the directories, translating the offsets       */\n/*      into indexes we can use with TIFFUnlinkDirectory().             */\n/* -------------------------------------------------------------------- */\n    std::vector<uint16> anOvDirIndexes;\n    int iThisOffset = 1;\n\n    TIFFSetDirectory( m_hTIFF, 0 );\n\n    while( true )\n    {\n        for( int i = 0; i < m_nOverviewCount; ++i )\n        {\n            if( anOvDirOffsets[i] == TIFFCurrentDirOffset( m_hTIFF ) )\n            {\n                CPLDebug( \"GTiff\", \"%d -> %d\",\n                          static_cast<int>(anOvDirOffsets[i]), iThisOffset );\n                anOvDirIndexes.push_back( static_cast<uint16>(iThisOffset) );\n            }\n        }\n\n        if( TIFFLastDirectory( m_hTIFF ) )\n            break;\n\n        TIFFReadDirectory( m_hTIFF );\n        ++iThisOffset;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Actually unlink the target directories.  Note that we do        */\n/*      this from last to first so as to avoid renumbering any of       */\n/*      the earlier directories we need to remove.                      */\n/* -------------------------------------------------------------------- */\n    while( !anOvDirIndexes.empty() )\n    {\n        TIFFUnlinkDirectory( m_hTIFF, anOvDirIndexes.back() );\n        anOvDirIndexes.pop_back();\n    }\n\n    CPLFree( m_papoOverviewDS );\n\n    m_nOverviewCount = 0;\n    m_papoOverviewDS = nullptr;\n\n    if( !SetDirectory() )\n        return CE_Failure;\n\n    return CE_None;\n}",
    "GDALDataset *GTiffDataset::OpenDir( GDALOpenInfo * poOpenInfo )\n\n{\n    bool bAllowRGBAInterface = true;\n    const char* pszFilename = poOpenInfo->pszFilename;\n    if( STARTS_WITH_CI(pszFilename, \"GTIFF_RAW:\") )\n    {\n        bAllowRGBAInterface = false;\n        pszFilename += strlen(\"GTIFF_RAW:\");\n    }\n\n    if( !STARTS_WITH_CI(pszFilename, \"GTIFF_DIR:\") ||\n        pszFilename[strlen(\"GTIFF_DIR:\")] == '\\0' )\n    {\n        return nullptr;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Split out filename, and dir#/offset.                            */\n/* -------------------------------------------------------------------- */\n    pszFilename += strlen(\"GTIFF_DIR:\");\n    bool bAbsolute = false;\n\n    if( STARTS_WITH_CI(pszFilename, \"off:\") )\n    {\n        bAbsolute = true;\n        pszFilename += 4;\n    }\n\n    toff_t nOffset = atol(pszFilename);\n    pszFilename += 1;\n\n    while( *pszFilename != '\\0' && pszFilename[-1] != ':' )\n        ++pszFilename;\n\n    if( *pszFilename == '\\0' || nOffset == 0 )\n    {\n        ReportError(pszFilename, CE_Failure, CPLE_OpenFailed,\n            \"Unable to extract offset or filename, should take the form:\\n\"\n            \"GTIFF_DIR:<dir>:filename or GTIFF_DIR:off:<dir_offset>:filename\" );\n        return nullptr;\n    }\n\n    if( poOpenInfo->eAccess == GA_Update )\n    {\n        ReportError(\n            pszFilename, CE_Warning, CPLE_AppDefined,\n            \"Opening a specific TIFF directory is not supported in \"\n            \"update mode. Switching to read-only\" );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Try opening the dataset.                                        */\n/* -------------------------------------------------------------------- */\n    if( !GTiffOneTimeInit() )\n        return nullptr;\n\n    const char* pszFlag = poOpenInfo->eAccess == GA_Update ? \"r+D\" : \"rDO\";\n    VSILFILE* l_fpL = VSIFOpenL(pszFilename, pszFlag);\n    if( l_fpL == nullptr )\n        return nullptr;\n    TIFF *l_hTIFF = VSI_TIFFOpen( pszFilename, pszFlag, l_fpL );\n    if( l_hTIFF == nullptr )\n    {\n        CPL_IGNORE_RET_VAL(VSIFCloseL(l_fpL));\n        return nullptr;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If a directory was requested by index, advance to it now.       */\n/* -------------------------------------------------------------------- */\n    if( !bAbsolute )\n    {\n        const toff_t nOffsetRequested = nOffset;\n        while( nOffset > 1 )\n        {\n            if( TIFFReadDirectory( l_hTIFF ) == 0 )\n            {\n                XTIFFClose( l_hTIFF );\n                ReportError(\n                    pszFilename, CE_Failure, CPLE_OpenFailed,\n                    \"Requested directory %lu not found.\",\n                    static_cast<long unsigned int>(nOffsetRequested));\n                CPL_IGNORE_RET_VAL(VSIFCloseL(l_fpL));\n                return nullptr;\n            }\n            nOffset--;\n        }\n\n        nOffset = TIFFCurrentDirOffset( l_hTIFF );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Create a corresponding GDALDataset.                             */\n/* -------------------------------------------------------------------- */\n    GTiffDataset *poDS = new GTiffDataset();\n    poDS->SetDescription( poOpenInfo->pszFilename );\n    poDS->m_pszFilename = CPLStrdup(pszFilename);\n    poDS->m_fpL = l_fpL;\n    poDS->m_hTIFF = l_hTIFF;\n    poDS->m_bSingleIFDOpened = true;\n\n    if( !EQUAL(pszFilename,poOpenInfo->pszFilename)\n        && !STARTS_WITH_CI(poOpenInfo->pszFilename, \"GTIFF_RAW:\") )\n    {\n        poDS->SetPhysicalFilename( pszFilename );\n        poDS->SetSubdatasetName( poOpenInfo->pszFilename );\n    }\n\n    if( poOpenInfo->AreSiblingFilesLoaded() )\n        poDS->oOvManager.TransferSiblingFiles(\n            poOpenInfo->StealSiblingFiles() );\n\n    if( poDS->OpenOffset( l_hTIFF,\n                          nOffset, poOpenInfo->eAccess,\n                          bAllowRGBAInterface, true ) != CE_None )\n    {\n        delete poDS;\n        return nullptr;\n    }\n\n    return poDS;\n}",
    "void GTiffDataset::ScanDirectories()\n\n{\n/* -------------------------------------------------------------------- */\n/*      We only scan once.  We do not scan for non-base datasets.       */\n/* -------------------------------------------------------------------- */\n    if( !m_bScanDeferred )\n        return;\n\n    m_bScanDeferred = false;\n\n    if( m_poBaseDS )\n        return;\n\n    Crystalize();\n\n    CPLDebug( \"GTiff\", \"ScanDirectories()\" );\n\n/* ==================================================================== */\n/*      Scan all directories.                                           */\n/* ==================================================================== */\n    CPLStringList aosSubdatasets;\n    int iDirIndex = 0;\n\n    FlushDirectory();\n\n    do\n    {\n        // Only libtiff 4.0.4 can handle between 32768 and 65535 directories.\n#if !defined(SUPPORTS_MORE_THAN_32768_DIRECTORIES)\n        if( iDirIndex == 32768 )\n            break;\n#endif\n        toff_t nTopDir = TIFFCurrentDirOffset(m_hTIFF);\n        uint32 nSubType = 0;\n\n        ++iDirIndex;\n\n        toff_t *tmpSubIFDOffsets = nullptr;\n        toff_t *subIFDOffsets = nullptr;\n        uint16 nSubIFDs = 0;\n        if (TIFFGetField(m_hTIFF, TIFFTAG_SUBIFD, &nSubIFDs, &tmpSubIFDOffsets) && iDirIndex == 1)\n        {\n            subIFDOffsets = static_cast<toff_t *>(CPLMalloc(nSubIFDs * sizeof(toff_t)));\n            for (uint16 iSubIFD = 0; iSubIFD < nSubIFDs; iSubIFD++)\n            {\n                subIFDOffsets[iSubIFD] = tmpSubIFDOffsets[iSubIFD];\n            }\n        }\n\n        //early break for backwards compatibility: if the first directory read is also the last, and there are no subIFDs, no use continuing\n        if( iDirIndex==1 && nSubIFDs==0 && TIFFLastDirectory( m_hTIFF )) {\n            CPLFree(subIFDOffsets);\n            break;\n        }\n\n\n        for( uint16 iSubIFD = 0; iSubIFD<=nSubIFDs; iSubIFD++ ) {\n            toff_t nThisDir = nTopDir;\n            if ( iSubIFD > 0 && iDirIndex > 1 ) //don't read subIFDs if we are not in the original directory\n                break;\n            if ( iSubIFD > 0 ) {\n                // make static analyzer happy. subIFDOffsets cannot be null if iSubIFD>0\n                assert(subIFDOffsets != nullptr); \n                nThisDir = subIFDOffsets[iSubIFD-1];\n                //CPLDebug(\"GTiff\", \"Opened subIFD %d/%d at offset %llu.\", iSubIFD, nSubIFDs, nThisDir);\n                if (!TIFFSetSubDirectory(m_hTIFF,nThisDir))\n                    break;\n            }\n\n\n            if( !TIFFGetField(m_hTIFF, TIFFTAG_SUBFILETYPE, &nSubType) )\n                nSubType = 0;\n\n            /* Embedded overview of the main image */\n            if( (nSubType & FILETYPE_REDUCEDIMAGE) != 0 &&\n                (nSubType & FILETYPE_MASK) == 0 &&\n                ((nSubIFDs==0 && iDirIndex != 1) || iSubIFD>0) &&\n                m_nOverviewCount < 30 /* to avoid DoS */ )\n            {\n                GTiffDataset *poODS = new GTiffDataset();\n                poODS->ShareLockWithParentDataset(this);\n                poODS->SetStructuralMDFromParent(this);\n                poODS->m_pszFilename = CPLStrdup(m_pszFilename);\n                if( poODS->OpenOffset( VSI_TIFFOpenChild(m_hTIFF), nThisDir,\n                                    eAccess ) != CE_None\n                    || poODS->GetRasterCount() != GetRasterCount() )\n                {\n                    delete poODS;\n                }\n                else\n                {\n                    CPLDebug( \"GTiff\", \"Opened %dx%d overview.\",\n                            poODS->GetRasterXSize(), poODS->GetRasterYSize());\n                    ++m_nOverviewCount;\n                    m_papoOverviewDS = static_cast<GTiffDataset **>(\n                        CPLRealloc(m_papoOverviewDS,\n                                m_nOverviewCount * (sizeof(void*))) );\n                    m_papoOverviewDS[m_nOverviewCount-1] = poODS;\n                    poODS->m_poBaseDS = this;\n                    poODS->m_bIsOverview = true;\n                }\n            }\n            // Embedded mask of the main image.\n            else if( (nSubType & FILETYPE_MASK) != 0 &&\n                    (nSubType & FILETYPE_REDUCEDIMAGE) == 0 &&\n                    ((nSubIFDs==0 && iDirIndex != 1) || iSubIFD>0) &&\n                    m_poMaskDS == nullptr )\n            {\n                m_poMaskDS = new GTiffDataset();\n                m_poMaskDS->ShareLockWithParentDataset(this);\n                m_poMaskDS->SetStructuralMDFromParent(this);\n                m_poMaskDS->m_pszFilename = CPLStrdup(m_pszFilename);\n\n                // The TIFF6 specification - page 37 - only allows 1\n                // SamplesPerPixel and 1 BitsPerSample Here we support either 1 or\n                // 8 bit per sample and we support either 1 sample per pixel or as\n                // many samples as in the main image We don't check the value of\n                // the PhotometricInterpretation tag, which should be set to\n                // \"Transparency mask\" (4) according to the specification (page\n                // 36).  However, the TIFF6 specification allows image masks to\n                // have a higher resolution than the main image, what we don't\n                // support here.\n\n                if( m_poMaskDS->OpenOffset( VSI_TIFFOpenChild(m_hTIFF), nThisDir,\n                                        eAccess ) != CE_None\n                    || m_poMaskDS->GetRasterCount() == 0\n                    || !(m_poMaskDS->GetRasterCount() == 1\n                        || m_poMaskDS->GetRasterCount() == GetRasterCount())\n                    || m_poMaskDS->GetRasterXSize() != GetRasterXSize()\n                    || m_poMaskDS->GetRasterYSize() != GetRasterYSize()\n                    || m_poMaskDS->GetRasterBand(1)->GetRasterDataType() != GDT_Byte)\n                {\n                    delete m_poMaskDS;\n                    m_poMaskDS = nullptr;\n                }\n                else\n                {\n                    CPLDebug( \"GTiff\", \"Opened band mask.\");\n                    m_poMaskDS->m_poBaseDS = this;\n                    m_poMaskDS->m_poImageryDS = this;\n\n                    m_poMaskDS->m_bPromoteTo8Bits =\n                        CPLTestBool(\n                            CPLGetConfigOption( \"GDAL_TIFF_INTERNAL_MASK_TO_8BIT\",\n                                                \"YES\" ) );\n                }\n            }\n\n            // Embedded mask of an overview.  The TIFF6 specification allows the\n            // combination of the FILETYPE_xxxx masks.\n            else if( (nSubType & FILETYPE_REDUCEDIMAGE) != 0 &&\n                    (nSubType & FILETYPE_MASK) != 0 &&\n                    ((nSubIFDs==0 && iDirIndex != 1) || iSubIFD>0))\n            {\n                GTiffDataset* poDS = new GTiffDataset();\n                poDS->ShareLockWithParentDataset(this);\n                poDS->SetStructuralMDFromParent(this);\n                poDS->m_pszFilename = CPLStrdup(m_pszFilename);\n                if( poDS->OpenOffset( VSI_TIFFOpenChild(m_hTIFF), nThisDir,\n                                    eAccess ) != CE_None\n                    || poDS->GetRasterCount() == 0\n                    || poDS->GetRasterBand(1)->GetRasterDataType() != GDT_Byte)\n                {\n                    delete poDS;\n                }\n                else\n                {\n                    int i = 0;  // Used after for.\n                    for( ; i < m_nOverviewCount; ++i )\n                    {\n                        auto poOvrDS = cpl::down_cast<GTiffDataset*>(\n                                GDALDataset::FromHandle(m_papoOverviewDS[i]));\n                        if( poOvrDS->m_poMaskDS == nullptr &&\n                            poDS->GetRasterXSize() ==\n                            m_papoOverviewDS[i]->GetRasterXSize() &&\n                            poDS->GetRasterYSize() ==\n                            m_papoOverviewDS[i]->GetRasterYSize() &&\n                            (poDS->GetRasterCount() == 1 ||\n                            poDS->GetRasterCount() == GetRasterCount()))\n                        {\n                            CPLDebug(\n                                \"GTiff\", \"Opened band mask for %dx%d overview.\",\n                                poDS->GetRasterXSize(), poDS->GetRasterYSize());\n                            poDS->m_poImageryDS = poOvrDS;\n                            poOvrDS->m_poMaskDS = poDS;\n                            poDS->m_bPromoteTo8Bits =\n                                CPLTestBool(\n                                    CPLGetConfigOption(\n                                        \"GDAL_TIFF_INTERNAL_MASK_TO_8BIT\",\n                                        \"YES\" ) );\n                            poDS->m_poBaseDS = this;\n                            break;\n                        }\n                    }\n                    if( i == m_nOverviewCount )\n                    {\n                        delete poDS;\n                    }\n                }\n            }\n            else if( !m_bSingleIFDOpened && (nSubType == 0 || nSubType == FILETYPE_PAGE) )\n            {\n                uint32 nXSize = 0;\n                uint32 nYSize = 0;\n\n                TIFFGetField( m_hTIFF, TIFFTAG_IMAGEWIDTH, &nXSize );\n                TIFFGetField( m_hTIFF, TIFFTAG_IMAGELENGTH, &nYSize );\n\n                // For Geodetic TIFF grids (GTG)\n                // (https://proj.org/specifications/geodetictiffgrids.html)\n                // extract the grid_name to put it in the description\n                std::string osFriendlyName;\n                char* pszText = nullptr;\n                if( TIFFGetField( m_hTIFF, TIFFTAG_GDAL_METADATA, &pszText ) &&\n                    strstr(pszText, \"grid_name\") != nullptr )\n                {\n                    CPLXMLNode *psRoot = CPLParseXMLString( pszText );\n                    CPLXMLNode *psItem = nullptr;\n\n                    if( psRoot != nullptr && psRoot->eType == CXT_Element\n                        && EQUAL(psRoot->pszValue,\"GDALMetadata\") )\n                        psItem = psRoot->psChild;\n\n                    for( ; psItem != nullptr; psItem = psItem->psNext )\n                    {\n\n                        if( psItem->eType != CXT_Element\n                            || !EQUAL(psItem->pszValue,\"Item\") )\n                            continue;\n\n                        const char *pszKey = CPLGetXMLValue( psItem, \"name\", nullptr );\n                        const char *pszValue = CPLGetXMLValue( psItem, nullptr, nullptr );\n                        int nBand =\n                            atoi(CPLGetXMLValue( psItem, \"sample\", \"-1\" ));\n                        if( pszKey && pszValue && nBand <= 0 &&\n                            EQUAL(pszKey, \"grid_name\") )\n                        {\n                            osFriendlyName = \": \";\n                            osFriendlyName += pszValue;\n                            break;\n                        }\n                    }\n\n                    CPLDestroyXMLNode(psRoot);\n                }\n\n                if( nXSize > INT_MAX || nYSize > INT_MAX )\n                {\n                    CPLDebug(\"GTiff\",\n                            \"Skipping directory with too large image: %u x %u\",\n                            nXSize, nYSize);\n                }\n                else\n                {\n                    uint16 nSPP = 0;\n                    if( !TIFFGetField(m_hTIFF, TIFFTAG_SAMPLESPERPIXEL, &nSPP ) )\n                        nSPP = 1;\n\n                    CPLString osName, osDesc;\n                    osName.Printf( \"SUBDATASET_%d_NAME=GTIFF_DIR:%d:%s\",\n                                iDirIndex, iDirIndex, m_pszFilename );\n                    osDesc.Printf( \"SUBDATASET_%d_DESC=Page %d (%dP x %dL x %dB)\",\n                                iDirIndex, iDirIndex,\n                                static_cast<int>(nXSize),\n                                static_cast<int>(nYSize),\n                                nSPP );\n                    osDesc += osFriendlyName;\n\n                    aosSubdatasets.AddString(osName);\n                    aosSubdatasets.AddString(osDesc);\n                }\n            }\n        }\n        CPLFree(subIFDOffsets);\n\n        // Make sure we are stepping from the expected directory regardless\n        // of churn done processing the above.\n        if( TIFFCurrentDirOffset(m_hTIFF) != nTopDir )\n            TIFFSetSubDirectory( m_hTIFF, nTopDir );\n    } while( !m_bSingleIFDOpened && !TIFFLastDirectory( m_hTIFF ) && TIFFReadDirectory( m_hTIFF ) != 0 );\n\n\n    ReloadDirectory();\n\n    // If we have a mask for the main image, loop over the overviews, and if\n    // they have a mask, let's set this mask as an overview of the main mask.\n    if( m_poMaskDS != nullptr )\n    {\n        for( int i = 0; i < m_nOverviewCount; ++i )\n        {\n            if( cpl::down_cast<GTiffDataset *>(GDALDataset::FromHandle(\n                   m_papoOverviewDS[i]))->m_poMaskDS != nullptr)\n            {\n                ++m_poMaskDS->m_nOverviewCount;\n                m_poMaskDS->m_papoOverviewDS = static_cast<GTiffDataset **>(\n                    CPLRealloc(m_poMaskDS->m_papoOverviewDS,\n                               m_poMaskDS->m_nOverviewCount * (sizeof(void*))) );\n                m_poMaskDS->m_papoOverviewDS[m_poMaskDS->m_nOverviewCount-1] =\n                    cpl::down_cast<GTiffDataset*>(GDALDataset::FromHandle(\n                        m_papoOverviewDS[i]))->m_poMaskDS;\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Only keep track of subdatasets if we have more than one         */\n/*      subdataset (pair).                                              */\n/* -------------------------------------------------------------------- */\n    if( aosSubdatasets.size() > 2 )\n    {\n        m_oGTiffMDMD.SetMetadata( aosSubdatasets.List(), \"SUBDATASETS\" );\n    }\n}",
    "Grid Grid::load_tiff(const std::filesystem::path& path) {\n    auto tiff = TiffPtr(TIFFOpen(path.c_str(), \"r\"));\n    if (!tiff) {\n        throw Error(\"Failed to open\");\n    }\n\n    uint32_t width = 0;\n    uint32_t height = 0;\n    uint16_t depth = 0;\n\n    do {\n        uint32_t layer_width, layer_height;\n        TIFFGetField(tiff.get(), TIFFTAG_IMAGEWIDTH, &layer_width);\n        TIFFGetField(tiff.get(), TIFFTAG_IMAGELENGTH, &layer_height);\n\n        if (layer_width == 0 || layer_height == 0) {\n            throw Error(\"Layer {} has invalid dimensions ({}x{})\", depth, layer_width, layer_height);\n        } else if (width == 0) {\n            width = layer_width;\n            height = layer_height;\n        } else if (layer_width != width && layer_height != height) {\n            throw Error(\"Dimensions of layer {} differ from previous dimensions ({}x{}, previously {}x{})\",\n                depth,\n                layer_width,\n                layer_height,\n                width,\n                height\n            );\n        }\n\n        ++depth;\n    } while (TIFFReadDirectory(tiff.get()));\n\n    const size_t size = static_cast<size_t>(depth) * width * height;\n    auto data = std::make_unique<Pixel[]>(size);\n\n    fmt::print(\"{}x{}x{} = {} pixels\\n\", width, height, depth, size);\n\n    size_t layer_stride = width * height;\n    for (uint16_t i = 0; i < depth; ++i) {\n        TIFFSetDirectory(tiff.get(), i);\n\n        // TIFFReadRGBAImage writes uint32_t's to the raster, which are in the form ABGR. This means\n        // that in-memory, their layout is RGBA if the host machine is little-endian, so instead of\n        // an expensive copy routine just do a reinterpret cast.\n        TIFFReadRGBAImage(tiff.get(), width, height, reinterpret_cast<uint32_t*>(&data.get()[layer_stride * i]));\n    }\n\n    return Grid(\n        {width, height, depth},\n        std::move(data)\n    );\n}",
    "int wxTIFFHandler::GetImageCount( wxInputStream& stream )\n{\n    TIFF *tif = TIFFwxOpen( stream, \"image\", \"r\" );\n\n    if (!tif)\n        return 0;\n\n    int dircount = 0;  // according to the libtiff docs, dircount should be set to 1 here???\n    do {\n        dircount++;\n    } while (TIFFReadDirectory(tif));\n\n    TIFFClose( tif );\n\n    return dircount;\n}",
    "ImageMetadataLoader::Status TiffReader::readMetadata(QIODevice& device,\n                                                     const VirtualFunction<void, const ImageMetadata&>& out) {\n  if (!device.isReadable()) {\n    return ImageMetadataLoader::GENERIC_ERROR;\n  }\n  if (device.isSequential()) {\n    // libtiff needs to be able to seek.\n    return ImageMetadataLoader::GENERIC_ERROR;\n  }\n\n  if (!checkHeader(TiffHeader(readHeader(device)))) {\n    return ImageMetadataLoader::FORMAT_NOT_RECOGNIZED;\n  }\n\n  TiffHandle tif(TIFFClientOpen(\"file\", \"rBm\", &device, &deviceRead, &deviceWrite, &deviceSeek, &deviceClose,\n                                &deviceSize, &deviceMap, &deviceUnmap));\n  if (!tif.handle()) {\n    return ImageMetadataLoader::GENERIC_ERROR;\n  }\n\n  do {\n    out(currentPageMetadata(tif));\n  } while (TIFFReadDirectory(tif.handle()));\n  return ImageMetadataLoader::LOADED;\n}",
    "bool TIFFReadObject<SourceType>::advance_directory()\n{\n  if (impl_->tif == nullptr)\n  {\n    return false;\n  }\n\n  return TIFFReadDirectory(impl_->tif) != 0;\n}",
    "int ScImgDataLoader_TIFF::getLayers(const QString& fn, int /*page*/)\n{\n\tint layerNum = 1;\n\tint test;\n\tstruct PSDLayer lay;\n\tTIFFSetTagExtender(TagExtender);\n\tTIFF* tif = TIFFOpen(fn.toLocal8Bit(), \"r\");\n\tif (!tif)\n\t\treturn layerNum;\n\n\tdo\n\t{\n\t\tchar *layerName = nullptr;\n\t\tTIFFGetField(tif, TIFFTAG_PAGENAME, &layerName);\n\t\tQString name = QString(layerName);\n\t\tif (name.isEmpty())\n\t\t\tlay.layerName = QString(\"Layer #%1\").arg(layerNum);\n\t\telse\n\t\t\tlay.layerName = name;\n\t\tlay.blend = \"norm\";\n\t\tlay.opacity = 255;\n\t\tlay.flags = 0;\n\t\tm_imageInfoRecord.layerInfo.append(lay);\n\t\tm_imageInfoRecord.valid = true;\n\t\tlayerNum++;\n\t\ttest = TIFFReadDirectory(tif);\n\t}\n\twhile (test == 1);\n\tTIFFClose(tif);\n\n\treturn layerNum;\n}",
    "bool ScImgDataLoader_TIFF::testAlphaChannelAvailability(const QString& fn, int /*page*/, bool& hasAlpha)\n{\n\tint  test;\n\n\tQByteArray byteOrder(2, ' ');\n\tQFile fo(fn);\n\tif (fo.open(QIODevice::ReadOnly))\n\t{\n\t\tfo.read(byteOrder.data(), 1);\n\t\tfo.close();\n\t}\n\n\tTIFFSetTagExtender(TagExtender);\n\tTIFF* tif = TIFFOpen(fn.toLocal8Bit(), \"r\");\n\tif (!tif)\n\t\treturn false;\n\n\tuint16 extrasamples, *extratypes;\n\thasAlpha = false;\n\tdo\n\t{\n\t\tif (TIFFGetField (tif, TIFFTAG_EXTRASAMPLES, &extrasamples, &extratypes) == 1)\n\t\t{\n\t\t\tfor (int i = 0; i < extrasamples; ++i)\n\t\t\t{\n\t\t\t\tif (extratypes[i] != EXTRASAMPLE_UNSPECIFIED)\n\t\t\t\t{\n\t\t\t\t\thasAlpha = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttest = TIFFReadDirectory(tif);\n\t}\n\twhile (test == 1);\n\n\tif (hasAlpha)\n\t{\n\t\tTIFFClose(tif);\n\t\treturn true;\n\t}\n\n\tunsigned int PhotoshopLen2 = 0;\n\tunsigned char* PhotoshopBuffer2;\n\tint gotField = TIFFGetField(tif, 37724, &PhotoshopLen2, &PhotoshopBuffer2);\n\tif (gotField && (PhotoshopLen2 > 40))\n\t{\n\t\tm_imageInfoRecord.layerInfo.clear();\n\t\tQByteArray arrayPhot = QByteArray::fromRawData((const char*)PhotoshopBuffer2, PhotoshopLen2);\n\t\tQDataStream s(&arrayPhot, QIODevice::ReadOnly);\n\t\tif (byteOrder[0] == 'M')\n\t\t\ts.setByteOrder(QDataStream::BigEndian);\n\t\telse\n\t\t\ts.setByteOrder(QDataStream::LittleEndian);\n\n\t\tQList<PSDLayer> layerInfo;\n\t\tif (loadLayerInfo(s, layerInfo))\n\t\t{\n\t\t\tfor (int layer = 0; layer < layerInfo.count(); ++layer)\n\t\t\t{\n\t\t\t\tconst PSDLayer& psdLayer = layerInfo.at(layer);\n\t\t\t\tuint channel_num = psdLayer.channelLen.count();\n\t\t\t\tfor (uint channel = 0; channel < channel_num; ++channel)\n\t\t\t\t{\n\t\t\t\t\tif (psdLayer.channelType[channel] == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\thasAlpha = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (hasAlpha) break;\n\t\t\t}\n\t\t}\n\t}\n\n\tTIFFClose(tif);\n\treturn true;\n}",
    "bool ScImgDataLoader_TIFF::loadPicture(const QString& fn, int page, int res, bool thumbnail)\n{\n\tScColorMgmtEngine engine(ScCore->defaultEngine);\n\tbool bilevel = false;\n\tbool failedPS = false;\n\tbool foundPS = false;\n\tshort resolutionunit = RESUNIT_INCH; // Default unit is inch\n\tfloat xres = 72.0, yres = 72.0;\n\tif (!QFile::exists(fn))\n\t\treturn false;\n\tQByteArray byteOrder(2, ' ');\n\tQFile fo(fn);\n\tif (fo.open(QIODevice::ReadOnly))\n\t{\n\t\tfo.read(byteOrder.data(), 1);\n\t\tfo.close();\n\t}\n\tsrand(314159265);\n\tfor (int i = 0; i < 4096; i++)\n\t\tm_random_table[i] = rand();\n\tfor (int i = 0; i < 4096; i++)\n\t{\n\t\tint tmp;\n\t\tint swap = i + rand() % (4096 - i);\n\t\ttmp = m_random_table[i];\n\t\tm_random_table[i] = m_random_table[swap];\n\t\tm_random_table[swap] = tmp;\n\t}\n\n\tinitialize();\n\n\tint test;\n\tbool valid = m_imageInfoRecord.isRequest;\n\tQMap<int, ImageLoadRequest> req = m_imageInfoRecord.RequestProps;\n\tm_imageInfoRecord.RequestProps = req;\n\tm_imageInfoRecord.isRequest = valid;\n\tm_imageInfoRecord.type = ImageTypeTIF;\n\tgetLayers(fn, page);\n\n\tTIFFSetTagExtender(TagExtender);\n\tTIFF* tif = TIFFOpen(fn.toLocal8Bit(), \"r\");\n\tif (!tif)\n\t\treturn false;\n\n\tbool isCMYK = false;\n\tunsigned int widtht, heightt, size;\n\tchar *description=nullptr, *copyright=nullptr, *datetime=nullptr, *artist=nullptr, *scannerMake=nullptr, *scannerModel=nullptr;\n\tuint16 bitspersample, fillorder, planar;\n\n\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &widtht);\n\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &heightt);\n\tTIFFGetField(tif, TIFFTAG_XRESOLUTION, &xres);\n\tTIFFGetField(tif, TIFFTAG_YRESOLUTION, &yres);\n\tTIFFGetField(tif, TIFFTAG_RESOLUTIONUNIT , &resolutionunit);\n\tsize = widtht * heightt;\n\tTIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &m_photometric);\n\tTIFFGetField(tif, TIFFTAG_PLANARCONFIG, &planar);\n\tTIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bitspersample);\n\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &m_samplesperpixel);\n\tTIFFGetField(tif, TIFFTAG_FILLORDER, &fillorder);\n\n\tTIFFGetField(tif, TIFFTAG_MAKE, &scannerMake);\n\tTIFFGetField(tif, TIFFTAG_MODEL, &scannerModel);\n\tTIFFGetField(tif, TIFFTAG_IMAGEDESCRIPTION, &description);\n\tTIFFGetField(tif, TIFFTAG_COPYRIGHT, &copyright);\n\tTIFFGetField(tif, TIFFTAG_DATETIME, &datetime);\n\tTIFFGetField(tif, TIFFTAG_ARTIST, &artist);\n\tm_imageInfoRecord.exifInfo.cameraName = QString(scannerModel);\n\tm_imageInfoRecord.exifInfo.cameraVendor = QString(scannerMake);\n\tm_imageInfoRecord.exifInfo.comment = QString(description);\n\tm_imageInfoRecord.exifInfo.userComment = QString(copyright);\n\tm_imageInfoRecord.exifInfo.width = widtht;\n\tm_imageInfoRecord.exifInfo.height = heightt;\n\tm_imageInfoRecord.exifInfo.dateTime = QString(datetime);\n\tm_imageInfoRecord.exifInfo.artist = QString(artist);\n\tm_imageInfoRecord.exifInfo.thumbnail = QImage();\n\tm_imageInfoRecord.exifDataValid = true;\n\tuint32 EmbedLen = 0;\n\tvoid*  EmbedBuffer;\n\tif (TIFFGetField(tif, TIFFTAG_ICCPROFILE, &EmbedLen, &EmbedBuffer))\n\t{\n\t\tQByteArray profArray((const char*) EmbedBuffer, EmbedLen);\n\t\tScColorProfile tiffProf = engine.openProfileFromMem(profArray);\n\t\tm_embeddedProfile = profArray;\n\t\tm_imageInfoRecord.profileName = tiffProf.productDescription();\n\t\tm_imageInfoRecord.isEmbedded = true;\n\t}\n\telse\n\t{\n\t\tm_imageInfoRecord.isEmbedded = false;\n\t\tm_imageInfoRecord.profileName = \"\";\n\t}\n\tunsigned int PhotoshopLen = 0;\n\tunsigned char* PhotoshopBuffer;\n\tif (TIFFGetField(tif, TIFFTAG_PHOTOSHOP, &PhotoshopLen, &PhotoshopBuffer) )\n\t{\n\t\tif (PhotoshopLen != 0)\n\t\t{\n\t\t\tQByteArray arrayPhot = QByteArray((const char*)PhotoshopBuffer,PhotoshopLen);\n\t\t\tQDataStream strPhot(&arrayPhot,QIODevice::ReadOnly);\n\t\t\tstrPhot.setByteOrder( QDataStream::BigEndian );\n\t\t\tPSDHeader fakeHeader;\n\t\t\tfakeHeader.width = widtht;\n\t\t\tfakeHeader.height = heightt;\n\t\t\tparseRessourceData(strPhot, fakeHeader, PhotoshopLen);\n\t\t\tm_imageInfoRecord.exifInfo.width = widtht;\n\t\t\tm_imageInfoRecord.exifInfo.height = heightt;\n\t\t\tif (!m_imageInfoRecord.valid)\n\t\t\t\tm_imageInfoRecord.valid = (m_imageInfoRecord.PDSpathData.size())>0;\n\t\t\tif (thumbnail)\n\t\t\t{\n\t\t\t\tif (m_photometric == PHOTOMETRIC_SEPARATED)\n\t\t\t\t{\n\t\t\t\t\tisCMYK = true;\n\t\t\t\t\tm_imageInfoRecord.colorspace = ColorSpaceCMYK;\n\t\t\t\t}\n\t\t\t\telse if (m_samplesperpixel == 1)\n\t\t\t\t{\n\t\t\t\t\tm_imageInfoRecord.colorspace = ColorSpaceGray;\n\t\t\t\t\tisCMYK = false;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tm_imageInfoRecord.colorspace = ColorSpaceRGB;\n\t\t\t\tif (bitspersample == 1)\n\t\t\t\t\tbilevel = true;\n\t\t\t\tif (!m_imageInfoRecord.exifInfo.thumbnail.isNull())\n\t\t\t\t{\n\t\t\t\t\tif (isCMYK)\n\t\t\t\t\t{\n\t\t\t\t\t\tr_image.create(m_imageInfoRecord.exifInfo.thumbnail.width(), m_imageInfoRecord.exifInfo.thumbnail.height(), 5);\n\t\t\t\t\t\tm_pixelFormat = Format_CMYKA_8;;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tr_image.create(m_imageInfoRecord.exifInfo.thumbnail.width(), m_imageInfoRecord.exifInfo.thumbnail.height(), 4);\n\t\t\t\t\t\tm_pixelFormat = (m_imageInfoRecord.colorspace == ColorSpaceCMYK) ? Format_CMYK_8 : Format_RGBA_8;\n\t\t\t\t\t}\n\t\t\t\t\tr_image.fill(0);\n\t\t\t\t\tQRgb *s;\n\t\t\t\t\tuchar *d;\n\t\t\t\t\tunsigned char cc, cm, cy, ck;\n\t\t\t\t\tfor (int yit=0; yit < m_imageInfoRecord.exifInfo.thumbnail.height(); ++yit)\n\t\t\t\t\t{\n\t\t\t\t\t\ts = (QRgb*)(m_imageInfoRecord.exifInfo.thumbnail.scanLine( yit ));\n\t\t\t\t\t\td = r_image.scanLine( yit );\n\t\t\t\t\t\tfor (int xit=0; xit < m_imageInfoRecord.exifInfo.thumbnail.width(); ++xit)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (isCMYK)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcc = 255 - qRed(*s);\n\t\t\t\t\t\t\t\tcm = 255 - qGreen(*s);\n\t\t\t\t\t\t\t\tcy = 255 - qBlue(*s);\n\t\t\t\t\t\t\t\tck = qMin(qMin(cc, cm), cy);\n\t\t\t\t\t\t\t\td[0] = cc-ck;\n\t\t\t\t\t\t\t\td[1] = cm-ck;\n\t\t\t\t\t\t\t\td[2] = cy-ck;\n\t\t\t\t\t\t\t\td[3] = ck;\n\t\t\t\t\t\t\t\td[4] = 255;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\td[0] = qRed(*s);\n\t\t\t\t\t\t\t\td[1] = qGreen(*s);\n\t\t\t\t\t\t\t\td[2] = qBlue(*s);\n\t\t\t\t\t\t\t\td[3] = 255;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ts++;\n\t\t\t\t\t\t\td += r_image.channels();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tTIFFClose(tif);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tunsigned int PhotoshopLen2 = 0;\n\tunsigned char* PhotoshopBuffer2;\n\tint gotField = TIFFGetField(tif, 37724, &PhotoshopLen2, &PhotoshopBuffer2);\n\tif (gotField && (PhotoshopLen2 > 40))\n\t{\n\t\tm_imageInfoRecord.layerInfo.clear();\n\t\tQByteArray arrayPhot = QByteArray::fromRawData((const char*)PhotoshopBuffer2, PhotoshopLen2);\n\t\tQDataStream s(&arrayPhot,QIODevice::ReadOnly);\n\t\tif (byteOrder[0] == 'M')\n\t\t\ts.setByteOrder( QDataStream::BigEndian );\n\t\telse\n\t\t\ts.setByteOrder( QDataStream::LittleEndian );\n\n\t\tfailedPS = !loadLayerInfo(s, m_imageInfoRecord.layerInfo); \n\t\tif (!failedPS)\n\t\t{\n\t\t\tint chans = 4;\n\t\t\tint numChannels = m_imageInfoRecord.layerInfo.last().channelType.count();\n\t\t\tint numLayers = m_imageInfoRecord.layerInfo.count();\n\t\t\tPSDHeader fakeHeader;\n\t\t\tfakeHeader.width = widtht;\n\t\t\tfakeHeader.height = heightt;\n\t\t\tfakeHeader.channel_count = numChannels;\n\t\t\tfakeHeader.depth = 8;\n\t\t\tif (m_photometric == PHOTOMETRIC_SEPARATED)\n\t\t\t{\n\t\t\t\tisCMYK = true;\n\t\t\t\tfakeHeader.color_mode = CM_CMYK;\n\t\t\t\tchans = 5;\n\t\t\t}\n\t\t\telse if (m_samplesperpixel == 1)\n\t\t\t{\n\t\t\t\tfakeHeader.color_mode = CM_GRAYSCALE;\n\t\t\t\tisCMYK = false;\n\t\t\t\tchans = 4;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfakeHeader.color_mode = CM_RGB;\n\t\t\t\tisCMYK = false;\n\t\t\t\tchans = 4;\n\t\t\t}\n\t\t\tif (!r_image.create(widtht, heightt, chans))\n\t\t\t\treturn false;\n\t\t\tr_image.fill(0);\n\t\t\tbool firstLayer = true;\n\t\t\tfor (int layer = 0; layer < numLayers; layer++)\n\t\t\t{\n\t\t\t\tloadLayerChannels( s, fakeHeader, m_imageInfoRecord.layerInfo, layer, &firstLayer );\n\t\t\t}\n\t\t\tarrayPhot.clear();\n\t\t\tTIFFClose(tif);\n\t\t\tfoundPS = true;\n\t\t\tif (m_imageInfoRecord.layerInfo.count() == 1)\n\t\t\t\tm_imageInfoRecord.layerInfo.clear();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tarrayPhot.clear();\n\t\t\tgetLayers(fn, page);\n\t\t}\n\t}\n\n\tif (xres <= 1.0 || yres <= 1.0)\n\t{\n\t\txres = yres = 72.0;\n\t\tQFileInfo qfi(fn);\n\t\tm_message = QObject::tr(\"%1 may be corrupted : missing resolution tags\").arg(qfi.fileName());\n\t\tm_msgType = warningMsg;\n\t}\n\tif ((!foundPS) || (failedPS))\n\t{\n\t\tint chans = 4;\n\t\tif (m_photometric == PHOTOMETRIC_SEPARATED)\n\t\t{\n\t\t\tif (m_samplesperpixel > 5) \n\t\t\t\tchans = 4;\n\t\t\telse\n\t\t\t\tchans = m_samplesperpixel;\n\t\t}\n\t\telse\n\t\t\tchans = 4;\n\t\tif (!r_image.create(widtht, heightt, chans))\n\t\t{\n\t\t\tTIFFClose(tif);\n\t\t\treturn false;\n\t\t}\n\t\tr_image.fill(0);\n\t\tint layerNum = 0;\n\t\tdo\n\t\t{\n\t\t\tRawImage tmpImg;\n\t\t\tif (!tmpImg.create(widtht, heightt, chans))\n\t\t\t{\n\t\t\t\tTIFFClose(tif);\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\ttmpImg.fill(0);\n\t\t\tif (!getImageData(tif, &tmpImg, widtht, heightt, size, m_photometric, bitspersample, m_samplesperpixel, bilevel, isCMYK))\n\t\t\t{\n\t\t\t\tTIFFClose(tif);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbool visible = true;\n\t\t\tbool useMask = true;\n\t\t\tif ((m_imageInfoRecord.isRequest) && (m_imageInfoRecord.RequestProps.contains(layerNum)))\n\t\t\t\tvisible = m_imageInfoRecord.RequestProps[layerNum].visible;\n\t\t\tQString layBlend(\"norm\");\n\t\t\tif ((m_imageInfoRecord.isRequest) && (m_imageInfoRecord.RequestProps.contains(layerNum)))\n\t\t\t\tlayBlend = m_imageInfoRecord.RequestProps[layerNum].blend;\n\t\t\tif ((m_imageInfoRecord.isRequest) && (m_imageInfoRecord.RequestProps.contains(layerNum)))\n\t\t\t\tuseMask = m_imageInfoRecord.RequestProps[layerNum].useMask;\n\t\t\tint layOpa = 255;\n\t\t\tif ((m_imageInfoRecord.isRequest) && (m_imageInfoRecord.RequestProps.contains(layerNum)))\n\t\t\t\tlayOpa = m_imageInfoRecord.RequestProps[layerNum].opacity;\n\t\t\tif (visible)\n\t\t\t{\n\t\t\t\tif ((layerNum == 0) && (layBlend != \"diss\"))\n\t\t\t\t\tr_image = tmpImg;\n\t\t\t\telse\n\t\t\t\t\tblendOntoTarget(&tmpImg, layOpa, layBlend, isCMYK, useMask);\n\t\t\t}\n\t\t\t//JG Copy should not be necessary as QImage is implicitly shared in Qt4\n\t\t\tQImage imt; //QImage imt = tmpImg.copy();\n\t\t\tdouble sx = tmpImg.width() / 40.0;\n\t\t\tdouble sy = tmpImg.height() / 40.0;\n\t\t\timt = tmpImg.convertToQImage(chans > 4);\n\t\t\timt = sy < sx ?\timt.scaled(qRound(imt.width() / sx), qRound(imt.height() / sx), Qt::IgnoreAspectRatio, Qt::SmoothTransformation) :\n\t\t\t\t\t\t\t\t\t\timt.scaled(qRound(imt.width() / sy), qRound(imt.height() / sy), Qt::IgnoreAspectRatio, Qt::SmoothTransformation);\n\t\t\tm_imageInfoRecord.layerInfo[layerNum].thumb = imt.copy();\n\t\t\tif (chans > 4)\n\t\t\t{\n\t\t\t\tQImage imt2 = imt.createAlphaMask();\n\t\t\t\timt2.invertPixels();\n\t\t\t\tm_imageInfoRecord.layerInfo[layerNum].thumb_mask = imt2.copy();\n\t\t\t}\n\t\t\telse\n\t\t\t\tm_imageInfoRecord.layerInfo[layerNum].thumb_mask = QImage();\n\t\t\tlayerNum++;\n\n\t\t\tif ((m_imageInfoRecord.layerInfo.count() == 1) && (chans < 5))\n\t\t\t\tm_imageInfoRecord.layerInfo.clear();\n\t\t\ttest = TIFFReadDirectory(tif);\n\n\t\t\t// #10415 : check that image size for the current directory is the same as the main one\n\t\t\t// Some progs use tiff directory to store previews, we do not handle such case\n\t\t\t// and may perform reads in non allocated blocks if we continue\n\t\t\twhile (test == 1)\n\t\t\t{\n\t\t\t\tunsigned int dirWidth(0), dirHeight(0);\n\t\t\t\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &dirWidth);\n\t\t\t\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &dirHeight);\n\t\t\t\tif (dirWidth == widtht && dirHeight == heightt)\n\t\t\t\t\tbreak;\n\t\t\t\ttest = TIFFReadDirectory(tif);\n\t\t\t\tlayerNum++;\n\t\t\t}\n\t\t}\n\t\twhile (test == 1);\n\t\tTIFFClose(tif);\n\t}\n\tif (resolutionunit == RESUNIT_INCH)\n\t{\n\t\tm_image.setDotsPerMeterX ((int) (xres / 0.0254));\n\t\tm_image.setDotsPerMeterY ((int) (yres / 0.0254));\n\t\tm_imageInfoRecord.xres = qRound(xres);\n\t\tm_imageInfoRecord.yres = qRound(yres);\n\t}\n\telse if (resolutionunit == RESUNIT_CENTIMETER)\n\t{\n\t\tm_image.setDotsPerMeterX ((int) (xres * 100.0));\n\t\tm_image.setDotsPerMeterY ((int) (yres * 100.0));\n\t\tm_imageInfoRecord.xres = qRound(xres*2.54);\n\t\tm_imageInfoRecord.yres = qRound(yres*2.54);\n\t}\n\tif (isCMYK)\n\t{\n\t\tm_imageInfoRecord.colorspace = ColorSpaceCMYK;\n\t\tm_pixelFormat = (r_image.channels() == 5) ? Format_CMYKA_8 : Format_CMYK_8;\n\t}\n\telse if (m_samplesperpixel == 1)\n\t{\n\t\t// Do not set m_pixelFormat here as the real pixel format is most probably different than gray\n\t\tif (bitspersample == 1)\n\t\t\tm_imageInfoRecord.colorspace = ColorSpaceMonochrome;\n\t\telse\n\t\t\tm_imageInfoRecord.colorspace = ColorSpaceGray;\n\t}\n\telse\n\t{\n\t\tm_imageInfoRecord.colorspace = ColorSpaceRGB;\n\t\tm_pixelFormat = Format_RGBA_8;\n\t}\n\tm_imageInfoRecord.BBoxX = 0;\n\tm_imageInfoRecord.BBoxH = r_image.height();\n\tif ((m_imageInfoRecord.layerInfo.isEmpty()) && (m_imageInfoRecord.PDSpathData.isEmpty()))\n\t\tm_imageInfoRecord.valid = false;\n\telse\n\t\tm_imageInfoRecord.valid = true;\n\treturn true;\n}",
    "PIX *\nOpenclDevice::pixReadMemTiffCl(const l_uint8 *data,size_t size,l_int32  n)\n{\n\tl_int32  i, pagefound;\n\tPIX     *pix;\n\tTIFF    *tif;\n\t//L_MEMSTREAM *memStream;\n\tPROCNAME(\"pixReadMemTiffCl\");\n\n\tif (!data)\n\t\treturn (PIX *)ERROR_PTR(\"data pointer is NULL\", procName, NULL);\n\n\tif ((tif = fopenTiffMemstream(\"\", \"r\", (l_uint8 **)&data, &size)) == NULL)\n\t\treturn (PIX *)ERROR_PTR(\"tif not opened\", procName, NULL);\n\n\tpagefound = FALSE;\n\tpix = NULL;\n\tfor (i = 0; i < MAX_PAGES_IN_TIFF_FILE; i++) {\n\t\tif (i == n) {\n\t\t\tpagefound = TRUE;\n\t\t\tif ((pix = pixReadFromTiffStreamCl(tif)) == NULL) {\n\t\t\t\tTIFFCleanup(tif);\n\t\t\t\treturn (PIX *)ERROR_PTR(\"pix not read\", procName, NULL);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (TIFFReadDirectory(tif) == 0)\n\t\t\tbreak;\n\t}\n\n\tif (pagefound == FALSE) {\n\t\tL_WARNING(\"tiff page %d not found\", procName);\n\t\tTIFFCleanup(tif);\n\t\treturn NULL;\n\t}\n\n\tTIFFCleanup(tif);\n\treturn pix;\n}",
    "PIX *\nOpenclDevice::pixReadStreamTiffCl(FILE    *fp,\n                  l_int32  n)\n{\nl_int32  i, pagefound;\nPIX     *pix;\nTIFF    *tif;\n\n    PROCNAME(\"pixReadStreamTiff\");\n\n    if (!fp)\n        return (PIX *)ERROR_PTR(\"stream not defined\", procName, NULL);\n\n    if ((tif = fopenTiffCl(fp, \"rb\")) == NULL)\n        return (PIX *)ERROR_PTR(\"tif not opened\", procName, NULL);\n\n    pagefound = FALSE;\n    pix = NULL;\n    for (i = 0; i < MAX_PAGES_IN_TIFF_FILE; i++) {\n        if (i == n) {\n            pagefound = TRUE;\n            if ((pix = pixReadFromTiffStreamCl(tif)) == NULL) {\n                TIFFCleanup(tif);\n                return (PIX *)ERROR_PTR(\"pix not read\", procName, NULL);\n            }\n            break;\n        }\n        if (TIFFReadDirectory(tif) == 0)\n            break;\n    }\n\n    if (pagefound == FALSE) {\n        L_WARNING(\"tiff page %d not found\", procName, n);\n        TIFFCleanup(tif);\n        return NULL;\n    }\n\n    TIFFCleanup(tif);\n    return pix;\n}",
    "int ScImgDataLoader_TIFF::getLayers(const QString& fn, int /*page*/)\n{\n\tint layerNum = 1;\n\tint test;\n\tstruct PSDLayer lay;\n\tTIFFSetTagExtender(TagExtender);\n\tTIFF* tif = TIFFOpen(fn.toLocal8Bit(), \"r\");\n\tif (tif)\n\t{\n\t\tdo\n\t\t{\n\t\t\tchar *layerName=0;\n\t\t\tTIFFGetField(tif, TIFFTAG_PAGENAME, &layerName);\n\t\t\tQString name = QString(layerName);\n\t\t\tif (name.isEmpty())\n\t\t\t\tlay.layerName = QString(\"Layer #%1\").arg(layerNum);\n\t\t\telse\n\t\t\t\tlay.layerName = name;\n\t\t\tlay.blend = \"norm\";\n\t\t\tlay.opacity = 255;\n\t\t\tlay.flags = 0;\n\t\t\tm_imageInfoRecord.layerInfo.append(lay);\n\t\t\tm_imageInfoRecord.valid = true;\n\t\t\tlayerNum++;\n\t\t\ttest = TIFFReadDirectory(tif);\n\t\t}\n\t\twhile (test == 1);\n\t\tTIFFClose(tif);\n\t}\n\treturn layerNum;\n}",
    "bool ScImgDataLoader_TIFF::loadPicture(const QString& fn, int page, int res, bool thumbnail)\n{\n\tScColorMgmtEngine engine(ScCore->defaultEngine);\n\tbool bilevel = false;\n\tbool failedPS = false;\n\tbool foundPS = false;\n\tshort resolutionunit = 0;\n\tfloat xres = 72.0, yres = 72.0;\n\tif (!QFile::exists(fn))\n\t\treturn false;\n\tQByteArray byteOrder(2, ' ');\n\tQFile fo(fn);\n\tif (fo.open(QIODevice::ReadOnly))\n\t{\n\t\tfo.read(byteOrder.data(), 1);\n\t\tfo.close();\n\t}\n\tsrand(314159265);\n\tfor (int i = 0; i < 4096; i++)\n\t\trandom_table[i] = rand();\n\tfor (int i = 0; i < 4096; i++)\n\t{\n\t\tint tmp;\n\t\tint swap = i + rand() % (4096 - i);\n\t\ttmp = random_table[i];\n\t\trandom_table[i] = random_table[swap];\n\t\trandom_table[swap] = tmp;\n\t}\n\tint test;\n\tbool valid = m_imageInfoRecord.isRequest;\n\tQMap<int, ImageLoadRequest> req = m_imageInfoRecord.RequestProps;\n\tinitialize();\n\tm_imageInfoRecord.RequestProps = req;\n\tm_imageInfoRecord.isRequest = valid;\n\tm_imageInfoRecord.type = ImageTypeTIF;\n\tgetLayers(fn, page);\n\tTIFFSetTagExtender(TagExtender);\n\tTIFF* tif = TIFFOpen(fn.toLocal8Bit(), \"r\");\n\tif (tif)\n\t{\n\t\tbool isCMYK = false;\n\t\tunsigned int widtht, heightt, size;\n\t\tchar *description=0, *copyright=0, *datetime=0, *artist=0, *scannerMake=0, *scannerModel=0;\n\t\tuint16 bitspersample, fillorder, planar;\n\n\t\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &widtht);\n\t\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &heightt);\n\t\tTIFFGetField(tif, TIFFTAG_XRESOLUTION, &xres);\n\t\tTIFFGetField(tif, TIFFTAG_YRESOLUTION, &yres);\n\t\tTIFFGetField(tif, TIFFTAG_RESOLUTIONUNIT , &resolutionunit);\n\t\tsize = widtht * heightt;\n\t\tTIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric);\n\t\tTIFFGetField(tif, TIFFTAG_PLANARCONFIG, &planar);\n\t\tTIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bitspersample);\n\t\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &samplesperpixel);\n\t\tTIFFGetField(tif, TIFFTAG_FILLORDER, &fillorder);\n\n\t\tTIFFGetField(tif, TIFFTAG_MAKE, &scannerMake);\n\t\tTIFFGetField(tif, TIFFTAG_MODEL, &scannerModel);\n\t\tTIFFGetField(tif, TIFFTAG_IMAGEDESCRIPTION, &description);\n\t\tTIFFGetField(tif, TIFFTAG_COPYRIGHT, &copyright);\n\t\tTIFFGetField(tif, TIFFTAG_DATETIME, &datetime);\n\t\tTIFFGetField(tif, TIFFTAG_ARTIST, &artist);\n\t\tm_imageInfoRecord.exifInfo.cameraName = QString(scannerModel);\n\t\tm_imageInfoRecord.exifInfo.cameraVendor = QString(scannerMake);\n\t\tm_imageInfoRecord.exifInfo.comment = QString(description);\n\t\tm_imageInfoRecord.exifInfo.userComment = QString(copyright);\n\t\tm_imageInfoRecord.exifInfo.width = widtht;\n\t\tm_imageInfoRecord.exifInfo.height = heightt;\n\t\tm_imageInfoRecord.exifInfo.dateTime = QString(datetime);\n\t\tm_imageInfoRecord.exifInfo.artist = QString(artist);\n\t\tm_imageInfoRecord.exifInfo.thumbnail = QImage();\n\t\tm_imageInfoRecord.exifDataValid = true;\n\t\tuint32 EmbedLen = 0;\n\t\tvoid*  EmbedBuffer;\n\t\tif (TIFFGetField(tif, TIFFTAG_ICCPROFILE, &EmbedLen, &EmbedBuffer))\n\t\t{\n\t\t\tQByteArray profArray((const char*) EmbedBuffer, EmbedLen);\n\t\t\tScColorProfile tiffProf = engine.openProfileFromMem(profArray);\n\t\t\tm_embeddedProfile = profArray;\n\t\t\tm_imageInfoRecord.profileName = tiffProf.productDescription();\n\t\t\tm_imageInfoRecord.isEmbedded = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tm_imageInfoRecord.isEmbedded = false;\n\t\t\tm_imageInfoRecord.profileName = \"\";\n\t\t}\n\t\tunsigned int PhotoshopLen = 0;\n\t\tunsigned char* PhotoshopBuffer;\n\t\tif (TIFFGetField(tif, TIFFTAG_PHOTOSHOP, &PhotoshopLen, &PhotoshopBuffer) )\n\t\t{\n\t\t\tif (PhotoshopLen != 0)\n\t\t\t{\n\t\t\t\tQByteArray arrayPhot = QByteArray((const char*)PhotoshopBuffer,PhotoshopLen);\n\t\t\t\tQDataStream strPhot(&arrayPhot,QIODevice::ReadOnly);\n\t\t\t\tstrPhot.setByteOrder( QDataStream::BigEndian );\n\t\t\t\tPSDHeader fakeHeader;\n\t\t\t\tfakeHeader.width = widtht;\n\t\t\t\tfakeHeader.height = heightt;\n\t\t\t\tparseRessourceData(strPhot, fakeHeader, PhotoshopLen);\n\t\t\t\tm_imageInfoRecord.exifInfo.width = widtht;\n\t\t\t\tm_imageInfoRecord.exifInfo.height = heightt;\n\t\t\t\tif (!m_imageInfoRecord.valid)\n\t\t\t\t\tm_imageInfoRecord.valid = (m_imageInfoRecord.PDSpathData.size())>0?true:false;\n\t\t\t\tif (thumbnail)\n\t\t\t\t{\n\t\t\t\t\tif (photometric == PHOTOMETRIC_SEPARATED)\n\t\t\t\t\t{\n\t\t\t\t\t\tisCMYK = true;\n\t\t\t\t\t\tm_imageInfoRecord.colorspace = ColorSpaceCMYK;\n\t\t\t\t\t}\n\t\t\t\t\telse if (samplesperpixel == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tm_imageInfoRecord.colorspace = ColorSpaceGray;\n\t\t\t\t\t\tisCMYK = false;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tm_imageInfoRecord.colorspace = ColorSpaceRGB;\n\t\t\t\t\tif (bitspersample == 1)\n\t\t\t\t\t\tbilevel = true;\n\t\t\t\t\tif (!m_imageInfoRecord.exifInfo.thumbnail.isNull())\n\t\t\t\t\t{\n\t\t\t\t\t\tif (isCMYK)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tr_image.create(m_imageInfoRecord.exifInfo.thumbnail.width(), m_imageInfoRecord.exifInfo.thumbnail.height(), 5);\n\t\t\t\t\t\t\tm_pixelFormat = Format_CMYKA_8;;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tr_image.create(m_imageInfoRecord.exifInfo.thumbnail.width(), m_imageInfoRecord.exifInfo.thumbnail.height(), 4);\n\t\t\t\t\t\t\tm_pixelFormat = (m_imageInfoRecord.colorspace == ColorSpaceCMYK) ? Format_CMYK_8 : Format_RGBA_8;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr_image.fill(0);\n\t\t\t\t\t\tQRgb *s;\n\t\t\t\t\t\tuchar *d;\n\t\t\t\t\t\tunsigned char cc, cm, cy, ck;\n\t\t\t\t\t\tfor( int yit=0; yit < m_imageInfoRecord.exifInfo.thumbnail.height(); ++yit )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ts = (QRgb*)(m_imageInfoRecord.exifInfo.thumbnail.scanLine( yit ));\n\t\t\t\t\t\t\td = r_image.scanLine( yit );\n\t\t\t\t\t\t\tfor(int xit=0; xit < m_imageInfoRecord.exifInfo.thumbnail.width(); ++xit )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (isCMYK)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tcc = 255 - qRed(*s);\n\t\t\t\t\t\t\t\t\tcm = 255 - qGreen(*s);\n\t\t\t\t\t\t\t\t\tcy = 255 - qBlue(*s);\n\t\t\t\t\t\t\t\t\tck = qMin(qMin(cc, cm), cy);\n\t\t\t\t\t\t\t\t\td[0] = cc-ck;\n\t\t\t\t\t\t\t\t\td[1] = cm-ck;\n\t\t\t\t\t\t\t\t\td[2] = cy-ck;\n\t\t\t\t\t\t\t\t\td[3] = ck;\n\t\t\t\t\t\t\t\t\td[4] = 255;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\td[0] = qRed(*s);\n\t\t\t\t\t\t\t\t\td[1] = qGreen(*s);\n\t\t\t\t\t\t\t\t\td[2] = qBlue(*s);\n\t\t\t\t\t\t\t\t\td[3] = 255;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ts++;\n\t\t\t\t\t\t\t\td += r_image.channels();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tTIFFClose(tif);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tunsigned int PhotoshopLen2 = 0;\n\t\tunsigned char* PhotoshopBuffer2;\n\t\tint gotField = TIFFGetField(tif, 37724, &PhotoshopLen2, &PhotoshopBuffer2);\n\t\tif (gotField && (PhotoshopLen2 > 40))\n\t\t{\n\t\t\tm_imageInfoRecord.layerInfo.clear();\n\t\t\tQByteArray arrayPhot = QByteArray::fromRawData((const char*)PhotoshopBuffer2, PhotoshopLen2);\n\t\t\tQDataStream s(&arrayPhot,QIODevice::ReadOnly);\n\t\t\tif (byteOrder[0] == 'M')\n\t\t\t\ts.setByteOrder( QDataStream::BigEndian );\n\t\t\telse\n\t\t\t\ts.setByteOrder( QDataStream::LittleEndian );\n\n\t\t\tfailedPS = !loadLayerInfo(s, m_imageInfoRecord.layerInfo); \n\t\t\tif (!failedPS)\n\t\t\t{\n\t\t\t\tint chans = 4;\n\t\t\t\tint numChannels = m_imageInfoRecord.layerInfo.last().channelType.count();\n\t\t\t\tint numLayers = m_imageInfoRecord.layerInfo.count();\n\t\t\t\tPSDHeader fakeHeader;\n\t\t\t\tfakeHeader.width = widtht;\n\t\t\t\tfakeHeader.height = heightt;\n\t\t\t\tfakeHeader.channel_count = numChannels;\n\t\t\t\tfakeHeader.depth = 8;\n\t\t\t\tif (photometric == PHOTOMETRIC_SEPARATED)\n\t\t\t\t{\n\t\t\t\t\tisCMYK = true;\n\t\t\t\t\tfakeHeader.color_mode = CM_CMYK;\n\t\t\t\t\tchans = 5;\n\t\t\t\t}\n\t\t\t\telse if (samplesperpixel == 1)\n\t\t\t\t{\n\t\t\t\t\tfakeHeader.color_mode = CM_GRAYSCALE;\n\t\t\t\t\tisCMYK = false;\n\t\t\t\t\tchans = 4;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfakeHeader.color_mode = CM_RGB;\n\t\t\t\t\tisCMYK = false;\n\t\t\t\t\tchans = 4;\n\t\t\t\t}\n\t\t\t\tif( !r_image.create( widtht, heightt, chans ))\n\t\t\t\t\treturn false;\n\t\t\t\tr_image.fill(0);\n\t\t\t\tbool firstLayer = true;\n\t\t\t\tfor (int layer = 0; layer < numLayers; layer++)\n\t\t\t\t{\n\t\t\t\t\tloadLayerChannels( s, fakeHeader, m_imageInfoRecord.layerInfo, layer, &firstLayer );\n\t\t\t\t}\n\t\t\t\tarrayPhot.clear();\n\t\t\t\tTIFFClose(tif);\n\t\t\t\tfoundPS = true;\n\t\t\t\tif (m_imageInfoRecord.layerInfo.count() == 1)\n\t\t\t\t\tm_imageInfoRecord.layerInfo.clear();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tarrayPhot.clear();\n\t\t\t\tgetLayers(fn, page);\n\t\t\t}\n\t\t}\n\n\t\tif( xres <= 1.0 || yres <= 1.0 )\n\t\t{\n\t\t\txres = yres = 72.0;\n\t\t\tQFileInfo qfi(fn);\n\t\t\tm_message = QObject::tr(\"%1 may be corrupted : missing resolution tags\").arg(qfi.fileName());\n\t\t\tm_msgType = warningMsg;\n\t\t}\n\t\tif ((!foundPS) || (failedPS))\n\t\t{\n\t\t\tint chans = 4;\n\t\t\tif (photometric == PHOTOMETRIC_SEPARATED)\n\t\t\t{\n\t\t\t\tif (samplesperpixel > 5) \n\t\t\t\t\tchans = 4;\n\t\t\t\telse\n\t\t\t\t\tchans = samplesperpixel;\n\t\t\t}\n\t\t\telse\n\t\t\t\tchans = 4;\n\t\t\tif (!r_image.create(widtht, heightt, chans))\n\t\t\t{\n\t\t\t\tTIFFClose(tif);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tr_image.fill(0);\n\t\t\tint layerNum = 0;\n\t\t\tdo\n\t\t\t{\n\t\t\t\tRawImage tmpImg;\n\t\t\t\tif( !tmpImg.create(widtht, heightt, chans))\n\t\t\t\t{\n\t\t\t\t\tTIFFClose(tif);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\ttmpImg.fill(0);\n\t\t\t\tif (!getImageData(tif, &tmpImg, widtht, heightt, size, photometric, bitspersample, samplesperpixel, bilevel, isCMYK))\n\t\t\t\t{\n\t\t\t\t\tTIFFClose(tif);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tbool visible = true;\n\t\t\t\tbool useMask = true;\n\t\t\t\tif ((m_imageInfoRecord.isRequest) && (m_imageInfoRecord.RequestProps.contains(layerNum)))\n\t\t\t\t\tvisible = m_imageInfoRecord.RequestProps[layerNum].visible;\n\t\t\t\tQString layBlend = \"norm\";\n\t\t\t\tif ((m_imageInfoRecord.isRequest) && (m_imageInfoRecord.RequestProps.contains(layerNum)))\n\t\t\t\t\tlayBlend = m_imageInfoRecord.RequestProps[layerNum].blend;\n\t\t\t\tif ((m_imageInfoRecord.isRequest) && (m_imageInfoRecord.RequestProps.contains(layerNum)))\n\t\t\t\t\tuseMask = m_imageInfoRecord.RequestProps[layerNum].useMask;\n\t\t\t\tint layOpa = 255;\n\t\t\t\tif ((m_imageInfoRecord.isRequest) && (m_imageInfoRecord.RequestProps.contains(layerNum)))\n\t\t\t\t\tlayOpa = m_imageInfoRecord.RequestProps[layerNum].opacity;\n\t\t\t\tif (visible)\n\t\t\t\t{\n\t\t\t\t\tif ((layerNum == 0) && (layBlend != \"diss\"))\n\t\t\t\t\t\tr_image = tmpImg;\n\t\t\t\t\telse\n\t\t\t\t\t\tblendOntoTarget(&tmpImg, layOpa, layBlend, isCMYK, useMask);\n\t\t\t\t}\n\t\t\t\t//JG Copy should not be necessary as QImage is implicitly shared in Qt4\n\t\t\t\tQImage imt; //QImage imt = tmpImg.copy();\n\t\t\t\tdouble sx = tmpImg.width() / 40.0;\n\t\t\t\tdouble sy = tmpImg.height() / 40.0;\n\t\t\t\timt = tmpImg.convertToQImage((chans > 4) ? true : false);\n\t\t\t\timt = sy < sx ?\timt.scaled(qRound(imt.width() / sx), qRound(imt.height() / sx), Qt::IgnoreAspectRatio, Qt::SmoothTransformation) :\n\t\t\t\t\t\t\t\t\t\t\timt.scaled(qRound(imt.width() / sy), qRound(imt.height() / sy), Qt::IgnoreAspectRatio, Qt::SmoothTransformation);\n\t\t\t\tm_imageInfoRecord.layerInfo[layerNum].thumb = imt.copy();\n\t\t\t\tif (chans > 4)\n\t\t\t\t{\n\t\t\t\t\tQImage imt2 = imt.createAlphaMask();\n\t\t\t\t\timt2.invertPixels();\n\t\t\t\t\tm_imageInfoRecord.layerInfo[layerNum].thumb_mask = imt2.copy();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tm_imageInfoRecord.layerInfo[layerNum].thumb_mask = QImage();\n\t\t\t\tlayerNum++;\n\n\t\t\t\tif ((m_imageInfoRecord.layerInfo.count() == 1) && (chans < 5))\n\t\t\t\t\tm_imageInfoRecord.layerInfo.clear();\n\t\t\t\ttest = TIFFReadDirectory(tif);\n\n\t\t\t\t// #10415 : check that image size for the current directory is the same as the main one\n\t\t\t\t// Some progs use tiff directory to store previews, we do not handle such case\n\t\t\t\t// and may perform reads in non allocated blocks if we continue\n\t\t\t\twhile (test == 1)\n\t\t\t\t{\n\t\t\t\t\tunsigned int dirWidth(0), dirHeight(0);\n\t\t\t\t\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &dirWidth);\n\t\t\t\t\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &dirHeight);\n\t\t\t\t\tif (dirWidth == widtht && dirHeight == heightt)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\ttest = TIFFReadDirectory(tif);\n\t\t\t\t\tlayerNum++;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (test == 1);\n\t\t\tTIFFClose(tif);\n\t\t}\n\t\tif (resolutionunit == RESUNIT_INCH)\n\t\t{\n\t\t\tm_image.setDotsPerMeterX ((int) (xres / 0.0254));\n\t\t\tm_image.setDotsPerMeterY ((int) (yres / 0.0254));\n\t\t\tm_imageInfoRecord.xres = qRound(xres);\n\t\t\tm_imageInfoRecord.yres = qRound(yres);\n\t\t}\n\t\telse if (resolutionunit == RESUNIT_CENTIMETER)\n\t\t{\n\t\t\tm_image.setDotsPerMeterX ((int) (xres * 100.0));\n\t\t\tm_image.setDotsPerMeterY ((int) (yres * 100.0));\n\t\t\tm_imageInfoRecord.xres = qRound(xres*2.54);\n\t\t\tm_imageInfoRecord.yres = qRound(yres*2.54);\n\t\t}\n\t\tif (isCMYK)\n\t\t{\n\t\t\tm_imageInfoRecord.colorspace = ColorSpaceCMYK;\n\t\t\tm_pixelFormat = (r_image.channels() == 5) ? Format_CMYKA_8 : Format_CMYK_8;\n\t\t}\n\t\telse if (samplesperpixel == 1)\n\t\t{\n\t\t\t// Do not set m_pixelFormat here as the real pixel format is most probably different than gray\n\t\t\tif (bitspersample == 1)\n\t\t\t{\n\t\t\t\tm_imageInfoRecord.colorspace = ColorSpaceMonochrome;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tm_imageInfoRecord.colorspace = ColorSpaceGray;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tm_imageInfoRecord.colorspace = ColorSpaceRGB;\n\t\t\tm_pixelFormat = Format_RGBA_8;\n\t\t}\n\t\tm_imageInfoRecord.BBoxX = 0;\n\t\tm_imageInfoRecord.BBoxH = r_image.height();\n\t\tif ((m_imageInfoRecord.layerInfo.isEmpty()) && (m_imageInfoRecord.PDSpathData.isEmpty()))\n\t\t\tm_imageInfoRecord.valid = false;\n\t\telse\n\t\t\tm_imageInfoRecord.valid = true;\n\t\treturn true;\n\t}\n\treturn false;\n}",
    "JNIEXPORT jboolean JNICALL LCTIFFWriter_METHOD(append)\n    ( JNIEnv *env, jobject jLCTIFFWriter, jstring jFileName )\n{\n    TIFF *const destTIFF = getNativePtr( env, jLCTIFFWriter );\n    TIFFSetField( destTIFF, TIFFTAG_PAGENUMBER, 0, 2 );\n    int result = TIFFWriteDirectory( destTIFF );\n    if ( !result )\n        return JNI_FALSE;\n    jstring_to_c const cFileName( env, jFileName );\n    TIFF *const srcTIFF = LC_TIFFOpen( cFileName, \"r\" );\n    if ( !srcTIFF )\n        return JNI_FALSE;\n    if ( isLightZoneLayeredTIFF( srcTIFF ) )\n        TIFFReadDirectory( srcTIFF );\n    result = tiffcp( srcTIFF, destTIFF );\n    TIFFSetField( destTIFF, TIFFTAG_PAGENUMBER, 1, 2 );\n    TIFFClose( srcTIFF );\n    return result ? JNI_TRUE : JNI_FALSE;\n}",
    "CPLErr GTiffDataset::CleanOverviews()\n\n{\n    CPLAssert( bBase );\n\n    FlushDirectory();\n    *ppoActiveDSRef = NULL;\n\n/* -------------------------------------------------------------------- */\n/*      Cleanup overviews objects, and get offsets to all overview      */\n/*      directories.                                                    */\n/* -------------------------------------------------------------------- */\n    std::vector<toff_t>  anOvDirOffsets;\n    int i;\n\n    for( i = 0; i < nOverviewCount; i++ )\n    {\n        anOvDirOffsets.push_back( papoOverviewDS[i]->nDirOffset );\n        delete papoOverviewDS[i];\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Loop through all the directories, translating the offsets       */\n/*      into indexes we can use with TIFFUnlinkDirectory().             */\n/* -------------------------------------------------------------------- */\n    std::vector<uint16> anOvDirIndexes;\n    int iThisOffset = 1;\n\n    TIFFSetDirectory( hTIFF, 0 );\n    \n    for( ; TRUE; ) \n    {\n        for( i = 0; i < nOverviewCount; i++ )\n        {\n            if( anOvDirOffsets[i] == TIFFCurrentDirOffset( hTIFF ) )\n            {\n                CPLDebug( \"GTiff\", \"%d -> %d\", \n                          (int) anOvDirOffsets[i], iThisOffset );\n                anOvDirIndexes.push_back( iThisOffset );\n            }\n        }\n        \n        if( TIFFLastDirectory( hTIFF ) )\n            break;\n\n        TIFFReadDirectory( hTIFF );\n        iThisOffset++;\n    } \n\n/* -------------------------------------------------------------------- */\n/*      Actually unlink the target directories.  Note that we do        */\n/*      this from last to first so as to avoid renumbering any of       */\n/*      the earlier directories we need to remove.                      */\n/* -------------------------------------------------------------------- */\n    while( !anOvDirIndexes.empty() )\n    {\n        TIFFUnlinkDirectory( hTIFF, anOvDirIndexes.back() );\n        anOvDirIndexes.pop_back();\n    }\n\n    CPLFree( papoOverviewDS );\n\n    nOverviewCount = 0;\n    papoOverviewDS = NULL;\n\n    if (!SetDirectory())\n        return CE_Failure;\n\n    return CE_None;\n}",
    "GDALDataset *GTiffDataset::OpenDir( GDALOpenInfo * poOpenInfo )\n\n{\n    int bAllowRGBAInterface = TRUE;\n    const char* pszFilename = poOpenInfo->pszFilename;\n    if( EQUALN(pszFilename,\"GTIFF_RAW:\", strlen(\"GTIFF_RAW:\")) )\n    {\n        bAllowRGBAInterface = FALSE;\n        pszFilename += strlen(\"GTIFF_RAW:\");\n    }\n\n    if( !EQUALN(pszFilename,\"GTIFF_DIR:\",strlen(\"GTIFF_DIR:\")) )\n        return NULL;\n    \n/* -------------------------------------------------------------------- */\n/*      Split out filename, and dir#/offset.                            */\n/* -------------------------------------------------------------------- */\n    pszFilename += strlen(\"GTIFF_DIR:\");\n    int        bAbsolute = FALSE;\n    toff_t     nOffset;\n    \n    if( EQUALN(pszFilename,\"off:\",4) )\n    {\n        bAbsolute = TRUE;\n        pszFilename += 4;\n    }\n\n    nOffset = atol(pszFilename);\n    pszFilename += 1;\n\n    while( *pszFilename != '\\0' && pszFilename[-1] != ':' )\n        pszFilename++;\n\n    if( *pszFilename == '\\0' || nOffset == 0 )\n    {\n        CPLError( CE_Failure, CPLE_OpenFailed,\n                  \"Unable to extract offset or filename, should take the form\\n\"\n                  \"GTIFF_DIR:<dir>:filename or GTIFF_DIR:off:<dir_offset>:filename\" );\n        return NULL;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Try opening the dataset.                                        */\n/* -------------------------------------------------------------------- */\n    TIFF\t*hTIFF;\n\n    GTiffOneTimeInit();\n\n    hTIFF = VSI_TIFFOpen( pszFilename, \"r\" );\n    if( hTIFF == NULL )\n        return( NULL );\n\n/* -------------------------------------------------------------------- */\n/*      If a directory was requested by index, advance to it now.       */\n/* -------------------------------------------------------------------- */\n    if( !bAbsolute )\n    {\n        while( nOffset > 1 )\n        {\n            if( TIFFReadDirectory( hTIFF ) == 0 )\n            {\n                XTIFFClose( hTIFF );\n                CPLError( CE_Failure, CPLE_OpenFailed, \n                          \"Requested directory %lu not found.\", (long unsigned int)nOffset );\n                return NULL;\n            }\n            nOffset--;\n        }\n\n        nOffset = TIFFCurrentDirOffset( hTIFF );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Create a corresponding GDALDataset.                             */\n/* -------------------------------------------------------------------- */\n    GTiffDataset \t*poDS;\n\n    poDS = new GTiffDataset();\n    poDS->SetDescription( poOpenInfo->pszFilename );\n    poDS->osFilename = poOpenInfo->pszFilename;\n    poDS->poActiveDS = poDS;\n\n    if( !EQUAL(pszFilename,poOpenInfo->pszFilename) \n        && !EQUALN(poOpenInfo->pszFilename,\"GTIFF_RAW:\",10) )\n    {\n        poDS->SetPhysicalFilename( pszFilename );\n        poDS->SetSubdatasetName( poOpenInfo->pszFilename );\n        poDS->osFilename = pszFilename;\n    }\n\n    if (poOpenInfo->eAccess == GA_Update)\n    {\n        CPLError( CE_Warning, CPLE_AppDefined,\n                  \"Opening a specific TIFF directory is not supported in update mode. Switching to read-only\" );\n    }\n\n    if( poDS->OpenOffset( hTIFF, &(poDS->poActiveDS),\n                          nOffset, FALSE, GA_ReadOnly, bAllowRGBAInterface ) != CE_None )\n    {\n        delete poDS;\n        return NULL;\n    }\n    else\n    {\n        poDS->bCloseTIFFHandle = TRUE;\n        return poDS;\n    }\n}",
    "CPLErr GTiffDataset::OpenOffset( TIFF *hTIFFIn, \n                                 GTiffDataset **ppoActiveDSRef,\n                                 toff_t nDirOffsetIn, \n\t\t\t\t int bBaseIn, GDALAccess eAccess,\n                                 int bAllowRGBAInterface)\n\n{\n    uint32\tnXSize, nYSize;\n    int\t\tbTreatAsBitmap = FALSE;\n    int         bTreatAsOdd = FALSE;\n\n    this->eAccess = eAccess;\n\n    hTIFF = hTIFFIn;\n    this->ppoActiveDSRef = ppoActiveDSRef;\n\n    nDirOffset = nDirOffsetIn;\n\n    if (!SetDirectory( nDirOffsetIn ))\n        return CE_Failure;\n\n    bBase = bBaseIn;\n\n    this->eAccess = eAccess;\n\n/* -------------------------------------------------------------------- */\n/*      Capture some information from the file that is of interest.     */\n/* -------------------------------------------------------------------- */\n    TIFFGetField( hTIFF, TIFFTAG_IMAGEWIDTH, &nXSize );\n    TIFFGetField( hTIFF, TIFFTAG_IMAGELENGTH, &nYSize );\n    nRasterXSize = nXSize;\n    nRasterYSize = nYSize;\n\n    if( !TIFFGetField(hTIFF, TIFFTAG_SAMPLESPERPIXEL, &nSamplesPerPixel ) )\n        nBands = 1;\n    else\n        nBands = nSamplesPerPixel;\n    \n    if( !TIFFGetField(hTIFF, TIFFTAG_BITSPERSAMPLE, &(nBitsPerSample)) )\n        nBitsPerSample = 1;\n    \n    if( !TIFFGetField( hTIFF, TIFFTAG_PLANARCONFIG, &(nPlanarConfig) ) )\n        nPlanarConfig = PLANARCONFIG_CONTIG;\n    \n    if( !TIFFGetField( hTIFF, TIFFTAG_PHOTOMETRIC, &(nPhotometric) ) )\n        nPhotometric = PHOTOMETRIC_MINISBLACK;\n    \n    if( !TIFFGetField( hTIFF, TIFFTAG_SAMPLEFORMAT, &(nSampleFormat) ) )\n        nSampleFormat = SAMPLEFORMAT_UINT;\n    \n    if( !TIFFGetField( hTIFF, TIFFTAG_COMPRESSION, &(nCompression) ) )\n        nCompression = COMPRESSION_NONE;\n    \n#if defined(TIFFLIB_VERSION) && TIFFLIB_VERSION > 20031007 /* 3.6.0 */\n    if (nCompression != COMPRESSION_NONE &&\n        !TIFFIsCODECConfigured(nCompression))\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                  \"Cannot open TIFF file due to missing codec.\" );\n        return CE_Failure;\n    }\n#endif\n\n/* -------------------------------------------------------------------- */\n/*      YCbCr JPEG compressed images should be translated on the fly    */\n/*      to RGB by libtiff/libjpeg unless specifically requested         */\n/*      otherwise.                                                      */\n/* -------------------------------------------------------------------- */\n    if( nCompression == COMPRESSION_JPEG \n        && nPhotometric == PHOTOMETRIC_YCBCR \n        && CSLTestBoolean( CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\",\n                                              \"YES\") ) )\n    {\n        int nColorMode;\n\n        SetMetadataItem( \"SOURCE_COLOR_SPACE\", \"YCbCr\", \"IMAGE_STRUCTURE\" );\n        if ( !TIFFGetField( hTIFF, TIFFTAG_JPEGCOLORMODE, &nColorMode ) ||\n              nColorMode != JPEGCOLORMODE_RGB )\n            TIFFSetField(hTIFF, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Get strip/tile layout.                                          */\n/* -------------------------------------------------------------------- */\n    if( TIFFIsTiled(hTIFF) )\n    {\n        TIFFGetField( hTIFF, TIFFTAG_TILEWIDTH, &(nBlockXSize) );\n        TIFFGetField( hTIFF, TIFFTAG_TILELENGTH, &(nBlockYSize) );\n    }\n    else\n    {\n        if( !TIFFGetField( hTIFF, TIFFTAG_ROWSPERSTRIP,\n                           &(nRowsPerStrip) ) )\n        {\n            CPLError( CE_Warning, CPLE_AppDefined, \n                      \"RowsPerStrip not defined ... assuming all one strip.\" );\n            nRowsPerStrip = nYSize; /* dummy value */\n        }\n\n        nBlockXSize = nRasterXSize;\n        nBlockYSize = MIN(nRowsPerStrip,nYSize);\n    }\n        \n    nBlocksPerBand =\n        ((nYSize + nBlockYSize - 1) / nBlockYSize)\n        * ((nXSize + nBlockXSize  - 1) / nBlockXSize);\n\n/* -------------------------------------------------------------------- */\n/*      Should we handle this using the GTiffBitmapBand?                */\n/* -------------------------------------------------------------------- */\n    if( nBitsPerSample == 1 && nBands == 1 )\n    {\n        bTreatAsBitmap = TRUE;\n\n        // Lets treat large \"one row\" bitmaps using the scanline api.\n        if( !TIFFIsTiled(hTIFF) \n            && nBlockYSize == nYSize \n            && nYSize > 2000 \n            && bAllowRGBAInterface )\n            bTreatAsSplitBitmap = TRUE;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Should we treat this via the RGBA interface?                    */\n/* -------------------------------------------------------------------- */\n    if( bAllowRGBAInterface &&\n        !bTreatAsBitmap && !(nBitsPerSample > 8) \n        && (nPhotometric == PHOTOMETRIC_CIELAB ||\n            nPhotometric == PHOTOMETRIC_LOGL ||\n            nPhotometric == PHOTOMETRIC_LOGLUV ||\n            nPhotometric == PHOTOMETRIC_SEPARATED ||\n            ( nPhotometric == PHOTOMETRIC_YCBCR \n              && nCompression != COMPRESSION_JPEG )) )\n    {\n        char\tszMessage[1024];\n\n        if( TIFFRGBAImageOK( hTIFF, szMessage ) == 1 )\n        {\n            const char* pszSourceColorSpace = NULL;\n            switch (nPhotometric)\n            {\n                case PHOTOMETRIC_CIELAB:\n                    pszSourceColorSpace = \"CIELAB\";\n                    break;\n                case PHOTOMETRIC_LOGL:\n                    pszSourceColorSpace = \"LOGL\";\n                    break;\n                case PHOTOMETRIC_LOGLUV:\n                    pszSourceColorSpace = \"LOGLUV\";\n                    break;\n                case PHOTOMETRIC_SEPARATED:\n                    pszSourceColorSpace = \"CMYK\";\n                    break;\n                case PHOTOMETRIC_YCBCR:\n                    pszSourceColorSpace = \"YCbCr\";\n                    break;\n            }\n            if (pszSourceColorSpace)\n                SetMetadataItem( \"SOURCE_COLOR_SPACE\", pszSourceColorSpace, \"IMAGE_STRUCTURE\" );\n            bTreatAsRGBA = TRUE;\n            nBands = 4;\n        }\n        else\n        {\n            CPLDebug( \"GTiff\", \"TIFFRGBAImageOK says:\\n%s\", szMessage );\n        }\n    }\n    \n/* -------------------------------------------------------------------- */\n/*      Should we treat this via the split interface?                   */\n/* -------------------------------------------------------------------- */\n    if( !TIFFIsTiled(hTIFF) \n        && nBitsPerSample == 8\n        && nBlockYSize == nYSize \n        && nYSize > 2000\n        && !bTreatAsRGBA \n        && CSLTestBoolean(CPLGetConfigOption(\"GDAL_ENABLE_TIFF_SPLIT\", \"YES\")))\n    {\n        /* libtiff 3.9.2 (20091104) and older, libtiff 4.0.0beta5 (also 20091104) */\n        /* and older will crash when trying to open a all-in-one-strip */\n        /* YCbCr JPEG compressed TIFF (see #3259). BUG_3259_FIXED is defined */\n        /* in internal libtiff tif_config.h until a 4.0.0beta6 is released */\n#if (TIFFLIB_VERSION <= 20091104 && !defined(BIGTIFF_SUPPORT)) || \\\n    (TIFFLIB_VERSION <= 20091104 && defined(BIGTIFF_SUPPORT) && !defined(BUG_3259_FIXED))\n        if (nPhotometric == PHOTOMETRIC_YCBCR  &&\n            nCompression == COMPRESSION_JPEG)\n        {\n            CPLDebug(\"GTiff\", \"Avoid using split band to open all-in-one-strip \"\n                              \"YCbCr JPEG compressed TIFF because of older libtiff\");\n        }\n        else\n#endif\n            bTreatAsSplit = TRUE;\n    }\n    \n/* -------------------------------------------------------------------- */\n/*      Should we treat this via the odd bits interface?                */\n/* -------------------------------------------------------------------- */\n    if ( nSampleFormat == SAMPLEFORMAT_IEEEFP )\n    {\n        if ( nBitsPerSample == 16 || nBitsPerSample == 24 )\n            bTreatAsOdd = TRUE;\n    }\n    else if ( !bTreatAsRGBA && !bTreatAsBitmap\n              && nBitsPerSample != 8\n              && nBitsPerSample != 16\n              && nBitsPerSample != 32\n              && nBitsPerSample != 64 \n              && nBitsPerSample != 128 )\n        bTreatAsOdd = TRUE;\n\n    int bMinIsWhite = nPhotometric == PHOTOMETRIC_MINISWHITE;\n\n/* -------------------------------------------------------------------- */\n/*      Capture the color table if there is one.                        */\n/* -------------------------------------------------------------------- */\n    unsigned short\t*panRed, *panGreen, *panBlue;\n\n    if( bTreatAsRGBA \n        || TIFFGetField( hTIFF, TIFFTAG_COLORMAP, \n                         &panRed, &panGreen, &panBlue) == 0 )\n    {\n\t// Build inverted palette if we have inverted photometric.\n\t// Pixel values remains unchanged.  Avoid doing this for *deep*\n        // data types (per #1882)\n\tif( nBitsPerSample <= 16 && nPhotometric == PHOTOMETRIC_MINISWHITE )\n\t{\n\t    GDALColorEntry  oEntry;\n\t    int\t\t    iColor, nColorCount;\n\t    \n\t    poColorTable = new GDALColorTable();\n\t    nColorCount = 1 << nBitsPerSample;\n\n\t    for ( iColor = 0; iColor < nColorCount; iColor++ )\n\t    {\n\t\toEntry.c1 = oEntry.c2 = oEntry.c3 = (short) \n                    ((255 * (nColorCount - 1 - iColor)) / (nColorCount-1));\n\t\toEntry.c4 = 255;\n\t\tpoColorTable->SetColorEntry( iColor, &oEntry );\n\t    }\n\n\t    nPhotometric = PHOTOMETRIC_PALETTE;\n\t}\n\telse\n\t    poColorTable = NULL;\n    }\n    else\n    {\n        int\tnColorCount, nMaxColor = 0;\n        GDALColorEntry oEntry;\n\n        poColorTable = new GDALColorTable();\n\n        nColorCount = 1 << nBitsPerSample;\n\n        for( int iColor = nColorCount - 1; iColor >= 0; iColor-- )\n        {\n            oEntry.c1 = panRed[iColor] / 256;\n            oEntry.c2 = panGreen[iColor] / 256;\n            oEntry.c3 = panBlue[iColor] / 256;\n            oEntry.c4 = 255;\n\n            poColorTable->SetColorEntry( iColor, &oEntry );\n\n            nMaxColor = MAX(nMaxColor,panRed[iColor]);\n            nMaxColor = MAX(nMaxColor,panGreen[iColor]);\n            nMaxColor = MAX(nMaxColor,panBlue[iColor]);\n        }\n\n        // Bug 1384 - Some TIFF files are generated with color map entry\n        // values in range 0-255 instead of 0-65535 - try to handle these\n        // gracefully.\n        if( nMaxColor > 0 && nMaxColor < 256 )\n        {\n            CPLDebug( \"GTiff\", \"TIFF ColorTable seems to be improperly scaled, fixing up.\" );\n            \n            for( int iColor = nColorCount - 1; iColor >= 0; iColor-- )\n            {\n                oEntry.c1 = panRed[iColor];\n                oEntry.c2 = panGreen[iColor];\n                oEntry.c3 = panBlue[iColor];\n                oEntry.c4 = 255;\n                \n                poColorTable->SetColorEntry( iColor, &oEntry );\n            }\n        }\n    }\n    \n/* -------------------------------------------------------------------- */\n/*      Create band information objects.                                */\n/* -------------------------------------------------------------------- */\n    for( int iBand = 0; iBand < nBands; iBand++ )\n    {\n        if( bTreatAsRGBA )\n            SetBand( iBand+1, new GTiffRGBABand( this, iBand+1 ) );\n        else if( bTreatAsSplitBitmap )\n            SetBand( iBand+1, new GTiffSplitBitmapBand( this, iBand+1 ) );\n        else if( bTreatAsSplit )\n            SetBand( iBand+1, new GTiffSplitBand( this, iBand+1 ) );\n        else if( bTreatAsBitmap )\n            SetBand( iBand+1, new GTiffBitmapBand( this, iBand+1 ) );\n        else if( bTreatAsOdd )\n            SetBand( iBand+1, new GTiffOddBitsBand( this, iBand+1 ) );\n        else\n            SetBand( iBand+1, new GTiffRasterBand( this, iBand+1 ) );\n    }\n\n    if( GetRasterBand(1)->GetRasterDataType() == GDT_Unknown )\n    {\n        CPLError( CE_Failure, CPLE_NotSupported,\n                  \"Unsupported TIFF configuration.\" );\n        return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Get the transform or gcps from the GeoTIFF file.                */\n/* -------------------------------------------------------------------- */\n    if( bBaseIn )\n    {\n        char    *pszTabWKT = NULL;\n        double\t*padfTiePoints, *padfScale, *padfMatrix;\n        uint16\tnCount;\n\n        adfGeoTransform[0] = 0.0;\n        adfGeoTransform[1] = 1.0;\n        adfGeoTransform[2] = 0.0;\n        adfGeoTransform[3] = 0.0;\n        adfGeoTransform[4] = 0.0;\n        adfGeoTransform[5] = 1.0;\n    \n        if( TIFFGetField(hTIFF,TIFFTAG_GEOPIXELSCALE,&nCount,&padfScale )\n            && nCount >= 2 \n            && padfScale[0] != 0.0 && padfScale[1] != 0.0 )\n        {\n            adfGeoTransform[1] = padfScale[0];\n            adfGeoTransform[5] = - ABS(padfScale[1]);\n\n            if( TIFFGetField(hTIFF,TIFFTAG_GEOTIEPOINTS,&nCount,&padfTiePoints )\n                && nCount >= 6 )\n            {\n                adfGeoTransform[0] =\n                    padfTiePoints[3] - padfTiePoints[0] * adfGeoTransform[1];\n                adfGeoTransform[3] =\n                    padfTiePoints[4] - padfTiePoints[1] * adfGeoTransform[5];\n\n                bGeoTransformValid = TRUE;\n            }\n        }\n\n        else if( TIFFGetField(hTIFF,TIFFTAG_GEOTRANSMATRIX,&nCount,&padfMatrix ) \n                 && nCount == 16 )\n        {\n            adfGeoTransform[0] = padfMatrix[3];\n            adfGeoTransform[1] = padfMatrix[0];\n            adfGeoTransform[2] = padfMatrix[1];\n            adfGeoTransform[3] = padfMatrix[7];\n            adfGeoTransform[4] = padfMatrix[4];\n            adfGeoTransform[5] = padfMatrix[5];\n            bGeoTransformValid = TRUE;\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Otherwise try looking for a .tfw, .tifw or .wld file.           */\n/* -------------------------------------------------------------------- */\n        else\n        {\n            bGeoTransformValid = \n                GDALReadWorldFile( osFilename, NULL, adfGeoTransform );\n\n            if( !bGeoTransformValid )\n            {\n                bGeoTransformValid = \n                    GDALReadWorldFile( osFilename, \"wld\", adfGeoTransform );\n            }\n\n            if( !bGeoTransformValid )\n            {\n                int bTabFileOK = \n                    GDALReadTabFile( osFilename, adfGeoTransform, \n                                     &pszTabWKT, &nGCPCount, &pasGCPList );\n\n                if( bTabFileOK && nGCPCount == 0 )\n                    bGeoTransformValid = TRUE;\n            }\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Check for GCPs.  Note, we will allow there to be GCPs and a     */\n/*      transform in some circumstances.                                */\n/* -------------------------------------------------------------------- */\n        if( TIFFGetField(hTIFF,TIFFTAG_GEOTIEPOINTS,&nCount,&padfTiePoints )\n            && !bGeoTransformValid )\n        {\n            nGCPCount = nCount / 6;\n            pasGCPList = (GDAL_GCP *) CPLCalloc(sizeof(GDAL_GCP),nGCPCount);\n        \n            for( int iGCP = 0; iGCP < nGCPCount; iGCP++ )\n            {\n                char\tszID[32];\n\n                sprintf( szID, \"%d\", iGCP+1 );\n                pasGCPList[iGCP].pszId = CPLStrdup( szID );\n                pasGCPList[iGCP].pszInfo = CPLStrdup(\"\");\n                pasGCPList[iGCP].dfGCPPixel = padfTiePoints[iGCP*6+0];\n                pasGCPList[iGCP].dfGCPLine = padfTiePoints[iGCP*6+1];\n                pasGCPList[iGCP].dfGCPX = padfTiePoints[iGCP*6+3];\n                pasGCPList[iGCP].dfGCPY = padfTiePoints[iGCP*6+4];\n                pasGCPList[iGCP].dfGCPZ = padfTiePoints[iGCP*6+5];\n            }\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Did we find a tab file?  If so we will use it's coordinate      */\n/*      system and give it precidence.                                  */\n/* -------------------------------------------------------------------- */\n        if( pszTabWKT != NULL \n            && (pszProjection == NULL || pszProjection[0] == '\\0') )\n        {\n            CPLFree( pszProjection );\n            pszProjection = pszTabWKT;\n            pszTabWKT = NULL;\n            bLookedForProjection = TRUE;\n        }\n        \n        CPLFree( pszTabWKT );\n        bGeoTIFFInfoChanged = FALSE;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Capture some other potentially interesting information.         */\n/* -------------------------------------------------------------------- */\n    char\t*pszText, szWorkMDI[200];\n    float   fResolution;\n    uint16  nShort;\n\n    if( TIFFGetField( hTIFF, TIFFTAG_DOCUMENTNAME, &pszText ) )\n        SetMetadataItem( \"TIFFTAG_DOCUMENTNAME\",  pszText );\n\n    if( TIFFGetField( hTIFF, TIFFTAG_IMAGEDESCRIPTION, &pszText ) )\n        SetMetadataItem( \"TIFFTAG_IMAGEDESCRIPTION\", pszText );\n\n    if( TIFFGetField( hTIFF, TIFFTAG_SOFTWARE, &pszText ) )\n        SetMetadataItem( \"TIFFTAG_SOFTWARE\", pszText );\n\n    if( TIFFGetField( hTIFF, TIFFTAG_DATETIME, &pszText ) )\n        SetMetadataItem( \"TIFFTAG_DATETIME\", pszText );\n\n    if( TIFFGetField( hTIFF, TIFFTAG_ARTIST, &pszText ) )\n        SetMetadataItem( \"TIFFTAG_ARTIST\", pszText );\n\n    if( TIFFGetField( hTIFF, TIFFTAG_HOSTCOMPUTER, &pszText ) )\n        SetMetadataItem( \"TIFFTAG_HOSTCOMPUTER\", pszText );\n\n    if( TIFFGetField( hTIFF, TIFFTAG_COPYRIGHT, &pszText ) )\n        SetMetadataItem( \"TIFFTAG_COPYRIGHT\", pszText );\n\n    if( TIFFGetField( hTIFF, TIFFTAG_XRESOLUTION, &fResolution ) )\n    {\n        sprintf( szWorkMDI, \"%.8g\", fResolution );\n        SetMetadataItem( \"TIFFTAG_XRESOLUTION\", szWorkMDI );\n    }\n\n    if( TIFFGetField( hTIFF, TIFFTAG_YRESOLUTION, &fResolution ) )\n    {\n        sprintf( szWorkMDI, \"%.8g\", fResolution );\n        SetMetadataItem( \"TIFFTAG_YRESOLUTION\", szWorkMDI );\n    }\n\n    if( TIFFGetField( hTIFF, TIFFTAG_MINSAMPLEVALUE, &nShort ) )\n    {\n        sprintf( szWorkMDI, \"%d\", nShort );\n        SetMetadataItem( \"TIFFTAG_MINSAMPLEVALUE\", szWorkMDI );\n    }\n\n    if( TIFFGetField( hTIFF, TIFFTAG_MAXSAMPLEVALUE, &nShort ) )\n    {\n        sprintf( szWorkMDI, \"%d\", nShort );\n        SetMetadataItem( \"TIFFTAG_MAXSAMPLEVALUE\", szWorkMDI );\n    }\n\n    if( TIFFGetField( hTIFF, TIFFTAG_RESOLUTIONUNIT, &nShort ) )\n    {\n        if( nShort == RESUNIT_NONE )\n            sprintf( szWorkMDI, \"%d (unitless)\", nShort );\n        else if( nShort == RESUNIT_INCH )\n            sprintf( szWorkMDI, \"%d (pixels/inch)\", nShort );\n        else if( nShort == RESUNIT_CENTIMETER )\n            sprintf( szWorkMDI, \"%d (pixels/cm)\", nShort );\n        else\n            sprintf( szWorkMDI, \"%d\", nShort );\n        SetMetadataItem( \"TIFFTAG_RESOLUTIONUNIT\", szWorkMDI );\n    }\n\n    if( nCompression == COMPRESSION_NONE )\n        /* no compression tag */;\n    else if( nCompression == COMPRESSION_CCITTRLE )\n        SetMetadataItem( \"COMPRESSION\", \"CCITTRLE\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_CCITTFAX3 )\n        SetMetadataItem( \"COMPRESSION\", \"CCITTFAX3\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_CCITTFAX4 )\n        SetMetadataItem( \"COMPRESSION\", \"CCITTFAX4\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_LZW )\n        SetMetadataItem( \"COMPRESSION\", \"LZW\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_OJPEG )\n        SetMetadataItem( \"COMPRESSION\", \"OJPEG\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_JPEG )\n    {  \n        if ( nPhotometric == PHOTOMETRIC_YCBCR )\n            SetMetadataItem( \"COMPRESSION\", \"YCbCr JPEG\", \"IMAGE_STRUCTURE\" );\n        else\n            SetMetadataItem( \"COMPRESSION\", \"JPEG\", \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_NEXT )\n        SetMetadataItem( \"COMPRESSION\", \"NEXT\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_CCITTRLEW )\n        SetMetadataItem( \"COMPRESSION\", \"CCITTRLEW\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_PACKBITS )\n        SetMetadataItem( \"COMPRESSION\", \"PACKBITS\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_THUNDERSCAN )\n        SetMetadataItem( \"COMPRESSION\", \"THUNDERSCAN\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_PIXARFILM )\n        SetMetadataItem( \"COMPRESSION\", \"PIXARFILM\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_PIXARLOG )\n        SetMetadataItem( \"COMPRESSION\", \"PIXARLOG\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_DEFLATE )\n        SetMetadataItem( \"COMPRESSION\", \"DEFLATE\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_ADOBE_DEFLATE )\n        SetMetadataItem( \"COMPRESSION\", \"DEFLATE\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_DCS )\n        SetMetadataItem( \"COMPRESSION\", \"DCS\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_JBIG )\n        SetMetadataItem( \"COMPRESSION\", \"JBIG\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_SGILOG )\n        SetMetadataItem( \"COMPRESSION\", \"SGILOG\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_SGILOG24 )\n        SetMetadataItem( \"COMPRESSION\", \"SGILOG24\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_JP2000 )\n        SetMetadataItem( \"COMPRESSION\", \"JP2000\", \"IMAGE_STRUCTURE\" );\n    else\n    {\n        CPLString oComp;\n        SetMetadataItem( \"COMPRESSION\", \n                         (const char *) oComp.Printf( \"%d\", nCompression));\n    }\n\n    if( nPlanarConfig == PLANARCONFIG_CONTIG && nBands != 1 )\n        SetMetadataItem( \"INTERLEAVE\", \"PIXEL\", \"IMAGE_STRUCTURE\" );\n    else\n        SetMetadataItem( \"INTERLEAVE\", \"BAND\", \"IMAGE_STRUCTURE\" );\n\n    if(  (GetRasterBand(1)->GetRasterDataType() == GDT_Byte   && nBitsPerSample != 8 ) ||\n         (GetRasterBand(1)->GetRasterDataType() == GDT_UInt16 && nBitsPerSample != 16) ||\n         (GetRasterBand(1)->GetRasterDataType() == GDT_UInt32 && nBitsPerSample != 32) )\n    {\n        for (int i = 0; i < nBands; ++i)\n            GetRasterBand(i+1)->SetMetadataItem( \"NBITS\", \n                                                 CPLString().Printf( \"%d\", (int)nBitsPerSample ),\n                                                 \"IMAGE_STRUCTURE\" );\n    }\n        \n    if( bMinIsWhite )\n        SetMetadataItem( \"MINISWHITE\", \"YES\", \"IMAGE_STRUCTURE\" );\n\n    if( TIFFGetField( hTIFF, TIFFTAG_GDAL_METADATA, &pszText ) )\n    {\n        CPLXMLNode *psRoot = CPLParseXMLString( pszText );\n        CPLXMLNode *psItem = NULL;\n\n        if( psRoot != NULL && psRoot->eType == CXT_Element\n            && EQUAL(psRoot->pszValue,\"GDALMetadata\") )\n            psItem = psRoot->psChild;\n\n        for( ; psItem != NULL; psItem = psItem->psNext )\n        {\n            const char *pszKey, *pszValue, *pszRole, *pszDomain; \n            char *pszUnescapedValue;\n            int nBand, bIsXML = FALSE;\n\n            if( psItem->eType != CXT_Element\n                || !EQUAL(psItem->pszValue,\"Item\") )\n                continue;\n\n            pszKey = CPLGetXMLValue( psItem, \"name\", NULL );\n            pszValue = CPLGetXMLValue( psItem, NULL, NULL );\n            nBand = atoi(CPLGetXMLValue( psItem, \"sample\", \"-1\" )) + 1;\n            pszRole = CPLGetXMLValue( psItem, \"role\", \"\" );\n            pszDomain = CPLGetXMLValue( psItem, \"domain\", \"\" );\n                \n            if( pszKey == NULL || pszValue == NULL )\n                continue;\n\n            if( EQUALN(pszDomain,\"xml:\",4) )\n                bIsXML = TRUE;\n\n            pszUnescapedValue = CPLUnescapeString( pszValue, NULL, \n                                                   CPLES_XML );\n            if( nBand == 0 )\n            {\n                if( bIsXML )\n                {\n                    char *apszMD[2] = { pszUnescapedValue, NULL };\n                    SetMetadata( apszMD, pszDomain );\n                }\n                else\n                    SetMetadataItem( pszKey, pszUnescapedValue, pszDomain );\n            }\n            else\n            {\n                GDALRasterBand *poBand = GetRasterBand(nBand);\n                if( poBand != NULL )\n                {\n                    if( EQUAL(pszRole,\"scale\") )\n                        poBand->SetScale( atof(pszUnescapedValue) );\n                    else if( EQUAL(pszRole,\"offset\") )\n                        poBand->SetOffset( atof(pszUnescapedValue) );\n                    else if( EQUAL(pszRole,\"unittype\") )\n                        poBand->SetUnitType( pszUnescapedValue );\n                    else\n                    {\n                        if( bIsXML )\n                        {\n                            char *apszMD[2] = { pszUnescapedValue, NULL };\n                            poBand->SetMetadata( apszMD, pszDomain );\n                        }\n                        else\n                            poBand->SetMetadataItem(pszKey,pszUnescapedValue,\n                                                    pszDomain );\n                    }\n                }\n            }\n            CPLFree( pszUnescapedValue );\n        }\n\n        CPLDestroyXMLNode( psRoot );\n    }\n\n    bMetadataChanged = FALSE;\n\n/* -------------------------------------------------------------------- */\n/*      Check for RPC metadata in an RPB file.                          */\n/* -------------------------------------------------------------------- */\n    if( bBaseIn )\n    {\n        char **papszRPCMD = GDALLoadRPBFile( osFilename, NULL );\n        \n        if( papszRPCMD != NULL )\n        {\n            oGTiffMDMD.SetMetadata( papszRPCMD, \"RPC\" );\n            CSLDestroy( papszRPCMD );\n            bMetadataChanged = FALSE;\n        }\n        else\n            ReadRPCTag();\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Check for RPC metadata in an RPB file.                          */\n/* -------------------------------------------------------------------- */\n    if( bBaseIn )\n    {\n        char **papszIMDMD = GDALLoadIMDFile( osFilename, NULL );\n\n        if( papszIMDMD != NULL )\n        {\n            oGTiffMDMD.SetMetadata( papszIMDMD, \"IMD\" );\n            CSLDestroy( papszIMDMD );\n            bMetadataChanged = FALSE;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Check for NODATA                                                */\n/* -------------------------------------------------------------------- */\n    if( TIFFGetField( hTIFF, TIFFTAG_GDAL_NODATA, &pszText ) )\n    {\n        bNoDataSet = TRUE;\n        dfNoDataValue = atof( pszText );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If this is a \"base\" raster, we should scan for any              */\n/*      associated overviews, internal mask bands and subdatasets.      */\n/* -------------------------------------------------------------------- */\n    if( bBase )\n    {\n        char **papszSubdatasets = NULL;\n        int  iDirIndex = 0;\n\n        FlushDirectory();  \n        while( !TIFFLastDirectory( hTIFF ) \n               && (iDirIndex == 0 || TIFFReadDirectory( hTIFF ) != 0) )\n        {\n            toff_t\tnThisDir = TIFFCurrentDirOffset(hTIFF);\n            uint32\tnSubType = 0;\n\n            *ppoActiveDSRef = NULL; // our directory no longer matches this ds\n            \n            iDirIndex++;\n\n            if( !TIFFGetField(hTIFF, TIFFTAG_SUBFILETYPE, &nSubType) )\n                nSubType = 0;\n\n            /* Embedded overview of the main image */\n            if ((nSubType & FILETYPE_REDUCEDIMAGE) != 0 &&\n                (nSubType & FILETYPE_MASK) == 0 &&\n                iDirIndex != 1 )\n            {\n                GTiffDataset\t*poODS;\n                \n                poODS = new GTiffDataset();\n                if( poODS->OpenOffset( hTIFF, ppoActiveDSRef, nThisDir, FALSE, \n                                       eAccess ) != CE_None \n                    || poODS->GetRasterCount() != GetRasterCount() )\n                {\n                    delete poODS;\n                }\n                else\n                {\n                    CPLDebug( \"GTiff\", \"Opened %dx%d overview.\\n\", \n                              poODS->GetRasterXSize(), poODS->GetRasterYSize());\n                    nOverviewCount++;\n                    papoOverviewDS = (GTiffDataset **)\n                        CPLRealloc(papoOverviewDS, \n                                   nOverviewCount * (sizeof(void*)));\n                    papoOverviewDS[nOverviewCount-1] = poODS;\n                    poODS->poBaseDS = this;\n                }\n            }\n            \n            /* Embedded mask of the main image */\n            else if ((nSubType & FILETYPE_MASK) != 0 &&\n                     (nSubType & FILETYPE_REDUCEDIMAGE) == 0 &&\n                     poMaskDS == NULL )\n            {\n                poMaskDS = new GTiffDataset();\n                \n                /* The TIFF6 specification - page 37 - only allows 1 SamplesPerPixel and 1 BitsPerSample\n                   Here we support either 1 or 8 bit per sample\n                   and we support either 1 sample per pixel or as many samples as in the main image\n                   We don't check the value of the PhotometricInterpretation tag, which should be\n                   set to \"Transparency mask\" (4) according to the specification (page 36)\n                   ... But the TIFF6 specification allows image masks to have a higher resolution than\n                   the main image, what we don't support here\n                */\n\n                if( poMaskDS->OpenOffset( hTIFF, ppoActiveDSRef, nThisDir, \n                                          FALSE, eAccess ) != CE_None \n                    || poMaskDS->GetRasterCount() == 0\n                    || !(poMaskDS->GetRasterCount() == 1 || poMaskDS->GetRasterCount() == GetRasterCount())\n                    || poMaskDS->GetRasterXSize() != GetRasterXSize()\n                    || poMaskDS->GetRasterYSize() != GetRasterYSize()\n                    || poMaskDS->GetRasterBand(1)->GetRasterDataType() != GDT_Byte)\n                {\n                    delete poMaskDS;\n                    poMaskDS = NULL;\n                }\n                else\n                {\n                    CPLDebug( \"GTiff\", \"Opened band mask.\\n\");\n                    poMaskDS->poBaseDS = this;\n                }\n            }\n            \n            /* Embedded mask of an overview */\n            /* The TIFF6 specification allows the combination of the FILETYPE_xxxx masks */\n            else if (nSubType & (FILETYPE_REDUCEDIMAGE | FILETYPE_MASK))\n            {\n                GTiffDataset* poDS = new GTiffDataset();\n                if( poDS->OpenOffset( hTIFF, ppoActiveDSRef, nThisDir, FALSE, \n                                      eAccess ) != CE_None\n                    || poDS->GetRasterCount() == 0\n                    || poDS->GetRasterBand(1)->GetRasterDataType() != GDT_Byte)\n                {\n                    delete poDS;\n                }\n                else\n                {\n                    int i;\n                    for(i=0;i<nOverviewCount;i++)\n                    {\n                        if (((GTiffDataset*)papoOverviewDS[i])->poMaskDS == NULL &&\n                            poDS->GetRasterXSize() == papoOverviewDS[i]->GetRasterXSize() &&\n                            poDS->GetRasterYSize() == papoOverviewDS[i]->GetRasterYSize() &&\n                            (poDS->GetRasterCount() == 1 || poDS->GetRasterCount() == GetRasterCount()))\n                        {\n                            CPLDebug( \"GTiff\", \"Opened band mask for %dx%d overview.\\n\",\n                                      poDS->GetRasterXSize(), poDS->GetRasterYSize());\n                            ((GTiffDataset*)papoOverviewDS[i])->poMaskDS = poDS;\n                            poDS->poBaseDS = this;\n                            break;\n                        }\n                    }\n                    if (i == nOverviewCount)\n                    {\n                        delete poDS;\n                    }\n                }\n            }\n            else if( nSubType == 0 ) {\n                CPLString osName, osDesc;\n                uint32\tnXSize, nYSize;\n                uint16  nSPP;\n\n                TIFFGetField( hTIFF, TIFFTAG_IMAGEWIDTH, &nXSize );\n                TIFFGetField( hTIFF, TIFFTAG_IMAGELENGTH, &nYSize );\n                if( !TIFFGetField(hTIFF, TIFFTAG_SAMPLESPERPIXEL, &nSPP ) )\n                    nSPP = 1;\n\n                osName.Printf( \"SUBDATASET_%d_NAME=GTIFF_DIR:%d:%s\", \n                               iDirIndex, iDirIndex, osFilename.c_str() );\n                osDesc.Printf( \"SUBDATASET_%d_DESC=Page %d (%dP x %dL x %dB)\", \n                               iDirIndex, iDirIndex, \n                               (int)nXSize, (int)nYSize, nSPP );\n\n                papszSubdatasets = \n                    CSLAddString( papszSubdatasets, osName );\n                papszSubdatasets = \n                    CSLAddString( papszSubdatasets, osDesc );\n            }\n\n            // Make sure we are stepping from the expected directory regardless\n            // of churn done processing the above.\n            if( TIFFCurrentDirOffset(hTIFF) != nThisDir )\n                TIFFSetSubDirectory( hTIFF, nThisDir );\n            *ppoActiveDSRef = NULL;\n        }\n\n        /* If we have a mask for the main image, loop over the overviews, and if they */\n        /* have a mask, let's set this mask as an overview of the main mask... */\n        if (poMaskDS != NULL)\n        {\n            int i;\n            for(i=0;i<nOverviewCount;i++)\n            {\n                if (((GTiffDataset*)papoOverviewDS[i])->poMaskDS != NULL)\n                {\n                    poMaskDS->nOverviewCount++;\n                    poMaskDS->papoOverviewDS = (GTiffDataset **)\n                        CPLRealloc(poMaskDS->papoOverviewDS, \n                                poMaskDS->nOverviewCount * (sizeof(void*)));\n                    poMaskDS->papoOverviewDS[poMaskDS->nOverviewCount-1] =\n                            ((GTiffDataset*)papoOverviewDS[i])->poMaskDS;\n                }\n            }\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Only keep track of subdatasets if we have more than one         */\n/*      subdataset (pair).                                              */\n/* -------------------------------------------------------------------- */\n        if( CSLCount(papszSubdatasets) > 2 )\n        {\n            oGTiffMDMD.SetMetadata( papszSubdatasets, \"SUBDATASETS\" );\n        }\n        CSLDestroy( papszSubdatasets );\n    }\n\n    return( CE_None );\n}",
    "std::unique_ptr<GTiffGrid> GTiffDataset::nextGrid() {\n    if (!m_hasNextGrid)\n        return nullptr;\n    if (m_nextDirOffset) {\n        TIFFSetSubDirectory(m_hTIFF, m_nextDirOffset);\n    }\n\n    uint32_t width = 0;\n    uint32_t height = 0;\n    TIFFGetField(m_hTIFF, TIFFTAG_IMAGEWIDTH, &width);\n    TIFFGetField(m_hTIFF, TIFFTAG_IMAGELENGTH, &height);\n    if (width == 0 || height == 0 || width > INT_MAX || height > INT_MAX) {\n        pj_log(m_ctx, PJ_LOG_ERROR, _(\"Invalid image size\"));\n        return nullptr;\n    }\n\n    uint16_t samplesPerPixel = 0;\n    if (!TIFFGetField(m_hTIFF, TIFFTAG_SAMPLESPERPIXEL, &samplesPerPixel)) {\n        pj_log(m_ctx, PJ_LOG_ERROR, _(\"Missing SamplesPerPixel tag\"));\n        return nullptr;\n    }\n    if (samplesPerPixel == 0) {\n        pj_log(m_ctx, PJ_LOG_ERROR, _(\"Invalid SamplesPerPixel value\"));\n        return nullptr;\n    }\n\n    uint16_t bitsPerSample = 0;\n    if (!TIFFGetField(m_hTIFF, TIFFTAG_BITSPERSAMPLE, &bitsPerSample)) {\n        pj_log(m_ctx, PJ_LOG_ERROR, _(\"Missing BitsPerSample tag\"));\n        return nullptr;\n    }\n\n    uint16_t planarConfig = 0;\n    if (!TIFFGetField(m_hTIFF, TIFFTAG_PLANARCONFIG, &planarConfig)) {\n        pj_log(m_ctx, PJ_LOG_ERROR, _(\"Missing PlanarConfig tag\"));\n        return nullptr;\n    }\n\n    uint16_t sampleFormat = 0;\n    if (!TIFFGetField(m_hTIFF, TIFFTAG_SAMPLEFORMAT, &sampleFormat)) {\n        pj_log(m_ctx, PJ_LOG_ERROR, _(\"Missing SampleFormat tag\"));\n        return nullptr;\n    }\n\n    TIFFDataType dt;\n    if (sampleFormat == SAMPLEFORMAT_INT && bitsPerSample == 16)\n        dt = TIFFDataType::Int16;\n    else if (sampleFormat == SAMPLEFORMAT_UINT && bitsPerSample == 16)\n        dt = TIFFDataType::UInt16;\n    else if (sampleFormat == SAMPLEFORMAT_INT && bitsPerSample == 32)\n        dt = TIFFDataType::Int32;\n    else if (sampleFormat == SAMPLEFORMAT_UINT && bitsPerSample == 32)\n        dt = TIFFDataType::UInt32;\n    else if (sampleFormat == SAMPLEFORMAT_IEEEFP && bitsPerSample == 32)\n        dt = TIFFDataType::Float32;\n    else if (sampleFormat == SAMPLEFORMAT_IEEEFP && bitsPerSample == 64)\n        dt = TIFFDataType::Float64;\n    else {\n        pj_log(m_ctx, PJ_LOG_ERROR,\n               _(\"Unsupported combination of SampleFormat \"\n                 \"and BitsPerSample values\"));\n        return nullptr;\n    }\n\n    uint16_t photometric = PHOTOMETRIC_MINISBLACK;\n    if (!TIFFGetField(m_hTIFF, TIFFTAG_PHOTOMETRIC, &photometric))\n        photometric = PHOTOMETRIC_MINISBLACK;\n    if (photometric != PHOTOMETRIC_MINISBLACK) {\n        pj_log(m_ctx, PJ_LOG_ERROR, _(\"Unsupported Photometric value\"));\n        return nullptr;\n    }\n\n    uint16_t compression = COMPRESSION_NONE;\n    if (!TIFFGetField(m_hTIFF, TIFFTAG_COMPRESSION, &compression))\n        compression = COMPRESSION_NONE;\n\n    if (compression != COMPRESSION_NONE &&\n        !TIFFIsCODECConfigured(compression)) {\n        pj_log(m_ctx, PJ_LOG_ERROR,\n               _(\"Cannot open TIFF file due to missing codec.\"));\n        return nullptr;\n    }\n    // We really don't want to try dealing with old-JPEG images\n    if (compression == COMPRESSION_OJPEG) {\n        pj_log(m_ctx, PJ_LOG_ERROR, _(\"Unsupported compression method.\"));\n        return nullptr;\n    }\n\n    const auto blockSize = TIFFIsTiled(m_hTIFF) ? TIFFTileSize64(m_hTIFF)\n                                                : TIFFStripSize64(m_hTIFF);\n    if (blockSize == 0 || blockSize > 64 * 1024 * 2014) {\n        pj_log(m_ctx, PJ_LOG_ERROR, _(\"Unsupported block size.\"));\n        return nullptr;\n    }\n\n    unsigned short count = 0;\n    unsigned short *geokeys = nullptr;\n    bool pixelIsArea = false;\n\n    ExtentAndRes extent;\n    extent.isGeographic = true;\n\n    if (!TIFFGetField(m_hTIFF, TIFFTAG_GEOKEYDIRECTORY, &count, &geokeys)) {\n        pj_log(m_ctx, PJ_LOG_TRACE, \"No GeoKeys tag\");\n    } else {\n        if (count < 4 || (count % 4) != 0) {\n            pj_log(m_ctx, PJ_LOG_ERROR,\n                   _(\"Wrong number of values in GeoKeys tag\"));\n            return nullptr;\n        }\n\n        if (geokeys[0] != 1) {\n            pj_log(m_ctx, PJ_LOG_ERROR, _(\"Unsupported GeoTIFF major version\"));\n            return nullptr;\n        }\n        // We only know that we support GeoTIFF 1.0 and 1.1 at that time\n        if (geokeys[1] != 1 || geokeys[2] > 1) {\n            pj_log(m_ctx, PJ_LOG_TRACE, \"GeoTIFF %d.%d possibly not handled\",\n                   geokeys[1], geokeys[2]);\n        }\n\n        for (unsigned int i = 4; i + 3 < count; i += 4) {\n            constexpr unsigned short GTModelTypeGeoKey = 1024;\n            constexpr unsigned short ModelTypeProjected = 1;\n            constexpr unsigned short ModelTypeGeographic = 2;\n\n            constexpr unsigned short GTRasterTypeGeoKey = 1025;\n            constexpr unsigned short RasterPixelIsArea = 1;\n            // constexpr unsigned short RasterPixelIsPoint = 2;\n\n            if (geokeys[i] == GTModelTypeGeoKey) {\n                if (geokeys[i + 3] == ModelTypeProjected) {\n                    extent.isGeographic = false;\n                } else if (geokeys[i + 3] != ModelTypeGeographic) {\n                    pj_log(m_ctx, PJ_LOG_ERROR,\n                           _(\"Only GTModelTypeGeoKey = \"\n                             \"ModelTypeGeographic or ModelTypeProjected are \"\n                             \"supported\"));\n                    return nullptr;\n                }\n            } else if (geokeys[i] == GTRasterTypeGeoKey) {\n                if (geokeys[i + 3] == RasterPixelIsArea) {\n                    pixelIsArea = true;\n                }\n            }\n        }\n    }\n\n    double hRes = 0;\n    double vRes = 0;\n    double west = 0;\n    double north = 0;\n\n    double *matrix = nullptr;\n    if (TIFFGetField(m_hTIFF, TIFFTAG_GEOTRANSMATRIX, &count, &matrix) &&\n        count == 16) {\n        // If using GDAL to produce a bottom-up georeferencing, it will produce\n        // a GeoTransformationMatrix, since negative values in GeoPixelScale\n        // have historically been implementation bugs.\n        if (matrix[1] != 0 || matrix[4] != 0) {\n            pj_log(m_ctx, PJ_LOG_ERROR,\n                   _(\"Rotational terms not supported in \"\n                     \"GeoTransformationMatrix tag\"));\n            return nullptr;\n        }\n\n        west = matrix[3];\n        hRes = matrix[0];\n        north = matrix[7];\n        vRes = -matrix[5]; // negation to simulate GeoPixelScale convention\n    } else {\n        double *geopixelscale = nullptr;\n        if (TIFFGetField(m_hTIFF, TIFFTAG_GEOPIXELSCALE, &count,\n                         &geopixelscale) != 1) {\n            pj_log(m_ctx, PJ_LOG_ERROR, _(\"No GeoPixelScale tag\"));\n            return nullptr;\n        }\n        if (count != 3) {\n            pj_log(m_ctx, PJ_LOG_ERROR,\n                   _(\"Wrong number of values in GeoPixelScale tag\"));\n            return nullptr;\n        }\n        hRes = geopixelscale[0];\n        vRes = geopixelscale[1];\n\n        double *geotiepoints = nullptr;\n        if (TIFFGetField(m_hTIFF, TIFFTAG_GEOTIEPOINTS, &count,\n                         &geotiepoints) != 1) {\n            pj_log(m_ctx, PJ_LOG_ERROR, _(\"No GeoTiePoints tag\"));\n            return nullptr;\n        }\n        if (count != 6) {\n            pj_log(m_ctx, PJ_LOG_ERROR,\n                   _(\"Wrong number of values in GeoTiePoints tag\"));\n            return nullptr;\n        }\n\n        west = geotiepoints[3] - geotiepoints[0] * hRes;\n        north = geotiepoints[4] + geotiepoints[1] * vRes;\n    }\n\n    if (pixelIsArea) {\n        west += 0.5 * hRes;\n        north -= 0.5 * vRes;\n    }\n\n    const double mulFactor = extent.isGeographic ? DEG_TO_RAD : 1;\n    extent.west = west * mulFactor;\n    extent.north = north * mulFactor;\n    extent.resX = hRes * mulFactor;\n    extent.resY = fabs(vRes) * mulFactor;\n    extent.east = (west + hRes * (width - 1)) * mulFactor;\n    extent.south = (north - vRes * (height - 1)) * mulFactor;\n    extent.computeInvRes();\n\n    if (vRes < 0) {\n        std::swap(extent.north, extent.south);\n    }\n\n    if (!((!extent.isGeographic ||\n           (fabs(extent.west) <= 4 * M_PI && fabs(extent.east) <= 4 * M_PI &&\n            fabs(extent.north) <= M_PI + 1e-5 &&\n            fabs(extent.south) <= M_PI + 1e-5)) &&\n          extent.west < extent.east && extent.south < extent.north &&\n          extent.resX > 1e-10 && extent.resY > 1e-10)) {\n        pj_log(m_ctx, PJ_LOG_ERROR, _(\"Inconsistent georeferencing for %s\"),\n               m_filename.c_str());\n        return nullptr;\n    }\n\n    auto ret = std::unique_ptr<GTiffGrid>(new GTiffGrid(\n        m_ctx, m_hTIFF, m_cache, m_fp.get(), m_ifdIdx, m_filename, width,\n        height, extent, dt, samplesPerPixel, planarConfig, vRes < 0));\n    m_ifdIdx++;\n    m_hasNextGrid = TIFFReadDirectory(m_hTIFF) != 0;\n    m_nextDirOffset = TIFFCurrentDirOffset(m_hTIFF);\n    return ret;\n}",
    "std::unique_ptr<GTiffGrid> GTiffDataset::nextGrid() {\n    if (!m_hasNextGrid)\n        return nullptr;\n    if (m_nextDirOffset) {\n        TIFFSetSubDirectory(m_hTIFF, m_nextDirOffset);\n    }\n\n    uint32_t width = 0;\n    uint32_t height = 0;\n    TIFFGetField(m_hTIFF, TIFFTAG_IMAGEWIDTH, &width);\n    TIFFGetField(m_hTIFF, TIFFTAG_IMAGELENGTH, &height);\n    if (width == 0 || height == 0 || width > INT_MAX || height > INT_MAX) {\n        pj_log(m_ctx, PJ_LOG_ERROR, _(\"Invalid image size\"));\n        return nullptr;\n    }\n\n    uint16_t samplesPerPixel = 0;\n    if (!TIFFGetField(m_hTIFF, TIFFTAG_SAMPLESPERPIXEL, &samplesPerPixel)) {\n        pj_log(m_ctx, PJ_LOG_ERROR, _(\"Missing SamplesPerPixel tag\"));\n        return nullptr;\n    }\n    if (samplesPerPixel == 0) {\n        pj_log(m_ctx, PJ_LOG_ERROR, _(\"Invalid SamplesPerPixel value\"));\n        return nullptr;\n    }\n\n    uint16_t bitsPerSample = 0;\n    if (!TIFFGetField(m_hTIFF, TIFFTAG_BITSPERSAMPLE, &bitsPerSample)) {\n        pj_log(m_ctx, PJ_LOG_ERROR, _(\"Missing BitsPerSample tag\"));\n        return nullptr;\n    }\n\n    uint16_t planarConfig = 0;\n    if (!TIFFGetField(m_hTIFF, TIFFTAG_PLANARCONFIG, &planarConfig)) {\n        pj_log(m_ctx, PJ_LOG_ERROR, _(\"Missing PlanarConfig tag\"));\n        return nullptr;\n    }\n\n    uint16_t sampleFormat = 0;\n    if (!TIFFGetField(m_hTIFF, TIFFTAG_SAMPLEFORMAT, &sampleFormat)) {\n        pj_log(m_ctx, PJ_LOG_ERROR, _(\"Missing SampleFormat tag\"));\n        return nullptr;\n    }\n\n    TIFFDataType dt;\n    if (sampleFormat == SAMPLEFORMAT_INT && bitsPerSample == 16)\n        dt = TIFFDataType::Int16;\n    else if (sampleFormat == SAMPLEFORMAT_UINT && bitsPerSample == 16)\n        dt = TIFFDataType::UInt16;\n    else if (sampleFormat == SAMPLEFORMAT_INT && bitsPerSample == 32)\n        dt = TIFFDataType::Int32;\n    else if (sampleFormat == SAMPLEFORMAT_UINT && bitsPerSample == 32)\n        dt = TIFFDataType::UInt32;\n    else if (sampleFormat == SAMPLEFORMAT_IEEEFP && bitsPerSample == 32)\n        dt = TIFFDataType::Float32;\n    else if (sampleFormat == SAMPLEFORMAT_IEEEFP && bitsPerSample == 64)\n        dt = TIFFDataType::Float64;\n    else {\n        pj_log(m_ctx, PJ_LOG_ERROR,\n               _(\"Unsupported combination of SampleFormat \"\n                 \"and BitsPerSample values\"));\n        return nullptr;\n    }\n\n    uint16_t photometric = PHOTOMETRIC_MINISBLACK;\n    if (!TIFFGetField(m_hTIFF, TIFFTAG_PHOTOMETRIC, &photometric))\n        photometric = PHOTOMETRIC_MINISBLACK;\n    if (photometric != PHOTOMETRIC_MINISBLACK) {\n        pj_log(m_ctx, PJ_LOG_ERROR, _(\"Unsupported Photometric value\"));\n        return nullptr;\n    }\n\n    uint16_t compression = COMPRESSION_NONE;\n    if (!TIFFGetField(m_hTIFF, TIFFTAG_COMPRESSION, &compression))\n        compression = COMPRESSION_NONE;\n\n    if (compression != COMPRESSION_NONE &&\n        !TIFFIsCODECConfigured(compression)) {\n        pj_log(m_ctx, PJ_LOG_ERROR,\n               _(\"Cannot open TIFF file due to missing codec.\"));\n        return nullptr;\n    }\n    // We really don't want to try dealing with old-JPEG images\n    if (compression == COMPRESSION_OJPEG) {\n        pj_log(m_ctx, PJ_LOG_ERROR, _(\"Unsupported compression method.\"));\n        return nullptr;\n    }\n\n    const auto blockSize = TIFFIsTiled(m_hTIFF) ? TIFFTileSize64(m_hTIFF)\n                                                : TIFFStripSize64(m_hTIFF);\n    if (blockSize == 0 || blockSize > 64 * 1024 * 2014) {\n        pj_log(m_ctx, PJ_LOG_ERROR, _(\"Unsupported block size.\"));\n        return nullptr;\n    }\n\n    unsigned short count = 0;\n    unsigned short *geokeys = nullptr;\n    bool pixelIsArea = false;\n\n    ExtentAndRes extent;\n    extent.isGeographic = true;\n\n    if (!TIFFGetField(m_hTIFF, TIFFTAG_GEOKEYDIRECTORY, &count, &geokeys)) {\n        pj_log(m_ctx, PJ_LOG_TRACE, \"No GeoKeys tag\");\n    } else {\n        if (count < 4 || (count % 4) != 0) {\n            pj_log(m_ctx, PJ_LOG_ERROR,\n                   _(\"Wrong number of values in GeoKeys tag\"));\n            return nullptr;\n        }\n\n        if (geokeys[0] != 1) {\n            pj_log(m_ctx, PJ_LOG_ERROR, _(\"Unsupported GeoTIFF major version\"));\n            return nullptr;\n        }\n        // We only know that we support GeoTIFF 1.0 and 1.1 at that time\n        if (geokeys[1] != 1 || geokeys[2] > 1) {\n            pj_log(m_ctx, PJ_LOG_TRACE, \"GeoTIFF %d.%d possibly not handled\",\n                   geokeys[1], geokeys[2]);\n        }\n\n        for (unsigned int i = 4; i + 3 < count; i += 4) {\n            constexpr unsigned short GTModelTypeGeoKey = 1024;\n            constexpr unsigned short ModelTypeProjected = 1;\n            constexpr unsigned short ModelTypeGeographic = 2;\n\n            constexpr unsigned short GTRasterTypeGeoKey = 1025;\n            constexpr unsigned short RasterPixelIsArea = 1;\n            // constexpr unsigned short RasterPixelIsPoint = 2;\n\n            if (geokeys[i] == GTModelTypeGeoKey) {\n                if (geokeys[i + 3] == ModelTypeProjected) {\n                    extent.isGeographic = false;\n                } else if (geokeys[i + 3] != ModelTypeGeographic) {\n                    pj_log(m_ctx, PJ_LOG_ERROR,\n                           _(\"Only GTModelTypeGeoKey = \"\n                             \"ModelTypeGeographic or ModelTypeProjected are \"\n                             \"supported\"));\n                    return nullptr;\n                }\n            } else if (geokeys[i] == GTRasterTypeGeoKey) {\n                if (geokeys[i + 3] == RasterPixelIsArea) {\n                    pixelIsArea = true;\n                }\n            }\n        }\n    }\n\n    double hRes = 0;\n    double vRes = 0;\n    double west = 0;\n    double north = 0;\n\n    double *matrix = nullptr;\n    if (TIFFGetField(m_hTIFF, TIFFTAG_GEOTRANSMATRIX, &count, &matrix) &&\n        count == 16) {\n        // If using GDAL to produce a bottom-up georeferencing, it will produce\n        // a GeoTransformationMatrix, since negative values in GeoPixelScale\n        // have historically been implementation bugs.\n        if (matrix[1] != 0 || matrix[4] != 0) {\n            pj_log(m_ctx, PJ_LOG_ERROR,\n                   _(\"Rotational terms not supported in \"\n                     \"GeoTransformationMatrix tag\"));\n            return nullptr;\n        }\n\n        west = matrix[3];\n        hRes = matrix[0];\n        north = matrix[7];\n        vRes = -matrix[5]; // negation to simulate GeoPixelScale convention\n    } else {\n        double *geopixelscale = nullptr;\n        if (TIFFGetField(m_hTIFF, TIFFTAG_GEOPIXELSCALE, &count,\n                         &geopixelscale) != 1) {\n            pj_log(m_ctx, PJ_LOG_ERROR, _(\"No GeoPixelScale tag\"));\n            return nullptr;\n        }\n        if (count != 3) {\n            pj_log(m_ctx, PJ_LOG_ERROR,\n                   _(\"Wrong number of values in GeoPixelScale tag\"));\n            return nullptr;\n        }\n        hRes = geopixelscale[0];\n        vRes = geopixelscale[1];\n\n        double *geotiepoints = nullptr;\n        if (TIFFGetField(m_hTIFF, TIFFTAG_GEOTIEPOINTS, &count,\n                         &geotiepoints) != 1) {\n            pj_log(m_ctx, PJ_LOG_ERROR, _(\"No GeoTiePoints tag\"));\n            return nullptr;\n        }\n        if (count != 6) {\n            pj_log(m_ctx, PJ_LOG_ERROR,\n                   _(\"Wrong number of values in GeoTiePoints tag\"));\n            return nullptr;\n        }\n\n        west = geotiepoints[3] - geotiepoints[0] * hRes;\n        north = geotiepoints[4] + geotiepoints[1] * vRes;\n    }\n\n    if (pixelIsArea) {\n        west += 0.5 * hRes;\n        north -= 0.5 * vRes;\n    }\n\n    const double mulFactor = extent.isGeographic ? DEG_TO_RAD : 1;\n    extent.west = west * mulFactor;\n    extent.north = north * mulFactor;\n    extent.resX = hRes * mulFactor;\n    extent.resY = fabs(vRes) * mulFactor;\n    extent.east = (west + hRes * (width - 1)) * mulFactor;\n    extent.south = (north - vRes * (height - 1)) * mulFactor;\n    extent.computeInvRes();\n\n    if (vRes < 0) {\n        std::swap(extent.north, extent.south);\n    }\n\n    if (!((!extent.isGeographic ||\n           (fabs(extent.west) <= 4 * M_PI && fabs(extent.east) <= 4 * M_PI &&\n            fabs(extent.north) <= M_PI + 1e-5 &&\n            fabs(extent.south) <= M_PI + 1e-5)) &&\n          extent.west < extent.east && extent.south < extent.north &&\n          extent.resX > 1e-10 && extent.resY > 1e-10)) {\n        pj_log(m_ctx, PJ_LOG_ERROR, _(\"Inconsistent georeferencing for %s\"),\n               m_filename.c_str());\n        return nullptr;\n    }\n\n    auto ret = std::unique_ptr<GTiffGrid>(new GTiffGrid(\n        m_ctx, m_hTIFF, m_cache, m_fp.get(), m_ifdIdx, m_filename, width,\n        height, extent, dt, samplesPerPixel, planarConfig, vRes < 0));\n    m_ifdIdx++;\n    m_hasNextGrid = TIFFReadDirectory(m_hTIFF) != 0;\n    m_nextDirOffset = TIFFCurrentDirOffset(m_hTIFF);\n\n    // If the TIFF file contains multiple grids, append the index of the grid\n    // in the grid name to help debugging.\n    if (m_ifdIdx >= 2 || m_hasNextGrid) {\n        ret->m_name += \" (index \";\n        ret->m_name += std::to_string(m_ifdIdx); // 1-based\n        ret->m_name += ')';\n    }\n\n    return ret;\n}",
    "TIFFHeader getTIFFHeader(const std::filesystem::path& filename) {\n#ifdef cimg_use_tiff\n    TIFF* tif = TIFFOpen(filename.string().c_str(), \"r\");\n    util::OnScopeExit closeFile([tif]() {\n        if (tif) TIFFClose(tif);\n    });\n\n    if (!tif) {\n        throw DataReaderException(SourceContext{}, \"Error could not open input file: {}\", filename);\n    }\n    TIFFSetDirectory(tif, 0);\n\n    std::uint16_t samplesPerPixel = 1, bitsPerSample = 8, sampleFormat = 1;\n    if (!TIFFGetFieldDefaulted(tif, TIFFTAG_BITSPERSAMPLE, &bitsPerSample)) {\n        bitsPerSample = 8;\n    }\n    if (!TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLESPERPIXEL, &samplesPerPixel)) {\n        samplesPerPixel = 1;\n    }\n    if (!TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLEFORMAT, &sampleFormat)) {\n        sampleFormat = 1;\n    }\n\n    float xres = 1.0f;\n    float yres = 1.0f;\n    // X and Y resolution tags are stored as float\n    if (!TIFFGetFieldDefaulted(tif, TIFFTAG_XRESOLUTION, &xres)) {\n        xres = 1.0f;\n    }\n    if (!TIFFGetFieldDefaulted(tif, TIFFTAG_YRESOLUTION, &yres)) {\n        yres = 1.0f;\n    }\n    const dvec2 res{xres, yres};\n\n    std::uint16_t resUnit = 2;\n    if (!TIFFGetFieldDefaulted(tif, TIFFTAG_RESOLUTIONUNIT, &resUnit)) {\n        resUnit = 2;\n    }\n    const TIFFResolutionUnit resolutionUnit = static_cast<TIFFResolutionUnit>(resUnit);\n\n    std::uint32_t x = 0, y = 0, z = 0;\n    TIFFGetFieldDefaulted(tif, TIFFTAG_IMAGEWIDTH, &x);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_IMAGELENGTH, &y);\n    // count the images\n    do {\n        ++z;\n    } while (TIFFReadDirectory(tif));\n\n    NumericType numericType;\n    switch (sampleFormat) {\n        case SAMPLEFORMAT_UINT:\n            numericType = NumericType::UnsignedInteger;\n            break;\n        case SAMPLEFORMAT_INT:\n            numericType = NumericType::SignedInteger;\n            break;\n        case SAMPLEFORMAT_IEEEFP:\n            numericType = NumericType::Float;\n            break;\n        case SAMPLEFORMAT_COMPLEXIEEEFP:\n            [[fallthrough]];\n        case SAMPLEFORMAT_COMPLEXINT:\n            throw DataReaderException(\"Unsupported TIFF format\");\n            break;\n        default:\n            numericType = NumericType::UnsignedInteger;\n            break;\n    }\n\n    SwizzleMask swizzleMask;\n    if (samplesPerPixel == 1) {\n        swizzleMask = swizzlemasks::luminance;\n    } else if (samplesPerPixel == 2) {\n        swizzleMask = swizzlemasks::luminanceAlpha;\n    } else if (samplesPerPixel == 3) {\n        swizzleMask = swizzlemasks::rgb;\n    } else if (samplesPerPixel == 4) {\n        swizzleMask = swizzlemasks::rgba;\n    } else {\n        throw DataReaderException(\"Unsupported TIFF format with more than 4 channels\");\n    }\n\n    auto df = DataFormatBase::get(numericType, samplesPerPixel, bitsPerSample);\n\n    return {df, size3_t{x, y, z}, res, resolutionUnit, swizzleMask};\n#else\n    throw Exception(\"TIFF not available\");\n    return {};\n#endif\n}",
    "static int read_region_extra(IMAGE *image, TIFF *tfp, char *filename,\n                             INFO_REGION *region, int scale, UCHAR *buf,\n                             int wrap_out, int xD_offset, int yD_offset) {\n  UCHAR *inp = NIL, *outp = NIL, *appo_outp = NIL;\n  int row, nrow, rrow;\n  int scanline_size, rowperstrip;\n\n  if (!TIFFReadDirectory(tfp)) return FALSE;\n\n  scanline_size = TIFFScanlineSize(tfp);\n  if (!TIFFGetField(tfp, TIFFTAG_ROWSPERSTRIP, &rowperstrip))\n    rowperstrip = MAXINT / 2;\n\n  appo_outp = image->pixmap.extra + yD_offset * wrap_out + xD_offset;\n\n  if (Verbose)\n    printf(\"Posizione in uscita (extra): %d, %d\\n\", xD_offset, yD_offset);\n\n  /* Puntatore per avanzamento nel buffer della regione */\n  outp = appo_outp;\n\n  row = region->startScanRow;\n  /*\n* Questa serie di scanline viene fatta perche' non viene\n* accettato un accesso random alle righe del file.\n*/\n  if (row > 0) {\n    int c;\n    c = (row / rowperstrip) * rowperstrip;\n    for (; c < row; c++) {\n      if (TIFFReadScanline(tfp, buf, c, 0) < 0) {\n        // tmsg_error(\"bad extra data read on line %d of file %s\", c, filename);\n        return FALSE;\n      }\n    }\n  }\n  for (nrow = 0; nrow < region->scanNrow; nrow++) {\n    appo_outp = outp;\n    if (TIFFReadScanline(tfp, buf, row, 0) < 0) {\n      // tmsg_error(\"bad extra data read at line %d of file %s\", row, filename);\n      return FALSE;\n    }\n\n    inp = buf + region->startScanCol;\n    for (rrow = 0; rrow < region->scanNcol; rrow++) {\n      *outp++ = *inp;\n      inp += scale;\n    }\n    if (scale > 1) {\n      register currRow = 0, stepRow = 1, nextRow = 0;\n      if (row + scale > region->ly_in)\n        break;\n      else\n        nextRow = row + scale;\n      stepRow   = (nextRow / rowperstrip) * rowperstrip;\n      for (currRow = stepRow; currRow < nextRow; currRow++) {\n        if (TIFFReadScanline(tfp, buf, currRow, 0) < 0) {\n          // tmsg_error(\"bad extra data in file %s at line %d\", filename,\n          // currRow);\n          return FALSE;\n        }\n      }\n    }\n    outp = appo_outp + wrap_out;\n    row += scale;\n  }\n  return TRUE;\n}",
    "static int get_icon_16(TIFF *tfp, IMAGE *image) {\n  int lx, ly;\n  UCHAR *buffer;\n  USHORT *icon_buffer;\n  int scanline, row;\n  TBOOL swap_needed;\n\n  if (!TIFFReadDirectory(tfp)) return FALSE;\n  if (!get_image_sizes(tfp, &lx, &ly)) return FALSE;\n  swap_needed = scanline_needs_swapping(tfp);\n\n  scanline = TIFFScanlineSize(tfp);\n\n  icon_buffer = new USHORT[lx * ly];\n\n  if (!icon_buffer) return FALSE;\n  image->icon.buffer  = icon_buffer;\n  image->icon.xsize   = lx;\n  image->icon.ysize   = ly;\n  image->icon.xSBsize = lx;\n  image->icon.ySBsize = ly;\n  image->icon.xD      = 0;\n  image->icon.yD      = 0;\n\n  buffer = (UCHAR *)image->icon.buffer;\n  for (row = 0; row < image->icon.ysize; row++) {\n    if (TIFFReadScanline(tfp, buffer, row, 0) < 0) {\n      // tmsg_error(\"bad data read on line %d\", row);\n      return FALSE;\n    }\n    if (swap_needed) TIFFSwabArrayOfShort((USHORT *)buffer, lx);\n\n    buffer += scanline;\n  }\n  return TRUE;\n}",
    "static int get_icon_24(TIFF *tfp, IMAGE *image) {\n  int lx, ly;\n  UCHAR *buffer;\n  ULONG *icon_buffer;\n  int scanline, row;\n  TBOOL swap_needed;\n\n  if (!TIFFReadDirectory(tfp)) return FALSE;\n  if (!get_image_sizes(tfp, &lx, &ly)) return FALSE;\n  swap_needed = scanline_needs_swapping(tfp);\n\n  scanline = TIFFScanlineSize(tfp);\n\n  icon_buffer = new ULONG[lx * ly];\n  if (!icon_buffer) return FALSE;\n  image->icon.buffer  = (USHORT *)icon_buffer;\n  image->icon.xsize   = lx;\n  image->icon.ysize   = ly;\n  image->icon.xSBsize = lx;\n  image->icon.ySBsize = ly;\n  image->icon.xD      = 0;\n  image->icon.yD      = 0;\n\n  buffer = (UCHAR *)image->icon.buffer;\n  for (row = 0; row < image->icon.ysize; row++) {\n    if (TIFFReadScanline(tfp, buffer, row, 0) < 0) {\n      // tmsg_error(\"bad data read on line %d\", row);\n      return FALSE;\n    }\n    if (swap_needed) TIFFSwabArrayOfLong((TUINT32 *)buffer, lx);\n\n    buffer += scanline;\n  }\n  return TRUE;\n}",
    "static int get_extra(TIFF *tfp, IMAGE *image) {\n  int x, y, x0, y0, x1, y1, lx, ly, xsize, ysize, wrap;\n  UCHAR *buf, *pix;\n\n  if (!TIFFReadDirectory(tfp)) return FALSE;\n\n  x0    = image->pixmap.xD;\n  y0    = image->pixmap.yD;\n  lx    = image->pixmap.xSBsize;\n  ly    = image->pixmap.ySBsize;\n  x1    = x0 + lx - 1;\n  y1    = y0 + ly - 1;\n  xsize = image->pixmap.xsize;\n  ysize = image->pixmap.ysize;\n  wrap  = image->pixmap.xsize;\n  buf   = image->pixmap.extra;\n  for (y = 0; y < y0; y++) {\n    pix = buf + y * wrap;\n    for (x = 0; x < xsize; x++) *pix++ = 0;\n  }\n  for (; y <= y1; y++) {\n    pix = buf + y * wrap;\n    for (x = 0; x < x0; x++) *pix++ = 0;\n    if (TIFFReadScanline(tfp, (UCHAR *)pix, y - y0, 0) < 0) {\n      static int gia_dato = FALSE;\n      if (!gia_dato) {\n        // tmsg_error(\"bad data read on extra line %d\", y);\n        gia_dato = TRUE;\n      }\n      memset(pix, 0, lx * sizeof(*pix));\n    }\n    pix += lx;\n    for (x = x1 + 1; x < xsize; x++) *pix++ = 0;\n  }\n  for (; y < ysize; y++) {\n    pix = buf + y * wrap;\n    for (x = 0; x < xsize; x++) *pix++ = 0;\n  }\n  return TRUE;\n}",
    "static osg::ImageSequence* tiffLoad(std::istream& fin, const osgDB::Options* options)\n{\n    TIFFSetErrorHandler(tiffError);\n    TIFFSetWarningHandler(tiffWarn);\n    TIFF* in = TIFFClientOpen(\"inputstream\", \"r\", (thandle_t)&fin,\n                              tiffStreamReadProc, tiffStreamWriteProc,\n                              tiffStreamSeekProc, tiffStreamCloseProc,\n                              tiffStreamSizeProc, tiffStreamMapProc, tiffStreamUnmapProc);\n    if (in == NULL) { OSG_WARN << \"[ReaderWriterTiff] Unable to open stream\" << std::endl; return NULL; }\n\n    uint16_t photometric = 0;\n    if (TIFFGetField(in, TIFFTAG_PHOTOMETRIC, &photometric) == 1)\n    {\n        if (photometric != PHOTOMETRIC_RGB && photometric != PHOTOMETRIC_PALETTE &&\n            photometric != PHOTOMETRIC_MINISWHITE && photometric != PHOTOMETRIC_MINISBLACK)\n        {\n            OSG_WARN << \"[ReaderWriterTiff] Photometric type \" << photometric << \" not handled\" << std::endl;\n            TIFFClose(in); return NULL;\n        }\n    }\n    else\n    {\n        OSG_WARN << \"[ReaderWriterTiff] Unable to get photometric type\" << std::endl;\n        TIFFClose(in); return NULL;\n    }\n\n    uint16_t samplesperpixel = 0;\n    if (TIFFGetField(in, TIFFTAG_SAMPLESPERPIXEL, &samplesperpixel) == 1)\n    {\n        if (samplesperpixel != 1 && samplesperpixel != 2 &&\n            samplesperpixel != 3 && samplesperpixel != 4)\n        {\n            OSG_WARN << \"[ReaderWriterTiff] Bad samples per pixel: \" << samplesperpixel << std::endl;\n            TIFFClose(in); return NULL;\n        }\n    }\n    else\n    {\n        OSG_WARN << \"[ReaderWriterTiff] Unable to get samples per pixel\" << std::endl;\n        TIFFClose(in); return NULL;\n    }\n\n    uint16_t bitspersample = 0;\n    if (TIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bitspersample) == 1)\n    {\n        if (bitspersample != 8 && bitspersample != 16 && bitspersample != 32)\n        {\n            OSG_WARN << \"[ReaderWriterTiff] Can only handle 8, 16 and 32 bit samples\" << std::endl;\n            TIFFClose(in); return NULL;\n        }\n    }\n    else\n    {\n        OSG_WARN << \"[ReaderWriterTiff] Unable to get bits per sample\" << std::endl;\n        TIFFClose(in); return NULL;\n    }\n\n    uint32_t w = 0, h = 0, d = 1; uint16_t config = 0, dataType = 0;\n    if (TIFFGetField(in, TIFFTAG_IMAGEWIDTH, &w) != 1 || TIFFGetField(in, TIFFTAG_IMAGELENGTH, &h) != 1 ||\n        TIFFGetField(in, TIFFTAG_PLANARCONFIG, &config) != 1)\n    {\n        OSG_WARN << \"[ReaderWriterTiff] Unable to get width / height / depth parameters\" << std::endl;\n        TIFFClose(in); return NULL;\n    }\n\n    // if it has a palette, data returned is 3 byte rgb\n    int format = (photometric == PHOTOMETRIC_PALETTE) ? 3 : (samplesperpixel * bitspersample / 8);\n    int bytespersample = bitspersample / 8;\n    int bytesperpixel = bytespersample * samplesperpixel;\n    TIFFGetField(in, TIFFTAG_DATATYPE, &dataType);\n    TIFFGetField(in, TIFFTAG_IMAGEDEPTH, &d);\n\n    osg::ref_ptr<osg::ImageSequence> seq = new osg::ImageSequence;\n    if (d > 1)\n    {\n        // TODO...\n        OSG_WARN << \"[ReaderWriterTiff] Unsupported dimension\" << std::endl;\n    }\n    else\n    {\n        int dirCount = 0, imgSize = w * h * format;\n        do\n        {\n            unsigned char* inBuffer = NULL; bool hasError = false;\n            unsigned char* buffer = new unsigned char[imgSize];\n            memset(buffer, 0, imgSize); dirCount++;\n\n            unsigned char* currPtr = buffer + (h - 1) * w * format;\n            uint16_t *red = NULL, *green = NULL, *blue = NULL;\n            size_t rowSize = TIFFScanlineSize(in);\n            switch (PACK(photometric, config))\n            {\n            case PACK(PHOTOMETRIC_MINISWHITE, PLANARCONFIG_CONTIG):\n            case PACK(PHOTOMETRIC_MINISBLACK, PLANARCONFIG_CONTIG):\n            case PACK(PHOTOMETRIC_MINISWHITE, PLANARCONFIG_SEPARATE):\n            case PACK(PHOTOMETRIC_MINISBLACK, PLANARCONFIG_SEPARATE):\n                inBuffer = new unsigned char[rowSize];\n                for (uint32_t row = 0; row < h; row++)\n                {\n                    if (TIFFReadScanline(in, inBuffer, row, 0) < 0) { hasError = true; break; }\n                    invertRow(currPtr, inBuffer, samplesperpixel * w,\n                              photometric == PHOTOMETRIC_MINISWHITE, bitspersample);\n                    currPtr -= format * w;\n                }\n                break;\n\n            case PACK(PHOTOMETRIC_PALETTE, PLANARCONFIG_CONTIG):\n            case PACK(PHOTOMETRIC_PALETTE, PLANARCONFIG_SEPARATE):\n                if (TIFFGetField(in, TIFFTAG_COLORMAP, &red, &green, &blue) != 1)\n                { hasError = true; break; }\n                else if (!hasError && bitspersample != 32 && checkColormap(1<<bitspersample, red, green, blue) == 16)\n                {\n                    for (int i = (1 << bitspersample) - 1; i >= 0; --i)\n                    { red[i] = CVT(red[i]); green[i] = CVT(green[i]); blue[i] = CVT(blue[i]); }\n                }\n\n                inBuffer = new unsigned char[rowSize];\n                for (uint32_t row = 0; row < h; row++)\n                {\n                    if (TIFFReadScanline(in, inBuffer, row, 0) < 0) { hasError = true; break; }\n                    remapRow(currPtr, inBuffer, w, red, green, blue); currPtr -= format * w;\n                }\n                break;\n\n            case PACK(PHOTOMETRIC_RGB, PLANARCONFIG_CONTIG):\n                inBuffer = new unsigned char[rowSize];\n                for (uint32_t row = 0; row < h; row++)\n                {\n                    if (TIFFReadScanline(in, inBuffer, row, 0) < 0) { hasError = true; break; }\n                    memcpy(currPtr, inBuffer, format * w); currPtr -= format * w;\n                }\n                break;\n\n            case PACK(PHOTOMETRIC_RGB, PLANARCONFIG_SEPARATE):\n                inBuffer = new unsigned char[format * rowSize];\n                for (uint32_t row = 0; !hasError && row < h; row++)\n                {\n                    for (int s = 0; s < format; s++)\n                    {\n                        if (TIFFReadScanline(in, (tdata_t)(inBuffer + s * rowSize), (uint32_t)row, (tsample_t)s) < 0)\n                        { hasError = true; break; }\n                    }\n\n                    if (!hasError)\n                    {\n                        unsigned char *inBuffer2 = inBuffer + rowSize, *inBuffer3 = inBuffer + 2 * rowSize,\n                                      *inBuffer4 = inBuffer + 3 * rowSize;\n                        if (format == 4) interleaveRow(currPtr, inBuffer, inBuffer2, inBuffer3, inBuffer4, w, format, bitspersample);\n                        else if (format == 3) interleaveRow(currPtr, inBuffer, inBuffer2, inBuffer3, w, format, bitspersample);\n                        currPtr -= format * w;\n                    }\n                }\n                break;\n            default:\n                OSG_WARN << \"[ReaderWriterTiff] Unsupported Packing: \" << photometric << \", \" << config << std::endl;\n                hasError = true; break;\n            }\n\n            if (inBuffer) delete[] inBuffer;\n            if (hasError)\n            {\n                OSG_WARN << \"[ReaderWriterTiff] Failed to read with packing: \" << photometric << \", \" << config << std::endl;\n                if (buffer) delete[] buffer; continue;\n            }\n\n            int numComponents = (photometric == PHOTOMETRIC_PALETTE) ? format : samplesperpixel;\n            unsigned int pixelFormat =\n                (numComponents) == 1 ? GL_LUMINANCE :\n                (numComponents) == 2 ? GL_LUMINANCE_ALPHA :\n                (numComponents) == 3 ? GL_RGB :\n                (numComponents) == 4 ? GL_RGBA : (GLenum)-1;\n            unsigned int dataType =\n                (bitspersample == 8) ? GL_UNSIGNED_BYTE :\n                (bitspersample == 16) ? GL_UNSIGNED_SHORT :\n                (bitspersample == 32) ? GL_FLOAT : (GLenum)-1;\n            unsigned int internalFormat = computeInternalFormat(pixelFormat, dataType);\n            if (internalFormat <= 0)\n            {\n                OSG_WARN << \"[ReaderWriterTiff] Unsupported image format\" << std::endl;\n                continue;\n            }\n\n            osg::Image* image = new osg::Image;\n            image->setImage(w, h, d, internalFormat, pixelFormat, dataType,\n                            buffer, osg::Image::USE_NEW_DELETE);\n            seq->addImage(image);\n        } while (TIFFReadDirectory(in));\n    }\n    TIFFClose(in);\n    return seq.release();\n}",
    "void GTiffDataset::ScanDirectories()\n\n{\n    /* -------------------------------------------------------------------- */\n    /*      We only scan once.  We do not scan for non-base datasets.       */\n    /* -------------------------------------------------------------------- */\n    if (!m_bScanDeferred)\n        return;\n\n    m_bScanDeferred = false;\n\n    if (m_poBaseDS)\n        return;\n\n    Crystalize();\n\n    CPLDebug(\"GTiff\", \"ScanDirectories()\");\n\n    /* ==================================================================== */\n    /*      Scan all directories.                                           */\n    /* ==================================================================== */\n    CPLStringList aosSubdatasets;\n    int iDirIndex = 0;\n\n    FlushDirectory();\n\n    do\n    {\n        toff_t nTopDir = TIFFCurrentDirOffset(m_hTIFF);\n        uint32_t nSubType = 0;\n\n        ++iDirIndex;\n\n        toff_t *tmpSubIFDOffsets = nullptr;\n        toff_t *subIFDOffsets = nullptr;\n        uint16_t nSubIFDs = 0;\n        if (TIFFGetField(m_hTIFF, TIFFTAG_SUBIFD, &nSubIFDs,\n                         &tmpSubIFDOffsets) &&\n            iDirIndex == 1)\n        {\n            subIFDOffsets =\n                static_cast<toff_t *>(CPLMalloc(nSubIFDs * sizeof(toff_t)));\n            for (uint16_t iSubIFD = 0; iSubIFD < nSubIFDs; iSubIFD++)\n            {\n                subIFDOffsets[iSubIFD] = tmpSubIFDOffsets[iSubIFD];\n            }\n        }\n\n        // early break for backwards compatibility: if the first directory read\n        // is also the last, and there are no subIFDs, no use continuing\n        if (iDirIndex == 1 && nSubIFDs == 0 && TIFFLastDirectory(m_hTIFF))\n        {\n            CPLFree(subIFDOffsets);\n            break;\n        }\n\n        for (uint16_t iSubIFD = 0; iSubIFD <= nSubIFDs; iSubIFD++)\n        {\n            toff_t nThisDir = nTopDir;\n            if (iSubIFD > 0 && iDirIndex > 1)  // don't read subIFDs if we are\n                                               // not in the original directory\n                break;\n            if (iSubIFD > 0)\n            {\n                // make static analyzer happy. subIFDOffsets cannot be null if\n                // iSubIFD>0\n                assert(subIFDOffsets != nullptr);\n                nThisDir = subIFDOffsets[iSubIFD - 1];\n                // CPLDebug(\"GTiff\", \"Opened subIFD %d/%d at offset %llu.\",\n                // iSubIFD, nSubIFDs, nThisDir);\n                if (!TIFFSetSubDirectory(m_hTIFF, nThisDir))\n                    break;\n            }\n\n            if (!TIFFGetField(m_hTIFF, TIFFTAG_SUBFILETYPE, &nSubType))\n                nSubType = 0;\n\n            /* Embedded overview of the main image */\n            if ((nSubType & FILETYPE_REDUCEDIMAGE) != 0 &&\n                (nSubType & FILETYPE_MASK) == 0 &&\n                ((nSubIFDs == 0 && iDirIndex != 1) || iSubIFD > 0) &&\n                m_nOverviewCount < 30 /* to avoid DoS */)\n            {\n                GTiffDataset *poODS = new GTiffDataset();\n                poODS->ShareLockWithParentDataset(this);\n                poODS->SetStructuralMDFromParent(this);\n                if (m_bHasGotSiblingFiles)\n                    poODS->oOvManager.TransferSiblingFiles(\n                        CSLDuplicate(GetSiblingFiles()));\n                poODS->m_pszFilename = CPLStrdup(m_pszFilename);\n                poODS->m_nColorTableMultiplier = m_nColorTableMultiplier;\n                if (poODS->OpenOffset(VSI_TIFFOpenChild(m_hTIFF), nThisDir,\n                                      eAccess) != CE_None ||\n                    poODS->GetRasterCount() != GetRasterCount())\n                {\n                    delete poODS;\n                }\n                else\n                {\n                    CPLDebug(\"GTiff\", \"Opened %dx%d overview.\",\n                             poODS->GetRasterXSize(), poODS->GetRasterYSize());\n                    ++m_nOverviewCount;\n                    m_papoOverviewDS = static_cast<GTiffDataset **>(CPLRealloc(\n                        m_papoOverviewDS, m_nOverviewCount * (sizeof(void *))));\n                    m_papoOverviewDS[m_nOverviewCount - 1] = poODS;\n                    poODS->m_poBaseDS = this;\n                    poODS->m_bIsOverview = true;\n\n                    // Propagate a few compression related settings that are\n                    // no preserved at the TIFF tag level, but may be set in\n                    // the GDAL_METADATA tag in the IMAGE_STRUCTURE domain\n                    // Note: this might not be totally reflecting the reality\n                    // if users have created overviews with different settings\n                    // but this is probably better than the default ones\n                    poODS->m_nWebPLevel = m_nWebPLevel;\n                    // below is not a copy & paste error: we transfer the\n                    // m_dfMaxZErrorOverview overview of the parent to\n                    // m_dfMaxZError of the overview\n                    poODS->m_dfMaxZError = m_dfMaxZErrorOverview;\n                    poODS->m_dfMaxZErrorOverview = m_dfMaxZErrorOverview;\n#if HAVE_JXL\n                    poODS->m_bJXLLossless = m_bJXLLossless;\n                    poODS->m_fJXLDistance = m_fJXLDistance;\n                    poODS->m_fJXLAlphaDistance = m_fJXLAlphaDistance;\n                    poODS->m_nJXLEffort = m_nJXLEffort;\n#endif\n                    // Those ones are not serialized currently..\n                    // poODS->m_nZLevel = m_nZLevel;\n                    // poODS->m_nLZMAPreset = m_nLZMAPreset;\n                    // poODS->m_nZSTDLevel = m_nZSTDLevel;\n                }\n            }\n            // Embedded mask of the main image.\n            else if ((nSubType & FILETYPE_MASK) != 0 &&\n                     (nSubType & FILETYPE_REDUCEDIMAGE) == 0 &&\n                     ((nSubIFDs == 0 && iDirIndex != 1) || iSubIFD > 0) &&\n                     m_poMaskDS == nullptr)\n            {\n                m_poMaskDS = new GTiffDataset();\n                m_poMaskDS->ShareLockWithParentDataset(this);\n                m_poMaskDS->SetStructuralMDFromParent(this);\n                m_poMaskDS->m_pszFilename = CPLStrdup(m_pszFilename);\n\n                // The TIFF6 specification - page 37 - only allows 1\n                // SamplesPerPixel and 1 BitsPerSample Here we support either 1\n                // or 8 bit per sample and we support either 1 sample per pixel\n                // or as many samples as in the main image We don't check the\n                // value of the PhotometricInterpretation tag, which should be\n                // set to \"Transparency mask\" (4) according to the specification\n                // (page 36).  However, the TIFF6 specification allows image\n                // masks to have a higher resolution than the main image, what\n                // we don't support here.\n\n                if (m_poMaskDS->OpenOffset(VSI_TIFFOpenChild(m_hTIFF), nThisDir,\n                                           eAccess) != CE_None ||\n                    m_poMaskDS->GetRasterCount() == 0 ||\n                    !(m_poMaskDS->GetRasterCount() == 1 ||\n                      m_poMaskDS->GetRasterCount() == GetRasterCount()) ||\n                    m_poMaskDS->GetRasterXSize() != GetRasterXSize() ||\n                    m_poMaskDS->GetRasterYSize() != GetRasterYSize() ||\n                    m_poMaskDS->GetRasterBand(1)->GetRasterDataType() !=\n                        GDT_Byte)\n                {\n                    delete m_poMaskDS;\n                    m_poMaskDS = nullptr;\n                }\n                else\n                {\n                    CPLDebug(\"GTiff\", \"Opened band mask.\");\n                    m_poMaskDS->m_poBaseDS = this;\n                    m_poMaskDS->m_poImageryDS = this;\n\n                    m_poMaskDS->m_bPromoteTo8Bits =\n                        CPLTestBool(CPLGetConfigOption(\n                            \"GDAL_TIFF_INTERNAL_MASK_TO_8BIT\", \"YES\"));\n                }\n            }\n\n            // Embedded mask of an overview.  The TIFF6 specification allows the\n            // combination of the FILETYPE_xxxx masks.\n            else if ((nSubType & FILETYPE_REDUCEDIMAGE) != 0 &&\n                     (nSubType & FILETYPE_MASK) != 0 &&\n                     ((nSubIFDs == 0 && iDirIndex != 1) || iSubIFD > 0))\n            {\n                GTiffDataset *poDS = new GTiffDataset();\n                poDS->ShareLockWithParentDataset(this);\n                poDS->SetStructuralMDFromParent(this);\n                poDS->m_pszFilename = CPLStrdup(m_pszFilename);\n                if (poDS->OpenOffset(VSI_TIFFOpenChild(m_hTIFF), nThisDir,\n                                     eAccess) != CE_None ||\n                    poDS->GetRasterCount() == 0 ||\n                    poDS->GetRasterBand(1)->GetRasterDataType() != GDT_Byte)\n                {\n                    delete poDS;\n                }\n                else\n                {\n                    int i = 0;  // Used after for.\n                    for (; i < m_nOverviewCount; ++i)\n                    {\n                        auto poOvrDS = cpl::down_cast<GTiffDataset *>(\n                            GDALDataset::FromHandle(m_papoOverviewDS[i]));\n                        if (poOvrDS->m_poMaskDS == nullptr &&\n                            poDS->GetRasterXSize() ==\n                                m_papoOverviewDS[i]->GetRasterXSize() &&\n                            poDS->GetRasterYSize() ==\n                                m_papoOverviewDS[i]->GetRasterYSize() &&\n                            (poDS->GetRasterCount() == 1 ||\n                             poDS->GetRasterCount() == GetRasterCount()))\n                        {\n                            CPLDebug(\n                                \"GTiff\", \"Opened band mask for %dx%d overview.\",\n                                poDS->GetRasterXSize(), poDS->GetRasterYSize());\n                            poDS->m_poImageryDS = poOvrDS;\n                            poOvrDS->m_poMaskDS = poDS;\n                            poDS->m_bPromoteTo8Bits =\n                                CPLTestBool(CPLGetConfigOption(\n                                    \"GDAL_TIFF_INTERNAL_MASK_TO_8BIT\", \"YES\"));\n                            poDS->m_poBaseDS = this;\n                            break;\n                        }\n                    }\n                    if (i == m_nOverviewCount)\n                    {\n                        delete poDS;\n                    }\n                }\n            }\n            else if (!m_bSingleIFDOpened &&\n                     (nSubType == 0 || nSubType == FILETYPE_PAGE))\n            {\n                uint32_t nXSize = 0;\n                uint32_t nYSize = 0;\n\n                TIFFGetField(m_hTIFF, TIFFTAG_IMAGEWIDTH, &nXSize);\n                TIFFGetField(m_hTIFF, TIFFTAG_IMAGELENGTH, &nYSize);\n\n                // For Geodetic TIFF grids (GTG)\n                // (https://proj.org/specifications/geodetictiffgrids.html)\n                // extract the grid_name to put it in the description\n                std::string osFriendlyName;\n                char *pszText = nullptr;\n                if (TIFFGetField(m_hTIFF, TIFFTAG_GDAL_METADATA, &pszText) &&\n                    strstr(pszText, \"grid_name\") != nullptr)\n                {\n                    CPLXMLNode *psRoot = CPLParseXMLString(pszText);\n                    const CPLXMLNode *psItem =\n                        psRoot ? CPLGetXMLNode(psRoot, \"=GDALMetadata\")\n                               : nullptr;\n                    if (psItem)\n                        psItem = psItem->psChild;\n                    for (; psItem != nullptr; psItem = psItem->psNext)\n                    {\n\n                        if (psItem->eType != CXT_Element ||\n                            !EQUAL(psItem->pszValue, \"Item\"))\n                            continue;\n\n                        const char *pszKey =\n                            CPLGetXMLValue(psItem, \"name\", nullptr);\n                        const char *pszValue =\n                            CPLGetXMLValue(psItem, nullptr, nullptr);\n                        int nBand =\n                            atoi(CPLGetXMLValue(psItem, \"sample\", \"-1\"));\n                        if (pszKey && pszValue && nBand <= 0 &&\n                            EQUAL(pszKey, \"grid_name\"))\n                        {\n                            osFriendlyName = \": \";\n                            osFriendlyName += pszValue;\n                            break;\n                        }\n                    }\n\n                    CPLDestroyXMLNode(psRoot);\n                }\n\n                if (nXSize > INT_MAX || nYSize > INT_MAX)\n                {\n                    CPLDebug(\"GTiff\",\n                             \"Skipping directory with too large image: %u x %u\",\n                             nXSize, nYSize);\n                }\n                else\n                {\n                    uint16_t nSPP = 0;\n                    if (!TIFFGetField(m_hTIFF, TIFFTAG_SAMPLESPERPIXEL, &nSPP))\n                        nSPP = 1;\n\n                    CPLString osName, osDesc;\n                    osName.Printf(\"SUBDATASET_%d_NAME=GTIFF_DIR:%d:%s\",\n                                  iDirIndex, iDirIndex, m_pszFilename);\n                    osDesc.Printf(\n                        \"SUBDATASET_%d_DESC=Page %d (%dP x %dL x %dB)\",\n                        iDirIndex, iDirIndex, static_cast<int>(nXSize),\n                        static_cast<int>(nYSize), nSPP);\n                    osDesc += osFriendlyName;\n\n                    aosSubdatasets.AddString(osName);\n                    aosSubdatasets.AddString(osDesc);\n                }\n            }\n        }\n        CPLFree(subIFDOffsets);\n\n        // Make sure we are stepping from the expected directory regardless\n        // of churn done processing the above.\n        if (TIFFCurrentDirOffset(m_hTIFF) != nTopDir)\n            TIFFSetSubDirectory(m_hTIFF, nTopDir);\n    } while (!m_bSingleIFDOpened && !TIFFLastDirectory(m_hTIFF) &&\n             TIFFReadDirectory(m_hTIFF) != 0);\n\n    ReloadDirectory();\n\n    // If we have a mask for the main image, loop over the overviews, and if\n    // they have a mask, let's set this mask as an overview of the main mask.\n    if (m_poMaskDS != nullptr)\n    {\n        for (int i = 0; i < m_nOverviewCount; ++i)\n        {\n            if (cpl::down_cast<GTiffDataset *>(\n                    GDALDataset::FromHandle(m_papoOverviewDS[i]))\n                    ->m_poMaskDS != nullptr)\n            {\n                ++m_poMaskDS->m_nOverviewCount;\n                m_poMaskDS->m_papoOverviewDS =\n                    static_cast<GTiffDataset **>(CPLRealloc(\n                        m_poMaskDS->m_papoOverviewDS,\n                        m_poMaskDS->m_nOverviewCount * (sizeof(void *))));\n                m_poMaskDS->m_papoOverviewDS[m_poMaskDS->m_nOverviewCount - 1] =\n                    cpl::down_cast<GTiffDataset *>(\n                        GDALDataset::FromHandle(m_papoOverviewDS[i]))\n                        ->m_poMaskDS;\n            }\n        }\n    }\n\n    // Assign color interpretation from main dataset\n    const int l_nBands = GetRasterCount();\n    for (int iOvr = 0; iOvr < m_nOverviewCount; ++iOvr)\n    {\n        for (int i = 1; i <= l_nBands; i++)\n        {\n            auto poBand = dynamic_cast<GTiffRasterBand *>(\n                m_papoOverviewDS[iOvr]->GetRasterBand(i));\n            if (poBand)\n                poBand->m_eBandInterp =\n                    GetRasterBand(i)->GetColorInterpretation();\n        }\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Only keep track of subdatasets if we have more than one         */\n    /*      subdataset (pair).                                              */\n    /* -------------------------------------------------------------------- */\n    if (aosSubdatasets.size() > 2)\n    {\n        m_oGTiffMDMD.SetMetadata(aosSubdatasets.List(), \"SUBDATASETS\");\n    }\n}",
    "vtkImageAlgorithm* VtkRaster::loadImageFromTIFF(const std::string& fileName)\n{\n    TIFF* tiff = XTIFFOpen(fileName.c_str(), \"r\");\n\n    if (tiff)\n    {\n        GTIF* geoTiff = GTIFNew(tiff);\n\n        int version[3];\n        int count(0);\n        GTIFDirectoryInfo(geoTiff, version, &count);\n\n        if (count == 0)\n            WARN(\"VtkRaster::loadImageFromTIFF - file is not georeferenced.\");\n\n        if (geoTiff)\n        {\n            double x0 = 0.0;\n            double y0 = 0.0;\n            double cellsize = 1.0;\n            int imgWidth = 0;\n            int imgHeight = 0;\n            int nImages = 0;\n            int pntCount = 0;\n            double* pnts = nullptr;\n\n            // get actual number of images in the tiff file\n            do\n            {\n                ++nImages;\n            } while (TIFFReadDirectory(tiff));\n            if (nImages > 1)\n                INFO(\n                    \"VtkRaster::loadImageFromTIFF() - File contains {:d} \"\n                    \"images. This method is not tested for this case.\",\n                    nImages);\n\n            // get image size\n            TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, &imgWidth);\n            TIFFGetField(tiff, TIFFTAG_IMAGELENGTH, &imgHeight);\n\n            // get cellsize\n            // Note: GeoTiff allows anisotropic pixels. This is not supported\n            // here and equilateral pixels are assumed.\n            if (TIFFGetField(tiff, GTIFF_PIXELSCALE, &pntCount, &pnts))\n            {\n                if (pnts[0] != pnts[1])\n                    WARN(\n                        \"VtkRaster::loadImageFromTIFF(): Original raster data \"\n                        \"has anisotrop pixel size!\");\n                cellsize = pnts[0];\n            }\n\n            // get upper left point / origin\n            if (TIFFGetField(tiff, GTIFF_TIEPOINTS, &pntCount, &pnts))\n            {\n                x0 = pnts[3];\n                y0 = pnts[4] -\n                     (imgHeight * cellsize);  // the origin should be the lower\n                                              // left corner of the img\n            }\n\n            // read pixel values\n            auto* pixVal = static_cast<uint32*>(\n                _TIFFmalloc(imgWidth * imgHeight * sizeof(uint32)));\n            if ((imgWidth > 0) && (imgHeight > 0))\n            {\n                if (!TIFFReadRGBAImage(tiff, imgWidth, imgHeight, pixVal, 0))\n                {\n                    ERR(\"VtkRaster::loadImageFromTIFF(): reading GeoTIFF \"\n                        \"file.\");\n                    _TIFFfree(pixVal);\n                    GTIFFree(geoTiff);\n                    XTIFFClose(tiff);\n                    return nullptr;\n                }\n            }\n\n            // check for colormap\n            uint16 photometric;\n            TIFFGetField(tiff, TIFFTAG_PHOTOMETRIC, &photometric);\n            // read colormap\n            uint16 *cmap_red = nullptr, *cmap_green = nullptr,\n                   *cmap_blue = nullptr;\n            int colormap_used = TIFFGetField(tiff, TIFFTAG_COLORMAP, &cmap_red,\n                                             &cmap_green, &cmap_blue);\n\n            auto* data = new float[imgWidth * imgHeight * 4];\n            auto* pxl(new int[4]);\n            for (int j = 0; j < imgHeight; ++j)\n            {\n                int lineindex = j * imgWidth;\n                for (int i = 0; i < imgWidth; ++i)\n                {  // scale intensities and set nodata values to white (i.e. the\n                   // background colour)\n                    unsigned pxl_idx(lineindex + i);\n                    unsigned pos = 4 * (pxl_idx);\n                    if (photometric == 1 && colormap_used == 1)\n                    {\n                        int idx = TIFFGetR(pixVal[pxl_idx]);\n                        data[pos] = static_cast<float>(cmap_red[idx] >> 8);\n                        data[pos + 1] =\n                            static_cast<float>(cmap_green[idx] >> 8);\n                        data[pos + 2] = static_cast<float>(cmap_blue[idx] >> 8);\n                        data[pos + 3] = 1;\n                    }\n                    else\n                    {\n                        data[pos] =\n                            static_cast<float>(TIFFGetR(pixVal[pxl_idx]));\n                        data[pos + 1] =\n                            static_cast<float>(TIFFGetG(pixVal[pxl_idx]));\n                        data[pos + 2] =\n                            static_cast<float>(TIFFGetB(pixVal[pxl_idx]));\n                        data[pos + 3] =\n                            static_cast<float>(TIFFGetA(pixVal[pxl_idx]));\n                    }\n                }\n            }\n            delete[] pxl;\n\n            // set transparency values according to maximum pixel value\n            if (photometric == 1)\n            {\n                float max_val(0);\n                unsigned nPixels = 4 * imgWidth * imgHeight;\n                for (unsigned j = 0; j < nPixels; ++j)\n                {\n                    if (data[j] > max_val)\n                    {\n                        max_val = data[j];\n                    }\n                }\n\n                for (unsigned j = 0; j < nPixels; j += 4)\n                {\n                    data[j + 3] = max_val;\n                }\n            }\n\n            vtkImageImport* image = vtkImageImport::New();\n            image->SetDataOrigin(x0, y0, 0);\n            image->SetDataSpacing(cellsize, cellsize, cellsize);\n            image->SetWholeExtent(0, imgWidth - 1, 0, imgHeight - 1, 0, 0);\n            image->SetDataExtent(0, imgWidth - 1, 0, imgHeight - 1, 0, 0);\n            image->SetDataExtentToWholeExtent();\n            image->SetDataScalarTypeToFloat();\n            image->SetNumberOfScalarComponents(4);\n            image->SetImportVoidPointer(data, 0);\n            image->Update();\n\n            _TIFFfree(pixVal);\n            GTIFFree(geoTiff);\n            XTIFFClose(tiff);\n            return image;\n        }\n\n        XTIFFClose(tiff);\n        ERR(\"VtkRaster::loadImageFromTIFF() - File not recognised as \"\n            \"GeoTIFF-Image.\");\n        return nullptr;\n    }\n\n    ERR(\"VtkRaster::loadImageFromTIFF() - File not recognised as TIFF-Image.\");\n    return nullptr;\n}",
    "KisImportExportErrorCode\nKisTIFFImport::convert(KisDocument *document,\n                       QIODevice * /*io*/,\n                       KisPropertiesConfigurationSP /*configuration*/)\n{\n    dbgFile << \"Start decoding TIFF File\";\n\n    if (!KisImportExportAdditionalChecks::doesFileExist(filename())) {\n        return ImportExportCodes::FileNotExist;\n    }\n    if (!KisImportExportAdditionalChecks::isFileReadable(filename())) {\n        return ImportExportCodes::NoAccessToRead;\n    }\n\n    QFile file(filename());\n    if (!file.open(QFile::ReadOnly)) {\n        return KisImportExportErrorCode(KisImportExportErrorCannotRead(file.error()));\n    }\n\n    // Open the TIFF file\n    const QByteArray encodedFilename = QFile::encodeName(filename());\n\n    // https://gitlab.com/libtiff/libtiff/-/issues/173\n#ifdef Q_OS_WIN\n    const intptr_t handle = _get_osfhandle(file.handle());\n#else\n    const int handle = file.handle();\n#endif\n\n    std::unique_ptr<TIFF, decltype(&TIFFCleanup)> image(TIFFFdOpen(handle, encodedFilename.data(), \"r\"), &TIFFCleanup);\n\n    if (!image) {\n        dbgFile << \"Could not open the file, either it does not exist, either \"\n                   \"it is not a TIFF :\"\n                << filename();\n        return (ImportExportCodes::FileFormatIncorrect);\n    }\n    dbgFile << \"Reading first image descriptor\";\n    KisImportExportErrorCode result = readTIFFDirectory(document, image.get());\n    if (!result.isOk()) {\n        return result;\n    }\n\n    if (!m_photoshopBlockParsed) {\n        // Photoshop images only have one IFD plus the layer blob\n        // Ward off inconsistencies by blocking future attempts to parse them\n        m_photoshopBlockParsed = true;\n        while (TIFFReadDirectory(image.get())) {\n            result = readTIFFDirectory(document, image.get());\n            if (!result.isOk()) {\n                return result;\n            }\n        }\n    }\n    // Freeing memory\n    image.reset();\n    file.close();\n\n    {\n        // HACK!! Externally parse the Exif metadata\n        // libtiff has no way to access the fields wholesale\n        try {\n            KisExiv2IODevice::ptr_type basicIoDevice(new KisExiv2IODevice(filename()));\n\n#if EXIV2_TEST_VERSION(0,28,0)\n            const std::unique_ptr<Exiv2::Image> readImg = Exiv2::ImageFactory::open(std::move(basicIoDevice));\n#else\n            const std::unique_ptr<Exiv2::Image> readImg(Exiv2::ImageFactory::open(basicIoDevice).release());\n#endif\n\n            readImg->readMetadata();\n\n            const KisMetaData::IOBackend *io =\n                KisMetadataBackendRegistry::instance()->value(\"exif\");\n\n            // All IFDs are paint layer children of root\n            KisNodeSP node = m_image->rootLayer()->firstChild();\n\n            QBuffer ioDevice;\n\n            {\n                // Synthesize the Exif blob\n                Exiv2::ExifData tempData;\n                Exiv2::Blob tempBlob;\n\n                // NOTE: do not use std::copy_if, auto_ptrs beware\n                for (const Exiv2::Exifdatum &i : readImg->exifData()) {\n                    const uint16_t tag = i.tag();\n\n                    if (tag == Exif::Image::ImageWidth\n                        || tag == Exif::Image::ImageLength\n                        || tag == Exif::Image::BitsPerSample\n                        || tag == Exif::Image::Compression\n                        || tag == Exif::Image::PhotometricInterpretation\n                        || tag == Exif::Image::Orientation\n                        || tag == Exif::Image::SamplesPerPixel\n                        || tag == Exif::Image::PlanarConfiguration\n                        || tag == Exif::Image::YCbCrSubSampling\n                        || tag == Exif::Image::YCbCrPositioning\n                        || tag == Exif::Image::XResolution\n                        || tag == Exif::Image::YResolution\n                        || tag == Exif::Image::ResolutionUnit\n                        || tag == Exif::Image::TransferFunction\n                        || tag == Exif::Image::WhitePoint\n                        || tag == Exif::Image::PrimaryChromaticities\n                        || tag == Exif::Image::YCbCrCoefficients\n                        || tag == Exif::Image::ReferenceBlackWhite\n                        || tag == Exif::Image::InterColorProfile) {\n                        dbgMetaData << \"Ignoring TIFF-specific\"\n                                    << i.key().c_str();\n                        continue;\n                    }\n\n                    tempData.add(i);\n                }\n\n                // Encode into temporary blob\n                Exiv2::ExifParser::encode(tempBlob,\n                                          Exiv2::littleEndian,\n                                          tempData);\n\n                // Reencode into Qt land\n                ioDevice.setData(reinterpret_cast<char *>(tempBlob.data()),\n                                 static_cast<int>(tempBlob.size()));\n            }\n\n            // Get layer\n            KisLayer *layer = qobject_cast<KisLayer *>(node.data());\n            KIS_ASSERT_RECOVER(layer)\n            {\n                errFile << \"Attempted to import metadata on an empty document\";\n                return ImportExportCodes::InternalError;\n            }\n\n            // Inject the data as any other IOBackend\n            io->loadFrom(layer->metaData(), &ioDevice);\n#if EXIV2_TEST_VERSION(0,28,0)\n        } catch (Exiv2::Error &e) {\n            errFile << \"Failed metadata import:\" << Exiv2::Error(e.code()).what();\n#else\n        } catch (Exiv2::AnyError &e) {\n            errFile << \"Failed metadata import:\" << e.code() << e.what();\n#endif\n        }\n    }\n\n    document->setCurrentImage(m_image);\n\n    m_image = nullptr;\n    m_photoshopBlockParsed = false;\n\n    return ImportExportCodes::OK;\n}",
    "GDALDataset *GTiffDataset::OpenDir(GDALOpenInfo *poOpenInfo)\n\n{\n    bool bAllowRGBAInterface = true;\n    const char *pszFilename = poOpenInfo->pszFilename;\n    if (STARTS_WITH_CI(pszFilename, \"GTIFF_RAW:\"))\n    {\n        bAllowRGBAInterface = false;\n        pszFilename += strlen(\"GTIFF_RAW:\");\n    }\n\n    if (!STARTS_WITH_CI(pszFilename, \"GTIFF_DIR:\") ||\n        pszFilename[strlen(\"GTIFF_DIR:\")] == '\\0')\n    {\n        return nullptr;\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Split out filename, and dir#/offset.                            */\n    /* -------------------------------------------------------------------- */\n    pszFilename += strlen(\"GTIFF_DIR:\");\n    bool bAbsolute = false;\n\n    if (STARTS_WITH_CI(pszFilename, \"off:\"))\n    {\n        bAbsolute = true;\n        pszFilename += 4;\n    }\n\n    toff_t nOffset = atol(pszFilename);\n    pszFilename += 1;\n\n    while (*pszFilename != '\\0' && pszFilename[-1] != ':')\n        ++pszFilename;\n\n    if (*pszFilename == '\\0' || nOffset == 0)\n    {\n        ReportError(\n            pszFilename, CE_Failure, CPLE_OpenFailed,\n            \"Unable to extract offset or filename, should take the form:\\n\"\n            \"GTIFF_DIR:<dir>:filename or GTIFF_DIR:off:<dir_offset>:filename\");\n        return nullptr;\n    }\n\n    if (poOpenInfo->eAccess == GA_Update)\n    {\n        ReportError(pszFilename, CE_Warning, CPLE_AppDefined,\n                    \"Opening a specific TIFF directory is not supported in \"\n                    \"update mode. Switching to read-only\");\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Try opening the dataset.                                        */\n    /* -------------------------------------------------------------------- */\n    GTiffOneTimeInit();\n\n    const char *pszFlag = poOpenInfo->eAccess == GA_Update ? \"r+DC\" : \"rDOC\";\n    VSILFILE *l_fpL = VSIFOpenL(pszFilename, pszFlag);\n    if (l_fpL == nullptr)\n        return nullptr;\n    TIFF *l_hTIFF = VSI_TIFFOpen(pszFilename, pszFlag, l_fpL);\n    if (l_hTIFF == nullptr)\n    {\n        CPL_IGNORE_RET_VAL(VSIFCloseL(l_fpL));\n        return nullptr;\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      If a directory was requested by index, advance to it now.       */\n    /* -------------------------------------------------------------------- */\n    if (!bAbsolute)\n    {\n        const toff_t nOffsetRequested = nOffset;\n        while (nOffset > 1)\n        {\n            if (TIFFReadDirectory(l_hTIFF) == 0)\n            {\n                XTIFFClose(l_hTIFF);\n                ReportError(pszFilename, CE_Failure, CPLE_OpenFailed,\n                            \"Requested directory %lu not found.\",\n                            static_cast<long unsigned int>(nOffsetRequested));\n                CPL_IGNORE_RET_VAL(VSIFCloseL(l_fpL));\n                return nullptr;\n            }\n            nOffset--;\n        }\n\n        nOffset = TIFFCurrentDirOffset(l_hTIFF);\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Create a corresponding GDALDataset.                             */\n    /* -------------------------------------------------------------------- */\n    GTiffDataset *poDS = new GTiffDataset();\n    poDS->SetDescription(poOpenInfo->pszFilename);\n    poDS->m_pszFilename = CPLStrdup(pszFilename);\n    poDS->m_fpL = l_fpL;\n    poDS->m_hTIFF = l_hTIFF;\n    poDS->m_bSingleIFDOpened = true;\n\n    if (!EQUAL(pszFilename, poOpenInfo->pszFilename) &&\n        !STARTS_WITH_CI(poOpenInfo->pszFilename, \"GTIFF_RAW:\"))\n    {\n        poDS->SetPhysicalFilename(pszFilename);\n        poDS->SetSubdatasetName(poOpenInfo->pszFilename);\n    }\n\n    if (poOpenInfo->AreSiblingFilesLoaded())\n        poDS->oOvManager.TransferSiblingFiles(poOpenInfo->StealSiblingFiles());\n\n    if (poDS->OpenOffset(l_hTIFF, nOffset, poOpenInfo->eAccess,\n                         bAllowRGBAInterface, true) != CE_None)\n    {\n        delete poDS;\n        return nullptr;\n    }\n\n    return poDS;\n}",
    "CPLErr GTiffDataset::CleanOverviews()\n\n{\n    CPLAssert(!m_poBaseDS);\n\n    ScanDirectories();\n\n    FlushDirectory();\n\n    /* -------------------------------------------------------------------- */\n    /*      Cleanup overviews objects, and get offsets to all overview      */\n    /*      directories.                                                    */\n    /* -------------------------------------------------------------------- */\n    std::vector<toff_t> anOvDirOffsets;\n\n    for (int i = 0; i < m_nOverviewCount; ++i)\n    {\n        anOvDirOffsets.push_back(m_papoOverviewDS[i]->m_nDirOffset);\n        if (m_papoOverviewDS[i]->m_poMaskDS)\n            anOvDirOffsets.push_back(\n                m_papoOverviewDS[i]->m_poMaskDS->m_nDirOffset);\n        delete m_papoOverviewDS[i];\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Loop through all the directories, translating the offsets       */\n    /*      into indexes we can use with TIFFUnlinkDirectory().             */\n    /* -------------------------------------------------------------------- */\n    std::vector<uint16_t> anOvDirIndexes;\n    int iThisOffset = 1;\n\n    TIFFSetDirectory(m_hTIFF, 0);\n\n    while (true)\n    {\n        for (toff_t nOffset : anOvDirOffsets)\n        {\n            if (nOffset == TIFFCurrentDirOffset(m_hTIFF))\n            {\n                anOvDirIndexes.push_back(static_cast<uint16_t>(iThisOffset));\n            }\n        }\n\n        if (TIFFLastDirectory(m_hTIFF))\n            break;\n\n        TIFFReadDirectory(m_hTIFF);\n        ++iThisOffset;\n    }\n\n    /* -------------------------------------------------------------------- */\n    /*      Actually unlink the target directories.  Note that we do        */\n    /*      this from last to first so as to avoid renumbering any of       */\n    /*      the earlier directories we need to remove.                      */\n    /* -------------------------------------------------------------------- */\n    while (!anOvDirIndexes.empty())\n    {\n        TIFFUnlinkDirectory(m_hTIFF, anOvDirIndexes.back());\n        anOvDirIndexes.pop_back();\n    }\n\n    CPLFree(m_papoOverviewDS);\n    m_nOverviewCount = 0;\n    m_papoOverviewDS = nullptr;\n\n    if (m_poMaskDS)\n    {\n        CPLFree(m_poMaskDS->m_papoOverviewDS);\n        m_poMaskDS->m_nOverviewCount = 0;\n        m_poMaskDS->m_papoOverviewDS = nullptr;\n    }\n\n    if (!SetDirectory())\n        return CE_Failure;\n\n    return CE_None;\n}",
    "std::tuple<GLuint, glm::ivec3> read3DTexture(std::string const& path) {\n  auto* data = TIFFOpen(path.c_str(), \"r\");\n\n  if (!data) {\n    logger().error(\"Failed to open TIFF file '{}'\", path);\n    return {0u, {0, 0, 0}};\n  }\n\n  uint32_t width{};\n  uint32_t height{};\n  uint32_t depth{};\n\n  TIFFGetField(data, TIFFTAG_IMAGELENGTH, &height);\n  TIFFGetField(data, TIFFTAG_IMAGEWIDTH, &width);\n\n  do {\n    depth++;\n  } while (TIFFReadDirectory(data));\n\n  std::vector<float> pixels(width * height * depth * 3);\n\n  for (unsigned z = 0; z < depth; z++) {\n    TIFFSetDirectory(data, z);\n    for (unsigned y = 0; y < height; y++) {\n      TIFFReadScanline(data, &pixels[width * 3 * y + (3 * width * height * z)], y);\n    }\n  }\n\n  TIFFClose(data);\n\n  GLuint texture;\n  glGenTextures(1, &texture);\n  glActiveTexture(GL_TEXTURE0);\n  glBindTexture(GL_TEXTURE_3D, texture);\n  glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n  glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n  glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\n  glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\n  glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);\n  glBindBuffer(GL_PIXEL_UNPACK_BUFFER, 0);\n  glTexImage3D(\n      GL_TEXTURE_3D, 0, GL_RGB32F, width, height, depth, 0, GL_RGB, GL_FLOAT, pixels.data());\n\n  return {texture, {width, height, depth}};\n}",
    "absl::Status TiffReader::Context::Open() {\n  tiff_ = TIFFClientOpen(\"tensorstore_tiff_reader\", \"rmh\",\n                         static_cast<thandle_t>(this), &ReadProc, &NoWriteProc,\n                         &SeekProc, &CloseProc, &SizeProc,\n                         /*mmap*/ nullptr, /*munmap*/ nullptr);\n  if (!tiff_) {\n    return absl::InvalidArgumentError(\"Not a TIFF file\");\n  }\n\n  // NOTE: If https://gitlab.com/libtiff/libtiff/-/merge_requests/390 is\n  // submitted, then we can setup per-file error handling and skip the initial\n  // header read.\n  if (!TIFFReadDirectory(tiff_)) {\n    error_.Update(absl::InvalidArgumentError(\"Failed to read TIFF directory\"));\n  }\n\n#if 0\n  // TODO: If this tiff has a thumbnail, then we probably want to skip it\n  // by default.\n  uint32_t file_type;\n  if (TIFFGetField(tiff_, TIFFTAG_SUBFILETYPE, &file_type) &&\n      file_type == FILETYPE_REDUCEDIMAGE) {\n    // It's a thumbnail\n  }\n#endif\n\n  return ExtractErrors(absl::OkStatus());\n}",
    "void\nTiffPlugin::setImageFiles(QStringList files)\n{\n  QProgressDialog progress(\"Enumerating files - may take some time...\",\n\t\t\t   0,\n\t\t\t   0, 100,\n\t\t\t   0);\n  progress.setMinimumDuration(0);\n\n  QStringList flist;\n  flist.clear();\n  \n  for(uint i=0; i<files.size(); i++)\n    {\n      progress.setValue(100*(float)i/(float)files.size());\n      qApp->processEvents();\n      \n      QFileInfo fileInfo(m_fileName[0], files[i]);\n      QString imgfl = fileInfo.absoluteFilePath();\n\n      m_imageList.append(imgfl);\n    }\n  \n  progress.setValue(100);\n  qApp->processEvents();\n\n  m_depth = m_imageList.size();\n\n  TIFF *image;\n  image = TIFFOpen((char*)m_imageList[0].toUtf8().data(), \"r\");\n  \n  // -- get number of images(directories) within the file\n  m_dirCount = 0;\n  if (image)\n    {\n      do {\n\tm_dirCount ++;\n      } while (TIFFReadDirectory(image));\n      if (m_dirCount > 1)\n\tQMessageBox::information(0, \"3D Tiff\",\n\t\t\t\t QString(\"Number of images : %1\").arg(m_dirCount));\n      if (m_dirCount > 1)\n\tm_depth = m_dirCount;\n    }\n\n  TIFFGetField(image, TIFFTAG_IMAGEWIDTH, &m_width);\n  TIFFGetField(image, TIFFTAG_IMAGELENGTH, &m_height);\n\n  uint16 bitPerSample;\n  TIFFGetField(image, TIFFTAG_BITSPERSAMPLE, &bitPerSample);\n\n  TIFFClose(image);\n\n  if (bitPerSample == 1)\n    {\n      QMessageBox::critical(0, \"Image Format Error\", \"Cannot handle this format : bits per voxel = 1\");\n      m_imageList.clear();\n      return;\n    }\n\n  if (bitPerSample == 8)\n    {\n      m_voxelType = _UChar;\n\n      QStringList vtypes;\n      vtypes << \"UChar\";\n      vtypes << \"Char\";\n      QString option = QInputDialog::getItem(0,\n\t\t\t\t\t     \"Select Voxel Type\",\n\t\t\t\t\t     \"Voxel Type (found 8 bits per voxel)\",\n\t\t\t\t\t     vtypes,\n\t\t\t\t\t     0,\n\t\t\t\t\t     false);\n      int idx = vtypes.indexOf(option);\n      if (idx == 1)\n\tm_voxelType = _Char;\n    }\n  else if (bitPerSample == 16)\n    {\n      m_voxelType = _UShort;\n\n      QStringList vtypes;\n      vtypes << \"UShort\";\n      vtypes << \"Short\";\n      QString option = QInputDialog::getItem(0,\n\t\t\t\t\t     \"Select Voxel Type\",\n\t\t\t\t\t     \"Voxel Type (found 16 bits per voxel)\",\n\t\t\t\t\t     vtypes,\n\t\t\t\t\t     0,\n\t\t\t\t\t     false);\n      int idx = vtypes.indexOf(option);\n      if (idx == 1)\n\tm_voxelType = _Short;\n    }\n  else if (bitPerSample == 32)\n    {\n      m_voxelType = _Float;\n\n      QStringList vtypes;\n      vtypes << \"Float\";\n      vtypes << \"Int\";\n      QString option = QInputDialog::getItem(0,\n\t\t\t\t\t     \"Select Voxel Type\",\n\t\t\t\t\t     \"Voxel Type (found 32 bits per voxel)\",\n\t\t\t\t\t     vtypes,\n\t\t\t\t\t     0,\n\t\t\t\t\t     false);\n      int idx = vtypes.indexOf(option);\n      if (idx == 1)\n\tm_voxelType = _Int;\n    }\n\n  m_headerBytes = 0;\n\n  m_bytesPerVoxel = 1;\n  if (m_voxelType == _UChar) m_bytesPerVoxel = 1;\n  else if (m_voxelType == _Char) m_bytesPerVoxel = 1;\n  else if (m_voxelType == _UShort) m_bytesPerVoxel = 2;\n  else if (m_voxelType == _Short) m_bytesPerVoxel = 2;\n  else if (m_voxelType == _Int) m_bytesPerVoxel = 4;\n  else if (m_voxelType == _Float) m_bytesPerVoxel = 4;\n\n  if (m_voxelType == _UChar ||\n      m_voxelType == _Char ||\n      m_voxelType == _UShort ||\n      m_voxelType == _Short)\n    findMinMaxandGenerateHistogram();\n  else\n    {\n      //QMessageBox::information(0, \"Error\",\n      //\t\t       \"Currently accepting only 1- and 2-byte images\");\n      findMinMax();\n      generateHistogram();\n    }\n}",
    "int ScImgDataLoader_TIFF::getLayers(const QString& fn, int /*page*/)\n{\n\tint layerNum = 1;\n\tint test;\n\tstruct PSDLayer lay;\n\tTIFFSetTagExtender(TagExtender);\n\tTIFF* tif = TIFFOpen(fn.toLocal8Bit(), \"r\");\n\tif (!tif)\n\t\treturn layerNum;\n\n\tdo\n\t{\n\t\tchar *layerName = nullptr;\n\t\tTIFFGetField(tif, TIFFTAG_PAGENAME, &layerName);\n\t\tQString name(layerName);\n\t\tif (name.isEmpty())\n\t\t\tlay.layerName = QString(\"Layer #%1\").arg(layerNum);\n\t\telse\n\t\t\tlay.layerName = name;\n\t\tlay.blend = \"norm\";\n\t\tlay.opacity = 255;\n\t\tlay.flags = 0;\n\t\tm_imageInfoRecord.layerInfo.append(lay);\n\t\tm_imageInfoRecord.valid = true;\n\t\tlayerNum++;\n\t\ttest = TIFFReadDirectory(tif);\n\t}\n\twhile (test == 1);\n\tTIFFClose(tif);\n\n\treturn layerNum;\n}",
    "bool ScImgDataLoader_TIFF::loadPicture(const QString& fn, int page, int res, bool thumbnail)\n{\n\tScColorMgmtEngine engine(ScCore->defaultEngine);\n\tbool bilevel = false;\n\tbool failedPS = false;\n\tbool foundPS = false;\n\tshort resolutionUnit = RESUNIT_INCH; // Default unit is inch\n\tfloat xres = 72.0, yres = 72.0;\n\tif (!QFile::exists(fn))\n\t\treturn false;\n\tQByteArray byteOrder(2, ' ');\n\tQFile fo(fn);\n\tif (fo.open(QIODevice::ReadOnly))\n\t{\n\t\tfo.read(byteOrder.data(), 1);\n\t\tfo.close();\n\t}\n\tsrand(314159265);\n\tfor (int i = 0; i < 4096; i++)\n\t\tm_random_table[i] = rand();\n\tfor (int i = 0; i < 4096; i++)\n\t{\n\t\tint tmp;\n\t\tint swap = i + rand() % (4096 - i);\n\t\ttmp = m_random_table[i];\n\t\tm_random_table[i] = m_random_table[swap];\n\t\tm_random_table[swap] = tmp;\n\t}\n\n\tinitialize();\n\n\tint test;\n\tbool valid = m_imageInfoRecord.isRequest;\n\tQMap<int, ImageLoadRequest> req = m_imageInfoRecord.RequestProps;\n\tm_imageInfoRecord.RequestProps = req;\n\tm_imageInfoRecord.isRequest = valid;\n\tm_imageInfoRecord.type = ImageTypeTIF;\n\tgetLayers(fn, page);\n\n\tTIFFSetTagExtender(TagExtender);\n\tTIFF* tif = TIFFOpen(fn.toLocal8Bit(), \"r\");\n\tif (!tif)\n\t\treturn false;\n\n\tbool isCMYK = false;\n\tunsigned int widtht, heightt, size;\n\tchar* description = nullptr;\n\tchar* copyright = nullptr;\n\tchar* datetime = nullptr;\n\tchar* artist = nullptr;\n\tchar* scannerMake = nullptr;\n\tchar* scannerModel = nullptr;\n\tuint16_t bitsPerSample = 1;\n\tuint16_t sampleFormat = SAMPLEFORMAT_UINT;\n\tuint16_t fillorder = FILLORDER_MSB2LSB;\n\tuint16_t planar = PLANARCONFIG_CONTIG;\n\n\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &widtht);\n\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &heightt);\n\tTIFFGetField(tif, TIFFTAG_XRESOLUTION, &xres);\n\tTIFFGetField(tif, TIFFTAG_YRESOLUTION, &yres);\n\tTIFFGetField(tif, TIFFTAG_RESOLUTIONUNIT , &resolutionUnit);\n\tsize = widtht * heightt;\n\tTIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &m_photometric);\n\tTIFFGetField(tif, TIFFTAG_PLANARCONFIG, &planar);\n\tTIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bitsPerSample);\n\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &m_samplesPerPixel);\n\tTIFFGetField(tif, TIFFTAG_SAMPLEFORMAT, &sampleFormat);\n\tTIFFGetField(tif, TIFFTAG_FILLORDER, &fillorder);\n\n\tTIFFGetField(tif, TIFFTAG_MAKE, &scannerMake);\n\tTIFFGetField(tif, TIFFTAG_MODEL, &scannerModel);\n\tTIFFGetField(tif, TIFFTAG_IMAGEDESCRIPTION, &description);\n\tTIFFGetField(tif, TIFFTAG_COPYRIGHT, &copyright);\n\tTIFFGetField(tif, TIFFTAG_DATETIME, &datetime);\n\tTIFFGetField(tif, TIFFTAG_ARTIST, &artist);\n\n\tSampleFormatInfo sampleInfo;\n\tsampleInfo.photometric = m_photometric;\n\tsampleInfo.bitsPerSample = bitsPerSample;\n\tsampleInfo.samplesPerPixel = m_samplesPerPixel;\n\tsampleInfo.samplesFormat = sampleFormat;\n\tsampleInfo.fillOrder = fillorder;\n\n\tm_imageInfoRecord.exifInfo.cameraName = QString(scannerModel);\n\tm_imageInfoRecord.exifInfo.cameraVendor = QString(scannerMake);\n\tm_imageInfoRecord.exifInfo.comment = QString(description);\n\tm_imageInfoRecord.exifInfo.userComment = QString(copyright);\n\tm_imageInfoRecord.exifInfo.width = widtht;\n\tm_imageInfoRecord.exifInfo.height = heightt;\n\tm_imageInfoRecord.exifInfo.dateTime = QString(datetime);\n\tm_imageInfoRecord.exifInfo.artist = QString(artist);\n\tm_imageInfoRecord.exifInfo.thumbnail = QImage();\n\tm_imageInfoRecord.exifDataValid = true;\n\n\tm_imageInfoRecord.isEmbedded = false;\n\tm_imageInfoRecord.profileName.clear();\n\tm_imageInfoRecord.embeddedProfileName.clear();\n\n\tuint32_t EmbedLen = 0;\n\tvoid*  EmbedBuffer;\n\tif (TIFFGetField(tif, TIFFTAG_ICCPROFILE, &EmbedLen, &EmbedBuffer))\n\t{\n\t\tbool profileIsValid = false;\n\t\tQByteArray profArray((const char*) EmbedBuffer, EmbedLen);\n\t\tScColorProfile tiffProf = engine.openProfileFromMem(profArray);\n\t\tif (tiffProf)\n\t\t{\n\t\t\teColorSpaceType colorSpace = tiffProf.colorSpace();\n\t\t\tif (colorSpace == ColorSpace_Rgb)\n\t\t\t\tprofileIsValid = (m_photometric == PHOTOMETRIC_RGB);\n\t\t\tif (colorSpace == ColorSpace_Cmyk)\n\t\t\t\tprofileIsValid = (m_photometric == PHOTOMETRIC_SEPARATED && m_samplesPerPixel >= 4);\n\t\t\tif (colorSpace == ColorSpace_Gray)\n\t\t\t\tprofileIsValid = (m_photometric == PHOTOMETRIC_MINISBLACK || m_photometric == PHOTOMETRIC_MINISWHITE);\n\t\t}\n\t\tif (profileIsValid)\n\t\t{\n\t\t\tm_embeddedProfile = profArray;\n\t\t\tm_imageInfoRecord.profileName = tiffProf.productDescription();\n\t\t\tm_imageInfoRecord.embeddedProfileName = m_imageInfoRecord.profileName;\n\t\t\tm_imageInfoRecord.isEmbedded = true;\n\t\t}\n\t}\n\n\tunsigned int PhotoshopLen = 0;\n\tunsigned char* PhotoshopBuffer;\n\tif (TIFFGetField(tif, TIFFTAG_PHOTOSHOP, &PhotoshopLen, &PhotoshopBuffer) )\n\t{\n\t\tif (PhotoshopLen != 0)\n\t\t{\n\t\t\tQByteArray arrayPhot = QByteArray((const char*)PhotoshopBuffer,PhotoshopLen);\n\t\t\tQDataStream strPhot(&arrayPhot,QIODevice::ReadOnly);\n\t\t\tstrPhot.setByteOrder( QDataStream::BigEndian );\n\t\t\tPSDHeader fakeHeader;\n\t\t\tfakeHeader.width = widtht;\n\t\t\tfakeHeader.height = heightt;\n\t\t\tparseResourceData(strPhot, fakeHeader, PhotoshopLen);\n\t\t\tm_imageInfoRecord.exifInfo.width = widtht;\n\t\t\tm_imageInfoRecord.exifInfo.height = heightt;\n\t\t\tif (!m_imageInfoRecord.valid)\n\t\t\t\tm_imageInfoRecord.valid = (m_imageInfoRecord.PDSpathData.size())>0;\n\t\t\tif (thumbnail)\n\t\t\t{\n\t\t\t\tif (m_photometric == PHOTOMETRIC_SEPARATED)\n\t\t\t\t{\n\t\t\t\t\tisCMYK = true;\n\t\t\t\t\tm_imageInfoRecord.colorspace = ColorSpaceCMYK;\n\t\t\t\t}\n\t\t\t\telse if (m_samplesPerPixel == 1)\n\t\t\t\t{\n\t\t\t\t\tm_imageInfoRecord.colorspace = ColorSpaceGray;\n\t\t\t\t\tisCMYK = false;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tm_imageInfoRecord.colorspace = ColorSpaceRGB;\n\t\t\t\tif (bitsPerSample == 1)\n\t\t\t\t\tbilevel = true;\n\t\t\t\tif (!m_imageInfoRecord.exifInfo.thumbnail.isNull())\n\t\t\t\t{\n\t\t\t\t\tif (isCMYK)\n\t\t\t\t\t{\n\t\t\t\t\t\tr_image.create(m_imageInfoRecord.exifInfo.thumbnail.width(), m_imageInfoRecord.exifInfo.thumbnail.height(), 5);\n\t\t\t\t\t\tm_pixelFormat = Format_CMYKA_8;;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tr_image.create(m_imageInfoRecord.exifInfo.thumbnail.width(), m_imageInfoRecord.exifInfo.thumbnail.height(), 4);\n\t\t\t\t\t\tm_pixelFormat = (m_imageInfoRecord.colorspace == ColorSpaceCMYK) ? Format_CMYK_8 : Format_RGBA_8;\n\t\t\t\t\t}\n\t\t\t\t\tr_image.fill(0);\n\t\t\t\t\tQRgb *s;\n\t\t\t\t\tuchar *d;\n\t\t\t\t\tunsigned char cc, cm, cy, ck;\n\t\t\t\t\tfor (int yit = 0; yit < m_imageInfoRecord.exifInfo.thumbnail.height(); ++yit)\n\t\t\t\t\t{\n\t\t\t\t\t\ts = (QRgb*)(m_imageInfoRecord.exifInfo.thumbnail.scanLine(yit));\n\t\t\t\t\t\td = r_image.scanLine(yit);\n\t\t\t\t\t\tfor (int xit = 0; xit < m_imageInfoRecord.exifInfo.thumbnail.width(); ++xit)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (isCMYK)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcc = 255 - qRed(*s);\n\t\t\t\t\t\t\t\tcm = 255 - qGreen(*s);\n\t\t\t\t\t\t\t\tcy = 255 - qBlue(*s);\n\t\t\t\t\t\t\t\tck = qMin(qMin(cc, cm), cy);\n\t\t\t\t\t\t\t\td[0] = cc-ck;\n\t\t\t\t\t\t\t\td[1] = cm-ck;\n\t\t\t\t\t\t\t\td[2] = cy-ck;\n\t\t\t\t\t\t\t\td[3] = ck;\n\t\t\t\t\t\t\t\td[4] = 255;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\td[0] = qRed(*s);\n\t\t\t\t\t\t\t\td[1] = qGreen(*s);\n\t\t\t\t\t\t\t\td[2] = qBlue(*s);\n\t\t\t\t\t\t\t\td[3] = 255;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ts++;\n\t\t\t\t\t\t\td += r_image.channels();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tTIFFClose(tif);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tunsigned int PhotoshopLen2 = 0;\n\tunsigned char* PhotoshopBuffer2;\n\tint gotField = TIFFGetField(tif, 37724, &PhotoshopLen2, &PhotoshopBuffer2);\n\tif (gotField && (PhotoshopLen2 > 40))\n\t{\n\t\tm_imageInfoRecord.layerInfo.clear();\n\t\tQByteArray arrayPhot = QByteArray::fromRawData((const char*)PhotoshopBuffer2, PhotoshopLen2);\n\t\tQDataStream s(&arrayPhot,QIODevice::ReadOnly);\n\t\tif (byteOrder[0] == 'M')\n\t\t\ts.setByteOrder( QDataStream::BigEndian );\n\t\telse\n\t\t\ts.setByteOrder( QDataStream::LittleEndian );\n\n\t\tfailedPS = !loadLayerInfo(s, m_imageInfoRecord.layerInfo); \n\t\tif (!failedPS)\n\t\t{\n\t\t\tint chans = 4;\n\t\t\tint numChannels = m_imageInfoRecord.layerInfo.last().channelType.count();\n\t\t\tint numLayers = m_imageInfoRecord.layerInfo.count();\n\t\t\tPSDHeader fakeHeader;\n\t\t\tfakeHeader.width = widtht;\n\t\t\tfakeHeader.height = heightt;\n\t\t\tfakeHeader.channel_count = numChannels;\n\t\t\tfakeHeader.depth = 8;\n\t\t\tif (m_photometric == PHOTOMETRIC_SEPARATED)\n\t\t\t{\n\t\t\t\tisCMYK = true;\n\t\t\t\tfakeHeader.color_mode = CM_CMYK;\n\t\t\t\tchans = 5;\n\t\t\t}\n\t\t\telse if (m_samplesPerPixel == 1)\n\t\t\t{\n\t\t\t\tfakeHeader.color_mode = CM_GRAYSCALE;\n\t\t\t\tisCMYK = false;\n\t\t\t\tchans = 4;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfakeHeader.color_mode = CM_RGB;\n\t\t\t\tisCMYK = false;\n\t\t\t\tchans = 4;\n\t\t\t}\n\t\t\tif (!r_image.create(widtht, heightt, chans))\n\t\t\t\treturn false;\n\t\t\tr_image.fill(0);\n\t\t\tbool firstLayer = true;\n\t\t\tfor (int layer = 0; layer < numLayers; layer++)\n\t\t\t{\n\t\t\t\tloadLayerChannels( s, fakeHeader, m_imageInfoRecord.layerInfo, layer, &firstLayer );\n\t\t\t}\n\t\t\tarrayPhot.clear();\n\t\t\tTIFFClose(tif);\n\t\t\tfoundPS = true;\n\t\t\tif (m_imageInfoRecord.layerInfo.count() == 1)\n\t\t\t\tm_imageInfoRecord.layerInfo.clear();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tarrayPhot.clear();\n\t\t\tgetLayers(fn, page);\n\t\t}\n\t}\n\n\tif (xres <= 1.0 || yres <= 1.0)\n\t{\n\t\txres = yres = 72.0;\n\t\tQFileInfo qfi(fn);\n\t\tm_message = QObject::tr(\"%1 may be corrupted : missing resolution tags\").arg(qfi.fileName());\n\t\tm_msgType = warningMsg;\n\t}\n\tif ((!foundPS) || (failedPS))\n\t{\n\t\tint chans = 4;\n\t\tif (m_photometric == PHOTOMETRIC_SEPARATED)\n\t\t{\n\t\t\tif (m_samplesPerPixel > 5) \n\t\t\t\tchans = 4;\n\t\t\telse\n\t\t\t\tchans = m_samplesPerPixel;\n\t\t}\n\t\telse\n\t\t\tchans = 4;\n\t\tif (!r_image.create(widtht, heightt, chans))\n\t\t{\n\t\t\tTIFFClose(tif);\n\t\t\treturn false;\n\t\t}\n\t\tr_image.fill(0);\n\t\tint layerNum = 0;\n\t\tdo\n\t\t{\n\t\t\tRawImage tmpImg;\n\t\t\tif (!tmpImg.create(widtht, heightt, chans))\n\t\t\t{\n\t\t\t\tTIFFClose(tif);\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\ttmpImg.fill(0);\n\t\t\tif (!getImageData(tif, &tmpImg, widtht, heightt, size, sampleInfo, bilevel, isCMYK))\n\t\t\t{\n\t\t\t\tTIFFClose(tif);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbool visible = true;\n\t\t\tbool useMask = true;\n\t\t\tif ((m_imageInfoRecord.isRequest) && (m_imageInfoRecord.RequestProps.contains(layerNum)))\n\t\t\t\tvisible = m_imageInfoRecord.RequestProps[layerNum].visible;\n\t\t\tQString layBlend(\"norm\");\n\t\t\tif ((m_imageInfoRecord.isRequest) && (m_imageInfoRecord.RequestProps.contains(layerNum)))\n\t\t\t\tlayBlend = m_imageInfoRecord.RequestProps[layerNum].blend;\n\t\t\tif ((m_imageInfoRecord.isRequest) && (m_imageInfoRecord.RequestProps.contains(layerNum)))\n\t\t\t\tuseMask = m_imageInfoRecord.RequestProps[layerNum].useMask;\n\t\t\tint layOpa = 255;\n\t\t\tif ((m_imageInfoRecord.isRequest) && (m_imageInfoRecord.RequestProps.contains(layerNum)))\n\t\t\t\tlayOpa = m_imageInfoRecord.RequestProps[layerNum].opacity;\n\t\t\tif (visible)\n\t\t\t{\n\t\t\t\tif ((layerNum == 0) && (layBlend != \"diss\"))\n\t\t\t\t\tr_image = tmpImg;\n\t\t\t\telse\n\t\t\t\t\tblendOntoTarget(&tmpImg, layOpa, layBlend, isCMYK, useMask);\n\t\t\t}\n\t\t\t//JG Copy should not be necessary as QImage is implicitly shared in Qt4\n\t\t\tQImage imt; //QImage imt = tmpImg.copy();\n\t\t\tdouble sx = tmpImg.width() / 40.0;\n\t\t\tdouble sy = tmpImg.height() / 40.0;\n\t\t\timt = tmpImg.convertToQImage(chans > 4);\n\t\t\timt = sy < sx ?\timt.scaled(qRound(imt.width() / sx), qRound(imt.height() / sx), Qt::IgnoreAspectRatio, Qt::SmoothTransformation) :\n\t\t\t\t\t\t\t\t\t\timt.scaled(qRound(imt.width() / sy), qRound(imt.height() / sy), Qt::IgnoreAspectRatio, Qt::SmoothTransformation);\n\t\t\tm_imageInfoRecord.layerInfo[layerNum].thumb = imt.copy();\n\t\t\tif (chans > 4)\n\t\t\t{\n\t\t\t\tQImage imt2 = imt.createAlphaMask();\n\t\t\t\timt2.invertPixels();\n\t\t\t\tm_imageInfoRecord.layerInfo[layerNum].thumb_mask = imt2.copy();\n\t\t\t}\n\t\t\telse\n\t\t\t\tm_imageInfoRecord.layerInfo[layerNum].thumb_mask = QImage();\n\t\t\tlayerNum++;\n\n\t\t\tif ((m_imageInfoRecord.layerInfo.count() == 1) && (chans < 5))\n\t\t\t\tm_imageInfoRecord.layerInfo.clear();\n\t\t\ttest = TIFFReadDirectory(tif);\n\n\t\t\t// #10415 : check that image size for the current directory is the same as the main one\n\t\t\t// Some progs use tiff directory to store previews, we do not handle such case\n\t\t\t// and may perform reads in non allocated blocks if we continue\n\t\t\twhile (test == 1)\n\t\t\t{\n\t\t\t\tunsigned int dirWidth(0), dirHeight(0);\n\t\t\t\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &dirWidth);\n\t\t\t\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &dirHeight);\n\t\t\t\tif (dirWidth == widtht && dirHeight == heightt)\n\t\t\t\t\tbreak;\n\t\t\t\ttest = TIFFReadDirectory(tif);\n\t\t\t\tlayerNum++;\n\t\t\t}\n\t\t}\n\t\twhile (test == 1);\n\t\tTIFFClose(tif);\n\t}\n\tif (resolutionUnit == RESUNIT_INCH)\n\t{\n\t\tm_image.setDotsPerMeterX ((int) (xres / 0.0254));\n\t\tm_image.setDotsPerMeterY ((int) (yres / 0.0254));\n\t\tm_imageInfoRecord.xres = qRound(xres);\n\t\tm_imageInfoRecord.yres = qRound(yres);\n\t}\n\telse if (resolutionUnit == RESUNIT_CENTIMETER)\n\t{\n\t\tm_image.setDotsPerMeterX ((int) (xres * 100.0));\n\t\tm_image.setDotsPerMeterY ((int) (yres * 100.0));\n\t\tm_imageInfoRecord.xres = qRound(xres*2.54);\n\t\tm_imageInfoRecord.yres = qRound(yres*2.54);\n\t}\n\tif (isCMYK)\n\t{\n\t\tm_imageInfoRecord.colorspace = ColorSpaceCMYK;\n\t\tm_pixelFormat = (r_image.channels() == 5) ? Format_CMYKA_8 : Format_CMYK_8;\n\t}\n\telse if (m_samplesPerPixel == 1)\n\t{\n\t\t// Do not set m_pixelFormat here as the real pixel format is most probably different than gray\n\t\tif (bitsPerSample == 1)\n\t\t\tm_imageInfoRecord.colorspace = ColorSpaceMonochrome;\n\t\telse\n\t\t\tm_imageInfoRecord.colorspace = ColorSpaceGray;\n\t}\n\telse\n\t{\n\t\tm_imageInfoRecord.colorspace = ColorSpaceRGB;\n\t\tm_pixelFormat = Format_RGBA_8;\n\t}\n\tm_imageInfoRecord.BBoxX = 0;\n\tm_imageInfoRecord.BBoxH = r_image.height();\n\tm_imageInfoRecord.valid = !(m_imageInfoRecord.layerInfo.isEmpty() && m_imageInfoRecord.PDSpathData.isEmpty());\n\treturn true;\n}",
    "void GeoImageGeoTiff::_initTimeVector(TIFF *tif, const vector<double> &times)\n{\n    _times = times;\n    _tiffTimes.clear();\n\n    // Check if the first time step (tiff \"directory\" has a time stamp.\n    // If it does all directories must have a time stamp. If no time\n    // stamp is present then the time stamp is taken from the data itself.\n    //\n    TIFFSetDirectory(tif, 0);\n\n    char *timePtr = NULL;\n    bool  hasTime = TIFFGetField(tif, TIFFTAG_DATETIME, &timePtr);\n\n    // build a list of the times in the tiff\n    //\n    UDUnits udunits;\n    udunits.Initialize();\n\n    do {\n        int dircount = 0;\n\n        if (hasTime) {\n            double tifftime = 0.0;\n            bool   ok = _getTiffTime(tif, &udunits, tifftime);\n            if (!ok) {\n                SetDiagMsg(\"Failed to read time stamp from TIFF image\");\n                break;\n            }\n            _tiffTimes.push_back(tifftime);\n        } else {\n            if (dircount < _times.size()) _tiffTimes.push_back(_times[dircount]);\n        }\n\n        dircount++;\n    } while (TIFFReadDirectory(tif));\n\n    return;\n}",
    "void TIFF::construct_ifds()\n{\n    PROF_SCOPED_RANGE(PROF_EVENT(tiff_construct_ifds));\n    ifd_offsets_.clear();\n    ifd_offsets_.reserve(DEFAULT_IFD_SIZE);\n    ifds_.clear();\n    ifds_.reserve(DEFAULT_IFD_SIZE);\n\n    uint16_t ifd_index = 0;\n    do\n    {\n        uint64_t offset = TIFFCurrentDirOffset(tiff_client_);\n        ifd_offsets_.push_back(offset);\n\n        auto ifd = std::make_shared<cuslide::tiff::IFD>(this, ifd_index, offset);\n        ifds_.emplace_back(std::move(ifd));\n        ++ifd_index;\n    } while (TIFFReadDirectory(tiff_client_));\n\n    // Set index for each level\n    level_to_ifd_idx_.reserve(ifd_index);\n    for (size_t index = 0; index < ifd_index; ++index)\n    {\n        level_to_ifd_idx_.emplace_back(index);\n    }\n\n    // Resolve format and fix `level_to_ifds_idx_`\n    resolve_vendor_format();\n\n    // Sort index by resolution (the largest resolution is index 0)\n    std::sort(level_to_ifd_idx_.begin(), level_to_ifd_idx_.end(), [this](const size_t& a, const size_t& b) {\n        uint32_t width_a = this->ifds_[a]->width();\n        uint32_t width_b = this->ifds_[b]->width();\n        if (width_a > width_b)\n        {\n            return true;\n        }\n        else if (width_a < width_b)\n        {\n            return false;\n        }\n        else\n        {\n            uint32_t height_a = this->ifds_[a]->height();\n            uint32_t height_b = this->ifds_[b]->height();\n            return height_a > height_b;\n        }\n    });\n}",
    "uint32_t getNumLayers(std::string const& path) {\n  auto* data = TIFFOpen(path.c_str(), \"r\");\n\n  if (!data) {\n    std::cerr << \"Failed to open TIFF file'\" << path << \"' \" << std::endl;\n    return 0;\n  }\n\n  uint32_t numLayers = 0;\n\n  do {\n    numLayers++;\n  } while (TIFFReadDirectory(data));\n\n  TIFFClose(data);\n\n  return numLayers;\n}",
    "int main(int argc, char **argv) {\n\n\tint devId = 0;\n\n\tchar *fname = NULL;\n\n\tint verbose = 0;\n\tint decWriteOutN = 0;\n\n\tint frameBeg = INT_MIN;\n\tint frameEnd = INT_MAX;\n\tint decodeRange = 0;\n\tint doEncode = 0;\n\tint encWriteOut = 0;\n\n\tint och;\n\twhile(1) {\n\t\tint option_index = 0;\n\t\tstatic struct option long_options[] = {\n\t\t\t{      \"file\", required_argument, 0, 'f'},\n\t\t\t{    \"device\", required_argument, 0, 'd'},\n\t\t\t{\"decode-out\", optional_argument, 0,   1},\n\t\t\t{ \"frame-beg\", required_argument, 0, 'b'},\n\t\t\t{ \"frame-end\", required_argument, 0, 'e'},\n\t\t\t{   \"memtype\", required_argument, 0, 'm'},\n\t\t\t{   \"copyh2d\", required_argument, 0, 'c'},\n\t\t\t{   \"verbose\",       no_argument, 0, 'v'},\n\t\t\t{    \"encode\",       no_argument, 0, 'E'},\n\t\t\t{\"rowsxstrip\", required_argument, 0, 'r'},\n\t\t\t{\"stripalloc\", required_argument, 0, 's'},\n\t\t\t{\"encode-out\", optional_argument, 0,   2},\n\t\t\t{      \"help\",       no_argument, 0, 'h'},\n\t\t\t{           0,                 0, 0,   0}\n\t\t};\n\n\t\toch = getopt_long(argc, argv, \"f:d:vo::hb:e:m:cEr:s:\", long_options, &option_index);\n\t\tif (och == -1) break;\n\t\tswitch (och) {\n\t\t\tcase   0:// handles long opts with non-NULL flag field\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\tdevId = atoi(optarg);\n\t\t\t\tbreak;\n\t\t\tcase 'f':\n\t\t\t\tfname = strdup(optarg);\n\t\t\t\tbreak;\n\t\t\tcase 'b':\n\t\t\t\tframeBeg = atoi(optarg);\n\t\t\t\tdecodeRange = 1;\n\t\t\t\tbreak;\n\t\t\tcase 'e':\n\t\t\t\tframeEnd = atoi(optarg);\n\t\t\t\tdecodeRange = 1;\n\t\t\t\tbreak;\n\t\t\tcase 'v':\n\t\t\t\tverbose++;\n\t\t\t\tbreak;\n\t\t\tcase   1:\n\t\t\t\tdecWriteOutN = 1;\n\t\t\t\tif(!optarg                 &&\n\t\t\t\t   argv[optind]    != NULL &&\n\t\t\t\t   argv[optind][0] != '-') {\n\n\t\t\t\t\tdecWriteOutN = atoi(argv[optind++]);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'E':\n\t\t\t\tdoEncode = 1;\n\t\t\t\tbreak;\n\t\t\tcase   2:\n\t\t\t\tencWriteOut = 1;\n\t\t\t\tbreak;\n\t\t\tcase 'h':\n\t\t\tcase '?':\n\t\t\t\tusage(argv[0]);\n\t\t\tdefault:\n\t\t\t\tfprintf(stderr, \"unknown option: %c\\n\", och);\n\t\t\t\tusage(argv[0]);\n\t\t}\n\t}\n\n\tif (!fname) {\n\t\tfprintf(stderr, \"Please specify a TIFF file with the -f option!\\n\");\n\t\tusage(argv[0]);\n\t}\n\n\tif (frameBeg > frameEnd) {\n\t\tfprintf(stderr, \"Invalid frame range!\\n\");\n\t\tusage(argv[0]);\n\t}\n\n\tCHECK_CUDA(cudaSetDevice(devId));\n\n\tcudaDeviceProp props;\n\n\tprintf(\"\\nUsing GPU:\\n\");\n\tCHECK_CUDA(cudaGetDeviceProperties(&props, devId));\n\tprintf(\"\\t%2d (%s, %d SMs, %d th/SM max, CC %d.%d, ECC %s)\\n\",\n\t\t\tdevId, props.name, props.multiProcessorCount,\n\t\t\tprops.maxThreadsPerMultiProcessor,\n\t\t\tprops.major, props.minor,\n\t\t\tprops.ECCEnabled?\"on\":\"off\");\n\tprintf(\"\\n\");\n\n\t// dummy allocation to initialize subsystems\n\tunsigned char *dummy;\n\tCHECK_CUDA(cudaMalloc(&dummy, 1024*1024*10));\n\tCHECK_CUDA(cudaFree(dummy));\n\n\tcudaStream_t stream;\n\tCHECK_CUDA(cudaStreamCreate(&stream));\n\n\n\tnvtiffStream_t tiff_stream;\n\tnvtiffDecoder_t decoder;\n    CHECK_NVTIFF(nvtiffStreamCreate(&tiff_stream));\n\tCHECK_NVTIFF(nvtiffDecoderCreate(&decoder,\n        nullptr, nullptr, 0));\n\n    CHECK_NVTIFF(nvtiffStreamParseFromFile(fname, tiff_stream));\n\n\tuint32_t num_images = 0;\n    CHECK_NVTIFF(nvtiffStreamGetNumImages(tiff_stream, &num_images));\n\tstd::vector<nvtiffImageInfo_t> image_info(num_images);\n    std::vector<uint8_t*> nvtiff_out(num_images);\n    std::vector<size_t> nvtiff_out_size(num_images);\n    \n\t// BEGIN work (possibly) overlapped with H2D copy of the file data\n\tif (verbose) {\n\t\tCHECK_NVTIFF(nvtiffStreamPrint(tiff_stream));\n\t}\n\t\n\tframeBeg = fmax(frameBeg, 0);\n\tframeEnd = fmin(frameEnd, num_images-1);\n\tconst int nDecode = frameEnd-frameBeg+1;\n\n\tfor (uint32_t image_id = 0; image_id < num_images; image_id++) {\n        CHECK_NVTIFF(nvtiffStreamGetImageInfo(tiff_stream, image_id, &image_info[image_id]));\n        nvtiff_out_size[image_id] = DIV_UP((size_t)image_info[image_id].bits_per_pixel * image_info[image_id].image_width, 8) *\n                                    (size_t)image_info[image_id].image_height;\n        if (image_info[image_id].photometric_int == NVTIFF_PHOTOMETRIC_PALETTE) {\n            nvtiff_out_size[image_id] = image_info[image_id].image_width * image_info[image_id].image_height * 3 * sizeof(uint16_t);\n        }\n        CHECK_CUDA(cudaMalloc(&nvtiff_out[image_id], nvtiff_out_size[image_id]));\n    }\n\n\tprintf(\"Decoding %u, images [%d, %d], from file %s... \",\n\t\tnDecode,\n\t\tframeBeg,\n\t\tframeEnd,\n\t\tfname);\n\tfflush(stdout);\n\n\n\tauto decode_start = perfclock::now();\n\tif (!decodeRange) {\n\t\tCHECK_NVTIFF(nvtiffDecode(tiff_stream, decoder, nvtiff_out.data(), stream));\n\t} else { \n\t\tCHECK_NVTIFF(nvtiffDecodeRange(tiff_stream, decoder, frameBeg, nDecode, nvtiff_out.data(), stream));\n\t}\n\tCHECK_CUDA(cudaStreamSynchronize(stream));\n\tauto decode_end = perfclock::now();\n    double decode_time = std::chrono::duration<float>(decode_end - decode_start).count();\n\n\tprintf(\"done in %lf secs\\n\\n\", decode_time);\n\n\tif (decWriteOutN) {\n        const uint32_t nout = std::min(decWriteOutN, nDecode);\n\n        printf(\"Writing images for the first %d subfile(s)...\\n\", nout);\n        fflush(stdout);\n\n        for (uint32_t image_id = 0; image_id < nout; image_id++) {\n            auto& info = image_info[image_id];\n            std::vector<uint8_t> imageOut_h(nvtiff_out_size[image_id]);\n            CHECK_CUDA(cudaMemcpy(imageOut_h.data(), nvtiff_out[image_id], nvtiff_out_size[image_id], cudaMemcpyDeviceToHost));\n            write_image(fname, info, imageOut_h.data(), image_id);\n        }\n    }\n\n#ifdef LIBTIFF_TEST\n\tTIFF* tif = TIFFOpen(fname, \"r\");\n\tif (tif) {\n\n\t\t// we alredy know that all subfiles have the same porperties\n\t\tuint32_t *raster;\n\t\traster = (uint32_t *)_TIFFmalloc(tiffData->subFiles[0].ncol*tiffData->subFiles[0].nrow * sizeof (uint32_t));\n\n\t\tprintf(\"\\tDecoding with libTIFF... \"); fflush(stdout);\n\t\tauto decode_start = perfclock::now();\n\t\tfor(int i = 0; i < tiffData->nSubFiles; i++) {\n\t\t\tif (!TIFFReadRGBAImage(tif,\n\t\t\t\t\t       tiffData->subFiles[i].ncol,\n\t\t\t\t\t       tiffData->subFiles[i].nrow,\n\t\t\t\t\t       raster, 0)) {\n\t\t\t\tfprintf(stderr, \"Error while decoding image %d with libTiff\\n\", i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tTIFFReadDirectory(tif);\n\t\t}\n\t\tauto decode_end = perfclock::now();\n\t\tdouble decode_time = std::chrono::duration<float>(decode_end - decode_start).count();\n\t\tprintf(\"done in %lf secs\\n\\n\", decode_time);\n\n\t\t_TIFFfree(raster);\n\t\tTIFFClose(tif);\n\t}\n#endif\n\tbool identical_multi_tiff = check_identical(image_info.data(), num_images);\n\tif(!identical_multi_tiff && doEncode){\n\t\tprintf(\"Encoding will be skipped since the images within the tiff file do not have identical properties...\\n\");\n\t}\n\t// TODO check identical\n\tif (doEncode && identical_multi_tiff) {\n\n\t\tunsigned int nrow              = image_info[0].image_height;\n\t\tunsigned int ncol              = image_info[0].image_width;\n\t\tunsigned int photometricInt    = (unsigned int)image_info[0].photometric_int;\n\t\tunsigned int planarConf        = (unsigned int)image_info[0].planar_config;\n\t\tunsigned short pixelSize       = image_info[0].bits_per_pixel/8;\n\t\tunsigned short samplesPerPixel = image_info[0].samples_per_pixel;\n\t\tunsigned short sampleFormat    = image_info[0].sample_format[0];\n\n\t\tunsigned short *bitsPerSample = (unsigned short *)malloc(sizeof(*bitsPerSample)*samplesPerPixel);\n\t\tmemcpy(bitsPerSample,\n\t\t\timage_info[0].bits_per_sample,\n\t\t       sizeof(*bitsPerSample)*samplesPerPixel);\n\n\t\tCHECK_NVTIFF(nvtiffStreamDestroy(tiff_stream));\n        CHECK_NVTIFF(nvtiffDecoderDestroy(decoder, stream));\n\t\ttiff_stream = NULL;\n\t\tdecoder = NULL;\n\n\t\tunsigned int nSubFiles = nDecode;\n\n\t\tprintf(\"Encoding %u, %s %ux%u images ... \",\n\t\t\tnDecode, image_info[0].photometric_int == 2 ? \"RGB\" : \"Grayscale\",\n\t\t\timage_info[0].image_width, image_info[0].image_height);\n\t\tfflush(stdout);\n\n        auto enc_start = perfclock::now();\n\n\t\tnvtiffEncoder_t encoder;\n\t\tCHECK_NVTIFF(nvtiffEncoderCreate(&encoder, nullptr, nullptr, stream));\n\t\tnvtiffEncodeParams_t params;\n\t\tCHECK_NVTIFF(nvtiffEncodeParamsCreate(&params));\n\t\tCHECK_NVTIFF(nvtiffEncodeParamsSetImageInfo(params, &image_info[0]));\n\t\tCHECK_NVTIFF(nvtiffEncodeParamsSetInputs(params, nvtiff_out.data(), nSubFiles));\n\t\tCHECK_NVTIFF(nvtiffEncode(encoder, &params, 1, stream));\n\t\tCHECK_NVTIFF(nvtiffEncodeFinalize(encoder, &params, 1, stream));\n\n\t\tCHECK_CUDA(cudaStreamSynchronize(stream));\n\t\tauto enc_end = perfclock::now();\n\t\tdouble enc_time = std::chrono::duration<float>(enc_end - enc_start).count();\n\n\t    size_t stripSizeTotal = 0;\n        size_t metadataSize = 0;\n\t\tCHECK_NVTIFF(nvtiffGetBitstreamSize(encoder, &params, 1, &metadataSize, &stripSizeTotal));\n\t\tprintf(\"done in %lf secs (compr. ratio: %.2lfx)\\n\\n\",\n\t\t\t\tenc_time, double(nvtiff_out_size[0])*nSubFiles/stripSizeTotal);\n\n\t\tif (encWriteOut) {\n\t\t\tprintf(\"\\tWriting %u compressed images to TIFF file... \", nDecode); fflush(stdout);\n\t\t\tauto write_start = perfclock::now();\n\t\t\tCHECK_NVTIFF(nvtiffWriteTiffFile(encoder, &params, 1, \"outFile.tif\", stream));\n\t\t\tauto write_end = perfclock::now();\n\t\t\tdouble write_time = std::chrono::duration<float>(write_end - write_start).count();\n\t\t\tprintf(\"done in %lf secs\\n\\n\", write_time);\n\n\t\t}\n        CHECK_NVTIFF(nvtiffEncodeParamsDestroy(params, stream));\n\t\tCHECK_NVTIFF(nvtiffEncoderDestroy(encoder, stream));\n\n#ifdef LIBTIFF_TEST\n\t\ttif = TIFFOpen(\"libTiffOut.tif\", \"w\");\n\t\tif (tif) {\n\n\t\t\tunsigned char **imageOut_h = (unsigned char **)Malloc(sizeof(*imageOut_h)*nDecode);\n\t\t\tfor(unsigned int i = 0; i < nDecode; i++) {\n\t\t\t\timageOut_h[i] = (unsigned char *)Malloc(sizeof(*imageOut_h)*imageSize);\n\t\t\t\tCHECK_CUDA(cudaMemcpy(imageOut_h[i],\n\t\t\t\t\t\t\timageOut_d[i],\n\t\t\t\t\t\t\timageSize,\n\t\t\t\t\t\t\tcudaMemcpyDeviceToHost));\n\t\t\t}\n\n\t\t\tsize_t stripSize = sizeof(**imageOut_h)*encRowsPerStrip*ncol*pixelSize;\n\n\t\t\tprintf(\"\\tEncoding with libTIFF... \"); fflush(stdout);\n\t\t\t__t = Wtime();\n\t\t\tfor(unsigned int i = 0; i < nDecode; i++) {\n\n\t\t\t\tTIFFSetField(tif, TIFFTAG_IMAGEWIDTH, nrow);\n\t\t\t\tTIFFSetField(tif, TIFFTAG_IMAGELENGTH, ncol);\n\t\t\t\tTIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8);\n\t\t\t\tTIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_LZW);\n\t\t\t\tTIFFSetField(tif, TIFFTAG_PHOTOMETRIC, photometricInt);\n\t\t\t\tTIFFSetField(tif, TIFFTAG_FILLORDER, 1);\n\t\t\t\tTIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, samplesPerPixel);\n\t\t\t\tTIFFSetField(tif, TIFFTAG_PLANARCONFIG, planarConf);\n\t\t\t\tTIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, encRowsPerStrip);\n\n\t\t\t\tfor(unsigned int j = 0; j < nStripOut; j++) {\n\n\t\t\t\t\tunsigned int currStripSize = stripSize;\n\t\t\t\t\tif (j == nStripOut-1) {\n\t\t\t\t\t\tcurrStripSize = imageSize - j*stripSize;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (-1 == TIFFWriteEncodedStrip(tif,\n\t\t\t\t\t\t\t\tj,\n\t\t\t\t\t\t\t\timageOut_h[i]+j*stripSize,\n\t\t\t\t\t\t\t\tcurrStripSize)) {\n\n\t\t\t\t\t\tfprintf(stderr, \"Error while encoding image %d with libTiff\\n\", i);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// need to find a way to have libTiff to encode in \n\t\t\t\t// memory without writing to disk the last direnctory\n\t\t\t\t// after each TIFFWriteDirectory() call\n\t\t\t\tTIFFWriteDirectory(tif);\n\t\t\t\t//TIFFRewriteDirectory(tif);\n\t\t\t}\n\t\t\t__t = Wtime()-__t;\n\t\t\tprintf(\"done in %lf secs\\n\\n\", __t);\n\n\t\t\tTIFFClose(tif);\n\t\t}\n#endif\n\t}\n\n\t// cleanup\n\tfor(unsigned int i = 0; i < nDecode; i++) {\n\t\tCHECK_CUDA(cudaFree(nvtiff_out[i]));\n\t}\n\n\tfree(fname);\n\t\n\tif(tiff_stream)\t{\n\t\tCHECK_NVTIFF(nvtiffStreamDestroy(tiff_stream));\n\t}\n    \n\tif(decoder){\n\t    CHECK_NVTIFF(nvtiffDecoderDestroy(decoder, stream));\n\t }\n\t\n\tCHECK_CUDA(cudaStreamDestroy(stream));\n\n\tCHECK_CUDA(cudaDeviceReset());\n\n\treturn 0;\n}",
    "int main(int argc, char *argv[])\n{\n    uint16_t             defconfig = (uint16_t)-1;\n    uint16_t             deffillorder = 0;\n    uint32_t             deftilewidth = (uint32_t)-1;\n    uint32_t             deftilelength = (uint32_t)-1;\n    uint32_t             defrowsperstrip = (uint32_t)-1;\n    uint32_t             diroff = 0;\n    TIFF *             in;\n    TIFF *             out;\n    const char *       mode = \"w\";\n    int                c;\n    extern int         optind;\n    extern const char *myoptarg;\n\n    while ((c = getopt(argc, argv, \"c:f:l:m:M:n:o:p:r:w:e:g:4:aistd\")) != -1) switch (c) {\n        case 'a': /* append to output */ mode = \"a\"; break;\n        case 'd': /* down cast 8bit to 4bit */ convert_8_to_4 = 1; break;\n        case 'c': /* compression scheme */\n            if (!processCompressOptions(myoptarg)) usage();\n            break;\n        case 'e': worldfile = myoptarg; break;\n        case 'f': /* fill order */\n            if (streq(myoptarg, \"lsb2msb\"))\n                deffillorder = FILLORDER_LSB2MSB;\n            else if (streq(myoptarg, \"msb2lsb\"))\n                deffillorder = FILLORDER_MSB2LSB;\n            else\n                usage();\n            break;\n        case 'i': /* ignore errors */ ignore = TRUE; break;\n        case 'g': /* GeoTIFF metadata file */ geofile = myoptarg; break;\n        case 'm': /*multiple times and latlon extents file */\n            timeLonLatName = myoptarg;\n            timeLonLatFile = fopen(timeLonLatName, \"r\");\n            if (!timeLonLatFile) {\n                fprintf(stderr, \"Failure to open %s\\n\", timeLonLatName);\n                exit(-1);\n            }\n            break;\n        case 'M': /*multiple timestamps file */\n            timeName = myoptarg;\n            timeFile = fopen(timeName, \"r\");\n            if (!timeFile) {\n                fprintf(stderr, \"Failure to open %s\\n\", timeName);\n                exit(-1);\n            }\n            break;\n        case 'n': /* single latlong extents, requires option 4 */\n        {\n            int retval = sscanf(myoptarg, \"%f %f %f %f\", lonLatExts, lonLatExts + 1, lonLatExts + 2, lonLatExts + 3);\n            if (retval != 4) {\n                fprintf(stderr, \"Four lon/lat extent values required\\n\");\n                exit(-1);\n            }\n        } break;\n\n        case '4': proj4_string = myoptarg; break;\n        case 'l': /* tile length */\n            outtiled = TRUE;\n            deftilelength = atoi(myoptarg);\n            break;\n        case 'o': /* initial directory offset */ diroff = strtoul(myoptarg, NULL, 0); break;\n        case 'p': /* planar configuration */\n            if (streq(myoptarg, \"separate\"))\n                defconfig = PLANARCONFIG_SEPARATE;\n            else if (streq(myoptarg, \"contig\"))\n                defconfig = PLANARCONFIG_CONTIG;\n            else\n                usage();\n            break;\n        case 'r': /* rows/strip */ defrowsperstrip = atoi(myoptarg); break;\n        case 's': /* generate stripped output */ outtiled = FALSE; break;\n        case 't': /* generate tiled output */ outtiled = TRUE; break;\n        case 'w': /* tile width */\n            outtiled = TRUE;\n            deftilewidth = atoi(myoptarg);\n            break;\n        case '?':\n            usage();\n            /*NOTREACHED*/\n        }\n    if (argc - optind < 2) usage();\n    out = TIFFOpen(argv[argc - 1], mode);\n    if (out == NULL) return (-2);\n    for (; optind < argc - 1; optind++) {\n        in = TIFFOpen(argv[optind], \"r\");\n        if (in == NULL) return (-3);\n        if (diroff != 0 && !TIFFSetSubDirectory(in, diroff)) {\n            TIFFError(TIFFFileName(in), \"Error, setting subdirectory at %#x\", diroff);\n            (void)TIFFClose(out);\n            return (1);\n        }\n        do {\n            config = defconfig;\n            compression = defcompression;\n            predictor = defpredictor;\n            fillorder = deffillorder;\n            rowsperstrip = defrowsperstrip;\n            tilewidth = deftilewidth;\n            tilelength = deftilelength;\n            g3opts = defg3opts;\n            if (!tiffcp(in, out) || !TIFFWriteDirectory(out)) {\n                (void)TIFFClose(out);\n                return (1);\n            }\n        } while (TIFFReadDirectory(in));\n        (void)TIFFClose(in);\n    }\n    (void)TIFFClose(out);\n    return (0);\n}",
    "bool DkBasicLoader::loadTIFF(const QString &, QImage &, QSharedPointer<QByteArray>) const\n{\n    qWarning() << \"built-in TIFF loader is not included in this build and may be able to load this file\";\n#else\nbool DkBasicLoader::loadTIFF(const QString &filePath, QImage &img, QSharedPointer<QByteArray> ba) const\n{\n    bool success = false;\n\n    // first turn off nasty warning/error dialogs - (we do the GUI : )\n    TIFFErrorHandler oldErrorHandler, oldWarningHandler;\n    oldWarningHandler = TIFFSetWarningHandler(NULL);\n    oldErrorHandler = TIFFSetErrorHandler(NULL);\n\n    DkTimer dt;\n    TIFF *tiff = 0;\n\n// TODO: currently TIFFStreamOpen can only be linked on Windows?!\n#if defined(Q_OS_WIN)\n\n    std::istringstream is(ba ? ba->toStdString() : \"\");\n\n    if (ba)\n        tiff = TIFFStreamOpen(\"MemTIFF\", &is);\n\n    // fallback to direct loading\n    if (!tiff)\n        tiff = TIFFOpen(filePath.toLatin1(), \"r\");\n\n    // FIXME: we could load without buffer if toLatin1()=>toUtf8() and on\n    // windows use wchar_t* version of TIFFOpen();\n\n    // loading from buffer allows us to load files with non-latin names\n    QSharedPointer<QByteArray> bal;\n    if (!tiff)\n        bal = loadFileToBuffer(filePath);\n\n    std::istringstream isl(bal ? bal->toStdString() : \"\");\n\n    if (bal)\n        tiff = TIFFStreamOpen(\"MemTIFF\", &isl);\n#else\n    tiff = TIFFOpen(filePath.toLatin1(), \"r\");\n#endif\n\n    if (!tiff)\n        return success;\n\n    uint32_t width = 0;\n    uint32_t height = 0;\n\n    TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, &width);\n    TIFFGetField(tiff, TIFFTAG_IMAGELENGTH, &height);\n\n    // init the qImage\n    img = QImage(width, height, QImage::Format_ARGB32);\n\n    const int stopOnError = 1;\n    success = TIFFReadRGBAImageOriented(tiff, width, height, reinterpret_cast<uint32_t *>(img.bits()), ORIENTATION_TOPLEFT, stopOnError) != 0;\n\n    if (success) {\n        for (uint32_t y = 0; y < height; ++y)\n            convert32BitOrder(img.scanLine(y), width);\n    }\n\n    TIFFClose(tiff);\n\n    TIFFSetWarningHandler(oldWarningHandler);\n    TIFFSetWarningHandler(oldErrorHandler);\n\n    return success;\n\n#endif // !WITH_LIBTIFF\n    return false;\n}\n\n#define DRIF_IMAGE_IMPL\n#include \"drif_image.h\"\n\nbool isQtFmtCompatible(uint32_t f)\n{\n    switch (f) {\n    case DRIF_FMT_RGB888:\n    case DRIF_FMT_RGBA8888:\n    case DRIF_FMT_GRAY:\n        return true;\n    }\n\n    return false;\n}\n\nuint32_t drif2qtfmt(uint32_t f)\n{\n    switch (f) {\n    case DRIF_FMT_RGB888:\n        return QImage::Format_RGB888;\n    case DRIF_FMT_RGBA8888:\n        return QImage::Format_RGBA8888;\n    case DRIF_FMT_GRAY:\n        return QImage::Format_Grayscale8;\n    }\n\n    return QImage::Format_Invalid;\n}\n\nbool DkBasicLoader::loadDRIF(const QString &filePath, QImage &img, QSharedPointer<QByteArray> ba) const\n{\n    bool success = false;\n\n    uint32_t w;\n    uint32_t h;\n    uint32_t f;\n\n    uint8_t *imgBytes = drifLoadImg(filePath.toLatin1(), &w, &h, &f);\n\n    if (!imgBytes)\n        return success;\n\n    if (isQtFmtCompatible(f)) {\n        img = QImage((int)w, (int)h, (QImage::Format)drif2qtfmt(f));\n        memcpy(reinterpret_cast<void *>(img.bits()), imgBytes, drifGetSize(w, h, f));\n\n        success = true;\n    }\n#ifdef WITH_OPENCV\n    else {\n        img = QImage((int)w, (int)h, QImage::Format_RGB888);\n\n        switch (f) {\n        case DRIF_FMT_BGR888: {\n            cv::Mat imgMat = cv::Mat((int)h, (int)w, CV_8UC3, imgBytes);\n            cv::Mat rgbMat = cv::Mat((int)h, (int)w, CV_8UC3, reinterpret_cast<uint8_t *>(img.bits()));\n            cv::cvtColor(imgMat, rgbMat, CV_BGR2RGB);\n\n            success = true;\n        } break;\n\n        case DRIF_FMT_RGB888P:\n        case DRIF_FMT_RGBA8888P: {\n            cv::Mat imgMatR = cv::Mat((int)h, (int)w, CV_8UC1, imgBytes);\n            cv::Mat imgMatG = cv::Mat((int)h, (int)w, CV_8UC1, imgBytes + w * h);\n            cv::Mat imgMatB = cv::Mat((int)h, (int)w, CV_8UC1, imgBytes + 2 * w * h);\n            cv::Mat rgbMat = cv::Mat((int)h, (int)w, CV_8UC3, reinterpret_cast<uint8_t *>(img.bits()));\n\n            std::vector<cv::Mat> imgMat{imgMatR, imgMatG, imgMatB};\n            cv::merge(imgMat, rgbMat);\n\n            success = true;\n        } break;\n\n        case DRIF_FMT_BGR888P:\n        case DRIF_FMT_BGRA8888P: {\n            cv::Mat imgMatB = cv::Mat((int)h, (int)w, CV_8UC1, imgBytes);\n            cv::Mat imgMatG = cv::Mat((int)h, (int)w, CV_8UC1, imgBytes + w * h);\n            cv::Mat imgMatR = cv::Mat((int)h, (int)w, CV_8UC1, imgBytes + 2 * w * h);\n            cv::Mat rgbMat = cv::Mat((int)h, (int)w, CV_8UC3, reinterpret_cast<uint8_t *>(img.bits()));\n\n            std::vector<cv::Mat> imgMat{imgMatR, imgMatG, imgMatB};\n            cv::merge(imgMat, rgbMat);\n\n            success = true;\n        } break;\n\n        case DRIF_FMT_BGRA8888: {\n            cv::Mat imgMat = cv::Mat((int)h, (int)w, CV_8UC4, imgBytes);\n            cv::Mat rgbMat = cv::Mat((int)h, (int)w, CV_8UC3, reinterpret_cast<uint8_t *>(img.bits()));\n            cv::cvtColor(imgMat, rgbMat, CV_BGR2RGB, 3);\n\n            success = true;\n        } break;\n\n        case DRIF_FMT_RGBA8888: {\n            cv::Mat imgMat = cv::Mat((int)h, (int)w, CV_8UC4, imgBytes);\n            cv::Mat rgbMat = cv::Mat((int)h, (int)w, CV_8UC3, reinterpret_cast<uint8_t *>(img.bits()));\n            cv::cvtColor(imgMat, rgbMat, CV_RGBA2RGB, 3);\n\n            success = true;\n        } break;\n\n        case DRIF_FMT_GRAY: {\n            cv::Mat imgMat = cv::Mat((int)h, (int)w, CV_8UC1, imgBytes);\n            cv::Mat rgbMat = cv::Mat((int)h, (int)w, CV_8UC3, reinterpret_cast<uint8_t *>(img.bits()));\n            cv::cvtColor(imgMat, rgbMat, CV_GRAY2RGB);\n\n            success = true;\n        } break;\n\n        case DRIF_FMT_YUV420P: {\n            cv::Mat imgMat = cv::Mat((int)h + h / 2, (int)w, CV_8UC1, imgBytes);\n            cv::Mat rgbMat = cv::Mat((int)h, (int)w, CV_8UC3, reinterpret_cast<uint8_t *>(img.bits()));\n            cv::cvtColor(imgMat, rgbMat, CV_YUV2RGB_I420);\n\n            success = true;\n        } break;\n\n        case DRIF_FMT_YVU420P: {\n            cv::Mat imgMat = cv::Mat((int)h + h / 2, (int)w, CV_8UC1, imgBytes);\n            cv::Mat rgbMat = cv::Mat((int)h, (int)w, CV_8UC3, reinterpret_cast<uint8_t *>(img.bits()));\n            cv::cvtColor(imgMat, rgbMat, CV_YUV2RGB_YV12);\n\n            success = true;\n        } break;\n\n        case DRIF_FMT_NV12: {\n            cv::Mat imgMat = cv::Mat((int)h + h / 2, (int)w, CV_8UC1, imgBytes);\n            cv::Mat rgbMat = cv::Mat((int)h, (int)w, CV_8UC3, reinterpret_cast<uint8_t *>(img.bits()));\n            cv::cvtColor(imgMat, rgbMat, CV_YUV2RGB_NV12);\n\n            success = true;\n        } break;\n\n        case DRIF_FMT_NV21: {\n            cv::Mat imgMat = cv::Mat((int)h + h / 2, (int)w, CV_8UC1, imgBytes);\n            cv::Mat rgbMat = cv::Mat((int)h, (int)w, CV_8UC3, reinterpret_cast<uint8_t *>(img.bits()));\n            cv::cvtColor(imgMat, rgbMat, CV_YUV2RGB_NV21);\n\n            success = true;\n        } break;\n\n        default:\n            success = false;\n            break;\n        }\n    }\n#endif\n\n    drifFreeImg(imgBytes);\n\n    return success;\n}\n\nvoid DkBasicLoader::setImage(const QImage &img, const QString &editName, const QString &file)\n{\n    mFile = file;\n    setEditImage(img, editName);\n}\n\nvoid DkBasicLoader::pruneEditHistory()\n{\n    // delete all hidden edit states\n    for (int idx = mImages.size() - 1; idx > mImageIndex; idx--) {\n        mImages.pop_back();\n    }\n}\n\nvoid DkBasicLoader::setEditImage(const QImage &img, const QString &editName)\n{\n    if (img.isNull())\n        return;\n\n    // delete all hidden edit states\n    pruneEditHistory();\n\n    // compute new history size\n    int historySize = 0;\n    for (const DkEditImage &e : mImages) {\n        historySize += e.size();\n    }\n\n    // reset exif orientation after image edit\n    if (!mImages.isEmpty())\n        mMetaData->clearOrientation();\n    // new history item with new pixmap (and old or original metadata)\n    DkEditImage newImg(img, mMetaData->copy(), editName); // new image, old/unchanged metadata\n\n    if (historySize + newImg.size() > DkSettingsManager::param().resources().historyMemory && mImages.size() > mMinHistorySize) {\n        mImages.removeAt(1);\n        qWarning() << \"removing history image because it's too large:\" << historySize + newImg.size() << \"MB\";\n    }\n\n    mImages.append(newImg);\n    mImageIndex = mImages.size() - 1; // set the index again to the last\n}\n\nvoid DkBasicLoader::setEditMetaData(const QSharedPointer<DkMetaDataT> &metaData, const QImage &img, const QString &editName)\n{\n    // delete all hidden edit states\n    pruneEditHistory();\n\n    // not removing second history item if oversized (see setEditImage())\n\n    // new history item with new metadata (and image, but hasNewImage() will be false)\n    DkEditImage newImg(metaData->copy(), img, editName); // new metadata, old/unchanged image\n\n    mImages.append(newImg);\n    mImageIndex = mImages.size() - 1; // set the index again to the last\n}\n\nvoid DkBasicLoader::setEditMetaData(const QSharedPointer<DkMetaDataT> &metaData, const QString &editName)\n{\n    // Add history edit with new metadata (hasMetaData()), copying last or original image\n    QImage lastImg = image(); // copy last edit of pixmap (if any) to new history item\n    setEditMetaData(metaData, lastImg, editName);\n}\n\nvoid DkBasicLoader::setEditMetaData(const QString &editName)\n{\n    // Add history edit with edited metadata (hasMetaData()), copying last or original image\n    setEditMetaData(mMetaData, image(), editName);\n}\n\nQImage DkBasicLoader::lastImage() const\n{\n    // Find and return the last/current version of the image (ready to be saved to disk)\n    // This is initially the first item (the original image) or the last one,\n    // excluding history items with images that only have modified metadata,\n    // for example, after rotating there'd be a history item with the rotated image\n    // but this rotated pixmap is for the gui only, it should not be saved.\n    for (int idx = mImageIndex; idx >= 0; idx--) {\n        if (mImages[idx].hasNewImage()) {\n            return mImages[idx].image();\n        }\n    }\n\n    return QImage();\n}\n\nQImage DkBasicLoader::pixmap() const\n{\n    // This is sometimes called with an invalid index, for example, after navigating back and forth\n    // if the history has been edited (i.e., > 1 entry). Sometimes, the index is -1 and the history is empty,\n    // which means we have nothing to return (image requested but nothing loaded). (via ViewPort?)\n    if (mImageIndex < 0 || mImageIndex >= mImages.size()) {\n        if (mImages.isEmpty())\n            return QImage();\n        else\n            return mImages.last().image();\n    }\n    // Return current pixmap, which may contain modification from metadata changes like rotation\n    // This should not be used to write the image to disk, use image() instead.\n    return mImages.at(mImageIndex).image();\n}\n\n/**\n * @brief Returns the pointer to the current metadata object which belongs to the loaded image.\n *\n * Note that this is a pointer, not a copy. After changing the metadata, it's necessary\n * to call setEditMetaData(), passing an appropriate edit name, to add a history item (will be copied).\n *\n * @return QSharedPointer<DkMetaDataT>\n */\nQSharedPointer<DkMetaDataT> DkBasicLoader::getMetaData() const\n{\n    QSharedPointer<DkMetaDataT> metaData(mMetaData);\n    return metaData;\n};\n\nQSharedPointer<DkMetaDataT> DkBasicLoader::lastMetaDataEdit(bool return_nullptr, bool return_orig) const\n{\n    QSharedPointer<DkMetaDataT> lastEdit; // null edit\n    if (return_orig) {\n        // Return original metadata only if requested (otherwise only return modified metadata)\n        lastEdit = mImages.first().metaData();\n    } else if (!return_nullptr) {\n        // Empty null object will be returned if no history item (with edited metadata) could be found\n        lastEdit = QSharedPointer<DkMetaDataT>(new DkMetaDataT());\n    }\n\n    // Get latest modified metadata item from history (or null)\n    for (int idx = mImageIndex; idx > 0; idx--) {\n        if (mImages[idx].hasNewMetaData()) {\n            lastEdit = mImages[idx].metaData();\n            break;\n        }\n    }\n\n    return lastEdit;\n}\n\nbool DkBasicLoader::isImageEdited()\n{\n    for (int i = 1, ii = mImageIndex; i <= ii; i++) {\n        if (mImages[i].hasNewImage()) {\n            return true;\n        }\n    }\n    return false;\n}\n\nbool DkBasicLoader::isMetaDataEdited()\n{\n    for (int i = 1, ii = mImageIndex; i <= ii; i++) {\n        if (mImages[i].hasNewMetaData()) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid DkBasicLoader::undo()\n{\n    // Change history index (for image()...)\n    if (mImageIndex > 0)\n        mImageIndex--;\n\n    // Get last history item with modified metadata (up until new history index)\n    QSharedPointer<DkMetaDataT> metaData(mMetaData);\n    metaData = lastMetaDataEdit(false, true);\n    // Update our current metadata object, which is also used elsewhere (pointer)\n    // for example, see DkMetaDataWidgets/DkMetaDataHUD - or DkCommentWidget\n    mMetaData->update(metaData);\n\n    // Notify listeners about changed metadata\n    emit undoSignal();\n    emit resetMetaDataSignal();\n}\n\nvoid DkBasicLoader::redo()\n{\n    // Change history index (for image()...)\n    if (mImageIndex < mImages.size() - 1)\n        mImageIndex++;\n\n    // Get last history item with modified metadata (up until new history index)\n    QSharedPointer<DkMetaDataT> metaData(mMetaData);\n    metaData = lastMetaDataEdit(false, true);\n    // Update our current metadata object, which is also used elsewhere (pointer)\n    // for example, see DkMetaDataWidgets/DkMetaDataHUD - or DkCommentWidget\n    mMetaData->update(metaData);\n\n    // Notify listeners about changed metadata\n    emit redoSignal();\n    emit resetMetaDataSignal();\n}\n\nQVector<DkEditImage> *DkBasicLoader::history()\n{\n    return &mImages;\n}\n\nDkEditImage DkBasicLoader::lastEdit() const\n{\n    assert(mImageIndex >= 0 && mImageIndex < mImages.size());\n    return mImages[mImageIndex];\n}\n\nint DkBasicLoader::historyIndex() const\n{\n    return mImageIndex;\n}\n\nvoid DkBasicLoader::setMinHistorySize(int size)\n{\n    mMinHistorySize = size;\n}\n\nvoid DkBasicLoader::setHistoryIndex(int idx)\n{\n    mImageIndex = idx;\n    // TODO update mMetaData, see undo()\n}\n\n// QByteArray DkBasicLoader::loadFileToBuffer(const QString &filePath) const\n// {\n//     QFileInfo fi(filePath);\n\n//     if (!fi.exists())\n//         return;\n\n// #ifdef WITH_QUAZIP\n//     if (fi.dir().path().contains(DkZipContainer::zipMarker()))\n//         DkZipContainer::extractImage(DkZipContainer::decodeZipFile(filePath), DkZipContainer::decodeImageFile(filePath), ba);\n// #endif\n\n//     QFile file(filePath);\n//     file.open(QIODevice::ReadOnly);\n\n//     ba = file.readAll();\n// }\n\nQSharedPointer<QByteArray> DkBasicLoader::loadFileToBuffer(const QString &filePath) const\n{\n    QFileInfo fi(filePath);\n\n#ifdef WITH_QUAZIP\n    if (fi.dir().path().contains(DkZipContainer::zipMarker()))\n        return DkZipContainer::extractImage(DkZipContainer::decodeZipFile(filePath), DkZipContainer::decodeImageFile(filePath));\n#endif\n\n    QFile file(filePath);\n    file.open(QIODevice::ReadOnly);\n\n    QSharedPointer<QByteArray> ba(new QByteArray(file.readAll()));\n    file.close();\n\n    return ba;\n}\n\n/**\n * @brief writeBufferToFile() writes the passed in file buffer to the specified file.\n *\n * It's called by the save() routine, which saves the image to that file buffer\n * and updates that file buffer to also contain exif data.\n *\n * @param fileInfo path to file to be written\n * @param ba raw content to be written to file\n */\nbool DkBasicLoader::writeBufferToFile(const QString &fileInfo, const QSharedPointer<QByteArray> ba) const\n{\n    if (!ba || ba->isEmpty())\n        return false;\n\n    QFile file(fileInfo);\n    file.open(QIODevice::WriteOnly);\n    qint64 bytesWritten = file.write(*ba.data(), ba->size());\n    file.close();\n    qDebug() << \"[DkBasicLoader] buffer saved, bytes written: \" << bytesWritten;\n\n    if (!bytesWritten || bytesWritten == -1)\n        return false;\n\n    return true;\n}\n\nvoid DkBasicLoader::indexPages(const QString &filePath, const QSharedPointer<QByteArray> ba)\n{\n    // reset counters\n    mNumPages = 1;\n    mPageIdx = 1;\n\n#ifdef WITH_LIBTIFF\n\n    QFileInfo fInfo(filePath);\n\n    // for now we just support tiff's\n    if (!fInfo.suffix().contains(QRegularExpression(\"(tif|tiff)\", QRegularExpression::CaseInsensitiveOption)))\n        return;\n\n    // first turn off nasty warning/error dialogs - (we do the GUI : )\n    TIFFErrorHandler oldErrorHandler, oldWarningHandler;\n    oldWarningHandler = TIFFSetWarningHandler(NULL);\n    oldErrorHandler = TIFFSetErrorHandler(NULL);\n\n    DkTimer dt;\n    TIFF *tiff = 0;\n\n#if defined(Q_OS_WIN)\n    std::istringstream is(ba ? ba->toStdString() : \"\");\n\n    if (ba)\n        tiff = TIFFStreamOpen(\"MemTIFF\", &is);\n\n    // read from file\n    if (!tiff)\n        tiff = TIFFOpen(filePath.toLatin1(), \"r\"); // this->mFile was here before - not sure why\n\n    // loading from buffer allows us to load files with non-latin names\n    QSharedPointer<QByteArray> bal;\n    if (!tiff)\n        bal = loadFileToBuffer(filePath);\n    ;\n    std::istringstream isl(bal ? bal->toStdString() : \"\");\n\n    if (bal)\n        tiff = TIFFStreamOpen(\"MemTIFF\", &isl);\n#else\n    // read from file\n    tiff = TIFFOpen(filePath.toLatin1(), \"r\"); // this->mFile was here before - not sure why\n#endif\n\n    if (!tiff)\n        return;\n\n    // libtiff example\n    int dircount = 0;\n\n    do {\n        dircount++;\n\n    } while (TIFFReadDirectory(tiff));\n\n    mNumPages = dircount;\n\n    if (mNumPages > 1)\n        mPageIdx = 1;\n\n    qDebug() << dircount << \" TIFF directories... \" << dt;\n    TIFFClose(tiff);\n\n    TIFFSetWarningHandler(oldWarningHandler);\n    TIFFSetWarningHandler(oldErrorHandler);\n#else\n    Q_UNUSED(filePath);\n#endif\n}\n\nbool DkBasicLoader::loadPage(int skipIdx)\n{\n    bool imgLoaded = false;\n\n    mPageIdx += skipIdx;\n\n    // <= 1 since first page is loaded using qt\n    if (mPageIdx > mNumPages || mPageIdx <= 1)\n        return imgLoaded;\n\n    return loadPageAt(mPageIdx);\n}\n\nbool DkBasicLoader::loadPageAt(int pageIdx)\n{\n    bool imgLoaded = false;\n\n#ifdef WITH_LIBTIFF\n\n    // <= 1 since first page is loaded using qt\n    if (pageIdx > mNumPages || pageIdx < 1)\n        return imgLoaded;\n\n    // first turn off nasty warning/error dialogs - (we do the GUI : )\n    TIFFErrorHandler oldErrorHandler, oldWarningHandler;\n    oldWarningHandler = TIFFSetWarningHandler(NULL);\n    oldErrorHandler = TIFFSetErrorHandler(NULL);\n\n    DkTimer dt;\n    TIFF *tiff = TIFFOpen(mFile.toLatin1(), \"r\");\n\n#if defined(Q_OS_WIN)\n\n    // loading from buffer allows us to load files with non-latin names\n    QSharedPointer<QByteArray> ba;\n    if (!tiff)\n        ba = loadFileToBuffer(mFile);\n\n    std::istringstream is(ba ? ba->toStdString() : \"\");\n    if (ba)\n        tiff = TIFFStreamOpen(\"MemTIFF\", &is);\n#endif\n\n    if (!tiff)\n        return imgLoaded;\n\n    uint32_t width = 0;\n    uint32_t height = 0;\n\n    // go to current directory\n    for (int idx = 1; idx < pageIdx; idx++) {\n        if (!TIFFReadDirectory(tiff))\n            return false;\n    }\n    TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, &width);\n    TIFFGetField(tiff, TIFFTAG_IMAGELENGTH, &height);\n\n    // init the qImage\n    QImage img = QImage(width, height, QImage::Format_ARGB32);\n\n    const int stopOnError = 1;\n    imgLoaded = TIFFReadRGBAImageOriented(tiff, width, height, reinterpret_cast<uint32_t *>(img.bits()), ORIENTATION_TOPLEFT, stopOnError) != 0;\n\n    if (imgLoaded) {\n        for (uint32_t y = 0; y < height; ++y)\n            convert32BitOrder(img.scanLine(y), width);\n    }\n\n    TIFFClose(tiff);\n\n    TIFFSetWarningHandler(oldWarningHandler);\n    TIFFSetWarningHandler(oldErrorHandler);\n\n    setEditImage(img, tr(\"Original Image\"));\n#else\n    Q_UNUSED(pageIdx);\n#endif\n\n    return imgLoaded;\n}\n\nbool DkBasicLoader::setPageIdx(int skipIdx)\n{\n    // do nothing if we don't have tiff pages\n    if (mNumPages <= 1)\n        return false;\n\n    mPageIdxDirty = false;\n\n    int newPageIdx = mPageIdx + skipIdx;\n\n    if (newPageIdx > 0 && newPageIdx <= mNumPages) {\n        mPageIdxDirty = true;\n        mPageIdx = newPageIdx;\n    }\n\n    return mPageIdxDirty;\n}\n\nvoid DkBasicLoader::resetPageIdx()\n{\n    mPageIdxDirty = false;\n    mPageIdx = 1;\n}\n\nvoid DkBasicLoader::convert32BitOrder(void *buffer, int width) const\n{\n#ifdef WITH_LIBTIFF\n    // code from Qt QTiffHandler\n    uint32_t *target = reinterpret_cast<uint32_t *>(buffer);\n    for (uint32_t x = 0; x < width; ++x) {\n        uint32_t p = target[x];\n        // convert between ARGB and ABGR\n        target[x] = (p & 0xff000000) | ((p & 0x00ff0000) >> 16) | (p & 0x0000ff00) | ((p & 0x000000ff) << 16);\n    }\n#else\n    Q_UNUSED(buffer);\n    Q_UNUSED(width);\n#endif\n}\n\n/**\n * @brief saves the image and its metadata to the specified file.\n *\n * It writes the image to a file buffer and then writes that buffer back to the original file.\n * Modified metadata is saved afterwards.\n *\n * @param filePath target path to image file\n * @param img source image to be written to file (may be converted along the way)\n * @param compression compression flag for QImageWriter\n */\nQString DkBasicLoader::save(const QString &filePath, const QImage &img, int compression)\n{\n    QSharedPointer<QByteArray> ba;\n\n    DkTimer dt;\n    if (saveToBuffer(filePath, img, ba, compression) && ba) {\n        if (writeBufferToFile(filePath, ba)) {\n            qInfo() << \"saved to\" << filePath << \"in\" << dt;\n            return filePath;\n        }\n    }\n\n    return QString();\n}\n\n/**\n * @brief saveToBuffer() writes the image matrix img to the file buffer.\n *\n * The file path is used to convert the image based on the file suffix.\n *\n * @param filePath path to file to which this image will later be written, the suffix is relevant\n * @param img image to be written to file buffer\n * @param ba in-memory file buffer containing resulting file\n * @param compression compression flag for QImageWriter\n */\nbool DkBasicLoader::saveToBuffer(const QString &filePath, const QImage &img, QSharedPointer<QByteArray> &ba, int compression) const\n{\n    bool bufferCreated = false;\n\n    if (!ba) {\n        ba = QSharedPointer<QByteArray>(new QByteArray());\n        bufferCreated = true;\n    }\n    // copy current metadata object: mMetaData pointer may be reset in the background in the process\n    // and then it won't be saved because !isLoaded()... [2022-08, pse]\n    QSharedPointer<DkMetaDataT> metaData = mMetaData;\n\n    bool saved = false;\n\n    QFileInfo fInfo(filePath);\n\n#ifdef Q_OS_WIN\n    if (0 == fInfo.suffix().compare(\"ico\", Qt::CaseInsensitive)) {\n        saved = saveWindowsIcon(img, ba);\n    } else\n#endif\n    {\n        bool hasAlpha = DkImage::alphaChannelUsed(img);\n\n        QImage sImg = img;\n\n        // JPEG 2000 can only handle 32 or 8bit images\n        if (!hasAlpha && img.colorTable().empty() && !fInfo.suffix().contains(QRegularExpression(\"(avif|j2k|jp2|jpf|jpx|jxl|png)\"))) {\n            sImg = sImg.convertToFormat(QImage::Format_RGB888);\n        } else if (fInfo.suffix().contains(QRegularExpression(\"(j2k|jp2|jpf|jpx)\")) && sImg.depth() != 32 && sImg.depth() != 8) {\n            if (sImg.hasAlphaChannel()) {\n                sImg = sImg.convertToFormat(QImage::Format_ARGB32);\n            } else {\n                sImg = sImg.convertToFormat(QImage::Format_RGB32);\n            }\n        }\n\n        if (fInfo.suffix().contains(QRegularExpression(\"(png)\")))\n            compression = -1;\n\n        QBuffer fileBuffer(ba.data());\n        // size_t s = fileBuffer.size();\n        fileBuffer.open(QIODevice::WriteOnly);\n        QImageWriter *imgWriter = new QImageWriter(&fileBuffer, fInfo.suffix().toStdString().c_str());\n\n        if (compression >= 0) { // -1 -> use Qt's default\n            imgWriter->setCompression(compression);\n            imgWriter->setQuality(compression);\n        }\n        if (compression == -1 && imgWriter->format() == \"jpg\") {\n            imgWriter->setQuality(DkSettingsManager::instance().settings().app().defaultJpgQuality);\n        }\n\n        imgWriter->setOptimizedWrite(true); // this saves space TODO: user option here?\n        imgWriter->setProgressiveScanWrite(true);\n\n        saved = imgWriter->write(sImg); // hint: release() might run now, resetting mMetaData which is used below [2022-08, pse]\n        delete imgWriter;\n    }\n\n    if (saved && metaData) {\n        if (!metaData->isLoaded() || !metaData->hasMetaData()) {\n            if (!bufferCreated)\n                metaData->readMetaData(filePath, ba);\n            else\n                // if we created the buffere here - force loading metadata from the file\n                metaData->readMetaData(filePath);\n        }\n\n        // If we have metadata for the image, save it\n        // If your images are saved without metadata, check if the metadata object is discarded or reset\n        // causing isLoaded() to return false (glitch on reload) - pse\n        if (metaData->isLoaded()) {\n            try {\n                // be careful: here we actually lie about the constness\n                metaData->updateImageMetaData(img, false); // set dimensions in exif (do not reset exif orientation)\n                if (!metaData->saveMetaData(ba, true))\n                    metaData->clearExifState();\n            } catch (...) {\n                // is it still throwing anything?\n                qInfo() << \"Sorry, I could not save the meta data...\";\n                // clear exif state here -> the 'dirty' flag would otherwise edit the original image (see #514)\n                metaData->clearExifState();\n            }\n        }\n    }\n\n    if (!saved)\n        emit errorDialogSignal(tr(\"Sorry, I could not save: %1\").arg(fInfo.fileName()));\n\n    return saved;\n}\n\nvoid DkBasicLoader::saveThumbToMetaData(const QString &filePath)\n{\n    QSharedPointer<QByteArray> ba; // dummy\n    saveThumbToMetaData(filePath, ba);\n}\n\nvoid DkBasicLoader::saveThumbToMetaData(const QString &filePath, QSharedPointer<QByteArray> &ba)\n{\n    if (!hasImage())\n        return;\n\n    mMetaData->setThumbnail(DkImage::createThumb(image()));\n    saveMetaData(filePath, ba);\n}\n\n/**\n * @brief this will write the current exif/metadata to the loaded file.\n *\n * It calls the other overload passing an empty buffer,\n * so it'll load the buffer, save the exif data to the buffer\n * and write the buffer back to the file.\n *\n * @param filePath path to current file to be updated\n */\nvoid DkBasicLoader::saveMetaData(const QString &filePath)\n{\n    QSharedPointer<QByteArray> ba; // dummy\n    saveMetaData(filePath, ba);\n}\n\n/**\n * @brief writes metadata to the file on disk, if it's marked as dirty\n *\n * This routine will write new metadata to the file on disk if metadata is marked dirty.\n * It does this by first loading the file into a buffer (unless a non-empty buffer is passed),\n * then it calls the MetaData module to save the exif data to that buffer\n * and finally, it writes the modified buffer to the file on disk.\n * The MetaData module has an overload which does basically the same thing.\n *\n * See ImageLoader (regular workflow starts there) and ImageContainer.\n *\n * @param filePath path to image file\n * @param ba file buffer to be saved (leave empty to work on the specified file as it is on disk)\n */\nvoid DkBasicLoader::saveMetaData(const QString &filePath, QSharedPointer<QByteArray> &ba)\n{\n    if (!ba)\n        ba = QSharedPointer<QByteArray>(new QByteArray());\n\n    if (ba->isEmpty() && mMetaData->isDirty()) {\n        ba = loadFileToBuffer(filePath);\n    }\n\n    // Update in-memory copy of file (ba) with new meta data\n    bool saved = false;\n    try {\n        saved = mMetaData->saveMetaData(ba);\n    } catch (...) {\n        qInfo() << \"could not save metadata...\";\n    }\n\n    // Write in-memory copy to specified file - use this overload only if you really need it\n    if (saved)\n        writeBufferToFile(filePath, ba);\n}\n\nbool DkBasicLoader::isContainer(const QString &filePath)\n{\n    QFileInfo fInfo(filePath);\n    if (!fInfo.isFile() || !fInfo.exists())\n        return false;\n\n    QString suffix = fInfo.suffix();\n\n    if (suffix.isEmpty())\n        return false;\n\n    for (int idx = 0; idx < DkSettingsManager::param().app().containerFilters.size(); idx++) {\n        if (DkSettingsManager::param().app().containerFilters[idx].contains(suffix))\n            return true;\n    }\n\n    return false;\n}\n\n/**\n * @brief releases the currently loaded images.\n *\n * Clears the history.\n * Called by loadGeneral() and ImageContainer::clear().\n *\n * @note This will *not* silently auto-save your beautiful images.\n * It was apparently intended to be used that way (it called saveMetaData(), like ~DkImageContainerT()).\n * All changes should be explicitly committed, including exif notes.\n * If you think this is wrong, a comment would be appreciated. See issue #799. PSE, 2022.\n *\n **/\nvoid DkBasicLoader::release()\n{\n    // TODO: auto save routines here?\n    // answer: no.\n\n    mImages.clear(); // clear history\n    mImageIndex = -1;\n\n    // Unload metadata\n    mMetaData = QSharedPointer<DkMetaDataT>(new DkMetaDataT());\n}\n\n#ifdef Q_OS_WIN\n// bool DkBasicLoader::saveWindowsIcon(const QString &filePath, const QImage &img) const\n// {\n//     QSharedPointer<QByteArray> ba;\n\n//     if (saveWindowsIcon(img, ba) && ba && !ba->isEmpty()) {\n//         writeBufferToFile(filePath, ba);\n//         return true;\n//     }\n\n//     return false;\n// }\n\nstruct ICONDIRENTRY {\n    UCHAR nWidth;\n    UCHAR nHeight;\n    UCHAR nNumColorsInPalette; // 0 if no palette\n    UCHAR nReserved; // should be 0\n    WORD nNumColorPlanes; // 0 or 1\n    WORD nBitsPerPixel;\n    ULONG nDataLength; // length in bytes\n    ULONG nOffset; // offset of BMP or PNG data from beginning of file\n};\n\nbool DkBasicLoader::saveWindowsIcon(const QImage &img, QSharedPointer<QByteArray> &ba) const\n{\n    // this code is an adopted version of:\n    // http://stackoverflow.com/questions/2289894/how-can-i-save-hicon-to-an-ico-file\n\n    if (!ba)\n        ba = QSharedPointer<QByteArray>(new QByteArray());\n\n#if QT_VERSION < QT_VERSION_CHECK(6, 0, 0)\n    HICON hIcon = QtWin::toHICON(QPixmap::fromImage(img));\n#else\n    HICON hIcon = img.toHICON();\n#endif\n    int nColorBits = 32;\n\n    QBuffer buffer(ba.data());\n    buffer.open(QIODevice::WriteOnly);\n\n    if (!hIcon)\n        return false;\n\n    HDC screenDevice = GetDC(0);\n\n    // Write header:\n    UCHAR icoHeader[6] = {0, 0, 1, 0, 1, 0}; // ICO file with 1 image\n    buffer.write((const char *)(&icoHeader), sizeof(icoHeader));\n\n    // Get information about icon:\n    ICONINFO iconInfo;\n    GetIconInfo(hIcon, &iconInfo);\n    HGDIOBJ handle1(iconInfo.hbmColor); // free bitmaps when function ends\n    BITMAPINFO bmInfo = {0};\n    bmInfo.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);\n    bmInfo.bmiHeader.biBitCount = 0; // don't get the color table\n    if (!GetDIBits(screenDevice, iconInfo.hbmColor, 0, 0, NULL, &bmInfo, DIB_RGB_COLORS)) {\n        return false;\n    }\n\n    // Allocate size of bitmap info header plus space for color table:\n    int nBmInfoSize = sizeof(BITMAPINFOHEADER);\n    if (nColorBits < 24) {\n        nBmInfoSize += sizeof(RGBQUAD) * (int)(1 << nColorBits);\n    }\n\n    QSharedPointer<UCHAR> bitmapInfo(new UCHAR[nBmInfoSize]);\n    BITMAPINFO *pBmInfo = (BITMAPINFO *)bitmapInfo.data();\n    memcpy(pBmInfo, &bmInfo, sizeof(BITMAPINFOHEADER));\n\n    // Get bitmap data:\n    QSharedPointer<UCHAR> bits(new UCHAR[bmInfo.bmiHeader.biSizeImage]);\n    pBmInfo->bmiHeader.biBitCount = (WORD)nColorBits;\n    pBmInfo->bmiHeader.biCompression = BI_RGB;\n    if (!GetDIBits(screenDevice, iconInfo.hbmColor, 0, bmInfo.bmiHeader.biHeight, bits.data(), pBmInfo, DIB_RGB_COLORS)) {\n        return false;\n    }\n\n    // Get mask data:\n    BITMAPINFO maskInfo = {0};\n    maskInfo.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);\n    maskInfo.bmiHeader.biBitCount = 0; // don't get the color table\n    if (!GetDIBits(screenDevice, iconInfo.hbmMask, 0, 0, NULL, &maskInfo, DIB_RGB_COLORS)) {\n        return false;\n    }\n\n    QSharedPointer<UCHAR> maskBits(new UCHAR[maskInfo.bmiHeader.biSizeImage]);\n    QSharedPointer<UCHAR> maskInfoBytes(new UCHAR[sizeof(BITMAPINFO) + 2 * sizeof(RGBQUAD)]);\n    BITMAPINFO *pMaskInfo = (BITMAPINFO *)maskInfoBytes.data();\n    memcpy(pMaskInfo, &maskInfo, sizeof(maskInfo));\n    if (!GetDIBits(screenDevice, iconInfo.hbmMask, 0, maskInfo.bmiHeader.biHeight, maskBits.data(), pMaskInfo, DIB_RGB_COLORS)) {\n        return false;\n    }\n\n    // Write directory entry:\n    ICONDIRENTRY dir;\n    dir.nWidth = (UCHAR)pBmInfo->bmiHeader.biWidth;\n    dir.nHeight = (UCHAR)pBmInfo->bmiHeader.biHeight;\n    dir.nNumColorsInPalette = (nColorBits == 4 ? 16 : 0);\n    dir.nReserved = 0;\n    dir.nNumColorPlanes = 0;\n    dir.nBitsPerPixel = pBmInfo->bmiHeader.biBitCount;\n    dir.nDataLength = pBmInfo->bmiHeader.biSizeImage + pMaskInfo->bmiHeader.biSizeImage + nBmInfoSize;\n    dir.nOffset = sizeof(dir) + sizeof(icoHeader);\n    buffer.write((const char *)&dir, sizeof(dir));\n\n    // Write DIB header (including color table):\n    int nBitsSize = pBmInfo->bmiHeader.biSizeImage;\n    pBmInfo->bmiHeader.biHeight *= 2; // because the header is for both image and mask\n    pBmInfo->bmiHeader.biCompression = 0;\n    pBmInfo->bmiHeader.biSizeImage += pMaskInfo->bmiHeader.biSizeImage; // because the header is for both image and mask\n    buffer.write((const char *)&pBmInfo->bmiHeader, nBmInfoSize);\n\n    // Write image data:\n    buffer.write((const char *)bits.data(), nBitsSize);\n\n    // Write mask data:\n    buffer.write((const char *)maskBits.data(), pMaskInfo->bmiHeader.biSizeImage);\n\n    buffer.close();\n\n    DeleteObject(handle1);\n\n    return true;\n}\n\n#endif // #ifdef Q_OS_WIN\n\n#ifdef WITH_OPENCV\n\n// cv::Mat DkBasicLoader::getImageCv()\n// {\n//     return cv::Mat();\n// }\n\nbool DkBasicLoader::loadOpenCVVecFile(const QString &filePath, QImage &img, QSharedPointer<QByteArray> ba, QSize s) const\n{\n    if (!ba)\n        ba = QSharedPointer<QByteArray>(new QByteArray());\n\n    // load from file?\n    if (ba->isEmpty())\n        ba = loadFileToBuffer(filePath);\n\n    if (ba->isEmpty())\n        return false;\n\n    // read header & get a pointer to the first image\n    int fileCount, vecSize;\n    const unsigned char *imgPtr = (const unsigned char *)ba->constData();\n    if (!readHeader(&imgPtr, fileCount, vecSize))\n        return false;\n\n    int guessedW = 0;\n    int guessedH = 0;\n\n    getPatchSizeFromFileName(QFileInfo(filePath).fileName(), guessedW, guessedH);\n\n    qDebug() << \"patch size from filename: \" << guessedW << \" x \" << guessedH;\n\n    if (vecSize > 0 && !guessedH && !guessedW) {\n        guessedW = qFloor(sqrt((float)vecSize));\n        if (guessedW > 0)\n            guessedH = vecSize / guessedW;\n    }\n\n    if (guessedW <= 0 || guessedH <= 0 || guessedW * guessedH != vecSize) {\n        // TODO: ask user\n        qDebug() << \"dimensions do not match, patch size: \" << guessedW << \" x \" << guessedH << \" vecSize: \" << vecSize;\n        return false;\n    }\n\n    int fSize = ba->size();\n    int numElements = 0;\n\n    // guess size\n    if (s.isEmpty()) {\n        double nEl = (fSize - 64) / (vecSize * 2);\n        nEl = (fSize - 64 - qCeil(nEl)) / (vecSize * 2) + 1; // opencv adds one byte per image - so we take care for this here\n\n        if (qFloor(nEl) != qCeil(nEl))\n            return false;\n        numElements = qRound(nEl);\n    }\n\n    double nRowsCols = sqrt(numElements);\n    int numCols = qCeil(nRowsCols);\n    int minusOneRow = (qFloor(nRowsCols) != qCeil(nRowsCols) && nRowsCols - qFloor(nRowsCols) < 0.5) ? 1 : 0;\n\n    cv::Mat allPatches((numCols - minusOneRow) * guessedH, numCols * guessedW, CV_8UC1, cv::Scalar(125));\n\n    for (int idx = 0; idx < numElements; idx++) {\n        if (*imgPtr != 0) {\n            qDebug() << \"skipping non-empty byte - there is something seriously wrong here!\";\n            // return false;\t// stop if the byte is non-empty -> otherwise we might read wrong memory\n        }\n\n        imgPtr++; // there is an empty byte between images\n        cv::Mat cPatch = getPatch(&imgPtr, QSize(guessedW, guessedH));\n        cv::Mat cPatchAll = allPatches(cv::Rect(idx % numCols * guessedW, qFloor(idx / numCols) * guessedH, guessedW, guessedH));\n\n        if (!cPatchAll.empty())\n            cPatch.copyTo(cPatchAll);\n    }\n\n    img = DkImage::mat2QImage(allPatches);\n    img = img.convertToFormat(QImage::Format_ARGB32);\n\n    // setEditImage(img, tr(\"Original Image\"));\n\n    return true;\n}\n\nvoid DkBasicLoader::getPatchSizeFromFileName(const QString &fileName, int &width, int &height) const\n{\n    // parse patch size from file\n    QStringList sections = fileName.split(QRegularExpression(\"[-\\\\.]\"));\n\n    for (int idx = 0; idx < sections.size(); idx++) {\n        QString tmpSec = sections[idx];\n        qDebug() << \"section: \" << tmpSec;\n\n        if (tmpSec.contains(\"w\"))\n            width = tmpSec.remove(\"w\").toInt();\n        else if (tmpSec.contains(\"h\"))\n            height = tmpSec.remove(\"h\").toInt();\n    }\n}\n\nbool DkBasicLoader::readHeader(const unsigned char **dataPtr, int &fileCount, int &vecSize) const\n{\n    const int *pData = (const int *)*dataPtr;\n    fileCount = *pData;\n    pData++; // read file count\n    vecSize = *pData; // read vec size\n\n    qDebug() << \"vec size: \" << vecSize << \" fileCount \" << fileCount;\n\n    *dataPtr += 12; // skip the first 12 (header) bytes\n\n    return true;\n}\n\n// the double pointer is here needed to additionally increase the pointer value\ncv::Mat DkBasicLoader::getPatch(const unsigned char **dataPtr, QSize patchSize) const\n{\n    cv::Mat img8U(patchSize.height(), patchSize.width(), CV_8UC1, cv::Scalar(0));\n\n    // ok, take just the second byte\n    for (int rIdx = 0; rIdx < img8U.rows; rIdx++) {\n        unsigned char *ptr8U = img8U.ptr<unsigned char>(rIdx);\n\n        for (int cIdx = 0; cIdx < img8U.cols; cIdx++) {\n            ptr8U[cIdx] = **dataPtr;\n            *dataPtr += 2; // it is strange: opencv stores vec files as 16 bit but just use the 2nd byte\n        }\n    }\n\n    return img8U;\n}\n\nint DkBasicLoader::mergeVecFiles(const QStringList &vecFilePaths, QString &saveFilePath) const\n{\n    int lastVecSize = 0;\n    int totalFileCount = 0;\n    int vecCount = 0;\n    int pWidth = 0, pHeight = 0;\n    QByteArray vecBuffer;\n\n    for (const QString &filePath : vecFilePaths) {\n        QFileInfo fInfo(filePath);\n        QSharedPointer<QByteArray> ba = loadFileToBuffer(filePath);\n        if (ba->isEmpty()) {\n            qDebug() << \"could not load: \" << fInfo.fileName();\n            continue;\n        }\n\n        int fileCount, vecSize;\n        const unsigned char *dataPtr = (const unsigned char *)ba->constData();\n        if (!readHeader(&dataPtr, fileCount, vecSize)) {\n            qDebug() << \"could not read header, skipping: \" << fInfo.fileName();\n            continue;\n        }\n\n        if (lastVecSize && vecSize != lastVecSize) {\n            qDebug() << \"wrong vec size, skipping: \" << fInfo.fileName();\n            continue;\n        }\n\n        vecBuffer.append((const char *)dataPtr, vecSize * fileCount * 2 + fileCount); // +fileCount accounts for the '\\0' bytes between the patches\n\n        getPatchSizeFromFileName(fInfo.fileName(), pWidth, pHeight);\n\n        totalFileCount += fileCount;\n        lastVecSize = vecSize;\n\n        vecCount++;\n    }\n\n    // don't save if we could not merge the files\n    if (!vecCount)\n        return vecCount;\n\n    unsigned int *header = new unsigned int[3];\n    header[0] = totalFileCount;\n    header[1] = lastVecSize;\n    header[2] = 0;\n\n    vecBuffer.prepend((const char *)header, 3 * sizeof(int));\n\n    QFileInfo saveFileInfo(saveFilePath);\n\n    // append width, height if we don't know\n    if (pWidth && pHeight) {\n        QString whString = \"-w\" + QString::number(pWidth) + \"-h\" + QString::number(pHeight);\n        saveFileInfo = QFileInfo(saveFileInfo.absolutePath(), saveFileInfo.baseName() + whString + \".\" + saveFileInfo.suffix());\n    }\n\n    QFile file(saveFileInfo.absoluteFilePath());\n    file.open(QIODevice::WriteOnly);\n    file.write(vecBuffer);\n    file.close();\n\n    return vecCount;\n}\n\n#endif // #ifdef WITH_OPENCV\n\n// FileDownloader --------------------------------------------------------------------\nFileDownloader::FileDownloader(const QUrl &imageUrl, const QString &filePath, QObject *parent)\n    : QObject(parent)\n{\n    mFilePath = filePath;\n\n    QNetworkProxyQuery npq(QUrl(\"https://google.com\"));\n    QList<QNetworkProxy> listOfProxies = QNetworkProxyFactory::systemProxyForQuery(npq);\n    if (!listOfProxies.empty() && listOfProxies[0].hostName() != \"\") {\n        mWebCtrl.setProxy(listOfProxies[0]);\n    }\n\n    connect(&mWebCtrl, &QNetworkAccessManager::finished, this, &FileDownloader::fileDownloaded);\n\n    downloadFile(imageUrl);\n}\n\nFileDownloader::~FileDownloader()\n{\n}\n\nvoid FileDownloader::downloadFile(const QUrl &url)\n{\n    QNetworkRequest request(url);\n    mWebCtrl.get(request);\n    mUrl = url;\n}\n\nvoid FileDownloader::saved()\n{\n    if (mSaveWatcher.result()) {\n        qInfo() << \"downloaded image saved to\" << mFilePath;\n        emit downloaded(mFilePath);\n    } else {\n        qWarning() << \"could not download file to \" << mFilePath;\n    }\n}\n\nbool FileDownloader::save(const QString &filePath, const QSharedPointer<QByteArray> data)\n{\n    if (!data) {\n        qWarning() << \"cannot save file if data is NULL\";\n        return false;\n    }\n\n    QFileInfo fi(filePath);\n\n    if (!fi.absoluteDir().exists())\n        QDir().mkpath(fi.absolutePath());\n\n    QFile f(filePath);\n    f.open(QIODevice::WriteOnly);\n\n    return f.write(*data);\n}\n\nvoid FileDownloader::fileDownloaded(QNetworkReply *pReply)\n{\n    if (pReply->error() != QNetworkReply::NoError) {\n        qWarning() << \"I could not download: \" << mUrl;\n        qWarning() << pReply->errorString();\n    }\n\n    mDownloadedData = QSharedPointer<QByteArray>(new QByteArray(pReply->readAll()));\n    // emit a signal\n    pReply->deleteLater();\n\n    // data only requested\n    if (mFilePath.isEmpty()) {\n        emit downloaded();\n    }\n    // ok save it\n    else {\n        connect(&mSaveWatcher, &QFutureWatcherBase::finished, this, &FileDownloader::saved, Qt::UniqueConnection);\n        mSaveWatcher.setFuture(QtConcurrent::run([&] {\n            return save(mFilePath, mDownloadedData);\n        }));\n    }\n}\n\nQSharedPointer<QByteArray> FileDownloader::downloadedData() const\n{\n    return mDownloadedData;\n}\n\nQUrl FileDownloader::getUrl() const\n{\n    return mUrl;\n}\n\n#ifdef WITH_QUAZIP\n\n// DkZipContainer --------------------------------------------------------------------\nDkZipContainer::DkZipContainer(const QString &encodedFilePath)\n{\n    if (!encodedFilePath.isEmpty() && encodedFilePath.contains(mZipMarker)) {\n        mImageInZip = true;\n        mEncodedFilePath = encodedFilePath;\n        mZipFilePath = decodeZipFile(encodedFilePath);\n        mImageFileName = decodeImageFile(encodedFilePath);\n    } else\n        mImageInZip = false;\n}\n\nQString DkZipContainer::encodeZipFile(const QString &zipFile, const QString &imageFile)\n{\n    // if you think this code is unreadable, take a look at the old line:\n    // return QFileInfo(QDir(zipFile.absoluteFilePath() + mZipMarker + imageFile.left(imageFile.lastIndexOf(\"/\") + 1).replace(\"/\",\n    // mZipMarker)),(imageFile.lastIndexOf(\"/\") < 0) ? imageFile : imageFile.right(imageFile.size() - imageFile.lastIndexOf(\"/\") - 1));\n\n    QDir dir = QDir(zipFile + mZipMarker + imageFile.left(imageFile.lastIndexOf(\"/\") + 1).replace(\"/\", mZipMarker));\n    QString fileName = (imageFile.lastIndexOf(\"/\") < 0) ? imageFile : imageFile.right(imageFile.size() - imageFile.lastIndexOf(\"/\") - 1);\n\n    return QFileInfo(dir, fileName).absoluteFilePath();\n}\n\nQString DkZipContainer::decodeZipFile(const QString &encodedFileInfo)\n{\n    QString encodedDir = QFileInfo(encodedFileInfo).absolutePath();\n\n    return encodedDir.left(encodedDir.indexOf(mZipMarker));\n}\n\nQString DkZipContainer::decodeImageFile(const QString &encodedFileInfo)\n{\n    // get relative zip path\n    QString tmp = encodedFileInfo.right(encodedFileInfo.size() - encodedFileInfo.indexOf(mZipMarker) - QString(mZipMarker).size());\n    tmp = tmp.replace(mZipMarker, \"/\");\n    tmp = tmp.replace(\"//\", \"/\");\n\n    // diem: this fixes an issue with images that are in a zip's root folder\n    if (tmp.startsWith(\"/\"))\n        tmp = tmp.right(tmp.length() - 1);\n\n    return tmp;\n}\n\nQSharedPointer<QByteArray> DkZipContainer::extractImage(const QString &zipFile, const QString &imageFile)\n{\n    QuaZip zip(zipFile);\n    if (!zip.open(QuaZip::mdUnzip))\n        return QSharedPointer<QByteArray>(new QByteArray());\n\n    qDebug() << \"DkZip::extractImage filePath: \" << zipFile;\n    qDebug() << \"3.0 image file\" << imageFile;\n\n    zip.setCurrentFile(imageFile);\n    QuaZipFile extractedFile(&zip);\n    if (!extractedFile.open(QIODevice::ReadOnly) || extractedFile.getZipError() != UNZ_OK)\n        return QSharedPointer<QByteArray>(new QByteArray());\n\n    QSharedPointer<QByteArray> ba(new QByteArray(extractedFile.readAll()));\n    extractedFile.close();\n\n    zip.close();\n\n    return ba;\n}\n\nvoid DkZipContainer::extractImage(const QString &zipFile, const QString &imageFile, QByteArray &ba)\n{\n    QuaZip zip(zipFile);\n    if (!zip.open(QuaZip::mdUnzip))\n        return;\n\n    zip.setCurrentFile(imageFile);\n    QuaZipFile extractedFile(&zip);\n    if (!extractedFile.open(QIODevice::ReadOnly) || extractedFile.getZipError() != UNZ_OK)\n        return;\n\n    ba = QByteArray(extractedFile.readAll());\n    extractedFile.close();\n\n    zip.close();\n}\n\nbool DkZipContainer::isZip() const\n{\n    return mImageInZip;\n}\n\nQString DkZipContainer::getZipFilePath() const\n{\n    return mZipFilePath;\n}\n\nQString DkZipContainer::getImageFileName() const\n{\n    return mImageFileName;\n}\n\nQString DkZipContainer::getEncodedFilePath() const\n{\n    return mEncodedFilePath;\n}\n\nQString DkZipContainer::zipMarker()\n{\n    return mZipMarker;\n}\n\n#endif\n\n// DkRawLoader --------------------------------------------------------------------\nDkRawLoader::DkRawLoader(const QString &filePath, const QSharedPointer<DkMetaDataT> &metaData)\n{\n    mFilePath = filePath;\n    mMetaData = metaData;\n}\n\nbool DkRawLoader::isEmpty() const\n{\n    return mFilePath.isEmpty();\n}\n\nvoid DkRawLoader::setLoadFast(bool fast)\n{\n    mLoadFast = fast;\n}\n\nbool DkRawLoader::load(const QSharedPointer<QByteArray> ba)\n{\n    DkTimer dt;\n\n    // try fetching the preview\n    if (loadPreview(ba))\n        return true;\n\n#ifdef WITH_LIBRAW\n\n    try {\n        // open the buffer\n        LibRaw iProcessor;\n\n        iProcessor.imgdata.params.use_camera_wb = 1;\n        iProcessor.imgdata.params.output_color = 1;\n        iProcessor.imgdata.params.output_bps = 8;\n        iProcessor.imgdata.params.four_color_rgb = 1;\n        iProcessor.imgdata.params.user_flip = 0;\n\n        if (DkSettingsManager::param().resources().filterRawImages) {\n            iProcessor.imgdata.params.user_qual = 3;\n            iProcessor.imgdata.params.dcb_enhance_fl = 1;\n            iProcessor.imgdata.params.fbdd_noiserd = 2;\n        } else {\n            iProcessor.imgdata.params.user_qual = 0;\n            iProcessor.imgdata.params.dcb_enhance_fl = 0;\n            iProcessor.imgdata.params.fbdd_noiserd = 0;\n        }\n\n        if (!openBuffer(ba, iProcessor)) {\n            qDebug() << \"could not open buffer for\" << mFilePath;\n            return false;\n        }\n\n        // check camera models for specific hacks\n        detectSpecialCamera(iProcessor);\n\n        // try loading RAW preview\n        if (mLoadFast) {\n            mImg = loadPreviewRaw(iProcessor);\n            mImg.setText(\"RAW.IsPreview\", mImg.isNull() ? \"no\" : \"yes\");\n\n            // are we done already?\n            if (!mImg.isNull())\n                return true;\n        }\n\n        // unpack the data\n        int error = iProcessor.unpack();\n        if (std::strcmp(iProcessor.version(), \"0.13.5\") != 0) // fixes a bug specific to libraw 13 - version call is UNTESTED\n            iProcessor.raw2image();\n\n        if (error != LIBRAW_SUCCESS)\n            return false;\n\n        // develop using libraw\n        error = iProcessor.dcraw_process();\n\n        auto rimg = iProcessor.dcraw_make_mem_image();\n\n        if (rimg) {\n            mImg = QImage(rimg->data, rimg->width, rimg->height, rimg->width * 3, QImage::Format_RGB888);\n            mImg = mImg.copy(); // make a deep copy...\n            mImg.setColorSpace(QColorSpace(QColorSpace::SRgb));\n            LibRaw::dcraw_clear_mem(rimg);\n            mImg.setText(\"RAW.Loader\", \"Default\");\n            mImg.setText(\"RAW.IsPreview\", \"no\");\n            return true;\n        }\n\n        // demosaic image\n        cv::Mat rawMat;\n\n        QHash<QString, QString> info; // info for mImg.setText()\n        info.insert(\"RAW.Loader\", \"Nomacs\");\n        info.insert(\"RAW.IsPreview\", \"no\");\n\n        if (iProcessor.imgdata.idata.filters) {\n            rawMat = demosaic(iProcessor);\n            info.insert(\"RAW.Processing\", \"Demosaic\");\n        } else {\n            rawMat = prepareImg(iProcessor);\n            info.insert(\"RAW.Processing\", \"Copy\");\n        }\n\n        // color correction + white balance\n        if (mIsChromatic)\n            whiteBalance(iProcessor, rawMat);\n\n        info.insert(\"RAW.ColorCorrection\", mIsChromatic ? \"yes\" : \"no\");\n\n        // gamma correction\n        gammaCorrection(iProcessor, rawMat);\n\n        // reduce color noise\n        bool noiseReduced = false;\n        if (DkSettingsManager::param().resources().filterRawImages && mIsChromatic) {\n            reduceColorNoise(iProcessor, rawMat);\n            noiseReduced = true;\n        }\n        info.insert(\"RAW.NoiseReduction\", noiseReduced ? \"yes\" : \"no\");\n\n        mImg = raw2Img(iProcessor, rawMat);\n\n        for (auto &key : qAsConst(info).keys())\n            mImg.setText(key, info.value(key));\n\n        // qDebug() << \"img size\" << mImg.size();\n        // qDebug() << \"raw mat size\" << rawMat.rows << \"x\" << rawMat.cols;\n        iProcessor.recycle();\n        rawMat.release();\n    } catch (...) {\n        qDebug() << \"[RAW] error during processing...\";\n        return false;\n    }\n\n    qInfo() << \"[RAW] loaded in \" << dt;\n\n#endif\n\n    return !mImg.isNull();\n}\n\nQImage DkRawLoader::image() const\n{\n    return mImg;\n}\n\nbool DkRawLoader::loadPreview(const QSharedPointer<QByteArray> &ba)\n{\n    try {\n        // try to get preview image from exiv2\n        if (mMetaData) {\n            if (mLoadFast || DkSettingsManager::param().resources().loadRawThumb == DkSettings::raw_thumb_always\n                || DkSettingsManager::param().resources().loadRawThumb == DkSettings::raw_thumb_if_large) {\n                mMetaData->readMetaData(mFilePath, ba);\n\n                int minWidth = 0;\n\n#ifdef WITH_LIBRAW // if nomacs has libraw - we can still hope for a fallback -> otherwise try whatever we have here\n                if (DkSettingsManager::param().resources().loadRawThumb == DkSettings::raw_thumb_if_large)\n                    minWidth = 1920;\n#endif\n                mImg = mMetaData->getPreviewImage(minWidth);\n\n                if (!mImg.isNull()) {\n                    qDebug() << \"[RAW] loaded with exiv2\";\n                    return true;\n                }\n            }\n        }\n    } catch (...) {\n        qWarning() << \"Exception caught during fetching RAW from thumbnail...\";\n    }\n\n    return false;\n}\n\n#ifdef WITH_LIBRAW\n\n// here are some hints from earlier days...\n//// (-w) Use camera white balance, if possible (otherwise, fallback to auto_wb)\n// iProcessor.imgdata.params.use_camera_wb = 1;\n//// (-a) Use automatic white balance obtained after averaging over the entire image\n// iProcessor.imgdata.params.use_auto_wb = 1;\n//// (-q 3) Adaptive homogeneity-directed de-mosaicing algorithm (AHD)\n// iProcessor.imgdata.params.user_qual = 3;\n// iProcessor.imgdata.params.output_tiff = 1;\n////iProcessor.imgdata.params.four_color_rgb = 1;\n////iProcessor.imgdata.params.output_color = 1; //sRGB  (0...raw)\n//// RAW data filtration mode during data unpacking and post-processing\n// iProcessor.imgdata.params.filtering_mode = LIBRAW_FILTERING_AUTOMATIC;\n\nQImage DkRawLoader::loadPreviewRaw(LibRaw &iProcessor) const\n{\n    int tW = iProcessor.imgdata.thumbnail.twidth;\n\n    if (DkSettingsManager::param().resources().loadRawThumb == DkSettings::raw_thumb_always\n        || (DkSettingsManager::param().resources().loadRawThumb == DkSettings::raw_thumb_if_large && tW >= 1920)) {\n        // crashes here if image is broken\n        int err = iProcessor.unpack_thumb();\n        char *tPtr = iProcessor.imgdata.thumbnail.thumb;\n\n        if (!err && tPtr) {\n            QImage img;\n            img.loadFromData((const uchar *)tPtr, iProcessor.imgdata.thumbnail.tlength);\n\n            // we're good to go\n            if (!img.isNull()) {\n                qDebug() << \"[RAW] I loaded the RAW's thumbnail\";\n                return img;\n            } else\n                qDebug() << \"RAW could not load the thumb\";\n        } else\n            qDebug() << \"error unpacking the thumb...\";\n    }\n\n    // default: return nothing\n    return QImage();\n}\n\nbool DkRawLoader::openBuffer(const QSharedPointer<QByteArray> &ba, LibRaw &iProcessor) const\n{\n    int error = LIBRAW_DATA_ERROR;\n\n    QFileInfo fi(mFilePath);\n\n    // use iprocessor from libraw to read the data\n    // OK - so LibRaw 0.17 cannot identify iiq files in the buffer - so we load them from the file\n    if (fi.suffix().contains(\"iiq\", Qt::CaseInsensitive) || !ba || ba->isEmpty()) {\n        error = iProcessor.open_file(mFilePath.toStdString().c_str());\n    } else {\n        // the buffer check is because:\n        // libraw has an error when loading buffers if the first 4 bytes encode as 'RIFF'\n        // and no data follows at all\n        if (ba->isEmpty() || ba->size() < 100)\n            return false;\n\n        error = iProcessor.open_buffer((void *)ba->constData(), ba->size());\n    }\n\n    return (error == LIBRAW_SUCCESS);\n}\n\nvoid DkRawLoader::detectSpecialCamera(const LibRaw &iProcessor)\n{\n    if (QString(iProcessor.imgdata.idata.model) == \"IQ260 Achromatic\")\n        mIsChromatic = false;\n\n    if (QString(iProcessor.imgdata.idata.model).contains(\"IQ260\"))\n        mCamType = camera_iiq;\n    else if (QString(iProcessor.imgdata.idata.make).compare(\"Canon\", Qt::CaseInsensitive))\n        mCamType = camera_canon;\n\n    // add your camera flag (for hacks) here\n}\n\ncv::Mat DkRawLoader::demosaic(LibRaw &iProcessor) const\n{\n    cv::Mat rawMat = cv::Mat(iProcessor.imgdata.sizes.height, iProcessor.imgdata.sizes.width, CV_16UC1);\n    double dynamicRange = (double)(iProcessor.imgdata.color.maximum - iProcessor.imgdata.color.black);\n\n    // normalize all image values\n    for (int rIdx = 0; rIdx < rawMat.rows; rIdx++) {\n        unsigned short *ptrRaw = rawMat.ptr<unsigned short>(rIdx);\n\n        for (int cIdx = 0; cIdx < rawMat.cols; cIdx++) {\n            int colIdx = iProcessor.COLOR(rIdx, cIdx);\n            double val = (double)(iProcessor.imgdata.image[(rawMat.cols * rIdx) + cIdx][colIdx]);\n\n            // normalize the value w.r.t the black point defined\n            val = (val - iProcessor.imgdata.color.black) / dynamicRange;\n            ptrRaw[cIdx] = clip<unsigned short>(val * USHRT_MAX); // for conversion to 16U\n        }\n    }\n\n    // no demosaicing\n    if (mIsChromatic) {\n        unsigned long type = (unsigned long)iProcessor.imgdata.idata.filters;\n        type = type & 255;\n\n        cv::Mat rgbImg;\n\n        // define bayer pattern\n        if (type == 180) {\n            cvtColor(rawMat, rgbImg, CV_BayerBG2RGB); // bitmask  10 11 01 00  -> 3(G) 2(B) 1(G) 0(R) ->\tRG RG RG\n                                                      //\t\t\t\t\t\t\t\t\t\t\t\t\tGB GB GB\n        } else if (type == 30) {\n            cvtColor(rawMat, rgbImg, CV_BayerRG2RGB); // bitmask  00 01 11 10\t-> 0 1 3 2\n        } else if (type == 225) {\n            cvtColor(rawMat, rgbImg, CV_BayerGB2RGB); // bitmask  11 10 00 01\n        } else if (type == 75) {\n            cvtColor(rawMat, rgbImg, CV_BayerGR2RGB); // bitmask  01 00 10 11\n        } else {\n            qWarning() << \"Wrong Bayer Pattern (not BG, RG, GB, GR)\\n\";\n            return cv::Mat();\n        }\n\n        rawMat = rgbImg;\n    }\n\n    // 16U (1 or 3 channeled) Mat\n    return rawMat;\n}\n\ncv::Mat DkRawLoader::prepareImg(const LibRaw &iProcessor) const\n{\n    cv::Mat rawMat = cv::Mat(iProcessor.imgdata.sizes.height, iProcessor.imgdata.sizes.width, CV_16UC3, cv::Scalar(0));\n    double dynamicRange = (double)(iProcessor.imgdata.color.maximum - iProcessor.imgdata.color.black);\n\n    // normalization function\n    auto normalize = [&](double val) {\n        val = (val - iProcessor.imgdata.color.black) / dynamicRange;\n        return clip<unsigned short>(val * USHRT_MAX);\n    };\n\n    for (int rIdx = 0; rIdx < rawMat.rows; rIdx++) {\n        unsigned short *ptrI = rawMat.ptr<unsigned short>(rIdx);\n\n        for (int cIdx = 0; cIdx < rawMat.cols; cIdx++) {\n            *ptrI = normalize(iProcessor.imgdata.image[rawMat.cols * rIdx + cIdx][0]);\n            ptrI++;\n            *ptrI = normalize(iProcessor.imgdata.image[rawMat.cols * rIdx + cIdx][1]);\n            ptrI++;\n            *ptrI = normalize(iProcessor.imgdata.image[rawMat.cols * rIdx + cIdx][2]);\n            ptrI++;\n        }\n    }\n\n    return rawMat;\n}\n\ncv::Mat DkRawLoader::whiteMultipliers(const LibRaw &iProcessor) const\n{\n    // get camera white balance multipliers\n    cv::Mat wm(1, 4, CV_32FC1);\n\n    float *wmp = wm.ptr<float>();\n\n    for (int idx = 0; idx < wm.cols; idx++)\n        wmp[idx] = iProcessor.imgdata.color.cam_mul[idx];\n\n    if (wmp[3] == 0)\n        wmp[3] = wmp[1]; // take green (usually its RGBG)\n\n    // normalize white balance multipliers\n    float w = (float)cv::sum(wm)[0] / 4.0f;\n    float maxW = 1.0f;\n\n    // clipping according the camera model\n    // if w > 2.0 maxW is 256, otherwise 512\n    // tested empirically\n    // check if it can be defined by some metadata settings?\n    if (w > 2.0f)\n        maxW = 255.0f;\n    if (w > 2.0f && mCamType == camera_canon)\n        maxW = 511.0f; // some cameras would even need ~800 - why?\n\n    // normalize white point\n    wm /= maxW;\n\n    // 1 x 4 32FC1 white balance vector\n    return wm;\n}\n\ncv::Mat DkRawLoader::gammaTable(const LibRaw &iProcessor) const\n{\n    // OK this is an instance of reverse engineering:\n    // we found out that the values of (at least) the PhaseOne's achromatic back have to be doubled\n    // our images are no close to what their software (Capture One does) - only the gamma correction\n    // seems to be slightly different... -> now we can load compressed IIQs that are not supported by PS : )\n    double cameraHackMlp = (QString(iProcessor.imgdata.idata.model) == \"IQ260 Achromatic\") ? 2.0 : 1.0;\n\n    // read gamma value and create gamma table\n    double gamma = (double)iProcessor.imgdata.params.gamm[0];\n\n    cv::Mat gmt(1, USHRT_MAX, CV_16UC1);\n    unsigned short *gmtp = gmt.ptr<unsigned short>();\n\n    for (int idx = 0; idx < gmt.cols; idx++) {\n        gmtp[idx] = clip<unsigned short>(qRound((1.099 * std::pow((double)idx / USHRT_MAX, gamma) - 0.099) * 255 * cameraHackMlp));\n    }\n\n    // a 1 x 65535 U16 gamma table\n    return gmt;\n}\n\nvoid DkRawLoader::whiteBalance(const LibRaw &iProcessor, cv::Mat &img) const\n{\n    // white balance must not be empty at this point\n    cv::Mat wb = whiteMultipliers(iProcessor);\n    const float *wbp = wb.ptr<float>();\n    assert(wb.cols == 4);\n\n    for (int rIdx = 0; rIdx < img.rows; rIdx++) {\n        unsigned short *ptr = img.ptr<unsigned short>(rIdx);\n\n        for (int cIdx = 0; cIdx < img.cols; cIdx++) {\n            // apply white balance correction\n            unsigned short r = clip<unsigned short>(*ptr * wbp[0]);\n            unsigned short g = clip<unsigned short>(*(ptr + 1) * wbp[1]);\n            unsigned short b = clip<unsigned short>(*(ptr + 2) * wbp[2]);\n\n            // apply color correction\n            int cr =\n                qRound(iProcessor.imgdata.color.rgb_cam[0][0] * r + iProcessor.imgdata.color.rgb_cam[0][1] * g + iProcessor.imgdata.color.rgb_cam[0][2] * b);\n            int cg =\n                qRound(iProcessor.imgdata.color.rgb_cam[1][0] * r + iProcessor.imgdata.color.rgb_cam[1][1] * g + iProcessor.imgdata.color.rgb_cam[1][2] * b);\n            int cb =\n                qRound(iProcessor.imgdata.color.rgb_cam[2][0] * r + iProcessor.imgdata.color.rgb_cam[2][1] * g + iProcessor.imgdata.color.rgb_cam[2][2] * b);\n\n            // clip & save color corrected values\n            *ptr = clip<unsigned short>(cr);\n            ptr++;\n            *ptr = clip<unsigned short>(cg);\n            ptr++;\n            *ptr = clip<unsigned short>(cb);\n            ptr++;\n        }\n    }\n}\n\nvoid DkRawLoader::gammaCorrection(const LibRaw &iProcessor, cv::Mat &img) const\n{\n    // white balance must not be empty at this point\n    cv::Mat gt = gammaTable(iProcessor);\n    const unsigned short *gammaLookup = gt.ptr<unsigned short>();\n    assert(gt.cols == USHRT_MAX);\n\n    for (int rIdx = 0; rIdx < img.rows; rIdx++) {\n        unsigned short *ptr = img.ptr<unsigned short>(rIdx);\n\n        for (int cIdx = 0; cIdx < img.cols * img.channels(); cIdx++) {\n            // values close to 0 are treated linear\n            if (ptr[cIdx] <= 5) // 0.018 * 255\n                ptr[cIdx] = (unsigned short)qRound(ptr[cIdx] * (double)iProcessor.imgdata.params.gamm[1] / 255.0);\n            else\n                ptr[cIdx] = gammaLookup[ptr[cIdx]];\n        }\n    }\n}\n\nvoid DkRawLoader::reduceColorNoise(const LibRaw &iProcessor, cv::Mat &img) const\n{\n    // filter color noise with a median filter\n    float isoSpeed = iProcessor.imgdata.other.iso_speed;\n\n    if (isoSpeed > 0) {\n        DkTimer dt;\n\n        int winSize;\n        if (isoSpeed > 6400)\n            winSize = 13;\n        else if (isoSpeed >= 3200)\n            winSize = 11;\n        else if (isoSpeed >= 2500)\n            winSize = 9;\n        else if (isoSpeed >= 400)\n            winSize = 7;\n        else\n            winSize = 5;\n\n        DkTimer dMed;\n\n        // revert back to 8-bit image\n        img.convertTo(img, CV_8U);\n\n        cv::cvtColor(img, img, CV_RGB2YCrCb);\n\n        std::vector<cv::Mat> imgCh;\n        cv::split(img, imgCh);\n        assert(imgCh.size() == 3);\n\n        cv::medianBlur(imgCh[1], imgCh[1], winSize);\n        cv::medianBlur(imgCh[2], imgCh[2], winSize);\n\n        cv::merge(imgCh, img);\n        cv::cvtColor(img, img, CV_YCrCb2RGB);\n        qDebug() << \"median blur takes:\" << dt;\n    }\n}\n\nQImage DkRawLoader::raw2Img(const LibRaw &iProcessor, cv::Mat &img) const\n{\n    // check the pixel aspect ratio of the raw image\n    if (iProcessor.imgdata.sizes.pixel_aspect != 1.0f)\n        cv::resize(img, img, cv::Size(), (double)iProcessor.imgdata.sizes.pixel_aspect, 1.0f);\n\n    // revert back to 8-bit image\n    img.convertTo(img, CV_8U);\n\n    // TODO: for now - fix this!\n    if (img.channels() == 1)\n        cv::cvtColor(img, img, CV_GRAY2RGB);\n\n    return DkImage::mat2QImage(img);\n}\n\n#endif\n\n// -------------------------------------------------------------------- DkTgaLoader\nnamespace tga\n{\nDkTgaLoader::DkTgaLoader(QSharedPointer<QByteArray> ba)\n{\n    mBa = ba;\n}\n\nQImage DkTgaLoader::image() const\n{\n    return mImg;\n}\n\nbool DkTgaLoader::load()\n{\n    if (!mBa || mBa->isEmpty())\n        return false;\n\n    return load(mBa);\n}\n\nbool DkTgaLoader::load(QSharedPointer<QByteArray> ba)\n{\n    // this code is from: http://www.paulbourke.net/dataformats/tga/\n    // thanks!\n    Header header;\n\n    const char *dataC = ba->data();\n\n    /* Display the header fields */\n    header.idlength = *dataC;\n    dataC++;\n    header.colourmaptype = *dataC;\n    dataC++;\n    header.datatypecode = *dataC;\n    dataC++;\n\n    const short *dataS = (const short *)dataC;\n\n    header.colourmaporigin = *dataS;\n    dataS++;\n    header.colourmaplength = *dataS;\n    dataS++;\n    dataC = (const char *)dataS;\n    header.colourmapdepth = *dataC;\n    dataC++;\n    dataS = (const short *)dataC;\n    header.x_origin = *dataS;\n    dataS++;\n    header.y_origin = *dataS;\n    dataS++;\n    header.width = *dataS;\n    dataS++;\n    header.height = *dataS;\n    dataS++;\n    dataC = (const char *)dataS;\n    header.bitsperpixel = *dataC;\n    dataC++;\n    header.imagedescriptor = *dataC;\n    dataC++;\n\n#ifdef _DEBUG\n    qDebug() << \"TGA Header ------------------------------\";\n    qDebug() << \"ID length:         \" << (int)header.idlength;\n    qDebug() << \"Colourmap type:    \" << (int)header.colourmaptype;\n    qDebug() << \"Image type:        \" << (int)header.datatypecode;\n    qDebug() << \"Colour map offset: \" << header.colourmaporigin;\n    qDebug() << \"Colour map length: \" << header.colourmaplength;\n    qDebug() << \"Colour map depth:  \" << (int)header.colourmapdepth;\n    qDebug() << \"X origin:          \" << header.x_origin;\n    qDebug() << \"Y origin:          \" << header.y_origin;\n    qDebug() << \"Width:             \" << header.width;\n    qDebug() << \"Height:            \" << header.height;\n    qDebug() << \"Bits per pixel:    \" << (int)header.bitsperpixel;\n    qDebug() << \"Descriptor:        \" << (int)header.imagedescriptor;\n#endif\n\n    /* What can we handle */\n    if (header.datatypecode != 2 && header.datatypecode != 10) {\n        qWarning() << \"[TGA] Can only handle image type 2 and 10\";\n        return false;\n    }\n\n    if (header.bitsperpixel != 16 && header.bitsperpixel != 24 && header.bitsperpixel != 32) {\n        qWarning() << \"[TGA] Can only handle pixel depths of 16, 24, and 32\";\n        return false;\n    }\n\n    if (header.colourmaptype != 0 && header.colourmaptype != 1) {\n        qWarning() << \"[TGA] Can only handle colour map types of 0 and 1\";\n        return false;\n    }\n\n    Pixel *pixels = new Pixel[header.width * header.height * sizeof(Pixel)];\n\n    if (!pixels) {\n        qWarning() << \"[TGA] could not allocate\" << header.width * header.height * sizeof(Pixel) / 1024 << \"KB\";\n        return false;\n    }\n\n    ///* Skip over unnecessary stuff */\n    int skipover = header.idlength;\n    skipover += header.colourmaptype * header.colourmaplength;\n    dataC += skipover;\n\n    /* Read the image */\n    int bytes2read = header.bitsperpixel / 8; // save?\n    unsigned char p[5];\n\n    for (int n = 0; n < header.width * header.height;) {\n        if (header.datatypecode == 2) { /* Uncompressed */\n\n            // TODO: out-of-bounds not checked here...\n            for (int bi = 0; bi < bytes2read; bi++, dataC++)\n                p[bi] = *dataC;\n\n            mergeBytes(&(pixels[n]), p, bytes2read);\n            n++;\n        } else if (header.datatypecode == 10) { /* Compressed */\n\n            for (int bi = 0; bi < bytes2read + 1; bi++, dataC++)\n                p[bi] = *dataC;\n\n            int j = p[0] & 0x7f;\n            mergeBytes(&(pixels[n]), &(p[1]), bytes2read);\n            n++;\n            if (p[0] & 0x80) { /* RLE chunk */\n                for (int i = 0; i < j; i++) {\n                    mergeBytes(&(pixels[n]), &(p[1]), bytes2read);\n                    n++;\n                }\n            } else { /* Normal chunk */\n                for (int i = 0; i < j; i++) {\n                    for (int bi = 0; bi < bytes2read; bi++, dataC++)\n                        p[bi] = *dataC;\n\n                    mergeBytes(&(pixels[n]), p, bytes2read);\n                    n++;\n                }\n            }\n        }\n    }\n\n    mImg = QImage((uchar *)pixels, header.width, header.height, QImage::Format_ARGB32);\n    mImg = mImg.copy();\n\n    // I somehow expected the 5th bit to be 0x10 -> but Paul seems to have a 0th bit : )\n    if (!(header.imagedescriptor & 0x20))\n        mImg = mImg.mirrored();\n\n    delete[] pixels;\n\n    return true;\n}\n\nvoid DkTgaLoader::mergeBytes(Pixel *pixel, unsigned char *p, int bytes) const\n{\n    if (bytes == 4) {\n        pixel->r = p[0];\n        pixel->g = p[1];\n        pixel->b = p[2];\n        pixel->a = p[3];\n    } else if (bytes == 3) {\n        pixel->r = p[0];\n        pixel->g = p[1];\n        pixel->b = p[2];\n        pixel->a = 255;\n    } else if (bytes == 2) {\n        pixel->r = (p[0] & 0x1f) << 3;\n        pixel->g = ((p[1] & 0x03) << 6) | ((p[0] & 0xe0) >> 2);\n        pixel->b = (p[1] & 0x7c) << 1;\n        pixel->a = 255; // (p[1] & 0x80);\n    }\n}\n}\n\n}",
    "void DkBasicLoader::indexPages(const QString &filePath, const QSharedPointer<QByteArray> ba)\n{\n    // reset counters\n    mNumPages = 1;\n    mPageIdx = 1;\n\n#ifdef WITH_LIBTIFF\n\n    QFileInfo fInfo(filePath);\n\n    // for now we just support tiff's\n    if (!fInfo.suffix().contains(QRegularExpression(\"(tif|tiff)\", QRegularExpression::CaseInsensitiveOption)))\n        return;\n\n    // first turn off nasty warning/error dialogs - (we do the GUI : )\n    TIFFErrorHandler oldErrorHandler, oldWarningHandler;\n    oldWarningHandler = TIFFSetWarningHandler(NULL);\n    oldErrorHandler = TIFFSetErrorHandler(NULL);\n\n    DkTimer dt;\n    TIFF *tiff = 0;\n\n#if defined(Q_OS_WIN)\n    std::istringstream is(ba ? ba->toStdString() : \"\");\n\n    if (ba)\n        tiff = TIFFStreamOpen(\"MemTIFF\", &is);\n\n    // read from file\n    if (!tiff)\n        tiff = TIFFOpen(filePath.toLatin1(), \"r\"); // this->mFile was here before - not sure why\n\n    // loading from buffer allows us to load files with non-latin names\n    QSharedPointer<QByteArray> bal;\n    if (!tiff)\n        bal = loadFileToBuffer(filePath);\n    ;\n    std::istringstream isl(bal ? bal->toStdString() : \"\");\n\n    if (bal)\n        tiff = TIFFStreamOpen(\"MemTIFF\", &isl);\n#else\n    // read from file\n    tiff = TIFFOpen(filePath.toLatin1(), \"r\"); // this->mFile was here before - not sure why\n#endif\n\n    if (!tiff)\n        return;\n\n    // libtiff example\n    int dircount = 0;\n\n    do {\n        dircount++;\n\n    } while (TIFFReadDirectory(tiff));\n\n    mNumPages = dircount;\n\n    if (mNumPages > 1)\n        mPageIdx = 1;\n\n    qDebug() << dircount << \" TIFF directories... \" << dt;\n    TIFFClose(tiff);\n\n    TIFFSetWarningHandler(oldWarningHandler);\n    TIFFSetWarningHandler(oldErrorHandler);\n#else\n    Q_UNUSED(filePath);\n#endif\n}",
    "bool DkBasicLoader::loadPageAt(int pageIdx)\n{\n    bool imgLoaded = false;\n\n#ifdef WITH_LIBTIFF\n\n    // <= 1 since first page is loaded using qt\n    if (pageIdx > mNumPages || pageIdx < 1)\n        return imgLoaded;\n\n    // first turn off nasty warning/error dialogs - (we do the GUI : )\n    TIFFErrorHandler oldErrorHandler, oldWarningHandler;\n    oldWarningHandler = TIFFSetWarningHandler(NULL);\n    oldErrorHandler = TIFFSetErrorHandler(NULL);\n\n    DkTimer dt;\n    TIFF *tiff = TIFFOpen(mFile.toLatin1(), \"r\");\n\n#if defined(Q_OS_WIN)\n\n    // loading from buffer allows us to load files with non-latin names\n    QSharedPointer<QByteArray> ba;\n    if (!tiff)\n        ba = loadFileToBuffer(mFile);\n\n    std::istringstream is(ba ? ba->toStdString() : \"\");\n    if (ba)\n        tiff = TIFFStreamOpen(\"MemTIFF\", &is);\n#endif\n\n    if (!tiff)\n        return imgLoaded;\n\n    uint32_t width = 0;\n    uint32_t height = 0;\n\n    // go to current directory\n    for (int idx = 1; idx < pageIdx; idx++) {\n        if (!TIFFReadDirectory(tiff))\n            return false;\n    }\n    TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, &width);\n    TIFFGetField(tiff, TIFFTAG_IMAGELENGTH, &height);\n\n    // init the qImage\n    QImage img = QImage(width, height, QImage::Format_ARGB32);\n\n    const int stopOnError = 1;\n    imgLoaded = TIFFReadRGBAImageOriented(tiff, width, height, reinterpret_cast<uint32_t *>(img.bits()), ORIENTATION_TOPLEFT, stopOnError) != 0;\n\n    if (imgLoaded) {\n        for (uint32_t y = 0; y < height; ++y)\n            convert32BitOrder(img.scanLine(y), width);\n    }\n\n    TIFFClose(tiff);\n\n    TIFFSetWarningHandler(oldWarningHandler);\n    TIFFSetWarningHandler(oldErrorHandler);\n\n    setEditImage(img, tr(\"Original Image\"));\n#else\n    Q_UNUSED(pageIdx);\n#endif\n\n    return imgLoaded;\n}",
    "unsigned int\nXdmfTIFFController::getNumberDirectories() const\n{\n  TIFF* tif = TIFFOpen(mFilePath.c_str(), \"r\");\n  unsigned int count = 0;\n  if (tif) {\n    do {\n      count++;\n    } while (TIFFReadDirectory(tif));\n    TIFFClose(tif);\n  }\n  return count;\n}",
    "bool QTiffHandler::ensureHaveDirectoryCount() const\n{\n    if (d->directoryCount > 0)\n        return true;\n\n    TIFF *tiff = d->openInternal(\"rh\", device());\n\n    if (!tiff) {\n        device()->reset();\n        return false;\n    }\n\n    while (TIFFReadDirectory(tiff))\n      ++d->directoryCount;\n    TIFFClose(tiff);\n    device()->reset();\n    return true;\n}",
    "char *loadTiffMetaInfo(char* filename, uint32 &sz0, uint32  &sz1, uint32  &sz2, uint32  &sz3, uint16 &datatype)\n{\n    //\n    TIFFSetWarningHandler(0);\n    TIFFSetErrorHandler(0);\n\n    //\n    TIFF *input = TIFFOpen(filename,\"r\");\n    if (!input)\n    {\n        return ((char *) \"Cannot open the file.\");\n    }\n\n    if (!TIFFGetField(input, TIFFTAG_IMAGEWIDTH, &sz0))\n    {\n        TIFFClose(input);\n        return ((char *) \"Image width of undefined.\");\n    }\n\n    if (!TIFFGetField(input, TIFFTAG_IMAGELENGTH, &sz1))\n    {\n        TIFFClose(input);\n        return ((char *) \"Image length of undefined.\");\n    }\n\n    if (!TIFFGetField(input, TIFFTAG_BITSPERSAMPLE, &datatype))\n    {\n        TIFFClose(input);\n        return ((char *) \"Undefined bits per sample.\");\n    }\n\n//    if (!TIFFGetField(input, TIFFTAG_SAMPLESPERPIXEL, &sz3))\n//    {\n//        sz3 = 1;\n//    }\n\n    sz3 = 1; // hard coded here 6/8/2018\n\n    uint16 Cpage;\n    if (!TIFFGetField(input, TIFFTAG_PAGENUMBER, &Cpage, &sz2) || sz2==0)\n    {\n        sz2 = 1;\n        while ( TIFFReadDirectory(input) )\n        {\n            sz2++;\n        }\n    }\n    datatype /= 8;\n\n    //\n    TIFFClose(input);\n\n    //\n    return ((char *) 0);\n}",
    "void readTiff( stringstream *dataStreamInMemory, unsigned char *&img, unsigned int first, unsigned int last, int starti, int endi, int startj, int endj )\n{\n    //\n    TIFF* input = TIFFStreamOpen(\"MemTIFF\", (istream *)dataStreamInMemory);\n\n    //\n    uint32 rps;\n    uint16 spp, bpp, photo, comp, planar_config;\n    int StripsPerImage,LastStripSize;\n    unsigned int img_width, img_height;\n\n    //\n    if (!TIFFGetField(input, TIFFTAG_IMAGEWIDTH, &img_width))\n    {\n        TIFFClose(input);\n        ssclear(dataStreamInMemory);\n        return;\n    }\n\n    if (!TIFFGetField(input, TIFFTAG_IMAGELENGTH, &img_height))\n    {\n        TIFFClose(input);\n        ssclear(dataStreamInMemory);\n        return;\n    }\n\n    if (!TIFFGetField(input, TIFFTAG_BITSPERSAMPLE, &bpp))\n    {\n        TIFFClose(input);\n        ssclear(dataStreamInMemory);\n        return;\n    }\n\n    if (!TIFFGetField(input, TIFFTAG_SAMPLESPERPIXEL, &spp))\n    {\n        spp = 1;\n    }\n\n    int b_swap=TIFFIsByteSwapped(input);\n\n    //\n    if (!TIFFGetField(input, TIFFTAG_PHOTOMETRIC, &photo))\n    {\n        TIFFClose(input);\n        ssclear(dataStreamInMemory);\n        return;\n    }\n\n    if (!TIFFGetField(input, TIFFTAG_COMPRESSION, &comp))\n    {\n        TIFFClose(input);\n        ssclear(dataStreamInMemory);\n        return;\n    }\n\n    if (!TIFFGetField(input, TIFFTAG_PLANARCONFIG, &planar_config))\n    {\n        TIFFClose(input);\n        ssclear(dataStreamInMemory);\n        return;\n    }\n\n    //\n    starti = (starti == -1) ? 0 : starti;\n    endi   = (endi == -1) ? img_height-1 : endi;\n    startj = (startj == -1) ? 0 : startj;\n    endj   = (endj == -1) ? img_width-1 : endj;\n\n    // file is internally tiled\n    if (TIFFIsTiled(input))\n    {\n        uint32 tilewidth;\n        uint32 tilelength;\n        uint32 tiledepth;\n        tsize_t tilenum;\n        tsize_t tilesize;\n        tsize_t tilenum_width;\n        tsize_t tilenum_length;\n        ttile_t tile;\n        tdata_t data;\n        unsigned char *psrc; // pointer in the tile buffer to the top left pixel of the current block to be copied\n        unsigned char *pdst; // pointer in the image buffer to the top left pixel of the current block to be filled\n        uint32 stride_src;\n        uint32 stride_dst;\n        int i; // row index in the slice of the top left pixel of the current block to be filled\n        int j; // column index in the slice of the top left pixel of the current block to be filled\n        uint32 width; // width of the current block to be filled (in pixels)\n        uint32 len; // length of the current block to be filled (in pixels)\n        int page;\n\n        // checks\n        if ( TIFFGetField(input, TIFFTAG_TILEDEPTH, &tiledepth) )\n        {\n            cout<<\"Tiling among slices (z direction) not supported.\"<<endl;\n            return;\n        }\n        if ( spp > 1 )\n        {\n            if ( TIFFGetField(input, TIFFTAG_PLANARCONFIG, &planar_config) )\n            {\n                if ( planar_config > 1 )\n                {\n                    cout<<\"Non-interleaved multiple channels not supported with tiling.\"<<endl;\n                    return;\n                }\n            }\n        }\n\n        // tiling is in x,y only\n        TIFFGetField(input, TIFFTAG_TILEWIDTH, &tilewidth);\n        TIFFGetField(input, TIFFTAG_TILELENGTH, &tilelength);\n        tilenum = TIFFNumberOfTiles(input);\n        tilesize = TIFFTileSize(input);\n        tilenum_width  = (img_width % tilewidth) ? (img_width / tilewidth) + 1 : img_width / tilewidth;\n        tilenum_length = (img_height % tilelength) ? (img_height / tilelength) + 1 : img_height / tilelength;\n\n        data = new unsigned char[tilesize];\n        stride_src = tilewidth * spp; // width of tile (in bytes)\n        stride_dst = (endj - startj + 1) * spp; // width of subregion (in bytes)\n\n        page = 0;\n        do {\n\n            psrc = ((unsigned char *)data) + ((starti % tilelength)*tilewidth + (startj % tilewidth)) * spp; // in the first tile skip (starti % tilelength) rows plus (startj % tilewidth) pixels\n            pdst = img; // the buffer has the size of the subregion\n            len = tilelength - (starti % tilelength); // rows to be copied for the first row of tiles\n            tile = TIFFComputeTile(input,startj,starti,0,0); // index of the first tile to be copied in the current row of tiles\n            for ( i=starti; i<=endi; ) {\n                width = tilewidth - (startj%tilewidth); // width of the first block to be copied/filled\n                for ( j=startj; j<=endj; ) {\n                    TIFFReadEncodedTile(input,tile,data,(tsize_t) -1); // read tile into tile buffer\n                    copydata (psrc,stride_src,pdst,stride_dst,(width * spp),len); // copy the block\n                    j += width;\n                    tile++; // index of the next tile in the same row of tiles\n                    psrc = ((unsigned char *)data) + ((i % tilelength)*tilewidth) * spp; // the block in the next tile begins just after (i % tilelength) rows\n                    pdst += width * spp; // the block in the image buffer move forward of width pixels\n                    width = (((tile%tilenum_width) + 1) * tilewidth <= (endj+1)) ? tilewidth : ((endj+1)%tilewidth); // if the next tile in the row is all within the subregion, width is tilewidth otherwise it is shorter\n                }\n                i += len;\n                tile = TIFFComputeTile(input,startj,i,0,0); // index of the first tile to be copied in the current row of tiles\n                psrc = ((unsigned char *)data) + ((i % tilelength)*tilewidth + (startj % tilewidth)) * spp; // in the first tile of the next row of tiles skip (i % tilelength) rows plus (startj % tilewidth) pixels\n                pdst = img + ((i-starti) * stride_dst); // the block in the image buffer begin after (i-starti) rows\n                len = (((tile/tilenum_width) + 1) * tilelength <= (endi+1)) ? tilelength : ((endi+1)%tilelength); // if the next row of tiles is all within the subregion, len is tilelength otherwise it is shorter\n            }\n\n            page++;\n\n        }while ( page < static_cast<int>(last-first+1) && TIFFReadDirectory(input));\n\n        return;\n    }\n\n    //\n    if (!TIFFGetField(input, TIFFTAG_ROWSPERSTRIP, &rps))\n    {\n        TIFFClose(input);\n        dataStreamInMemory->clear();\n        dataStreamInMemory->str(string());\n        return;\n    }\n\n    StripsPerImage =  (img_height + rps - 1) / rps;\n    LastStripSize = img_height % rps;\n    if (LastStripSize==0)\n        LastStripSize=rps;\n\n    unsigned char *buf = img;\n    int page=0;\n\n    if ( starti < 0 || endi >= img_height || startj < 0 || endj >= img_width || starti >= endi || startj >= endj )\n    {\n        cout<<\"Wrong substack indices.\"<<endl;\n        return;\n    }\n\n    if ( starti == 0 && endi == (img_height-1) && startj == 0 && endj == (img_width-1) ) { // read whole images from files\n\n        if (!TIFFSetDirectory(input, first))\n        {\n            TIFFClose(input);\n            dataStreamInMemory->clear();\n            dataStreamInMemory->str(string());\n            return;\n        }\n\n        do{\n\n            for (int i=0; i < StripsPerImage-1; i++){\n                if (comp==1) {\n                    TIFFReadRawStrip(input, i, buf, spp * rps * img_width * (bpp/8));\n                    buf = buf + spp * rps * img_width * (bpp/8);\n                }\n                else{\n                    TIFFReadEncodedStrip(input, i, buf, spp * rps * img_width * (bpp/8));\n                    buf = buf + spp * rps * img_width * (bpp/8);\n                }\n            }\n\n            if (comp==1) {\n                TIFFReadRawStrip(input, StripsPerImage-1, buf, spp * LastStripSize * img_width * (bpp/8));\n            }\n            else{\n                TIFFReadEncodedStrip(input, StripsPerImage-1, buf, spp * LastStripSize * img_width * (bpp/8));\n            }\n            buf = buf + spp * LastStripSize * img_width * (bpp/8);\n\n            page++;\n\n        }while ( page < static_cast<int>(last-first+1) && TIFFReadDirectory(input));// while (TIFFReadDirectory(input));\n\n    }\n    else { // read only a subregion of images from files\n\n        unsigned int XSIZE = img_width;\n\n        unsigned char *rowbuf = new unsigned char[spp * rps * XSIZE * (bpp/8)];\n        unsigned char *bufptr;\n\n        do{\n            if (!TIFFSetDirectory(input, first + page))\n            {\n                TIFFClose(input);\n                ssclear(dataStreamInMemory);\n                return;\n            }\n\n            int stripIndex = (starti / rps) - 1; // the strip preceeding the first one\n            for (int i=starti; i <= endi; i++) {\n                if ( floor((double)i / rps) > stripIndex ) { // read a new strip\n                    stripIndex = (int)floor((double)i / rps);\n                    if (comp==1) {\n                        TIFFReadRawStrip(input, stripIndex, rowbuf, spp * ((stripIndex < StripsPerImage) ? rps :LastStripSize) * XSIZE * (bpp/8));\n                    }\n                    else{\n                        TIFFReadEncodedStrip(input, stripIndex, rowbuf, spp * ((stripIndex < StripsPerImage) ? rps :LastStripSize) * XSIZE * (bpp/8));\n                    }\n                }\n                bufptr = rowbuf + (i % rps) * (spp * XSIZE * (bpp/8));\n                if ( bpp == 8 )\n                    for (int j=0, j1=startj; j<=(endj-startj); j++, j1++) {\n                        for (int c=0; c<spp; c++) {\n                            buf[j * spp + c] = bufptr[j1 * spp + c];\n                        }\n                    }\n                else\n                    for (int j=0 , j1=startj; j<=(endj-startj); j++, j1++) {\n                        for (int c=0; c<spp; c++) {\n                            ((uint16 *)buf)[j * spp + c] = ((uint16 *)bufptr)[j1 * spp + c];\n                        }\n                    }\n                buf = buf + spp * (endj-startj+1) * (bpp/8);\n            }\n\n            page++;\n\n        }while ( page < static_cast<int>(last-first+1) );\n\n        delete []rowbuf;\n\n    }\n\n    if ( page < static_cast<int>(last-first+1) ){\n        return;\n    }\n\n    //\n    TIFFClose(input);\n    ssclear(dataStreamInMemory);\n\n    // swap the data bytes if necessary\n    if (b_swap)\n    {\n        int i;\n        size_t total = img_width * img_height * spp * (last-first+1);\n        if (bpp/8 == 2)\n        {\n            for (i=0;i<total; i++)\n            {\n                swap2bytes((void *)(img+2*i));\n            }\n        }\n        else if (bpp/8 == 4)\n        {\n            for (i=0;i<total; i++)\n            {\n                swap4bytes((void *)(img+4*i));\n            }\n        }\n    }\n\n    //\n    return;\n}",
    "unsigned char *readtiff(char *myfile, int *width, int *height, int *depth, int *channels )\n//================================================================================\n\n{\n    TIFF* tif = TIFFOpen(myfile, \"r\");\n    if (tif)\n    {\n\t\t*depth = 0;\n\t\tdo\n\t\t{\n\t\t\t(*depth)++;\n\t\t\tuint16 compression, cc, bpp         ;\n\t\t\t\n\t\t\t//check if we are reading a compressed image. If so\n\t\t\t//return with an error\n\t\t\tTIFFGetField(tif, TIFFTAG_COMPRESSION, &compression);\n\t\t\t\n\t\t\tif ( compression != COMPRESSION_NONE )\n\t\t\t{\n\t\t\t\tcerr<<\"File is not an Uncompressed TIFF image !\\n\";\n\t\t\t}\n\t\t\t\n\t\t\t//check if the image has 8 bits-per-pixel in each channel\n\t\t\tTIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bpp);\n\t\t\t\n\t\t\tif ( bpp != 8 )\n\t\t\t{\n\t\t\t\tcerr<<\"File does not have 8 bits per channel !\\n\";\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t//read the dimensions of the TIFF image\n\t\t\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH , width);//width\n\t\t\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, height);//height\n\t\t\t//determine what type of image is it (color or grayscale)\n\t\t\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &cc);\n\t\t\t\n\t\t\t//get the photometric if a grayscale image is\n\t\t\t//being read\n\t\t\tif (cc == 1)\n\t\t\t{\n\t\t\t\t*channels = 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t*channels = 3;\n\t\t\t}\n\t\t}while(TIFFReadDirectory(tif));\n\t\t\n\t\tTIFFClose(tif);\n\t}\n\telse\n    {\n        cerr<<\"Unable to open file for reading !\\n\";\n    }\n\t\n\t\n\ttif = TIFFOpen(myfile,\"r\");\n\tif(tif)\n\t{\n\t\tunsigned char *img = new unsigned char[(*channels)*(*width)*(*height)*(*depth)];\n\t\tint layer = 0;\n\t\tdo\n\t\t{\t\t\t\n\t\t\tuint16 p, compression, cc, bpp;\n\t\t\t\n\t\t\t//check if we are reading a compressed image. If so\n\t\t\t//return with an error\n\t\t\tTIFFGetField(tif, TIFFTAG_COMPRESSION, &compression);\n\t\t\t\n\t\t\tif ( compression != COMPRESSION_NONE )\n\t\t\t{\n\t\t\t\tcerr<<\"File is not an Uncompressed TIFF image !\\n\";\n\t\t\t}\n\t\t\t\n\t\t\t//check if the image has 8 bits-per-pixel in each channel\n\t\t\tTIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bpp);\n\t\t\t\n\t\t\tif ( bpp != 8 )\n\t\t\t{\n\t\t\t\tcerr<<\"File does not have 8 bits per channel !\\n\";\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t//read the dimensions of the TIFF image\n\t\t\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH , width);//width\n\t\t\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, height);//height\n\t\t\t//determine what type of image is it (color or grayscale)\n\t\t\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &cc);\n\t\t\t\n\t\t\t//get the photometric if a grayscale image is\n\t\t\t//being read\n\t\t\tif (cc == 1)\n\t\t\t{\n\t\t\t\t*channels = 1;\n\t\t\t\tTIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &p);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t*channels = 3;\n\t\t\t}\n\t\t\t\n\t\t\t//create the matrix to hold the image data\n\t\t\t\n\t\t\t//create a dummy array\n\t\t\tint linebytes = (*channels)*(*width);\n\t\t\tunsigned char *buf = new unsigned char[linebytes];\n\t\t\t\n\t\t\t//start reading the data from the TIFF file in scanlines\n\t\t\tfor ( int row = 0; row < *height; row++ )\n\t\t\t{\n\t\t\t\tif(TIFFReadScanline(tif, buf, row, 0) != 1)\n\t\t\t\t{\n\t\t\t\t\tcerr<<\"Error reading TIFF scanline !\\n\";\n\t\t\t\t}\n\t\t\t\tmemcpy(&img[layer*(*channels)*(*width)*(*height)+row*linebytes], buf, linebytes);\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tdelete(buf);\n\t\t\n\t\t\tlayer++;\n\t\t} while(TIFFReadDirectory(tif));\n\t\t\t\n        TIFFClose(tif);\n\t\t\n\t\treturn img;\n    }\n\t\n\treturn NULL;\n}",
    "char *tiffread(const char* filename, unsigned char *&p, uint32 &sz0, uint32  &sz1, uint32  &sz2, uint16 &datatype)\n{\n    //\n    TIFF *input = TIFFOpen(filename,\"r\");\n    if (!input)\n    {\n        return ((char *) \"Cannot open the file.\");\n    }\n\n    if (!TIFFGetField(input, TIFFTAG_IMAGEWIDTH, &sz0))\n    {\n        TIFFClose(input);\n        return ((char *) \"Image width of undefined.\");\n    }\n\n    if (!TIFFGetField(input, TIFFTAG_IMAGELENGTH, &sz1))\n    {\n        TIFFClose(input);\n        return ((char *) \"Image length of undefined.\");\n    }\n\n    if (!TIFFGetField(input, TIFFTAG_BITSPERSAMPLE, &datatype))\n    {\n        TIFFClose(input);\n        return ((char *) \"Undefined bits per sample.\");\n    }\n\n    uint16 Cpage;\n    if (!TIFFGetField(input, TIFFTAG_PAGENUMBER, &Cpage, &sz2) || sz2==0)\n    {\n        sz2 = 1;\n        while ( TIFFReadDirectory(input) )\n        {\n            sz2++;\n        }\n    }\n    datatype /= 8;\n\n    //cout<<\"test \"<<sz0<<\" \"<<sz1<<\" \"<<sz2<<\" \"<<datatype<<endl;\n\n    V3DLONG imgsz = (V3DLONG)sz0*(V3DLONG)sz1*(V3DLONG)sz2*(V3DLONG)datatype;\n\n    //\n    try\n    {\n        p = new unsigned char [imgsz];\n    }\n    catch(...)\n    {\n        return ((char*) \"fail to alloc memory for loading a tiff image.\");\n    }\n\n    //\n    uint32 rps;\n    int StripsPerImage,LastStripSize;\n\n    //\n    if (!TIFFGetField(input, TIFFTAG_ROWSPERSTRIP, &rps))\n    {\n        TIFFClose(input);\n        return ((char *) \"Undefined rowsperstrip.\");\n    }\n\n    uint16 comp;\n    if (!TIFFGetField(input, TIFFTAG_COMPRESSION, &comp))\n    {\n        TIFFClose(input);\n        return ((char *) \"Undefined compression.\");\n    }\n\n    StripsPerImage =  (sz1 + rps - 1) / rps;\n    LastStripSize = sz1 % rps;\n    if (LastStripSize==0)\n        LastStripSize=rps;\n\n    if (!TIFFSetDirectory(input, 0)) // init\n    {\n        TIFFClose(input);\n        return ((char *) \"fail to setdir.\");\n    }\n\n    unsigned char *buf = p;\n    do{\n        for (int i=0; i < StripsPerImage-1; i++)\n        {\n            cout<<\"i \"<<i<<endl;\n\n            if (comp==1)\n            {\n                TIFFReadRawStrip(input, i, buf,  rps * sz0 * datatype);\n                buf = buf + rps * sz0 * datatype;\n            }\n            else\n            {\n                TIFFReadEncodedStrip(input, i, buf, rps * sz0 * datatype);\n                buf = buf + rps * sz0 * datatype;\n            }\n        }\n\n        if (comp==1)\n        {\n            TIFFReadRawStrip(input, StripsPerImage-1, buf, LastStripSize * sz0 * datatype);\n        }\n        else\n        {\n            TIFFReadEncodedStrip(input, StripsPerImage-1, buf, LastStripSize * sz0 * datatype);\n        }\n        buf = buf + LastStripSize * sz0 * datatype;\n\n    } while(TIFFReadDirectory(input));\n\n    //\n    TIFFClose(input);\n\n    //\n    return ((char *) 0);\n}",
    "char *loadTiff3D2Metadata ( char * filename, unsigned int &sz0, unsigned int  &sz1, unsigned int  &sz2, unsigned int  &sz3, int &datatype, int &b_swap, void * &fhandle, int &header_len ) {\r\n\r\n    // 2015-01-30. Alessandro. @ADDED performance (time) measurement in all most time-consuming methods.\r\n    #ifdef _VAA3D_TERAFLY_PLUGIN_MODE\r\n    TERAFLY_TIME_START(TiffLoadMetadata)\r\n    #endif\r\n\r\n\tuint32 XSIZE;\r\n\tuint32 YSIZE;\r\n\tuint16 bpp;\r\n\tuint16 spp;\r\n\tuint16 Cpage;\r\n\tuint16 Npages;\r\n    TIFF *input;\r\n    int check;\r\n\r\n\tinput=TIFFOpen(filename,\"r\");\r\n\tif (!input)\r\n    {\r\n\t\t//throw iim::IOException(strprintf(\"in IOManager::readTiffMultipage(...): Cannot open the file %s\",finName).c_str());\r\n\t\treturn ((char *) \"Cannot open the file.\");\r\n    }\r\n\r\n\tcheck=TIFFGetField(input, TIFFTAG_IMAGEWIDTH, &XSIZE);\r\n\tif (!check)\r\n\t{\r\n\t\tTIFFClose(input);\r\n\t\t//throw iim::IOException(strprintf(\"in IOManager::readTiffMultipage(...): Image length of %s undefined\\n\", finName).c_str());\r\n\t\treturn ((char *) \"Image width of undefined.\");\r\n\t}\t\t\r\n    \r\n\tcheck=TIFFGetField(input, TIFFTAG_IMAGELENGTH, &YSIZE);\r\n\tif (!check)\r\n\t{\r\n\t\tTIFFClose(input);\r\n\t\t//throw iim::IOException(strprintf(\"in IOManager::readTiffMultipage(...): Image length of %s undefined\\n\", finName).c_str());\r\n\t\treturn ((char *) \"Image length of undefined.\");\r\n\t}\t\t\r\n    \r\n\tcheck=TIFFGetField(input, TIFFTAG_BITSPERSAMPLE, &bpp); \r\n\tif (!check)\r\n\t{\r\n\t\tTIFFClose(input);\r\n\t\t//throw iim::IOException(strprintf(\"in IOManager::readTiffMultipage(...): Undefined bits per sample in %s \\n\", finName).c_str());\r\n\t\treturn ((char *) \"Undefined bits per sample.\");\r\n\t}\r\n\r\n\tcheck=TIFFGetField(input, TIFFTAG_SAMPLESPERPIXEL, &spp);\r\n\tif (!check)\r\n\t{\r\n\t\tTIFFClose(input);\r\n\t\t//throw iim::IOException(strprintf(\"in IOManager::readTiffMultipage(...): Undefined bits per sample in %s \\n\", finName).c_str());\r\n\t\treturn ((char *) \"Undefined samples per pixel.\");\r\n\t}\r\n\r\n\t// Onofri\r\n\tcheck=TIFFGetField(input, TIFFTAG_PAGENUMBER, &Cpage, &Npages);\r\n\tif (!check || Npages==0) { // the tag has not been read correctly\r\n\t\t// Add warning?\r\n\t\tNpages = 0;\r\n\t\tdo {\r\n\t\t\tNpages++;\r\n\t\t} while ( TIFFReadDirectory(input) );\r\n\t}\r\n\r\n\tsz0 = XSIZE;\r\n\tsz1 = YSIZE;\r\n\tsz2 = Npages;\r\n\tsz3 = spp;\r\n\tdatatype = bpp/8;\r\n\r\n\t//b_swap = 0;\r\n\tb_swap=TIFFIsByteSwapped(input);\r\n\tfhandle = (void *) input;\r\n\theader_len = -1;\r\n\r\n\t// the file must non be closed (it is responsibility of the caller)\r\n\t//TIFFClose(input);\r\n\r\n    // 2015-01-30. Alessandro. @ADDED performance (time) measurement in all most time-consuming methods.\r\n    #ifdef _VAA3D_TERAFLY_PLUGIN_MODE\r\n    TERAFLY_TIME_STOP(TiffLoadMetadata, itm::IO, itm::strprintf(\"successfully loaded metadata from file \\\"%s\\\"\", filename))\r\n    #endif\r\n\r\n\treturn ((char *) 0);\r\n}",
    "char *readTiff3DFile2Buffer ( void *fhandler, unsigned char *img, unsigned int img_width, unsigned int img_height, unsigned int first, unsigned int last, int b_swap ) {\r\n\tuint32 rps;\r\n    uint16 spp, bpp, photo, comp, planar_config;\r\n    int check, StripsPerImage,LastStripSize;\r\n\r\n    TIFF *input = (TIFF *) fhandler;\r\n\r\n\tcheck=TIFFGetField(input, TIFFTAG_ROWSPERSTRIP, &rps);\r\n\tif (!check)\r\n\t{\r\n\t\treturn ((char *) \"Image length of undefined.\");\r\n\t}\t\r\n\t//rps=600;\r\n    \r\n\tcheck=TIFFGetField(input, TIFFTAG_BITSPERSAMPLE, &bpp); \r\n\tif (!check)\r\n\t{\r\n\t\treturn ((char *) \"Undefined bits per sample.\");\r\n\t}\r\n\r\n\tcheck=TIFFGetField(input, TIFFTAG_SAMPLESPERPIXEL, &spp);\r\n\tif (!check)\r\n\t{\r\n\t\treturn ((char *) \"Undefined samples per pixel.\");\r\n\t}\r\n\r\n\tcheck=TIFFGetField(input, TIFFTAG_PHOTOMETRIC, &photo);\r\n\tif (!check)\r\n\t{\r\n\t\treturn ((char *) \"Cannot determine photometric interpretation.\");\r\n\t}\r\n\r\n\tcheck=TIFFGetField(input, TIFFTAG_COMPRESSION, &comp);\r\n\tif (!check)\r\n\t{\r\n\t\treturn ((char *) \"Cannot determine compression technique.\");\r\n\t}\r\n\r\n\tcheck=TIFFGetField(input, TIFFTAG_PLANARCONFIG, &planar_config);\r\n\tif (!check)\r\n\t{\r\n\t\treturn ((char *) \"Cannot determine planar configuration.\");\r\n\t}\r\n\r\n\r\n\tStripsPerImage =  (img_height + rps - 1) / rps;\r\n\tLastStripSize = img_height % rps;\r\n\tif (LastStripSize==0)\r\n\t\tLastStripSize=rps;\r\n\r\n\tcheck=TIFFSetDirectory(input, first);\r\n\tif (!check)\r\n\t{\r\n\t\treturn ((char *) \"Cannot open the requested first strip.\");\r\n\t}\r\n\r\n\tunsigned char *buf = img;\r\n\tint page=0;\r\n\tdo{\r\n\r\n\t\tfor (int i=0; i < StripsPerImage-1; i++){\r\n\t\t\tif (comp==1) {\r\n\t\t\t\tTIFFReadRawStrip(input, i, buf, spp * rps * img_width * (bpp/8));\r\n\t\t\t\tbuf = buf + spp * rps * img_width * (bpp/8);\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\tTIFFReadEncodedStrip(input, i, buf, spp * rps * img_width * (bpp/8));\r\n\t\t\t\tbuf = buf + spp * rps * img_width * (bpp/8);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (comp==1) {\r\n\t\t\tTIFFReadRawStrip(input, StripsPerImage-1, buf, spp * LastStripSize * img_width * (bpp/8));\r\n\t\t}\r\n\t\telse{\r\n\t\t\tTIFFReadEncodedStrip(input, StripsPerImage-1, buf, spp * LastStripSize * img_width * (bpp/8));\r\n\t\t}\r\n\t\tbuf = buf + spp * LastStripSize * img_width * (bpp/8);\r\n\r\n\t\tpage++;\r\n\t\r\n\t}while ( page < static_cast<int>(last-first+1) && TIFFReadDirectory(input));//while (TIFFReadDirectory(input));\r\n\r\n\t// input file is assumedo ti be already open and it is provided as an handler; the file should be closed by caller\r\n\t//TIFFClose(input);  \r\n\r\n\tif ( page < static_cast<int>(last-first+1) ){\r\n\t\treturn ((char *) \"Cannot read all the pages.\");\r\n\t}\r\n\r\n\t// swap the data bytes if necessary \t\r\n\tif (b_swap)\r\n\t{\r\n\t\tint i;\r\n\t\tsize_t total = img_width * img_height * spp * (last-first+1);\r\n\t\tif (bpp/8 == 2)\r\n\t\t{\r\n\t\t\tfor (i=0;i<total; i++)\r\n\t\t\t{\r\n\t\t\t\tswap2bytes((void *)(img+2*i));\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (bpp/8 == 4)\r\n\t\t{\r\n\t\t\tfor (i=0;i<total; i++)\r\n\t\t\t{\r\n\t\t\t\tswap4bytes((void *)(img+4*i));\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn (char *) 0;\r\n}",
    "char *tiffread(char* filename, unsigned char *&p, uint32 &sz0, uint32  &sz1, uint32  &sz2, uint16 &datatype, uint16 &comp)\n{\n    //\n    TIFF *input = TIFFOpen(filename,\"r\");\n    if (!input)\n    {\n        return ((char *) \"Cannot open the file.\");\n    }\n\n    if (!TIFFGetField(input, TIFFTAG_IMAGEWIDTH, &sz0))\n    {\n        TIFFClose(input);\n        return ((char *) \"Image width of undefined.\");\n    }\n\n    if (!TIFFGetField(input, TIFFTAG_IMAGELENGTH, &sz1))\n    {\n        TIFFClose(input);\n        return ((char *) \"Image length of undefined.\");\n    }\n\n    if (!TIFFGetField(input, TIFFTAG_BITSPERSAMPLE, &datatype))\n    {\n        TIFFClose(input);\n        return ((char *) \"Undefined bits per sample.\");\n    }\n\n    uint16 Cpage;\n    if (!TIFFGetField(input, TIFFTAG_PAGENUMBER, &Cpage, &sz2) || sz2==0)\n    {\n        sz2 = 1;\n        while ( TIFFReadDirectory(input) )\n        {\n            sz2++;\n        }\n    }\n    datatype /= 8;\n\n    //cout<<\"test \"<<sz0<<\" \"<<sz1<<\" \"<<sz2<<\" \"<<datatype<<endl;\n\n    long imgsz = (long)sz0*(long)sz1*(long)sz2*(long)datatype;\n\n    //\n    try\n    {\n        p = new unsigned char [imgsz];\n    }\n    catch(...)\n    {\n        return ((char*) \"fail to alloc memory for loading a tiff image.\");\n    }\n\n    //\n    uint32 rps;\n    int StripsPerImage,LastStripSize;\n\n    //\n    if (!TIFFGetField(input, TIFFTAG_ROWSPERSTRIP, &rps))\n    {\n        TIFFClose(input);\n        return ((char *) \"Undefined rowsperstrip.\");\n    }\n\n    if (!TIFFGetField(input, TIFFTAG_COMPRESSION, &comp))\n    {\n        TIFFClose(input);\n        return ((char *) \"Undefined compression.\");\n    }\n\n    StripsPerImage =  (sz1 + rps - 1) / rps;\n    LastStripSize = sz1 % rps;\n    if (LastStripSize==0)\n        LastStripSize=rps;\n\n    if (!TIFFSetDirectory(input, 0)) // init\n    {\n        TIFFClose(input);\n        return ((char *) \"fail to setdir.\");\n    }\n\n    unsigned char *buf = p;\n\n    do{\n        for (int i=0; i < StripsPerImage-1; i++)\n        {\n            if (comp==1)\n            {\n                TIFFReadRawStrip(input, i, buf,  rps * sz0 * datatype);\n                buf = buf + rps * sz0 * datatype;\n            }\n            else\n            {\n                TIFFReadEncodedStrip(input, i, buf, rps * sz0 * datatype);\n                buf = buf + rps * sz0 * datatype;\n            }\n        }\n\n        if (comp==1)\n        {\n            TIFFReadRawStrip(input, StripsPerImage-1, buf, LastStripSize * sz0 * datatype);\n        }\n        else\n        {\n            TIFFReadEncodedStrip(input, StripsPerImage-1, buf, LastStripSize * sz0 * datatype);\n        }\n        buf = buf + LastStripSize * sz0 * datatype;\n\n    }\n    while (TIFFReadDirectory(input)); // while (TIFFReadDirectory(input));\n\n    //\n    TIFFClose(input);\n\n    //\n    return ((char *) 0);\n}",
    "void \r\n\tiomanager::tiff3D::readMetadata(\r\n\tstd::string img_path,\t\t// (INPUT)\timage filepath\r\n\tint & img_width,\t\t\t// (OUTPUT) image width  (in pixels)\r\n\tint & img_height,\t\t\t// (OUTPUT) image height (in pixels)\r\n\tint & img_depth,\t\t\t// (OUTPUT) image depth (in pixels)\r\n\tint & img_bytes_x_chan,\t// (OUTPUT) number of bytes per channel\r\n\tint & img_chans,\t\t\t// (OUTPUT) number of channels\r\n\tconst std::string & params)\t// (INPUT)\tadditional parameters <param1=val, param2=val, ...> \r\nthrow (iom::exception)\r\n{\r\n\t/**/iom::debug(iom::LEV3, iom::strprintf(\"img_path = %s, img_width = %d, img_height = %d, img_depth = %d, img_bytes_x_chan = %d, img_chans = %d, params = \\\"%s\\\"\",\r\n\t\timg_path.c_str(), img_width, img_height, img_depth,\timg_bytes_x_chan, img_chans, params.c_str()).c_str(), __iom__current__function__);\r\n\r\n\t// disable warning handler to avoid messages on unrecognized tags\r\n\tTIFFSetWarningHandler(0);\r\n\r\n\tTIFF* input=TIFFOpen(img_path.c_str(),\"r\");\r\n\tif (!input)\r\n\t\tthrow iom::exception(iom::strprintf(\"unable to open image \\\"%s\\\". Possible unsupported format or it isn't an image.\\nSupported format is 3DTIFF\", img_path.c_str()), __iom__current__function__);\r\n\r\n\tif (!TIFFGetField(input, TIFFTAG_IMAGEWIDTH, &img_width))\r\n\t\tthrow iom::exception(iom::strprintf(\"unable to determine 'TIFFTAG_IMAGEWIDTH' from image \\\"%s\\\". \", img_path.c_str()), __iom__current__function__);\r\n\r\n\tif (!TIFFGetField(input, TIFFTAG_IMAGELENGTH, &img_height))\r\n\t\tthrow iom::exception(iom::strprintf(\"unable to determine 'TIFFTAG_IMAGELENGTH' from image \\\"%s\\\". \", img_path.c_str()), __iom__current__function__);\r\n\r\n\tif (!TIFFGetField(input, TIFFTAG_BITSPERSAMPLE, &img_bytes_x_chan))\r\n\t\tthrow iom::exception(iom::strprintf(\"unable to determine 'TIFFTAG_BITSPERSAMPLE' from image \\\"%s\\\". \", img_path.c_str()), __iom__current__function__);\r\n\timg_bytes_x_chan /= 8;\r\n\r\n\tif (!TIFFGetField(input, TIFFTAG_SAMPLESPERPIXEL, &img_chans)) \r\n\t\tthrow iom::exception(iom::strprintf(\"unable to determine 'TIFFTAG_SAMPLESPERPIXEL' from image \\\"%s\\\". \", img_path.c_str()), __iom__current__function__);\r\n\r\n\t// Onofri\r\n\tuint16 cpage;  // Current page. We do not actually need it.\r\n\tuint16 npages; // Number of pages. \r\n\tint PNcheck=TIFFGetField(input, TIFFTAG_PAGENUMBER, &cpage, &npages);\r\n\tif (!PNcheck || npages==0) { // the tag has not been read correctly\r\n\t\tiom::warning(iom::strprintf(\"unable to determine 'TIFFTAG_PAGENUMBER' from image file \\\"%s\\\". \", img_path.c_str()).c_str(),__iom__current__function__);\r\n\t\timg_depth = 0;\r\n\t\tdo {\r\n\t\t\timg_depth++;\r\n\t\t} while (TIFFReadDirectory(input));\r\n\t}\r\n\telse\r\n\t\timg_depth = npages;\r\n\r\n\tTIFFClose(input);\r\n}",
    "void \r\n\tiomanager::tiff2D::readMetadata(\r\n\tstd::string img_path,\t\t\t// (INPUT)  image filepath\r\n\tint & img_width,\t\t\t\t// (OUTPUT) image width  (in pixels)\r\n\tint & img_height,\t\t\t\t// (OUTPUT) image height (in pixels)\r\n\tint & img_bytes_x_chan,\t\t\t// (OUTPUT) number of bytes per channel\r\n\tint & img_chans,\t\t\t\t// (OUTPUT) number of channels\r\n\tconst std::string & params)\t\t// (INPUT)  additional parameters <param1=val, param2=val, ...> \r\nthrow (iom::exception)\r\n{\r\n\t/**/iom::debug(iom::LEV3, iom::strprintf(\"img_path = \\\"%s\\\", params = \\\"%s\\\"\",img_path.c_str(), params.c_str()).c_str(), __iom__current__function__);\r\n\r\n\tuint16 bpp;\r\n\tuint16 spp;\r\n\r\n\t // disable warning handler to avoid messages on unrecognized tags\r\n\tTIFFSetWarningHandler(0);\r\n\r\n\tTIFF* input=TIFFOpen(img_path.c_str(),\"r\");\r\n\tif (!input)\r\n\t\tthrow iom::exception(iom::strprintf(\"unable to open image \\\"%s\\\". Possible unsupported format or it isn't an image.\\nSupported format is 2DTIFF\", img_path.c_str()), __iom__current__function__);\r\n\r\n\tif (!TIFFGetField(input, TIFFTAG_IMAGEWIDTH, &img_width))\r\n\t\tthrow iom::exception(iom::strprintf(\"unable to determine 'TIFFTAG_IMAGEWIDTH' from image \\\"%s\\\". \", img_path.c_str()), __iom__current__function__);\r\n\r\n\tif (!TIFFGetField(input, TIFFTAG_IMAGELENGTH, &img_height))\r\n\t\tthrow iom::exception(iom::strprintf(\"unable to determine 'TIFFTAG_IMAGELENGTH' from image \\\"%s\\\". \", img_path.c_str()), __iom__current__function__);\r\n\r\n\tif (!TIFFGetField(input, TIFFTAG_BITSPERSAMPLE, &bpp))\r\n\t\tthrow iom::exception(iom::strprintf(\"unable to determine 'TIFFTAG_BITSPERSAMPLE' from image \\\"%s\\\". \", img_path.c_str()), __iom__current__function__);\r\n\timg_bytes_x_chan = bpp/8;\r\n\r\n\tif (!TIFFGetField(input, TIFFTAG_SAMPLESPERPIXEL, &spp)) \r\n\t\tthrow iom::exception(iom::strprintf(\"unable to determine 'TIFFTAG_SAMPLESPERPIXEL' from image \\\"%s\\\". \", img_path.c_str()), __iom__current__function__);\r\n\timg_chans = spp;\r\n\r\n\t// Onofri\r\n\tint img_depth;\t\t\t// image depth (in pixels)\r\n\tuint16 cpage;  // Current page. We do not actually need it.\r\n\tuint16 npages; // Number of pages. \r\n\tint PNcheck=TIFFGetField(input, TIFFTAG_PAGENUMBER, &cpage, &npages);\r\n\tif (!PNcheck || npages==0) { // the tag has not been read correctly\r\n\t\tiom::warning(iom::strprintf(\"unable to determine 'TIFFTAG_PAGENUMBER' from image file \\\"%s\\\". \", img_path.c_str()).c_str(),__iom__current__function__);\r\n\t\timg_depth = 0;\r\n\t\tdo {\r\n\t\t\timg_depth++;\r\n\t\t} while (TIFFReadDirectory(input));\r\n\t}\r\n\telse\r\n\t\timg_depth = npages;\r\n\r\n\tTIFFClose(input);\r\n\t\r\n\t// check the exception after closing the file\r\n\tif ( img_depth > 1 ) \r\n\t\tthrow iom::exception(iom::strprintf(\"image \\\"%s\\\" has more than one page.\\nSupported format is 2DTIFF\", img_path.c_str()), __iom__current__function__);\r\n}",
    "char *loadTiff3D2Metadata ( char * filename, unsigned int &sz0, unsigned int  &sz1, unsigned int  &sz2, unsigned int  &sz3, int &datatype, int &b_swap, void * &fhandle, int &header_len ) {\r\n\r\n    // 2015-01-30. Alessandro. @ADDED performance (time) measurement in all most time-consuming methods.\r\n    #ifdef _VAA3D_TERAFLY_PLUGIN_MODE\r\n    TERAFLY_TIME_START(TiffLoadMetadata);\r\n    #endif\r\n\r\n    uint32 XSIZE;\r\n    uint32 YSIZE;\r\n    uint16 bpp;\r\n    uint16 spp;\r\n    uint16 Cpage;\r\n    uint16 Npages;\r\n    TIFF *input;\r\n    int check;\r\n\r\n    //disable warning and error handlers to avoid messages on unrecognized tags\r\n    TIFFSetWarningHandler(0);\r\n    TIFFSetErrorHandler(0);\r\n\r\n    input=TIFFOpen(filename,\"r\");\r\n    if (!input)\r\n    {\r\n        //throw iim::IOException(strprintf(\"in IOManager::readTiffMultipage(...): Cannot open the file %s\",finName).c_str());\r\n        return ((char *) \"Cannot open the file.\");\r\n    }\r\n\r\n    check=TIFFGetField(input, TIFFTAG_IMAGEWIDTH, &XSIZE);\r\n    if (!check)\r\n    {\r\n        TIFFClose(input);\r\n        //throw iim::IOException(strprintf(\"in IOManager::readTiffMultipage(...): Image length of %s undefined\\n\", finName).c_str());\r\n        return ((char *) \"Image width of undefined.\");\r\n    }\r\n    \r\n    check=TIFFGetField(input, TIFFTAG_IMAGELENGTH, &YSIZE);\r\n    if (!check)\r\n    {\r\n        TIFFClose(input);\r\n        //throw iim::IOException(strprintf(\"in IOManager::readTiffMultipage(...): Image length of %s undefined\\n\", finName).c_str());\r\n        return ((char *) \"Image length of undefined.\");\r\n    }\r\n    \r\n    check=TIFFGetField(input, TIFFTAG_BITSPERSAMPLE, &bpp);\r\n    if (!check)\r\n    {\r\n        TIFFClose(input);\r\n        //throw iim::IOException(strprintf(\"in IOManager::readTiffMultipage(...): Undefined bits per sample in %s \\n\", finName).c_str());\r\n        return ((char *) \"Undefined bits per sample.\");\r\n    }\r\n\r\n    check=TIFFGetField(input, TIFFTAG_SAMPLESPERPIXEL, &spp);\r\n    if (!check)\r\n    {\r\n        spp = 1;\r\n        //TIFFClose(input);\r\n        //throw iim::IOException(strprintf(\"in IOManager::readTiffMultipage(...): Undefined bits per sample in %s \\n\", finName).c_str());\r\n        //return ((char *) \"Undefined samples per pixel.\");\r\n    }\r\n\r\n    // Onofri\r\n    check=TIFFGetField(input, TIFFTAG_PAGENUMBER, &Cpage, &Npages);\r\n    if (!check || Npages==0) { // the tag has not been read correctly\r\n        // Add warning?\r\n        Npages = 0;\r\n        do {\r\n            Npages++;\r\n        } while ( TIFFReadDirectory(input) );\r\n    }\r\n\r\n    sz0 = XSIZE;\r\n    sz1 = YSIZE;\r\n    sz2 = Npages;\r\n    sz3 = spp;\r\n    datatype = bpp/8;\r\n\r\n    //b_swap = 0;\r\n    b_swap=TIFFIsByteSwapped(input);\r\n    fhandle = (void *) input;\r\n    header_len = -1;\r\n\r\n    // the file must non be closed (it is responsibility of the caller)\r\n    //TIFFClose(input);\r\n\r\n    // 2015-01-30. Alessandro. @ADDED performance (time) measurement in all most time-consuming methods.\r\n    #ifdef _VAA3D_TERAFLY_PLUGIN_MODE\r\n    TERAFLY_TIME_STOP(TiffLoadMetadata, tf::IO, tf::strprintf(\"successfully loaded metadata from file \\\"%s\\\"\", filename));\r\n    #endif\r\n\r\n    return ((char *) 0);\r\n}",
    "int loadLsm2Stack(char * filename, unsigned char * & img, long * & sz, int & datatype)\n{\n\tint berror=0;\n\t\n\tTIFF  *tif=0;\n\tint depth, width, height;\n\tshort bits, colorchannels;\n\t\n\ttif = Open_Tiff(filename,\"r\");\n\tif (!tif) \n\t{\n\t\tfprintf(stderr, \"Cannot open the specified LSM file in loadLsm2Stack(). \\n\");\n\t\treturn 1; //070805, by Hanchuan Peng\n\t}\n\t\n\tdepth = 1;\n\twhile (TIFFReadDirectory(tif))\n\t\tdepth += 1;\n\tTIFFClose(tif);\n\t\n\tprintf(\"Total # of directories is %d, half of them are thumbnails So real data have %d slices.\\n\", depth, depth/2);\n\tdepth = depth / 2;\t\t/* half the dirs are thumbnails */\n\t\n\ttif = Open_Tiff(filename,\"r\");\n\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &colorchannels); \n\tTIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bits);\n\t\n\tif (bits<=8 && bits>0) datatype=1;\n\telse if (bits<=16 && bits>0) datatype=2;\n\telse \n\t{\n\t\tfprintf(stderr, \"LSM file should not support more than 16 bits data. Check the codes in loadLsm2Stack(). \\n\");\n\t\treturn 1; //070805, by Hanchuan Peng\n\t}\n\t\n\tlong pixel_per_slice, pixel_per_channel, ntotalpixel;\n\tif (sz) {delete []sz; sz=0;}\n\tsz = new long [4]; /* reallocate the memory if the input parameter is non-null. Note that this requests the input is also an NULL point, the same to img. */\n\tif (!sz)  \n\t{\n\t\tfprintf(stderr,\"Fail to allocate memory.\\n\");\n\t\tberror = 1;\n\t\treturn berror;\n\t}\n\telse\n\t{\n\t\tsz[0] = width;\n\t\tsz[1] = height;\n\t\tsz[2] = depth;\n\t\tsz[3] = colorchannels;\n\t\tpixel_per_slice = long(width)*long(height);\n\t\tpixel_per_channel = pixel_per_slice*long(depth);\n\t\tntotalpixel = pixel_per_channel*colorchannels;\n\t}\n\t\n\tif (img) {delete []img; img=0;}\n\telse \n\t{\n\t\timg = new unsigned char [long(ntotalpixel)*long(datatype)];\n\t\tif (!img)\n\t\t{\n\t\t\tfprintf(stderr,\"Fail to allocate memory.\\n\");\n\t\t\tif (sz) {delete []sz;sz=0;}\n\t\t\tberror = 1;\n\t\t\treturn berror;\n\t\t}\n\t}\n\t\n\t// read every other directory (real data, the in between are thumbnails \n\tlong d;\n\tshort cur_colorchannels, cur_bits;\n\tint cur_width, cur_height;\n\tfor (d=0;d<depth;d++)\n\t{\n\t\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &cur_width);\n\t\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &cur_height);\n\t\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &cur_colorchannels); \n\t\tTIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &cur_bits);\n\n\t\tprintf(\"d=%ld, current width=%d, height=%d, cur_colorchannels=%d, cur_bits=%d\\n\", d, cur_width, cur_height, cur_colorchannels, cur_bits); fflush(stdout); //080301\n\n\t\tif (cur_width != width || cur_height != height || cur_colorchannels!=colorchannels || cur_bits!=bits) \n\t\t{\n\t\t\tfprintf(stderr, \"The %ld Individual image slice has a different size/colorchannel/bits from the first slice!\", d);\n\t\t\t//in this case, do nothing to read the data and leave it empty\n\t\t}\n\t\telse\n\t\t{\n\t\t\tread_lsm_slice(tif, img+long(d)*long(pixel_per_slice)*long(datatype), pixel_per_slice, pixel_per_channel, datatype);\n\t\t}\n\t\t\n\t\tif (d==depth-1)\n\t\t\tbreak; //no need to do read directory anymore once the last one is read\n\t\telse\n\t\t{ \n\t\t\tif (!TIFFReadDirectory(tif)) break;\t  /* skip the one we just read, it's a thumbnail  */\n\t\t\tif (!TIFFReadDirectory(tif)) break;\t  /* get the next slice  */\n\t\t}\n\t}\n\t\n\tTIFFClose(tif);\n\t\n\t//return (stack);\n\treturn berror;\n}",
    "int loadLsmThumbnail2Stack_middle(char * filename, unsigned char * & img, long * & sz, int & datatype)\n{\n\tint berror=0;\n\t\n\tTIFF  *tif=0;\n\tint depth, width, height;\n\tshort bits, colorchannels;\n\t\n\ttif = Open_Tiff(filename,\"r\");\n\tif (!tif) \n\t{\n\t\tfprintf(stderr, \"Cannot open the specified LSM file in loadLsm2Stack(). \\n\");\n\t\treturn 1; //070805, by Hanchuan Peng\n\t}\n\t\n\tdepth = 1;\n\twhile (TIFFReadDirectory(tif))\n\t\tdepth += 1;\n\tTIFFClose(tif);\n\t\n\tprintf(\"Total # of directories is %d, half of them are thumbnails So real data have %d slices.\\n\", depth, depth/2);\n\tdepth = depth / 2;\t\t/* half the dirs are thumbnails */\n\t\n\ttif = Open_Tiff(filename,\"r\");\n\tTIFFReadDirectory(tif); //bypass a big image and get to the first thumbnail image\n\t\n\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &colorchannels); \n\tTIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bits);\n\n\tif (bits<=8 && bits>0) datatype=1;\n\telse if (bits<=16 && bits>0) datatype=2;\n\telse \n\t{\n\t\tfprintf(stderr, \"LSM file should not support more than 16 bits data. Check the codes in loadLsm2Stack(). \\n\");\n\t\treturn 1; //070805, by Hanchuan Peng\n\t}\n\t\n\tlong pixel_per_slice, pixel_per_channel, ntotalpixel;\n\tif (sz) {delete []sz; sz=0;}\n\tsz = new long [4]; /* reallocate the memory if the input parameter is non-null. Note that this requests the input is also an NULL point, the same to img. */\n\tif (!sz)  \n\t{\n\t\tfprintf(stderr,\"Fail to allocate memory.\\n\");\n\t\tberror = 1;\n\t\treturn berror;\n\t}\n\telse\n\t{\n\t\tsz[0] = width;\n\t\tsz[1] = height;\n\t\tsz[2] = 1;\n\t\tsz[3] = colorchannels;\n\t\tpixel_per_slice = long(width)*long(height);\n\t\tpixel_per_channel = pixel_per_slice*long(sz[2]);\n\t\tntotalpixel = pixel_per_channel*colorchannels;\n\t}\n\t\n\tif (img) {delete []img; img=0;}\n\telse \n\t{\n\t\timg = new unsigned char [long(ntotalpixel)*long(datatype)];\n\t\tif (!img)\n\t\t{\n\t\t\tfprintf(stderr,\"Fail to allocate memory.\\n\");\n\t\t\tif (sz) {delete []sz;sz=0;}\n\t\t\tberror = 1;\n\t\t\treturn berror;\n\t\t}\n\t}\n\t\n\t// read every other directory (real data, the in between are thumbnails )\n\t\n\tlong d;\n\tshort cur_colorchannels, cur_bits;\n\tint cur_width, cur_height;\n\tfor (d=0;d<=int(depth/2);d++)\n\t{\n\t\tif (d<int(depth/2))\n\t\t{\n\t\t\tTIFFReadDirectory(tif); //bypass a thumbnail \n\t\t\tTIFFReadDirectory(tif); //bypass a big image\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &cur_width);\n\t\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &cur_height);\n\t\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &cur_colorchannels); \n\t\tTIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &cur_bits);\n\n\t\tprintf(\"d=%ld, current width=%d, height=%d\\n\", d, cur_width, cur_height); fflush(stdout);\n\n\t\tif (cur_width != width || cur_height != height || cur_colorchannels!=colorchannels || cur_bits!=bits) \n\t\t{\n\t\t\tfprintf(stderr, \"The %ld Individual image slice has a different size/colorchannel/bits from the first slice!\", d);\n\t\t\t//in this case, do nothing to read the data and leave it empty\n\t\t}\n\t\telse\n\t\t{\n\t\t    //note that as we onlky read one slice here, the \"img+long(d)*long(pixel_per_slice)*long(datatype)\" equals \"img\"\n\t\t\tread_lsm_slice(tif, img, pixel_per_slice, pixel_per_channel, datatype);\n\t\t}\n\t\t\n\t\tbreak; //after we read one slice, then stop;\n\t}\n\t\n\tTIFFClose(tif);\n\t\n\treturn berror;\n}",
    "int loadLsmSlice(char * filename, unsigned char * & img, long * & sz, int & datatype, long sliceno, bool b_thumbnail)\n{\n\tint berror=0;\n\t\n\tif (sliceno<-2)\n\t{\n\t\tfprintf(stderr, \"The sliceno parameter is invalid. Must not <-2: -2 to read all slices, -1 to read middle only, 0 to N-1 to read the 1 to N-1 slice. If bigger than N-1, then just read the last slice.\\n\");\n\t\treturn 1; //070805, by Hanchuan Peng\n\t}\n\t\n\tTIFF  *tif=0;\n\tint depth, width, height;\n\tshort bits, colorchannels;\n\t\n\ttif = Open_Tiff(filename,\"r\");\n\tif (!tif) \n\t{\n\t\tfprintf(stderr, \"Cannot open the specified LSM file in loadLsmSlice(). \\n\");\n\t\treturn 1; //070805, by Hanchuan Peng\n\t}\n\t\n\tdepth = 1;\n\twhile (TIFFReadDirectory(tif))\n\t\tdepth += 1;\n\tTIFFClose(tif);\n\t\n\tprintf(\"%d\\n\", depth/2);\n\t//printf(\"Total # of directories is %d, half of them are thumbnails So real data have %d slices.\\n\", depth, depth/2);\n\tdepth = depth / 2;\t\t/* half the dirs are thumbnails */\n\tif (sliceno>depth-1) sliceno=depth-1; \n\t//printf(\"slice #=%d\\n\", sliceno);\n\t\n\ttif = Open_Tiff(filename,\"r\");\n\n\tif (b_thumbnail)\n\t\tTIFFReadDirectory(tif); //by pass one big image and get to the first thumbnail image\n\n\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &colorchannels); \n\tTIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bits);\n\t\n\tif (bits<=8 && bits>0) datatype=1;\n\telse if (bits<=16 && bits>0) datatype=2;\n\telse \n\t{\n\t\tfprintf(stderr, \"LSM file should not support more than 16 bits data. Check the codes in loadLsm2Slice(). \\n\");\n\t\treturn 1; //070805, by Hanchuan Peng\n\t}\n\t\n\tlong pixel_per_slice, pixel_per_channel, ntotalpixel;\n\tif (sz) {delete []sz; sz=0;}\n\tsz = new long [4]; /* reallocate the memory if the input parameter is non-null. Note that this requests the input is also an NULL point, the same to img. */\n\tif (!sz)  \n\t{\n\t\tfprintf(stderr,\"Fail to allocate memory.\\n\");\n\t\tberror = 1;\n\t\treturn berror;\n\t}\n\telse\n\t{\n\t\tsz[0] = width;\n\t\tsz[1] = height;\n\t\tsz[2] = (sliceno==-2) ? depth : 1;\n\t\tsz[3] = colorchannels;\n\t\tpixel_per_slice = long(sz[1])*long(sz[0]);\n\t\tpixel_per_channel = pixel_per_slice*long(sz[2]);\n\t\tntotalpixel = pixel_per_channel*colorchannels;\n\t}\n\t\n\tif (img) {delete []img; img=0;}\n\telse \n\t{\n\t\timg = new unsigned char [long(ntotalpixel)*long(datatype)];\n\t\tif (!img)\n\t\t{\n\t\t\tfprintf(stderr,\"Fail to allocate memory.\\n\");\n\t\t\tif (sz) {delete []sz;sz=0;}\n\t\t\tberror = 1;\n\t\t\treturn berror;\n\t\t}\n\t}\n\t\n\t// read every other directory (real data, the in between are thumbnails \n    bool b_readnow=false;\n\tlong d;\n\tshort cur_colorchannels, cur_bits;\n\tint cur_width, cur_height;\n\tfor (d=0;d<depth;d++)\n\t{\n\t\tif (sliceno>-2)\n\t\t{\n\t\t\tif (sliceno==-1) //middle slice only\n\t\t\t{\n\t\t\t\tb_readnow=(d==int(depth/2))?true:false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tb_readnow=(d==sliceno)?true:false;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tb_readnow=true;\n\t\t}\n\n\t\tif (b_readnow)\n\t\t{\n\t\t\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &cur_width);\n\t\t\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &cur_height);\n\t\t\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &cur_colorchannels); \n\t\t\tTIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &cur_bits);\n\n\t\t\t//printf(\"d=%d, current width=%d, height=%d, cur_colorchannels=%d, cur_bits=%d\\n\", d, cur_width, cur_height, cur_colorchannels, cur_bits); fflush(stdout); //080301\n\n\t\t\tif (cur_width != width || cur_height != height || cur_colorchannels!=colorchannels || cur_bits!=bits) \n\t\t\t{\n\t\t\t\tfprintf(stderr, \"The %ld Individual image slice has a different size/colorchannel/bits from the first slice!\", d);\n\t\t\t\t//in this case, do nothing to read the data and leave it empty\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (sliceno==-2)\n\t\t\t\t{\n\t\t\t\t\tread_lsm_slice(tif, img+long(d)*long(pixel_per_slice)*long(datatype), pixel_per_slice, pixel_per_channel, datatype);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tread_lsm_slice(tif, img, pixel_per_slice, pixel_per_channel, datatype);\n\t\t\t\t\tbreak; //because only 1 read is needed in this case\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (d==depth-1)\n\t\t\tbreak; //no need to do read directory anymore once the last one is read\n\t\telse\n\t\t{ \n\t\t\tif (!TIFFReadDirectory(tif)) break;\t  /* one directory  */\n\t\t\tif (!TIFFReadDirectory(tif)) break;\t  /* another directory */\n\t\t}\n\t}\n\t\n\tTIFFClose(tif);\n\t\n\treturn berror;\n}",
    "int loadTifSlice(char * filename, unsigned char * & img, long * & sz, int & datatype, long sliceno, bool b_thumbnail)\n{\n\tint berror=0;\n\t\n\tif (sliceno<-2)\n\t{\n\t\tfprintf(stderr, \"The sliceno parameter is invalid. Must not <-2: -2 to read all slices, -1 to read middle only, 0 to N-1 to read the 1 to N-1 slice. If bigger than N-1, then just read the last slice.\\n\");\n\t\treturn 1; \n\t}\n\t\n\tTIFF  *tif=0;\n\tint depth, width, height;\n\tshort bits, colorchannels;\n\t\n\ttif = Open_Tiff(filename,\"r\");\n\tif (!tif) \n\t{\n\t\tfprintf(stderr, \"Cannot open the specified TIFF file in loadTifSlice(). \\n\");\n\t\treturn 1; \n\t}\n\t\n\tdepth = 1;\n\twhile (TIFFReadDirectory(tif))\n\t\tdepth += 1;\n\tTIFFClose(tif);\n\t\n\tprintf(\"%d\\n\", depth); //note that this sentence will be output an important info to use the pop_thumbnail php program\n\t//printf(\"Total # of directories is %d, half of them are thumbnails So real data have %d slices.\\n\", depth, depth/2);\n\t//depth = depth / 2;\t\t/* half the dirs are thumbnails */\n\tif (sliceno>depth-1) sliceno=depth-1; \n\t//printf(\"slice #=%d\\n\", sliceno);\n\t\n\ttif = Open_Tiff(filename,\"r\");\n\n\t//if (b_thumbnail) TIFFReadDirectory(tif); //by pass one big image and get to the first thumbnail image\n\n\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &colorchannels); \n\tTIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bits);\n\t\n\tif (bits<=8 && bits>0) datatype=1;\n\telse if (bits<=16 && bits>0) datatype=2;\n\telse \n\t{\n\t\tfprintf(stderr, \"TIF file should not support more than 16 bits data. Check the codes in loadTifSlice(). \\n\");\n\t\treturn 1; //070805, by Hanchuan Peng\n\t}\n\t\n\tlong pixel_per_slice, pixel_per_channel, ntotalpixel;\n\tif (sz) {delete []sz; sz=0;}\n\tsz = new long [4]; /* reallocate the memory if the input parameter is non-null. Note that this requests the input is also an NULL point, the same to img. */\n\tif (!sz)  \n\t{\n\t\tfprintf(stderr,\"Fail to allocate memory.\\n\");\n\t\tberror = 1;\n\t\treturn berror;\n\t}\n\telse\n\t{\n\t\tsz[0] = width;\n\t\tsz[1] = height;\n\t\tsz[2] = (sliceno==-2) ? depth : 1;\n\t\tsz[3] = colorchannels;\n\t\tpixel_per_slice = long(sz[1])*long(sz[0]);\n\t\tpixel_per_channel = pixel_per_slice*long(sz[2]);\n\t\tntotalpixel = pixel_per_channel*colorchannels;\n\t}\n\t\n\tif (img) {delete []img; img=0;}\n\telse \n\t{\n\t\timg = new unsigned char [long(ntotalpixel)*long(datatype)];\n\t\tif (!img)\n\t\t{\n\t\t\tfprintf(stderr,\"Fail to allocate memory.\\n\");\n\t\t\tif (sz) {delete []sz;sz=0;}\n\t\t\tberror = 1;\n\t\t\treturn berror;\n\t\t}\n\t}\n\t\n\t// read every other directory (real data, the in between are thumbnails \n    bool b_readnow=false;\n\tlong d;\n\tshort cur_colorchannels, cur_bits;\n\tint cur_width, cur_height;\n\tfor (d=0;d<depth;d++)\n\t{\n\t\tif (sliceno>-2)\n\t\t{\n\t\t\tif (sliceno==-1) //middle slice only\n\t\t\t{\n\t\t\t\tb_readnow=(d==int(depth/2))?true:false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tb_readnow=(d==sliceno)?true:false;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tb_readnow=true;\n\t\t}\n\n\t\tif (b_readnow)\n\t\t{\n\t\t\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &cur_width);\n\t\t\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &cur_height);\n\t\t\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &cur_colorchannels); \n\t\t\tTIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &cur_bits);\n\n\t\t\t//printf(\"d=%d, current width=%d, height=%d\\n\", d, cur_width, cur_height); fflush(stdout);\n\n\t\t\tif (cur_width != width || cur_height != height || cur_colorchannels!=colorchannels || cur_bits!=bits) \n\t\t\t{\n\t\t\t\tfprintf(stderr, \"The %ld Individual image slice has a different size/colorchannel/bits from the first slice!\", d);\n\t\t\t\t//in this case, do nothing to read the data and leave it empty\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (sliceno==-2)\n\t\t\t\t{\n\t\t\t\t\tread_tif_slice(tif, img+long(d)*long(pixel_per_slice)*long(datatype)*sz[3], width, height);\n\t\t\t\t\t//printf(\"Read No. %d slice.\\n\", d);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tread_tif_slice(tif, img, width, height);\n\t\t\t\t\t//printf(\"width=[%d] height=[%d] color=[%d] bits-per-sample=[%d].\\n\", width, height, cur_colorchannels, cur_bits);\n\t\t\t\t\t//printf(\"Read No. %d slice.\\n\", d);\n\t\t\t\t\t//read_directory(tif,Select_Plane(stack,d),\"Read_Stack\");\n\t\t\t\t\tbreak; //because only 1 read is needed in this case\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (d==depth-1)\n\t\t\tbreak; //no need to do read directory anymore once the last one is read\n\t\telse\n\t\t{ \n\t\t\tif (!TIFFReadDirectory(tif)) break;\t  /* one directory  */\n\t\t\t//if (!TIFFReadDirectory(tif)) break;\t  /* another directory */\n\t\t}\n\t}\n\t\n\tTIFFClose(tif);\n\t\n\t//debugging code: verification succeeds in Matlab reading code: \n\t//t=fopen('/Users/pengh/Desktop/temp/test1.dat');a=fread(t, 512*512*3, 'uint8');a=reshape(a,[3 512 512]);a=permute(a, [2 3 1]);fclose(t); imshow(a(:,:,1:3)/255)\n\t\t\t\n\t//FILE * tmp_fp=fopen(\"/Users/pengh/temp/test1.dat\", \"w\");\n\t//fwrite(img, 3, width*height,tmp_fp);\n\t//fclose(tmp_fp);\n\t\n\t\n\t//produce thumbnail if required\n\tif (b_thumbnail)\n\t{\n\t\tlong thumbsz0=128, thumbsz1=128;\n\t\tif (sz[0]>thumbsz0 || sz[1]>thumbsz1)\n\t\t{\t\n\t\t\tunsigned char * img1 = new unsigned char [long(thumbsz0)*thumbsz1*sz[2]*sz[3]*long(datatype)];\n\t\t\tunsigned char ****img4d1 = 0;\n\t\t\tnew4dpointer(img4d1, sz[3], thumbsz0, thumbsz1, sz[2], img1);\n\t\n\t\t\tunsigned char ****img4d = 0;\n\t\t\tnew4dpointer(img4d, sz[3], sz[0], sz[1], sz[2], img);\n\t\t\t\n\t\t\tdouble factor_jj=sz[1]/thumbsz1, factor_ii=sz[0]/thumbsz0;\n\t\t\tfor (long kk=0;kk<sz[2];kk++)\n\t\t\t{\n\t\t\t\tfor (long jj=0; jj<thumbsz1; jj++)\n\t\t\t\t{\n\t\t\t\t\tfor (long ii=0;ii<thumbsz0; ii++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (long cc=0;cc<sz[3];cc++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\timg4d1[kk][jj][ii][cc] = img4d[kk][long(floor(jj*factor_jj))][long(floor(ii*factor_ii))][cc];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tdelete4dpointer(img4d, sz[3], sz[0], sz[1], sz[2]);\n\t\t\tdelete4dpointer(img4d1, sz[3], thumbsz0, thumbsz1, sz[2]);\n\n\t\t\tdelete []img;\n\t\t\timg = img1;\n\t\t\tsz[0] = thumbsz0;\n\t\t\tsz[1] = thumbsz1;\n\t\t\t//sz[2] and sz[3] do not need change\n\t\t}\n\t}\n\n\t//FILE * tmp_fp=fopen(\"/Users/pengh/temp/test1.dat\", \"w\");\n\t//fwrite(img, 3, width*height,tmp_fp);\n\t//fclose(tmp_fp);\n\t\n\t//permute the data to make sure it will be output correctly\n\tunsigned char ****img4d = 0;\n\tnew4dpointer(img4d, sz[3], sz[0], sz[1], sz[2], img); //must realize this order!\n\t\n\tunsigned char * img1 = new unsigned char [sz[0]*sz[1]*sz[2]*sz[3]];\n\tunsigned char ****img4d1 = 0;\n\tnew4dpointer(img4d1, sz[0], sz[1], sz[2], sz[3], img1);\n\t\n\tfor (long tcc=0;tcc<sz[3];tcc++)\n\t{\n\t\tfor (long tkk=0;tkk<sz[2];tkk++)\n\t\t{\n\t\t\tfor (long tjj=0;tjj<sz[1];tjj++)\n\t\t\t{\n\t\t\t\tfor (long tii=0;tii<sz[0];tii++)\n\t\t\t\t{\n\t\t\t\t\timg4d1[tcc][tkk][tjj][tii] = img4d[tkk][tjj][tii][tcc];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tdelete4dpointer(img4d1, sz[0], sz[1], sz[2], sz[3]);\n\tdelete4dpointer(img4d, sz[3], sz[0], sz[1], sz[2]);\n\tif (img) {delete []img; img=0;}\n\timg = img1;\n\t\n\treturn berror;\n}",
    "Image *Read_Tiff(TIFF *tif, int *lastone)\n{ Image *image;\n\n  int   width, height, kind;\n\n  TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n  TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n\n  kind = determine_kind(tif);\n\n  image = new_image(height*width*kind,\"Read_Tiff\");\n\n  image->width  = width;\n  image->height = height;\n  image->kind   = kind;\n\n  read_directory(tif,image,\"Read_Tiff\");\n\n  *lastone = (! TIFFReadDirectory(tif));\n  return (image);\n}",
    "Stack *Read_Stack(char *file_name)\n{ Stack *stack;\n\n  TIFF  *tif;\n  int    depth, width, height, kind;\n\n  tif = Open_Tiff(file_name,\"r\");\n  depth = 1;\n  while (TIFFReadDirectory(tif))\n    depth += 1;\n  TIFFClose(tif);\n\n  tif = Open_Tiff(file_name,\"r\");\n  TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n  TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n\n  kind  = determine_kind(tif);\n  stack = new_stack(depth*height*width*kind,\"Read_Stack\");\n\n  stack->width  = width;\n  stack->height = height;\n  stack->depth  = depth;\n  stack->kind   = kind;\n\n  { int d;\n\n    d = 0;\n    while (1)\n      { read_directory(tif,Select_Plane(stack,d),\"Read_Stack\");\n\n        d += 1;\n        if (!TIFFReadDirectory(tif)) break;\n\n        TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n        TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n        if (width != stack->width || height != stack->height)\n          error(\"Images of stack are not of the same dimensions!\",NULL);\n\n        kind = determine_kind(tif);\n        if (kind != stack->kind)\n          error(\"Images of stack are not of the same type (GREY, GREY16, or COLOR)!\",NULL);\n      }\n  }\n\n  TIFFClose(tif);\n\n  return (stack);\n}",
    "Stack *Read_LSM_Stack(char *file_name)\n{\n  Stack *stack;\n\n  TIFF  *tif;\n  int    depth, width, height, kind;\n\n  tif = Open_Tiff(file_name,\"r\");\n  if (!tif) return 0; //070805, bu Hanchuan Peng\n\t\n  depth = 1;\n  while (TIFFReadDirectory(tif))\n    depth += 1;\n  TIFFClose(tif);\n  depth = depth / 2;\t\t/* half the dirs are thumbnails */\n\n  tif = Open_Tiff(file_name,\"r\");\n  TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n  TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n\n  kind  = determine_kind(tif);\n  stack = new_stack(depth*height*width*kind,\"Read_Stack\");\n\n  stack->width  = width;\n  stack->height = height;\n  stack->depth  = depth;\n  stack->kind   = kind;\n\n  printf(\"test1 done\\n\");\n\n  int d;\n\n  d = 0;\n  /* read every other directory (real data, the in between are thumbnails */\n  while (1)\n  {\n\t  read_directory(tif,Select_Plane(stack,d),\"Read_Stack\");\n\t  \n\t  d += 1;\n\t  if (!TIFFReadDirectory(tif)) break;\n\t  /* skip the one we just read, it's a thumbnail  */\n\n\t  if (!TIFFReadDirectory(tif)) break;\n\t  \n\t  TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);\n\t  TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);\n\t  if (width != stack->width || height != stack->height)\n          error(\"Images of stack are not of the same dimensions!\",NULL);\n\t  \n\t  kind = determine_kind(tif);\n\t  if (kind != stack->kind)\n          error(\"Images of stack are not of the same type (GREY, GREY16, or COLOR)!\",NULL);\n  }\n  \n  TIFFClose(tif);\n\n  return (stack);\n}",
    "bool QFRDRImagingFCSData::loadVideo(const QString& filename, double** data, int* width, int* height, uint32_t* frames, double scaleFactor, double scaleOffset) {\r\n    bool ok=false;\r\n\r\n    //qDebug()<<filename<<data<<width<<height<<frames;\r\n    if (!data || !width || !height || !frames) return false;\r\n\r\n    if (*data) qfFree(*data);\r\n    *data=NULL;\r\n    *width=0;\r\n    *height=0;\r\n    *frames=0;\r\n\r\n    if (QFile::exists(filename)) {\r\n        TIFF* tif=TIFFOpen(filename.toLatin1().data(), \"r\");\r\n        if (tif) {\r\n            *frames=TIFFCountDirectories(tif);\r\n            uint32 nx,ny;\r\n            TIFFGetField(tif,TIFFTAG_IMAGEWIDTH,&nx);\r\n            TIFFGetField(tif,TIFFTAG_IMAGELENGTH,&ny);\r\n            uint16 bitspersample;\r\n            uint16 sampleformat = SAMPLEFORMAT_UINT;\r\n            TIFFGetField(tif, TIFFTAG_SAMPLEFORMAT, &sampleformat);\r\n            TIFFGetFieldDefaulted(tif,TIFFTAG_BITSPERSAMPLE,&bitspersample);\r\n\r\n            *width=nx;\r\n            *height=ny;\r\n            if (*frames>0 && *width>0 && *height>0) {\r\n                *data=(double*)qfMalloc(nx*ny*(*frames)*sizeof(double));\r\n                uint32_t i=0;\r\n                if (*data) {\r\n                    do {\r\n                        ok=ok & TIFFReadFrame<double>(tif, &((*data)[i*nx*ny]));\r\n                        if (sampleformat == SAMPLEFORMAT_UINT && bitspersample==16 && (scaleFactor!=1.0 || scaleOffset!=0.0)) {\r\n                            for (uint32_t jj=0; jj<nx*ny; jj++) {\r\n                                (*data)[i*nx*ny+jj]=scaleOffset+(*data)[i*nx*ny+jj]*scaleFactor;\r\n                            }\r\n                        }\r\n                        i++;\r\n                    } while (TIFFReadDirectory(tif) && i<=(*frames));\r\n                }\r\n            } else {\r\n                log_warning(tr(\"WARNING: could not load overview image file '%1'\\n\").arg(filename));\r\n            }\r\n            TIFFClose(tif);\r\n            //qDebug()<<getID()<<\"loading video \"<<filename<<\"   siez=\"<<*width<<\"x\"<<*height<<\"   frames=\"<<*frames;\r\n        } else {\r\n            log_warning(tr(\"WARNING: could not load overview image file '%1'\\n\").arg(filename));\r\n        }\r\n    } else {\r\n        log_warning(tr(\"WARNING: could not find overview image file '%1'\\n\").arg(filename));\r\n    }\r\n    return ok;\r\n}",
    "bool QFRDRNumberAndBrightnessData::loadVideo(const QString& filename, double** data, int* width, int* height, uint32_t* frames) {\n    bool ok=false;\n\n    if (*data) qfFree(*data);\n    *data=NULL;\n    *width=0;\n    *height=0;\n    *frames=0;\n\n    if (QFile::exists(filename)) {\n        TIFF* tif=TIFFOpen(filename.toLatin1().data(), \"r\");\n        if (tif) {\n            *frames=TIFFCountDirectories(tif);\n            uint32 nx,ny;\n            TIFFGetField(tif,TIFFTAG_IMAGEWIDTH,&nx);\n            TIFFGetField(tif,TIFFTAG_IMAGELENGTH,&ny);\n            *width=nx;\n            *height=ny;\n            *data=(double*)qfMalloc(nx*ny*(*frames)*sizeof(double));\n            uint32_t i=0;\n            do {\n                ok=ok & TIFFReadFrame<double>(tif, &((*data)[i*nx*ny]));\n                i++;\n            } while (TIFFReadDirectory(tif) && i<=(*frames));\n            TIFFClose(tif);\n        }\n    }\n    return ok;\n}",
    "uint32_t QFImageReaderLIBTIFF::countFrames() {\n    if (!tif) return 0;\n\n    if (fileinfo.properties.contains(\"FRAMES\")) {\n        bool ok=false;\n        uint32_t f=fileinfo.properties[\"FRAMES\"].toULongLong(&ok);\n        if (ok && f>0) {\n            return f;\n        }\n    }\n\n    uint32_t nb_images = 0;\n    //tdir_t dir=TIFFCurrentDirectory(tif);\n    TIFFSetDirectory(tif,0);\n    //reset();\n    do {\n        ++nb_images;\n    } while (TIFFReadDirectory(tif) && (nb_images<65000)); // LIBTIFF can only read up to 2^{16} frames!!!\n    //TIFFSetDirectory(tif,dir);\n    TIFFSetDirectory(tif,0);\n    //reset();\n    return nb_images;\n}",
    "bool QFImageReaderLIBTIFF::nextFrame() {\n    if (!tif) return false;\n    return TIFFReadDirectory(tif);\n}",
    "CPLErr GTiffDataset::OpenOffset( TIFF *hTIFFIn, \n                                 GTiffDataset **ppoActiveDSRef,\n                                 toff_t nDirOffsetIn, \n\t\t\t\t int bBaseIn, GDALAccess eAccess,\n                                 int bAllowRGBAInterface,\n                                 int bReadGeoTransform,\n                                 char** papszSiblingFiles )\n\n{\n    uint32\tnXSize, nYSize;\n    int\t\tbTreatAsBitmap = FALSE;\n    int         bTreatAsOdd = FALSE;\n\n    this->eAccess = eAccess;\n\n    hTIFF = hTIFFIn;\n    this->ppoActiveDSRef = ppoActiveDSRef;\n\n    nDirOffset = nDirOffsetIn;\n\n    if (!SetDirectory( nDirOffsetIn ))\n        return CE_Failure;\n\n    bBase = bBaseIn;\n\n    this->eAccess = eAccess;\n\n/* -------------------------------------------------------------------- */\n/*      Capture some information from the file that is of interest.     */\n/* -------------------------------------------------------------------- */\n    TIFFGetField( hTIFF, TIFFTAG_IMAGEWIDTH, &nXSize );\n    TIFFGetField( hTIFF, TIFFTAG_IMAGELENGTH, &nYSize );\n    nRasterXSize = nXSize;\n    nRasterYSize = nYSize;\n\n    if( !TIFFGetField(hTIFF, TIFFTAG_SAMPLESPERPIXEL, &nSamplesPerPixel ) )\n        nBands = 1;\n    else\n        nBands = nSamplesPerPixel;\n    \n    if( !TIFFGetField(hTIFF, TIFFTAG_BITSPERSAMPLE, &(nBitsPerSample)) )\n        nBitsPerSample = 1;\n    \n    if( !TIFFGetField( hTIFF, TIFFTAG_PLANARCONFIG, &(nPlanarConfig) ) )\n        nPlanarConfig = PLANARCONFIG_CONTIG;\n    \n    if( !TIFFGetField( hTIFF, TIFFTAG_PHOTOMETRIC, &(nPhotometric) ) )\n        nPhotometric = PHOTOMETRIC_MINISBLACK;\n    \n    if( !TIFFGetField( hTIFF, TIFFTAG_SAMPLEFORMAT, &(nSampleFormat) ) )\n        nSampleFormat = SAMPLEFORMAT_UINT;\n    \n    if( !TIFFGetField( hTIFF, TIFFTAG_COMPRESSION, &(nCompression) ) )\n        nCompression = COMPRESSION_NONE;\n    \n#if defined(TIFFLIB_VERSION) && TIFFLIB_VERSION > 20031007 /* 3.6.0 */\n    if (nCompression != COMPRESSION_NONE &&\n        !TIFFIsCODECConfigured(nCompression))\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                  \"Cannot open TIFF file due to missing codec.\" );\n        return CE_Failure;\n    }\n#endif\n\n/* -------------------------------------------------------------------- */\n/*      YCbCr JPEG compressed images should be translated on the fly    */\n/*      to RGB by libtiff/libjpeg unless specifically requested         */\n/*      otherwise.                                                      */\n/* -------------------------------------------------------------------- */\n    if( nCompression == COMPRESSION_JPEG \n        && nPhotometric == PHOTOMETRIC_YCBCR \n        && CSLTestBoolean( CPLGetConfigOption(\"CONVERT_YCBCR_TO_RGB\",\n                                              \"YES\") ) )\n    {\n        int nColorMode;\n\n        SetMetadataItem( \"SOURCE_COLOR_SPACE\", \"YCbCr\", \"IMAGE_STRUCTURE\" );\n        if ( !TIFFGetField( hTIFF, TIFFTAG_JPEGCOLORMODE, &nColorMode ) ||\n              nColorMode != JPEGCOLORMODE_RGB )\n            TIFFSetField(hTIFF, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Get strip/tile layout.                                          */\n/* -------------------------------------------------------------------- */\n    if( TIFFIsTiled(hTIFF) )\n    {\n        TIFFGetField( hTIFF, TIFFTAG_TILEWIDTH, &(nBlockXSize) );\n        TIFFGetField( hTIFF, TIFFTAG_TILELENGTH, &(nBlockYSize) );\n    }\n    else\n    {\n        if( !TIFFGetField( hTIFF, TIFFTAG_ROWSPERSTRIP,\n                           &(nRowsPerStrip) ) )\n        {\n            CPLError( CE_Warning, CPLE_AppDefined, \n                      \"RowsPerStrip not defined ... assuming all one strip.\" );\n            nRowsPerStrip = nYSize; /* dummy value */\n        }\n\n        nBlockXSize = nRasterXSize;\n        nBlockYSize = MIN(nRowsPerStrip,nYSize);\n    }\n        \n    nBlocksPerBand =\n        ((nYSize + nBlockYSize - 1) / nBlockYSize)\n        * ((nXSize + nBlockXSize  - 1) / nBlockXSize);\n\n/* -------------------------------------------------------------------- */\n/*      Should we handle this using the GTiffBitmapBand?                */\n/* -------------------------------------------------------------------- */\n    if( nBitsPerSample == 1 && nBands == 1 )\n    {\n        bTreatAsBitmap = TRUE;\n\n        // Lets treat large \"one row\" bitmaps using the scanline api.\n        if( !TIFFIsTiled(hTIFF) \n            && nBlockYSize == nYSize \n            && nYSize > 2000 \n            && bAllowRGBAInterface )\n            bTreatAsSplitBitmap = TRUE;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Should we treat this via the RGBA interface?                    */\n/* -------------------------------------------------------------------- */\n    if( bAllowRGBAInterface &&\n        !bTreatAsBitmap && !(nBitsPerSample > 8) \n        && (nPhotometric == PHOTOMETRIC_CIELAB ||\n            nPhotometric == PHOTOMETRIC_LOGL ||\n            nPhotometric == PHOTOMETRIC_LOGLUV ||\n            nPhotometric == PHOTOMETRIC_SEPARATED ||\n            ( nPhotometric == PHOTOMETRIC_YCBCR \n              && nCompression != COMPRESSION_JPEG )) )\n    {\n        char\tszMessage[1024];\n\n        if( TIFFRGBAImageOK( hTIFF, szMessage ) == 1 )\n        {\n            const char* pszSourceColorSpace = NULL;\n            switch (nPhotometric)\n            {\n                case PHOTOMETRIC_CIELAB:\n                    pszSourceColorSpace = \"CIELAB\";\n                    break;\n                case PHOTOMETRIC_LOGL:\n                    pszSourceColorSpace = \"LOGL\";\n                    break;\n                case PHOTOMETRIC_LOGLUV:\n                    pszSourceColorSpace = \"LOGLUV\";\n                    break;\n                case PHOTOMETRIC_SEPARATED:\n                    pszSourceColorSpace = \"CMYK\";\n                    break;\n                case PHOTOMETRIC_YCBCR:\n                    pszSourceColorSpace = \"YCbCr\";\n                    break;\n            }\n            if (pszSourceColorSpace)\n                SetMetadataItem( \"SOURCE_COLOR_SPACE\", pszSourceColorSpace, \"IMAGE_STRUCTURE\" );\n            bTreatAsRGBA = TRUE;\n            nBands = 4;\n        }\n        else\n        {\n            CPLDebug( \"GTiff\", \"TIFFRGBAImageOK says:\\n%s\", szMessage );\n        }\n    }\n    \n/* -------------------------------------------------------------------- */\n/*      Should we treat this via the split interface?                   */\n/* -------------------------------------------------------------------- */\n    if( !TIFFIsTiled(hTIFF) \n        && nBitsPerSample == 8\n        && nBlockYSize == nYSize \n        && nYSize > 2000\n        && !bTreatAsRGBA \n        && CSLTestBoolean(CPLGetConfigOption(\"GDAL_ENABLE_TIFF_SPLIT\", \"YES\")))\n    {\n        /* libtiff 3.9.2 (20091104) and older, libtiff 4.0.0beta5 (also 20091104) */\n        /* and older will crash when trying to open a all-in-one-strip */\n        /* YCbCr JPEG compressed TIFF (see #3259). */\n#if (TIFFLIB_VERSION <= 20091104 && !defined(BIGTIFF_SUPPORT)) || \\\n    (TIFFLIB_VERSION <= 20091104 && defined(BIGTIFF_SUPPORT))\n        if (nPhotometric == PHOTOMETRIC_YCBCR  &&\n            nCompression == COMPRESSION_JPEG)\n        {\n            CPLDebug(\"GTiff\", \"Avoid using split band to open all-in-one-strip \"\n                              \"YCbCr JPEG compressed TIFF because of older libtiff\");\n        }\n        else\n#endif\n            bTreatAsSplit = TRUE;\n    }\n    \n/* -------------------------------------------------------------------- */\n/*      Should we treat this via the odd bits interface?                */\n/* -------------------------------------------------------------------- */\n    if ( nSampleFormat == SAMPLEFORMAT_IEEEFP )\n    {\n        if ( nBitsPerSample == 16 || nBitsPerSample == 24 )\n            bTreatAsOdd = TRUE;\n    }\n    else if ( !bTreatAsRGBA && !bTreatAsBitmap\n              && nBitsPerSample != 8\n              && nBitsPerSample != 16\n              && nBitsPerSample != 32\n              && nBitsPerSample != 64 \n              && nBitsPerSample != 128 )\n        bTreatAsOdd = TRUE;\n\n    int bMinIsWhite = nPhotometric == PHOTOMETRIC_MINISWHITE;\n\n/* -------------------------------------------------------------------- */\n/*      Capture the color table if there is one.                        */\n/* -------------------------------------------------------------------- */\n    unsigned short\t*panRed, *panGreen, *panBlue;\n\n    if( bTreatAsRGBA \n        || TIFFGetField( hTIFF, TIFFTAG_COLORMAP, \n                         &panRed, &panGreen, &panBlue) == 0 )\n    {\n\t// Build inverted palette if we have inverted photometric.\n\t// Pixel values remains unchanged.  Avoid doing this for *deep*\n        // data types (per #1882)\n\tif( nBitsPerSample <= 16 && nPhotometric == PHOTOMETRIC_MINISWHITE )\n\t{\n\t    GDALColorEntry  oEntry;\n\t    int\t\t    iColor, nColorCount;\n\t    \n\t    poColorTable = new GDALColorTable();\n\t    nColorCount = 1 << nBitsPerSample;\n\n\t    for ( iColor = 0; iColor < nColorCount; iColor++ )\n\t    {\n\t\toEntry.c1 = oEntry.c2 = oEntry.c3 = (short) \n                    ((255 * (nColorCount - 1 - iColor)) / (nColorCount-1));\n\t\toEntry.c4 = 255;\n\t\tpoColorTable->SetColorEntry( iColor, &oEntry );\n\t    }\n\n\t    nPhotometric = PHOTOMETRIC_PALETTE;\n\t}\n\telse\n\t    poColorTable = NULL;\n    }\n    else\n    {\n        int\tnColorCount, nMaxColor = 0;\n        GDALColorEntry oEntry;\n\n        poColorTable = new GDALColorTable();\n\n        nColorCount = 1 << nBitsPerSample;\n\n        for( int iColor = nColorCount - 1; iColor >= 0; iColor-- )\n        {\n            oEntry.c1 = panRed[iColor] / 256;\n            oEntry.c2 = panGreen[iColor] / 256;\n            oEntry.c3 = panBlue[iColor] / 256;\n            oEntry.c4 = 255;\n\n            poColorTable->SetColorEntry( iColor, &oEntry );\n\n            nMaxColor = MAX(nMaxColor,panRed[iColor]);\n            nMaxColor = MAX(nMaxColor,panGreen[iColor]);\n            nMaxColor = MAX(nMaxColor,panBlue[iColor]);\n        }\n\n        // Bug 1384 - Some TIFF files are generated with color map entry\n        // values in range 0-255 instead of 0-65535 - try to handle these\n        // gracefully.\n        if( nMaxColor > 0 && nMaxColor < 256 )\n        {\n            CPLDebug( \"GTiff\", \"TIFF ColorTable seems to be improperly scaled, fixing up.\" );\n            \n            for( int iColor = nColorCount - 1; iColor >= 0; iColor-- )\n            {\n                oEntry.c1 = panRed[iColor];\n                oEntry.c2 = panGreen[iColor];\n                oEntry.c3 = panBlue[iColor];\n                oEntry.c4 = 255;\n                \n                poColorTable->SetColorEntry( iColor, &oEntry );\n            }\n        }\n    }\n    \n/* -------------------------------------------------------------------- */\n/*      Create band information objects.                                */\n/* -------------------------------------------------------------------- */\n    for( int iBand = 0; iBand < nBands; iBand++ )\n    {\n        if( bTreatAsRGBA )\n            SetBand( iBand+1, new GTiffRGBABand( this, iBand+1 ) );\n        else if( bTreatAsSplitBitmap )\n            SetBand( iBand+1, new GTiffSplitBitmapBand( this, iBand+1 ) );\n        else if( bTreatAsSplit )\n            SetBand( iBand+1, new GTiffSplitBand( this, iBand+1 ) );\n        else if( bTreatAsBitmap )\n            SetBand( iBand+1, new GTiffBitmapBand( this, iBand+1 ) );\n        else if( bTreatAsOdd )\n            SetBand( iBand+1, new GTiffOddBitsBand( this, iBand+1 ) );\n        else\n            SetBand( iBand+1, new GTiffRasterBand( this, iBand+1 ) );\n    }\n\n    if( GetRasterBand(1)->GetRasterDataType() == GDT_Unknown )\n    {\n        CPLError( CE_Failure, CPLE_NotSupported,\n                  \"Unsupported TIFF configuration.\" );\n        return CE_Failure;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Get the transform or gcps from the GeoTIFF file.                */\n/* -------------------------------------------------------------------- */\n    if( bReadGeoTransform )\n    {\n        char    *pszTabWKT = NULL;\n        double\t*padfTiePoints, *padfScale, *padfMatrix;\n        uint16\tnCount;\n        bool    bPixelIsPoint = false;\n        short nRasterType;\n        GTIF\t*psGTIF;\n        int     bPointGeoIgnore = FALSE;\n\n        psGTIF = GTIFNew( hTIFF ); // I wonder how expensive this is?\n\n        if( psGTIF )\n        {\n            if( GTIFKeyGet(psGTIF, GTRasterTypeGeoKey, &nRasterType,\n                        0, 1 ) == 1\n                && nRasterType == (short) RasterPixelIsPoint )\n            {\n                bPixelIsPoint = true;\n                bPointGeoIgnore =\n                    CSLTestBoolean( CPLGetConfigOption(\"GTIFF_POINT_GEO_IGNORE\",\n                                                    \"FALSE\") );\n            }\n\n            GTIFFree( psGTIF );\n        }\n\n        adfGeoTransform[0] = 0.0;\n        adfGeoTransform[1] = 1.0;\n        adfGeoTransform[2] = 0.0;\n        adfGeoTransform[3] = 0.0;\n        adfGeoTransform[4] = 0.0;\n        adfGeoTransform[5] = 1.0;\n    \n        if( TIFFGetField(hTIFF,TIFFTAG_GEOPIXELSCALE,&nCount,&padfScale )\n            && nCount >= 2 \n            && padfScale[0] != 0.0 && padfScale[1] != 0.0 )\n        {\n            adfGeoTransform[1] = padfScale[0];\n            adfGeoTransform[5] = - ABS(padfScale[1]);\n\n            if( TIFFGetField(hTIFF,TIFFTAG_GEOTIEPOINTS,&nCount,&padfTiePoints )\n                && nCount >= 6 )\n            {\n                adfGeoTransform[0] =\n                    padfTiePoints[3] - padfTiePoints[0] * adfGeoTransform[1];\n                adfGeoTransform[3] =\n                    padfTiePoints[4] - padfTiePoints[1] * adfGeoTransform[5];\n\n                if( bPixelIsPoint && !bPointGeoIgnore )\n                {\n                    adfGeoTransform[0] -= (adfGeoTransform[1] * 0.5 + adfGeoTransform[2] * 0.5);\n                    adfGeoTransform[3] -= (adfGeoTransform[4] * 0.5 + adfGeoTransform[5] * 0.5);\n                }\n\n                bGeoTransformValid = TRUE;\n            }\n        }\n\n        else if( TIFFGetField(hTIFF,TIFFTAG_GEOTRANSMATRIX,&nCount,&padfMatrix ) \n                 && nCount == 16 )\n        {\n            adfGeoTransform[0] = padfMatrix[3];\n            adfGeoTransform[1] = padfMatrix[0];\n            adfGeoTransform[2] = padfMatrix[1];\n            adfGeoTransform[3] = padfMatrix[7];\n            adfGeoTransform[4] = padfMatrix[4];\n            adfGeoTransform[5] = padfMatrix[5];\n\n            if( bPixelIsPoint && !bPointGeoIgnore )\n            {\n                adfGeoTransform[0] -= (adfGeoTransform[1] * 0.5 + adfGeoTransform[2] * 0.5);\n                adfGeoTransform[3] -= (adfGeoTransform[4] * 0.5 + adfGeoTransform[5] * 0.5);\n            }\n\n            bGeoTransformValid = TRUE;\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Otherwise try looking for a .tfw, .tifw or .wld file.           */\n/* -------------------------------------------------------------------- */\n        else\n        {\n            char* pszWldFilename = NULL;\n\n            bGeoTransformValid =\n                GDALReadWorldFile2( osFilename, NULL, adfGeoTransform,\n                                    papszSiblingFiles, &pszWldFilename);\n\n            if( !bGeoTransformValid )\n            {\n                bGeoTransformValid =\n                    GDALReadWorldFile2( osFilename, \"wld\", adfGeoTransform,\n                                        papszSiblingFiles, &pszWldFilename);\n            }\n\n            if( !bGeoTransformValid )\n            {\n                int bTabFileOK =\n                    GDALReadTabFile2( osFilename, adfGeoTransform,\n                                      &pszTabWKT, &nGCPCount, &pasGCPList,\n                                      papszSiblingFiles, &pszWldFilename );\n\n                if( bTabFileOK && nGCPCount == 0 )\n                    bGeoTransformValid = TRUE;\n            }\n\n            if (pszWldFilename)\n            {\n                osWldFilename = pszWldFilename;\n                CPLFree(pszWldFilename);\n            }\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Check for GCPs.  Note, we will allow there to be GCPs and a     */\n/*      transform in some circumstances.                                */\n/* -------------------------------------------------------------------- */\n        if( TIFFGetField(hTIFF,TIFFTAG_GEOTIEPOINTS,&nCount,&padfTiePoints )\n            && !bGeoTransformValid )\n        {\n            nGCPCount = nCount / 6;\n            pasGCPList = (GDAL_GCP *) CPLCalloc(sizeof(GDAL_GCP),nGCPCount);\n        \n            for( int iGCP = 0; iGCP < nGCPCount; iGCP++ )\n            {\n                char\tszID[32];\n\n                sprintf( szID, \"%d\", iGCP+1 );\n                pasGCPList[iGCP].pszId = CPLStrdup( szID );\n                pasGCPList[iGCP].pszInfo = CPLStrdup(\"\");\n                pasGCPList[iGCP].dfGCPPixel = padfTiePoints[iGCP*6+0];\n                pasGCPList[iGCP].dfGCPLine = padfTiePoints[iGCP*6+1];\n                pasGCPList[iGCP].dfGCPX = padfTiePoints[iGCP*6+3];\n                pasGCPList[iGCP].dfGCPY = padfTiePoints[iGCP*6+4];\n                pasGCPList[iGCP].dfGCPZ = padfTiePoints[iGCP*6+5];\n\n                if( bPixelIsPoint && !bPointGeoIgnore )\n                {\n                    pasGCPList[iGCP].dfGCPPixel -= 0.5;\n                    pasGCPList[iGCP].dfGCPLine -= 0.5;\n                }\n            }\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Did we find a tab file?  If so we will use it's coordinate      */\n/*      system and give it precidence.                                  */\n/* -------------------------------------------------------------------- */\n        if( pszTabWKT != NULL \n            && (pszProjection == NULL || pszProjection[0] == '\\0') )\n        {\n            CPLFree( pszProjection );\n            pszProjection = pszTabWKT;\n            pszTabWKT = NULL;\n            bLookedForProjection = TRUE;\n        }\n        \n        CPLFree( pszTabWKT );\n        bGeoTIFFInfoChanged = FALSE;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Capture some other potentially interesting information.         */\n/* -------------------------------------------------------------------- */\n    char\t*pszText, szWorkMDI[200];\n    float   fResolution;\n    uint16  nShort;\n\n    if( TIFFGetField( hTIFF, TIFFTAG_DOCUMENTNAME, &pszText ) )\n        SetMetadataItem( \"TIFFTAG_DOCUMENTNAME\",  pszText );\n\n    if( TIFFGetField( hTIFF, TIFFTAG_IMAGEDESCRIPTION, &pszText ) )\n        SetMetadataItem( \"TIFFTAG_IMAGEDESCRIPTION\", pszText );\n\n    if( TIFFGetField( hTIFF, TIFFTAG_SOFTWARE, &pszText ) )\n        SetMetadataItem( \"TIFFTAG_SOFTWARE\", pszText );\n\n    if( TIFFGetField( hTIFF, TIFFTAG_DATETIME, &pszText ) )\n        SetMetadataItem( \"TIFFTAG_DATETIME\", pszText );\n\n    if( TIFFGetField( hTIFF, TIFFTAG_ARTIST, &pszText ) )\n        SetMetadataItem( \"TIFFTAG_ARTIST\", pszText );\n\n    if( TIFFGetField( hTIFF, TIFFTAG_HOSTCOMPUTER, &pszText ) )\n        SetMetadataItem( \"TIFFTAG_HOSTCOMPUTER\", pszText );\n\n    if( TIFFGetField( hTIFF, TIFFTAG_COPYRIGHT, &pszText ) )\n        SetMetadataItem( \"TIFFTAG_COPYRIGHT\", pszText );\n\n    if( TIFFGetField( hTIFF, TIFFTAG_XRESOLUTION, &fResolution ) )\n    {\n        sprintf( szWorkMDI, \"%.8g\", fResolution );\n        SetMetadataItem( \"TIFFTAG_XRESOLUTION\", szWorkMDI );\n    }\n\n    if( TIFFGetField( hTIFF, TIFFTAG_YRESOLUTION, &fResolution ) )\n    {\n        sprintf( szWorkMDI, \"%.8g\", fResolution );\n        SetMetadataItem( \"TIFFTAG_YRESOLUTION\", szWorkMDI );\n    }\n\n    if( TIFFGetField( hTIFF, TIFFTAG_MINSAMPLEVALUE, &nShort ) )\n    {\n        sprintf( szWorkMDI, \"%d\", nShort );\n        SetMetadataItem( \"TIFFTAG_MINSAMPLEVALUE\", szWorkMDI );\n    }\n\n    if( TIFFGetField( hTIFF, TIFFTAG_MAXSAMPLEVALUE, &nShort ) )\n    {\n        sprintf( szWorkMDI, \"%d\", nShort );\n        SetMetadataItem( \"TIFFTAG_MAXSAMPLEVALUE\", szWorkMDI );\n    }\n\n    if( TIFFGetField( hTIFF, TIFFTAG_RESOLUTIONUNIT, &nShort ) )\n    {\n        if( nShort == RESUNIT_NONE )\n            sprintf( szWorkMDI, \"%d (unitless)\", nShort );\n        else if( nShort == RESUNIT_INCH )\n            sprintf( szWorkMDI, \"%d (pixels/inch)\", nShort );\n        else if( nShort == RESUNIT_CENTIMETER )\n            sprintf( szWorkMDI, \"%d (pixels/cm)\", nShort );\n        else\n            sprintf( szWorkMDI, \"%d\", nShort );\n        SetMetadataItem( \"TIFFTAG_RESOLUTIONUNIT\", szWorkMDI );\n    }\n\n    if( nCompression == COMPRESSION_NONE )\n        /* no compression tag */;\n    else if( nCompression == COMPRESSION_CCITTRLE )\n        SetMetadataItem( \"COMPRESSION\", \"CCITTRLE\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_CCITTFAX3 )\n        SetMetadataItem( \"COMPRESSION\", \"CCITTFAX3\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_CCITTFAX4 )\n        SetMetadataItem( \"COMPRESSION\", \"CCITTFAX4\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_LZW )\n        SetMetadataItem( \"COMPRESSION\", \"LZW\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_OJPEG )\n        SetMetadataItem( \"COMPRESSION\", \"OJPEG\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_JPEG )\n    {  \n        if ( nPhotometric == PHOTOMETRIC_YCBCR )\n            SetMetadataItem( \"COMPRESSION\", \"YCbCr JPEG\", \"IMAGE_STRUCTURE\" );\n        else\n            SetMetadataItem( \"COMPRESSION\", \"JPEG\", \"IMAGE_STRUCTURE\" );\n    }\n    else if( nCompression == COMPRESSION_NEXT )\n        SetMetadataItem( \"COMPRESSION\", \"NEXT\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_CCITTRLEW )\n        SetMetadataItem( \"COMPRESSION\", \"CCITTRLEW\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_PACKBITS )\n        SetMetadataItem( \"COMPRESSION\", \"PACKBITS\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_THUNDERSCAN )\n        SetMetadataItem( \"COMPRESSION\", \"THUNDERSCAN\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_PIXARFILM )\n        SetMetadataItem( \"COMPRESSION\", \"PIXARFILM\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_PIXARLOG )\n        SetMetadataItem( \"COMPRESSION\", \"PIXARLOG\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_DEFLATE )\n        SetMetadataItem( \"COMPRESSION\", \"DEFLATE\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_ADOBE_DEFLATE )\n        SetMetadataItem( \"COMPRESSION\", \"DEFLATE\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_DCS )\n        SetMetadataItem( \"COMPRESSION\", \"DCS\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_JBIG )\n        SetMetadataItem( \"COMPRESSION\", \"JBIG\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_SGILOG )\n        SetMetadataItem( \"COMPRESSION\", \"SGILOG\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_SGILOG24 )\n        SetMetadataItem( \"COMPRESSION\", \"SGILOG24\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_JP2000 )\n        SetMetadataItem( \"COMPRESSION\", \"JP2000\", \"IMAGE_STRUCTURE\" );\n    else if( nCompression == COMPRESSION_LZMA )\n        SetMetadataItem( \"COMPRESSION\", \"LZMA\", \"IMAGE_STRUCTURE\" );\n\n    else\n    {\n        CPLString oComp;\n        SetMetadataItem( \"COMPRESSION\", \n                         (const char *) oComp.Printf( \"%d\", nCompression));\n    }\n\n    if( nPlanarConfig == PLANARCONFIG_CONTIG && nBands != 1 )\n        SetMetadataItem( \"INTERLEAVE\", \"PIXEL\", \"IMAGE_STRUCTURE\" );\n    else\n        SetMetadataItem( \"INTERLEAVE\", \"BAND\", \"IMAGE_STRUCTURE\" );\n\n    if(  (GetRasterBand(1)->GetRasterDataType() == GDT_Byte   && nBitsPerSample != 8 ) ||\n         (GetRasterBand(1)->GetRasterDataType() == GDT_UInt16 && nBitsPerSample != 16) ||\n         (GetRasterBand(1)->GetRasterDataType() == GDT_UInt32 && nBitsPerSample != 32) )\n    {\n        for (int i = 0; i < nBands; ++i)\n            GetRasterBand(i+1)->SetMetadataItem( \"NBITS\", \n                                                 CPLString().Printf( \"%d\", (int)nBitsPerSample ),\n                                                 \"IMAGE_STRUCTURE\" );\n    }\n        \n    if( bMinIsWhite )\n        SetMetadataItem( \"MINISWHITE\", \"YES\", \"IMAGE_STRUCTURE\" );\n\n    if( TIFFGetField( hTIFF, TIFFTAG_GDAL_METADATA, &pszText ) )\n    {\n        CPLXMLNode *psRoot = CPLParseXMLString( pszText );\n        CPLXMLNode *psItem = NULL;\n\n        if( psRoot != NULL && psRoot->eType == CXT_Element\n            && EQUAL(psRoot->pszValue,\"GDALMetadata\") )\n            psItem = psRoot->psChild;\n\n        for( ; psItem != NULL; psItem = psItem->psNext )\n        {\n            const char *pszKey, *pszValue, *pszRole, *pszDomain; \n            char *pszUnescapedValue;\n            int nBand, bIsXML = FALSE;\n\n            if( psItem->eType != CXT_Element\n                || !EQUAL(psItem->pszValue,\"Item\") )\n                continue;\n\n            pszKey = CPLGetXMLValue( psItem, \"name\", NULL );\n            pszValue = CPLGetXMLValue( psItem, NULL, NULL );\n            nBand = atoi(CPLGetXMLValue( psItem, \"sample\", \"-1\" )) + 1;\n            pszRole = CPLGetXMLValue( psItem, \"role\", \"\" );\n            pszDomain = CPLGetXMLValue( psItem, \"domain\", \"\" );\n                \n            if( pszKey == NULL || pszValue == NULL )\n                continue;\n\n            if( EQUALN(pszDomain,\"xml:\",4) )\n                bIsXML = TRUE;\n\n            pszUnescapedValue = CPLUnescapeString( pszValue, NULL, \n                                                   CPLES_XML );\n            if( nBand == 0 )\n            {\n                if( bIsXML )\n                {\n                    char *apszMD[2] = { pszUnescapedValue, NULL };\n                    SetMetadata( apszMD, pszDomain );\n                }\n                else\n                    SetMetadataItem( pszKey, pszUnescapedValue, pszDomain );\n            }\n            else\n            {\n                GDALRasterBand *poBand = GetRasterBand(nBand);\n                if( poBand != NULL )\n                {\n                    if( EQUAL(pszRole,\"scale\") )\n                        poBand->SetScale( CPLAtofM(pszUnescapedValue) );\n                    else if( EQUAL(pszRole,\"offset\") )\n                        poBand->SetOffset( CPLAtofM(pszUnescapedValue) );\n                    else if( EQUAL(pszRole,\"unittype\") )\n                        poBand->SetUnitType( pszUnescapedValue );\n                    else\n                    {\n                        if( bIsXML )\n                        {\n                            char *apszMD[2] = { pszUnescapedValue, NULL };\n                            poBand->SetMetadata( apszMD, pszDomain );\n                        }\n                        else\n                            poBand->SetMetadataItem(pszKey,pszUnescapedValue,\n                                                    pszDomain );\n                    }\n                }\n            }\n            CPLFree( pszUnescapedValue );\n        }\n\n        CPLDestroyXMLNode( psRoot );\n    }\n\n    bMetadataChanged = FALSE;\n\n/* -------------------------------------------------------------------- */\n/*      Check for NODATA                                                */\n/* -------------------------------------------------------------------- */\n    if( TIFFGetField( hTIFF, TIFFTAG_GDAL_NODATA, &pszText ) )\n    {\n        bNoDataSet = TRUE;\n        dfNoDataValue = CPLAtofM( pszText );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If this is a \"base\" raster, we should scan for any              */\n/*      associated overviews, internal mask bands and subdatasets.      */\n/* -------------------------------------------------------------------- */\n    if( bBase )\n    {\n        char **papszSubdatasets = NULL;\n        int  iDirIndex = 0;\n\n        FlushDirectory();  \n        while( !TIFFLastDirectory( hTIFF ) \n               && (iDirIndex == 0 || TIFFReadDirectory( hTIFF ) != 0) )\n        {\n            toff_t\tnThisDir = TIFFCurrentDirOffset(hTIFF);\n            uint32\tnSubType = 0;\n\n            *ppoActiveDSRef = NULL; // our directory no longer matches this ds\n            \n            iDirIndex++;\n\n            if( !TIFFGetField(hTIFF, TIFFTAG_SUBFILETYPE, &nSubType) )\n                nSubType = 0;\n\n            /* Embedded overview of the main image */\n            if ((nSubType & FILETYPE_REDUCEDIMAGE) != 0 &&\n                (nSubType & FILETYPE_MASK) == 0 &&\n                iDirIndex != 1 )\n            {\n                GTiffDataset\t*poODS;\n                \n                poODS = new GTiffDataset();\n                if( poODS->OpenOffset( hTIFF, ppoActiveDSRef, nThisDir, FALSE, \n                                       eAccess ) != CE_None \n                    || poODS->GetRasterCount() != GetRasterCount() )\n                {\n                    delete poODS;\n                }\n                else\n                {\n                    CPLDebug( \"GTiff\", \"Opened %dx%d overview.\\n\", \n                              poODS->GetRasterXSize(), poODS->GetRasterYSize());\n                    nOverviewCount++;\n                    papoOverviewDS = (GTiffDataset **)\n                        CPLRealloc(papoOverviewDS, \n                                   nOverviewCount * (sizeof(void*)));\n                    papoOverviewDS[nOverviewCount-1] = poODS;\n                    poODS->poBaseDS = this;\n                }\n            }\n            \n            /* Embedded mask of the main image */\n            else if ((nSubType & FILETYPE_MASK) != 0 &&\n                     (nSubType & FILETYPE_REDUCEDIMAGE) == 0 &&\n                     poMaskDS == NULL )\n            {\n                poMaskDS = new GTiffDataset();\n                \n                /* The TIFF6 specification - page 37 - only allows 1 SamplesPerPixel and 1 BitsPerSample\n                   Here we support either 1 or 8 bit per sample\n                   and we support either 1 sample per pixel or as many samples as in the main image\n                   We don't check the value of the PhotometricInterpretation tag, which should be\n                   set to \"Transparency mask\" (4) according to the specification (page 36)\n                   ... But the TIFF6 specification allows image masks to have a higher resolution than\n                   the main image, what we don't support here\n                */\n\n                if( poMaskDS->OpenOffset( hTIFF, ppoActiveDSRef, nThisDir, \n                                          FALSE, eAccess ) != CE_None \n                    || poMaskDS->GetRasterCount() == 0\n                    || !(poMaskDS->GetRasterCount() == 1 || poMaskDS->GetRasterCount() == GetRasterCount())\n                    || poMaskDS->GetRasterXSize() != GetRasterXSize()\n                    || poMaskDS->GetRasterYSize() != GetRasterYSize()\n                    || poMaskDS->GetRasterBand(1)->GetRasterDataType() != GDT_Byte)\n                {\n                    delete poMaskDS;\n                    poMaskDS = NULL;\n                }\n                else\n                {\n                    CPLDebug( \"GTiff\", \"Opened band mask.\\n\");\n                    poMaskDS->poBaseDS = this;\n                    \n                    poMaskDS->bPromoteTo8Bits = CSLTestBoolean(CPLGetConfigOption(\"GDAL_TIFF_INTERNAL_MASK_TO_8BIT\", \"YES\"));\n                }\n            }\n            \n            /* Embedded mask of an overview */\n            /* The TIFF6 specification allows the combination of the FILETYPE_xxxx masks */\n            else if ((nSubType & FILETYPE_REDUCEDIMAGE) != 0 &&\n                     (nSubType & FILETYPE_MASK) != 0)\n            {\n                GTiffDataset* poDS = new GTiffDataset();\n                if( poDS->OpenOffset( hTIFF, ppoActiveDSRef, nThisDir, FALSE, \n                                      eAccess ) != CE_None\n                    || poDS->GetRasterCount() == 0\n                    || poDS->GetRasterBand(1)->GetRasterDataType() != GDT_Byte)\n                {\n                    delete poDS;\n                }\n                else\n                {\n                    int i;\n                    for(i=0;i<nOverviewCount;i++)\n                    {\n                        if (((GTiffDataset*)papoOverviewDS[i])->poMaskDS == NULL &&\n                            poDS->GetRasterXSize() == papoOverviewDS[i]->GetRasterXSize() &&\n                            poDS->GetRasterYSize() == papoOverviewDS[i]->GetRasterYSize() &&\n                            (poDS->GetRasterCount() == 1 || poDS->GetRasterCount() == GetRasterCount()))\n                        {\n                            CPLDebug( \"GTiff\", \"Opened band mask for %dx%d overview.\\n\",\n                                      poDS->GetRasterXSize(), poDS->GetRasterYSize());\n                            ((GTiffDataset*)papoOverviewDS[i])->poMaskDS = poDS;\n                            poDS->bPromoteTo8Bits = CSLTestBoolean(CPLGetConfigOption(\"GDAL_TIFF_INTERNAL_MASK_TO_8BIT\", \"YES\"));\n                            poDS->poBaseDS = this;\n                            break;\n                        }\n                    }\n                    if (i == nOverviewCount)\n                    {\n                        delete poDS;\n                    }\n                }\n            }\n            else if( nSubType == 0 ) {\n                CPLString osName, osDesc;\n                uint32\tnXSize, nYSize;\n                uint16  nSPP;\n\n                TIFFGetField( hTIFF, TIFFTAG_IMAGEWIDTH, &nXSize );\n                TIFFGetField( hTIFF, TIFFTAG_IMAGELENGTH, &nYSize );\n                if( !TIFFGetField(hTIFF, TIFFTAG_SAMPLESPERPIXEL, &nSPP ) )\n                    nSPP = 1;\n\n                osName.Printf( \"SUBDATASET_%d_NAME=GTIFF_DIR:%d:%s\", \n                               iDirIndex, iDirIndex, osFilename.c_str() );\n                osDesc.Printf( \"SUBDATASET_%d_DESC=Page %d (%dP x %dL x %dB)\", \n                               iDirIndex, iDirIndex, \n                               (int)nXSize, (int)nYSize, nSPP );\n\n                papszSubdatasets = \n                    CSLAddString( papszSubdatasets, osName );\n                papszSubdatasets = \n                    CSLAddString( papszSubdatasets, osDesc );\n            }\n\n            // Make sure we are stepping from the expected directory regardless\n            // of churn done processing the above.\n            if( TIFFCurrentDirOffset(hTIFF) != nThisDir )\n                TIFFSetSubDirectory( hTIFF, nThisDir );\n            *ppoActiveDSRef = NULL;\n        }\n\n        /* If we have a mask for the main image, loop over the overviews, and if they */\n        /* have a mask, let's set this mask as an overview of the main mask... */\n        if (poMaskDS != NULL)\n        {\n            int i;\n            for(i=0;i<nOverviewCount;i++)\n            {\n                if (((GTiffDataset*)papoOverviewDS[i])->poMaskDS != NULL)\n                {\n                    poMaskDS->nOverviewCount++;\n                    poMaskDS->papoOverviewDS = (GTiffDataset **)\n                        CPLRealloc(poMaskDS->papoOverviewDS, \n                                poMaskDS->nOverviewCount * (sizeof(void*)));\n                    poMaskDS->papoOverviewDS[poMaskDS->nOverviewCount-1] =\n                            ((GTiffDataset*)papoOverviewDS[i])->poMaskDS;\n                }\n            }\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Only keep track of subdatasets if we have more than one         */\n/*      subdataset (pair).                                              */\n/* -------------------------------------------------------------------- */\n        if( CSLCount(papszSubdatasets) > 2 )\n        {\n            oGTiffMDMD.SetMetadata( papszSubdatasets, \"SUBDATASETS\" );\n        }\n        CSLDestroy( papszSubdatasets );\n    }\n\n    return( CE_None );\n}"
]