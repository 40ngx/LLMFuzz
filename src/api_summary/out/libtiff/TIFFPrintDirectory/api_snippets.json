[
    "bool\ntiffns::tiff_to_png(const char *tiffname, FILE *pngfp)\n{\n    bool bigendian = test_bigendian();\n\n    TIFF *tif = TIFFOpen(tiffname, \"r\");\n    if (!tif) {\n        err_printf(\"Failed to open %s.\", tiffname);\n        return (false);\n    }\n\n    png_struct *png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING,\n        &jmpbuf_struct, error_handler, 0);\n    if (!png_ptr) {\n        TIFFClose(tif);\n        return (false);\n    }\n\n    png_info *info_ptr = png_create_info_struct(png_ptr);\n    if (!info_ptr) {\n        png_destroy_write_struct(&png_ptr, 0);\n        TIFFClose(tif);\n        return (false);\n    }\n\n    if (setjmp(jmpbuf_struct.jmpbuf)) {\n        png_destroy_write_struct(&png_ptr, 0);\n        TIFFClose(tif);\n        return (false);\n    }\n\n    png_init_io(png_ptr, pngfp);\n\n#ifdef DEBUG\n    if (verbose) {\n        int byteswapped = TIFFIsByteSwapped(tif);\n\n        fprintf(stderr, \"tiff_to_png:  \");\n        TIFFPrintDirectory(tif, stderr, TIFFPRINT_NONE);\n        fprintf(stderr, \"tiff_to_png:  byte order = %s\\n\",\n            ((bigendian && byteswapped) || (!bigendian && !byteswapped))?\n            \"little-endian (Intel)\" : \"big-endian (Motorola)\");\n        fprintf(stderr, \"tiff_to_png:  this machine is %s-endian\\n\",\n            bigendian? \"big\" : \"little\");\n    }\n#endif\n\n    unsigned short photometric;\n    if (!TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric)) {\n        err_printf(\"TIFF photometric could not be retrieved (%s)\", tiffname);\n        png_destroy_write_struct(&png_ptr, &info_ptr);\n        TIFFClose(tif);\n        return (false);\n    }\n    unsigned short bps;\n    if (!TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bps))\n        bps = 1;\n    unsigned short spp;\n    if (!TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &spp))\n        spp = 1;\n    unsigned short planar;\n    if (!TIFFGetField(tif, TIFFTAG_PLANARCONFIG, &planar))\n        planar = 1;\n\n    unsigned short tiled = TIFFIsTiled(tif);\n\n    int cols, rows;\n    TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &cols);\n    TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &rows);\n    png_uint_32 width = cols;\n\n    bool have_res = false;\n    float xres, yres;\n    png_uint_32 res_x=0, res_y=0;\n    int unit_type = 0;\n    if (TIFFGetField(tif, TIFFTAG_XRESOLUTION, &xres) &&\n            TIFFGetField(tif, TIFFTAG_YRESOLUTION, &yres) && \n            (xres != 0.0) && (yres != 0.0)) {\n        uint16_t resunit;\n        have_res = true;\n#ifdef DEBUG\n        if (verbose) {\n            float ratio = xres / yres;\n            fprintf(stderr,\n                \"tiff_to_png:  aspect ratio (hor/vert) = %g (%g / %g)\\n\",\n                ratio, xres, yres);\n            if (0.95 < ratio && ratio < 1.05)\n                fprintf(stderr, \"tiff2png:  near-unity aspect ratio\\n\");\n            else if (1.90 < ratio && ratio < 2.10)\n                fprintf(stderr, \"tiff2png:  near-2X aspect ratio\\n\");\n            else\n                fprintf(stderr, \"tiff2png:  non-square, non-2X pixels\\n\");\n        }\n#endif\n\n        if (!TIFFGetField(tif, TIFFTAG_RESOLUTIONUNIT, &resunit))\n            resunit = RESUNIT_INCH;\n\n        // Convert from TIFF data (floats) to PNG data (unsigned longs).\n        switch (resunit) {\n        case RESUNIT_CENTIMETER:\n            res_x = (png_uint_32)(100.0*xres + 0.5);\n            res_y = (png_uint_32)(100.0*yres + 0.5);\n            unit_type = PNG_RESOLUTION_METER;\n            break;\n        case RESUNIT_INCH:\n            res_x = (png_uint_32)(39.37*xres + 0.5);\n            res_y = (png_uint_32)(39.37*yres + 0.5);\n            unit_type = PNG_RESOLUTION_METER;\n            break;\n        case RESUNIT_NONE:\n        default:\n            res_x = (png_uint_32)(100.0*xres + 0.5);\n            res_y = (png_uint_32)(100.0*yres + 0.5);\n            unit_type = PNG_RESOLUTION_UNKNOWN;\n            break;\n        }\n    }\n\n#ifdef DEBUG\n    if (verbose) {\n        fprintf(stderr, \"tiff_to_png:  %dx%dx%d image\\n\", cols, rows,\n            bps * spp);\n        fprintf(stderr, \"tiff_to_png:  %d bit%s/sample, %d sample%s/pixel\\n\",\n            bps, bps == 1? \"\" : \"s\", spp, spp == 1? \"\" : \"s\");\n    }\n#endif\n\n    // Detect tiff filetype.\n\n    int maxval = (1 << bps) - 1;\n#ifdef DEBUG\n    if (verbose)\n        fprintf(stderr, \"tiff_to_png:  maxval=%d\\n\", maxval);\n#endif\n\n    int color_type = -1;\n    int bit_depth = 0;\n    int colors = 0;\n    png_color palette[MAXCOLORS];\n    unsigned short tiff_compression_method;\n\n    switch (photometric) {\n    case PHOTOMETRIC_MINISWHITE:\n    case PHOTOMETRIC_MINISBLACK:\n#ifdef DEBUG\n        if (verbose) {\n            fprintf(stderr,\n                \"tiff_to_png:  %d graylevels (min = %s)\\n\", maxval + 1,\n                photometric == PHOTOMETRIC_MINISBLACK? \"black\" : \"white\");\n        }\n#endif\n        if (spp == 1) {\n            // no alpha\n            color_type = PNG_COLOR_TYPE_GRAY;\n#ifdef DEBUG\n            if (verbose)\n                fprintf(stderr, \"tiff_to_png:  color type = grayscale\\n\");\n#endif\n            bit_depth = bps;\n        }\n        else {\n            // must be alpha\n            color_type = PNG_COLOR_TYPE_GRAY_ALPHA;\n#ifdef DEBUG\n            if (verbose)\n                fprintf(stderr,\n                    \"tiff_to_png:  color type = grayscale + alpha\\n\");\n#endif\n            if (bps <= 8)\n                bit_depth = 8;\n            else\n                bit_depth = bps;\n        }\n        break;\n\n    case PHOTOMETRIC_PALETTE:\n        {\n            int palette_8bit; // Set iff all color values in TIFF palette\n                              // are < 256.\n\n            color_type = PNG_COLOR_TYPE_PALETTE;\n#ifdef DEBUG\n            if (verbose)\n                fprintf(stderr, \"tiff_to_png:  color type = paletted\\n\");\n#endif\n\n            unsigned short *redcolormap;\n            unsigned short *greencolormap;\n            unsigned short *bluecolormap;\n            if (!TIFFGetField(tif, TIFFTAG_COLORMAP, &redcolormap,\n                    &greencolormap, &bluecolormap)) {\n                err_printf(\"Cannot retrieve TIFF colormaps (%s)\\n\", tiffname);\n                png_destroy_write_struct(&png_ptr, &info_ptr);\n                TIFFClose(tif);\n                return (false);\n            }\n            colors = maxval + 1;\n            if (colors > MAXCOLORS) {\n                err_printf(\"Palette too large (%d colors) (%s)\\n\",\n                    colors, tiffname);\n                png_destroy_write_struct(&png_ptr, &info_ptr);\n                TIFFClose(tif);\n                return (false);\n            }\n            // Max PNG palette-size is 8 bits, you could convert to\n            // full-color.\n            if (bps >= 8) \n                bit_depth = 8;\n            else\n                bit_depth = bps;\n\n            // PLTE chunk\n            // TIFF palettes contain 16-bit shorts, while PNG palettes\n            // are 8-bit.  Some broken (??) software puts 8-bit values\n            // in the shorts, which would make the palette come out\n            // all zeros, which isn't good.  We check...\n\n            palette_8bit = 1;\n            for (int i = 0 ; i < colors ; i++) {\n                if (redcolormap[i] > 255 || greencolormap[i] > 255 ||\n                         bluecolormap[i] > 255) {\n                     palette_8bit = 0;\n                     break;\n                }\n            } \n#ifdef DEBUG\n            if (palette_8bit && verbose)\n                fprintf(stderr,\n                    \"tiff_to_png warning:  assuming 8-bit palette values.\\n\");\n#endif\n\n            for (int i = 0 ; i < colors ; i++) {\n                if (palette_8bit) {\n                    palette[i].red   = (png_byte)redcolormap[i];\n                    palette[i].green = (png_byte)greencolormap[i];\n                    palette[i].blue  = (png_byte)bluecolormap[i];\n                }\n                else {\n                    palette[i].red   = (png_byte)(redcolormap[i] >> 8);\n                    palette[i].green = (png_byte)(greencolormap[i] >> 8);\n                    palette[i].blue  = (png_byte)(bluecolormap[i] >> 8);\n                }\n            }\n            break;\n        }\n\n    case PHOTOMETRIC_YCBCR:\n        TIFFGetField(tif, TIFFTAG_COMPRESSION, &tiff_compression_method);\n        if (tiff_compression_method == COMPRESSION_JPEG &&\n                planar == PLANARCONFIG_CONTIG) {\n            // Can rely on libjpeg to convert to RGB.\n            TIFFSetField(tif, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n            photometric = PHOTOMETRIC_RGB;\n#ifdef DEBUG\n            if (verbose)\n                fprintf(stderr, \"tiff2png:  original color type = YCbCr \"\n                    \"with JPEG compression.\\n\");\n#endif\n        }\n        else {\n            err_printf(\n                \"Don't know how to handle PHOTOMETRIC_YCBCR with \"\n                \"compression %d\\n\"\n                \"  (%sJPEG) and planar config %d (%scontiguous)\\n\"\n                \"  (%s)\\n\", tiff_compression_method,\n                tiff_compression_method == COMPRESSION_JPEG? \"\" : \"not \",\n                planar, planar == PLANARCONFIG_CONTIG? \"\" : \"not \", tiffname);\n            png_destroy_write_struct(&png_ptr, &info_ptr);\n            TIFFClose(tif);\n            return (false);\n        }\n        // fall thru... \n\n    case PHOTOMETRIC_RGB:\n        if (spp == 3) {\n            color_type = PNG_COLOR_TYPE_RGB;\n#ifdef DEBUG\n            if (verbose)\n                fprintf(stderr, \"tiff_to_png:  color type = truecolor\\n\");\n#endif\n        }\n        else {\n            color_type = PNG_COLOR_TYPE_RGB_ALPHA;\n#ifdef DEBUG\n            if (verbose)\n                fprintf(stderr,\n                    \"tiff_to_png:  color type = truecolor + alpha\\n\");\n#endif\n        }\n        if (bps <= 8)\n            bit_depth = 8;\n        else\n            bit_depth = bps;\n        break;\n\n    case PHOTOMETRIC_LOGL:\n    case PHOTOMETRIC_LOGLUV:\n        TIFFGetField(tif, TIFFTAG_COMPRESSION, &tiff_compression_method);\n        if (tiff_compression_method != COMPRESSION_SGILOG &&\n                tiff_compression_method != COMPRESSION_SGILOG24) {\n            err_printf(\"Don't know how to handle PHOTOMETRIC_LOGL%s with\\n\"\n                \"  compression %d (not SGILOG) (%s)\\n\",\n                photometric == PHOTOMETRIC_LOGLUV? \"UV\" : \"\",\n                tiff_compression_method, tiffname);\n            png_destroy_write_struct(&png_ptr, &info_ptr);\n            TIFFClose(tif);\n            return (false);\n        }\n        // rely on library to convert to RGB/greyscale.\n#ifdef LIBTIFF_HAS_16BIT_INTEGER_FORMAT\n        if (bps > 8) {\n            // SGILOGDATAFMT_16BIT converts to a floating-point\n            // luminance value; U,V are left as such. \n            // SGILOGDATAFMT_16BIT_INT doesn't exist.\n\n            TIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_16BIT_INT);\n            bit_depth = bps = 16;\n        }\n        else\n#endif\n        {\n            // SGILOGDATAFMT_8BIT converts to normal grayscale or RGB format.\n            TIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_8BIT);\n            bit_depth = bps = 8;\n        }\n        if (photometric == PHOTOMETRIC_LOGL) {\n            photometric = PHOTOMETRIC_MINISBLACK;\n            color_type = PNG_COLOR_TYPE_GRAY;\n#ifdef DEBUG\n            if (verbose) {\n                fprintf(stderr, \"tiff_to_png:  original color type = \"\n                    \"logL with SGILOG compression.\\n\");\n                fprintf(stderr, \"tiff_to_png:  color type = grayscale.\\n\");\n            }\n#endif\n        }\n        else {\n            photometric = PHOTOMETRIC_RGB;\n            color_type = PNG_COLOR_TYPE_RGB;\n#ifdef DEBUG\n            if (verbose) {\n                fprintf(stderr, \"tiff_to_png:  original color type = \"\n                    \"logLUV with SGILOG compression.\\n\");\n                fprintf(stderr, \"tiff_to_png:  color type = truecolor.\\n\");\n            }\n#endif\n        }\n        break;\n\n    case PHOTOMETRIC_MASK:\n    case PHOTOMETRIC_SEPARATED:\n    case PHOTOMETRIC_CIELAB:\n    case PHOTOMETRIC_DEPTH:\n        err_printf(\"Don't know how to handle %s (%s)\\n\",\n            photometric == PHOTOMETRIC_MASK?      \"PHOTOMETRIC_MASK\" :\n            photometric == PHOTOMETRIC_SEPARATED? \"PHOTOMETRIC_SEPARATED\" :\n            photometric == PHOTOMETRIC_CIELAB?    \"PHOTOMETRIC_CIELAB\" :\n            photometric == PHOTOMETRIC_DEPTH?     \"PHOTOMETRIC_DEPTH\" :\n                                                  \"unknown photometric\",\n            tiffname);\n        png_destroy_write_struct(&png_ptr, &info_ptr);\n        TIFFClose(tif);\n        return (false);\n\n    default:\n        err_printf(\"Unknown photometric (%d) (%s)\\n\",\n            photometric, tiffname);\n        png_destroy_write_struct(&png_ptr, &info_ptr);\n        TIFFClose(tif);\n        return (false);\n    }\n    int tiff_color_type = color_type;\n\n#ifdef DEBUG\n    if (verbose)\n        fprintf(stderr, \"tiff_to_png:  bit depth = %d\\n\", bit_depth);\n#endif\n\n    // Put parameter info in png-chunks.\n\n    png_set_IHDR(png_ptr, info_ptr, width, rows, bit_depth, color_type,\n        PNG_INTERLACE_NONE, PNG_COMPRESSION_TYPE_DEFAULT,\n        PNG_FILTER_TYPE_DEFAULT);\n\n//    if (png_compression_level != -1)\n//        png_set_compression_level(png_ptr, png_compression_level);\n\n    if (color_type == PNG_COLOR_TYPE_PALETTE)\n        png_set_PLTE(png_ptr, info_ptr, palette, colors);\n\n    // gAMA chunk\n//    if (gamma != -1.0) {\n#ifdef DEBUG\n//        if (verbose)\n//            fprintf(stderr, \"tiff_to_png:  gamma = %f\\n\", gamma);\n#endif\n//        png_set_gAMA(png_ptr, info_ptr, gamma);\n//    }\n\n    // pHYs chunk\n    if (have_res)\n        png_set_pHYs(png_ptr, info_ptr, res_x, res_y, unit_type);\n\n    png_write_info(png_ptr, info_ptr);\n    png_set_packing(png_ptr);\n\n    // Allocate space for one line (or row of tiles) of TIFF image.\n\n    unsigned char *tiffline = 0;\n    unsigned char *tifftile = 0;\n    unsigned char *tiffstrip = 0;\n    size_t tilesz = 0L;\n    int num_tilesX = 0;\n    uint32_t tile_width = 0, tile_height = 0;\n\n    if (!tiled) {\n        // strip-based TIFF\n        if (planar == 1) {\n            // contiguous picture\n            tiffline = (unsigned char*)malloc(TIFFScanlineSize(tif));\n        }\n        else {\n            // separated planes\n            tiffline = (unsigned char*)malloc(TIFFScanlineSize(tif) * spp);\n        }\n    }\n    else {\n        // Allocate space for one \"row\" of tiles.\n\n        TIFFGetField(tif, TIFFTAG_TILEWIDTH, &tile_width);\n        TIFFGetField(tif, TIFFTAG_TILELENGTH, &tile_height);\n\n        num_tilesX = (width+tile_width-1)/tile_width;\n\n        if (planar == 1) {\n            tilesz = TIFFTileSize(tif);\n            tifftile = new unsigned char[tilesz];\n            size_t stripsz = (tile_width*num_tilesX) * tile_height * spp;\n            tiffstrip = new unsigned char[stripsz];\n            tiffline = tiffstrip;\n            // Just set the line to the top of the strip, we'll move it\n            // through below.\n        }\n        else {\n            err_printf(\n                \"Can't handle tiled separated-plane TIFF format (%s).\\n\",\n                tiffname);\n            png_destroy_write_struct (&png_ptr, &info_ptr);\n            TIFFClose(tif);\n            return (false);\n        }\n    }\n\n    if (!tiffline) {\n        err_printf(\"Can't allocate memory for TIFF scanline buffer (%s).\\n\",\n            tiffname);\n        png_destroy_write_struct(&png_ptr, &info_ptr);\n        TIFFClose(tif);\n        if (tiled && planar == 1)\n            delete [] tifftile;\n        return (false);\n    }\n\n    if (planar != 1) {\n        // In case we must combine more planes into one.\n        tiffstrip = new unsigned char[TIFFScanlineSize(tif)];\n        if (!tiffstrip) {\n            err_printf(\"Can't allocate memory for TIFF strip buffer (%s).\\n\",\n                tiffname);\n            png_destroy_write_struct(&png_ptr, &info_ptr);\n            TIFFClose(tif);\n            free(tiffline);\n            return (false);\n        }\n    }\n\n    // Allocate space for one line of PNG image.\n    // max: 3 color channels plus one alpha channel, 16 bit => 8 bytes/pixel\n\n    png_byte *pngline = new unsigned char[cols * 8];\n    for (int pass = 0 ; pass < png_set_interlace_handling(png_ptr); pass++) {\n        for (int row = 0; row < rows; row++) {\n            if (planar == 1) {\n                // contiguous picture\n                if (!tiled) {\n                    if (TIFFReadScanline(tif, tiffline, row, 0) < 0) {\n                        err_printf(\"Bad data read on line %d (%s).\\n\",\n                            row, tiffname);\n                        png_destroy_write_struct(&png_ptr, &info_ptr);\n                        TIFFClose(tif);\n                        free(tiffline);\n                        return (false);\n                    }\n                }\n                else {\n                    // tiled\n                    int col, ok=1, r;\n                    int tileno;\n                    // Read in one row of tiles and hand out the data\n                    // one scanline at a time so the code below\n                    // doesn't need to change.\n\n                    // Is it time for a new strip?\n                    if ((row % tile_height) == 0) {\n                        for (col = 0; ok && col < num_tilesX; col += 1 ) {\n                            tileno = col+(row/tile_height)*num_tilesX;\n                            // Read the tile into an RGB array.\n                            if (!TIFFReadEncodedTile(tif, tileno, tifftile,\n                                    tilesz)) {\n                                ok = 0;\n                                break;\n                            }\n\n                            // Copy this tile into the row buffer.\n                            for (r = 0; r < (int) tile_height; r++) {\n                                void *dest = tiffstrip + (r * tile_width *\n                                    num_tilesX * spp) +\n                                    (col * tile_width * spp);\n                                void *src  = tifftile + (r * tile_width * spp);\n                                memcpy(dest, src, (tile_width * spp));\n                            }\n                        }\n                        tiffline = tiffstrip; // Set tileline to top of strip.\n                    }\n                    else {\n                        tiffline = tiffstrip + ((row % tile_height) *\n                            ((tile_width * num_tilesX) * spp));\n                    }\n                }\n            }\n            else {\n                // Separated planes, then combine more strips into one line.\n                unsigned short s;\n\n                // XXX:  this assumes strips; are separated-plane\n                // tiles possible?\n\n                unsigned char *p_line = tiffline;\n                for (int n = 0; n < (cols/8 * bps*spp); n++)\n                    *p_line++ = '\\0';\n\n                for (s = 0; s < spp; s++) {\n                    unsigned char *p_strip = tiffstrip;\n                    int getbitsleft = 8;\n                    p_line = tiffline;\n                    int putbitsleft = 8;\n\n                    if (TIFFReadScanline(tif, tiffstrip, row, s) < 0) {\n                        err_printf(\"Bad data read on line %d (%s).\\n\",\n                            row, tiffname);\n                        png_destroy_write_struct(&png_ptr, &info_ptr);\n                        TIFFClose(tif);\n                        delete [] tiffline;\n                        delete [] tiffstrip;\n                        return (false);\n                    }\n\n                    p_strip = (unsigned char *)tiffstrip;\n                    unsigned char sample = '\\0';\n                    for (int i = 0 ; i < s ; i++)\n                        PUT_LINE_SAMPLE\n                    for (int n = 0; n < cols; n++) {\n                        GET_STRIP_SAMPLE\n                        PUT_LINE_SAMPLE\n                        sample = '\\0';\n                        for (int i = 0 ; i < (spp-1) ; i++)\n                            PUT_LINE_SAMPLE\n                    }\n                }\n            }\n\n            unsigned char *p_line = tiffline;\n            int bitsleft = 8;\n            png_byte *p_png = pngline;\n\n            // Convert from tiff-line to png-line.\n\n            switch (tiff_color_type) {\n            case PNG_COLOR_TYPE_GRAY:       // we know spp == 1\n                for (int col = cols; col > 0; --col) {\n                    switch (bps) {\n                    case 16:\n#ifdef INVERT_MINISWHITE\n                        if (photometric == PHOTOMETRIC_MINISWHITE) {\n                            unsigned char sample;\n                            int sample16;\n                            if (bigendian) {\n                                // same as PNG order\n                                GET_LINE_SAMPLE\n                                sample16 = sample;\n                                sample16 <<= 8;\n                                GET_LINE_SAMPLE\n                                sample16 |= sample;\n                            }\n                            else {\n                                // reverse of PNG\n                                GET_LINE_SAMPLE\n                                sample16 = sample;\n                                GET_LINE_SAMPLE\n                                sample16 |= (((int)sample) << 8);\n                            }\n                            sample16 = maxval - sample16;\n                            *p_png++ = (unsigned char)((sample16 >> 8) & 0xff);\n                            *p_png++ = (unsigned char)(sample16 & 0xff);\n                        }\n                        else // not PHOTOMETRIC_MINISWHITE\n#endif\n                        {\n                            unsigned char sample;\n                            if (bigendian) {\n                                GET_LINE_SAMPLE\n                                *p_png++ = sample;\n                                GET_LINE_SAMPLE\n                                *p_png++ = sample;\n                            }\n                            else {\n                                GET_LINE_SAMPLE\n                                p_png[1] = sample;\n                                GET_LINE_SAMPLE\n                                *p_png = sample;\n                                p_png += 2;\n                            }\n                        }\n                        break;\n\n                    case 8:\n                    case 4:\n                    case 2:\n                    case 1:\n                        {\n                            unsigned char sample;\n                            GET_LINE_SAMPLE\n#ifdef INVERT_MINISWHITE\n                            if (photometric == PHOTOMETRIC_MINISWHITE)\n                                sample = maxval - sample;\n#endif\n                            *p_png++ = sample;\n                        }\n                        break;\n\n                    }\n                }\n                break;\n\n            case PNG_COLOR_TYPE_GRAY_ALPHA:\n                for (int col = 0; col < cols; col++) {\n                    for (int i = 0 ; i < spp ; i++) {\n                        switch (bps) {\n                        case 16:\n#ifdef INVERT_MINISWHITE\n                            if (photometric == PHOTOMETRIC_MINISWHITE &&\n                                    i == 0) {\n                                unsigned char sample;\n                                int sample16;\n                                if (bigendian) {\n                                    GET_LINE_SAMPLE\n                                    sample16 = (sample << 8);\n                                    GET_LINE_SAMPLE\n                                    sample16 |= sample;\n                                }\n                                else {\n                                    GET_LINE_SAMPLE\n                                    sample16 = sample;\n                                    GET_LINE_SAMPLE\n                                    sample16 |= (((int)sample) << 8);\n                                }\n                                sample16 = maxval - sample16;\n                                *p_png++ = (unsigned char)(\n                                    (sample16 >> 8) & 0xff);\n                                *p_png++ = (unsigned char)(sample16 & 0xff);\n                            }\n                            else\n#endif\n                            {\n                                unsigned char sample;\n                                if (bigendian) {\n                                    GET_LINE_SAMPLE\n                                    *p_png++ = sample;\n                                    GET_LINE_SAMPLE\n                                    *p_png++ = sample;\n                                }\n                                else {\n                                    GET_LINE_SAMPLE\n                                    p_png[1] = sample;\n                                    GET_LINE_SAMPLE\n                                    *p_png = sample;\n                                    p_png += 2;\n                                }\n                            }\n                            break;\n\n                        case 8:\n                            {\n                                unsigned char sample;\n                                GET_LINE_SAMPLE\n#ifdef INVERT_MINISWHITE\n                                if (photometric == PHOTOMETRIC_MINISWHITE &&\n                                        i == 0)\n                                    sample = maxval - sample;\n#endif\n                                *p_png++ = sample;\n                            }\n                            break;\n\n                        case 4:\n                            {\n                                unsigned char sample;\n                                GET_LINE_SAMPLE\n#ifdef INVERT_MINISWHITE\n                                if (photometric == PHOTOMETRIC_MINISWHITE &&\n                                        i == 0)\n                                    sample = maxval - sample;\n#endif\n                                *p_png++ = sample * 17;   /* was 16 */\n                            }\n                            break;\n\n                        case 2:\n                            {\n                                unsigned char sample;\n                                GET_LINE_SAMPLE\n#ifdef INVERT_MINISWHITE\n                                if (photometric == PHOTOMETRIC_MINISWHITE &&\n                                        i == 0)\n                                    sample = maxval - sample;\n#endif\n                                *p_png++ = sample * 85;   /* was 64 */\n                            }\n                            break;\n\n                        case 1:\n                            {\n                                unsigned char sample;\n                                GET_LINE_SAMPLE\n#ifdef INVERT_MINISWHITE\n                                if (photometric == PHOTOMETRIC_MINISWHITE &&\n                                        i == 0)\n                                    sample = maxval - sample;\n#endif\n                                *p_png++ = sample * 255;  /* was 128...oops */\n                            }\n                            break;\n\n                        }\n                    }\n                }\n                break;\n\n            case PNG_COLOR_TYPE_RGB:\n            case PNG_COLOR_TYPE_RGB_ALPHA:\n                for (int col = 0; col < cols; col++) {\n                    // Process for red, green and blue (and when\n                    // applicable alpha).\n\n                    for (int i = 0 ; i < spp ; i++) {\n                        switch (bps) {\n                        case 16:\n                            // XXX:  do we need INVERT_MINISWHITE\n                            // support here, too, or is that only for\n                            // grayscale?\n\n                            unsigned char sample;\n                            if (bigendian) {\n                                GET_LINE_SAMPLE\n                                *p_png++ = sample;\n                                GET_LINE_SAMPLE\n                                *p_png++ = sample;\n                            }\n                            else {\n                                GET_LINE_SAMPLE\n                                p_png[1] = sample;\n                                GET_LINE_SAMPLE\n                                *p_png = sample;\n                                p_png += 2;\n                            }\n                            break;\n\n                        case 8:\n                            GET_LINE_SAMPLE\n                            *p_png++ = sample;\n                            break;\n\n                        case 4:\n                            GET_LINE_SAMPLE\n                            *p_png++ = sample * 17;\n                            break;\n\n                        case 2:\n                            GET_LINE_SAMPLE\n                            *p_png++ = sample * 85;\n                            break;\n\n                        case 1:\n                            GET_LINE_SAMPLE\n                            *p_png++ = sample * 255;\n                           break;\n\n                        }\n                    }\n                }\n                break;\n  \n            case PNG_COLOR_TYPE_PALETTE:\n                for (int col = 0; col < cols; col++) {\n                    unsigned char sample;\n                    GET_LINE_SAMPLE\n                    *p_png++ = sample;\n                }\n                break;\n  \n            default:\n                err_printf(\"Unknown photometric (%d) (%s).\\n\",\n                    photometric, tiffname);\n                png_destroy_write_struct(&png_ptr, &info_ptr);\n                TIFFClose(tif);\n                delete [] tiffline;\n                if (tiled && planar == 1)\n                    delete [] tifftile;\n                else if (planar != 1)\n                    delete [] tiffstrip;\n                return (false);\n\n            }\n            png_write_row(png_ptr, pngline);\n        }\n    }\n\n    TIFFClose(tif);\n\n    png_write_end(png_ptr, info_ptr);\n\n    png_destroy_write_struct(&png_ptr, &info_ptr);\n\n    free(tiffline);\n    if (tiled && planar == 1)\n        delete [] tifftile;\n    else if (planar != 1)\n        delete [] tiffstrip;\n    return (true);\n}",
    "void TEST_AGAINST_LIBTIFF(const std::string& filename, std::vector<TestResult>& test_results) {\r\n#ifdef TINYTIFF_TEST_LIBTIFF\r\n    HighResTimer timer, timer1;\r\n    bool ok=false;\r\n    std::cout<<\"\\n\\nreading '\"<<std::string(filename)<<\"' with tinytiff and libtiff and checking read contents ... filesize = \"<<bytestostr(get_filesize(filename.c_str()))<<\"\\n\";\r\n    test_results.emplace_back();\r\n    test_results.back().name=std::string(\"TEST_AGAINST_LIBTIFF(\")+std::string(filename)+std::string(\")\");\r\n    test_results.back().success=ok=false;\r\n    test_results.back().numImages=0;\r\n    try {\r\n        timer.start();\r\n        std::cout<<\"    libTIFF: opening file with     [duration: \"<<floattounitstr(double(timer.get_time())/1.0e6, \"s\")<<\" ]\\n\";\r\n        TIFF* ltiff=TIFFOpen(filename.c_str(), \"r\");\r\n        if (!ltiff) {\r\n            TESTFAIL(\"libTIFF ERROR: reading (not existent, not accessible or no TIFF file)\", test_results.back())\r\n        } else {\r\n            timer.start();\r\n            uint32_t libTIFF_frames=TIFFCountDirectories(ltiff);\r\n            double duration=timer.get_time();\r\n            std::cout<<\"    libTIFF: frames: \"<<libTIFF_frames<<\"     [duration: \"<<duration<<\" us  =  \"<<floattounitstr(duration/1.0e6, \"s\")<<\" ]\\n\";\r\n            std::cout<<\"    TinyTIFF: opening file with     [duration: \"<<floattounitstr(double(timer.get_time())/1.0e6, \"s\")<<\" ]\\n\";\r\n            TinyTIFFReaderFile* tiffr=TinyTIFFReader_open(filename.c_str());\r\n            if (!tiffr) {\r\n                TESTFAIL(\"TinyTIFF ERROR: reading (not existent, not accessible or no TIFF file)\", test_results.back())\r\n                ok=false;\r\n            } else if (TinyTIFFReader_wasError(tiffr)) {\r\n                TESTFAIL(\"TinyTIFF ERROR: \"<<TinyTIFFReader_getLastError(tiffr)<<\"\", test_results.back())\r\n                ok=false;\r\n            } else {\r\n                timer.start();\r\n                uint32_t tinyTIFF_frames=TinyTIFFReader_countFrames(tiffr);\r\n                duration=timer.get_time();\r\n                std::cout<<\"    TinyTIFF: frames: \"<<tinyTIFF_frames<<\"     [duration: \"<<duration<<\" us  =  \"<<floattounitstr(duration/1.0e6, \"s\")<<\" ]\\n\";\r\n                if (TinyTIFFReader_wasError(tiffr)) {\r\n                    TESTFAIL(\"TinyTIFF ERROR: \"<<TinyTIFFReader_getLastError(tiffr)<<\"\", test_results.back())\r\n                    ok=false;\r\n                } else {\r\n                    if (libTIFF_frames!=tinyTIFF_frames) {\r\n                        TESTFAIL(\"number of frames, read with TinyTIFF (\"<<tinyTIFF_frames<<\") and libTIFF (\"<<libTIFF_frames<<\") are not equal!\", test_results.back())\r\n                        ok=false;\r\n                    } else {\r\n                        timer.start();\r\n                        size_t frame=0;\r\n                        ok=true;\r\n                        do {\r\n                            std::cout<<\"   frame: \"<<frame<<std::endl;\r\n                            uint32_t tinyTIFF_width=TinyTIFFReader_getWidth(tiffr);\r\n                            uint32_t tinyTIFF_height=TinyTIFFReader_getHeight(tiffr);\r\n                            uint16_t tinyTIFF_bitspersample=TinyTIFFReader_getBitsPerSample(tiffr, 0);\r\n                            uint16_t tinyTIFF_samplesperpixel=TinyTIFFReader_getSamplesPerPixel(tiffr);\r\n                            const char* tinyTIFF_imagedesc=TinyTIFFReader_getImageDescription(tiffr);\r\n                            std::cout<<\"     tinyTIFF: width=\"<<tinyTIFF_width<<\", height=\"<<tinyTIFF_height<<\", bitspersample=\"<<tinyTIFF_bitspersample<<\", samplesperpixel=\"<<tinyTIFF_samplesperpixel<<\"\\n\";\r\n                            if (frame==0) {\r\n                                const std::string desc=std::to_string(tinyTIFF_width)+\"x\"+std::to_string(tinyTIFF_height)+\"pix/\"+std::to_string(sizeof(TIMAGESAMPLETYPE)*8)+\"bit/\"+std::to_string(tinyTIFF_samplesperpixel)+\"ch/\"+std::to_string(tinyTIFF_frames)+\"frames\";\r\n                                test_results.back().name=std::string(\"TEST_AGAINST_LIBTIFF(\")+desc+\", \"+std::string(filename)+std::string(\")\");\r\n                            }\r\n\r\n                            uint32_t libTIFF_width=0;\r\n                            uint32_t libTIFF_height=0;\r\n                            uint32_t libTIFF_bitspersample=0;\r\n                            uint32_t libTIFF_samplesperpixel=0;\r\n                            char*libtiff_imagedesc;\r\n                            TIFFGetField(ltiff,TIFFTAG_SAMPLESPERPIXEL,&libTIFF_samplesperpixel);\r\n                            TIFFGetField(ltiff,TIFFTAG_BITSPERSAMPLE,&libTIFF_bitspersample);\r\n                            TIFFGetField(ltiff,TIFFTAG_IMAGEWIDTH,&libTIFF_width);\r\n                            TIFFGetField(ltiff,TIFFTAG_IMAGELENGTH,&libTIFF_height);\r\n                            TIFFGetField(ltiff,TIFFTAG_IMAGEDESCRIPTION,&libtiff_imagedesc);\r\n                            TIFFPrintDirectory(ltiff, stdout,TIFFPRINT_STRIPS|TIFFPRINT_COLORMAP);\r\n                            std::cout<<\"     libTIFF:  width=\"<<libTIFF_width<<\", height=\"<<libTIFF_height<<\", bitspersample=\"<<libTIFF_bitspersample<<\", samplesperpixel=\"<<libTIFF_samplesperpixel<<\"\\n\";\r\n\r\n                            if (tinyTIFF_width!=libTIFF_width) {\r\n                                TESTFAIL(\"in frame \"<<frame<<\": TinyTIFF and libTIFF read different widths (TinyTIFF: \"<<tinyTIFF_width<<\" != libTIFF: \"<<libTIFF_width<<\")\", test_results.back())\r\n                                ok=false;\r\n                                break;\r\n                            }\r\n                            if (tinyTIFF_height!=libTIFF_height) {\r\n                                TESTFAIL(\"in frame \"<<frame<<\": TinyTIFF and libTIFF read different heights (TinyTIFF: \"<<tinyTIFF_height<<\" != libTIFF: \"<<libTIFF_height<<\")\", test_results.back())\r\n                                ok=false;\r\n                                break;\r\n                            }\r\n                            if (tinyTIFF_bitspersample!=libTIFF_bitspersample) {\r\n                                TESTFAIL(\"in frame \"<<frame<<\": TinyTIFF and libTIFF read different bitspersamples (TinyTIFF: \"<<tinyTIFF_bitspersample<<\" != libTIFF: \"<<libTIFF_bitspersample<<\")\", test_results.back())\r\n                                ok=false;\r\n                                break;\r\n                            }\r\n                            if (tinyTIFF_samplesperpixel!=libTIFF_samplesperpixel) {\r\n                                TESTFAIL(\"in frame \"<<frame<<\": TinyTIFF and libTIFF read different samplesperpixels (TinyTIFF: \"<<tinyTIFF_samplesperpixel<<\" != libTIFF: \"<<libTIFF_samplesperpixel<<\")\", test_results.back())\r\n                                ok=false;\r\n                                break;\r\n                            }\r\n                            if (tinyTIFF_imagedesc==nullptr || libtiff_imagedesc==nullptr || strcmp(tinyTIFF_imagedesc, libtiff_imagedesc)!=0) {\r\n                                std::cout<<\"       WARNING in frame \"<<frame<<\": TinyTIFF and libTIFF read different descriptions (TinyTIFF: '\"<<tinyTIFF_imagedesc<<\"' != libTIFF: '\"<<libtiff_imagedesc<<\"')\\n\";\r\n                                //ok=false;\r\n                                //break;\r\n                            }\r\n                            if (ok) {\r\n                                for (size_t sample=0; sample<libTIFF_samplesperpixel; sample++) {\r\n                                    std::vector<TIMAGESAMPLETYPE> tinyTIFF_data(tinyTIFF_width*tinyTIFF_height*sizeof(TIMAGESAMPLETYPE)*2, 0);\r\n                                    TinyTIFFReader_getSampleData(tiffr,tinyTIFF_data.data(), sample);\r\n                                    if (TinyTIFFReader_wasError(tiffr)) {\r\n                                        TESTFAIL(\"TinyTIFF ERROR: reading frame \"<<frame<<\", sample \"<<sample<<\":\"<<TinyTIFFReader_getLastError(tiffr)<<\"\", test_results.back())\r\n                                        ok=false;\r\n                                        break;\r\n                                    }\r\n                                    std::vector<TIMAGESAMPLETYPE> libTIFF_data(libTIFF_width*libTIFF_height*sizeof(TIMAGESAMPLETYPE)*2, 0);\r\n                                    if (!TIFFReadFrame(ltiff, libTIFF_data.data(), sample)) {\r\n                                        TESTFAIL(\"libTIFF ERROR: reading frame \"<<frame<<\", sample \"<<sample<<\"\", test_results.back())\r\n                                        ok=false;\r\n                                        break;\r\n                                    }\r\n                                    for (size_t i=0; i<libTIFF_data.size(); i++) {\r\n                                        if (i<=8) std::cout<<\"          f\"<<frame<<\"s\"<<sample<<\"i\"<<i<<\": tiny=\"<<std::dec<<static_cast<typename atleast_int<TIMAGESAMPLETYPE>::TPrint>(tinyTIFF_data[i])<<\" lib=\"<<static_cast<typename atleast_int<TIMAGESAMPLETYPE>::TPrint>(libTIFF_data[i])<<\"\\n\";\r\n                                        if (libTIFF_data[i]!=tinyTIFF_data[i]) {\r\n                                            TESTFAIL(\"in frame \"<<frame<<\", sample \"<<sample<<\": TinyTIFF and libTIFF read different sample values (I=\"<<i<<\": TinyTIFF: \"<<std::dec<<static_cast<typename atleast_int<TIMAGESAMPLETYPE>::TPrint>(tinyTIFF_data[i])<<\" != libTIFF: \"<<std::dec<<static_cast<typename atleast_int<TIMAGESAMPLETYPE>::TPrint>(libTIFF_data[i])<<\")\", test_results.back())\r\n                                            ok=false;\r\n                                            break;\r\n                                        }\r\n                                    }\r\n                                    if (!ok) {\r\n                                        SAVE_TIFF(std::string(std::string(filename)+\".tinytiff.error_sample\"+std::to_string(sample)+\".tif\").c_str(), tinyTIFF_data.data(), tinyTIFF_width, tinyTIFF_height);\r\n                                        SAVE_TIFF(std::string(std::string(filename)+\".libtiff.error_sample\"+std::to_string(sample)+\".tif\").c_str(), libTIFF_data.data(), tinyTIFF_width, tinyTIFF_height);\r\n                                    }\r\n                                }\r\n                            }\r\n\r\n\r\n                            frame++;\r\n                        } while (ok && TIFFReadDirectory(ltiff) && TinyTIFFReader_readNext(tiffr));\r\n\r\n                        test_results.back().success=ok;\r\n                        test_results.back().numImages=frame;\r\n                        duration=timer.get_time();\r\n                        test_results.back().duration_ms=duration/1.0e3;\r\n                        std::cout<<\"    read and checked all \"<<frame<<\" frames: \"<<((ok)?std::string(\"SUCCESS\"):std::string(\"ERROR\"))<<\"     [duration: \"<<duration<<\" us  =  \"<<floattounitstr(duration/1.0e6, \"s\")<<\" ]\\n\";\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    } catch(...) {\r\n        ok=false;\r\n        std::cout<<\"       CRASH While reading file\\n\";\r\n    }\r\n\r\n    test_results.back().success=ok;\r\n    if (ok) std::cout<<\"  => SUCCESS\\n\";\r\n    else std::cout<<\"  => NOT CORRECTLY READ\\n\";\r\n#endif\r\n}",
    "bool libtiffTestRead(const char* filename, const T* writteneven, const T* writtenodd, uint32_t width, uint32_t height, uint16_t samples=1, uint32_t frames_expected=0, TinyTIFFSampleLayout inputOrg=TinyTIFF_Chunky, std::string* description_out=nullptr)  {\r\n    bool ok=true;\r\n#ifdef TINYTIFF_TEST_LIBTIFF\r\n    TIFF* tif = TIFFOpen(filename, \"r\");\r\n    T* data=(T*)malloc(width*height*sizeof(T));\r\n    if (tif) {\r\n        uint32_t frame=0;\r\n        do {\r\n            uint32_t nx,ny;\r\n            uint16_t ns,bs;\r\n            TIFFGetField(tif,TIFFTAG_IMAGEWIDTH,&nx);\r\n            TIFFGetField(tif,TIFFTAG_IMAGELENGTH,&ny);\r\n            TIFFGetField(tif,TIFFTAG_SAMPLESPERPIXEL,&ns);\r\n            TIFFGetField(tif,TIFFTAG_BITSPERSAMPLE,&bs);\r\n            char* val=NULL;\r\n            TIFFGetField(tif,TIFFTAG_IMAGEDESCRIPTION,&val);\r\n            if (val) {\r\n                std::cout<<\"    ImageDescription(\"<<strlen(val)<<\"):\\n\"<<val<<\"\\n\";\r\n                if (description_out) *description_out=val;\r\n            } else {\r\n                if (description_out) description_out->clear();\r\n            }\r\n            TIFFPrintDirectory(tif, stdout);\r\n            if (nx==width && ny==height && ns==samples && bs==sizeof(T)*8) {\r\n                size_t errcnt=0;\r\n                size_t pixcnt=0;\r\n                for (uint16_t samp=0; samp<samples; samp++) {\r\n                    if (TIFFReadFrame(tif, data, samp)) {\r\n                        ok=true;\r\n                        const T* written=writteneven;\r\n                        if (writtenodd && frame%2==1) written=writtenodd;\r\n                        if (inputOrg==TinyTIFF_Chunky) {\r\n                            for (uint32_t i=0; i<width*height; i++) {\r\n                                if (data[i]!=written[i*samples+samp]) {\r\n                                    ok=false;\r\n                                    errcnt++;\r\n                                    if (errcnt<50) std::cout<<\" -- READ-ERROR: pixel-value differs in frame \"<<frame<<\" for pixel (\"<<i%width<<\",\"<<i/width<<\"): file: \"<<static_cast<typename atleast_int<T>::TPrint>(data[i])<<\" expected: \"<<static_cast<typename atleast_int<T>::TPrint>(written[i*samples+samp])<<\"\\n\";\r\n                                    if (errcnt==50) std::cout<<\" -- READ-ERROR: ...\\n\";\r\n                                } else {\r\n                                    pixcnt++;\r\n                                }\r\n                            }\r\n                        } else {\r\n                            for (uint32_t i=0; i<width*height; i++) {\r\n                                if (data[i]!=written[i+samp*width*height]) {\r\n                                    ok=false;\r\n                                    errcnt++;\r\n                                    if (errcnt<50) std::cout<<\" -- READ-ERROR: pixel-value differs in frame \"<<frame<<\" for pixel (\"<<i%width<<\",\"<<i/width<<\"): file: \"<<static_cast<typename atleast_int<T>::TPrint>(data[i])<<\" expected: \"<<static_cast<typename atleast_int<T>::TPrint>(written[i+samp*width*height])<<\"\\n\";\r\n                                    if (errcnt==50) std::cout<<\" -- READ-ERROR: ...\\n\";\r\n                                } else {\r\n                                    pixcnt++;\r\n                                }\r\n                            }\r\n                        }\r\n                        if (!ok) {\r\n                            std::cout<<\" -- TEST READ WITH LIBTIFF: READ WRONG DATA for \"<<errcnt<<\" pixels in frame \"<<frame<<\"!!!\\n\";\r\n                        }\r\n                    } else {\r\n                        std::cout<<\" -- TEST READ WITH LIBTIFF: COULD NOT READ FRAME \"<<frame<<\"!\\n\";\r\n                        ok=false;\r\n                    }\r\n                }\r\n                if (ok) {\r\n                    std::cout<<\" -- TEST READ WITH LIBTIFF: SUCCESS FOR FRAME \"<<frame<<\"! All \"<<pixcnt<<\" pixels&samples as expected!\\n\";\r\n                }\r\n            } else {\r\n                std::cout<<\" -- TEST READ WITH LIBTIFF: FRAME SIZE OF FRAME \"<<frame<<\" DOES NOT MATCH (width: file:\"<<nx<<\"/expected:\"<<width<<\",   height: file:\"<<ny<<\"/expected:\"<<height<<\",   samples: file:\"<<ns<<\"/expected:\"<<samples<<\",   bitspersample: file:\"<<bs<<\"/expected:\"<<(sizeof(T)*8)<<\")!\\n\";\r\n                ok=false;\r\n            }\r\n            frame++;\r\n        } while (ok && TIFFReadDirectory(tif));\r\n        if (frames_expected>0 && frames_expected!=frame) {\r\n            std::cout<<\" -- ERROR IN TEST READ WITH LIBTIFF: number of frames (\"<<frame<<\")does not match expected number of frames (\"<<frames_expected<<\")\\n\";\r\n            ok=false;\r\n        }\r\n        TIFFClose(tif);\r\n    } else {\r\n        std::cout<<\" -- TEST READ WITH LIBTIFF: COULD NOT OPEN FILE!\\n\";\r\n        ok=false;\r\n    }\r\n    free(data);\r\n#endif\r\n    return ok;\r\n}"
]