{
    "SourcegraphEndpoint": "https://sourcegraph.com",
    "Query": "file:\\.(c|cpp|cc)$ lang:c++ count:all TIFFPrintDirectory",
    "Site": {
        "BuildVersion": "316984_2025-03-18_6.1-1f1695fa27f5"
    },
    "Results": [
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "8722f0343793ce08807b342847b74f4bf9a38ddc"
                },
                "content": "// Copyright 2022 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n#include <absl/strings/string_view.h>\n#include <memory>\n#include <string>\n#include <utility>\n\n#include <boost/log/trivial.hpp>\n#include \"src/openslideUtil.h\"\n#include \"src/tiffFile.h\"\n\n\nnamespace wsiToDicomConverter {\n\nTiffFile::TiffFile(absl::string_view path, const int32_t dirIndex) :\ntiffFilePath_(path), currentDirectoryIndex_(dirIndex) {\n  initalized_ = false;\n  tileReadBufSize_  = 0;\n  openslide_level_ = 0;\n  std::string path_str = std::move(static_cast<std::string>(path));\n  tiffFile_ = TIFFOpen(path_str.c_str(), \"r\");\n  if (tiffFile_ == nullptr) {\n      return;\n  }\n  do {\n    // Uncomment to print description of tiff dir to stdio.\n    // TIFFPrintDirectory(tiffFile_, stdout);\n    tiffDir_.push_back(std::move(std::make_unique<TiffDirectory>(tiffFile_)));\n  } while (TIFFReadDirectory(tiffFile_));\n  TIFFSetDirectory(tiffFile_, currentDirectoryIndex_);\n  tileReadBufSize_ = TIFFTileSize(tiffFile_);\n  initalized_ = true;\n}\n\nTiffFile::TiffFile(const TiffFile &tf, const int32_t dirIndex) :\ntiffFilePath_(tf.path()), currentDirectoryIndex_(dirIndex) {\n    initalized_ = false;\n    tileReadBufSize_  = 0;\n    openslide_level_ = 0;\n    tiffFile_ = TIFFOpen(tiffFilePath_.c_str(), \"r\");\n    if (tiffFile_ == nullptr) {\n      return;\n    }\n    const size_t dirCount = tf.directoryCount();\n    for (size_t idx = 0; idx < dirCount; ++idx) {\n      tiffDir_.push_back((std::move(\n                      std::make_unique<TiffDirectory>(*tf.directory(idx)))));\n    }\n    TIFFSetDirectory(tiffFile_, currentDirectoryIndex_);\n    tileReadBufSize_ = tf.tileReadBufSize_;\n    if (!fileDirectory()->isJpeg2kCompressed()) {\n      osptr_ = nullptr;\n      openslide_level_ = 0;\n    } else {\n      osptr_ = std::make_unique<OpenSlidePtr>(tf.path());\n      openslide_t* opslide = osptr_->osr();\n      int64_t level_width = -1;\n      int64_t level_height = -1;\n      const int64_t targetWidth = fileDirectory()->imageWidth();\n      const int64_t targetHeight = fileDirectory()->imageHeight();\n      if (openslide_get_error(opslide)) {\n        BOOST_LOG_TRIVIAL(error) << openslide_get_error(opslide);\n        throw 1;\n      }\n      const int32_t level_count = openslide_get_level_count(opslide);\n      for (openslide_level_ = 0;\n           openslide_level_ < level_count;\n           ++openslide_level_) {\n        openslide_get_level_dimensions(opslide, openslide_level_,\n                                       &level_width, &level_height);\n        if (level_width == targetWidth && level_height == targetHeight) {\n          break;\n        }\n      }\n      if (level_width != targetWidth && level_height != targetHeight) {\n        BOOST_LOG_TRIVIAL(error) << \"Could not find expected level in \"\n                                    \"JPG2000 encoded tiff.\";\n        throw 1;\n      }\n    }\n    initalized_ = true;\n}\n\nopenslide_t * TiffFile::getOpenslidePtr() {\n  return osptr_->osr();\n}\n\nint32_t TiffFile::getOpenslideLevel() const {\n  return openslide_level_;\n}\n\nTiffFile::~TiffFile() {\n  osptr_ = nullptr;\n  close();\n}\n\nvoid TiffFile::close() {\n  if (tiffFile_ == nullptr) {\n    return;\n  }\n  TIFFClose(tiffFile_);\n  tiffFile_ = nullptr;\n}\n\nstd::string TiffFile::path() const {\n  return tiffFilePath_;\n}\n\nint32_t TiffFile::directoryLevel() const {\n  return currentDirectoryIndex_;\n}\n\nbool TiffFile::isLoaded() const {\n  return (tiffFile_ != nullptr);\n}\n\nbool TiffFile::isInitalized() const {\n  return initalized_;\n}\n\nbool TiffFile::hasExtractablePyramidImages() const {\n  for (int32_t idx = 0; idx < tiffDir_.size(); ++idx) {\n    if (tiffDir_[idx]->isExtractablePyramidImage()) {\n      return true;\n    }\n  }\n  return false;\n}\n\nint32_t TiffFile::getDirectoryIndexMatchingImageDimensions(uint32_t width,\nuint32_t height, bool isExtractablePyramidImage) const {\n  for (int32_t idx = 0; idx < tiffDir_.size(); ++idx) {\n    if (!isExtractablePyramidImage ||\n        tiffDir_[idx]->isExtractablePyramidImage()) {\n      if (tiffDir_[idx]->doImageDimensionsMatch(width, height)) {\n        return idx;\n      }\n    }\n  }\n  return -1;\n}\n\nconst TiffDirectory *TiffFile::fileDirectory() const {\n  return directory(currentDirectoryIndex_);\n}\n\nconst TiffDirectory *TiffFile::directory(int64_t dirIndex) const {\n  return tiffDir_[dirIndex].get();\n}\n\nuint32_t TiffFile::directoryCount() const {\n  return tiffDir_.size();\n}\n\nclass TileReadBuffer {\n public:\n  explicit TileReadBuffer(uint64_t size);\n  virtual ~TileReadBuffer();\n  tdata_t buffer_;\n};\n\nTileReadBuffer::TileReadBuffer(uint64_t size) {\n  buffer_ = _TIFFmalloc(size);\n}\n\nTileReadBuffer::~TileReadBuffer() {\n  if (buffer_ != nullptr) {\n    _TIFFfree(buffer_);\n  }\n}\n\nstd::unique_ptr<TiffTile> TiffFile::tile(uint32_t tileIndex) {\n  if (tiffFile_ == nullptr) {\n    return nullptr;\n  }\n  TileReadBuffer readBuffer(tileReadBufSize_);\n  if (readBuffer.buffer_ == nullptr) {\n    return nullptr;\n  }\n  uint32_t bufferSize = TIFFReadRawTile(tiffFile_,\n                                        static_cast<ttile_t>(tileIndex),\n                                        readBuffer.buffer_,\n                                        tileReadBufSize_);\n  if (bufferSize == 0) {\n    return nullptr;\n  }\n  std::unique_ptr<uint8_t[]> mem_buffer =\n                                       std::make_unique<uint8_t[]>(bufferSize);\n  if (mem_buffer == nullptr) {\n    return nullptr;\n  }\n  _TIFFmemcpy(mem_buffer.get(), readBuffer.buffer_, bufferSize);\n  return std::make_unique<TiffTile>(directory(directoryLevel()), tileIndex,\n                                    std::move(mem_buffer), bufferSize);\n}\n\n}  // namespace wsiToDicomConverter\n",
                "name": "tiffFile.cpp",
                "path": "src/tiffFile.cpp",
                "url": "/github.com/GoogleCloudPlatform/wsi-to-dicom-converter/-/blob/src/tiffFile.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 37,
                    "offsetAndLengths": [
                        [
                            7,
                            18
                        ]
                    ],
                    "preview": "    // TIFFPrintDirectory(tiffFile_, stdout);"
                }
            ],
            "repository": {
                "name": "github.com/GoogleCloudPlatform/wsi-to-dicom-converter",
                "url": "/github.com/GoogleCloudPlatform/wsi-to-dicom-converter"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "f29d030f997c7aa72523647da27c35bd2b86f33b"
                },
                "content": "\n/*========================================================================*\n *                                                                        *\n *  Distributed by Whiteley Research Inc., Sunnyvale, California, USA     *\n *                       http://wrcad.com                                 *\n *  Copyright (C) 2017 Whiteley Research Inc., all rights reserved.       *\n *  Author: Stephen R. Whiteley, except as indicated.                     *\n *                                                                        *\n *  As fully as possible recognizing licensing terms and conditions       *\n *  imposed by earlier work from which this work was derived, if any,     *\n *  this work is released under the Apache License, Version 2.0 (the      *\n *  \"License\").  You may not use this file except in compliance with      *\n *  the License, and compliance with inherited licenses which are         *\n *  specified in a sub-header below this one if applicable.  A copy       *\n *  of the License is provided with this distribution, or you may         *\n *  obtain a copy of the License at                                       *\n *                                                                        *\n *        http://www.apache.org/licenses/LICENSE-2.0                      *\n *                                                                        *\n *  See the License for the specific language governing permissions       *\n *  and limitations under the License.                                    *\n *                                                                        *\n *   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,      *\n *   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES      *\n *   OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-        *\n *   INFRINGEMENT.  IN NO EVENT SHALL WHITELEY RESEARCH INCORPORATED      *\n *   OR STEPHEN R. WHITELEY BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER     *\n *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,      *\n *   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE       *\n *   USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                        *\n *========================================================================*\n *               XicTools Integrated Circuit Design System                *\n *                                                                        *\n * MOZY html help viewer files                                            *\n *                                                                        *\n *========================================================================*\n $Id:$\n *========================================================================*/\n\n/*------------------------------------------------------------------------*\n * This file is part of the gtkhtm widget library.  The gtkhtm library\n * was derived from the gtk-xmhtml library by:\n *\n *   Stephen R. Whiteley  <stevew@wrcad.com>\n *   Whiteley Research Inc.\n *------------------------------------------------------------------------*\n *  The gtk-xmhtml widget was derived from the XmHTML library by\n *  Miguel de Icaza  <miguel@nuclecu.unam.mx> and others from the GNOME\n *  project.\n *  11/97 - 2/98\n *------------------------------------------------------------------------*\n * The present file is heavily based on\n * tiff2png.c - converts Tagged Image File Format to Portable Network Graphics\n *\n * Copyright 1996,2000 Willem van Schaik, Calgary (willem@schaik.com)\n * Copyright 1999-2002 Greg Roelofs (newt@pobox.com)\n *\n * [see VERSION macro below for version and date]\n *\n * Lots of material was stolen from libtiff, tifftopnm, pnmtopng, which\n * programs had also done a fair amount of \"borrowing\", so the credit for\n * this program goes besides the author also to:\n *         Sam Leffler\n *         Jef Poskanzer\n *         Alexander Lehmann\n *         Patrick Naughton\n *         Marcel Wijkstra\n *\n *------------------------------------------------------------------------*\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Library General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Library General Public License for more details.\n *\n * You should have received a copy of the GNU Library General Public\n * License along with this library; if not, write to the Free\n * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n *------------------------------------------------------------------------*/\n\n// Needed to expose vasprintf prototype in stdio.h.\n#ifdef WIN32\n#define _GNU_SOURCE\n#endif\n\n#include \"htm_widget.h\"\n#include \"htm_image.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <unistd.h>\n#include <string.h>\n//#ifdef WIN32\n// This provides vasprintf in win-builds MINGW.\n//#include <libiberty.h>\n//#endif\n\n#if defined(HAVE_LIBTIFF) && defined(HAVE_LIBPNG)\n#include <tiff.h>\n#include <tiffio.h>\n#include <png.h>\n\nnamespace tiffns {\n    char *tiff_to_png_err();\n    bool tiff_to_png(const char*, FILE*);\n}\n\n\n// We handle TIFF by converting to PNG.\n//\nhtmRawImageData*\nhtmImageManager::readTIFF(ImageBuffer *ib)\n{\n    const char *path = getenv(\"TMPDIR\");\n    if (!path)\n        path = \"/tmp\";\n    char buf[256];\n    snprintf(buf, sizeof(buf), \"%s/moz%d-%s.tmp\", path, getpid(), \"tiff\");\n    FILE *fp = fopen(buf, \"wb\");\n    if (!fp)\n        return (0);\n\n    fwrite(ib->buffer, 1, ib->size, fp);\n    fclose(fp);\n    char *tiffile = new char[strlen(buf)+1];\n    strcpy(tiffile, buf);\n\n    snprintf(buf, sizeof(buf), \"%s/moz%d-%s.tmp\", path, getpid(), \"png\");\n    fp = fopen(buf, \"wb\");\n    if (fp) {\n        bool ret = tiffns::tiff_to_png(tiffile, fp);\n        fclose (fp);\n        if (ret) {\n            fp = fopen(buf, \"rb\");\n            fseek(fp, 0, SEEK_END);\n            long len = ftell(fp);\n            rewind(fp);\n            char *sbuf = new char[len];\n            long sz = fread(sbuf, 1, len, fp);\n            if (sz == len) {\n                delete [] ib->buffer;\n                ib->buffer = (unsigned char*)sbuf;\n                ib->size = sz;\n                ib->type = IMAGE_PNG;\n            }\n            else\n                delete [] sbuf;\n        }\n        unlink(buf);\n    }\n    unlink(tiffile);\n    delete [] tiffile;\n\n    if (ib->type == IMAGE_PNG)\n        return (readPNG(ib));\n    return (0);\n}\n\n\n#ifdef _AIX\n#define jmpbuf __jmpbuf\n#endif\n\n#define MAXCOLORS 256\n\n#ifndef PHOTOMETRIC_DEPTH\n#define PHOTOMETRIC_DEPTH 32768\n#endif\n\n// It appears that PHOTOMETRIC_MINISWHITE should always be inverted\n// (which makes sense), but if you find a class of TIFFs or a version\n// of libtiff for which that is *not* the case, try not defining\n// INVERT_MINISWHITE.\n\n#define INVERT_MINISWHITE\n\n// Macros to get and put bits out of the bytes.\n\n#define GET_LINE_SAMPLE \\\n  { \\\n    if (bitsleft == 0) \\\n    { \\\n      p_line++; \\\n      bitsleft = 8; \\\n    } \\\n    bitsleft -= (bps >= 8) ? 8 : bps; \\\n    sample = (*p_line >> bitsleft) & maxval; \\\n  }\n\n#define GET_STRIP_SAMPLE \\\n  { \\\n    if (getbitsleft == 0) \\\n    { \\\n      p_strip++; \\\n      getbitsleft = 8; \\\n    } \\\n    getbitsleft -= (bps >= 8) ? 8 : bps; \\\n    sample = (*p_strip >> getbitsleft) & maxval; \\\n  }\n\n#define PUT_LINE_SAMPLE \\\n  { \\\n    if (putbitsleft == 0) \\\n    { \\\n      p_line++; \\\n      putbitsleft = 8; \\\n    } \\\n    putbitsleft -= (bps >= 8) ? 8 : bps; \\\n    *p_line |= ((sample & maxval) << putbitsleft); \\\n  }\n\nnamespace {\n    inline bool test_bigendian()\n    {\n        union { int32_t i; char c[4]; } endian_tester;\n        endian_tester.i = 1;\n        return (endian_tester.c[0]);\n    }\n\n\n    struct jmpbuf_wrapper\n    {\n        jmp_buf jmpbuf;\n    };\n    jmpbuf_wrapper jmpbuf_struct;\n\n    char *err_msg;\n\n    void err_printf(const char *fmt, ...)\n    {\n        va_list args;\n        delete [] err_msg;\n#ifdef HAVE_VASPRINTF\n        va_start(args, fmt);\n        vasprintf(&err_msg, fmt, args);\n#else\n        char buf[1024];\n        va_start(args, fmt);\n        vsnprintf(buf, 1024, fmt, args);\n        err_msg = new char[strlen(buf)+1];\n        strcpy(err_msg, buf);\n#endif\n    }\n\n\n    void error_handler(png_structp png_ptr, png_const_charp msg)\n    {\n        err_printf(\"fatal libpng error: %s\", msg);\n        jmpbuf_wrapper *jmpbuf_ptr =\n            (jmpbuf_wrapper*)png_get_error_ptr(png_ptr);\n        longjmp(jmpbuf_ptr->jmpbuf, 1);\n    }\n}\n\n\n// Static function.\n// Return the error message generated by a call to tiff_to_png.  The\n// returned string should be deleted after use.  This clears the error\n// message saved from the function call.\n//\nchar *\ntiffns::tiff_to_png_err()\n{\n    char *er = err_msg;\n    err_msg = 0;\n    return (er);\n}\n\n\n// Static function.\n// Read a TIFF file in tiffname, and output a PNG translation to\n// pngfp.  True is returned on success.  On error, false is returned,\n// and an error message is available from tiff_to_png_err.\n//\nbool\ntiffns::tiff_to_png(const char *tiffname, FILE *pngfp)\n{\n    bool bigendian = test_bigendian();\n\n    TIFF *tif = TIFFOpen(tiffname, \"r\");\n    if (!tif) {\n        err_printf(\"Failed to open %s.\", tiffname);\n        return (false);\n    }\n\n    png_struct *png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING,\n        &jmpbuf_struct, error_handler, 0);\n    if (!png_ptr) {\n        TIFFClose(tif);\n        return (false);\n    }\n\n    png_info *info_ptr = png_create_info_struct(png_ptr);\n    if (!info_ptr) {\n        png_destroy_write_struct(&png_ptr, 0);\n        TIFFClose(tif);\n        return (false);\n    }\n\n    if (setjmp(jmpbuf_struct.jmpbuf)) {\n        png_destroy_write_struct(&png_ptr, 0);\n        TIFFClose(tif);\n        return (false);\n    }\n\n    png_init_io(png_ptr, pngfp);\n\n#ifdef DEBUG\n    if (verbose) {\n        int byteswapped = TIFFIsByteSwapped(tif);\n\n        fprintf(stderr, \"tiff_to_png:  \");\n        TIFFPrintDirectory(tif, stderr, TIFFPRINT_NONE);\n        fprintf(stderr, \"tiff_to_png:  byte order = %s\\n\",\n            ((bigendian && byteswapped) || (!bigendian && !byteswapped))?\n            \"little-endian (Intel)\" : \"big-endian (Motorola)\");\n        fprintf(stderr, \"tiff_to_png:  this machine is %s-endian\\n\",\n            bigendian? \"big\" : \"little\");\n    }\n#endif\n\n    unsigned short photometric;\n    if (!TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric)) {\n        err_printf(\"TIFF photometric could not be retrieved (%s)\", tiffname);\n        png_destroy_write_struct(&png_ptr, &info_ptr);\n        TIFFClose(tif);\n        return (false);\n    }\n    unsigned short bps;\n    if (!TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bps))\n        bps = 1;\n    unsigned short spp;\n    if (!TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &spp))\n        spp = 1;\n    unsigned short planar;\n    if (!TIFFGetField(tif, TIFFTAG_PLANARCONFIG, &planar))\n        planar = 1;\n\n    unsigned short tiled = TIFFIsTiled(tif);\n\n    int cols, rows;\n    TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &cols);\n    TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &rows);\n    png_uint_32 width = cols;\n\n    bool have_res = false;\n    float xres, yres;\n    png_uint_32 res_x=0, res_y=0;\n    int unit_type = 0;\n    if (TIFFGetField(tif, TIFFTAG_XRESOLUTION, &xres) &&\n            TIFFGetField(tif, TIFFTAG_YRESOLUTION, &yres) && \n            (xres != 0.0) && (yres != 0.0)) {\n        uint16_t resunit;\n        have_res = true;\n#ifdef DEBUG\n        if (verbose) {\n            float ratio = xres / yres;\n            fprintf(stderr,\n                \"tiff_to_png:  aspect ratio (hor/vert) = %g (%g / %g)\\n\",\n                ratio, xres, yres);\n            if (0.95 < ratio && ratio < 1.05)\n                fprintf(stderr, \"tiff2png:  near-unity aspect ratio\\n\");\n            else if (1.90 < ratio && ratio < 2.10)\n                fprintf(stderr, \"tiff2png:  near-2X aspect ratio\\n\");\n            else\n                fprintf(stderr, \"tiff2png:  non-square, non-2X pixels\\n\");\n        }\n#endif\n\n        if (!TIFFGetField(tif, TIFFTAG_RESOLUTIONUNIT, &resunit))\n            resunit = RESUNIT_INCH;\n\n        // Convert from TIFF data (floats) to PNG data (unsigned longs).\n        switch (resunit) {\n        case RESUNIT_CENTIMETER:\n            res_x = (png_uint_32)(100.0*xres + 0.5);\n            res_y = (png_uint_32)(100.0*yres + 0.5);\n            unit_type = PNG_RESOLUTION_METER;\n            break;\n        case RESUNIT_INCH:\n            res_x = (png_uint_32)(39.37*xres + 0.5);\n            res_y = (png_uint_32)(39.37*yres + 0.5);\n            unit_type = PNG_RESOLUTION_METER;\n            break;\n        case RESUNIT_NONE:\n        default:\n            res_x = (png_uint_32)(100.0*xres + 0.5);\n            res_y = (png_uint_32)(100.0*yres + 0.5);\n            unit_type = PNG_RESOLUTION_UNKNOWN;\n            break;\n        }\n    }\n\n#ifdef DEBUG\n    if (verbose) {\n        fprintf(stderr, \"tiff_to_png:  %dx%dx%d image\\n\", cols, rows,\n            bps * spp);\n        fprintf(stderr, \"tiff_to_png:  %d bit%s/sample, %d sample%s/pixel\\n\",\n            bps, bps == 1? \"\" : \"s\", spp, spp == 1? \"\" : \"s\");\n    }\n#endif\n\n    // Detect tiff filetype.\n\n    int maxval = (1 << bps) - 1;\n#ifdef DEBUG\n    if (verbose)\n        fprintf(stderr, \"tiff_to_png:  maxval=%d\\n\", maxval);\n#endif\n\n    int color_type = -1;\n    int bit_depth = 0;\n    int colors = 0;\n    png_color palette[MAXCOLORS];\n    unsigned short tiff_compression_method;\n\n    switch (photometric) {\n    case PHOTOMETRIC_MINISWHITE:\n    case PHOTOMETRIC_MINISBLACK:\n#ifdef DEBUG\n        if (verbose) {\n            fprintf(stderr,\n                \"tiff_to_png:  %d graylevels (min = %s)\\n\", maxval + 1,\n                photometric == PHOTOMETRIC_MINISBLACK? \"black\" : \"white\");\n        }\n#endif\n        if (spp == 1) {\n            // no alpha\n            color_type = PNG_COLOR_TYPE_GRAY;\n#ifdef DEBUG\n            if (verbose)\n                fprintf(stderr, \"tiff_to_png:  color type = grayscale\\n\");\n#endif\n            bit_depth = bps;\n        }\n        else {\n            // must be alpha\n            color_type = PNG_COLOR_TYPE_GRAY_ALPHA;\n#ifdef DEBUG\n            if (verbose)\n                fprintf(stderr,\n                    \"tiff_to_png:  color type = grayscale + alpha\\n\");\n#endif\n            if (bps <= 8)\n                bit_depth = 8;\n            else\n                bit_depth = bps;\n        }\n        break;\n\n    case PHOTOMETRIC_PALETTE:\n        {\n            int palette_8bit; // Set iff all color values in TIFF palette\n                              // are < 256.\n\n            color_type = PNG_COLOR_TYPE_PALETTE;\n#ifdef DEBUG\n            if (verbose)\n                fprintf(stderr, \"tiff_to_png:  color type = paletted\\n\");\n#endif\n\n            unsigned short *redcolormap;\n            unsigned short *greencolormap;\n            unsigned short *bluecolormap;\n            if (!TIFFGetField(tif, TIFFTAG_COLORMAP, &redcolormap,\n                    &greencolormap, &bluecolormap)) {\n                err_printf(\"Cannot retrieve TIFF colormaps (%s)\\n\", tiffname);\n                png_destroy_write_struct(&png_ptr, &info_ptr);\n                TIFFClose(tif);\n                return (false);\n            }\n            colors = maxval + 1;\n            if (colors > MAXCOLORS) {\n                err_printf(\"Palette too large (%d colors) (%s)\\n\",\n                    colors, tiffname);\n                png_destroy_write_struct(&png_ptr, &info_ptr);\n                TIFFClose(tif);\n                return (false);\n            }\n            // Max PNG palette-size is 8 bits, you could convert to\n            // full-color.\n            if (bps >= 8) \n                bit_depth = 8;\n            else\n                bit_depth = bps;\n\n            // PLTE chunk\n            // TIFF palettes contain 16-bit shorts, while PNG palettes\n            // are 8-bit.  Some broken (??) software puts 8-bit values\n            // in the shorts, which would make the palette come out\n            // all zeros, which isn't good.  We check...\n\n            palette_8bit = 1;\n            for (int i = 0 ; i < colors ; i++) {\n                if (redcolormap[i] > 255 || greencolormap[i] > 255 ||\n                         bluecolormap[i] > 255) {\n                     palette_8bit = 0;\n                     break;\n                }\n            } \n#ifdef DEBUG\n            if (palette_8bit && verbose)\n                fprintf(stderr,\n                    \"tiff_to_png warning:  assuming 8-bit palette values.\\n\");\n#endif\n\n            for (int i = 0 ; i < colors ; i++) {\n                if (palette_8bit) {\n                    palette[i].red   = (png_byte)redcolormap[i];\n                    palette[i].green = (png_byte)greencolormap[i];\n                    palette[i].blue  = (png_byte)bluecolormap[i];\n                }\n                else {\n                    palette[i].red   = (png_byte)(redcolormap[i] >> 8);\n                    palette[i].green = (png_byte)(greencolormap[i] >> 8);\n                    palette[i].blue  = (png_byte)(bluecolormap[i] >> 8);\n                }\n            }\n            break;\n        }\n\n    case PHOTOMETRIC_YCBCR:\n        TIFFGetField(tif, TIFFTAG_COMPRESSION, &tiff_compression_method);\n        if (tiff_compression_method == COMPRESSION_JPEG &&\n                planar == PLANARCONFIG_CONTIG) {\n            // Can rely on libjpeg to convert to RGB.\n            TIFFSetField(tif, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n            photometric = PHOTOMETRIC_RGB;\n#ifdef DEBUG\n            if (verbose)\n                fprintf(stderr, \"tiff2png:  original color type = YCbCr \"\n                    \"with JPEG compression.\\n\");\n#endif\n        }\n        else {\n            err_printf(\n                \"Don't know how to handle PHOTOMETRIC_YCBCR with \"\n                \"compression %d\\n\"\n                \"  (%sJPEG) and planar config %d (%scontiguous)\\n\"\n                \"  (%s)\\n\", tiff_compression_method,\n                tiff_compression_method == COMPRESSION_JPEG? \"\" : \"not \",\n                planar, planar == PLANARCONFIG_CONTIG? \"\" : \"not \", tiffname);\n            png_destroy_write_struct(&png_ptr, &info_ptr);\n            TIFFClose(tif);\n            return (false);\n        }\n        // fall thru... \n\n    case PHOTOMETRIC_RGB:\n        if (spp == 3) {\n            color_type = PNG_COLOR_TYPE_RGB;\n#ifdef DEBUG\n            if (verbose)\n                fprintf(stderr, \"tiff_to_png:  color type = truecolor\\n\");\n#endif\n        }\n        else {\n            color_type = PNG_COLOR_TYPE_RGB_ALPHA;\n#ifdef DEBUG\n            if (verbose)\n                fprintf(stderr,\n                    \"tiff_to_png:  color type = truecolor + alpha\\n\");\n#endif\n        }\n        if (bps <= 8)\n            bit_depth = 8;\n        else\n            bit_depth = bps;\n        break;\n\n    case PHOTOMETRIC_LOGL:\n    case PHOTOMETRIC_LOGLUV:\n        TIFFGetField(tif, TIFFTAG_COMPRESSION, &tiff_compression_method);\n        if (tiff_compression_method != COMPRESSION_SGILOG &&\n                tiff_compression_method != COMPRESSION_SGILOG24) {\n            err_printf(\"Don't know how to handle PHOTOMETRIC_LOGL%s with\\n\"\n                \"  compression %d (not SGILOG) (%s)\\n\",\n                photometric == PHOTOMETRIC_LOGLUV? \"UV\" : \"\",\n                tiff_compression_method, tiffname);\n            png_destroy_write_struct(&png_ptr, &info_ptr);\n            TIFFClose(tif);\n            return (false);\n        }\n        // rely on library to convert to RGB/greyscale.\n#ifdef LIBTIFF_HAS_16BIT_INTEGER_FORMAT\n        if (bps > 8) {\n            // SGILOGDATAFMT_16BIT converts to a floating-point\n            // luminance value; U,V are left as such. \n            // SGILOGDATAFMT_16BIT_INT doesn't exist.\n\n            TIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_16BIT_INT);\n            bit_depth = bps = 16;\n        }\n        else\n#endif\n        {\n            // SGILOGDATAFMT_8BIT converts to normal grayscale or RGB format.\n            TIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_8BIT);\n            bit_depth = bps = 8;\n        }\n        if (photometric == PHOTOMETRIC_LOGL) {\n            photometric = PHOTOMETRIC_MINISBLACK;\n            color_type = PNG_COLOR_TYPE_GRAY;\n#ifdef DEBUG\n            if (verbose) {\n                fprintf(stderr, \"tiff_to_png:  original color type = \"\n                    \"logL with SGILOG compression.\\n\");\n                fprintf(stderr, \"tiff_to_png:  color type = grayscale.\\n\");\n            }\n#endif\n        }\n        else {\n            photometric = PHOTOMETRIC_RGB;\n            color_type = PNG_COLOR_TYPE_RGB;\n#ifdef DEBUG\n            if (verbose) {\n                fprintf(stderr, \"tiff_to_png:  original color type = \"\n                    \"logLUV with SGILOG compression.\\n\");\n                fprintf(stderr, \"tiff_to_png:  color type = truecolor.\\n\");\n            }\n#endif\n        }\n        break;\n\n    case PHOTOMETRIC_MASK:\n    case PHOTOMETRIC_SEPARATED:\n    case PHOTOMETRIC_CIELAB:\n    case PHOTOMETRIC_DEPTH:\n        err_printf(\"Don't know how to handle %s (%s)\\n\",\n            photometric == PHOTOMETRIC_MASK?      \"PHOTOMETRIC_MASK\" :\n            photometric == PHOTOMETRIC_SEPARATED? \"PHOTOMETRIC_SEPARATED\" :\n            photometric == PHOTOMETRIC_CIELAB?    \"PHOTOMETRIC_CIELAB\" :\n            photometric == PHOTOMETRIC_DEPTH?     \"PHOTOMETRIC_DEPTH\" :\n                                                  \"unknown photometric\",\n            tiffname);\n        png_destroy_write_struct(&png_ptr, &info_ptr);\n        TIFFClose(tif);\n        return (false);\n\n    default:\n        err_printf(\"Unknown photometric (%d) (%s)\\n\",\n            photometric, tiffname);\n        png_destroy_write_struct(&png_ptr, &info_ptr);\n        TIFFClose(tif);\n        return (false);\n    }\n    int tiff_color_type = color_type;\n\n#ifdef DEBUG\n    if (verbose)\n        fprintf(stderr, \"tiff_to_png:  bit depth = %d\\n\", bit_depth);\n#endif\n\n    // Put parameter info in png-chunks.\n\n    png_set_IHDR(png_ptr, info_ptr, width, rows, bit_depth, color_type,\n        PNG_INTERLACE_NONE, PNG_COMPRESSION_TYPE_DEFAULT,\n        PNG_FILTER_TYPE_DEFAULT);\n\n//    if (png_compression_level != -1)\n//        png_set_compression_level(png_ptr, png_compression_level);\n\n    if (color_type == PNG_COLOR_TYPE_PALETTE)\n        png_set_PLTE(png_ptr, info_ptr, palette, colors);\n\n    // gAMA chunk\n//    if (gamma != -1.0) {\n#ifdef DEBUG\n//        if (verbose)\n//            fprintf(stderr, \"tiff_to_png:  gamma = %f\\n\", gamma);\n#endif\n//        png_set_gAMA(png_ptr, info_ptr, gamma);\n//    }\n\n    // pHYs chunk\n    if (have_res)\n        png_set_pHYs(png_ptr, info_ptr, res_x, res_y, unit_type);\n\n    png_write_info(png_ptr, info_ptr);\n    png_set_packing(png_ptr);\n\n    // Allocate space for one line (or row of tiles) of TIFF image.\n\n    unsigned char *tiffline = 0;\n    unsigned char *tifftile = 0;\n    unsigned char *tiffstrip = 0;\n    size_t tilesz = 0L;\n    int num_tilesX = 0;\n    uint32_t tile_width = 0, tile_height = 0;\n\n    if (!tiled) {\n        // strip-based TIFF\n        if (planar == 1) {\n            // contiguous picture\n            tiffline = (unsigned char*)malloc(TIFFScanlineSize(tif));\n        }\n        else {\n            // separated planes\n            tiffline = (unsigned char*)malloc(TIFFScanlineSize(tif) * spp);\n        }\n    }\n    else {\n        // Allocate space for one \"row\" of tiles.\n\n        TIFFGetField(tif, TIFFTAG_TILEWIDTH, &tile_width);\n        TIFFGetField(tif, TIFFTAG_TILELENGTH, &tile_height);\n\n        num_tilesX = (width+tile_width-1)/tile_width;\n\n        if (planar == 1) {\n            tilesz = TIFFTileSize(tif);\n            tifftile = new unsigned char[tilesz];\n            size_t stripsz = (tile_width*num_tilesX) * tile_height * spp;\n            tiffstrip = new unsigned char[stripsz];\n            tiffline = tiffstrip;\n            // Just set the line to the top of the strip, we'll move it\n            // through below.\n        }\n        else {\n            err_printf(\n                \"Can't handle tiled separated-plane TIFF format (%s).\\n\",\n                tiffname);\n            png_destroy_write_struct (&png_ptr, &info_ptr);\n            TIFFClose(tif);\n            return (false);\n        }\n    }\n\n    if (!tiffline) {\n        err_printf(\"Can't allocate memory for TIFF scanline buffer (%s).\\n\",\n            tiffname);\n        png_destroy_write_struct(&png_ptr, &info_ptr);\n        TIFFClose(tif);\n        if (tiled && planar == 1)\n            delete [] tifftile;\n        return (false);\n    }\n\n    if (planar != 1) {\n        // In case we must combine more planes into one.\n        tiffstrip = new unsigned char[TIFFScanlineSize(tif)];\n        if (!tiffstrip) {\n            err_printf(\"Can't allocate memory for TIFF strip buffer (%s).\\n\",\n                tiffname);\n            png_destroy_write_struct(&png_ptr, &info_ptr);\n            TIFFClose(tif);\n            free(tiffline);\n            return (false);\n        }\n    }\n\n    // Allocate space for one line of PNG image.\n    // max: 3 color channels plus one alpha channel, 16 bit => 8 bytes/pixel\n\n    png_byte *pngline = new unsigned char[cols * 8];\n    for (int pass = 0 ; pass < png_set_interlace_handling(png_ptr); pass++) {\n        for (int row = 0; row < rows; row++) {\n            if (planar == 1) {\n                // contiguous picture\n                if (!tiled) {\n                    if (TIFFReadScanline(tif, tiffline, row, 0) < 0) {\n                        err_printf(\"Bad data read on line %d (%s).\\n\",\n                            row, tiffname);\n                        png_destroy_write_struct(&png_ptr, &info_ptr);\n                        TIFFClose(tif);\n                        free(tiffline);\n                        return (false);\n                    }\n                }\n                else {\n                    // tiled\n                    int col, ok=1, r;\n                    int tileno;\n                    // Read in one row of tiles and hand out the data\n                    // one scanline at a time so the code below\n                    // doesn't need to change.\n\n                    // Is it time for a new strip?\n                    if ((row % tile_height) == 0) {\n                        for (col = 0; ok && col < num_tilesX; col += 1 ) {\n                            tileno = col+(row/tile_height)*num_tilesX;\n                            // Read the tile into an RGB array.\n                            if (!TIFFReadEncodedTile(tif, tileno, tifftile,\n                                    tilesz)) {\n                                ok = 0;\n                                break;\n                            }\n\n                            // Copy this tile into the row buffer.\n                            for (r = 0; r < (int) tile_height; r++) {\n                                void *dest = tiffstrip + (r * tile_width *\n                                    num_tilesX * spp) +\n                                    (col * tile_width * spp);\n                                void *src  = tifftile + (r * tile_width * spp);\n                                memcpy(dest, src, (tile_width * spp));\n                            }\n                        }\n                        tiffline = tiffstrip; // Set tileline to top of strip.\n                    }\n                    else {\n                        tiffline = tiffstrip + ((row % tile_height) *\n                            ((tile_width * num_tilesX) * spp));\n                    }\n                }\n            }\n            else {\n                // Separated planes, then combine more strips into one line.\n                unsigned short s;\n\n                // XXX:  this assumes strips; are separated-plane\n                // tiles possible?\n\n                unsigned char *p_line = tiffline;\n                for (int n = 0; n < (cols/8 * bps*spp); n++)\n                    *p_line++ = '\\0';\n\n                for (s = 0; s < spp; s++) {\n                    unsigned char *p_strip = tiffstrip;\n                    int getbitsleft = 8;\n                    p_line = tiffline;\n                    int putbitsleft = 8;\n\n                    if (TIFFReadScanline(tif, tiffstrip, row, s) < 0) {\n                        err_printf(\"Bad data read on line %d (%s).\\n\",\n                            row, tiffname);\n                        png_destroy_write_struct(&png_ptr, &info_ptr);\n                        TIFFClose(tif);\n                        delete [] tiffline;\n                        delete [] tiffstrip;\n                        return (false);\n                    }\n\n                    p_strip = (unsigned char *)tiffstrip;\n                    unsigned char sample = '\\0';\n                    for (int i = 0 ; i < s ; i++)\n                        PUT_LINE_SAMPLE\n                    for (int n = 0; n < cols; n++) {\n                        GET_STRIP_SAMPLE\n                        PUT_LINE_SAMPLE\n                        sample = '\\0';\n                        for (int i = 0 ; i < (spp-1) ; i++)\n                            PUT_LINE_SAMPLE\n                    }\n                }\n            }\n\n            unsigned char *p_line = tiffline;\n            int bitsleft = 8;\n            png_byte *p_png = pngline;\n\n            // Convert from tiff-line to png-line.\n\n            switch (tiff_color_type) {\n            case PNG_COLOR_TYPE_GRAY:       // we know spp == 1\n                for (int col = cols; col > 0; --col) {\n                    switch (bps) {\n                    case 16:\n#ifdef INVERT_MINISWHITE\n                        if (photometric == PHOTOMETRIC_MINISWHITE) {\n                            unsigned char sample;\n                            int sample16;\n                            if (bigendian) {\n                                // same as PNG order\n                                GET_LINE_SAMPLE\n                                sample16 = sample;\n                                sample16 <<= 8;\n                                GET_LINE_SAMPLE\n                                sample16 |= sample;\n                            }\n                            else {\n                                // reverse of PNG\n                                GET_LINE_SAMPLE\n                                sample16 = sample;\n                                GET_LINE_SAMPLE\n                                sample16 |= (((int)sample) << 8);\n                            }\n                            sample16 = maxval - sample16;\n                            *p_png++ = (unsigned char)((sample16 >> 8) & 0xff);\n                            *p_png++ = (unsigned char)(sample16 & 0xff);\n                        }\n                        else // not PHOTOMETRIC_MINISWHITE\n#endif\n                        {\n                            unsigned char sample;\n                            if (bigendian) {\n                                GET_LINE_SAMPLE\n                                *p_png++ = sample;\n                                GET_LINE_SAMPLE\n                                *p_png++ = sample;\n                            }\n                            else {\n                                GET_LINE_SAMPLE\n                                p_png[1] = sample;\n                                GET_LINE_SAMPLE\n                                *p_png = sample;\n                                p_png += 2;\n                            }\n                        }\n                        break;\n\n                    case 8:\n                    case 4:\n                    case 2:\n                    case 1:\n                        {\n                            unsigned char sample;\n                            GET_LINE_SAMPLE\n#ifdef INVERT_MINISWHITE\n                            if (photometric == PHOTOMETRIC_MINISWHITE)\n                                sample = maxval - sample;\n#endif\n                            *p_png++ = sample;\n                        }\n                        break;\n\n                    }\n                }\n                break;\n\n            case PNG_COLOR_TYPE_GRAY_ALPHA:\n                for (int col = 0; col < cols; col++) {\n                    for (int i = 0 ; i < spp ; i++) {\n                        switch (bps) {\n                        case 16:\n#ifdef INVERT_MINISWHITE\n                            if (photometric == PHOTOMETRIC_MINISWHITE &&\n                                    i == 0) {\n                                unsigned char sample;\n                                int sample16;\n                                if (bigendian) {\n                                    GET_LINE_SAMPLE\n                                    sample16 = (sample << 8);\n                                    GET_LINE_SAMPLE\n                                    sample16 |= sample;\n                                }\n                                else {\n                                    GET_LINE_SAMPLE\n                                    sample16 = sample;\n                                    GET_LINE_SAMPLE\n                                    sample16 |= (((int)sample) << 8);\n                                }\n                                sample16 = maxval - sample16;\n                                *p_png++ = (unsigned char)(\n                                    (sample16 >> 8) & 0xff);\n                                *p_png++ = (unsigned char)(sample16 & 0xff);\n                            }\n                            else\n#endif\n                            {\n                                unsigned char sample;\n                                if (bigendian) {\n                                    GET_LINE_SAMPLE\n                                    *p_png++ = sample;\n                                    GET_LINE_SAMPLE\n                                    *p_png++ = sample;\n                                }\n                                else {\n                                    GET_LINE_SAMPLE\n                                    p_png[1] = sample;\n                                    GET_LINE_SAMPLE\n                                    *p_png = sample;\n                                    p_png += 2;\n                                }\n                            }\n                            break;\n\n                        case 8:\n                            {\n                                unsigned char sample;\n                                GET_LINE_SAMPLE\n#ifdef INVERT_MINISWHITE\n                                if (photometric == PHOTOMETRIC_MINISWHITE &&\n                                        i == 0)\n                                    sample = maxval - sample;\n#endif\n                                *p_png++ = sample;\n                            }\n                            break;\n\n                        case 4:\n                            {\n                                unsigned char sample;\n                                GET_LINE_SAMPLE\n#ifdef INVERT_MINISWHITE\n                                if (photometric == PHOTOMETRIC_MINISWHITE &&\n                                        i == 0)\n                                    sample = maxval - sample;\n#endif\n                                *p_png++ = sample * 17;   /* was 16 */\n                            }\n                            break;\n\n                        case 2:\n                            {\n                                unsigned char sample;\n                                GET_LINE_SAMPLE\n#ifdef INVERT_MINISWHITE\n                                if (photometric == PHOTOMETRIC_MINISWHITE &&\n                                        i == 0)\n                                    sample = maxval - sample;\n#endif\n                                *p_png++ = sample * 85;   /* was 64 */\n                            }\n                            break;\n\n                        case 1:\n                            {\n                                unsigned char sample;\n                                GET_LINE_SAMPLE\n#ifdef INVERT_MINISWHITE\n                                if (photometric == PHOTOMETRIC_MINISWHITE &&\n                                        i == 0)\n                                    sample = maxval - sample;\n#endif\n                                *p_png++ = sample * 255;  /* was 128...oops */\n                            }\n                            break;\n\n                        }\n                    }\n                }\n                break;\n\n            case PNG_COLOR_TYPE_RGB:\n            case PNG_COLOR_TYPE_RGB_ALPHA:\n                for (int col = 0; col < cols; col++) {\n                    // Process for red, green and blue (and when\n                    // applicable alpha).\n\n                    for (int i = 0 ; i < spp ; i++) {\n                        switch (bps) {\n                        case 16:\n                            // XXX:  do we need INVERT_MINISWHITE\n                            // support here, too, or is that only for\n                            // grayscale?\n\n                            unsigned char sample;\n                            if (bigendian) {\n                                GET_LINE_SAMPLE\n                                *p_png++ = sample;\n                                GET_LINE_SAMPLE\n                                *p_png++ = sample;\n                            }\n                            else {\n                                GET_LINE_SAMPLE\n                                p_png[1] = sample;\n                                GET_LINE_SAMPLE\n                                *p_png = sample;\n                                p_png += 2;\n                            }\n                            break;\n\n                        case 8:\n                            GET_LINE_SAMPLE\n                            *p_png++ = sample;\n                            break;\n\n                        case 4:\n                            GET_LINE_SAMPLE\n                            *p_png++ = sample * 17;\n                            break;\n\n                        case 2:\n                            GET_LINE_SAMPLE\n                            *p_png++ = sample * 85;\n                            break;\n\n                        case 1:\n                            GET_LINE_SAMPLE\n                            *p_png++ = sample * 255;\n                           break;\n\n                        }\n                    }\n                }\n                break;\n  \n            case PNG_COLOR_TYPE_PALETTE:\n                for (int col = 0; col < cols; col++) {\n                    unsigned char sample;\n                    GET_LINE_SAMPLE\n                    *p_png++ = sample;\n                }\n                break;\n  \n            default:\n                err_printf(\"Unknown photometric (%d) (%s).\\n\",\n                    photometric, tiffname);\n                png_destroy_write_struct(&png_ptr, &info_ptr);\n                TIFFClose(tif);\n                delete [] tiffline;\n                if (tiled && planar == 1)\n                    delete [] tifftile;\n                else if (planar != 1)\n                    delete [] tiffstrip;\n                return (false);\n\n            }\n            png_write_row(png_ptr, pngline);\n        }\n    }\n\n    TIFFClose(tif);\n\n    png_write_end(png_ptr, info_ptr);\n\n    png_destroy_write_struct(&png_ptr, &info_ptr);\n\n    free(tiffline);\n    if (tiled && planar == 1)\n        delete [] tifftile;\n    else if (planar != 1)\n        delete [] tiffstrip;\n    return (true);\n}\n\n\n#else\n\nhtmRawImageData*\nhtmImageManager::readTIFF(ImageBuffer*)\n{\n    return (0);\n}\n\n#endif\n\n",
                "name": "htm_TIFF.cc",
                "path": "mozy/src/htm/htm_TIFF.cc",
                "url": "/github.com/wrcad/xictools/-/blob/mozy/src/htm/htm_TIFF.cc"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 317,
                    "offsetAndLengths": [
                        [
                            8,
                            18
                        ]
                    ],
                    "preview": "        TIFFPrintDirectory(tif, stderr, TIFFPRINT_NONE);"
                }
            ],
            "repository": {
                "name": "github.com/wrcad/xictools",
                "url": "/github.com/wrcad/xictools"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "c879e6eeedc274706c6138f7823318df68147c1b"
                },
                "content": "#ifdef TINYTIFF_TEST_LIBTIFF\r\n#include <tiffio.h>\r\n#include \"libtiff_tools.h\"\r\n#endif\r\n#include <array>\r\n#include <fstream>\r\n#include <iostream>\r\n#include <string>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <iomanip>\r\n#include \"tinytiffwriter.h\"\r\n#include \"tinytiffreader.h\"\r\n#include \"tinytiffhighrestimer.h\"\r\n#include \"test_results.h\"\r\n#include \"testimage_tools.h\"\r\n#include <sys/types.h>\r\n#include <sys/stat.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <errno.h>\r\n#include <string.h>\r\n#include <cstring>\r\n#include <iostream>\r\n#include <fstream>\r\n#include <sstream>\r\n#include <cstdarg>\r\n#include <cstdio>\r\n#include <cstdlib>\r\n#include <vector>\r\n#include <time.h>\r\n#include <math.h>\r\n#include <sys/stat.h>\r\n#include <stdint.h>\r\n#include <stdexcept>\r\n#include <cctype>\r\n#include <array>\r\n#include \"tinytiff_tools.hxx\"\r\n\r\n\r\ninline TinyTIFFWriterFile* TinyTIFFWriter_open(const std::string& filename, uint16_t bitsPerSample, enum TinyTIFFWriterSampleFormat sampleFormat, uint16_t samples, uint32_t width, uint32_t height, enum TinyTIFFWriterSampleInterpretation sampleInterpretation) {\r\n    return TinyTIFFWriter_open(filename.c_str(), bitsPerSample, sampleFormat, samples, width, height, sampleInterpretation);\r\n}\r\n std::string tolower(const std::string& s){\r\n  std::string d;\r\n  d=\"\";\r\n  if (s.length()>0) {\r\n    for (unsigned long i=0; i<s.length(); i++) {\r\n        d+=std::tolower(s[i]);\r\n    }\r\n  }\r\n  return d;\r\n};\r\n\r\n bool strtobool(std::string data){\r\n    std::string d=tolower(data);\r\n  if (d==\"true\") return true;\r\n  if (d==\"t\") return true;\r\n  if (d==\"1\") return true;\r\n  if (d==\"j\") return true;\r\n  if (d==\"y\") return true;\r\n  if (d==\"yes\") return true;\r\n  if (d==\"ja\") return true;\r\n  return false;\r\n}\r\n std::string toupper(const std::string& s){\r\n  std::string d;\r\n  d=\"\";\r\n  if (s.length()>0) {\r\n    for (unsigned long i=0; i<s.length(); i++) {\r\n        d+=toupper(s[i]);\r\n    }\r\n  }\r\n  return d;\r\n};\r\n\r\n\r\n std::string inttostr(long data){\r\n  return format(\"%ld\", data);\r\n};\r\n\r\n std::string inttohex(long data){\r\n  return format(\"%lX\", data);\r\n};\r\n\r\n std::string uinttostr(unsigned long data){\r\n  std::ostringstream ost;\r\n  ost<<data;\r\n  return ost.str();\r\n};\r\n\r\n std::string floattostr(double data, int past_comma=-1, bool remove_trail0=false, double belowIsZero=1e-16){\r\n  if (belowIsZero>0) {\r\n      if (fabs(data)<belowIsZero) return std::string(\"0\");\r\n  }\r\n\r\n  std::string form=\"%.\"+inttostr(past_comma)+\"lf\";\r\n  //std::string form=\"%lf\";\r\n  if (past_comma<=0) form=\"%lf\";\r\n  std::string r=format(form,data);\r\n  //std::cout<<r<<std::endl;\r\n  if (remove_trail0 && (tolower(r).find('e')==std::string::npos)) {\r\n      if (data==0) return \"0\";\r\n      //size_t cp=r.find(\".\");\r\n      //if (cp<r.size()) return r;\r\n      std::string re;\r\n      size_t dpos=r.find('.');\r\n      if (dpos==std::string::npos) {\r\n          return r;\r\n      } else {\r\n          long i=r.size()-1;\r\n          bool nonz=false;\r\n          while (i>=0) {\r\n              //std::cout<<i<<\"\\n\";\r\n              if (r[i]!='0') {\r\n                  nonz=true;\r\n              }\r\n              if (nonz || (i<long(dpos))) {\r\n                  if (re.size()==0 && r[i]=='.') {\r\n                      // swallow decimal dot, if only 0 folowed\r\n                  } else {\r\n                      re=r[i]+re;\r\n                  }\r\n              }\r\n              i--;\r\n          }\r\n          return re;\r\n      }\r\n\r\n  }\r\n  return r;\r\n}\r\n\r\n std::string floattounitstr(double dataa, std::string unitname){\r\n  if (dataa==0) return floattostr(dataa)+unitname;\r\n  std::string u=\"\";\r\n  double factor=1;\r\n  double data=fabs(dataa);\r\n  if (data>=1e3) { u=\"k\"; factor=1e3; }\r\n  if (data>=1e6) { u=\"M\"; factor=1e6; }\r\n  if (data>=1e9) { u=\"G\"; factor=1e9; }\r\n  if (data>=1e12) { u=\"T\"; factor=1e12; }\r\n  if (data>=1e15) { u=\"P\"; factor=1e15; }\r\n  if (data>=1e18) { u=\"E\"; factor=1e18; }\r\n  if (data<1) {u=\"m\"; factor=1e-3; }\r\n  if (data<1e-3) {u=\"u\"; factor=1e-6; }\r\n  if (data<1e-6) {u=\"n\"; factor=1e-9; }\r\n  if (data<1e-9) {u=\"p\"; factor=1e-12; }\r\n  if (data<1e-12) {u=\"f\"; factor=1e-15; }\r\n  if (data<1e-15) {u=\"a\"; factor=1e-18; }\r\n\r\n  return floattostr(dataa/factor)+u+unitname;\r\n};\r\n\r\nusing namespace std;\r\n\r\n#define TESTFAIL(msg, res) { std::stringstream str; str<<msg; std::cout<<str.str()<<\"\\n\"; res.success=ok=false; res.message=str.str();}\r\n\r\n// save data (size=width*height*sizeof(TDATA)) into a file \\a filename\r\ntemplate<class TDATA>\r\nvoid SAVE_TIFF(const std::string& filename, const TDATA* data, size_t width, size_t height) {\r\n    TinyTIFFWriterFile* tiff = TinyTIFFWriter_open(filename.c_str(), sizeof(TDATA)*8, TinyTIFF_SampleFormatFromType<TDATA>().format, 1, width, height, TinyTIFFWriter_Greyscale);\r\n    TinyTIFFWriter_writeImage(tiff, data);\r\n    TinyTIFFWriter_close(tiff);\r\n}\r\n\r\n// save data (size=width*height*sizeof(TDATA)) into a file \\a filename\r\ntemplate<class TDATA>\r\nvoid SAVE_TIFF_libtiff(const std::string& filename, const TDATA* data, size_t width, size_t height, bool little_endian=true) {\r\n#ifdef TINYTIFF_TEST_LIBTIFF\r\n    TIFF* tifvideo;\r\n    if (little_endian) {\r\n        tifvideo=TIFFOpen(filename.c_str(), \"wl\");\r\n    } else {\r\n        tifvideo=TIFFOpen(filename.c_str(), \"wb\");\r\n    }\r\n    if (tifvideo) {\r\n        TIFFWrite<TDATA>(tifvideo, data, width, height);\r\n        TIFFWriteDirectory(tifvideo);\r\n        TIFFClose(tifvideo);\r\n    }\r\n#endif\r\n}\r\n\r\n\r\n// try to open a TIFF file with TInyTIFFReader, if read successfully, the read frames are stored using SAVE_TIFF,\r\n// does not check the contents for correctness!\r\ntemplate<class TIMAGESAMPLETYPE>\r\nvoid TEST_SIMPLE(const std::string& filename, std::vector<TestResult>& test_results) {\r\n    HighResTimer timer;\r\n    bool ok=false;\r\n    test_results.emplace_back();\r\n    test_results.back().name=std::string(\"TEST_SIMPLE(\")+std::string(filename)+std::string(\")\");\r\n    std::cout<<\"\\n\\nreading '\"<<std::string(filename)<<\"' and checking read contents ... filesize = \"<<bytestostr(get_filesize(filename.c_str()))<<\"\\n\";\r\n    test_results.back().success=ok=false;\r\n    TinyTIFFReaderFile* tiffr=TinyTIFFReader_open(filename.c_str());\r\n    if (!tiffr) {\r\n        TESTFAIL(\"reading (not existent, not accessible or no TIFF file)\", test_results.back())\r\n    } else {\r\n        if (TinyTIFFReader_wasError(tiffr)) TESTFAIL(\"\"<<TinyTIFFReader_getLastError(tiffr)<<\"\", test_results.back())\r\n        std::cout<<\"    ImageDescription:\\n\"<< TinyTIFFReader_getImageDescription(tiffr) <<\"\\n\";\r\n        timer.start();\r\n        uint32_t frames=TinyTIFFReader_countFrames(tiffr);\r\n        double duration=timer.get_time();\r\n        std::cout<<\"    frames: \"<<frames<<\"     [duration: \"<<duration<<\" us  =  \"<<floattounitstr(duration/1.0e6, \"s\")<<\" ]\\n\";\r\n        if (TinyTIFFReader_wasError(tiffr)) TESTFAIL(\"\"<<TinyTIFFReader_getLastError(tiffr)<<\"\", test_results.back())\r\n        timer.start();\r\n        test_results.back().success=ok=true;\r\n        uint32_t frame=0;\r\n        do {\r\n            uint32_t width=TinyTIFFReader_getWidth(tiffr);\r\n            uint32_t height=TinyTIFFReader_getHeight(tiffr);\r\n            if (width>0 && height>0) std::cout<<\"    size of frame \"<<frame<<\": \"<<width<<\"x\"<<height<<\"\\n\";\r\n            else { TESTFAIL(\"IN FRAME \"<<frame<<\": size too small \"<<width<<\"x\"<<height<<\"\", test_results.back()) test_results.back().success=ok=false; }\r\n            if (ok) {\r\n                frame++;\r\n                TIMAGESAMPLETYPE* tmp=(TIMAGESAMPLETYPE*)calloc(width*height, sizeof(TIMAGESAMPLETYPE));\r\n                TinyTIFFReader_getSampleData(tiffr, tmp, 0);\r\n                if (TinyTIFFReader_wasError(tiffr)) { test_results.back().success=ok=false; TESTFAIL(\"\"<<TinyTIFFReader_getLastError(tiffr)<<\"\", test_results.back()) }\r\n                if (ok) {\r\n                    char fn[1024];\r\n                    sprintf(fn, \"%s.%u.tif\", filename.c_str(), frame);\r\n                    SAVE_TIFF(fn, tmp, width, height);\r\n                }\r\n                free(tmp);\r\n            }\r\n        } while (ok && TinyTIFFReader_readNext(tiffr));\r\n        duration=timer.get_time();\r\n        test_results.back().duration_ms=duration/1.0e3;\r\n        test_results.back().numImages=frame;\r\n        std::cout<<\"    read and checked all frames: \"<<((ok)?std::string(\"SUCCESS\"):std::string(\"ERROR\"))<<\"     [duration: \"<<duration<<\" us  =  \"<<floattounitstr(duration/1.0e6, \"s\")<<\" ]\\n\";\r\n        std::cout<<\"    read \"<<frame<<\" frames\\n\";\r\n    }\r\n    TinyTIFFReader_close(tiffr);\r\n    test_results.back().success=ok;\r\n    if (ok) std::cout<<\"  => SUCCESS\\n\";\r\n    else std::cout<<\"  => NOT CORRECTLY READ\\n\";\r\n}\r\n\r\n\r\n// try to read the data in the TIFF file \\a filename with TinyTIFFReader, compare the read data to the data in image and imagei, the file is expected to contain either\r\n// a single frame of contents \\a image, or a series of frames alternativ between image and imagei (i.e.  image,imagei,image,imagei,image,...)\r\ntemplate<class TIMAGESAMPLETYPE>\r\nvoid TEST(const std::string& filename, const TIMAGESAMPLETYPE* image, const TIMAGESAMPLETYPE* imagei,size_t WIDTH_IN, size_t HEIGHT_IN, size_t SAMPLES_IN, size_t FRAMES_IN, std::vector<TestResult>& test_results) {\r\n    HighResTimer timer, timer1;\r\n    bool ok=false;\r\n    std::cout<<\"\\n\\nreading '\"<<std::string(filename)<<\"' and checking read contents ... filesize = \"<<bytestostr(get_filesize(filename.c_str()))<<\"\\n\";\r\n    test_results.emplace_back();\r\n    const std::string desc=std::to_string(WIDTH_IN)+\"x\"+std::to_string(HEIGHT_IN)+\"pix/\"+std::to_string(sizeof(TIMAGESAMPLETYPE)*8)+\"bit/\"+std::to_string(SAMPLES_IN)+\"ch/\"+std::to_string(FRAMES_IN)+\"frames\";\r\n    test_results.back().name=std::string(\"TEST(\")+desc+\", \"+std::string(filename)+std::string(\")\");\r\n    test_results.back().success=ok=false;\r\n    try {\r\n        TinyTIFFReaderFile* tiffr=TinyTIFFReader_open(filename.c_str());\r\n        if (!tiffr) {\r\n            TESTFAIL(\"reading (not existent, not accessible or no TIFF file)\", test_results.back())\r\n        } else {\r\n            if (TinyTIFFReader_wasError(tiffr)) TESTFAIL(\"\"<<TinyTIFFReader_getLastError(tiffr)<<\"\", test_results.back())\r\n            const char* desc=TinyTIFFReader_getImageDescription(tiffr);\r\n            if (desc!=NULL && strlen(desc)>0) {\r\n                std::cout<<\"    ImageDescription:\\n\"<< desc <<\"\\n\";\r\n            } else {\r\n                std::cout<<\"    ImageDescription: EMPTY\\n\";\r\n            }\r\n            timer.start();\r\n            uint32_t frames=TinyTIFFReader_countFrames(tiffr);\r\n            double duration=timer.get_time();\r\n            std::cout<<\"    frames: \"<<frames<<\"     [duration: \"<<duration<<\" us  =  \"<<floattounitstr(duration/1.0e6, \"s\")<<\" ]\\n\";\r\n            if (TinyTIFFReader_wasError(tiffr)) TESTFAIL(\"\"<<TinyTIFFReader_getLastError(tiffr)<<\"\", test_results.back())\r\n            timer.start();\r\n            test_results.back().success=ok=true;\r\n            uint32_t frame=0;\r\n            double duration_getdata=0, duration_nextframe=0;\r\n            bool next;\r\n            do {\r\n                uint32_t width=TinyTIFFReader_getWidth(tiffr);\r\n                uint32_t height=TinyTIFFReader_getHeight(tiffr);\r\n                uint32_t samples=TinyTIFFReader_getSamplesPerPixel(tiffr);\r\n                test_results.back().success=ok=(width==WIDTH_IN)&&(height==HEIGHT_IN)&&(samples==SAMPLES_IN);\r\n                if (!ok) TESTFAIL(\"IN FRAME \"<<frame<<\": size does not match, read \"<<width<<\"x\"<<height<<\"x\"<<samples<<\"    expected \"<<WIDTH_IN<<\"x\"<<HEIGHT_IN<<\"x\"<<SAMPLES_IN<<\"\", test_results.back());\r\n                if (ok) {\r\n                    for (size_t sample=0; sample<samples; sample++) {\r\n                        TIMAGESAMPLETYPE* tmp=(TIMAGESAMPLETYPE*)calloc(width*height, TinyTIFFReader_getBitsPerSample(tiffr, sample)/8);\r\n                        timer1.start();\r\n                        TinyTIFFReader_getSampleData(tiffr, tmp, sample);\r\n                        duration_getdata+=timer1.get_time();\r\n                        if (TinyTIFFReader_wasError(tiffr)) TESTFAIL(\"\"<<TinyTIFFReader_getLastError(tiffr)<<\"\", test_results.back())\r\n                        uint32_t poserror=0xFFFFFFFF;\r\n                        if (frame%2==0) {\r\n                            for (uint32_t i=0; i<width*height; i++) {\r\n                                test_results.back().success=ok=ok&&(tmp[i]==image[i*SAMPLES_IN+sample]);\r\n                                if (!ok) { poserror=i; break; }\r\n                            }\r\n                        } else {\r\n                            for (uint32_t i=0; i<width*height; i++) {\r\n                                test_results.back().success=ok=ok&&(tmp[i]==imagei[i*SAMPLES_IN+sample]);\r\n                                if (!ok) { poserror=i; break; }\r\n                            }\r\n                        }\r\n                        free(tmp);\r\n                        if (!ok) TESTFAIL(\"IN FRAME \"<<frame<<\"/ SAMPLE \"<<sample<<\": did not read correct contents @ pos=\"<<poserror<<\"\", test_results.back());\r\n                    }\r\n                }\r\n                if (ok) {\r\n                    frame++;\r\n                }\r\n                timer1.start();\r\n                next=TinyTIFFReader_readNext(tiffr);\r\n                duration_nextframe+=timer1.get_time();\r\n            } while (ok && next);\r\n            duration=timer.get_time();\r\n            test_results.back().duration_ms=duration/1.0e3;\r\n            test_results.back().numImages=frame;\r\n            std::cout<<\"    read and checked \"<<frame<<\" frames: \"<<((ok)?std::string(\"SUCCESS\"):std::string(\"ERROR\"))<<\"     [duration: \"<<duration<<\" us  =  \"<<floattounitstr(duration/1.0e6, \"s\")<<\" ]\\n\";\r\n            std::cout<<\"    getSampleData() consumed \"<<floattounitstr(duration_getdata/1.0e6, \"s\")<<\"\\n\";\r\n            std::cout<<\"    readNext() consumed \"<<floattounitstr(duration_nextframe/1.0e6, \"s\")<<\"\\n\";\r\n            std::cout<<\"    read \"<<frame<<\" frames\\n\";\r\n\r\n            if (frame!=FRAMES_IN) {\r\n                ok=false;\r\n                TESTFAIL(\"not enough frames red: expected: \"<<FRAMES_IN<<\", found: \"<<frame<<\"\", test_results.back())\r\n            }\r\n        }\r\n        TinyTIFFReader_close(tiffr);\r\n    } catch(...) {\r\n        ok=false;\r\n        std::cout<<\"       CRASH While reading file\\n\";\r\n    }\r\n\r\n    test_results.back().success=ok;\r\n    if (ok) std::cout<<\"  => SUCCESS\\n\";\r\n    else std::cout<<\"  => NOT CORRECTLY READ\\n\";\r\n}\r\n\r\n\r\n// try to read the data in the TIFF file \\a filename with TinyTIFFReader and LIBTIFF and compare the result of the two\r\ntemplate<class TIMAGESAMPLETYPE>\r\nvoid TEST_AGAINST_LIBTIFF(const std::string& filename, std::vector<TestResult>& test_results) {\r\n#ifdef TINYTIFF_TEST_LIBTIFF\r\n    HighResTimer timer, timer1;\r\n    bool ok=false;\r\n    std::cout<<\"\\n\\nreading '\"<<std::string(filename)<<\"' with tinytiff and libtiff and checking read contents ... filesize = \"<<bytestostr(get_filesize(filename.c_str()))<<\"\\n\";\r\n    test_results.emplace_back();\r\n    test_results.back().name=std::string(\"TEST_AGAINST_LIBTIFF(\")+std::string(filename)+std::string(\")\");\r\n    test_results.back().success=ok=false;\r\n    test_results.back().numImages=0;\r\n    try {\r\n        timer.start();\r\n        std::cout<<\"    libTIFF: opening file with     [duration: \"<<floattounitstr(double(timer.get_time())/1.0e6, \"s\")<<\" ]\\n\";\r\n        TIFF* ltiff=TIFFOpen(filename.c_str(), \"r\");\r\n        if (!ltiff) {\r\n            TESTFAIL(\"libTIFF ERROR: reading (not existent, not accessible or no TIFF file)\", test_results.back())\r\n        } else {\r\n            timer.start();\r\n            uint32_t libTIFF_frames=TIFFCountDirectories(ltiff);\r\n            double duration=timer.get_time();\r\n            std::cout<<\"    libTIFF: frames: \"<<libTIFF_frames<<\"     [duration: \"<<duration<<\" us  =  \"<<floattounitstr(duration/1.0e6, \"s\")<<\" ]\\n\";\r\n            std::cout<<\"    TinyTIFF: opening file with     [duration: \"<<floattounitstr(double(timer.get_time())/1.0e6, \"s\")<<\" ]\\n\";\r\n            TinyTIFFReaderFile* tiffr=TinyTIFFReader_open(filename.c_str());\r\n            if (!tiffr) {\r\n                TESTFAIL(\"TinyTIFF ERROR: reading (not existent, not accessible or no TIFF file)\", test_results.back())\r\n                ok=false;\r\n            } else if (TinyTIFFReader_wasError(tiffr)) {\r\n                TESTFAIL(\"TinyTIFF ERROR: \"<<TinyTIFFReader_getLastError(tiffr)<<\"\", test_results.back())\r\n                ok=false;\r\n            } else {\r\n                timer.start();\r\n                uint32_t tinyTIFF_frames=TinyTIFFReader_countFrames(tiffr);\r\n                duration=timer.get_time();\r\n                std::cout<<\"    TinyTIFF: frames: \"<<tinyTIFF_frames<<\"     [duration: \"<<duration<<\" us  =  \"<<floattounitstr(duration/1.0e6, \"s\")<<\" ]\\n\";\r\n                if (TinyTIFFReader_wasError(tiffr)) {\r\n                    TESTFAIL(\"TinyTIFF ERROR: \"<<TinyTIFFReader_getLastError(tiffr)<<\"\", test_results.back())\r\n                    ok=false;\r\n                } else {\r\n                    if (libTIFF_frames!=tinyTIFF_frames) {\r\n                        TESTFAIL(\"number of frames, read with TinyTIFF (\"<<tinyTIFF_frames<<\") and libTIFF (\"<<libTIFF_frames<<\") are not equal!\", test_results.back())\r\n                        ok=false;\r\n                    } else {\r\n                        timer.start();\r\n                        size_t frame=0;\r\n                        ok=true;\r\n                        do {\r\n                            std::cout<<\"   frame: \"<<frame<<std::endl;\r\n                            uint32_t tinyTIFF_width=TinyTIFFReader_getWidth(tiffr);\r\n                            uint32_t tinyTIFF_height=TinyTIFFReader_getHeight(tiffr);\r\n                            uint16_t tinyTIFF_bitspersample=TinyTIFFReader_getBitsPerSample(tiffr, 0);\r\n                            uint16_t tinyTIFF_samplesperpixel=TinyTIFFReader_getSamplesPerPixel(tiffr);\r\n                            const char* tinyTIFF_imagedesc=TinyTIFFReader_getImageDescription(tiffr);\r\n                            std::cout<<\"     tinyTIFF: width=\"<<tinyTIFF_width<<\", height=\"<<tinyTIFF_height<<\", bitspersample=\"<<tinyTIFF_bitspersample<<\", samplesperpixel=\"<<tinyTIFF_samplesperpixel<<\"\\n\";\r\n                            if (frame==0) {\r\n                                const std::string desc=std::to_string(tinyTIFF_width)+\"x\"+std::to_string(tinyTIFF_height)+\"pix/\"+std::to_string(sizeof(TIMAGESAMPLETYPE)*8)+\"bit/\"+std::to_string(tinyTIFF_samplesperpixel)+\"ch/\"+std::to_string(tinyTIFF_frames)+\"frames\";\r\n                                test_results.back().name=std::string(\"TEST_AGAINST_LIBTIFF(\")+desc+\", \"+std::string(filename)+std::string(\")\");\r\n                            }\r\n\r\n                            uint32_t libTIFF_width=0;\r\n                            uint32_t libTIFF_height=0;\r\n                            uint32_t libTIFF_bitspersample=0;\r\n                            uint32_t libTIFF_samplesperpixel=0;\r\n                            char*libtiff_imagedesc;\r\n                            TIFFGetField(ltiff,TIFFTAG_SAMPLESPERPIXEL,&libTIFF_samplesperpixel);\r\n                            TIFFGetField(ltiff,TIFFTAG_BITSPERSAMPLE,&libTIFF_bitspersample);\r\n                            TIFFGetField(ltiff,TIFFTAG_IMAGEWIDTH,&libTIFF_width);\r\n                            TIFFGetField(ltiff,TIFFTAG_IMAGELENGTH,&libTIFF_height);\r\n                            TIFFGetField(ltiff,TIFFTAG_IMAGEDESCRIPTION,&libtiff_imagedesc);\r\n                            TIFFPrintDirectory(ltiff, stdout,TIFFPRINT_STRIPS|TIFFPRINT_COLORMAP);\r\n                            std::cout<<\"     libTIFF:  width=\"<<libTIFF_width<<\", height=\"<<libTIFF_height<<\", bitspersample=\"<<libTIFF_bitspersample<<\", samplesperpixel=\"<<libTIFF_samplesperpixel<<\"\\n\";\r\n\r\n                            if (tinyTIFF_width!=libTIFF_width) {\r\n                                TESTFAIL(\"in frame \"<<frame<<\": TinyTIFF and libTIFF read different widths (TinyTIFF: \"<<tinyTIFF_width<<\" != libTIFF: \"<<libTIFF_width<<\")\", test_results.back())\r\n                                ok=false;\r\n                                break;\r\n                            }\r\n                            if (tinyTIFF_height!=libTIFF_height) {\r\n                                TESTFAIL(\"in frame \"<<frame<<\": TinyTIFF and libTIFF read different heights (TinyTIFF: \"<<tinyTIFF_height<<\" != libTIFF: \"<<libTIFF_height<<\")\", test_results.back())\r\n                                ok=false;\r\n                                break;\r\n                            }\r\n                            if (tinyTIFF_bitspersample!=libTIFF_bitspersample) {\r\n                                TESTFAIL(\"in frame \"<<frame<<\": TinyTIFF and libTIFF read different bitspersamples (TinyTIFF: \"<<tinyTIFF_bitspersample<<\" != libTIFF: \"<<libTIFF_bitspersample<<\")\", test_results.back())\r\n                                ok=false;\r\n                                break;\r\n                            }\r\n                            if (tinyTIFF_samplesperpixel!=libTIFF_samplesperpixel) {\r\n                                TESTFAIL(\"in frame \"<<frame<<\": TinyTIFF and libTIFF read different samplesperpixels (TinyTIFF: \"<<tinyTIFF_samplesperpixel<<\" != libTIFF: \"<<libTIFF_samplesperpixel<<\")\", test_results.back())\r\n                                ok=false;\r\n                                break;\r\n                            }\r\n                            if (tinyTIFF_imagedesc==nullptr || libtiff_imagedesc==nullptr || strcmp(tinyTIFF_imagedesc, libtiff_imagedesc)!=0) {\r\n                                std::cout<<\"       WARNING in frame \"<<frame<<\": TinyTIFF and libTIFF read different descriptions (TinyTIFF: '\"<<tinyTIFF_imagedesc<<\"' != libTIFF: '\"<<libtiff_imagedesc<<\"')\\n\";\r\n                                //ok=false;\r\n                                //break;\r\n                            }\r\n                            if (ok) {\r\n                                for (size_t sample=0; sample<libTIFF_samplesperpixel; sample++) {\r\n                                    std::vector<TIMAGESAMPLETYPE> tinyTIFF_data(tinyTIFF_width*tinyTIFF_height*sizeof(TIMAGESAMPLETYPE)*2, 0);\r\n                                    TinyTIFFReader_getSampleData(tiffr,tinyTIFF_data.data(), sample);\r\n                                    if (TinyTIFFReader_wasError(tiffr)) {\r\n                                        TESTFAIL(\"TinyTIFF ERROR: reading frame \"<<frame<<\", sample \"<<sample<<\":\"<<TinyTIFFReader_getLastError(tiffr)<<\"\", test_results.back())\r\n                                        ok=false;\r\n                                        break;\r\n                                    }\r\n                                    std::vector<TIMAGESAMPLETYPE> libTIFF_data(libTIFF_width*libTIFF_height*sizeof(TIMAGESAMPLETYPE)*2, 0);\r\n                                    if (!TIFFReadFrame(ltiff, libTIFF_data.data(), sample)) {\r\n                                        TESTFAIL(\"libTIFF ERROR: reading frame \"<<frame<<\", sample \"<<sample<<\"\", test_results.back())\r\n                                        ok=false;\r\n                                        break;\r\n                                    }\r\n                                    for (size_t i=0; i<libTIFF_data.size(); i++) {\r\n                                        if (i<=8) std::cout<<\"          f\"<<frame<<\"s\"<<sample<<\"i\"<<i<<\": tiny=\"<<std::dec<<static_cast<typename atleast_int<TIMAGESAMPLETYPE>::TPrint>(tinyTIFF_data[i])<<\" lib=\"<<static_cast<typename atleast_int<TIMAGESAMPLETYPE>::TPrint>(libTIFF_data[i])<<\"\\n\";\r\n                                        if (libTIFF_data[i]!=tinyTIFF_data[i]) {\r\n                                            TESTFAIL(\"in frame \"<<frame<<\", sample \"<<sample<<\": TinyTIFF and libTIFF read different sample values (I=\"<<i<<\": TinyTIFF: \"<<std::dec<<static_cast<typename atleast_int<TIMAGESAMPLETYPE>::TPrint>(tinyTIFF_data[i])<<\" != libTIFF: \"<<std::dec<<static_cast<typename atleast_int<TIMAGESAMPLETYPE>::TPrint>(libTIFF_data[i])<<\")\", test_results.back())\r\n                                            ok=false;\r\n                                            break;\r\n                                        }\r\n                                    }\r\n                                    if (!ok) {\r\n                                        SAVE_TIFF(std::string(std::string(filename)+\".tinytiff.error_sample\"+std::to_string(sample)+\".tif\").c_str(), tinyTIFF_data.data(), tinyTIFF_width, tinyTIFF_height);\r\n                                        SAVE_TIFF(std::string(std::string(filename)+\".libtiff.error_sample\"+std::to_string(sample)+\".tif\").c_str(), libTIFF_data.data(), tinyTIFF_width, tinyTIFF_height);\r\n                                    }\r\n                                }\r\n                            }\r\n\r\n\r\n                            frame++;\r\n                        } while (ok && TIFFReadDirectory(ltiff) && TinyTIFFReader_readNext(tiffr));\r\n\r\n                        test_results.back().success=ok;\r\n                        test_results.back().numImages=frame;\r\n                        duration=timer.get_time();\r\n                        test_results.back().duration_ms=duration/1.0e3;\r\n                        std::cout<<\"    read and checked all \"<<frame<<\" frames: \"<<((ok)?std::string(\"SUCCESS\"):std::string(\"ERROR\"))<<\"     [duration: \"<<duration<<\" us  =  \"<<floattounitstr(duration/1.0e6, \"s\")<<\" ]\\n\";\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    } catch(...) {\r\n        ok=false;\r\n        std::cout<<\"       CRASH While reading file\\n\";\r\n    }\r\n\r\n    test_results.back().success=ok;\r\n    if (ok) std::cout<<\"  => SUCCESS\\n\";\r\n    else std::cout<<\"  => NOT CORRECTLY READ\\n\";\r\n#endif\r\n}\r\n\r\n\r\n\r\n#ifdef TINYTIFF_TEST_LIBTIFF\r\nstatic void errorhandler(const char* module, const char* fmt, va_list ap)\r\n{\r\n    static std::array<char, 1024> errorbuffer;\r\n    vsnprintf(errorbuffer.data(), errorbuffer.size(), fmt, ap);\r\n\r\n    std::cout<<\"###LIBTIFF-ERROR: \"<<module<<\": \"<<errorbuffer.data()<<\"\\n\";\r\n}\r\nstatic void warninghandler(const char* module, const char* fmt, va_list ap)\r\n{\r\n    static std::array<char, 1024> errorbuffer;\r\n    vsnprintf(errorbuffer.data(), errorbuffer.size(), fmt, ap);\r\n\r\n    std::cout<<\"###LIBTIFF-WARNING: \"<<module<<\": \"<<errorbuffer.data()<<\"\\n\";\r\n}\r\n#endif\r\n\r\n\r\n\r\nint main(int argc, char *argv[]) {\r\n    int quicktest=TINYTIFF_FALSE;\r\n    if (argc>1 && std::string(argv[1])==\"--simple\")  quicktest=TINYTIFF_TRUE;\r\n\r\n    std::cout<<\"tinytiffreader_test:\"<<std::endl;\r\n    if (quicktest!=TINYTIFF_FALSE) std::cout<<\"  - quick test with --simple\"<<std::endl;\r\n#ifdef TINYTIFF_TEST_LIBTIFF\r\n    std::cout<<\"  - checking against LibTIFF \"<<TIFFGetVersion()<<std::endl;\r\n    TIFFSetErrorHandler(errorhandler);\r\n    TIFFSetWarningHandler(warninghandler);\r\n#endif\r\n    std::cout<<\"creating some test TIFF files ...\"<<std::endl;\r\n\r\n    HighResTimer timer, timer1;\r\n\r\n    const size_t WIDTH=(quicktest!=TINYTIFF_FALSE)?32:513;\r\n    const size_t HEIGHT=(quicktest!=TINYTIFF_FALSE)?32:333;\r\n    const size_t PATTERNSIZE=12;\r\n    const size_t TEST_FRAMES=(quicktest!=TINYTIFF_FALSE)?6:100;\r\n\r\n\r\n    vector<uint8_t> image8(WIDTH*HEIGHT, 0);\r\n    vector<uint8_t> image8i(WIDTH*HEIGHT, 0);\r\n    vector<uint16_t> image16(WIDTH*HEIGHT, 0);\r\n    vector<uint16_t> image16i(WIDTH*HEIGHT, 0);\r\n    vector<uint32_t> image32(WIDTH*HEIGHT, 0);\r\n    vector<uint32_t> image32i(WIDTH*HEIGHT, 0);\r\n    vector<uint64_t> image64(WIDTH*HEIGHT, 0);\r\n    vector<uint64_t> image64i(WIDTH*HEIGHT, 0);\r\n    vector<float> imagef(WIDTH*HEIGHT, 0);\r\n    vector<float> imagefi(WIDTH*HEIGHT, 0);\r\n    vector<double> imaged(WIDTH*HEIGHT, 0);\r\n    vector<double> imagedi(WIDTH*HEIGHT, 0);\r\n    vector<uint8_t> imagergb(WIDTH*HEIGHT*3, 0);\r\n    vector<uint8_t> imagergbi(WIDTH*HEIGHT*3, 0);\r\n\r\n    write1ChannelTestData(image8.data(), WIDTH, HEIGHT, PATTERNSIZE);\r\n    write1ChannelTestData(image8i.data(), WIDTH, HEIGHT, PATTERNSIZE);\r\n    invertTestImage(image8i.data(), WIDTH, HEIGHT);\r\n    write1ChannelTestData(image16.data(), WIDTH, HEIGHT, PATTERNSIZE);\r\n    write1ChannelTestData(image16i.data(), WIDTH, HEIGHT, PATTERNSIZE);\r\n    invertTestImage(image16i.data(), WIDTH, HEIGHT);\r\n    write1ChannelTestData(image32.data(), WIDTH, HEIGHT, PATTERNSIZE);\r\n    write1ChannelTestData(image32i.data(), WIDTH, HEIGHT, PATTERNSIZE);\r\n    invertTestImage(image32i.data(), WIDTH, HEIGHT);\r\n    write1ChannelTestData(image64.data(), WIDTH, HEIGHT, PATTERNSIZE);\r\n    write1ChannelTestData(image64i.data(), WIDTH, HEIGHT, PATTERNSIZE);\r\n    invertTestImage(image64i.data(), WIDTH, HEIGHT);\r\n    write1ChannelFloatTestData(imagef.data(), WIDTH, HEIGHT, PATTERNSIZE);\r\n    write1ChannelFloatTestData(imagefi.data(), WIDTH, HEIGHT, PATTERNSIZE);\r\n    invertFloatTestImage(imagefi.data(), WIDTH, HEIGHT);\r\n    write1ChannelFloatTestData(imaged.data(), WIDTH, HEIGHT, PATTERNSIZE);\r\n    write1ChannelFloatTestData(imagedi.data(), WIDTH, HEIGHT, PATTERNSIZE);\r\n    invertFloatTestImage(imagedi.data(), WIDTH, HEIGHT);\r\n    writeRGBTestDataChunky(imagergb.data(), WIDTH, HEIGHT, PATTERNSIZE,3);\r\n    writeRGBTestDataChunky(imagergbi.data(), WIDTH, HEIGHT, PATTERNSIZE,3);\r\n    invertTestImage(imagergbi.data(), WIDTH, HEIGHT,3);\r\n\r\n    TinyTIFFWriterFile* tiff = TinyTIFFWriter_open(\"test8.tif\", 8, TinyTIFFWriter_UInt, 1, WIDTH,HEIGHT, TinyTIFFWriter_AutodetectSampleInterpetation);\r\n    TinyTIFFWriter_writeImage(tiff, image8.data());\r\n    TinyTIFFWriter_close(tiff);\r\n#ifdef TINYTIFF_TEST_LIBTIFF\r\n    SAVE_TIFF_libtiff(\"test8_littleendian.tif\", image8.data(), WIDTH, HEIGHT, true);\r\n    SAVE_TIFF_libtiff(\"test8_bigendian.tif\", image8.data(), WIDTH, HEIGHT, false);\r\n#endif\r\n    tiff = TinyTIFFWriter_open(\"test8m.tif\", 8, TinyTIFFWriter_UInt, 1, WIDTH,HEIGHT, TinyTIFFWriter_AutodetectSampleInterpetation);\r\n    for (size_t i=0; i<TEST_FRAMES/2; i++) {\r\n        TinyTIFFWriter_writeImage(tiff, image8.data());\r\n        TinyTIFFWriter_writeImage(tiff, image8i.data());\r\n    }\r\n    TinyTIFFWriter_close(tiff);\r\n\r\n    tiff = TinyTIFFWriter_open(\"test16.tif\", 16, TinyTIFFWriter_UInt, 1, WIDTH,HEIGHT, TinyTIFFWriter_AutodetectSampleInterpetation);\r\n    TinyTIFFWriter_writeImage(tiff, image16.data());\r\n    TinyTIFFWriter_close(tiff);\r\n#ifdef TINYTIFF_TEST_LIBTIFF\r\n    SAVE_TIFF_libtiff(\"test16_littleendian.tif\", image16.data(), WIDTH, HEIGHT, true);\r\n    SAVE_TIFF_libtiff(\"test16_bigendian.tif\", image16.data(), WIDTH, HEIGHT, false);\r\n#endif\r\n    tiff = TinyTIFFWriter_open(\"test16m.tif\", 16, TinyTIFFWriter_UInt, 1, WIDTH,HEIGHT, TinyTIFFWriter_AutodetectSampleInterpetation);\r\n    for (size_t i=0; i<TEST_FRAMES/2; i++) {\r\n        TinyTIFFWriter_writeImage(tiff, image16.data());\r\n        TinyTIFFWriter_writeImage(tiff, image16i.data());\r\n    }\r\n    TinyTIFFWriter_close(tiff);\r\n\r\n    tiff = TinyTIFFWriter_open(\"test32.tif\", 32, TinyTIFFWriter_UInt, 1, WIDTH,HEIGHT, TinyTIFFWriter_AutodetectSampleInterpetation);\r\n    TinyTIFFWriter_writeImage(tiff, image32.data());\r\n    TinyTIFFWriter_close(tiff);\r\n#ifdef TINYTIFF_TEST_LIBTIFF\r\n    SAVE_TIFF_libtiff(\"test32_littleendian.tif\", image32.data(), WIDTH, HEIGHT, true);\r\n    SAVE_TIFF_libtiff(\"test32_bigendian.tif\", image32.data(), WIDTH, HEIGHT, false);\r\n#endif\r\n    tiff = TinyTIFFWriter_open(\"test32m.tif\", 32, TinyTIFFWriter_UInt, 1, WIDTH,HEIGHT, TinyTIFFWriter_AutodetectSampleInterpetation);\r\n    for (size_t i=0; i<TEST_FRAMES/2; i++) {\r\n        TinyTIFFWriter_writeImage(tiff, image32.data());\r\n        TinyTIFFWriter_writeImage(tiff, image32i.data());\r\n    }\r\n    TinyTIFFWriter_close(tiff);\r\n\r\n    tiff = TinyTIFFWriter_open(\"test64.tif\", 64, TinyTIFFWriter_UInt, 1, WIDTH,HEIGHT, TinyTIFFWriter_AutodetectSampleInterpetation);\r\n    TinyTIFFWriter_writeImage(tiff, image64.data());\r\n    TinyTIFFWriter_close(tiff);\r\n#ifdef TINYTIFF_TEST_LIBTIFF\r\n    SAVE_TIFF_libtiff(\"test64_littleendian.tif\", image64.data(), WIDTH, HEIGHT, true);\r\n    SAVE_TIFF_libtiff(\"test64_bigendian.tif\", image64.data(), WIDTH, HEIGHT, false);\r\n#endif\r\n    tiff = TinyTIFFWriter_open(\"test64m.tif\", 64, TinyTIFFWriter_UInt, 1, WIDTH,HEIGHT, TinyTIFFWriter_AutodetectSampleInterpetation);\r\n    for (size_t i=0; i<TEST_FRAMES/2; i++) {\r\n        TinyTIFFWriter_writeImage(tiff, image64.data());\r\n        TinyTIFFWriter_writeImage(tiff, image64i.data());\r\n    }\r\n    TinyTIFFWriter_close(tiff);\r\n\r\n    tiff = TinyTIFFWriter_open(\"testf.tif\", 32, TinyTIFFWriter_Float, 1, WIDTH,HEIGHT, TinyTIFFWriter_AutodetectSampleInterpetation);\r\n    TinyTIFFWriter_writeImage(tiff, imagef.data());\r\n    TinyTIFFWriter_close(tiff);\r\n    tiff = TinyTIFFWriter_open(\"testfm.tif\", 32, TinyTIFFWriter_Float, 1, WIDTH,HEIGHT, TinyTIFFWriter_AutodetectSampleInterpetation);\r\n    for (size_t i=0; i<TEST_FRAMES/2; i++) {\r\n        TinyTIFFWriter_writeImage(tiff, imagef.data());\r\n        TinyTIFFWriter_writeImage(tiff, imagefi.data());\r\n    }\r\n    TinyTIFFWriter_close(tiff);\r\n\r\n    tiff = TinyTIFFWriter_open(\"testd.tif\", 64, TinyTIFFWriter_Float, 1, WIDTH,HEIGHT, TinyTIFFWriter_AutodetectSampleInterpetation);\r\n    TinyTIFFWriter_writeImage(tiff, imaged.data());\r\n    TinyTIFFWriter_close(tiff);\r\n    tiff = TinyTIFFWriter_open(\"testdm.tif\", 64, TinyTIFFWriter_Float, 1, WIDTH,HEIGHT, TinyTIFFWriter_AutodetectSampleInterpetation);\r\n    for (size_t i=0; i<TEST_FRAMES/2; i++) {\r\n        TinyTIFFWriter_writeImage(tiff, imaged.data());\r\n        TinyTIFFWriter_writeImage(tiff, imagedi.data());\r\n    }\r\n    TinyTIFFWriter_close(tiff);\r\n\r\n    tiff = TinyTIFFWriter_open(\"testrgb.tif\", 8, TinyTIFFWriter_UInt, 3, WIDTH,HEIGHT, TinyTIFFWriter_AutodetectSampleInterpetation);\r\n    TinyTIFFWriter_writeImagePlanarReorder(tiff, imagergb.data());\r\n    TinyTIFFWriter_close(tiff);\r\n    tiff = TinyTIFFWriter_open(\"testrgbm.tif\", 8, TinyTIFFWriter_UInt, 3, WIDTH,HEIGHT, TinyTIFFWriter_AutodetectSampleInterpetation);\r\n    for (size_t i=0; i<TEST_FRAMES/2; i++) {\r\n        TinyTIFFWriter_writeImagePlanarReorder(tiff, imagergb.data());\r\n        TinyTIFFWriter_writeImagePlanarReorder(tiff, imagergbi.data());\r\n    }\r\n    TinyTIFFWriter_close(tiff);\r\n\r\n    std::cout<<\" DONE!\\n\";\r\n\r\n    std::vector<TestResult> test_results;\r\n\r\n\r\n\r\n    TEST<uint8_t>(\"test8.tif\", image8.data(), image8i.data(), WIDTH, HEIGHT, 1, 1, test_results);\r\n    TEST<uint8_t>(\"test8m.tif\", image8.data(), image8i.data(), WIDTH, HEIGHT, 1, TEST_FRAMES, test_results);\r\n    TEST<uint16_t>(\"test16.tif\", image16.data(), image16i.data(), WIDTH, HEIGHT, 1, 1, test_results);\r\n    TEST<uint16_t>(\"test16m.tif\", image16.data(), image16i.data(), WIDTH, HEIGHT, 1, TEST_FRAMES, test_results);\r\n    TEST<uint32_t>(\"test32.tif\", image32.data(), image32i.data(), WIDTH, HEIGHT, 1, 1, test_results);\r\n    TEST<uint32_t>(\"test32m.tif\", image32.data(), image32i.data(), WIDTH, HEIGHT, 1, TEST_FRAMES, test_results);\r\n    TEST<uint64_t>(\"test64.tif\", image64.data(), image64i.data(), WIDTH, HEIGHT, 1, 1, test_results);\r\n    TEST<uint64_t>(\"test64m.tif\", image64.data(), image64i.data(), WIDTH, HEIGHT, 1, TEST_FRAMES, test_results);\r\n    TEST<float>(\"testf.tif\", imagef.data(), imagefi.data(), WIDTH, HEIGHT, 1, 1, test_results);\r\n    TEST<float>(\"testfm.tif\", imagef.data(), imagefi.data(), WIDTH, HEIGHT, 1, TEST_FRAMES, test_results);\r\n    TEST<double>(\"testd.tif\", imaged.data(), imagedi.data(), WIDTH, HEIGHT, 1, 1, test_results);\r\n    TEST<double>(\"testdm.tif\", imaged.data(), imagedi.data(), WIDTH, HEIGHT, 1, TEST_FRAMES, test_results);\r\n    TEST<uint8_t>(\"testrgb.tif\", imagergb.data(), imagergbi.data(), WIDTH, HEIGHT, 3, 1, test_results);\r\n    TEST<uint8_t>(\"testrgbm.tif\", imagergb.data(), imagergbi.data(), WIDTH, HEIGHT, 3, TEST_FRAMES, test_results);\r\n\r\n#ifdef TINYTIFF_TEST_LIBTIFF\r\n\r\n    TEST<uint8_t>(\"test8_littleendian.tif\", image8.data(), image8i.data(), WIDTH, HEIGHT, 1, 1, test_results);\r\n    TEST<uint8_t>(\"test8_bigendian.tif\", image8.data(), image8i.data(), WIDTH, HEIGHT, 1, 1, test_results);\r\n    TEST<uint16_t>(\"test16_littleendian.tif\", image16.data(), image16i.data(), WIDTH, HEIGHT, 1, 1, test_results);\r\n    TEST<uint16_t>(\"test16_bigendian.tif\", image16.data(), image16i.data(), WIDTH, HEIGHT, 1, 1, test_results);\r\n    TEST<uint32_t>(\"test32_littleendian.tif\", image32.data(), image32i.data(), WIDTH, HEIGHT, 1, 1, test_results);\r\n    TEST<uint32_t>(\"test32_bigendian.tif\", image32.data(), image32i.data(), WIDTH, HEIGHT, 1, 1, test_results);\r\n    TEST<uint64_t>(\"test64_littleendian.tif\", image64.data(), image64i.data(), WIDTH, HEIGHT, 1, 1, test_results);\r\n    TEST<uint64_t>(\"test64_bigendian.tif\", image64.data(), image64i.data(), WIDTH, HEIGHT, 1, 1, test_results);\r\n\r\n    //TEST_AGAINST_LIBTIFF<uint16_t>(\"2K_source_Stack.tif\",  test_results);\r\n    //TEST_AGAINST_LIBTIFF<uint16_t>(\"2K_tiff_image.tif\",  test_results);\r\n    TEST_AGAINST_LIBTIFF<uint8_t>(\"cell.tif\",  test_results);\r\n    //TEST_AGAINST_LIBTIFF<uint8_t>(\"circuit.tif\",  test_results);\r\n    //TEST_AGAINST_LIBTIFF<uint8_t>(\"galaxy.tif\",  test_results);\r\n    //TEST_AGAINST_LIBTIFF<uint8_t>(\"mri.tif\",  test_results);\r\n    TEST_AGAINST_LIBTIFF<uint8_t>(\"multi-channel-time-series.ome.tif\",  test_results);\r\n    TEST_AGAINST_LIBTIFF<uint16_t>(\"test16m_imagej.tif\",  test_results);\r\n    TEST_AGAINST_LIBTIFF<float>(\"imagej_32bit_ramp.tif\",  test_results);\r\n    //TEST_AGAINST_LIBTIFF<uint8_t>(\"imagej_32bit_ramp_tiled.tif\",  test_results);\r\n    TEST_AGAINST_LIBTIFF<uint8_t>(\"circuit_nocompression.tif\",  test_results);\r\n    //TEST_AGAINST_LIBTIFF<uint8_t>(\"mri_nocompression.tif\",  test_results);\r\n    TEST_AGAINST_LIBTIFF<uint8_t>(\"galaxy_nocompression.tif\",  test_results);\r\n    TEST_AGAINST_LIBTIFF<uint8_t>(\"corel_photopaint_grey.tif\",  test_results);\r\n    TEST_AGAINST_LIBTIFF<uint16_t>(\"corel_photopaint_grey16.tif\",  test_results);\r\n    TEST_AGAINST_LIBTIFF<uint8_t>(\"corel_photopaint_greyalpha.tif\",  test_results);\r\n    TEST_AGAINST_LIBTIFF<uint8_t>(\"corel_photopaint_rgb.tif\",  test_results);\r\n    TEST_AGAINST_LIBTIFF<uint16_t>(\"corel_photopaint_rgb48.tif\",  test_results);\r\n    TEST_AGAINST_LIBTIFF<uint8_t>(\"corel_photopaint_rgba.tif\",  test_results);\r\n    //TEST_AGAINST_LIBTIFF<uint8_t>(\"gh19-id8.tif\",  test_results);\r\n#else\r\n    //TEST_SIMPLE<uint16_t>(\"2K_source_Stack.tif\",  test_results);\r\n    //TEST_SIMPLE<uint16_t>(\"2K_tiff_image.tif\",  test_results);\r\n    TEST_SIMPLE<uint8_t>(\"cell.tif\",  test_results);\r\n    TEST_SIMPLE<uint8_t>(\"circuit.tif\",  test_results);\r\n    TEST_SIMPLE<uint8_t>(\"galaxy.tif\",  test_results);\r\n    TEST_SIMPLE<uint8_t>(\"mri.tif\",  test_results);\r\n    TEST_SIMPLE<uint8_t>(\"multi-channel-time-series.ome.tif\",  test_results);\r\n    TEST_SIMPLE<uint16_t>(\"test16m_imagej.tif\",  test_results);\r\n    TEST_SIMPLE<float>(\"imagej_32bit_ramp.tif\",  test_results);\r\n    TEST_SIMPLE<uint8_t>(\"imagej_32bit_ramp_tiled.tif\",  test_results);\r\n    TEST_SIMPLE<uint8_t>(\"circuit_nocompression.tif\",  test_results);\r\n    TEST_SIMPLE<uint8_t>(\"mri_nocompression.tif\",  test_results);\r\n    TEST_SIMPLE<uint8_t>(\"galaxy_nocompression.tif\",  test_results);\r\n    TEST_SIMPLE<uint8_t>(\"corel_photopaint_grey.tif\",  test_results);\r\n    TEST_SIMPLE<uint16_t>(\"corel_photopaint_grey16.tif\",  test_results);\r\n    TEST_SIMPLE<uint8_t>(\"corel_photopaint_greyalpha.tif\",  test_results);\r\n    TEST_SIMPLE<uint8_t>(\"corel_photopaint_rgb.tif\",  test_results);\r\n    TEST_SIMPLE<uint16_t>(\"corel_photopaint_rgb48.tif\",  test_results);\r\n    TEST_SIMPLE<uint8_t>(\"corel_photopaint_rgba.tif\",  test_results);\r\n    //TEST_SIMPLE<uint8_t>(\"gh19-id8.tif\",  test_results);\r\n#endif\r\n\r\n    std::ostringstream testsum;\r\n    testsum<<\"\\n\\n\\n\\n\";\r\n    testsum<<\"tinytiffreader_test:\"<<std::endl;\r\n    if (quicktest!=TINYTIFF_FALSE) testsum<<\"  - quick test with --simple\"<<std::endl;\r\n#ifdef TINYTIFF_TEST_LIBTIFF\r\n    testsum<<\"  - checking against LibTIFF\"<<std::endl;\r\n#endif\r\n    testsum<<\"  - TinyTIFFReader Version: \"<<TinyTIFFReader_getVersion()<<\"\\n  - TinyTIFFWriter Version: \"<<TinyTIFFWriter_getVersion()<<\"\\n\";\r\n#ifdef TINYTIFF_TEST_LIBTIFF\r\n    testsum<<\"  - libTIFF Version: \"<<TIFFGetVersion()<<\"\\n\";\r\n#endif\r\n    testsum<<\"\\n\"<<writeTestSummary(test_results)<<std::endl;\r\n    std::cout<<testsum.str();\r\n    std::ofstream file(\"tintytiffreader_test_result.txt\", std::ofstream::out | std::ofstream::trunc);\r\n    file<<testsum.str();\r\n    file.close();\r\n    writeJUnit(\"tintytiffreader_test_result.xml\", \"tinytiffreader_test\", test_results);\r\n    return 0;\r\n}\r\n",
                "name": "tinytiffreader_test.cpp",
                "path": "tests/tinytiffreader_test/tinytiffreader_test.cpp",
                "url": "/github.com/jkriege2/TinyTIFF/-/blob/tests/tinytiffreader_test/tinytiffreader_test.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 403,
                    "offsetAndLengths": [
                        [
                            28,
                            18
                        ]
                    ],
                    "preview": "                            TIFFPrintDirectory(ltiff, stdout,TIFFPRINT_STRIPS|TIFFPRINT_COLORMAP);\r"
                }
            ],
            "repository": {
                "name": "github.com/jkriege2/TinyTIFF",
                "url": "/github.com/jkriege2/TinyTIFF"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "c879e6eeedc274706c6138f7823318df68147c1b"
                },
                "content": "#include \"tinytiffwriter.h\"\r\n#include \"tinytiffhighrestimer.h\"\r\n#include \"test_results.h\"\r\n#include \"testimage_tools.h\"\r\n#include <fstream>\r\n#include <string.h>\r\n#include <array>\r\n#ifdef TINYTIFF_TEST_LIBTIFF\r\n#include <tiffio.h>\r\n#include \"libtiff_tools.h\"\r\n#endif\r\n#include \"tinytiff_tools.hxx\"\r\n#include <sstream>\r\n\r\n\r\nusing namespace std;\r\n\r\n#define TESTFAIL(msg, res) { std::stringstream str; str<<msg; std::cout<<str.str()<<\"\\n\"; res.success=false; res.message=str.str();}\r\n\r\n\r\ntemplate <class T>\r\nbool libtiffTestRead(const char* filename, const T* writteneven, const T* writtenodd, uint32_t width, uint32_t height, uint16_t samples=1, uint32_t frames_expected=0, TinyTIFFSampleLayout inputOrg=TinyTIFF_Chunky, std::string* description_out=nullptr)  {\r\n    bool ok=true;\r\n#ifdef TINYTIFF_TEST_LIBTIFF\r\n    TIFF* tif = TIFFOpen(filename, \"r\");\r\n    T* data=(T*)malloc(width*height*sizeof(T));\r\n    if (tif) {\r\n        uint32_t frame=0;\r\n        do {\r\n            uint32_t nx,ny;\r\n            uint16_t ns,bs;\r\n            TIFFGetField(tif,TIFFTAG_IMAGEWIDTH,&nx);\r\n            TIFFGetField(tif,TIFFTAG_IMAGELENGTH,&ny);\r\n            TIFFGetField(tif,TIFFTAG_SAMPLESPERPIXEL,&ns);\r\n            TIFFGetField(tif,TIFFTAG_BITSPERSAMPLE,&bs);\r\n            char* val=NULL;\r\n            TIFFGetField(tif,TIFFTAG_IMAGEDESCRIPTION,&val);\r\n            if (val) {\r\n                std::cout<<\"    ImageDescription(\"<<strlen(val)<<\"):\\n\"<<val<<\"\\n\";\r\n                if (description_out) *description_out=val;\r\n            } else {\r\n                if (description_out) description_out->clear();\r\n            }\r\n            TIFFPrintDirectory(tif, stdout);\r\n            if (nx==width && ny==height && ns==samples && bs==sizeof(T)*8) {\r\n                size_t errcnt=0;\r\n                size_t pixcnt=0;\r\n                for (uint16_t samp=0; samp<samples; samp++) {\r\n                    if (TIFFReadFrame(tif, data, samp)) {\r\n                        ok=true;\r\n                        const T* written=writteneven;\r\n                        if (writtenodd && frame%2==1) written=writtenodd;\r\n                        if (inputOrg==TinyTIFF_Chunky) {\r\n                            for (uint32_t i=0; i<width*height; i++) {\r\n                                if (data[i]!=written[i*samples+samp]) {\r\n                                    ok=false;\r\n                                    errcnt++;\r\n                                    if (errcnt<50) std::cout<<\" -- READ-ERROR: pixel-value differs in frame \"<<frame<<\" for pixel (\"<<i%width<<\",\"<<i/width<<\"): file: \"<<static_cast<typename atleast_int<T>::TPrint>(data[i])<<\" expected: \"<<static_cast<typename atleast_int<T>::TPrint>(written[i*samples+samp])<<\"\\n\";\r\n                                    if (errcnt==50) std::cout<<\" -- READ-ERROR: ...\\n\";\r\n                                } else {\r\n                                    pixcnt++;\r\n                                }\r\n                            }\r\n                        } else {\r\n                            for (uint32_t i=0; i<width*height; i++) {\r\n                                if (data[i]!=written[i+samp*width*height]) {\r\n                                    ok=false;\r\n                                    errcnt++;\r\n                                    if (errcnt<50) std::cout<<\" -- READ-ERROR: pixel-value differs in frame \"<<frame<<\" for pixel (\"<<i%width<<\",\"<<i/width<<\"): file: \"<<static_cast<typename atleast_int<T>::TPrint>(data[i])<<\" expected: \"<<static_cast<typename atleast_int<T>::TPrint>(written[i+samp*width*height])<<\"\\n\";\r\n                                    if (errcnt==50) std::cout<<\" -- READ-ERROR: ...\\n\";\r\n                                } else {\r\n                                    pixcnt++;\r\n                                }\r\n                            }\r\n                        }\r\n                        if (!ok) {\r\n                            std::cout<<\" -- TEST READ WITH LIBTIFF: READ WRONG DATA for \"<<errcnt<<\" pixels in frame \"<<frame<<\"!!!\\n\";\r\n                        }\r\n                    } else {\r\n                        std::cout<<\" -- TEST READ WITH LIBTIFF: COULD NOT READ FRAME \"<<frame<<\"!\\n\";\r\n                        ok=false;\r\n                    }\r\n                }\r\n                if (ok) {\r\n                    std::cout<<\" -- TEST READ WITH LIBTIFF: SUCCESS FOR FRAME \"<<frame<<\"! All \"<<pixcnt<<\" pixels&samples as expected!\\n\";\r\n                }\r\n            } else {\r\n                std::cout<<\" -- TEST READ WITH LIBTIFF: FRAME SIZE OF FRAME \"<<frame<<\" DOES NOT MATCH (width: file:\"<<nx<<\"/expected:\"<<width<<\",   height: file:\"<<ny<<\"/expected:\"<<height<<\",   samples: file:\"<<ns<<\"/expected:\"<<samples<<\",   bitspersample: file:\"<<bs<<\"/expected:\"<<(sizeof(T)*8)<<\")!\\n\";\r\n                ok=false;\r\n            }\r\n            frame++;\r\n        } while (ok && TIFFReadDirectory(tif));\r\n        if (frames_expected>0 && frames_expected!=frame) {\r\n            std::cout<<\" -- ERROR IN TEST READ WITH LIBTIFF: number of frames (\"<<frame<<\")does not match expected number of frames (\"<<frames_expected<<\")\\n\";\r\n            ok=false;\r\n        }\r\n        TIFFClose(tif);\r\n    } else {\r\n        std::cout<<\" -- TEST READ WITH LIBTIFF: COULD NOT OPEN FILE!\\n\";\r\n        ok=false;\r\n    }\r\n    free(data);\r\n#endif\r\n    return ok;\r\n}\r\n\r\nenum class DescriptionMode {\r\n    None,\r\n    Text,\r\n    Metadata\r\n};\r\n\r\ntemplate <class T>\r\nvoid performWriteTest(const std::string& name, const char* filename, const T* imagedata, size_t WIDTH, size_t HEIGHT, size_t SAMPLES, TinyTIFFWriterSampleInterpretation interpret, std::vector<TestResult>& test_results, TinyTIFFSampleLayout inputOrg=TinyTIFF_Chunky, TinyTIFFSampleLayout outputOrg=TinyTIFF_Chunky, DescriptionMode descMode=DescriptionMode::None) {\r\n    const size_t bits=sizeof(T)*8;\r\n    std::string desc=std::to_string(WIDTH)+\"x\"+std::to_string(HEIGHT)+\"pix/\"+std::to_string(bits)+\"bit/\"+std::to_string(SAMPLES)+\"ch/1frame\";\r\n    if (inputOrg==TinyTIFF_Chunky && outputOrg==TinyTIFF_Chunky) desc+=\"/CHUNKY_FROM_CHUNKY\";\r\n    if (inputOrg==TinyTIFF_Chunky && outputOrg==TinyTIFF_Planar) desc+=\"/PLANAR_FROM_CHUNKY\";\r\n    if (inputOrg==TinyTIFF_Planar && outputOrg==TinyTIFF_Chunky) desc+=\"/CHUNKY_FROM_PLANAR\";\r\n    if (inputOrg==TinyTIFF_Planar && outputOrg==TinyTIFF_Planar) desc+=\"/PLANAR_FROM_PLANAR\";\r\n    test_results.emplace_back();\r\n    test_results.back().name=name+\" [\"+desc+\", \"+std::string(filename)+\"]\";\r\n    test_results.back().success=true;\r\n    std::cout<<\"\\n\\n*****************************************************************************\\n\";\r\n    std::cout<<\"* \"<<test_results.back().name<<\"\\n\";\r\n    HighResTimer timer;\r\n    timer.start();\r\n    TinyTIFFWriterFile* tiff = TinyTIFFWriter_open(filename, bits, TinyTIFF_SampleFormatFromType<T>().format, SAMPLES, WIDTH,HEIGHT, interpret);\r\n    if (tiff) {\r\n        int res;\r\n        res=TinyTIFFWriter_writeImageMultiSample(tiff, imagedata, inputOrg, outputOrg);\r\n        if (res!=TINYTIFF_TRUE) {\r\n            test_results.back().success=false;\r\n            TESTFAIL(\"error writing image data into '\"<<filename<<\"'! MESSAGE: \"<<TinyTIFFWriter_getLastError(tiff)<<\"\", test_results.back())\r\n        }\r\n        if (descMode==DescriptionMode::None) TinyTIFFWriter_close(tiff);\r\n        else if (descMode==DescriptionMode::Text) TinyTIFFWriter_close_withdescription(tiff, \"Test Description for TIFF\");\r\n        else if (descMode==DescriptionMode::Metadata) TinyTIFFWriter_close_withmetadatadescription(tiff, 1.234, 2.345, 10, 0.1);\r\n        test_results.back().duration_ms=timer.get_time()/1e3;\r\n        test_results.back().numImages=1;\r\n        std::string description_out;\r\n        if ((get_filesize(filename)<=0)) {\r\n            test_results.back().success=false;\r\n            TESTFAIL(\"file '\"<<filename<<\"' has no contents!\", test_results.back())\r\n        } else {\r\n            if (!libtiffTestRead<T>(filename, imagedata, nullptr, WIDTH, HEIGHT, SAMPLES, 1, inputOrg, &description_out)) {\r\n                test_results.back().success=false;\r\n                TESTFAIL(\"reading '\"<<filename<<\"' with libTIFF failed!\", test_results.back())\r\n            } else {\r\n                if (descMode==DescriptionMode::Text && description_out.find(\"Test Description for TIFF\")==std::string::npos) {\r\n                    test_results.back().success=false;\r\n                    TESTFAIL(\"reading '\"<<filename<<\"' with libTIFF failed to read correct description!\", test_results.back())\r\n                } else  if (descMode==DescriptionMode::Metadata && description_out.find(\"pixel_width\")==std::string::npos) {\r\n                    test_results.back().success=false;\r\n                    TESTFAIL(\"reading '\"<<filename<<\"' with libTIFF failed to read correct metadata description!\", test_results.back())\r\n                }\r\n            }\r\n        }\r\n    } else {\r\n        TESTFAIL(\"could not open '\"<<filename<<\"' for writing!\", test_results.back())\r\n        test_results.back().success=false;\r\n    }\r\n    if (test_results.back().success) {\r\n        std::cout<<\"* ==> SUCCESSFUL,   duration=\"<<test_results.back().duration_ms<<\"ms\\n\";\r\n    } else {\r\n        std::cout<<\"* ==> FAILED\\n\";\r\n    }\r\n}\r\n\r\ntemplate <class T>\r\nvoid performWriteTest_ExpectedToFail(const std::string& name, const char* filename, const T* imagedata, size_t WIDTH, size_t HEIGHT, size_t SAMPLES, TinyTIFFWriterSampleInterpretation interpret, std::vector<TestResult>& test_results, TinyTIFFSampleLayout inputOrg=TinyTIFF_Chunky, TinyTIFFSampleLayout outputOrg=TinyTIFF_Chunky) {\r\n    const size_t bits=sizeof(T)*8;\r\n    std::string desc=std::to_string(WIDTH)+\"x\"+std::to_string(HEIGHT)+\"pix/\"+std::to_string(bits)+\"bit/\"+std::to_string(SAMPLES)+\"ch/1frame\";\r\n    if (inputOrg==TinyTIFF_Chunky && outputOrg==TinyTIFF_Chunky) desc+=\"/CHUNKY_FROM_CHUNKY\";\r\n    if (inputOrg==TinyTIFF_Chunky && outputOrg==TinyTIFF_Planar) desc+=\"/PLANAR_FROM_CHUNKY\";\r\n    if (inputOrg==TinyTIFF_Planar && outputOrg==TinyTIFF_Chunky) desc+=\"/CHUNKY_FROM_PLANAR\";\r\n    if (inputOrg==TinyTIFF_Planar && outputOrg==TinyTIFF_Planar) desc+=\"/PLANAR_FROM_PLANAR\";\r\n    test_results.emplace_back();\r\n    test_results.back().name=name+\" [\"+desc+\", \"+std::string(filename)+\"]\";\r\n    test_results.back().success=true;\r\n    std::cout<<\"\\n\\n*****************************************************************************\\n\";\r\n    std::cout<<\"* \"<<test_results.back().name<<\"\\n\";\r\n    HighResTimer timer;\r\n    timer.start();\r\n    TinyTIFFWriterFile* tiff = TinyTIFFWriter_open(filename, bits, TinyTIFF_SampleFormatFromType<T>().format, SAMPLES, WIDTH,HEIGHT, interpret);\r\n    if (tiff) {\r\n        int res;\r\n        res=TinyTIFFWriter_writeImageMultiSample(tiff, imagedata, inputOrg, outputOrg);\r\n        if (res!=TINYTIFF_FALSE) {\r\n            test_results.back().success=false;\r\n            TESTFAIL(\"could not prevent writing image data into '\"<<filename<<\"'!\", test_results.back())\r\n        } else {\r\n            std::cout<<\"  --> WRITING GENERATED ERROR MESSAGE:\"<<TinyTIFFWriter_getLastError(tiff)<<\"\\n\";\r\n        }\r\n        TinyTIFFWriter_close(tiff);\r\n        test_results.back().duration_ms=timer.get_time()/1e3;\r\n        test_results.back().numImages=1;\r\n        std::string description_out;\r\n    } else {\r\n        TESTFAIL(\"could not open '\"<<filename<<\"' for writing!\", test_results.back())\r\n        test_results.back().success=false;\r\n    }\r\n    if (test_results.back().success) {\r\n        std::cout<<\"* ==> SUCCESSFUL,   duration=\"<<test_results.back().duration_ms<<\"ms\\n\";\r\n    } else {\r\n        std::cout<<\"* ==> FAILED\\n\";\r\n    }\r\n}\r\n\r\n\r\ntemplate <class T>\r\nvoid performMultiFrameWriteTest_ExpectedToFail(const std::string& name, const char* filename, const T* imagedata, const T* imagedatai, size_t WIDTH, size_t HEIGHT, size_t SAMPLES, size_t FRAMES, TinyTIFFWriterSampleInterpretation interpret, std::vector<TestResult>& test_results, TinyTIFFSampleLayout inputOrg=TinyTIFF_Chunky, TinyTIFFSampleLayout outputOrg=TinyTIFF_Chunky) {\r\n    const size_t bits=sizeof(T)*8;\r\n    std::string desc=std::to_string(WIDTH)+\"x\"+std::to_string(HEIGHT)+\"pix/\"+std::to_string(bits)+\"bit/\"+std::to_string(SAMPLES)+\"ch/1frame\";\r\n    if (inputOrg==TinyTIFF_Chunky && outputOrg==TinyTIFF_Chunky) desc+=\"/CHUNKY_FROM_CHUNKY\";\r\n    if (inputOrg==TinyTIFF_Chunky && outputOrg==TinyTIFF_Planar) desc+=\"/PLANAR_FROM_CHUNKY\";\r\n    if (inputOrg==TinyTIFF_Planar && outputOrg==TinyTIFF_Chunky) desc+=\"/CHUNKY_FROM_PLANAR\";\r\n    if (inputOrg==TinyTIFF_Planar && outputOrg==TinyTIFF_Planar) desc+=\"/PLANAR_FROM_PLANAR\";\r\n    test_results.emplace_back();\r\n    test_results.back().name=name+\" [\"+desc+\", \"+std::string(filename)+\"]\";\r\n    test_results.back().success=true;\r\n    std::cout<<\"\\n\\n*****************************************************************************\\n\";\r\n    std::cout<<\"* \"<<test_results.back().name<<\"\\n\";\r\n    HighResTimer timer;\r\n    timer.start();\r\n    TinyTIFFWriterFile* tiff = TinyTIFFWriter_open(filename, bits, TinyTIFF_SampleFormatFromType<T>().format, SAMPLES, WIDTH,HEIGHT, interpret);\r\n    if (tiff) {\r\n        int res;\r\n        size_t f=0;\r\n        for (; f<FRAMES; f++) {\r\n            if (f%2==0) res=TinyTIFFWriter_writeImageMultiSample(tiff, imagedata, inputOrg, outputOrg);\r\n            else res=TinyTIFFWriter_writeImageMultiSample(tiff, imagedatai, inputOrg, outputOrg);\r\n            if (res!=TINYTIFF_TRUE) {\r\n                break;\r\n            }\r\n        }\r\n        if (res!=TINYTIFF_FALSE) {\r\n            test_results.back().success=false;\r\n            TESTFAIL(\"could not prevent writing image data into '\"<<filename<<\"'!\", test_results.back())\r\n        } else {\r\n            std::cout<<\"  --> WRITING GENERATED ERROR MESSAGE for frame \"<<(f+1)<<\"/\"<<FRAMES<<\":\"<<TinyTIFFWriter_getLastError(tiff)<<\"\\n\";\r\n        }\r\n        TinyTIFFWriter_close(tiff);\r\n        test_results.back().duration_ms=timer.get_time()/1e3;\r\n        test_results.back().numImages=1;\r\n        std::string description_out;\r\n    } else {\r\n        TESTFAIL(\"could not open '\"<<filename<<\"' for writing!\", test_results.back())\r\n        test_results.back().success=false;\r\n    }\r\n    if (test_results.back().success) {\r\n        std::cout<<\"* ==> SUCCESSFUL,   duration=\"<<test_results.back().duration_ms<<\"ms\\n\";\r\n    } else {\r\n        std::cout<<\"* ==> FAILED\\n\";\r\n    }\r\n}\r\n\r\ntemplate <class T>\r\nvoid performMultiFrameWriteTest(const std::string& name, const char* filename, const T* imagedata, const T* imagedatai, size_t WIDTH, size_t HEIGHT, size_t SAMPLES, size_t FRAMES, TinyTIFFWriterSampleInterpretation interpret, std::vector<TestResult>& test_results, TinyTIFFSampleLayout inputOrg=TinyTIFF_Chunky, TinyTIFFSampleLayout outputOrg=TinyTIFF_Chunky) {\r\n    const size_t bits=sizeof(T)*8;\r\n    std::string desc=std::to_string(WIDTH)+\"x\"+std::to_string(HEIGHT)+\"pix/\"+std::to_string(bits)+\"bit/\"+std::to_string(SAMPLES)+\"ch/\"+std::to_string(FRAMES)+\"frames\";\r\n    if (inputOrg==TinyTIFF_Chunky && outputOrg==TinyTIFF_Chunky) desc+=\"/CHUNKY_FROM_CHUNKY\";\r\n    if (inputOrg==TinyTIFF_Chunky && outputOrg==TinyTIFF_Planar) desc+=\"/PLANAR_FROM_CHUNKY\";\r\n    if (inputOrg==TinyTIFF_Planar && outputOrg==TinyTIFF_Chunky) desc+=\"/CHUNKY_FROM_PLANAR\";\r\n    if (inputOrg==TinyTIFF_Planar && outputOrg==TinyTIFF_Planar) desc+=\"/PLANAR_FROM_PLANAR\";\r\n    test_results.emplace_back();\r\n    test_results.back().name=name+\" [\"+desc+\", \"+std::string(filename)+\"]\";\r\n    test_results.back().success=true;\r\n    std::cout<<\"\\n\\n*****************************************************************************\\n\";\r\n    std::cout<<\"* \"<<test_results.back().name<<\"\\n\";\r\n    HighResTimer timer;\r\n    timer.start();\r\n    TinyTIFFWriterFile* tiff = TinyTIFFWriter_open(filename, bits, TinyTIFF_SampleFormatFromType<T>().format, SAMPLES, WIDTH,HEIGHT, interpret);\r\n    if (tiff) {\r\n        for (size_t f=0; f<FRAMES; f++) {\r\n            int res;\r\n            if (f%2==0) res=TinyTIFFWriter_writeImageMultiSample(tiff, imagedata, inputOrg, outputOrg);\r\n            else res=TinyTIFFWriter_writeImageMultiSample(tiff, imagedatai, inputOrg, outputOrg);\r\n            if (res!=TINYTIFF_TRUE) {\r\n                test_results.back().success=false;\r\n                TESTFAIL(\"error writing image data into '\"<<filename<<\"'! MESSAGE: \"<<TinyTIFFWriter_getLastError(tiff)<<\"\", test_results.back())\r\n            }\r\n\r\n        }\r\n        TinyTIFFWriter_close(tiff);\r\n        test_results.back().duration_ms=timer.get_time()/1e3;\r\n        test_results.back().numImages=FRAMES;\r\n        if ((get_filesize(filename)<=0)) {\r\n            test_results.back().success=false;\r\n            TESTFAIL(\"file '\"<<filename<<\"' has no contents!\", test_results.back())\r\n        } else if (!libtiffTestRead<T>(filename, imagedata, imagedatai, WIDTH, HEIGHT, SAMPLES, FRAMES, inputOrg)) {\r\n            test_results.back().success=false;\r\n            TESTFAIL(\"reading '\"<<filename<<\"' with libTIFF failes!\", test_results.back())\r\n        }\r\n    } else {\r\n        TESTFAIL(\"could not open '\"<<filename<<\"' for writing!\", test_results.back())\r\n        test_results.back().success=false;\r\n    }\r\n    if (test_results.back().success) {\r\n        std::cout<<\"* ==> SUCCESSFUL,   duration=\"<<test_results.back().duration_ms<<\"ms\\n\";\r\n    } else {\r\n        std::cout<<\"* ==> FAILED\\n\";\r\n    }\r\n}\r\n\r\n\r\n#ifdef TINYTIFF_TEST_LIBTIFF\r\nstatic void errorhandler(const char* module, const char* fmt, va_list ap)\r\n{\r\n    static std::array<char, 1024> errorbuffer;\r\n    vsnprintf(errorbuffer.data(), errorbuffer.size(), fmt, ap);\r\n\r\n    std::cout<<\"###LIBTIFF-ERROR: \"<<module<<\": \"<<errorbuffer.data()<<\"\\n\";\r\n}\r\nstatic void warninghandler(const char* module, const char* fmt, va_list ap)\r\n{\r\n    static std::array<char, 1024> errorbuffer;\r\n    vsnprintf(errorbuffer.data(), errorbuffer.size(), fmt, ap);\r\n\r\n    std::cout<<\"###LIBTIFF-WARNING: \"<<module<<\": \"<<errorbuffer.data()<<\"\\n\";\r\n}\r\n#endif\r\n\r\nint main(int argc, char *argv[]) {\r\n    int quicktest=TINYTIFF_FALSE;\r\n    if (argc>1 && std::string(argv[1])==\"--simple\")  quicktest=TINYTIFF_TRUE;\r\n\r\n    std::cout<<\"tinytiffwriter_test:\"<<std::endl;\r\n    if (quicktest!=TINYTIFF_FALSE) std::cout<<\"  - quick test with --simple\"<<std::endl;\r\n#ifdef TINYTIFF_TEST_LIBTIFF\r\n    std::cout<<\"  - cheching against LibTIFF \"<<TIFFGetVersion()<<std::endl;\r\n    TIFFSetErrorHandler(errorhandler);\r\n    TIFFSetWarningHandler(warninghandler);\r\n#endif\r\n    std::vector<TestResult> test_results;\r\n\r\n    const size_t WIDTH = (quicktest!=TINYTIFF_FALSE)?32:500;\r\n    const size_t HEIGHT = (quicktest!=TINYTIFF_FALSE)?32:432;\r\n    const size_t NUMFRAMES = (quicktest!=TINYTIFF_FALSE)?6:100;\r\n    const size_t PATTERNSIZE = 12;\r\n\r\n\r\n    std::vector<uint8_t> image8(WIDTH*HEIGHT, 0);\r\n    std::vector<uint8_t> image8i(WIDTH*HEIGHT, 0);\r\n    std::vector<uint16_t> image16(WIDTH*HEIGHT, 0);\r\n    std::vector<uint16_t> image16i(WIDTH*HEIGHT, 0);\r\n    std::vector<uint32_t> image32(WIDTH*HEIGHT, 0);\r\n    std::vector<uint32_t> image32i(WIDTH*HEIGHT, 0);\r\n    std::vector<uint64_t> image64(WIDTH*HEIGHT, 0);\r\n    std::vector<uint64_t> image64i(WIDTH*HEIGHT, 0);\r\n    std::vector<float> imagef(WIDTH*HEIGHT, 0);\r\n    std::vector<float> imagefi(WIDTH*HEIGHT, 0);\r\n    std::vector<double> imaged(WIDTH*HEIGHT, 0);\r\n    std::vector<double> imagedi(WIDTH*HEIGHT, 0);\r\n    std::vector<uint8_t> imagergb(WIDTH*HEIGHT*3, 0);\r\n    std::vector<uint8_t> imagergbi(WIDTH*HEIGHT*3, 0);\r\n    std::vector<uint8_t> imagergba(WIDTH*HEIGHT*4, 0);\r\n    std::vector<uint8_t> imagergbai(WIDTH*HEIGHT*4, 0);\r\n    std::vector<uint8_t> greyalpha(WIDTH*HEIGHT*2, 0);\r\n    std::vector<uint8_t> greyalphai(WIDTH*HEIGHT*2, 0);\r\n    std::vector<uint8_t> imagergbplan(WIDTH*HEIGHT*3, 0);\r\n    std::vector<uint8_t> imagergbplani(WIDTH*HEIGHT*3, 0);\r\n\r\n\r\n    write1ChannelTestData(image8.data(), WIDTH, HEIGHT, PATTERNSIZE, 1);\r\n    write1ChannelTestData(image8i.data(), WIDTH, HEIGHT, PATTERNSIZE, 1);\r\n    invertTestImage(image8i.data(), WIDTH, HEIGHT, 1);\r\n    write1ChannelTestData(image16.data(), WIDTH, HEIGHT, PATTERNSIZE, 1);\r\n    write1ChannelTestData(image16i.data(), WIDTH, HEIGHT, PATTERNSIZE, 1);\r\n    invertTestImage(image16i.data(), WIDTH, HEIGHT, 1);\r\n    write1ChannelTestData(image32.data(), WIDTH, HEIGHT, PATTERNSIZE, 1);\r\n    write1ChannelTestData(image32i.data(), WIDTH, HEIGHT, PATTERNSIZE, 1);\r\n    invertTestImage(image32i.data(), WIDTH, HEIGHT, 1);\r\n    write1ChannelTestData(image64.data(), WIDTH, HEIGHT, PATTERNSIZE, 1);\r\n    write1ChannelTestData(image64i.data(), WIDTH, HEIGHT, PATTERNSIZE, 1);\r\n    invertTestImage(image64i.data(), WIDTH, HEIGHT, 1);\r\n    write1ChannelFloatTestData<float>(imagef.data(), WIDTH, HEIGHT, PATTERNSIZE, 1, 1.0);\r\n    write1ChannelFloatTestData<float>(imagefi.data(), WIDTH, HEIGHT, PATTERNSIZE, 1, 1.0);\r\n    invertFloatTestImage<float>(imagefi.data(), WIDTH, HEIGHT, 1, 1.0);\r\n    write1ChannelFloatTestData<double>(imaged.data(), WIDTH, HEIGHT, PATTERNSIZE, 1, 1.0);\r\n    write1ChannelFloatTestData<double>(imagedi.data(), WIDTH, HEIGHT, PATTERNSIZE, 1, 1.0);\r\n    invertFloatTestImage<double>(imagedi.data(), WIDTH, HEIGHT, 1, 1.0);\r\n    writeRGBTestDataChunky(imagergb.data(), WIDTH, HEIGHT, PATTERNSIZE,3);\r\n    writeRGBTestDataChunky(imagergbi.data(), WIDTH, HEIGHT, PATTERNSIZE,3);\r\n    invertTestImage(imagergbi.data(), WIDTH, HEIGHT,3);\r\n    writeRGBTestDataPlanar(imagergbplan.data(), WIDTH, HEIGHT, PATTERNSIZE,3);\r\n    writeRGBTestDataPlanar(imagergbplani.data(), WIDTH, HEIGHT, PATTERNSIZE,3);\r\n    invertTestImage(imagergbplani.data(), WIDTH, HEIGHT,3);\r\n    writeRGBTestDataChunky(imagergba.data(), WIDTH, HEIGHT, PATTERNSIZE,4);\r\n    writeALPHATestData(imagergba.data(), 3, WIDTH, HEIGHT, 4);\r\n    writeRGBTestDataChunky(imagergbai.data(), WIDTH, HEIGHT, PATTERNSIZE,4);\r\n    writeALPHATestData(imagergbai.data(), 3, WIDTH, HEIGHT, 4);\r\n    invertTestImage(imagergbai.data(), WIDTH, HEIGHT,4);\r\n    write1ChannelTestData(greyalpha.data(), WIDTH, HEIGHT, PATTERNSIZE, 2);\r\n    writeALPHATestData(greyalpha.data(), 1, WIDTH, HEIGHT, 2);\r\n    write1ChannelTestData(greyalphai.data(), WIDTH, HEIGHT, PATTERNSIZE, 2);\r\n    writeALPHATestData(greyalphai.data(), 1, WIDTH, HEIGHT, 2);\r\n    invertTestImage(greyalphai.data(), WIDTH, HEIGHT, 2);\r\n\r\n\r\n    performWriteTest(\"WRITING 8-Bit UINT GREY TIFF\", \"test8.tif\", image8.data(), WIDTH, HEIGHT, 1, TinyTIFFWriter_Greyscale, test_results);\r\n    performWriteTest(\"WRITING 8-Bit UINT GREY TIFF with description\", \"test8_msg.tif\", image8.data(), WIDTH, HEIGHT, 1, TinyTIFFWriter_Greyscale, test_results, TinyTIFF_Chunky, TinyTIFF_Chunky, DescriptionMode::Text);\r\n    performWriteTest(\"WRITING 8-Bit UINT GREY TIFF with metadata description\", \"test8_metadata.tif\", image8.data(), WIDTH, HEIGHT, 1, TinyTIFFWriter_Greyscale, test_results, TinyTIFF_Chunky, TinyTIFF_Chunky, DescriptionMode::Metadata);\r\n    performWriteTest(\"WRITING 8-Bit UINT GREY TIFF\", \"test8.tif\", image8.data(), WIDTH, HEIGHT, 1, TinyTIFFWriter_Greyscale, test_results);\r\n    if (quicktest==TINYTIFF_FALSE) performMultiFrameWriteTest(\"WRITING 8-Bit UINT GREY TIFF\", \"test8m.tif\", image8.data(), image8i.data(), WIDTH, HEIGHT, 1, NUMFRAMES, TinyTIFFWriter_Greyscale, test_results);\r\n\r\n    performWriteTest(\"WRITING 16-Bit UINT GREY TIFF\", \"test16.tif\", image16.data(), WIDTH, HEIGHT, 1, TinyTIFFWriter_Greyscale, test_results);\r\n    if (quicktest==TINYTIFF_FALSE) performMultiFrameWriteTest(\"WRITING 16-Bit UINT GREY TIFF\", \"test16m.tif\", image16.data(), image16i.data(), WIDTH, HEIGHT, 1, NUMFRAMES, TinyTIFFWriter_Greyscale, test_results);\r\n\r\n    performWriteTest(\"WRITING 32-Bit UINT GREY TIFF\", \"test32.tif\", image32.data(), WIDTH, HEIGHT, 1, TinyTIFFWriter_Greyscale, test_results);\r\n    if (quicktest==TINYTIFF_FALSE) performMultiFrameWriteTest(\"WRITING 32-Bit UINT GREY TIFF\", \"test32m.tif\", image32.data(), image32i.data(), WIDTH, HEIGHT, 1, NUMFRAMES, TinyTIFFWriter_Greyscale, test_results);\r\n\r\n    performWriteTest(\"WRITING 64-Bit UINT GREY TIFF\", \"test64.tif\", image64.data(), WIDTH, HEIGHT, 1, TinyTIFFWriter_Greyscale, test_results);\r\n    if (quicktest==TINYTIFF_FALSE) performMultiFrameWriteTest(\"WRITING 64-Bit UINT GREY TIFF\", \"test64m.tif\", image64.data(), image64i.data(), WIDTH, HEIGHT, 1, NUMFRAMES, TinyTIFFWriter_Greyscale, test_results);\r\n    if (quicktest==TINYTIFF_FALSE) {\r\n        const size_t WIDTH_too_many=8000;\r\n        const size_t HEIGHT_too_many=4000;\r\n        const std::vector<uint64_t> image64_too_many(WIDTH_too_many*HEIGHT_too_many, 0);\r\n        const size_t too_many_frames=((size_t)0xFFFFFFFF)/((size_t)(WIDTH_too_many*HEIGHT_too_many*sizeof(uint64_t)))*8;\r\n        performMultiFrameWriteTest_ExpectedToFail(\"WRITING TOO MANY 64-Bit UINT GREY TIFF\", \"test64m_toomany.tif\", image64_too_many.data(), image64_too_many.data(), WIDTH_too_many, HEIGHT_too_many, 1, too_many_frames, TinyTIFFWriter_Greyscale, test_results);\r\n    }\r\n\r\n    performWriteTest(\"WRITING 32-Bit FLOAT GREY TIFF\", \"testf.tif\", imagef.data(), WIDTH, HEIGHT, 1, TinyTIFFWriter_Greyscale, test_results);\r\n    if (quicktest==TINYTIFF_FALSE) performMultiFrameWriteTest(\"WRITING 32-Bit FLOAT GREY TIFF\", \"testfm.tif\", imagef.data(), imagefi.data(), WIDTH, HEIGHT, 1, NUMFRAMES, TinyTIFFWriter_Greyscale, test_results);\r\n\r\n    performWriteTest(\"WRITING 64-Bit FLOAT GREY TIFF\", \"testd.tif\", imaged.data(), WIDTH, HEIGHT, 1, TinyTIFFWriter_Greyscale, test_results);\r\n    if (quicktest==TINYTIFF_FALSE) performMultiFrameWriteTest(\"WRITING 64-Bit FLOAT GREY TIFF\", \"testdm.tif\", imaged.data(), imagedi.data(), WIDTH, HEIGHT, 1, NUMFRAMES, TinyTIFFWriter_Greyscale, test_results);\r\n\r\n    performWriteTest(\"WRITING 8-Bit UINT RGB TIFF\", \"testrgb.tif\", imagergb.data(), WIDTH, HEIGHT, 3, TinyTIFFWriter_RGB, test_results);\r\n    if (quicktest==TINYTIFF_FALSE) performMultiFrameWriteTest(\"WRITING 8-Bit UINT RGB TIFF\", \"testrgbm.tif\", imagergb.data(), imagergbi.data(), WIDTH, HEIGHT, 3, NUMFRAMES, TinyTIFFWriter_RGB, test_results);\r\n\r\n    performWriteTest(\"WRITING 8-Bit UINT RGB TIFF\", \"testrgb_chunkplan.tif\", imagergb.data(), WIDTH, HEIGHT, 3, TinyTIFFWriter_RGB, test_results, TinyTIFF_Chunky, TinyTIFF_Planar);\r\n    if (quicktest==TINYTIFF_FALSE) performMultiFrameWriteTest(\"WRITING 8-Bit UINT RGB TIFF\", \"testrgbm_chunkplan.tif\", imagergb.data(), imagergbi.data(), WIDTH, HEIGHT, 3, NUMFRAMES, TinyTIFFWriter_RGB, test_results, TinyTIFF_Chunky, TinyTIFF_Planar);\r\n\r\n    performWriteTest(\"WRITING 8-Bit UINT RGB TIFF\", \"testrgb_planchunk.tif\", imagergbplan.data(), WIDTH, HEIGHT, 3, TinyTIFFWriter_RGB, test_results, TinyTIFF_Planar, TinyTIFF_Chunky);\r\n    if (quicktest==TINYTIFF_FALSE) performMultiFrameWriteTest(\"WRITING 8-Bit UINT RGB TIFF\", \"testrgbm_planchunk.tif\", imagergbplan.data(), imagergbplani.data(), WIDTH, HEIGHT, 3, NUMFRAMES, TinyTIFFWriter_RGB, test_results, TinyTIFF_Planar, TinyTIFF_Chunky);\r\n\r\n    performWriteTest(\"WRITING 8-Bit UINT RGB TIFF\", \"testrgb_planplan.tif\", imagergbplan.data(), WIDTH, HEIGHT, 3, TinyTIFFWriter_RGB, test_results, TinyTIFF_Planar, TinyTIFF_Planar);\r\n    if (quicktest==TINYTIFF_FALSE) performMultiFrameWriteTest(\"WRITING 8-Bit UINT RGB TIFF\", \"testrgbm_planplan.tif\", imagergbplan.data(), imagergbplani.data(), WIDTH, HEIGHT, 3, NUMFRAMES, TinyTIFFWriter_RGB, test_results, TinyTIFF_Planar, TinyTIFF_Planar);\r\n\r\n    performWriteTest(\"WRITING 8-Bit UINT RGBA TIFF\", \"testrgba.tif\", imagergba.data(), WIDTH, HEIGHT, 4, TinyTIFFWriter_RGBA, test_results);\r\n    if (quicktest==TINYTIFF_FALSE) performMultiFrameWriteTest(\"WRITING 8-Bit UINT RGBA TIFF\", \"testrgbam.tif\", imagergba.data(), imagergbai.data(), WIDTH, HEIGHT, 4, NUMFRAMES, TinyTIFFWriter_RGBA, test_results);\r\n\r\n    performWriteTest(\"WRITING 8-Bit UINT GREY+ALPHA  TIFF\", \"test_ga.tif\", greyalpha.data(), WIDTH, HEIGHT, 2, TinyTIFFWriter_GreyscaleAndAlpha, test_results);\r\n    if (quicktest==TINYTIFF_FALSE) performMultiFrameWriteTest(\"WRITING 8-Bit UINT GREY+ALPHA TIFF\", \"test_gam.tif\", greyalpha.data(), greyalphai.data(), WIDTH, HEIGHT, 2, NUMFRAMES, TinyTIFFWriter_GreyscaleAndAlpha, test_results);\r\n\r\n\r\n\r\n    std::ostringstream testsum;\r\n    testsum<<\"\\n\\n\\n\\n\";\r\n    testsum<<\"tinytiffwriter_test:\"<<std::endl;\r\n    if (quicktest!=TINYTIFF_FALSE) testsum<<\"  - quick test with --simple\"<<std::endl;\r\n#ifdef TINYTIFF_TEST_LIBTIFF\r\n    testsum<<\"  - cheching against LibTIFF\"<<std::endl;\r\n#endif\r\n    testsum<<\"  - TinyTIFFReader Version: \"<<TinyTIFFReader_getVersion()<<\"\\n  - TinyTIFFWriter Version: \"<<TinyTIFFWriter_getVersion()<<\"\\n\";\r\n#ifdef TINYTIFF_TEST_LIBTIFF\r\n    testsum<<\"  - libTIFF Version: \"<<TIFFGetVersion()<<\"\\n\";\r\n#endif\r\n    testsum<<\"\\n\"<<writeTestSummary(test_results)<<std::endl;\r\n    std::cout<<testsum.str();\r\n    std::ofstream file(\"tintytiffwriter_test_result.txt\", std::ofstream::out | std::ofstream::trunc);\r\n    file<<testsum.str();\r\n    file.close();\r\n\r\n    writeJUnit(\"tintytiffwriter_test_result.xml\", \"tinytiffwriter_test\", test_results);\r\n\r\n    return 0;\r\n}\r\n",
                "name": "tinytiffwriter_test.cpp",
                "path": "tests/tinytiffwriter_test/tinytiffwriter_test.cpp",
                "url": "/github.com/jkriege2/TinyTIFF/-/blob/tests/tinytiffwriter_test/tinytiffwriter_test.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 43,
                    "offsetAndLengths": [
                        [
                            12,
                            18
                        ]
                    ],
                    "preview": "            TIFFPrintDirectory(tif, stdout);\r"
                }
            ],
            "repository": {
                "name": "github.com/jkriege2/TinyTIFF",
                "url": "/github.com/jkriege2/TinyTIFF"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "78c8b4d634f1379eb3e33642716717f53bf7e1ad"
                },
                "content": "#include <iostream>\t// std::cout\n#include <limits>\t// std::numeric_limits\n#include <sstream>\t// std::ostringstream\n#include <iomanip>\t// std::setw(-)\n#include \"image_tif_read_handle.h\"\n#include \"image_tif_read_handle_info.h\"\n\nnamespace image {\nnamespace tif {\n\nstd::string get_info(\n\t  const std::string& name\n\t, const std::string& file_path\n) {\n\tstd::ostringstream os; \n\tbool isexist = false;\n\n\t os << name << '\\n';\n\n\timage::tif::read_handle handler(file_path);\n\n\t os << \" Byte Order : \";\n\tunion { unsigned short us; unsigned char uc[2]; } order_box;\n\torder_box.us = 1;\n\tconst bool cpu_is_little_endian = (1==order_box.uc[0])?true:false;\n\tconst bool byte_swap_sw = (TIFFIsByteSwapped(handler))?true:false;\n\tif (( (!cpu_is_little_endian) == (!byte_swap_sw) ) ||\n\t    (   cpu_is_little_endian  ==   byte_swap_sw   )) {\n\t     /*\tCPUがbig    endian(false)でbyte swapしてない(false)か、\n\t\tCPUがlittle endian(true )でbyte swapした(true) */\n\t os << \"Big Endian\";\n\t} else {\n\t os << \"Little Endian\";\n\t}\n\t os << \"\\n\";\n\n\t os << \" Compression : \";\n\tconst unsigned int u_compre = handler.compression(isexist);\n\tswitch (u_compre) {\n\tcase COMPRESSION_NONE:\t\tos << \"NONE\"; break;\n\tcase COMPRESSION_CCITTRLE:\tos << \"CCITTRLE\"; break;\n\tcase COMPRESSION_CCITTFAX3:\tos << \"CCITTFAX3\"; break;\n\tcase COMPRESSION_CCITTFAX4:\tos << \"CCITTFAX4\"; break;\n\tcase COMPRESSION_LZW:\t\tos << \"LZW\"; break;\n\tcase COMPRESSION_OJPEG:\t\tos << \"OJPEG\"; break;\n\tcase COMPRESSION_JPEG:\t\tos << \"JPEG\"; break;\n\tcase COMPRESSION_NEXT:\t\tos << \"NEXT\"; break;\n\tcase COMPRESSION_CCITTRLEW:\tos << \"CCITTRLEW\"; break;\n\tcase COMPRESSION_PACKBITS:\tos << \"PACKBITS\"; break;\n\tcase COMPRESSION_THUNDERSCAN:\tos << \"THUNDERSCAN\"; break;\n\t/* codes 32895-32898 are reserved for ANSI IT8 TIFF/IT <dkelly@etsinc.com) */\n\tcase COMPRESSION_IT8CTPAD:\tos << \"IT8CTPAD\"; break;\n\tcase COMPRESSION_IT8LW:\t\tos << \"IT8LW\"; break;\n\tcase COMPRESSION_IT8MP:\t\tos << \"IT8MP\"; break;\n\tcase COMPRESSION_IT8BL:\t\tos << \"IT8BL\"; break;\n\t/* compression codes 32908-32911 are reserved for Pixar */\n\tcase COMPRESSION_PIXARFILM:\tos << \"PIXARFILM\"; break;\n\tcase COMPRESSION_PIXARLOG:\tos << \"PIXARLOG\"; break;\n\tcase COMPRESSION_DEFLATE:\tos << \"DEFLATE\"; break;\n\tcase COMPRESSION_ADOBE_DEFLATE:\tos << \"ADOBE DEFLATE\"; break;\n\t/* compression code 32947 is reserved for Oceana Matrix <dev@oceana.com> */\n\tcase COMPRESSION_DCS:\t\tos << \"DCS\"; break;\n\tcase COMPRESSION_JBIG:\t\tos << \"JBIG\"; break;\n\tcase COMPRESSION_SGILOG:\tos << \"SGILOG\"; break;\n\tcase COMPRESSION_SGILOG24:\tos << \"SGILOG24\"; break;\n\tdefault:\n\t\t{\n\t\t\tos\t<< \"Bad_Compression_Type\"\n\t\t\t\t<< '(' << u_compre << ')';\n\t\t}\n\t\tbreak;\n\t}\n\t os << \"\\n\";\n\n\t//------------------------------------------------------------\n\n\t os << \"Image\\n\"\n\t    << \" Size : \"\n\t    << handler.imagewidth(isexist)\n\t    << \" x \"\n\t    << handler.imagelength(isexist)\n\t    << \"  \"\n\t    ;\n\tif      (1 == handler.samplesperpixel(isexist)) {\n\t if (1 == handler.bitspersample(isexist)) { os << \"MonoBW\"; }\n\t else\t\t\t\t   { os << \"Grayscale\"; }\n\t}\n\telse if (3 == handler.samplesperpixel(isexist)) { os << \"RGB\"; }\n\telse if (4 == handler.samplesperpixel(isexist)) { os << \"RGBA\"; }\n\telse {\n\t os << \"Bad_Samples_Per_Pixel\"\n\t    << '(' << handler.samplesperpixel(isexist) << ')';\n\t}\n\n\t os\n\t    << ' '\n\t    << handler.bitspersample(isexist)\n\t    << \" bit\";\n\tif (1 < handler.bitspersample(isexist)) {\n\t os << 's';\n\t}\n\t os << '\\n';\n\n\t os << \" Resolution : \";\n\n\tconst unsigned int u_re = handler.resolutionunit(isexist);\n\tif (std::numeric_limits<unsigned int>::max() == u_re) {\n\t\tos << \"Not Defined\";\n\t} else {\n\t\tswitch (u_re) {\n\t\tcase RESUNIT_INCH:\n\t\tcase RESUNIT_CENTIMETER:\n\t\t\tos << handler.xresolution(isexist);\n\t\t if (handler.xresolution(isexist) != handler.yresolution(isexist)) {\n\t\t\tos << \" x \" << handler.yresolution(isexist);\n\t\t }\n\t\t\tos << ' ';\n\t\t}\n\t\tswitch (u_re) {\n\t\tcase RESUNIT_NONE:       os << \"Nothing\"; break;\n\t\tcase RESUNIT_INCH:       os << \"Dot/Inch\"; break;\n\t\tcase RESUNIT_CENTIMETER: os << \"Dot/Centimeter\"; break;\n\t\tdefault: os\t<< \"Bad_Unit_Type\"\n\t\t\t\t<< '(' << (int)u_re << ')';\n\t\t\tbreak;\n\t\t}\n\t}\n\t os << '\\n';\n\n\t os << \" Orientation(Row Column) : \";\n\tconst unsigned int u_or = handler.orientation(isexist);\n\tif (std::numeric_limits<unsigned int>::max() == u_or) {\n\t\t\t\t    os << \"Not Defined\";\n\t} else {\n\t switch (u_or) {\n\t case 0:\n\t case ORIENTATION_TOPLEFT:  os << \"Top Left\"; break;\n\t case ORIENTATION_TOPRIGHT: os << \"Top Right\"; break;\n\t case ORIENTATION_BOTRIGHT: os << \"Bottom Right\"; break;\n\t case ORIENTATION_BOTLEFT:  os << \"Bottom Left\"; break;\n\t case ORIENTATION_LEFTTOP:  os << \"Left Top\"; break;\n\t case ORIENTATION_RIGHTTOP: os << \"Right Top\"; break;\n\t case ORIENTATION_RIGHTBOT: os << \"Right Bottom\"; break;\n\t case ORIENTATION_LEFTBOT:  os << \"Left Bottom\"; break;\n\t default: os\t<< \"Bad_Orientation_Type\"\n\t\t\t<< '(' << (int)u_or << ')';\n\t }\n\t}\n\t os << '\\n';\n\n\treturn os.str();\n}\n//--------------------------------------------------------------------\nstd::string get_line_head(void) {\n\tstd::string line_head;\n\tline_head += \"bo  compr width heigh c bi or pho pla bit\";\n\tline_head += \" reso x y (tile) file\\n\";\n\treturn line_head;\n}\nstd::string get_line_info(\n\tconst std::string& file_path\n) {\n\t/* TIFFファイル開く ------------------------------- */\n\timage::tif::read_handle handler(file_path.c_str());\n\tbool isexist = false;\n\n\tstd::ostringstream os;\n\n\t/* TIFFファイルのバイトオーダ --------------------- */\n\tunion { unsigned short us; unsigned char uc[2]; } order_box;\n\torder_box.us = 1;\n\tconst bool cpu_is_little_endian = (1==order_box.uc[0])?true:false;\n\tconst bool byte_swap_sw = (TIFFIsByteSwapped(handler))?true:false;\n\tif (( (!cpu_is_little_endian) == (!byte_swap_sw) ) ||\n\t    (   cpu_is_little_endian  ==   byte_swap_sw  )) {\n\t     /*\tCPUがbig    endian(false)でbyte swapしてない(false)か、\n\t\tCPUがlittle endian(true )でbyte swapした(true) */\n\t\tos << \"big\";\n\t} else {\n\t\tos << \"lit\";\n\t}\n\n\t/* このライブラリで扱えるか否か ------------------- */\n\tbool b_canuse_sw = true;\n try {\n\thandler.check_parameters();\n }\n // catch (std::exception& e) {\n\t// std::cout << e.what() << '\\n';\n catch (std::exception) {\n\tb_canuse_sw = false;\n }\n\tif (b_canuse_sw) { os << \" \"; }\n\telse             { os << \"x\"; }\n\n\t/* 圧縮タイプ ------------------------------------- */\n#if 0 //------help------\n標仕仕様\n#define\tCOMPRESSION_NONE\t1\t/* dump mode */\n#define\tCOMPRESSION_CCITTRLE\t2\t/* CCITT modified Huffman RLE */\n#define\tCOMPRESSION_PACKBITS\t32773\t/* Macintosh RLE */\n\n拡張仕様\n#define\tCOMPRESSION_CCITTFAX3\t3\t/* CCITT Group 3 fax encoding */\n#define\tCOMPRESSION_CCITT_T4\t3       /* CCITT T.4 (TIFF 6 name) */\n#define\tCOMPRESSION_CCITTFAX4\t4\t/* CCITT Group 4 fax encoding */\n#define\tCOMPRESSION_CCITT_T6\t4       /* CCITT T.6 (TIFF 6 name) */\n#define\tCOMPRESSION_LZW\t\t5       /* Lempel-Ziv  & Welch */\n#define\tCOMPRESSION_JPEG\t7\t/* %JPEG DCT compression */\n#endif //------help------\n\tconst unsigned int u_compre = handler.compression(isexist);\n\tchar *cp_compre = 0;\n\tswitch (u_compre) {\n\tcase COMPRESSION_NONE:\t\tcp_compre = \"dump \"; break;\n\tcase COMPRESSION_CCITTRLE:\tcp_compre = \"crle \"; break;\n\tcase COMPRESSION_CCITTFAX3:\tcp_compre = \"cfax3\"; break;\n\tcase COMPRESSION_CCITTFAX4:\tcp_compre = \"cfax4\"; break;\n\tcase COMPRESSION_LZW:\t\tcp_compre = \"lzw  \"; break;\n\tcase COMPRESSION_OJPEG:\t\tcp_compre = \"ojpeg\"; break;\n\tcase COMPRESSION_JPEG:\t\tcp_compre = \"jpeg \"; break;\n\tcase COMPRESSION_NEXT:\t\tcp_compre = \"next \"; break;\n\tcase COMPRESSION_CCITTRLEW:\tcp_compre = \"crlew\"; break;\n\tcase COMPRESSION_PACKBITS:\tcp_compre = \"packb\"; break;\n\tcase COMPRESSION_THUNDERSCAN:\tcp_compre = \"thund\"; break;\n\t/* codes 32895-32898 are reserved for ANSI IT8 TIFF/IT <dkelly@etsinc.com) */\n\tcase COMPRESSION_IT8CTPAD:\tcp_compre = \"it8ct\"; break;\n\tcase COMPRESSION_IT8LW:\t\tcp_compre = \"it8lw\"; break;\n\tcase COMPRESSION_IT8MP:\t\tcp_compre = \"it8mp\"; break;\n\tcase COMPRESSION_IT8BL:\t\tcp_compre = \"it8bl\"; break;\n\t/* compression codes 32908-32911 are reserved for Pixar */\n\tcase COMPRESSION_PIXARFILM:\tcp_compre = \"pixfi\"; break;\n\tcase COMPRESSION_PIXARLOG:\tcp_compre = \"pixlo\"; break;\n\tcase COMPRESSION_DEFLATE:\tcp_compre = \"defla\"; break;\n\tcase COMPRESSION_ADOBE_DEFLATE:\tcp_compre = \"adefl\"; break;\n\t/* compression code 32947 is reserved for Oceana Matrix <dev@oceana.com> */\n\tcase COMPRESSION_DCS:\t\tcp_compre = \"dcs  \"; break;\n\tcase COMPRESSION_JBIG:\t\tcp_compre = \"jbig \"; break;\n\tcase COMPRESSION_SGILOG:\tcp_compre = \"sgilo\"; break;\n\tcase COMPRESSION_SGILOG24:\tcp_compre = \"sgi24\"; break;\n\t}\n\tif (0 == cp_compre) {\n\t\tos << std::setw(5) <<  u_compre; }\n\telse {\t\t\tos << cp_compre; }\n\n\t/* 画像幅 ----------------------------------------- */\n\tos << ' ' << std::setw(5) << handler.imagewidth(isexist);\n\t/* 画像高さ --------------------------------------- */\n\tos << ' ' << std::setw(5) << handler.imagelength(isexist);\n\t/* チャンネル数 ----------------------------------- */\n\tos << ' ' << std::setw(1) << handler.samplesperpixel(isexist);\n\t/* サンプリングビット数 --------------------------- */\n\tos << ' ' << std::setw(2) << handler.bitspersample(isexist);\n\t/* 画像向き --------------------------------------- */\n\tconst unsigned int u_orient = handler.orientation(isexist);\n\tchar *cp_orient = 0;\n/*\n2008-04-17\nVC8(vc2005)およびVC6で\nstd::numeric_limits<unsigned int>::max()\nは\n#include <windows.h>\nがあることで\n#define max(a,b) ...\nによってつぶされてしまうので\n-DNOMINMAX\nを指定してコンパイルするか\n#define NOMINMAX\nをソースコードに定義するか\n(std::numeric_limits<unsigned int>::max)()\nとする\nhttp://support.microsoft.com/kb/143208/ja\n*/\n\tif (std::numeric_limits<unsigned int>::max() == u_orient) {\n\t\t\t\t\tcp_orient = \"nd\"; }\n\tswitch (u_orient) {\n\tcase ORIENTATION_TOPLEFT:\tcp_orient = \"TL\"; break;\n\tcase ORIENTATION_TOPRIGHT:\tcp_orient = \"TR\"; break;\n\tcase ORIENTATION_LEFTTOP:\tcp_orient = \"LT\"; break;\n\tcase ORIENTATION_RIGHTTOP:\tcp_orient = \"RT\"; break;\n\tcase ORIENTATION_BOTRIGHT:\tcp_orient = \"BR\"; break;\n\tcase ORIENTATION_BOTLEFT:\tcp_orient = \"BL\"; break;\n\tcase ORIENTATION_RIGHTBOT:\tcp_orient = \"RB\"; break;\n\tcase ORIENTATION_LEFTBOT:\tcp_orient = \"LB\"; break;\n\t}\n\t /* zero is made in photoshop does it? */\n\tif (0 == cp_orient) {\n\t\tos << ' ' << std::setw(2) <<  u_orient; }\n\telse {\t\t\tos << ' ' << cp_orient; }\n\n\t/* 画像種類 --------------------------------------- */\n\tconst unsigned int u_photom = handler.photometric(isexist);\n\tchar *cp_photom = 0;\n\tswitch (u_photom) {\n\tcase PHOTOMETRIC_MINISWHITE:\tcp_photom = \"mw \"; break;\n\tcase PHOTOMETRIC_MINISBLACK:\tcp_photom = \"mb \"; break;\n\tcase PHOTOMETRIC_RGB:\t\tcp_photom = \"rgb\"; break;\n\tcase PHOTOMETRIC_MASK:\t\tcp_photom = \"mas\"; break;\n\tcase PHOTOMETRIC_SEPARATED:\tcp_photom = \"sep\"; break;\n\tcase PHOTOMETRIC_YCBCR:\t\tcp_photom = \"ycb\"; break;\n\tcase PHOTOMETRIC_CIELAB:\tcp_photom = \"cie\"; break;\n\tcase PHOTOMETRIC_ITULAB:\tcp_photom = \"itu\"; break;\n\tcase PHOTOMETRIC_LOGL:\t\tcp_photom = \"log\"; break;\n\tcase PHOTOMETRIC_LOGLUV:\tcp_photom = \"lov\"; break;\n\t}\n\tif (0 == cp_photom) {\n\t\tos << ' ' << std::setw(3) <<  u_photom; }\n\telse {\t\t\tos << ' ' << cp_photom; }\n\n\t/* 画像格納順序 ----------------------------------- */\n\tconst unsigned int u_planar = handler.planarconfig(isexist);\n\tchar *cp_planar=0;\n\tswitch (u_planar) {\n\tcase PLANARCONFIG_CONTIG:\tcp_planar = \"con\"; break;\n\tcase PLANARCONFIG_SEPARATE:\tcp_planar = \"sep\"; break;\n\t}\n\tif (0 == cp_planar) {\n\t\tos << ' ' << std::setw(1) <<  u_planar; }\n\telse {\t\t\tos << ' ' << cp_planar; }\n\n\t/* データビットの向き ----------------------------- */\n\tconst unsigned int u_fillor = handler.fillorder(isexist);\n\tchar *cp_fillor = 0;\n\tif (std::numeric_limits<unsigned int>::max() == u_fillor) {\n\t\t\t\tcp_fillor = \"nd \"; }\n\tswitch (u_fillor) {\n\tcase FILLORDER_MSB2LSB: cp_fillor = \"M2L\"; break;\n\tcase FILLORDER_LSB2MSB: cp_fillor = \"L2M\"; break;\n\t}\n\tif (0 == cp_fillor) {\n\t\tos << ' ' << std::setw(3) <<  u_fillor; }\n\telse {\t\t\tos << ' ' << cp_fillor; }\n\n\t/* 画像解像度 ------------------------------------- */\n\tconst unsigned int u_resolu = handler.resolutionunit(isexist);\n\tchar *cp_resolu = 0;\n\tif (std::numeric_limits<unsigned int>::max() == u_resolu) {\n\t\t\t\tcp_resolu = \"nd  \"; }\n\tswitch (u_resolu) {\n\tcase RESUNIT_NONE:\tcp_resolu = \"noth\"; break;\n\tcase RESUNIT_INCH:\tcp_resolu = \"inch\"; break;\n\tcase RESUNIT_CENTIMETER:cp_resolu = \"cent\"; break;\n\t}\n\tif (0 == cp_resolu) {\n\t\tos << ' ' << std::setw(4) <<  u_resolu; }\n\telse {\t\t\tos << ' ' << cp_resolu; }\n\n\tos << ' ' << handler.xresolution(isexist);\n\tos << ' ' << handler.yresolution(isexist);\n\n\t/* タイルformatの場合 ----------------------------- */\n\tif (TIFFIsTiled( handler )) {\n\t\tos\n\t\t\t<< \" (\"\n\t\t\t<< handler.tilewidth(isexist)\n\t\t\t<< ' '\n\t\t\t<< handler.tilelength(isexist)\n\t\t\t<< ')';\n\t}\n\t/* ファイル名(ディレクトリパスを除く) ------------- */\n\tstd::string::size_type  index = file_path.rfind('/');\n\tif (std::string::npos == index) {\n\t\t\t\tindex = file_path.rfind('\\\\');\n\t}\n\tif (std::string::npos == index) {\n\t\tos << ' ' << file_path;\n\t} else {\n\t\tos << ' ' << file_path.substr(index+1);\n\t}\n\t/* 改行コード ------------------------------------- */\n\tos << \"\\n\";\n\n\t/* TIFFファイル閉じる ----------------------------- */\n\t// handler.v_close();\n\n\treturn os.str();\n}\n\n} // namespace tif\n} // namespace image\n\n//--------------------------------------------------------------------\nnamespace {\n struct tif_help_list_ {\n\tchar *short_name;\n\tchar *define_name;\n\tint define_number;\n\tchar *explain;\n };\n std::string get_tif_help_list_info_(\n\tconst char *title\n\t, const char *tag_name\n\t, unsigned int each_size\n\t, tif_help_list_ *help_list\n ) {\n\tstd::ostringstream os; \n\n\tos\t<< std::setw(6) << std::left << title << \"\\n\"\n\t\t<< \"  (\" << tag_name << \")\\n\";\n\tfor(size_t ii = 0; ii <each_size/sizeof(tif_help_list_); ++ii) {\n\t\tos\t<< \"    \"\n\t\t\t<< std::setw(5) << std::left\n\t\t\t<< help_list[ii].short_name\n\t\t\t<< \" (\"\n\t\t\t<< std::setw(25) << std::left\n\t\t\t<< help_list[ii].define_name\n\t\t\t<< std::setw(5) << std::right\n\t\t\t<< help_list[ii].define_number\n\t\t\t<< ')'\n\t\t\t<< help_list[ii].explain\n\t\t\t<< '\\n';\n\t}\n\treturn os.str();\n }\n} // namespace\n\nnamespace image {\nnamespace tif {\n\n/* 圧縮種類のリスト */\nstd::string get_compression_list(void) {\n\ttif_help_list_ tif_compr_list[] = {\n{ \"dump \",\"COMPRESSION_NONE\",\t        1,\"dump mode\" },\n{ \"crle \",\"COMPRESSION_CCITTRLE\",       2,\"CCITT modified Huffman RLE\" },\n{ \"cfax3\",\"COMPRESSION_CCITTFAX3\",      3,\"CCITT Group 3 fax encoding\" },\n{ \"cfax4\",\"COMPRESSION_CCITTFAX4\",      4,\"CCITT Group 4 fax encoding\" },\n{ \"lzw  \",\"COMPRESSION_LZW\",\t        5,\"Lempel-Ziv  & Welch\" },\n{ \"ojpeg\",\"COMPRESSION_OJPEG\",\t        6,\"!6.0 JPEG\" },\n{ \"jpeg \",\"COMPRESSION_JPEG\",\t        7,\"%JPEG DCT compression\" },\n{ \"next \",\"COMPRESSION_NEXT\",\t    32766,\"NeXT 2-bit RLE\" },\n{ \"crlew\",\"COMPRESSION_CCITTRLEW\",  32771,\"#1 w/ word alignment\" },\n{ \"packb\",\"COMPRESSION_PACKBITS\",   32773,\"Macintosh RLE\" },\n{ \"thund\",\"COMPRESSION_THUNDERSCAN\",32809,\"ThunderScan RLE\" },\n{ \"it8ct\",\"COMPRESSION_IT8CTPAD\",   32895,\"reserved for IT8 CT w/padding\" },\n{ \"it8lw\",\"COMPRESSION_IT8LW\",      32896,\"reserved for IT8 Linework RLE\" },\n{ \"it8mp\",\"COMPRESSION_IT8MP\",      32897,\"reserved for IT8 Monochrome picture\" },\n{ \"it8bl\",\"COMPRESSION_IT8BL\",      32898,\"reserved for IT8 Binary line art\" },\n{ \"pixfi\",\"COMPRESSION_PIXARFILM\",  32908,\"reserved for Pixar companded 10bit LZW\" },\n{ \"pixlo\",\"COMPRESSION_PIXARLOG\",   32909,\"reserved for Pixar companded 11bit ZIP\" },\n{ \"defla\",\"COMPRESSION_DEFLATE\",    32946,\"Deflate compression\" },\n{ \"adefl\",\"COMPRESSION_ADOBE_DEFLATE\",  8,\"Deflate compression, as recognized by Adobe\" },\n{ \"dcs  \",\"COMPRESSION_DCS\",        32947,\"reserved for Kodak DCS encoding\" },\n{ \"jbig \",\"COMPRESSION_JBIG\",       34661,\"ISO JBIG\" },\n{ \"sgilo\",\"COMPRESSION_SGILOG\",     34676,\"SGI Log Luminance RLE\" },\n{ \"sgi24\",\"COMPRESSION_SGILOG24\",   34677,\"SGI Log 24-bit packed\" },\n\t};\n \treturn get_tif_help_list_info_(\n\t\t\"compr\"\n\t\t,\"TIFFTAG_COMPRESSION\"\n\t\t, sizeof(tif_compr_list)\n\t\t, tif_compr_list\n\t);\n}\n/* 画像向き種類のリスト */\nstd::string get_orientation_list(void) {\n\ttif_help_list_ tif_orient_list[] = {\n{ \"nd\",\"not defined in file\",\t0,\"\" },\n{ \"TL\",\"ORIENTATION_TOPLEFT\",\t1,\"row 0 top, col 0 lhs\" },\n{ \"TR\",\"ORIENTATION_TOPRIGHT\",\t2,\"row 0 top, col 0 rhs\" },\n{ \"LT\",\"ORIENTATION_BOTRIGHT\",\t3,\"row 0 bottom, col 0 rhs\" },\n{ \"RT\",\"ORIENTATION_BOTLEFT\",\t4,\"row 0 bottom, col 0 lhs\" },\n{ \"BR\",\"ORIENTATION_LEFTTOP\",\t5,\"row 0 lhs, col 0 top\" },\n{ \"BL\",\"ORIENTATION_RIGHTTOP\",\t6,\"row 0 rhs, col 0 top\" },\n{ \"RB\",\"ORIENTATION_RIGHTBOT\",\t7,\"row 0 rhs, col 0 bottom\" },\n{ \"LB\",\"ORIENTATION_LEFTBOT\",\t8,\"row 0 lhs, col 0 bottom\" },\n\t};\n\treturn get_tif_help_list_info_(\n\t\t\"or\"\n\t\t, \"TIFFTAG_ORIENTATION\"\n\t\t, sizeof(tif_orient_list)\n\t\t, tif_orient_list\n\t);\n}\n/* 画像種類リスト */\nstd::string get_photometric_list(void) {\n\ttif_help_list_ tif_photom_list[] = {\n{ \"mw \",\"PHOTOMETRIC_MINISWHITE\",\t0,\"min value is white\" },\n{ \"mb \",\"PHOTOMETRIC_MINISBLACK\",\t1,\"min value is black\" },\n{ \"rgb\",\"PHOTOMETRIC_RGB\",\t\t2,\"RGB color model\" },\n{ \"mas\",\"PHOTOMETRIC_MASK\",\t\t4,\"$holdout mask\" },\n{ \"sep\",\"PHOTOMETRIC_SEPARATED\",\t5,\"!color separations\" },\n{ \"ycb\",\"PHOTOMETRIC_YCBCR\",\t\t6,\"!CCIR 601\" },\n{ \"cie\",\"PHOTOMETRIC_CIELAB\",\t\t8,\"!1976 CIE L*a*b*\" },\n{ \"itu\",\"PHOTOMETRIC_ITULAB\",\t\t10,\"ITU L*a*b*\" },\n{ \"log\",\"PHOTOMETRIC_LOGL\",\t\t32844,\"CIE Log2(L)\" },\n{ \"lov\",\"PHOTOMETRIC_LOGLUV\",\t\t32845,\"CIE Log2(L) (u',v')\" },\n\t};\n\treturn get_tif_help_list_info_(\n\t\t\"pho\"\n\t\t, \"TIFFTAG_PHOTOMETRIC\"\n\t\t, sizeof(tif_photom_list)\n\t\t, tif_photom_list\n\t);\n}\n/* 画像格納順序リスト */\nstd::string get_planarconfig_list(void) {\n\ttif_help_list_ tif_planar_list[] = {\n{ \"con\",\"PLANARCONFIG_CONTIG\",\t\t1,\"single image plan\" },\n{ \"sep\",\"PLANARCONFIG_SEPARATE\",\t2,\"separate planes of data\" },\n\t};\n\treturn get_tif_help_list_info_(\n\t\t\"pla\"\n\t\t, \"TIFFTAG_PLANARCONFIG\"\n\t\t, sizeof(tif_planar_list)\n\t\t, tif_planar_list\n\t);\n}\n/* データビットの向きリスト */\nstd::string get_fillorder_list(void) {\n\ttif_help_list_ tif_fillor_list[] = {\n{ \"nd \",\"not defined in file\",\t\t0,\"\" },\n{ \"M2L\",\"FILLORDER_MSB2LSB\",\t1,\"most significant -> least\" },\n{ \"L2M\",\"FILLORDER_LSB2MSB\",\t2,\"least significant -> most\" },\n\t};\n\treturn get_tif_help_list_info_(\n\t\t\"bit\"\n\t\t, \"TIFFTAG_FILLORDER\"\n\t\t, sizeof(tif_fillor_list)\n\t\t, tif_fillor_list\n\t);\n}\nvoid print_tiff_directory(int argc, char *argv[]) {\n\tfor (int ii = 0; ii < argc; ++ii) {\n\t\timage::tif::read_handle handler(argv[ii]);\n\t\tstd::cout << \"File : \" << argv[ii] << '\\n';\n\t\tTIFFPrintDirectory(handler,stdout\n\t\t\t/***,TIFFPRINT_STRIPS |\n\t\t\tTIFFPRINT_CURVES |\n\t\t\tTIFFPRINT_COLORMAP |\n\t\t\tTIFFPRINT_JPEGQTABLES |\n\t\t\tTIFFPRINT_JPEGACTABLES |\n\t\t\tTIFFPRINT_JPEGDCTABLES***/\n\t\t);\n\t}\n}\n\n} // namespace image\n} // namespace tif\n\n#ifdef DEBUG_IMAGE_TIF_READ_HANDLE_INFO\n#include \"image_tif_common.cpp\"\n#include \"image_tif_read_handle.cpp\"\nnamespace {\n void print_column_(int argc, char *argv[]) {\n\tstd::string info;\n\tinfo += image::tif::get_line_head();\n\tfor (int ii = 0; ii < argc; ++ii) {\n\t\tinfo += image::tif::get_line_info( argv[ii] );\n\t}\n\tstd::cout << info;\n }\n void print_info_(int argc, char *argv[]) {\n\tstd::string info;\n\tfor (int ii = 0; ii < argc; ++ii) {\n\t\tinfo += image::tif::get_info( \"TIFF\" ,argv[ii] );\n\t}\n\tstd::cout << info;\n }\n}\n\nint main(int argc, char** argv) {\n\tif (argc <= 1) {\n\t\tstd::cout\n\t<< \"Usage : \" << argv[0] << \" [-tifinfo/-tifdir] image.tif ...\\n\"\n\t<< \"Usage : \" << argv[0] << \" -tifhelp\\n\"\n\t<< \"[Options]\\n\"\n\t<< \"\\t-tifdir  : tiff detail<.tif>\\n\"\n\t\t;\n\t\treturn 0;\n\t}\n try {\n\tif (!strcmp( \"-tifinfo\", argv[1] ) ) {\n\t\tprint_info_( argc-2, &argv[2] );\n\t}\n\telse if (!strcmp( \"-tifdir\", argv[1] ) ) {\n\t\timage::tif::print_tiff_directory( argc-2, &argv[2] );\n\t}\n\telse if (!strcmp( \"-tifhelp\", argv[1] ) ) {\n\t\tstd::cout << image::tif::get_compression_list();\n\t\tstd::cout << image::tif::get_orientation_list();\n\t\tstd::cout << image::tif::get_photometric_list();\n\t\tstd::cout << image::tif::get_planarconfig_list();\n\t\tstd::cout << image::tif::get_fillorder_list();\n\t}\n\telse {\n\t\tprint_column_( argc-1, &argv[1] );\n\t}\n }\n catch (std::exception& e) {\n\tstd::cout << e.what() << '\\n';\n }\n\treturn 0;\n}\n#endif\n/*\nrem :596,597 w! maketiffinfo.bat\ncl /W4 /WX /MD /EHa /O2 /source-charset:utf-8 /DUNICODE /DDEBUG_IMAGE_TIF_READ_HANDLE_INFO /I. /I../../thirdparty/libtiff/tiff-4.0.9_x32/libtiff image_tif_read_handle_info.cpp ../../thirdparty/libtiff/tiff-4.0.9_x32/libtiff/libtiff.lib /Fetiffinfo\ndel image_tif_read_handle_info.obj\n# :605,605 w! make.sh\ng++ -Wall -std=c++11 image_tif_read_handle_info.cpp image_tif_common.cpp image_tif_read_handle.cpp -DDEBUG_IMAGE_TIF_READ_HANDLE_INFO -I. -ltiff\n*/\n",
                "name": "image_tif_read_handle_info.cpp",
                "path": "sources/lib_image_rw/image_tif_read_handle_info.cpp",
                "url": "/github.com/opentoonz/GTS/-/blob/sources/lib_image_rw/image_tif_read_handle_info.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 524,
                    "offsetAndLengths": [
                        [
                            2,
                            18
                        ]
                    ],
                    "preview": "\t\tTIFFPrintDirectory(handler,stdout"
                }
            ],
            "repository": {
                "name": "github.com/opentoonz/GTS",
                "url": "/github.com/opentoonz/GTS"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "3d7638c3ccdb7e8296cf689ff5f6b391d7eb7988"
                },
                "content": "﻿/*====================================================================*\n -  Copyright (C) 2001 Leptonica.  All rights reserved.\n -  This software is distributed in the hope that it will be\n -  useful, but with NO WARRANTY OF ANY KIND.\n -  No author or distributor accepts responsibility to anyone for the\n -  consequences of using this software, or for whether it serves any\n -  particular purpose or works at all, unless he or she says so in\n -  writing.  Everyone is granted permission to copy, modify and\n -  redistribute this source code, for commercial or non-commercial\n -  purposes, with the following restrictions: (1) the origin of this\n -  source code must not be misrepresented; (2) modified versions must\n -  be plainly marked as such; and (3) this notice may not be removed\n -  or altered from any source or modified source distribution.\n *====================================================================*/\n\n/*\n *  tiffio.c\n *                     \n *     Reading tiff:\n *             PIX       *pixReadTiff()    [ special top level ]\n *             PIX       *pixReadStreamTiff()\n *      static PIX       *pixReadFromTiffStream()\n *\n *     Writing tiff:\n *             l_int32    pixWriteTiff()   [ special top level ]\n *             l_int32    pixWriteTiffCustom()   [ special top level ]\n *             l_int32    pixWriteStreamTiff()\n *      static l_int32    pixWriteToTiffStream()\n *      static l_int32    writeCustomTiffTags()\n *\n *     Reading and writing multipage tiff\n *             PIXA       pixaReadMultipageTiff()\n *             l_int32    writeMultipageTiff()  [ special top level ]\n *             l_int32    writeMultipageTiffSA()\n *\n *     Information about tiff file\n *             l_int32    fprintTiffInfo()\n *             l_int32    tiffGetCount()\n *      static l_int32    tiffGetResolution()\n *             l_int32    readHeaderTiff()\n *             l_int32    freadHeaderTiff()\n *             l_int32    readHeaderMemTiff()\n *      static l_int32    tiffReadHeaderTiff()\n *             l_int32    findTiffCompression()\n *      static l_int32    getTiffCompressedFormat()\n *\n *     Extraction of tiff g4 data:\n *             l_int32    extractTiffG4DataFromFile()\n *\n *     Open tiff stream from file stream\n *      static TIFF      *fopenTiff()\n *\n *     Memory I/O: reading memory --> pix and writing pix --> memory\n *             [10 static helper functions]\n *             l_int32    pixReadMemTiff();\n *             l_int32    pixWriteMemTiff();\n *             l_int32    pixWriteMemTiffCustom();\n *\n *   Note:  You should be using version 3.7.4 of libtiff to be certain\n *          that all the necessary functions are included.\n */\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#ifndef _MSC_VER\n#include <unistd.h>\n#else  /* _MSC_VER */\n#include <io.h>\n#define seek _seek;\n#endif  /* _MSC_VER */\n#include <fcntl.h>\n#include \"allheaders.h\"\n\n#ifdef HAVE_CONFIG_H\n#include \"config_auto.h\"\n#endif  /* HAVE_CONFIG_H */\n\n/* --------------------------------------------*/\n#if  HAVE_LIBTIFF   /* defined in environ.h */\n/* --------------------------------------------*/\n\n#include \"tiff.h\"\n#include \"tiffio.h\"\n\nstatic const l_int32  DEFAULT_RESOLUTION = 300;   /* ppi */\nstatic const l_int32  MAX_PAGES_IN_TIFF_FILE = 3000;  /* should be enough */\n\n\n    /* All functions with TIFF interfaces are static. */\nstatic PIX      *pixReadFromTiffStream(TIFF *tif);\nstatic l_int32   tiffGetResolution(TIFF *tif, l_uint32 *pxres, l_uint32 *pyres);\nstatic l_int32   tiffReadHeaderTiff(TIFF *tif, l_int32 *pwidth,\n                                    l_int32 *pheight, l_int32 *pbps,\n                                    l_int32 *pspp, l_int32 *pres,\n                                    l_int32 *pcmap, l_int32 *pformat);\nstatic l_int32   writeCustomTiffTags(TIFF *tif, NUMA *natags,\n                                     SARRAY *savals, SARRAY  *satypes,\n                                     NUMA *nasizes);\nstatic l_int32   pixWriteToTiffStream(TIFF *tif, PIX *pix, l_int32 comptype,\n                                      NUMA *natags, SARRAY *savals,\n                                      SARRAY *satypes, NUMA *nasizes);\nstatic TIFF     *fopenTiff(FILE *fp, const char *modestr); \n\n    /* Static helper for tiff compression type */\nstatic l_int32   getTiffCompressedFormat(l_uint16 tiffcomp);\n\n    /* Static function for memory I/O */\nstatic TIFF     *fopenTiffMemstream(const char *filename, const char *operation,\n                                    l_uint8 **pdata, size_t *pdatasize);\n\n    /* This structure defines a transform to be performed on a TIFF image\n     * (note that the same transformation can be represented in\n     * several different ways using this structure since\n     * vflip + hflip + counterclockwise == clockwise). */\nstruct tiff_transform {\n    int vflip;    /* if non-zero, image needs a vertical fip */\n    int hflip;    /* if non-zero, image needs a horizontal flip */\n    int rotate;   /* -1 -> counterclockwise 90-degree rotation,\n                      0 -> no rotation\n                      1 -> clockwise 90-degree rotation */\n};\n\n    /* This describes the transformations needed for a given orientation\n     * tag.  The tag values start at 1, so you need to subtract 1 to get a\n     * valid index into this array. */\nstatic struct tiff_transform tiff_orientation_transforms[] = {\n    {0, 0, 0},\n    {0, 1, 0},\n    {1, 1, 0},\n    {1, 0, 0},\n    {0, 1, -1},\n    {0, 0, 1},\n    {0, 1, 1},\n    {0, 0, -1}\n};\n\n\n\n/*--------------------------------------------------------------*\n *                      Reading from file                       *\n *--------------------------------------------------------------*/\n/*!\n *  pixReadTiff()\n *\n *      Input:  filename\n *              page number (0 based)\n *      Return: pix, or null on error\n *\n *  Notes:\n *      (1) This is a version of pixRead(), specialized for tiff\n *          files, that allows specification of the page to be returned\n */\nPIX *\npixReadTiff(const char  *filename,\n            l_int32      n)\n{\nFILE  *fp;\nPIX   *pix;\n\n    PROCNAME(\"pixReadTiff\");\n\n    if (!filename)\n        return (PIX *)ERROR_PTR(\"filename not defined\", procName, NULL);\n\n    if ((fp = fopenReadStream(filename)) == NULL)\n        return (PIX *)ERROR_PTR(\"image file not found\", procName, NULL);\n    if ((pix = pixReadStreamTiff(fp, n)) == NULL) {\n        fclose(fp);\n        return (PIX *)ERROR_PTR(\"pix not read\", procName, NULL);\n    }\n    fclose(fp);\n\n    return pix;\n}\n\n\n/*--------------------------------------------------------------*\n *                     Reading from stream                      *\n *--------------------------------------------------------------*/\n/*!\n *  pixReadStreamTiff()\n *\n *      Input:  stream\n *              n (page number: 0 based)\n *      Return: pix, or null on error (e.g., if the page number is invalid)\n */\nPIX *\npixReadStreamTiff(FILE    *fp,\n                  l_int32  n)\n{\nl_int32  i, pagefound;\nPIX     *pix;\nTIFF    *tif;\n\n    PROCNAME(\"pixReadStreamTiff\");\n\n    if (!fp)\n        return (PIX *)ERROR_PTR(\"stream not defined\", procName, NULL);\n\n    if ((tif = fopenTiff(fp, \"r\")) == NULL)\n        return (PIX *)ERROR_PTR(\"tif not opened\", procName, NULL);\n\n    pagefound = FALSE;\n    pix = NULL;\n    for (i = 0; i < MAX_PAGES_IN_TIFF_FILE; i++) {\n        if (i == n) {\n            pagefound = TRUE;\n            if ((pix = pixReadFromTiffStream(tif)) == NULL) {\n                TIFFCleanup(tif);\n                return (PIX *)ERROR_PTR(\"pix not read\", procName, NULL);\n            }\n            break;\n        }\n        if (TIFFReadDirectory(tif) == 0)\n            break;\n    }\n\n    if (pagefound == FALSE) {\n        L_WARNING_INT(\"tiff page %d not found\", procName, n);\n        TIFFCleanup(tif);\n        return NULL;\n    }\n\n    TIFFCleanup(tif);\n    return pix;\n}\n\n\n/*!\n *  pixReadFromTiffStream()\n *\n *      Input:  stream\n *      Return: pix, or null on error\n *\n * Quoting the libtiff documenation at http://libtiff.maptools.org/libtiff.html\n *\n * libtiff provides a high-level interface for reading image data from\n * a TIFF file. This interface handles the details of data\n * organization and format for a wide variety of TIFF files; at least\n * the large majority of those files that one would normally\n * encounter. Image data is, by default, returned as ABGR pixels\n * packed into 32-bit words (8 bits per sample). Rectangular rasters\n * can be read or data can be intercepted at an intermediate level and\n * packed into memory in a format more suitable to the\n * application. The library handles all the details of the format of\n * data stored on disk and, in most cases, if any colorspace\n * conversions are required: bilevel to RGB, greyscale to RGB, CMYK to\n * RGB, YCbCr to RGB, 16-bit samples to 8-bit samples,\n * associated/unassociated alpha, etc.\n */\nstatic PIX *\npixReadFromTiffStream(TIFF  *tif)\n{\nl_uint8   *linebuf, *data;\nl_uint16   spp, bps, bpp, tiffbpl, photometry, tiffcomp, orientation;\nl_uint16  *redmap, *greenmap, *bluemap;\nl_int32    d, wpl, bpl, comptype, i, j, k, ncolors, rval, gval, bval;\nl_uint32   w, h, xres, yres, tiffword;\nl_uint32  *line, *ppixel, *tiffdata;\nPIX       *pix;\nPIXCMAP   *cmap;\n\n    PROCNAME(\"pixReadFromTiffStream\");\n\n    if (!tif)\n        return (PIX *)ERROR_PTR(\"tif not defined\", procName, NULL);\n\n        /* Use default fields for bps and spp */\n    TIFFGetFieldDefaulted(tif, TIFFTAG_BITSPERSAMPLE, &bps);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLESPERPIXEL, &spp);\n    bpp = bps * spp;\n    if (bpp > 32)\n        return (PIX *)ERROR_PTR(\"can't handle bpp > 32\", procName, NULL);\n    if (spp == 1)\n        d = bps;\n    else if (spp == 3 || spp == 4)\n        d = 32;\n    else\n        return (PIX *)ERROR_PTR(\"spp not in set {1,3,4}\", procName, NULL);\n\n    TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w);\n    TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\n    tiffbpl = TIFFScanlineSize(tif);\n\n    if ((pix = pixCreate(w, h, d)) == NULL)\n        return (PIX *)ERROR_PTR(\"pix not made\", procName, NULL);\n    data = (l_uint8 *)pixGetData(pix);\n    wpl = pixGetWpl(pix);\n    bpl = 4 * wpl;\n\n        /* Read the data */\n    if (spp == 1) {\n        if ((linebuf = (l_uint8 *)CALLOC(tiffbpl + 1, sizeof(l_uint8))) == NULL)\n            return (PIX *)ERROR_PTR(\"calloc fail for linebuf\", procName, NULL);\n        \n        for (i = 0 ; i < h ; i++) {\n            if (TIFFReadScanline(tif, linebuf, i, 0) < 0) {\n                FREE(linebuf);\n                pixDestroy(&pix);\n                return (PIX *)ERROR_PTR(\"line read fail\", procName, NULL);\n            }\n            memcpy((char *)data, (char *)linebuf, tiffbpl);\n            data += bpl;\n        }\n        if (bps <= 8)\n            pixEndianByteSwap(pix);\n        else   /* bps == 16 */\n            pixEndianTwoByteSwap(pix);\n        FREE(linebuf);\n    }\n    else {  /* rgb */\n        if ((tiffdata = (l_uint32 *)CALLOC(w * h, sizeof(l_uint32))) == NULL) {\n            pixDestroy(&pix);\n            return (PIX *)ERROR_PTR(\"calloc fail for tiffdata\", procName, NULL);\n        }\n        if (!TIFFReadRGBAImageOriented(tif, w, h, (uint32 *)tiffdata,\n                                       ORIENTATION_TOPLEFT, 0)) {\n            FREE(tiffdata);\n            pixDestroy(&pix);\n            return (PIX *)ERROR_PTR(\"failed to read tiffdata\", procName, NULL);\n        }\n\n        line = pixGetData(pix);\n        for (i = 0 ; i < h ; i++, line += wpl) {\n            for (j = 0, k = 0, ppixel = line; j < w; j++) {\n                    /* TIFFGet* are macros */\n                tiffword = tiffdata[i * w + j];\n                rval = TIFFGetR(tiffword);\n                gval = TIFFGetG(tiffword);\n                bval = TIFFGetB(tiffword);\n                composeRGBPixel(rval, gval, bval, ppixel);\n                ppixel++;\n            } \n        }\n        FREE(tiffdata);\n    }\n\n    if (tiffGetResolution(tif, &xres, &yres)) {\n        pixSetXRes(pix, xres);\n        pixSetYRes(pix, yres);\n    }\n\n        /* Find and save the compression type */\n    TIFFGetFieldDefaulted(tif, TIFFTAG_COMPRESSION, &tiffcomp);\n    comptype = getTiffCompressedFormat(tiffcomp);\n    pixSetInputFormat(pix, comptype);\n\n    if (TIFFGetField(tif, TIFFTAG_COLORMAP, &redmap, &greenmap, &bluemap)) {\n            /* Save the colormap as a pix cmap.  Because the\n             * tiff colormap components are 16 bit unsigned,\n             * and go from black (0) to white (0xffff), the\n             * the pix cmap takes the most significant byte. */\n        if ((cmap = pixcmapCreate(bps)) == NULL) {\n            pixDestroy(&pix);\n            return (PIX *)ERROR_PTR(\"cmap not made\", procName, NULL);\n        }\n        ncolors = 1 << bps;\n        for (i = 0; i < ncolors; i++)\n            pixcmapAddColor(cmap, redmap[i] >> 8, greenmap[i] >> 8,\n                            bluemap[i] >> 8);\n        pixSetColormap(pix, cmap);\n    }\n    else {   /* No colormap: check photometry and invert if necessary */\n        if (!TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometry)) {\n                /* Guess default photometry setting.  Assume min_is_white\n                 * if compressed 1 bpp; min_is_black otherwise. */\n            if (tiffcomp == COMPRESSION_CCITTFAX3 ||\n                tiffcomp == COMPRESSION_CCITTFAX4 ||\n                tiffcomp == COMPRESSION_CCITTRLE ||\n                tiffcomp == COMPRESSION_CCITTRLEW) {\n                photometry = PHOTOMETRIC_MINISWHITE;\n            }\n            else\n                photometry = PHOTOMETRIC_MINISBLACK;\n        }\n        if ((d == 1 && photometry == PHOTOMETRIC_MINISBLACK) ||\n            (d == 8 && photometry == PHOTOMETRIC_MINISWHITE))\n            pixInvert(pix, pix);\n    }\n\n    if (TIFFGetField(tif, TIFFTAG_ORIENTATION, &orientation)) {\n        if (orientation >= 1 && orientation <= 8) {\n            struct tiff_transform *transform =\n              &tiff_orientation_transforms[orientation - 1];\n            if (transform->vflip) pixFlipTB(pix, pix);\n            if (transform->hflip) pixFlipLR(pix, pix);\n            if (transform->rotate) {\n                PIX *oldpix = pix;\n                pix = pixRotate90(oldpix, transform->rotate);\n                pixDestroy(&oldpix);\n            }\n        }\n    }\n\n    return pix;\n}\n\n\n/*--------------------------------------------------------------*\n *                       Writing to file                        *\n *--------------------------------------------------------------*/\n/*! \n *  pixWriteTiff()\n *\n *      Input:  filename (to write to)\n *              pix\n *              comptype (IFF_TIFF, IFF_TIFF_RLE, IFF_TIFF_PACKBITS,\n *                        IFF_TIFF_G3, IFF_TIFF_G4,\n *                        IFF_TIFF_LZW, IFF_TIFF_ZIP)\n *              modestring (\"a\" or \"w\")\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) For multi-page tiff, write the first pix with mode \"w\" and\n *          all subsequent pix with mode \"a\".\n */\nl_int32\npixWriteTiff(const char  *filename,\n             PIX         *pix,\n             l_int32      comptype,\n             const char  *modestring)\n{\n    return pixWriteTiffCustom(filename, pix, comptype, modestring,\n                              NULL, NULL, NULL, NULL);\n}\n\n\n/*! \n *  pixWriteTiffCustom()\n *\n *      Input:  filename (to write to)\n *              pix\n *              comptype (IFF_TIFF, IFF_TIFF_RLE, IFF_TIFF_PACKBITS,\n *                        IFF_TIFF_G3, IFF_TIFF_G4)\n *                        IFF_TIFF_LZW, IFF_TIFF_ZIP)\n *              modestring (\"a\" or \"w\")\n *              natags (<optional> NUMA of custom tiff tags)\n *              savals (<optional> SARRAY of values)\n *              satypes (<optional> SARRAY of types)\n *              nasizes (<optional> NUMA of sizes)\n *      Return: 0 if OK, 1 on error\n *\n *  Usage:\n *      (1) This writes a page image to a tiff file, with optional\n *          extra tags defined in tiff.h\n *      (2) For multi-page tiff, write the first pix with mode \"w\" and\n *          all subsequent pix with mode \"a\".\n *      (3) For the custom tiff tags:\n *          (a) The three arrays {natags, savals, satypes} must all be\n *              either NULL or defined and of equal size.\n *          (b) If they are defined, the tags are an array of integers,\n *              the vals are an array of values in string format, and\n *              the types are an array of types in string format. \n *          (c) All valid tags are definined in tiff.h.\n *          (d) The types allowed are the set of strings:\n *                \"char*\"\n *                \"l_uint8*\"\n *                \"l_uint16\"\n *                \"l_uint32\"\n *                \"l_int32\"\n *                \"l_float64\"\n *                \"l_uint16-l_uint16\" (note the dash; use it between the\n *                                    two l_uint16 vals in the val string)\n *              Of these, \"char*\" and \"l_uint16\" are the most commonly used.\n *          (e) The last array, nasizes, is also optional.  It is for\n *              tags that take an array of bytes for a value, a number of\n *              elements in the array, and a type that is either \"char*\"\n *              or \"l_uint8*\" (probably either will work). \n *              Use NULL if there are no such tags.\n *          (f) VERY IMPORTANT: if there are any tags that require the\n *              extra size value, stored in nasizes, they must be\n *              written first!\n */\nl_int32\npixWriteTiffCustom(const char  *filename,\n                   PIX         *pix,\n                   l_int32      comptype,\n                   const char  *modestring,\n                   NUMA        *natags,\n                   SARRAY      *savals,\n                   SARRAY      *satypes,\n                   NUMA        *nasizes)\n{\nl_int32  ret;\nTIFF    *tif;\n\n    PROCNAME(\"pixWriteTiffCustom\");\n\n    if (!filename)\n        return ERROR_INT(\"filename not defined\", procName, 1);\n    if (!pix)\n        return ERROR_INT(\"pix not defined\", procName, 1);\n\n    if ((tif = TIFFOpen(filename, modestring)) == NULL)\n        return ERROR_INT(\"tif not opened\", procName, 1);\n    ret = pixWriteToTiffStream(tif, pix, comptype, natags, savals,\n                               satypes, nasizes);\n    TIFFClose(tif);\n\n    return ret;\n}\n\n\n/*--------------------------------------------------------------*\n *                       Writing to stream                      *\n *--------------------------------------------------------------*/\n/*!\n *  pixWriteStreamTiff()\n *\n *      Input:  stream (opened for append or write)\n *              pix\n *              comptype (IFF_TIFF, IFF_TIFF_RLE, IFF_TIFF_PACKBITS,\n *                        IFF_TIFF_G3, IFF_TIFF_G4,\n *                        IFF_TIFF_LZW, IFF_TIFF_ZIP)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) For images with bpp > 1, this resets the comptype, if\n *          necessary, to write uncompressed data.\n *      (2) G3 and G4 are only defined for 1 bpp.\n *      (3) We only allow PACKBITS for bpp = 1, because for bpp > 1\n *          it typically expands images that are not synthetically generated.\n *      (4) G4 compression is typically about twice as good as G3.\n *          G4 is excellent for binary compression of text/line-art,\n *          but terrible for halftones and dithered patterns.  (In\n *          fact, G4 on halftones can give a file that is larger\n *          than uncompressed!)  If a binary image has dithered\n *          regions, it is usually better to compress with png.\n */\nl_int32\npixWriteStreamTiff(FILE    *fp,\n                   PIX     *pix,\n                   l_int32  comptype)\n{\nTIFF  *tif;\n\n    PROCNAME(\"pixWriteStreamTiff\");\n\n    if (!fp)\n        return ERROR_INT(\"stream not defined\", procName, 1 );\n    if (!pix)\n        return ERROR_INT(\"pix not defined\", procName, 1 );\n\n    if (pixGetDepth(pix) != 1 && comptype != IFF_TIFF &&\n        comptype != IFF_TIFF_LZW && comptype != IFF_TIFF_ZIP) {\n        L_WARNING(\"invalid compression type for image with bpp > 1\", procName);\n        comptype = IFF_TIFF_ZIP;\n    }\n\n    if ((tif = fopenTiff(fp, \"w\")) == NULL)\n        return ERROR_INT(\"tif not opened\", procName, 1);\n\n    if (pixWriteToTiffStream(tif, pix, comptype, NULL, NULL, NULL, NULL)) {\n        TIFFCleanup(tif);\n        return ERROR_INT(\"tif write error\", procName, 1);\n    }\n    \n    TIFFCleanup(tif);\n    return 0;\n}\n\n\n/*!\n *  pixWriteToTiffStream()\n *\n *      Input:  tif (data structure, opened to a file)\n *              pix\n *              comptype  (IFF_TIFF: for any image; no compression\n *                         IFF_TIFF_RLE, IFF_TIFF_PACKBITS: for 1 bpp only\n *                         IFF_TIFF_G4 and IFF_TIFF_G3: for 1 bpp only\n *                         IFF_TIFF_LZW, IFF_TIFF_ZIP: for any image\n *              natags (<optional> NUMA of custom tiff tags)\n *              savals (<optional> SARRAY of values)\n *              satypes (<optional> SARRAY of types)\n *              nasizes (<optional> NUMA of sizes)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This static function should only be called through higher\n *          level functions in this file; namely, pixWriteTiffCustom(),\n *          pixWriteTiff(), pixWriteStreamTiff(), pixWriteMemTiff()\n *          and pixWriteMemTiffCustom().\n *      (2) We only allow PACKBITS for bpp = 1, because for bpp > 1\n *          it typically expands images that are not synthetically generated.\n *      (3) See pixWriteTiffCustom() for details on how to use\n *          the last four parameters for customized tiff tags.\n *      (4) The only valid pixel depths in leptonica are 1, 2, 4, 8, 16\n *          and 32.  However, it is possible, and in some cases desirable,\n *          to write out a tiff file using an rgb pix that has 24 bpp.\n *          This can be created by appending the raster data for a 24 bpp\n *          image (with proper scanline padding) directly to a 24 bpp\n *          pix that was created without a data array.  See note in\n *          pixWriteStreamPng() for an example.\n */\nstatic l_int32\npixWriteToTiffStream(TIFF    *tif,\n                     PIX     *pix,\n                     l_int32  comptype,\n                     NUMA    *natags,\n                     SARRAY  *savals,\n                     SARRAY  *satypes,\n                     NUMA    *nasizes)\n{\nl_uint8   *linebuf, *data;\nl_uint16   redmap[256], greenmap[256], bluemap[256];\nl_int32    w, h, d, i, j, k, wpl, bpl, tiffbpl, ncolors, cmapsize;\nl_int32   *rmap, *gmap, *bmap;\nl_uint32   xres, yres;\nl_uint32  *line, *ppixel;\nPIX       *pixt;\nPIXCMAP   *cmap;\nchar      *text;\n\n    PROCNAME(\"pixWriteToTiffStream\");\n\n    if (!tif)\n        return ERROR_INT(\"tif stream not defined\", procName, 1);\n    if (!pix)\n        return ERROR_INT( \"pix not defined\", procName, 1 );\n\n    pixGetDimensions(pix, &w, &h, &d);\n    xres = pixGetXRes(pix);\n    yres = pixGetYRes(pix);\n    if (xres == 0) xres = DEFAULT_RESOLUTION;\n    if (yres == 0) yres = DEFAULT_RESOLUTION;\n\n        /* ------------------ Write out the header -------------  */\n    TIFFSetField(tif, TIFFTAG_RESOLUTIONUNIT, (l_uint32)RESUNIT_INCH);\n    TIFFSetField(tif, TIFFTAG_XRESOLUTION, (l_float64)xres);\n    TIFFSetField(tif, TIFFTAG_YRESOLUTION, (l_float64)yres);\n\n    TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, (l_uint32)w);\n    TIFFSetField(tif, TIFFTAG_IMAGELENGTH, (l_uint32)h);\n    TIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n\n    if ((text = pixGetText(pix)) != NULL)\n        TIFFSetField(tif, TIFFTAG_IMAGEDESCRIPTION, text);\n        \n    if (d == 1)\n        TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISWHITE);\n    else if (d == 32 || d == 24) {\n        TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n        TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE,\n                       (l_uint16)8, (l_uint16)8, (l_uint16)8);\n        TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, (l_uint16)3);\n    }\n    else if ((cmap = pixGetColormap(pix)) == NULL)\n        TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n    else {  /* Save colormap in the tiff; not more than 256 colors */\n        pixcmapToArrays(cmap, &rmap, &gmap, &bmap);\n        ncolors = pixcmapGetCount(cmap);\n        ncolors = L_MIN(256, ncolors);  /* max 256 */\n        cmapsize = 1 << d;\n        cmapsize = L_MIN(256, cmapsize);  /* power of 2; max 256 */\n        if (ncolors > cmapsize) {\n            L_WARNING(\"too many colors in cmap for tiff; truncating\", procName);\n            ncolors = cmapsize;\n        }\n        for (i = 0; i < ncolors; i++) {\n            redmap[i] = (rmap[i] << 8) | rmap[i];\n            greenmap[i] = (gmap[i] << 8) | gmap[i];\n            bluemap[i] = (bmap[i] << 8) | bmap[i];\n        }\n        for (i = ncolors; i < cmapsize; i++)  /* init, even though not used */\n            redmap[i] = greenmap[i] = bluemap[i] = 0;\n        FREE(rmap);\n        FREE(gmap);\n        FREE(bmap);\n\n        TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_PALETTE);\n        TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, (l_uint16)1);\n        TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, (l_uint16)d);\n        TIFFSetField(tif, TIFFTAG_COLORMAP, redmap, greenmap, bluemap);\n    }\n\n    if (d != 24 && d != 32) {\n        TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, (l_uint16)d);\n        TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, (l_uint16)1);\n    }\n\n    TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG); \n    if (comptype == IFF_TIFF)  /* no compression */\n        TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n    else if (comptype == IFF_TIFF_G4)\n        TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_CCITTFAX4);\n    else if (comptype == IFF_TIFF_G3)\n        TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_CCITTFAX3);\n    else if (comptype == IFF_TIFF_RLE)\n        TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_CCITTRLE);\n    else if (comptype == IFF_TIFF_PACKBITS)\n        TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_PACKBITS);\n    else if (comptype == IFF_TIFF_LZW)\n        TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_LZW);\n    else if (comptype == IFF_TIFF_ZIP)\n        TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_ADOBE_DEFLATE);\n    else { \n        L_WARNING(\"unknown tiff compression; using none\", procName);\n        TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n    }\n\n        /* This is a no-op if arrays are NULL */\n    writeCustomTiffTags(tif, natags, savals, satypes, nasizes);\n\n        /* ------------- Write out the image data -------------  */\n    tiffbpl = TIFFScanlineSize(tif);\n    wpl = pixGetWpl(pix);\n    bpl = 4 * wpl;\n    if (tiffbpl > bpl)\n        fprintf(stderr, \"Big trouble: tiffbpl = %d, bpl = %d\\n\", tiffbpl, bpl);\n    if ((linebuf = (l_uint8 *)CALLOC(1, bpl)) == NULL)\n        return ERROR_INT(\"calloc fail for linebuf\", procName, 1);\n\n        /* Use single strip for image */\n    TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, h);\n\n    if (d != 24 && d != 32) {\n        if (d == 16)\n            pixt = pixEndianTwoByteSwapNew(pix);\n        else\n            pixt = pixEndianByteSwapNew(pix);\n        data = (l_uint8 *)pixGetData(pixt);\n        for (i = 0; i < h; i++, data += bpl) {\n            memcpy((char *)linebuf, (char *)data, tiffbpl);\n            if (TIFFWriteScanline(tif, linebuf, i, 0) < 0)\n                break;\n        }\n        pixDestroy(&pixt);\n    }\n    else if (d == 24) {  /* See note 4 above: special case of 24 bpp rgb */\n        for (i = 0; i < h; i++) {\n            line = pixGetData(pix) + i * wpl;\n            if (TIFFWriteScanline(tif, (l_uint8 *)line, i, 0) < 0)\n                break;\n        }\n    }\n    else {  /* standard 32 bpp rgb */\n        for (i = 0; i < h; i++) {\n            line = pixGetData(pix) + i * wpl;\n            for (j = 0, k = 0, ppixel = line; j < w; j++) {\n                linebuf[k++] = GET_DATA_BYTE(ppixel, COLOR_RED);\n                linebuf[k++] = GET_DATA_BYTE(ppixel, COLOR_GREEN);\n                linebuf[k++] = GET_DATA_BYTE(ppixel, COLOR_BLUE);\n                ppixel++;\n            } \n            if (TIFFWriteScanline(tif, linebuf, i, 0) < 0)\n                break;\n        }\n    }\n\n/*    TIFFWriteDirectory(tif); */\n    FREE(linebuf);\n\n    return 0;\n}\n\n\n/*!\n *  writeCustomTiffTags()\n *\n *      Input:  tif\n *              natags (<optional> NUMA of custom tiff tags)\n *              savals (<optional> SARRAY of values)\n *              satypes (<optional> SARRAY of types)\n *              nasizes (<optional> NUMA of sizes)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes: \n *      (1) This static function should be called indirectly through\n *          higher level functions, such as pixWriteTiffCustom(),\n *          which call pixWriteToTiffStream().  See details in\n *          pixWriteTiffCustom() for using the 4 input arrays.\n *      (2) This is a no-op if the first 3 arrays are all NULL.\n *      (3) Otherwise, the first 3 arrays must be defined and all\n *          of equal size.\n *      (4) The fourth array is always optional.\n *      (5) The most commonly used types are \"char*\" and \"u_int16\".\n *          See tiff.h for a full listing of the tiff tags. \n *          Note that many of these tags, in particular the bit tags,\n *          are intended to be private, and cannot be set by this function.\n *          Examples are the STRIPOFFSETS and STRIPBYTECOUNTS tags,\n *          which are bit tags that are automatically set in the header,\n *          and can be extracted using tiffdump.\n */\nstatic l_int32\nwriteCustomTiffTags(TIFF    *tif,\n                    NUMA    *natags,\n                    SARRAY  *savals,\n                    SARRAY  *satypes,\n                    NUMA    *nasizes)\n{\nchar      *sval, *type;\nl_int32    i, n, ns, size, tagval, val;\nl_float64  dval;\nl_uint32   uval, uval2;\n\n    PROCNAME(\"writeCustomTiffTags\");\n\n    if (!tif)\n        return ERROR_INT(\"tif stream not defined\", procName, 1);\n    if (!natags && !savals && !satypes)\n        return 0;\n    if (!natags || !savals || !satypes)\n        return ERROR_INT(\"not all arrays defined\", procName, 1);\n    n = numaGetCount(natags);\n    if ((sarrayGetCount(savals) != n) || (sarrayGetCount(satypes) != n))\n        return ERROR_INT(\"not all sa the same size\", procName, 1);\n\n        /* The sized arrays (4 args to TIFFSetField) are written first */\n    if (nasizes) {\n        ns = numaGetCount(nasizes);\n        if (ns > n)\n            return ERROR_INT(\"too many 4-arg tag calls\", procName, 1);\n        for (i = 0; i < ns; i++) {\n            numaGetIValue(natags, i, &tagval);\n            sval = sarrayGetString(savals, i, 0);\n            type = sarrayGetString(satypes, i, 0);\n            numaGetIValue(nasizes, i, &size);\n            if (strcmp(type, \"char*\") && strcmp(type, \"l_uint8*\"))\n                L_WARNING(\"array type not char* or l_uint8*; ignore\", procName);\n            TIFFSetField(tif, tagval, size, sval);\n        }\n    }\n    else\n        ns = 0;\n\n        /* The typical tags (3 args to TIFFSetField) are now written */\n    for (i = ns; i < n; i++) {\n        numaGetIValue(natags, i, &tagval);\n        sval = sarrayGetString(savals, i, 0);\n        type = sarrayGetString(satypes, i, 0);\n        if (!strcmp(type, \"char*\")) {\n            TIFFSetField(tif, tagval, sval);\n        }\n        else if (!strcmp(type, \"l_uint16\")) {\n            if (sscanf(sval, \"%u\", &uval) == 1) {\n                TIFFSetField(tif, tagval, (l_uint16)uval);\n            }\n            else {\n                fprintf(stderr, \"val %s not of type %s\\n\", sval, type);\n                return ERROR_INT(\"custom tag(s) not written\", procName, 1);\n            }\n        }\n        else if (!strcmp(type, \"l_uint32\")) {\n            if (sscanf(sval, \"%u\", &uval) == 1) {\n                TIFFSetField(tif, tagval, uval);\n            }\n            else {\n                fprintf(stderr, \"val %s not of type %s\\n\", sval, type);\n                return ERROR_INT(\"custom tag(s) not written\", procName, 1);\n            }\n        }\n        else if (!strcmp(type, \"l_int32\")) {\n            if (sscanf(sval, \"%d\", &val) == 1) {\n                TIFFSetField(tif, tagval, val);\n            }\n            else {\n                fprintf(stderr, \"val %s not of type %s\\n\", sval, type);\n                return ERROR_INT(\"custom tag(s) not written\", procName, 1);\n            }\n        }\n        else if (!strcmp(type, \"l_float64\")) {\n            if (sscanf(sval, \"%lf\", &dval) == 1) {\n                TIFFSetField(tif, tagval, dval);\n            }\n            else {\n                fprintf(stderr, \"val %s not of type %s\\n\", sval, type);\n                return ERROR_INT(\"custom tag(s) not written\", procName, 1);\n            }\n        }\n        else if (!strcmp(type, \"l_uint16-l_uint16\")) {\n            if (sscanf(sval, \"%u-%u\", &uval, &uval2) == 2) {\n                TIFFSetField(tif, tagval, (l_uint16)uval, (l_uint16)uval2);\n            }\n            else {\n                fprintf(stderr, \"val %s not of type %s\\n\", sval, type);\n                return ERROR_INT(\"custom tag(s) not written\", procName, 1);\n            }\n        }\n        else\n            return ERROR_INT(\"unknown type; tag(s) not written\", procName, 1);\n    }\n    return 0;\n}\n    \n\n/*--------------------------------------------------------------*\n *               Reading and writing multipage tiff             *\n *--------------------------------------------------------------*/\n/*\n *  pixaReadMultipageTiff()\n *\n *      Input:  filename (input tiff file)\n *      Return: pixa (of page images), or null on error\n */\nPIXA *\npixaReadMultipageTiff(const char  *filename)\n{\nl_int32  i, npages;\nFILE    *fp;\nPIX     *pix;\nPIXA    *pixa;\n\n    PROCNAME(\"pixaReadMultipageTiff\");\n\n    if (!filename)\n        return (PIXA *)ERROR_PTR(\"filename not defined\", procName, NULL);\n\n    if ((fp = fopen(filename, \"rb\")) == NULL)\n        return (PIXA *)ERROR_PTR(\"stream not opened\", procName, NULL);\n    if (fileFormatIsTiff(fp)) {\n        tiffGetCount(fp, &npages);\n        L_INFO_INT(\" Tiff: %d pages\\n\", procName, npages);\n    }\n    else\n        return (PIXA *)ERROR_PTR(\"file not tiff\", procName, NULL);\n    fclose(fp);\n\n    pixa = pixaCreate(npages);\n    for (i = 0; i < npages; i++) {\n        pix = pixReadTiff(filename, i);\n        if (!pix) {\n            L_WARNING_INT(\"pix not read for page %d\", procName, i);\n            continue;\n        }\n        pixaAddPix(pixa, pix, L_INSERT);\n    }\n\n    return pixa;\n}\n\n\n/*\n *  writeMultipageTiff()\n *\n *      Input:  dirin (input directory)\n *              substr (<optional> substring filter on filenames; can be NULL)\n *              fileout (output ps file)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) This writes a set of image files in a directory out\n *          as a multipage tiff file.  The images can be in any\n *          initial file format.\n *      (2) Images with a colormap have the colormap removed before\n *          re-encoding as tiff.\n *      (3) All images are encoded losslessly.  Those with 1 bpp are\n *          encoded 'g4'.  The rest are encoded as 'zip' (flate encoding).\n *          Because it is lossless, this is an expensive method for\n *          saving most rgb images.\n */\nl_int32\nwriteMultipageTiff(const char  *dirin,\n                   const char  *substr,\n                   const char  *fileout)\n{\nSARRAY  *sa;\n\n    PROCNAME(\"writeMultipageTiff\");\n\n    if (!dirin)\n        return ERROR_INT(\"dirin not defined\", procName, 1);\n    if (!fileout)\n        return ERROR_INT(\"fileout not defined\", procName, 1);\n\n        /* Get all filtered and sorted full pathnames. */\n    sa = getSortedPathnamesInDirectory(dirin, substr, 0, 0);\n\n        /* Generate the tiff file */\n    writeMultipageTiffSA(sa, fileout);\n    sarrayDestroy(&sa);\n    return 0;\n}\n\n\n/*\n *  writeMultipageTiffSA()\n *\n *      Input:  sarray (of full path names)\n *              fileout (output ps file)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) See writeMultipageTiff()\n */\nl_int32\nwriteMultipageTiffSA(SARRAY      *sa,\n                     const char  *fileout)\n{\nchar        *fname;\nconst char  *op;\nl_int32      i, nfiles, firstfile, format;\nFILE        *fp;\nPIX         *pix, *pixt;\n\n    PROCNAME(\"writeMultipageTiffSA\");\n\n    if (!sa)\n        return ERROR_INT(\"sa not defined\", procName, 1);\n    if (!fileout)\n        return ERROR_INT(\"fileout not defined\", procName, 1);\n\n    nfiles = sarrayGetCount(sa);\n    firstfile = TRUE;\n    for (i = 0; i < nfiles; i++) {\n        op = (firstfile) ? \"w\" : \"a\";\n        fname = sarrayGetString(sa, i, L_NOCOPY);\n        if ((fp = fopen(fname, \"rb\")) == NULL)\n            continue;\n        findFileFormat(fp, &format);\n        fclose(fp);\n        if (format == IFF_UNKNOWN) {\n            L_INFO_STRING(\"format unknown for file: %s\", procName, fname);\n            continue;\n        }\n\n        if ((pix = pixRead(fname)) == NULL) {\n            L_WARNING_STRING(\"pix not made for file: %s\", procName, fname);\n            continue;\n        }\n        if (pixGetDepth(pix) == 1)\n            pixWriteTiff(fileout, pix, IFF_TIFF_G4, op);\n        else {\n            if (pixGetColormap(pix))\n                pixt = pixRemoveColormap(pix, REMOVE_CMAP_BASED_ON_SRC);\n            else\n                pixt = pixClone(pix);\n            pixWriteTiff(fileout, pixt, IFF_TIFF_ZIP, op);\n            pixDestroy(&pixt);\n        }\n        firstfile = FALSE;\n        pixDestroy(&pix);\n    }\n\n    return 0;\n}\n        \n\n/*--------------------------------------------------------------*\n *                    Print info to stream                      *\n *--------------------------------------------------------------*/\n/*\n *  fprintTiffInfo()\n * \n *      Input:  stream (for output of tag data)\n *              tiffile (input)\n *      Return: 0 if OK; 1 on error\n */\nl_int32\nfprintTiffInfo(FILE        *fpout,\n               const char  *tiffile)\n{\nTIFF  *tif;\n\n    PROCNAME(\"fprintTiffInfo\");\n\n    if (!tiffile)\n        return ERROR_INT(\"tiffile not defined\", procName, 1);\n    if (!fpout)\n        return ERROR_INT(\"stream out not defined\", procName, 1);\n\n    if ((tif = TIFFOpen(tiffile, \"r\")) == NULL)\n        return ERROR_INT(\"tif not open for read\", procName, 1);\n\n    TIFFPrintDirectory(tif, fpout, 0);\n    TIFFClose(tif);\n\n    return 0;\n}\n\n\n/*--------------------------------------------------------------*\n *                   Get count from stream                      *\n *--------------------------------------------------------------*/\n/*\n *  tiffGetCount()\n * \n *      Input:  stream (opened for read)\n *              &n (<return> number of images)\n *      Return: 0 if OK; 1 on error\n */\nl_int32\ntiffGetCount(FILE     *fp,\n             l_int32  *pn)\n{\nl_int32  i;\nTIFF    *tif;\n\n    PROCNAME(\"tiffGetCount\");\n\n    if (!fp)\n        return ERROR_INT(\"stream not defined\", procName, 1);\n    if (!pn)\n        return ERROR_INT(\"&n not defined\", procName, 1);\n    *pn = 0;\n\n    if ((tif = fopenTiff(fp, \"r\")) == NULL)\n        return ERROR_INT(\"tif not open for read\", procName, 1);\n\n    for (i = 1; i < MAX_PAGES_IN_TIFF_FILE; i++) {\n        if (TIFFReadDirectory(tif) == 0)\n            break;\n    }\n    *pn = i;\n    TIFFCleanup(tif);\n    return 0;\n}\n\n\n/*--------------------------------------------------------------*\n *                   Get resolution from tif                    *\n *--------------------------------------------------------------*/\n/*\n *  tiffGetResolution()\n * \n *      Input:  tiff stream (opened for read)\n *              &xres, &yres (<return> resolution in ppi)\n *      Return: 1 if OK; 0 on error   (nonstandard)\n *\n *  Notes:\n *      (1) If neither resolution field is set, this is not an error;\n *          the returned resolution values are 0 (designating 'unknown').\n */\nstatic l_int32\ntiffGetResolution(TIFF      *tif,\n                  l_uint32  *pxres,\n                  l_uint32  *pyres)\n{\nl_uint16   resunit;\nl_int32    foundxres, foundyres;\nl_float32  fxres, fyres;\n\n    PROCNAME(\"tiffGetResolution\");\n\n    if (!tif)\n        return ERROR_INT(\"tif not opened\", procName, 0);\n    if (!pxres || !pyres)\n        return ERROR_INT(\"&xres and &yres not both defined\", procName, 0);\n    *pxres = *pyres = 0;\n\n    TIFFGetFieldDefaulted(tif, TIFFTAG_RESOLUTIONUNIT, &resunit);\n    foundxres = TIFFGetField(tif, TIFFTAG_XRESOLUTION, &fxres);\n    foundyres = TIFFGetField(tif, TIFFTAG_YRESOLUTION, &fyres);\n    if (!foundxres && !foundyres) return 1;\n    if (!foundxres && foundyres)\n        fxres = fyres;\n    else if (foundxres && !foundyres)\n        fyres = fxres;\n\n    if (resunit == RESUNIT_CENTIMETER) {  /* convert to ppi */\n        *pxres = (l_uint32)(2.54 * fxres + 0.5);\n        *pyres = (l_uint32)(2.54 * fyres + 0.5);\n    }\n    else {\n        *pxres = (l_uint32)fxres;\n        *pyres = (l_uint32)fyres;\n    }\n\n    return 1;\n}\n\n\n/*--------------------------------------------------------------*\n *              Get some tiff header information                *\n *--------------------------------------------------------------*/\n/*!\n *  readHeaderTiff()\n *\n *      Input:  filename\n *              n (page image number: 0-based)\n *              &width (<return>)\n *              &height (<return>)\n *              &bps (<return> bits per sample -- 1, 2, 4 or 8)\n *              &spp (<return>; samples per pixel -- 1 or 3)\n *              &res (<optional return>; resolution in x dir; NULL to ignore)\n *              &cmap (<optional return>; colormap exists; input NULL to ignore)\n *              &format (<optional return>; tiff format; input NULL to ignore)\n *      Return: 0 if OK, 1 on error\n * \n *  Notes:\n *      (1) If there is a colormap, cmap is returned as 1; else 0.\n *      (2) If @n is equal to or greater than the number of images, returns 1.\n */\nl_int32\nreadHeaderTiff(const char *filename,\n               l_int32     n,\n               l_int32    *pwidth,\n               l_int32    *pheight,\n               l_int32    *pbps,\n               l_int32    *pspp,\n               l_int32    *pres,\n               l_int32    *pcmap,\n               l_int32    *pformat)\n{\nl_int32  ret;\nFILE    *fp;\n\n    PROCNAME(\"readHeaderTiff\");\n\n    if (!filename)\n        return ERROR_INT(\"filename not defined\", procName, 1);\n    if (!pwidth || !pheight || !pbps || !pspp)\n        return ERROR_INT(\"input ptr(s) not all defined\", procName, 1);\n    *pwidth = *pheight = *pbps = *pspp = 0;\n    if (pres) *pres = 0;\n    if (pcmap) *pcmap = 0;\n\n    if ((fp = fopenReadStream(filename)) == NULL)\n        return ERROR_INT(\"image file not found\", procName, 1);\n    ret = freadHeaderTiff(fp, n, pwidth, pheight, pbps, pspp,\n                          pres, pcmap, pformat);\n    fclose(fp);\n    return ret;\n}\n\n\n/*!\n *  freadHeaderTiff()\n *\n *      Input:  stream\n *              n (page image number: 0-based)\n *              &width (<return>)\n *              &height (<return>)\n *              &bps (<return> bits per sample -- 1, 2, 4 or 8)\n *              &spp (<return>; samples per pixel -- 1 or 3)\n *              &res (<optional return>; resolution in x dir; NULL to ignore)\n *              &cmap (<optional return>; colormap exists; input NULL to ignore)\n *              &format (<optional return>; tiff format; input NULL to ignore)\n *      Return: 0 if OK, 1 on error\n * \n *  Notes:\n *      (1) If there is a colormap, cmap is returned as 1; else 0.\n *      (2) If @n is equal to or greater than the number of images, returns 1.\n */\nl_int32\nfreadHeaderTiff(FILE     *fp,\n                l_int32   n,\n                l_int32  *pwidth,\n                l_int32  *pheight,\n                l_int32  *pbps,\n                l_int32  *pspp,\n                l_int32  *pres,\n                l_int32  *pcmap,\n                l_int32  *pformat)\n{\nl_int32  i, ret, format;\nTIFF    *tif;\n\n    PROCNAME(\"freadHeaderTiff\");\n\n    if (!fp)\n        return ERROR_INT(\"stream not defined\", procName, 1);\n    if (n < 0)\n        return ERROR_INT(\"image index must be >= 0\", procName, 1);\n    if (!pwidth || !pheight || !pbps || !pspp)\n        return ERROR_INT(\"input ptr(s) not all defined\", procName, 1);\n    *pwidth = *pheight = *pbps = *pspp = 0;\n    if (pres) *pres = 0;\n    if (pcmap) *pcmap = 0;\n    if (pformat) *pformat = 0;\n\n    findFileFormat(fp, &format);\n    if (format != IFF_TIFF &&\n        format != IFF_TIFF_G3 && format != IFF_TIFF_G4 &&\n        format != IFF_TIFF_RLE && format != IFF_TIFF_PACKBITS &&\n        format != IFF_TIFF_LZW && format != IFF_TIFF_ZIP)\n        return ERROR_INT(\"file not tiff format\", procName, 1);\n\n    if ((tif = fopenTiff(fp, \"r\")) == NULL)\n        return ERROR_INT(\"tif not open for read\", procName, 1);\n\n    for (i = 0; i < n; i++) {\n        if (TIFFReadDirectory(tif) == 0)\n            return ERROR_INT(\"image n not found in file\", procName, 1);\n    }\n\n    ret = tiffReadHeaderTiff(tif, pwidth, pheight, pbps, pspp,\n                             pres, pcmap, pformat);\n    TIFFCleanup(tif);\n    return ret;\n}\n\n\n/*!\n *  readHeaderMemTiff()\n *\n *      Input:  cdata (const; tiff-encoded)\n *              size (size of data)\n *              n (page image number: 0-based)\n *              &width (<return>)\n *              &height (<return>)\n *              &bps (<return> bits per sample -- 1, 2, 4 or 8)\n *              &spp (<return>; samples per pixel -- 1 or 3)\n *              &res (<optional return>; resolution in x dir; NULL to ignore)\n *              &cmap (<optional return>; colormap exists; input NULL to ignore)\n *              &format (<optional return>; tiff format; input NULL to ignore)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) Use TIFFClose(); TIFFCleanup() doesn't free internal memstream.\n */\nl_int32\nreadHeaderMemTiff(const l_uint8  *cdata,\n                  size_t          size,\n                  l_int32         n,\n                  l_int32        *pwidth,\n                  l_int32        *pheight,\n                  l_int32        *pbps,\n                  l_int32        *pspp,\n                  l_int32        *pres,\n                  l_int32        *pcmap,\n                  l_int32        *pformat)\n{\nl_uint8  *data;\nl_int32   i, ret;\nTIFF     *tif;\n\n    PROCNAME(\"readHeaderMemTiff\");\n\n    if (!cdata)\n        return ERROR_INT(\"cdata not defined\", procName, 1);\n    if (!pwidth || !pheight || !pbps || !pspp)\n        return ERROR_INT(\"input ptr(s) not all defined\", procName, 1);\n    *pwidth = *pheight = *pbps = *pspp = 0;\n    if (pres) *pres = 0;\n    if (pcmap) *pcmap = 0;\n    if (pformat) *pformat = 0;\n    \n        /* Open a tiff stream to memory */\n    data = (l_uint8 *)cdata;  /* we're really not going to change this */\n    if ((tif = fopenTiffMemstream(\"tifferror\", \"r\", &data, &size)) == NULL)\n        return ERROR_INT(\"tiff stream not opened\", procName, 1);\n\n    for (i = 0; i < n; i++) {\n        if (TIFFReadDirectory(tif) == 0) {\n            TIFFClose(tif);\n            return ERROR_INT(\"image n not found in file\", procName, 1);\n        }\n    }\n\n    ret = tiffReadHeaderTiff(tif, pwidth, pheight, pbps, pspp,\n                             pres, pcmap, pformat);\n    TIFFClose(tif);\n    return ret;\n}\n\n\n/*!\n *  tiffReadHeaderTiff()\n *\n *      Input:  tif\n *              &width (<return>)\n *              &height (<return>)\n *              &bps (<return> bits per sample -- 1, 2, 4 or 8)\n *              &spp (<return>; samples per pixel -- 1 or 3)\n *              &res (<optional return>; resolution in x dir; NULL to ignore)\n *              &cmap (<optional return>; cmap exists; input NULL to ignore)\n *              &format (<optional return>; tiff format; input NULL to ignore)\n *      Return: 0 if OK, 1 on error\n */\nstatic l_int32\ntiffReadHeaderTiff(TIFF     *tif,\n                   l_int32  *pwidth,\n                   l_int32  *pheight,\n                   l_int32  *pbps,\n                   l_int32  *pspp,\n                   l_int32  *pres,\n                   l_int32  *pcmap,\n                   l_int32  *pformat)\n{\nl_uint16   tiffcomp;\nl_uint16   bps, spp;\nl_uint16  *rmap, *gmap, *bmap;\nl_uint32   w, h, xres, yres;\n\n    PROCNAME(\"tiffReadHeaderTiff\");\n\n    if (!tif)\n        return ERROR_INT(\"tif not opened\", procName, 1);\n\n    TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w);\n    *pwidth = w;\n    TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\n    *pheight = h;\n    TIFFGetFieldDefaulted(tif, TIFFTAG_BITSPERSAMPLE, &bps);\n    *pbps = bps;\n    TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLESPERPIXEL, &spp);\n    *pspp = spp;\n\n    if (pres) {\n        *pres = 300;  /* default ppi */\n        if (tiffGetResolution(tif, &xres, &yres))\n            *pres = (l_int32)xres;\n    }\n            \n    if (pcmap) {\n        *pcmap = 0;\n        if (TIFFGetField(tif, TIFFTAG_COLORMAP, &rmap, &gmap, &bmap))\n            *pcmap = 1;\n    }\n\n    if (pformat) {\n        TIFFGetFieldDefaulted(tif, TIFFTAG_COMPRESSION, &tiffcomp);\n        *pformat = getTiffCompressedFormat(tiffcomp);\n    }\n    return 0;\n}\n\n\n/*!\n *  findTiffCompression()\n *\n *      Input:  stream (must be rewound to BOF)\n *              &comptype (<return> compression type)\n *      Return: 0 if OK, 1 on error\n *\n *  Notes:\n *      (1) The returned compression type is that defined in \n *          the enum in imageio.h.  It is not the tiff flag value.\n *      (2) The compression type is initialized to IFF_UNKNOWN.\n *          If it is not one of the specified types, the returned\n *          type is IFF_TIFF, which indicates no compression.\n *      (3) When this function is called, the stream must be at BOF.\n *          If the opened stream is to be used again to read the\n *          file, it must be rewound to BOF after calling this function.\n */\nl_int32\nfindTiffCompression(FILE     *fp,\n                    l_int32  *pcomptype)\n{\nl_uint16  tiffcomp;\nTIFF     *tif;\n\n    PROCNAME(\"findTiffCompression\");\n\n    if (!pcomptype)\n        return ERROR_INT(\"&comptype not defined\", procName, 1);\n    *pcomptype = IFF_UNKNOWN;  /* init */\n    if (!fp)\n        return ERROR_INT(\"stream not defined\", procName, 1);\n    \n    if ((tif = fopenTiff(fp, \"rb\")) == NULL)\n        return ERROR_INT(\"tif not opened\", procName, 1);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_COMPRESSION, &tiffcomp);\n    *pcomptype = getTiffCompressedFormat(tiffcomp);\n    TIFFCleanup(tif);\n    return 0;\n}\n\n\n/*!\n *  getTiffCompressedFormat()\n *\n *      Input:  tiffcomp (defined in tiff.h)\n *      Return: compression format (defined in imageio.h)\n *\n *  Notes:\n *      (1) The input must be the actual tiff compression type\n *          returned by a tiff library call.  It should always be\n *          a valid tiff type.\n *      (2) The return type is defined in the enum in imageio.h.\n */\nstatic l_int32\ngetTiffCompressedFormat(l_uint16  tiffcomp)\n{\nl_int32  comptype;\n\n    switch (tiffcomp)\n    {\n    case COMPRESSION_CCITTFAX4:\n        comptype = IFF_TIFF_G4;\n        break;\n    case COMPRESSION_CCITTFAX3:\n        comptype = IFF_TIFF_G3;\n        break;\n    case COMPRESSION_CCITTRLE:\n        comptype = IFF_TIFF_RLE;\n        break;\n    case COMPRESSION_PACKBITS:\n        comptype = IFF_TIFF_PACKBITS;\n        break;\n    case COMPRESSION_LZW:\n        comptype = IFF_TIFF_LZW;\n        break;\n    case COMPRESSION_ADOBE_DEFLATE:\n        comptype = IFF_TIFF_ZIP;\n        break;\n    default:\n        comptype = IFF_TIFF;\n        break;\n    }\n    return comptype;\n}\n\n\n/*--------------------------------------------------------------*\n *                   Extraction of tiff g4 data                 *\n *--------------------------------------------------------------*/\n/*!\n *  extractTiffG4DataFromFile()\n *\n *      Input:  filein\n *              &data (<return> binary data of ccitt g4 encoded stream)\n *              &nbytes (<return> size of binary data)\n *              &w (<return optional> image width)\n *              &h (<return optional> image height)\n *              &minisblack (<return optional> boolean)\n *      Return: 0 if OK, 1 on error\n */\nl_int32\nextractTiffG4DataFromFile(const char  *filein,\n                          l_uint8    **pdata,\n                          l_int32     *pnbytes,\n                          l_int32     *pw,\n                          l_int32     *ph,\n                          l_int32     *pminisblack)\n{\nl_uint8  *inarray, *data;\nl_uint16  minisblack, comptype;  /* accessors require l_uint16 */\nl_int32   istiff, fbytes, nbytes;\nl_uint32  w, h, rowsperstrip;  /* accessors require l_uint32 */\nl_uint32  diroff;\nFILE     *fpin;\nTIFF     *tif;\n\n    PROCNAME(\"extractTiffG4DataFromFile\");\n\n    if (!pdata)\n        return ERROR_INT(\"&data not defined\", procName, 1);\n    if (!pnbytes)\n        return ERROR_INT(\"&nbytes not defined\", procName, 1);\n    if (!pw && !ph && !pminisblack)\n        return ERROR_INT(\"no output data requested\", procName, 1);\n    *pdata = NULL;\n    *pnbytes = 0;\n\n    if ((fpin = fopen(filein, \"rb\")) == NULL)\n        return ERROR_INT(\"filein not defined\", procName, 1);\n    istiff = fileFormatIsTiff(fpin);\n    fclose(fpin);\n    if (!istiff)\n        return ERROR_INT(\"filein not tiff\", procName, 1);\n\n    if ((inarray = arrayRead(filein, &fbytes)) == NULL)\n        return ERROR_INT(\"inarray not made\", procName, 1);\n\n        /* Get metadata about the image */\n    if ((tif = TIFFOpen(filein, \"r\")) == NULL)\n        return ERROR_INT(\"tif not open for read\", procName, 1);\n    TIFFGetField(tif, TIFFTAG_COMPRESSION, &comptype);\n    if (comptype != COMPRESSION_CCITTFAX4) {\n        FREE(inarray);\n        TIFFClose(tif);\n        return ERROR_INT(\"filein is not g4 compressed\", procName, 1);\n    }\n\n    TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w);\n    TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\n    TIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    if (h != rowsperstrip)\n        L_WARNING(\"more than 1 strip\", procName);\n    TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &minisblack);  /* for 1 bpp */\n/*    TIFFPrintDirectory(tif, stderr, 0); */\n    TIFFClose(tif);\n    if (pw) *pw = (l_int32)w;\n    if (ph) *ph = (l_int32)h;\n    if (pminisblack) *pminisblack = (l_int32)minisblack;\n\n        /* The header has 8 bytes: the first 2 are the magic number,\n         * the next 2 are the version, and the last 4 are the\n         * offset to the first directory.  That's what we want here.\n         * We have to test the byte order before decoding 4 bytes! */\n    if (inarray[0] == 0x4d) {  /* big-endian */\n        diroff = (inarray[4] << 24) | (inarray[5] << 16) |\n                 (inarray[6] << 8) | inarray[7];\n    }\n    else  {   /* inarray[0] == 0x49 :  little-endian */\n        diroff = (inarray[7] << 24) | (inarray[6] << 16) |\n                 (inarray[5] << 8) | inarray[4];\n    }\n/*    fprintf(stderr, \" diroff = %d, %x\\n\", diroff, diroff); */\n\n        /* Extract the ccittg4 encoded data from the tiff file.\n         * We skip the 8 byte header and take nbytes of data,\n         * up to the beginning of the directory (at diroff)  */\n    nbytes = diroff - 8;\n    *pnbytes = nbytes;\n    if ((data = (l_uint8 *)CALLOC(nbytes, sizeof(l_uint8))) == NULL) {\n        FREE(inarray);\n        return ERROR_INT(\"data not allocated\", procName, 1);\n    }\n    *pdata = data;\n    memcpy(data, inarray + 8, nbytes);\n    FREE(inarray);\n\n    return 0;\n}\n\n\n/*--------------------------------------------------------------*\n *               Open tiff stream from file stream              *\n *--------------------------------------------------------------*/\n/*!\n *  fopenTiff()\n *\n *      Input:  stream\n *              modestring (\"r\", \"w\", ...)\n *      Return: tiff (data structure, opened for a file descriptor)\n *\n *  Notes:\n *      (1) Why is this here?  Leffler did not provide a function that\n *          takes a stream and gives a TIFF.  He only gave one that\n *          generates a TIFF starting with a file descriptor.  So we\n *          need to make it here, because it is useful to have functions\n *          that take a stream as input.\n *      (2) Requires lseek to rewind to BOF; fseek won't hack it.\n *      (3) When linking with windows, suggest you use tif_unix.c\n *          instead of tif_win32.c, because it has been reported that\n *          the file descriptor returned from fileno() does not work\n *          with TIFFFdOpen() in tif_win32.c.  (win32 requires a\n *          \"handle\", which is an integer returned by _get_osfhandle(fd).)\n */\nstatic TIFF *\nfopenTiff(FILE        *fp,\n          const char  *modestring)\n{\nl_int32  fd;\n\n    PROCNAME(\"fopenTiff\");\n\n    if (!fp)\n        return (TIFF *)ERROR_PTR(\"stream not opened\", procName, NULL);\n    if (!modestring)\n        return (TIFF *)ERROR_PTR(\"modestring not defined\", procName, NULL);\n\n    if ((fd = fileno(fp)) < 0)\n        return (TIFF *)ERROR_PTR(\"invalid file descriptor\", procName, NULL);\n    lseek(fd, 0, SEEK_SET);\n\n    return TIFFFdOpen(fd, \"TIFFstream\", modestring);\n}\n\n\n/*----------------------------------------------------------------------*\n *     Memory I/O: reading memory --> pix and writing pix --> memory    *\n *----------------------------------------------------------------------*/\n/*  It would be nice to use open_memstream() and fmemopen()\n *  for writing and reading to memory, rsp.  These functions manage\n *  memory for writes and reads that use a file streams interface.\n *  Unfortunately, the tiff library only has an interface for reading\n *  and writing to file descriptors, not to file streams.  The tiff\n *  library procedure is to open a \"tiff stream\" and read/write to it.\n *  The library provides a client interface for managing the I/O\n *  from memory, which requires seven callbacks.  See the TIFFClientOpen\n *  man page for callback signatures.  Adam Langley provided the code\n *  to do this.  */\n\n/*\n *  The L_Memstram @buffer has different functions in writing and reading.\n *\n *     * In reading, it is assigned to the data and read from as\n *       the tiff library uncompresses the data and generates the pix.\n *       The @offset points to the current read position in the data,\n *       and the @hw always gives the number of bytes of data.\n *       The @outdata and @outsize ptrs are not used.\n *       When finished, tiffCloseCallback() simply frees the L_Memstream.\n *\n *     * In writing, it accepts the data that the tiff library\n *       produces when a pix is compressed.  the buffer points to a\n *       malloced area of @bufsize bytes.  The current writing position\n *       in the buffer is @offset and the most ever written is @hw.\n *       The buffer is expanded as necessary.  When finished,\n *       tiffCloseCallback() assigns the @outdata and @outsize ptrs\n *       to the @buffer and @bufsize results, and frees the L_Memstream.\n */\nstruct L_Memstream\n{\n    l_uint8   *buffer;    /* expands to hold data when written to;         */\n                          /* fixed size when read from.                    */\n    size_t     bufsize;   /* current size allocated when written to;       */\n                          /* fixed size of input data when read from.      */\n    size_t     offset;    /* byte offset from beginning of buffer.         */\n    size_t     hw;        /* high-water mark; max bytes in buffer.         */\n    l_uint8  **poutdata;  /* input param for writing; data goes here.      */\n    size_t    *poutsize;  /* input param for writing; data size goes here. */\n};\ntypedef struct L_Memstream  L_MEMSTREAM;\n\n\n    /* These are static functions for memory I/O */\nstatic L_MEMSTREAM *memstreamCreateForRead(l_uint8 *indata, size_t pinsize);\nstatic L_MEMSTREAM *memstreamCreateForWrite(l_uint8 **poutdata,\n                                            size_t *poutsize);\nstatic tsize_t tiffReadCallback(thandle_t handle, tdata_t data, tsize_t length);\nstatic tsize_t tiffWriteCallback(thandle_t handle, tdata_t data,\n                                 tsize_t length);\nstatic toff_t tiffSeekCallback(thandle_t handle, toff_t offset, l_int32 whence);\nstatic l_int32 tiffCloseCallback(thandle_t handle);\nstatic toff_t tiffSizeCallback(thandle_t handle);\nstatic l_int32 tiffMapCallback(thandle_t handle, tdata_t *data, toff_t *length);\nstatic void tiffUnmapCallback(thandle_t handle, tdata_t data, toff_t length);\n\n\nstatic L_MEMSTREAM *\nmemstreamCreateForRead(l_uint8  *indata,\n                       size_t    insize)\n{\nL_MEMSTREAM  *mstream;\n\n    mstream = (L_MEMSTREAM *)CALLOC(1, sizeof(L_MEMSTREAM));\n    mstream->buffer = indata;   /* handle to input data array */\n    mstream->bufsize = insize;  /* amount of input data */\n    mstream->hw = insize;       /* high-water mark fixed at input data size */\n    mstream->offset = 0;        /* offset always starts at 0 */\n    return mstream;\n}\n\n\nstatic L_MEMSTREAM *\nmemstreamCreateForWrite(l_uint8  **poutdata,\n                        size_t    *poutsize)\n{\nL_MEMSTREAM  *mstream;\n\n    mstream = (L_MEMSTREAM *)CALLOC(1, sizeof(L_MEMSTREAM));\n    mstream->buffer = (l_uint8 *)CALLOC(8 * 1024, 1);\n    mstream->bufsize = 8 * 1024;\n    mstream->poutdata = poutdata;  /* used only at end of write */\n    mstream->poutsize = poutsize;  /* ditto  */\n    mstream->hw = mstream->offset = 0;\n    return mstream;\n}\n\n\nstatic tsize_t\ntiffReadCallback(thandle_t  handle,\n                 tdata_t    data,\n                 tsize_t    length)\n{\nL_MEMSTREAM  *mstream;\nsize_t        amount;\n\n    mstream = (L_MEMSTREAM *)handle;\n    amount = L_MIN((size_t)length, mstream->hw - mstream->offset);\n    memcpy(data, mstream->buffer + mstream->offset, amount);\n    mstream->offset += amount;\n    return amount;\n}\n\n\nstatic tsize_t\ntiffWriteCallback(thandle_t  handle,\n                  tdata_t    data,\n                  tsize_t    length)\n{\nL_MEMSTREAM  *mstream;\nsize_t        newsize;\n\n        /* reallocNew() uses calloc to initialize the array.\n         * If malloc is used instead, for some of the encoding methods,\n         * not all the data in 'bufsize' bytes in the buffer will\n         * have been initialized by the end of the compression. */\n    mstream = (L_MEMSTREAM *)handle;\n    if (mstream->offset + length > mstream->bufsize) {\n        newsize = 2 * (mstream->offset + length);\n        mstream->buffer = (l_uint8 *)reallocNew((void **)&mstream->buffer,\n                                                mstream->offset, newsize);\n        mstream->bufsize = newsize;\n    }\n\n    memcpy(mstream->buffer + mstream->offset, data, length);\n    mstream->offset += length;\n    mstream->hw = L_MAX(mstream->offset, mstream->hw);\n    return length;\n}\n\n\nstatic toff_t\ntiffSeekCallback(thandle_t  handle,\n                 toff_t     offset,\n                 l_int32    whence)\n{\nL_MEMSTREAM  *mstream;\n\n    PROCNAME(\"tiffSeekCallback\");\n    mstream = (L_MEMSTREAM *)handle;\n    switch (whence) {\n        case SEEK_SET:\n/*            fprintf(stderr, \"seek_set: offset = %d\\n\", offset); */\n            mstream->offset = offset;\n            break;\n        case SEEK_CUR:\n/*            fprintf(stderr, \"seek_cur: offset = %d\\n\", offset); */\n            mstream->offset += offset;\n            break;\n        case SEEK_END:\n/*            fprintf(stderr, \"seek end: hw = %d, offset = %d\\n\",\n                    mstream->hw, offset); */\n            mstream->offset = mstream->hw - offset;  /* offset >= 0 */\n            break;\n        default:\n            return (toff_t)ERROR_INT(\"bad whence value\", procName,\n                                     mstream->offset);\n    }\n\n    return mstream->offset;\n}\n\n\nstatic l_int32\ntiffCloseCallback(thandle_t  handle)\n{\nL_MEMSTREAM  *mstream;\n\n    mstream = (L_MEMSTREAM *)handle;\n    if (mstream->poutdata) {   /* writing: save the output data */\n        *mstream->poutdata = mstream->buffer;\n        *mstream->poutsize = mstream->hw;\n    }\n    FREE(mstream);  /* never free the buffer! */\n    return 0;\n}\n\n\nstatic toff_t\ntiffSizeCallback(thandle_t  handle)\n{\nL_MEMSTREAM  *mstream;\n\n    mstream = (L_MEMSTREAM *)handle;\n    return mstream->hw;\n}\n\n\nstatic l_int32\ntiffMapCallback(thandle_t  handle,\n                tdata_t   *data,\n                toff_t    *length)\n{\nL_MEMSTREAM  *mstream;\n\n    mstream = (L_MEMSTREAM *)handle;\n    *data = mstream->buffer;\n    *length = mstream->hw;\n    return 0;\n} \n\n\nstatic void\ntiffUnmapCallback(thandle_t  handle,\n                  tdata_t    data,\n                  toff_t     length)\n{\n    return;\n} \n\n\n/*!\n *  fopenTiffMemstream()\n *\n *      Input:  filename (for error output; can be \"\")\n *              operation (\"w\" for write, \"r\" for read)\n *              &data (<return> written data)\n *              &datasize (<return> size of written data)\n *      Return: tiff (data structure, opened for write to memory)\n *\n *  Notes:\n *      (1) This wraps up a number of callbacks for either:\n *            * reading from tiff in memory buffer --> pix\n *            * writing from pix --> tiff in memory buffer\n *      (2) After use, the memstream is automatically destroyed when\n *          TIFFClose() is called.  TIFFCleanup() doesn't free the memstream.\n */\nstatic TIFF *\nfopenTiffMemstream(const char  *filename,\n                   const char  *operation,\n                   l_uint8    **pdata,\n                   size_t      *pdatasize)\n{\nL_MEMSTREAM  *mstream;\n\n    PROCNAME(\"fopenTiffMemstream\");\n\n    if (!filename)\n        return (TIFF *)ERROR_PTR(\"filename not defined\", procName, NULL);\n    if (!operation)\n        return (TIFF *)ERROR_PTR(\"operation not defined\", procName, NULL);\n    if (!pdata)\n        return (TIFF *)ERROR_PTR(\"&data not defined\", procName, NULL);\n    if (!pdatasize)\n        return (TIFF *)ERROR_PTR(\"&datasize not defined\", procName, NULL);\n    if (!strcmp(operation, \"r\") && !strcmp(operation, \"w\"))\n        return (TIFF *)ERROR_PTR(\"operation not 'r' or 'w'}\", procName, NULL);\n\n    if (!strcmp(operation, \"r\"))\n        mstream = memstreamCreateForRead(*pdata, *pdatasize);\n    else\n        mstream = memstreamCreateForWrite(pdata, pdatasize);\n\n    return TIFFClientOpen(filename, operation, mstream,\n                          tiffReadCallback, tiffWriteCallback,\n                          tiffSeekCallback, tiffCloseCallback,\n                          tiffSizeCallback, tiffMapCallback,\n                          tiffUnmapCallback);\n}\n\n\n/*!\n *  pixReadMemTiff()\n *\n *      Input:  data (const; tiff-encoded)\n *              datasize (size of data)\n *              n (page image number: 0-based)\n *      Return: pix, or null on error\n *\n *  Notes:\n *      (1) This is a version of pixReadTiff(), where the data is read\n *          from a memory buffer and uncompressed.\n *      (2) Use TIFFClose(); TIFFCleanup() doesn't free internal memstream.\n */\nPIX *\npixReadMemTiff(const l_uint8  *cdata,\n               size_t          size,\n               l_int32         n)\n{\nl_uint8  *data;\nl_int32   i, pagefound;\nPIX      *pix;\nTIFF     *tif;\n\n    PROCNAME(\"pixReadMemTiff\");\n\n    if (!cdata)\n        return (PIX *)ERROR_PTR(\"cdata not defined\", procName, NULL);\n\n    data = (l_uint8 *)cdata;  /* we're really not going to change this */\n    if ((tif = fopenTiffMemstream(\"tifferror\", \"r\", &data, &size)) == NULL)\n        return (PIX *)ERROR_PTR(\"tiff stream not opened\", procName, NULL);\n\n    pagefound = FALSE;\n    pix = NULL;\n    for (i = 0; i < MAX_PAGES_IN_TIFF_FILE; i++) {\n        if (i == n) {\n            pagefound = TRUE;\n            if ((pix = pixReadFromTiffStream(tif)) == NULL) {\n                TIFFClose(tif);\n                return (PIX *)ERROR_PTR(\"pix not read\", procName, NULL);\n            }\n            pixSetInputFormat(pix, IFF_TIFF);\n            break;\n        }\n        if (TIFFReadDirectory(tif) == 0)\n            break;\n    }\n\n    if (pagefound == FALSE)\n        L_WARNING_INT(\"tiff page %d not found\", procName, n);\n\n    TIFFClose(tif);\n    return pix;\n}\n\n\n/*! \n *  pixWriteMemTiff()\n *\n *      Input:  &data (<return> data of tiff compressed image)\n *              &size (<return> size of returned data)\n *              pix\n *              comptype (IFF_TIFF, IFF_TIFF_RLE, IFF_TIFF_PACKBITS,\n *                        IFF_TIFF_G3, IFF_TIFF_G4,\n *                        IFF_TIFF_LZW, IFF_TIFF_ZIP)\n *      Return: 0 if OK, 1 on error\n *\n *  Usage:\n *      (1) See pixWriteTiff().  This version writes to\n *          memory instead of to a file.\n */\nl_int32\npixWriteMemTiff(l_uint8  **pdata,\n                size_t    *psize,\n                PIX       *pix,\n                l_int32    comptype)\n{\n    return pixWriteMemTiffCustom(pdata, psize, pix, comptype,\n                                 NULL, NULL, NULL, NULL);\n}\n\n\n/*! \n *  pixWriteMemTiffCustom()\n *\n *      Input:  &data (<return> data of tiff compressed image)\n *              &size (<return> size of returned data)\n *              pix\n *              comptype (IFF_TIFF, IFF_TIFF_RLE, IFF_TIFF_PACKBITS,\n *                        IFF_TIFF_G3, IFF_TIFF_G4,\n *                        IFF_TIFF_LZW, IFF_TIFF_ZIP)\n *              natags (<optional> NUMA of custom tiff tags)\n *              savals (<optional> SARRAY of values)\n *              satypes (<optional> SARRAY of types)\n *              nasizes (<optional> NUMA of sizes)\n *      Return: 0 if OK, 1 on error\n *\n *  Usage:\n *      (1) See pixWriteTiffCustom().  This version writes to\n *          memory instead of to a file.\n *      (2) Use TIFFClose(); TIFFCleanup() doesn't free internal memstream.\n */\nl_int32\npixWriteMemTiffCustom(l_uint8  **pdata,\n                      size_t    *psize,\n                      PIX       *pix,\n                      l_int32    comptype,\n                      NUMA      *natags,\n                      SARRAY    *savals,\n                      SARRAY    *satypes,\n                      NUMA      *nasizes)\n{\nl_int32  ret;\nTIFF    *tif;\n\n    PROCNAME(\"pixWriteMemTiffCustom\");\n\n    if (!pdata)\n        return ERROR_INT(\"&data not defined\", procName, 1);\n    if (!psize)\n        return ERROR_INT(\"&size not defined\", procName, 1);\n    if (!pix)\n        return ERROR_INT(\"&pix not defined\", procName, 1);\n    if (pixGetDepth(pix) != 1 && comptype != IFF_TIFF &&\n        comptype != IFF_TIFF_LZW && comptype != IFF_TIFF_ZIP) {\n        L_WARNING(\"invalid compression type for image with bpp > 1\", procName);\n        comptype = IFF_TIFF_ZIP;\n    }\n\n    if ((tif = fopenTiffMemstream(\"tifferror\", \"w\", pdata, psize)) == NULL)\n        return ERROR_INT(\"tiff stream not opened\", procName, 1);\n    ret = pixWriteToTiffStream(tif, pix, comptype, natags, savals,\n                               satypes, nasizes);\n\n    TIFFClose(tif);\n    return ret;\n}\n\n/* --------------------------------------------*/\n#endif  /* HAVE_LIBTIFF */\n/* --------------------------------------------*/\n",
                "name": "tiffio.cpp",
                "path": "DesktopEditor/raster/JBig2/source/LeptonLib/tiffio.cpp",
                "url": "/github.com/ONLYOFFICE/core/-/blob/DesktopEditor/raster/JBig2/source/LeptonLib/tiffio.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 1065,
                    "offsetAndLengths": [
                        [
                            4,
                            18
                        ]
                    ],
                    "preview": "    TIFFPrintDirectory(tif, fpout, 0);"
                },
                {
                    "limitHit": false,
                    "lineNumber": 1563,
                    "offsetAndLengths": [
                        [
                            6,
                            18
                        ]
                    ],
                    "preview": "/*    TIFFPrintDirectory(tif, stderr, 0); */"
                }
            ],
            "repository": {
                "name": "github.com/ONLYOFFICE/core",
                "url": "/github.com/ONLYOFFICE/core"
            }
        },
        {
            "__typename": "FileMatch",
            "file": {
                "commit": {
                    "oid": "61d8a3923d2f6c87da136676e64754796f379826"
                },
                "content": "/*\n * Copyright (c) 2020-2021, NVIDIA CORPORATION.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"ifd.h\"\n\n#include <sys/types.h>\n#include <unistd.h>\n\n#include <algorithm>\n#include <iostream>\n#include <random>\n#include <thread>\n\n#include <fmt/format.h>\n#include <tiffio.h>\n#include <tiffiop.h> // this is not included in the released library\n#include <turbojpeg.h>\n\n#include <cucim/codec/hash_function.h>\n#include <cucim/cuimage.h>\n#include <cucim/logger/timer.h>\n#include <cucim/memory/memory_manager.h>\n#include <cucim/profiler/nvtx3.h>\n#include <cucim/util/cuda.h>\n\n#include \"cuslide/deflate/deflate.h\"\n#include \"cuslide/jpeg/libjpeg_turbo.h\"\n#include \"cuslide/jpeg2k/libopenjpeg.h\"\n#include \"cuslide/loader/nvjpeg_processor.h\"\n#include \"cuslide/lzw/lzw.h\"\n#include \"cuslide/raw/raw.h\"\n#include \"tiff.h\"\n\n\nnamespace cuslide::tiff\n{\n\nIFD::IFD(TIFF* tiff, uint16_t index, ifd_offset_t offset) : tiff_(tiff), ifd_index_(index), ifd_offset_(offset)\n{\n    PROF_SCOPED_RANGE(PROF_EVENT(ifd_ifd));\n    auto tif = tiff->client();\n\n    char* software_char_ptr = nullptr;\n    char* model_char_ptr = nullptr;\n\n    // TODO: error handling\n    TIFFGetField(tif, TIFFTAG_SOFTWARE, &software_char_ptr);\n    software_ = std::string(software_char_ptr ? software_char_ptr : \"\");\n    TIFFGetField(tif, TIFFTAG_MODEL, &model_char_ptr);\n    model_ = std::string(model_char_ptr ? model_char_ptr : \"\");\n    TIFFGetField(tif, TIFFTAG_IMAGEDESCRIPTION, &model_char_ptr);\n    image_description_ = std::string(model_char_ptr ? model_char_ptr : \"\");\n    TIFFGetField(tif, TIFFTAG_RESOLUTIONUNIT, &resolution_unit_);\n    TIFFGetField(tif, TIFFTAG_XRESOLUTION, &x_resolution_);\n    TIFFGetField(tif, TIFFTAG_YRESOLUTION, &y_resolution_);\n\n    TIFFDirectory& tif_dir = tif->tif_dir;\n    flags_ = tif->tif_flags;\n\n    width_ = tif_dir.td_imagewidth;\n    height_ = tif_dir.td_imagelength;\n    if ((flags_ & TIFF_ISTILED) != 0)\n    {\n        tile_width_ = tif_dir.td_tilewidth;\n        tile_height_ = tif_dir.td_tilelength;\n    }\n    else\n    {\n        rows_per_strip_ = tif_dir.td_rowsperstrip;\n    }\n    bits_per_sample_ = tif_dir.td_bitspersample;\n    samples_per_pixel_ = tif_dir.td_samplesperpixel;\n    subfile_type_ = tif_dir.td_subfiletype;\n    planar_config_ = tif_dir.td_planarconfig;\n    photometric_ = tif_dir.td_photometric;\n    compression_ = tif_dir.td_compression;\n    TIFFGetField(tif, TIFFTAG_PREDICTOR, &predictor_);\n    subifd_count_ = tif_dir.td_nsubifd;\n    uint64_t* subifd_offsets = tif_dir.td_subifd;\n    if (subifd_count_)\n    {\n        subifd_offsets_.resize(subifd_count_);\n        subifd_offsets_.insert(subifd_offsets_.end(), &subifd_offsets[0], &subifd_offsets[subifd_count_]);\n    }\n\n    if (compression_ == COMPRESSION_JPEG)\n    {\n        uint8_t* jpegtable_data = nullptr;\n        uint32_t jpegtable_count = 0;\n\n        TIFFGetField(tif, TIFFTAG_JPEGTABLES, &jpegtable_count, &jpegtable_data);\n        jpegtable_.reserve(jpegtable_count);\n        jpegtable_.insert(jpegtable_.end(), jpegtable_data, jpegtable_data + jpegtable_count);\n\n        if (photometric_ == PHOTOMETRIC_RGB)\n        {\n            jpeg_color_space_ = 2; // JCS_RGB\n        }\n        else if (photometric_ == PHOTOMETRIC_YCBCR)\n        {\n            jpeg_color_space_ = 3; // JCS_YCbCr\n        }\n    }\n\n    image_piece_count_ = tif_dir.td_stripoffset_entry.tdir_count;\n\n    image_piece_offsets_.reserve(image_piece_count_);\n    uint64* td_stripoffset_p = tif_dir.td_stripoffset_p;\n    uint64* td_stripbytecount_p = tif_dir.td_stripbytecount_p;\n\n    // Copy data to vector\n    image_piece_offsets_.insert(image_piece_offsets_.end(), &td_stripoffset_p[0], &td_stripoffset_p[image_piece_count_]);\n    image_piece_bytecounts_.insert(\n        image_piece_bytecounts_.end(), &td_stripbytecount_p[0], &td_stripbytecount_p[image_piece_count_]);\n\n    // Calculate hash value with IFD index\n    hash_value_ = tiff->file_handle_->hash_value ^ cucim::codec::splitmix64(index);\n\n    //    TIFFPrintDirectory(tif, stdout, TIFFPRINT_STRIPS);\n}\n\nbool IFD::read(const TIFF* tiff,\n               const cucim::io::format::ImageMetadataDesc* metadata,\n               const cucim::io::format::ImageReaderRegionRequestDesc* request,\n               cucim::io::format::ImageDataDesc* out_image_data)\n{\n    PROF_SCOPED_RANGE(PROF_EVENT(ifd_read));\n    ::TIFF* tif = tiff->tiff_client_;\n\n    uint16_t ifd_index = ifd_index_;\n\n    std::string device_name(request->device);\n\n    if (request->shm_name)\n    {\n        device_name = device_name + fmt::format(\"[{}]\", request->shm_name); // TODO: check performance\n    }\n    cucim::io::Device out_device(device_name);\n\n    int64_t sx = request->location[0];\n    int64_t sy = request->location[1];\n    uint32_t batch_size = request->batch_size;\n    int64_t w = request->size[0];\n    int64_t h = request->size[1];\n    int32_t n_ch = samples_per_pixel_; // number of channels\n    int ndim = 3;\n\n    size_t raster_size = w * h * samples_per_pixel_;\n    void* raster = nullptr;\n    auto raster_type = cucim::io::DeviceType::kCPU;\n\n    DLTensor* out_buf = request->buf;\n    bool is_buf_available = out_buf && out_buf->data;\n\n    if (is_buf_available)\n    {\n        // TODO: memory size check if out_buf->data has high-enough memory (>= tjBufSize())\n        raster = out_buf->data;\n    }\n\n    if (is_read_optimizable())\n    {\n        if (batch_size > 1)\n        {\n            ndim = 4;\n        }\n        int64_t* location = request->location;\n        uint64_t location_len = request->location_len;\n        const uint32_t num_workers = request->num_workers;\n        const bool drop_last = request->drop_last;\n        uint32_t prefetch_factor = request->prefetch_factor;\n        const bool shuffle = request->shuffle;\n        const uint64_t seed = request->seed;\n\n        if (num_workers == 0 && location_len > 1)\n        {\n            throw std::runtime_error(\"Cannot read multiple locations with zero workers!\");\n        }\n\n        // Shuffle data\n        if (shuffle)\n        {\n            auto rng = std::default_random_engine{ seed };\n            struct position\n            {\n                int64_t x;\n                int64_t y;\n            };\n            std::shuffle(reinterpret_cast<position*>(&location[0]),\n                         reinterpret_cast<position*>(&location[location_len * 2]), rng);\n        }\n\n        // Adjust location length based on 'drop_last'\n        const uint32_t remaining_len = location_len % batch_size;\n        if (drop_last)\n        {\n            location_len -= remaining_len;\n        }\n\n        // Do not use prefetch if the image is too small\n        if (1 + prefetch_factor > location_len)\n        {\n            prefetch_factor = location_len - 1;\n        }\n\n        size_t one_raster_size = raster_size;\n        raster_size *= batch_size;\n\n        const IFD* ifd = this;\n\n        if (location_len > 1 || batch_size > 1 || num_workers > 0)\n        {\n            // Reconstruct location\n            std::unique_ptr<std::vector<int64_t>>* location_unique =\n                reinterpret_cast<std::unique_ptr<std::vector<int64_t>>*>(request->location_unique);\n            std::unique_ptr<std::vector<int64_t>> request_location = std::move(*location_unique);\n            delete location_unique;\n\n            // Reconstruct size\n            std::unique_ptr<std::vector<int64_t>>* size_unique =\n                reinterpret_cast<std::unique_ptr<std::vector<int64_t>>*>(request->size_unique);\n            std::unique_ptr<std::vector<int64_t>> request_size = std::move(*size_unique);\n            delete size_unique;\n\n            auto load_func = [tiff, ifd, location, w, h, out_device](\n                                 cucim::loader::ThreadBatchDataLoader* loader_ptr, uint64_t location_index) {\n                uint8_t* raster_ptr = loader_ptr->raster_pointer(location_index);\n\n                if (!read_region_tiles(tiff, ifd, location, location_index, w, h,\n                                       raster_ptr, out_device, loader_ptr))\n                {\n                    fmt::print(stderr, \"[Error] Failed to read region!\\n\");\n                }\n            };\n\n            uint32_t maximum_tile_count = 0;\n\n            std::unique_ptr<cucim::loader::BatchDataProcessor> batch_processor;\n\n            // Set raster_type to CUDA because loader will handle this with nvjpeg\n            if (out_device.type() == cucim::io::DeviceType::kCUDA)\n            {\n                raster_type = cucim::io::DeviceType::kCUDA;\n\n                // The maximal number of tiles (x-axis) overapped with the given patch\n                uint32_t tile_across_count = std::min(static_cast<uint64_t>(ifd->width_) + (ifd->tile_width_ - 1),\n                                                      static_cast<uint64_t>(w) + (ifd->tile_width_ - 1)) /\n                                                 ifd->tile_width_ +\n                                             1;\n                // The maximal number of tiles (y-axis) overapped with the given patch\n                uint32_t tile_down_count = std::min(static_cast<uint64_t>(ifd->height_) + (ifd->tile_height_ - 1),\n                                                    static_cast<uint64_t>(h) + (ifd->tile_height_ - 1)) /\n                                               ifd->tile_height_ +\n                                           1;\n                // The maximal number of possible tiles (# of tasks) to load for the given image batch\n                maximum_tile_count = tile_across_count * tile_down_count * batch_size;\n\n                // Create NvJpegProcessor\n                auto& jpegtable = ifd->jpegtable_;\n                const void* jpegtable_data = jpegtable.data();\n                uint32_t jpegtable_size = jpegtable.size();\n\n                auto nvjpeg_processor = std::make_unique<cuslide::loader::NvJpegProcessor>(\n                    tiff->file_handle_, ifd, request_location->data(), request_size->data(), location_len, batch_size,\n                    maximum_tile_count, static_cast<const uint8_t*>(jpegtable_data), jpegtable_size);\n\n                // Update prefetch_factor\n                prefetch_factor = nvjpeg_processor->preferred_loader_prefetch_factor();\n\n                batch_processor = std::move(nvjpeg_processor);\n            }\n\n            auto loader = std::make_unique<cucim::loader::ThreadBatchDataLoader>(\n                load_func, std::move(batch_processor), out_device, std::move(request_location), std::move(request_size),\n                location_len, one_raster_size, batch_size, prefetch_factor, num_workers);\n\n            const uint32_t load_size = std::min(static_cast<uint64_t>(batch_size) * (1 + prefetch_factor), location_len);\n\n            loader->request(load_size);\n\n            // If it reads entire image with multi threads (using loader), fetch the next item.\n            if (location_len == 1 && batch_size == 1)\n            {\n                raster = loader->next_data();\n            }\n\n            out_image_data->loader = loader.release(); // set loader to out_image_data\n        }\n        else\n        {\n            if (!raster)\n            {\n                raster = cucim_malloc(one_raster_size);\n            }\n\n            if (!read_region_tiles(tiff, ifd, location, 0, w, h, raster, out_device, nullptr))\n            {\n                fmt::print(stderr, \"[Error] Failed to read region!\\n\");\n            }\n        }\n    }\n    else\n    {\n        PROF_SCOPED_RANGE(PROF_EVENT(ifd_read_slowpath));\n        // Print a warning message for the slow path\n        std::call_once(\n            tiff->slow_path_warning_flag_,\n            [](const std::string& file_path) {\n                fmt::print(\n                    stderr,\n                    \"[Warning] Loading image('{}') with a slow-path. The pixel format of the loaded image would be RGBA (4 channels) instead of RGB!\\n\",\n                    file_path);\n            },\n            tiff->file_path());\n        // Handle out-of-boundary case\n        int64_t ex = sx + w - 1;\n        int64_t ey = sy + h - 1;\n        if (sx < 0 || sy < 0 || sx >= width_ || sy >= height_ || ex < 0 || ey < 0 || ex >= width_ || ey >= height_)\n        {\n            throw std::invalid_argument(fmt::format(\"Cannot handle the out-of-boundary cases.\"));\n        }\n\n        // Check if the image format is supported or not\n        if (!is_format_supported())\n        {\n            throw std::runtime_error(fmt::format(\n                \"This format (compression: {}, sample_per_pixel: {}, planar_config: {}, photometric: {}) is not supported yet!.\",\n                compression_, samples_per_pixel_, planar_config_, photometric_));\n        }\n\n        if (tif->tif_curdir != ifd_index)\n        {\n            TIFFSetDirectory(tif, ifd_index);\n        }\n        // RGBA -> 4 channels\n        n_ch = 4;\n\n        char emsg[1024];\n        if (TIFFRGBAImageOK(tif, emsg))\n        {\n            TIFFRGBAImage img;\n            if (TIFFRGBAImageBegin(&img, tif, -1, emsg))\n            {\n                size_t npixels;\n                npixels = w * h;\n                raster_size = npixels * 4;\n                if (!raster)\n                {\n                    raster = cucim_malloc(raster_size);\n                }\n                img.col_offset = sx;\n                img.row_offset = sy;\n                img.req_orientation = ORIENTATION_TOPLEFT;\n\n                if (raster != nullptr)\n                {\n                    if (!TIFFRGBAImageGet(&img, (uint32_t*)raster, w, h))\n                    {\n                        memset(raster, 0, raster_size);\n                    }\n                }\n            }\n            else\n            {\n                throw std::runtime_error(fmt::format(\n                    \"This format (compression: {}, sample_per_pixel: {}, planar_config: {}, photometric: {}) is not supported yet!: {}\",\n                    compression_, samples_per_pixel_, planar_config_, photometric_, emsg));\n            }\n            TIFFRGBAImageEnd(&img);\n        }\n        else\n        {\n            throw std::runtime_error(fmt::format(\n                \"This format (compression: {}, sample_per_pixel: {}, planar_config: {}, photometric: {}) is not supported yet!: {}\",\n                compression_, samples_per_pixel_, planar_config_, photometric_, emsg));\n        }\n    }\n\n    int64_t* shape = static_cast<int64_t*>(cucim_malloc(sizeof(int64_t) * ndim));\n    if (ndim == 3)\n    {\n        shape[0] = h;\n        shape[1] = w;\n        shape[2] = n_ch;\n    }\n    else // ndim == 4\n    {\n        shape[0] = batch_size;\n        shape[1] = h;\n        shape[2] = w;\n        shape[3] = n_ch;\n    }\n\n    // Copy the raster memory and free it if needed.\n    if (!is_buf_available && raster && raster_type == cucim::io::DeviceType::kCPU)\n    {\n        cucim::memory::move_raster_from_host(&raster, raster_size, out_device);\n    }\n\n    auto& out_image_container = out_image_data->container;\n    out_image_container.data = raster;\n    out_image_container.device = DLDevice{ static_cast<DLDeviceType>(out_device.type()), out_device.index() };\n    out_image_container.ndim = ndim;\n    out_image_container.dtype = metadata->dtype;\n    out_image_container.shape = shape;\n    out_image_container.strides = nullptr; // Tensor is compact and row-majored\n    out_image_container.byte_offset = 0;\n    auto& shm_name = out_device.shm_name();\n    size_t shm_name_len = shm_name.size();\n    if (shm_name_len != 0)\n    {\n        out_image_data->shm_name = static_cast<char*>(cucim_malloc(shm_name_len + 1));\n        memcpy(out_image_data->shm_name, shm_name.c_str(), shm_name_len + 1);\n    }\n    else\n    {\n        out_image_data->shm_name = nullptr;\n    }\n\n    return true;\n}\n\nuint32_t IFD::index() const\n{\n    return ifd_index_;\n}\nifd_offset_t IFD::offset() const\n{\n    return ifd_offset_;\n}\n\nstd::string& IFD::software()\n{\n    return software_;\n}\nstd::string& IFD::model()\n{\n    return model_;\n}\nstd::string& IFD::image_description()\n{\n    return image_description_;\n}\nuint16_t IFD::resolution_unit() const\n{\n    return resolution_unit_;\n}\nfloat IFD::x_resolution() const\n{\n    return x_resolution_;\n}\nfloat IFD::y_resolution() const\n{\n    return y_resolution_;\n}\nuint32_t IFD::width() const\n{\n    return width_;\n}\nuint32_t IFD::height() const\n{\n    return height_;\n}\nuint32_t IFD::tile_width() const\n{\n    return tile_width_;\n}\nuint32_t IFD::tile_height() const\n{\n    return tile_height_;\n}\nuint32_t IFD::rows_per_strip() const\n{\n    return rows_per_strip_;\n}\nuint32_t IFD::bits_per_sample() const\n{\n    return bits_per_sample_;\n}\nuint32_t IFD::samples_per_pixel() const\n{\n    return samples_per_pixel_;\n}\nuint64_t IFD::subfile_type() const\n{\n    return subfile_type_;\n}\nuint16_t IFD::planar_config() const\n{\n    return planar_config_;\n}\nuint16_t IFD::photometric() const\n{\n    return photometric_;\n}\nuint16_t IFD::compression() const\n{\n    return compression_;\n}\nuint16_t IFD::predictor() const\n{\n    return predictor_;\n}\n\nuint16_t IFD::subifd_count() const\n{\n    return subifd_count_;\n}\nstd::vector<uint64_t>& IFD::subifd_offsets()\n{\n    return subifd_offsets_;\n}\nuint32_t IFD::image_piece_count() const\n{\n    return image_piece_count_;\n}\nconst std::vector<uint64_t>& IFD::image_piece_offsets() const\n{\n    return image_piece_offsets_;\n}\nconst std::vector<uint64_t>& IFD::image_piece_bytecounts() const\n{\n    return image_piece_bytecounts_;\n}\n\nsize_t IFD::pixel_size_nbytes() const\n{\n    const int pixel_format = TJPF_RGB; // TODO: support other pixel format\n    const int nbytes = tjPixelSize[pixel_format];\n    return nbytes;\n}\n\nsize_t IFD::tile_raster_size_nbytes() const\n{\n    const size_t nbytes = tile_width_ * tile_height_ * pixel_size_nbytes();\n    return nbytes;\n}\n\nbool IFD::is_compression_supported() const\n{\n    switch (compression_)\n    {\n    case COMPRESSION_NONE:\n    case COMPRESSION_JPEG:\n    case COMPRESSION_ADOBE_DEFLATE:\n    case COMPRESSION_DEFLATE:\n    case cuslide::jpeg2k::kAperioJpeg2kYCbCr: // 33003: Jpeg 2000 with YCbCr format, possibly with a chroma subsampling\n                                              // of 4:2:2\n    case cuslide::jpeg2k::kAperioJpeg2kRGB: // 33005: Jpeg 2000 with RGB\n    case COMPRESSION_LZW:\n        return true;\n    default:\n        return false;\n    }\n}\n\nbool IFD::is_read_optimizable() const\n{\n    return is_compression_supported() && bits_per_sample_ == 8 && samples_per_pixel_ == 3 &&\n           (tile_width_ != 0 && tile_height_ != 0) && planar_config_ == PLANARCONFIG_CONTIG &&\n           (photometric_ == PHOTOMETRIC_RGB || photometric_ == PHOTOMETRIC_YCBCR) &&\n           !tiff_->is_in_read_config(TIFF::kUseLibTiff);\n}\n\nbool IFD::is_format_supported() const\n{\n    return is_compression_supported();\n}\n\nbool IFD::read_region_tiles(const TIFF* tiff,\n                            const IFD* ifd,\n                            const int64_t* location,\n                            const int64_t location_index,\n                            const int64_t w,\n                            const int64_t h,\n                            void* raster,\n                            const cucim::io::Device& out_device,\n                            cucim::loader::ThreadBatchDataLoader* loader)\n{\n    PROF_SCOPED_RANGE(PROF_EVENT(ifd_read_region_tiles));\n    // Reference code: https://github.com/libjpeg-turbo/libjpeg-turbo/blob/master/tjexample.c\n\n    int64_t sx = location[location_index * 2];\n    int64_t sy = location[location_index * 2 + 1];\n    int64_t ex = sx + w - 1;\n    int64_t ey = sy + h - 1;\n\n    uint32_t width = ifd->width_;\n    uint32_t height = ifd->height_;\n\n    // Handle out-of-boundary case\n    if (sx < 0 || sy < 0 || sx >= width || sy >= height || ex < 0 || ey < 0 || ex >= width || ey >= height)\n    {\n        return read_region_tiles_boundary(tiff, ifd, location, location_index, w, h, raster, out_device, loader);\n    }\n    cucim::cache::ImageCache& image_cache = cucim::CuImage::cache_manager().cache();\n    cucim::cache::CacheType cache_type = image_cache.type();\n\n    uint8_t background_value = tiff->background_value_;\n    uint16_t compression_method = ifd->compression_;\n    int jpeg_color_space = ifd->jpeg_color_space_;\n    int predictor = ifd->predictor_;\n\n    // TODO: revert this once we can get RGB data instead of RGBA\n    uint32_t samples_per_pixel = 3; // ifd->samples_per_pixel();\n\n    const void* jpegtable_data = ifd->jpegtable_.data();\n    uint32_t jpegtable_count = ifd->jpegtable_.size();\n\n    uint32_t tw = ifd->tile_width_;\n    uint32_t th = ifd->tile_height_;\n\n    uint32_t offset_sx = static_cast<uint32_t>(sx / tw); // x-axis start offset for the requested region in the ifd tile\n                                                         // array as grid\n    uint32_t offset_ex = static_cast<uint32_t>(ex / tw); // x-axis end  offset for the requested region in the ifd tile\n                                                         // array as grid\n    uint32_t offset_sy = static_cast<uint32_t>(sy / th); // y-axis start offset for the requested region in the ifd tile\n                                                         // array as grid\n    uint32_t offset_ey = static_cast<uint32_t>(ey / th); // y-axis end offset for the requested region in the ifd tile\n                                                         // array as grid\n\n    uint32_t pixel_offset_sx = static_cast<uint32_t>(sx % tw);\n    uint32_t pixel_offset_ex = static_cast<uint32_t>(ex % tw);\n    uint32_t pixel_offset_sy = static_cast<uint32_t>(sy % th);\n    uint32_t pixel_offset_ey = static_cast<uint32_t>(ey % th);\n\n    uint32_t stride_y = width / tw + !!(width % tw); // # of tiles in a row(y) in the ifd tile array as grid\n\n    uint32_t start_index_y = offset_sy * stride_y;\n    uint32_t end_index_y = offset_ey * stride_y;\n\n    const size_t tile_raster_nbytes = ifd->tile_raster_size_nbytes();\n\n    int tiff_file = tiff->file_handle_->fd;\n    uint64_t ifd_hash_value = ifd->hash_value_;\n    uint32_t dest_pixel_step_y = w * samples_per_pixel;\n\n    uint32_t nbytes_tw = tw * samples_per_pixel;\n    auto dest_start_ptr = static_cast<uint8_t*>(raster);\n\n    // TODO: Current implementation doesn't consider endianness so need to consider later\n    // TODO: Consider tile's depth tag.\n    for (uint32_t index_y = start_index_y; index_y <= end_index_y; index_y += stride_y)\n    {\n        uint32_t tile_pixel_offset_sy = (index_y == start_index_y) ? pixel_offset_sy : 0;\n        uint32_t tile_pixel_offset_ey = (index_y == end_index_y) ? pixel_offset_ey : (th - 1);\n        uint32_t dest_pixel_offset_len_y = tile_pixel_offset_ey - tile_pixel_offset_sy + 1;\n\n        uint32_t dest_pixel_index_x = 0;\n\n        uint32_t index = index_y + offset_sx;\n        for (uint32_t offset_x = offset_sx; offset_x <= offset_ex; ++offset_x, ++index)\n        {\n            PROF_SCOPED_RANGE(PROF_EVENT_P(ifd_read_region_tiles_iter, index));\n            auto tiledata_offset = static_cast<uint64_t>(ifd->image_piece_offsets_[index]);\n            auto tiledata_size = static_cast<uint64_t>(ifd->image_piece_bytecounts_[index]);\n\n            // Calculate a simple hash value for the tile index\n            uint64_t index_hash = ifd_hash_value ^ (static_cast<uint64_t>(index) | (static_cast<uint64_t>(index) << 32));\n\n            uint32_t tile_pixel_offset_x = (offset_x == offset_sx) ? pixel_offset_sx : 0;\n            uint32_t nbytes_tile_pixel_size_x = (offset_x == offset_ex) ?\n                                                    (pixel_offset_ex - tile_pixel_offset_x + 1) * samples_per_pixel :\n                                                    (tw - tile_pixel_offset_x) * samples_per_pixel;\n            auto decode_func = [=, &image_cache]() {\n                PROF_SCOPED_RANGE(PROF_EVENT_P(ifd_read_region_tiles_task, index_hash));\n                uint32_t nbytes_tile_index = (tile_pixel_offset_sy * tw + tile_pixel_offset_x) * samples_per_pixel;\n                uint32_t dest_pixel_index = dest_pixel_index_x;\n                uint8_t* tile_data = nullptr;\n                if (tiledata_size > 0)\n                {\n                    std::unique_ptr<uint8_t, decltype(cucim_free)*> tile_raster =\n                        std::unique_ptr<uint8_t, decltype(cucim_free)*>(nullptr, cucim_free);\n\n                    if (loader && loader->batch_data_processor())\n                    {\n                        switch (compression_method)\n                        {\n                        case COMPRESSION_JPEG:\n                            break;\n                        default:\n                            throw std::runtime_error(\"Unsupported compression method\");\n                        }\n                        auto value = loader->wait_for_processing(index);\n                        if (!value) // if shutdown\n                        {\n                            return;\n                        }\n                        tile_data = static_cast<uint8_t*>(value->data);\n\n                        cudaError_t cuda_status;\n                        CUDA_ERROR(cudaMemcpy2D(dest_start_ptr + dest_pixel_index, dest_pixel_step_y,\n                                                tile_data + nbytes_tile_index, nbytes_tw, nbytes_tile_pixel_size_x,\n                                                tile_pixel_offset_ey - tile_pixel_offset_sy + 1,\n                                                cudaMemcpyDeviceToDevice));\n                    }\n                    else\n                    {\n                        auto key = image_cache.create_key(ifd_hash_value, index);\n                        image_cache.lock(index_hash);\n                        auto value = image_cache.find(key);\n                        if (value)\n                        {\n                            image_cache.unlock(index_hash);\n                            tile_data = static_cast<uint8_t*>(value->data);\n                        }\n                        else\n                        {\n                            // Lifetime of tile_data is same with `value`\n                            // : do not access this data when `value` is not accessible.\n                            if (cache_type != cucim::cache::CacheType::kNoCache)\n                            {\n                                tile_data = static_cast<uint8_t*>(image_cache.allocate(tile_raster_nbytes));\n                            }\n                            else\n                            {\n                                // Allocate temporary buffer for tile data\n                                tile_raster = std::unique_ptr<uint8_t, decltype(cucim_free)*>(\n                                    reinterpret_cast<uint8_t*>(cucim_malloc(tile_raster_nbytes)), cucim_free);\n                                tile_data = tile_raster.get();\n                            }\n                            {\n                                PROF_SCOPED_RANGE(PROF_EVENT(ifd_decompression));\n                                switch (compression_method)\n                                {\n                                case COMPRESSION_NONE:\n                                    cuslide::raw::decode_raw(tiff_file, nullptr, tiledata_offset, tiledata_size,\n                                                             &tile_data, tile_raster_nbytes, out_device);\n                                    break;\n                                case COMPRESSION_JPEG:\n                                    cuslide::jpeg::decode_libjpeg(tiff_file, nullptr, tiledata_offset, tiledata_size,\n                                                                  jpegtable_data, jpegtable_count, &tile_data,\n                                                                  out_device, jpeg_color_space);\n                                    break;\n                                case COMPRESSION_ADOBE_DEFLATE:\n                                case COMPRESSION_DEFLATE:\n                                    cuslide::deflate::decode_deflate(tiff_file, nullptr, tiledata_offset, tiledata_size,\n                                                                     &tile_data, tile_raster_nbytes, out_device);\n                                    break;\n                                case cuslide::jpeg2k::kAperioJpeg2kYCbCr: // 33003\n                                    cuslide::jpeg2k::decode_libopenjpeg(tiff_file, nullptr, tiledata_offset,\n                                                                        tiledata_size, &tile_data, tile_raster_nbytes,\n                                                                        out_device, cuslide::jpeg2k::ColorSpace::kSYCC);\n                                    break;\n                                case cuslide::jpeg2k::kAperioJpeg2kRGB: // 33005\n                                    cuslide::jpeg2k::decode_libopenjpeg(tiff_file, nullptr, tiledata_offset,\n                                                                        tiledata_size, &tile_data, tile_raster_nbytes,\n                                                                        out_device, cuslide::jpeg2k::ColorSpace::kRGB);\n                                    break;\n                                case COMPRESSION_LZW:\n                                    cuslide::lzw::decode_lzw(tiff_file, nullptr, tiledata_offset, tiledata_size,\n                                                             &tile_data, tile_raster_nbytes, out_device);\n                                    // Apply unpredictor\n                                    //   1: none, 2: horizontal differencing, 3: floating point predictor\n                                    //   https://www.adobe.io/content/dam/udp/en/open/standards/tiff/TIFF6.pdf\n                                    if (predictor == 2)\n                                    {\n                                        cuslide::lzw::horAcc8(tile_data, tile_raster_nbytes, nbytes_tw);\n                                    }\n                                    break;\n                                default:\n                                    throw std::runtime_error(\"Unsupported compression method\");\n                                }\n                            }\n\n                            value = image_cache.create_value(tile_data, tile_raster_nbytes);\n                            image_cache.insert(key, value);\n                            image_cache.unlock(index_hash);\n                        }\n\n                        for (uint32_t ty = tile_pixel_offset_sy; ty <= tile_pixel_offset_ey;\n                             ++ty, dest_pixel_index += dest_pixel_step_y, nbytes_tile_index += nbytes_tw)\n                        {\n                            memcpy(dest_start_ptr + dest_pixel_index, tile_data + nbytes_tile_index,\n                                   nbytes_tile_pixel_size_x);\n                        }\n                    }\n                }\n                else\n                {\n                    if (out_device.type() == cucim::io::DeviceType::kCPU)\n                    {\n                        for (uint32_t ty = tile_pixel_offset_sy; ty <= tile_pixel_offset_ey;\n                             ++ty, dest_pixel_index += dest_pixel_step_y, nbytes_tile_index += nbytes_tw)\n                        {\n                            // Set background value such as (255,255,255)\n                            memset(dest_start_ptr + dest_pixel_index, background_value, nbytes_tile_pixel_size_x);\n                        }\n                    }\n                    else\n                    {\n                        cudaError_t cuda_status;\n                        CUDA_ERROR(cudaMemset2D(dest_start_ptr + dest_pixel_index, dest_pixel_step_y, background_value,\n                                                nbytes_tile_pixel_size_x,\n                                                tile_pixel_offset_ey - tile_pixel_offset_sy + 1));\n                    }\n                }\n            };\n\n            if (loader && *loader)\n            {\n                loader->enqueue(std::move(decode_func),\n                                cucim::loader::TileInfo{ location_index, index, tiledata_offset, tiledata_size });\n            }\n            else\n            {\n                decode_func();\n            }\n\n            dest_pixel_index_x += nbytes_tile_pixel_size_x;\n        }\n        dest_start_ptr += dest_pixel_step_y * dest_pixel_offset_len_y;\n    }\n\n    return true;\n}\n\nbool IFD::read_region_tiles_boundary(const TIFF* tiff,\n                                     const IFD* ifd,\n                                     const int64_t* location,\n                                     const int64_t location_index,\n                                     const int64_t w,\n                                     const int64_t h,\n                                     void* raster,\n                                     const cucim::io::Device& out_device,\n                                     cucim::loader::ThreadBatchDataLoader* loader)\n{\n    PROF_SCOPED_RANGE(PROF_EVENT(ifd_read_region_tiles_boundary));\n    (void)out_device;\n    // Reference code: https://github.com/libjpeg-turbo/libjpeg-turbo/blob/master/tjexample.c\n    int64_t sx = location[location_index * 2];\n    int64_t sy = location[location_index * 2 + 1];\n\n    uint8_t background_value = tiff->background_value_;\n    uint16_t compression_method = ifd->compression_;\n    int jpeg_color_space = ifd->jpeg_color_space_;\n    int predictor = ifd->predictor_;\n\n    int64_t ex = sx + w - 1;\n    int64_t ey = sy + h - 1;\n\n    uint32_t width = ifd->width_;\n    uint32_t height = ifd->height_;\n\n    // Memory for tile_raster would be manually allocated here, instead of using decode_libjpeg().\n    // Need to free the manually. Usually it is set to nullptr and memory is created by decode_libjpeg() by using\n    // tjAlloc() (Also need to free with tjFree() after use. See the documentation of tjAlloc() for the detail.)\n    const int pixel_size_nbytes = ifd->pixel_size_nbytes();\n    auto dest_start_ptr = static_cast<uint8_t*>(raster);\n\n    bool is_out_of_image = (ex < 0 || width <= sx || ey < 0 || height <= sy);\n    if (is_out_of_image)\n    {\n        // Fill background color(255,255,255) and return\n        memset(dest_start_ptr, background_value, w * h * pixel_size_nbytes);\n        return true;\n    }\n    cucim::cache::ImageCache& image_cache = cucim::CuImage::cache_manager().cache();\n    cucim::cache::CacheType cache_type = image_cache.type();\n\n    uint32_t tw = ifd->tile_width_;\n    uint32_t th = ifd->tile_height_;\n\n    const size_t tile_raster_nbytes = tw * th * pixel_size_nbytes;\n\n    // TODO: revert this once we can get RGB data instead of RGBA\n    uint32_t samples_per_pixel = 3; // ifd->samples_per_pixel();\n\n    const void* jpegtable_data = ifd->jpegtable_.data();\n    uint32_t jpegtable_count = ifd->jpegtable_.size();\n\n    bool sx_in_range = (sx >= 0 && sx < width);\n    bool ex_in_range = (ex >= 0 && ex < width);\n    bool sy_in_range = (sy >= 0 && sy < height);\n    bool ey_in_range = (ey >= 0 && ey < height);\n\n    int64_t offset_boundary_x = (static_cast<int64_t>(width) - 1) / tw;\n    int64_t offset_boundary_y = (static_cast<int64_t>(height) - 1) / th;\n\n    int64_t offset_sx = sx / tw; // x-axis start offset for the requested region in the\n                                 // ifd tile array as grid\n\n    int64_t offset_ex = ex / tw; // x-axis end  offset for the requested region in the\n                                 // ifd tile array as grid\n\n    int64_t offset_sy = sy / th; // y-axis start offset for the requested region in the\n                                 // ifd tile array as grid\n    int64_t offset_ey = ey / th; // y-axis end offset for the requested region in the\n                                 // ifd tile array as grid\n    int64_t pixel_offset_sx = (sx % tw);\n    int64_t pixel_offset_ex = (ex % tw);\n    int64_t pixel_offset_sy = (sy % th);\n    int64_t pixel_offset_ey = (ey % th);\n    int64_t pixel_offset_boundary_x = ((width - 1) % tw);\n    int64_t pixel_offset_boundary_y = ((height - 1) % th);\n\n    // Make sure that division and modulo has same value with Python's one (e.g., making -1 / 3 == -1 instead of 0)\n    if (pixel_offset_sx < 0)\n    {\n        pixel_offset_sx += tw;\n        --offset_sx;\n    }\n    if (pixel_offset_ex < 0)\n    {\n        pixel_offset_ex += tw;\n        --offset_ex;\n    }\n    if (pixel_offset_sy < 0)\n    {\n        pixel_offset_sy += th;\n        --offset_sy;\n    }\n    if (pixel_offset_ey < 0)\n    {\n        pixel_offset_ey += th;\n        --offset_ey;\n    }\n    int64_t offset_min_x = sx_in_range ? offset_sx : 0;\n    int64_t offset_max_x = ex_in_range ? offset_ex : offset_boundary_x;\n    int64_t offset_min_y = sy_in_range ? offset_sy : 0;\n    int64_t offset_max_y = ey_in_range ? offset_ey : offset_boundary_y;\n\n    uint32_t stride_y = width / tw + !!(width % tw); // # of tiles in a row(y) in the ifd tile array as grid\n\n    int64_t start_index_y = offset_sy * stride_y;\n    int64_t start_index_min_y = offset_min_y * stride_y;\n    int64_t end_index_y = offset_ey * stride_y;\n    int64_t end_index_max_y = offset_max_y * stride_y;\n    int64_t boundary_index_y = offset_boundary_y * stride_y;\n\n\n    int tiff_file = tiff->file_handle_->fd;\n    uint64_t ifd_hash_value = ifd->hash_value_;\n\n    uint32_t dest_pixel_step_y = w * samples_per_pixel;\n    uint32_t nbytes_tw = tw * samples_per_pixel;\n\n\n    // TODO: Current implementation doesn't consider endianness so need to consider later\n    // TODO: Consider tile's depth tag.\n    // TODO: update the type of variables (index, index_y) : other function uses uint32_t\n    for (int64_t index_y = start_index_y; index_y <= end_index_y; index_y += stride_y)\n    {\n        uint32_t tile_pixel_offset_sy = (index_y == start_index_y) ? pixel_offset_sy : 0;\n        uint32_t tile_pixel_offset_ey = (index_y == end_index_y) ? pixel_offset_ey : (th - 1);\n        uint32_t dest_pixel_offset_len_y = tile_pixel_offset_ey - tile_pixel_offset_sy + 1;\n\n        uint32_t dest_pixel_index_x = 0;\n\n        int64_t index = index_y + offset_sx;\n        for (int64_t offset_x = offset_sx; offset_x <= offset_ex; ++offset_x, ++index)\n        {\n            PROF_SCOPED_RANGE(PROF_EVENT_P(ifd_read_region_tiles_boundary_iter, index));\n            uint64_t tiledata_offset = 0;\n            uint64_t tiledata_size = 0;\n\n            // Calculate a simple hash value for the tile index\n            uint64_t index_hash = ifd_hash_value ^ (static_cast<uint64_t>(index) | (static_cast<uint64_t>(index) << 32));\n\n            if (offset_x >= offset_min_x && offset_x <= offset_max_x && index_y >= start_index_min_y &&\n                index_y <= end_index_max_y)\n            {\n                tiledata_offset = static_cast<uint64_t>(ifd->image_piece_offsets_[index]);\n                tiledata_size = static_cast<uint64_t>(ifd->image_piece_bytecounts_[index]);\n            }\n\n            uint32_t tile_pixel_offset_x = (offset_x == offset_sx) ? pixel_offset_sx : 0;\n            uint32_t nbytes_tile_pixel_size_x = (offset_x == offset_ex) ?\n                                                    (pixel_offset_ex - tile_pixel_offset_x + 1) * samples_per_pixel :\n                                                    (tw - tile_pixel_offset_x) * samples_per_pixel;\n\n            uint32_t nbytes_tile_index_orig = (tile_pixel_offset_sy * tw + tile_pixel_offset_x) * samples_per_pixel;\n            uint32_t dest_pixel_index_orig = dest_pixel_index_x;\n\n            auto decode_func = [=, &image_cache]() {\n                PROF_SCOPED_RANGE(PROF_EVENT_P(ifd_read_region_tiles_boundary_task, index_hash));\n                uint32_t nbytes_tile_index = nbytes_tile_index_orig;\n                uint32_t dest_pixel_index = dest_pixel_index_orig;\n\n                if (tiledata_size > 0)\n                {\n                    bool copy_partial = false;\n                    uint32_t fixed_nbytes_tile_pixel_size_x = nbytes_tile_pixel_size_x;\n                    uint32_t fixed_tile_pixel_offset_ey = tile_pixel_offset_ey;\n\n                    if (offset_x == offset_boundary_x)\n                    {\n                        copy_partial = true;\n                        if (offset_x != offset_ex)\n                        {\n                            fixed_nbytes_tile_pixel_size_x =\n                                (pixel_offset_boundary_x - tile_pixel_offset_x + 1) * samples_per_pixel;\n                        }\n                        else\n                        {\n                            fixed_nbytes_tile_pixel_size_x =\n                                (std::min(pixel_offset_boundary_x, pixel_offset_ex) - tile_pixel_offset_x + 1) *\n                                samples_per_pixel;\n                        }\n                    }\n                    if (index_y == boundary_index_y)\n                    {\n                        copy_partial = true;\n                        if (index_y != end_index_y)\n                        {\n                            fixed_tile_pixel_offset_ey = pixel_offset_boundary_y;\n                        }\n                        else\n                        {\n                            fixed_tile_pixel_offset_ey = std::min(pixel_offset_boundary_y, pixel_offset_ey);\n                        }\n                    }\n\n                    uint8_t* tile_data = nullptr;\n                    std::unique_ptr<uint8_t, decltype(cucim_free)*> tile_raster =\n                        std::unique_ptr<uint8_t, decltype(cucim_free)*>(nullptr, cucim_free);\n\n                    if (loader && loader->batch_data_processor())\n                    {\n                        switch (compression_method)\n                        {\n                        case COMPRESSION_JPEG:\n                            break;\n                        default:\n                            throw std::runtime_error(\"Unsupported compression method\");\n                        }\n                        auto value = loader->wait_for_processing(index);\n                        if (!value) // if shutdown\n                        {\n                            return;\n                        }\n\n                        tile_data = static_cast<uint8_t*>(value->data);\n\n                        cudaError_t cuda_status;\n                        if (copy_partial)\n                        {\n                            uint32_t fill_gap_x = nbytes_tile_pixel_size_x - fixed_nbytes_tile_pixel_size_x;\n                            // Fill original, then fill white for remaining\n                            if (fill_gap_x > 0)\n                            {\n                                CUDA_ERROR(cudaMemcpy2D(\n                                    dest_start_ptr + dest_pixel_index, dest_pixel_step_y, tile_data + nbytes_tile_index,\n                                    nbytes_tw, fixed_nbytes_tile_pixel_size_x,\n                                    fixed_tile_pixel_offset_ey - tile_pixel_offset_sy + 1, cudaMemcpyDeviceToDevice));\n                                CUDA_ERROR(cudaMemset2D(dest_start_ptr + dest_pixel_index + fixed_nbytes_tile_pixel_size_x,\n                                                        dest_pixel_step_y, background_value, fill_gap_x,\n                                                        fixed_tile_pixel_offset_ey - tile_pixel_offset_sy + 1));\n                                dest_pixel_index +=\n                                    dest_pixel_step_y * (fixed_tile_pixel_offset_ey - tile_pixel_offset_sy + 1);\n                            }\n                            else\n                            {\n                                CUDA_ERROR(cudaMemcpy2D(\n                                    dest_start_ptr + dest_pixel_index, dest_pixel_step_y, tile_data + nbytes_tile_index,\n                                    nbytes_tw, fixed_nbytes_tile_pixel_size_x,\n                                    fixed_tile_pixel_offset_ey - tile_pixel_offset_sy + 1, cudaMemcpyDeviceToDevice));\n                                dest_pixel_index +=\n                                    dest_pixel_step_y * (fixed_tile_pixel_offset_ey - tile_pixel_offset_sy + 1);\n                            }\n\n                            CUDA_ERROR(cudaMemset2D(dest_start_ptr + dest_pixel_index, dest_pixel_step_y,\n                                                    background_value, nbytes_tile_pixel_size_x,\n                                                    tile_pixel_offset_ey - (fixed_tile_pixel_offset_ey + 1) + 1));\n                        }\n                        else\n                        {\n                            CUDA_ERROR(cudaMemcpy2D(dest_start_ptr + dest_pixel_index, dest_pixel_step_y,\n                                                    tile_data + nbytes_tile_index, nbytes_tw, nbytes_tile_pixel_size_x,\n                                                    tile_pixel_offset_ey - tile_pixel_offset_sy + 1,\n                                                    cudaMemcpyDeviceToDevice));\n                        }\n                    }\n                    else\n                    {\n                        auto key = image_cache.create_key(ifd_hash_value, index);\n                        image_cache.lock(index_hash);\n                        auto value = image_cache.find(key);\n                        if (value)\n                        {\n                            image_cache.unlock(index_hash);\n                            tile_data = static_cast<uint8_t*>(value->data);\n                        }\n                        else\n                        {\n                            // Lifetime of tile_data is same with `value`\n                            // : do not access this data when `value` is not accessible.\n                            if (cache_type != cucim::cache::CacheType::kNoCache)\n                            {\n                                tile_data = static_cast<uint8_t*>(image_cache.allocate(tile_raster_nbytes));\n                            }\n                            else\n                            {\n                                // Allocate temporary buffer for tile data\n                                tile_raster = std::unique_ptr<uint8_t, decltype(cucim_free)*>(\n                                    reinterpret_cast<uint8_t*>(cucim_malloc(tile_raster_nbytes)), cucim_free);\n                                tile_data = tile_raster.get();\n                            }\n                            {\n                                PROF_SCOPED_RANGE(PROF_EVENT(ifd_decompression));\n                                switch (compression_method)\n                                {\n                                case COMPRESSION_NONE:\n                                    cuslide::raw::decode_raw(tiff_file, nullptr, tiledata_offset, tiledata_size,\n                                                             &tile_data, tile_raster_nbytes, out_device);\n                                    break;\n                                case COMPRESSION_JPEG:\n                                    cuslide::jpeg::decode_libjpeg(tiff_file, nullptr, tiledata_offset, tiledata_size,\n                                                                  jpegtable_data, jpegtable_count, &tile_data,\n                                                                  out_device, jpeg_color_space);\n                                    break;\n                                case COMPRESSION_ADOBE_DEFLATE:\n                                case COMPRESSION_DEFLATE:\n                                    cuslide::deflate::decode_deflate(tiff_file, nullptr, tiledata_offset, tiledata_size,\n                                                                     &tile_data, tile_raster_nbytes, out_device);\n                                    break;\n                                case cuslide::jpeg2k::kAperioJpeg2kYCbCr: // 33003\n                                    cuslide::jpeg2k::decode_libopenjpeg(tiff_file, nullptr, tiledata_offset,\n                                                                        tiledata_size, &tile_data, tile_raster_nbytes,\n                                                                        out_device, cuslide::jpeg2k::ColorSpace::kSYCC);\n                                    break;\n                                case cuslide::jpeg2k::kAperioJpeg2kRGB: // 33005\n                                    cuslide::jpeg2k::decode_libopenjpeg(tiff_file, nullptr, tiledata_offset,\n                                                                        tiledata_size, &tile_data, tile_raster_nbytes,\n                                                                        out_device, cuslide::jpeg2k::ColorSpace::kRGB);\n                                    break;\n                                case COMPRESSION_LZW:\n                                    cuslide::lzw::decode_lzw(tiff_file, nullptr, tiledata_offset, tiledata_size,\n                                                             &tile_data, tile_raster_nbytes, out_device);\n                                    // Apply unpredictor\n                                    //   1: none, 2: horizontal differencing, 3: floating point predictor\n                                    //   https://www.adobe.io/content/dam/udp/en/open/standards/tiff/TIFF6.pdf\n                                    if (predictor == 2)\n                                    {\n                                        cuslide::lzw::horAcc8(tile_data, tile_raster_nbytes, nbytes_tw);\n                                    }\n                                    break;\n                                default:\n                                    throw std::runtime_error(\"Unsupported compression method\");\n                                }\n                            }\n                            value = image_cache.create_value(tile_data, tile_raster_nbytes);\n                            image_cache.insert(key, value);\n                            image_cache.unlock(index_hash);\n                        }\n                        if (copy_partial)\n                        {\n                            uint32_t fill_gap_x = nbytes_tile_pixel_size_x - fixed_nbytes_tile_pixel_size_x;\n                            // Fill original, then fill white for remaining\n                            if (fill_gap_x > 0)\n                            {\n                                for (uint32_t ty = tile_pixel_offset_sy; ty <= fixed_tile_pixel_offset_ey;\n                                     ++ty, dest_pixel_index += dest_pixel_step_y, nbytes_tile_index += nbytes_tw)\n                                {\n                                    memcpy(dest_start_ptr + dest_pixel_index, tile_data + nbytes_tile_index,\n                                           fixed_nbytes_tile_pixel_size_x);\n                                    memset(dest_start_ptr + dest_pixel_index + fixed_nbytes_tile_pixel_size_x,\n                                           background_value, fill_gap_x);\n                                }\n                            }\n                            else\n                            {\n                                for (uint32_t ty = tile_pixel_offset_sy; ty <= fixed_tile_pixel_offset_ey;\n                                     ++ty, dest_pixel_index += dest_pixel_step_y, nbytes_tile_index += nbytes_tw)\n                                {\n                                    memcpy(dest_start_ptr + dest_pixel_index, tile_data + nbytes_tile_index,\n                                           fixed_nbytes_tile_pixel_size_x);\n                                }\n                            }\n\n                            for (uint32_t ty = fixed_tile_pixel_offset_ey + 1; ty <= tile_pixel_offset_ey;\n                                 ++ty, dest_pixel_index += dest_pixel_step_y)\n                            {\n                                memset(dest_start_ptr + dest_pixel_index, background_value, nbytes_tile_pixel_size_x);\n                            }\n                        }\n                        else\n                        {\n                            for (uint32_t ty = tile_pixel_offset_sy; ty <= tile_pixel_offset_ey;\n                                 ++ty, dest_pixel_index += dest_pixel_step_y, nbytes_tile_index += nbytes_tw)\n                            {\n                                memcpy(dest_start_ptr + dest_pixel_index, tile_data + nbytes_tile_index,\n                                       nbytes_tile_pixel_size_x);\n                            }\n                        }\n                    }\n                }\n                else\n                {\n\n                    if (out_device.type() == cucim::io::DeviceType::kCPU)\n                    {\n                        for (uint32_t ty = tile_pixel_offset_sy; ty <= tile_pixel_offset_ey;\n                             ++ty, dest_pixel_index += dest_pixel_step_y, nbytes_tile_index += nbytes_tw)\n                        {\n                            // Set (255,255,255)\n                            memset(dest_start_ptr + dest_pixel_index, background_value, nbytes_tile_pixel_size_x);\n                        }\n                    }\n                    else\n                    {\n                        cudaError_t cuda_status;\n                        CUDA_ERROR(cudaMemset2D(dest_start_ptr + dest_pixel_index, dest_pixel_step_y, background_value,\n                                                nbytes_tile_pixel_size_x, tile_pixel_offset_ey - tile_pixel_offset_sy));\n                    }\n                }\n            };\n\n            if (loader && *loader)\n            {\n                loader->enqueue(std::move(decode_func),\n                                cucim::loader::TileInfo{ location_index, index, tiledata_offset, tiledata_size });\n            }\n            else\n            {\n                decode_func();\n            }\n\n            dest_pixel_index_x += nbytes_tile_pixel_size_x;\n        }\n        dest_start_ptr += dest_pixel_step_y * dest_pixel_offset_len_y;\n    }\n    return true;\n}\n\n} // namespace cuslide::tiff\n\n\n// Hidden methods for benchmarking.\n\n#include <fmt/format.h>\n#include <langinfo.h>\n#include <iostream>\n#include <fstream>\n\nnamespace cuslide::tiff\n{\nvoid IFD::write_offsets_(const char* file_path)\n{\n    std::ofstream offsets(fmt::format(\"{}.offsets\", file_path), std::ios::out | std::ios::binary | std::ios::trunc);\n    std::ofstream bytecounts(fmt::format(\"{}.bytecounts\", file_path), std::ios::out | std::ios::binary | std::ios::trunc);\n\n    offsets.write(reinterpret_cast<char*>(&image_piece_count_), sizeof(image_piece_count_));\n    bytecounts.write(reinterpret_cast<char*>(&image_piece_count_), sizeof(image_piece_count_));\n    for (uint32_t i = 0; i < image_piece_count_; i++)\n    {\n        offsets.write(reinterpret_cast<char*>(&image_piece_offsets_[i]), sizeof(image_piece_offsets_[i]));\n        bytecounts.write(reinterpret_cast<char*>(&image_piece_bytecounts_[i]), sizeof(image_piece_bytecounts_[i]));\n    }\n    bytecounts.close();\n    offsets.close();\n}\n\n} // namespace cuslide::tiff\n",
                "name": "ifd.cpp",
                "path": "cpp/plugins/cucim.kit.cuslide/src/cuslide/tiff/ifd.cpp",
                "url": "/github.com/rapidsai/cucim/-/blob/cpp/plugins/cucim.kit.cuslide/src/cuslide/tiff/ifd.cpp"
            },
            "lineMatches": [
                {
                    "limitHit": false,
                    "lineNumber": 131,
                    "offsetAndLengths": [
                        [
                            10,
                            18
                        ]
                    ],
                    "preview": "    //    TIFFPrintDirectory(tif, stdout, TIFFPRINT_STRIPS);"
                }
            ],
            "repository": {
                "name": "github.com/rapidsai/cucim",
                "url": "/github.com/rapidsai/cucim"
            }
        }
    ],
    "LimitHit": false,
    "Cloning": [],
    "Missing": [],
    "Timedout": [],
    "ResultCount": 72,
    "ElapsedMilliseconds": 4233,
    "Alert": {
        "Title": "",
        "Description": "",
        "ProposedQueries": null
    }
}