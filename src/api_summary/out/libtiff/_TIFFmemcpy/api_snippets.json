[
    "HANDLE TIFFRGBA2DIB(TIFFDibImage *dib, uint32_t *raster)\n{\n    void *pDIB = 0;\n    TIFFRGBAImage *img = &dib->tif;\n\n    uint32_t imageLength;\n    uint32_t imageWidth;\n    uint16_t BitsPerSample;\n    uint16_t SamplePerPixel;\n    uint32_t RowsPerStrip;\n    uint16_t PhotometricInterpretation;\n\n    BITMAPINFOHEADER bi;\n    int dwDIBSize;\n\n    TIFFGetField(img->tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n    TIFFGetField(img->tif, TIFFTAG_IMAGELENGTH, &imageLength);\n    TIFFGetField(img->tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n    TIFFGetField(img->tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);\n    TIFFGetField(img->tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\n    TIFFGetField(img->tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\n\n    if (BitsPerSample == 1 && SamplePerPixel == 1 && dib->dibinstalled)\n    { // bilevel\n        bi.biSize = sizeof(BITMAPINFOHEADER);\n        bi.biWidth = imageWidth;\n        bi.biHeight = imageLength;\n        bi.biPlanes = 1; // always\n        bi.biBitCount = 1;\n        bi.biCompression = BI_RGB;\n        bi.biSizeImage = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter = 0;\n        bi.biYPelsPerMeter = 0;\n        bi.biClrUsed = 0;      //  must be zero for RGB compression (none)\n        bi.biClrImportant = 0; // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize(&bi);\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr(GHND, dwDIBSize);\n        if (pDIB == 0)\n        {\n            return (NULL);\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER *)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD *pRgbq = (RGBQUAD *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed = 0;\n        pRgbq[0].rgbBlue = 0;\n        pRgbq[0].rgbGreen = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed = 255;\n        pRgbq[1].rgbBlue = 255;\n        pRgbq[1].rgbGreen = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        // PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr(\n            (BITMAPINFOHEADER *)pDIB); //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int sizeWords = bi.biSizeImage / 4;\n        RGBQUAD *rgbDib = (RGBQUAD *)pbiBits;\n        long *rgbTif = (long *)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n    //  For now just always default to the RGB 32 bit form. // save as 32 bit\n    //  for simplicity\n    else if (true /*BitsPerSample == 8 && SamplePerPixel == 3*/)\n    { // 24 bit color\n\n        bi.biSize = sizeof(BITMAPINFOHEADER);\n        bi.biWidth = imageWidth;\n        bi.biHeight = imageLength;\n        bi.biPlanes = 1; // always\n        bi.biBitCount = 32;\n        bi.biCompression = BI_RGB;\n        bi.biSizeImage = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter = 0;\n        bi.biYPelsPerMeter = 0;\n        bi.biClrUsed = 0;      //  must be zero for RGB compression (none)\n        bi.biClrImportant = 0; // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize(&bi);\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr(GHND, dwDIBSize);\n        if (pDIB == 0)\n        {\n            return (NULL);\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER *)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD *pRgbq = (RGBQUAD *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        // PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int sizeWords = bi.biSizeImage / 4;\n        RGBQUAD *rgbDib = (RGBQUAD *)pbiBits;\n        long *rgbTif = (long *)raster;\n\n        // Swap the byte order while copying\n        for (int i = 0; i < sizeWords; ++i)\n        {\n            rgbDib[i].rgbRed = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}",
    "DECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img->samplesperpixel;\n\n    (void)y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char *ucp = (u_char *)cp;\n\n    /* Convert 'w' to bytes from pixels (rounded up) */\n    w = (w + 7) / 8;\n\n    while (h-- > 0)\n    {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- > 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}",
    "HANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = &dib->tif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img->tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n    TIFFGetField(img->tif, TIFFTAG_IMAGELENGTH, &imageLength);\n    TIFFGetField(img->tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n    TIFFGetField(img->tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);\n    TIFFGetField(img->tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\n    TIFFGetField(img->tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 && SamplePerPixel == 1 && dib->dibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 && SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i < sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}",
    "DECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img->samplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- > 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- > 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}",
    "static int\nFax4Encode(TIFF* tif, tidata_t bp, tsize_t cc, tsample_t s, int debug_max_steps)\n   {\n   Fax3EncodeState *sp = EncoderState(tif);\n   state_info state;\n   int bad;\n   int blank;\n   int blank_count = 0;\n   byte *ptr, *end;\n   int step = 0, nbits;\n   int type;\n\n   (void) s;\n   debug2 ((\"Fax4Encode: rowbytes=%d\\n\", sp->b.rowbytes));\n   while ((long)cc > 0 && step < debug_max_steps)\n      {\n      debug3 ((\"\\n^%d: \", tif->tif_row));\n\n      blank = 1;\n      end = bp + sp->b.rowbytes;\n      for (ptr = bp; ptr < end; ptr++)\n         if (*ptr)\n            {\n            debug3 ((\"   data[0x%x]=0x%x - not blank\\n\", ptr - bp, *ptr));\n            blank = 0;\n            break;\n            }\n      if (blank)\n         {\n         if (blank_count == 63)\n            {\n            step++;\n            Fax3PutBits (tif, 0xc0 | blank_count, 8);  // write 8 bits\n            blank_count = 0;\n            }\n         memset (sp->refline, '\\0', sp->b.rowbytes); //!\n         blank_count++;\n         }\n\n      if (!blank || cc == 1)  // not blank, or last line\n         {\n         // write out blank lines\n         if (blank_count)\n            {\n            step++;\n            Fax3PutBits (tif, 0xc0 | blank_count, 8);  // write 8 bits\n            blank_count = 0;\n            }\n         }\n\n      save_state (&state, tif, sp);\n      if (!blank)\n         {\n         step++;\n         type = ENCODE_comp;\n\n         // write the 2-bit code\n         Fax3PutBits (tif, ENCODE_comp, 2);  // 2 means compressed data\n\n         tif->bit_count = 0;\n         if (!Fax3Encode2DRow(tif, bp, sp->refline, sp->b.rowpixels, &bad)) //!\n            return (0);\n\n         debug3 ((\"bits_sent = 0x%x\\n\", tif->bit_count));\n\n         // work out how many bits would be sent in single mode\n         nbits = try_single (tif, bp, sp->b.rowbytes, false);\n         debug3 ((\"single mode would use 0x%x\\n\", nbits));\n\n         if (nbits - 18 < tif->bit_count)\n            type = ENCODE_single;\n         else\n            nbits = tif->bit_count;\n\n         if (nbits > (int)sp->b.rowpixels)\n            type = ENCODE_uncomp;\n\n         switch (type)\n            {\n            case ENCODE_comp :\n               // already done\n               break;\n\n            case ENCODE_uncomp :\n               debug2 ((\"**************** to big: writing uncompressed\\n\"));\n               // write uncompressed\n               restore_state (&state, tif, sp);\n               step++;\n               Fax3PutBits (tif, type, 2);  // 0 means uncompressed data\n               if (sp->bit != 8)\n                  Fax3FlushBits(tif, sp);\n               memcpy (tif->tif_rawcp, bp, sp->b.rowbytes);\n               tif->tif_rawcp += sp->b.rowbytes;\n               tif->tif_rawcc += sp->b.rowbytes;\n               //       sp->refline [sp->b.rowbytes] = 0;   //!\n               break;\n\n            case ENCODE_single :\n               restore_state (&state, tif, sp);\n               step++;\n               Fax3PutBits (tif, type, 2);  // 1 means single data\n               if (sp->bit != 8)\n                  Fax3FlushBits(tif, sp);\n               try_single (tif, bp, sp->b.rowbytes, true);\n               break;\n            }\n         //            _TIFFmemcpy(sp->refline, bp, sp->b.rowbytes + 1); //!\n         _TIFFmemcpy(sp->refline, bp, sp->b.rowbytes); //!\n         }\n//              bp += sp->b.rowbytes;\n      bp += sp->b.stride;\n//              cc -= sp->b.rowbytes;\n      cc--;\n      if (cc != 0)\n         tif->tif_row++;\n//         debug3 ((\"\\n\"));\n      }\n   debug2 ((\"Fax4Encode: done\\n\"));\n   return (1);\n   }",
    "std::unique_ptr<TiffTile> TiffFile::tile(uint32_t tileIndex) {\n  if (tiffFile_ == nullptr) {\n    return nullptr;\n  }\n  TileReadBuffer readBuffer(tileReadBufSize_);\n  if (readBuffer.buffer_ == nullptr) {\n    return nullptr;\n  }\n  uint32_t bufferSize = TIFFReadRawTile(tiffFile_,\n                                        static_cast<ttile_t>(tileIndex),\n                                        readBuffer.buffer_,\n                                        tileReadBufSize_);\n  if (bufferSize == 0) {\n    return nullptr;\n  }\n  std::unique_ptr<uint8_t[]> mem_buffer =\n                                       std::make_unique<uint8_t[]>(bufferSize);\n  if (mem_buffer == nullptr) {\n    return nullptr;\n  }\n  _TIFFmemcpy(mem_buffer.get(), readBuffer.buffer_, bufferSize);\n  return std::make_unique<TiffTile>(directory(directoryLevel()), tileIndex,\n                                    std::move(mem_buffer), bufferSize);\n}",
    "jint * NativeDecoder::getSampledRasterFromStrip(int inSampleSize, int *bitmapwidth, int *bitmapheight) {\n\n    //init signal handler for catch SIGSEGV error that could be raised in libtiff\n    struct sigaction act;\n    memset(&act, 0, sizeof(act));\n    sigemptyset(&act.sa_mask);\n    act.sa_sigaction = stripErrorHandler;\n    act.sa_flags = SA_SIGINFO | SA_ONSTACK;\n    if(sigaction(SIGSEGV, &act, 0) < 0) {\n        LOGE(\"Can\\'t setup signal handler. Working without errors catching mechanism\");\n    }\n\n    LOGII(\"width\", origwidth);\n    LOGII(\"height\", origheight);\n\n    jint *pixels = NULL;\n    *bitmapwidth = origwidth / inSampleSize;\n    *bitmapheight = origheight / inSampleSize;\n    uint32 pixelsBufferSize = *bitmapwidth * *bitmapheight;\n    int origImageBufferSize = origwidth * origheight;\n\n    LOGII(\"new width\", *bitmapwidth);\n    LOGII(\"new height\", *bitmapheight);\n\n    uint32 stripSize = TIFFStripSize (image);\n    uint32 stripMax = TIFFNumberOfStrips (image);\n    LOGII(\"strip size \", stripSize);\n    LOGII(\"stripMax  \", stripMax);\n    int rowPerStrip = -1;\n    TIFFGetField(image, TIFFTAG_ROWSPERSTRIP, &rowPerStrip);\n    LOGII(\"rowsperstrip\", rowPerStrip);\n\n    unsigned long estimateMem = 0;\n    estimateMem += (sizeof(jint) * pixelsBufferSize); //buffer for decoded pixels\n    estimateMem += (origwidth * sizeof(uint32)); //work line for rotate strip\n    estimateMem += (origwidth * rowPerStrip * sizeof (uint32) * 2); //current and next strips\n    estimateMem += (sizeof(jint) * origwidth * 2); //bottom and top lines for reading pixel(matrixBottomLine, matrixTopLine)\n    LOGII(\"estimateMem\", estimateMem);\n    if (estimateMem > availableMemory) {\n        if (throwException) {\n            throw_not_enought_memory_exception(env, availableMemory, estimateMem);\n        }\n        return NULL;\n    }\n\n    pixels = (jint *) malloc(sizeof(jint) * pixelsBufferSize);\n    if (pixels == NULL) {\n        LOGE(\"Can\\'t allocate memory for temp buffer\");\n        return NULL;\n    }\n\n    uint32* work_line_buf = (uint32 *)_TIFFmalloc(origwidth * sizeof(uint32));\n\n    uint32* raster;\n    uint32* rasterForBottomLine; // in this raster copy next strip for getting bottom line in matrix color selection\n    if (rowPerStrip == -1 && stripMax == 1) {\n            raster = (uint32 *)_TIFFmalloc(origImageBufferSize * sizeof (uint32));\n            rasterForBottomLine = (uint32 *)_TIFFmalloc(origImageBufferSize * sizeof (uint32));\n    } else {\n            raster = (uint32 *)_TIFFmalloc(origwidth * rowPerStrip * sizeof (uint32));\n            rasterForBottomLine = (uint32 *)_TIFFmalloc(origwidth * rowPerStrip * sizeof (uint32));\n    }\n    if (rowPerStrip == -1) {\n            rowPerStrip = origheight;\n    }\n\n    int writedLines = 0;\n    int nextStripOffset = 0;\n    int globalLineCounter = 0;\n\n    unsigned int *matrixTopLine = (uint32 *) malloc(sizeof(jint) * origwidth);\n    unsigned int *matrixBottomLine = (uint32 *) malloc(sizeof(jint) * origwidth);\n\n    int isSecondRasterExist = 0;\n    int ok = 1;\n    uint32 rows_to_write = 0;\n\n    //check for error\n    if (setjmp(NativeDecoder::strip_buf)) {\n        if (raster) {\n            _TIFFfree(raster);\n            raster = NULL;\n        }\n        if (rasterForBottomLine) {\n            _TIFFfree(rasterForBottomLine);\n            rasterForBottomLine = NULL;\n        }\n        if (matrixTopLine) {\n            _TIFFfree(matrixTopLine);\n            matrixTopLine = NULL;\n        }\n        if (matrixBottomLine) {\n            _TIFFfree(matrixBottomLine);\n            matrixBottomLine = NULL;\n        }\n\n        const char * err = \"Caught SIGSEGV signal(Segmentation fault or invalid memory reference)\";\n        LOGE(err);\n        if (throwException) {\n            throwDecodeFileException(err);\n        }\n\n        return NULL;\n    }\n\n    for (int i = 0; i < stripMax*rowPerStrip; i += rowPerStrip) {\n\n            sendProgress(i * origwidth, progressTotal);\n\n            //if second raster is exist - copy it to work raster end decode next strip\n            if (isSecondRasterExist) {\n                _TIFFmemcpy(raster, rasterForBottomLine, origwidth * rowPerStrip * sizeof (uint32));\n\n                //If next strip is exist - decode it, invert lines\n                if (i + rowPerStrip < stripMax*rowPerStrip) {\n                    TIFFReadRGBAStrip(image, i+rowPerStrip, rasterForBottomLine);\n                    isSecondRasterExist = 1;\n\n                    rows_to_write = 0;\n                    if ( i + rowPerStrip * 2 > origheight )\n                        rows_to_write = origheight - i - rowPerStrip;\n                    else\n                        rows_to_write = rowPerStrip;\n\n                    if (origorientation <= 4) {\n                        for (int line = 0; line < rows_to_write / 2; line++) {\n                            unsigned int  *top_line, *bottom_line;\n\n                            top_line = rasterForBottomLine + origwidth * line;\n                            bottom_line = rasterForBottomLine + origwidth * (rows_to_write - line - 1);\n\n                            _TIFFmemcpy(work_line_buf, top_line, sizeof(unsigned int) * origwidth);\n                            _TIFFmemcpy(top_line, bottom_line, sizeof(unsigned int) * origwidth);\n                            _TIFFmemcpy(bottom_line, work_line_buf, sizeof(unsigned int) * origwidth);\n                        }\n                    }\n                } else {\n                    isSecondRasterExist = 0;\n                }\n            } else {\n                //if second raster is not exist - first processing - read first and second raster\n                 TIFFReadRGBAStrip(image, i, raster);\n                 //invert lines, because libtiff origin is bottom left instead of top left\n                 rows_to_write = 0;\n                 if( i + rowPerStrip > origheight )\n                    rows_to_write = origheight - i;\n                 else\n                    rows_to_write = rowPerStrip;\n\n                 if (origorientation <= 4) {\n                     for (int line = 0; line < rows_to_write / 2; line++) {\n                         unsigned int  *top_line, *bottom_line;\n\n                         top_line = raster + origwidth * line;\n                         bottom_line = raster + origwidth * (rows_to_write - line - 1);\n\n                         _TIFFmemcpy(work_line_buf, top_line, sizeof(unsigned int) * origwidth);\n                         _TIFFmemcpy(top_line, bottom_line, sizeof(unsigned int) * origwidth);\n                         _TIFFmemcpy(bottom_line, work_line_buf, sizeof(unsigned int) * origwidth);\n                     }\n                 }\n\n                 //if next strip is exist - read it and invert lines\n                 if (i + rowPerStrip < origheight) {\n                    TIFFReadRGBAStrip(image, i+rowPerStrip, rasterForBottomLine);\n                    isSecondRasterExist = 1;\n\n                    //invert lines, because libtiff origin is bottom left instead of top left\n                    rows_to_write = 0;\n                    if ( i + rowPerStrip * 2 > origheight )\n                        rows_to_write = origheight - i - rowPerStrip;\n                    else\n                        rows_to_write = rowPerStrip;\n                    if (origorientation <= 4) {\n                        for (int line = 0; line < rows_to_write / 2; line++) {\n                            unsigned int  *top_line, *bottom_line;\n\n                            top_line = rasterForBottomLine + origwidth * line;\n                            bottom_line = rasterForBottomLine + origwidth * (rows_to_write - line - 1);\n\n                            _TIFFmemcpy(work_line_buf, top_line, sizeof(unsigned int) * origwidth);\n                            _TIFFmemcpy(top_line, bottom_line, sizeof(unsigned int) * origwidth);\n                            _TIFFmemcpy(bottom_line, work_line_buf, sizeof(unsigned int) * origwidth);\n                        }\n                    }\n                 }\n\n            }\n\n            if (inSampleSize == 1) {\n                int byteToCopy = 0;\n                if (i + rowPerStrip < origheight) {\n                    byteToCopy = sizeof(unsigned int) * rowPerStrip * origwidth;\n                } else {\n                    byteToCopy = sizeof(unsigned int) * rows_to_write * origwidth;\n                }\n                int position = i * origwidth;\n                memcpy(&pixels[position], raster, byteToCopy);\n                //sendProgress(position, progressTotal);\n            } else {\n                if (isSecondRasterExist) {\n                    _TIFFmemcpy(matrixBottomLine, rasterForBottomLine /*+ lineAddrToCopyBottomLine * origwidth*/, sizeof(unsigned int) * origwidth);\n                }\n                 int workWritedLines = writedLines;\n                 for (int resBmpY = workWritedLines, workY = 0; resBmpY < *bitmapheight && workY < rowPerStrip; /*wj++,*/ workY ++/*= inSampleSize*/) {\n\n                 if (checkStop()) {\n                     if (raster) {\n                         _TIFFfree(raster);\n                         raster = NULL;\n                     }\n                     if (rasterForBottomLine) {\n                         _TIFFfree(rasterForBottomLine);\n                         rasterForBottomLine = NULL;\n                     }\n                     if (matrixTopLine) {\n                         _TIFFfree(matrixTopLine);\n                         matrixTopLine = NULL;\n                     }\n                     if (matrixBottomLine) {\n                         _TIFFfree(matrixBottomLine);\n                         matrixBottomLine = NULL;\n                     }\n                     LOGI(\"Thread stopped\");\n                     return NULL;\n                 }\n\n                    // if total line of source image is equal to inSampleSize*N then process this line\n                    if (globalLineCounter % inSampleSize == 0) {\n                        for (int resBmpX = 0, workX = 0; resBmpX < *bitmapwidth; resBmpX++, workX += inSampleSize) {\n\n                            //Apply filter to pixel\n                            jint crPix = raster[workY * origwidth + workX];\n                            int sum = 1;\n\n\n                            int alpha = colorMask & crPix >> 24;\n                            int red = colorMask & crPix >> 16;\n                            int green = colorMask & crPix >> 8;\n                            int blue = colorMask & crPix;\n\n\n                            //topleft\n                            if (workX - 1 >= 0 && workY - 1 >= 0) {\n                                crPix = raster[(workY - 1) * origwidth + workX - 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            } else if (workX - 1 >= 0 && workY - 1 == -1 && globalLineCounter > 0) {\n                                crPix = matrixTopLine[workX - 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            }\n                            //top\n                            if (workY - 1 >= 0) {\n                                crPix = raster[(workY - 1) * origwidth + workX];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            } else if (workY - 1 == -1 && globalLineCounter > 0) {\n                                crPix = matrixTopLine[workX];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            }\n\n                            // topright\n                            if (workX + 1 < origwidth && workY - 1 >= 0) {\n                                crPix = raster[(workY - 1) * origwidth + workX + 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            } else if (workX + 1 < origwidth && workY - 1 == -1 && globalLineCounter > 0) {\n                                crPix = matrixTopLine[workX + 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            }\n\n                            //right\n                            if (workX + 1 < origwidth) {\n                                crPix = raster[workY * origwidth + workX + 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            }\n\n                            //bottomright\n                            if (workX + 1 < origwidth && workY + 1 < rowPerStrip) {\n                                crPix = raster[(workY + 1) * origwidth + workX + 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            } else if (workX + 1 < origwidth && workY + 1 == rowPerStrip && isSecondRasterExist) {\n                                crPix = matrixBottomLine[workX + 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            }\n\n                            //bottom\n                            if (workY + 1 < rowPerStrip) {\n                                crPix = raster[(workY + 1) * origwidth + workX + 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            } else if (workY + 1 == rowPerStrip && isSecondRasterExist) {\n                                crPix = matrixBottomLine[workX + 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            }\n\n                            //bottomleft\n                            if (workX - 1 >= 0 && workY + 1 < rowPerStrip) {\n                                crPix = raster[(workY + 1) * origwidth + workX - 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            } else if (workX - 1 >= 0 && workY + 1 == rowPerStrip  && isSecondRasterExist) {\n                                crPix = matrixBottomLine[workX - 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            }\n\n\n                            //left\n                            if (workX - 1 >= 0) {\n                                crPix = raster[workY * origwidth + workX - 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            }\n\n                            red /= sum;\n                            if (red > 255) red = 255;\n                            if (red < 0) red = 0;\n\n                            green /= sum;\n                            if (green > 255) green = 255;\n                            if (green < 0) green = 0;\n\n                            blue /= sum;\n                            if (blue > 255) blue = 255;\n                            if (blue < 0) blue = 0;\n\n                            alpha /= sum;///= sum;\n                            if (alpha > 255) alpha = 255;\n                            if (alpha < 0) alpha = 0;\n\n                            crPix = (alpha << 24) | (red << 16) | (green << 8) | (blue);\n\n                            pixels[resBmpY * *bitmapwidth + resBmpX] = crPix;\n                        }\n                        //if line was processed - increment counter of lines that was writed to result image\n                        writedLines++;\n                        //and incremetncounter of current Y for writing\n                        resBmpY++;\n                    }\n                    if (workY == rowPerStrip - 1 && i + rowPerStrip < origheight) {\n                        _TIFFmemcpy(matrixTopLine, raster + workY * origwidth, sizeof(unsigned int) * origwidth);\n                    }\n                    //incremetn global source image line counter\n                    globalLineCounter++;\n\n                }\n            }\n        }\n        LOGI(\"Decoding finished. Free memmory\");\n\n        //Close Buffers\n        if (raster) {\n            _TIFFfree(raster);\n            raster = NULL;\n        }\n\n        if (rasterForBottomLine) {\n            _TIFFfree(rasterForBottomLine);\n            rasterForBottomLine = NULL;\n        }\n\n        if (matrixTopLine) {\n            _TIFFfree(matrixTopLine);\n            matrixTopLine = NULL;\n        }\n\n        if (matrixBottomLine) {\n            _TIFFfree(matrixBottomLine);\n            matrixBottomLine = NULL;\n        }\n\n        if (useOrientationTag) {\n            uint32 buf;\n            //fixOrientation(pixels, pixelsBufferSize, *bitmapwidth, *bitmapheight);\n            switch(origorientation) {\n                 case ORIENTATION_TOPLEFT:\n                 case ORIENTATION_TOPRIGHT:\n                    break;\n                 case ORIENTATION_BOTRIGHT:\n                 case ORIENTATION_BOTLEFT:\n                    flipPixelsVertical(*bitmapwidth, *bitmapheight, pixels);\n                    break;\n                 case ORIENTATION_LEFTTOP:\n                    rotateRaster(pixels, 90, bitmapwidth, bitmapheight);\n                    flipPixelsHorizontal(*bitmapwidth, *bitmapheight, pixels);\n                    buf = *bitmapwidth;\n                    *bitmapwidth = *bitmapheight;\n                    *bitmapheight = buf;\n                    break;\n                 case ORIENTATION_RIGHTTOP:\n                    rotateRaster(pixels, 270, bitmapwidth, bitmapheight);\n                    flipPixelsHorizontal(*bitmapwidth, *bitmapheight, pixels);\n                    buf = *bitmapwidth;\n                    *bitmapwidth = *bitmapheight;\n                    *bitmapheight = buf;\n                    break;\n                 case ORIENTATION_RIGHTBOT:\n                    rotateRaster(pixels, 90, bitmapwidth, bitmapheight);\n                    buf= *bitmapwidth;\n                    *bitmapwidth = *bitmapheight;\n                    *bitmapheight = buf;\n                    break;\n                 case ORIENTATION_LEFTBOT:\n                    rotateRaster(pixels, 270, bitmapwidth, bitmapheight);\n                    buf = *bitmapwidth;\n                    *bitmapwidth = *bitmapheight;\n                    *bitmapheight = buf;\n                    break;\n            }\n\n        } else if (origorientation == 2 || origorientation == 3 || origorientation == 6 || origorientation == 7) {\n            flipPixelsHorizontal(*bitmapwidth, *bitmapheight, pixels);\n        }\n\n        return pixels;\n}",
    "jint * NativeDecoder::getSampledRasterFromStripWithBounds(int inSampleSize, int *bitmapwidth, int *bitmapheight) {\n\n    //init signal handler for catch SIGSEGV error that could be raised in libtiff\n    struct sigaction act;\n    memset(&act, 0, sizeof(act));\n    sigemptyset(&act.sa_mask);\n    act.sa_sigaction = stripErrorHandler;\n    act.sa_flags = SA_SIGINFO | SA_ONSTACK;\n    if(sigaction(SIGSEGV, &act, 0) < 0) {\n        LOGE(\"Can\\'t setup signal handler. Working without errors catching mechanism\");\n    }\n\n    LOGII(\"width\", origwidth);\n    LOGII(\"height\", origheight);\n\n    jint *pixels = NULL;\n    *bitmapwidth = origwidth / inSampleSize;\n    *bitmapheight = boundHeight / inSampleSize;//origheight / inSampleSize;\n    uint32 pixelsBufferSize = *bitmapwidth * *bitmapheight;\n    int origImageBufferSize = origwidth * origheight;\n\n    LOGII(\"new width\", *bitmapwidth);\n    LOGII(\"new height\", *bitmapheight);\n\n    uint32 stripSize = TIFFStripSize (image);\n    uint32 stripMax = TIFFNumberOfStrips (image);\n    LOGII(\"strip size \", stripSize);\n    LOGII(\"stripMax  \", stripMax);\n    int rowPerStrip = -1;\n    TIFFGetField(image, TIFFTAG_ROWSPERSTRIP, &rowPerStrip);\n    LOGII(\"rowsperstrip\", rowPerStrip);\n\n    unsigned long estimateMem = 0;\n    estimateMem += (sizeof(jint) * pixelsBufferSize); //temp buffer for decoded pixels\n    estimateMem += (sizeof(jint) * (boundWidth / inSampleSize) * (boundHeight/inSampleSize)); //final buffer that will store original image\n    estimateMem += (origwidth * sizeof(uint32)); //work line for rotate strip\n    estimateMem += (origwidth * rowPerStrip * sizeof (uint32) * 2); //current and next strips\n    estimateMem += (sizeof(jint) * origwidth * 2); //bottom and top lines for reading pixel(matrixBottomLine, matrixTopLine)\n    LOGII(\"estimateMem\", estimateMem);\n    if (estimateMem > availableMemory) {\n        if (throwException) {\n            throw_not_enought_memory_exception(env, availableMemory, estimateMem);\n        }\n        return NULL;\n    }\n\n    progressTotal = pixelsBufferSize + (boundWidth/inSampleSize) * (boundHeight / inSampleSize);\n    sendProgress(0, progressTotal);\n    jlong processedProgress = 0;\n\n    pixels = (jint *) malloc(sizeof(jint) * pixelsBufferSize);\n    if (pixels == NULL) {\n        LOGE(\"Can\\'t allocate memory for temp buffer\");\n        return NULL;\n    }\n\n    uint32* work_line_buf = (uint32 *)_TIFFmalloc(origwidth * sizeof(uint32));\n\n    uint32* raster;\n    uint32* rasterForBottomLine; // in this raster copy next strip for getting bottom line in matrix color selection\n    if (rowPerStrip == -1 && stripMax == 1) {\n            raster = (uint32 *)_TIFFmalloc(origImageBufferSize * sizeof (uint32));\n            rasterForBottomLine = (uint32 *)_TIFFmalloc(origImageBufferSize * sizeof (uint32));\n    } else {\n            raster = (uint32 *)_TIFFmalloc(origwidth * rowPerStrip * sizeof (uint32));\n            rasterForBottomLine = (uint32 *)_TIFFmalloc(origwidth * rowPerStrip * sizeof (uint32));\n    }\n    if (rowPerStrip == -1) {\n            rowPerStrip = origheight;\n    }\n\n    int writedLines = 0;\n    int nextStripOffset = 0;\n    int globalLineCounter = 0;\n\n    unsigned int *matrixTopLine = (uint32 *) malloc(sizeof(jint) * origwidth);\n    unsigned int *matrixBottomLine = (uint32 *) malloc(sizeof(jint) * origwidth);\n\n    int isSecondRasterExist = 0;\n    int ok = 1;\n    uint32 rows_to_write = 0;\n\n    //check for error\n    if (setjmp(NativeDecoder::strip_buf)) {\n        if (raster) {\n            _TIFFfree(raster);\n            raster = NULL;\n        }\n        if (rasterForBottomLine) {\n            _TIFFfree(rasterForBottomLine);\n            rasterForBottomLine = NULL;\n        }\n        if (matrixTopLine) {\n            _TIFFfree(matrixTopLine);\n            matrixTopLine = NULL;\n        }\n        if (matrixBottomLine) {\n            _TIFFfree(matrixBottomLine);\n            matrixBottomLine = NULL;\n        }\n\n        const char * err = \"Caught SIGSEGV signal(Segmentation fault or invalid memory reference)\";\n        LOGE(err);\n        if (throwException) {\n            throwDecodeFileException(err);\n        }\n\n        return NULL;\n    }\n\n    for (int i = 0; (i < stripMax*rowPerStrip || i > boundY + boundHeight) ; i += rowPerStrip) {\n\n            if (i + rowPerStrip <= boundY) {\n                continue;\n            }\n            if (i > boundY + boundHeight) {\n                break;\n            }\n\n            sendProgress(processedProgress * *bitmapwidth, progressTotal);\n            processedProgress += rowPerStrip/inSampleSize;\n\n            //if second raster is exist - copy it to work raster end decode next strip\n            if (isSecondRasterExist) {\n                _TIFFmemcpy(raster, rasterForBottomLine, origwidth * rowPerStrip * sizeof (uint32));\n\n                //If next strip is exist - decode it, invert lines\n                if (i + rowPerStrip < stripMax*rowPerStrip) {\n                    TIFFReadRGBAStrip(image, i+rowPerStrip, rasterForBottomLine);\n                    isSecondRasterExist = 1;\n\n                    rows_to_write = 0;\n                    if ( i + rowPerStrip * 2 > origheight )\n                        rows_to_write = origheight - i - rowPerStrip;\n                    else\n                        rows_to_write = rowPerStrip;\n\n                    if (origorientation <= 4) {\n                        for (int line = 0; line < rows_to_write / 2; line++) {\n                            unsigned int  *top_line, *bottom_line;\n\n                            top_line = rasterForBottomLine + origwidth * line;\n                            bottom_line = rasterForBottomLine + origwidth * (rows_to_write - line - 1);\n\n                            _TIFFmemcpy(work_line_buf, top_line, sizeof(unsigned int) * origwidth);\n                            _TIFFmemcpy(top_line, bottom_line, sizeof(unsigned int) * origwidth);\n                            _TIFFmemcpy(bottom_line, work_line_buf, sizeof(unsigned int) * origwidth);\n                        }\n                    }\n                } else {\n                    isSecondRasterExist = 0;\n                }\n            } else {\n                //if second raster is not exist - first processing - read first and second raster\n                 TIFFReadRGBAStrip(image, i, raster);\n                 //invert lines, because libtiff origin is bottom left instead of top left\n                 rows_to_write = 0;\n                 if( i + rowPerStrip > origheight )\n                    rows_to_write = origheight - i;\n                 else\n                    rows_to_write = rowPerStrip;\n\n                 if (origorientation <= 4) {\n                     for (int line = 0; line < rows_to_write / 2; line++) {\n                         unsigned int  *top_line, *bottom_line;\n\n                         top_line = raster + origwidth * line;\n                         bottom_line = raster + origwidth * (rows_to_write - line - 1);\n\n                         _TIFFmemcpy(work_line_buf, top_line, sizeof(unsigned int) * origwidth);\n                         _TIFFmemcpy(top_line, bottom_line, sizeof(unsigned int) * origwidth);\n                         _TIFFmemcpy(bottom_line, work_line_buf, sizeof(unsigned int) * origwidth);\n                     }\n                 }\n\n                 //if next strip is exist - read it and invert lines\n                 if (i + rowPerStrip < origheight) {\n                    TIFFReadRGBAStrip(image, i+rowPerStrip, rasterForBottomLine);\n                    isSecondRasterExist = 1;\n\n                    //invert lines, because libtiff origin is bottom left instead of top left\n                    rows_to_write = 0;\n                    if ( i + rowPerStrip * 2 > origheight )\n                        rows_to_write = origheight - i - rowPerStrip;\n                    else\n                        rows_to_write = rowPerStrip;\n                    if (origorientation <= 4) {\n                        for (int line = 0; line < rows_to_write / 2; line++) {\n                            unsigned int  *top_line, *bottom_line;\n\n                            top_line = rasterForBottomLine + origwidth * line;\n                            bottom_line = rasterForBottomLine + origwidth * (rows_to_write - line - 1);\n\n                            _TIFFmemcpy(work_line_buf, top_line, sizeof(unsigned int) * origwidth);\n                            _TIFFmemcpy(top_line, bottom_line, sizeof(unsigned int) * origwidth);\n                            _TIFFmemcpy(bottom_line, work_line_buf, sizeof(unsigned int) * origwidth);\n                        }\n                    }\n                 }\n\n            }\n\n            /*if (inSampleSize == 1) {\n                int byteToCopy = 0;\n                if (i + rowPerStrip < origheight) {\n                    byteToCopy = sizeof(unsigned int) * rowPerStrip * origwidth;\n                } else {\n                    byteToCopy = sizeof(unsigned int) * rows_to_write * origwidth;\n                }\n                int position = i * origwidth;\n                memcpy(&pixels[position], raster, byteToCopy);\n                //sendProgress(position, progressTotal);\n            } else {*/\n                if (isSecondRasterExist) {\n                    _TIFFmemcpy(matrixBottomLine, rasterForBottomLine /*+ lineAddrToCopyBottomLine * origwidth*/, sizeof(unsigned int) * origwidth);\n                }\n                 int workWritedLines = writedLines;\n                 for (int resBmpY = workWritedLines, workY = 0; resBmpY < *bitmapheight && workY < rowPerStrip; /*wj++,*/ workY ++/*= inSampleSize*/) {\n\n                 if (checkStop()) {\n                     if (raster) {\n                         _TIFFfree(raster);\n                         raster = NULL;\n                     }\n                     if (rasterForBottomLine) {\n                         _TIFFfree(rasterForBottomLine);\n                         rasterForBottomLine = NULL;\n                     }\n                     if (matrixTopLine) {\n                         _TIFFfree(matrixTopLine);\n                         matrixTopLine = NULL;\n                     }\n                     if (matrixBottomLine) {\n                         _TIFFfree(matrixBottomLine);\n                         matrixBottomLine = NULL;\n                     }\n                     LOGI(\"Thread stopped\");\n                     return NULL;\n                 }\n\n                    // if total line of source image is equal to inSampleSize*N then process this line\n                    if (globalLineCounter % inSampleSize == 0) {\n                        for (int resBmpX = 0, workX = 0; resBmpX < *bitmapwidth; workX += inSampleSize) {\n\n                            /*if (workX <= boundX) {\n                                continue;\n                            }\n                            if (workX > boundX + boundWidth) {\n                                break;\n                            }\n                            LOGII(\"J\", workX);*/\n\n                            //Apply filter to pixel\n                            jint crPix = raster[workY * origwidth + workX];\n                            int sum = 1;\n\n\n                            int alpha = colorMask & crPix >> 24;\n                            int red = colorMask & crPix >> 16;\n                            int green = colorMask & crPix >> 8;\n                            int blue = colorMask & crPix;\n\n\n                            //topleft\n                            if (workX - 1 >= 0 && workY - 1 >= 0) {\n                                crPix = raster[(workY - 1) * origwidth + workX - 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            } else if (workX - 1 >= 0 && workY - 1 == -1 && globalLineCounter > 0) {\n                                crPix = matrixTopLine[workX - 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            }\n                            //top\n                            if (workY - 1 >= 0) {\n                                crPix = raster[(workY - 1) * origwidth + workX];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            } else if (workY - 1 == -1 && globalLineCounter > 0) {\n                                crPix = matrixTopLine[workX];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            }\n\n                            // topright\n                            if (workX + 1 < origwidth && workY - 1 >= 0) {\n                                crPix = raster[(workY - 1) * origwidth + workX + 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            } else if (workX + 1 < origwidth && workY - 1 == -1 && globalLineCounter > 0) {\n                                crPix = matrixTopLine[workX + 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            }\n\n                            //right\n                            if (workX + 1 < origwidth) {\n                                crPix = raster[workY * origwidth + workX + 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            }\n\n                            //bottomright\n                            if (workX + 1 < origwidth && workY + 1 < rowPerStrip) {\n                                crPix = raster[(workY + 1) * origwidth + workX + 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            } else if (workX + 1 < origwidth && workY + 1 == rowPerStrip && isSecondRasterExist) {\n                                crPix = matrixBottomLine[workX + 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            }\n\n                            //bottom\n                            if (workY + 1 < rowPerStrip) {\n                                crPix = raster[(workY + 1) * origwidth + workX + 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            } else if (workY + 1 == rowPerStrip && isSecondRasterExist) {\n                                crPix = matrixBottomLine[workX + 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            }\n\n                            //bottomleft\n                            if (workX - 1 >= 0 && workY + 1 < rowPerStrip) {\n                                crPix = raster[(workY + 1) * origwidth + workX - 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            } else if (workX - 1 >= 0 && workY + 1 == rowPerStrip  && isSecondRasterExist) {\n                                crPix = matrixBottomLine[workX - 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            }\n\n\n                            //left\n                            if (workX - 1 >= 0) {\n                                crPix = raster[workY * origwidth + workX - 1];\n                                red += colorMask & crPix >> 16;\n                                green += colorMask & crPix >> 8;\n                                blue += colorMask & crPix;\n                                alpha += colorMask & crPix >> 24;\n                                sum++;\n                            }\n\n                            red /= sum;\n                            if (red > 255) red = 255;\n                            if (red < 0) red = 0;\n\n                            green /= sum;\n                            if (green > 255) green = 255;\n                            if (green < 0) green = 0;\n\n                            blue /= sum;\n                            if (blue > 255) blue = 255;\n                            if (blue < 0) blue = 0;\n\n                            alpha /= sum;///= sum;\n                            if (alpha > 255) alpha = 255;\n                            if (alpha < 0) alpha = 0;\n\n                            crPix = (alpha << 24) | (red << 16) | (green << 8) | (blue);\n\n                            pixels[resBmpY * *bitmapwidth + resBmpX] = crPix;\n\n                            resBmpX++;\n                        }\n                        //if line was processed - increment counter of lines that was writed to result image\n                        writedLines++;\n                        //and incremetncounter of current Y for writing\n                        resBmpY++;\n                    }\n                    if (workY == rowPerStrip - 1 && i + rowPerStrip < origheight) {\n                        _TIFFmemcpy(matrixTopLine, raster + workY * origwidth, sizeof(unsigned int) * origwidth);\n                    }\n                    //incremetn global source image line counter\n                    globalLineCounter++;\n\n                }\n            /*}*/\n        }\n        LOGI(\"Decoding finished. Free memmory\");\n\n        //Close Buffers\n        if (raster) {\n            _TIFFfree(raster);\n            raster = NULL;\n        }\n\n        if (rasterForBottomLine) {\n            _TIFFfree(rasterForBottomLine);\n            rasterForBottomLine = NULL;\n        }\n\n        if (matrixTopLine) {\n            _TIFFfree(matrixTopLine);\n            matrixTopLine = NULL;\n        }\n\n        if (matrixBottomLine) {\n            _TIFFfree(matrixBottomLine);\n            matrixBottomLine = NULL;\n        }\n\n        processedProgress *= *bitmapwidth;\n\n        if (useOrientationTag) {\n            uint32 buf;\n            switch(origorientation) {\n                 case ORIENTATION_TOPLEFT:\n                 case ORIENTATION_TOPRIGHT:\n                    break;\n                 case ORIENTATION_BOTRIGHT:\n                 case ORIENTATION_BOTLEFT:\n                    flipPixelsVertical(*bitmapwidth, *bitmapheight, pixels);\n                    break;\n                 case ORIENTATION_LEFTTOP:\n                    rotateRaster(pixels, 90, bitmapwidth, bitmapheight);\n                    flipPixelsHorizontal(*bitmapwidth, *bitmapheight, pixels);\n                    buf = *bitmapwidth;\n                    *bitmapwidth = *bitmapheight;\n                    *bitmapheight = buf;\n                    break;\n                 case ORIENTATION_RIGHTTOP:\n                    rotateRaster(pixels, 270, bitmapwidth, bitmapheight);\n                    flipPixelsHorizontal(*bitmapwidth, *bitmapheight, pixels);\n                    buf = *bitmapwidth;\n                    *bitmapwidth = *bitmapheight;\n                    *bitmapheight = buf;\n                    break;\n                 case ORIENTATION_RIGHTBOT:\n                    rotateRaster(pixels, 90, bitmapwidth, bitmapheight);\n                    buf= *bitmapwidth;\n                    *bitmapwidth = *bitmapheight;\n                    *bitmapheight = buf;\n                    break;\n                 case ORIENTATION_LEFTBOT:\n                    rotateRaster(pixels, 270, bitmapwidth, bitmapheight);\n                    buf = *bitmapwidth;\n                    *bitmapwidth = *bitmapheight;\n                    *bitmapheight = buf;\n                    break;\n            }\n\n        } else if (origorientation == 2 || origorientation == 3 || origorientation == 6 || origorientation == 7) {\n            flipPixelsHorizontal(*bitmapwidth, *bitmapheight, pixels);\n        }\n\n        uint32 tmpPixelBufferSize = (boundWidth / inSampleSize) * (boundHeight / inSampleSize);\n\n        estimateMem = (sizeof(jint) * pixelsBufferSize); //temp buffer for decoded pixels\n        estimateMem += (sizeof(jint) * tmpPixelBufferSize); //final buffer that will store original image\n        LOGII(\"estimateMem\", estimateMem);\n        if (estimateMem > availableMemory) {\n            if (throwException) {\n                throw_not_enought_memory_exception(env, availableMemory, estimateMem);\n            }\n            return NULL;\n        }\n\n        jint* tmpPixels = (jint *) malloc(sizeof(jint) * tmpPixelBufferSize);\n        uint32 startPosX = 0;\n\n        if (useOrientationTag && (origorientation == ORIENTATION_TOPRIGHT || origorientation == ORIENTATION_BOTRIGHT\n                                    || origorientation == ORIENTATION_LEFTBOT || origorientation == ORIENTATION_RIGHTBOT)) {\n            startPosX = *bitmapwidth - boundX/inSampleSize;\n            for (int ox = startPosX, nx = 0; nx < boundWidth/inSampleSize; ox--, nx++) {\n                sendProgress(processedProgress + nx * boundWidth/inSampleSize, progressTotal);\n                for (int oy = 0, ny = 0; ny < boundHeight/inSampleSize; oy++, ny++) {\n                    if (useOrientationTag && (origorientation > 4)) {\n                        tmpPixels[nx * (boundHeight/inSampleSize) + ny] = pixels[ox * *bitmapheight + oy];\n                    } else {\n                        tmpPixels[ny * (boundWidth/inSampleSize) + nx] = pixels[oy * *bitmapwidth + ox];\n                    }\n                }\n            }\n        } else {\n            startPosX = boundX/inSampleSize;\n            for (int ox = startPosX, nx = 0; nx < boundWidth/inSampleSize; ox++, nx++) {\n                sendProgress(processedProgress + nx * boundWidth/inSampleSize, progressTotal);\n                for (int oy = 0, ny = 0; ny < boundHeight/inSampleSize; oy++, ny++) {\n                    if (useOrientationTag && (origorientation > 4)) {\n                        tmpPixels[nx * (boundHeight/inSampleSize) + ny] = pixels[ox * *bitmapheight + oy];\n                    } else {\n                        tmpPixels[ny * (boundWidth/inSampleSize) + nx] = pixels[oy * *bitmapwidth + ox];\n                    }\n                }\n            }\n        }\n\n        free(pixels);\n        pixels = tmpPixels;\n        *bitmapwidth = boundWidth/inSampleSize;\n        *bitmapheight = boundHeight/inSampleSize;\n\n        return pixels;\n}",
    "void NativeDecoder::rotateTileLinesVertical(uint32 tileHeight, uint32 tileWidth, uint32* whatRotate, uint32 *bufferLine) {\n    for (int line = 0; line < tileHeight / 2; line++) {\n        unsigned int  *top_line, *bottom_line;\n        top_line = whatRotate + tileWidth * line;\n        bottom_line = whatRotate + tileWidth * (tileHeight - line -1);\n        _TIFFmemcpy(bufferLine, top_line, sizeof(unsigned int) * tileWidth);\n        _TIFFmemcpy(top_line, bottom_line, sizeof(unsigned int) * tileWidth);\n        _TIFFmemcpy(bottom_line, bufferLine, sizeof(unsigned int) * tileWidth);\n    }\n}",
    "jint * NativeDecoder::getSampledRasterFromTile(int inSampleSize, int *bitmapwidth, int *bitmapheight) {\n\n        //init signal handler for catch SIGSEGV error that could be raised in libtiff\n        struct sigaction act;\n        memset(&act, 0, sizeof(act));\n        sigemptyset(&act.sa_mask);\n        act.sa_sigaction = tileErrorHandler;\n        act.sa_flags = SA_SIGINFO | SA_ONSTACK;\n        if(sigaction(SIGSEGV, &act, 0) < 0) {\n            LOGE(\"Can\\'t setup signal handler. Working without errors catching mechanism\");\n        }\n\n        jint *pixels = NULL;\n        *bitmapwidth = origwidth / inSampleSize;\n        *bitmapheight = origheight / inSampleSize;\n        uint32 pixelsBufferSize = *bitmapwidth * *bitmapheight;\n\n        uint32 tileWidth = 0, tileHeight = 0;\n        TIFFGetField(image, TIFFTAG_TILEWIDTH, &tileWidth);\n        TIFFGetField(image, TIFFTAG_TILEWIDTH, &tileHeight);\n\n        unsigned long estimateMem = 0;\n        estimateMem += (sizeof(jint) * pixelsBufferSize); //buffer for decoded pixels\n        estimateMem += (tileWidth * tileHeight * sizeof(uint32)) * 3; //current, left and right tiles buffers\n        estimateMem += (tileWidth * sizeof(uint32)); //work line for rotate tile\n        LOGII(\"estimateMem\", estimateMem);\n        if (estimateMem > availableMemory) {\n            if (throwException) {\n                throw_not_enought_memory_exception(env, availableMemory, estimateMem);\n            }\n            return NULL;\n        }\n\n        pixels = (jint *) malloc(sizeof(jint) * pixelsBufferSize);\n        if (pixels == NULL) {\n            LOGE(\"Can\\'t allocate memory for temp buffer\");\n            return NULL;\n        }\n\n        uint32 row, column;\n\n        //main worker tile\n        uint32 *rasterTile = (uint32 *)_TIFFmalloc(tileWidth * tileHeight * sizeof(uint32));\n        //left tile\n        uint32 *rasterTileLeft = (uint32 *)_TIFFmalloc(tileWidth * tileHeight * sizeof(uint32));\n        //right tile\n        uint32 *rasterTileRight = (uint32 *)_TIFFmalloc(tileWidth * tileHeight * sizeof(uint32));\n\n        uint32 *work_line_buf = (uint32*)_TIFFmalloc(tileWidth * sizeof (uint32));\n\n        //this variable calculate processed pixels for x and y direction to make right offsets at the begining of next tile\n        //offset calculated from condition globalProcessed % inSampleSize should be 0\n        uint32 globalProcessedX = 0;\n        uint32 globalProcessedY = 0;\n\n        //check for error\n        if (setjmp(NativeDecoder::tile_buf)) {\n            if (rasterTile) {\n                _TIFFfree(rasterTile);\n                rasterTile = NULL;\n            }\n            if (rasterTileLeft) {\n                _TIFFfree(rasterTileLeft);\n                rasterTileLeft = NULL;\n            }\n            if (rasterTileRight) {\n                _TIFFfree(rasterTileRight);\n                rasterTileRight = NULL;\n            }\n            if (work_line_buf) {\n                _TIFFfree(work_line_buf);\n                work_line_buf = NULL;\n            }\n\n            const char * err = \"Caught SIGSEGV signal(Segmentation fault or invalid memory reference)\";\n            LOGE(err);\n            if (throwException) {\n                throwDecodeFileException(err);\n            }\n\n            return NULL;\n        }\n\n        for (row = 0; row < origheight; row += tileHeight) {\n            short leftTileExists = 0;\n            short rightTileExists = 0;\n            for (column = 0; column < origwidth; column += tileWidth) {\n                sendProgress(row * origwidth + column, progressTotal);\n\n                //If not first column - we should have previous tile - copy it to left tile buffer\n                if (column != 0) {\n                    _TIFFmemcpy(rasterTileLeft, rasterTile, tileWidth * tileHeight * sizeof(uint32));\n                    leftTileExists = 1;\n                } else {\n                    leftTileExists = 0;\n                }\n\n                //if current column + tile width is less than origin width - we have right tile - copy it to current tile and read next tile to rasterTileRight buffer\n                if (column + tileWidth < origwidth && rightTileExists) {\n                    _TIFFmemcpy(rasterTile, rasterTileRight, tileWidth * tileHeight * sizeof(uint32));\n                    TIFFReadRGBATile(image, column + tileWidth, row, rasterTileRight);\n                    rightTileExists = 1;\n                } else if (column + tileWidth < origwidth) {\n                    //have right tile but this is first tile in row, so need to read raster and right raster\n                    TIFFReadRGBATile(image, column + tileWidth, row, rasterTileRight);\n                    TIFFReadRGBATile(image, column, row, rasterTile);\n                    rightTileExists = 1;\n\n                    //in that case we also need to invert lines in rasterTile\n                    switch(origorientation) {\n                        case 1:\n                        case 5:\n                            rotateTileLinesVertical(tileHeight, tileWidth, rasterTile, work_line_buf);\n                            break;\n                        case 2:\n                        case 6:\n                            rotateTileLinesVertical(tileHeight, tileWidth, rasterTile, work_line_buf);\n                            rotateTileLinesHorizontal(tileHeight, tileWidth, rasterTile, work_line_buf);\n                            break;\n                        case 3:\n                        case 7:\n                            rotateTileLinesHorizontal(tileHeight, tileWidth, rasterTile, work_line_buf);\n                            break;\n                    }\n                } else {\n                    //otherwise we haven't right tile buffer, so we should read tile to current buffer\n                    TIFFReadRGBATile(image, column, row, rasterTile);\n                    rightTileExists = 0;\n                }\n\n                //if we have right tile - current tile already rotated and we need to rotate only right tile\n                if (rightTileExists) {\n                    switch(origorientation) {\n                        case 1:\n                        case 5:\n                            rotateTileLinesVertical(tileHeight, tileWidth, rasterTileRight, work_line_buf);\n                            break;\n                        case 2:\n                        case 6:\n                            rotateTileLinesVertical(tileHeight, tileWidth, rasterTileRight, work_line_buf);\n                            rotateTileLinesHorizontal(tileHeight, tileWidth, rasterTileRight, work_line_buf);\n                            break;\n                        case 3:\n                        case 7:\n                            rotateTileLinesHorizontal(tileHeight, tileWidth, rasterTileRight, work_line_buf);\n                            break;\n                    }\n                } else {\n                    //otherwise - current tile not rotated so rotate it\n                    //tile orig is on bottom left - should change lines\n                     switch(origorientation) {\n                        case 1:\n                        case 5:\n                            rotateTileLinesVertical(tileHeight, tileWidth, rasterTile, work_line_buf);\n                            break;\n                        case 2:\n                        case 6:\n                            rotateTileLinesVertical(tileHeight, tileWidth, rasterTile, work_line_buf);\n                            rotateTileLinesHorizontal(tileHeight, tileWidth, rasterTile, work_line_buf);\n                            break;\n                        case 3:\n                        case 7:\n                            rotateTileLinesHorizontal(tileHeight, tileWidth, rasterTile, work_line_buf);\n                            break;\n                    }\n                }\n\n                if (inSampleSize > 1 )\n                {\n                    //Tile could begin from not filled pixel(pixel[x,y] == 0). This variables allow to calculate begining of filled pixels\n                    int tileStartDataX = -1;\n                    int tileStartDataY = -1;\n\n                    for (int origTileY = 0, pixY = row/inSampleSize; origTileY < tileHeight && pixY < *bitmapheight; origTileY++) {\n\n                        if (checkStop()) {\n                            if (rasterTile) {\n                                _TIFFfree(rasterTile);\n                                rasterTile = NULL;\n                            }\n                            if (rasterTileLeft) {\n                                _TIFFfree(rasterTileLeft);\n                                rasterTileLeft = NULL;\n                            }\n                            if (rasterTileRight) {\n                                _TIFFfree(rasterTileRight);\n                                rasterTileRight = NULL;\n                            }\n                            if (work_line_buf) {\n                                _TIFFfree(work_line_buf);\n                                work_line_buf = NULL;\n                            }\n                            LOGI(\"Thread stopped\");\n                            return NULL;\n                        }\n\n                        if (tileStartDataY != -1 && globalProcessedY % inSampleSize != 0) {\n                            if (tileStartDataY != -1) {\n                                globalProcessedY++;\n                            }\n                        }\n                        else\n                        {\n                            for (int origTileX = 0, pixX = column/inSampleSize; origTileX < tileWidth && pixX < *bitmapwidth; origTileX++) {\n                                if (tileStartDataX != -1 && globalProcessedX % inSampleSize != 0)\n                                {\n                                    if (tileStartDataX != -1) {\n                                        globalProcessedX++;\n                                    }\n                                }\n                                else\n                                {\n                                    uint32 srcPosition = origTileY * tileWidth + origTileX;\n                                    if (rasterTile[srcPosition] != 0) {\n                                        if (tileStartDataX == -1) {\n                                            tileStartDataX = origTileX;\n                                        }\n                                        if (tileStartDataY == -1) {\n                                            tileStartDataY = origTileY;\n                                        }\n\n                                        //Apply filter to pixel\n                                        jint crPix = rasterTile[srcPosition];//origBuffer[j1 * origwidth + i1];\n                                        int sum = 1;\n\n                                        int alpha = colorMask & crPix >> 24;\n                                        int red = colorMask & crPix >> 16;\n                                        int green = colorMask & crPix >> 8;\n                                        int blue = colorMask & crPix;\n\n                                        //using kernel 3x3\n\n                                        //topleft\n                                        if (origTileX - 1 >= 0 && origTileY - 1 >= 0) {\n                                            crPix = rasterTile[(origTileY - 1) * tileWidth + origTileX - 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        } else if (origTileY - 1 >= 0 && leftTileExists) {\n                                            crPix = rasterTileLeft[(origTileY - 1) * tileWidth + tileWidth - 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        }\n\n                                        //top\n                                        if (origTileY - 1 >= 0) {\n                                            crPix = rasterTile[(origTileY - 1) * tileWidth + origTileX];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        }\n\n                                        // topright\n                                        if (origTileX + 1 < tileWidth && origTileY - 1 >= 0) {\n                                            crPix = rasterTile[(origTileY - 1) * tileWidth + origTileX + 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        } else if (origTileY - 1 >= 0 && rightTileExists) {\n                                            crPix = rasterTileRight[(origTileY - 1) * tileWidth];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        }\n\n                                        //right\n                                        if (origTileX + 1 < tileWidth) {\n                                            crPix = rasterTile[origTileY * tileWidth + origTileX + 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        } else if (rightTileExists) {\n                                            crPix = rasterTileRight[origTileY * tileWidth];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        }\n\n                                        //bottomright\n                                        if (origTileX + 1 < tileWidth && origTileY + 1 < tileHeight) {\n                                            crPix = rasterTile[(origTileY + 1) * tileWidth + origTileX + 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        } else if (origTileY + 1 < tileHeight && rightTileExists) {\n                                            crPix = rasterTileRight[(origTileY + 1) * tileWidth];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        }\n\n                                        //bottom\n                                        if (origTileY + 1 < tileHeight) {\n                                            crPix = rasterTile[(origTileY + 1) * tileWidth + origTileX];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        }\n\n                                        //bottomleft\n                                        if (origTileX - 1 >= 0 && origTileY + 1 < tileHeight) {\n                                            crPix = rasterTile[(origTileY + 1) * tileWidth + origTileX - 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        } else if (origTileY + 1 < tileHeight && leftTileExists) {\n                                            crPix = rasterTileLeft[(origTileY + 1) * tileWidth + tileWidth - 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        }\n\n                                        //left\n                                        if (origTileX - 1 >= 0) {\n                                            crPix = rasterTile[origTileY * tileWidth + origTileX - 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        } else if (leftTileExists) {\n                                            crPix = rasterTileLeft[origTileY * tileWidth + tileWidth - 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        }\n\n                                        red /= sum;\n                                        if (red > 255) red = 255;\n                                        if (red < 0) red = 0;\n\n                                        green /= sum;\n                                        if (green > 255) green = 255;\n                                        if (green < 0) green = 0;\n\n                                        blue /= sum;\n                                        if (blue > 255) blue = 255;\n                                        if (blue < 0) blue = 0;\n\n                                        alpha /= sum;///= sum;\n                                        if (alpha > 255) alpha = 255;\n                                        if (alpha < 0) alpha = 0;\n\n                                        crPix = (alpha << 24) | (red << 16) | (green << 8) | (blue);\n\n                                        int position;\n                                        if (origorientation <= 4) {\n                                            position = pixY * *bitmapwidth + pixX;\n                                        } else {\n                                            position = pixX * *bitmapheight + pixY;\n                                        }\n                                        pixels[position] = crPix;\n                                    } else {\n                                        if (tileStartDataX != -1) tileStartDataX = -1;\n                                        if (tileStartDataY != -1) tileStartDataY = -1;\n                                    }\n\n                                    if (tileStartDataX != -1) {\n                                        pixX++;\n                                        globalProcessedX++;\n                                    }\n\n                                }\n                            }\n                            if (tileStartDataY != -1) {\n                                pixY++;\n                                globalProcessedY++;\n                            }\n                        }\n                    }\n                } else {\n                    int rowHasPixels = 0;\n                        for (int th = 0, bh = 0; th < tileHeight; th++) {\n                            for (int tw = 0, bw = 0; tw < tileWidth; tw++) {\n                                uint32 srcPosition = th * tileWidth + tw;\n                                if (rasterTile[srcPosition] != 0) {\n                                    int position = 0;\n                                    if (origorientation <= 4) {\n                                        position = (row + bh) * *bitmapwidth + column + bw;\n                                    } else {\n                                        position = (column + bw) * *bitmapheight + row + bh;\n                                    }\n                                    pixels[position] = rasterTile[srcPosition];\n                                    rowHasPixels = 1;\n                                    bw++;\n                                }\n                            }\n                            if (rowHasPixels) {\n                                bh++;\n                                rowHasPixels = 0;\n                            }\n                        }\n                }\n            }\n        }\n\n        if (rasterTile) {\n            _TIFFfree(rasterTile);\n            rasterTile = NULL;\n        }\n        if (rasterTileLeft) {\n            _TIFFfree(rasterTileLeft);\n            rasterTileLeft = NULL;\n        }\n        if (rasterTileRight) {\n            _TIFFfree(rasterTileRight);\n            rasterTileRight = NULL;\n        }\n        if (work_line_buf) {\n            _TIFFfree(work_line_buf);\n            work_line_buf = NULL;\n        }\n\n        if (useOrientationTag) {\n            switch (origorientation) {\n                case ORIENTATION_TOPLEFT:\n                case ORIENTATION_LEFTTOP:\n                    break;\n                case ORIENTATION_TOPRIGHT:\n                    flipPixelsHorizontal(*bitmapwidth, *bitmapheight, pixels);\n                    break;\n                case ORIENTATION_RIGHTTOP:\n                    flipPixelsHorizontal(*bitmapheight, *bitmapwidth, pixels);\n                    break;\n                case ORIENTATION_BOTRIGHT:\n                case ORIENTATION_RIGHTBOT:\n                    rotateRaster(pixels, 180, bitmapwidth, bitmapheight);\n                    break;\n                case ORIENTATION_BOTLEFT:\n                    flipPixelsVertical(*bitmapwidth, *bitmapheight, pixels);\n                    break;\n                case ORIENTATION_LEFTBOT:\n                    flipPixelsVertical(*bitmapheight, *bitmapwidth, pixels);\n                    break;\n            }\n        } else {\n            if (origorientation > 4) {\n                uint32 buf = *bitmapwidth;\n                *bitmapwidth = *bitmapheight;\n                *bitmapheight = buf;\n                rotateRaster(pixels, 90, bitmapwidth, bitmapheight);\n                flipPixelsHorizontal(*bitmapwidth, *bitmapheight, pixels);\n            }\n        }\n\n        return pixels;\n}",
    "jint * NativeDecoder::getSampledRasterFromTileWithBounds(int inSampleSize, int *bitmapwidth, int *bitmapheight) {\n\n        //init signal handler for catch SIGSEGV error that could be raised in libtiff\n        struct sigaction act;\n        memset(&act, 0, sizeof(act));\n        sigemptyset(&act.sa_mask);\n        act.sa_sigaction = tileErrorHandler;\n        act.sa_flags = SA_SIGINFO | SA_ONSTACK;\n        if(sigaction(SIGSEGV, &act, 0) < 0) {\n            LOGE(\"Can\\'t setup signal handler. Working without errors catching mechanism\");\n        }\n\n\n        //First read all tiles that are on necessary area\n\n        uint32 tileWidth = 0, tileHeight = 0;\n        TIFFGetField(image, TIFFTAG_TILEWIDTH, &tileWidth);\n        TIFFGetField(image, TIFFTAG_TILEWIDTH, &tileHeight);\n\n        //find first and last tile to process\n        uint32 firstTileX = (uint32)(boundX / tileWidth);\n        uint32 firstTileY = (uint32)(boundY / tileHeight);\n\n        uint32 lastTileX = (uint32)((boundX + boundWidth) / tileWidth) + 1;\n        uint32 lastTileY = (uint32)((boundY + boundHeight) / tileHeight) + 1;\n\n        jint *pixels = NULL;\n        *bitmapwidth = /*boundWidth*/ (lastTileX - firstTileX) * tileWidth / inSampleSize;//origwidth / inSampleSize;\n        *bitmapheight = /*boundHeight*/ (lastTileY - firstTileY) * tileHeight / inSampleSize;//origheight / inSampleSize;\n        uint32 pixelsBufferSize = *bitmapwidth * *bitmapheight;\n\n         unsigned long estimateMem = 0;\n         estimateMem += (sizeof(jint) * pixelsBufferSize); //buffer for decoded pixels\n         estimateMem += (tileWidth * tileHeight * sizeof(uint32)) * 3; //current, left and right tiles buffers\n         estimateMem += (tileWidth * sizeof(uint32)); //work line for rotate tile\n         LOGII(\"estimateMem\", estimateMem);\n         if (estimateMem > availableMemory) {\n            if (throwException) {\n                throw_not_enought_memory_exception(env, availableMemory, estimateMem);\n            }\n            return NULL;\n         }\n\n        pixels = (jint *) malloc(sizeof(jint) * pixelsBufferSize);\n        if (pixels == NULL) {\n            LOGE(\"Can\\'t allocate memory for temp buffer\");\n            return NULL;\n        }\n\n        progressTotal = pixelsBufferSize + (boundWidth/inSampleSize) * (boundHeight/inSampleSize);\n        sendProgress(0, progressTotal);\n        jlong processedProgress = 0;\n\n        uint32 row, column, rowDest, columnDest;\n\n        //main worker tile\n        uint32 *rasterTile = (uint32 *)_TIFFmalloc(tileWidth * tileHeight * sizeof(uint32));\n        //left tile\n        uint32 *rasterTileLeft = (uint32 *)_TIFFmalloc(tileWidth * tileHeight * sizeof(uint32));\n        //right tile\n        uint32 *rasterTileRight = (uint32 *)_TIFFmalloc(tileWidth * tileHeight * sizeof(uint32));\n\n        uint32 *work_line_buf = (uint32*)_TIFFmalloc(tileWidth * sizeof (uint32));\n\n        //check for error\n        if (setjmp(NativeDecoder::tile_buf)) {\n            if (rasterTile) {\n                _TIFFfree(rasterTile);\n                rasterTile = NULL;\n            }\n            if (rasterTileLeft) {\n                _TIFFfree(rasterTileLeft);\n                rasterTileLeft = NULL;\n            }\n            if (rasterTileRight) {\n                _TIFFfree(rasterTileRight);\n                rasterTileRight = NULL;\n            }\n            if (work_line_buf) {\n                _TIFFfree(work_line_buf);\n                work_line_buf = NULL;\n            }\n\n        const char * err = \"Caught SIGSEGV signal(Segmentation fault or invalid memory reference)\";\n        LOGE(err);\n        if (throwException) {\n            throwDecodeFileException(err);\n        }\n\n            return NULL;\n        }\n\n        //this variable calculate processed pixels for x and y direction to make right offsets at the begining of next tile\n        //offset calculated from condition globalProcessed % inSampleSize should be 0\n        uint32 globalProcessedX = 0;\n        uint32 globalProcessedY = 0;\n\n        uint32 progressRow = 0;\n        uint32 progressColumn = 0;\n\n        rowDest = columnDest = 0;\n        for (row = firstTileY * tileHeight; row < lastTileY * tileHeight; row += tileHeight, progressRow += tileHeight) {\n            columnDest = 0;\n            short leftTileExists = 0;\n            short rightTileExists = 0;\n            for (column = firstTileX * tileWidth; column < lastTileX * tileWidth; column += tileWidth, progressColumn += tileWidth) {\n                processedProgress = progressRow * *bitmapwidth + progressColumn;\n                sendProgress(processedProgress, progressTotal);\n\n                //If not first column - we should have previous tile - copy it to left tile buffer\n                if (column != firstTileY) {\n                    _TIFFmemcpy(rasterTileLeft, rasterTile, tileWidth * tileHeight * sizeof(uint32));\n                    leftTileExists = 1;\n                } else {\n                    leftTileExists = 0;\n                }\n                //if current column + tile width is less than origin width - we have right tile - copy it to current tile and read next tile to rasterTileRight buffer\n                if (column + tileWidth < origwidth && rightTileExists) {\n                    _TIFFmemcpy(rasterTile, rasterTileRight, tileWidth * tileHeight * sizeof(uint32));\n                    TIFFReadRGBATile(image, column + tileWidth, row, rasterTileRight);\n                    rightTileExists = 1;\n                } else if (column + tileWidth < origwidth) {\n                    //have right tile but this is first tile in row, so need to read raster and right raster\n                    TIFFReadRGBATile(image, column + tileWidth, row, rasterTileRight);\n                    TIFFReadRGBATile(image, column, row, rasterTile);\n                    rightTileExists = 1;\n\n                    //in that case we also need to invert lines in rasterTile\n                    switch(origorientation) {\n                        case 1:\n                        case 5:\n                            rotateTileLinesVertical(tileHeight, tileWidth, rasterTile, work_line_buf);\n                            break;\n                        case 2:\n                        case 6:\n                            rotateTileLinesVertical(tileHeight, tileWidth, rasterTile, work_line_buf);\n                            rotateTileLinesHorizontal(tileHeight, tileWidth, rasterTile, work_line_buf);\n                            break;\n                        case 3:\n                        case 7:\n                            rotateTileLinesHorizontal(tileHeight, tileWidth, rasterTile, work_line_buf);\n                            break;\n                    }\n                } else {\n                    //otherwise we haven't right tile buffer, so we should read tile to current buffer\n                    TIFFReadRGBATile(image, column, row, rasterTile);\n                    rightTileExists = 0;\n                }\n\n                //if we have right tile - current tile already rotated and we need to rotate only right tile\n                if (rightTileExists) {\n                    switch(origorientation) {\n                        case 1:\n                        case 5:\n                            rotateTileLinesVertical(tileHeight, tileWidth, rasterTileRight, work_line_buf);\n                            break;\n                        case 2:\n                        case 6:\n                            rotateTileLinesVertical(tileHeight, tileWidth, rasterTileRight, work_line_buf);\n                            rotateTileLinesHorizontal(tileHeight, tileWidth, rasterTileRight, work_line_buf);\n                            break;\n                        case 3:\n                        case 7:\n                            rotateTileLinesHorizontal(tileHeight, tileWidth, rasterTileRight, work_line_buf);\n                            break;\n                    }\n                } else {\n                    //otherwise - current tile not rotated so rotate it\n                    //tile orig is on bottom left - should change lines\n                     switch(origorientation) {\n                        case 1:\n                        case 5:\n                            rotateTileLinesVertical(tileHeight, tileWidth, rasterTile, work_line_buf);\n                            break;\n                        case 2:\n                        case 6:\n                            rotateTileLinesVertical(tileHeight, tileWidth, rasterTile, work_line_buf);\n                            rotateTileLinesHorizontal(tileHeight, tileWidth, rasterTile, work_line_buf);\n                            break;\n                        case 3:\n                        case 7:\n                            rotateTileLinesHorizontal(tileHeight, tileWidth, rasterTile, work_line_buf);\n                            break;\n                    }\n                }\n\n                    //Tile could begin from not filled pixel(pixel[x,y] == 0). This variables allow to calculate begining of filled pixels\n                    int tileStartDataX = -1;\n                    int tileStartDataY = -1;\n\n                    for (int origTileY = 0, pixY = rowDest/inSampleSize; origTileY < tileHeight && pixY < *bitmapheight; origTileY++) {\n                        if (checkStop()) {\n                            if (rasterTile) {\n                                _TIFFfree(rasterTile);\n                                rasterTile = NULL;\n                            }\n                            if (rasterTileLeft) {\n                                _TIFFfree(rasterTileLeft);\n                                rasterTileLeft = NULL;\n                            }\n                            if (rasterTileRight) {\n                                _TIFFfree(rasterTileRight);\n                                rasterTileRight = NULL;\n                            }\n                            if (work_line_buf) {\n                                _TIFFfree(work_line_buf);\n                                work_line_buf = NULL;\n                            }\n                            LOGI(\"Thread stopped\");\n                            return NULL;\n                        }\n\n                        if (tileStartDataY != -1 && globalProcessedY % inSampleSize != 0) {\n                            if (tileStartDataY != -1) {\n                                globalProcessedY++;\n                            }\n                        }\n                        else\n                        {\n\n                            for (int origTileX = 0, pixX = columnDest/inSampleSize; origTileX < tileWidth && pixX < *bitmapwidth; origTileX++) {\n\n\n                                if (tileStartDataX != -1 && globalProcessedX % inSampleSize != 0)\n                                {\n                                    if (tileStartDataX != -1) {\n                                        globalProcessedX++;\n                                    }\n                                }\n                                else\n                                {\n                                    uint32 srcPosition = origTileY * tileWidth + origTileX;\n                                    if (rasterTile[srcPosition] != 0) {\n\n                                        if (tileStartDataX == -1) {\n                                            tileStartDataX = origTileX;\n                                        }\n                                        if (tileStartDataY == -1) {\n                                            tileStartDataY = origTileY;\n                                        }\n\n                                        //Apply filter to pixel\n                                        jint crPix = rasterTile[srcPosition];//origBuffer[j1 * origwidth + i1];\n                                        int sum = 1;\n\n                                        int alpha = colorMask & crPix >> 24;\n                                        int red = colorMask & crPix >> 16;\n                                        int green = colorMask & crPix >> 8;\n                                        int blue = colorMask & crPix;\n\n                                        //using kernel 3x3\n\n                                        //topleft\n                                        if (origTileX - 1 >= 0 && origTileY - 1 >= 0) {\n                                            crPix = rasterTile[(origTileY - 1) * tileWidth + origTileX - 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        } else if (origTileY - 1 >= 0 && leftTileExists) {\n                                            crPix = rasterTileLeft[(origTileY - 1) * tileWidth + tileWidth - 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        }\n\n                                        //top\n                                        if (origTileY - 1 >= 0) {\n                                            crPix = rasterTile[(origTileY - 1) * tileWidth + origTileX];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        }\n\n                                        // topright\n                                        if (origTileX + 1 < tileWidth && origTileY - 1 >= 0) {\n                                            crPix = rasterTile[(origTileY - 1) * tileWidth + origTileX + 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        } else if (origTileY - 1 >= 0 && rightTileExists) {\n                                            crPix = rasterTileRight[(origTileY - 1) * tileWidth];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        }\n\n                                        //right\n                                        if (origTileX + 1 < tileWidth) {\n                                            crPix = rasterTile[origTileY * tileWidth + origTileX + 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        } else if (rightTileExists) {\n                                            crPix = rasterTileRight[origTileY * tileWidth];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        }\n\n                                        //bottomright\n                                        if (origTileX + 1 < tileWidth && origTileY + 1 < tileHeight) {\n                                            crPix = rasterTile[(origTileY + 1) * tileWidth + origTileX + 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        } else if (origTileY + 1 < tileHeight && rightTileExists) {\n                                            crPix = rasterTileRight[(origTileY + 1) * tileWidth];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        }\n\n                                        //bottom\n                                        if (origTileY + 1 < tileHeight) {\n                                            crPix = rasterTile[(origTileY + 1) * tileWidth + origTileX];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        }\n\n                                        //bottomleft\n                                        if (origTileX - 1 >= 0 && origTileY + 1 < tileHeight) {\n                                            crPix = rasterTile[(origTileY + 1) * tileWidth + origTileX - 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        } else if (origTileY + 1 < tileHeight && leftTileExists) {\n                                            crPix = rasterTileLeft[(origTileY + 1) * tileWidth + tileWidth - 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        }\n\n                                        //left\n                                        if (origTileX - 1 >= 0) {\n                                            crPix = rasterTile[origTileY * tileWidth + origTileX - 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        } else if (leftTileExists) {\n                                            crPix = rasterTileLeft[origTileY * tileWidth + tileWidth - 1];\n                                            if (crPix != 0) {\n                                                red += colorMask & crPix >> 16;\n                                                green += colorMask & crPix >> 8;\n                                                blue += colorMask & crPix;\n                                                alpha += colorMask & crPix >> 24;\n                                                sum++;\n                                            }\n                                        }\n\n                                        red /= sum;\n                                        if (red > 255) red = 255;\n                                        if (red < 0) red = 0;\n\n                                        green /= sum;\n                                        if (green > 255) green = 255;\n                                        if (green < 0) green = 0;\n\n                                        blue /= sum;\n                                        if (blue > 255) blue = 255;\n                                        if (blue < 0) blue = 0;\n\n                                        alpha /= sum;///= sum;\n                                        if (alpha > 255) alpha = 255;\n                                        if (alpha < 0) alpha = 0;\n\n                                        crPix = (alpha << 24) | (red << 16) | (green << 8) | (blue);\n\n                                        int position;\n                                        if (origorientation <= 4) {\n                                            position = pixY * *bitmapwidth + pixX;\n                                        } else {\n                                            position = pixX * *bitmapheight + pixY;\n                                        }\n                                        pixels[position] = crPix;\n                                    } else {\n                                        if (tileStartDataX != -1) tileStartDataX = -1;\n                                        if (tileStartDataY != -1) tileStartDataY = -1;\n                                    }\n\n                                    if (tileStartDataX != -1) {\n                                        pixX++;\n                                        globalProcessedX++;\n                                    }\n\n                                }\n                            }\n                            if (tileStartDataY != -1) {\n                                pixY++;\n                                globalProcessedY++;\n                            }\n                        }\n                    }\n                columnDest += tileWidth;\n            }\n            rowDest += tileHeight;\n        }\n\n        if (rasterTile) {\n            _TIFFfree(rasterTile);\n            rasterTile = NULL;\n        }\n        if (rasterTileLeft) {\n            _TIFFfree(rasterTileLeft);\n            rasterTileLeft = NULL;\n        }\n        if (rasterTileRight) {\n            _TIFFfree(rasterTileRight);\n            rasterTileRight = NULL;\n        }\n        if (work_line_buf) {\n            _TIFFfree(work_line_buf);\n            work_line_buf = NULL;\n        }\n\n        //Copy necessary pixels to new array if orientation <=4\n        uint32 tmpPixelBufferSize = (boundWidth / inSampleSize) * (boundHeight / inSampleSize);\n\n        estimateMem = (sizeof(jint) * pixelsBufferSize); //buffer for decoded pixels\n        estimateMem += (sizeof(jint) * tmpPixelBufferSize); //finall buffer\n        LOGII(\"estimateMem\", estimateMem);\n        if (estimateMem > availableMemory) {\n            if (throwException) {\n                throw_not_enought_memory_exception(env, availableMemory, estimateMem);\n            }\n            return NULL;\n        }\n\n        if (origorientation <= 4) {\n\n            jint* tmpPixels = (jint *) malloc(sizeof(jint) * tmpPixelBufferSize);\n            uint32 startPosX = boundX%tileWidth /inSampleSize;//(firstTileX * tileWidth - tileWidth + boundX) / inSampleSize;\n            uint32 startPosY = boundY%tileHeight /inSampleSize;//(firstTileY * tileHeight - tileHeight + boundY) /inSampleSize;\n            for (int ox = startPosX, nx = 0; nx < boundWidth/inSampleSize; ox++, nx++) {\n                sendProgress(processedProgress + nx * (boundHeight/inSampleSize), progressTotal);\n                for (int oy = startPosY, ny = 0; ny < boundHeight/inSampleSize; oy++, ny++) {\n                    tmpPixels[ny * (boundWidth/inSampleSize) + nx] = pixels[oy * *bitmapwidth + ox];\n                }\n            }\n\n            free(pixels);\n            pixels = tmpPixels;\n            *bitmapwidth = boundWidth/inSampleSize;\n            *bitmapheight = boundHeight/inSampleSize;\n        }\n\n        if (useOrientationTag) {\n            switch (origorientation) {\n                case ORIENTATION_TOPLEFT:\n                case ORIENTATION_LEFTTOP:\n                    break;\n                case ORIENTATION_TOPRIGHT:\n                    flipPixelsHorizontal(*bitmapwidth, *bitmapheight, pixels);\n                    break;\n                case ORIENTATION_RIGHTTOP:\n                    flipPixelsHorizontal(*bitmapheight, *bitmapwidth, pixels);\n                    break;\n                case ORIENTATION_BOTRIGHT:\n                case ORIENTATION_RIGHTBOT:\n                    rotateRaster(pixels, 180, bitmapwidth, bitmapheight);\n                    break;\n                case ORIENTATION_BOTLEFT:\n                    flipPixelsVertical(*bitmapwidth, *bitmapheight, pixels);\n                    break;\n                case ORIENTATION_LEFTBOT:\n                    flipPixelsVertical(*bitmapheight, *bitmapwidth, pixels);\n                    break;\n            }\n        } else {\n            if (origorientation > 4) {\n                uint32 buf = *bitmapwidth;\n                *bitmapwidth = *bitmapheight;\n                *bitmapheight = buf;\n                rotateRaster(pixels, 90, bitmapwidth, bitmapheight);\n                flipPixelsHorizontal(*bitmapwidth, *bitmapheight, pixels);\n            }\n        }\n\n        //Copy necessary pixels to new array if orientation >4\n        if (origorientation > 4) {\n            jint* tmpPixels = (jint *) malloc(sizeof(jint) * tmpPixelBufferSize);\n            uint32 startPosX = boundX%tileWidth /inSampleSize;\n            uint32 startPosY = boundY%tileHeight /inSampleSize;\n            for (int ox = startPosX, nx = 0; nx < boundWidth/inSampleSize; ox++, nx++) {\n                sendProgress(processedProgress + nx * (boundHeight/inSampleSize), progressTotal);\n                for (int oy = startPosY, ny = 0; ny < boundHeight/inSampleSize; oy++, ny++) {\n                    if (useOrientationTag) {\n                        tmpPixels[nx * (boundHeight/inSampleSize) + ny] = pixels[ox * *bitmapheight + oy];\n                    } else {\n                        tmpPixels[ny * (boundWidth/inSampleSize) + nx] = pixels[oy * *bitmapwidth + ox];\n                    }\n                }\n            }\n\n            free(pixels);\n            pixels = tmpPixels;\n            *bitmapwidth = boundWidth/inSampleSize;\n            *bitmapheight = boundHeight/inSampleSize;\n        }\n\n        return pixels;\n}",
    "void NativeDecoder::flipPixelsVertical(uint32 width, uint32 height, jint* raster) {\n    jint *bufferLine = (jint *) malloc(sizeof(jint) * width);\n    for (int line = 0; line < height / 2; line++) {\n        jint  *top_line, *bottom_line;\n        top_line = raster + width * line;\n        bottom_line = raster + width * (height - line -1);\n        _TIFFmemcpy(bufferLine, top_line, sizeof(jint) * width);\n        _TIFFmemcpy(top_line, bottom_line, sizeof(jint) * width);\n        _TIFFmemcpy(bottom_line, bufferLine, sizeof(jint) * width);\n    }\n    free(bufferLine);\n}",
    "jboolean TiffToPngConverter::convertFromStrip() {\n    uint32 stripSize = TIFFStripSize (tiffImage);\n    uint32 stripMax = TIFFNumberOfStrips (tiffImage);\n    int rowPerStrip = -1;\n    TIFFGetField(tiffImage, TIFFTAG_ROWSPERSTRIP, &rowPerStrip);\n    LOGII(\"RPS\", rowPerStrip);\n\n    unsigned long estimateMem = width * sizeof(uint32);//working buf\n    estimateMem += width * rowPerStrip * sizeof (uint32);//raster\n    estimateMem += 4 * outWidth * sizeof(png_bytep); //buf for writing to png\n    LOGII(\"estimateMem\", estimateMem);\n    if (estimateMem > availableMemory && availableMemory != -1) {\n        LOGEI(\"Not enought memory\", availableMemory);\n        if (throwException) {\n            throw_not_enought_memory_exception(env, availableMemory, estimateMem);\n        }\n        return JNI_FALSE;\n    }\n\n    jlong total = stripMax * rowPerStrip * width;\n    sendProgress(0, total);\n\n    uint32* work_line_buf = (uint32 *)_TIFFmalloc(width * sizeof(uint32));\n    uint32* raster = (uint32 *)_TIFFmalloc(width * rowPerStrip * sizeof (uint32));\n\n    uint32 rows_to_write = 0;\n\n    for (int i = 0; i < stripMax*rowPerStrip; i += rowPerStrip) {\n        if (checkStop()) {\n            if (raster) {\n                _TIFFfree(raster);\n                raster = NULL;\n            }\n            if (work_line_buf) {\n                _TIFFfree(work_line_buf);\n                work_line_buf = NULL;\n            }\n            return JNI_FALSE;\n        }\n        sendProgress(i * width, total);\n        TIFFReadRGBAStrip(tiffImage, i, raster);\n\n        rows_to_write = 0;\n        if( i + rowPerStrip > height )\n            rows_to_write = height - i;\n        else\n            rows_to_write = rowPerStrip;\n\n        if (origorientation <= 4) {\n            for (int line = 0; line < rows_to_write / 2; line++) {\n                unsigned int  *top_line, *bottom_line;\n                top_line = raster + width * line;\n                bottom_line = raster + width * (rows_to_write - line - 1);\n\n                _TIFFmemcpy(work_line_buf, top_line, sizeof(unsigned int) * width);\n                _TIFFmemcpy(top_line, bottom_line, sizeof(unsigned int) * width);\n                _TIFFmemcpy(bottom_line, work_line_buf, sizeof(unsigned int) * width);\n            }\n        }\n\n        if (origorientation == ORIENTATION_TOPRIGHT || origorientation == ORIENTATION_BOTRIGHT\n                || origorientation == ORIENTATION_RIGHTTOP || origorientation == ORIENTATION_RIGHTBOT) {\n\n                for (int y = 0; y < rows_to_write; y++) {\n                    for (int x = 0; x < width/2; x++) {\n                        uint32 buf = raster[y * width + x];\n                        raster[y * width + x] = raster[y * width + width - 1 - x];\n                        raster[y * width + width - 1 - x] = buf;\n                    }\n                }\n\n        }\n\n        int outY, outX;\n        for (int y = 0; y < rows_to_write; y++) {\n            if (i + y < outStartY || i + y >= outStartY + outHeight) continue;\n            outY = i + y - outStartY;\n            LOGII(\"out Y\", outY);\n            png_bytep pngrow = (png_bytep)malloc(4 * outWidth * sizeof(png_bytep));\n            memcpy(pngrow, raster + y * width + outStartX, outWidth * 4);\n            png_write_row(png_ptr, pngrow);\n            free(pngrow);\n        }\n\n    }\n\n    if (raster) {\n        _TIFFfree(raster);\n        raster = NULL;\n    }\n\n    if (work_line_buf) {\n        _TIFFfree(work_line_buf);\n        work_line_buf = NULL;\n    }\n\n    sendProgress(total, total);\n\n    return JNI_TRUE;\n}",
    "jboolean TiffToBmpConverter::convertFromStrip() {\n    uint32 stripSize = TIFFStripSize (tiffImage);\n    uint32 stripMax = TIFFNumberOfStrips (tiffImage);\n    int rowPerStrip = -1;\n    TIFFGetField(tiffImage, TIFFTAG_ROWSPERSTRIP, &rowPerStrip);\n\n    unsigned long estimateMem = width * sizeof(uint32);//working buf\n    estimateMem += width * rowPerStrip * sizeof (uint32);//raster\n    estimateMem += outWidth * 3 + outWidth % 4;\n    //estimateMem += 4 * width * sizeof(png_bytep); //buf for writing to png\n    LOGII(\"estimateMem\", estimateMem);\n    if (estimateMem > availableMemory && availableMemory != -1) {\n        LOGEI(\"Not enought memory\", availableMemory);\n        if (throwException) {\n            throw_not_enought_memory_exception(env, availableMemory, estimateMem);\n        }\n        return JNI_FALSE;\n    }\n\n    LOGII(\"rps\", rowPerStrip);\n    LOGII(\"sm\", stripMax);\n\n    jlong total = stripMax * rowPerStrip * width;\n    sendProgress(0, total);\n\n    uint32* work_line_buf = (uint32 *)_TIFFmalloc(width * sizeof(uint32));\n    uint32* raster = (uint32 *)_TIFFmalloc(width * rowPerStrip * sizeof (uint32));\n\n    uint32 rows_to_write = 0;\n\n    //24 bpp bmp should has with multiple 4\n    int rowSize = outWidth * 3 + outWidth % 4;\n    unsigned char *row = new unsigned char[rowSize];\n    for (int i = 0; i < stripMax*rowPerStrip; i += rowPerStrip) {\n        if (checkStop()) {\n            if (raster) {\n                _TIFFfree(raster);\n                raster = NULL;\n            }\n            if (work_line_buf) {\n                _TIFFfree(work_line_buf);\n                work_line_buf = NULL;\n            }\n            return JNI_FALSE;\n        }\n\n        if ((i < outStartY && i + rowPerStrip < outStartY) || (i >= outStartY + outHeight && i + rowPerStrip >= outStartY + outHeight)) continue;\n        LOGII(\"i\", i);\n\n        sendProgress(i * width, total);\n        TIFFReadRGBAStrip(tiffImage, i, raster);\n\n        rows_to_write = 0;\n        if( i + rowPerStrip > height )\n            rows_to_write = height - i;\n        else\n            rows_to_write = rowPerStrip;\n\n        if (origorientation <= 4) {\n            for (int line = 0; line < rows_to_write / 2; line++) {\n                unsigned int  *top_line, *bottom_line;\n                top_line = raster + width * line;\n                bottom_line = raster + width * (rows_to_write - line - 1);\n\n                _TIFFmemcpy(work_line_buf, top_line, sizeof(unsigned int) * width);\n                _TIFFmemcpy(top_line, bottom_line, sizeof(unsigned int) * width);\n                _TIFFmemcpy(bottom_line, work_line_buf, sizeof(unsigned int) * width);\n            }\n        }\n\n        if (origorientation == ORIENTATION_TOPRIGHT || origorientation == ORIENTATION_BOTRIGHT\n                || origorientation == ORIENTATION_RIGHTTOP || origorientation == ORIENTATION_RIGHTBOT) {\n\n                for (int y = 0; y < rows_to_write; y++) {\n                    for (int x = 0; x < width/2; x++) {\n                        uint32 buf = raster[y * width + x];\n                        raster[y * width + x] = raster[y * width + width - 1 - x];\n                        raster[y * width + width - 1 - x] = buf;\n                    }\n                }\n        }\n\n        int outY, outX;\n        for (int y = 0; y < rows_to_write; y++) {\n            if (i + y < outStartY || i + y >= outStartY + outHeight) continue;\n            outY = i + y - outStartY;\n            for (int x = 0; x < width * 3; x += 3) {\n                if (x < outStartX * 3 || x >= (outStartX + outWidth) * 3) continue;\n                outX = x - (outStartX*3);\n                uint32 pix = raster[y * width + x/3];\n                unsigned char *vp = (unsigned char *)&pix;\n                //in bmp colors stores as bgr\n                row[outX] = vp[2]; //red\n                row[outX+1] = vp[1]; //green\n                row[outX+2] = vp[0];   //blue\n            }\n\n            //in bmp lines stored fliped verticaly. Write lines from bottom to top\n            fseek(outFIle, 122 + (outHeight - outY - 1) * rowSize , SEEK_SET);\n            fwrite(row,rowSize,1,outFIle);\n        }\n    }\n    free(row);\n\n    if (raster) {\n        _TIFFfree(raster);\n        raster = NULL;\n    }\n\n    if (work_line_buf) {\n        _TIFFfree(work_line_buf);\n        work_line_buf = NULL;\n    }\n\n    sendProgress(total, total);\n\n    return JNI_TRUE;\n}",
    "jboolean TiffToJpgConverter::convertFromStrip() {\n    uint32 stripSize = TIFFStripSize (tiffImage);\n    uint32 stripMax = TIFFNumberOfStrips (tiffImage);\n    int rowPerStrip = -1;\n    TIFFGetField(tiffImage, TIFFTAG_ROWSPERSTRIP, &rowPerStrip);\n\n    unsigned long estimateMem = width * sizeof(uint32);//working buf\n    estimateMem += width * rowPerStrip * sizeof (uint32);//raster\n    estimateMem += outWidth * sizeof(unsigned char) * 3; //buf for writing to jpg\n    LOGII(\"estimateMem\", estimateMem);\n    if (estimateMem > availableMemory && availableMemory != -1) {\n        LOGEI(\"Not enought memory\", availableMemory);\n        if (throwException) {\n            throw_not_enought_memory_exception(env, availableMemory, estimateMem);\n        }\n        return JNI_FALSE;\n    }\n\n    jlong total = stripMax * rowPerStrip * width;\n    sendProgress(0, total);\n\n    uint32* work_line_buf = (uint32 *)_TIFFmalloc(width * sizeof(uint32));\n    uint32* raster = (uint32 *)_TIFFmalloc(width * rowPerStrip * sizeof (uint32));\n\n    uint32 rows_to_write = 0;\n\n    for (int i = 0; i < stripMax*rowPerStrip; i += rowPerStrip) {\n        if (checkStop()) {\n            if (raster) {\n                _TIFFfree(raster);\n                raster = NULL;\n            }\n            if (work_line_buf) {\n                _TIFFfree(work_line_buf);\n                work_line_buf = NULL;\n            }\n            return JNI_FALSE;\n        }\n        sendProgress(i * width, total);\n        TIFFReadRGBAStrip(tiffImage, i, raster);\n\n        rows_to_write = 0;\n        if( i + rowPerStrip > height )\n            rows_to_write = height - i;\n        else\n            rows_to_write = rowPerStrip;\n\n        if (origorientation <= 4) {\n            for (int line = 0; line < rows_to_write / 2; line++) {\n                unsigned int  *top_line, *bottom_line;\n                top_line = raster + width * line;\n                bottom_line = raster + width * (rows_to_write - line - 1);\n\n                _TIFFmemcpy(work_line_buf, top_line, sizeof(unsigned int) * width);\n                _TIFFmemcpy(top_line, bottom_line, sizeof(unsigned int) * width);\n                _TIFFmemcpy(bottom_line, work_line_buf, sizeof(unsigned int) * width);\n            }\n        }\n\n        if (origorientation == ORIENTATION_TOPRIGHT || origorientation == ORIENTATION_BOTRIGHT\n                || origorientation == ORIENTATION_RIGHTTOP || origorientation == ORIENTATION_RIGHTBOT) {\n\n                for (int y = 0; y < rows_to_write; y++) {\n                    for (int x = 0; x < width/2; x++) {\n                        uint32 buf = raster[y * width + x];\n                        raster[y * width + x] = raster[y * width + width - 1 - x];\n                        raster[y * width + width - 1 - x] = buf;\n                    }\n                }\n\n        }\n        int outY, outX;\n        JSAMPROW row_pointer[1];\n        for (int y = 0; y < rows_to_write; y++) {\n            if (i + y < outStartY || i + y >= outStartY + outHeight) continue;\n            outY = i + y - outStartY;\n\n            unsigned char *jpgrow = (unsigned char*)malloc(outWidth * sizeof(unsigned char) * 3);\n\n            for (int x = 0; x < width * 3; x += 3) {\n                if (x < outStartX * 3 || x >= (outStartX + outWidth) * 3) continue;\n                outX = x - (outStartX*3);\n                uint32 pix = raster[y * width + x/3];\n                unsigned char *vp = (unsigned char *)&pix;\n                jpgrow[outX] = vp[0];\n                jpgrow[outX+1] = vp[1];\n                jpgrow[outX+2] = vp[2];\n            }\n            row_pointer[0] = jpgrow;\n            jpeg_write_scanlines(&cinfo, row_pointer, 1);\n            delete(jpgrow);\n\n            /*png_bytep row = (png_bytep)malloc(4 * width * sizeof(png_bytep));\n            memcpy(row, raster + (y * width), width * 4);\n            png_write_row(png_ptr, row);\n            delete(row);*/\n        }\n\n    }\n\n    if (raster) {\n        _TIFFfree(raster);\n        raster = NULL;\n    }\n\n    if (work_line_buf) {\n        _TIFFfree(work_line_buf);\n        work_line_buf = NULL;\n    }\n\n    sendProgress(total, total);\n\n    return JNI_TRUE;\n}",
    "unsigned char* TIFFImage::readEncodedDataFromImage(const long long& startX, const long long& startY, const unsigned int& level) {\r\n  if (_tiff) {\r\n    unsigned int codec = 0;\r\n    TIFFGetField(_tiff, TIFFTAG_COMPRESSION, &codec);\r\n    if (codec == 7) { // New style JPEG\r\n      long long levelStartX = std::floor(startX / getLevelDownsample(level) + 0.5);\r\n      long long levelStartY = std::floor(startY / getLevelDownsample(level) + 0.5);\r\n      TIFFSetDirectory(_tiff, level);\r\n      unsigned int tileNr = TIFFComputeTile(_tiff, levelStartX, levelStartY, 0, 0);\r\n      if (tileNr < TIFFNumberOfTiles(_tiff)) {\r\n        unsigned char table_end[2];\r\n        unsigned int count = 0;\r\n        unsigned char* jpt;\r\n        float* xfloatp;\r\n        unsigned int endOfBuffer = 0;\r\n        unsigned long long datasize = this->getEncodedTileSize(startX, startY, level);\r\n        if (datasize < 0) {\r\n          return NULL;\r\n        }\r\n        unsigned long long bufferoffset = 0;\r\n        unsigned char* buffer = new unsigned char[datasize];\r\n\r\n        if (TIFFGetField(_tiff, TIFFTAG_JPEGTABLES, &count, &jpt) != 0) {\r\n          if (count > 4) {\r\n            int retTIFFReadRawTile;\r\n            /* Ignore EOI marker of JpegTables */\r\n            _TIFFmemcpy(buffer, jpt, count - 2);\r\n            bufferoffset += count - 2;\r\n            /* Store last 2 bytes of the JpegTables */\r\n            table_end[0] = buffer[bufferoffset - 2];\r\n            table_end[1] = buffer[bufferoffset - 1];\r\n            endOfBuffer = bufferoffset;\r\n            bufferoffset -= 2;\r\n            retTIFFReadRawTile = TIFFReadRawTile(\r\n              _tiff,\r\n              tileNr,\r\n              (void*)&(((unsigned char*)buffer)[bufferoffset]),\r\n              -1);\r\n            bufferoffset += retTIFFReadRawTile;\r\n            /* Overwrite SOI marker of image scan with previously */\r\n            /* saved end of JpegTables */\r\n            buffer[endOfBuffer - 2] = table_end[0];\r\n            buffer[endOfBuffer - 1] = table_end[1];\r\n          }\r\n        }\r\n        else {\r\n          TIFFReadRawTile(\r\n            _tiff,\r\n            tileNr,\r\n            (void*)&(((unsigned char*)buffer)[bufferoffset]),\r\n            -1);\r\n        }\r\n        return buffer;\r\n      }\r\n      else {\r\n        return NULL;\r\n      }\r\n    }\r\n    else {\r\n      return NULL;\r\n    }\r\n  }\r\n  else {\r\n    return NULL;\r\n  }\r\n}",
    "void CqTiffInputFile::readPixelsTiled(TqUint8* buffer, TqInt startLine,\n\t\tTqInt numScanlines) const\n{\n\t// Load in relevant tiles; discard the excess.  At this stage, we don't do\n\t// any caching, under the assumption that the user will want to load a\n\t// bunch of scanlines at once.  If they load a single scanline at a time,\n\t// this will be very inefficient.\n\tCqTiffDirHandle dirHandle(m_fileHandle, m_imageIndex);\n\n\t// lines of interest will be startLine to endLine (exclusive)\n\tTqInt endLine = startLine + numScanlines;\n\n\tSqTileInfo tileInfo = m_header.find<Attr::TileInfo>();\n\t// Compute the boundaries of the smallest tiled region containing the\n\t// scanlines we're interested in.\n\tTqInt startTileLine = (startLine/tileInfo.height) * tileInfo.height;\n\t// endTileLine is the start line of the row of tiles coming *after* the\n\t// last row we want to load.\n\tTqInt endTileLine = ((endLine-1)/tileInfo.height + 1) * tileInfo.height;\n\n\tTqInt width = m_header.width();\n\tTqInt bytesPerPixel = m_header.channelList().bytesPerPixel();\n\tTqInt lineSize = bytesPerPixel*width;\n\tTqInt tileLineSize = bytesPerPixel*tileInfo.width;\n\tTqInt tileSize = tileLineSize*tileInfo.height;\n\n\t// Buffer to hold tiles read using libtiff.\n\tboost::shared_array<TqUint8> tempTileBuf(\n\t\t\tstatic_cast<TqUint8*>(_TIFFmalloc(tileSize)),\n\t\t\t_TIFFfree);\n\n\tfor(TqInt y = startTileLine; y < endTileLine; y += tileInfo.height)\n\t{\n\t\t// Determine how much of the beginning and end of the current strip\n\t\t// should be skipped due to the tiles falling off the range of\n\t\t// relevant scanlines.\n\t\tTqInt outStripSkipStart =\n\t\t\t(y == startTileLine) ? startLine - startTileLine : 0;\n\t\tTqInt outStripSkipEnd =\n\t\t\t(y + tileInfo.height == endTileLine) ? endTileLine - endLine : 0;\n\t\t// The output \"Strip height\" for the current line of tiles might be\n\t\t// smaller than the tile height; take this into account here.\n\t\tTqInt stripHeightOut = tileInfo.height - outStripSkipStart - outStripSkipEnd;\n\n\t\tfor(TqInt x = 0; x < width; x += tileInfo.width)\n\t\t{\n\t\t\t// Grab the tile using libtiff\n\t\t\tTIFFReadTile(dirHandle.tiffPtr(),\n\t\t\t\t\tstatic_cast<tdata_t>(tempTileBuf.get()), x, y, 0, 0);\n\t\t\t// The width of the tile in the output image is smaller when it\n\t\t\t// falls of the RHS of the image.\n\t\t\tTqInt tileLineSizeOut = min(tileLineSize, bytesPerPixel*(width-x));\n\t\t\t// Copy the tile into the output buffer.\n\t\t\tTqUint8* lineBuf = buffer + x*bytesPerPixel;\n\t\t\tTqUint8* tileLineBuf = static_cast<TqUint8*>(tempTileBuf.get())\n\t\t\t\t+ outStripSkipStart*tileLineSize;\n\t\t\tfor(TqInt tileLine = 0; tileLine < stripHeightOut; ++tileLine)\n\t\t\t{\n\t\t\t\t_TIFFmemcpy(lineBuf, tileLineBuf, tileLineSizeOut);\n\t\t\t\ttileLineBuf += tileLineSize;\n\t\t\t\tlineBuf += lineSize;\n\t\t\t}\n\t\t}\n\t\tbuffer += lineSize*stripHeightOut;\n\t}\n}",
    "void TIFFImageHandler::TileCollapseLeft(tdata_t inBuffer, tsize_t inScanWidth, \n\t\t\t\t\t\t\t\t\t\tuint32 inTileWidth, uint32 inEdgeTileWidth, \n\t\t\t\t\t\t\t\t\t\tuint32 inTileLength)\n{\n\ttsize_t edgescanwidth=0;\n\t\n\tedgescanwidth = (inScanWidth * inEdgeTileWidth + (inTileWidth - 1))/ inTileWidth;\n\tfor(uint32 i=0;i<inTileLength;i++)\n\t{\n\t\t_TIFFmemcpy( \n\t\t\t&(((char*)inBuffer)[edgescanwidth*i]), \n\t\t\t&(((char*)inBuffer)[inScanWidth*i]), \n\t\t\tedgescanwidth);\n\t}\t\n}",
    "void TIFFImageHandler::TileCollapseLeft(tdata_t inBuffer, tsize_t inScanWidth, \n\t\t\t\t\t\t\t\t\t\tuint32_t inTileWidth, uint32_t inEdgeTileWidth, \n\t\t\t\t\t\t\t\t\t\tuint32_t inTileLength)\n{\n\ttsize_t edgescanwidth=0;\n\t\n\tedgescanwidth = (inScanWidth * inEdgeTileWidth + (inTileWidth - 1))/ inTileWidth;\n\tfor(uint32_t i=0;i<inTileLength;i++)\n\t{\n\t\t_TIFFmemcpy( \n\t\t\t&(((char*)inBuffer)[edgescanwidth*i]), \n\t\t\t&(((char*)inBuffer)[inScanWidth*i]), \n\t\t\tedgescanwidth);\n\t}\t\n}",
    "bool ScImgDataLoader_TIFF::getImageData(TIFF* tif, RawImage *image, uint widtht, uint heightt, uint size, uint16 photometric, uint16 bitspersample, uint16 samplesperpixel, bool &bilevel, bool &isCMYK)\n{\n\tuint32 *bits = nullptr;\n\tif (photometric == PHOTOMETRIC_SEPARATED)\n\t{\n\t\tif (samplesperpixel > 5)\n\t\t{\n\t\t\tif (!getImageData_RGBA(tif, image, widtht, heightt, size, bitspersample, samplesperpixel))\n\t\t\t\treturn false;\n\t\t\tif (bitspersample == 1)\n\t\t\t\tbilevel = true;\n\t\t\tisCMYK = false;\n\t\t\tm_pixelFormat = Format_RGBA_8;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (TIFFIsTiled(tif))\n\t\t\t{\n\t\t\t\tuint32 columns, rows;\n\t\t\t\tuint32 *tile_buf;\n\t\t\t\tuint32 xt, yt;\n\t\t\t\tTIFFGetField(tif, TIFFTAG_TILEWIDTH,  &columns);\n\t\t\t\tTIFFGetField(tif, TIFFTAG_TILELENGTH, &rows);\n\t\t\t\ttile_buf = (uint32*) _TIFFmalloc(columns*rows*sizeof(uint32));\n\t\t\t\tif (tile_buf == nullptr)\n\t\t\t\t{\n\t\t\t\t\tTIFFClose(tif);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tuint32 tileW = columns, tileH = rows;\n\t\t\t\tfor (yt = 0; yt < (uint32) image->height(); yt += rows)\n\t\t\t\t{\n\t\t\t\t\tif (yt > (uint) image->height())\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif (image->height()-yt < rows)\n\t\t\t\t\t\ttileH = image->height()-yt;\n\t\t\t\t\ttileW = columns;\n\t\t\t\t\tuint32 yi;\n\t\t\t\t\tint chans = image->channels();\n\t\t\t\t\tfor (xt = 0; xt < (uint) image->width(); xt += columns)\n\t\t\t\t\t{\n\t\t\t\t\t\tTIFFReadTile(tif, tile_buf, xt, yt, 0, 0);\n\t\t\t\t\t\tfor (yi = 0; yi < tileH; yi++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t_TIFFmemcpy(image->scanLine(yt+(tileH-1-yi))+xt, tile_buf+tileW*yi, tileW*chans);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_TIFFfree(tile_buf);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttsize_t bytesperrow = TIFFScanlineSize(tif);\n\t\t\t\tbits = (uint32 *) _TIFFmalloc(bytesperrow);\n\t\t\t\tint chans = image->channels();\n\t\t\t\tif (bits)\n\t\t\t\t{\n\t\t\t\t\tfor (unsigned int y = 0; y < heightt; y++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (TIFFReadScanline(tif, bits, y, 0))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/* The code below allows loading of CMYK TIFFs generated by ImageMagick, \n\t\t\t\t\t\t\t   currently commented out because its an ugly hack atm\n\t\t\t\t\t\t\t   When converting 8-bit PNGs with an alpha channel to CMYK Tiff, ImageMagick\n\t\t\t\t\t\t\t   creates a 16-bit CMYK Tiff !?!??\n\t\t\t\t\t\t\tif (bitspersample > 8)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tuchar *ptrT = image->scanLine(y);\n\t\t\t\t\t\t\t\tuchar *ptrS = (uchar*)bits;\n\t\t\t\t\t\t\t\tfor (unsigned int x = 0; x < widtht; x++)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tptrT[0] = ptrS[1];\n\t\t\t\t\t\t\t\t\tptrT[1] = ptrS[3];\n\t\t\t\t\t\t\t\t\tptrT[2] = ptrS[5];\n\t\t\t\t\t\t\t\t\tptrT[3] = ptrS[7];\n\t\t\t\t\t\t\t\t\tif (samplesperpixel > 4)\n\t\t\t\t\t\t\t\t\t\tptrT[4] = ptrS[9];\n\t\t\t\t\t\t\t\t\tptrT += chans;\n\t\t\t\t\t\t\t\t\tptrS += chans * 2;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse */\n\t\t\t\t\t\t\t\tmemcpy(image->scanLine(y), bits, chans * widtht);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t_TIFFfree(bits);\n\t\t\t\t}\n\t\t\t}\n\t\t\tisCMYK = true;\n\t\t\tm_pixelFormat = (image->channels() == 5) ? Format_CMYKA_8 : Format_CMYK_8;\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (!getImageData_RGBA(tif, image, widtht, heightt, size, bitspersample, samplesperpixel))\n\t\t\treturn false;\n\t\tif (bitspersample == 1)\n\t\t\tbilevel = true;\n\t\tm_pixelFormat = Format_RGBA_8;\n\t}\n\treturn true;\n}",
    "bool ScImgDataLoader_TIFF::getImageData(TIFF* tif, RawImage *image, uint widtht, uint heightt, uint size, const SampleFormatInfo& sampleInfo, bool &bilevel, bool &isCMYK)\n{\n\tif (sampleInfo.photometric != PHOTOMETRIC_SEPARATED)\n\t{\n\t\tif (!getImageData_RGBA(tif, image, widtht, heightt, size, sampleInfo))\n\t\t\treturn false;\n\t\tif (sampleInfo.bitsPerSample == 1)\n\t\t\tbilevel = true;\n\t\tm_pixelFormat = Format_RGBA_8;\n\t\treturn true;\n\t}\n\n\t// Now we are in the PHOTOMETRIC_SEPARATED case\n\tif (sampleInfo.samplesPerPixel > 5)\n\t{\n\t\tif (!getImageData_RGBA(tif, image, widtht, heightt, size, sampleInfo))\n\t\t\treturn false;\n\t\tif (sampleInfo.bitsPerSample == 1)\n\t\t\tbilevel = true;\n\t\tisCMYK = false;\n\t\tm_pixelFormat = Format_RGBA_8;\n\t\treturn true;\n\t}\n\n\tif (sampleInfo.samplesFormat != SAMPLEFORMAT_UINT && sampleInfo.samplesFormat != SAMPLEFORMAT_INT)\n\t{\n\t\tm_message = QObject::tr(\"This image uses an unsupported non integer sample format\");\n\t\tm_msgType = errorMsg;\n\t\treturn false;\n\t}\n\n\tif (sampleInfo.bitsPerSample > 16)\n\t{\n\t\tm_message = QObject::tr(\"This image uses an unsupported bit depth: %1 bits per sample.\").arg(sampleInfo.bitsPerSample);\n\t\tm_msgType = errorMsg;\n\t\treturn false;\n\t}\n\n\tif (TIFFIsTiled(tif))\n\t{\n\t\tuint32_t columns, rows;\n\t\tuint32_t *tile_buf;\n\t\tuint32_t xt, yt;\n\t\tTIFFGetField(tif, TIFFTAG_TILEWIDTH,  &columns);\n\t\tTIFFGetField(tif, TIFFTAG_TILELENGTH, &rows);\n\t\ttile_buf = (uint32_t*) _TIFFmalloc(columns * rows * sizeof(uint32_t));\n\t\tif (tile_buf == nullptr)\n\t\t{\n\t\t\tTIFFClose(tif);\n\t\t\treturn false;\n\t\t}\n\t\tuint32_t tileW = columns, tileH = rows;\n\t\tfor (yt = 0; yt < (uint32_t) image->height(); yt += rows)\n\t\t{\n\t\t\tif (yt > (uint) image->height())\n\t\t\t\tbreak;\n\t\t\tif (image->height() - yt < rows)\n\t\t\t\ttileH = image->height() - yt;\n\t\t\ttileW = columns;\n\t\t\tuint32_t yi;\n\t\t\tint chans = image->channels();\n\t\t\tfor (xt = 0; xt < (uint) image->width(); xt += columns)\n\t\t\t{\n\t\t\t\tTIFFReadTile(tif, tile_buf, xt, yt, 0, 0);\n\t\t\t\tfor (yi = 0; yi < tileH; yi++)\n\t\t\t\t{\n\t\t\t\t\t_TIFFmemcpy(image->scanLine(yt + (tileH - 1 - yi)) + xt, tile_buf + tileW * yi, tileW * chans);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_TIFFfree(tile_buf);\n\t}\n\telse\n\t{\n\t\tint chans = image->channels();\n\t\ttsize_t bytesperrow = TIFFScanlineSize(tif);\n\t\tuint32_t *bits = (uint32_t *) _TIFFmalloc(bytesperrow);\n\t\tif (bits)\n\t\t{\n\t\t\tfor (unsigned int y = 0; y < heightt; y++)\n\t\t\t{\n\t\t\t\tif (!TIFFReadScanline(tif, bits, y, 0))\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (sampleInfo.bitsPerSample == 16 && sampleInfo.samplesFormat == SAMPLEFORMAT_UINT)\n\t\t\t\t\tconvertImageData((uint16_t*) bits, (uint8_t*) image->scanLine(y), chans * widtht);\n\t\t\t\telse if (sampleInfo.bitsPerSample == 16 && sampleInfo.samplesFormat == SAMPLEFORMAT_INT)\n\t\t\t\t\tconvertImageData((int16_t*) bits, (uint8_t*) image->scanLine(y), chans * widtht);\n\t\t\t\telse\n\t\t\t\t\tmemcpy(image->scanLine(y), bits, chans * widtht);\n\t\t\t}\n\t\t\t_TIFFfree(bits);\n\t\t}\n\t}\n\tisCMYK = true;\n\tm_pixelFormat = (image->channels() == 5) ? Format_CMYKA_8 : Format_CMYK_8;\n\n\treturn true;\n}"
]