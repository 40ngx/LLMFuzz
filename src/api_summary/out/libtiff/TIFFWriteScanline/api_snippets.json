[
    "bool TiffEncoder::Encode(const struct heif_image_handle *handle,\n                         const struct heif_image *image, const std::string &filename)\n{\n    TIFF *tif = TIFFOpen(filename.c_str(), \"w\");\n\n    // For now we write interleaved\n    int width = heif_image_get_width(image, heif_channel_interleaved);\n    int height = heif_image_get_height(image, heif_channel_interleaved);\n    bool hasAlpha = ((heif_image_get_chroma_format(image) == heif_chroma_interleaved_RGBA) ||\n                     (heif_image_get_chroma_format(image) == heif_chroma_interleaved_RRGGBBAA_BE));\n    int input_bpp = heif_image_get_bits_per_pixel_range(image, heif_channel_interleaved);\n\n    TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, width);\n    TIFFSetField(tif, TIFFTAG_IMAGELENGTH, height);\n    TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, input_bpp);\n    TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, hasAlpha ? 4 : 3);\n    if (hasAlpha)\n    {\n        // TODO: is alpha premultiplied?\n        uint16_t extra_samples[1] = {EXTRASAMPLE_UNASSALPHA};\n        TIFFSetField(tif, TIFFTAG_EXTRASAMPLES, 1, &extra_samples);\n    }\n    TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, 1);\n    TIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n    TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n    TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT);\n    TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n\n    int stride_rgb;\n    const uint8_t *row_rgb = heif_image_get_plane_readonly(image,\n                                                           heif_channel_interleaved, &stride_rgb);\n\n    for (int i = 0; i < height; i++)\n    {\n        // memcpy(scan_line, &buffer[i * width], width * sizeof(uint32));\n        TIFFWriteScanline(tif, (void *)(&(row_rgb[i * stride_rgb])), i, 0);\n    }\n    TIFFClose(tif);\n    return true;\n}",
    "void save_tiff(Image &img, std::string file)\n    {\n        auto d_depth = img.depth();\n        auto d_channels = img.channels();\n        auto d_height = img.height();\n        auto d_width = img.width();\n\n        if (img.size() == 0 || d_height == 0) // Make sure we aren't just gonna crash\n        {\n            logger->trace(\"Tried to save empty TIFF!\");\n            return;\n        }\n\n        TIFF *tif = TIFFOpen(file.c_str(), \"w\");\n        if (tif)\n        {\n            TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, d_width);\n            TIFFSetField(tif, TIFFTAG_IMAGELENGTH, d_height);\n            TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, d_channels);\n            TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, d_depth);\n            TIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n            TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n            TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, d_channels == 1 ? PHOTOMETRIC_MINISBLACK : PHOTOMETRIC_RGB);\n            if (d_channels == 4)\n            {\n                uint16_t out[1];\n                out[0] = EXTRASAMPLE_UNASSALPHA;\n                TIFFSetField(tif, TIFFTAG_EXTRASAMPLES, 1, &out);\n            }\n\n            tsize_t linebytes = d_channels * d_width * (d_depth == 8 ? sizeof(uint8_t) : sizeof(uint16_t));\n\n            unsigned char *buf = NULL;\n            if (TIFFScanlineSize(tif) == linebytes)\n                buf = (unsigned char *)_TIFFmalloc(linebytes);\n            else\n                buf = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(tif));\n\n            TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, TIFFDefaultStripSize(tif, d_width * d_channels));\n\n            for (size_t y = 0; y < d_height; y++)\n            {\n                for (size_t x = 0; x < d_width; x++)\n                {\n                    size_t i2 = /*((d_height - 1) - y)*/ y * d_width + x;\n                    if (d_depth == 8)\n                    {\n                        for (int i = 0; i < d_channels; i++)\n                            ((uint8_t *)buf)[x * d_channels + i] = img.get(i, i2);\n                    }\n                    else if (d_depth == 16)\n                    {\n                        for (int i = 0; i < d_channels; i++)\n                            ((uint16_t *)buf)[x * d_channels + i] = img.get(i, i2);\n                    }\n                }\n\n                if (TIFFWriteScanline(tif, buf, y, 0) < 0)\n                    break;\n            }\n\n            _TIFFfree(buf);\n\n            if (image::has_metadata(img))\n            {\n                nlohmann::json meta = image::get_metadata(img);\n                if (meta.contains(\"proj_cfg\"))\n                {\n                    try\n                    {\n                        proj::projection_t proj = meta[\"proj_cfg\"];\n                        geotiff::try_write_geotiff(tif, &proj);\n                    }\n                    catch (std::exception &)\n                    {\n                    }\n                }\n            }\n\n            TIFFClose(tif);\n        }\n    }",
    "static BOOL \nSaveOneTIFF(FreeImageIO *io, FIBITMAP *dib, fi_handle handle, int page, int flags, void *data, unsigned ifd, unsigned ifdCount) {\n\tif (!dib || !handle || !data) {\n\t\treturn FALSE;\n\t} \n\t\n\ttry { \n\t\tfi_TIFFIO *fio = (fi_TIFFIO*)data;\n\t\tTIFF *out = fio->tif;\n\n\t\tconst FREE_IMAGE_TYPE image_type = FreeImage_GetImageType(dib);\n\n\t\tconst uint32 width = FreeImage_GetWidth(dib);\n\t\tconst uint32 height = FreeImage_GetHeight(dib);\n\t\tconst uint16 bitsperpixel = (uint16)FreeImage_GetBPP(dib);\n\n\t\tconst FIICCPROFILE* iccProfile = FreeImage_GetICCProfile(dib);\n\t\t\n\t\t// setup out-variables based on dib and flag options\n\t\t\n\t\tuint16 bitspersample;\n\t\tuint16 samplesperpixel;\n\t\tuint16 photometric;\n\n\t\tif(image_type == FIT_BITMAP) {\n\t\t\t// standard image: 1-, 4-, 8-, 16-, 24-, 32-bit\n\n\t\t\tsamplesperpixel = ((bitsperpixel == 24) ? 3 : ((bitsperpixel == 32) ? 4 : 1));\n\t\t\tbitspersample = bitsperpixel / samplesperpixel;\n\t\t\tphotometric\t= GetPhotometric(dib);\n\n\t\t\tif((bitsperpixel == 8) && FreeImage_IsTransparent(dib)) {\n\t\t\t\t// 8-bit transparent picture : convert later to 8-bit + 8-bit alpha\n\t\t\t\tsamplesperpixel = 2;\n\t\t\t\tbitspersample = 8;\n\t\t\t}\n\t\t\telse if(bitsperpixel == 32) {\n\t\t\t\t// 32-bit images : check for CMYK or alpha transparency\n\n\t\t\t\tif((((iccProfile->flags & FIICC_COLOR_IS_CMYK) == FIICC_COLOR_IS_CMYK) || ((flags & TIFF_CMYK) == TIFF_CMYK))) {\n\t\t\t\t\t// CMYK support\n\t\t\t\t\tphotometric = PHOTOMETRIC_SEPARATED;\n\t\t\t\t\tTIFFSetField(out, TIFFTAG_INKSET, INKSET_CMYK);\n\t\t\t\t\tTIFFSetField(out, TIFFTAG_NUMBEROFINKS, 4);\n\t\t\t\t}\n\t\t\t\telse if(photometric == PHOTOMETRIC_RGB) {\n\t\t\t\t\t// transparency mask support\n\t\t\t\t\tuint16 sampleinfo[1]; \n\t\t\t\t\t// unassociated alpha data is transparency information\n\t\t\t\t\tsampleinfo[0] = EXTRASAMPLE_UNASSALPHA;\n\t\t\t\t\tTIFFSetField(out, TIFFTAG_EXTRASAMPLES, 1, sampleinfo);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if(image_type == FIT_RGB16) {\n\t\t\t// 48-bit RGB\n\n\t\t\tsamplesperpixel = 3;\n\t\t\tbitspersample = bitsperpixel / samplesperpixel;\n\t\t\tphotometric\t= PHOTOMETRIC_RGB;\n\t\t} else if(image_type == FIT_RGBA16) {\n\t\t\t// 64-bit RGBA\n\n\t\t\tsamplesperpixel = 4;\n\t\t\tbitspersample = bitsperpixel / samplesperpixel;\n\t\t\tif((((iccProfile->flags & FIICC_COLOR_IS_CMYK) == FIICC_COLOR_IS_CMYK) || ((flags & TIFF_CMYK) == TIFF_CMYK))) {\n\t\t\t\t// CMYK support\n\t\t\t\tphotometric = PHOTOMETRIC_SEPARATED;\n\t\t\t\tTIFFSetField(out, TIFFTAG_INKSET, INKSET_CMYK);\n\t\t\t\tTIFFSetField(out, TIFFTAG_NUMBEROFINKS, 4);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tphotometric\t= PHOTOMETRIC_RGB;\n\t\t\t\t// transparency mask support\n\t\t\t\tuint16 sampleinfo[1]; \n\t\t\t\t// unassociated alpha data is transparency information\n\t\t\t\tsampleinfo[0] = EXTRASAMPLE_UNASSALPHA;\n\t\t\t\tTIFFSetField(out, TIFFTAG_EXTRASAMPLES, 1, sampleinfo);\n\t\t\t}\n\t\t} else if(image_type == FIT_RGBF) {\n\t\t\t// 96-bit RGBF => store with a LogLuv encoding ?\n\n\t\t\tsamplesperpixel = 3;\n\t\t\tbitspersample = bitsperpixel / samplesperpixel;\n\t\t\t// the library converts to and from floating-point XYZ CIE values\n\t\t\tif((flags & TIFF_LOGLUV) == TIFF_LOGLUV) {\n\t\t\t\tphotometric\t= PHOTOMETRIC_LOGLUV;\n\t\t\t\tTIFFSetField(out, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_FLOAT);\n\t\t\t\t// TIFFSetField(out, TIFFTAG_STONITS, 1.0);   // assume unknown \n\t\t\t}\n\t\t\telse {\n\t\t\t\t// store with default compression (LZW) or with input compression flag\n\t\t\t\tphotometric\t= PHOTOMETRIC_RGB;\n\t\t\t}\n\t\t\t\n\t\t} else if (image_type == FIT_RGBAF) {\n\t\t\t// 128-bit RGBAF => store with default compression (LZW) or with input compression flag\n\t\t\t\n\t\t\tsamplesperpixel = 4;\n\t\t\tbitspersample = bitsperpixel / samplesperpixel;\n\t\t\tphotometric\t= PHOTOMETRIC_RGB;\n\t\t} else {\n\t\t\t// special image type (int, long, double, ...)\n\t\t\t\n\t\t\tsamplesperpixel = 1;\n\t\t\tbitspersample = bitsperpixel;\n\t\t\tphotometric\t= PHOTOMETRIC_MINISBLACK;\n\t\t}\n\n\t\t// set image data type\n\n\t\tWriteImageType(out, image_type);\n\t\t\n\t\t// write possible ICC profile\n\n\t\tif (iccProfile->size && iccProfile->data) {\n\t\t\tTIFFSetField(out, TIFFTAG_ICCPROFILE, iccProfile->size, iccProfile->data);\n\t\t}\n\n\t\t// handle standard width/height/bpp stuff\n\n\t\tTIFFSetField(out, TIFFTAG_IMAGEWIDTH, width);\n\t\tTIFFSetField(out, TIFFTAG_IMAGELENGTH, height);\n\t\tTIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, samplesperpixel);\n\t\tTIFFSetField(out, TIFFTAG_BITSPERSAMPLE, bitspersample);\n\t\tTIFFSetField(out, TIFFTAG_PHOTOMETRIC, photometric);\n\t\tTIFFSetField(out, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\t// single image plane \n\t\tTIFFSetField(out, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n\t\tTIFFSetField(out, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);\n\t\tTIFFSetField(out, TIFFTAG_ROWSPERSTRIP, TIFFDefaultStripSize(out, (uint32) -1)); \n\n\t\t// handle metrics\n\n\t\tWriteResolution(out, dib);\n\n\t\t// multi-paging\n\n\t\tif (page >= 0) {\n\t\t\tchar page_number[20];\n\t\t\tsprintf(page_number, \"Page %d\", page);\n\n\t\t\tTIFFSetField(out, TIFFTAG_SUBFILETYPE, (uint32)FILETYPE_PAGE);\n\t\t\tTIFFSetField(out, TIFFTAG_PAGENUMBER, (uint16)page, (uint16)0);\n\t\t\tTIFFSetField(out, TIFFTAG_PAGENAME, page_number);\n\n\t\t} else {\n\t\t\t// is it a thumbnail ? \n\t\t\tTIFFSetField(out, TIFFTAG_SUBFILETYPE, (ifd == 0) ? (uint32)0 : (uint32)FILETYPE_REDUCEDIMAGE);\n\t\t}\n\n\t\t// palettes (image colormaps are automatically scaled to 16-bits)\n\n\t\tif (photometric == PHOTOMETRIC_PALETTE) {\n\t\t\tuint16 *r, *g, *b;\n\t\t\tuint16 nColors = (uint16)FreeImage_GetColorsUsed(dib);\n\t\t\tRGBQUAD *pal = FreeImage_GetPalette(dib);\n\n\t\t\tr = (uint16 *) _TIFFmalloc(sizeof(uint16) * 3 * nColors);\n\t\t\tif(r == NULL) {\n\t\t\t\tthrow FI_MSG_ERROR_MEMORY;\n\t\t\t}\n\t\t\tg = r + nColors;\n\t\t\tb = g + nColors;\n\n\t\t\tfor (int i = nColors - 1; i >= 0; i--) {\n\t\t\t\tr[i] = SCALE((uint16)pal[i].rgbRed);\n\t\t\t\tg[i] = SCALE((uint16)pal[i].rgbGreen);\n\t\t\t\tb[i] = SCALE((uint16)pal[i].rgbBlue);\n\t\t\t}\n\n\t\t\tTIFFSetField(out, TIFFTAG_COLORMAP, r, g, b);\n\n\t\t\t_TIFFfree(r);\n\t\t}\n\n\t\t// compression tag\n\n\t\tWriteCompression(out, bitspersample, samplesperpixel, photometric, flags);\n\n\t\t// metadata\n\n\t\tWriteMetadata(out, dib);\n\n\t\t// thumbnail tag\n\n\t\tif((ifd == 0) && (ifdCount > 1)) {\n\t\t\tuint16 nsubifd = 1;\n\t\t\tuint64 subifd[1];\n\t\t\tsubifd[0] = 0;\n\t\t\tTIFFSetField(out, TIFFTAG_SUBIFD, nsubifd, subifd);\n\t\t}\n\n\t\t// read the DIB lines from bottom to top\n\t\t// and save them in the TIF\n\t\t// -------------------------------------\n\t\t\n\t\tconst uint32 pitch = FreeImage_GetPitch(dib);\n\n\t\tif(image_type == FIT_BITMAP) {\n\t\t\t// standard bitmap type\n\t\t\n\t\t\tswitch(bitsperpixel) {\n\t\t\t\tcase 1 :\n\t\t\t\tcase 4 :\n\t\t\t\tcase 8 :\n\t\t\t\t{\n\t\t\t\t\tif((bitsperpixel == 8) && FreeImage_IsTransparent(dib)) {\n\t\t\t\t\t\t// 8-bit transparent picture : convert to 8-bit + 8-bit alpha\n\n\t\t\t\t\t\t// get the transparency table\n\t\t\t\t\t\tBYTE *trns = FreeImage_GetTransparencyTable(dib);\n\n\t\t\t\t\t\tBYTE *buffer = (BYTE *)malloc(2 * width * sizeof(BYTE));\n\t\t\t\t\t\tif(buffer == NULL) {\n\t\t\t\t\t\t\tthrow FI_MSG_ERROR_MEMORY;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (int y = height - 1; y >= 0; y--) {\n\t\t\t\t\t\t\tBYTE *bits = FreeImage_GetScanLine(dib, y);\n\n\t\t\t\t\t\t\tBYTE *p = bits, *b = buffer;\n\n\t\t\t\t\t\t\tfor(uint32 x = 0; x < width; x++) {\n\t\t\t\t\t\t\t\t// copy the 8-bit layer\n\t\t\t\t\t\t\t\tb[0] = *p;\n\t\t\t\t\t\t\t\t// convert the trns table to a 8-bit alpha layer\n\t\t\t\t\t\t\t\tb[1] = trns[ b[0] ];\n\n\t\t\t\t\t\t\t\tp++;\n\t\t\t\t\t\t\t\tb += samplesperpixel;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// write the scanline to disc\n\n\t\t\t\t\t\t\tTIFFWriteScanline(out, buffer, height - y - 1, 0);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfree(buffer);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// other cases\n\t\t\t\t\t\tBYTE *buffer = (BYTE *)malloc(pitch * sizeof(BYTE));\n\t\t\t\t\t\tif(buffer == NULL) {\n\t\t\t\t\t\t\tthrow FI_MSG_ERROR_MEMORY;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (uint32 y = 0; y < height; y++) {\n\t\t\t\t\t\t\t// get a copy of the scanline\n\t\t\t\t\t\t\tmemcpy(buffer, FreeImage_GetScanLine(dib, height - y - 1), pitch);\n\t\t\t\t\t\t\t// write the scanline to disc\n\t\t\t\t\t\t\tTIFFWriteScanline(out, buffer, y, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree(buffer);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\t\t\t\t\n\n\t\t\t\tcase 24:\n\t\t\t\tcase 32:\n\t\t\t\t{\n\t\t\t\t\tBYTE *buffer = (BYTE *)malloc(pitch * sizeof(BYTE));\n\t\t\t\t\tif(buffer == NULL) {\n\t\t\t\t\t\tthrow FI_MSG_ERROR_MEMORY;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (uint32 y = 0; y < height; y++) {\n\t\t\t\t\t\t// get a copy of the scanline\n\n\t\t\t\t\t\tmemcpy(buffer, FreeImage_GetScanLine(dib, height - y - 1), pitch);\n\n#if FREEIMAGE_COLORORDER == FREEIMAGE_COLORORDER_BGR\n\t\t\t\t\t\tif (photometric != PHOTOMETRIC_SEPARATED) {\n\t\t\t\t\t\t\t// TIFFs store color data RGB(A) instead of BGR(A)\n\t\t\n\t\t\t\t\t\t\tBYTE *pBuf = buffer;\n\t\t\n\t\t\t\t\t\t\tfor (uint32 x = 0; x < width; x++) {\n\t\t\t\t\t\t\t\tINPLACESWAP(pBuf[0], pBuf[2]);\n\t\t\t\t\t\t\t\tpBuf += samplesperpixel;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t\t// write the scanline to disc\n\n\t\t\t\t\t\tTIFFWriteScanline(out, buffer, y, 0);\n\t\t\t\t\t}\n\n\t\t\t\t\tfree(buffer);\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}//< switch (bitsperpixel)\n\n\t\t} else if(image_type == FIT_RGBF && (flags & TIFF_LOGLUV) == TIFF_LOGLUV) {\n\t\t\t// RGBF image => store as XYZ using a LogLuv encoding\n\n\t\t\tBYTE *buffer = (BYTE *)malloc(pitch * sizeof(BYTE));\n\t\t\tif(buffer == NULL) {\n\t\t\t\tthrow FI_MSG_ERROR_MEMORY;\n\t\t\t}\n\n\t\t\tfor (uint32 y = 0; y < height; y++) {\n\t\t\t\t// get a copy of the scanline and convert from RGB to XYZ\n\t\t\t\ttiff_ConvertLineRGBToXYZ(buffer, FreeImage_GetScanLine(dib, height - y - 1), width);\n\t\t\t\t// write the scanline to disc\n\t\t\t\tTIFFWriteScanline(out, buffer, y, 0);\n\t\t\t}\n\t\t\tfree(buffer);\n\t\t} else {\n\t\t\t// just dump the dib (tiff supports all dib types)\n\t\t\t\n\t\t\tBYTE *buffer = (BYTE *)malloc(pitch * sizeof(BYTE));\n\t\t\tif(buffer == NULL) {\n\t\t\t\tthrow FI_MSG_ERROR_MEMORY;\n\t\t\t}\n\t\t\t\n\t\t\tfor (uint32 y = 0; y < height; y++) {\n\t\t\t\t// get a copy of the scanline\n\t\t\t\tmemcpy(buffer, FreeImage_GetScanLine(dib, height - y - 1), pitch);\n\t\t\t\t// write the scanline to disc\n\t\t\t\tTIFFWriteScanline(out, buffer, y, 0);\n\t\t\t}\n\t\t\tfree(buffer);\n\t\t}\n\n\t\t// write out the directory tag if we wrote a page other than -1 or if we have a thumbnail to write later\n\n\t\tif( (page >= 0) || ((ifd == 0) && (ifdCount > 1)) ) {\n\t\t\tTIFFWriteDirectory(out);\n\t\t\t// else: TIFFClose will WriteDirectory\n\t\t}\n\n\t\treturn TRUE;\n\t\t\n\t} catch(const char *text) {\n\t\tFreeImage_OutputMessageProc(s_format_id, text);\n\t\treturn FALSE;\n\t} \n}",
    "int DNGWriter::write(const char *filename, const Camera *camera,\n\t\t     const StreamConfiguration &config,\n\t\t     const ControlList &metadata,\n\t\t     [[maybe_unused]] const FrameBuffer *buffer,\n\t\t     const void *data)\n{\n\tconst ControlList &cameraProperties = camera->properties();\n\n\tconst auto it = formatInfo.find(config.pixelFormat);\n\tif (it == formatInfo.cend()) {\n\t\tstd::cerr << \"Unsupported pixel format\" << std::endl;\n\t\treturn -EINVAL;\n\t}\n\tconst FormatInfo *info = &it->second;\n\n\tTIFF *tif = TIFFOpen(filename, \"w\");\n\tif (!tif) {\n\t\tstd::cerr << \"Failed to open tiff file\" << std::endl;\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Scanline buffer, has to be large enough to store both a RAW scanline\n\t * or a thumbnail scanline. The latter will always be much smaller than\n\t * the former as we downscale by 16 in both directions.\n\t */\n\tstd::vector<uint8_t> scanline((config.size.width * info->bitsPerSample + 7) / 8);\n\n\ttoff_t rawIFDOffset = 0;\n\ttoff_t exifIFDOffset = 0;\n\n\t/*\n\t * Start with a thumbnail in IFD 0 for compatibility with TIFF baseline\n\t * readers, as required by the TIFF/EP specification. Tags that apply to\n\t * the whole file are stored here.\n\t */\n\tconst uint8_t version[] = { 1, 2, 0, 0 };\n\n\tTIFFSetField(tif, TIFFTAG_DNGVERSION, version);\n\tTIFFSetField(tif, TIFFTAG_DNGBACKWARDVERSION, version);\n\tTIFFSetField(tif, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);\n\tTIFFSetField(tif, TIFFTAG_MAKE, \"libcamera\");\n\n\tconst auto &model = cameraProperties.get(properties::Model);\n\tif (model) {\n\t\tTIFFSetField(tif, TIFFTAG_MODEL, model->c_str());\n\t\t/* \\todo set TIFFTAG_UNIQUECAMERAMODEL. */\n\t}\n\n\tTIFFSetField(tif, TIFFTAG_SOFTWARE, \"qcam\");\n\tTIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n\n\t/*\n\t * Thumbnail-specific tags. The thumbnail is stored as an RGB image\n\t * with 1/16 of the raw image resolution. Greyscale would save space,\n\t * but doesn't seem well supported by RawTherapee.\n\t */\n\tTIFFSetField(tif, TIFFTAG_SUBFILETYPE, FILETYPE_REDUCEDIMAGE);\n\tTIFFSetField(tif, TIFFTAG_IMAGEWIDTH, config.size.width / 16);\n\tTIFFSetField(tif, TIFFTAG_IMAGELENGTH, config.size.height / 16);\n\tTIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8);\n\tTIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n\tTIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n\tTIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 3);\n\tTIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\tTIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT);\n\n\t/*\n\t * Fill in some reasonable colour information in the DNG. We supply\n\t * the \"neutral\" colour values which determine the white balance, and the\n\t * \"ColorMatrix1\" which converts XYZ to (un-white-balanced) camera RGB.\n\t * Note that this is not a \"proper\" colour calibration for the DNG,\n\t * nonetheless, many tools should be able to render the colours better.\n\t */\n\tfloat neutral[3] = { 1, 1, 1 };\n\tMatrix3d wbGain = Matrix3d::identity();\n\t/* From http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html */\n\tconst Matrix3d rgb2xyz(0.4124564, 0.3575761, 0.1804375,\n\t\t\t       0.2126729, 0.7151522, 0.0721750,\n\t\t\t       0.0193339, 0.1191920, 0.9503041);\n\tMatrix3d ccm = Matrix3d::identity();\n\t/*\n\t * Pick a reasonable number eps to protect against singularities. It\n\t * should be comfortably larger than the point at which we run into\n\t * numerical trouble, yet smaller than any plausible gain that we might\n\t * apply to a colour, either explicitly or as part of the colour matrix.\n\t */\n\tconst double eps = 1e-2;\n\n\tconst auto &colourGains = metadata.get(controls::ColourGains);\n\tif (colourGains) {\n\t\tif ((*colourGains)[0] > eps && (*colourGains)[1] > eps) {\n\t\t\twbGain = Matrix3d::diag((*colourGains)[0], 1, (*colourGains)[1]);\n\t\t\tneutral[0] = 1.0 / (*colourGains)[0]; /* red */\n\t\t\tneutral[2] = 1.0 / (*colourGains)[1]; /* blue */\n\t\t}\n\t}\n\n\tconst auto &ccmControl = metadata.get(controls::ColourCorrectionMatrix);\n\tif (ccmControl) {\n\t\tMatrix3d ccmSupplied(*ccmControl);\n\t\tif (ccmSupplied.determinant() > eps)\n\t\t\tccm = ccmSupplied;\n\t}\n\n\t/*\n\t * rgb2xyz is known to be invertible, and we've ensured above that both\n\t * the ccm and wbGain matrices are non-singular, so the product of all\n\t * three is guaranteed to be invertible too.\n\t */\n\tMatrix3d colorMatrix1 = (rgb2xyz * ccm * wbGain).inverse();\n\n\tTIFFSetField(tif, TIFFTAG_COLORMATRIX1, 9, colorMatrix1.m);\n\tTIFFSetField(tif, TIFFTAG_ASSHOTNEUTRAL, 3, neutral);\n\n\t/*\n\t * Reserve space for the SubIFD and ExifIFD tags, pointing to the IFD\n\t * for the raw image and EXIF data respectively. The real offsets will\n\t * be set later.\n\t */\n\tTIFFSetField(tif, TIFFTAG_SUBIFD, 1, &rawIFDOffset);\n\tTIFFSetField(tif, TIFFTAG_EXIFIFD, exifIFDOffset);\n\n\t/* Write the thumbnail. */\n\tconst uint8_t *row = static_cast<const uint8_t *>(data);\n\tfor (unsigned int y = 0; y < config.size.height / 16; y++) {\n\t\tinfo->thumbScanline(*info, scanline.data(), row,\n\t\t\t\t    config.size.width / 16, config.stride);\n\n\t\tif (TIFFWriteScanline(tif, scanline.data(), y, 0) != 1) {\n\t\t\tstd::cerr << \"Failed to write thumbnail scanline\"\n\t\t\t\t  << std::endl;\n\t\t\tTIFFClose(tif);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\trow += config.stride * 16;\n\t}\n\n\tTIFFWriteDirectory(tif);\n\n\t/*\n\t * Workaround for a bug introduced in libtiff version 4.5.1 and no fix\n\t * released. In these versions the CFA* tags were missing in the field\n\t * info.\n\t * Introduced by: https://gitlab.com/libtiff/libtiff/-/commit/738e04099b13192bb1f654e74e9b5829313f3161\n\t * Fixed by: https://gitlab.com/libtiff/libtiff/-/commit/49856998c3d82e65444b47bb4fb11b7830a0c2be\n\t */\n\tif (!TIFFFindField(tif, TIFFTAG_CFAREPEATPATTERNDIM, TIFF_ANY)) {\n\t\tstatic const TIFFFieldInfo infos[] = {\n\t\t\t{ TIFFTAG_CFAREPEATPATTERNDIM, 2, 2, TIFF_SHORT, FIELD_CUSTOM,\n\t\t\t  1, 0, const_cast<char *>(\"CFARepeatPatternDim\") },\n\t\t\t{ TIFFTAG_CFAPATTERN, -1, -1, TIFF_BYTE, FIELD_CUSTOM,\n\t\t\t  1, 1, const_cast<char *>(\"CFAPattern\") },\n\t\t};\n\t\tTIFFMergeFieldInfo(tif, infos, 2);\n\t}\n\n\t/* Create a new IFD for the RAW image. */\n\tconst uint16_t cfaRepeatPatternDim[] = { 2, 2 };\n\tconst uint8_t cfaPlaneColor[] = {\n\t\tCFAPatternRed,\n\t\tCFAPatternGreen,\n\t\tCFAPatternBlue\n\t};\n\n\tTIFFSetField(tif, TIFFTAG_SUBFILETYPE, 0);\n\tTIFFSetField(tif, TIFFTAG_IMAGEWIDTH, config.size.width);\n\tTIFFSetField(tif, TIFFTAG_IMAGELENGTH, config.size.height);\n\tTIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, info->bitsPerSample);\n\tTIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n\tTIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_CFA);\n\tTIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 1);\n\tTIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\tTIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT);\n\tTIFFSetField(tif, TIFFTAG_CFAREPEATPATTERNDIM, cfaRepeatPatternDim);\n\tif (TIFFLIB_VERSION < 20201219)\n\t\tTIFFSetField(tif, TIFFTAG_CFAPATTERN, info->pattern);\n\telse\n\t\tTIFFSetField(tif, TIFFTAG_CFAPATTERN, 4, info->pattern);\n\tTIFFSetField(tif, TIFFTAG_CFAPLANECOLOR, 3, cfaPlaneColor);\n\tTIFFSetField(tif, TIFFTAG_CFALAYOUT, 1);\n\n\tconst uint16_t blackLevelRepeatDim[] = { 2, 2 };\n\tfloat blackLevel[] = { 0.0f, 0.0f, 0.0f, 0.0f };\n\tuint32_t whiteLevel = (1 << info->bitsPerSample) - 1;\n\n\tconst auto &blackLevels = metadata.get(controls::SensorBlackLevels);\n\tif (blackLevels) {\n\t\tSpan<const int32_t, 4> levels = *blackLevels;\n\n\t\t/*\n\t\t * The black levels control is specified in R, Gr, Gb, B order.\n\t\t * Map it to the TIFF tag that is specified in CFA pattern\n\t\t * order.\n\t\t */\n\t\tunsigned int green = (info->pattern[0] == CFAPatternRed ||\n\t\t\t\t      info->pattern[1] == CFAPatternRed)\n\t\t\t\t   ? 0 : 1;\n\n\t\tfor (unsigned int i = 0; i < 4; ++i) {\n\t\t\tunsigned int level;\n\n\t\t\tswitch (info->pattern[i]) {\n\t\t\tcase CFAPatternRed:\n\t\t\t\tlevel = levels[0];\n\t\t\t\tbreak;\n\t\t\tcase CFAPatternGreen:\n\t\t\t\tlevel = levels[green + 1];\n\t\t\t\tgreen = (green + 1) % 2;\n\t\t\t\tbreak;\n\t\t\tcase CFAPatternBlue:\n\t\t\tdefault:\n\t\t\t\tlevel = levels[3];\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Map the 16-bit value to the bits per sample range. */\n\t\t\tblackLevel[i] = level >> (16 - info->bitsPerSample);\n\t\t}\n\t}\n\n\tTIFFSetField(tif, TIFFTAG_BLACKLEVELREPEATDIM, &blackLevelRepeatDim);\n\tTIFFSetField(tif, TIFFTAG_BLACKLEVEL, 4, &blackLevel);\n\tTIFFSetField(tif, TIFFTAG_WHITELEVEL, 1, &whiteLevel);\n\n\t/* Write RAW content. */\n\trow = static_cast<const uint8_t *>(data);\n\tfor (unsigned int y = 0; y < config.size.height; y++) {\n\t\tinfo->packScanline(scanline.data(), row, config.size.width);\n\n\t\tif (TIFFWriteScanline(tif, scanline.data(), y, 0) != 1) {\n\t\t\tstd::cerr << \"Failed to write RAW scanline\"\n\t\t\t\t  << std::endl;\n\t\t\tTIFFClose(tif);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\trow += config.stride;\n\t}\n\n\t/* Checkpoint the IFD to retrieve its offset, and write it out. */\n\tTIFFCheckpointDirectory(tif);\n\trawIFDOffset = TIFFCurrentDirOffset(tif);\n\tTIFFWriteDirectory(tif);\n\n\t/* Create a new IFD for the EXIF data and fill it. */\n\tTIFFCreateEXIFDirectory(tif);\n\n\t/* Store creation time. */\n\ttime_t rawtime;\n\tstruct tm *timeinfo;\n\tchar strTime[20];\n\n\ttime(&rawtime);\n\ttimeinfo = localtime(&rawtime);\n\tstrftime(strTime, 20, \"%Y:%m:%d %H:%M:%S\", timeinfo);\n\n\t/*\n\t * \\todo Handle timezone information by setting OffsetTimeOriginal and\n\t * OffsetTimeDigitized once libtiff catches up to the specification and\n\t * has EXIFTAG_ defines to handle them.\n\t */\n\tTIFFSetField(tif, EXIFTAG_DATETIMEORIGINAL, strTime);\n\tTIFFSetField(tif, EXIFTAG_DATETIMEDIGITIZED, strTime);\n\n\tconst auto &analogGain = metadata.get(controls::AnalogueGain);\n\tif (analogGain) {\n\t\tuint16_t iso = std::min(std::max(*analogGain * 100, 0.0f), 65535.0f);\n\t\tTIFFSetField(tif, EXIFTAG_ISOSPEEDRATINGS, 1, &iso);\n\t}\n\n\tconst auto &exposureTime = metadata.get(controls::ExposureTime);\n\tif (exposureTime)\n\t\tTIFFSetField(tif, EXIFTAG_EXPOSURETIME, *exposureTime / 1e6);\n\n\tTIFFWriteCustomDirectory(tif, &exifIFDOffset);\n\n\t/* Update the IFD offsets and close the file. */\n\tTIFFSetDirectory(tif, 0);\n\tTIFFSetField(tif, TIFFTAG_SUBIFD, 1, &rawIFDOffset);\n\tTIFFSetField(tif, TIFFTAG_EXIFIFD, exifIFDOffset);\n\tTIFFWriteDirectory(tif);\n\n\tTIFFClose(tif);\n\n\treturn 0;\n}",
    "void saveInternal(const Image<T> &image, const char *name)\n{\n  TIFF* tif=TIFFOpen(name, \"w\");\n\n  if (!tif)\n  {\n    throw gutil::IOException(\"Cannot store image: \"+std::string(name));\n  }\n\n  TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, static_cast<uint32_t>(image.getWidth()));\n  TIFFSetField(tif, TIFFTAG_IMAGELENGTH, static_cast<uint32_t>(image.getHeight()));\n  TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, static_cast<uint16_t>(image.getDepth()));\n  TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8*sizeof(T));\n\n  if (std::is_floating_point<T>::value)\n  {\n    TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);\n  }\n  else\n  {\n    TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT);\n  }\n\n  int strip=static_cast<int>(8192/(image.getWidth()*image.getDepth()*sizeof(T)));\n  strip=std::max(1, strip);\n  strip=std::min(static_cast<int>(image.getHeight()), strip);\n\n  TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, TIFFDefaultStripSize(tif, static_cast<uint32_t>(strip)));\n\n  TIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n  TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\n  if (image.getDepth() == 3 || image.getDepth() == 4)\n  {\n    TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n  }\n  else\n  {\n    TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n  }\n\n  if (image.getDepth() == 1)\n  {\n    for (long k=0; k<image.getHeight(); k++)\n    {\n      if (TIFFWriteScanline(tif, image.getPtr(0, k, 0), static_cast<uint32_t>(k), 0) < 0)\n      {\n        TIFFClose(tif);\n        throw gutil::IOException(\"Cannot write image data: \"+std::string(name));\n      }\n    }\n  }\n  else\n  {\n    std::vector<T> line(image.getWidth()*image.getDepth());\n\n    for (long k=0; k<image.getHeight(); k++)\n    {\n      T *p=line.data();\n      for (long i=0; i<image.getWidth(); i++)\n      {\n        for (int d=0; d<image.getDepth(); d++)\n        {\n          *p++=image.get(i, k, d);\n        }\n      }\n\n      if (TIFFWriteScanline(tif, line.data(), static_cast<uint32_t>(k), 0) < 0)\n      {\n        TIFFClose(tif);\n        throw gutil::IOException(\"Cannot write image data: \"+std::string(name));\n      }\n    }\n  }\n\n  TIFFClose(tif);\n}",
    "void TiffExporter::writeLine(int l) const {\n    if (!TIFFWriteScanline(m_image, m_raster, l)) {\n      throw IException(IException::Programmer,\n          \"Could not write image\", _FILEINFO_);\n    }\n  }",
    "int WriteTiff(const char * filename,\n  const std::vector<unsigned char> & ptr,\n  int w,\n  int h,\n  int depth)\n{\n  TIFF* tiff = TIFFOpen(filename, \"w\");\n  if (!tiff) {\n    OPENMVG_LOG_ERROR << \"Couldn't open \" << filename << \" fopen returned 0\";\n    return 0;\n  }\n  TIFFSetField(tiff, TIFFTAG_IMAGEWIDTH, w);\n  TIFFSetField(tiff, TIFFTAG_IMAGELENGTH, h);\n  TIFFSetField(tiff, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n  TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n  TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 8);\n  TIFFSetField(tiff, TIFFTAG_SAMPLESPERPIXEL, depth);\n  TIFFSetField(tiff, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n  TIFFSetField(tiff, TIFFTAG_COMPRESSION,COMPRESSION_NONE);\n  TIFFSetField(tiff, TIFFTAG_ROWSPERSTRIP, 16);\n  for (uint32 y=0; y < static_cast<uint32>(h); ++y) {\n    if (TIFFWriteScanline(tiff,(tdata_t)(((uint8*)(&ptr[0]))+depth*w*y),y)<0) {\n      TIFFClose(tiff);\n      return 0;\n    }\n  }\n  TIFFClose(tiff);\n  return 1;\n}",
    "bool wxTIFFHandler::SaveFile( wxImage *image, wxOutputStream& stream, bool verbose )\n{\n    TIFF *tif = TIFFwxOpen( stream, \"image\", \"w\" );\n\n    if (!tif)\n    {\n        if (verbose)\n        {\n            wxLogError( _(\"TIFF: Error saving image.\") );\n        }\n\n        return false;\n    }\n\n    const int imageWidth = image->GetWidth();\n    TIFFSetField(tif, TIFFTAG_IMAGEWIDTH,  (uint32) imageWidth);\n    TIFFSetField(tif, TIFFTAG_IMAGELENGTH, (uint32)image->GetHeight());\n    TIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n    TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\n    // save the image resolution if we have it\n    int xres, yres;\n    const wxImageResolution res = GetResolutionFromOptions(*image, &xres, &yres);\n    uint16 tiffRes;\n    switch ( res )\n    {\n        default:\n            wxFAIL_MSG( wxT(\"unknown image resolution units\") );\n            wxFALLTHROUGH;\n\n        case wxIMAGE_RESOLUTION_NONE:\n            tiffRes = RESUNIT_NONE;\n            break;\n\n        case wxIMAGE_RESOLUTION_INCHES:\n            tiffRes = RESUNIT_INCH;\n            break;\n\n        case wxIMAGE_RESOLUTION_CM:\n            tiffRes = RESUNIT_CENTIMETER;\n            break;\n    }\n\n    if ( tiffRes != RESUNIT_NONE )\n    {\n        TIFFSetField(tif, TIFFTAG_RESOLUTIONUNIT, tiffRes);\n        TIFFSetField(tif, TIFFTAG_XRESOLUTION, (float)xres);\n        TIFFSetField(tif, TIFFTAG_YRESOLUTION, (float)yres);\n    }\n\n\n    int spp = image->GetOptionInt(wxIMAGE_OPTION_TIFF_SAMPLESPERPIXEL);\n    if ( !spp )\n        spp = 3;\n\n    int bps = image->GetOptionInt(wxIMAGE_OPTION_TIFF_BITSPERSAMPLE);\n    if ( !bps )\n    {\n        bps = 8;\n    }\n    else if (bps == 1)\n    {\n        // One bit per sample combined with 3 samples per pixel is\n        // not allowed and crashes libtiff.\n        spp = 1;\n    }\n\n    int photometric = PHOTOMETRIC_RGB;\n\n    if ( image->HasOption(wxIMAGE_OPTION_TIFF_PHOTOMETRIC) )\n    {\n        photometric = image->GetOptionInt(wxIMAGE_OPTION_TIFF_PHOTOMETRIC);\n        if (photometric == PHOTOMETRIC_MINISWHITE\n            || photometric == PHOTOMETRIC_MINISBLACK)\n        {\n            // either b/w or greyscale\n            spp = 1;\n        }\n    }\n    else if (spp <= 2)\n    {\n        photometric = PHOTOMETRIC_MINISWHITE;\n    }\n\n    const bool hasAlpha = image->HasAlpha();\n\n    int compression = image->GetOptionInt(wxIMAGE_OPTION_TIFF_COMPRESSION);\n    if ( !compression || (compression == COMPRESSION_JPEG && hasAlpha) )\n    {\n        // We can't use COMPRESSION_LZW because current version of libtiff\n        // doesn't implement it (\"no longer implemented due to Unisys patent\n        // enforcement\") and other compression methods are lossy so we\n        // shouldn't use them by default -- and the only remaining one is none.\n        // Also JPEG compression for alpha images is not a good idea (viewers\n        // not opening the image properly).\n        compression = COMPRESSION_NONE;\n    }\n\n    if\n    (\n        (photometric == PHOTOMETRIC_RGB && spp == 4)\n        || (photometric <= PHOTOMETRIC_MINISBLACK && spp == 2)\n    )\n    {\n        // Compensate for user passing a SamplesPerPixel that includes\n        // the alpha channel.\n        spp--;\n    }\n\n\n    int extraSamples = hasAlpha ? 1 : 0;\n\n    TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, spp + extraSamples);\n    TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, bps);\n    TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, photometric);\n    TIFFSetField(tif, TIFFTAG_COMPRESSION, compression);\n\n    if (extraSamples)\n    {\n        uint16 extra[] = { EXTRASAMPLE_UNSPECIFIED };\n        TIFFSetField(tif, TIFFTAG_EXTRASAMPLES, (long) 1, &extra);\n    }\n\n    // scanlinesize is determined by spp+extraSamples and bps\n    const tsize_t linebytes =\n        (tsize_t)((imageWidth * (spp + extraSamples) * bps + 7) / 8);\n\n    unsigned char *buf;\n\n    const bool isColouredImage = (spp > 1)\n        && (photometric != PHOTOMETRIC_MINISWHITE)\n        && (photometric != PHOTOMETRIC_MINISBLACK);\n\n\n    if (TIFFScanlineSize(tif) > linebytes || !isColouredImage || hasAlpha)\n    {\n        buf = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(tif));\n        if (!buf)\n        {\n            if (verbose)\n            {\n                wxLogError( _(\"TIFF: Couldn't allocate memory.\") );\n            }\n\n            TIFFClose( tif );\n\n            return false;\n        }\n    }\n    else\n    {\n        buf = NULL;\n    }\n\n    TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP,TIFFDefaultStripSize(tif, (uint32) -1));\n\n    const int bitsPerPixel = (spp + extraSamples) * bps;\n    const int bytesPerPixel = (bitsPerPixel + 7) / 8;\n    const int pixelsPerByte = 8 / bitsPerPixel;\n    int remainingPixelCount = 0;\n\n    if (pixelsPerByte)\n    {\n        // How many pixels to write in the last byte column?\n        remainingPixelCount = imageWidth % pixelsPerByte;\n        if (!remainingPixelCount) remainingPixelCount = pixelsPerByte;\n    }\n\n    const bool minIsWhite = (photometric == PHOTOMETRIC_MINISWHITE);\n    unsigned char *ptr = image->GetData();\n    for ( int row = 0; row < image->GetHeight(); row++ )\n    {\n        if ( buf )\n        {\n            if (isColouredImage)\n            {\n                // colour image\n                if (hasAlpha)\n                {\n                    for ( int column = 0; column < imageWidth; column++ )\n                    {\n                        buf[column*4    ] = ptr[column*3    ];\n                        buf[column*4 + 1] = ptr[column*3 + 1];\n                        buf[column*4 + 2] = ptr[column*3 + 2];\n                        buf[column*4 + 3] = image->GetAlpha(column, row);\n                    }\n                }\n                else\n                {\n                    memcpy(buf, ptr, imageWidth * 3);\n                }\n            }\n            else if (spp * bps == 8) // greyscale image\n            {\n                for ( int column = 0; column < imageWidth; column++ )\n                {\n                    uint8 value = ptr[column*3 + 1];\n                    if (minIsWhite)\n                    {\n                        value = 255 - value;\n                    }\n\n                    buf[column * bytesPerPixel] = value;\n\n                    if (hasAlpha)\n                    {\n                        value = image->GetAlpha(column, row);\n                        buf[column*bytesPerPixel+1] = minIsWhite ? 255 - value\n                                                                 : value;\n                    }\n                }\n            }\n            else // black and white image\n            {\n                for ( int column = 0; column < linebytes; column++ )\n                {\n                    uint8 reverse = 0;\n                    int pixelsPerByteCount = (column + 1 != linebytes)\n                        ? pixelsPerByte\n                        : remainingPixelCount;\n                    for ( int bp = 0; bp < pixelsPerByteCount; bp++ )\n                    {\n                        if ( (ptr[column * 3 * pixelsPerByte + bp*3 + 1] <=127)\n                            == minIsWhite )\n                        {\n                            // check only green as this is sufficient\n                            reverse |= (uint8) (128 >> (bp * bitsPerPixel));\n                        }\n\n                        if (hasAlpha\n                            && (image->GetAlpha(column * pixelsPerByte + bp,\n                                    row) <= 127) == minIsWhite)\n                        {\n                            reverse |= (uint8) (64 >> (bp * bitsPerPixel));\n                        }\n                    }\n\n                    buf[column] = reverse;\n                }\n            }\n        }\n\n        if ( TIFFWriteScanline(tif, buf ? buf : ptr, (uint32)row, 0) < 0 )\n        {\n            if (verbose)\n            {\n                wxLogError( _(\"TIFF: Error writing image.\") );\n            }\n\n            TIFFClose( tif );\n            if (buf)\n                _TIFFfree(buf);\n\n            return false;\n        }\n\n        ptr += imageWidth * 3;\n    }\n\n    (void) TIFFClose(tif);\n\n    if (buf)\n        _TIFFfree(buf);\n\n    return true;\n}",
    "int ImageIO::saveTIFF (\n    const Glib::ustring &fname,\n    int bps,\n    bool isFloat,\n    bool uncompressed,\n    bool big\n) const\n{\n    if (getWidth() < 1 || getHeight() < 1) {\n        return IMIO_HEADERERROR;\n    }\n\n    bool writeOk = true;\n    int width = getWidth ();\n    int height = getHeight ();\n\n    if (bps < 0) {\n        bps = getBPS ();\n    }\n\n    int lineWidth = width * 3 * (bps / 8);\n    std::vector<unsigned char> linebuffer(lineWidth);\n\n    std::string mode = \"w\";\n\n    if (big) {\n        mode += '8';\n    }\n\n#ifdef _WIN32\n    FILE *file = g_fopen_withBinaryAndLock (fname);\n    int fileno = _fileno(file);\n    int osfileno = _get_osfhandle(fileno);\n    TIFF* out = TIFFFdOpen (osfileno, fname.c_str(), mode.c_str());\n#else\n    TIFF* out = TIFFOpen(fname.c_str(), mode.c_str());\n    // int fileno = TIFFFileno (out);\n#endif\n\n    if (!out) {\n        return IMIO_CANNOTWRITEFILE;\n    }\n\n    if (pl) {\n        pl->setProgressStr (\"PROGRESSBAR_SAVETIFF\");\n        pl->setProgress (0.0);\n    }\n\n    bool needsReverse = false;\n\n    TIFFSetField (out, TIFFTAG_SOFTWARE, \"RawTherapee \" RTVERSION);\n    TIFFSetField (out, TIFFTAG_IMAGEWIDTH, width);\n    TIFFSetField (out, TIFFTAG_IMAGELENGTH, height);\n    TIFFSetField (out, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n    TIFFSetField (out, TIFFTAG_SAMPLESPERPIXEL, 3);\n    TIFFSetField (out, TIFFTAG_ROWSPERSTRIP, height);\n    TIFFSetField (out, TIFFTAG_BITSPERSAMPLE, bps);\n    TIFFSetField (out, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    TIFFSetField (out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n    TIFFSetField (out, TIFFTAG_COMPRESSION, uncompressed ? COMPRESSION_NONE : COMPRESSION_ADOBE_DEFLATE);\n    TIFFSetField (out, TIFFTAG_SAMPLEFORMAT, (bps == 16 || bps == 32) && isFloat ? SAMPLEFORMAT_IEEEFP : SAMPLEFORMAT_UINT);\n\n    // somehow Exiv2 (tested with 0.27.3) doesn't seem to be able to update\n    // XResolution and YResolution, so we do it ourselves here....\n    constexpr float default_resolution = 300.f;\n    float x_res = default_resolution;\n    float y_res = default_resolution;\n    int res_unit = RESUNIT_INCH;\n    if (!metadataInfo.filename().empty()) {\n        auto exif = metadataInfo.getOutputExifData();\n        auto it = exif.findKey(Exiv2::ExifKey(\"Exif.Image.XResolution\"));\n        if (it != exif.end()) {\n            x_res = it->toFloat();\n        }\n        it = exif.findKey(Exiv2::ExifKey(\"Exif.Image.YResolution\"));\n        if (it != exif.end()) {\n            y_res = it->toFloat();\n        }\n        it = exif.findKey(Exiv2::ExifKey(\"Exif.Image.ResolutionUnit\"));\n        if (it != exif.end()) {\n            res_unit = to_long(it);\n        }\n    }\n    TIFFSetField(out, TIFFTAG_XRESOLUTION, x_res);\n    TIFFSetField(out, TIFFTAG_YRESOLUTION, y_res);\n    TIFFSetField(out, TIFFTAG_RESOLUTIONUNIT, res_unit);\n\n    if (!uncompressed) {\n        TIFFSetField (out, TIFFTAG_PREDICTOR, (bps == 16 || bps == 32) && isFloat ? PREDICTOR_FLOATINGPOINT : PREDICTOR_HORIZONTAL);\n    }\n    if (!profileData.empty()) {\n        TIFFSetField (out, TIFFTAG_ICCPROFILE, profileData.size(), profileData.data());\n    }\n\n    for (int row = 0; row < height; row++) {\n        getScanline (row, linebuffer.data(), bps, isFloat);\n\n        if (bps == 16) {\n            if(needsReverse && !uncompressed && isFloat) {\n                for(int i = 0; i < lineWidth; i += 2) {\n                    std::swap(linebuffer[i], linebuffer[i + 1]);\n                }\n            }\n        } else if (bps == 32) {\n            if(needsReverse && !uncompressed) {\n                for(int i = 0; i < lineWidth; i += 4) {\n                    std::swap(linebuffer[i], linebuffer[i + 3]);\n                    std::swap(linebuffer[i + 1], linebuffer[i + 2]);\n                }\n            }\n        }\n\n        if (TIFFWriteScanline (out, linebuffer.data(), row, 0) < 0) {\n            TIFFClose (out);\n            return IMIO_CANNOTWRITEFILE;\n        }\n\n        if (pl && !(row % 100)) {\n            pl->setProgress ((double)(row + 1) / height);\n        }\n    }\n\n    if (TIFFFlush(out) != 1) {\n        writeOk = false;\n    }\n\n    TIFFClose (out);\n#ifdef _WIN32\n    fclose (file);\n#endif\n\n    if (!saveMetadata(fname)) {\n        writeOk = false;\n    }\n\n    if (pl) {\n        pl->setProgressStr (\"PROGRESSBAR_READY\");\n        pl->setProgress (1.0);\n    }\n\n    if(writeOk) {\n        return IMIO_SUCCESS;\n    } else {\n        g_remove (fname.c_str());\n        return IMIO_CANNOTWRITEFILE;\n    }\n}",
    "ui32 tif_out::write(const line_buf* line, ui32 comp_num)\n  {\n    assert(tiff_handle);\n    \n    if (bytes_per_sample == 1)\n    {\n      int max_val = (1 << bit_depth_of_data[comp_num]) - 1;\n      const si32* sp = line->i32;\n      ui8* dp = buffer + comp_num;\n      if (bit_depth_of_data[comp_num] == 8)\n      {\n        for (ui32 i = width; i > 0; --i, dp += num_components)\n        {\n          // clamp the decoded sample to the allowed range\n          int val = *sp++;\n          val = val >= 0 ? val : 0;\n          val = val <= max_val ? val : max_val;\n          *dp = (ui8)val;\n        }\n      }\n      else if (bit_depth_of_data[comp_num] < 8)\n      {\n        const int bits_to_shift = 8 - (int)bit_depth_of_data[comp_num];\n        const int bit_mask = (1 << bit_depth_of_data[comp_num]) - 1;\n        for (ui32 i = width; i > 0; --i, dp += num_components)\n        {\n          // clamp the decoded sample to the allowed range\n          int val = *sp++;\n          val = val >= 0 ? val : 0;\n          val = val <= max_val ? val : max_val;\n          // shift the decoded data so the data's MSB is aligned with the \n          // 8 bit MSB\n          *dp = (ui8)((val & bit_mask) << bits_to_shift);\n        }\n      }\n      else if (bit_depth_of_data[comp_num] > 8)\n      {\n        const int bits_to_shift = (int)bit_depth_of_data[comp_num] - 8;\n        const int bit_mask = (1 << bit_depth_of_data[comp_num]) - 1;\n        for (ui32 i = width; i > 0; --i, dp += num_components)\n        {\n          // clamp the decoded sample to the allowed range\n          int val = *sp++;\n          val = val >= 0 ? val : 0;\n          val = val <= max_val ? val : max_val;\n          // shift the decoded data so the data's MSB is aligned with the \n          // 8 bit MSB\n          *dp = (ui8)((val >> bits_to_shift) & bit_mask);\n        }\n      }\n      \n    }\n    else if(bytes_per_sample == 2)\n    {\n      int max_val = (1 << bit_depth_of_data[comp_num]) - 1;\n      const si32* sp = line->i32;\n      ui16* dp = (ui16*)buffer + comp_num;\n\n      if (bit_depth_of_data[comp_num] == 16)\n      {\n        for (ui32 i = width; i > 0; --i, dp += num_components)\n        {\n          // clamp the decoded sample to the allowed range\n          int val = *sp++;\n          val = val >= 0 ? val : 0;\n          val = val <= max_val ? val : max_val;\n          *dp = (ui16)val;\n        }\n      }\n      else if (bit_depth_of_data[comp_num] < 16)\n      {\n        const int bits_to_shift = 16 - (int)bit_depth_of_data[comp_num];\n        const int bit_mask = (1 << bit_depth_of_data[comp_num]) - 1;\n        for (ui32 i = width; i > 0; --i, dp += num_components)\n        {\n          // clamp the decoded sample to the allowed range\n          int val = *sp++;\n          val = val >= 0 ? val : 0;\n          val = val <= max_val ? val : max_val;\n\n          // shift the decoded data so the data's MSB is aligned with the \n          // 16 bit MSB\n          *dp = (ui16)((val & bit_mask) << bits_to_shift);\n        }\n      }\n      else if (bit_depth_of_data[comp_num] > 16)\n      {\n        const int bits_to_shift = (int)bit_depth_of_data[comp_num] - 16;\n        const int bit_mask = (1 << bit_depth_of_data[comp_num]) - 1;\n        for (ui32 i = width; i > 0; --i, dp += num_components)\n        {\n          // clamp the decoded sample to the allowed range\n          int val = *sp++;\n          val = val >= 0 ? val : 0;\n          val = val <= max_val ? val : max_val;\n\n          // shift the decoded data so the data's MSB is aligned with the \n          // 16 bit MSB\n          *dp = (ui16)((val >> bits_to_shift) & bit_mask);\n        }\n      }\n      \n    }\n      // write scanline when the last component is reached \n      if (comp_num == num_components-1)\n      {\n        int result = TIFFWriteScanline(tiff_handle, buffer, cur_line++);\n        if (result != 1)\n          OJPH_ERROR(0x030000C1, \"error writing to file %s\", fname);\n      }\n    return 0;\n  }",
    "bool CxImageTIF::EncodeBody(TIFF *m_tif, bool multipage, int32_t page, int32_t pagecount)\n{\n\tuint32 height=head.biHeight;\n\tuint32 width=head.biWidth;\n\tuint16 bitcount=head.biBitCount;\n\tuint16 bitspersample;\n\tuint16 samplesperpixel;\n\tuint16 photometric=0;\n\tuint16 compression;\n//\tuint16 pitch;\n//\tint32_t line;\n\tuint32 x, y;\n\n\tsamplesperpixel = ((bitcount == 24) || (bitcount == 32)) ? (uint8_t)3 : (uint8_t)1;\n#if CXIMAGE_SUPPORT_ALPHA\n\tif (bitcount==24 && AlphaIsValid()) { bitcount=32; samplesperpixel=4; }\n#endif //CXIMAGE_SUPPORT_ALPHA\n\n\tbitspersample = bitcount / samplesperpixel;\n\n\t//set the PHOTOMETRIC tag\n\tRGBQUAD *rgb = GetPalette();\n\tswitch (bitcount) {\n\t\tcase 1:\n\t\t\tif (CompareColors(&rgb[0],&rgb[1])<0) {\n\t\t\t\t/* <abe> some viewers do not handle PHOTOMETRIC_MINISBLACK:\n\t\t\t\t * let's transform the image in PHOTOMETRIC_MINISWHITE\n\t\t\t\t */\n\t\t\t\t//invert the colors\n\t\t\t\tRGBQUAD tempRGB=GetPaletteColor(0);\n\t\t\t\tSetPaletteColor(0,GetPaletteColor(1));\n\t\t\t\tSetPaletteColor(1,tempRGB);\n\t\t\t\t//invert the pixels\n\t\t\t\tuint8_t *iSrc=info.pImage;\n\t\t\t\tfor (uint32_t i=0;i<head.biSizeImage;i++){\n\t\t\t\t\t*iSrc=(uint8_t)~(*(iSrc));\n\t\t\t\t\tiSrc++;\n\t\t\t\t}\n\t\t\t\tphotometric = PHOTOMETRIC_MINISWHITE;\n\t\t\t\t//photometric = PHOTOMETRIC_MINISBLACK;\n\t\t\t} else {\n\t\t\t\tphotometric = PHOTOMETRIC_MINISWHITE;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 4:\t// Check if the DIB has a color or a greyscale palette\n\t\tcase 8:\n\t\t\tphotometric = PHOTOMETRIC_MINISBLACK; //default to gray scale\n\t\t\tfor (x = 0; x < head.biClrUsed; x++) {\n\t\t\t\tif ((rgb->rgbRed != x)||(rgb->rgbRed != rgb->rgbGreen)||(rgb->rgbRed != rgb->rgbBlue)){\n\t\t\t\t\tphotometric = PHOTOMETRIC_PALETTE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\trgb++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 24:\n\t\tcase 32:\n\t\t\tphotometric = PHOTOMETRIC_RGB;\t\t\t\n\t\t\tbreak;\n\t}\n\n#if CXIMAGE_SUPPORT_ALPHA\n\tif (AlphaIsValid() && bitcount==8) samplesperpixel=2; //8bpp + alpha layer\n#endif //CXIMAGE_SUPPORT_ALPHA\n\n//\tline = CalculateLine(width, bitspersample * samplesperpixel);\n//\tpitch = (uint16)CalculatePitch(line);\n\n\t//prepare the palette struct\n\tRGBQUAD pal[256];\n\tif (GetPalette()){\n\t\tuint8_t b;\n\t\tmemcpy(pal,GetPalette(),GetPaletteSize());\n\t\tfor(uint16_t a=0;a<head.biClrUsed;a++){\t//swap blue and red components\n\t\t\tb=pal[a].rgbBlue; pal[a].rgbBlue=pal[a].rgbRed; pal[a].rgbRed=b;\n\t\t}\n\t}\n\n\t// handle standard width/height/bpp stuff\n\tTIFFSetField(m_tif, TIFFTAG_IMAGEWIDTH, width);\n\tTIFFSetField(m_tif, TIFFTAG_IMAGELENGTH, height);\n\tTIFFSetField(m_tif, TIFFTAG_SAMPLESPERPIXEL, samplesperpixel);\n\tTIFFSetField(m_tif, TIFFTAG_BITSPERSAMPLE, bitspersample);\n\tTIFFSetField(m_tif, TIFFTAG_PHOTOMETRIC, photometric);\n\tTIFFSetField(m_tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\t// single image plane \n\tTIFFSetField(m_tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n\n\tuint32 rowsperstrip = TIFFDefaultStripSize(m_tif, (uint32) -1);  //<REC> gives better compression\n\tTIFFSetField(m_tif, TIFFTAG_ROWSPERSTRIP, rowsperstrip);\n\n\t// handle metrics\n\tTIFFSetField(m_tif, TIFFTAG_RESOLUTIONUNIT, RESUNIT_INCH);\n\tTIFFSetField(m_tif, TIFFTAG_XRESOLUTION, (float)info.xDPI);\n\tTIFFSetField(m_tif, TIFFTAG_YRESOLUTION, (float)info.yDPI);\n//\tTIFFSetField(m_tif, TIFFTAG_XPOSITION, (float)info.xOffset);\n//\tTIFFSetField(m_tif, TIFFTAG_YPOSITION, (float)info.yOffset);\n\n\t// multi-paging - Thanks to Abe <God(dot)bless(at)marihuana(dot)com>\n\tif (multipage)\n\t{\n\t\tchar page_number[20];\n\t\tsprintf(page_number, \"Page %d\", page);\n\n\t\tTIFFSetField(m_tif, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE);\n\t\tTIFFSetField(m_tif, TIFFTAG_PAGENUMBER, page,pagecount);\n\t\tTIFFSetField(m_tif, TIFFTAG_PAGENAME, page_number);\n\t} else {\n\t\tTIFFSetField(m_tif, TIFFTAG_SUBFILETYPE, 0);\n\t}\n\n\t// palettes (image colormaps are automatically scaled to 16-bits)\n\tif (photometric == PHOTOMETRIC_PALETTE) {\n\t\tuint16 *r, *g, *b;\n\t\tr = (uint16 *) _TIFFmalloc(sizeof(uint16) * 3 * 256);\n\t\tg = r + 256;\n\t\tb = g + 256;\n\n\t\tfor (int32_t i = 255; i >= 0; i--) {\n\t\t\tb[i] = (uint16)SCALE((uint16)pal[i].rgbRed);\n\t\t\tg[i] = (uint16)SCALE((uint16)pal[i].rgbGreen);\n\t\t\tr[i] = (uint16)SCALE((uint16)pal[i].rgbBlue);\n\t\t}\n\n\t\tTIFFSetField(m_tif, TIFFTAG_COLORMAP, r, g, b);\n\t\t_TIFFfree(r);\n\t}\n\n\t// compression\n\tif (GetCodecOption(CXIMAGE_FORMAT_TIF)) {\n\t\tcompression = (uint16_t)GetCodecOption(CXIMAGE_FORMAT_TIF);\n\t} else {\n\t\tswitch (bitcount) {\n\t\t\tcase 1 :\n\t\t\t\tcompression = COMPRESSION_CCITTFAX4;\n\t\t\t\tbreak;\n\t\t\tcase 4 :\n\t\t\tcase 8 :\n\t\t\t\tcompression = COMPRESSION_LZW;\n\t\t\t\tbreak;\n\t\t\tcase 24 :\n\t\t\tcase 32 :\n\t\t\t\tcompression = COMPRESSION_JPEG;\n\t\t\t\tbreak;\n\t\t\tdefault :\n\t\t\t\tcompression = COMPRESSION_NONE;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tTIFFSetField(m_tif, TIFFTAG_COMPRESSION, compression);\n\n\tswitch (compression) {\n\tcase COMPRESSION_JPEG:\n\t\tTIFFSetField(m_tif, TIFFTAG_JPEGQUALITY, GetJpegQuality());\n\t\tTIFFSetField(m_tif, TIFFTAG_ROWSPERSTRIP, ((7+rowsperstrip)>>3)<<3);\n   \t\tbreak;\n\tcase COMPRESSION_LZW:\n\t\tif (bitcount>=8) TIFFSetField(m_tif, TIFFTAG_PREDICTOR, 2);\n\t\tbreak;\n\t}\n\n\t// read the DIB lines from bottom to top and save them in the TIF\n\n\tuint8_t *bits;\n\tswitch(bitcount) {\t\t\t\t\n\t\tcase 1 :\n\t\tcase 4 :\n\t\tcase 8 :\n\t\t{\n\t\t\tif (samplesperpixel==1){\n\t\t\t\tbits = (uint8_t*)malloc(info.dwEffWidth);\n\t\t\t\tif (!bits) return false;\n\t\t\t\tfor (y = 0; y < height; y++) {\n\t\t\t\t\tmemcpy(bits,info.pImage + (height - y - 1)*info.dwEffWidth,info.dwEffWidth);\n\t\t\t\t\tif (TIFFWriteScanline(m_tif,bits, y, 0)==-1){\n\t\t\t\t\t\tfree(bits);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree(bits);\n\t\t\t}\n#if CXIMAGE_SUPPORT_ALPHA\n\t\t\telse { //8bpp + alpha layer\n\t\t\t\tbits = (uint8_t*)malloc(2*width);\n\t\t\t\tif (!bits) return false;\n\t\t\t\tfor (y = 0; y < height; y++) {\n\t\t\t\t\tfor (x=0;x<width;x++){\n\t\t\t\t\t\tbits[2*x]=BlindGetPixelIndex(x,height - y - 1);\n\t\t\t\t\t\tbits[2*x+1]=AlphaGet(x,height - y - 1);\n\t\t\t\t\t}\n\t\t\t\t\tif (TIFFWriteScanline(m_tif,bits, y, 0)==-1) {\n\t\t\t\t\t\tfree(bits);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree(bits);\n\t\t\t}\n#endif //CXIMAGE_SUPPORT_ALPHA\n\t\t\tbreak;\n\t\t}\t\t\t\t\n\t\tcase 24:\n\t\t{\n\t\t\tuint8_t *buffer = (uint8_t *)malloc(info.dwEffWidth);\n\t\t\tif (!buffer) return false;\n\t\t\tfor (y = 0; y < height; y++) {\n\t\t\t\t// get a pointer to the scanline\n\t\t\t\tmemcpy(buffer, info.pImage + (height - y - 1)*info.dwEffWidth, info.dwEffWidth);\n\t\t\t\t// TIFFs store color data RGB instead of BGR\n\t\t\t\tuint8_t *pBuf = buffer;\n\t\t\t\tfor (x = 0; x < width; x++) {\n\t\t\t\t\tuint8_t tmp = pBuf[0];\n\t\t\t\t\tpBuf[0] = pBuf[2];\n\t\t\t\t\tpBuf[2] = tmp;\n\t\t\t\t\tpBuf += 3;\n\t\t\t\t}\n\t\t\t\t// write the scanline to disc\n\t\t\t\tif (TIFFWriteScanline(m_tif, buffer, y, 0)==-1){\n\t\t\t\t\tfree(buffer);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree(buffer);\n\t\t\tbreak;\n\t\t}\t\t\t\t\n\t\tcase 32 :\n\t\t{\n#if CXIMAGE_SUPPORT_ALPHA\n\t\t\tuint8_t *buffer = (uint8_t *)malloc((info.dwEffWidth*4)/3);\n\t\t\tif (!buffer) return false;\n\t\t\tfor (y = 0; y < height; y++) {\n\t\t\t\t// get a pointer to the scanline\n\t\t\t\tmemcpy(buffer, info.pImage + (height - y - 1)*info.dwEffWidth, info.dwEffWidth);\n\t\t\t\t// TIFFs store color data RGB instead of BGR\n\t\t\t\tuint8_t *pSrc = buffer + 3 * width;\n\t\t\t\tuint8_t *pDst = buffer + 4 * width;\n\t\t\t\tfor (x = 0; x < width; x++) {\n\t\t\t\t\tpDst-=4;\n\t\t\t\t\tpSrc-=3;\n\t\t\t\t\tpDst[3] = AlphaGet(width-x-1,height-y-1);\n\t\t\t\t\tpDst[2] = pSrc[0];\n\t\t\t\t\tpDst[1] = pSrc[1];\n\t\t\t\t\tpDst[0] = pSrc[2];\n\t\t\t\t}\n\t\t\t\t// write the scanline to disc\n\t\t\t\tif (TIFFWriteScanline(m_tif, buffer, y, 0)==-1){\n\t\t\t\t\tfree(buffer);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree(buffer);\n#endif //CXIMAGE_SUPPORT_ALPHA\n\t\t\tbreak;\n\t\t}\t\t\t\t\n\t}\n\treturn true;\n}",
    "int WriteTiff(const char * filename,\n  const vector<unsigned char> & ptr,\n  int w,\n  int h,\n  int depth)\n{\n  TIFF* tiff = TIFFOpen(filename, \"w\");\n  if (!tiff) {\n    std::cerr << \"Error: Couldn't open \" << filename << \" fopen returned 0\";\n    return 0;\n  }\n  TIFFSetField(tiff, TIFFTAG_IMAGEWIDTH, w);\n  TIFFSetField(tiff, TIFFTAG_IMAGELENGTH, h);\n  TIFFSetField(tiff, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n  TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n  TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 8);\n  TIFFSetField(tiff, TIFFTAG_SAMPLESPERPIXEL, depth);\n  TIFFSetField(tiff, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n  TIFFSetField(tiff, TIFFTAG_COMPRESSION,COMPRESSION_NONE);\n  TIFFSetField(tiff, TIFFTAG_ROWSPERSTRIP, 16);\n  for (uint32 y=0; y < h ; ++y) {\n    if (TIFFWriteScanline(tiff,(tdata_t)(((uint8*)(&ptr[0]))+depth*w*y),y)<0) {\n      TIFFClose(tiff);\n      return 0;\n    }\n  }\n  TIFFClose(tiff);\n  return 1;\n}",
    "bool TiffWriter::writePointers(unsigned char **rowPointers, int rowCount)\n{\n    // Write all rows to the file\n\n    for (int row = 0; row < rowCount; row++) {\n        if (TIFFWriteScanline(priv->f, rowPointers[row], row, 0) < 0) {\n            fprintf(stderr, \"TiffWriter: Error writing tiff row %d\\n\", row);\n            return false;\n        }\n    }\n\n    return true;\n}",
    "bool TiffWriter::writeRow(unsigned char **rowData)\n{\n    // Add a single row\n\n    if (TIFFWriteScanline(priv->f, *rowData, priv->curRow, 0) < 0) {\n        fprintf(stderr, \"TiffWriter: Error writing tiff row %d\\n\", priv->curRow);\n        return false;\n    }\n\n    priv->curRow++;\n\n    return true;\n}",
    "bool tImageTIFF::Save(const tString& tiffFile, const SaveParams& params) const\n{\n\tif (!IsValid() || (params.Format == tFormat::Invalid))\n\t\treturn false;\n\n\tif (tSystem::tGetFileType(tiffFile) != tSystem::tFileType::TIFF)\n\t\treturn false;\n\n\tTIFF* tiff = TIFFOpen(tiffFile.Chr(), \"wb\");\n\tif (!tiff)\n\t\treturn false;\n\n\tint rowSize = 0;\n\tuint8* rowBuf = nullptr;\n\tfor (tFrame* frame = Frames.First(); frame; frame = frame->Next())\n\t{\n\t\t// Writes image from last loop and starts a new directory.\n\t\tif (frame != Frames.First())\n\t\t\tTIFFWriteDirectory(tiff);\n\n\t\tbool isOpaque = frame->IsOpaque();\n\t\tint bytesPerPixel = 0;\n\t\tswitch (params.Format)\n\t\t{\n\t\t\tcase tFormat::Auto:\t\tbytesPerPixel = isOpaque ? 3 : 4;\tbreak;\n\t\t\tcase tFormat::BPP24:\tbytesPerPixel = 3;\t\t\t\t\tbreak;\n\t\t\tcase tFormat::BPP32:\tbytesPerPixel = 4;\t\t\t\t\tbreak;\n\t\t}\n\t\ttAssert(bytesPerPixel);\n\n\t\tint w = frame->Width;\n\t\tint h = frame->Height;\n\n\t\tTIFFSetField(tiff, TIFFTAG_IMAGEWIDTH, w);\n\t\tTIFFSetField(tiff, TIFFTAG_IMAGELENGTH, h);\n\t\tTIFFSetField(tiff, TIFFTAG_SAMPLESPERPIXEL, bytesPerPixel);\n\t\tTIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 8);\n\t\tTIFFSetField(tiff, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n\t\tTIFFSetField(tiff, TIFFTAG_COMPRESSION, params.UseZLibCompression ? COMPRESSION_DEFLATE : COMPRESSION_NONE);\n\t\tTIFFSetField(tiff, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\t\tTIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n\t\tif (bytesPerPixel == 4)\n\t\t{\n\t\t\t// Unassociated alpha means the extra channel is not a premultiplied alpha channel.\n\t\t\tuint16 extraSampleTypes[] = { EXTRASAMPLE_UNASSALPHA };\n\t\t\tTIFFSetField(tiff, TIFFTAG_EXTRASAMPLES, tNumElements(extraSampleTypes), extraSampleTypes);\n\t\t}\n\n\t\tint pageDurMilliSec = (params.OverrideFrameDuration >= 0) ? params.OverrideFrameDuration : int(frame->Duration*1000.0f);\n\t\tWriteSoftwarePageDuration(tiff, pageDurMilliSec);\n\n\t\tint rowSizeNeeded = TIFFScanlineSize(tiff);\n\t\ttAssert(rowSizeNeeded == (w*bytesPerPixel));\n\n\t\t// Let's not reallocate the line buffer every frame. Often all frames will be the same size.\n\t\tif (rowSize != rowSizeNeeded)\n\t\t{\n\t\t\tif (rowBuf)\n\t\t\t\t_TIFFfree(rowBuf);\n\t\t\trowBuf = (uint8*)_TIFFmalloc(rowSizeNeeded);\n\t\t\trowSize = rowSizeNeeded;\n\t\t}\n\n\t\tTIFFSetField(tiff, TIFFTAG_ROWSPERSTRIP, TIFFDefaultStripSize(tiff, w*bytesPerPixel));\n\t\tfor (int r = 0; r < h; r++)\n\t\t{\n\t\t\tfor (int x = 0; x < w; x++)\n\t\t\t{\n\t\t\t\tint idx = (h-r-1)*w + x;\n\t\t\t\trowBuf[x*bytesPerPixel + 0] = frame->Pixels[idx].R;\n\t\t\t\trowBuf[x*bytesPerPixel + 1] = frame->Pixels[idx].G;\n\t\t\t\trowBuf[x*bytesPerPixel + 2] = frame->Pixels[idx].B;\n\t\t\t\tif (bytesPerPixel == 4)\n\t\t\t\t\trowBuf[x*bytesPerPixel + 3] = frame->Pixels[idx].A;\n\t\t\t}\n\n\t\t\tint errCode = TIFFWriteScanline(tiff, rowBuf, r, 0);\n\t\t\tif (errCode < 0)\n\t\t\t\tcontinue;\n\t\t}\n    }\n\n\tif (rowBuf)\n\t\t_TIFFfree(rowBuf);\n\tTIFFClose(tiff);\n\n\treturn true;\n}",
    "void save_tiff( const char *filename,\n\t\t\t\tTqFloat *raster,\n\t\t\t\tTqInt width,\n\t\t\t\tTqInt length,\n\t\t\t\tTqInt samples,\n\t\t\t\tconst char* description)\n{\n\t/* save to a tiff file */\n\tTqInt i;\n\tTqUchar *pdata = (TqUchar *) raster;\n\tTIFF* ptex = TIFFOpen( filename, \"w\" );\n\tstatic TqChar datetime[20];\n\tstruct tm  *ct;\n\tTqInt    year;\n\tTqInt linewidth;\n\n\ttime_t long_time;\n\n\ttime( &long_time );           /* Get time as long integer. */\n\tct = localtime( &long_time ); /* Convert to local time. */\n\n\n\tyear=1900 + ct->tm_year;\n\tstd::sprintf(datetime, \"%04d:%02d:%02d %02d:%02d:%02d\",\n\t        year, ct->tm_mon + 1, ct->tm_mday,\n\t        ct->tm_hour, ct->tm_min, ct->tm_sec);\n\n\n\tTIFFCreateDirectory( ptex );\n\n\n\tTIFFSetField( ptex, TIFFTAG_SOFTWARE, description );\n\tTIFFSetField( ptex, TIFFTAG_IMAGEWIDTH, width );\n\tTIFFSetField( ptex, TIFFTAG_IMAGELENGTH, length );\n\tTIFFSetField( ptex, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG );\n\tTIFFSetField( ptex, TIFFTAG_BITSPERSAMPLE, 32 );\n\tTIFFSetField( ptex, TIFFTAG_SAMPLESPERPIXEL, samples );\n\tTIFFSetField( ptex, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT );\n\tTIFFSetField( ptex, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP );\n\tTIFFSetField( ptex, TIFFTAG_COMPRESSION, COMPRESSION_PACKBITS );\n\tTIFFSetField( ptex, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB );\n\tTIFFSetField( ptex, TIFFTAG_ROWSPERSTRIP, 1 );\n\tTIFFSetField( ptex, TIFFTAG_DATETIME, datetime);\n\n\tlinewidth = width * samples;\n\tlinewidth *= sizeof(TqFloat);\n\tfor ( i = 0; i < length; i++ )\n\t{\n\t\tTIFFWriteScanline( ptex, pdata, i, 0 );\n\t\tpdata += linewidth;\n\t}\n\tTIFFClose( ptex );\n}",
    "void CqTiffOutputFile::writeScanlinePixels(const CqMixedImageBuffer& buffer)\n{\n\tCqTiffDirHandle dirHandle(m_fileHandle);\n\t// Simplest possible implementation using scanline TIFF I/O.  Could use\n\t// Strip-based IO if performance is ever a problem here.\n\tconst TqUint8* rawBuf = buffer.rawData();\n\tconst TqInt rowStride = buffer.channelList().bytesPerPixel()*buffer.width();\n\tconst TqInt endLine = m_currentLine + buffer.height();\n\t// Temporary buffer for scanlines.  We need to copy the data into here\n\t// since libtiff trashes the buffer when encoding is turned on.  (The TIFF\n\t// docs don't seem to mention this though, ugh.)\n\tboost::scoped_array<TqUint8> lineBuf(new TqUint8[rowStride]);\n\tfor(TqInt line = m_currentLine; line < endLine; ++line)\n\t{\n\t\t// copy the data into temp buffer.\n\t\tstd::memcpy(lineBuf.get(), rawBuf, rowStride);\n\t\t// write data\n\t\tTIFFWriteScanline( dirHandle.tiffPtr(), reinterpret_cast<tdata_t>(lineBuf.get()),\n\t\t\t\tstatic_cast<uint32>(line) );\n\t\trawBuf += rowStride;\n\t}\n\tm_currentLine = endLine;\n}",
    "void WriteTIFF(const std::string& filename, SqDisplayInstance* image)\n{\n\tuint16 photometric = PHOTOMETRIC_RGB;\n\tuint16 config = PLANARCONFIG_CONTIG;\n\tstruct tm *ct;\n\tchar mydescription[80];\n\tint year;\n\n\ttime_t long_time;\n\n\ttime( &long_time );           /* Get time as long integer. */\n\tct = localtime( &long_time ); /* Convert to local time. */\n\n\n\tyear=1900 + ct->tm_year;\n\tsprintf(datetime, \"%04d:%02d:%02d %02d:%02d:%02d\", year, ct->tm_mon + 1,\n\t        ct->tm_mday, ct->tm_hour, ct->tm_min, ct->tm_sec);\n\n\tif (description.empty())\n\t{\n\t\tdouble nSecs = difftime(long_time, start);\n\t\tsprintf(mydescription,\"Aqsis Renderer, %d secs rendertime\", static_cast<TqInt>(nSecs));\n\t\tstart = long_time;\n\t}\n\telse\n\t{\n\t\tstrcpy(mydescription, description.c_str());\n\t}\n\n\n\t// Set common tags\n\t// If in \"shadowmap\" mode, write as a shadowmap.\n\tif( image->m_imageType == Type_Shadowmap )\n\t{\n\t\tSaveAsShadowMap(filename, image, mydescription);\n\t\treturn;\n\t}\n\telse if( image->m_imageType == Type_ZFile )\n\t{\n\t\tstd::ofstream ofile( filename.c_str(), std::ios::out | std::ios::binary );\n\t\tif ( ofile.is_open() )\n\t\t{\n\t\t\t// Save a file type and version marker\n\t\t\tofile << ZFILE_HEADER;\n\n\t\t\t// Save the xres and yres.\n\t\t\tofile.write( reinterpret_cast<char* >( &image->m_width ), sizeof( image->m_width ) );\n\t\t\tofile.write( reinterpret_cast<char* >( &image->m_height ), sizeof( image->m_height ) );\n\n\t\t\t// Save the transformation matrices.\n\t\t\tofile.write( reinterpret_cast<char*>( image->m_matWorldToCamera[ 0 ] ), sizeof( image->m_matWorldToCamera[ 0 ][ 0 ] ) * 4 );\n\t\t\tofile.write( reinterpret_cast<char*>( image->m_matWorldToCamera[ 1 ] ), sizeof( image->m_matWorldToCamera[ 0 ][ 0 ] ) * 4 );\n\t\t\tofile.write( reinterpret_cast<char*>( image->m_matWorldToCamera[ 2 ] ), sizeof( image->m_matWorldToCamera[ 0 ][ 0 ] ) * 4 );\n\t\t\tofile.write( reinterpret_cast<char*>( image->m_matWorldToCamera[ 3 ] ), sizeof( image->m_matWorldToCamera[ 0 ][ 0 ] ) * 4 );\n\n\t\t\tofile.write( reinterpret_cast<char*>( image->m_matWorldToScreen[ 0 ] ), sizeof( image->m_matWorldToScreen[ 0 ][ 0 ] ) * 4 );\n\t\t\tofile.write( reinterpret_cast<char*>( image->m_matWorldToScreen[ 1 ] ), sizeof( image->m_matWorldToScreen[ 0 ][ 0 ] ) * 4 );\n\t\t\tofile.write( reinterpret_cast<char*>( image->m_matWorldToScreen[ 2 ] ), sizeof( image->m_matWorldToScreen[ 0 ][ 0 ] ) * 4 );\n\t\t\tofile.write( reinterpret_cast<char*>( image->m_matWorldToScreen[ 3 ] ), sizeof( image->m_matWorldToScreen[ 0 ][ 0 ] ) * 4 );\n\n\t\t\t// Now output the depth values\n\t\t\tofile.write( reinterpret_cast<char*>( image->m_data ), sizeof( TqFloat ) * ( image->m_width * image->m_height ) );\n\t\t\tofile.close();\n\t\t}\n\t\treturn;\n\t}\n\n\tTIFF* pOut = TIFFOpen( filename.c_str(), \"w\" );\n\n\tif ( pOut )\n\t{\n\t\t// Write the image to a tiff file.\n\t\tchar version[ 80 ];\n\n\t\tshort ExtraSamplesTypes[ 1 ] = {EXTRASAMPLE_ASSOCALPHA};\n\n\t\tsprintf( version, \"Aqsis %s (%s %s)\", AQSIS_VERSION_STR, __DATE__, __TIME__);\n\t\tbool use_logluv = false;\n\n\t\tTIFFSetField( pOut, TIFFTAG_SOFTWARE, ( char* ) version );\n\t\tTIFFSetField( pOut, TIFFTAG_IMAGEWIDTH, ( uint32 ) image->m_width );\n\t\tTIFFSetField( pOut, TIFFTAG_IMAGELENGTH, ( uint32 ) image->m_height );\n\t\tTIFFSetField( pOut, TIFFTAG_RESOLUTIONUNIT, RESUNIT_NONE );\n\t\tTIFFSetField( pOut, TIFFTAG_XRESOLUTION, (float) 1.0 );\n\t\tTIFFSetField( pOut, TIFFTAG_YRESOLUTION, (float) 1.0 );\n\t\tTIFFSetField( pOut, TIFFTAG_BITSPERSAMPLE, (short) 8 );\n\t\tTIFFSetField( pOut, TIFFTAG_PIXAR_MATRIX_WORLDTOCAMERA, image->m_matWorldToCamera );\n\t\tTIFFSetField( pOut, TIFFTAG_PIXAR_MATRIX_WORLDTOSCREEN, image->m_matWorldToScreen );\n\t\tTIFFSetField( pOut, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT );\n\t\tTIFFSetField( pOut, TIFFTAG_SAMPLESPERPIXEL, image->m_iFormatCount );\n\t\tTIFFSetField( pOut, TIFFTAG_DATETIME, datetime);\n\t\tif (!image->m_hostname.empty())\n\t\t\tTIFFSetField( pOut, TIFFTAG_HOSTCOMPUTER, image->m_hostname.c_str() );\n\t\tTIFFSetField( pOut, TIFFTAG_IMAGEDESCRIPTION, mydescription);\n\n\t\t// Set the position tages in case we aer dealing with a cropped image.\n\t\tTIFFSetField( pOut, TIFFTAG_XPOSITION, ( float ) image->m_origin[0] );\n\t\tTIFFSetField( pOut, TIFFTAG_YPOSITION, ( float ) image->m_origin[1] );\n\t\tTIFFSetField( pOut, TIFFTAG_PIXAR_IMAGEFULLWIDTH, (uint32) image->m_OriginalSize[0] );\n\t\tTIFFSetField( pOut, TIFFTAG_PIXAR_IMAGEFULLLENGTH, (uint32) image->m_OriginalSize[1] );\n\n\t\t// Write out an 8 bits per pixel integer image.\n\t\tif ( image->m_format == PkDspyUnsigned8 )\n\t\t{\n\t\t\tTIFFSetField( pOut, TIFFTAG_BITSPERSAMPLE, 8 );\n\t\t\tTIFFSetField( pOut, TIFFTAG_PLANARCONFIG, config );\n\t\t\tTIFFSetField( pOut, TIFFTAG_COMPRESSION, image->m_compression );\n\t\t\tif ( image->m_compression == COMPRESSION_JPEG )\n\t\t\t\tTIFFSetField( pOut, TIFFTAG_JPEGQUALITY, image->m_quality );\n\t\t\tTIFFSetField( pOut, TIFFTAG_PHOTOMETRIC, photometric );\n\t\t\tTIFFSetField( pOut, TIFFTAG_ROWSPERSTRIP, TIFFDefaultStripSize( pOut, 0 ) );\n\n\t\t\tif ( image->m_iFormatCount == 4 )\n\t\t\t\tTIFFSetField( pOut, TIFFTAG_EXTRASAMPLES, 1, ExtraSamplesTypes );\n\n\t\t\tTqInt row;\n\t\t\tfor ( row = 0; row < image->m_height; row++ )\n\t\t\t{\n\t\t\t\tif ( TIFFWriteScanline( pOut, reinterpret_cast<void*>(reinterpret_cast<char*>(image->m_data) + ( row * image->m_lineLength ))\n\t\t\t\t                        , row, 0 ) < 0 )\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tTIFFClose( pOut );\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Write out a floating point image.\n\t\t\tTIFFSetField( pOut, TIFFTAG_STONITS, ( double ) 1.0 );\n\n\t\t\t//\t\t\tif(/* user wants logluv compression*/)\n\t\t\t//\t\t\t{\n\t\t\t//\t\t\t\tif(/* user wants to save the alpha channel */)\n\t\t\t//\t\t\t\t{\n\t\t\t//\t\t\t\t\twarn(\"SGI LogLuv encoding does not allow an alpha channel\"\n\t\t\t//\t\t\t\t\t\t\t\" - using uncompressed IEEEFP instead\");\n\t\t\t//\t\t\t\t}\n\t\t\t//\t\t\t\telse\n\t\t\t//\t\t\t\t{\n\t\t\t//\t\t\t\t\tuse_logluv = true;\n\t\t\t//\t\t\t\t}\n\t\t\t//\n\t\t\t//\t\t\t\tif(/* user wants LZW compression*/)\n\t\t\t//\t\t\t\t{\n\t\t\t//\t\t\t\t\twarn(\"LZW compression is not available with SGI LogLuv encoding\\n\");\n\t\t\t//\t\t\t\t}\n\t\t\t//\t\t\t}\n\n\t\t\tif ( use_logluv )\n\t\t\t{\n\t\t\t\t/* use SGI LogLuv compression */\n\t\t\t\tTIFFSetField( pOut, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT );\n\t\t\t\tTIFFSetField( pOut, TIFFTAG_BITSPERSAMPLE, 16 );\n\t\t\t\tTIFFSetField( pOut, TIFFTAG_COMPRESSION, COMPRESSION_SGILOG );\n\t\t\t\tTIFFSetField( pOut, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_LOGLUV );\n\t\t\t\tTIFFSetField( pOut, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_FLOAT );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* use uncompressed IEEEFP pixels */\n\t\t\t\tTIFFSetField( pOut, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP );\n\t\t\t\tTIFFSetField( pOut, TIFFTAG_BITSPERSAMPLE, 32 );\n\t\t\t\tTIFFSetField( pOut, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB );\n\t\t\t\tTIFFSetField( pOut, TIFFTAG_COMPRESSION, image->m_compression );\n\t\t\t}\n\t\t\tif (image->m_format == PkDspyUnsigned16)\n\t\t\t{\n\t\t\t\tTIFFSetField( pOut, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT );\n\t\t\t\tTIFFSetField( pOut, TIFFTAG_BITSPERSAMPLE, 16 );\n\t\t\t}\n\n\t\t\tTIFFSetField( pOut, TIFFTAG_SAMPLESPERPIXEL, image->m_iFormatCount );\n\n\t\t\tif ( image->m_iFormatCount == 4 )\n\t\t\t\tTIFFSetField( pOut, TIFFTAG_EXTRASAMPLES, 1, ExtraSamplesTypes );\n\t\t\tTIFFSetField( pOut, TIFFTAG_PLANARCONFIG, config );\n\n\t\t\tTqInt row = 0;\n\t\t\tfor ( row = 0; row < image->m_height; row++ )\n\t\t\t{\n\t\t\t\tif ( TIFFWriteScanline( pOut, reinterpret_cast<void*>(reinterpret_cast<TqUchar*>(image->m_data) + ( row * image->m_lineLength )), row, 0 )\n\t\t\t\t        < 0 )\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tTIFFClose( pOut );\n\t\t}\n\t}\n}",
    "BOOST_AUTO_TEST_CASE(CqTiffDirHandle_write_read_header_test)\n{\n\tstd::ostringstream out;\n\t{\n\t\t// Create a tiff with some given header data.\n\t\tAqsis::CqTiffFileHandle tiffHandle(out);\n\t\tboost::shared_ptr<Aqsis::CqTiffFileHandle>\n\t\t\ttiffHandlePtr(&tiffHandle, Aqsis::nullDeleter);\n\t\tAqsis::CqTiffDirHandle dirHandle(tiffHandlePtr);\n\n\t\tAqsis::CqTexFileHeader header;\n\t\theader.setWidth(11);\n\t\theader.setHeight(1);\n\t\tAqsis::CqChannelList& channels = header.channelList();\n\t\tchannels.addChannel(Aqsis::SqChannelInfo(\"y\", Aqsis::Channel_Signed8));\n\t\theader.set<Aqsis::Attr::DisplayWindow>( Aqsis::SqImageRegion(1,2,3,4) );\n\n\t\tdirHandle.writeHeader(header);\n\t\tTqUint8 rubbishPixels[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\t\tTIFFWriteScanline(dirHandle.tiffPtr(), rubbishPixels, 0);\n\t}\n\n\t{\n\t\t// Read the tiff back in again.\n\t\tstd::istringstream in(out.str());\n\t\tAqsis::CqTiffFileHandle tiffHandle(in);\n\t\tboost::shared_ptr<Aqsis::CqTiffFileHandle>\n\t\t\ttiffHandlePtr(&tiffHandle, Aqsis::nullDeleter);\n\t\tAqsis::CqTiffDirHandle dirHandle(tiffHandlePtr);\n\n\t\tAqsis::CqTexFileHeader header;\n\t\tdirHandle.fillHeader(header);\n\n\t\t// check dimensions\n\t\tBOOST_CHECK_EQUAL(header.width(), 11);\n\t\tBOOST_CHECK_EQUAL(header.height(), 1);\n\t\t// check channels\n\t\tAqsis::CqChannelList& channels = header.channelList();\n\t\t// Note that we can't store actual channel names in tiff, but a single\n\t\t// channel is deduced to be an intensity channel under normal circumstances.\n\t\tBOOST_CHECK_EQUAL(channels[0].name, \"y\");\n\t\tBOOST_CHECK_EQUAL(channels[0].type, Aqsis::Channel_Signed8);\n\t\t// check display window\n\t\tAqsis::SqImageRegion& displayWindow = header.find<Aqsis::Attr::DisplayWindow>();\n\t\tBOOST_CHECK_EQUAL(displayWindow.width, 1);\n\t\tBOOST_CHECK_EQUAL(displayWindow.height, 2);\n\t\tBOOST_CHECK_EQUAL(displayWindow.topLeftX, 3);\n\t\tBOOST_CHECK_EQUAL(displayWindow.topLeftY, 4);\n\t}\n}",
    "void CqTextureMapOld::WriteImage( TIFF* ptex, TqPuchar raster, TqUlong width, TqUlong length, TqInt samples, TqInt compression, TqInt quality )\n{\n\t// First check if we can support the requested compression format.\n\tif(!TIFFIsCODECConfigured(compression))\n\t{\n\t\tAqsis::log() << error << \"Compression type \" << compression << \" not supported by the libtiff implementation\" << std::endl;\n\t\treturn;\n\t}\n\tTqChar version[ 80 ];\n\tTIFFCreateDirectory( ptex );\n\n\tsprintf( version, \"%s %s\", \"Aqsis\", AQSIS_VERSION_STR );\n\tTIFFSetField( ptex, TIFFTAG_SOFTWARE, ( char* ) version );\n\tTIFFSetField( ptex, TIFFTAG_IMAGEWIDTH, width );\n\tTIFFSetField( ptex, TIFFTAG_IMAGELENGTH, length );\n\tTIFFSetField( ptex, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG );\n\tTIFFSetField( ptex, TIFFTAG_BITSPERSAMPLE, 8 );\n\tTIFFSetField( ptex, TIFFTAG_SAMPLESPERPIXEL, samples );\n\tTIFFSetField( ptex, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT );\n\tTIFFSetField( ptex, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT );\n\tTIFFSetField( ptex, TIFFTAG_COMPRESSION, compression );\n\tTIFFSetField( ptex, TIFFTAG_ROWSPERSTRIP, 1 );\n\n\tunsigned char *pdata = raster;\n\tfor ( TqUlong i = 0; i < length; i++ )\n\t{\n\t\tTIFFWriteScanline( ptex, pdata, i );\n\t\tpdata += ( width * samples );\n\t}\n\tTIFFWriteDirectory( ptex );\n}",
    "void CqTextureMapOld::WriteImage( TIFF* ptex, TqFloat *raster, TqUlong width, TqUlong length, TqInt samples, TqInt compression, TqInt quality )\n{\n\t// First check if we can support the requested compression format.\n\tif(!TIFFIsCODECConfigured(compression))\n\t{\n\t\tAqsis::log() << error << \"Compression type \" << compression << \" not supported by the libtiff implementation\" << std::endl;\n\t\treturn;\n\t}\n\tTqChar version[ 80 ];\n\tTIFFCreateDirectory( ptex );\n\n\tsprintf( version, \"%s %s\", \"Aqsis\", AQSIS_VERSION_STR );\n\tTIFFSetField( ptex, TIFFTAG_SOFTWARE, ( char* ) version );\n\tTIFFSetField( ptex, TIFFTAG_IMAGEWIDTH, width );\n\tTIFFSetField( ptex, TIFFTAG_IMAGELENGTH, length );\n\tTIFFSetField( ptex, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG );\n\tTIFFSetField( ptex, TIFFTAG_BITSPERSAMPLE, 32 );\n\tTIFFSetField( ptex, TIFFTAG_SAMPLESPERPIXEL, samples );\n\tTIFFSetField( ptex, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT );\n\tTIFFSetField( ptex, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP );\n\tTIFFSetField( ptex, TIFFTAG_COMPRESSION, compression ); /* COMPRESSION_DEFLATE */\n\tTIFFSetField( ptex, TIFFTAG_ROWSPERSTRIP, 1 );\n\tTIFFSetField( ptex, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB );\n\n\tTqFloat *pdata = raster;\n\tfor ( TqUlong i = 0; i < length; i++ )\n\t{\n\t\tTIFFWriteScanline( ptex, pdata, i );\n\t\tpdata += ( width * samples );\n\t}\n\tTIFFWriteDirectory( ptex );\n}",
    "void CqTextureMapOld::WriteImage( TIFF* ptex, TqUshort *raster, TqUlong width, TqUlong length, TqInt samples, TqInt compression, TqInt quality )\n{\n\t// First check if we can support the requested compression format.\n\tif(!TIFFIsCODECConfigured(compression))\n\t{\n\t\tAqsis::log() << error << \"Compression type \" << compression << \" not supported by the libtiff implementation\" << std::endl;\n\t\treturn;\n\t}\n\tTqChar version[ 80 ];\n\tTIFFCreateDirectory( ptex );\n\n\tsprintf( version, \"%s %s\", \"Aqsis\", AQSIS_VERSION_STR );\n\tTIFFSetField( ptex, TIFFTAG_SOFTWARE, ( char* ) version );\n\tTIFFSetField( ptex, TIFFTAG_IMAGEWIDTH, width );\n\tTIFFSetField( ptex, TIFFTAG_IMAGELENGTH, length );\n\tTIFFSetField( ptex, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG );\n\tTIFFSetField( ptex, TIFFTAG_BITSPERSAMPLE, 16 );\n\tTIFFSetField( ptex, TIFFTAG_SAMPLESPERPIXEL, samples );\n\tTIFFSetField( ptex, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT );\n\tTIFFSetField( ptex, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT );\n\tTIFFSetField( ptex, TIFFTAG_COMPRESSION, compression ); /* COMPRESSION_DEFLATE */\n\tTIFFSetField( ptex, TIFFTAG_ROWSPERSTRIP, 1 );\n\tTIFFSetField( ptex, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB );\n\n\tTqUshort *pdata = raster;\n\tfor ( TqUlong i = 0; i < length; i++ )\n\t{\n\t\tTIFFWriteScanline( ptex, pdata, i );\n\t\tpdata += ( width * samples );\n\t}\n\tTIFFWriteDirectory( ptex );\n}",
    "noinline\nvoid renderImageSimple(TIFF* tif, int width, int superSamp, const float* filter,\n                       int filterWidth, const Transform& trans, int maxIter)\n{\n    writeHeader(tif, width, width);\n    int fullWidth = superSamp*(width + filterWidth-1);\n    std::vector<float> colVals(3*fullWidth*fullWidth, -1);\n    renderTile(&colVals[0], fullWidth, trans, maxIter);\n\n    std::vector<uint8> colFilt(width*3, 0);\n\n    const int fw = filterWidth*superSamp;\n    for(int iy = 0; iy < width; ++iy)\n    {\n        for(int ix = 0; ix < width; ++ix)\n        {\n            // Filter pixel\n            float col[3] = {0,0,0};\n            for(int j = 0; j < fw; ++j)\n                for(int i = 0; i < fw; ++i)\n                {\n                    float* c = &colVals[3*(fullWidth*(superSamp*iy+j) + superSamp*ix+i)];\n                    float w = filter[fw*j + i];\n                    col[0] += w*c[0];\n                    col[1] += w*c[1];\n                    col[2] += w*c[2];\n                }\n            // Quantize & store in scanline\n            colFilt[3*ix+0] = uint8(clamp(255*col[0], 0.0f, 255.0f));\n            colFilt[3*ix+1] = uint8(clamp(255*col[1], 0.0f, 255.0f));\n            colFilt[3*ix+2] = uint8(clamp(255*col[2], 0.0f, 255.0f));\n        }\n        // Save result\n        TIFFWriteScanline(tif, &colFilt[0], iy);\n    }\n}",
    "bool writeGeoTiffFloat(const std::string &filename, int x, int y, const float *data, double pixel_width, bool scalar,\n                       const std::string &projection_file, double origin_x, double origin_y)\n{\n  /* Open TIFF descriptor to write GeoTIFF tags */\n  TIFF *tif = XTIFFOpen(filename.c_str(), \"w\");\n  if (!tif)\n  {\n    return false;\n  }\n\n  /* Open GTIF Key parser */\n  GTIF *gtif = GTIFNew(tif);\n  if (!gtif)\n  {\n    return false;\n  }\n\n  if (x < 0 || y < 0)\n  {\n    std::cerr << \"Bad image size: \" << x << \", \" << y << std::endl;\n    return false;\n  }\n  const uint32_t w = (uint32_t)x;\n  const uint32_t h = (uint32_t)y;\n  const int channels = scalar ? 2 : 4;\n\n  /* Set up standard TIFF file */\n  TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, w);\n  /* set other TIFF tags and write out image ... */\n  TIFFSetField(tif, TIFFTAG_IMAGELENGTH, h);\n  TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 32);\n  TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n  TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, scalar ? PHOTOMETRIC_MINISBLACK : PHOTOMETRIC_RGB);\n  TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);\n  TIFFSetField(tif, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);\n  TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, channels);\n  const uint16_t ex_samp[] = { EXTRASAMPLE_ASSOCALPHA };\n  TIFFSetField(tif, TIFFTAG_EXTRASAMPLES, 1, &ex_samp);\n  TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, 1);\n  TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\n  // now go line by line to write out the image data\n  for (uint32_t row = 0; row < h; row++)\n  {\n    std::vector<float> pdst(channels * w);\n\n    // moving the data from the dib to a row structure that\n    // can be used by the tiff library\n    for (uint32_t col = 0; col < w; col++)\n    {\n      const uint32_t index = 3 * ((h - 1 - row) * w + col);\n      const float shade = (data[index + 0] + data[index + 1] + data[index + 2]) / 3.0f;\n      if (scalar)\n      {\n        pdst[2 * col] = shade;\n        pdst[2 * col + 1] = shade == 0.0 ? 0.0 : 255.0;\n      }\n      else\n      {\n        pdst[4 * col + 0] = data[index + 0];\n        pdst[4 * col + 1] = data[index + 1];\n        pdst[4 * col + 2] = data[index + 2];\n        pdst[4 * col + 3] = shade == 0.0 ? 0.0 : 255.0;\n      }\n    }\n\n    // now actually write the row data\n    TIFFWriteScanline(tif, &pdst[0], row, 0);\n  }\n\n  // read in the projection parameters\n  if (!projection_file.empty())\n  {\n    std::ifstream ifs(projection_file.c_str(), std::ios::in);\n    if (ifs.fail())\n    {\n      std::cerr << \"cannot open file \" << projection_file << std::endl;\n      return false;\n    }\n    std::string line;\n    if (!getline(ifs, line))\n    {\n      return false;\n    }\n    // the set of keys in the key-value pairs that we are parsing\n    const std::vector<std::string> keys = { \"+proj\", \"+ellps\", \"+datum\", \"+units\", \"+lat_0\", \"+lon_0\", \"+x_0\", \"+y_0\", \"+zone\" };\n    std::vector<std::string> values;\n    int zone_value = KvUserDefined;\n    for (const auto &key : keys)\n    {\n      std::string::size_type found = line.find(key);\n      if (found == std::string::npos)  // error checking\n      {\n        if (key == \"+ellps\")\n        {\n          std::cout << \"No ellps field found in proj file, setting it equal to the datum.\" << std::endl;\n          values.push_back(\"\");\n          continue;\n        }\n        if (key == \"+zone\")\n        {\n          std::cout << \"No zone field found in proj file\" << std::endl;\n          values.push_back(\"\");\n          continue;\n        }\n        std::cerr << \"Error: cannot find key: \" << key << \" in the projection file: \" << projection_file << std::endl;\n        return false;\n      }\n      // generate the list of values that correspond to the list of keys\n      found += key.length() + 1;\n      std::string::size_type space = line.find(\" \", found);\n      if (space == std::string::npos)\n        space = line.length();\n      values.push_back(line.substr(found, space - found));\n    }\n    if (values[1].empty())  // if ellipsoid type not specified, we take it to be the same as the datum\n    {\n      values[1] = values[2];\n    }\n    double coord_lat = 0.0;\n    if (!values[4].empty())\n    {\n      coord_lat = std::stod(values[4]);  // latitude\n    }\n    double coord_long = 0.0;\n    if (!values[5].empty())\n    {\n      coord_long = std::stod(values[5]);  // longitude\n    }\n    Eigen::Vector2d geo_offset(0, 0);\n    if (!values[6].empty())\n    {\n      geo_offset[0] = std::stod(values[6]);  // offset in m\n    }\n    if (!values[7].empty())\n    {\n      geo_offset[1] = std::stod(values[7]);  // offset in m\n    }\n    if (!values[8].empty())\n    {\n      std::cout << \"zone: \" << values[8] << std::endl;\n      zone_value = std::stoi(values[8]);\n      std::cout << \"zone?: \" << zone_value << std::endl;\n    }\n    std::cout << \"proj: \" << values[0] << \", geooffset: \" << geo_offset.transpose() << \", geokey: \" << values[1] << \", datum: \" << values[2]\n              << \", coord_long: \" << coord_long << \" zone: \" << zone_value << std::endl;\n\n    const double scales[3] = { pixel_width, pixel_width, pixel_width };\n    TIFFSetField(tif, TIFFTAG_GEOPIXELSCALE, 3, scales);  // set the width of a pixel\n\n    // Set GeoTIFF information\n    // We are only supporting a limited set of projection types, so here we assume standard settings\n    GTIFKeySet(gtif, GTModelTypeGeoKey, TYPE_SHORT, 1, ModelTypeProjected);\n    GTIFKeySet(gtif, GTRasterTypeGeoKey, TYPE_SHORT, 1, RasterPixelIsArea);\n\n    GTIFKeySet(gtif, ProjLinearUnitsGeoKey, TYPE_SHORT, 1, Linear_Meter);\n    GTIFKeySet(gtif, VerticalUnitsGeoKey, TYPE_SHORT, 1, Linear_Meter);\n\n    GTIFKeySet(gtif, ProjectionGeoKey, TYPE_SHORT, 1, KvUserDefined);\n    if (values[0] == \"ortho\")\n      GTIFKeySet(gtif, ProjCoordTransGeoKey, TYPE_SHORT, 1, CT_Orthographic);\n    else if (values[0] == \"utm\")\n      GTIFKeySet(gtif, ProjCoordTransGeoKey, TYPE_SHORT, 1, CT_TransverseMercator);\n    else\n    {\n      std::stringstream ss(values[0]);\n      int projcoord = 0;\n      ss >> projcoord;\n      if (!ss.fail())  // we are using a direct number here, so\n      {\n        GTIFKeySet(gtif, ProjCoordTransGeoKey, TYPE_SHORT, 1, projcoord);\n      }\n      else\n      {\n        std::cout << \"unknown projection type: \" << values[0] << std::endl;\n        return false;\n      }   \n    }\n\n    // describe the coordinates of the image corners\n    const double tiepoints[6] = { 0, 0, 0, origin_x + geo_offset[0], origin_y + geo_offset[1], 0 };\n    TIFFSetField(tif, TIFFTAG_GEOTIEPOINTS, 6, tiepoints);\n\n    if (values[1] == \"WGS84\")  // we support WGS84 by name\n    {\n      GTIFKeySet(gtif, GeographicTypeGeoKey, TYPE_SHORT, 1, GCS_WGS_84);\n    }\n    else  // all other Geographic type geokeys we parse directly by their number\n    {\n      std::stringstream ss(values[1]);\n      int geokey = 0;\n      ss >> geokey;\n      if (!ss.fail())  // we are using a direct number here, so\n      {\n        GTIFKeySet(gtif, GeographicTypeGeoKey, TYPE_SHORT, 1, geokey);\n      }\n      else\n      {\n        std::cout << \"unknown geographic projection type: \" << values[1] << std::endl;\n        return false;\n      }\n    }\n    if (values[2] == \"WGS84\")  // we support the datum type by name\n    {\n      GTIFKeySet(gtif, GeogGeodeticDatumGeoKey, TYPE_SHORT, 1, Datum_WGS84);\n    }\n    else\n    {\n      std::stringstream ss(values[2]);\n      int datum = 0;\n      ss >> datum;\n      if (!ss.fail())  // we are using a direct number here, so\n      {\n        GTIFKeySet(gtif, GeographicTypeGeoKey, TYPE_SHORT, 1, datum);\n      }\n      else\n      {\n        std::cout << \"unknown datum: \" << values[2] << std::endl;\n        return false;\n      }\n    }\n    GTIFKeySet(gtif, ProjectedCSTypeGeoKey, TYPE_SHORT, 1, zone_value);\n    GTIFKeySet(gtif, ProjectionGeoKey, TYPE_SHORT, 1, KvUserDefined);\n\n    if (values[3] != \"m\")  // we only support metres as the units\n    {\n      std::cout << \"unknown unit type: \" << values[3] << std::endl;\n      return false;\n    }\n    GTIFKeySet(gtif, ProjCenterLongGeoKey, TYPE_DOUBLE, 1, coord_long);\n    GTIFKeySet(gtif, ProjCenterLatGeoKey, TYPE_DOUBLE, 1, coord_lat);\n\n    // Store the keys into the TIFF Tags\n    GTIFWriteKeys(gtif);\n  }\n\n  // get rid of the key parser\n  GTIFFree(gtif);\n\n  // save and close the TIFF file descriptor\n  XTIFFClose(tif);\n\n  return true;\n}",
    "static std::optional<bool> recover_bitmap(const Parser::ParserStruct &tag, const std::string &path, const std::filesystem::path &data, bool overwrite) {\n        auto *bitmap = dynamic_cast<const Parser::Bitmap *>(&tag);\n        auto file_path = data / (path + \".tif\");\n\n        std::size_t width, height;\n        if(bitmap) {\n            width = bitmap->color_plate_width;\n            height = bitmap->color_plate_height;\n        }\n        else {\n            return std::nullopt;\n        }\n\n        // Does it already exist?\n        if(std::filesystem::exists(file_path) && !overwrite) {\n            oprintf_success_warn(\"%s already exists\", file_path.string().c_str());\n            return false;\n        }\n\n        // Decompress it\n        auto decompressed_stuff = HEK::decompress_color_plate_data(*bitmap);\n        \n        // Do we have color plate data?\n        if(!decompressed_stuff.has_value()) {\n            eprintf_warn(\"No color plate data to recover from - tag likely extracted\");\n            return false;\n        }\n\n        // Let's begin\n        auto file_path_str = file_path.string();\n        create_directories_for_path(file_path);\n\n        auto *tiff = TIFFOpen(file_path_str.c_str(), \"w\");\n        if(!tiff) {\n            eprintf_error(\"Failed to open %s for writing\", file_path_str.c_str());\n            return false;\n        }\n\n        TIFFSetField(tiff, TIFFTAG_IMAGEWIDTH, width);\n        TIFFSetField(tiff, TIFFTAG_IMAGELENGTH, height);\n\n        std::uint16_t extrasamples = EXTRASAMPLE_UNASSALPHA;\n        TIFFSetField(tiff, TIFFTAG_EXTRASAMPLES, 1, &extrasamples);\n\n        TIFFSetField(tiff, TIFFTAG_SAMPLESPERPIXEL, 4);\n        TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 8, 8, 8, 8);\n        TIFFSetField(tiff, TIFFTAG_ROWSPERSTRIP, 1);\n        TIFFSetField(tiff, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n        TIFFSetField(tiff, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n        TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n        TIFFSetField(tiff, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT);\n        TIFFSetField(tiff, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n\n        // Swap blue and red channels\n        for(auto &i : *decompressed_stuff) {\n            i = (i & 0xFF00FF00) | ((i & 0x00FF0000) >> 16) | ((i & 0x000000FF) << 16);\n        }\n\n        // Write it\n        for (std::size_t y = 0; y < height; y++) {\n            TIFFWriteScanline(tiff, decompressed_stuff->data() + y * width, y, 0);\n        }\n\n        TIFFClose(tiff);\n\n        oprintf(\"Recovered data file %s\\n\", file_path_str.c_str());\n\n        return true;\n    }",
    "void dng_save(std::vector<libcamera::Span<uint8_t>> const &mem, StreamInfo const &info, ControlList const &metadata,\n\t\t\t  std::string const &filename, std::string const &cam_model, StillOptions const *options)\n{\n\t// Check the Bayer format and unpack it to u16.\n\n\tauto it = bayer_formats.find(info.pixel_format);\n\tif (it == bayer_formats.end())\n\t\tthrow std::runtime_error(\"unsupported Bayer format\");\n\tBayerFormat const &bayer_format = it->second;\n\tLOG(1, \"Bayer format is \" << bayer_format.name);\n\n\t// Decompression will require a buffer that's 8 pixels aligned.\n\tunsigned int buf_stride_pixels = info.width;\n\tunsigned int buf_stride_pixels_padded = (buf_stride_pixels + 7) & ~7;\n\tstd::vector<uint16_t> buf(buf_stride_pixels_padded * info.height);\n\tif (bayer_format.compressed)\n\t{\n\t\tuncompress(mem[0].data(), info, &buf[0]);\n\t\tbuf_stride_pixels = buf_stride_pixels_padded;\n\t}\n\telse if (bayer_format.packed)\n\t{\n\t\tswitch (bayer_format.bits)\n\t\t{\n\t\tcase 10:\n\t\t\tunpack_10bit(mem[0].data(), info, &buf[0]);\n\t\t\tbreak;\n\t\tcase 12:\n\t\t\tunpack_12bit(mem[0].data(), info, &buf[0]);\n\t\t\tbreak;\n\t\t}\n\t}\n\telse\n\t\tunpack_16bit(mem[0].data(), info, &buf[0]);\n\n\t// We need to fish out some metadata values for the DNG.\n\tfloat black = 4096 * (1 << bayer_format.bits) / 65536.0;\n\tfloat black_levels[] = { black, black, black, black };\n\tauto bl = metadata.get(controls::SensorBlackLevels);\n\tif (bl)\n\t{\n\t\t// levels is in the order R, Gr, Gb, B. Re-order it for the actual bayer order.\n\t\tfor (int i = 0; i < 4; i++)\n\t\t{\n\t\t\tint j = bayer_format.order[i];\n\t\t\tj = j == 0 ? 0 : (j == 2 ? 3 : 1 + !!bayer_format.order[i ^ 1]);\n\t\t\tblack_levels[j] = (*bl)[i] * (1 << bayer_format.bits) / 65536.0;\n\t\t}\n\t}\n\telse\n\t\tLOG_ERROR(\"WARNING: no black level found, using default\");\n\n\tauto exp = metadata.get(controls::ExposureTime);\n\tfloat exp_time = 10000;\n\tif (exp)\n\t\texp_time = *exp;\n\telse\n\t\tLOG_ERROR(\"WARNING: default to exposure time of \" << exp_time << \"us\");\n\texp_time /= 1e6;\n\n\tauto ag = metadata.get(controls::AnalogueGain);\n\tuint16_t iso = 100;\n\tif (ag)\n\t\tiso = *ag * 100.0;\n\telse\n\t\tLOG_ERROR(\"WARNING: default to ISO value of \" << iso);\n\n\tfloat NEUTRAL[] = { 1, 1, 1 };\n\tMatrix WB_GAINS(1, 1, 1);\n\tauto cg = metadata.get(controls::ColourGains);\n\tif (cg)\n\t{\n\t\tNEUTRAL[0] = 1.0 / (*cg)[0];\n\t\tNEUTRAL[2] = 1.0 / (*cg)[1];\n\t\tWB_GAINS = Matrix((*cg)[0], 1, (*cg)[1]);\n\t}\n\n\t// Use a slightly plausible default CCM in case the metadata doesn't have one (it should!).\n\tMatrix CCM(1.90255, -0.77478, -0.12777,\n\t\t\t   -0.31338, 1.88197, -0.56858,\n\t\t\t   -0.06001, -0.61785, 1.67786);\n\tauto ccm = metadata.get(controls::ColourCorrectionMatrix);\n\tif (ccm)\n\t{\n\t\tCCM = Matrix((*ccm)[0], (*ccm)[1], (*ccm)[2], (*ccm)[3], (*ccm)[4], (*ccm)[5], (*ccm)[6], (*ccm)[7], (*ccm)[8]);\n\t}\n\telse\n\t\tLOG_ERROR(\"WARNING: no CCM metadata found\");\n\n\t// This maxtrix from http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n\tMatrix RGB2XYZ(0.4124564, 0.3575761, 0.1804375,\n\t\t\t\t   0.2126729, 0.7151522, 0.0721750,\n\t\t\t\t   0.0193339, 0.1191920, 0.9503041);\n\tMatrix CAM_XYZ = (RGB2XYZ * CCM * WB_GAINS).Inv();\n\n\tLOG(2, \"Black levels \" << black_levels[0] << \" \" << black_levels[1] << \" \" << black_levels[2] << \" \"\n\t\t\t\t\t\t   << black_levels[3] << \", exposure time \" << exp_time * 1e6 << \"us, ISO \" << iso);\n\tLOG(2, \"Neutral \" << NEUTRAL[0] << \" \" << NEUTRAL[1] << \" \" << NEUTRAL[2]);\n\tLOG(2, \"Cam_XYZ: \");\n\tLOG(2, CAM_XYZ.m[0] << \" \" << CAM_XYZ.m[1] << \" \" << CAM_XYZ.m[2]);\n\tLOG(2, CAM_XYZ.m[3] << \" \" << CAM_XYZ.m[4] << \" \" << CAM_XYZ.m[5]);\n\tLOG(2, CAM_XYZ.m[6] << \" \" << CAM_XYZ.m[7] << \" \" << CAM_XYZ.m[8]);\n\n\t// Finally write the DNG.\n\n\tTIFF *tif = nullptr;\n\n\ttry\n\t{\n\t\tconst short cfa_repeat_pattern_dim[] = { 2, 2 };\n\t\tuint32_t white = (1 << bayer_format.bits) - 1;\n\t\ttoff_t offset_subifd = 0, offset_exififd = 0;\n\t\tstd::string unique_model = std::string(MAKE_STRING \" \") + cam_model;\n\n\t\ttif = TIFFOpen(filename.c_str(), \"w\");\n\t\tif (!tif)\n\t\t\tthrow std::runtime_error(\"could not open file \" + filename);\n\n\t\t// This is just the thumbnail, but put it first to help software that only\n\t\t// reads the first IFD.\n\t\tTIFFSetField(tif, TIFFTAG_SUBFILETYPE, 1);\n\t\tTIFFSetField(tif, TIFFTAG_IMAGEWIDTH, info.width >> 4);\n\t\tTIFFSetField(tif, TIFFTAG_IMAGELENGTH, info.height >> 4);\n\t\tTIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8);\n\t\tTIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n\t\tTIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n\t\tTIFFSetField(tif, TIFFTAG_MAKE, MAKE_STRING);\n\t\tTIFFSetField(tif, TIFFTAG_MODEL, cam_model.c_str());\n\t\tTIFFSetField(tif, TIFFTAG_DNGVERSION, \"\\001\\001\\000\\000\");\n\t\tTIFFSetField(tif, TIFFTAG_DNGBACKWARDVERSION, \"\\001\\000\\000\\000\");\n\t\tTIFFSetField(tif, TIFFTAG_UNIQUECAMERAMODEL, unique_model.c_str());\n\t\tTIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n\t\tTIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 3);\n\t\tTIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\t\tTIFFSetField(tif, TIFFTAG_SOFTWARE, \"rpicam-still\");\n\t\tTIFFSetField(tif, TIFFTAG_COLORMATRIX1, 9, CAM_XYZ.m);\n\t\tTIFFSetField(tif, TIFFTAG_ASSHOTNEUTRAL, 3, NEUTRAL);\n\t\tTIFFSetField(tif, TIFFTAG_CALIBRATIONILLUMINANT1, 21);\n\t\tTIFFSetField(tif, TIFFTAG_SUBIFD, 1, &offset_subifd);\n\t\tTIFFSetField(tif, TIFFTAG_EXIFIFD, offset_exififd);\n\n\t\t// Make a small greyscale thumbnail, just to give some clue what's in here.\n\t\tstd::vector<uint8_t> thumb_buf((info.width >> 4) * 3);\n\n\t\tfor (unsigned int y = 0; y < (info.height >> 4); y++)\n\t\t{\n\t\t\tfor (unsigned int x = 0; x < (info.width >> 4); x++)\n\t\t\t{\n\t\t\t\tunsigned int off = (y * buf_stride_pixels + x) << 4;\n\t\t\t\tuint32_t grey =\n\t\t\t\t\tbuf[off] + buf[off + 1] + buf[off + buf_stride_pixels] + buf[off + buf_stride_pixels + 1];\n\t\t\t\tgrey = (grey << 14) >> bayer_format.bits;\n\t\t\t\tgrey = sqrt((double)grey); // simple \"gamma correction\"\n\t\t\t\tthumb_buf[3 * x] = thumb_buf[3 * x + 1] = thumb_buf[3 * x + 2] = grey;\n\t\t\t}\n\t\t\tif (TIFFWriteScanline(tif, &thumb_buf[0], y, 0) != 1)\n\t\t\t\tthrow std::runtime_error(\"error writing DNG thumbnail data\");\n\t\t}\n\n\t\tTIFFWriteDirectory(tif);\n\n\t\t// The main image (actually tends to show up as \"sub-image 1\").\n\t\tTIFFSetField(tif, TIFFTAG_SUBFILETYPE, 0);\n\t\tTIFFSetField(tif, TIFFTAG_IMAGEWIDTH, info.width);\n\t\tTIFFSetField(tif, TIFFTAG_IMAGELENGTH, info.height);\n\t\tTIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 16);\n\t\tTIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_CFA);\n\t\tTIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 1);\n\t\tTIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\t\tTIFFSetField(tif, TIFFTAG_CFAREPEATPATTERNDIM, cfa_repeat_pattern_dim);\n#if TIFFLIB_VERSION >= 20201219 // version 4.2.0 or later\n\t\tTIFFSetField(tif, TIFFTAG_CFAPATTERN, 4, bayer_format.order);\n#else\n\t\tTIFFSetField(tif, TIFFTAG_CFAPATTERN, bayer_format.order);\n#endif\n\t\tTIFFSetField(tif, TIFFTAG_WHITELEVEL, 1, &white);\n\t\tconst uint16_t black_level_repeat_dim[] = { 2, 2 };\n\t\tTIFFSetField(tif, TIFFTAG_BLACKLEVELREPEATDIM, &black_level_repeat_dim);\n\t\tTIFFSetField(tif, TIFFTAG_BLACKLEVEL, 4, &black_levels);\n\n\t\tfor (unsigned int y = 0; y < info.height; y++)\n\t\t{\n\t\t\tif (TIFFWriteScanline(tif, &buf[buf_stride_pixels * y], y, 0) != 1)\n\t\t\t\tthrow std::runtime_error(\"error writing DNG image data\");\n\t\t}\n\n\t\t// We have to checkpoint before the directory offset is valid.\n\t\tTIFFCheckpointDirectory(tif);\n\t\toffset_subifd = TIFFCurrentDirOffset(tif);\n\t\tTIFFWriteDirectory(tif);\n\n\t\t// Create a separate IFD just for the EXIF tags. Why we couldn't simply have\n\t\t// DNG tags for these, which would have made life so much easier, I have no idea.\n\t\tTIFFCreateEXIFDirectory(tif);\n\n\t\ttime_t t;\n\t\ttime(&t);\n\t\tstruct tm *time_info = localtime(&t);\n\t\tchar time_str[32];\n\t\tstrftime(time_str, 32, \"%Y:%m:%d %H:%M:%S\", time_info);\n\t\tTIFFSetField(tif, EXIFTAG_DATETIMEORIGINAL, time_str);\n\n\t\tTIFFSetField(tif, EXIFTAG_ISOSPEEDRATINGS, 1, &iso);\n\t\tTIFFSetField(tif, EXIFTAG_EXPOSURETIME, exp_time);\n\n\t\tauto lp = metadata.get(libcamera::controls::LensPosition);\n\t\tif (lp)\n\t\t{\n\t\t\tdouble dist = (*lp > 0.0) ? (1.0 / *lp) : std::numeric_limits<double>::infinity();\n\t\t\tTIFFSetField(tif, EXIFTAG_SUBJECTDISTANCE, dist);\n\t\t}\n\n\t\tTIFFCheckpointDirectory(tif);\n\t\toffset_exififd = TIFFCurrentDirOffset(tif);\n\t\tTIFFWriteDirectory(tif);\n\n\t\t// Now got back to the initial IFD and correct the offsets to its sub-thingies\n\t\tTIFFSetDirectory(tif, 0);\n\t\tTIFFSetField(tif, TIFFTAG_SUBIFD, 1, &offset_subifd);\n\t\tTIFFSetField(tif, TIFFTAG_EXIFIFD, offset_exififd);\n\t\tTIFFWriteDirectory(tif);\n\n\t\t// For reasons unknown, the last sub-IFD that we make seems to reappear at the\n\t\t// end of the file as IDF1, and some tools (exiftool for example) are prone to\n\t\t// complain about it. As far as I can see the code above is doing the correct\n\t\t// things, and I can't find any references to this problem anywhere. So frankly\n\t\t// I have no idea what is happening - please let us know if you do. Anyway,\n\t\t// this bodge appears to make the problem go away...\n\t\tTIFFUnlinkDirectory(tif, 2);\n\n\t\tTIFFClose(tif);\n\t}\n\tcatch (std::exception const &e)\n\t{\n\t\tif (tif)\n\t\t\tTIFFClose(tif);\n\t\tthrow;\n\t}\n}",
    "uiRetVal uiGeotiffWriter::writeHorizon( uiTaskRunner& taskrunner, const MultiID& hor3Dkey,\n\t\t\t\t\tbool exportZ, const BufferStringSet& attribs )\n{\n    if (!srs_)\n\treturn uiRetVal(tr(\"uiGeotiffWriter::writeHorizon - srs is undefined.\"));\n\n    if (hor3Dkey.isUdf())\n\treturn uiRetVal(tr(\"uiGeotiffWriter::writeHorizon - undefined horizon id.\"));\n\n    if (!exportZ && attribs.isEmpty())\n\treturn uiRetVal(tr(\"uiGeotiffWriter::writeHorizon - nothing to export.\"));\n\n    if (!isOK() || !open())\n\treturn errmsg_;\n\n    const float zfac = SI().zIsTime() ? 1000 : 1;\n    EM::IOObjInfo eminfo(hor3Dkey);\n    if (!eminfo.isOK())\n\treturn uiRetVal(tr(\"uiGeotiffWriter::writeHorizon - cannot read %1.\").arg(eminfo.name()));\n\n    TrcKeySampling hs;\n    hs.set(eminfo.getInlRange(), eminfo.getCrlRange());\n    int nrBands = exportZ ? attribs.size()+1 : attribs.size();\n    bandmetadata_.setEmpty();\n\n    uiRetVal uirv = setTiffTags(hs, nrBands);\n    if ( !uirv.isOK() )\n    {\n\tclose();\n\treturn uirv;\n    }\n\n    ConstPtrMan<IOObj> ioobj = IOM().get( hor3Dkey );\n    if ( !ioobj )\n\treturn uiRetVal(tr(\"uiGeotiffWriter::writeHorizon - undefined horizon ioobj.\"));\n\n    EM::SurfaceIOData sd;\n    uiString errmsg;\n    if ( !EM::EMM().getSurfaceData(ioobj->key(), sd, errmsg) )\n\treturn uiRetVal(tr(\"uiGeoTiffWriter::writeHorizon - \"), errmsg);\n\n    EM::SurfaceIODataSelection sels( sd );\n    sels.selvalues.erase();\n    RefMan<EM::EMObject> emobj = EM::EMM().createTempObject( ioobj->group() );\n    if ( !emobj )\n\treturn uiRetVal(tr(\"uiGeotiffWriter::writeHorizon - cannot create temporary horizon.\"));\n\n    emobj->setMultiID( ioobj->key() );\n    mDynamicCastGet(EM::Horizon3D*,hor,emobj.ptr())\n    PtrMan<Executor> loader = hor->geometry().loader( &sels );\n    if ( !loader )\n\treturn uiRetVal(tr(\"uiGeotiffWriter::writeHorizon - getting 3D horizon loader failed\"));\n\n    if ( !TaskRunner::execute(&taskrunner,*loader) )\n\t return uiRetVal(tr(\"uiGeotiffWriter::writeHorizon - loading 3D horizon failed\"));\n\n    float* rowBuff = (float*) _TIFFmalloc(TIFFScanlineSize(tif_));\n    BufferString description;\n    int bandnr = 0;\n// Export Z\n    if (exportZ)\n    {\n\tdescription = BufferString(\"Z value \", SI().getZUnitString());\n\taddBandMetadata(bandnr, description);\n\tfor (int ildx=0; ildx<hs.nrInl(); ildx++)\n\t{\n\t    for (int icdx=0; icdx<hs.nrCrl(); icdx++)\n\t    {\n\t\tconst auto trckey = hs.trcKeyAt( ildx, icdx );\n\t\tfloat z = hor->getZ( trckey );\n\t\tif (!mIsUdf(z))\n\t\t    z *= zfac;\n\t\trowBuff[icdx] = z;\n\t    }\n\t    if (!TIFFWriteScanline(tif_, rowBuff, ildx, bandnr))\n\t    {\n\t\t_TIFFfree(rowBuff);\n\t\treturn uiRetVal(tr(\"uiGeotiffWriter::writeHorizon - writing horizon z data failed\"));\n\t    }\n        }\n        bandnr++;\n    }\n// Export attributes\n    if (attribs.size()>0)\n    {\n\tfor (int iatt=0; iatt<attribs.size(); iatt++)\n\t{\n\t    PtrMan<Executor> auxloader = hor->auxdata.auxDataLoader(attribs.get(iatt).buf());\n\t    if ( !loader || !TaskRunner::execute( &taskrunner, *auxloader ) )\n\t\t    return uiRetVal(tr(\"uiGeotiffWriter::writeHorizon - loading 3D horizon attributes failed\"));\n\n\t    if (hor->auxdata.hasAuxDataName(attribs.get(iatt)))\n\t    {\n\n\t\tint iaux = hor->auxdata.auxDataIndex(attribs.get(iatt));\n\t\tdescription = attribs.get(iatt);\n\t\taddBandMetadata(bandnr, description);\n\t\tfor (int ildx=0; ildx<hs.nrInl(); ildx++)\n\t\t{\n\t\t    for (int icdx=0; icdx<hs.nrCrl(); icdx++)\n\t\t    {\n\t\t\tconst auto trckey = hs.trcKeyAt( ildx, icdx );\n\t\t\tfloat z = hor->auxdata.getAuxDataVal( iaux, trckey );\n\t\t\trowBuff[icdx] = z;\n\t\t    }\n\t\t    if (!TIFFWriteScanline(tif_, rowBuff, ildx, bandnr))\n\t\t    {\n\t\t\t_TIFFfree(rowBuff);\n\t\t\treturn uiRetVal(tr(\"uiGeotiffWriter::writeHorizon - writing attribute data failed\"));\n\t\t    }\n\t\t}\n\t    } else\n\t    {\n\t\t_TIFFfree(rowBuff);\n\t\treturn uiRetVal(tr(\"uiGeotiffWriter::writeHorizon - no data for attribute: %1\").arg(attribs.get(iatt)));\n\t    }\n\t    bandnr++;\n\t    hor->auxdata.removeAll();\n\t}\n    }\n    setMetadataField();\n    close();\n    _TIFFfree( rowBuff );\n\n    return uiRetVal::OK();\n}",
    "uiRetVal uiGeotiffWriter::writeZSlices( uiTaskRunner& taskrunner, const TypeSet<MultiID>& seisids, float slicetime )\n{\n    if (!srs_)\n\treturn uiRetVal(tr(\"uiGeotiffWriter::writeZSlices - srs is undefined.\"));\n\n    if (seisids.isEmpty())\n\treturn uiRetVal(tr(\"uiGeotiffWriter::writeZSlices - nothing to export.\"));\n\n    TrcKeySampling hs;\n    bool first = true;\n    int nrBands = 0;\n    for ( const auto& seisid : seisids )\n    {\n\tPtrMan<IOObj> ioobj = IOM().get(seisid);\n\tif ( !ioobj )\n\t    return uiRetVal(tr(\"uiGeotiffWriter::writeZSlices - cannot find data set.\"));\n\n\tconst SeisIOObjInfo seisinfo(ioobj.ptr());\n\tTrcKeyZSampling tkzs;\n\tseisinfo.getRanges(tkzs);\n\tnrBands += seisinfo.nrComponents();\n\tif (first)\n\t{\n\t    hs = tkzs.hsamp_;\n\t    continue;\n\t}\n\n\tif (tkzs.hsamp_.lineRange().isCompatible(hs.lineRange()) && tkzs.hsamp_.trcRange().isCompatible(hs.trcRange()))\n\t    hs.include(tkzs.hsamp_);\n\telse\n\t    return uiRetVal(tr(\"uiGeotiffWriter::writeZSlices - data sets have inconsistent horizontal sampling.\"));\n    }\n\n    if (!isOK() || !open())\n\treturn errmsg_;\n\n    const float zfac = SI().showZ2UserFactor();\n    slicetime /= zfac;\n    bandmetadata_.setEmpty();\n    uiRetVal uirv = setTiffTags(hs, nrBands);\n    if ( !uirv.isOK() )\n    {\n\tclose();\n\treturn uirv;\n    }\n\n    float* rowBuff = (float*) _TIFFmalloc(TIFFScanlineSize(tif_));\n    BufferString description;\n    int bandnr = 0;\n    for ( const auto& seisid : seisids )\n    {\n\tPtrMan<IOObj> ioobj = IOM().get(seisid);\n\tconst SeisIOObjInfo seisinfo(ioobj.ptr());\n\tTrcKeyZSampling tkzforload;\n\tseisinfo.getRanges(tkzforload);\n\ttkzforload.hsamp_ = hs;\n\ttkzforload.zsamp_ = StepInterval<float>(slicetime, slicetime, tkzforload.zsamp_.step_);\n\tSeis::SequentialReader rdr( *ioobj, &tkzforload );\n\tif ( !rdr.execute() )\n\t    return uiRetVal(tr(\"uiGeotiffWriter::writeZSlices - reading seismic volume failed.\"));\n\n\tConstRefMan<RegularSeisDataPack> dp = rdr.getDataPack();\n\tif ( !dp )\n\t    continue;\n\n\tconst TrcKeyZSampling& actualtkz = dp->sampling();\n\tconst int nrcomp = dp->nrComponents();\n\n\tfor ( int cidx=0; cidx<nrcomp; cidx++ )\n\t{\n\t    description = dp->getComponentName(cidx);\n\t    addBandMetadata(bandnr, description);\n\t    const Array3DImpl<float>& arr = dp->data(cidx);\n\t    for (int ildx=0; ildx<hs.nrInl(); ildx++)\n\t    {\n\t\tfor (int icdx=0; icdx<hs.nrCrl(); icdx++)\n\t\t{\n\t\t    const int dpidx = dp->getGlobalIdx(hs.trcKeyAt( ildx, icdx ));\n\t\t    const int lidx = actualtkz.hsamp_.lineIdxFromGlobal(dpidx);\n\t\t    const int tidx = actualtkz.hsamp_.trcIdxFromGlobal(dpidx);\n\t\t    if ( dpidx!=-1 )\n\t\t\trowBuff[icdx] = arr.get(lidx, tidx, 0);\n\t\t    else\n\t\t\trowBuff[icdx] = mUdf(float);\n\t\t}\n\t\tif (!TIFFWriteScanline(tif_, rowBuff, ildx, bandnr))\n\t\t{\n\t\t    _TIFFfree(rowBuff);\n\t\t    return uiRetVal(tr(\"uiGeotiffWriter::writeZSlices - writing z slices failed\"));\n\t\t}\n\t    }\n\t    bandnr++;\n\t}\n    }\n    setMetadataField();\n    close();\n    _TIFFfree( rowBuff );\n\n    return uiRetVal::OK();\n}",
    "bool\nImage::saveTIFF(const char *file, SaveInfo*)\n{\n    TIFF *tif = TIFFOpen(file, \"w\");\n    if (!tif)\n        return (false);\n\n    TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, rgb_width);\n    TIFFSetField(tif, TIFFTAG_IMAGELENGTH, rgb_height);\n    TIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n    TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8);\n    TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n//    TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_LZW);\nTIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);\n    TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 3);\n    TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n    TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP,\n        TIFFDefaultStripSize(tif, (unsigned int)-1));\n    for (int y = 0; y < rgb_height; y++) {\n        unsigned char *data = rgb_data + (y * rgb_width * 3);\n        TIFFWriteScanline(tif, data, y, 0);\n    }\n    TIFFClose(tif);\n    return (true);\n}",
    "File(\n                    const std::string& fileName,\n                    const std::shared_ptr<dtk::Image>& image)\n                {\n#if defined(_WINDOWS)\n                    _tiff.p = TIFFOpenW(dtk::toWide(fileName).c_str(), \"w\");\n#else // _WINDOWS\n                    _tiff.p = TIFFOpen(fileName.c_str(), \"w\");\n#endif // _WINDOWS\n                    if (!_tiff.p)\n                    {\n                        throw std::runtime_error(dtk::Format(\"{0}: Cannot open\").arg(fileName));\n                    }\n\n                    uint16_t tiffPhotometric = 0;\n                    uint16_t tiffSamples = 0;\n                    uint16_t tiffSampleDepth = 0;\n                    uint16_t tiffSampleFormat = 0;\n                    uint16_t tiffExtraSamples[] = { EXTRASAMPLE_ASSOCALPHA };\n                    uint16_t tiffExtraSamplesSize = 0;\n                    uint16_t tiffCompression = 0;\n                    const auto& info = image->getInfo();\n                    switch (dtk::getChannelCount(info.type))\n                    {\n                    case 1:\n                        tiffPhotometric = PHOTOMETRIC_MINISBLACK;\n                        tiffSamples = 1;\n                        break;\n                    case 2:\n                        tiffPhotometric = PHOTOMETRIC_MINISBLACK;\n                        tiffSamples = 2;\n                        tiffExtraSamplesSize = 1;\n                        break;\n                    case 3:\n                        tiffPhotometric = PHOTOMETRIC_RGB;\n                        tiffSamples = 3;\n                        break;\n                    case 4:\n                        tiffPhotometric = PHOTOMETRIC_RGB;\n                        tiffSamples = 4;\n                        tiffExtraSamplesSize = 1;\n                        break;\n                    default: break;\n                    }\n                    switch (info.type)\n                    {\n                    case dtk::ImageType::L_U8:\n                    case dtk::ImageType::LA_U8:\n                    case dtk::ImageType::RGB_U8:\n                    case dtk::ImageType::RGBA_U8:\n                        tiffSampleDepth = 8;\n                        tiffSampleFormat = SAMPLEFORMAT_UINT;\n                        break;\n                    case dtk::ImageType::L_U16:\n                    case dtk::ImageType::LA_U16:\n                    case dtk::ImageType::RGB_U16:\n                    case dtk::ImageType::RGBA_U16:\n                        tiffSampleDepth = 16;\n                        tiffSampleFormat = SAMPLEFORMAT_UINT;\n                        break;\n                    case dtk::ImageType::L_F32:\n                    case dtk::ImageType::LA_F32:\n                    case dtk::ImageType::RGB_F32:\n                    case dtk::ImageType::RGBA_F32:\n                        tiffSampleDepth = 32;\n                        tiffSampleFormat = SAMPLEFORMAT_IEEEFP;\n                        break;\n                    default: break;\n                    }\n                    if (!tiffSamples || !tiffSampleDepth)\n                    {\n                        throw std::runtime_error(dtk::Format(\"{0}: Cannot open\").arg(fileName));\n                    }\n\n                    tiffCompression = COMPRESSION_NONE;\n                    /*switch (_p->options.compression)\n                    {\n                    case Compression::None:\n                        compression = COMPRESSION_NONE;\n                        break;\n                    case Compression::RLE:\n                        compression = COMPRESSION_PACKBITS;\n                        break;\n                    case Compression::LZW:\n                        compression = COMPRESSION_LZW;\n                        break;\n                    default: break;\n                    }*/\n                    TIFFSetField(_tiff.p, TIFFTAG_IMAGEWIDTH, info.size.w);\n                    TIFFSetField(_tiff.p, TIFFTAG_IMAGELENGTH, info.size.h);\n                    TIFFSetField(_tiff.p, TIFFTAG_PHOTOMETRIC, tiffPhotometric);\n                    TIFFSetField(_tiff.p, TIFFTAG_SAMPLESPERPIXEL, tiffSamples);\n                    TIFFSetField(_tiff.p, TIFFTAG_BITSPERSAMPLE, tiffSampleDepth);\n                    TIFFSetField(_tiff.p, TIFFTAG_SAMPLEFORMAT, tiffSampleFormat);\n                    TIFFSetField(_tiff.p, TIFFTAG_EXTRASAMPLES, tiffExtraSamplesSize, tiffExtraSamples);\n                    TIFFSetField(_tiff.p, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n                    TIFFSetField(_tiff.p, TIFFTAG_COMPRESSION, tiffCompression);\n                    TIFFSetField(_tiff.p, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\n                    const auto& tags = image->getTags();\n                    auto i = tags.find(\"Creator\");\n                    if (i != tags.end())\n                    {\n                        TIFFSetField(_tiff.p, TIFFTAG_ARTIST, i->second.c_str());\n                    }\n                    i = tags.find(\"Copyright\");\n                    if (i != tags.end())\n                    {\n                        TIFFSetField(_tiff.p, TIFFTAG_COPYRIGHT, i->second.c_str());\n                    }\n                    i = tags.find(\"Time\");\n                    if (i != tags.end())\n                    {\n                        TIFFSetField(_tiff.p, TIFFTAG_DATETIME, i->second.c_str());\n                    }\n                    i = tags.find(\"Description\");\n                    if (i != tags.end())\n                    {\n                        TIFFSetField(_tiff.p, TIFFTAG_IMAGEDESCRIPTION, i->second.c_str());\n                    }\n\n                    const size_t scanlineByteCount = dtk::getAlignedByteCount(\n                        info.size.w * tiffSamples * tiffSampleDepth / 8,\n                        info.layout.alignment);\n                    const uint8_t* p = image->getData() + (info.size.h - 1) * scanlineByteCount;\n                    for (uint16_t y = 0; y < info.size.h; ++y, p -= scanlineByteCount)\n                    {\n                        if (TIFFWriteScanline(_tiff.p, (tdata_t*)p, y) == -1)\n                        {\n                            throw std::runtime_error(dtk::Format(\"{0}: Cannot write scanline: {1}\").arg(fileName).arg(y));\n                        }\n                    }\n                }",
    "void LibTiffWriter::_write(Image* im, std::string filename) {\n        struct tiff* img_out;\n\n        int width = im->width();\n        int height = im->height();\n        int channels = im->channels();\n\n\n\t\t/* Check if color profile is implemented. */\n\t\tswitch(im->getColorProfile()) {\n\t\t\tcase none: case ColorSpace::ProPhoto: case ColorSpace::Adobe_RGB_1998:\n\t\t\t\tbreak;\n\t\t\tdefault: case ColorSpace::sRGB: case ColorSpace::Wide_Gamut_RGB: \n\t\t\t\tthrow std::logic_error(\"[LibTiffWriter] Color profile not implemented.\");\n\t\t}\n\n\n\t\tcv::Mat im_16u;\n\t\tim->getMat().convertTo(im_16u, CV_16U, 0xFFFF);\n        uint16_t* bitmap = (uint16_t*) im_16u.data;\n\n\n\n        /* ==============[ Open tiff file for writing ]================== */\n\n\t\timg_out = TIFFOpen(filename.c_str(), \"w\");\n\t\tif(!img_out) \n            throw LibTiff_OpenFileFailed();\n\n\n\n\t\t/* =================[ Write tiff header tags ]================== */\n\n\t\tTIFFSetField(img_out, TIFFTAG_IMAGEWIDTH, width);\n\t\tTIFFSetField(img_out, TIFFTAG_IMAGELENGTH, height);\n\n\t\t/* Set the number of channels. */\n\t\tTIFFSetField(img_out, TIFFTAG_SAMPLESPERPIXEL, channels);\n\n\t\t/* We want 16 bits. */\n\t\tTIFFSetField(img_out, TIFFTAG_BITSPERSAMPLE, 16);\n\t\t\n\t\t/* Image rotation. */\n\t\tTIFFSetField(img_out, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n\n\t\t/* Write all channel data in one array (a bitmap) instead of separating the channels. */\n\t\tTIFFSetField(img_out, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\n\t\t/* Indicate type of image. */\n\t\tif(channels == 3)\n\t\t\tTIFFSetField(img_out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n\t\telse if(channels == 1)\n\t\t\tTIFFSetField(img_out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n\t\telse {\n\t\t\tTIFFSetField(img_out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n\t\t\tuint16_t tags[16] = {EXTRASAMPLE_UNSPECIFIED};\n\t\t\tTIFFSetField(img_out, TIFFTAG_EXTRASAMPLES, channels - 1, tags);\n\t\t}\n\n\t\t/* Set color profile. */\n\t\tswitch(im->getColorProfile()) {\n\n\t\t\tcase none: \n\t\t\t\tbreak;\n\n\t\t\tcase ColorSpace::ProPhoto:\n\t\t\t\tTIFFSetField(img_out, TIFFTAG_ICCPROFILE, ProPhoto_icm_size, ProPhoto_icm_data);\n\t\t\t\tbreak;\n\n\t\t\tcase ColorSpace::Adobe_RGB_1998:\n\t\t\t\tTIFFSetField(img_out, TIFFTAG_ICCPROFILE, AdobeRGB1998_icc_size, AdobeRGB1998_icc_data);\n\t\t\t\tbreak;\n\n\t\t\tcase ColorSpace::sRGB:\n\t\t\tcase ColorSpace::Wide_Gamut_RGB:\n\t\t\tdefault: throw std::logic_error(\"[LibTiffWriter] Invalid color profile.\");\n\t\t}\n\n\t\t/* Set custom application tags as artist. */\n\t\ttry {\n\t\t\tstd::string t = this->getCustomTag(im);\n\t\t\tTIFFSetField(img_out, TIFFTAG_ARTIST, t.c_str());\n\t\t}\n\t\tcatch(...) {\n\t\t\tstd::cerr << \"[LibTiffWriter] Warning: could not write custom tag.\\n\";\n\t\t}\n\n\t\t/* Set software field. */\n\t\tstd::string software_version = std::string(\"BTRGB v\") + PROJECT_VERSION;\n\t\tTIFFSetField(img_out, TIFFTAG_SOFTWARE, software_version.c_str());\n\n\t\t/* Set make and model if available. */\n\t\tbtrgb::exif tags = im->getExifTags();\n\t\tif(tags.make != btrgb::UNSPECIFIED)\n\t\t\tTIFFSetField(img_out, TIFFTAG_MAKE, tags.make.c_str());\n\t\tif(tags.model != btrgb::UNSPECIFIED)\n\t\t\tTIFFSetField(img_out, TIFFTAG_MODEL, tags.model.c_str());\n\n\t\t/* The written data needs to be broken up into \"Strips\" to make buffering easier \n\t\t* for TIFF readers. Rows-per-strip needs to be tagged, this is the number of \n\t\t* physical pixel rows of the image written in each strip. A \"row\" here is a bitmap\n\t\t* row where the length is <image width> X <number of channels>. A strip size of 8kB is \n\t\t* recommended (I wonder if this is for computing standars/capabilities wayback \n\t\t* when). Anyway, since the data type of the return value and estimate rows-per-strip \n\t\t* values are uint32: TIFFDefaultStripSize will not give strips that contain a fraction \n\t\t* of a row, and our image rows are more than 8kB, so the closest to the recommended we \n\t\t* can do is one row per strip. */\n\t\t/*\n\t\tint rows_per_strip = TIFFDefaultStripSize(img_out, 1);\n\t\tTIFFSetField(img_out, TIFFTAG_ROWSPERSTRIP, rows_per_strip);\n\t\t*/\n\t\tTIFFSetField(img_out, TIFFTAG_ROWSPERSTRIP, 1);\n\n\n\n        /* =================[ Write bitmap to file ]================== */\n\n\t\t/* The buffer for each strip to be copied to and then written to disk. \n\t\t* If rows-per-strip is one, scanline size should equate to the number\n\t\t* of bytes for one physical pixel row of the image, and the number of\n\t\t* strips should equal the height of the image. */\n\t\t/*\n\t\ttmsize_t scanline_size = TIFFScanlineSize(img_out);\n\t\tunsigned short* sample_row = (unsigned short *) _TIFFmalloc(scanline_size);\n\t\tif (sample_row)\n\t\t\t_TIFFfree(sample_row);\n\t\t*/\n\n\t\tuint32_t row, row_size = width * channels;\n        void* row_memory_address;\n\n\t\t/* Write all rows to file.\n         * ASSUMPTION: The \"rows per strip\" tiff tag is set to one. */\n\t\tfor( row = 0; row < height; row++) {\n\t\t\t\n\t\t\trow_memory_address = bitmap + row * row_size;\n\n            /* Write row to file. */\n\t\t\tif (TIFFWriteScanline(img_out, row_memory_address, row, 0) < 0) {\n                TIFFClose(img_out);\n\t\t\t\tthrow LibTiff_WriteStripFailed();\n            }\n\n\t\t}\n\n\n\n\t\t/* ==============[ Close tiff file ]================== */\n\t\tTIFFClose(img_out);\n    }",
    "void writeTiff(QImageIO* iio)\n{\n  QImage image;\n  TIFF* tiffile;\n  QRgb rgb;\n  char *data;\n  int y;\n  int channels;\n  int quality;\n  int compression;\n  int width;\n  int bytes;\n  int depth;\n  bool color;\n  bool has_alpha;\n  Q_UINT16  extra_samples[1];\n  QString params;\n  float x_res,y_res;\n  //PACKBITS is supported for all formats and lossless; use it as default, if the user\n  //didn't request a specific format.\n  compression = COMPRESSION_PACKBITS;\n  if(iio->parameters())\n  {\n    params = iio->parameters();\n    if(params.contains(\"COMPRESSION_NONE\"))\n      compression = COMPRESSION_NONE;\n    else if(params.contains(\"COMPRESSION_CCITTRLE\")) //Huffman\n      compression = COMPRESSION_CCITTRLE;\n    else if(params.contains(\"COMPRESSION_CCITTFAX3\")) //group3 fax\n      compression = COMPRESSION_CCITTFAX3;\n    else if(params.contains(\"COMPRESSION_CCITTFAX4\")) //group4 fax\n      compression = COMPRESSION_CCITTFAX4;\n    else if(params.contains(\"COMPRESSION_PACKBITS\"))  //packed bits\n      compression = COMPRESSION_PACKBITS;\n    else\n    {\n      bool ok;\n      int i = params.toInt(&ok);\n      if(ok)\n      {\n        if(i>=0 && i<=100)\n        {\n          compression = COMPRESSION_JPEG;\n          quality = i;\n        }\n      }\n    }\n  }\n  image = iio->image();\n  width = image.width();\n  depth = image.depth();\n  has_alpha = image.hasAlphaBuffer();\n  if(depth == 32) depth = 8;\n  if(depth == 8)\n  {\n    if((compression ==  COMPRESSION_CCITTRLE) ||\n       (compression ==  COMPRESSION_CCITTFAX3) ||\n       (compression ==  COMPRESSION_CCITTFAX4))\n    {\n      iio->setStatus(1);//compression type unsupported for this format\n      return;\n    }\n  }\n  else if(depth == 1)\n  {\n    if(compression ==  COMPRESSION_JPEG)\n    {\n      iio->setStatus(1);//compression type unsupported for this format\n      return;\n    }\n  }\n\n  if(image.depth()>1 && !image.allGray())\n  {\n    channels = 3;\n    if(has_alpha)\n      channels += 1;\n    color = true;\n  }\n  else\n  {\n    channels = 1;\n    color = false;\n  }\n\n  //For non-lineart images, bytes per channel is always one\n  bytes = 1;\n\n  if((image.depth() == 1) && (image.numColors() == 2))\n  {\n\t  if(qGray(image.color(0)) > qGray(image.color(1)))\n    {\n\t    // 0=dark/black, 1=light/white - invert\n\t    image.detach();\n\t    for(int y=0; y<image.height(); y++ )\n      {\n\t\t    uchar *p = image.scanLine(y);\n\t\t    uchar *end = p + image.bytesPerLine();\n\t\t    while ( p < end )\n\t\t      *p++ ^= 0xff;\n\t    }\n\t  }\n  }\n\n  tiffile = TIFFOpen(QFile::encodeName(iio->fileName()), \"w\");\nqDebug(\"TIFF: try to open %s\",iio->fileName().latin1());\n  if(!tiffile)\n  {\n    iio->setStatus(1);\n    return ;\n  }\n\n  TIFFSetField(tiffile, TIFFTAG_IMAGEWIDTH, image.width());\n  TIFFSetField(tiffile, TIFFTAG_IMAGELENGTH, image.height());\n  TIFFSetField(tiffile, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n  TIFFSetField(tiffile, TIFFTAG_BITSPERSAMPLE, channels);\n  TIFFSetField(tiffile, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n  TIFFSetField(tiffile, TIFFTAG_COMPRESSION, compression);\n  TIFFSetField(tiffile, TIFFTAG_SOFTWARE, \"QuiteInsane\");\n\n  if((image.dotsPerMeterX() > 0) && (image.dotsPerMeterY() > 0))\n  {\n    TIFFSetField(tiffile, TIFFTAG_RESOLUTIONUNIT, RESUNIT_INCH);\n    x_res = float(image.dotsPerMeterX())/(100.0/2.54);\n    y_res = float(image.dotsPerMeterY())/(100.0/2.54);\n    TIFFSetField(tiffile, TIFFTAG_XRESOLUTION,x_res);\n    TIFFSetField(tiffile, TIFFTAG_YRESOLUTION,y_res);\n  }\n\n  if(compression == COMPRESSION_JPEG)\n  {\n    TIFFSetField(tiffile, TIFFTAG_JPEGQUALITY, quality);\n    TIFFSetField(tiffile, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RAW);\n  }\n\n  if(color)\n  {\n    TIFFSetField(tiffile, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n    TIFFSetField(tiffile, TIFFTAG_BITSPERSAMPLE,8);\n    if(has_alpha)\n      TIFFSetField(tiffile, TIFFTAG_SAMPLESPERPIXEL,4);\n    else\n      TIFFSetField(tiffile, TIFFTAG_SAMPLESPERPIXEL,3);\n  }\n  else\n  {\n    if(depth == 1) //lineart\n    {\n      TIFFSetField(tiffile, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISWHITE);\n      TIFFSetField(tiffile, TIFFTAG_BITSPERSAMPLE,1);\n      TIFFSetField(tiffile, TIFFTAG_SAMPLESPERPIXEL,1);\n    }\n    else // grayscale\n    {\n      TIFFSetField(tiffile, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n      TIFFSetField(tiffile, TIFFTAG_BITSPERSAMPLE,8);\n      TIFFSetField(tiffile, TIFFTAG_SAMPLESPERPIXEL,1);\n    }\n  }\n\n  if(has_alpha)\n  {\n    extra_samples [0] = EXTRASAMPLE_ASSOCALPHA;\n    TIFFSetField (tiffile, TIFFTAG_EXTRASAMPLES, 1, extra_samples);\n  }\n  TIFFSetField(tiffile,TIFFTAG_ROWSPERSTRIP,TIFFDefaultStripSize(tiffile,0));\n\n  if(image.depth() > 1)\n    data = new char[image.width() * channels * bytes];\n  else\n    data = new char[(image.width()+7)/8];\n\n  if(data)\n  {\n    for(y = 0; y < image.height(); y++)\n    {\n      if(image.depth() > 1)\n      {\n        for(int i=0;i<image.width();i++)\n        {\n          rgb = image.pixel(i,y);\n          if(channels == 3)\n          {\n            data[i*3] = qRed(rgb);\n            data[i*3+1] = qGreen(rgb);\n            data[i*3+2] = qBlue(rgb);\n          }\n          else if(channels == 4)//alpha\n          {\n            int alpha = qAlpha(rgb);\n            data[i*4] = Q_UINT8(qRed(rgb)*alpha/255);\n            data[i*4+1] = Q_UINT8(qGreen(rgb)*alpha/255);\n            data[i*4+2] = Q_UINT8(qBlue(rgb)*alpha/255);\n            data[i*4+3] = Q_UINT8(alpha);\n          }\n          else\n          {\n            data[i] = qGray(rgb);\n          }\n        }\n        if(TIFFWriteScanline(tiffile,data, y, 0) == -1) //error\n        {\n          TIFFClose(tiffile);\n          delete [] data;\n          iio->setStatus(1);\n          return;\n        }\n      }\n      else\n      {\n        if(TIFFWriteScanline(tiffile,(char*)image.scanLine(y), y, 0) == -1) //error\n        {\n          TIFFClose(tiffile);\n          delete [] data;\n          iio->setStatus(1);\n          return;\n        }\n      }\n    }\n    iio->setStatus(0);\n    delete [] data;\n  }\n  else\n  {\n    //could not allocate data\n    iio->setStatus(1);\n  }\n  TIFFClose(tiffile);\n}",
    "void imageIO::writeImage(const float * steady_state, uint max_visits, pixel center) {\n  //const uint Z_AREA = 1;\n  const double block_size = (2 * AREA + 1) * (2 * AREA + 1);// * (Z_AREA * Z_AREA + 1);\n\n  uint i, j;\n  float block_mean = 0.0;\n  float min_val    = 1.0 / max_visits;\n\n  // Do thresholding\n  if (OPT_THRESHOLD){\n\n    // find the block of pixels aroung the center that we will use for thresholding\n    for (i = (center.x - AREA); i <= (center.x + AREA); ++i) {\n      for (j = (center.y - AREA); j <= (center.y + AREA); ++j) {\n\t//for (k = (center.z - Z_AREA); k <= (center.z + Z_AREA); ++k) {\n\t  pixel cur = {i, j, center.z};\n\t  block_mean += steady_state[OFFSET(img, cur)];\n\t  //}\n      }      \n    }\n    \n    block_mean /= block_size;\n\n    if (fout.is_open()){\n      fout << \"Cell body size        : \" << block_size << endl \n\t   << \"Mean cell body value  : \" << block_mean << endl\n\t   << \"Min threshold         : \" << min_val << endl << endl;\n    }\n      \n    if (OPT_DEBUG > 0){\n      cout << \"Cell body size      : \" << block_size << endl \n\t   << \"Mean cell body value: \" << block_mean << endl\n\t   << \"Min threshold       : \" << min_val << endl;\n    }\n\n    block_mean -= min_val;\n  }else{\n    block_mean = 1.0;\n    min_val    = 0.0;\n  }\n\n  /*\n   * ************** WRITE MULTI-PLANAR TIFF FILE **************\n   */ \n  string outfile = OPT_IMAGEOUT + \"stack.tif\";\n  TIFF * image;\n  uint rowsperstrip, page;\n  double norm;\n  char page_number[20], z_depth[40];\n\n  uchar * row = (uchar *) malloc(img.width * sizeof(uchar));\n  \n  // Open the TIFF file\n  if((image = TIFFOpen(outfile.c_str(), \"w\")) == NULL){\n    cerr << \"Could not open \" << outfile << \" for writing\\n\";\n  }\n  \n  // Loop through each plane of the image\n  for (page = 0; page < img.depth; ++page){\n      TIFFSetField(image, TIFFTAG_IMAGEWIDTH, img.width);\n      TIFFSetField(image, TIFFTAG_IMAGELENGTH, img.height);\n      TIFFSetField(image, TIFFTAG_IMAGEDEPTH, img.depth);      \n      TIFFSetField(image, TIFFTAG_BITSPERSAMPLE, 8);\n      TIFFSetField(image, TIFFTAG_SAMPLESPERPIXEL, 1);\n      \n      rowsperstrip = TIFFDefaultStripSize(image, -1);\n      \n      TIFFSetField(image, TIFFTAG_ROWSPERSTRIP, rowsperstrip);\n      TIFFSetField(image, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n      TIFFSetField(image, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n      \n      TIFFSetField(image, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);\n      TIFFSetField(image, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\n      // set the resolution, we multiply by 10,000 to convert from\n      // microns (10^-6) to centimerters (10^-2)\n      TIFFSetField(image, TIFFTAG_RESOLUTIONUNIT, RESUNIT_CENTIMETER);\n      sprintf(z_depth, \"z_resolution: %f\", (img.z_dist * 10000));\n      TIFFSetField(image, TIFFTAG_XRESOLUTION, (img.xy_dist * 10000));\n      TIFFSetField(image, TIFFTAG_YRESOLUTION, (img.xy_dist * 10000));\n      // not sure where else to put the z_resolution data????\n      TIFFSetField(image, TIFFTAG_ARTIST, z_depth);\n\n      sprintf(page_number, \"Page %d\", page + 1);\n      TIFFSetField(image, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE);\n      TIFFSetField(image, TIFFTAG_PAGENUMBER, page + 1, page + 1);\n      TIFFSetField(image, TIFFTAG_PAGENAME, page_number);\n   \n\n      for (i = 0; i < img.height; ++i){\n\t\n\t// compute pixel values\n\tfor (j = 0; j < img.width; ++j) {\n\t  norm = (fabs(steady_state[(page * img.height * img.width) + \n\t\t\t\t    (img.width * i) + j] - min_val) / block_mean);\n\t  row[j] = (uchar)(min(1.0, norm) * 255);\n\t}\n\t\n\t// write a single row of the image\n\tif (TIFFWriteScanline(image, row, i, 0) == -1){ \n\t  printf(\"Error!!\\n\");\n\t}\n      }\n\n      // write one plane of the image\n      if (img.depth > 1){\n\tTIFFWriteDirectory(image);\n      }\n  }\n  \n  free(row);\n  TIFFClose(image);\n}",
    "int TMOImage::WriteData(TIFF *pFile, bool HDR)\n{\n\tConvert(TMO_RGB, false);\n\n\tint x, y, offset;\n\tdouble pixel[3];\n\n\tfloat *scanline = NULL;\t\t\t // 32b HDR\n\tunsigned char *scanlineb = NULL; // 8b LDR\n\n\tif (HDR)\n\t{ // write 32b floats\n\t\tscanline = new float[3 * iWidth];\n\t\tfor (y = 0; y < iHeight; y++)\n\t\t{\n\t\t\tif (y % 10 == 0)\n\t\t\t\tif (ProgressBar(y, iHeight) == 1)\n\t\t\t\t\tthrow TMO_EPROGRESS_BAR;\n\t\t\toffset = y * iWidth;\n\t\t\tfor (x = iWidth; x--;)\n\t\t\t{\n\t\t\t\tif (iFormat < 256)\n\t\t\t\t{\n\t\t\t\t\tpixel[0] = GetOffset(offset + x)[0];\n\t\t\t\t\tpixel[1] = GetOffset(offset + x)[1];\n\t\t\t\t\tpixel[2] = GetOffset(offset + x)[2];\n\t\t\t\t\tscanline[3 * x] = pixel[0];\n\t\t\t\t\tscanline[3 * x + 1] = pixel[1];\n\t\t\t\t\tscanline[3 * x + 2] = pixel[2];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpixel[0] = GetOffset(offset + x)[0];\n\t\t\t\t\tif (pixel[0] < 0.0)\n\t\t\t\t\t\tpixel[0] = 0.0;\n\t\t\t\t\tif (pixel[0] > 1.0)\n\t\t\t\t\t\tpixel[0] = 1.0;\n\t\t\t\t\tscanline[3 * x] =\n\t\t\t\t\t\tscanline[3 * x + 1] =\n\t\t\t\t\t\t\tscanline[3 * x + 2] = (unsigned char)(255 * pixel[0]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (TIFFWriteScanline(pFile, scanline, y, 0) < 0)\n\t\t\t\tthrow TMO_EFILE;\n\t\t}\n\t}\n\telse\n\t{\n\t\tscanlineb = new unsigned char[3 * iWidth];\n\t\tfor (y = 0; y < iHeight; y++)\n\t\t{\n\t\t\tif (y % 10 == 0)\n\t\t\t\tif (ProgressBar(y, iHeight) == 1)\n\t\t\t\t\tthrow TMO_EPROGRESS_BAR;\n\t\t\toffset = y * iWidth;\n\t\t\tfor (x = iWidth; x--;)\n\t\t\t{\n\t\t\t\tif (iFormat < 256)\n\t\t\t\t{\n\t\t\t\t\tpixel[0] = GetOffset(offset + x)[0];\n\t\t\t\t\tpixel[1] = GetOffset(offset + x)[1];\n\t\t\t\t\tpixel[2] = GetOffset(offset + x)[2];\n\t\t\t\t\tif (pixel[0] < 0.0)\n\t\t\t\t\t\tpixel[0] = 0.0;\n\t\t\t\t\tif (pixel[1] < 0.0)\n\t\t\t\t\t\tpixel[1] = 0.0;\n\t\t\t\t\tif (pixel[2] < 0.0)\n\t\t\t\t\t\tpixel[2] = 0.0;\n\t\t\t\t\tif (pixel[0] > 1.0)\n\t\t\t\t\t\tpixel[0] = 1.0;\n\t\t\t\t\tif (pixel[1] > 1.0)\n\t\t\t\t\t\tpixel[1] = 1.0;\n\t\t\t\t\tif (pixel[2] > 1.0)\n\t\t\t\t\t\tpixel[2] = 1.0;\n\t\t\t\t\tscanlineb[3 * x] = (unsigned char)(255 * pixel[0]);\n\t\t\t\t\tscanlineb[3 * x + 1] = (unsigned char)(255 * pixel[1]);\n\t\t\t\t\tscanlineb[3 * x + 2] = (unsigned char)(255 * pixel[2]);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpixel[0] = GetOffset(offset + x)[0];\n\t\t\t\t\tif (pixel[0] < 0.0)\n\t\t\t\t\t\tpixel[0] = 0.0;\n\t\t\t\t\tif (pixel[0] > 1.0)\n\t\t\t\t\t\tpixel[0] = 1.0;\n\t\t\t\t\tscanlineb[3 * x] =\n\t\t\t\t\t\tscanlineb[3 * x + 1] =\n\t\t\t\t\t\t\tscanlineb[3 * x + 2] = (unsigned char)(255 * pixel[0]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (TIFFWriteScanline(pFile, scanlineb, y, 0) < 0)\n\t\t\t\tthrow TMO_EFILE_WRITE;\n\t\t}\n\t}\n\tif (y % 10 == 0)\n\t\tif (ProgressBar(y, iHeight) == 1)\n\t\t\tthrow TMO_EPROGRESS_BAR;\n\tif (pFile)\n\t\tTIFFClose(pFile);\n\tpFile = 0;\n\tif (scanline)\n\t\tdelete[] scanline;\n\tif (scanlineb)\n\t\tdelete[] scanlineb;\n\treturn 0;\n}",
    "int Screenshot(const char *fname, bool convert)\n{\n#ifdef GLVIS_DEBUG\n   cout << \"Screenshot: glFinish() ... \" << flush;\n#endif\n   glFinish();\n#ifdef GLVIS_DEBUG\n   cout << \"done.\" << endl;\n#endif\n#ifndef __EMSCRIPTEN__\n   if (wnd->isExposePending())\n   {\n      MFEM_WARNING(\"Expose pending, some events may not have been handled.\" << endl);\n   }\n   string filename = fname;\n   string convert_name = fname;\n   bool call_convert = false;\n   if (convert)\n   {\n      // check the extension of 'fname' to see if convert is needed\n      size_t ext_size = strlen(glvis_screenshot_ext);\n      if (filename.size() < ext_size ||\n          filename.compare(filename.size() - ext_size,\n                           ext_size, glvis_screenshot_ext) != 0)\n      {\n         call_convert = true;\n         filename += glvis_screenshot_ext;\n      }\n   }\n   else // do not call convert\n   {\n      filename += glvis_screenshot_ext;\n   }\n\n   int w, h;\n   wnd->getGLDrawSize(w, h);\n   if (wnd->isSwapPending())\n   {\n#ifdef GLVIS_DEBUG\n      cerr << \"Screenshot: reading image data from back buffer...\" << endl;\n#endif\n      glReadBuffer(GL_BACK);\n   }\n   else\n   {\n#ifdef GLVIS_DEBUG\n      cerr << \"Screenshot: reading image data from front buffer...\" << endl;\n#endif\n      MFEM_WARNING(\"Screenshot: Reading from the front buffer is unreliable. \"\n                   << \" Resulting screenshots may be incorrect.\" << endl);\n      glReadBuffer(GL_FRONT);\n   }\n#if defined(GLVIS_USE_LIBTIFF)\n   // Save a TIFF image. This requires the libtiff library, see www.libtiff.org\n   TIFF* image;\n\n   // MyExpose(w,h);\n\n   unsigned char *pixels = new unsigned char[3*w];\n   if (!pixels)\n   {\n      return 1;\n   }\n\n   image = TIFFOpen(filename.c_str(), \"w\");\n   if (!image)\n   {\n      delete [] pixels;\n      return 2;\n   }\n\n   TIFFSetField(image, TIFFTAG_IMAGEWIDTH, w);\n   TIFFSetField(image, TIFFTAG_IMAGELENGTH, h);\n   TIFFSetField(image, TIFFTAG_BITSPERSAMPLE, 8);\n   TIFFSetField(image, TIFFTAG_COMPRESSION, COMPRESSION_PACKBITS);\n   TIFFSetField(image, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n   TIFFSetField(image, TIFFTAG_SAMPLESPERPIXEL, 3);\n   TIFFSetField(image, TIFFTAG_ROWSPERSTRIP, 1);\n   TIFFSetField(image, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);\n   TIFFSetField(image, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n   for (int i = 0; i < h; i++)\n   {\n      glReadPixels(0, h-i-1, w, 1, GL_RGB, GL_UNSIGNED_BYTE, pixels);\n      if (TIFFWriteScanline(image, pixels, i, 0) < 0)\n      {\n         TIFFClose(image);\n         delete [] pixels;\n         return 3;\n      }\n   }\n\n   TIFFFlushData(image);\n   TIFFClose(image);\n   delete [] pixels;\n\n#elif defined(GLVIS_USE_LIBPNG)\n   // Save as png image. Requires libpng.\n   int status = SaveAsPNG(filename.c_str(), w, h, wnd->isHighDpi());\n   if (status != 0) { return status; }\n\n#else\n   // use SDL for screenshots\n\n   // https://stackoverflow.com/questions/20233469/how-do-i-take-and-save-a-bmp-screenshot-in-sdl-2\n   unsigned char * pixels = new unsigned char[w*h*4]; // 4 bytes for RGBA\n   glReadPixels(0, 0, w, h, GL_RGBA, GL_UNSIGNED_BYTE, pixels);\n\n   SDL_Surface * surf = SDL_CreateRGBSurfaceFrom(pixels, w, h, 8*4, w*4, rmask,\n                                                 gmask, bmask, amask);\n   if (surf == nullptr)\n   {\n      std::cerr << \"unable to take screenshot: \" << SDL_GetError() << std::endl;\n   }\n   else\n   {\n      if (InvertSurfaceVertical(surf))\n      {\n         std::cerr << \"failed to invert surface, your screenshot may be upside down\" <<\n                   std::endl;\n      }\n      SDL_SaveBMP(surf, filename.c_str());\n      SDL_FreeSurface(surf);\n      // automatically convert to png if not being used\n      if (!call_convert)\n      {\n         call_convert = true;\n         convert_name += \".png\";\n      }\n   }\n   delete [] pixels;\n#endif\n\n   if (call_convert)\n   {\n      ostringstream cmd;\n      cmd << \"convert \" << filename << ' ' << convert_name;\n      if (system(cmd.str().c_str()))\n      {\n         return 1;\n      }\n      remove(filename.c_str());\n   }\n   return 0;\n#else\n   cout << \"Screenshots not yet implemented for JS\" << endl;\n   return 1;\n#endif\n}",
    "bool ImMatToFile(const ImMat& mat, std::string path)\n{\n    int ret = -1;\n    if (mat.empty())\n    {\n        return false;\n    }\n    auto file_suffix = ImGuiHelper::path_filename_suffix(path);\n    if (!file_suffix.empty())\n    {\n        if (file_suffix.compare(\".png\") == 0 || file_suffix.compare(\".PNG\") == 0)\n            stbi_write_png(path.c_str(), mat.w, mat.h, mat.c, mat.data, mat.w * mat.c);\n        else if (file_suffix.compare(\".jpg\") == 0 || file_suffix.compare(\".JPG\") == 0 ||\n                file_suffix.compare(\".jpeg\") == 0 || file_suffix.compare(\".JPEG\") == 0)\n            stbi_write_jpg(path.c_str(), mat.w, mat.h, mat.c, mat.data, mat.w * mat.c);\n        else if (file_suffix.compare(\".bmp\") == 0 || file_suffix.compare(\".BMP\") == 0)\n            stbi_write_bmp(path.c_str(), mat.w, mat.h, mat.c, mat.data);\n        else if (file_suffix.compare(\".tga\") == 0 || file_suffix.compare(\".TGA\") == 0)\n            stbi_write_tga(path.c_str(), mat.w, mat.h, mat.c, mat.data);\n#if IMGUI_TIFF\n        else if (file_suffix.compare(\".tiff\") == 0 || file_suffix.compare(\".TIFF\") == 0)\n        {\n            // TODO::Dicky\n            TIFF* tif = TIFFOpen(path.c_str(), \"w\");\n            if (tif)\n            {\n                const char* copyright_str = \"CodeWin\"; \n                const char* app_str = \"CodeWin\"; \n                TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, mat.w);\n                TIFFSetField(tif, TIFFTAG_IMAGELENGTH, mat.h);\n                TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, mat.c);\n                TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, mat.h);\n                TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, mat.depth);\n                if (mat.c == 1)\n                    TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n                else\n                    TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n                //TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);\n                TIFFSetField(tif, TIFFTAG_RESOLUTIONUNIT, RESUNIT_INCH);\n                TIFFSetField(tif, TIFFTAG_XRESOLUTION, 72.0);\n                TIFFSetField(tif, TIFFTAG_YRESOLUTION, 72.0);\n                TIFFSetField(tif, TIFFTAG_COPYRIGHT, copyright_str);\n                TIFFSetField(tif, TIFFTAG_SOFTWARE, app_str);\n                TIFFSetField(tif, TIFFTAG_PLANARCONFIG, mat.elempack > 1 ? PLANARCONFIG_CONTIG : PLANARCONFIG_SEPARATE);\n                if (mat.type == IM_DT_FLOAT32)\n                    TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);\n                else if (mat.type == IM_DT_INT16 || mat.type == IM_DT_INT32)\n                    TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT);\n                if (mat.elempack > 1)\n                {\n                    for (int row = 0; row < mat.h; row++)\n                    {\n                        void* mat_row = (unsigned char*)mat.data + (size_t)mat.w * row * mat.elemsize * mat.elempack;\n                        TIFFWriteScanline(tif, mat_row, row, 0);\n                    } \n                }\n                else\n                {\n                    for (int c = 0; c < mat.c; c++)\n                    {\n                        auto channel = mat.channel(c);\n                        for (int row = 0; row < channel.h; row++)\n                        {\n                            void* channel_row = (unsigned char*)channel.data + (size_t)channel.w * row * channel.elemsize;\n                            TIFFWriteScanline(tif, channel_row, row, c);\n                        }\n                    }\n                }\n\n                TIFFClose(tif);\n            }\n        }\n#endif\n    }\n    else\n    {\n        path += \".png\";\n        stbi_write_png(path.c_str(), mat.w, mat.h, mat.c, mat.data, mat.w * mat.c);\n    }\n    return true;\n}",
    "MAGICS_NO_EXPORT void CairoDriver::write_tiff() const {\n    int compression = 1;\n\n    unsigned char* data = cairo_image_surface_get_data(surface_);\n    int width           = cairo_image_surface_get_width(surface_);\n    int height          = cairo_image_surface_get_height(surface_);\n    const int stride    = cairo_image_surface_get_stride(surface_);\n\n    TIFF* tif = TIFFOpen(fileName_.c_str(), \"w\");\n    if (!tif) {\n        if (MagicsGlobal::strict()) {\n            throw CannotOpenFile(fileName_);\n        }\n        MagLog::warning() << \"CairoDriver: Unable to open TIFF file \" << fileName_ << std::endl;\n        return;\n    }\n\n    GTIF* gtif = GTIFNew(tif);\n    if (!gtif) {\n        if (MagicsGlobal::strict()) {\n            throw CannotOpenFile(fileName_);\n        }\n        MagLog::warning() << \"CairoDriver: Unable to open GeoTIFF file \" << fileName_ << std::endl;\n        return;\n    }\n\n    TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, width);\n    TIFFSetField(tif, TIFFTAG_IMAGELENGTH, height);\n    TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 4);\n    TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8);\n    TIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n    TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n    TIFFSetField(tif, TIFFTAG_SOFTWARE, \"Magics\");\n\n    GTIFKeySet(gtif, GTModelTypeGeoKey, TYPE_SHORT, 1, ModelGeographic);\n    GTIFKeySet(gtif, GTRasterTypeGeoKey, TYPE_SHORT, 1, RasterPixelIsArea);\n    GTIFKeySet(gtif, GTCitationGeoKey, TYPE_ASCII, 0, \"MagicsPlot\");\n    GTIFKeySet(gtif, GeographicTypeGeoKey, TYPE_SHORT, 1, KvUserDefined);\n    GTIFKeySet(gtif, GeogCitationGeoKey, TYPE_ASCII, 0, \"Everest Ellipsoid Used.\");\n    GTIFKeySet(gtif, GeogAngularUnitsGeoKey, TYPE_SHORT, 1, Angular_Degree);\n    GTIFKeySet(gtif, GeogLinearUnitsGeoKey, TYPE_SHORT, 1, Linear_Meter);\n    GTIFKeySet(gtif, GeogGeodeticDatumGeoKey, TYPE_SHORT, 1, KvUserDefined);\n    GTIFKeySet(gtif, GeogEllipsoidGeoKey, TYPE_SHORT, 1, Ellipse_WGS_84);\n    GTIFKeySet(gtif, GeogSemiMajorAxisGeoKey, TYPE_DOUBLE, 1, (double)6377298.556);\n    GTIFKeySet(gtif, GeogInvFlatteningGeoKey, TYPE_DOUBLE, 1, (double)300.8017);\n\n    if (compression > 1) {\n        if (compression > 10)\n            compression = 10;\n        TIFFSetField(tif, TIFFTAG_COMPRESSION, compression);\n    }\n\n    // DPI\n    TIFFSetField(tif, TIFFTAG_RESOLUTIONUNIT, RESUNIT_INCH);\n    TIFFSetField(tif, TIFFTAG_XRESOLUTION, (float)90.);\n    TIFFSetField(tif, TIFFTAG_YRESOLUTION, (float)90.);\n\n    unsigned char* buf;\n    if (TIFFScanlineSize(tif))\n        buf = (unsigned char*)_TIFFmalloc(4 * width);\n    else\n        buf = (unsigned char*)_TIFFmalloc(TIFFScanlineSize(tif));\n\n    unsigned char* pscanline;\n    for (unsigned int i = 0; i < height; i++) {\n        pscanline = buf;\n        for (unsigned int j = 0; j < stride; j++) {\n            *pscanline++ = data[i * stride + j++];\n            *pscanline++ = data[i * stride + j++];\n            *pscanline++ = data[i * stride + j++];\n            *pscanline++ = data[i * stride + j];\n        }\n        TIFFWriteScanline(tif, buf, i, 0);\n    }\n    TIFFClose(tif);\n    _TIFFfree(buf);\n    return;\n}",
    "int DiTIFFPlugin::write(\n  DiImage *image,\n  FILE *stream,\n  const unsigned long frame) const\n{\n  int result = 0;\n  if ((image != NULL) && (stream != NULL))\n  {\n    int stream_fd = fileno(stream);\n\n\n#ifdef HAVE_WINDOWS_H\n\n#if TIFFLIB_VERSION < 20050912\n#error TIFF library versions prior to 3.7.4 are not supported by DCMTK on Win32 - critical API change!\n#endif\n\n/* Older versions of libtiff expected a Win32 HANDLE when compiled on Windows\n * instead of a file descriptor. The code below was needed to make that work.\n * Libtiff version 3.7.4 and newer are known to use a file descriptor instead,\n * but it is not completely clear at which libtiff release the API change happened.\n *\n * #ifdef __CYGWIN__\n *   stream_fd = OFstatic_cast(int, get_osfhandle(stream_fd));\n * #else\n *   stream_fd =OFstatic_cast(int, _get_osfhandle(stream_fd));\n * #endif\n */\n\n#elif TIFFLIB_VERSION < 20041016\n#error TIFF library versions prior to 3.7.0 are not supported by DCMTK - TIFFCleanup is missing!\n#endif\n\n    /* create bitmap with 8 bits per sample */\n    void *data = OFconst_cast(void *, image->getOutputData(frame, 8 /*bits*/, 0 /*planar*/));\n    if (data != NULL)\n    {\n      OFBool isMono = (image->getInternalColorModel() == EPI_Monochrome1) || (image->getInternalColorModel() == EPI_Monochrome2);\n      Uint16 rows = image->getRows();\n      Uint16 cols = image->getColumns();\n\n      short photometric = isMono ? PHOTOMETRIC_MINISBLACK : PHOTOMETRIC_RGB;\n      short samplesperpixel = isMono ? 1 : 3;\n      unsigned long bytesperrow = cols * samplesperpixel;\n      if (bytesperrow > 0)\n      {\n        short opt_predictor = 0;\n        switch (predictor)\n        {\n          case E_tiffLZWPredictorDefault:\n            opt_predictor = 0;\n            break;\n          case E_tiffLZWPredictorNoPrediction:\n            opt_predictor = 1;\n            break;\n          case E_tiffLZWPredictorHDifferencing:\n            opt_predictor = 2;\n            break;\n        }\n\n        unsigned short opt_compression = COMPRESSION_NONE;\n        switch (compressionType)\n        {\n          case E_tiffLZWCompression:\n            opt_compression = COMPRESSION_LZW;\n            break;\n          case E_tiffPackBitsCompression:\n            opt_compression = COMPRESSION_PACKBITS;\n            break;\n          case E_tiffNoCompression:\n            opt_compression = COMPRESSION_NONE;\n            break;\n        }\n\n        long opt_rowsperstrip = OFstatic_cast(long, rowsPerStrip);\n        if (opt_rowsperstrip <= 0) opt_rowsperstrip = 8192 / bytesperrow;\n        if (opt_rowsperstrip == 0) opt_rowsperstrip++;\n\n        OFBool OK = OFTrue;\n        unsigned char *bytedata = OFstatic_cast(unsigned char *, data);\n        TIFF *tif = TIFFFdOpen(stream_fd, \"TIFF\", \"w\");\n        if (tif)\n        {\n          /* Set TIFF parameters. */\n          TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, cols);\n          TIFFSetField(tif, TIFFTAG_IMAGELENGTH, rows);\n          TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8);\n          TIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n          TIFFSetField(tif, TIFFTAG_COMPRESSION, opt_compression);\n          if (opt_compression == COMPRESSION_LZW && opt_predictor != 0)\n          TIFFSetField(tif, TIFFTAG_PREDICTOR, opt_predictor);\n          TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, photometric);\n          TIFFSetField(tif, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);\n          TIFFSetField(tif, TIFFTAG_DOCUMENTNAME, \"unnamed\");\n          TIFFSetField(tif, TIFFTAG_IMAGEDESCRIPTION, \"Converted DICOM Image\");\n          TIFFSetField(tif, TIFFTAG_SOFTWARE, \"OFFIS DCMTK \" OFFIS_DCMTK_VERSION);\n          TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, samplesperpixel);\n          TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, opt_rowsperstrip);\n          /* TIFFSetField(tif, TIFFTAG_STRIPBYTECOUNTS, rows / opt_rowsperstrip); */\n          TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\n          /* Now write the TIFF data. */\n          unsigned long offset = 0;\n          for (Uint16 i=0; (i < rows) && OK; i++)\n          {\n            if (TIFFWriteScanline(tif, bytedata + offset, i, 0) < 0) OK = OFFalse;\n            offset += bytesperrow;\n          }\n          TIFFFlushData(tif);\n          /* Clean up internal structures and free memory.\n           * However, the file will be closed by the caller, therefore\n           * TIFFClose(tif) is not called.\n           */\n          TIFFCleanup(tif);\n        }\n        if (OK) result = 1;\n      }\n    }\n\n    /* delete pixel data */\n    image->deleteOutputData();\n  }\n  return result;\n}",
    "int R2Image::\nWriteTIFFFile(const char *filename) const\n{\n#ifdef RN_USE_TIFF\n  // Open TIFF file\n  TIFF *out = TIFFOpen(filename, \"w\");\n  if (!out) {\n    RNFail(\"Unable to open TIFF file %s\\n\", filename);\n    return 0;\n  }\n\n  // Set TIFF parameters\n  TIFFSetField(out, TIFFTAG_IMAGEWIDTH, width);\n  TIFFSetField(out, TIFFTAG_IMAGELENGTH, height);\n  TIFFSetField(out, TIFFTAG_ORIENTATION, ORIENTATION_BOTLEFT);\n  TIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, 3);\n  TIFFSetField(out, TIFFTAG_BITSPERSAMPLE, 8);\n  TIFFSetField(out, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n  TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n  TIFFSetField(out, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n  TIFFSetField(out, TIFFTAG_ROWSPERSTRIP, 1);\n\n  // Allocate data for scan lines\n  int scanline_size = TIFFScanlineSize(out);\n  unsigned char *buf = (unsigned char *)_TIFFmalloc(scanline_size);\n  if (!buf) {\n    RNFail(\"Unable to allocate memory for TIFF scan lines\\n\");\n    return 0;\n  }\n\n  // Write scan lines to TIFF file\n  for (int row = 0; row < height; row++) {\n    const unsigned char *p = Pixels(row);\n    if (TIFFWriteScanline(out, (tdata_t) p, height - row - 1, 0) < 0) {\n      RNFail(\"Unable to write scanline to TIFF image %s\\n\", filename);\n      return 0;\n    }\n  }\n\n  // Free data for scan lines\n  _TIFFfree(buf);\n\n  // Close TIFF file\n  TIFFClose(out);\n\n  // Return success\n  return 1;\n#else\n  RNFail(\"TIFF not supported\");\n  return 0;\n#endif\n}",
    "bool CxImageTIF::EncodeBody(TIFF *m_tif, bool multipage, int page, int pagecount)\n{\n  uint32 height=head.biHeight;\n  uint32 width=head.biWidth;\n  uint16 bitcount=head.biBitCount;\n  uint16 bitspersample;\n  uint16 samplesperpixel;\n  uint16 photometric=0;\n  uint16 compression;\n//  uint16 pitch;\n//  int line;\n  uint32 x, y;\n\n  samplesperpixel = ((bitcount == 24) || (bitcount == 32)) ? (BYTE)3 : (BYTE)1;\n#if CXIMAGE_SUPPORT_ALPHA\n  if (bitcount==24 && AlphaIsValid()) { bitcount=32; samplesperpixel=4; }\n#endif //CXIMAGE_SUPPORT_ALPHA\n\n  bitspersample = bitcount / samplesperpixel;\n\n  //set the PHOTOMETRIC tag\n  RGBQUAD *rgb = GetPalette();\n  switch (bitcount) {\n    case 1:\n      if (CompareColors(&rgb[0],&rgb[1])<0) {\n        /* <abe> some viewers do not handle PHOTOMETRIC_MINISBLACK:\n         * let's transform the image in PHOTOMETRIC_MINISWHITE\n         */\n        //invert the colors\n        RGBQUAD tempRGB=GetPaletteColor(0);\n        SetPaletteColor(0,GetPaletteColor(1));\n        SetPaletteColor(1,tempRGB);\n        //invert the pixels\n        BYTE *iSrc=info.pImage;\n        for (unsigned long i=0;i<head.biSizeImage;i++){\n          *iSrc=(BYTE)~(*(iSrc));\n          iSrc++;\n        }\n        photometric = PHOTOMETRIC_MINISWHITE;\n        //photometric = PHOTOMETRIC_MINISBLACK;\n      } else {\n        photometric = PHOTOMETRIC_MINISWHITE;\n      }\n      break;\n    case 4:  // Check if the DIB has a color or a greyscale palette\n    case 8:\n      photometric = PHOTOMETRIC_MINISBLACK; //default to gray scale\n      for (x = 0; x < head.biClrUsed; x++) {\n        if ((rgb->rgbRed != x)||(rgb->rgbRed != rgb->rgbGreen)||(rgb->rgbRed != rgb->rgbBlue)){\n          photometric = PHOTOMETRIC_PALETTE;\n          break;\n        }\n        rgb++;\n      }\n      break;\n    case 24:\n    case 32:\n      photometric = PHOTOMETRIC_RGB;      \n      break;\n  }\n\n#if CXIMAGE_SUPPORT_ALPHA\n  if (AlphaIsValid() && bitcount==8) samplesperpixel=2; //8bpp + alpha layer\n#endif //CXIMAGE_SUPPORT_ALPHA\n\n//  line = CalculateLine(width, bitspersample * samplesperpixel);\n//  pitch = (uint16)CalculatePitch(line);\n\n  //prepare the palette struct\n  RGBQUAD pal[256];\n  if (GetPalette()){\n    BYTE b;\n    memcpy(pal,GetPalette(),GetPaletteSize());\n    for(WORD a=0;a<head.biClrUsed;a++){  //swap blue and red components\n      b=pal[a].rgbBlue; pal[a].rgbBlue=pal[a].rgbRed; pal[a].rgbRed=b;\n    }\n  }\n\n  // handle standard width/height/bpp stuff\n  TIFFSetField(m_tif, TIFFTAG_IMAGEWIDTH, width);\n  TIFFSetField(m_tif, TIFFTAG_IMAGELENGTH, height);\n  TIFFSetField(m_tif, TIFFTAG_SAMPLESPERPIXEL, samplesperpixel);\n  TIFFSetField(m_tif, TIFFTAG_BITSPERSAMPLE, bitspersample);\n  TIFFSetField(m_tif, TIFFTAG_PHOTOMETRIC, photometric);\n  TIFFSetField(m_tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);  // single image plane \n  TIFFSetField(m_tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n\n  uint32 rowsperstrip = TIFFDefaultStripSize(m_tif, (uint32) -1);  //<REC> gives better compression\n  TIFFSetField(m_tif, TIFFTAG_ROWSPERSTRIP, rowsperstrip);\n\n  // handle metrics\n  TIFFSetField(m_tif, TIFFTAG_RESOLUTIONUNIT, RESUNIT_INCH);\n  TIFFSetField(m_tif, TIFFTAG_XRESOLUTION, (float)info.xDPI);\n  TIFFSetField(m_tif, TIFFTAG_YRESOLUTION, (float)info.yDPI);\n//  TIFFSetField(m_tif, TIFFTAG_XPOSITION, (float)info.xOffset);\n//  TIFFSetField(m_tif, TIFFTAG_YPOSITION, (float)info.yOffset);\n\n  // multi-paging - Thanks to Abe <God(dot)bless(at)marihuana(dot)com>\n  if (multipage)\n  {\n    char page_number[20];\n    sprintf(page_number, \"Page %d\", page);\n\n    TIFFSetField(m_tif, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE);\n    TIFFSetField(m_tif, TIFFTAG_PAGENUMBER, page,pagecount);\n    TIFFSetField(m_tif, TIFFTAG_PAGENAME, page_number);\n  } else {\n    TIFFSetField(m_tif, TIFFTAG_SUBFILETYPE, 0);\n  }\n\n  // palettes (image colormaps are automatically scaled to 16-bits)\n  if (photometric == PHOTOMETRIC_PALETTE) {\n    uint16 *r, *g, *b;\n    r = (uint16 *) _TIFFmalloc(sizeof(uint16) * 3 * 256);\n    g = r + 256;\n    b = g + 256;\n\n    for (int i = 255; i >= 0; i--) {\n      b[i] = (uint16)SCALE((uint16)pal[i].rgbRed);\n      g[i] = (uint16)SCALE((uint16)pal[i].rgbGreen);\n      r[i] = (uint16)SCALE((uint16)pal[i].rgbBlue);\n    }\n\n    TIFFSetField(m_tif, TIFFTAG_COLORMAP, r, g, b);\n    _TIFFfree(r);\n  }\n\n  // compression\n  if (GetCodecOption(CXIMAGE_FORMAT_TIF)) {\n    compression = (WORD)GetCodecOption(CXIMAGE_FORMAT_TIF);\n  } else {\n    switch (bitcount) {\n      case 1 :\n        compression = COMPRESSION_CCITTFAX4;\n        break;\n      case 4 :\n      case 8 :\n        compression = COMPRESSION_LZW;\n        break;\n      case 24 :\n      case 32 :\n        compression = COMPRESSION_JPEG;\n        break;\n      default :\n        compression = COMPRESSION_NONE;\n        break;\n    }\n  }\n  TIFFSetField(m_tif, TIFFTAG_COMPRESSION, compression);\n\n  switch (compression) {\n  case COMPRESSION_JPEG:\n    TIFFSetField(m_tif, TIFFTAG_JPEGQUALITY, GetJpegQuality());\n    TIFFSetField(m_tif, TIFFTAG_ROWSPERSTRIP, ((7+rowsperstrip)>>3)<<3);\n       break;\n  case COMPRESSION_LZW:\n    if (bitcount>=8) TIFFSetField(m_tif, TIFFTAG_PREDICTOR, 2);\n    break;\n  }\n\n  // read the DIB lines from bottom to top and save them in the TIF\n\n  BYTE *bits;\n  switch(bitcount) {        \n    case 1 :\n    case 4 :\n    case 8 :\n    {\n      if (samplesperpixel==1){\n        bits = (BYTE*)malloc(info.dwEffWidth);\n        if (!bits) return false;\n        for (y = 0; y < height; y++) {\n          memcpy(bits,info.pImage + (height - y - 1)*info.dwEffWidth,info.dwEffWidth);\n          if (TIFFWriteScanline(m_tif,bits, y, 0)==-1){\n            free(bits);\n            return false;\n          }\n        }\n        free(bits);\n      }\n#if CXIMAGE_SUPPORT_ALPHA\n      else { //8bpp + alpha layer\n        bits = (BYTE*)malloc(2*width);\n        if (!bits) return false;\n        for (y = 0; y < height; y++) {\n          for (x=0;x<width;x++){\n            bits[2*x]=BlindGetPixelIndex(x,height - y - 1);\n            bits[2*x+1]=AlphaGet(x,height - y - 1);\n          }\n          if (TIFFWriteScanline(m_tif,bits, y, 0)==-1) {\n            free(bits);\n            return false;\n          }\n        }\n        free(bits);\n      }\n#endif //CXIMAGE_SUPPORT_ALPHA\n      break;\n    }        \n    case 24:\n    {\n      BYTE *buffer = (BYTE *)malloc(info.dwEffWidth);\n      if (!buffer) return false;\n      for (y = 0; y < height; y++) {\n        // get a pointer to the scanline\n        memcpy(buffer, info.pImage + (height - y - 1)*info.dwEffWidth, info.dwEffWidth);\n        // TIFFs store color data RGB instead of BGR\n        BYTE *pBuf = buffer;\n        for (x = 0; x < width; x++) {\n          BYTE tmp = pBuf[0];\n          pBuf[0] = pBuf[2];\n          pBuf[2] = tmp;\n          pBuf += 3;\n        }\n        // write the scanline to disc\n        if (TIFFWriteScanline(m_tif, buffer, y, 0)==-1){\n          free(buffer);\n          return false;\n        }\n      }\n      free(buffer);\n      break;\n    }        \n    case 32 :\n    {\n#if CXIMAGE_SUPPORT_ALPHA\n      BYTE *buffer = (BYTE *)malloc((info.dwEffWidth*4)/3);\n      if (!buffer) return false;\n      for (y = 0; y < height; y++) {\n        // get a pointer to the scanline\n        memcpy(buffer, info.pImage + (height - y - 1)*info.dwEffWidth, info.dwEffWidth);\n        // TIFFs store color data RGB instead of BGR\n        BYTE *pSrc = buffer + 3 * width;\n        BYTE *pDst = buffer + 4 * width;\n        for (x = 0; x < width; x++) {\n          pDst-=4;\n          pSrc-=3;\n          pDst[3] = AlphaGet(width-x-1,height-y-1);\n          pDst[2] = pSrc[0];\n          pDst[1] = pSrc[1];\n          pDst[0] = pSrc[2];\n        }\n        // write the scanline to disc\n        if (TIFFWriteScanline(m_tif, buffer, y, 0)==-1){\n          free(buffer);\n          return false;\n        }\n      }\n      free(buffer);\n#endif //CXIMAGE_SUPPORT_ALPHA\n      break;\n    }        \n  }\n  return true;\n}",
    "OIIO_NAMESPACE_USING\n\nnamespace bioexplorer\n{\nnamespace mediamaker\n{\nusing namespace core;\n// Number of floats used to define the camera\nconst size_t CAMERA_DEFINITION_SIZE = 12;\n\n#define CATCH_STD_EXCEPTION()           \\\n    catch (const std::runtime_error &e) \\\n    {                                   \\\n        response.status = false;        \\\n        response.contents = e.what();   \\\n        PLUGIN_ERROR << e.what() );     \\\n    }\n\nvoid _addDepthRenderer(core::Engine &engine)\n{\n    PLUGIN_REGISTER_RENDERER(RENDERER_DEPTH);\n    core::PropertyMap properties;\n    properties.setProperty(MEDIA_MAKER_RENDERER_PROPERTY_DEPTH_INFINITY);\n    engine.addRendererType(RENDERER_DEPTH, properties);\n}\n\nvoid _addAlbedoRenderer(core::Engine &engine)\n{\n    PLUGIN_REGISTER_RENDERER(RENDERER_ALBEDO);\n    core::PropertyMap properties;\n    properties.setProperty(RENDERER_PROPERTY_MAX_RAY_DEPTH);\n    auto &params = engine.getParametersManager().getApplicationParameters();\n    const auto &engineName = params.getEngine();\n    if (engineName == ENGINE_OSPRAY)\n        properties.setProperty(COMMON_PROPERTY_USE_HARDWARE_RANDOMIZER);\n    engine.addRendererType(RENDERER_ALBEDO, properties);\n}\n\nvoid _addAmbientOcclusionRenderer(core::Engine &engine)\n{\n    PLUGIN_REGISTER_RENDERER(RENDERER_AMBIENT_OCCLUSION);\n    core::PropertyMap properties;\n    auto samples = RENDERER_PROPERTY_GLOBAL_ILLUMINATION_SAMPLES;\n    samples.set(16);\n    properties.setProperty(samples);\n    properties.setProperty(RENDERER_PROPERTY_GLOBAL_ILLUMINATION_RAY_LENGTH);\n    properties.setProperty(RENDERER_PROPERTY_MAX_RAY_DEPTH);\n    auto &params = engine.getParametersManager().getApplicationParameters();\n    const auto &engineName = params.getEngine();\n    if (engineName == ENGINE_OSPRAY)\n        properties.setProperty(COMMON_PROPERTY_USE_HARDWARE_RANDOMIZER);\n    properties.setProperty(COMMON_PROPERTY_USE_HARDWARE_RANDOMIZER);\n    engine.addRendererType(RENDERER_AMBIENT_OCCLUSION, properties);\n}\n\nvoid _addShadowRenderer(core::Engine &engine)\n{\n    PLUGIN_REGISTER_RENDERER(RENDERER_SHADOW);\n    core::PropertyMap properties;\n    properties.setProperty(RENDERER_PROPERTY_SHADOW_SAMPLES);\n    properties.setProperty(RENDERER_PROPERTY_GLOBAL_ILLUMINATION_RAY_LENGTH);\n    properties.setProperty(RENDERER_PROPERTY_SOFT_SHADOW_STRENGTH);\n    engine.addRendererType(RENDERER_SHADOW, properties);\n}\n\nvoid _addRadianceRenderer(core::Engine &engine)\n{\n    PLUGIN_REGISTER_RENDERER(RENDERER_RADIANCE);\n    core::PropertyMap properties;\n    engine.addRendererType(RENDERER_RADIANCE, properties);\n}\n\nMediaMakerPlugin::MediaMakerPlugin()\n    : ExtensionPlugin()\n{\n}\n\nvoid MediaMakerPlugin::init()\n{\n    auto actionInterface = _api->getActionInterface();\n    if (actionInterface)\n    {\n        std::string entryPoint = PLUGIN_API_PREFIX + \"version\";\n        PLUGIN_REGISTER_ENDPOINT(entryPoint);\n        actionInterface->registerRequest<Response>(entryPoint, [&]() { return _version(); });\n\n        entryPoint = PLUGIN_API_PREFIX + \"set-odu-camera\";\n        PLUGIN_REGISTER_ENDPOINT(entryPoint);\n        actionInterface->registerNotification<CameraDefinition>(entryPoint,\n                                                                [&](const CameraDefinition &s) { _setCamera(s); });\n\n        entryPoint = PLUGIN_API_PREFIX + \"get-odu-camera\";\n        PLUGIN_REGISTER_ENDPOINT(entryPoint);\n        actionInterface->registerRequest<CameraDefinition>(entryPoint,\n                                                           [&]() -> CameraDefinition { return _getCamera(); });\n\n        entryPoint = PLUGIN_API_PREFIX + \"export-frames-to-disk\";\n        PLUGIN_REGISTER_ENDPOINT(entryPoint);\n        actionInterface->registerNotification<ExportFramesToDisk>(entryPoint, [&](const ExportFramesToDisk &s)\n                                                                  { _exportFramesToDisk(s); });\n\n        entryPoint = PLUGIN_API_PREFIX + \"get-export-frames-progress\";\n        PLUGIN_REGISTER_ENDPOINT(entryPoint);\n        actionInterface->registerRequest<FrameExportProgress>(entryPoint,\n                                                              [&](void) -> FrameExportProgress\n                                                              { return _getFrameExportProgress(); });\n\n        entryPoint = PLUGIN_API_PREFIX + \"attach-odu-camera-handler\";\n        PLUGIN_REGISTER_ENDPOINT(entryPoint);\n        actionInterface->registerNotification<CameraHandlerDetails>(entryPoint, [&](const CameraHandlerDetails &s)\n                                                                    { _attachCameraHandler(s); });\n    }\n\n    auto &engine = _api->getEngine();\n    auto &params = engine.getParametersManager().getApplicationParameters();\n    const auto &engineName = params.getEngine();\n#ifdef USE_OPTIX6\n    if (engineName == ENGINE_OPTIX_6)\n    {\n        _createOptiXRenderers();\n        _createRenderers();\n    }\n#endif\n    if (engineName == ENGINE_OSPRAY)\n        _createRenderers();\n}\n\n#ifdef USE_OPTIX6\nvoid MediaMakerPlugin::_createOptiXRenderers()\n{\n    std::map<std::string, std::string> renderers = {\n        {RENDERER_ALBEDO, MediaMaker_generated_Albedo_cu_ptx},\n        {RENDERER_SHADING_NORMAL, MediaMaker_generated_ShadingNormal_cu_ptx},\n        {RENDERER_GEOMETRY_NORMAL, MediaMaker_generated_GeometryNormal_cu_ptx},\n        {RENDERER_AMBIENT_OCCLUSION, MediaMaker_generated_AmbientOcclusion_cu_ptx},\n        {RENDERER_SHADOW, MediaMaker_generated_Shadow_cu_ptx},\n        {RENDERER_DEPTH, MediaMaker_generated_Depth_cu_ptx},\n        {RENDERER_RADIANCE, MediaMaker_generated_Radiance_cu_ptx},\n    };\n    ::core::engine::optix::OptiXContext &context = ::core::engine::optix::OptiXContext::get();\n    for (const auto &renderer : renderers)\n    {\n        PLUGIN_REGISTER_RENDERER(renderer.first);\n        const std::string ptx = renderer.second;\n\n        auto osp = std::make_shared<::core::engine::optix::OptixShaderProgram>();\n        osp->closest_hit = context.getOptixContext()->createProgramFromPTXString(\n            ptx, ::core::engine::optix::OPTIX_CUDA_FUNCTION_CLOSEST_HIT_RADIANCE);\n        osp->closest_hit_textured = context.getOptixContext()->createProgramFromPTXString(\n            ptx, ::core::engine::optix::OPTIX_CUDA_FUNCTION_CLOSEST_HIT_RADIANCE_TEXTURED);\n        osp->any_hit = context.getOptixContext()->createProgramFromPTXString(\n            ptx, ::core::engine::optix::OPTIX_CUDA_FUNCTION_ANY_HIT_SHADOW);\n\n        context.addRenderer(renderer.first, osp);\n    }\n}\n#endif\n\nvoid MediaMakerPlugin::_setCamera(const CameraDefinition &payload)\n{\n    auto &camera = _api->getCamera();\n    setCamera(cameraDefinitionToKeyFrame(payload), camera);\n}\n\nCameraDefinition MediaMakerPlugin::_getCamera()\n{\n    auto &camera = _api->getCamera();\n    const auto keyFrame = getCameraKeyFrame(camera);\n    return keyFrameToCameraDefinition(keyFrame);\n}\n\nvoid MediaMakerPlugin::_createRenderers()\n{\n    auto &engine = _api->getEngine();\n    _addAlbedoRenderer(engine);\n    _addDepthRenderer(engine);\n    _addAmbientOcclusionRenderer(engine);\n    _addShadowRenderer(engine);\n    _addRadianceRenderer(engine);\n    engine.addRendererType(RENDERER_GEOMETRY_NORMAL);\n    engine.addRendererType(RENDERER_SHADING_NORMAL);\n}\n\nResponse MediaMakerPlugin::_version() const\n{\n    Response response;\n    response.contents = PACKAGE_VERSION_STRING;\n    return response;\n}\n\nvoid MediaMakerPlugin::preRender()\n{\n    if (_exportFramesToDiskDirty && _accumulationFrameNumber == 0)\n    {\n        auto &frameBuffer = _api->getEngine().getFrameBuffer();\n        frameBuffer.resize(_frameBufferSize);\n        frameBuffer.clear();\n\n        auto &camera = _api->getCamera();\n        if (camera.hasProperty(CAMERA_PROPERTY_ASPECT_RATIO.name))\n            camera.updateProperty(CAMERA_PROPERTY_ASPECT_RATIO.name,\n                                  static_cast<double>(_frameBufferSize.x) / static_cast<double>(_frameBufferSize.y));\n        camera.commit();\n\n        const uint64_t i = CAMERA_DEFINITION_SIZE * _frameNumber;\n        // Camera position\n        CameraDefinition cd;\n        const auto &ci = _exportFramesToDiskPayload.cameraInformation;\n        cd.origin = {ci[i], ci[i + 1], ci[i + 2]};\n        cd.direction = {ci[i + 3], ci[i + 4], ci[i + 5]};\n        cd.up = {ci[i + 6], ci[i + 7], ci[i + 8]};\n        cd.apertureRadius = ci[i + 9];\n        cd.focalDistance = ci[i + 10];\n        cd.interpupillaryDistance = ci[i + 11];\n        _setCamera(cd);\n\n        // Animation parameters\n        const auto &ai = _exportFramesToDiskPayload.animationInformation;\n        if (!ai.empty())\n            _api->getParametersManager().getAnimationParameters().setFrame(ai[_frameNumber]);\n    }\n}\n\nvoid MediaMakerPlugin::postRender()\n{\n    ++_accumulationFrameNumber;\n\n    if (_exportFramesToDiskDirty)\n    {\n        try\n        {\n            if (_exportFramesToDiskPayload.exportIntermediateFrames)\n                _exportFrameToDisk();\n\n            if (_accumulationFrameNumber == _exportFramesToDiskPayload.spp)\n            {\n                ++_frameNumber;\n                _accumulationFrameNumber = 0;\n                _exportFramesToDiskDirty = (_frameNumber < _exportFramesToDiskPayload.endFrame);\n                _exportFrameToDisk();\n            }\n        }\n        catch (const std::runtime_error &e)\n        {\n            PLUGIN_ERROR(e.what());\n        }\n    }\n}\n\nvoid writeBufferToFile(const std::vector<unsigned char> &buffer, const std::string &filename)\n{\n    std::ofstream file(filename, std::ios::binary);\n    if (!file.is_open())\n        CORE_THROW(\"Failed to create \" + filename);\n    file.write(reinterpret_cast<const char *>(buffer.data()), buffer.size());\n    file.close();\n}\n\nvoid MediaMakerPlugin::_exportColorBuffer() const\n{\n    auto &frameBuffer = _api->getEngine().getFrameBuffer();\n    auto image = frameBuffer.getImage();\n    ImageBuf rotatedBuf;\n    ImageBufAlgo::flip(rotatedBuf, image);\n\n    // Determine the output format\n    std::string format = _exportFramesToDiskPayload.format;\n    if (format != \"jpg\" && format != \"png\" && format != \"tiff\")\n        CORE_THROW(\"Unknown format: \" + format);\n\n    int quality = _exportFramesToDiskPayload.quality;\n\n    // Prepare the filename\n    const auto filename = _exportFramesToDiskPayload.path + \"/\" + _exportFramesToDiskPayload.baseName + \".\" + format;\n\n    // Set up ImageSpec for output image\n    ImageSpec spec = rotatedBuf.spec();\n    if (format == \"jpg\")\n        spec.attribute(\"CompressionQuality\", quality);\n\n    // Create an output buffer and write image to memory\n    std::vector<unsigned char> buffer(spec.image_bytes());\n\n    auto out = ImageOutput::create(filename);\n    if (!out)\n        CORE_THROW(\"Could not create image output.\");\n\n    out->open(filename, spec);\n    out->write_image(TypeDesc::UINT8, rotatedBuf.localpixels());\n    out->close();\n\n    PLUGIN_INFO(\"Color frame saved to \" + filename);\n}\n\nvoid MediaMakerPlugin::_exportDepthBuffer() const\n{\n    auto &frameBuffer = _api->getEngine().getFrameBuffer();\n    frameBuffer.map();\n    const auto depthBuffer = frameBuffer.getFloatBuffer();\n    const auto &size = frameBuffer.getSize();\n\n    const auto filename = _exportFramesToDiskPayload.path + \"/\" + _exportFramesToDiskPayload.baseName + \".\" +\n                          _exportFramesToDiskPayload.format;\n\n    TIFF *image = TIFFOpen(filename.c_str(), \"w\");\n    TIFFSetField(image, TIFFTAG_IMAGEWIDTH, size.x);\n    TIFFSetField(image, TIFFTAG_IMAGELENGTH, size.y);\n    TIFFSetField(image, TIFFTAG_BITSPERSAMPLE, 32);\n    TIFFSetField(image, TIFFTAG_SAMPLESPERPIXEL, 1);\n    TIFFSetField(image, TIFFTAG_ROWSPERSTRIP, 1);\n    TIFFSetField(image, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n    TIFFSetField(image, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    TIFFSetField(image, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n    TIFFSetField(image, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);\n    TIFFSetField(image, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n\n    float *scan_line = (float *)malloc(1 + size.x * (sizeof(float)));\n\n    for (uint32_t i = 0; i < size.y; ++i)\n    {\n        memcpy(scan_line, &depthBuffer[i * size.x], size.x * sizeof(float));\n        TIFFWriteScanline(image, scan_line, size.y - 1 - i, 0);\n    }\n\n    TIFFClose(image);\n    free(scan_line);\n\n    PLUGIN_INFO(\"Depth frame saved to \" + filename);\n\n    frameBuffer.unmap();\n}\n\nvoid MediaMakerPlugin::_exportFrameToDisk() const\n{\n    switch (_exportFramesToDiskPayload.frameBufferMode)\n    {\n    case FrameBufferMode::color:\n        _exportColorBuffer();\n        break;\n    case FrameBufferMode::depth:\n        _exportDepthBuffer();\n        break;\n    default:\n        PLUGIN_THROW(\"Undefined frame buffer mode\")\n    }\n}\n\nvoid MediaMakerPlugin::_exportFramesToDisk(const ExportFramesToDisk &payload)\n{\n    _exportFramesToDiskPayload = payload;\n    _exportFramesToDiskDirty = true;\n    _frameNumber = payload.startFrame;\n    _frameBufferSize = Vector2ui(payload.size[0], payload.size[1]);\n    _accumulationFrameNumber = 0;\n    _baseName = payload.baseName;\n\n    const size_t nbFrames = _exportFramesToDiskPayload.endFrame - _exportFramesToDiskPayload.startFrame;\n    PLUGIN_INFO(\n        \"----------------------------------------------------------------------\"\n        \"----------\");\n    PLUGIN_INFO(\"Movie settings               :\");\n    PLUGIN_INFO(\"- Samples per pixel          : \" + std::to_string(payload.spp));\n    PLUGIN_INFO(\"- Frame size                 : \" + std::to_string(_frameBufferSize.x) + \"x\" +\n                std::to_string(_frameBufferSize.y));\n    PLUGIN_INFO(\"- Export folder              : \" + payload.path);\n    PLUGIN_INFO(\"- Export intermediate frames : \" + std::string(payload.exportIntermediateFrames ? \"Yes\" : \"No\"));\n    PLUGIN_INFO(\"- Start frame                : \" + std::to_string(payload.startFrame));\n    PLUGIN_INFO(\"- End frame                  : \" << std::to_string(payload.endFrame));\n    PLUGIN_INFO(\"- Frame base name            : \" << payload.baseName);\n    PLUGIN_INFO(\"- Number of frames           : \" << std::to_string(nbFrames));\n    PLUGIN_INFO(\n        \"----------------------------------------------------------------------\"\n        \"----------\");\n}\n\nFrameExportProgress MediaMakerPlugin::_getFrameExportProgress()\n{\n    FrameExportProgress result;\n    double percentage = 1.f;\n    const size_t nbFrames = _exportFramesToDiskPayload.cameraInformation.size() / CAMERA_DEFINITION_SIZE;\n    const size_t totalNumberOfFrames = nbFrames * _exportFramesToDiskPayload.spp;\n\n    if (totalNumberOfFrames != 0)\n    {\n        const double currentProgress = _frameNumber * _exportFramesToDiskPayload.spp + _accumulationFrameNumber;\n        percentage = currentProgress / double(totalNumberOfFrames);\n    }\n    result.progress = percentage;\n    result.done = !_exportFramesToDiskDirty;\n    PLUGIN_DEBUG(\"Percentage = \" << result.progress << \", Done = \" << (result.done ? \"True\" : \"False\"));\n    return result;\n}\n\nvoid MediaMakerPlugin::_attachCameraHandler(const CameraHandlerDetails &payload)\n{\n    auto &scene = _api->getScene();\n    const auto modelDescriptors = scene.getModelDescriptors();\n    if (modelDescriptors.empty())\n        PLUGIN_THROW(\"At least one model is required in the scene\");\n\n    if (payload.directions.size() != payload.origins.size())\n        PLUGIN_THROW(\"Invalid number of values for direction vectors\");\n\n    if (payload.ups.size() != payload.origins.size())\n        PLUGIN_THROW(\"Invalid number of values for up vectors\");\n\n    const uint64_t nbKeyFrames = payload.origins.size() / 3;\n    CameraKeyFrames keyFrames;\n    for (uint64_t i = 0; i < nbKeyFrames; ++i)\n    {\n        CameraKeyFrame keyFrame;\n        keyFrame.origin = {payload.origins[i * 3], payload.origins[i * 3 + 1], payload.origins[i * 3 + 2]};\n        keyFrame.direction = {payload.directions[i * 3], payload.directions[i * 3 + 1], payload.directions[i * 3 + 2]};\n        keyFrame.up = {payload.ups[i * 3], payload.ups[i * 3 + 1], payload.ups[i * 3 + 2]};\n        keyFrame.apertureRadius = payload.apertureRadii[i];\n        keyFrame.focalDistance = payload.focalDistances[i];\n        keyFrames.push_back(keyFrame);\n    }\n\n    auto modelDescriptor = modelDescriptors[0];\n    if (!modelDescriptor)\n        PLUGIN_THROW(\"Invalid model\");\n\n    auto &model = modelDescriptor->getModel();\n    auto &camera = _api->getCamera();\n    auto handler = std::make_shared<CameraHandler>(camera, keyFrames, payload.stepsBetweenKeyFrames,\n                                                   payload.numberOfSmoothingSteps);\n    model.setSimulationHandler(handler);\n}\n\nextern \"C\" ExtensionPlugin *core_plugin_create(int /*argc*/, char ** /*argv*/)\n{\n    PLUGIN_INFO(\"Initializing Media Maker plug-in (version \" << PACKAGE_VERSION_STRING << \")\");\n    PLUGIN_INFO(\"\");\n    PLUGIN_INFO(\"_|      _|                  _|  _|                _|      _|            _|                          \");\n    PLUGIN_INFO(\"_|_|  _|_|    _|_|      _|_|_|        _|_|_|      _|_|  _|_|    _|_|_|  _|  _|      _|_|    _|  _|_|\");\n    PLUGIN_INFO(\"_|  _|  _|  _|_|_|_|  _|    _|  _|  _|    _|      _|  _|  _|  _|    _|  _|_|      _|_|_|_|  _|_|    \");\n    PLUGIN_INFO(\"_|      _|  _|        _|    _|  _|  _|    _|      _|      _|  _|    _|  _|  _|    _|        _|      \");\n    PLUGIN_INFO(\"_|      _|    _|_|_|    _|_|_|  _|    _|_|_|      _|      _|    _|_|_|  _|    _|    _|_|_|  _|      \");\n    PLUGIN_INFO(\"\");\n    return new MediaMakerPlugin();\n}\n\n} // namespace mediamaker\n}",
    "void MediaMakerPlugin::_exportDepthBuffer() const\n{\n    auto &frameBuffer = _api->getEngine().getFrameBuffer();\n    frameBuffer.map();\n    const auto depthBuffer = frameBuffer.getFloatBuffer();\n    const auto &size = frameBuffer.getSize();\n\n    const auto filename = _exportFramesToDiskPayload.path + \"/\" + _exportFramesToDiskPayload.baseName + \".\" +\n                          _exportFramesToDiskPayload.format;\n\n    TIFF *image = TIFFOpen(filename.c_str(), \"w\");\n    TIFFSetField(image, TIFFTAG_IMAGEWIDTH, size.x);\n    TIFFSetField(image, TIFFTAG_IMAGELENGTH, size.y);\n    TIFFSetField(image, TIFFTAG_BITSPERSAMPLE, 32);\n    TIFFSetField(image, TIFFTAG_SAMPLESPERPIXEL, 1);\n    TIFFSetField(image, TIFFTAG_ROWSPERSTRIP, 1);\n    TIFFSetField(image, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n    TIFFSetField(image, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    TIFFSetField(image, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n    TIFFSetField(image, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);\n    TIFFSetField(image, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n\n    float *scan_line = (float *)malloc(1 + size.x * (sizeof(float)));\n\n    for (uint32_t i = 0; i < size.y; ++i)\n    {\n        memcpy(scan_line, &depthBuffer[i * size.x], size.x * sizeof(float));\n        TIFFWriteScanline(image, scan_line, size.y - 1 - i, 0);\n    }\n\n    TIFFClose(image);\n    free(scan_line);\n\n    PLUGIN_INFO(\"Depth frame saved to \" + filename);\n\n    frameBuffer.unmap();\n}",
    "static bool saveFloatTIFF(const char * fileName, const FloatImage * fimage, uint base_component, uint num_components)\r\n{\r\n    nvCheck(fileName != NULL);\r\n    nvCheck(fimage != NULL);\r\n    nvCheck(base_component + num_components <= fimage->componentCount());\r\n\r\n    const int iW = fimage->width();\r\n    const int iH = fimage->height();\r\n    const int iC = num_components;\r\n\r\n    TIFF * image = TIFFOpen(fileName, \"w\");\r\n\r\n    // Open the TIFF file\r\n    if (image == NULL)\r\n    {\r\n        nvDebug(\"Could not open '%s' for writing\\n\", fileName);\r\n        return false;\r\n    }\r\n\r\n    TIFFSetField(image, TIFFTAG_IMAGEWIDTH,  iW);\r\n    TIFFSetField(image, TIFFTAG_IMAGELENGTH, iH);\r\n    TIFFSetField(image, TIFFTAG_SAMPLESPERPIXEL, iC);\r\n    TIFFSetField(image, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);\r\n    TIFFSetField(image, TIFFTAG_BITSPERSAMPLE, 32);\r\n\r\n    uint32 rowsperstrip = TIFFDefaultStripSize(image, (uint32)-1);\r\n\r\n    TIFFSetField(image, TIFFTAG_ROWSPERSTRIP, rowsperstrip);\r\n    TIFFSetField(image, TIFFTAG_COMPRESSION, COMPRESSION_PACKBITS);\r\n    if (num_components == 3)\r\n    {\r\n        // Set this so that it can be visualized with pfstools.\r\n        TIFFSetField(image, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\r\n    }\r\n    TIFFSetField(image, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\r\n    TIFFSetField(image, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\r\n\r\n    float * scanline = new float[iW * iC];\r\n    for (int y = 0; y < iH; y++)\r\n    {\r\n        for (int c = 0; c < iC; c++)\r\n        {\r\n            const float * src = fimage->scanline(y, base_component + c);\r\n            for (int x = 0; x < iW; x++) scanline[x * iC + c] = src[x];\r\n        }\r\n        if (TIFFWriteScanline(image, scanline, y, 0)==-1)\r\n        {\r\n            nvDebug(\"Error writing scanline %d\\n\", y);\r\n            return false;\r\n        }\r\n    }\r\n    delete [] scanline;\r\n\r\n    // Close the file\r\n    TIFFClose(image);\r\n    return true;\r\n}",
    "int main(int argc, char** argv) {\n    double gamma = 1.0;\n    bool   gui = false;\n    bool   savepng = false;\n    bool   savebayer = false;\n    \n    if(argc<2){\n        printf(\"Usage: %s filename [--gui] [--savepng] [--savebayer] [--gamma=1.0]\\n\",argv[0]);\n        return -1;\n    }\n    for(int i=2;i<argc;i++){\n        if(strcmp(argv[i],\"--savepng\")==0){\n            savepng = true;\n        }\n        if(strcmp(argv[i],\"--savebayer\")==0){\n            savebayer = true;\n        }\n        if(strcmp(argv[i],\"--gui\")==0){\n            gui = true;\n        }\n        if(strncmp(argv[i],\"--gamma=\",8)==0) {\n            gamma = atof(argv[i]+8);\n        }\n    }\n    const char* fn = argv[1];\n\n    fprintf(stdout,\"--------------------EFFUSUS--------------------\\n\");\n    fprintf(stdout,\"Gamma:    \\t %f\\n\",gamma);\n    fprintf(stdout,\"GUI:      \\t %s\\n\",gui?\"true\":\"false\");\n    fprintf(stdout,\"Save PNG: \\t %s\\n\",savepng?\"true\":\"false\");\n    fprintf(stdout,\"Save Bayer:\\t %s\\n\",savebayer?\"true\":\"false\");\n    fprintf(stdout,\"Filename: \\t %s\\n\",fn);\n    fprintf(stdout,\"-----------------------------------------------\\n\");\n    // Flush printf\n    fflush(stdout);\n\n    // Load binary\n    uint8_t* fbuf = (uint8_t*)malloc((CCD_H+1)*CCD_W*2);\n    long flen = read_binary_file(fn, fbuf, (CCD_H+1)*CCD_W*2);\n    if(flen==-1) return -1;\n    printf(\"Read Successful, flen=%ld\\n\",flen);\n\n    // Convert binary to rggb raw data\n    uint16_t* raw = (uint16_t*)malloc(2*(SCR_W+1)*SCR_H*4);\n    memset(raw,0xFF,sizeof(raw));\n    effusus_bin2raw(raw, fbuf, CCD_W, CCD_H, SCR_W, SCR_H);\n\n    if(gui) {\n        // Init SDL\n        SDL_Init(SDL_INIT_VIDEO);\n        swin = SDL_SetVideoMode(SCR_W/2, SCR_H/2, 16, false);\n        semu = SDL_CreateRGBSurface(SDL_SWSURFACE,SCR_W, SCR_H,16,0,0,0,0);\n        if ((semu == NULL) || (swin == NULL)) {\n            fprintf(stderr, \"could not create surface: %s\\n\", SDL_GetError());\n            return -1;\n        }\n        uint16_t* vram = (uint16_t*)(semu->pixels);\n\n        // Dither to VRAM\n        effusus_dither_to_vram(vram, raw, gamma, SCR_W, SCR_H, EFFUSUS_DITHER_FS);\n        \n        SDL_Event event;\n        bool running = true;\n        \n        while(running){\n            while(SDL_PollEvent(&event)){\n                running = event.type != SDL_QUIT;\n            }\n            switch( event.type ){\n                case SDL_KEYDOWN:\n                    switch( event.key.keysym.sym ){\n                    case SDLK_ESCAPE:\n                        running = false;\n                        break;\n                    default:\n                        break;\n                }\n            }\n            SDL_SoftStretch(semu,&rsrc,swin,&rdst);\n            SDL_Flip(swin);\n        }\n        SDL_SoftStretch(semu,&rsrc,swin,&rdst);\n        SDL_Flip(swin);\n    }\n\n    unsigned bayerbuf_size = SCR_W*SCR_H*4*2;\n    uint8_t* bayerbuf;\n    bayerbuf = (uint8_t*)malloc(bayerbuf_size);\n    memset(bayerbuf,0x00,bayerbuf_size);\n    effusus_raw2bayer(raw, bayerbuf, SCR_W, SCR_H);\n    if(savebayer){\n        // Store bayer raw to binary file\n        // This will result in the following image format:\n        // 4416 x 2726 RGGB(2x2)\n        // Row-Stride = 8832, Pixel-Stride = 4 \n        // 16-bit per pixel, Little-Endian\n        //\n        // The file can be opened by GIMP, RawTherapee, or LibRaw\n        FILE* fbayer = fopen(\"bayer.raw\",\"wb\");\n        fwrite(bayerbuf,1,bayerbuf_size,fbayer);\n        fclose(fbayer);\n        PRINTINFO(\"Bayer RAW saved to bayer.raw\\n\");\n    }\n\n    if(savepng){\n        // Store raw to PNG\n        effusus_writepng(\"output.png\", raw, SCR_W, SCR_H);\n    }\n\n    // Write to mosaic tiff\n    // print libtiff version\n    printf(\"LIBTIFF %s\\n\", TIFFGetVersion());\n    TIFF* tiff = TIFFOpen(\"output.tiff\",\"w\");\n    if(!tiff){\n        fprintf(stderr,\"Failed to open output.tiff for writing\\n\");\n        return -1;\n    }\n    // Set TIFF tags\n    TIFFSetField(tiff, TIFFTAG_IMAGEWIDTH,  SCR_W*2);\n    TIFFSetField(tiff, TIFFTAG_IMAGELENGTH, SCR_H*2);\n    TIFFSetField(tiff, TIFFTAG_SAMPLESPERPIXEL, 1);\n    TIFFSetField(tiff, TIFFTAG_ROWSPERSTRIP, 1);\n    TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 16);\n    TIFFSetField(tiff, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT);\n    TIFFSetField(tiff, TIFFTAG_ORIENTATION, ORIENTATION_BOTRIGHT);\n    TIFFSetField(tiff, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_CFA);\n\n    TIFFSetField(tiff, TIFFTAG_MAKE, \"DummyMake\");\n    TIFFSetField(tiff, TIFFTAG_MODEL, \"DummyModel\");\n    TIFFSetField(tiff, TIFFTAG_SOFTWARE, \"DummySoftware\");\n    TIFFSetField(tiff, TIFFTAG_ORIGINALRAWFILENAME, 1, \"DummyName.dng\");\n    TIFFSetField(tiff, TIFFTAG_UNIQUECAMERAMODEL, \"DummyUniqueModel\");\n    TIFFSetField(tiff, TIFFTAG_IMAGEDESCRIPTION, \"DummyImageDescription\");\n    TIFFSetField(tiff, TIFFTAG_COPYRIGHT, \"DummyCopyright\");\n    TIFFSetField(tiff, TIFFTAG_DATETIME, \"2016:06:30 11:11:15\");\n    TIFFSetField(tiff, TIFFTAG_DNGVERSION, \"\\01\\01\\00\\00\");\n    TIFFSetField(tiff, TIFFTAG_SUBFILETYPE, 0);\n    TIFFSetField(tiff, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n    TIFFSetField(tiff, TIFFTAG_DNGBACKWARDVERSION, \"\\01\\00\\00\\00\");\n    \n    // Custom TIFF tag for CFA pattern\n    TIFFSetField(tiff, TIFFTAG_CFAPATTERN, 4, \"\\000\\001\\001\\002\"); // RGGB\n\n    // Write bayer data\n    tsize_t linebytes = SCR_W*4 * sizeof(uint8_t);\n    uint8_t *buf = (uint8_t*)_TIFFmalloc(linebytes);\n    for (uint32_t row = 0; row < SCR_H*2; row++) {\n        // Copy data from bayerbuf to buf, big endian\n        for (uint32_t col = 0; col < SCR_W*4; col+=2) {\n            buf[col]   = bayerbuf[row*SCR_W*4+col];\n            buf[col+1] = bayerbuf[row*SCR_W*4+col+1];\n        }\n        if (TIFFWriteScanline(tiff, buf, row, 0) < 0) {\n            fprintf(stderr, \"Failed to write TIFF scanline\\n\");\n            break;\n        }\n    }\n    _TIFFfree(buf);\n    //\n\n    // Close TIFF\n    TIFFClose(tiff);\n\n    free(bayerbuf);\n    free(raw);\n    if(gui)\tSDL_Quit();\n    printf(\"Done!\\n\");\n    \n    return 0;\n}",
    "int DiTIFFPlugin::write(\n  DiImage *image,\n  FILE *stream,\n  const unsigned int frame) const\n{\n  int result = 0;\n  if ((image != NULL) && (stream != NULL))\n  {\n    int stream_fd = fileno(stream);\n\n#ifdef HAVE_WINDOWS_H\n    /* The Win32 version of libtiff expects a Win32 HANDLE (casted to int)\n     * instead of a file descriptor. Therefore, we use _get_osfhandle()\n     * which takes a Unix-style file descriptor and derives the corresponding\n     * Win32 API file handle (HANDLE). This function may not be available on all\n     * compilers for Win32, sorry.\n     */\n#ifdef __CYGWIN__\n    stream_fd = OFstatic_cast(int, get_osfhandle(stream_fd));\n#else\n    stream_fd =OFstatic_cast(int, _get_osfhandle(stream_fd));\n#endif\n#endif\n\n    /* create bitmap with 8 bits per sample */\n    void *data = OFconst_cast(void *, image->getOutputData(frame, 8 /*bits*/, 0 /*planar*/));\n    if (data != NULL)\n    {\n      OFBool isMono = (image->getInternalColorModel() == EPI_Monochrome1) || (image->getInternalColorModel() == EPI_Monochrome2);\n      Uint16 rows = image->getRows();\n      Uint16 cols = image->getColumns();\n\n      short photometric = isMono ? PHOTOMETRIC_MINISBLACK : PHOTOMETRIC_RGB;\n      short samplesperpixel = isMono ? 1 : 3;\n      unsigned int bytesperrow = cols * samplesperpixel;\n      if (bytesperrow > 0)\n      {\n        short opt_predictor = 0;\n        switch (predictor)\n        {\n          case E_tiffLZWPredictorDefault:\n            opt_predictor = 0;\n            break;\n          case E_tiffLZWPredictorNoPrediction:\n            opt_predictor = 1;\n            break;\n          case E_tiffLZWPredictorHDifferencing:\n            opt_predictor = 2;\n            break;\n        }\n\n        unsigned short opt_compression = COMPRESSION_NONE;\n        switch (compressionType)\n        {\n          case E_tiffLZWCompression:\n            opt_compression = COMPRESSION_LZW;\n            break;\n          case E_tiffPackBitsCompression:\n            opt_compression = COMPRESSION_PACKBITS;\n            break;\n          case E_tiffNoCompression:\n            opt_compression = COMPRESSION_NONE;\n            break;\n        }\n\n        long opt_rowsperstrip = OFstatic_cast(long, rowsPerStrip);\n        if (opt_rowsperstrip <= 0) opt_rowsperstrip = 8192 / bytesperrow;\n        if (opt_rowsperstrip == 0) opt_rowsperstrip++;\n\n        OFBool OK = OFTrue;\n        unsigned char *bytedata = OFstatic_cast(unsigned char *, data);\n        TIFF *tif = TIFFFdOpen(stream_fd, \"TIFF\", \"w\");\n        if (tif)\n        {\n          /* Set TIFF parameters. */\n          TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, cols);\n          TIFFSetField(tif, TIFFTAG_IMAGELENGTH, rows);\n          TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8);\n          TIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n          TIFFSetField(tif, TIFFTAG_COMPRESSION, opt_compression);\n          if (opt_compression == COMPRESSION_LZW && opt_predictor != 0)\n          TIFFSetField(tif, TIFFTAG_PREDICTOR, opt_predictor);\n          TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, photometric);\n          TIFFSetField(tif, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);\n          TIFFSetField(tif, TIFFTAG_DOCUMENTNAME, \"unnamed\");\n          TIFFSetField(tif, TIFFTAG_IMAGEDESCRIPTION, \"converted DICOM image\");\n          TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, samplesperpixel);\n          TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, opt_rowsperstrip);\n          /* TIFFSetField(tif, TIFFTAG_STRIPBYTECOUNTS, rows / opt_rowsperstrip); */\n          TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\n          /* Now write the TIFF data. */\n          unsigned int offset = 0;\n          for (Uint16 i=0; (i < rows) && OK; i++)\n          {\n            if (TIFFWriteScanline(tif, bytedata + offset, i, 0) < 0) OK = OFFalse;\n            offset += bytesperrow;\n          }\n          TIFFFlushData(tif);\n          TIFFClose(tif);\n        }\n        if (OK) result = 1;\n      }\n    }\n\n    /* delete pixel data */\n    image->deleteOutputData();\n  }\n  return result;\n}",
    "void WriteTIFF(const char *name, float *rgba, int XRes, int YRes, bool hasAlpha) \n{\n    // Open 8-bit TIFF file for writing\n    TIFF *tiff = TIFFOpen(name, \"w\");\n    if (!tiff) {\n\tfprintf(stderr, \"Unable to open TIFF %s for writing\", name);\n\treturn;\n    }\n\n    int nChannels = hasAlpha ? 4 : 3;\n    TIFFSetField(tiff, TIFFTAG_SAMPLESPERPIXEL, nChannels);\n    if (hasAlpha) {\n\tshort int extra[] = { EXTRASAMPLE_ASSOCALPHA };\n\tTIFFSetField(tiff, TIFFTAG_EXTRASAMPLES, (short)1, extra);\n    }\n    // Write image resolution information\n    TIFFSetField(tiff, TIFFTAG_IMAGEWIDTH, XRes);\n    TIFFSetField(tiff, TIFFTAG_IMAGELENGTH, YRes);\n    TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 8);\n    TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n    // Set Generic TIFF Fields\n    TIFFSetField(tiff, TIFFTAG_ROWSPERSTRIP, 1);\n    TIFFSetField(tiff, TIFFTAG_XRESOLUTION, 1.f);\n    TIFFSetField(tiff, TIFFTAG_YRESOLUTION, 1.f);\n    TIFFSetField(tiff, TIFFTAG_RESOLUTIONUNIT, (short)1);\n    TIFFSetField(tiff, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n    TIFFSetField(tiff, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    TIFFSetField(tiff, TIFFTAG_ORIENTATION, (int)ORIENTATION_TOPLEFT);\n    // Write 8-bit scanlines\n    unsigned char *buf = new unsigned char[nChannels * XRes];\n    for (int y = 0; y < YRes; ++y) {\n\tunsigned char *bufp = buf;\n\tfor (int x = 0; x < XRes; ++x) {\n\t    // Pack 8-bit pixels samples into buf\n\t    for (int s = 0; s < nChannels; ++s)\n\t\t*bufp++ = (unsigned char)*rgba++;\n\t}\n\tTIFFWriteScanline(tiff, buf, y, 1);\n    }\n    // Close 8-bit TIFF file\n    delete[] buf;\n    TIFFClose(tiff);\n}",
    "bool\nTiffWriter::writeRGB32Image(\n    TiffHandle const& tif, QImage const& image, bool multipage, int compression)\n{\n    assert(image.format() == QImage::Format_RGB32);\n\n    TIFFSetField(tif.handle(), TIFFTAG_SAMPLESPERPIXEL, uint16(3));\n    TIFFSetField(tif.handle(), TIFFTAG_COMPRESSION, uint16(compression));\n    TIFFSetField(tif.handle(), TIFFTAG_BITSPERSAMPLE, uint16(8));\n    TIFFSetField(tif.handle(), TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n    if (GlobalStaticSettings::m_use_horizontal_predictor) {\n        TIFFSetField(tif.handle(), TIFFTAG_PREDICTOR, PREDICTOR_HORIZONTAL);\n    }\n\n    int const width = image.width();\n    int const height = image.height();\n\n    std::vector<uint8_t> tmp_line(width * 3);\n\n    // Libtiff expects \"RR GG BB\" sequences regardless of CPU byte order.\n\n    for (int y = 0; y < height; ++y) {\n        uint32_t const* p_src = (uint32_t const*)image.scanLine(y);\n        uint8_t* p_dst = &tmp_line[0];\n        for (int x = 0; x < width; ++x) {\n            uint32_t const ARGB = *p_src;\n            p_dst[0] = static_cast<uint8_t>(ARGB >> 16);\n            p_dst[1] = static_cast<uint8_t>(ARGB >> 8);\n            p_dst[2] = static_cast<uint8_t>(ARGB);\n            ++p_src;\n            p_dst += 3;\n        }\n        if (TIFFWriteScanline(tif.handle(), &tmp_line[0], y) == -1) {\n            return false;\n        }\n    }\n\n    if (multipage && (TIFFWriteDirectory(tif.handle()) == -1)) {\n        return false;\n    }\n\n    return true;\n}",
    "bool\nTiffWriter::writeARGB32Image(\n    TiffHandle const& tif, QImage const& image, bool multipage, int compression)\n{\n    assert(image.format() == QImage::Format_ARGB32);\n\n    TIFFSetField(tif.handle(), TIFFTAG_SAMPLESPERPIXEL, uint16(4));\n    TIFFSetField(tif.handle(), TIFFTAG_COMPRESSION, uint16(compression));\n    TIFFSetField(tif.handle(), TIFFTAG_BITSPERSAMPLE, uint16(8));\n    TIFFSetField(tif.handle(), TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n    if (GlobalStaticSettings::m_use_horizontal_predictor) {\n        TIFFSetField(tif.handle(), TIFFTAG_PREDICTOR, PREDICTOR_HORIZONTAL);\n    }\n\n    int const width = image.width();\n    int const height = image.height();\n\n    std::vector<uint8_t> tmp_line(width * 4);\n\n    // Libtiff expects \"RR GG BB AA\" sequences regardless of CPU byte order.\n\n    for (int y = 0; y < height; ++y) {\n        uint32_t const* p_src = (uint32_t const*)image.scanLine(y);\n        uint8_t* p_dst = &tmp_line[0];\n        for (int x = 0; x < width; ++x) {\n            uint32_t const ARGB = *p_src;\n            p_dst[0] = static_cast<uint8_t>(ARGB >> 16);\n            p_dst[1] = static_cast<uint8_t>(ARGB >> 8);\n            p_dst[2] = static_cast<uint8_t>(ARGB);\n            p_dst[3] = static_cast<uint8_t>(ARGB >> 24);\n            ++p_src;\n            p_dst += 4;\n        }\n        if (TIFFWriteScanline(tif.handle(), &tmp_line[0], y) == -1) {\n            return false;\n        }\n    }\n\n    if (multipage && (TIFFWriteDirectory(tif.handle()) == -1)) {\n        return false;\n    }\n\n    return true;\n}",
    "bool\nTiffWriter::write8bitLines(\n    TiffHandle const& tif, QImage const& image)\n{\n    int const width = image.width();\n    int const height = image.height();\n\n    // TIFFWriteScanline() can actually modify the data you pass it,\n    // so we have to use a temporary buffer even when no coversion\n    // is required.\n    std::vector<uint8_t> tmp_line(width, 0);\n\n    for (int y = 0; y < height; ++y) {\n        uint8_t const* src_line = image.scanLine(y);\n        memcpy(&tmp_line[0], src_line, tmp_line.size());\n        if (TIFFWriteScanline(tif.handle(), &tmp_line[0], y) == -1) {\n            return false;\n        }\n    }\n\n    return true;\n}",
    "bool\nTiffWriter::writeBinaryLinesAsIs(\n    TiffHandle const& tif, QImage const& image)\n{\n    int const width = image.width();\n    int const height = image.height();\n\n    // TIFFWriteScanline() can actually modify the data you pass it,\n    // so we have to use a temporary buffer even when no conversion\n    // is required.\n    int const bpl = (width + 7) / 8;\n    std::vector<uint8_t> tmp_line(bpl, 0);\n\n    for (int y = 0; y < height; ++y) {\n        uint8_t const* src_line = image.scanLine(y);\n        memcpy(&tmp_line[0], src_line, bpl);\n        if (TIFFWriteScanline(tif.handle(), &tmp_line[0], y) == -1) {\n            return false;\n        }\n    }\n\n    return true;\n}",
    "bool\nTiffWriter::writeBinaryLinesReversed(\n    TiffHandle const& tif, QImage const& image)\n{\n    int const width = image.width();\n    int const height = image.height();\n\n    int const bpl = (width + 7) / 8;\n    std::vector<uint8_t> tmp_line(bpl, 0);\n\n    for (int y = 0; y < height; ++y) {\n        uint8_t const* src_line = image.scanLine(y);\n        for (int i = 0; i < bpl; ++i) {\n            tmp_line[i] = m_reverseBitsLUT[src_line[i]];\n        }\n        if (TIFFWriteScanline(tif.handle(), &tmp_line[0], y) == -1) {\n            return false;\n        }\n    }\n\n    return true;\n}",
    "void TIFFFormat::do_write(image_list* input, byte_sink* output, const options_map& opts, bool is_multi) {\n    tiff_warn_error twe;\n    tsize_t (*read_function)(thandle_t, void*, tsize_t) =\n         (dynamic_cast<byte_source*>(output) ?\n                            tiff_read_from_writer :\n                            tiff_no_read);\n    tif_holder t = TIFFClientOpen(\n                    \"internal\",\n                    \"w\",\n                    output,\n                    read_function,\n                    tiff_write,\n                    tiff_seek<byte_sink>,\n                    tiff_close,\n                    tiff_size<byte_sink>,\n                    NULL,\n                    NULL);\n    std::vector<uint8_t> bufdata;\n    const unsigned n_pages = input->size();\n    for (unsigned i = 0; i != n_pages; ++i) {\n        Image* im = input->at(i);\n        void* bufp = 0;\n        bool copy_data = false;\n        const uint32_t h = im->dim(0);\n        const uint32_t nchannels = uint16_t(im->dim_or(2, 1));\n        const uint16_t photometric = ((im->ndims() == 3 && im->dim(2)) ?\n                                                        PHOTOMETRIC_RGB :\n                                                        PHOTOMETRIC_MINISBLACK);\n        TIFFSetField(t.tif, TIFFTAG_IMAGELENGTH, uint32_t(h));\n        TIFFSetField(t.tif, TIFFTAG_IMAGEWIDTH, uint32_t(im->dim(1)));\n        TIFFSetField(t.tif, TIFFTAG_BITSPERSAMPLE, uint16_t(im->nbits()));\n        TIFFSetField(t.tif, TIFFTAG_SAMPLESPERPIXEL, uint16_t(im->dim_or(2, 1)));\n        TIFFSetField(t.tif, TIFFTAG_PHOTOMETRIC, uint16_t(photometric));\n        TIFFSetField(t.tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\n        if (get_optional_bool(opts, \"tiff:compress\", true)) {\n            TIFFSetField(t.tif, TIFFTAG_COMPRESSION, COMPRESSION_LZW);\n            // For 8 bit images, prediction defaults to false; for 16 bit images,\n            // it defaults to true. This is because compression of raw 16 bit\n            // images is often counter-productive without this flag. See the\n            // discusssion at http://www.asmail.be/msg0055176395.html\n            const bool prediction_default = im->nbits() != 8;\n            if (get_optional_bool(opts, \"tiff:horizontal-predictor\", prediction_default)) {\n                TIFFSetField(t.tif, TIFFTAG_PREDICTOR, PREDICTOR_HORIZONTAL);\n                if (!copy_data) {\n                    bufdata.resize(im->dim(1) * im->nbytes() * nchannels);\n                    bufp = &bufdata[0];\n                    copy_data = true;\n                }\n            }\n        }\n\n        TIFFSetField(t.tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n        const char* meta = get_optional_cstring(opts, \"metadata\");\n        if (meta) {\n            TIFFSetField(t.tif, TIFFTAG_IMAGEDESCRIPTION, meta);\n        }\n        options_map::const_iterator x_iter = opts.find(\"tiff:XResolution\");\n        if (x_iter != opts.end()) {\n            double d;\n            int i;\n            float value;\n            if (x_iter->second.get_int(i)) { value = i; }\n            else if (x_iter->second.get_double(d)) { value = d; }\n            else { throw WriteOptionsError(\"XResolution must be an integer or floating point value.\"); }\n\n            TIFFSetField(t.tif, TIFFTAG_XRESOLUTION, value);\n        }\n\n        options_map::const_iterator y_iter = opts.find(\"tiff:YResolution\");\n        if (x_iter != opts.end()) {\n            double d;\n            int i;\n            float value;\n            if (x_iter->second.get_int(i)) { value = i; }\n            else if (x_iter->second.get_double(d)) { value = d; }\n            else { throw WriteOptionsError(\"YResolution must be an integer or floating point value.\"); }\n\n            TIFFSetField(t.tif, TIFFTAG_YRESOLUTION, value);\n        }\n\n        const uint16_t resolution_unit = get_optional_int(opts, \"tiff:XResolutionUnit\", uint16_t(-1));\n        if (resolution_unit != uint16_t(-1)) {\n            TIFFSetField(t.tif, TIFFTAG_RESOLUTIONUNIT, resolution_unit);\n        }\n\n        if (is_multi) {\n            TIFFSetField(t.tif, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE);\n            TIFFSetField(t.tif, TIFFTAG_PAGENUMBER, i, n_pages);\n        }\n\n        for (uint32_t r = 0; r != h; ++r) {\n            void* rowp = im->rowp(r);\n            if (copy_data) {\n                std::memcpy(bufp, rowp, im->dim(1) * im->nbytes() * nchannels);\n                rowp = bufp;\n            }\n            if (TIFFWriteScanline(t.tif, rowp, r) == -1) {\n                throw CannotWriteError(\"imread.imsave._tiff: Error writing TIFF file\");\n            }\n        }\n        if (is_multi) {\n            if (!TIFFWriteDirectory(t.tif)) {\n                throw CannotWriteError(\"TIFFWriteDirectory failed\");\n            }\n        }\n    }\n    TIFFFlush(t.tif);\n}",
    "void MyImage::toTIFF(int bit, float minthresh, float maxthresh, bool zscaleing, float grey, float gamma)\n{\n    /*\n    // If no dynamic range provided, use the data min/max values\n    if (!zscaleing) {\n        minthresh = minVec_T(dataCurrent);\n        maxthresh = maxVec_T(dataCurrent);\n    }\n    */\n\n    if (*verbosity >= 2) emit messageAvailable(\"Creating \"+baseName+\".tiff ...\", \"ignore\");\n\n    if (dataTIFF.isEmpty()) dataTIFF = dataCurrent;\n\n    long n = naxis1;\n    long m = naxis2;\n    long dim = n*m;\n\n    // If z-scale is requested\n    if (zscaleing) {\n        float medVal = medianMask_T(dataTIFF);\n        float rmsVal = rmsMask_T(dataTIFF);\n        minthresh = medVal - 2.*rmsVal;\n        maxthresh = medVal + 10.*rmsVal;\n    }\n\n    // If gamma correction if requested\n    if ( gamma != 1.0 ) {\n        gamma = 1./gamma;\n        double gmaxlevel = pow(maxthresh, gamma);\n#pragma omp parallel for\n        for (long k=0; k<dim; ++k) {\n            dataTIFF[k] = pow(dataTIFF[k], gamma) / gmaxlevel * maxthresh;\n        }\n    }\n\n    // Clipping min and max values\n#pragma omp parallel for\n    for (long k=0; k<dim; k++) {\n        if (dataTIFF[k] <= minthresh) dataTIFF[k] = minthresh;\n        if (dataTIFF[k] >= maxthresh) dataTIFF[k] = maxthresh;\n    }\n\n    float blowup = 0.;\n    if (bit == 8) {\n        grey = grey / 100. * 253.;\n        blowup = (253. - grey) / (maxthresh - minthresh);\n    }\n    else {\n        grey = grey / 100. * 65000.;\n        blowup = (65000. - grey) / (maxthresh - minthresh);\n    }\n\n    std::vector< std::vector<long> > imtiff(n);\n    for (long i=0; i<n; ++i) {\n        imtiff[i].resize(m,0);\n    }\n\n#pragma omp parallel for\n    for (long i=0; i<n; ++i)  {\n        for (long j=0; j<m; ++j)  {\n            dataTIFF[i+n*j] = blowup * (dataTIFF[i+n*j] - minthresh) + grey;\n            // flipping TIFF in y dir\n            imtiff[i][naxis2-j-1] = (long) dataTIFF[i+n*j];\n        }\n    }\n\n    QString outname = path+\"/\"+baseName+\".tiff\";\n    TIFF     *outtiff;             // pointer to the TIFF file, defined in tiffio.h\n    outtiff = TIFFOpen(outname.toUtf8().data(), \"w\");\n    TIFFSetField(outtiff, TIFFTAG_IMAGEWIDTH, n);\n    TIFFSetField(outtiff, TIFFTAG_IMAGELENGTH, m);\n    TIFFSetField(outtiff, TIFFTAG_COMPRESSION, 1);\n    if (bit == 8)  TIFFSetField(outtiff, TIFFTAG_BITSPERSAMPLE, 8);\n    if (bit == 16) TIFFSetField(outtiff, TIFFTAG_BITSPERSAMPLE, 16);\n    TIFFSetField(outtiff, TIFFTAG_SAMPLESPERPIXEL, 1);\n    TIFFSetField(outtiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n    TIFFSetField(outtiff, TIFFTAG_PLANARCONFIG, 1);\n    TIFFSetField(outtiff, TIFFTAG_SOFTWARE, \"THELI\");\n    TIFFSetField(outtiff, TIFFTAG_IMAGEDESCRIPTION, \"Created by THELI\");\n\n    if (bit == 8) {\n        uint8 *outbuf = (uint8 *)_TIFFmalloc(TIFFScanlineSize(outtiff));\n        for (long row=0; row<m; ++row) {\n            uint8 *outb = outbuf;\n            for (long column=0; column<n; ++column) {\n                *outb++ = (uint8) (imtiff[column][row]);\n            }\n            TIFFWriteScanline(outtiff, outbuf, row, 0);\n        }\n        TIFFClose(outtiff);\n        _TIFFfree(outbuf);\n    }\n    else {\n        // bit == 16\n        uint16 *outbuf = (uint16 *)_TIFFmalloc(TIFFScanlineSize(outtiff));\n        for (long row=0; row<m; ++row) {\n            uint16 *outb = outbuf;\n            for (long column=0; column<n; ++column) {\n                *outb++ = (uint16) (imtiff[column][row]);\n            }\n            TIFFWriteScanline(outtiff, outbuf, row, 0);\n        }\n        TIFFClose(outtiff);\n        _TIFFfree(outbuf);\n    }\n}",
    "void ColorPicture::writeRGBTIFF(QVector<float> &R, QVector<float> &G, QVector<float> &B, long n, long m, float min, float max, QString path)\n{\n    emit messageAvailable(\"Creating RGB.tiff ...\", \"ignore\");\n\n    // Clipping min and max values\n    QVector<QVector<float>> RGBlist;\n    RGBlist << R << G << B;\n\n#pragma omp parallel for\n    for (int i=0; i<3; ++i) {\n        for (auto &pixel : RGBlist[i]) {\n            if (pixel <= min) pixel = min;\n            if (pixel >= max) pixel = max;\n        }\n    }\n\n    float grey = 0.;  // inactive\n    grey = grey / 100. * 65000.;\n    float blowup = (65000. - grey) / (max - min);\n\n    std::vector< std::vector<long> > imtiff(n);\n    for (long i=0; i<n; ++i) {\n        imtiff[i].resize(m,0);\n    }\n\n#pragma omp parallel for\n    for (int img=0; img<3; ++img) {\n        for (long i=0; i<n; ++i)  {\n            for (long j=0; j<m; ++j)  {\n                RGBlist[img][i+n*j] = blowup * (RGBlist[img][i+n*j] - min) + grey;\n                // flipping TIFF in y dir\n                imtiff[i][m-j-1] = (long) RGBlist[img][i+n*j];\n            }\n        }\n    }\n\n    QString outname = path+\"/RGB.tiff\";\n    TIFF     *outtiff;             // pointer to the TIFF file, defined in tiffio.h\n    outtiff = TIFFOpen(outname.toUtf8().data(), \"w\");\n    TIFFSetField(outtiff, TIFFTAG_IMAGEWIDTH, n);\n    TIFFSetField(outtiff, TIFFTAG_IMAGELENGTH, m);\n    TIFFSetField(outtiff, TIFFTAG_COMPRESSION, 1);\n    TIFFSetField(outtiff, TIFFTAG_BITSPERSAMPLE, 16);\n    TIFFSetField(outtiff, TIFFTAG_SAMPLESPERPIXEL, 3);\n    TIFFSetField(outtiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n    TIFFSetField(outtiff, TIFFTAG_PLANARCONFIG, 1);       // store pixel values as sequential RGB RGB RGB\n    TIFFSetField(outtiff, TIFFTAG_SOFTWARE, \"THELI\");\n    TIFFSetField(outtiff, TIFFTAG_IMAGEDESCRIPTION, \"Created by THELI\");\n\n    uint16 *outbuf = (uint16 *)_TIFFmalloc(TIFFScanlineSize(outtiff));\n    for (long row=0; row<m; ++row) {\n        uint16 *outb = outbuf;\n        for (long column=0; column<n; ++column) {\n            *outb++ = (uint16) (imtiff[column][row]);\n        }\n        TIFFWriteScanline(outtiff, outbuf, row, 0);\n    }\n    TIFFClose(outtiff);\n    _TIFFfree(outbuf);\n}",
    "bool ossimTiffWriter::writeToStrips()\n{\n   static const char* const MODULE = \"ossimTiffWriter::writeToStrips\";\n   TIFF* tiffPtr = (TIFF*)theTif;\n\n   if (traceDebug()) CLOG << \" Entered.\" << std::endl;\n\n   // Start the sequence at the first tile.\n   theInputConnection->setToStartOfSequence();\n\n   ossim_uint32 bands = theInputConnection->getNumberOfOutputBands();\n   ossim_uint32 tilesWide = theInputConnection->getNumberOfTilesHorizontal();\n   ossim_uint32 tilesHigh = theInputConnection->getNumberOfTilesVertical();\n   ossim_uint32 tileHeight = theInputConnection->getTileHeight();\n   ossim_uint32 numberOfTiles = theInputConnection->getNumberOfTiles();\n   ossim_uint32 width = theAreaOfInterest.width();\n   ossim_uint32 bytesInLine =\n         ossim::scalarSizeInBytes(theInputConnection->getOutputScalarType()) *\n         width * bands;\n\n   //---\n   // Buffer to hold one line x tileHeight\n   //---\n   ossim_uint32 bufferSizeInBytes = bytesInLine * tileHeight;\n   unsigned char* buffer = new unsigned char[bufferSizeInBytes];\n\n   int tileNumber = 0;\n   vector<ossim_float64> minBands;\n   vector<ossim_float64> maxBands;\n   for(ossim_uint32 i = 0; ((i < tilesHigh)&&(!needsAborting())); ++i)\n   {\n      // Clear the buffer.\n      memset(buffer, 0, bufferSizeInBytes);\n\n      // Set the buffer rectangle.\n      ossimIrect bufferRect(theAreaOfInterest.ul().x,\n                            theAreaOfInterest.ul().y + i * tileHeight,\n                            theAreaOfInterest.ul().x + width - 1,\n                            theAreaOfInterest.ul().y + i * tileHeight +\n                            tileHeight - 1);\n\n      // Tile loop in the sample (width) direction.\n      for(ossim_uint32 j = 0; ((j < tilesWide)&&(!needsAborting())); ++j)\n      {\n         // Get the tile and copy it to the buffer.\n         ossimRefPtr<ossimImageData> id = theInputConnection->getNextTile();\n         if (!id)\n         {\n            ossimNotify(ossimNotifyLevel_WARN)\n                     << MODULE << \" ERROR:\"\n                     << \"Error returned writing tiff tile:  \" << tileNumber\n                     << \"\\nNULL Tile encountered\"\n                     << std::endl;\n            delete [] buffer;\n            return false;\n         }\n         id->unloadTile(buffer, bufferRect, OSSIM_BIP);\n         if(!theColorLutFlag&&!needsAborting())\n         {\n            id->computeMinMaxPix(minBands, maxBands);\n         }\n         ++tileNumber;\n      }\n\n      // Get the number of lines to write from the buffer.\n      ossim_uint32 linesToWrite = min(tileHeight, static_cast<ossim_uint32>(theAreaOfInterest.lr().y - bufferRect.ul().y + 1));\n\n      // Write the buffer out to disk.\n      ossim_uint32 row = static_cast<ossim_uint32>(bufferRect.ul().y -\n                                                   theAreaOfInterest.ul().y);\n      ossim_uint8* buf = buffer;\n      for (ossim_uint32 ii=0; ((ii<linesToWrite)&&(!needsAborting())); ++ii)\n      {\n         ossim_int32 status = TIFFWriteScanline(tiffPtr,\n                                                buf,\n                                                row,\n                                                0);\n         if (status == -1)\n         {\n            ossimNotify(ossimNotifyLevel_WARN)\n                     << MODULE << \" ERROR:\"\n                     << \"Error returned writing tiff scanline:  \" << row\n                     << std::endl;\n            setErrorStatus();\n            delete [] buffer;\n            return false;\n         }\n\n         ++row;  // Increment the line number.\n         buf += bytesInLine;\n\n      } // End of loop to write lines from buffer to tiff file.\n\n      double tile = tileNumber;\n      double numTiles = numberOfTiles;\n      setPercentComplete(tile / numTiles * 100);\n      if(needsAborting())\n      {\n         setPercentComplete(100);\n      }\n\n   } // End of loop in the line (height) direction.\n\n   if(!theColorLutFlag)\n   {\n      writeMinMaxTags(minBands, maxBands);\n   }\n\n   // Free the memory.\n   delete [] buffer;\n\n   if (traceDebug()) CLOG << \" Exited.\" << std::endl;\n\n   return true;\n}",
    "bool ossimTiffWriter::writeToStripsBandSep()\n{\n   static const char* const MODULE = \"ossimTiffWriter::writeToStripsBandSep\";\n   TIFF* tiffPtr = (TIFF*)theTif;\n\n   if (traceDebug()) CLOG << \" Entered.\" << std::endl;\n\n   // Start the sequence at the first tile.\n   theInputConnection->setToStartOfSequence();\n\n   ossim_uint32 bands = theInputConnection->getNumberOfOutputBands();\n   ossim_uint32 tilesWide = theInputConnection->getNumberOfTilesHorizontal();\n   ossim_uint32 tilesHigh = theInputConnection->getNumberOfTilesVertical();\n   ossim_uint32 tileHeight      = theInputConnection->getTileHeight();\n   ossim_uint32 numberOfTiles   = theInputConnection->getNumberOfTiles();\n   ossim_uint32 width           = theAreaOfInterest.width();\n   ossim_uint32 bytesInLine     =\n         ossim::scalarSizeInBytes(theInputConnection->getOutputScalarType()) *\n         width;\n\n   //---\n   // Buffer to hold one line x tileHeight\n   //---\n   ossim_uint32 bufferSizeInBytes = bytesInLine * tileHeight * bands;\n\n   unsigned char* buffer = new unsigned char[bufferSizeInBytes];\n\n   // Tile loop in height direction.\n   ossim_uint32 tileNumber = 0;\n   vector<ossim_float64> minBands;\n   vector<ossim_float64> maxBands;\n   for(ossim_uint32 i = 0; ((i < tilesHigh)&&(!needsAborting())); ++i)\n   {\n      // Clear the buffer.\n      memset(buffer, 0, bufferSizeInBytes);\n\n      // Set the buffer rectangle.\n      ossimIrect bufferRect(theAreaOfInterest.ul().x,\n                            theAreaOfInterest.ul().y + i * tileHeight,\n                            theAreaOfInterest.ul().x + width - 1,\n                            theAreaOfInterest.ul().y + i * tileHeight +\n                            tileHeight - 1);\n\n      // Tile loop in the sample (width) direction.\n      for(ossim_uint32 j = 0; ((j < tilesWide)&&(!needsAborting())); ++j)\n      {\n         // Get the tile and copy it to the buffer.\n         ossimRefPtr<ossimImageData> id = theInputConnection->getNextTile();\n         if (!id)\n         {\n            ossimNotify(ossimNotifyLevel_WARN)\n                     << MODULE << \" ERROR:\"\n                     << \"Error returned writing tiff tile:  \" << tileNumber\n                     << \"\\nNULL Tile encountered\"\n                     << std::endl;\n            delete [] buffer;\n            return false;\n         }\n         id->unloadTile(buffer, bufferRect, OSSIM_BIL);\n         if(!theColorLutFlag)\n         {\n            id->computeMinMaxPix(minBands, maxBands);\n         }\n         ++tileNumber;\n      }\n\n      // Get the number of lines to write from the buffer.\n      ossim_uint32 linesToWrite = min(tileHeight, static_cast<ossim_uint32>(theAreaOfInterest.lr().y - bufferRect.ul().y + 1));\n\n      // Write the buffer out to disk.\n      ossim_uint32 row = static_cast<ossim_uint32>(bufferRect.ul().y -\n                                                   theAreaOfInterest.ul().y);\n      ossim_uint8* buf = buffer;\n      for (ossim_uint32 ii=0; ((ii<linesToWrite)&&(!needsAborting())); ++ii)\n      {\n         for (ossim_uint32 band =0; ((band<bands)&&(!needsAborting())); ++band)\n         {\n            ossim_int32 status = TIFFWriteScanline(tiffPtr,\n                                                   buf,\n                                                   row,\n                                                   band);\n            if (status == -1)\n            {\n               ossimNotify(ossimNotifyLevel_WARN)\n                        << MODULE << \" ERROR:\"\n                        << \"Error returned writing tiff scanline:  \" << row\n                        << std::endl;\n               delete [] buffer;\n               return false;\n            }\n            buf += bytesInLine;\n         }\n\n         ++row;  // Increment the line number.\n\n      } // End of loop to write lines from buffer to tiff file.\n\n      double tile = tileNumber;\n      double numTiles = numberOfTiles;\n      setPercentComplete(tile / numTiles * 100);\n      if(needsAborting())\n      {\n         setPercentComplete(100);\n      }\n   } // End of loop in the line (height) direction.\n\n   if(!theColorLutFlag)\n   {\n      writeMinMaxTags(minBands, maxBands);\n   }\n\n   // Free the memory.\n   delete [] buffer;\n\n   if (traceDebug()) CLOG << \" Exited.\" << std::endl;\n\n   return true;\n}",
    "bool\tWriteGeoTiff(DEMGeo& inMap, const char * inFileName)\n{\n\tint result = -1;\n\tTIFF * tif;\n\tTIFFErrorHandler\twarnH = TIFFSetWarningHandler(IgnoreTiffWarnings);\n\tTIFFErrorHandler\terrH = TIFFSetErrorHandler(IgnoreTiffErrs);\n\n\ttif = XTIFFOpen(inFileName, \"w\");\n\n    if (tif == NULL) goto bail;\n\t\n\t{\n\t\tuint16 d = 16;\n\t\tuint16 format = SAMPLEFORMAT_INT;\n\t\t\n\t\tresult = TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, inMap.mWidth);\n\t\tresult = TIFFSetField(tif, TIFFTAG_IMAGELENGTH, inMap.mHeight);\n\t\tresult = TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 1);\n\t\tresult = TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, d);\n\t\tresult = TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, format);\n\t\tresult = TIFFSetField(tif,TIFFTAG_COMPRESSION,   COMPRESSION_DEFLATE);\n\t\tresult = TIFFSetField(tif, TIFFTAG_ZIPQUALITY, 9);\n\t\tresult = TIFFSetField(tif,TIFFTAG_PHOTOMETRIC,   PHOTOMETRIC_MINISBLACK);\n\t\tresult = TIFFSetField(tif,TIFFTAG_PLANARCONFIG,  PLANARCONFIG_CONTIG);\n\n\t\ttsize_t line_size = TIFFScanlineSize(tif);\n\t\ttdata_t aline = _TIFFmalloc(line_size);\n\n\t\tfor (int y = 0; y < inMap.mHeight; ++y)\n\t\t{\n\t\t\tswitch(format) {\n\t\t\tcase SAMPLEFORMAT_UINT:\n\t\t\t\tswitch(d) {\n\t\t\t\tcase 8:\n\t\t\t\t\tcopy_from_scanline<unsigned char>((unsigned char *) aline, y, inMap);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 16:\n\t\t\t\t\tcopy_from_scanline<unsigned short>((unsigned short *) aline, y, inMap);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 32:\n\t\t\t\t\tcopy_from_scanline<unsigned int>((unsigned int *) aline, y, inMap);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tprintf(\"TIFF error: unsupported unsigned int sample depth: %d\\n\", d);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase SAMPLEFORMAT_INT:\n\t\t\t\tswitch(d) {\n\t\t\t\tcase 8:\n\t\t\t\t\tcopy_from_scanline<char>((char *) aline, y, inMap);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 16:\n\t\t\t\t\tcopy_from_scanline<short>((short *) aline, y, inMap);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 32:\n\t\t\t\t\tcopy_from_scanline<int>((int *) aline, y, inMap);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tprintf(\"TIFF error: unsupported signed int sample depth: %d\\n\", d);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase SAMPLEFORMAT_IEEEFP:\n\t\t\t\tswitch(d) {\n\t\t\t\tcase 32:\n\t\t\t\t\tcopy_from_scanline<float>((float *) aline, y, inMap);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 64:\n\t\t\t\t\tcopy_from_scanline<double>((double *) aline, y, inMap);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tprintf(\"TIFF error: unsupported floating point sample depth: %d\\n\", d);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"TIFF error: unsupported pixel format %d\\n\", format);\n\t\t\t\tbreak;\t\t\t\n\t\t\t}\n\n\t\t\tresult = TIFFWriteScanline(tif, aline, y, 0);\n\t\t\tif (result == -1) { printf(\"Tiff error in read.\\n\"); break; }\n\n\t\t}\n\t\t_TIFFfree(aline);\n\n\tdouble tiepoints[6]={0};\n\tdouble pixscale[3]={0};\n\ttiepoints[3] = inMap.mWest;\n\ttiepoints[4] = inMap.mNorth;\n\tpixscale[0] = (inMap.mEast  - inMap.mWest ) / (double) (inMap.mWidth - inMap.mPost);\n\tpixscale[1] = (inMap.mNorth - inMap.mSouth) / (double) (inMap.mHeight - inMap.mPost);\n\t\t\n\tTIFFSetField(tif,TIFFTAG_GEOTIEPOINTS, 6,tiepoints);\n\tTIFFSetField(tif,TIFFTAG_GEOPIXELSCALE, 3,pixscale);\n\n\tGTIF * gtif = GTIFNew(tif);\n\n\t// Ben says: this seems to be the minimum amount of stuff we have to write (so far) to make a happy GeoTIFF file...\n\tGTIFKeySet(gtif, GTModelTypeGeoKey, TYPE_SHORT, 1, ModelTypeGeographic);\n\tGTIFKeySet(gtif, GTRasterTypeGeoKey, TYPE_SHORT, 1, inMap.mPost ? RasterPixelIsPoint : RasterPixelIsArea);\n\tGTIFKeySet(gtif, GeographicTypeGeoKey, TYPE_SHORT, 1,  GCSE_WGS84);\n\tGTIFKeySet(gtif, GeogGeodeticDatumGeoKey, TYPE_SHORT, 1, Datum_WGS84);\n\n\n\n\tGTIFWriteKeys(gtif);\n\tGTIFFree(gtif);\n\n\n\n\t\tXTIFFClose(tif);\n\n\t\tTIFFSetWarningHandler(warnH);\n\t\tTIFFSetErrorHandler(errH);\n\t\treturn result != -1;\n\t}\nbail:\n\tTIFFSetWarningHandler(warnH);\n\tTIFFSetErrorHandler(errH);\n\treturn false;\n\n}",
    "int WriteGeotiff_real(char *filename, void *buffer, size_t width, size_t height, double scale, double minX, double maxY, int projection, int zone, int NS_hemisphere, int data_type, bool doRound)\n{\n    TIFF *tif;  /* TIFF-level descriptor */\n    GTIF *gtif; /* GeoKey-level descriptor */\n    size_t bytes = 0; /* Size of data type for computing buffer offset */\n\n    switch (data_type)\n    {\n        case FLOAT:\n            bytes = sizeof(float);\n            break;\n        case UCHAR:\n            bytes = sizeof(unsigned char);\n            break;\n        case UINT16:\n            bytes = sizeof(uint16);\n            break;\n        default:\n            printf(\"unrecognized data type: %d\\n\", data_type);\n            break;\n    }\n\n    if (bytes == 0)\n    {\n        // Unknown data type\n        return -1;\n    }\n\n    long int int_mem = (long)(bytes*height*width);\n    double tif_mem = (double)(int_mem/1024.0/1024.0/1024.0);\n    printf(\"tif mem %f\\n\",tif_mem);\n\n    tif = XTIFFOpen(filename, \"w8\");\n    if (!tif)\n    {\n        printf(\"WriteGeotiff failed in XTIFFOpen\\n\");\n        return -1;\n    }\n\n    gtif = GTIFNew(tif);\n    if (!gtif)\n    {\n        printf(\"WriteGeotiff failed in GTIFNew\\n\");\n        XTIFFClose(tif);\n        return -1;\n    }\n\n    SetUpTIFFDirectory(tif, width, height, scale, minX, maxY, data_type);\n    SetUpGeoKeys(gtif, projection, zone, NS_hemisphere);\n\n    // scanline_buffer is needed because TIFFWriteScanline modifies the buffer if PREDICTOR != 1.\n    void *scanline_buffer = malloc(bytes * width);\n    if (!scanline_buffer) {\n        printf(\"WriteGeotiff failed in malloc scanline_buffer\\n\");\n        return -1;\n    }\n\n    for (int row=0; row<height; row++)\n    {\n        memcpy(scanline_buffer, ((char *)buffer) + (bytes * row * width), bytes * width);\n\n        // If requested, round values to nearest 1/128\n        if (doRound && data_type == FLOAT) {\n            for(size_t i = 0 ; i < width; i++)\n            {\n                float &val = ((float*)scanline_buffer)[i];\n                val = std::round(val*128) / 128;\n            }\n        }\n\n        if (TIFFWriteScanline(tif, scanline_buffer, row, 0) == -1) // TODO: TIFFWriteScanline may return -1 on failure:\n        {\n            TIFFError(\"WriteGeotiff_DEM\",\"failure in WriteScanline on row %d\\n\", row);\n        }\n    }\n\n    free(scanline_buffer);\n    \n    GTIFWriteKeys(gtif);\n    GTIFFree(gtif);\n    XTIFFClose(tif);\n    return 0;\n}",
    "JNIEXPORT jboolean JNICALL Java_org_beyka_tiffbitmapfactory_TiffSaver_save\n    (JNIEnv *env, jclass clazz, jstring filePath, jint fileDescriptor, jobject bitmap, jobject options, jboolean append) {\n\n__android_log_write(ANDROID_LOG_ERROR, \"NativeTiffSaver\", \"Test Error here\");\n\n        //Options class\n        jclass jSaveOptionsClass = env->FindClass(\"org/beyka/tiffbitmapfactory/TiffSaver$SaveOptions\");\n\n        //How much memory can we use?\n        jfieldID availableMemoryFieldID = env->GetFieldID(jSaveOptionsClass,\n                                                                          \"inAvailableMemory\",\n                                                                          \"J\");\n        unsigned long inAvailableMemory = env->GetLongField(options, availableMemoryFieldID);\n\n        //If we need to throw exceptions\n        jfieldID throwExceptionFieldID = env->GetFieldID(jSaveOptionsClass,\n                                                                           \"inThrowException\",\n                                                                           \"Z\");\n        jboolean throwException = env->GetBooleanField(options, throwExceptionFieldID);\n\n        // check is bitmap null\n        if (bitmap == NULL) {\n            const char *message = \"Bitmap is null\\0\";\n            LOGE(message);\n            if (throwException) {\n                jstring jmessage = env->NewStringUTF(message);\n                throw_decode_file_exception(env, filePath, jmessage);\n                env->DeleteLocalRef(jmessage);\n            }\n            return JNI_FALSE;\n        }\n\n\n        jclass bitmapClass = env->FindClass(\"android/graphics/Bitmap\");\n\n        //check is bitmap recycled\n        jmethodID isRecycledMethodid = env->GetMethodID(bitmapClass, \"isRecycled\", \"()Z\");\n        jboolean isRecycled = env->CallBooleanMethod(bitmap, isRecycledMethodid);\n        if (isRecycled) {\n            const char *message = \"Bitmap is recycled\\0\";\n            LOGE(message);\n            if (throwException) {\n                jstring jmessage = env->NewStringUTF(message);\n                throw_decode_file_exception(env, filePath, jmessage);\n                env->DeleteLocalRef(jmessage);\n            }\n            return JNI_FALSE;\n        }\n\n        //Read pixels from bitmap\n\n        AndroidBitmapInfo  info;\n        void* pixels;\n        int ret;\n\n\n\n        if ((ret = AndroidBitmap_getInfo(env, bitmap, &info)) < 0) {\n            LOGE(\"AndroidBitmap_getInfo() failed ! error=\");\n            return JNI_FALSE;\n        }\n\n        if ((ret = AndroidBitmap_lockPixels(env, bitmap, &pixels)) < 0) {\n                LOGE(\"AndroidBitmap_lockPixels() failed ! error=\");\n                return JNI_FALSE;\n        }\n\n        uint32 img_width = info.width;\n        uint32 img_height= info.height;\n\n/*\n        //Get array of jint from jintArray\n        jint *c_array;\n        c_array = env->GetIntArrayElements(img, NULL);\n        if (c_array == NULL) {\n            //if array is null - nothing to save\n            LOGE(\"array is null\");\n            return JNI_FALSE;\n        }\n*/\n\n\n        //Get options\n\n        //Get compression mode from options object\n        jfieldID gOptions_CompressionModeFieldID = env->GetFieldID(jSaveOptionsClass,\n        \"compressionScheme\",\n        \"Lorg/beyka/tiffbitmapfactory/CompressionScheme;\");\n        jobject compressionMode = env->GetObjectField(options, gOptions_CompressionModeFieldID);\n\n        jclass compressionModeClass = env->FindClass(\n        \"org/beyka/tiffbitmapfactory/CompressionScheme\");\n        jfieldID ordinalFieldID = env->GetFieldID(compressionModeClass, \"ordinal\", \"I\");\n        jint compressionInt = env->GetIntField(compressionMode, ordinalFieldID);\n\n        //Get image orientation from options object\n        jfieldID gOptions_OrientationFieldID = env->GetFieldID(jSaveOptionsClass,\n        \"orientation\",\n        \"Lorg/beyka/tiffbitmapfactory/Orientation;\");\n        jobject orientation = env->GetObjectField(options, gOptions_OrientationFieldID);\n\n        jclass orientationClass = env->FindClass(\n        \"org/beyka/tiffbitmapfactory/Orientation\");\n        jfieldID orientationOrdinalFieldID = env->GetFieldID(orientationClass, \"ordinal\", \"I\");\n        jint orientationInt = env->GetIntField(orientation, orientationOrdinalFieldID);\n        env->DeleteLocalRef(orientationClass);\n\n        // variables for resolution\n        jfieldID gOptions_xResolutionFieldID = env->GetFieldID(jSaveOptionsClass, \"xResolution\", \"F\");\n        float xRes = env->GetFloatField(options, gOptions_xResolutionFieldID);\n        jfieldID gOptions_yResolutionFieldID = env->GetFieldID(jSaveOptionsClass, \"yResolution\", \"F\");\n        float yRes = env->GetFloatField(options, gOptions_yResolutionFieldID);\n        jfieldID gOptions_resUnitFieldID = env->GetFieldID(jSaveOptionsClass,\n                                                           \"resUnit\",\n                                                           \"Lorg/beyka/tiffbitmapfactory/ResolutionUnit;\");\n        jobject resUnitObject = env->GetObjectField(options, gOptions_resUnitFieldID);\n        //Get res int from resUnitObject\n        jclass resolutionUnitClass = env->FindClass(\"org/beyka/tiffbitmapfactory/ResolutionUnit\");\n        jfieldID resUnitOrdinalFieldID = env->GetFieldID(resolutionUnitClass, \"ordinal\", \"I\");\n        uint16 resUnit = env->GetIntField(resUnitObject, resUnitOrdinalFieldID);\n        env->DeleteLocalRef(resolutionUnitClass);\n\n        //Get author field if exist\n        jfieldID gOptions_authorFieldID = env->GetFieldID(jSaveOptionsClass, \"author\", \"Ljava/lang/String;\");\n        jstring jAuthor = (jstring)env->GetObjectField(options, gOptions_authorFieldID);\n        const char *authorString = NULL;\n        if (jAuthor) {\n            authorString = env->GetStringUTFChars(jAuthor, 0);\n            LOGIS(\"Author: \", authorString);\n        }\n\n        //Get copyright field if exist\n        jfieldID gOptions_copyrightFieldID = env->GetFieldID(jSaveOptionsClass, \"copyright\", \"Ljava/lang/String;\");\n        jstring jCopyright = (jstring)env->GetObjectField(options, gOptions_copyrightFieldID);\n        const char *copyrightString = NULL;\n        if (jCopyright) {\n            copyrightString = env->GetStringUTFChars(jCopyright, 0);\n            LOGIS(\"Copyright: \", copyrightString);\n        }\n\n        //Get image description field if exist\n        jfieldID gOptions_imgDescrFieldID = env->GetFieldID(jSaveOptionsClass, \"imageDescription\", \"Ljava/lang/String;\");\n        jstring jImgDescr = (jstring)env->GetObjectField(options, gOptions_imgDescrFieldID);\n        const char *imgDescrString = NULL;\n        if (jImgDescr) {\n            imgDescrString = env->GetStringUTFChars(jImgDescr, 0);\n            LOGIS(\"Image Description: \", imgDescrString);\n        }\n\n        //Get software name and number from buildconfig\n        jclass jBuildConfigClass = env->FindClass(\n                \"org/beyka/tiffbitmapfactory/BuildConfig\");\n        jfieldID softwareNameFieldID = env->GetStaticFieldID(jBuildConfigClass, \"softwarename\", \"Ljava/lang/String;\");\n        jstring jsoftwarename = (jstring)env->GetStaticObjectField(jBuildConfigClass, softwareNameFieldID);\n        const char *softwareNameString = NULL;\n        if (jsoftwarename) {\n            softwareNameString = env->GetStringUTFChars(jsoftwarename, 0);\n            LOGIS(\"Software Name: \", softwareNameString);\n        }\n\n        //Get android version\n        jclass build_class = env->FindClass(\"android/os/Build$VERSION\");\n        jfieldID releaseFieldID = env->GetStaticFieldID(build_class, \"RELEASE\", \"Ljava/lang/String;\");\n        jstring jrelease = (jstring)env->GetStaticObjectField(build_class, releaseFieldID);\n        const char *releaseString = NULL;\n        if (jrelease) {\n            releaseString = env->GetStringUTFChars(jrelease, 0);\n            LOGIS(\"Release: \", releaseString);\n        }\n        char *fullReleaseName = concat(\"Android \", releaseString);\n        LOGIS(\"Full Release: \", fullReleaseName);\n\n\n        uint32 pixelsBufferSize = img_width * img_height;\n        uint32* img = NULL;\n        int tmpImgArrayCreated = 0;\n        switch (info.format) {\n            case ANDROID_BITMAP_FORMAT_RGBA_8888:\n            {\n                LOGI(\"ANDROID_BITMAP_FORMAT_RGBA_8888\");\n                img = (uint32*)pixels;\n                break;\n            }\n            case ANDROID_BITMAP_FORMAT_RGBA_4444:\n            {\n                LOGI(\"ANDROID_BITMAP_FORMAT_RGBA_4444\");\n                uint16_t* tmp4444 = (uint16_t*)pixels;\n                img = (uint32*) malloc(sizeof(uint32) * pixelsBufferSize);\n                for (int x = 0; x < img_width; x++) {\n                    for (int y = 0; y < img_height; y++) {\n                        uint16_t pix = tmp4444[y * img_width + x];\n                        int alpha = colorMask & pix >> 16;\n                        int red = colorMask & pix >> 8;\n                        int green = colorMask & pix >> 4;\n                        int blue = colorMask & pix;\n                        uint32 crPix = (alpha << 24) | (blue << 16) | (green << 8) | (red);\n                        img[y * img_width + x] = crPix;\n                    }\n                }\n                tmpImgArrayCreated = 1;\n                break;\n            }\n            case ANDROID_BITMAP_FORMAT_RGB_565:\n            {\n                LOGI(\"ANDROID_BITMAP_FORMAT_RGB_565\");\n                uint16_t* tmp565 = (uint16_t*)pixels;\n                img = (uint32*) malloc(sizeof(uint32) * pixelsBufferSize);\n                for (int x = 0; x < img_width; x++) {\n                    for (int y = 0; y < img_height; y++) {\n                        uint16_t pix = tmp565[y * img_width + x];\n                        unsigned char red = 0b11111 & pix >> 11;\n                        unsigned char green = 0b111111 & pix >> 5;\n                        unsigned char blue = 0b11111 & pix;\n                        uint32 crPix = (blue << 3 << 16) | (green << 2 << 8) | (red<<3);\n                        img[y * img_width + x] = crPix;\n                    }\n                }\n                tmpImgArrayCreated = 1;\n                break;\n            }\n            case ANDROID_BITMAP_FORMAT_A_8:\n            {\n                LOGI(\"ANDROID_BITMAP_FORMAT_A_8\");\n                uint8_t* tmp8 = (uint8_t*)pixels;\n                img = (uint32*) malloc(sizeof(uint32) * pixelsBufferSize);\n                for (int x = 0; x < img_width; x++) {\n                    for (int y = 0; y < img_height; y++) {\n                        uint8_t pix = tmp8[y * img_width + x];\n                        img[y * img_width + x] = pix << 24;\n                    }\n                }\n                tmpImgArrayCreated = 1;\n                break;\n            }\n        }\n\n/*\n        int pixelsBufferSize = img_width * img_height;\n        uint32 *array = (uint32 *) malloc(sizeof(uint32) * pixelsBufferSize);\n        if (!array) {\n            throw_not_enought_memory_exception(env, sizeof(uint32) * pixelsBufferSize, 0);//todo change for estimating memory\n            return JNI_FALSE;\n        }\n\n        uint32_t* img = (uint32_t*)pixels;\n        for (int y = 0; y < img_height; y++) {\n            for (int x = 0; x < img_width; x++) {\n                uint32_t pix = img[y * img_width + x];\n                int alpha = colorMask & pix >> 24;\n                int red = colorMask & pix >> 16;\n                int green = colorMask & pix >> 8;\n                int blue = colorMask & pix;\n                uint32 crPix = (alpha << 24) | (blue << 16) | (green << 8) | (red);\n                array[y * img_width + x] = crPix;\n            }\n        }\n*/\n\n/*\n        for (int i = 0; i < img_width; i++) {\n            for (int j = 0; j < img_height; j++) {\n\n                uint32 crPix = getPixel(pixels,info,i,j);\n\n                //jint crPix = c_array[j * img_width + i];\n                int alpha = colorMask & crPix >> 24;\n                int red = colorMask & crPix >> 16;\n                int green = colorMask & crPix >> 8;\n                int blue = colorMask & crPix;\n\n                crPix = (alpha << 24) | (blue << 16) | (green << 8) | (red);\n                array[j * img_width + i] = crPix;\n            }\n        }\n*/\n        TIFF *output_image;\n\n        LOGII(\"Check file descripor\", fileDescriptor);\n\n        const char *strPath = NULL;\n        if (fileDescriptor == -1) {\n            strPath = env->GetStringUTFChars(filePath, 0);\n            LOGIS(\"nativeTiffOpenForSave\", strPath);\n            int mode = O_RDWR | O_CREAT | O_TRUNC | 0;\n            if (append) {\n                mode = O_RDWR | O_CREAT;\n            }\n            fileDescriptor = open(strPath, mode, 0666);\n            if (fileDescriptor < 0) {\n                throw_cant_open_file_exception(env, filePath);\n                return JNI_FALSE;\n            }\n        }\n\n        // Open the TIFF file\n        if (!append) {\n            if ((output_image = TIFFFdOpen(fileDescriptor, \"\", \"w\")) == NULL) {\n                LOGE(\"Unable to write tif file\");\n                if (strPath) {\n                    throw_cant_open_file_exception(env, filePath);\n                } else {\n                    throw_cant_open_file_exception_fd(env, fileDescriptor);\n                }\n                return JNI_FALSE;\n            }\n        } else {\n            if ((output_image = TIFFFdOpen(fileDescriptor, \"\", \"a\")) == NULL) {\n                LOGE(\"Unable to write tif file\");\n                if (strPath) {\n                    throw_cant_open_file_exception(env, filePath);\n                } else {\n                    throw_cant_open_file_exception_fd(env, fileDescriptor);\n                return JNI_FALSE;\n                }\n            }\n        }\n\n        TIFFSetField(output_image, TIFFTAG_IMAGEWIDTH, img_width);\n        TIFFSetField(output_image, TIFFTAG_IMAGELENGTH, img_height);\n        TIFFSetField(output_image, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n        TIFFSetField(output_image, TIFFTAG_COMPRESSION, compressionInt);\n        TIFFSetField(output_image, TIFFTAG_ORIENTATION, orientationInt);\n        TIFFSetField(output_image, TIFFTAG_XRESOLUTION, xRes);\n        TIFFSetField(output_image, TIFFTAG_YRESOLUTION, yRes);\n        TIFFSetField(output_image, TIFFTAG_RESOLUTIONUNIT, resUnit);\n\n        if (compressionInt == COMPRESSION_CCITTRLE ||compressionInt == COMPRESSION_CCITTFAX3 || compressionInt == COMPRESSION_CCITTFAX4) {\n            TIFFSetField(output_image, TIFFTAG_BITSPERSAMPLE,\t1);\n            TIFFSetField(output_image, TIFFTAG_SAMPLESPERPIXEL,\t1);\n            TIFFSetField(output_image, TIFFTAG_ROWSPERSTRIP, 1);\n            TIFFSetField(output_image, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n            TIFFSetField(output_image, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);\n        } else {\n            TIFFSetField(output_image, TIFFTAG_BITSPERSAMPLE, 8);\n            TIFFSetField(output_image, TIFFTAG_SAMPLESPERPIXEL, 4);\n            TIFFSetField(output_image, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n        }\n\n        //Write additiona tags\n        //CreationDate tag\n        char *date = getCreationDate();\n        TIFFSetField(output_image, TIFFTAG_DATETIME, date);\n        free(date);\n        //Host system\n        TIFFSetField(output_image, TIFFTAG_HOSTCOMPUTER, fullReleaseName);\n\n        //software\n        if (softwareNameString) {\n            TIFFSetField(output_image, TIFFTAG_SOFTWARE, softwareNameString);\n        }\n        //image description\n        if (imgDescrString) {\n            TIFFSetField(output_image, TIFFTAG_IMAGEDESCRIPTION, imgDescrString);\n        }\n        //author\n        if (authorString) {\n            TIFFSetField(output_image, TIFFTAG_ARTIST, authorString);\n        }\n        //copyright\n        if (copyrightString) {\n            TIFFSetField(output_image, TIFFTAG_COPYRIGHT, copyrightString);\n        }\n\n        // Write the information to the file\n        if (compressionInt == COMPRESSION_CCITTRLE || compressionInt == COMPRESSION_CCITTFAX3 || compressionInt == COMPRESSION_CCITTFAX4) {\n            unsigned char *bilevel = convertArgbToBilevel(img, img_width, img_height);\n            int compressedWidth = (img_width/8 + 0.5);\n            for (int i = 0; i < img_height; i++) {\n                TIFFWriteEncodedStrip(output_image, i, &bilevel[i * compressedWidth], (compressedWidth));\n            }\n            free(bilevel);\n        } else if (compressionInt == COMPRESSION_JPEG) {\n            for (int row = 0; row < img_height; row++) {\n                TIFFWriteScanline(output_image, &img[row * img_width], row, 0);\n            }\n        } else {\n            TIFFSetField(output_image, TIFFTAG_ROWSPERSTRIP, 1);\n            for (int row = 0; row < img_height; row++) {\n                TIFFWriteEncodedStrip(output_image, row, &img[row * img_width], img_width * sizeof(uint32));\n                //TIFFWriteScanline(output_image, &img[row * img_width], row, 0);\n            }\n        }\n       ret = TIFFWriteDirectory(output_image);\n        LOGII(\"ret = \", ret);\n\n        // Close the file\n        TIFFClose(output_image);\n/*\n        //free temp array\n        free (array);\n*/\n        if (tmpImgArrayCreated) {\n            free(img);\n        }\n\n        //Now we don't need android pixels, so unlock\n                 AndroidBitmap_unlockPixels(env, bitmap);\n\n        //Remove variables\n        if (releaseString) {\n            env->ReleaseStringUTFChars(jrelease, releaseString);\n        }\n        free(fullReleaseName);\n        if (softwareNameString) {\n            env->ReleaseStringUTFChars(jsoftwarename, softwareNameString);\n        }\n        if (imgDescrString) {\n            env->ReleaseStringUTFChars(jImgDescr, imgDescrString);\n        }\n        if (authorString) {\n            env->ReleaseStringUTFChars(jAuthor, authorString);\n        }\n        if (copyrightString) {\n            env->ReleaseStringUTFChars(jCopyright, copyrightString);\n        }\n        if (strPath) {\n            env->ReleaseStringUTFChars(filePath, strPath);\n        }\n//        env->ReleaseIntArrayElements(img, c_array, 0);\n\n        if (ret == -1) return JNI_FALSE;\n        return JNI_TRUE;\n    }",
    "jboolean BmpToTiffConverter::convert()\n{\n    LOGI(\"CONVERT\");\n    readOptions();\n\n    if(outFd < 0) {\n        //open tiff file for writing or appending\n        const char *outCPath = NULL;\n        outCPath = env->GetStringUTFChars(outPath, 0);\n        LOGIS(\"OUT path\", outCPath);\n        LOGIS(\"nativeTiffOpenForSave\", outCPath);\n        int mode = O_RDWR | O_CREAT | O_TRUNC | 0;\n        if (appendTiff) {\n            mode = O_RDWR | O_CREAT;\n        }\n         outFd = open(outCPath, mode, 0666);\n         if (outFd < 0) {\n            throw_cant_open_file_exception(env, outPath);\n            env->ReleaseStringUTFChars(outPath, outCPath);\n            return JNI_FALSE;\n         }\n         env->ReleaseStringUTFChars(outPath, outCPath);\n    }\n\n    if (!appendTiff) {\n        if ((tiffImage = TIFFFdOpen(outFd, \"\", \"w\")) == NULL) {\n            LOGE(\"Unable to open tif file\");\n            if (throwException) {\n                throw_cant_open_file_exception_fd(env, outFd);\n            }\n            return JNI_FALSE;\n        }\n    } else {\n         if ((tiffImage = TIFFFdOpen(outFd, \"\", \"a\")) == NULL) {\n            LOGE(\"Unable to open tif file\");\n            if (throwException) {\n                throw_cant_open_file_exception_fd(env, outFd);\n            }\n            return JNI_FALSE;\n         }\n    }\n\n    //open bmp file fow reading\n    if(inFd < 0) {\n        const char *inCPath = NULL;\n        inCPath = env->GetStringUTFChars(inPath, 0);\n        LOGIS(\"IN path\", inCPath);\n        int mode = O_RDONLY;\n        inFd = open(inCPath, mode, 0666);\n        if (inFd < 0) {\n            LOGES(\"Can\\'t open in file\", inCPath);\n            throw_cant_open_file_exception(env, inPath);\n            env->ReleaseStringUTFChars(inPath, inCPath);\n            return JNI_FALSE;\n        }\n        env->ReleaseStringUTFChars(inPath, inCPath);\n    }\n\n    //Read header of bitmap file\n    readHeaders();\n\n    //Check is file is BMP image\n    bool is_bmp = !strncmp( (const char*)&bmp->bfType, \"BM\", 2 );\n    if (!is_bmp) {\n        LOGE(\"Not bmp file\");\n        if (throwException) {\n            throw_cant_open_file_exception_fd(env, inFd);\n        }\n        return JNI_FALSE;\n    }\n\n    //check is bitmap has 24  bit per pixel. other format not supported\n    if (inf->biBitCount != 16 && inf->biBitCount != 24 && inf->biBitCount != 32 && inf->biBitCount != 0) {\n        LOGE(\"Support only 24bpp bitmaps\");\n        if (throwException) {\n            throw_cant_open_file_exception_fd(env, inFd);\n        }\n        return JNI_FALSE;\n    }\n    LOGII(\"Bits per pixel\", inf->biBitCount);\n\n    int compression = inf->biCompression;\n    LOGII(\"compression\", inf->biCompression);\n    for (int i = 0; i < 3; i++) {\n        LOGII(\"mask\", inf->biPalete[i]);\n    }\n\n    //Component per pixel will be always 4. Alpha will be always 0xff\n    int componentsPerPixel = 4;//inf->biBitCount / 8;\n\n    int width = inf->biWidth;\n    int height = inf->biHeight;\n    LOGII(\"width\", width);\n    LOGII(\"height\", height);\n\n    //Create tiff structure\n    TIFFSetField(tiffImage, TIFFTAG_IMAGEWIDTH, width);\n    TIFFSetField(tiffImage, TIFFTAG_IMAGELENGTH, height);\n    TIFFSetField(tiffImage, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    TIFFSetField(tiffImage, TIFFTAG_COMPRESSION, compressionInt);\n    TIFFSetField(tiffImage, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n    TIFFSetField(tiffImage, TIFFTAG_XRESOLUTION, xRes);\n    TIFFSetField(tiffImage, TIFFTAG_YRESOLUTION, yRes);\n    TIFFSetField(tiffImage, TIFFTAG_RESOLUTIONUNIT, resUnit);\n\n    if (compressionInt == COMPRESSION_CCITTRLE || compressionInt == COMPRESSION_CCITTFAX3 || compressionInt == COMPRESSION_CCITTFAX4) {\n        TIFFSetField(tiffImage, TIFFTAG_BITSPERSAMPLE,\t1);\n        TIFFSetField(tiffImage, TIFFTAG_SAMPLESPERPIXEL,\t1);\n        TIFFSetField(tiffImage, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n        TIFFSetField(tiffImage, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);\n    } else {\n        TIFFSetField(tiffImage, TIFFTAG_BITSPERSAMPLE, 8);\n        TIFFSetField(tiffImage, TIFFTAG_SAMPLESPERPIXEL, componentsPerPixel);\n        TIFFSetField(tiffImage, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n    }\n\n    //creation date\n    char *date = getCreationDate();\n    TIFFSetField(tiffImage, TIFFTAG_DATETIME, date);\n    free(date);\n    //image description\n    if (cdescription) {\n        TIFFSetField(tiffImage, TIFFTAG_IMAGEDESCRIPTION, cdescription);\n    }\n    //software tag\n    if (csoftware) {\n        TIFFSetField(tiffImage, TIFFTAG_SOFTWARE, csoftware);\n    }\n\n    //progress reporter\n    jlong total = width * height;\n    sendProgress(0, total);\n\n    int rowSize = width * componentsPerPixel;\n    //Calculate row per strip\n    //maximum size for strip should be less than 2Mb if memory available\n    unsigned long MB2 = (availableMemory == -1 || availableMemory > 3 * 1024 * 1024) ? 2 * 1024 * 1024 : width * 4;\n    int rowPerStrip = MB2/rowSize;\n    if (rowPerStrip >= height) {\n        rowPerStrip = height / 4;\n    }\n    if (rowPerStrip < 1) rowPerStrip = 1;\n    LOGII(\"rowPerStrip\", rowPerStrip);\n\n    unsigned long estimateMem = rowPerStrip * width * 4 * 2;//need 2 buffers for read data from bitmap. Check getPixelsFromBmp method\n\n    if (compressionInt == COMPRESSION_JPEG) {\n        estimateMem += width * sizeof(uint32);//temp array for writing JPEG lines\n        estimateMem += width * sizeof(uint32);//temp array for fliping bitmap data in getPixelsFromBmp method\n    } else if (compressionInt == COMPRESSION_CCITTRLE || compressionInt == COMPRESSION_CCITTFAX3 || compressionInt == COMPRESSION_CCITTFAX4) {\n        estimateMem += (width/8 + 0.5) * rowPerStrip; // bilevel array\n    } else {\n        estimateMem += 0;\n    }\n    LOGII(\"estimateMem\", estimateMem);\n    if (estimateMem > availableMemory && availableMemory != -1) {\n        LOGEI(\"Not enough memory\", availableMemory);\n        if (throwException) {\n            throw_not_enought_memory_exception(env, availableMemory, estimateMem);\n        }\n        return JNI_FALSE;\n    }\n\n    if (checkStop()) {\n        conversion_result = JNI_FALSE;\n        return conversion_result;\n    }\n\n    int ret;\n\n    if (compressionInt == COMPRESSION_CCITTRLE || compressionInt == COMPRESSION_CCITTFAX3 || compressionInt == COMPRESSION_CCITTFAX4) {\n        TIFFSetField(tiffImage, TIFFTAG_ROWSPERSTRIP, rowPerStrip);\n        int compressedWidth = (width/8 + 0.5);\n        for (int y = 0; y < height; y+=rowPerStrip) {\n            if (checkStop()) {\n                conversion_result = JNI_FALSE;\n                return conversion_result;\n            }\n            int rowToRead = rowPerStrip;\n            if (rowToRead + y >= height) {\n                rowToRead = height - y;\n            }\n            sendProgress(y * width, total);\n            uint32 *pixels = getPixelsFromBmp(y, rowToRead);\n            unsigned char *bilevel = convertArgbToBilevel(pixels, width, rowToRead);\n            free(pixels);\n            ret = TIFFWriteEncodedStrip(tiffImage, y/rowToRead, bilevel, compressedWidth * sizeof(unsigned char) * rowToRead);\n            free(bilevel);\n        }\n    } else if (compressionInt == COMPRESSION_JPEG) {\n        for (int ys = 0; ys < height; ys+=rowPerStrip) {\n        if (checkStop()) {\n            return JNI_FALSE;\n        }\n        int rowToRead = rowPerStrip;\n        if (rowToRead + ys >= height) {\n            rowToRead = height - ys;\n        }\n        sendProgress(ys * width, total);\n        uint32 *pixels = getPixelsFromBmp(ys, rowToRead);\n        uint32 *pixelsline = new uint32[width];\n        for (int k = 0; k < rowToRead; k++) {\n            memcpy(pixelsline, &pixels [k * width], width * sizeof(uint32));\n            ret = TIFFWriteScanline(tiffImage, pixelsline, ys + k, 0);\n        }\n        delete[] pixelsline;\n        free(pixels);\n        }\n    } else {\n        TIFFSetField(tiffImage, TIFFTAG_ROWSPERSTRIP, rowPerStrip);\n        for (int y = 0; y < height; y+=rowPerStrip) {\n            if (checkStop()) {\n                return JNI_FALSE;\n            }\n            int rowToRead = rowPerStrip;\n            if (rowToRead + y >= height) {\n                rowToRead = height - y;\n            }\n            //LOGII(\"rowToRead\", rowToRead);\n            sendProgress(y * width, total);\n            uint32 *pixels = getPixelsFromBmp(y, rowToRead);\n            TIFFWriteEncodedStrip(tiffImage, y/rowPerStrip, pixels, width * sizeof(uint32) * rowToRead);\n            free(pixels);\n        }\n    }\n\n    ret = TIFFWriteDirectory(tiffImage);\n    LOGII(\"ret = \", ret);\n\n    sendProgress(total, total);\n    conversion_result = JNI_TRUE;\n    return conversion_result;\n}",
    "jboolean JpgToTiffConverter::convert()\n{\n    readOptions();\n\n    if(outFd < 0) {\n        //open tiff file for writing or appending\n        const char *outCPath = NULL;\n        outCPath = env->GetStringUTFChars(outPath, 0);\n        LOGIS(\"OUT path\", outCPath);\n        LOGIS(\"nativeTiffOpenForSave\", outCPath);\n        int mode = O_RDWR | O_CREAT | O_TRUNC | 0;\n        if (appendTiff) {\n            mode = O_RDWR | O_CREAT;\n        }\n        outFd = open(outCPath, mode, 0666);\n        if (outFd < 0) {\n            throw_cant_open_file_exception(env, outPath);\n            env->ReleaseStringUTFChars(outPath, outCPath);\n            return JNI_FALSE;\n        }\n        env->ReleaseStringUTFChars(outPath, outCPath);\n    }\n\n    if (!appendTiff) {\n        if ((tiffImage = TIFFFdOpen(outFd, \"\", \"w\")) == NULL) {\n        LOGE(\"Unable to open tif file\");\n            if (throwException) {\n                throw_cant_open_file_exception_fd(env, outFd);\n            }\n            return JNI_FALSE;\n        }\n    } else {\n        if ((tiffImage = TIFFFdOpen(outFd, \"\", \"a\")) == NULL) {\n            LOGE(\"Unable to open tif file\");\n            if (throwException) {\n                throw_cant_open_file_exception_fd(env, outFd);\n            }\n            return JNI_FALSE;\n        }\n    }\n\n    //open jpg file fow reading\n    if (inFd < 0) {\n        const char *inCPath = NULL;\n        inCPath = env->GetStringUTFChars(inPath, 0);\n        LOGIS(\"IN path\", inCPath);\n        inFile = fopen(inCPath, \"rb\");\n        if (!inFile) {\n            if (throwException) {\n                throw_cant_open_file_exception(env, inPath);\n            }\n            LOGES(\"Can\\'t open out file\", inCPath);\n            env->ReleaseStringUTFChars(inPath, inCPath);\n            return JNI_FALSE;\n        }\n        env->ReleaseStringUTFChars(inPath, inCPath);\n    } else {\n        inFile = fdopen(inFd, \"rb\");\n        if (!inFile) {\n            if (throwException) {\n                throw_cant_open_file_exception_fd(env, inFd);\n            }\n            LOGES(\"Can\\'t open out file descriptor\", inFd);\n            return JNI_FALSE;\n        }\n    }\n\n    //read file header\n    size_t byte_count = 8;\n    unsigned char *header = (unsigned char *)malloc(sizeof(unsigned char) * byte_count);\n    fread(header, 1, byte_count, inFile);\n\n    //Check is file is JPG image\n    bool is_jpg = !strncmp( (const char*)header, \"\\xFF\\xD8\\xFF\", 3 );\n    //seek file to begin\n    rewind(inFile);\n    if (!is_jpg) {\n        LOGE(\"Not jpeg file\");\n        if (throwException) {\n            if (inFd < 0) {\n                throw_cant_open_file_exception(env, inPath);\n            } else {\n                throw_cant_open_file_exception_fd(env, inFd);\n            }\n        }\n        return JNI_FALSE;\n    } else {\n        LOGI(\"IS JPEG\");\n    }\n\n    /* We set up the normal JPEG error routines, then override error_exit. */\n    cinfo.err = jpeg_std_error(&jerr);\n\n    jpeg_create_decompress(&cinfo);\n    jpeg_struct_init = 1;\n    LOGI(\"decompress created\");\n\n    jpeg_stdio_src(&cinfo, inFile);\n    LOGI(\"set file\");\n\n    //read file parameters\n    int readHeader = jpeg_read_header(&cinfo, TRUE);\n    LOGII(\"read jpeg header\", readHeader);\n\n    //start decompress\n    int startDecompress = jpeg_start_decompress(&cinfo);\n    LOGII(\"start decompress\", startDecompress);\n\n    width = cinfo.image_width;\n    height = cinfo.image_height;\n    LOGII(\"width\", width);\n    LOGII(\"height\", height);\n\n    componentsPerPixel = cinfo.output_components;\n\n    //Create tiff structure\n    TIFFSetField(tiffImage, TIFFTAG_IMAGEWIDTH, width);\n    TIFFSetField(tiffImage, TIFFTAG_IMAGELENGTH, height);\n    TIFFSetField(tiffImage, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    TIFFSetField(tiffImage, TIFFTAG_COMPRESSION, compressionInt);\n    TIFFSetField(tiffImage, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n    TIFFSetField(tiffImage, TIFFTAG_XRESOLUTION, xRes);\n    TIFFSetField(tiffImage, TIFFTAG_YRESOLUTION, yRes);\n    TIFFSetField(tiffImage, TIFFTAG_RESOLUTIONUNIT, resUnit);\n\n    if (compressionInt == COMPRESSION_CCITTRLE || compressionInt == COMPRESSION_CCITTFAX3 || compressionInt == COMPRESSION_CCITTFAX4) {\n        TIFFSetField(tiffImage, TIFFTAG_BITSPERSAMPLE,\t1);\n        TIFFSetField(tiffImage, TIFFTAG_SAMPLESPERPIXEL,\t1);\n        TIFFSetField(tiffImage, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n        TIFFSetField(tiffImage, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);\n    } else {\n        TIFFSetField(tiffImage, TIFFTAG_BITSPERSAMPLE, 8);\n        TIFFSetField(tiffImage, TIFFTAG_SAMPLESPERPIXEL, componentsPerPixel);\n        if (componentsPerPixel == 1) {\n            TIFFSetField(tiffImage, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n        } else {\n            TIFFSetField(tiffImage, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n        }\n    }\n    //creation date\n    char *date = getCreationDate();\n    TIFFSetField(tiffImage, TIFFTAG_DATETIME, date);\n    free(date);\n    //image description\n    if (cdescription) {\n        TIFFSetField(tiffImage, TIFFTAG_IMAGEDESCRIPTION, cdescription);\n    }\n    //software tag\n    if (csoftware) {\n        TIFFSetField(tiffImage, TIFFTAG_SOFTWARE, csoftware);\n    }\n\n    //progress reporter\n    jlong total = width * height;\n    sendProgress(0, total);\n\n    int rowSize = width * componentsPerPixel;\n    LOGII(\"jpg samples\", componentsPerPixel);\n\n    //Calculate row per strip\n    //maximum size for strip should be less than 2Mb if memory available\n    unsigned long MB2 = (availableMemory == -1 || availableMemory > 3 * 1024 * 1024) ? 2 * 1024 * 1024 : width * 4;\n    int rowPerStrip = MB2/rowSize;\n    //TODO This is workaround. Need to understand why FAX compression schemes have shift in strips.\n    if (compressionInt == COMPRESSION_CCITTRLE || compressionInt == COMPRESSION_CCITTFAX3 || compressionInt == COMPRESSION_CCITTFAX4) {\n        rowPerStrip = 1;\n    }\n\n    if (rowPerStrip >= height) {\n        rowPerStrip = height / 4;\n    }\n    if (rowPerStrip < 1) rowPerStrip = 1;\n    LOGII(\"rowPerStrip\", rowPerStrip);\n\n    unsigned long estimateMem = rowPerStrip * width * 4;\n    estimateMem += sizeof(JSAMPLE) * rowSize;//jpg buffer\n    if (compressionInt == COMPRESSION_JPEG) {\n        estimateMem += 0;\n    } else if (compressionInt == COMPRESSION_CCITTRLE || compressionInt == COMPRESSION_CCITTFAX3 || compressionInt == COMPRESSION_CCITTFAX4) {\n        estimateMem += (width/8 + 0.5) * rowPerStrip;\n    } else {\n        estimateMem += rowPerStrip * rowSize;\n    }\n    LOGII(\"estimateMem\", estimateMem);\n    if (estimateMem > availableMemory && availableMemory != -1) {\n        LOGEI(\"Not enough memory\", availableMemory);\n        if (throwException) {\n            throw_not_enought_memory_exception(env, availableMemory, estimateMem);\n        }\n        return JNI_FALSE;\n    }\n\n    if (checkStop()) {\n        //jpeg_finish_decompress(&cinfo);\n        conversion_result = JNI_FALSE;\n        return conversion_result;\n    }\n\n    //Buffer for read jpeg image line by line\n    int buffer_height = 1;\n    JSAMPARRAY buffer = (JSAMPARRAY)malloc(sizeof(JSAMPROW) * buffer_height);\n    buffer[0] = (JSAMPROW)malloc(sizeof(JSAMPLE) * rowSize);\n\n    //buffer for format strips for tiff\n\n\n    int ret;\n    if (compressionInt == COMPRESSION_JPEG) {\n        int line = 0;\n        while (cinfo.output_scanline < height) {\n            if (checkStop()) {\n                free(buffer[0]);\n                free(buffer);\n                conversion_result = JNI_FALSE;\n                return conversion_result;\n            }\n            if (line % rowPerStrip == 0) {\n                sendProgress(line * width, total);\n            }\n            jpeg_read_scanlines(&cinfo, buffer, 1);\n            ret = TIFFWriteScanline(tiffImage, buffer[0], line, 0);\n            line++;\n        }\n    } else {\n        TIFFSetField(tiffImage, TIFFTAG_ROWSPERSTRIP, rowPerStrip);\n        unsigned char *data = new unsigned char[rowSize * rowPerStrip];\n        int totalRowCounter = 0;\n        int rowCounter = 0;\n        bool shouldWrite = false;\n        while (cinfo.output_scanline < height) {\n            shouldWrite = true;\n            jpeg_read_scanlines(&cinfo, buffer, 1);\n            memcpy(data + rowCounter * rowSize, buffer[0], rowSize);\n            rowCounter++;\n            totalRowCounter++;\n            if (rowCounter == rowPerStrip) {\n                if (checkStop()) {\n                    //jpeg_finish_decompress(&cinfo);\n                    delete[] data;\n                    free(buffer[0]);\n                    free(buffer);\n                    conversion_result = JNI_FALSE;\n                    return conversion_result;\n                }\n                if (compressionInt == COMPRESSION_CCITTRLE || compressionInt == COMPRESSION_CCITTFAX3 || compressionInt == COMPRESSION_CCITTFAX4) {\n                    int compressedWidth = (width/8 + 0.5);\n                    unsigned char *bilevel = convertArgbToBilevel(data, componentsPerPixel, width, rowPerStrip);\n                    ret = TIFFWriteEncodedStrip(tiffImage, totalRowCounter/rowPerStrip - 1, bilevel, compressedWidth * sizeof(unsigned char) * rowPerStrip);\n                    free(bilevel);\n                } else {\n                    ret = TIFFWriteEncodedStrip(tiffImage, totalRowCounter/rowPerStrip - 1, data, rowPerStrip * rowSize);\n                }\n                rowCounter = 0;\n                shouldWrite = false;\n                sendProgress(totalRowCounter * width, total);\n            }\n        }\n        if (shouldWrite) {  LOGI(\"last stage\");\n            if (checkStop()) {\n                //jpeg_finish_decompress(&cinfo);\n                delete[] data;\n                free(buffer[0]);\n                free(buffer);\n                conversion_result = JNI_FALSE;\n                return conversion_result;\n            }\n            if (compressionInt == COMPRESSION_CCITTRLE || compressionInt == COMPRESSION_CCITTFAX3 || compressionInt == COMPRESSION_CCITTFAX4) {\n                int compressedWidth = (width/8 + 0.5);\n                unsigned char *bilevel = convertArgbToBilevel(data, componentsPerPixel, width, rowPerStrip);\n                ret = TIFFWriteEncodedStrip(tiffImage, totalRowCounter/rowPerStrip, bilevel, compressedWidth * sizeof(unsigned char) * rowPerStrip);\n                free(bilevel);\n            } else {\n                ret = TIFFWriteEncodedStrip(tiffImage, totalRowCounter/rowPerStrip, data, rowPerStrip * rowSize);\n            }\n        }\n        delete[] data;\n    }\n\n    ret = TIFFWriteDirectory(tiffImage);\n    LOGII(\"ret = \", ret);\n\n    jpeg_finish_decompress(&cinfo);\n\n\n    free(buffer[0]);\n    free(buffer);\n\n    sendProgress(total, total);\n    conversion_result = JNI_TRUE;\n    return conversion_result;\n}",
    "jboolean PngToTiffConverter::convert()\n{\n    readOptions();\n\n    //open tiff file for writing or appending\n    if(outFd < 0) {\n        //open tiff file for writing or appending\n        const char *outCPath = NULL;\n        outCPath = env->GetStringUTFChars(outPath, 0);\n        LOGIS(\"OUT path\", outCPath);\n        LOGIS(\"nativeTiffOpenForSave\", outCPath);\n        int mode = O_RDWR | O_CREAT | O_TRUNC | 0;\n        if (appendTiff) {\n            mode = O_RDWR | O_CREAT;\n        }\n        outFd = open(outCPath, mode, 0666);\n        if (outFd < 0) {\n            throw_cant_open_file_exception(env, outPath);\n            env->ReleaseStringUTFChars(outPath, outCPath);\n            return JNI_FALSE;\n        }\n        env->ReleaseStringUTFChars(outPath, outCPath);\n    }\n\n    if (!appendTiff) {\n        if ((tiffImage = TIFFFdOpen(outFd, \"\", \"w\")) == NULL) {\n            LOGE(\"Unable to open tif file\");\n            if (throwException) {\n                throw_cant_open_file_exception_fd(env, outFd);\n            }\n            return JNI_FALSE;\n        }\n    } else {\n        if ((tiffImage = TIFFFdOpen(outFd, \"\", \"a\")) == NULL) {\n            LOGE(\"Unable to open tif file\");\n            if (throwException) {\n                throw_cant_open_file_exception_fd(env, outFd);\n            }\n            return JNI_FALSE;\n        }\n    }\n\n    //open png file fow reading\n    if (inFd == -1) {\n        const char *inCPath = NULL;\n        inCPath = env->GetStringUTFChars(inPath, 0);\n        LOGIS(\"IN path\", inCPath);\n        inFile = fopen(inCPath, \"rb\");\n        if (!inFile) {\n            if (throwException) {\n                throw_cant_open_file_exception(env, inPath);\n            }\n            LOGES(\"Can\\'t open in file\", inCPath);\n            env->ReleaseStringUTFChars(inPath, inCPath);\n            return JNI_FALSE;\n        }\n        env->ReleaseStringUTFChars(inPath, inCPath);\n    } else {\n        inFile = fdopen(inFd, \"rb\");\n        if (!inFile) {\n            if (throwException) {\n                throw_cant_open_file_exception_fd(env, inFd);\n            }\n            LOGES(\"Can\\'t open out file descriptor\", inFd);\n            return JNI_FALSE;\n        }\n    }\n\n    //read file header\n    size_t byte_count = 8;\n    unsigned char *header = (unsigned char *)malloc(sizeof(unsigned char) * byte_count);\n    fread(header, 1, byte_count, inFile);\n\n    //check is file is PNG or not\n    bool is_png = !png_sig_cmp(header, 0, byte_count);\n    if (!is_png) {\n        LOGE(\"Not png file\");\n        if (throwException) {\n            if (inFd == -1) {\n                throw_cant_open_file_exception(env, inPath);\n            } else {\n                throw_cant_open_file_exception_fd(env, inFd);\n            }\n        }\n        return JNI_FALSE;\n    } else {\n        LOGI(\"Is png\");\n    }\n\n    //init png struct\n    png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);\n    if (!png_ptr) {\n        const char *message = \"Can\\'t create PNG structure\";\n        LOGE(*message);\n        if (throwException) {\n            jstring er = env->NewStringUTF(message);\n            if (inFd < 0) {\n                throw_decode_file_exception(env, inPath, er);\n            } else {\n                throw_decode_file_exception_fd(env, inFd, er);\n            }\n            env->DeleteLocalRef(er);\n        }\n        return JNI_FALSE;\n    }\n    png_ptr_init = 1;\n\n    png_set_sig_bytes(png_ptr, byte_count);\n\n    //create png info pointer\n    info_ptr = png_create_info_struct(png_ptr);\n    if (!info_ptr) {\n        const char *message = \"Can\\'t create PNG info structure\";\n        LOGE(*message);\n        if (throwException) {\n            jstring er = env->NewStringUTF(message);\n            if (inFd < 0) {\n                throw_decode_file_exception(env, inPath, er);\n            } else {\n                throw_decode_file_exception_fd(env, inFd, er);\n            }\n            env->DeleteLocalRef(er);\n        }\n        return JNI_FALSE;\n    }\n    png_info_init = 1;\n\n    //png error handler\n    if (setjmp(png_jmpbuf(png_ptr))) {\n        const char *message = \"Error reading PNG\";\n        LOGE(message);\n        if (throwException) {\n            jstring er = env->NewStringUTF(message);\n            if (inFd < 0) {\n                throw_decode_file_exception(env, inPath, er);\n            } else {\n                throw_decode_file_exception_fd(env, inFd, er);\n            }\n            env->DeleteLocalRef(er);\n        }\n        return JNI_FALSE;\n    }\n\n    //Init PNG IO\n    png_init_io(png_ptr, inFile);\n    //seek file header\n    png_set_sig_bytes(png_ptr, byte_count);\n\n    png_read_info(png_ptr, info_ptr);\n    png_get_IHDR(png_ptr, info_ptr, &width, &height, &bit_depth, &color_type, NULL, NULL, NULL);\n\n    LOGII(\"width\", width);\n    LOGII(\"height\", height);\n    LOGII(\"bit_depth\", bit_depth);\n    LOGII(\"color_type\", color_type);\n\n\n\n    // cast any pixel data to RGBA data for simplest reading\n    if(bit_depth == 16)\n        png_set_strip_16(png_ptr);\n\n    if(color_type == PNG_COLOR_TYPE_PALETTE)\n        png_set_palette_to_rgb(png_ptr);\n\n      // PNG_COLOR_TYPE_GRAY_ALPHA is always 8 or 16bit depth.\n    if(color_type == PNG_COLOR_TYPE_GRAY && bit_depth < 8)\n        png_set_expand_gray_1_2_4_to_8(png_ptr);\n\n    if(png_get_valid(png_ptr, info_ptr, PNG_INFO_tRNS))\n        png_set_tRNS_to_alpha(png_ptr);\n\n      // These color_type don't have an alpha channel then fill it with 0xff.\n    if(color_type == PNG_COLOR_TYPE_RGB ||\n         color_type == PNG_COLOR_TYPE_GRAY ||\n         color_type == PNG_COLOR_TYPE_PALETTE)\n        png_set_filler(png_ptr, 0xFF, PNG_FILLER_AFTER);\n\n    if(color_type == PNG_COLOR_TYPE_GRAY ||\n         color_type == PNG_COLOR_TYPE_GRAY_ALPHA)\n        png_set_gray_to_rgb(png_ptr);\n\n    int number_passes = png_set_interlace_handling(png_ptr);\n    LOGII(\"number_passes\", number_passes);\n\n    png_read_update_info(png_ptr, info_ptr);\n\n\n    LOGII(\"compression\", compressionInt);\n    //Set tiff parameters\n    //Set various text parameters\n    //Set image parameters\n    TIFFSetField(tiffImage, TIFFTAG_IMAGEWIDTH, width);\n    TIFFSetField(tiffImage, TIFFTAG_IMAGELENGTH, height);\n    TIFFSetField(tiffImage, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    TIFFSetField(tiffImage, TIFFTAG_COMPRESSION, compressionInt);\n    TIFFSetField(tiffImage, TIFFTAG_ORIENTATION, orientationInt);\n    TIFFSetField(tiffImage, TIFFTAG_XRESOLUTION, xRes);\n    TIFFSetField(tiffImage, TIFFTAG_YRESOLUTION, yRes);\n    TIFFSetField(tiffImage, TIFFTAG_RESOLUTIONUNIT, resUnit);\n\n    if (compressionInt == COMPRESSION_CCITTRLE || compressionInt == COMPRESSION_CCITTFAX3 || compressionInt == COMPRESSION_CCITTFAX4) {\n        TIFFSetField(tiffImage, TIFFTAG_BITSPERSAMPLE,\t1);\n        TIFFSetField(tiffImage, TIFFTAG_SAMPLESPERPIXEL,\t1);\n        TIFFSetField(tiffImage, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n        TIFFSetField(tiffImage, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);\n    } else {\n        TIFFSetField(tiffImage, TIFFTAG_BITSPERSAMPLE, 8);\n        TIFFSetField(tiffImage, TIFFTAG_SAMPLESPERPIXEL, 4);\n        TIFFSetField(tiffImage, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n    }\n    //creation date\n    char *date = getCreationDate();\n    TIFFSetField(tiffImage, TIFFTAG_DATETIME, date);\n    free(date);\n    //image description\n    if (cdescription) {\n        TIFFSetField(tiffImage, TIFFTAG_IMAGEDESCRIPTION, cdescription);\n    }\n    //software tag\n    if (csoftware) {\n        TIFFSetField(tiffImage, TIFFTAG_SOFTWARE, csoftware);\n    }\n\n    //Calculate row per strip\n    //maximum size for strip should be less than 2Mb if memory available\n    unsigned long MB2 = (availableMemory == -1 || availableMemory > 3 * 1024 * 1024) ? 2 * 1024 * 1024 : width * 4;\n    unsigned long rowSizeBytes = width * 4;\n    int rowPerStrip = MB2/rowSizeBytes;\n    if (rowPerStrip >= height) {\n        rowPerStrip = height / 4;\n    }\n    if (rowPerStrip < 1) rowPerStrip = 1;\n    LOGII(\"rowPerStrip\", rowPerStrip);\n\n    //check available memory and estimate memory\n    unsigned long estimateMem = rowPerStrip * width * 4;\n    estimateMem += (compressionInt == COMPRESSION_CCITTRLE || compressionInt == COMPRESSION_CCITTFAX3 || compressionInt == COMPRESSION_CCITTFAX4) ? (width/8 + 0.5) * rowPerStrip : 0;\n    LOGII(\"estimateMem\", estimateMem);\n    if (estimateMem > availableMemory && availableMemory != -1) {\n        LOGEI(\"Not enough memory\", availableMemory);\n        if (throwException) {\n            throw_not_enought_memory_exception(env, availableMemory, estimateMem);\n        }\n        return JNI_FALSE;\n    }\n\n    if (checkStop()) {\n        conversion_result = JNI_FALSE;\n        return conversion_result;\n    }\n\n    //progress reporter\n    jlong total = width * height;\n    sendProgress(0, total);\n\n\n    int rowbytes = png_get_rowbytes(png_ptr,info_ptr);\n    png_bytep row_pointers[rowPerStrip];\n    for (int sy = 0; sy < rowPerStrip; sy++) {\n        row_pointers[sy] = (png_byte*)malloc(rowbytes);\n    }\n\n    int ret;\n\n    // Write the information to the file\n    if (compressionInt == COMPRESSION_CCITTRLE || compressionInt == COMPRESSION_CCITTFAX3 || compressionInt == COMPRESSION_CCITTFAX4) {\n        TIFFSetField(tiffImage, TIFFTAG_ROWSPERSTRIP, rowPerStrip);\n        int compressedWidth = (width/8 + 0.5);\n        for (int y = 0; y < height; y+=rowPerStrip) {\n            if (checkStop()) {\n                for (int sy = 0; sy < rowPerStrip; sy++) {\n                    free(row_pointers[sy]);\n                }\n                conversion_result = JNI_FALSE;\n                return conversion_result;\n            }\n            int rowToRead = rowPerStrip;\n            if (rowToRead + y >= height) {\n                rowToRead = height - y;\n            }\n            sendProgress(y * width, total);\n            png_read_rows(png_ptr, &row_pointers[0], NULL, rowToRead);\n            unsigned char *bilevel = convertArgbToBilevel(&row_pointers[0], 4, width, rowToRead);\n            TIFFWriteEncodedStrip(tiffImage, y/rowPerStrip, bilevel, compressedWidth * sizeof(unsigned char) * rowToRead);\n            free(bilevel);\n        }\n    } else if (compressionInt == COMPRESSION_JPEG) {\n        for (int ys = 0; ys < height; ys+=rowPerStrip) {\n            if (checkStop()) {\n                for (int sy = 0; sy < rowPerStrip; sy++) {\n                    free(row_pointers[sy]);\n                }\n                conversion_result = JNI_FALSE;\n                return conversion_result;\n            }\n            int rowToRead = rowPerStrip;\n            if (rowToRead + ys >= height) {\n                rowToRead = height - ys;\n            }\n            LOGII(\"rowToRead\", rowToRead);\n            sendProgress(ys * width, total);\n            png_read_rows(png_ptr, &row_pointers[0], NULL, rowToRead);\n            uint32 *pixels = new uint32[width];\n            for (int k = 0; k < rowToRead; k++) {\n                memcpy(pixels, row_pointers[k], width * sizeof(uint32));\n                ret = TIFFWriteScanline(tiffImage, pixels, ys + k, 0);\n            }\n            //TIFFWriteEncodedStrip(tiffImage, y/rowPerStrip, pixels, width * sizeof(uint32) * rowToRead);\n            delete[] pixels;\n\n        }\n    } else {\n        TIFFSetField(tiffImage, TIFFTAG_ROWSPERSTRIP, rowPerStrip);\n        for (int y = 0; y < height; y+=rowPerStrip) {\n            if (checkStop()) {\n                for (int sy = 0; sy < rowPerStrip; sy++) {\n                    free(row_pointers[sy]);\n                }\n                conversion_result = JNI_FALSE;\n                return conversion_result;\n            }\n            int rowToRead = rowPerStrip;\n            if (rowToRead + y >= height) {\n                rowToRead = height - y;\n            }\n            LOGII(\"rowToRead\", rowToRead);\n            sendProgress(y * width, total);\n            png_read_rows(png_ptr, &row_pointers[0], NULL, rowToRead);\n            uint32 *pixels = new uint32[width * rowPerStrip];\n            for (int k = 0; k < rowToRead; k++) {\n                memcpy(pixels+k*width, row_pointers[k], width * sizeof(uint32));\n            }\n            TIFFWriteEncodedStrip(tiffImage, y/rowPerStrip, pixels, width * sizeof(uint32) * rowToRead);\n            delete[] pixels;\n        }\n    }\n    //free memory allocated for png rows\n    for (int sy = 0; sy < rowPerStrip; sy++) {\n        free(row_pointers[sy]);\n    }\n    ret = TIFFWriteDirectory(tiffImage);\n    LOGII(\"ret = \", ret);\n\n\n    sendProgress(total, total);\n    conversion_result = JNI_TRUE;\n    return conversion_result;\n}",
    "bool Export_3DTiff_Workspace::exportHelper() {\n\n    range = 255;\n\n    const int samplesPerPixel = 1;\n    const int bitsPerSample = 8;\n\n    std::vector<uint8_t> svec(width);\n\n    TIFF *output_image;\n\n    if((output_image = TIFFOpen(fileName.c_str(), \"w\")) == NULL){\n        std::cerr << \"Unable to write tif file: \" << \"image.tiff\" << std::endl;\n        return false;\n    }\n\n    for (int page = 0; page < numberOfPages; page++) {\n\n        TIFFSetField(output_image,TIFFTAG_IMAGEWIDTH, width);\n        TIFFSetField(output_image,TIFFTAG_SAMPLESPERPIXEL, samplesPerPixel);\n        TIFFSetField(output_image,TIFFTAG_BITSPERSAMPLE, bitsPerSample);\n        TIFFSetField(output_image,TIFFTAG_ORIENTATION, (int)ORIENTATION_TOPLEFT);\n        TIFFSetField(output_image,TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\n        TIFFSetField(output_image,TIFFTAG_ROWSPERSTRIP, height / samplesPerPixel);\n        TIFFSetField(output_image,TIFFTAG_XRESOLUTION, 100.0);\n        TIFFSetField(output_image,TIFFTAG_YRESOLUTION, 100.0);\n        TIFFSetField(output_image,TIFFTAG_RESOLUTIONUNIT, RESUNIT_INCH);\n\n        // specify that it's a page within the multipage file\n        TIFFSetField(output_image,TIFFTAG_SUBFILETYPE, FILETYPE_PAGE);\n        // specify the page number\n        TIFFSetField(output_image,TIFFTAG_PAGENUMBER, page, numberOfPages);\n\n        if(normalized) {\n            for (int y = 0; y < height; y++) {\n                for(int i=0;i<width;i++) {\n                    svec[i] = (uint8_t)((range*(work->matrix(i,y,page)-min)/(max-min)));\n                }\n                if (TIFFWriteScanline(output_image,&svec[0], y, 0)==-1) {\n                    std::cout << \"Complete or error\" << std::endl;\n                }\n            }\n        }\n        else {\n            for (int y = 0; y < height; y++) {\n                for(int i=0;i<width;i++) {\n                    svec[i] = (uint8_t)work->matrix(i,y,page);\n                }\n                if (TIFFWriteScanline(output_image,&svec[0], y, 0)==-1) {\n                    std::cout << \"Complete or error\" << std::endl;\n                }\n            }\n        }\n\n        TIFFWriteDirectory(output_image);\n    }\n\n\n    return true;\n\n}",
    "bool TiffEncoder::writeLibTiff( const std::vector<Mat>& img_vec, const std::vector<int>& params)\n{\n    // do NOT put \"wb\" as the mode, because the b means \"big endian\" mode, not \"binary\" mode.\n    // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n    TIFF* tif = NULL;\n\n    TiffEncoderBufHelper buf_helper(m_buf);\n    if ( m_buf )\n    {\n        tif = buf_helper.open();\n    }\n    else\n    {\n        tif = TIFFOpen(m_filename.c_str(), \"w\");\n    }\n    if (!tif)\n    {\n        return false;\n    }\n    cv::Ptr<void> tif_cleanup(tif, cv_tiffCloseHandle);\n\n    //Settings that matter to all images\n    int compression = COMPRESSION_LZW;\n    int predictor = PREDICTOR_HORIZONTAL;\n    int resUnit = -1, dpiX = -1, dpiY = -1;\n\n    readParam(params, IMWRITE_TIFF_COMPRESSION, compression);\n    readParam(params, TIFFTAG_PREDICTOR, predictor);\n    readParam(params, IMWRITE_TIFF_RESUNIT, resUnit);\n    readParam(params, IMWRITE_TIFF_XDPI, dpiX);\n    readParam(params, IMWRITE_TIFF_YDPI, dpiY);\n\n    //Iterate through each image in the vector and write them out as Tiff directories\n    for (size_t page = 0; page < img_vec.size(); page++)\n    {\n        const Mat& img = img_vec[page];\n        CV_Assert(!img.empty());\n        int channels = img.channels();\n        int width = img.cols, height = img.rows;\n        int type = img.type();\n        int depth = CV_MAT_DEPTH(type);\n        CV_CheckType(type, depth == CV_8U || depth == CV_8S || depth == CV_16U || depth == CV_16S || depth == CV_32S || depth == CV_32F || depth == CV_64F, \"\");\n        CV_CheckType(type, channels >= 1 && channels <= 4, \"\");\n\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, width));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_IMAGELENGTH, height));\n\n        if (img_vec.size() > 1)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE));\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PAGENUMBER, page, img_vec.size()));\n        }\n\n        int compression_param = -1;  // OPENCV_FUTURE\n        if (type == CV_32FC3 && (!readParam(params, IMWRITE_TIFF_COMPRESSION, compression_param) || compression_param == COMPRESSION_SGILOG))\n        {\n            if (!write_32FC3_SGILOG(img, tif))\n                return false;\n            continue;\n        }\n\n        int page_compression = compression;\n\n        int bitsPerChannel = -1;\n        uint16 sample_format = SAMPLEFORMAT_INT;\n        switch (depth)\n        {\n            case CV_8U:\n                sample_format = SAMPLEFORMAT_UINT;\n                /* FALLTHRU */\n            case CV_8S:\n            {\n                bitsPerChannel = 8;\n                break;\n            }\n\n            case CV_16U:\n                sample_format = SAMPLEFORMAT_UINT;\n                /* FALLTHRU */\n            case CV_16S:\n            {\n                bitsPerChannel = 16;\n                break;\n            }\n\n            case CV_32F:\n                sample_format = SAMPLEFORMAT_IEEEFP;\n                /* FALLTHRU */\n            case CV_32S:\n            {\n                bitsPerChannel = 32;\n                page_compression = COMPRESSION_NONE;\n                break;\n            }\n            case CV_64F:\n            {\n                bitsPerChannel = 64;\n                page_compression = COMPRESSION_NONE;\n                sample_format = SAMPLEFORMAT_IEEEFP;\n                break;\n            }\n            default:\n            {\n                return false;\n            }\n        }\n\n        const int bitsPerByte = 8;\n        size_t fileStep = (width * channels * bitsPerChannel) / bitsPerByte;\n        CV_Assert(fileStep > 0);\n\n        int rowsPerStrip = (int)((1 << 13) / fileStep);\n        readParam(params, TIFFTAG_ROWSPERSTRIP, rowsPerStrip);\n        rowsPerStrip = std::max(1, std::min(height, rowsPerStrip));\n\n        int colorspace = channels > 1 ? PHOTOMETRIC_RGB : PHOTOMETRIC_MINISBLACK;\n\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, bitsPerChannel));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_COMPRESSION, page_compression));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, colorspace));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, channels));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, rowsPerStrip));\n\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, sample_format));\n\n        if (page_compression == COMPRESSION_LZW || page_compression == COMPRESSION_ADOBE_DEFLATE || page_compression == COMPRESSION_DEFLATE)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PREDICTOR, predictor));\n        }\n\n        if (resUnit >= RESUNIT_NONE && resUnit <= RESUNIT_CENTIMETER)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_RESOLUTIONUNIT, resUnit));\n        }\n        if (dpiX >= 0)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_XRESOLUTION, (float)dpiX));\n        }\n        if (dpiY >= 0)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_YRESOLUTION, (float)dpiY));\n        }\n\n        // row buffer, because TIFFWriteScanline modifies the original data!\n        size_t scanlineSize = TIFFScanlineSize(tif);\n        AutoBuffer<uchar> _buffer(scanlineSize + 32);\n        uchar* buffer = _buffer.data(); CV_DbgAssert(buffer);\n        Mat m_buffer(Size(width, 1), CV_MAKETYPE(depth, channels), buffer, (size_t)scanlineSize);\n\n        for (int y = 0; y < height; ++y)\n        {\n            switch (channels)\n            {\n                case 1:\n                {\n                    memcpy(buffer, img.ptr(y), scanlineSize);\n                    break;\n                }\n\n                case 3:\n                {\n                    cvtColor(img(Rect(0, y, width, 1)), (const Mat&)m_buffer, COLOR_BGR2RGB);\n                    break;\n                }\n\n                case 4:\n                {\n                    cvtColor(img(Rect(0, y, width, 1)), (const Mat&)m_buffer, COLOR_BGRA2RGBA);\n                    break;\n                }\n\n                default:\n                {\n                    CV_Assert(0);\n                }\n            }\n\n            CV_TIFF_CHECK_CALL(TIFFWriteScanline(tif, buffer, y, 0) == 1);\n        }\n\n        CV_TIFF_CHECK_CALL(TIFFWriteDirectory(tif));\n    }\n\n    return true;\n}",
    "FXbool fxsaveTIF(FXStream& store,const FXColor* data,FXint width,FXint height,FXushort codec){\n  FXbool result=false;\n\n  // Must make sense\n  if(data && 0<width && 0<height){\n\n    // Correct for unsupported codecs\n    const TIFFCodec* coder=TIFFFindCODEC(codec);\n    if(coder==nullptr) codec=COMPRESSION_PACKBITS;\n\n    // Due to the infamous UNISYS patent, we can read LZW TIFF's but not\n    // write them back as that would require the LZW compression algorithm!\n    if(codec==COMPRESSION_LZW) codec=COMPRESSION_PACKBITS;\n\n    FXTRACE((100,\"fxsaveTIF: codec=%d\\n\",codec));\n\n    // Set error/warning handlers\n    TIFFSetErrorHandler(nullptr);\n    TIFFSetWarningHandler(nullptr);\n\n    // Initialize\n    tiff_store_handle s_handle;\n    s_handle.store=&store;\n    s_handle.begin=store.position();\n    s_handle.end=store.position();\n\n    // Open image\n    TIFF* image=TIFFClientOpen(\"tiff\",\"w\",(thandle_t)&s_handle,tif_dummy_read_store,tif_write_store,tif_seek_store,tif_close_store,tif_size_store,nullptr,nullptr);\n    if(image){\n      FXColor *buffer=nullptr;\n\n      // Size of a strip is 16kb\n      FXint rows_per_strip=16*1024/width;\n      if(rows_per_strip<1) rows_per_strip=1;\n\n      // Set fields\n      TIFFSetField(image,TIFFTAG_IMAGEWIDTH,width);\n      TIFFSetField(image,TIFFTAG_IMAGELENGTH,height);\n      TIFFSetField(image,TIFFTAG_COMPRESSION,codec);\n      TIFFSetField(image,TIFFTAG_ORIENTATION,ORIENTATION_TOPLEFT);\n      TIFFSetField(image,TIFFTAG_ROWSPERSTRIP,rows_per_strip);\n      TIFFSetField(image,TIFFTAG_BITSPERSAMPLE,8);\n      TIFFSetField(image,TIFFTAG_SAMPLESPERPIXEL,4);\n      TIFFSetField(image,TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG);\n      TIFFSetField(image,TIFFTAG_PHOTOMETRIC,PHOTOMETRIC_RGB);\n\n      // Allocate scanline buffer\n      if(allocElms(buffer,width)){\n\n        // Dump each line\n        for(FXint y=0; y<height; data+=width,y++){\n\n          // Convert byte order\n          for(FXint x=0; x<width; x++){\n            buffer[x]=FXREDVAL(data[x]) | FXGREENVAL(data[x])<<8 | FXBLUEVAL(data[x])<<16 | FXALPHAVAL(data[x])<<24;\n            }\n\n          // Write scanline\n          if(TIFFWriteScanline(image,buffer,y,1)!=1) goto x;\n          }\n\n        // All done\n        result=true;\n\n        // Delete scanline buffer\nx:      freeElms(buffer);\n        }\n\n      // Close image\n      TIFFClose(image);\n      }\n    }\n  return result;\n  }",
    "bool TifFormat::saveToFile(const std::string &name, const ImageLayer &image_layer, ColorSpace color_space, float gamma, bool alpha_premultiply)\n{\n#if defined(_WIN32)\n\tstd::wstring wname = string::utf8ToWutf16Le(name);\n\tlibtiff::TIFF *out = libtiff::TIFFOpenW(wname.c_str(), \"w\");\t//Windows needs the path in UTF16LE (unicode, UTF16, little endian) so we have to convert the UTF8 path to UTF16\n#else\n\tlibtiff::TIFF *out = libtiff::TIFFOpen(name.c_str(), \"w\");\n#endif\n\tif(!out)\n\t{\n\t\tlogger_.logError(getFormatName(), \": Cannot open file \", name);\n\t\treturn false;\n\t}\n\tconst int h = image_layer.getHeight();\n\tconst int w = image_layer.getWidth();\n\tint channels;\n\tif(image_layer.image_->hasAlpha()) channels = 4;\n\telse channels = 3;\n\n\tlibtiff::TIFFSetField(out, TIFFTAG_IMAGEWIDTH, w);\n\tlibtiff::TIFFSetField(out, TIFFTAG_IMAGELENGTH, h);\n\tlibtiff::TIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, channels);\n\tlibtiff::TIFFSetField(out, TIFFTAG_BITSPERSAMPLE, 8);\n\tlibtiff::TIFFSetField(out, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n\tlibtiff::TIFFSetField(out, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\tlibtiff::TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n\n\tconst size_t bytes_per_scanline = channels * w;\n\tlibtiff::TIFFSetField(out, TIFFTAG_ROWSPERSTRIP, libtiff::TIFFDefaultStripSize(out, bytes_per_scanline));\n\n\tauto *scanline = static_cast<uint8_t *>(libtiff::_TIFFmalloc(bytes_per_scanline));\n\tfor(int y = 0; y < h; y++)\n\t{\n\t\tfor(int x = 0; x < w; x++)\n\t\t{\n\t\t\tconst int ix = x * channels;\n\t\t\tRgba col = Layer::postProcess(image_layer.image_->getColor({{x, y}}), image_layer.layer_.getType(), color_space, gamma, alpha_premultiply);\n\t\t\tcol.clampRgba01();\n\t\t\tscanline[ix] = (uint8_t)(col.getR() * 255.f);\n\t\t\tscanline[ix + 1] = (uint8_t)(col.getG() * 255.f);\n\t\t\tscanline[ix + 2] = (uint8_t)(col.getB() * 255.f);\n\t\t\tif(image_layer.image_->hasAlpha()) scanline[ix + 3] = (uint8_t)(col.getA() * 255.f);\n\t\t}\n\t\tif(TIFFWriteScanline(out, scanline, y, 0) < 0)\n\t\t{\n\t\t\tlogger_.logError(getFormatName(), \": An error occurred while writing TIFF file\");\n\t\t\tlibtiff::TIFFClose(out);\n\t\t\tlibtiff::_TIFFfree(scanline);\n\t\t\treturn false;\n\t\t}\n\t}\n\tlibtiff::TIFFClose(out);\n\tlibtiff::_TIFFfree(scanline);\n\tif(logger_.isVerbose()) logger_.logVerbose(getFormatName(), \": Done.\");\n\treturn true;\n}",
    "int R2Image::\nWriteTIFF(const char *filename) const\n{\n#ifdef RN_USE_TIFF\n  // Open TIFF file\n  TIFF *out = TIFFOpen(filename, \"w\");\n  if (!out) {\n    fprintf(stderr, \"Unable to open TIFF file %s\\n\", filename);\n    return 0;\n  }\n\n  // Set TIFF parameters\n  TIFFSetField(out, TIFFTAG_IMAGEWIDTH, width);\n  TIFFSetField(out, TIFFTAG_IMAGELENGTH, height);\n  TIFFSetField(out, TIFFTAG_ORIENTATION, ORIENTATION_BOTLEFT);\n  TIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, 3);\n  TIFFSetField(out, TIFFTAG_BITSPERSAMPLE, 8);\n  TIFFSetField(out, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n  TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n  TIFFSetField(out, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n  TIFFSetField(out, TIFFTAG_ROWSPERSTRIP, 1);\n\n  // Allocate data for scan lines\n  int scanline_size = TIFFScanlineSize(out);\n  unsigned char *buf = (unsigned char *)_TIFFmalloc(scanline_size);\n  if (!buf) {\n    fprintf(stderr, \"Unable to allocate memory for TIFF scan lines\\n\");\n    return 0;\n  }\n\n  // Write scan lines to TIFF file\n  for (int row = 0; row < height; row++) {\n    const unsigned char *p = Pixels(row);\n    if (TIFFWriteScanline(out, (tdata_t) p, height - row - 1, 0) < 0) {\n      fprintf(stderr, \"Unable to write scanline to TIFF image %s\\n\", filename);\n      return 0;\n    }\n  }\n\n  // Free data for scan lines\n  _TIFFfree(buf);\n\n  // Close TIFF file\n  TIFFClose(out);\n\n  // Return success\n  return 1;\n#else\n  RNFail(\"TIFF not supported\");\n  return 0;\n#endif\n}",
    "bool TiffDetails::savePict(QString strFilename, QImage img, const SessionItem *pItem)\n{\n   if (strFilename.isEmpty() || img.isNull())\n   {\n      return false;\n   }\n\n   std::string filename = strFilename.toStdString();\n\n   unsigned int outputWidth = img.width();\n   unsigned int outputHeight = img.height();\n\n   if (mpOptionsWidget.get() == NULL)\n   {\n      computeExportResolution(outputWidth, outputHeight);\n   }\n   else\n   {\n      mpOptionsWidget->getResolution(outputWidth, outputHeight);\n   }\n   img = img.scaled(outputWidth, outputHeight);\n\n#if defined(WIN_API)\n   // replace \"/\" with \"\\\\\" to accommodate the sgi specific code\n   // in the library\n   unsigned int i;\n   for (i = 0; i < filename.length(); i++)\n   {\n      if (filename[i] == '/')\n      {\n         filename[i] = '\\\\';\n      }\n   }\n#endif\n\n   //open the file to write\n   TIFF* pOut = XTIFFOpen(filename.c_str(), \"wb\");\n   if (pOut == NULL)\n   {\n      return false;\n   }\n\n   unsigned int rowsPerStrip = OptionsTiffExporter::getSettingRowsPerStrip();\n   bool packBits = OptionsTiffExporter::getSettingPackBitsCompression();\n   bool saveBackgroundAsTransparent = isBackgroundTransparent();\n   if (mpOptionsWidget.get() != NULL)\n   {\n      rowsPerStrip = mpOptionsWidget->getRowsPerStrip();\n      packBits = mpOptionsWidget->getPackBitsCompression();\n   }\n   int samplesPerPixel = 3;\n   if (saveBackgroundAsTransparent)\n   {\n      samplesPerPixel = 4;\n   }\n   // Initialize private variables for tiff\n   TIFFSetField(pOut, TIFFTAG_IMAGEWIDTH, static_cast<uint32>(img.width()));\n   TIFFSetField(pOut, TIFFTAG_IMAGELENGTH, static_cast<uint32>(img.height()));\n   TIFFSetField(pOut, TIFFTAG_BITSPERSAMPLE, 8);\n   TIFFSetField(pOut, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n   TIFFSetField(pOut, TIFFTAG_SAMPLESPERPIXEL, samplesPerPixel);\n   TIFFSetField(pOut, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n   TIFFSetField(pOut, TIFFTAG_ROWSPERSTRIP, rowsPerStrip);\n   TIFFSetField(pOut, TIFFTAG_COMPRESSION, (packBits ? COMPRESSION_PACKBITS : COMPRESSION_NONE));\n\n   //allocate the memory needed\n   tdata_t pBuf = _TIFFmalloc(TIFFScanlineSize(pOut));\n\n   //determine if we should mask out the background pixels\n   //loop through the image and convert to tiff and write to the file\n   int x;\n   int y;\n   for (y = 0; y < img.height(); y++) \n   {\n      uint8* pp = static_cast<uint8*>(pBuf);\n\n      QRgb* pData = reinterpret_cast<QRgb*>(img.scanLine(y));\n      for (x = 0; x < img.width(); x++) \n      {\n         pp[0] = qRed(pData[x]);\n         pp[1] = qGreen(pData[x]);\n         pp[2] = qBlue(pData[x]);\n         if (saveBackgroundAsTransparent)\n         {\n            pp[3] = qAlpha(pData[x]);\n         }\n\n         pp += samplesPerPixel;\n      }\n\n      //write out 1 row and check for error\n      if (TIFFWriteScanline(pOut, pBuf, y, 0) < 0)\n      {\n         //error message\n         return false;\n      }\n   }\n\n   // Add in the geo info if it is available\n   addGeoKeys(pOut, img.width(), img.height(), pItem);\n\n   XTIFFClose(pOut);\n   return true;\n}",
    "bool GeoTIFFExporter::writeCube(TIFF* pOut)\n{\n   if (pOut == NULL)\n   {\n      return false;\n   }\n\n   VERIFY(mpRaster != NULL);\n   VERIFY(mpFileDescriptor != NULL);\n\n   const RasterDataDescriptor* pDescriptor = dynamic_cast<const RasterDataDescriptor*>(mpRaster->getDataDescriptor());\n   if (pDescriptor == NULL)\n   {\n      return false;\n   }\n\n   int size = 0;\n   int row = 0;\n   unsigned char* pBuffer = NULL;\n   unsigned short numRows = pDescriptor->getRowCount();\n   unsigned short numCols = pDescriptor->getColumnCount();\n   unsigned short numBands = pDescriptor->getBandCount();\n   unsigned short scols = mpFileDescriptor->getColumnCount();\n   unsigned short srows = mpFileDescriptor->getRowCount();\n   unsigned short sbands = mpFileDescriptor->getBandCount();\n\n   FactoryResource<DataRequest> pRequest;\n   pRequest->setInterleaveFormat(BIP);\n   DataAccessor accessor = mpRaster->getDataAccessor(pRequest.release());\n   if (!accessor.isValid())\n   {\n      mMessage = \"Could not get a valid BIP accessor for this dataset.\";\n      if (mpProgress != NULL)\n      {\n         mpProgress->updateProgress(mMessage, 0, ERRORS);\n      }\n\n      return false;\n   }\n\n   InterleaveFormatType eInterleave = pDescriptor->getInterleaveFormat();\n   if (eInterleave != BIP)\n   {\n      mMessage = \"Data will be saved in BIP format.\";\n      if (mpProgress != NULL)\n      {\n         mpProgress->updateProgress(mMessage, 0, WARNING);\n      }\n   }\n\n   unsigned int bytesPerElement(pDescriptor->getBytesPerElement());\n   size = scols * sbands * bytesPerElement;\n\n   TIFFSetField(pOut, TIFFTAG_IMAGEWIDTH, scols);\n   TIFFSetField(pOut, TIFFTAG_IMAGELENGTH, srows);\n   TIFFSetField(pOut, TIFFTAG_SAMPLESPERPIXEL, sbands);\n\n   //for this tag, must multiply by # of bytes per data type\n   TIFFSetField(pOut, TIFFTAG_BITSPERSAMPLE, static_cast<unsigned short>(bytesPerElement * 8));\n   TIFFSetField(pOut, TIFFTAG_SAMPLEFORMAT, static_cast<unsigned short>(\n                           getTiffSampleFormat(pDescriptor->getDataType())));\n\n   bool packBits = OptionsTiffExporter::getSettingPackBitsCompression();\n   if (mpOptionWidget.get() != NULL)\n   {\n      packBits = mpOptionWidget->getPackBitsCompression();\n   }\n   ttag_t compOpt = (packBits ? COMPRESSION_PACKBITS : COMPRESSION_NONE);\n\n   TIFFSetField(pOut, TIFFTAG_COMPRESSION, compOpt);\n   TIFFSetField(pOut, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n   TIFFSetField(pOut, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n   TIFFSetField(pOut, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);      //????\n   TIFFSetField(pOut, TIFFTAG_ROWSPERSTRIP, mRowsPerStrip);\n\n   //ready to test write\n   mMessage = \"Writing out GeoTIFF file...\";\n   if (mpProgress)\n   {\n      mpProgress->updateProgress( mMessage, 0, NORMAL);\n   }\n\n   if ((numRows == srows) && (numCols == scols) && (numBands == sbands))   // full cube write from memory\n   {\n      for (row = 0; row < srows; row++)\n      {\n         if (mAbortFlag)\n         {\n            mMessage = \"GeoTIFF export aborted!\";\n            if (mpProgress != NULL)\n            {\n               mpProgress->updateProgress(mMessage, 0, ERRORS);\n            }\n\n            return false;\n         }\n\n         VERIFY(accessor.isValid());\n         pBuffer = reinterpret_cast<unsigned char*>(accessor->getRow());\n         if (pBuffer != NULL)\n         {\n            if (TIFFWriteScanline(pOut, pBuffer, row, size) < 0)\n            {\n               mMessage = \"Unable to save GeoTIFF file, check folder permissions.\";\n               if (mpProgress)\n               {\n                  mpProgress->updateProgress(mMessage, 0, ERRORS);\n               }\n\n               return false;\n            }\n\n            updateProgress(row, srows, mMessage, NORMAL);\n         }\n         accessor->nextRow();\n      }\n   }\n   else // subcube write\n   {\n      const vector<DimensionDescriptor>& rows = mpFileDescriptor->getRows();\n      const vector<DimensionDescriptor>& columns = mpFileDescriptor->getColumns();\n      const vector<DimensionDescriptor>& bands = mpFileDescriptor->getBands();\n\n      unsigned int activeRowNumber = 0;\n      unsigned int rowSize(0);\n      unsigned int outRow(0);\n      for (unsigned int r = 0; r < srows; ++r)\n      {\n         if (mAbortFlag == true)\n         {\n            mMessage = \"GeoTIFF export aborted!\";\n            if (mpProgress != NULL)\n            {\n               mpProgress->updateProgress(mMessage, 0, ERRORS);\n            }\n\n            return false;\n         }\n\n         DimensionDescriptor rowDim = rows[r];\n         if (rowDim.isActiveNumberValid())\n         {\n            // Skip to the next row\n            for (; activeRowNumber < rowDim.getActiveNumber(); ++activeRowNumber)\n            {\n               accessor->nextRow();\n            }\n\n            VERIFY(accessor.isValid());\n\n            vector<char> rowData(size);\n            if (rowData.empty())\n            {\n               mMessage = \"Error GeoTIFFExporter008: Unable to allocate row buffer.\";\n               if (mpProgress)\n               {\n                  mpProgress->updateProgress(mMessage, 0, ERRORS);\n               }\n\n               return false;\n            }\n\n            unsigned int activeColumnNumber = 0;\n\n            char* pExportData = &(rowData.front());\n            for (unsigned int c = 0; c < scols; ++c)\n            {\n               DimensionDescriptor columnDim = columns[c];\n               if (columnDim.isActiveNumberValid())\n               {\n                  // Skip to the next column\n                  for (; activeColumnNumber < columnDim.getActiveNumber(); ++activeColumnNumber)\n                  {\n                     accessor->nextColumn();\n                  }\n\n                  char* pCurrentPixel = reinterpret_cast<char*>(accessor->getColumn());\n\n                  unsigned int activeBandNumber = 0;\n                  for (unsigned int b = 0; b < sbands; ++b)\n                  {\n                     DimensionDescriptor bandDim = bands[b];\n                     if (bandDim.isActiveNumberValid())\n                     {\n                        // Skip to the next band\n                        for (; activeBandNumber < bandDim.getActiveNumber(); ++activeBandNumber)\n                        {\n                           pCurrentPixel += bytesPerElement;\n                        }\n\n                        memcpy(pExportData, pCurrentPixel, bytesPerElement);\n                        pExportData += bytesPerElement;\n                        rowSize += bytesPerElement;\n                     }\n                  }\n               }\n               else // this column is not included, go to next column \n               {\n                  accessor->nextColumn();\n               }\n            }\n\n            if (rowSize > 0)\n            {\n               // write here\n               if (TIFFWriteScanline(pOut, &rowData[0], outRow, size) < 0)\n               {\n                  mMessage = \"Error GeoTIFFExporter006: Unable to save GeoTIFF file, check folder permissions.\";\n                  if (mpProgress)\n                  {\n                     mpProgress->updateProgress(mMessage, 0, ERRORS);\n                  }\n\n                  return false;\n               }\n\n               updateProgress(outRow++, srows, mMessage, NORMAL);\n            }\n         }\n         else // this row is not included, go to next row\n         {\n            accessor->nextRow();\n         }\n      }\n   }\n\n   //assumed everything has been done correctly up to now\n   //copy over Geo ref info if there are any, else\n   //try to look for world file in same directory and apply\n   if (!(applyWorldFile(pOut)))\n   {\n      if (!(CreateGeoTIFF(pOut)))\n      {\n         //no geo info found, where is it located?\n         mMessage = \"Geo data is unavailable and will not be written to the output file!\";\n         updateProgress(srows, srows, mMessage, WARNING);\n         if (mpStep != NULL)\n         {\n            mpStep->addMessage(mMessage, \"app\", \"9C1E7ADE-ADC4-468c-B15E-FEB53D5FEF5B\", true);\n         }\n      }\n   }\n\n   return true;\n}",
    "int writeTiff(char const *const filename, char const *const data,\n              const VkExtent2D size, const size_t nchannels)\n{\n    TIFF *tif = TIFFOpen(filename, \"w\");\n    if (tif == NULL)\n        return 1;\n\n    const size_t sample_bits = 8;\n\n    TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, size.width);\n    TIFFSetField(tif, TIFFTAG_IMAGELENGTH, size.height);\n    TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, nchannels);\n    TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, sample_bits);\n    TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_LZW);\n    TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    if (nchannels == 1)\n        TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n    else\n        TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n\n    for (size_t i = 0; i < size.height; i++) {\n        if (TIFFWriteScanline(tif, (void *) &data[i * size.width * nchannels], i, 0) < 0) {\n            TIFFClose(tif);\n            return 1;\n        }\n    }\n\n    TIFFClose(tif);\n    return 0;\n}",
    "ILboolean iSaveTiffInternal(/*ILconst_string Filename*/)\n{\n\tILenum\tFormat;\n\tILenum\tCompression;\n\tILuint\tixLine;\n\tTIFF\t*File;\n\tchar\tDescription[512];\n\tILimage *TempImage;\n\tconst char\t*str;\n\tILboolean SwapColors;\n\tILubyte *OldData;\n\n\tif(iCurImage == NULL) {\n\t\tilSetError(IL_ILLEGAL_OPERATION);\n\t\treturn IL_FALSE;\n\t}\n\n#if 1\n\tTIFFSetWarningHandler (NULL);\n\tTIFFSetErrorHandler   (NULL);\n#else\n\t//for debugging only\n\tTIFFSetWarningHandler(warningHandler);\n\tTIFFSetErrorHandler(errorHandler);\n#endif\n\tif (iGetHint(IL_COMPRESSION_HINT) == IL_USE_COMPRESSION)\n\t\tCompression = COMPRESSION_LZW;\n\telse\n\t\tCompression = COMPRESSION_NONE;\n\n\tif (iCurImage->Format == IL_COLOUR_INDEX) {\n\t\tif (ilGetBppPal(iCurImage->Pal.PalType) == 4)  // Preserve the alpha.\n\t\t\tTempImage = iConvertImage(iCurImage, IL_RGBA, IL_UNSIGNED_BYTE);\n\t\telse\n\t\t\tTempImage = iConvertImage(iCurImage, IL_RGB, IL_UNSIGNED_BYTE);\n\t\t\n\t\tif (TempImage == NULL) {\n\t\t\treturn IL_FALSE;\n\t\t}\n\t}\n\telse {\n\t\tTempImage = iCurImage;\n\t}\n\n\t/*#ifndef _UNICODE\n\t\tFile = TIFFOpen(Filename, \"w\");\n\t#else\n\t\tFile = TIFFOpenW(Filename, \"w\");\n\t#endif*/\n\n\t// Control writing functions ourself.\n\tFile = iTIFFOpen((char*)\"w\");\n\tif (File == NULL) {\n\t\tilSetError(IL_COULD_NOT_OPEN_FILE);\n\t\treturn IL_FALSE;\n\t}\n\n#ifdef _UNICODE\n\tsprintf(Description, \"Tiff generated by %Ls\", ilGetString(IL_VERSION_NUM));\n#else// _UNICODE\n\tsprintf(Description, \"Tiff generated by %s\", ilGetString(IL_VERSION_NUM));\n#endif// _UNICODE\n\n\tTIFFSetField(File, TIFFTAG_IMAGEWIDTH, TempImage->Width);\n\tTIFFSetField(File, TIFFTAG_IMAGELENGTH, TempImage->Height);\n\tTIFFSetField(File, TIFFTAG_COMPRESSION, Compression);\n\tTIFFSetField(File, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n\tTIFFSetField(File, TIFFTAG_BITSPERSAMPLE, TempImage->Bpc << 3);\n\tTIFFSetField(File, TIFFTAG_SAMPLESPERPIXEL, TempImage->Bpp);\n\tif (TempImage->Bpp == 4) //TODO: LUMINANCE, LUMINANCE_ALPHA\n\t\tTIFFSetField(File, TIFFTAG_MATTEING, 1);\n\tTIFFSetField(File, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\tTIFFSetField(File, TIFFTAG_ROWSPERSTRIP, 1);\n\tTIFFSetField(File, TIFFTAG_SOFTWARE, ilGetString(IL_VERSION_NUM));  //@TODO: Will probably not work properly under Windows if Unicode\n\t/*TIFFSetField(File, TIFFTAG_DOCUMENTNAME,\n\t\tiGetString(IL_TIF_DOCUMENTNAME_STRING) ?\n\t\tiGetString(IL_TIF_DOCUMENTNAME_STRING) : FileName);\n*/\n\tstr = iGetString(IL_TIF_DOCUMENTNAME_STRING);\n\tif (str) {\n\t\tTIFFSetField(File, TIFFTAG_DOCUMENTNAME, str);\n\t\tifree(str);\n\t}\n\n\n\tstr = iGetString(IL_TIF_AUTHNAME_STRING);\n\tif (iGetString(IL_TIF_AUTHNAME_STRING)) {\n\t\tTIFFSetField(File, TIFFTAG_ARTIST, str);\n\t\tifree(str);\n\t}\n\n\tstr = iGetString(IL_TIF_HOSTCOMPUTER_STRING);\n\tif (str) {\n\t\tTIFFSetField(File, TIFFTAG_HOSTCOMPUTER, str);\n\t\tifree(str);\n\t}\n\n\tstr = iGetString(IL_TIF_HOSTCOMPUTER_STRING);\n\tif (str) {\n\t\tTIFFSetField(File, TIFFTAG_IMAGEDESCRIPTION, str);\n\t\tifree(str);\n\t}\n\n\t// Set the date and time string.\n\tTIFFSetField(File, TIFFTAG_DATETIME, iMakeString());\n\n\t// 24/4/2003\n\t// Orientation flag is not always supported (Photoshop, ...), orient the image data \n\t// and set it always to normal view\n\tTIFFSetField(File, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n\tif (TempImage->Origin != IL_ORIGIN_UPPER_LEFT) {\n\t\tILubyte* Data = iGetFlipped(TempImage);\n\t\tOldData = TempImage->Data;\n\t\tTempImage->Data = Data;\n\t}\n\telse\n\t\tOldData = TempImage->Data;\n\n\t/*\n\t TIFFSetField(File, TIFFTAG_ORIENTATION,\n\t\t\t\t  TempImage->Origin == IL_ORIGIN_UPPER_LEFT ? ORIENTATION_TOPLEFT : ORIENTATION_BOTLEFT);\n\t */\n\n\tFormat = TempImage->Format;\n\tSwapColors = (Format == IL_BGR || Format == IL_BGRA);\n\tif (SwapColors)\n \t\tilSwapColours();\n\n\tfor (ixLine = 0; ixLine < TempImage->Height; ++ixLine) {\n\t\tif (TIFFWriteScanline(File, TempImage->Data + ixLine * TempImage->Bps, ixLine, 0) < 0) {\n\t\t\tTIFFClose(File);\n\t\t\tilSetError(IL_LIB_TIFF_ERROR);\n\t\t\tif (SwapColors)\n\t\t\t\tilSwapColours();\n\t\t\tif (TempImage->Data != OldData) {\n\t\t\t\tifree( TempImage->Data );\n\t\t\t\tTempImage->Data = OldData;\n\t\t\t}\n\t\t\tif (TempImage != iCurImage)\n\t\t\t\tilCloseImage(TempImage);\n\t\t\treturn IL_FALSE;\n\t\t}\n\t}\n\n\tif (SwapColors)\n \t\tilSwapColours();\n\n\tif (TempImage->Data != OldData) {\n\t\tifree(TempImage->Data);\n\t\tTempImage->Data = OldData;\n\t}\n\n\tif (TempImage != iCurImage)\n\t\tilCloseImage(TempImage);\n\n\tTIFFClose(File);\n\n\treturn IL_TRUE;\n}",
    "void DngWriter::processTight(TIFF *tif) {\n    LOGD(\"IN SXXXXl0\");\n    int i, j, row, col, b;\n    unsigned char *buffer, *dp;\n    unsigned short pixel[dngProfile->rawwidht]; // array holds 16 bits per pixel\n\n    LOGD(\"buffer set\");\n    j=0;\n    if(dngProfile->rowSize == 0)\n        dngProfile->rowSize =  -(-5 * dngProfile->rawwidht >> 5) << 3;\n    buffer =(unsigned char *)malloc(dngProfile->rowSize);\n    memset( buffer, 0, dngProfile->rowSize);\n    if (buffer == NULL)\n    {\n        LOGD(\"allocating buffer failed try again\");\n        buffer =(unsigned char *)malloc(dngProfile->rowSize);\n    }\n    LOGD(\"rowsize:%i\", dngProfile->rowSize);\n\n    for (row=0; row < dngProfile->rawheight; row ++)\n    {\n        i = 0;\n        for(b = row * dngProfile->rowSize; b < row * dngProfile->rowSize + dngProfile->rowSize; b++)\n            buffer[i++] = bayerBytes[b];\n        for (dp=buffer, col = 0; col < dngProfile->rawwidht; dp+=5, col+= 4)\n        {\n            for(int i = 0; i< 4; i++)\n            {\n                pixel[col+i] = (dp[i] <<2) | (dp[4] >> (i << 1) & 3);\n            }\n        }\n\n        if (TIFFWriteScanline(tif, pixel, row, 0) != 1) {\n            LOGD(\"Error writing TIFF scanline.\");\n        }\n    }\n    LOGD(\"Write done\");\n    if(buffer != NULL)\n    {\n        LOGD(\"Free Buffer\");\n        free(buffer);\n        LOGD(\"Freed Buffer\");\n    }\n    LOGD(\"Mem Released\");\n}",
    "void DngWriter::processLoose(TIFF *tif) {\n    int i, row, col, b;\n    unsigned char *buffer, *dp;\n    unsigned short pixel[dngProfile->rawwidht]; // array holds 16 bits per pixel\n\n    uint64 colorchannel;\n\n    dngProfile->rowSize= (dngProfile->rawwidht+5)/6 << 3;\n    buffer =(unsigned char *)malloc(dngProfile->rowSize);\n    memset( buffer, 0, dngProfile->rowSize);\n    if (buffer == NULL)\n    {\n        LOGD(\"allocating buffer failed try again\");\n        buffer =(unsigned char *)malloc(dngProfile->rowSize);\n    }\n    for (row=0; row < dngProfile->rawheight; row ++)\n    {\n        i = 0;\n        for(b = row * dngProfile->rowSize; b < (row * dngProfile->rowSize) + dngProfile->rowSize; b++)\n            buffer[i++] = bayerBytes[b];\n        /*\n         * get 5 bytes from buffer and move first 4bytes to 16bit\n         * split the 5th byte and add the value to the first 4 bytes\n         * */\n        for (dp=buffer, col = 0; col < dngProfile->rawwidht; dp+=8, col+= 6)\n        { // iterate over pixel columns\n\n            for(int i =0; i< 8; i++)\n            {\n                colorchannel = (colorchannel << 8) | dp[i^7];\n            }\n\n            for(int i =0; i< 6; i++)\n            {\n                pixel[col+i] = (colorchannel >> i*10) & 0x3ff;\n            }\n\n        }\n        if (TIFFWriteScanline (tif, pixel, row, 0) != 1) {\n            LOGD(\"Error writing TIFF scanline.\");\n        }\n    }\n    LOGD(\"Free Memory processLoose\");\n    if(buffer != NULL)\n    {\n        LOGD(\"Free Buffer\");\n        free(buffer);\n        LOGD(\"Freed Buffer\");\n    }\n\n    LOGD(\"Mem Released\");\n}",
    "void DngWriter::processSXXX16(TIFF *tif) {\n    int j, row, col;\n    unsigned short pixel[dngProfile->rawwidht];\n    unsigned short pixel2[dngProfile->rawwidht];\n    unsigned short low, high;\n    j=0;\n    for (row=0; row < dngProfile->rawheight; row+=2)\n    {\n        for (col = 0; col < dngProfile->rawwidht; col++)\n        { // iterate over pixel columns\n            int pos = (dngProfile->rawwidht * row + col)*2;\n            low = bayerBytes[pos];\n            high =   bayerBytes[pos+1];\n            pixel[col] =  high << 8 |low;\n            pos = (dngProfile->rawwidht * (row+1) + col)*2;\n            low = bayerBytes[pos];\n            high =   bayerBytes[pos+1];\n            pixel2[col] =  high << 8 |low;\n        }\n        if (TIFFWriteScanline (tif, pixel, row, 0) != 1) {\n            LOGD(\"Error writing TIFF scanline.\");\n        }\n        if (TIFFWriteScanline (tif, pixel2, row+1, 0) != 1) {\n            LOGD(\"Error writing TIFF scanline.\");\n        }\n    }\n\n    LOGD(\"Finalizng DNG\");\n    LOGD(\"Free Memory processSXXX16\");\n}",
    "void DngWriter::processSXXX16crop(TIFF *tif) {\n    LOGD(\"processSXXX16crop\");\n    int j, row, col, j2;\n    unsigned short pixel[crop_width];\n    unsigned short low, high;\n    int w_diff = dngProfile->rawwidht - crop_width;\n    int h_diff = dngProfile->rawheight - crop_height;\n    int offset_x = w_diff/2;\n    int offset_y = h_diff/2;\n    LOGD(\"crop w: %i h: %i offset x: %i y: %i\" ,crop_width,crop_height, offset_x,offset_y);\n    j=0;\n    j2 = 0;\n    for (row=offset_y; row < dngProfile->rawheight-offset_y; row++)\n    {\n        j=0;\n        for (col = offset_x; col < dngProfile->rawwidht - offset_x; col++)\n        { // iterate over pixel columns\n            int pos = (dngProfile->rawwidht * row + col)*2;\n            low = bayerBytes[pos];\n            high =   bayerBytes[pos+1];\n            pixel[j++] =  high << 8 |low;\n        }\n        if (TIFFWriteScanline (tif, pixel, j2++, 0) != 1) {\n            LOGD(\"Error writing TIFF scanline.\");\n        }\n    }\n\n    LOGD(\"Finalizng DNG\");\n    LOGD(\"Free Memory processSXXX16crop\");\n}",
    "void DngWriter::quadBayer16bit(TIFF *tif) {\n\n    int row, col;\n    unsigned short pixel[dngProfile->rawwidht];\n    unsigned short pixel2[dngProfile->rawwidht];\n    unsigned short pixel3[dngProfile->rawwidht];\n    unsigned short pixel4[dngProfile->rawwidht];\n    unsigned short r1,r2,r3,r4;\n    unsigned short g1,g2,g3,g4;\n    unsigned short gg1,gg2,gg3,gg4;\n    unsigned short b1,b2,b3,b4;\n\n    for (row=0; row < dngProfile->rawheight; row+=4)\n    {\n        for (col = 0; col < dngProfile->rawwidht; col+=4)\n        { // iterate over pixel columns\n            r1 = getColor(row,col);\n            r2 = getColor(row, col+1);\n            r3 = getColor(row+1,col);\n            r4 = getColor(row+1,col+1);\n            g1 = getColor(row,col+2);\n            g2 = getColor(row,col+3);\n            g3 = getColor(row+1,col+2);\n            g4 = getColor(row+1,col+3);\n\n            gg1 = getColor(row+2,col);\n            gg2 = getColor(row+2,col+1);\n            gg3 = getColor(row+3,col);\n            gg4 = getColor(row+3,col+1);\n            b1 = getColor(row+2,col+2);\n            b2 = getColor(row+2,col+3);\n            b3 = getColor(row+3,col+2);\n            b4 = getColor(row+3,col+3);\n\n            pixel[col] = r1;\n            pixel[col+1] = g1;\n            pixel[col+2] = r2;\n            pixel[col+3] = g2;\n            pixel3[col] = r3;\n            pixel3[col+1] = g3;\n            pixel3[col+2] = r4;\n            pixel3[col+3] = g4;\n\n            pixel2[col] = gg1;\n            pixel2[col+1] = b1;\n            pixel2[col+2] = gg2;\n            pixel2[col+3] = b2;\n            pixel4[col] = gg3;\n            pixel4[col+1] = b3;\n            pixel4[col+2] = gg4;\n            pixel4[col+3] = b4;\n\n        }\n        if (TIFFWriteScanline (tif, pixel, row, 0) != 1) {\n            LOGD(\"Error writing TIFF scanline.\");\n        }\n        if (TIFFWriteScanline (tif, pixel2, row+1, 0) != 1) {\n            LOGD(\"Error writing TIFF scanline.\");\n        }\n        if (TIFFWriteScanline (tif, pixel3, row+2, 0) != 1) {\n            LOGD(\"Error writing TIFF scanline.\");\n        }\n        if (TIFFWriteScanline (tif, pixel4, row+3, 0) != 1) {\n            LOGD(\"Error writing TIFF scanline.\");\n        }\n    }\n\n    LOGD(\"Finalizng DNG\");\n    LOGD(\"Free Memory quadBayer16bit\");\n}",
    "int ImageMatrix::SaveTiff(char *filename) {\n\treadOnlyPixels pix_plane = ReadablePixels();\n\n\tunsigned int x,y;\n\tTIFF* tif = TIFFOpen(filename, \"w\");\n\tif (!tif) return(0);\n\tunsigned short *BufImage16 = new unsigned short[width*height];\n\tif (!BufImage16) {\n\t\tTIFFClose(tif);\n\t\treturn (0);\n\t}\n\tunsigned char *BufImage8 = new unsigned char[width*height];\n\tif (!BufImage8) {\n\t\tTIFFClose(tif);\n\t\tdelete[] BufImage16;\n\t\treturn (0);\n\t}\n\n\n\tfor (y = 0; y < height; y++)\n\t\tfor (x = 0; x < width ; x++) {\n\t\t\tif (bits==16) BufImage16[x + (y * width)] = (unsigned short) ( pix_plane (y,x) );\n\t\t\telse BufImage8[x + (y * width)] = (unsigned char) ( pix_plane (y,x) );\n\t\t}\n\n\tTIFFSetField(tif,TIFFTAG_IMAGEWIDTH, width);\n\tTIFFSetField(tif,TIFFTAG_IMAGELENGTH, height);\n\tTIFFSetField(tif, TIFFTAG_PLANARCONFIG,1);\n\tTIFFSetField(tif, TIFFTAG_PHOTOMETRIC, 1);\n\tTIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, bits);\n\tTIFFSetField(tif, TIFFTAG_COMPRESSION, 1);\n\tTIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 1);\n\n\tfor (y = 0; y < height; y ++) {\n\t\tif (bits==16) TIFFWriteScanline (tif, &(BufImage16[y*width]), y,0 );\n\t\telse TIFFWriteScanline (tif, &(BufImage8[y*width]), y,0 );\n\t}\n\n\tTIFFClose(tif);\n\tdelete[] BufImage16;\n\tdelete[] BufImage8;\n\treturn(1);\n}",
    "WriteResult::WriteStatus writeTIFStream(std::ostream& fout, const osg::Image& img, const osgDB::ReaderWriter::Options* options) const\n        {\n            int compressionType = COMPRESSION_PACKBITS;\n            if (options) {\n                std::istringstream iss(options->getOptionString());\n                std::string opt;\n                while (iss >> opt) {\n                    opt = osgDB::convertToLowerCase(opt);\n\n                    std::size_t eqInd = opt.find(\"=\");\n                    if (opt.substr(0, eqInd) == \"tiff_compression\") {\n                        std::string compressTypeOpt;\n                        compressTypeOpt = opt.substr(eqInd + 1);\n                        compressTypeOpt = osgDB::convertToLowerCase(compressTypeOpt);\n                        if (compressTypeOpt == \"packbits\") {\n                            compressionType = COMPRESSION_PACKBITS;\n                        }\n                        else if (compressTypeOpt == \"lzw\") {\n                            compressionType = COMPRESSION_LZW;\n                        }\n                        else if (compressTypeOpt == \"jpeg\") {\n                            compressionType = COMPRESSION_JPEG;\n                        }\n                        else if (compressTypeOpt == \"none\") {\n                            compressionType = COMPRESSION_NONE;\n                        }\n                    }\n                }\n            }\n\n\n            //Code is based from the following article on CodeProject.com\n            //http://www.codeproject.com/bitmap/BitmapsToTiffs.asp\n\n            TIFF *image;\n            int samplesPerPixel;\n            int bitsPerSample;\n            uint16 photometric;\n\n            image = TIFFClientOpen(\"outputstream\", \"w\", (thandle_t)&fout,\n                                    libtiffOStreamReadProc, //Custom read function\n                                    libtiffOStreamWriteProc, //Custom write function\n                                    libtiffOStreamSeekProc, //Custom seek function\n                                    libtiffStreamCloseProc, //Custom close function\n                                    libtiffOStreamSizeProc, //Custom size function\n                                    libtiffStreamMapProc, //Custom map function\n                                    libtiffStreamUnmapProc); //Custom unmap function\n\n            if(image == NULL)\n            {\n                return WriteResult::ERROR_IN_WRITING_FILE;\n            }\n\n            switch(img.getPixelFormat()) {\n                case GL_DEPTH_COMPONENT:\n                case GL_LUMINANCE:\n                case GL_ALPHA:\n                case GL_RED:\n                    photometric = PHOTOMETRIC_MINISBLACK;\n                    samplesPerPixel = 1;\n                    break;\n                case GL_LUMINANCE_ALPHA:\n                case GL_RG:\n                    photometric = PHOTOMETRIC_MINISBLACK;\n                    samplesPerPixel = 2;\n                    break;\n                case GL_RGB:\n                    photometric = PHOTOMETRIC_RGB;\n                    samplesPerPixel = 3;\n                    break;\n                case GL_RGBA:\n                    photometric = PHOTOMETRIC_RGB;\n                    samplesPerPixel = 4;\n                    break;\n                default:\n                    return WriteResult::ERROR_IN_WRITING_FILE;\n                    break;\n            }\n\n            uint32 rowsperstrip = 0;\n\n            switch(img.getDataType()){\n                case GL_FLOAT:\n                    TIFFSetField(image, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);\n                    rowsperstrip = 1;\n                    bitsPerSample = 32;\n                    break;\n                case GL_SHORT:\n                    TIFFSetField(image, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_INT);\n                    bitsPerSample = 16;\n                    break;\n                case GL_UNSIGNED_SHORT:\n                    TIFFSetField(image, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT);\n                    bitsPerSample = 16;\n                    break;\n                default:\n                    bitsPerSample = 8;\n                    break;\n            }\n\n            TIFFSetField(image, TIFFTAG_IMAGEWIDTH,img.s());\n            TIFFSetField(image, TIFFTAG_IMAGELENGTH,img.t());\n            TIFFSetField(image, TIFFTAG_BITSPERSAMPLE,bitsPerSample);\n            TIFFSetField(image, TIFFTAG_SAMPLESPERPIXEL,samplesPerPixel);\n            TIFFSetField(image, TIFFTAG_PHOTOMETRIC, photometric);\n            TIFFSetField(image, TIFFTAG_COMPRESSION, compressionType);\n            TIFFSetField(image, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);\n            TIFFSetField(image, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\n            if (rowsperstrip==0) rowsperstrip = TIFFDefaultStripSize(image, 0);\n            TIFFSetField(image, TIFFTAG_ROWSPERSTRIP, rowsperstrip);\n\n            // Write the information to the file\n            for(int i = 0; i < img.t(); ++i) {\n                TIFFWriteScanline(image,(tdata_t)img.data(0,img.t()-i-1),i,0);\n            }\n\n            // Close the file\n            TIFFClose(image);\n\n            return WriteResult::FILE_SAVED;\n        }",
    "void Write::_write(const std::string& fileName, const std::shared_ptr<Image::Data>& image)\n            {\n                File f;\n#if defined(DJV_PLATFORM_WINDOWS)\n                f.f = TIFFOpen(fileName.data(), \"w\");\n#else\n                f.f = TIFFOpen(fileName.data(), \"w\");\n#endif // DJV_WINDOWS\n                if (!f.f)\n                {\n                    throw System::File::Error(String::Format(\"{0}: {1}\").\n                        arg(fileName).\n                        arg(_textSystem->getText(DJV_TEXT(\"error_file_open\"))));\n                }\n\n                const auto& info = image->getInfo();\n                uint16 photometric      = 0;\n                uint16 samples          = 0;\n                uint16 sampleDepth      = 0;\n                uint16 sampleFormat     = 0;\n                uint16 extraSamples[]   = { EXTRASAMPLE_ASSOCALPHA };\n                uint16 extraSamplesSize = 0;\n                uint16 compression      = 0;\n                switch (Image::getChannelCount(info.type))\n                {\n                case 1:\n                    photometric = PHOTOMETRIC_MINISBLACK;\n                    samples = 1;\n                    break;\n                case 2:\n                    photometric = PHOTOMETRIC_MINISBLACK;\n                    samples = 2;\n                    extraSamplesSize = 1;\n                    break;\n                case 3:\n                    photometric = PHOTOMETRIC_RGB;\n                    samples = 3;\n                    break;\n                case 4:\n                    photometric = PHOTOMETRIC_RGB;\n                    samples = 4;\n                    extraSamplesSize = 1;\n                    break;\n                default: break;\n                }\n                switch (Image::getDataType(info.type))\n                {\n                case Image::DataType::U8:\n                    sampleDepth = 8;\n                    sampleFormat = SAMPLEFORMAT_UINT;\n                    break;\n                case Image::DataType::U16:\n                    sampleDepth = 16;\n                    sampleFormat = SAMPLEFORMAT_UINT;\n                    break;\n                case Image::DataType::U32:\n                    sampleDepth = 32;\n                    sampleFormat = SAMPLEFORMAT_UINT;\n                    break;\n                case Image::DataType::F32:\n                    sampleDepth = 32;\n                    sampleFormat = SAMPLEFORMAT_IEEEFP;\n                    break;\n                default: break;\n                }\n                switch (_p->options.compression)\n                {\n                case Compression::None:\n                    compression = COMPRESSION_NONE;\n                    break;\n                case Compression::RLE:\n                    compression = COMPRESSION_PACKBITS;\n                    break;\n                case Compression::LZW:\n                    compression = COMPRESSION_LZW;\n                    break;\n                default: break;\n                }\n                TIFFSetField(f.f, TIFFTAG_IMAGEWIDTH, info.size.w);\n                TIFFSetField(f.f, TIFFTAG_IMAGELENGTH, info.size.h);\n                TIFFSetField(f.f, TIFFTAG_PHOTOMETRIC, photometric);\n                TIFFSetField(f.f, TIFFTAG_SAMPLESPERPIXEL, samples);\n                TIFFSetField(f.f, TIFFTAG_BITSPERSAMPLE, sampleDepth);\n                TIFFSetField(f.f, TIFFTAG_SAMPLEFORMAT, sampleFormat);\n                TIFFSetField(f.f, TIFFTAG_EXTRASAMPLES, extraSamplesSize, extraSamples);\n                TIFFSetField(f.f, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n                TIFFSetField(f.f, TIFFTAG_COMPRESSION, compression);\n                TIFFSetField(f.f, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\n                std::string tag = _info.tags.get(\"Creator\");\n                if (!tag.empty())\n                {\n                    TIFFSetField(f.f, TIFFTAG_ARTIST, tag.data());\n                }\n                tag = _info.tags.get(\"Copyright\");\n                if (!tag.empty())\n                {\n                    TIFFSetField(f.f, TIFFTAG_COPYRIGHT, tag.data());\n                }\n                tag = _info.tags.get(\"Time\");\n                if (!tag.empty())\n                {\n                    TIFFSetField(f.f, TIFFTAG_DATETIME, tag.data());\n                }\n                tag = _info.tags.get(\"Description\");;\n                if (!tag.empty())\n                {\n                    TIFFSetField(f.f, TIFFTAG_IMAGEDESCRIPTION, tag.data());\n                }\n\n                for (uint16_t y = 0; y < info.size.h; ++y)\n                {\n                    if (TIFFWriteScanline(f.f, (tdata_t *)image->getData(y), y) == -1)\n                    {\n                        throw System::File::Error(String::Format(\"{0}: {1}\").\n                            arg(fileName).\n                            arg(_textSystem->getText(DJV_TEXT(\"error_write_scanline\"))));\n                    }\n                }\n            }",
    "bool TiffEncoder::writeLibTiff( const std::vector<Mat>& img_vec, const std::vector<int>& params)\n{\n    // do NOT put \"wb\" as the mode, because the b means \"big endian\" mode, not \"binary\" mode.\n    // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n    TIFF* tif = NULL;\n\n    TiffEncoderBufHelper buf_helper(m_buf);\n    if ( m_buf )\n    {\n        tif = buf_helper.open();\n    }\n    else\n    {\n        tif = TIFFOpen(m_filename.c_str(), \"w\");\n    }\n    if (!tif)\n    {\n        return false;\n    }\n    cv::Ptr<void> tif_cleanup(tif, cv_tiffCloseHandle);\n\n    //Settings that matter to all images\n    int compression = COMPRESSION_LZW;\n    int predictor = PREDICTOR_HORIZONTAL;\n    int resUnit = -1, dpiX = -1, dpiY = -1;\n\n    readParam(params, IMWRITE_TIFF_COMPRESSION, compression);\n    readParam(params, TIFFTAG_PREDICTOR, predictor);\n    readParam(params, IMWRITE_TIFF_RESUNIT, resUnit);\n    readParam(params, IMWRITE_TIFF_XDPI, dpiX);\n    readParam(params, IMWRITE_TIFF_YDPI, dpiY);\n\n    //Iterate through each image in the vector and write them out as Tiff directories\n    for (size_t page = 0; page < img_vec.size(); page++)\n    {\n        const Mat& img = img_vec[page];\n        CV_Assert(!img.empty());\n        int channels = img.channels();\n        int width = img.cols, height = img.rows;\n        int type = img.type();\n        int depth = CV_MAT_DEPTH(type);\n        CV_CheckType(type, depth == CV_8U || depth == CV_16U || depth == CV_32F || depth == CV_64F, \"\");\n        CV_CheckType(type, channels >= 1 && channels <= 4, \"\");\n\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, width));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_IMAGELENGTH, height));\n\n        if (img_vec.size() > 1)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE));\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PAGENUMBER, page, img_vec.size()));\n        }\n\n        int compression_param = -1;  // OPENCV_FUTURE\n        if (type == CV_32FC3 && (!readParam(params, IMWRITE_TIFF_COMPRESSION, compression_param) || compression_param == COMPRESSION_SGILOG))\n        {\n            if (!write_32FC3_SGILOG(img, tif))\n                return false;\n            continue;\n        }\n\n        int page_compression = compression;\n\n        int bitsPerChannel = -1;\n        switch (depth)\n        {\n            case CV_8U:\n            {\n                bitsPerChannel = 8;\n                break;\n            }\n            case CV_16U:\n            {\n                bitsPerChannel = 16;\n                break;\n            }\n            case CV_32F:\n            {\n                bitsPerChannel = 32;\n                page_compression = COMPRESSION_NONE;\n                break;\n            }\n            case CV_64F:\n            {\n                bitsPerChannel = 64;\n                page_compression = COMPRESSION_NONE;\n                break;\n            }\n            default:\n            {\n                return false;\n            }\n        }\n\n        const int bitsPerByte = 8;\n        size_t fileStep = (width * channels * bitsPerChannel) / bitsPerByte;\n        CV_Assert(fileStep > 0);\n\n        int rowsPerStrip = (int)((1 << 13) / fileStep);\n        readParam(params, TIFFTAG_ROWSPERSTRIP, rowsPerStrip);\n        rowsPerStrip = std::max(1, std::min(height, rowsPerStrip));\n\n        int colorspace = channels > 1 ? PHOTOMETRIC_RGB : PHOTOMETRIC_MINISBLACK;\n\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, bitsPerChannel));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_COMPRESSION, page_compression));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, colorspace));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, channels));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG));\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, rowsPerStrip));\n\n        CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, depth >= CV_32F ? SAMPLEFORMAT_IEEEFP : SAMPLEFORMAT_UINT));\n\n        if (page_compression != COMPRESSION_NONE)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_PREDICTOR, predictor));\n        }\n\n        if (resUnit >= RESUNIT_NONE && resUnit <= RESUNIT_CENTIMETER)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_RESOLUTIONUNIT, resUnit));\n        }\n        if (dpiX >= 0)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_XRESOLUTION, (float)dpiX));\n        }\n        if (dpiY >= 0)\n        {\n            CV_TIFF_CHECK_CALL(TIFFSetField(tif, TIFFTAG_YRESOLUTION, (float)dpiY));\n        }\n\n        // row buffer, because TIFFWriteScanline modifies the original data!\n        size_t scanlineSize = TIFFScanlineSize(tif);\n        AutoBuffer<uchar> _buffer(scanlineSize + 32);\n        uchar* buffer = _buffer.data(); CV_DbgAssert(buffer);\n        Mat m_buffer(Size(width, 1), CV_MAKETYPE(depth, channels), buffer, (size_t)scanlineSize);\n\n        for (int y = 0; y < height; ++y)\n        {\n            switch (channels)\n            {\n                case 1:\n                {\n                    memcpy(buffer, img.ptr(y), scanlineSize);\n                    break;\n                }\n\n                case 3:\n                {\n                    cvtColor(img(Rect(0, y, width, 1)), (const Mat&)m_buffer, COLOR_BGR2RGB);\n                    break;\n                }\n\n                case 4:\n                {\n                    cvtColor(img(Rect(0, y, width, 1)), (const Mat&)m_buffer, COLOR_BGRA2RGBA);\n                    break;\n                }\n\n                default:\n                {\n                    CV_Assert(0);\n                }\n            }\n\n            CV_TIFF_CHECK_CALL(TIFFWriteScanline(tif, buffer, y, 0) == 1);\n        }\n\n        CV_TIFF_CHECK_CALL(TIFFWriteDirectory(tif));\n    }\n\n    return true;\n}",
    "void\nrender(ddjvu_page_t *page, int pageno)\n{\n  ddjvu_rect_t prect;\n  ddjvu_rect_t rrect;\n  ddjvu_format_style_t style;\n  ddjvu_render_mode_t mode;\n  ddjvu_format_t *fmt;\n  int iw = ddjvu_page_get_width(page);\n  int ih = ddjvu_page_get_height(page);\n  int dpi = ddjvu_page_get_resolution(page);\n  ddjvu_page_type_t type = ddjvu_page_get_type(page);\n  char *image = 0;\n  char white = (char)0xFF;\n  int rowsize;\n#if HAVE_TIFF\n  int compression = COMPRESSION_NONE;\n#endif\n  \n  /* Process size specification */\n  prect.x = 0;\n  prect.y = 0;\n  if (flag_size > 0)\n    {\n      prect.w = info_size.w;\n      prect.h = info_size.h;\n    }\n  else if (flag_subsample > 0)\n    {\n      prect.w = (iw + flag_subsample - 1) / flag_subsample;\n      prect.h = (ih + flag_subsample - 1) / flag_subsample;\n    }\n  else if (flag_scale > 0)\n    {\n      prect.w = (unsigned int) (iw * flag_scale) / dpi;\n      prect.h = (unsigned int) (ih * flag_scale) / dpi;\n    }\n  else if (flag_format)\n    {\n      prect.w = iw;\n      prect.h = ih;\n    }\n  else\n    {\n      prect.w = (iw * 100) / dpi;\n      prect.h = (ih * 100) / dpi;\n    }\n  /* Process aspect ratio */\n  if (flag_aspect <= 0 && iw>0 && ih>0)\n    {\n      double dw = (double)iw / prect.w;\n      double dh = (double)ih / prect.h;\n      if (dw > dh) \n        prect.h = (int)(ih / dw);\n      else\n        prect.w = (int)(iw / dh);\n    }\n\n  /* Process segment specification */\n  rrect = prect;\n  if (flag_segment > 0)\n    {\n      rrect = info_segment;\n      if (rrect.x < 0)\n        rrect.x = prect.w - rrect.w + rrect.x;\n      if (rrect.y < 0)\n        rrect.y = prect.h - rrect.h + rrect.y;\n    }\n\n  /* Process mode specification */\n  mode = DDJVU_RENDER_COLOR;\n  if (flag_mode == 'f')\n    mode = DDJVU_RENDER_FOREGROUND;\n  else if (flag_mode == 'b')\n    mode = DDJVU_RENDER_BACKGROUND;\n  else if (flag_mode == 'c')\n    mode = DDJVU_RENDER_COLOR;\n  else if (flag_mode == 'k')\n    mode = DDJVU_RENDER_BLACK;\n  else if (flag_mode == 's')\n    mode = DDJVU_RENDER_MASKONLY;\n  else if (flag_format == 'r' || flag_format == '4')\n    mode = DDJVU_RENDER_BLACK;\n\n  /* Determine output pixel format and compression */\n  style = DDJVU_FORMAT_RGB24;\n  if (mode==DDJVU_RENDER_BLACK ||\n      mode==DDJVU_RENDER_MASKONLY ||\n      (mode==DDJVU_RENDER_COLOR && type==DDJVU_PAGETYPE_BITONAL))\n    {\n      style = DDJVU_FORMAT_GREY8;\n      if ((int)prect.w == iw && (int)prect.h == ih)\n        style = DDJVU_FORMAT_MSBTOLSB;\n    }\n  switch(flag_format)\n    {\n    case 'f':\n    case 't':\n#if HAVE_TIFF\n      compression = COMPRESSION_NONE;\n      if (flag_quality >= 1000)\n        break;\n# ifdef CCITT_SUPPORT\n      if (style==DDJVU_FORMAT_MSBTOLSB \n          && TIFFFindCODEC(COMPRESSION_CCITT_T6))\n        compression = COMPRESSION_CCITT_T6;\n# endif\n# ifdef JPEG_SUPPORT\n      if (compression == COMPRESSION_NONE \n          && style!=DDJVU_FORMAT_MSBTOLSB \n          && flag_quality>0 && flag_quality<=100\n          && TIFFFindCODEC(COMPRESSION_JPEG))\n        compression = COMPRESSION_JPEG;\n# endif\n# ifdef ZIP_SUPPORT\n      if (compression == COMPRESSION_NONE\n          && (flag_format == 'f' || flag_quality == 900)\n          && TIFFFindCODEC(COMPRESSION_DEFLATE))\n        /* All pdf engines understand deflate. */\n        compression = COMPRESSION_DEFLATE;\n# endif\n# ifdef LZW_SUPPORT\n      if (compression == COMPRESSION_NONE\n          && flag_quality == 901\n          && TIFFFindCODEC(COMPRESSION_LZW))\n        /* Because of patents that are now expired, some versions\n           of libtiff only support lzw decoding and trigger an error\n           condition when trying to encode. Unfortunately we cannot\n           know this in advance and select another compression scheme. */\n        compression = COMPRESSION_LZW;\n# endif\n# ifdef PACKBITS_SUPPORT\n      if (compression == COMPRESSION_NONE \n          && TIFFFindCODEC(COMPRESSION_PACKBITS))\n        /* This mediocre default produces the most portable tiff files. */\n        compression = COMPRESSION_PACKBITS;\n# endif\n      break;\n#endif      \n    case '4':\n      style = DDJVU_FORMAT_MSBTOLSB; \n      break;\n    case 'r': \n    case '5':\n      style = DDJVU_FORMAT_GREY8;    \n      break;\n    case '6':\n      style = DDJVU_FORMAT_RGB24;   \n      break;\n    default:\n      break;\n    }\n  if (! (fmt = ddjvu_format_create(style, 0, 0)))\n    die(i18n(\"Cannot determine pixel style for page %d\"), pageno);\n  ddjvu_format_set_row_order(fmt, 1);\n  /* Allocate buffer */\n  if (style == DDJVU_FORMAT_MSBTOLSB) {\n    white = 0x00;\n    rowsize = (rrect.w + 7) / 8; \n  } else if (style == DDJVU_FORMAT_GREY8)\n    rowsize = rrect.w;\n  else\n    rowsize = rrect.w * 3;\n  size_t bufsize = (size_t)rowsize * rrect.h;\n  if (bufsize / rowsize != rrect.h)\n    die(i18n(\"Integer overflow when allocating image buffer for page %d\"), pageno);\n  if (! (image = (char*)malloc(bufsize)))\n    die(i18n(\"Cannot allocate image buffer for page %d\"), pageno);\n\n  /* Render */\n  timingdata[2] = ticks();\n  if (! ddjvu_page_render(page, mode, &prect, &rrect, fmt, rowsize, image))\n    memset(image, white, rowsize * rrect.h);\n  timingdata[3] = ticks();\n  if (flag_verbose)\n    if (timingdata[2] != timingdata[3])\n      fprintf(stderr,\"Rendering time: %5ld ms\\n\",\n\t      timingdata[3] - timingdata[2] );\n\n  /* Output */\n  switch (flag_format)\n    {\n      /* -------------- PNM output */\n    default:\n    case '4':\n    case '5':\n    case '6':\n      {\n        int i;\n        char *s = image;\n        if (style == DDJVU_FORMAT_MSBTOLSB) {\n          if (flag_verbose) \n            fprintf(stderr,i18n(\"Producing PBM file.\\n\"));\n          fprintf(fout,\"P4\\n%d %d\\n\", rrect.w, rrect.h);\n        } else if (style == DDJVU_FORMAT_GREY8) {\n          if (flag_verbose) \n            fprintf(stderr,i18n(\"Producing PGM file.\\n\"));\n          fprintf(fout,\"P5\\n%d %d\\n255\\n\", rrect.w, rrect.h);\n        } else {\n          if (flag_verbose) \n            fprintf(stderr,i18n(\"Producing PPM file.\\n\"));\n          fprintf(fout,\"P6\\n%d %d\\n255\\n\", rrect.w, rrect.h);\n        }\n        for (i=0; i<(int)rrect.h; i++,s+=rowsize)\n          if (fwrite(s, 1, rowsize, fout) < (size_t)rowsize)\n            die(i18n(\"writing pnm file: %s\"), strerror(errno));\n        break;\n      }\n      /* -------------- RLE output */\n    case 'r':\n      {\n        int i;\n        unsigned char *s = (unsigned char *)image;\n        if (flag_verbose)\n          fprintf(stderr,i18n(\"Producing RLE file.\\n\"));\n        fprintf(fout,\"R4\\n%d %d\\n\", rrect.w, rrect.h);\n        for (i=0; i<(int)rrect.h; i++,s+=rowsize)\n          {\n            int j = 0;\n            int c = 0xff;\n            while (j < (int)rrect.w)\n              {\n                int l = j;\n                while ((j<(int)rrect.w) && ((s[j]^c)<128))\n                  j += 1;\n                c = c ^ 0xff;\n                l = j - l;\n                while (l > 0x3fff) {\n                  putc( 0xff, fout);\n                  putc( 0xff, fout);\n                  putc( 0x00, fout);\n                  l -= 0x3fff;\n                }\n                if (l > 0xbf) {\n                  putc( (l >> 8) + 0xc0, fout);\n                  putc( (l & 0xff), fout);\n                } else {\n                  putc( l, fout);\n                }\n              }\n          }\n        if (ferror(fout))\n          die(i18n(\"writing rle file: %s\"), strerror(errno));\n        break;\n      }\n      /* -------------- TIFF or PDF output */\n    case 't':\n    case 'f':\n      {\n#if HAVE_TIFF\n        int i;\n        char *s = image;\n        TIFFSetField(tiff, TIFFTAG_IMAGEWIDTH, (uint32)rrect.w);\n        TIFFSetField(tiff, TIFFTAG_IMAGELENGTH, (uint32)rrect.h);\n        TIFFSetField(tiff, TIFFTAG_XRESOLUTION, \n\t\t     (float)((dpi*prect.w+iw/2)/iw));\n        TIFFSetField(tiff, TIFFTAG_YRESOLUTION, \n\t\t     (float)((dpi*prect.h+ih/2)/ih));\n        TIFFSetField(tiff, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n        TIFFSetField(tiff, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n# ifdef CCITT_SUPPORT\n        if (compression != COMPRESSION_CCITT_T6)\n# endif\n# ifdef JPEG_SUPPORT\n          if (compression != COMPRESSION_JPEG)\n# endif\n# ifdef ZIP_SUPPORT\n            if (compression != COMPRESSION_DEFLATE)\n# endif\n              TIFFSetField(tiff, TIFFTAG_ROWSPERSTRIP, (uint32)64);\n        if (style == DDJVU_FORMAT_MSBTOLSB) {\n          TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, (uint16)1);\n          TIFFSetField(tiff, TIFFTAG_SAMPLESPERPIXEL, (uint16)1);\n          TIFFSetField(tiff, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);\n          TIFFSetField(tiff, TIFFTAG_COMPRESSION, compression);\n          TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISWHITE);\n        } else {\n          TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, (uint16)8);\n          if (style == DDJVU_FORMAT_GREY8) {\n            TIFFSetField(tiff, TIFFTAG_SAMPLESPERPIXEL, (uint16)1);\n            TIFFSetField(tiff, TIFFTAG_COMPRESSION, compression);\n            TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n          } else {\n            TIFFSetField(tiff, TIFFTAG_SAMPLESPERPIXEL, (uint16)3);\n            TIFFSetField(tiff, TIFFTAG_COMPRESSION, compression);\n# ifdef JPEG_SUPPORT\n            if (compression == COMPRESSION_JPEG) {\n              TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);\n              TIFFSetField(tiff, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n              TIFFSetField(tiff, TIFFTAG_JPEGQUALITY, flag_quality);\n            } else \n# endif\n              TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n          }\n        }\n        if (flag_verbose) {\n          if (compression == COMPRESSION_NONE)\n            fprintf(stderr,i18n(\"Producing uncompressed TIFF file.\\n\"));\n# ifdef CCITT_SUPPORT\n          else if (compression == COMPRESSION_CCITT_T6)\n            fprintf(stderr,i18n(\"Producing TIFF/G4 file.\\n\"));\n# endif\n# ifdef JPEG_SUPPORT\n          else if (compression == COMPRESSION_JPEG)\n            fprintf(stderr,i18n(\"Producing TIFF/JPEG file.\\n\"));\n# endif\n# ifdef ZIP_SUPPORT\n          else if (compression == COMPRESSION_DEFLATE)\n            fprintf(stderr,i18n(\"Producing TIFF/DEFLATE file.\\n\"));\n# endif\n# ifdef PACKBITS_SUPPORT\n          else if (compression == COMPRESSION_PACKBITS)\n            fprintf(stderr,i18n(\"Producing TIFF/PACKBITS file.\\n\"));\n# endif\n          else\n            fprintf(stderr,i18n(\"Producing TIFF file.\\n\"));\n        }\n        if (rowsize != TIFFScanlineSize(tiff))\n          die(\"internal error (%d!=%d)\", rowsize, (int)TIFFScanlineSize(tiff));\n        for (i=0; i<(int)rrect.h; i++,s+=rowsize)\n          TIFFWriteScanline(tiff, s, i, 0);\n#else\n        die(i18n(\"TIFF output is not compiled\"));\n#endif\n      }\n    }\n\n  /* Free */\n  ddjvu_format_release(fmt);\n  free(image);\n}",
    "void ExecuteTerrainExport(\n        const ::Assets::ResChar dstFile[],\n        const SceneEngine::TerrainConfig& srcCfg, \n        const ::Assets::ResChar srcDir[],\n        SceneEngine::TerrainCoverageId coverageId,\n        ConsoleRig::IProgress* progress)\n    {\n            // Export a uber surface file to tiff format.\n        ::Assets::ResChar dirName[MaxPath];\n        XlDirname(dirName, dimof(dirName), dstFile);\n        CreateDirectoryRecursive(dirName);\n\n        ::Assets::ResChar srcFN[MaxPath];\n        srcCfg.GetUberSurfaceFilename(srcFN, dimof(srcFN), srcDir, coverageId);\n        if (!DoesFileExist(srcFN))\n            Throw(::Exceptions::BasicLabel(\"Could not find input file (%s)\", srcFN));\n\n        TerrainUberSurfaceGeneric uberSurface(srcFN);\n        auto step = \n              progress \n            ? progress->BeginStep(\"Create uber surface data\", uberSurface.GetHeight(), true)\n            : nullptr;\n\n        auto* tif = TIFFOpen(dstFile, \"w\");\n        if (!tif)\n            Throw(::Exceptions::BasicLabel(\"Error openning output file (%s)\", dstFile));\n        auto autoClose = MakeAutoClose([tif]() { TIFFClose(tif); });\n\n        TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, uberSurface.GetWidth());  // set the width of the image\n        TIFFSetField(tif, TIFFTAG_IMAGELENGTH, uberSurface.GetHeight());    // set the height of the image\n        TIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);    // set the origin of the image.\n\n        TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n        TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n\n        auto fmt = uberSurface.Format();\n        TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, fmt._arrayCount);\n        TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, fmt.GetSize() * 8 / fmt._arrayCount);\n        using TC = ImpliedTyping::TypeCat;\n        switch (fmt._type) {\n        case TC::Bool:\n        case TC::Int8:\n        case TC::Int16:\n        case TC::Int32:\n            TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_INT);\n            break;\n\n        case TC::UInt8:\n        case TC::UInt16:\n        case TC::UInt32:\n            TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT);\n            break;\n\n        case TC::Float:\n            TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);\n            break;\n\n        default:\n            Throw(::Exceptions::BasicLabel(\"Unknown uber surface format, can't export\"));\n        }\n\n        TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, 1);\n            // I think this will only work correctly with a single sample per pixel\n        for (unsigned row = 0; row < uberSurface.GetHeight(); row++) {\n            TIFFWriteScanline(tif, uberSurface.GetData(UInt2(0, row)), row, 0);\n\n            if (step) {\n                if (step->IsCancelled())\n                    break;\n                step->Advance();\n            }\n        }\n    }",
    "bool MainWindow::SaveTiffMulti(std::string filename)\n{\n    char *file = &filename[0u];\n    TIFF *out = TIFFOpen(file,\"w\") ;\n\n    if (out) {\n        int NPAGES = ui->listWidget_labels->count() +1; // number of page = nb labels + image\n\n        //// image\n        uint32 imagelength = image.rows;\n        uint32 imagewidth = image.cols;\n        uint8 * buf;\n        uint32 row, col;\n        uint16 nsamples = 3;\n\n        TIFFSetField(out, TIFFTAG_IMAGELENGTH, imagelength); // image length\n        TIFFSetField(out, TIFFTAG_IMAGEWIDTH, imagewidth); // image width\n        TIFFSetField(out, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG); // organized by RGB instead of channel\n        TIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, nsamples); // number of channels per pixel\n        TIFFSetField(out, TIFFTAG_COMPRESSION, COMPRESSION_LZW); // compression\n        TIFFSetField(out, TIFFTAG_BITSPERSAMPLE, 8) ; // size of the channels\n        TIFFSetField(out, TIFFTAG_ROWSPERSTRIP, TIFFDefaultStripSize(out, imagewidth*nsamples)); // strip size of the file to be size of one row of pixels\n        TIFFSetField(out, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT); // set the origin of the image\n        TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB); // RGB image\n        TIFFSetField(out, TIFFTAG_IMAGEDESCRIPTION, \"background\"); // label name\n        TIFFSetField(out, TIFFTAG_SOFTWARE, \"Superpixels Segmentation GUI with openCV by AbsurdePhoton www.absurdephoton.fr\"); // software used\n\n        /* We are writing single page of the multipage file */\n        TIFFSetField(out, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE); // new page\n        TIFFSetField(out, TIFFTAG_PAGENUMBER, 0, NPAGES); // page number\n\n        buf = new uint8 [imagewidth*nsamples] ;\n\n        for (row = 0; row < imagelength; row++) {\n            for(col=0; col < imagewidth; col++) {\n                //writing data - order = RGB\n                Vec3b c = image.at<Vec3b>(row, col);\n                buf[col*nsamples+0] = c[2];\n                buf[col*nsamples+1] = c[1];\n                buf[col*nsamples+2] = c[0];\n            }\n            if (TIFFWriteScanline(out, buf, row) != 1 ) {\n                return false;\n            }\n        }\n        TIFFWriteDirectory(out);\n        _TIFFfree(buf);\n\n        //// Layers\n        int page;\n        for (page = 0; page < (NPAGES - 1); page++){\n            QListWidgetItem *item = ui->listWidget_labels->item(page);\n            QColor c = item->background().color();\n            int nLabel = item->data(Qt::UserRole).toInt();\n            std::string name = item->text().toUtf8().constData();\n\n            uint32 imagelength = image.rows;\n            uint32 imagewidth = image.cols;\n            uint8 * buf;\n            uint32 row, col;\n            uint16 nsamples = 4;\n\n            TIFFSetField(out, TIFFTAG_IMAGELENGTH, imagelength); // image length\n            TIFFSetField(out, TIFFTAG_IMAGEWIDTH, imagewidth); // image width\n            TIFFSetField(out, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG); // organized by RGB instead of channel\n            TIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, nsamples); // number of channels per pixel\n            TIFFSetField(out, TIFFTAG_COMPRESSION, COMPRESSION_LZW); // compression\n            TIFFSetField(out, TIFFTAG_BITSPERSAMPLE, 8) ; // size of the channels\n            TIFFSetField(out, TIFFTAG_ROWSPERSTRIP, TIFFDefaultStripSize(out, imagewidth*nsamples)); // strip size of the file to be size of one row of pixels\n            TIFFSetField(out, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT); // set the origin of the image\n            TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB); // RGB image\n            TIFFSetField(out, TIFFTAG_EXTRASAMPLES, EXTRASAMPLE_ASSOCALPHA); // extra byte is alpha value\n            TIFFSetField(out, TIFFTAG_IMAGEDESCRIPTION, name); // label name\n            TIFFSetField(out, TIFFTAG_PAGENAME, name); // label name\n            TIFFSetField(out, TIFFTAG_SOFTWARE, \"Superpixels Segmentation GUI with openCV by AbsurdePhoton www.absurdephoton.fr\"); // software used\n\n            /* We are writing single page of the multipage file */\n            TIFFSetField(out, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE); // new page\n            TIFFSetField(out, TIFFTAG_PAGENUMBER, page + 1, NPAGES); // page number\n\n            buf = new uint8 [imagewidth*nsamples] ;\n\n            for (row = 0; row < imagelength; row++) {\n                for(col=0; col < imagewidth; col++) {\n                    //writing data - order = RGB\n                    int currentLabel = labels_mask.at<int>(row,col);\n                    if (currentLabel == nLabel) {\n                        buf[col*nsamples+0] = c.red();\n                        buf[col*nsamples+1] = c.green();\n                        buf[col*nsamples+2] = c.blue();\n                        buf[col*nsamples+3] = 255;\n                    }\n                    else {\n                        buf[col*nsamples+0] = 0;\n                        buf[col*nsamples+1] = 0;\n                        buf[col*nsamples+2] = 0;\n                        buf[col*nsamples+3] = 0;\n                    }\n                }\n                if (TIFFWriteScanline(out, buf, row) != 1 ) {\n                    return false;\n                }\n            }\n            TIFFWriteDirectory(out);\n            _TIFFfree(buf);\n        }\n        TIFFClose(out);\n    }\n    return true;\n}",
    "void SavePointCloudToTiff(float *src_pc, INT32 width, INT32 height, char *fileName)\n{\n\tINT32  x, y, pos_src, pos_dst, y_offset, z_offset;\n\tTIFF   *imageTiff = NULL;\n\tfloat  *point_cloud = (float*)malloc(width * height * 3 * sizeof(float));\n\tint    bitSize = 32;\n\tfloat  *ptrPageImage;\n\n\t// re-arrange point cloud data\n\ty_offset = width * height;\n\tz_offset = y_offset * 2;\n#pragma omp parallel for firstprivate(x, pos_src, pos_dst)\n\tfor (y = 0; y < height; y++) {\n\t\tpos_src = y * width * 3;\n\t\tpos_dst = y * width;\n\t\tfor (x = 0; x < width; x++) {\n\t\t\tif (src_pc[pos_src+2] < 1e+6f) {\n\t\t\t\tpoint_cloud[pos_dst         ] = src_pc[pos_src  ];\n\t\t\t\tpoint_cloud[pos_dst+y_offset] = src_pc[pos_src+1];\n\t\t\t\tpoint_cloud[pos_dst+z_offset] = src_pc[pos_src+2];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpoint_cloud[pos_dst         ] = NAN;\n\t\t\t\tpoint_cloud[pos_dst+y_offset] = NAN;\n\t\t\t\tpoint_cloud[pos_dst+z_offset] = NAN;\n\t\t\t}\n\t\t\tpos_src += 3;\n\t\t\tpos_dst++;\n\t\t}\n\t}\n\n\timageTiff = TIFFOpen(fileName, \"w\");\n\tif (imageTiff == NULL)   return;\n\tfor (int page = 0; page < 3; page++) {\n\t\tptrPageImage = point_cloud + (width * height) * page;\n\n\t\tTIFFSetField(imageTiff, TIFFTAG_IMAGEWIDTH, width);\n\t\tTIFFSetField(imageTiff, TIFFTAG_IMAGELENGTH, height);\n\t\tTIFFSetField(imageTiff, TIFFTAG_BITSPERSAMPLE, bitSize);\n\t\tTIFFSetField(imageTiff, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);\n\t\tTIFFSetField(imageTiff, TIFFTAG_SAMPLESPERPIXEL, 1);\n\t\tTIFFSetField(imageTiff, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n\t\tTIFFSetField(imageTiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n\t\tTIFFSetField(imageTiff, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);\n\t\tTIFFSetField(imageTiff, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\t\tTIFFSetField(imageTiff, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n\t\tTIFFSetField(imageTiff, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE);\n\t\tTIFFSetField(imageTiff, TIFFTAG_PAGENUMBER, page, 3);\n\n\t\tsize_t stride = width;\n\t\tfor (int i = 0; i < height; i++) {\n\t\t\tTIFFWriteScanline(imageTiff, ptrPageImage + i * stride, i, 0);\n\t\t}\n\t\tTIFFWriteDirectory(imageTiff);\n\n\t}\n\tTIFFClose(imageTiff);\n\tif (point_cloud != NULL) free(point_cloud);\n}",
    "void Image::writeTiff(\n  const std::string &p_name,\n  const bool p_quad) const {\n\n  //! Open the file\n  TIFF *tif = TIFFOpen(p_name.c_str(), \"w\");\n\n  //! Check that the file has been created\n  if (!tif) {\n    cout << \"Unable to write TIFF file \" << p_name << endl;\n    exit(EXIT_FAILURE);\n  }\n\n  //! For convenience\n  const size_t h = m_height * (p_quad ? 2 : 1);\n  const size_t w = m_width  * (p_quad ? 2 : 1);\n  uint32 rowsperstrip;\n  float* line = (float*) memalloc(16, (p_quad ? w : m_width) * sizeof(float));\n\n  //! Header of the tiff file\n  TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, (uint32) w);\n  TIFFSetField(tif, TIFFTAG_IMAGELENGTH, (uint32) h);\n  TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_SEPARATE);\n  TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, (uint16) m_channels);\n  TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, (uint16) sizeof(float) * 8);\n  TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);\n  rowsperstrip = TIFFDefaultStripSize(tif, (uint32) h);\n  TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, rowsperstrip);\n  TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n  TIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n\n  //! Write the file data\n  for (size_t c = 0, ok = 1; ok && c < m_channels; c++) {\n    for (size_t i = 0; ok && i < h; i++) {\n      const float* iI = this->getPtr(c, p_quad ? i / 2 : i);\n\n      //! Copy the line\n      if (p_quad) {\n        for (size_t j = 0; j < m_width; j++) {\n          line[2 * j + 0] = line[2 * j + 1] = iI[j];\n        }\n      }\n      else {\n        for (size_t j = 0; j < m_width; j++) {\n          line[j] = iI[j];\n        }\n      }\n\n      //! Write the line\n      if (TIFFWriteScanline(tif, line, (uint32) i, (tsample_t) c) < 0) {\n        cout << \"WriteTIFF: error writing row \" << i << endl;\n        ok = 0;\n      }\n    }\n  }\n\n  //! Release memory\n  memfree(line);\n\n  //! Close the file\n  TIFFClose(tif);\n}",
    "bool TiffEncoder::writeLibTiff( const std::vector<Mat>& img_vec, const std::vector<int>& params)\n{\n    // do NOT put \"wb\" as the mode, because the b means \"big endian\" mode, not \"binary\" mode.\n    // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n    TIFF* pTiffHandle;\n\n    TiffEncoderBufHelper buf_helper(m_buf);\n    if ( m_buf )\n    {\n        pTiffHandle = buf_helper.open();\n    }\n    else\n    {\n        pTiffHandle = TIFFOpen(m_filename.c_str(), \"w\");\n    }\n    if (!pTiffHandle)\n    {\n        return false;\n    }\n\n    //Settings that matter to all images\n    // defaults for now, maybe base them on params in the future\n    int compression = COMPRESSION_LZW;\n    int predictor = PREDICTOR_HORIZONTAL;\n    int resUnit = -1, dpiX = -1, dpiY = -1;\n\n    readParam(params, TIFFTAG_COMPRESSION, compression);\n    readParam(params, TIFFTAG_PREDICTOR, predictor);\n    readParam(params, IMWRITE_TIFF_RESUNIT, resUnit);\n    readParam(params, IMWRITE_TIFF_XDPI, dpiX);\n    readParam(params, IMWRITE_TIFF_YDPI, dpiY);\n\n    //Iterate through each image in the vector and write them out as Tiff directories\n    for (size_t page = 0; page < img_vec.size(); page++)\n    {\n        const Mat& img = img_vec[page];\n        int channels = img.channels();\n        int width = img.cols, height = img.rows;\n        int depth = img.depth();\n\n        int bitsPerChannel = -1;\n        switch (depth)\n        {\n            case CV_8U:\n            {\n                bitsPerChannel = 8;\n                break;\n            }\n            case CV_16U:\n            {\n                bitsPerChannel = 16;\n                break;\n            }\n            default:\n            {\n                TIFFClose(pTiffHandle);\n                return false;\n            }\n        }\n\n        const int bitsPerByte = 8;\n        size_t fileStep = (width * channels * bitsPerChannel) / bitsPerByte;\n\n        int rowsPerStrip = (int)((1 << 13) / fileStep);\n        readParam(params, TIFFTAG_ROWSPERSTRIP, rowsPerStrip);\n\n        if (rowsPerStrip < 1)\n            rowsPerStrip = 1;\n\n        if (rowsPerStrip > height)\n            rowsPerStrip = height;\n\n        int   colorspace = channels > 1 ? PHOTOMETRIC_RGB : PHOTOMETRIC_MINISBLACK;\n\n        if (!TIFFSetField(pTiffHandle, TIFFTAG_IMAGEWIDTH, width)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_IMAGELENGTH, height)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_BITSPERSAMPLE, bitsPerChannel)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_COMPRESSION, compression)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_PHOTOMETRIC, colorspace)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_SAMPLESPERPIXEL, channels)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_ROWSPERSTRIP, rowsPerStrip)\n            || (img_vec.size() > 1 && (\n               !TIFFSetField(pTiffHandle, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_PAGENUMBER, page, img_vec.size() )))\n            )\n        {\n            TIFFClose(pTiffHandle);\n            return false;\n        }\n\n        if (compression != COMPRESSION_NONE && !TIFFSetField(pTiffHandle, TIFFTAG_PREDICTOR, predictor))\n        {\n            TIFFClose(pTiffHandle);\n            return false;\n        }\n\n        if (((resUnit >= RESUNIT_NONE && resUnit <= RESUNIT_CENTIMETER) && !TIFFSetField(pTiffHandle, TIFFTAG_RESOLUTIONUNIT, resUnit))\n            || (dpiX >= 0 && !TIFFSetField(pTiffHandle, TIFFTAG_XRESOLUTION, (float)dpiX))\n            || (dpiY >= 0 && !TIFFSetField(pTiffHandle, TIFFTAG_YRESOLUTION, (float)dpiY))\n            )\n        {\n            TIFFClose(pTiffHandle);\n            return false;\n        }\n\n\n        // row buffer, because TIFFWriteScanline modifies the original data!\n        size_t scanlineSize = TIFFScanlineSize(pTiffHandle);\n        AutoBuffer<uchar> _buffer(scanlineSize + 32);\n        uchar* buffer = _buffer.data();\n        if (!buffer)\n        {\n            TIFFClose(pTiffHandle);\n            return false;\n        }\n\n        for (int y = 0; y < height; ++y)\n        {\n            switch (channels)\n            {\n                case 1:\n                {\n                    memcpy(buffer, img.ptr(y), scanlineSize);\n                    break;\n                }\n\n                case 3:\n                {\n                    if (depth == CV_8U)\n                        icvCvt_BGR2RGB_8u_C3R( img.ptr(y), 0, buffer, 0, Size(width, 1));\n                    else\n                        icvCvt_BGR2RGB_16u_C3R( img.ptr<ushort>(y), 0, (ushort*)buffer, 0, Size(width, 1));\n                    break;\n                }\n\n                case 4:\n                {\n                    if (depth == CV_8U)\n                        icvCvt_BGRA2RGBA_8u_C4R( img.ptr(y), 0, buffer, 0, Size(width, 1));\n                    else\n                        icvCvt_BGRA2RGBA_16u_C4R( img.ptr<ushort>(y), 0, (ushort*)buffer, 0, Size(width, 1));\n                    break;\n                }\n\n                default:\n                {\n                    TIFFClose(pTiffHandle);\n                    return false;\n                }\n            }\n\n            int writeResult = TIFFWriteScanline(pTiffHandle, buffer, y, 0);\n            if (writeResult != 1)\n            {\n                TIFFClose(pTiffHandle);\n                return false;\n            }\n        }\n\n        TIFFWriteDirectory(pTiffHandle);\n\n    }\n\n    TIFFClose(pTiffHandle);\n    return true;\n}",
    "bool TiffEncoder::write_32FC1(const Mat& _img)\n{\n\n    TIFF* tif;\n\n    TiffEncoderBufHelper buf_helper(m_buf);\n    if ( m_buf )\n    {\n        tif = buf_helper.open();\n    }\n    else\n    {\n        tif = TIFFOpen(m_filename.c_str(), \"w\");\n    }\n\n    if (!tif)\n    {\n        return false;\n    }\n\n    TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, _img.cols);\n    TIFFSetField(tif, TIFFTAG_IMAGELENGTH, _img.rows);\n    TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 1);\n    TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 32);\n    TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n    TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);\n    TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n    for (uint32 row = 0; row < (uint32)_img.rows; row++)\n    {\n        if (TIFFWriteScanline(tif, (tdata_t)_img.ptr<float>(row), row, 1) != 1)\n        {\n            TIFFClose(tif);\n            return false;\n        }\n    }\n    TIFFWriteDirectory(tif);\n    TIFFClose(tif);\n\n    return true;\n}",
    "bool imwrite_tiff(const matrix<unsigned short>& output, string outputfilename,\n                  Exiv2::ExifData exifData)\n{\n    int xsize, ysize;\n    xsize = output.nc()/3;\n    ysize = output.nr();\n\n\n\n    outputfilename = outputfilename + \".tif\";\n    TIFF *out = TIFFOpen(outputfilename.c_str(),\"w\");\n    if (!out)\n    {\n        cerr << \"Can't open file for writing\" << endl;\n        return 1;\n    }\t\n    TIFFSetField(out, TIFFTAG_IMAGEWIDTH, xsize);  \n    TIFFSetField(out, TIFFTAG_IMAGELENGTH, ysize);\n    TIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, 3); //RGB\n    TIFFSetField(out, TIFFTAG_BITSPERSAMPLE, 16);\n    TIFFSetField(out, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);    // set the origin of the image.\n    //Magic below\n    TIFFSetField(out, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n    if(!TIFFSetField(out, TIFFTAG_COMPRESSION, COMPRESSION_NONE)) {cout << \"couldn't set tiff compression\" << endl;}\n    //End Magic\n\n    std::string make = exifData[\"Exif.Image.Make\"].toString();\n    TIFFSetField(out, TIFFTAG_MAKE, make.c_str());\n    std::string model = exifData[\"Exif.Image.Model\"].toString();\n    TIFFSetField(out, TIFFTAG_MODEL, model.c_str());\n    TIFFSetField(out, TIFFTAG_SOFTWARE, \"Filmulator\");\n    std::string copyright = exifData[\"Exif.Image.Copyright\"].toString();\n    TIFFSetField(out, TIFFTAG_COPYRIGHT, copyright.c_str());\n    std::string lensinfo = exifData[\"Exif.Image.LensInfo\"].toString();\n    TIFFSetField(out, TIFFTAG_LENSINFO, lensinfo.c_str());\n    std::string datetime = exifData[\"Exif.Image.DateTime\"].toString();\n    TIFFSetField(out, TIFFTAG_DATETIME, datetime.c_str());\n\n    tsize_t linebytes = 3 * xsize * 2;//Size in bytes of a line\n    unsigned short *buf = NULL;\n    buf =(unsigned short *)_TIFFmalloc(linebytes);\n    for (int j = 0; j < ysize; j++)\n    {\n        for(int i = 0; i < xsize; i ++)\n        {\n            buf[i*3  ] = output(j,i*3  );\n            buf[i*3+1] = output(j,i*3+1);\n            buf[i*3+2] = output(j,i*3+2);\n        }\n        if (TIFFWriteScanline(out, buf, j, 0) < 0)\n            break;\n    }\n\n    TIFFWriteDirectory(out);\n\n    (void) TIFFClose(out);\n\n    if (buf)\n        _TIFFfree(buf);\n\n    //Programs reading tiffs really freak out if you write the full exif data\n    //So we write only the basics here.\n    Exiv2::ExifData minimumData;\n    minimumData[\"Exif.Photo.ISOSpeedRatings\"] = exifData[\"Exif.Photo.ISOSpeedRatings\"];\n    minimumData[\"Exif.Photo.ExposureTime\"]    = exifData[\"Exif.Photo.ExposureTime\"];\n    minimumData[\"Exif.Photo.FNumber\"]         = exifData[\"Exif.Photo.FNumber\"];\n    minimumData[\"Exif.Photo.FocalLength\"]     = exifData[\"Exif.Photo.FocalLength\"];\n\n    minimumData.sortByTag(); //darktable's does this so maybe we should\n\n    auto image = Exiv2::ImageFactory::open(outputfilename);\n    assert(image.get() != 0);\n\n    image->setExifData(minimumData);\n    image->writeMetadata();\n\n    return 0;\n}",
    "bool wxTIFFHandler::SaveFile( wxImage *image, wxOutputStream& stream, bool verbose )\n{\n    TIFF *tif = TIFFwxOpen( stream, \"image\", \"w\" );\n\n    if (!tif)\n    {\n        if (verbose)\n            wxLogError( _(\"TIFF: Error saving image.\") );\n\n        return false;\n    }\n\n    TIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n    TIFFSetField(tif, TIFFTAG_IMAGEWIDTH,  (uint32)image->GetWidth());\n    TIFFSetField(tif, TIFFTAG_IMAGELENGTH, (uint32)image->GetHeight());\n    TIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n    TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\n    if ( image->HasOption(wxIMAGE_OPTION_RESOLUTIONX) &&\n            image->HasOption(wxIMAGE_OPTION_RESOLUTIONY) )\n    {\n        TIFFSetField(tif, TIFFTAG_XRESOLUTION,\n                        (float)image->GetOptionInt(wxIMAGE_OPTION_RESOLUTIONX));\n        TIFFSetField(tif, TIFFTAG_YRESOLUTION,\n                        (float)image->GetOptionInt(wxIMAGE_OPTION_RESOLUTIONY));\n    }\n\n    int spp = image->GetOptionInt(wxIMAGE_OPTION_SAMPLESPERPIXEL);\n    if ( !spp )\n        spp = 3;\n\n    int bpp = image->GetOptionInt(wxIMAGE_OPTION_BITSPERSAMPLE);\n    if ( !bpp )\n        bpp=8;\n\n    int compression = image->GetOptionInt(wxIMAGE_OPTION_COMPRESSION);\n    if ( !compression )\n    {\n        // we can't use COMPRESSION_LZW because current version of libtiff\n        // doesn't implement it (\"no longer implemented due to Unisys patent\n        // enforcement\") and other compression methods are lossy so we\n        // shouldn't use them by default -- and the only remaining one is none\n        compression = COMPRESSION_NONE;\n    }\n\n    TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, spp);\n    TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, bpp);\n    TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, spp*bpp == 1 ? PHOTOMETRIC_MINISBLACK\n                                                        : PHOTOMETRIC_RGB);\n    TIFFSetField(tif, TIFFTAG_COMPRESSION, compression);\n\n    // scanlinesize if determined by spp and bpp\n    tsize_t linebytes = (tsize_t)image->GetWidth() * spp * bpp / 8;\n\n    if ( (image->GetWidth() % 8 > 0) && (spp * bpp < 8) )\n        linebytes+=1;\n\n    unsigned char *buf;\n\n    if (TIFFScanlineSize(tif) > linebytes || (spp * bpp < 24))\n    {\n        buf = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(tif));\n        if (!buf)\n        {\n            if (verbose)\n                wxLogError( _(\"TIFF: Couldn't allocate memory.\") );\n\n            TIFFClose( tif );\n\n            return false;\n        }\n    }\n    else\n    {\n        buf = NULL;\n    }\n\n    TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP,TIFFDefaultStripSize(tif, (uint32) -1));\n\n    unsigned char *ptr = image->GetData();\n    for ( int row = 0; row < image->GetHeight(); row++ )\n    {\n        if ( buf )\n        {\n            if ( spp * bpp > 1 )\n            {\n                // color image\n                memcpy(buf, ptr, image->GetWidth());\n            }\n            else // black and white image\n            {\n                for ( int column = 0; column < linebytes; column++ )\n                {\n                    uint8 reverse = 0;\n                    for ( int bp = 0; bp < 8; bp++ )\n                    {\n                        if ( ptr[column*24 + bp*3] > 0 )\n                        {\n                            // check only red as this is sufficient\n                            reverse = (uint8)(reverse | 128 >> bp);\n                        }\n                    }\n\n                    buf[column] = reverse;\n                }\n            }\n        }\n\n        if ( TIFFWriteScanline(tif, buf ? buf : ptr, (uint32)row, 0) < 0 )\n        {\n            if (verbose)\n                wxLogError( _(\"TIFF: Error writing image.\") );\n\n            TIFFClose( tif );\n            if (buf)\n                _TIFFfree(buf);\n\n            return false;\n        }\n\n        ptr += image->GetWidth()*3;\n    }\n\n    (void) TIFFClose(tif);\n\n    if (buf)\n        _TIFFfree(buf);\n\n    return true;\n}",
    "bool  TiffEncoder::writeLibTiff( const Mat& img, const vector<int>& params)\n{\n    int channels = img.channels();\n    int width = img.cols, height = img.rows;\n    int depth = img.depth();\n\n    int bitsPerChannel = -1;\n    switch (depth)\n    {\n        case CV_8U:\n        {\n            bitsPerChannel = 8;\n            break;\n        }\n        case CV_16U:\n        {\n            bitsPerChannel = 16;\n            break;\n        }\n        default:\n        {\n            return false;\n        }\n    }\n\n    const int bitsPerByte = 8;\n    size_t fileStep = (width * channels * bitsPerChannel) / bitsPerByte;\n\n    int rowsPerStrip = (int)((1 << 13)/fileStep);\n    readParam(params, TIFFTAG_ROWSPERSTRIP, rowsPerStrip);\n\n    if( rowsPerStrip < 1 )\n        rowsPerStrip = 1;\n\n    if( rowsPerStrip > height )\n        rowsPerStrip = height;\n\n\n    // do NOT put \"wb\" as the mode, because the b means \"big endian\" mode, not \"binary\" mode.\n    // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n    TIFF* pTiffHandle = TIFFOpen(m_filename.c_str(), \"w\");\n    if (!pTiffHandle)\n    {\n        return false;\n    }\n\n    // defaults for now, maybe base them on params in the future\n    int   compression  = COMPRESSION_LZW;\n    int   predictor    = PREDICTOR_HORIZONTAL;\n\n    readParam(params, TIFFTAG_COMPRESSION, compression);\n    readParam(params, TIFFTAG_PREDICTOR, predictor);\n\n    int   colorspace = channels > 1 ? PHOTOMETRIC_RGB : PHOTOMETRIC_MINISBLACK;\n\n    if ( !TIFFSetField(pTiffHandle, TIFFTAG_IMAGEWIDTH, width)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_IMAGELENGTH, height)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_BITSPERSAMPLE, bitsPerChannel)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_COMPRESSION, compression)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_PHOTOMETRIC, colorspace)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_SAMPLESPERPIXEL, channels)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_ROWSPERSTRIP, rowsPerStrip)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_PREDICTOR, predictor)\n       )\n    {\n        TIFFClose(pTiffHandle);\n        return false;\n    }\n\n    // row buffer, because TIFFWriteScanline modifies the original data!\n    size_t scanlineSize = TIFFScanlineSize(pTiffHandle);\n    AutoBuffer<uchar> _buffer(scanlineSize+32);\n    uchar* buffer = _buffer;\n    if (!buffer)\n    {\n        TIFFClose(pTiffHandle);\n        return false;\n    }\n\n    for (int y = 0; y < height; ++y)\n    {\n        switch(channels)\n        {\n            case 1:\n            {\n                memcpy(buffer, img.data + img.step * y, scanlineSize);\n                break;\n            }\n\n            case 3:\n            {\n                if (depth == CV_8U)\n                    icvCvt_BGR2RGB_8u_C3R( img.data + img.step*y, 0, buffer, 0, cvSize(width,1) );\n                else\n                    icvCvt_BGR2RGB_16u_C3R( (const ushort*)(img.data + img.step*y), 0, (ushort*)buffer, 0, cvSize(width,1) );\n                break;\n            }\n\n            case 4:\n            {\n                if (depth == CV_8U)\n                    icvCvt_BGRA2RGBA_8u_C4R( img.data + img.step*y, 0, buffer, 0, cvSize(width,1) );\n                else\n                    icvCvt_BGRA2RGBA_16u_C4R( (const ushort*)(img.data + img.step*y), 0, (ushort*)buffer, 0, cvSize(width,1) );\n                break;\n            }\n\n            default:\n            {\n                TIFFClose(pTiffHandle);\n                return false;\n            }\n        }\n\n        int writeResult = TIFFWriteScanline(pTiffHandle, buffer, y, 0);\n        if (writeResult != 1)\n        {\n            TIFFClose(pTiffHandle);\n            return false;\n        }\n    }\n\n    TIFFClose(pTiffHandle);\n    return true;\n}",
    "int write_tiff_image(float* inputImg, unsigned int n, unsigned int m,\n\tunsigned int nChannels, const char* outputFile)\n{\n\tuint32 width,height;\n\twidth = (uint32)n;\n\theight = (uint32)m;\n\n\t//parameters\n\tuint32 samplePerPixel = nChannels;\n\n\tTIFF *tifFile= TIFFOpen(outputFile, \"w\");\n\t//set parameters of image\n\tTIFFSetField (tifFile, TIFFTAG_IMAGEWIDTH, width);  // set the width of the image\n\tTIFFSetField(tifFile, TIFFTAG_IMAGELENGTH, height);    // set the height of the image\n\tTIFFSetField(tifFile, TIFFTAG_SAMPLESPERPIXEL, samplePerPixel);   // set number of channels per pixel\n\tTIFFSetField(tifFile, TIFFTAG_BITSPERSAMPLE, 8);\n\tTIFFSetField(tifFile, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);    // set the origin of the image.\n\t//   Some other essential fields to set that you do not have to understand for now.\n\tTIFFSetField(tifFile, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\tTIFFSetField(tifFile, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n\n\t//create a temporary buffer to write the image info to\n\ttsize_t lineBytes = (tsize_t) (samplePerPixel * width);  // length in memory of one row of pixel in the image.\n\tunsigned char *buf = NULL;        // buffer used to store the row of pixel information for writing to file\n\tunsigned char *bufChar;\n\t//    Allocating memory to store the pixels of current row\n\tif (TIFFScanlineSize(tifFile) == lineBytes)\n\t{\n\t\tbuf = (unsigned char *)_TIFFmalloc(lineBytes);\n\t\tbufChar = new unsigned char[lineBytes];\n\t}\n\telse\n\t{\n\t\tbuf = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(tifFile));\n\t\tbufChar = new unsigned char[TIFFScanlineSize(tifFile)];\n\t}\n\n\t//std::cout << \"line size : \" << TIFFScanlineSize(tifFile)<< std::endl;\n\t//std::cout << \"line bytes : \" << lineBytes << std::endl;\n\t//write the image\n\t // We set the strip size of the file to be size of one row of pixels\n\tTIFFSetField(tifFile, TIFFTAG_ROWSPERSTRIP, TIFFDefaultStripSize(tifFile, width*samplePerPixel));\n\t//std::cout << \"width*samplePerPixel : \" << width*samplePerPixel << std::endl;\n\n\t//Now writing image to the file one strip at a time\n\tfor (uint32 i = 0; i < height; i++)\n\t{\n\t\t//copy the image information into a temporary buffer\n\t\tfor (uint32 j=0; j<width; j++)\n\t\t{\t//the tiff stores the image info in the following order : RGB\n\t\t\tfor (uint32 c=0; c<nChannels; c++)\n\t\t\t\tbufChar[j*nChannels+c] = (unsigned char)(round( inputImg[j + i*width + c*width*height]) );\n\t\t}\n\t\tstd::memcpy(buf, bufChar, lineBytes);\t//copy information to special Tiff buffer\n\t\t//std::cout << \" \" << (*inputImg->get_ptr(i,0)) << std::endl;\n\t\tif (TIFFWriteScanline(tifFile, buf, i, 0) < 0)\n\t\t{\n\t\t\tstd::cout << \"Error in writing the image file.\" << std::endl;\n\t\t\treturn(-1);\n\t\t}\n\t}\n\n    if (buf)\n    \t_TIFFfree(buf);\n\tdelete bufChar;\n\n\t//close image\n\tTIFFClose(tifFile);\n\treturn(0);\n}",
    "bool TiffEncoder::writeLibTiff( const std::vector<Mat>& img_vec, const std::vector<int>& params)\n{\n    // do NOT put \"wb\" as the mode, because the b means \"big endian\" mode, not \"binary\" mode.\n    // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n    TIFF* pTiffHandle;\n\n    TiffEncoderBufHelper buf_helper(m_buf);\n    if ( m_buf )\n    {\n        pTiffHandle = buf_helper.open();\n    }\n    else\n    {\n        pTiffHandle = TIFFOpen(m_filename.c_str(), \"w\");\n    }\n    if (!pTiffHandle)\n    {\n        return false;\n    }\n\n    //Settings that matter to all images\n    // defaults for now, maybe base them on params in the future\n    int compression = COMPRESSION_LZW;\n    int predictor = PREDICTOR_HORIZONTAL;\n\n    readParam(params, TIFFTAG_COMPRESSION, compression);\n    readParam(params, TIFFTAG_PREDICTOR, predictor);\n\n    //Iterate through each image in the vector and write them out as Tiff directories\n    for (size_t page = 0; page < img_vec.size(); page++)\n    {\n        const Mat& img = img_vec[page];\n        int channels = img.channels();\n        int width = img.cols, height = img.rows;\n        int depth = img.depth();\n\n        int bitsPerChannel = -1;\n        switch (depth)\n        {\n            case CV_8U:\n            {\n                bitsPerChannel = 8;\n                break;\n            }\n            case CV_16U:\n            {\n                bitsPerChannel = 16;\n                break;\n            }\n            default:\n            {\n                TIFFClose(pTiffHandle);\n                return false;\n            }\n        }\n\n        const int bitsPerByte = 8;\n        size_t fileStep = (width * channels * bitsPerChannel) / bitsPerByte;\n\n        int rowsPerStrip = (int)((1 << 13) / fileStep);\n        readParam(params, TIFFTAG_ROWSPERSTRIP, rowsPerStrip);\n\n        if (rowsPerStrip < 1)\n            rowsPerStrip = 1;\n\n        if (rowsPerStrip > height)\n            rowsPerStrip = height;\n\n        int   colorspace = channels > 1 ? PHOTOMETRIC_RGB : PHOTOMETRIC_MINISBLACK;\n\n        if (!TIFFSetField(pTiffHandle, TIFFTAG_IMAGEWIDTH, width)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_IMAGELENGTH, height)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_BITSPERSAMPLE, bitsPerChannel)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_COMPRESSION, compression)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_PHOTOMETRIC, colorspace)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_SAMPLESPERPIXEL, channels)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_ROWSPERSTRIP, rowsPerStrip)\n            || (img_vec.size() > 1 && (\n               !TIFFSetField(pTiffHandle, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE)\n            || !TIFFSetField(pTiffHandle, TIFFTAG_PAGENUMBER, page, img_vec.size() )))\n            )\n        {\n            TIFFClose(pTiffHandle);\n            return false;\n        }\n\n        if (compression != COMPRESSION_NONE && !TIFFSetField(pTiffHandle, TIFFTAG_PREDICTOR, predictor))\n        {\n            TIFFClose(pTiffHandle);\n            return false;\n        }\n\n        // row buffer, because TIFFWriteScanline modifies the original data!\n        size_t scanlineSize = TIFFScanlineSize(pTiffHandle);\n        AutoBuffer<uchar> _buffer(scanlineSize + 32);\n        uchar* buffer = _buffer;\n        if (!buffer)\n        {\n            TIFFClose(pTiffHandle);\n            return false;\n        }\n\n        for (int y = 0; y < height; ++y)\n        {\n            switch (channels)\n            {\n                case 1:\n                {\n                    memcpy(buffer, img.ptr(y), scanlineSize);\n                    break;\n                }\n\n                case 3:\n                {\n                    if (depth == CV_8U)\n                        icvCvt_BGR2RGB_8u_C3R( img.ptr(y), 0, buffer, 0, cvSize(width, 1));\n                    else\n                        icvCvt_BGR2RGB_16u_C3R( img.ptr<ushort>(y), 0, (ushort*)buffer, 0, cvSize(width, 1));\n                    break;\n                }\n\n                case 4:\n                {\n                    if (depth == CV_8U)\n                        icvCvt_BGRA2RGBA_8u_C4R( img.ptr(y), 0, buffer, 0, cvSize(width, 1));\n                    else\n                        icvCvt_BGRA2RGBA_16u_C4R( img.ptr<ushort>(y), 0, (ushort*)buffer, 0, cvSize(width, 1));\n                    break;\n                }\n\n                default:\n                {\n                    TIFFClose(pTiffHandle);\n                    return false;\n                }\n            }\n\n            int writeResult = TIFFWriteScanline(pTiffHandle, buffer, y, 0);\n            if (writeResult != 1)\n            {\n                TIFFClose(pTiffHandle);\n                return false;\n            }\n        }\n\n        TIFFWriteDirectory(pTiffHandle);\n\n    }\n\n    TIFFClose(pTiffHandle);\n    return true;\n}",
    "bool  TiffEncoder::writeLibTiff( const Mat& img, const std::vector<int>& params)\n{\n    int channels = img.channels();\n    int width = img.cols, height = img.rows;\n    int depth = img.depth();\n\n    int bitsPerChannel = -1;\n    switch (depth)\n    {\n        case CV_8U:\n        {\n            bitsPerChannel = 8;\n            break;\n        }\n        case CV_16U:\n        {\n            bitsPerChannel = 16;\n            break;\n        }\n        default:\n        {\n            return false;\n        }\n    }\n\n    const int bitsPerByte = 8;\n    size_t fileStep = (width * channels * bitsPerChannel) / bitsPerByte;\n\n    int rowsPerStrip = (int)((1 << 13)/fileStep);\n    readParam(params, TIFFTAG_ROWSPERSTRIP, rowsPerStrip);\n\n    if( rowsPerStrip < 1 )\n        rowsPerStrip = 1;\n\n    if( rowsPerStrip > height )\n        rowsPerStrip = height;\n\n\n    // do NOT put \"wb\" as the mode, because the b means \"big endian\" mode, not \"binary\" mode.\n    // http://www.remotesensing.org/libtiff/man/TIFFOpen.3tiff.html\n    TIFF* pTiffHandle;\n\n    TiffEncoderBufHelper buf_helper(m_buf);\n    if ( m_buf )\n    {\n        pTiffHandle = buf_helper.open();\n    }\n    else\n    {\n        pTiffHandle = TIFFOpen(m_filename.c_str(), \"w\");\n    }\n    if (!pTiffHandle)\n    {\n        return false;\n    }\n\n    // defaults for now, maybe base them on params in the future\n    int   compression  = COMPRESSION_LZW;\n    int   predictor    = PREDICTOR_HORIZONTAL;\n\n    readParam(params, TIFFTAG_COMPRESSION, compression);\n    readParam(params, TIFFTAG_PREDICTOR, predictor);\n\n    int   colorspace = channels > 1 ? PHOTOMETRIC_RGB : PHOTOMETRIC_MINISBLACK;\n\n    if ( !TIFFSetField(pTiffHandle, TIFFTAG_IMAGEWIDTH, width)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_IMAGELENGTH, height)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_BITSPERSAMPLE, bitsPerChannel)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_COMPRESSION, compression)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_PHOTOMETRIC, colorspace)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_SAMPLESPERPIXEL, channels)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG)\n      || !TIFFSetField(pTiffHandle, TIFFTAG_ROWSPERSTRIP, rowsPerStrip)\n       )\n    {\n        TIFFClose(pTiffHandle);\n        return false;\n    }\n\n    if (compression != COMPRESSION_NONE && !TIFFSetField(pTiffHandle, TIFFTAG_PREDICTOR, predictor) )\n    {\n        TIFFClose(pTiffHandle);\n        return false;\n    }\n\n    // row buffer, because TIFFWriteScanline modifies the original data!\n    size_t scanlineSize = TIFFScanlineSize(pTiffHandle);\n    AutoBuffer<uchar> _buffer(scanlineSize+32);\n    uchar* buffer = _buffer;\n    if (!buffer)\n    {\n        TIFFClose(pTiffHandle);\n        return false;\n    }\n\n    for (int y = 0; y < height; ++y)\n    {\n        switch(channels)\n        {\n            case 1:\n            {\n                memcpy(buffer, img.ptr(y), scanlineSize);\n                break;\n            }\n\n            case 3:\n            {\n                if (depth == CV_8U)\n                    icvCvt_BGR2RGB_8u_C3R( img.ptr(y), 0, buffer, 0, cvSize(width,1) );\n                else\n                    icvCvt_BGR2RGB_16u_C3R( img.ptr<ushort>(y), 0, (ushort*)buffer, 0, cvSize(width,1) );\n                break;\n            }\n\n            case 4:\n            {\n                if (depth == CV_8U)\n                    icvCvt_BGRA2RGBA_8u_C4R( img.ptr(y), 0, buffer, 0, cvSize(width,1) );\n                else\n                    icvCvt_BGRA2RGBA_16u_C4R( img.ptr<ushort>(y), 0, (ushort*)buffer, 0, cvSize(width,1) );\n                break;\n            }\n\n            default:\n            {\n                TIFFClose(pTiffHandle);\n                return false;\n            }\n        }\n\n        int writeResult = TIFFWriteScanline(pTiffHandle, buffer, y, 0);\n        if (writeResult != 1)\n        {\n            TIFFClose(pTiffHandle);\n            return false;\n        }\n    }\n\n    TIFFClose(pTiffHandle);\n    return true;\n}",
    "int main(int argc, char* argv[]) {\n\n    TIFFSetWarningHandler(DummyHandler);\n\n    if (argc != 5) {\n        cerr << \"Usage:  \" << argv[0] << \" <background.tiff> <overlay.tiff> <mask.tiff> <output_filename.tiff>\" << endl;\n        return -1;\n    }\n\n    char *fn_tiff1 = argv[1];\n    char *fn_tiff2 = argv[2];\n    char *fn_tiff_mask = argv[3];\n    char *fn_tiff_out = argv[4];\n\n    // only check\n    FILE *fp;\n\n    fp = fopen(fn_tiff1, \"rb\");\n    if (!fp) {\n        fprintf(stderr, \"Not found: %s. Aborted.\\n\", fn_tiff1);\n        return -1;\n    };\n    fclose(fp);\n\n    fp = fopen(fn_tiff2, \"rb\");\n    if (!fp) {\n        fprintf(stderr, \"Not found: %s. Aborted.\\n\", fn_tiff2);\n        return -1;\n    };\n    fclose(fp);\n\n    fp = fopen(fn_tiff_mask, \"rb\");\n    if (!fp) {\n        fprintf(stderr, \"Not found: %s. Aborted.\\n\", fn_tiff_mask);\n        return -1;\n    };\n    fclose(fp);\n\n\n    TIFF *tiff1 = TIFFOpen(fn_tiff1, \"rb\");\n\n    TIFF *tiff2 = TIFFOpen(fn_tiff2, \"rb\");\n\n    TIFF *tiff_mask = TIFFOpen(fn_tiff_mask, \"rb\");\n\n    TIFF *tiff_out = TIFFOpen(fn_tiff_out, \"rb+\");\n\n\n\n    uint32_t width = 0, height = 0, bits_per_sample = 0, samples_per_pixel = 0, sample_format = 0;\n\n\n\n    TIFFGetField(tiff1, TIFFTAG_IMAGEWIDTH, &width);           // uint32 width;\n    TIFFGetField(tiff1, TIFFTAG_IMAGELENGTH, &height);        // uint32 height;\n\n    TIFFGetField(tiff1, TIFFTAG_BITSPERSAMPLE, &bits_per_sample);\n    TIFFGetField(tiff1, TIFFTAG_SAMPLESPERPIXEL, &samples_per_pixel);\n    TIFFGetField(tiff1, TIFFTAG_SAMPLEFORMAT, &sample_format);\n\n\n\n    printf(\"%s: (%d x %d, %d bit) (samples per pixel: %d, format: %d) \\n\", fn_tiff1, width, height, bits_per_sample, samples_per_pixel, sample_format);\n\n    if ( (bits_per_sample != 16) || (sample_format != 2) || (samples_per_pixel != 1) ) {\n        fprintf(stderr, \"ERROR: Bad format. Aborted. \\n\\n\");\n        TIFFClose(tiff1);\n        TIFFClose(tiff2);\n        TIFFClose(tiff_mask);\n        TIFFClose(tiff_out);\n        exit(-1);\n    };\n\n    uint32_t width2 = 0, height2 = 0, bits_per_sample2 = 0, samples_per_pixel2 = 0, sample_format2 = 0;\n\n    TIFFGetField(tiff2, TIFFTAG_IMAGEWIDTH, &width2);           // uint32 width;\n    TIFFGetField(tiff2, TIFFTAG_IMAGELENGTH, &height2);        // uint32 height;\n\n    TIFFGetField(tiff2, TIFFTAG_BITSPERSAMPLE, &bits_per_sample2);\n    TIFFGetField(tiff2, TIFFTAG_SAMPLESPERPIXEL, &samples_per_pixel2);\n    TIFFGetField(tiff2, TIFFTAG_SAMPLEFORMAT, &sample_format2);\n\n    printf(\"%s: (%d x %d, %d bit) (samples per pixel: %d, format: %d) \\n\", fn_tiff2, width2, height2, bits_per_sample2, samples_per_pixel2, sample_format2);\n\n    if (\n        (width != width2)\n        || (height != height2)\n        || (bits_per_sample != bits_per_sample2)\n        || (samples_per_pixel != samples_per_pixel2)\n        || (sample_format != sample_format2)\n\n        ) {\n\n        fprintf(stderr, \"ERROR: Format of %s is different from %s. Aborted. \\n\", fn_tiff2, fn_tiff1 );\n\n        TIFFClose(tiff1);\n        TIFFClose(tiff2);\n        TIFFClose(tiff_mask);\n        TIFFClose(tiff_out);\n\n        exit(-1);\n\n    };\n\n\n\n    uint32_t width_mask = 0, height_mask = 0, bits_per_sample_mask = 0, samples_per_pixel_mask = 0, sample_format_mask = 0;\n\n    TIFFGetField(tiff_mask, TIFFTAG_IMAGEWIDTH, &width_mask);           // uint32 width;\n    TIFFGetField(tiff_mask, TIFFTAG_IMAGELENGTH, &height_mask);        // uint32 height;\n\n    TIFFGetField(tiff_mask, TIFFTAG_BITSPERSAMPLE, &bits_per_sample_mask);\n    TIFFGetField(tiff_mask, TIFFTAG_SAMPLESPERPIXEL, &samples_per_pixel_mask);\n    TIFFGetField(tiff_mask, TIFFTAG_SAMPLEFORMAT, &sample_format_mask);\n\n    printf(\"%s: (%d x %d, %d bit) (samples per pixel: %d, format: %d) \\n\", fn_tiff_mask, width_mask, height_mask, bits_per_sample_mask, samples_per_pixel_mask, sample_format_mask);\n\n\n\n    int16_t *buf1, *buf2;\n    uint8_t *buf_mask;\n    tsize_t scanline = TIFFScanlineSize(tiff1);\n\n    if (TIFFScanlineSize(tiff2) != scanline) {\n        fprintf(stderr, \"ERROR: Scanline Size of %s (%d) is different from %s (%d).\\n\", fn_tiff2, (TIFFScanlineSize(tiff2)), fn_tiff1, scanline );\n        return -1;\n    };\n    if (2*TIFFScanlineSize(tiff_mask) != scanline) {\n        fprintf(stderr, \"ERROR: Scanline Size of %s (%d) must be 1/2 of scanline size of %s (%d).\\n\", fn_tiff_mask, (TIFFScanlineSize(tiff_mask)), fn_tiff1, scanline );\n        return -1;\n    };\n\n\n    buf1 = (int16_t*) _TIFFmalloc(scanline);\n    buf2 = (int16_t*) _TIFFmalloc(scanline);\n    buf_mask = (uint8_t*) _TIFFmalloc(scanline);\n\n\n    for (uint32_t row = 0; row < height; row++) {\n\n        TIFFReadScanline(tiff1, buf1, row);\n        TIFFReadScanline(tiff2, buf2, row);\n        TIFFReadScanline(tiff_mask, buf_mask, row);\n\n\n        for (int i = 0; i < width; i++) {\n\n            float k = 1.0 / 255.0 * buf_mask[i];\n\n            buf1[i] = (int16_t) ( (1.0-k)*buf1[i] + k*buf2[i] );\n\n        };\n\n\n        TIFFWriteScanline(tiff_out, buf1, row);\n\n    };\n\n    _TIFFfree(buf1);\n    _TIFFfree(buf2);\n    _TIFFfree(buf_mask);\n\n\n\n    TIFFClose(tiff1);\n    TIFFClose(tiff2);\n    TIFFClose(tiff_mask);\n    TIFFClose(tiff_out);\n\n\n\n    printf(\"Done.\\n\");\n\n    return 0;\n}",
    "bool\nTIFFOutput::write_scanline(int y, int z, TypeDesc format, const void* data,\n                           stride_t xstride)\n{\n    m_spec.auto_stride(xstride, format, spec().nchannels);\n    data = to_native_scanline(format, data, xstride, m_scratch, m_dither, y, z);\n\n    // Handle weird photometric/color spaces\n    std::vector<unsigned char> cmyk;\n    if (m_photometric == PHOTOMETRIC_SEPARATED && m_convert_rgb_to_cmyk)\n        data = convert_to_cmyk(spec().width, data, cmyk);\n    size_t scanline_vals = spec().width * m_outputchans;\n\n    // Handle weird bit depths\n    if (spec().format.size() * 8 != m_bitspersample) {\n        data = move_to_scratch(data, scanline_vals * spec().format.size());\n        fix_bitdepth(m_scratch.data(), scanline_vals);\n    }\n\n    y -= m_spec.y;\n    if (m_planarconfig == PLANARCONFIG_SEPARATE && m_spec.nchannels > 1) {\n        // Convert from contiguous (RGBRGBRGB) to separate (RRRGGGBBB)\n        int plane_bytes = m_spec.width * m_spec.format.size();\n\n        std::unique_ptr<char[]> separate_heap;\n        char* separate            = nullptr;\n        imagesize_t separate_size = plane_bytes * m_outputchans;\n        if (separate_size <= (1 << 16))\n            separate = ALLOCA(char, separate_size);        // <=64k ? stack\n        else {                                             // >64k ? heap\n            separate_heap.reset(new char[separate_size]);  // will auto-free\n            separate = separate_heap.get();\n        }\n\n        contig_to_separate(m_spec.width, m_outputchans, (const char*)data,\n                           separate);\n        for (int c = 0; c < m_outputchans; ++c) {\n            if (TIFFWriteScanline(m_tif, (tdata_t)&separate[plane_bytes * c], y,\n                                  c)\n                < 0) {\n                std::string err = oiio_tiff_last_error();\n                error(\"TIFFWriteScanline failed writing line y=%d,z=%d (%s)\", y,\n                      z, err.size() ? err.c_str() : \"unknown error\");\n                return false;\n            }\n        }\n    } else {\n        // No contig->separate is necessary.  But we still use scratch\n        // space since TIFFWriteScanline is destructive when\n        // TIFFTAG_PREDICTOR is used.\n        data = move_to_scratch(data, scanline_vals * m_spec.format.size());\n        if (TIFFWriteScanline(m_tif, (tdata_t)data, y) < 0) {\n            std::string err = oiio_tiff_last_error();\n            error(\"TIFFWriteScanline failed writing line y=%d,z=%d (%s)\", y, z,\n                  err.size() ? err.c_str() : \"unknown error\");\n            return false;\n        }\n    }\n\n    // Should we checkpoint? Only if we have enough scanlines and enough\n    // time has passed (or if using JPEG compression, for which it seems\n    // necessary).\n    ++m_checkpointItems;\n    if ((m_checkpointTimer() > DEFAULT_CHECKPOINT_INTERVAL_SECONDS\n         || m_compression == COMPRESSION_JPEG)\n        && m_checkpointItems >= MIN_SCANLINES_OR_TILES_PER_CHECKPOINT) {\n        TIFFCheckpointDirectory(m_tif);\n        m_checkpointTimer.lap();\n        m_checkpointItems = 0;\n    }\n\n    return true;\n}",
    "int WriteTiff(const char * filename,\n  const std::vector<unsigned char> & ptr,\n  int w,\n  int h,\n  int depth)\n{\n  TIFF* tiff = TIFFOpen(filename, \"w\");\n  if (!tiff) {\n    std::cerr << \"Error: Couldn't open \" << filename << \" fopen returned 0\";\n    return 0;\n  }\n  TIFFSetField(tiff, TIFFTAG_IMAGEWIDTH, w);\n  TIFFSetField(tiff, TIFFTAG_IMAGELENGTH, h);\n  TIFFSetField(tiff, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n  TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n  TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 8);\n  TIFFSetField(tiff, TIFFTAG_SAMPLESPERPIXEL, depth);\n  TIFFSetField(tiff, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n  TIFFSetField(tiff, TIFFTAG_COMPRESSION,COMPRESSION_NONE);\n  TIFFSetField(tiff, TIFFTAG_ROWSPERSTRIP, 16);\n  for (uint32 y=0; y < static_cast<uint32>(h); ++y) {\n    if (TIFFWriteScanline(tiff,(tdata_t)(((uint8*)(&ptr[0]))+depth*w*y),y)<0) {\n      TIFFClose(tiff);\n      return 0;\n    }\n  }\n  TIFFClose(tiff);\n  return 1;\n}",
    "bool TiffWriter::writeRGB32Image(const TiffHandle& tif, const QImage& image) {\n  assert(image.format() == QImage::Format_RGB32);\n\n  TIFFSetField(tif.handle(), TIFFTAG_SAMPLESPERPIXEL, uint16(3));\n  TIFFSetField(tif.handle(), TIFFTAG_COMPRESSION, uint16(ApplicationSettings::getInstance().getTiffColorCompression()));\n  TIFFSetField(tif.handle(), TIFFTAG_BITSPERSAMPLE, uint16(8));\n  TIFFSetField(tif.handle(), TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n\n  const int width = image.width();\n  const int height = image.height();\n\n  std::vector<uint8_t> tmpLine(width * 3);\n\n  // Libtiff expects \"RR GG BB\" sequences regardless of CPU byte order.\n\n  for (int y = 0; y < height; ++y) {\n    const auto* pSrc = (const uint32_t*) image.scanLine(y);\n    uint8_t* pDst = &tmpLine[0];\n    for (int x = 0; x < width; ++x) {\n      const uint32_t ARGB = *pSrc;\n      pDst[0] = static_cast<uint8_t>(ARGB >> 16);\n      pDst[1] = static_cast<uint8_t>(ARGB >> 8);\n      pDst[2] = static_cast<uint8_t>(ARGB);\n      ++pSrc;\n      pDst += 3;\n    }\n    if (TIFFWriteScanline(tif.handle(), &tmpLine[0], y) == -1) {\n      return false;\n    }\n  }\n  return true;\n}",
    "bool TiffWriter::writeARGB32Image(const TiffHandle& tif, const QImage& image) {\n  assert(image.format() == QImage::Format_ARGB32);\n\n  TIFFSetField(tif.handle(), TIFFTAG_SAMPLESPERPIXEL, uint16(4));\n  TIFFSetField(tif.handle(), TIFFTAG_COMPRESSION, uint16(ApplicationSettings::getInstance().getTiffColorCompression()));\n  TIFFSetField(tif.handle(), TIFFTAG_BITSPERSAMPLE, uint16(8));\n  TIFFSetField(tif.handle(), TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n\n  const int width = image.width();\n  const int height = image.height();\n\n  std::vector<uint8_t> tmpLine(width * 4);\n\n  // Libtiff expects \"RR GG BB AA\" sequences regardless of CPU byte order.\n\n  for (int y = 0; y < height; ++y) {\n    const auto* pSrc = (const uint32_t*) image.scanLine(y);\n    uint8_t* pDst = &tmpLine[0];\n    for (int x = 0; x < width; ++x) {\n      const uint32_t ARGB = *pSrc;\n      pDst[0] = static_cast<uint8_t>(ARGB >> 16);\n      pDst[1] = static_cast<uint8_t>(ARGB >> 8);\n      pDst[2] = static_cast<uint8_t>(ARGB);\n      pDst[3] = static_cast<uint8_t>(ARGB >> 24);\n      ++pSrc;\n      pDst += 4;\n    }\n    if (TIFFWriteScanline(tif.handle(), &tmpLine[0], y) == -1) {\n      return false;\n    }\n  }\n  return true;\n}",
    "bool TiffWriter::write8bitLines(const TiffHandle& tif, const QImage& image) {\n  const int width = image.width();\n  const int height = image.height();\n\n  // TIFFWriteScanline() can actually modify the data you pass it,\n  // so we have to use a temporary buffer even when no coversion\n  // is required.\n  std::vector<uint8_t> tmpLine(width, 0);\n\n  for (int y = 0; y < height; ++y) {\n    const uint8_t* srcLine = image.scanLine(y);\n    memcpy(&tmpLine[0], srcLine, tmpLine.size());\n    if (TIFFWriteScanline(tif.handle(), &tmpLine[0], y) == -1) {\n      return false;\n    }\n  }\n  return true;\n}",
    "bool TiffWriter::writeBinaryLinesAsIs(const TiffHandle& tif, const QImage& image) {\n  const int width = image.width();\n  const int height = image.height();\n  // TIFFWriteScanline() can actually modify the data you pass it,\n  // so we have to use a temporary buffer even when no coversion\n  // is required.\n  const int bpl = (width + 7) / 8;\n  std::vector<uint8_t> tmpLine(bpl, 0);\n\n  for (int y = 0; y < height; ++y) {\n    const uint8_t* srcLine = image.scanLine(y);\n    memcpy(&tmpLine[0], srcLine, bpl);\n    if (TIFFWriteScanline(tif.handle(), &tmpLine[0], y) == -1) {\n      return false;\n    }\n  }\n  return true;\n}",
    "bool TiffWriter::writeBinaryLinesReversed(const TiffHandle& tif, const QImage& image) {\n  const int width = image.width();\n  const int height = image.height();\n\n  const int bpl = (width + 7) / 8;\n  std::vector<uint8_t> tmpLine(bpl, 0);\n\n  for (int y = 0; y < height; ++y) {\n    const uint8_t* srcLine = image.scanLine(y);\n    for (int i = 0; i < bpl; ++i) {\n      tmpLine[i] = m_reverseBitsLUT[srcLine[i]];\n    }\n    if (TIFFWriteScanline(tif.handle(), &tmpLine[0], y) == -1) {\n      return false;\n    }\n  }\n  return true;\n}",
    "void AIPlug::processRaster(QDataStream &ts)\r\n{\r\n\tdouble m1, m2, m3, m4, m5, m6, x1, y1, x2, y2, dummy;\r\n\tint w, h, type, alpha, bin, bits;\r\n\tQString tmp = \"\";\r\n\tQString cumulated = \"\";\r\n\twhile (!ts.atEnd())\r\n\t{\r\n\t\ttmp = readLineFromDataStream(ts);\r\n\t\tif (tmp.startsWith(\"%\"))\r\n\t\t\tbreak;\r\n\t\ttmp.remove(\"[\");\r\n\t\ttmp.remove(\"]\");\r\n\t\tif (!tmp.isEmpty())\r\n\t\t\tcumulated += \" \" + tmp;\r\n\t}\r\n\tQString Cdata = \"\";\r\n\tQStringList da;\r\n\tgetCommands(cumulated, da);\r\n\tCdata = da.last();\r\n\tScTextStream gVals(&Cdata, QIODevice::ReadOnly);\r\n\tgVals >> m1 >> m2 >> m3 >> m4 >> m5 >> m6 >> x1 >> y1 >> x2 >> y2 >> w >> h >> bits >> type >> alpha >> dummy >> bin;\r\n//\tqDebug() << QString(\"Matrix: %1 %2 %3 %4 %5 %6\").arg(m1).arg(m2).arg(m3).arg(m4).arg(m5).arg(m6);\r\n//\tqDebug() << QString(\"Bounds: %1 %2 %3 %4\").arg(x1).arg(y1).arg(x2).arg(y2);\r\n//\tqDebug() << QString(\"Size: %1 %2\").arg(w).arg(h);\r\n//\tqDebug() << QString(\"Bits: %1\").arg(bits);\r\n//\tqDebug() << QString(\"Typ: %1\").arg(type);\r\n//\tqDebug() << QString(\"Alpha-Channels: %1\").arg(alpha);\r\n//\tqDebug() << QString(\"Encoding: %1\").arg(bin);\r\n\tuint dataSize = w * h * (type + alpha);\r\n\tuint alphaData = w * h * type;\r\n//\tbool cmyk = false;\r\n//\tif (type == 4)\r\n//\t\tcmyk = true;\r\n\tif (tmp.startsWith(\"%%BeginData\"))\r\n\t{\r\n\t\tScTextStream gVals2(&tmp, QIODevice::ReadOnly);\r\n\t\ttmp = readLineFromDataStream(ts);\r\n\t}\r\n\tQByteArray psdata;\r\n\tpsdata.resize(dataSize);\r\n\tRawImage m_image;\r\n\tif (type == 4)\r\n\t{\r\n\t\tif (alpha > 0)\r\n\t\t\tm_image.create(w, 1, 5);\r\n\t\telse\r\n\t\t\tm_image.create(w, 1, 4);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tif (alpha > 0)\r\n\t\t\tm_image.create(w, 1, 4);\r\n\t\telse\r\n\t\t\tm_image.create(w, 1, 3);\r\n\t}\r\n\tbool first = false;\r\n\tif (bin == 0) // 0 = ASCII encoded data\r\n\t{\r\n\t\tuint dataPointer = 0;\r\n\t\twhile (!ts.atEnd())\r\n\t\t{\r\n\t\t\tif (first)\r\n\t\t\t\ttmp = readLineFromDataStream(ts);\r\n\t\t\tfirst = true;\r\n\t\t\tif (tmp.startsWith(\"%AI5_EndRaster\"))\r\n\t\t\t\tbreak;\r\n\t\t\tfor (int a = 1; a < tmp.length(); a += 2)\r\n\t\t\t{\r\n\t\t\t\tbool ok;\r\n\t\t\t\tushort data = tmp.midRef(a, 2).toUShort(&ok, 16);\r\n\t\t\t\tpsdata[dataPointer++] = data;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tpsdata.resize(dataSize);\r\n\t\tts.readRawData(psdata.data(), dataSize);\r\n\t}\r\n\tQTransform imgMatrix = QTransform(m1, m2, m3, m4, m5, m6);\r\n\tQPointF pos = QPointF(imgMatrix.dx(), imgMatrix.dy());\r\n\tpos += QPointF(m_Doc->currentPage()->xOffset(), -m_Doc->currentPage()->yOffset());\r\n\tpos += QPointF(baseX, -baseY);\r\n\tint z = m_Doc->itemAdd(PageItem::ImageFrame, PageItem::Unspecified, pos.x() - docX, docHeight - (pos.y() - docY), 10, 10, 0, CurrColorFill, CurrColorStroke);\r\n\tPageItem* ite = m_Doc->Items->at(z);\r\n\tite->setWidthHeight(fabs(w * m1), fabs(h * m4));\r\n\tdouble rotation = getRotationFromMatrix(imgMatrix, 0.0);\r\n\tite->setRotation(rotation * 180 / M_PI);\r\n\tite->SetRectFrame();\r\n\tm_Doc->setRedrawBounding(ite);\r\n\tite->Clip = flattenPath(ite->PoLine, ite->Segments);\r\n\tite->setTextFlowMode(PageItem::TextFlowDisabled);\r\n\tite->setFillShade(CurrFillShade);\r\n\tite->setLineShade(CurrStrokeShade);\r\n\tite->setFillEvenOdd(fillRule);\r\n\tite->setFillTransparency(1.0 - Opacity);\r\n\tite->setLineTransparency(1.0 - Opacity);\r\n\tite->setFillBlendmode(blendMode);\r\n\tite->setLineBlendmode(blendMode);\r\n\tite->setLineEnd(CapStyle);\r\n\tite->setLineJoin(JoinStyle);\r\n\tuchar *p;\r\n\tuint yCount = 0;\r\n\tquint16 eTag = EXTRASAMPLE_UNASSALPHA;\r\n\tQTemporaryFile *tempFile = new QTemporaryFile(QDir::tempPath() + \"/scribus_temp_ai_XXXXXX.tif\");\r\n\ttempFile->setAutoRemove(false);\r\n\ttempFile->open();\r\n\tQString imgName = getLongPathName(tempFile->fileName());\r\n\ttempFile->close();\r\n\tite->isInlineImage = true;\r\n\tite->isTempFile = true;\r\n\tdelete tempFile;\r\n\tTIFF* tif = TIFFOpen(imgName.toLocal8Bit().data(), \"w\");\r\n\tif (tif)\r\n\t{\r\n\t\tTIFFSetField(tif, TIFFTAG_IMAGEWIDTH, w);\r\n\t\tTIFFSetField(tif, TIFFTAG_IMAGELENGTH, h);\r\n\t\tTIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8);\r\n\t\tTIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, m_image.channels());\r\n\t\tif (alpha == 1)\r\n\t\t\tTIFFSetField(tif, TIFFTAG_EXTRASAMPLES, 1, &eTag);\r\n\t\tTIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\r\n\t\tif (type == 4)\r\n\t\t\tTIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_SEPARATED);\r\n\t\telse\r\n\t\t\tTIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\r\n\t\tTIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_LZW);\r\n\t\tfor (int y = 0; y < h; ++y)\r\n\t\t{\r\n\t\t\tp = m_image.scanLine( 0 );\r\n\t\t\tfor (int xh = 0; xh < m_image.width(); ++xh )\r\n\t\t\t{\r\n\t\t\t\tp[0] = psdata[yCount++];\r\n\t\t\t\tif (type > 1)\r\n\t\t\t\t{\r\n\t\t\t\t\tp[1] = psdata[yCount++];\r\n\t\t\t\t\tp[2] = psdata[yCount++];\r\n\t\t\t\t\tif (type == 4)\r\n\t\t\t\t\t\tp[3] = psdata[yCount++];\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tp[1] = p[0];\r\n\t\t\t\t\tp[2] = p[0];\r\n\t\t\t\t}\r\n\t\t\t\tif (alpha == 1)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (type == 4)\r\n\t\t\t\t\t\tp[4] = psdata[alphaData++];\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tp[3] = psdata[alphaData++];\r\n\t\t\t\t}\r\n\t\t\t\tp += m_image.channels();\r\n\t\t\t}\r\n\t\t\tTIFFWriteScanline(tif, m_image.scanLine(0), y);\r\n\t\t}\r\n\t\tTIFFClose(tif);\r\n\t}\r\n\tm_Doc->loadPict(imgName, ite);\r\n\tif (ite->imageIsAvailable)\r\n\t\tite->setImageXYScale(ite->width() / ite->pixm.width(), ite->height() / ite->pixm.height());\r\n\tif (importerFlags & LoadSavePlugin::lfCreateDoc)\r\n\t\tite->setLocked(itemLocked);\r\n\tif (patternMode)\r\n\t\tPatternElements.append(ite);\r\n\telse\r\n\t\tElements.append(ite);\r\n\tif (groupStack.count() != 0)\r\n\t\tgroupStack.top().append(ite);\r\n}",
    "void SlaOutputDev::drawImage(GfxState *state, Object *ref, Stream *str, int width, int height, GfxImageColorMap *colorMap, GBool interpolate, POPPLER_CONST_082 int* maskColors, GBool inlineImg)\r\n{\r\n\tImageStream * imgStr = new ImageStream(str, width, colorMap->getNumPixelComps(), colorMap->getBits());\r\n//\tqDebug() << \"Image Components\" << colorMap->getNumPixelComps() << \"Mask\" << maskColors;\r\n\timgStr->reset();\r\n\tQImage* image = nullptr;\r\n\tif (maskColors)\r\n\t{\r\n\t\timage = new QImage(width, height, QImage::Format_ARGB32);\r\n\t\tfor (int y = 0; y < height; y++)\r\n\t\t{\r\n\t\t\tQRgb *s = (QRgb*)(image->scanLine(y));\r\n\t\t\tGuchar *pix = imgStr->getLine();\r\n\t\t\tfor (int x = 0; x < width; x++)\r\n\t\t\t{\r\n\t\t\t\tGfxRGB rgb;\r\n\t\t\t\tcolorMap->getRGB(pix, &rgb);\r\n\t\t\t\tint Rc = qRound(colToDbl(rgb.r) * 255);\r\n\t\t\t\tint Gc = qRound(colToDbl(rgb.g) * 255);\r\n\t\t\t\tint Bc = qRound(colToDbl(rgb.b) * 255);\r\n\t\t\t\t*s = qRgba(Rc, Gc, Bc, 255);\r\n\t\t\t\tfor (int i = 0; i < colorMap->getNumPixelComps(); ++i)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (pix[i] < maskColors[2*i] * 255 || pix[i] > maskColors[2*i+1] * 255)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t*s = *s | 0xff000000;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\ts++;\r\n\t\t\t\tpix += colorMap->getNumPixelComps();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\timage = new QImage(width, height, QImage::Format_ARGB32);\r\n\t\tfor (int y = 0; y < height; y++)\r\n\t\t{\r\n\t\t\tQRgb *s = (QRgb*)(image->scanLine(y));\r\n\t\t\tGuchar *pix = imgStr->getLine();\r\n\t\t\tfor (int x = 0; x < width; x++)\r\n\t\t\t{\r\n\t\t\t\tif (colorMap->getNumPixelComps() == 4)\r\n\t\t\t\t{\r\n\t\t\t\t\tGfxCMYK cmyk;\r\n\t\t\t\t\tcolorMap->getCMYK(pix, &cmyk);\r\n\t\t\t\t\tint Cc = qRound(colToDbl(cmyk.c) * 255);\r\n\t\t\t\t\tint Mc = qRound(colToDbl(cmyk.m) * 255);\r\n\t\t\t\t\tint Yc = qRound(colToDbl(cmyk.y) * 255);\r\n\t\t\t\t\tint Kc = qRound(colToDbl(cmyk.k) * 255);\r\n\t\t\t\t\t*s = qRgba(Yc, Mc, Cc, Kc);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tGfxRGB rgb;\r\n\t\t\t\t\tcolorMap->getRGB(pix, &rgb);\r\n\t\t\t\t\tint Rc = qRound(colToDbl(rgb.r) * 255);\r\n\t\t\t\t\tint Gc = qRound(colToDbl(rgb.g) * 255);\r\n\t\t\t\t\tint Bc = qRound(colToDbl(rgb.b) * 255);\r\n\t\t\t\t\t*s = qRgba(Rc, Gc, Bc, 255);\r\n\t\t\t\t}\r\n\t\t\t\ts++;\r\n\t\t\t\tpix += colorMap->getNumPixelComps();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (image == nullptr || image->isNull())\r\n\t{\r\n\t\tdelete imgStr;\r\n\t\tdelete image;\r\n\t\treturn;\r\n\t}\r\n\tconst double *ctm = state->getCTM();\r\n\tdouble xCoor = m_doc->currentPage()->xOffset();\r\n\tdouble yCoor = m_doc->currentPage()->yOffset();\r\n\tQRectF crect = QRectF(0, 0, width, height);\r\n\tm_ctm = QTransform(ctm[0] / width, ctm[1] / width, -ctm[2] / height, -ctm[3] / height, ctm[2] + ctm[4], ctm[3] + ctm[5]);\r\n\tQLineF cline = QLineF(0, 0, width, 0);\r\n\tQLineF tline = m_ctm.map(cline);\r\n\tQRectF trect = m_ctm.mapRect(crect);\r\n\tdouble sx = m_ctm.m11();\r\n\tdouble sy = m_ctm.m22();\r\n\tQImage img = image->copy();\r\n\tQTransform mm = QTransform(ctm[0] / width, ctm[1] / width, -ctm[2] / height, -ctm[3] / height, 0, 0);\r\n\tint z = m_doc->itemAdd(PageItem::ImageFrame, PageItem::Rectangle, xCoor + trect.x(), yCoor + trect.y(), trect.width(), trect.height(), 0, CommonStrings::None, CommonStrings::None);\r\n\tPageItem* ite = m_doc->Items->at(z);\r\n\tite->ClipEdited = true;\r\n\tite->FrameType = 3;\r\n\tm_doc->setRedrawBounding(ite);\r\n\tite->Clip = flattenPath(ite->PoLine, ite->Segments);\r\n\tite->setTextFlowMode(PageItem::TextFlowDisabled);\r\n\tite->setFillShade(100);\r\n\tite->setLineShade(100);\r\n\tite->setFillEvenOdd(false);\r\n\tite->setFillTransparency(1.0 - state->getFillOpacity());\r\n\tite->setFillBlendmode(getBlendMode(state));\r\n\tm_doc->adjustItemSize(ite);\r\n\tif ((mm.type() == QTransform::TxShear) || (mm.type() == QTransform::TxRotate))\r\n\t{\r\n\t\tite->setImageRotation(-tline.angle());\r\n\t\t/*QTransform rotMat;\r\n\t\trotMat.rotate(tline.angle());\r\n\t\tQTransform imgMat = m_ctm * rotMat.inverted();\r\n\t\tdouble scaleX = sqrt(imgMat.m11() * imgMat.m11() + imgMat.m12() * imgMat.m12());\r\n\t\tdouble scaleY = sqrt(imgMat.m21() * imgMat.m21() + imgMat.m22() * imgMat.m22());\r\n\t\timgMat.scale(1.0 / scaleX, 1.0 / scaleY);\r\n\t\tif (!imgMat.isIdentity())\r\n\t\t\timg = img.transformed(imgMat);*/\r\n\t}\r\n\telse\r\n\t{\r\n\t\tif ((sx < 0) || (sy < 0))\r\n\t\t{\r\n\t\t\tif (sx < 0)\r\n\t\t\t\tite->setImageFlippedH(true);\r\n\t\t\tif (sy < 0)\r\n\t\t\t\tite->setImageFlippedV(true);\r\n\t\t}\r\n\t}\r\n\tif (colorMap->getNumPixelComps() == 4)\r\n\t{\r\n\t\tQTemporaryFile *tempFile = new QTemporaryFile(QDir::tempPath() + \"/scribus_temp_pdf_XXXXXX.tif\");\r\n\t\ttempFile->setAutoRemove(false);\r\n\t\tif (tempFile->open())\r\n\t\t{\r\n\t\t\tQString fileName = getLongPathName(tempFile->fileName());\r\n\t\t\tif (!fileName.isEmpty())\r\n\t\t\t{\r\n\t\t\t\ttempFile->close();\r\n\t\t\t\tite->isInlineImage = true;\r\n\t\t\t\tite->isTempFile = true;\r\n\t\t\t\tite->AspectRatio = false;\r\n\t\t\t\tite->ScaleType   = false;\r\n\t\t\t\tTIFF* tif = TIFFOpen(fileName.toLocal8Bit().data(), \"w\");\r\n\t\t\t\tif (tif)\r\n\t\t\t\t{\r\n\t\t\t\t\tTIFFSetField(tif, TIFFTAG_IMAGEWIDTH, img.width());\r\n\t\t\t\t\tTIFFSetField(tif, TIFFTAG_IMAGELENGTH, img.height());\r\n\t\t\t\t\tTIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8);\r\n\t\t\t\t\tTIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 4);\r\n\t\t\t\t\tTIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\r\n\t\t\t\t\tTIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_SEPARATED);\r\n\t\t\t\t\tTIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_LZW);\r\n\t\t\t\t\tfor (int y = 0; y < img.height(); ++y)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tTIFFWriteScanline(tif, img.scanLine(y), y);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tTIFFClose(tif);\r\n\t\t\t\t\tm_doc->loadPict(fileName, ite);\r\n\t\t\t\t}\r\n\t\t\t\tm_Elements->append(ite);\r\n\t\t\t\tif (m_groupStack.count() != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tm_groupStack.top().Items.append(ite);\r\n\t\t\t\t\tapplyMask(ite);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\tm_doc->Items->removeAll(ite);\r\n\t\t}\r\n\t\tdelete tempFile;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tQTemporaryFile *tempFile = new QTemporaryFile(QDir::tempPath() + \"/scribus_temp_pdf_XXXXXX.png\");\r\n\t\ttempFile->setAutoRemove(false);\r\n\t\tif (tempFile->open())\r\n\t\t{\r\n\t\t\tQString fileName = getLongPathName(tempFile->fileName());\r\n\t\t\tif (!fileName.isEmpty())\r\n\t\t\t{\r\n\t\t\t\ttempFile->close();\r\n\t\t\t\tite->isInlineImage = true;\r\n\t\t\t\tite->isTempFile = true;\r\n\t\t\t\tite->AspectRatio = false;\r\n\t\t\t\tite->ScaleType   = false;\r\n\t\t\t\timg.save(fileName, \"PNG\");\r\n\t\t\t\tm_doc->loadPict(fileName, ite);\r\n\t\t\t\tm_Elements->append(ite);\r\n\t\t\t\tif (m_groupStack.count() != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tm_groupStack.top().Items.append(ite);\r\n\t\t\t\t\tapplyMask(ite);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\tm_doc->Items->removeAll(ite);\r\n\t\t}\r\n\t\tdelete tempFile;\r\n\t}\r\n\tif ((checkClip()) && (inPattern == 0))\r\n\t{\r\n\t\tFPointArray out = m_currentClipPath.copy();\r\n\t\tout.translate(m_doc->currentPage()->xOffset(), m_doc->currentPage()->yOffset());\r\n\t\tout.translate(-ite->xPos(), -ite->yPos());\r\n\t\tite->PoLine = out.copy();\r\n\t\tite->ClipEdited = true;\r\n\t\tite->FrameType = 3;\r\n\t\tFPoint wh = getMaxClipF(&ite->PoLine);\r\n\t\tite->setWidthHeight(wh.x(), wh.y());\r\n\t\tite->setTextFlowMode(PageItem::TextFlowDisabled);\r\n\t\tite->ScaleType   = true;\r\n\t\tm_doc->adjustItemSize(ite);\r\n\t\tite->OldB2 = ite->width();\r\n\t\tite->OldH2 = ite->height();\r\n\t\tite->updateClip();\r\n\t}\r\n\tdelete imgStr;\r\n\tdelete image;\r\n}",
    "void writeTiffFile(unsigned int width,unsigned int height,const unsigned char* image,const char* imageFileName)\n\t{\n\t/* Set the TIFF error handler: */\n\tTIFFSetErrorHandler(tiffErrorFunction);\n\tTIFFSetWarningHandler(tiffWarningFunction);\n\t\n\tTIFF* tiff=0;\n\ttry\n\t\t{\n\t\t/* Open the TIFF file: */\n\t\ttiff=TIFFOpen(imageFileName,\"w\");\n\t\tif(tiff==0)\n\t\t\tthrow std::runtime_error(\"Error while opening image file\");\n\t\t\n\t\t/* Write the TIFF image layout tags: */\n\t\tTIFFSetField(tiff,TIFFTAG_IMAGEWIDTH,width);\n\t\tTIFFSetField(tiff,TIFFTAG_IMAGELENGTH,height);\n\t\tTIFFSetField(tiff,TIFFTAG_BITSPERSAMPLE,8);\n\t\tTIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,3);\n\t\tTIFFSetField(tiff,TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG);\n\t\tTIFFSetField(tiff,TIFFTAG_COMPRESSION,COMPRESSION_NONE);\n\t\tTIFFSetField(tiff,TIFFTAG_PHOTOMETRIC,PHOTOMETRIC_RGB);\n\t\tTIFFSetField(tiff,TIFFTAG_ROWSPERSTRIP,TIFFDefaultStripSize(tiff,width*3));\n\t\t\n\t\t/* Write the image data to the TIFF file one scan line at a time, top-to-bottom: */\n\t\tfor(unsigned int row=height;row>0;--row)\n\t\t\tif(TIFFWriteScanline(tiff,reinterpret_cast<tdata_t>(const_cast<unsigned char*>(image+(row-1)*width*3)),height-row)<0)\n\t\t\t\tthrow std::runtime_error(\"Error while writing image\");\n\t\t\n\t\t/* Close the TIFF file: */\n\t\tTIFFClose(tiff);\n\t\t}\n\tcatch(std::runtime_error err)\n\t\t{\n\t\t/* Clean up: */\n\t\tif(tiff!=0)\n\t\t\tTIFFClose(tiff);\n\t\t\n\t\t/* Wrap and re-throw the exception: */\n\t\tMisc::throwStdErr(\"Images::writeTiffFile: Caught exception \\\"%s\\\" while writing image \\\"%s\\\"\",err.what(),imageFileName);\n\t\t}\n\t}",
    "void writeTiff(Window im, TIFF *tiff, unsigned int multiplier) {\n\n\n        double minval = (double)std::numeric_limits<T>::min();\n        double maxval = (double)std::numeric_limits<T>::max();\n\n        bool clamped = false;\n\n        T *buffer = new T[im.width * im.channels];\n        for (int y = 0; y < im.height; y++) {\n            for (int x = 0; x < im.width; x++) {\n                for (int c = 0; c < im.channels; c++) {\n                    double out = im(x, y)[c] * multiplier;\n                    if (out < minval) {clamped = true; out = minval;}\n                    if (out > maxval) {clamped = true; out = maxval;}\n                    buffer[x * im.channels + c] = (T)(out);\n                }\n            }\n            TIFFWriteScanline(tiff, buffer, y, 1);\n        }        \n\n        delete[] buffer;\n\n        if (clamped) printf(\"WARNING: Data exceeded the range [0, 1], so was clamped on writing.\\n\");\n    }",
    "bool TiffWriter::writePointers(unsigned char **rowPointers, int rowCount)\n{\n  // Write all rows to the file\n\n  for (int row = 0; row < rowCount; row++) {\n    if (TIFFWriteScanline(f, rowPointers[row], row, 0) < 0) {\n      fprintf(stderr, \"TiffWriter: Error writing tiff row %d\\n\", row);\n      return false;\n    }\n  }\n\n  return true;\n}",
    "bool TiffWriter::writeRow(unsigned char **rowData)\n{\n  // Add a single row\n\n  if (TIFFWriteScanline(f, *rowData, curRow, 0) < 0) {\n    fprintf(stderr, \"TiffWriter: Error writing tiff row %d\\n\", curRow);\n    return false;\n  }\n\n  curRow++;\n\n  return true;\n}",
    "void writeTiff(Image im, TIFF *tiff, unsigned int multiplier) {\n\n    double minval = (double)std::numeric_limits<T>::min();\n    double maxval = (double)std::numeric_limits<T>::max();\n\n    bool clamped = false;\n\n    vector<T> buffer(im.width * im.channels);\n    for (int y = 0; y < im.height; y++) {\n        for (int x = 0; x < im.width; x++) {\n            for (int c = 0; c < im.channels; c++) {\n                double out = im(x, y, c) * multiplier;\n                if (out < minval) {clamped = true; out = minval;}\n                if (out > maxval) {clamped = true; out = maxval;}\n                buffer[x*im.channels + c] = (T)(out);\n            }\n        }\n        TIFFWriteScanline(tiff, &buffer[0], y, 1);\n    }\n\n    if (clamped) { printf(\"WARNING: Data exceeded the range [0, 1], so was clamped on writing.\\n\"); }\n}",
    "ImageIO::errorType ImageIO::saveTIFF(const char * filename)\n{\n#ifdef ENABLE_TIFF\n\n  TIFF *tif;\n\n  tif = TIFFOpen(filename, \"w\");\n  if( !tif )\n  {\n    printf(\"Error in saveTIFF: Cannot open file %s.\\n\", filename);\n    return IO_ERROR;\n  }\n\n  TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, width);\n  TIFFSetField(tif, TIFFTAG_IMAGELENGTH, height);\n  TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, bytesPerPixel);\n  TIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n  TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, BITS_PER_CHANNEL_8);\n  TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n  if (bytesPerPixel < IMAGE_IO_RGB)\n    TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n  else\n    TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n  TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_LZW);\n  TIFFSetField(tif, TIFFTAG_PREDICTOR, IMAGE_IO_HORIZONTAL_DIFFERENCING);\n\n  tsize_t bytesPerRow = bytesPerPixel * width;    \n  \n  if (TIFFScanlineSize(tif) != bytesPerRow)\n  {\n    printf(\"Error in saveTIFF: the scanline size mismatches the length in memory of one row of pixels in the image.\\n\");\n    TIFFClose(tif);\n    return IO_ERROR;\n  }\n  \n  unsigned char * imageBuf = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(tif));\n  if (imageBuf == NULL)\n  {\n    printf(\"Error in saveTIFF: cannot allocate memory for the storage of a row of pixels.\\n\");\n    TIFFClose(tif);\n    return IO_ERROR;\n  }\n\n  // Set the strip size of the file to be the size of one row of pixels\n  TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, TIFFDefaultStripSize(tif, (uint32)bytesPerRow));\n\n  for (unsigned int row = 0; row < height; row++)\n  {\n    memcpy(imageBuf, &pixels[(height - row - 1) * bytesPerRow], sizeof(unsigned char) * bytesPerRow); \n    if (TIFFWriteScanline(tif, imageBuf, row, 0) < 0)  // an error occurred while writing the image\n    {\n      printf(\"Error in saveTIFF: Error while saving TIFF image to %s.\\n\", filename);\n      _TIFFfree(imageBuf);\n      TIFFClose(tif);\n      return IO_ERROR;\n    }\n  }\n\n  _TIFFfree(imageBuf);\n  TIFFClose(tif);\n\n  return OK;\n#else\n  return INVALID_FILE_FORMAT;\n#endif\n}",
    "bool QTiffHandler::write(const QImage &image)\n{\n    if (!device()->isWritable())\n        return false;\n\n    TIFF *const tiff = TIFFClientOpen(\"foo\",\n                                      \"w\",\n                                      this,\n                                      qtiffReadProc,\n                                      qtiffWriteProc,\n                                      qtiffSeekProc,\n                                      qtiffCloseProc,\n                                      qtiffSizeProc,\n                                      qtiffMapProc,\n                                      qtiffUnmapProc);\n    if (!tiff)\n        return false;\n\n    const int width = image.width();\n    const int height = image.height();\n\n    if (!TIFFSetField(tiff, TIFFTAG_IMAGEWIDTH, width)\n        || !TIFFSetField(tiff, TIFFTAG_IMAGELENGTH, height)\n        || !TIFFSetField(tiff, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG)) {\n        TIFFClose(tiff);\n        return false;\n    }\n\n    // set the resolution\n    bool  resolutionSet = false;\n    const int dotPerMeterX = image.dotsPerMeterX();\n    const int dotPerMeterY = image.dotsPerMeterY();\n    if ((dotPerMeterX % 100) == 0\n        && (dotPerMeterY % 100) == 0) {\n        resolutionSet = TIFFSetField(tiff, TIFFTAG_RESOLUTIONUNIT, RESUNIT_CENTIMETER)\n                        && TIFFSetField(tiff, TIFFTAG_XRESOLUTION, dotPerMeterX/100.0)\n                        && TIFFSetField(tiff, TIFFTAG_YRESOLUTION, dotPerMeterY/100.0);\n    } else {\n        resolutionSet = TIFFSetField(tiff, TIFFTAG_RESOLUTIONUNIT, RESUNIT_INCH)\n                        && TIFFSetField(tiff, TIFFTAG_XRESOLUTION, static_cast<float>(image.logicalDpiX()))\n                        && TIFFSetField(tiff, TIFFTAG_YRESOLUTION, static_cast<float>(image.logicalDpiY()));\n    }\n    if (!resolutionSet) {\n        TIFFClose(tiff);\n        return false;\n    }\n\n    // configure image depth\n    const QImage::Format format = image.format();\n    if (format == QImage::Format_Mono || format == QImage::Format_MonoLSB) {\n        uint16 photometric = PHOTOMETRIC_MINISBLACK;\n        if (image.colorTable().at(0) == 0xffffffff)\n            photometric = PHOTOMETRIC_MINISWHITE;\n        if (!TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, photometric)\n            || !TIFFSetField(tiff, TIFFTAG_COMPRESSION, compression == NoCompression ? COMPRESSION_NONE : COMPRESSION_CCITTRLE)\n            || !TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 1)) {\n            TIFFClose(tiff);\n            return false;\n        }\n\n        // try to do the conversion in chunks no greater than 16 MB\n        int chunks = (width * height / (1024 * 1024 * 16)) + 1;\n        int chunkHeight = qMax(height / chunks, 1);\n\n        int y = 0;\n        while (y < height) {\n            QImage chunk = image.copy(0, y, width, qMin(chunkHeight, height - y)).convertToFormat(QImage::Format_Mono);\n\n            int chunkStart = y;\n            int chunkEnd = y + chunk.height();\n            while (y < chunkEnd) {\n                if (TIFFWriteScanline(tiff, reinterpret_cast<uint32 *>(chunk.scanLine(y - chunkStart)), y) != 1) {\n                    TIFFClose(tiff);\n                    return false;\n                }\n                ++y;\n            }\n        }\n        TIFFClose(tiff);\n    } else if (format == QImage::Format_Indexed8) {\n        const QVector<QRgb> colorTable = image.colorTable();\n        bool isGrayscale = checkGrayscale(colorTable);\n        if (isGrayscale) {\n            uint16 photometric = PHOTOMETRIC_MINISBLACK;\n            if (image.colorTable().at(0) == 0xffffffff)\n                photometric = PHOTOMETRIC_MINISWHITE;\n            if (!TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, photometric)\n                    || !TIFFSetField(tiff, TIFFTAG_COMPRESSION, compression == NoCompression ? COMPRESSION_NONE : COMPRESSION_PACKBITS)\n                    || !TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 8)) {\n                TIFFClose(tiff);\n                return false;\n            }\n        } else {\n            if (!TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_PALETTE)\n                    || !TIFFSetField(tiff, TIFFTAG_COMPRESSION, compression == NoCompression ? COMPRESSION_NONE : COMPRESSION_PACKBITS)\n                    || !TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 8)) {\n                TIFFClose(tiff);\n                return false;\n            }\n            //// write the color table\n            // allocate the color tables\n            uint16 *redTable = static_cast<uint16 *>(qMalloc(256 * sizeof(uint16)));\n            uint16 *greenTable = static_cast<uint16 *>(qMalloc(256 * sizeof(uint16)));\n            uint16 *blueTable = static_cast<uint16 *>(qMalloc(256 * sizeof(uint16)));\n            if (!redTable || !greenTable || !blueTable) {\n                qFree(redTable);\n                qFree(greenTable);\n                qFree(blueTable);\n                TIFFClose(tiff);\n                return false;\n            }\n\n            // set the color table\n            const int tableSize = colorTable.size();\n            Q_ASSERT(tableSize <= 256);\n            for (int i = 0; i<tableSize; ++i) {\n                const QRgb color = colorTable.at(i);\n                redTable[i] = qRed(color) * 257;\n                greenTable[i] = qGreen(color) * 257;\n                blueTable[i] = qBlue(color) * 257;\n            }\n\n            const bool setColorTableSuccess = TIFFSetField(tiff, TIFFTAG_COLORMAP, redTable, greenTable, blueTable);\n\n            qFree(redTable);\n            qFree(greenTable);\n            qFree(blueTable);\n\n            if (!setColorTableSuccess) {\n                TIFFClose(tiff);\n                return false;\n            }\n        }\n\n        //// write the data\n        // try to do the conversion in chunks no greater than 16 MB\n        int chunks = (width * height/ (1024 * 1024 * 16)) + 1;\n        int chunkHeight = qMax(height / chunks, 1);\n\n        int y = 0;\n        while (y < height) {\n            QImage chunk = image.copy(0, y, width, qMin(chunkHeight, height - y));\n\n            int chunkStart = y;\n            int chunkEnd = y + chunk.height();\n            while (y < chunkEnd) {\n                if (TIFFWriteScanline(tiff, reinterpret_cast<uint32 *>(chunk.scanLine(y - chunkStart)), y) != 1) {\n                    TIFFClose(tiff);\n                    return false;\n                }\n                ++y;\n            }\n        }\n        TIFFClose(tiff);\n\n    } else {\n        if (!TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB)\n            || !TIFFSetField(tiff, TIFFTAG_COMPRESSION, compression == NoCompression ? COMPRESSION_NONE : COMPRESSION_LZW)\n            || !TIFFSetField(tiff, TIFFTAG_SAMPLESPERPIXEL, 4)\n            || !TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 8)) {\n            TIFFClose(tiff);\n            return false;\n        }\n        // try to do the ARGB32 conversion in chunks no greater than 16 MB\n        int chunks = (width * height * 4 / (1024 * 1024 * 16)) + 1;\n        int chunkHeight = qMax(height / chunks, 1);\n\n        int y = 0;\n        while (y < height) {\n            QImage chunk = image.copy(0, y, width, qMin(chunkHeight, height - y)).convertToFormat(QImage::Format_ARGB32);\n\n            int chunkStart = y;\n            int chunkEnd = y + chunk.height();\n            while (y < chunkEnd) {\n                if (QSysInfo::ByteOrder == QSysInfo::LittleEndian)\n                    convert32BitOrder(chunk.scanLine(y - chunkStart), width);\n                else\n                    convert32BitOrderBigEndian(chunk.scanLine(y - chunkStart), width);\n\n                if (TIFFWriteScanline(tiff, reinterpret_cast<uint32 *>(chunk.scanLine(y - chunkStart)), y) != 1) {\n                    TIFFClose(tiff);\n                    return false;\n                }\n                ++y;\n            }\n        }\n        TIFFClose(tiff);\n    }\n\n    return true;\n}",
    "void SlaOutputDev::drawImage(GfxState *state, Object *ref, Stream *str, int width, int height, GfxImageColorMap *colorMap, GBool interpolate, int *maskColors, GBool inlineImg)\r\n{\r\n\tImageStream * imgStr = new ImageStream(str, width, colorMap->getNumPixelComps(), colorMap->getBits());\r\n//\tqDebug() << \"Image Components\" << colorMap->getNumPixelComps() << \"Mask\" << maskColors;\r\n\timgStr->reset();\r\n\tQImage * image = 0;\r\n\tif (maskColors)\r\n\t{\r\n\t\timage = new QImage(width, height, QImage::Format_ARGB32);\r\n\t\tfor (int y = 0; y < height; y++)\r\n\t\t{\r\n\t\t\tQRgb *s = (QRgb*)(image->scanLine(y));\r\n\t\t\tGuchar *pix = imgStr->getLine();\r\n\t\t\tfor (int x = 0; x < width; x++)\r\n\t\t\t{\r\n\t\t\t\tGfxRGB rgb;\r\n\t\t\t\tcolorMap->getRGB(pix, &rgb);\r\n\t\t\t\tint Rc = qRound(colToDbl(rgb.r) * 255);\r\n\t\t\t\tint Gc = qRound(colToDbl(rgb.g) * 255);\r\n\t\t\t\tint Bc = qRound(colToDbl(rgb.b) * 255);\r\n\t\t\t\t*s = qRgba(Rc, Gc, Bc, 255);\r\n\t\t\t\tfor (int i = 0; i < colorMap->getNumPixelComps(); ++i)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (pix[i] < maskColors[2*i] * 255 || pix[i] > maskColors[2*i+1] * 255)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t*s = *s | 0xff000000;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\ts++;\r\n\t\t\t\tpix += colorMap->getNumPixelComps();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\timage = new QImage(width, height, QImage::Format_ARGB32);\r\n\t\tfor (int y = 0; y < height; y++)\r\n\t\t{\r\n\t\t\tQRgb *s = (QRgb*)(image->scanLine(y));\r\n\t\t\tGuchar *pix = imgStr->getLine();\r\n\t\t\tfor (int x = 0; x < width; x++)\r\n\t\t\t{\r\n\t\t\t\tif (colorMap->getNumPixelComps() == 4)\r\n\t\t\t\t{\r\n\t\t\t\t\tGfxCMYK cmyk;\r\n\t\t\t\t\tcolorMap->getCMYK(pix, &cmyk);\r\n\t\t\t\t\tint Cc = qRound(colToDbl(cmyk.c) * 255);\r\n\t\t\t\t\tint Mc = qRound(colToDbl(cmyk.m) * 255);\r\n\t\t\t\t\tint Yc = qRound(colToDbl(cmyk.y) * 255);\r\n\t\t\t\t\tint Kc = qRound(colToDbl(cmyk.k) * 255);\r\n\t\t\t\t\t*s = qRgba(Yc, Mc, Cc, Kc);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tGfxRGB rgb;\r\n\t\t\t\t\tcolorMap->getRGB(pix, &rgb);\r\n\t\t\t\t\tint Rc = qRound(colToDbl(rgb.r) * 255);\r\n\t\t\t\t\tint Gc = qRound(colToDbl(rgb.g) * 255);\r\n\t\t\t\t\tint Bc = qRound(colToDbl(rgb.b) * 255);\r\n\t\t\t\t\t*s = qRgba(Rc, Gc, Bc, 255);\r\n\t\t\t\t}\r\n\t\t\t\ts++;\r\n\t\t\t\tpix += colorMap->getNumPixelComps();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (image == NULL || image->isNull())\r\n\t{\r\n\t\tdelete imgStr;\r\n\t\tdelete image;\r\n\t\treturn;\r\n\t}\r\n\tdouble *ctm;\r\n\tctm = state->getCTM();\r\n\tdouble xCoor = m_doc->currentPage()->xOffset();\r\n\tdouble yCoor = m_doc->currentPage()->yOffset();\r\n\tQRectF crect = QRectF(0, 0, width, height);\r\n\tm_ctm = QTransform(ctm[0] / width, ctm[1] / width, -ctm[2] / height, -ctm[3] / height, ctm[2] + ctm[4], ctm[3] + ctm[5]);\r\n\tQLineF cline = QLineF(0, 0, width, 0);\r\n\tQLineF tline = m_ctm.map(cline);\r\n\tQRectF trect = m_ctm.mapRect(crect);\r\n\tdouble sx = m_ctm.m11();\r\n\tdouble sy = m_ctm.m22();\r\n\tQImage img = image->copy();\r\n\tQTransform mm = QTransform(ctm[0] / width, ctm[1] / width, -ctm[2] / height, -ctm[3] / height, 0, 0);\r\n\tif ((mm.type() == QTransform::TxShear) || (mm.type() == QTransform::TxRotate))\r\n\t{\r\n\t\tmm.reset();\r\n\t\tmm.rotate(-tline.angle());\r\n\t\timg = image->transformed(mm);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tif ((sx < 0) || (sy < 0))\r\n\t\t{\r\n\t\t\tif (sx < 0)\r\n\t\t\t\tmm.scale(-1, 1);\r\n\t\t\tif (sy < 0)\r\n\t\t\t\tmm.scale(1, -1);\r\n\t\t\timg = image->transformed(mm);\r\n\t\t}\r\n\t}\r\n\tint z = m_doc->itemAdd(PageItem::ImageFrame, PageItem::Rectangle, xCoor + trect.x(), yCoor + trect.y(), trect.width(), trect.height(), 0, CommonStrings::None, CommonStrings::None, true);\r\n\tPageItem* ite = m_doc->Items->at(z);\r\n\tite->ClipEdited = true;\r\n\tite->FrameType = 3;\r\n\tm_doc->setRedrawBounding(ite);\r\n\tite->Clip = FlattenPath(ite->PoLine, ite->Segments);\r\n\tite->setTextFlowMode(PageItem::TextFlowDisabled);\r\n\tite->setFillShade(100);\r\n\tite->setLineShade(100);\r\n\tite->setFillEvenOdd(false);\r\n\tite->setFillTransparency(1.0 - state->getFillOpacity());\r\n\tite->setFillBlendmode(getBlendMode(state));\r\n\tm_doc->AdjustItemSize(ite);\r\n\tif (colorMap->getNumPixelComps() == 4)\r\n\t{\r\n\t\tQTemporaryFile *tempFile = new QTemporaryFile(QDir::tempPath() + \"/scribus_temp_pdf_XXXXXX.tif\");\r\n\t\ttempFile->setAutoRemove(false);\r\n\t\tif (tempFile->open())\r\n\t\t{\r\n\t\t\tQString fileName = getLongPathName(tempFile->fileName());\r\n\t\t\tif (!fileName.isEmpty())\r\n\t\t\t{\r\n\t\t\t\ttempFile->close();\r\n\t\t\t\tite->isInlineImage = true;\r\n\t\t\t\tite->isTempFile = true;\r\n\t\t\t\tite->AspectRatio = false;\r\n\t\t\t\tite->ScaleType   = false;\r\n\t\t\t\tTIFF* tif = TIFFOpen(fileName.toLocal8Bit().data(), \"w\");\r\n\t\t\t\tif (tif)\r\n\t\t\t\t{\r\n\t\t\t\t\tTIFFSetField(tif, TIFFTAG_IMAGEWIDTH, img.width());\r\n\t\t\t\t\tTIFFSetField(tif, TIFFTAG_IMAGELENGTH, img.height());\r\n\t\t\t\t\tTIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8);\r\n\t\t\t\t\tTIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 4);\r\n\t\t\t\t\tTIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\r\n\t\t\t\t\tTIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_SEPARATED);\r\n\t\t\t\t\tTIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_LZW);\r\n\t\t\t\t\tfor (int y = 0; y < img.height(); ++y)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tTIFFWriteScanline(tif, img.scanLine(y), y);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tTIFFClose(tif);\r\n\t\t\t\t\tm_doc->loadPict(fileName, ite);\r\n\t\t\t\t}\r\n\t\t\t\tm_Elements->append(ite);\r\n\t\t\t\tif (m_groupStack.count() != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tm_groupStack.top().Items.append(ite);\r\n\t\t\t\t\tapplyMask(ite);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\tm_doc->Items->removeAll(ite);\r\n\t\t}\r\n\t\tdelete tempFile;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tQTemporaryFile *tempFile = new QTemporaryFile(QDir::tempPath() + \"/scribus_temp_pdf_XXXXXX.png\");\r\n\t\ttempFile->setAutoRemove(false);\r\n\t\tif (tempFile->open())\r\n\t\t{\r\n\t\t\tQString fileName = getLongPathName(tempFile->fileName());\r\n\t\t\tif (!fileName.isEmpty())\r\n\t\t\t{\r\n\t\t\t\ttempFile->close();\r\n\t\t\t\tite->isInlineImage = true;\r\n\t\t\t\tite->isTempFile = true;\r\n\t\t\t\tite->AspectRatio = false;\r\n\t\t\t\tite->ScaleType   = false;\r\n\t\t\t\timg.save(fileName, \"PNG\");\r\n\t\t\t\tm_doc->loadPict(fileName, ite);\r\n\t\t\t\tm_Elements->append(ite);\r\n\t\t\t\tif (m_groupStack.count() != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tm_groupStack.top().Items.append(ite);\r\n\t\t\t\t\tapplyMask(ite);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\tm_doc->Items->removeAll(ite);\r\n\t\t}\r\n\t\tdelete tempFile;\r\n\t}\r\n\tif (checkClip())\r\n\t{\r\n\t\tFPointArray out = m_currentClipPath.copy();\r\n\t\tout.translate(m_doc->currentPage()->xOffset(), m_doc->currentPage()->yOffset());\r\n\t\tout.translate(-ite->xPos(), -ite->yPos());\r\n\t\tite->PoLine = out.copy();\r\n\t\tFPoint wh = getMaxClipF(&ite->PoLine);\r\n\t\tite->setWidthHeight(wh.x(),wh.y());\r\n\t\tite->setTextFlowMode(PageItem::TextFlowDisabled);\r\n\t\tite->ScaleType   = true;\r\n\t\tm_doc->AdjustItemSize(ite);\r\n\t\tite->OldB2 = ite->width();\r\n\t\tite->OldH2 = ite->height();\r\n\t\tite->updateClip();\r\n\t}\r\n\tdelete imgStr;\r\n\tdelete image;\r\n}",
    "int ShowMesh2D::show_mesh_save_screen (const char * tiff_file, Window window, int width, int height)\n{\n  TIFF *fout= TIFFOpen(tiff_file, \"w\");\n  if(!fout) return 1;\n\n  int sampleperpixel = 3;    //RGB channel\n  XImage *ximage = XGetImage(display, window, 0, 0, width, height, AllPlanes, XYPixmap);\n  char *image=new char [width*height*sampleperpixel];\n  //it seems the XQueryColors has the limit of query size of 65535 colors.\n  XColor  *color=new XColor[65535];\n  int lines=65535/width;\n  int currentlines;\n  int count = 0;\n\n  for (int i = 0; i < height; i+=lines)\n  {\n    if(i+lines>=height) currentlines=height-i-1;\n    else currentlines=lines;\n    for (int j = 0; j < currentlines; j++)\n      for (int k = 0; k < width; k++)\n      {\n        unsigned long c;\n        c = XGetPixel(ximage, k, i+j);        /* X pixel value */\n        color[k+j*width].pixel = c;\n      }\n    XQueryColors(display, colormap, color, currentlines*width);\n    for (int j = 0; j < currentlines; j++)\n      for (int k = 0; k < width; k++)\n      {\n        char     r, g, b;\n        r = color[k+j*width].red >> 8;\n        g = color[k+j*width].green >> 8;\n        b = color[k+j*width].blue >> 8;\n\n        image[count++] = r;\n        image[count++] = g;\n        image[count++] = b;\n      }\n  }\n  delete [] color;\n\n  TIFFSetField(fout, TIFFTAG_IMAGEWIDTH, width);  // set the width of the image\n  TIFFSetField(fout, TIFFTAG_IMAGELENGTH, height);    // set the height of the image\n  TIFFSetField(fout, TIFFTAG_SAMPLESPERPIXEL, sampleperpixel);   // set number of channels per pixel\n  TIFFSetField(fout, TIFFTAG_BITSPERSAMPLE, 8);    // set the size of the channels\n  TIFFSetField(fout, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);    // set the origin of the image.\n  TIFFSetField(fout, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n  TIFFSetField(fout, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n  TIFFSetField(fout, TIFFTAG_COMPRESSION, COMPRESSION_PACKBITS);\n\n  tsize_t linebytes = sampleperpixel*width;     // length in memory of one row of pixel in the image.\n  // We set the strip size of the file to be size of one row of pixels\n  TIFFSetField(fout, TIFFTAG_ROWSPERSTRIP, TIFFDefaultStripSize(fout, width*sampleperpixel));\n  //Now writing image to the file one strip at a time\n  for (int row = 0; row < height; row++)\n  {\n    // check the index here, and figure out why not using h*linebytes\n    if(TIFFWriteScanline(fout, &image[row*linebytes], row, 0) < 0)\n      break;\n  }\n  TIFFClose(fout);\n  delete [] image;\n  XDestroyImage(ximage);\n  return 0;\n}",
    "void mat_to_image(const Mat mat, const std::string &image_file)\n{\n  PetscBool assembled;\n  MatAssembled(mat, &assembled);\n  if( !assembled )\n  {\n    MatAssemblyBegin(mat, MAT_FINAL_ASSEMBLY);\n    MatAssemblyEnd(mat, MAT_FINAL_ASSEMBLY);\n  }\n\n  PetscInt m;     //  - the number of local rows\n  PetscInt n;     //  - the number of local columns\n  MatGetLocalSize(mat, &m, &n);\n  PetscInt M, N;      // - the number of global rows and columns\n  MatGetSize(mat, &M, &N);\n\n  PetscInt row_begin ;  // - the global index of the first local row\n  PetscInt row_end;   // - one more than the global index of the last local row\n  MatGetOwnershipRange(mat, &row_begin,  &row_end);\n\n  // matrix entry (row, col) pairs\n  std::vector<PetscInt> rows;\n  std::vector<PetscInt> cols;\n  std::vector<PetscScalar> values;\n\n  // read the row\n  for(PetscInt row=row_begin; row<row_end; row++)\n  {\n    PetscInt ncols;\n    const PetscInt * row_cols_pointer;\n    const PetscScalar * row_vals_pointer;\n\n    MatGetRow(mat, row, &ncols, &row_cols_pointer, &row_vals_pointer);\n\n    for(PetscInt c=0; c<ncols; c++)\n    {\n      PetscInt col = row_cols_pointer[c];\n      rows.push_back(row);\n      cols.push_back(col);\n      values.push_back(fabs(row_vals_pointer[c]));\n    }\n\n    // restore pointers\n    MatRestoreRow(mat, row, &ncols, &row_cols_pointer, &row_vals_pointer);\n  }\n\n  // gather from other processor\n  Parallel::gather(0, rows);\n  Parallel::gather(0, cols);\n  Parallel::gather(0, values);\n\n  const PetscScalar max_value = *( std::max_element( values.begin(), values.end() ) );\n  std::vector< std::vector< std::pair<PetscInt, PetscScalar> > > entry(N);\n  for(unsigned int n=0; n<rows.size(); ++n)\n  {\n    PetscInt row = rows[n];\n    PetscInt col = cols[n];\n    entry[row].push_back( std::make_pair(col, values[n]) );\n  }\n  std::vector< std::vector< std::pair<PetscInt, PetscScalar> > > pad_entry(N);\n  {\n    std::set< std::pair<PetscInt, PetscInt> > mat_entry_set;\n    for(unsigned int n=0; n<values.size(); ++n)\n      mat_entry_set.insert(std::make_pair(rows[n], cols[n]));\n\n    for(unsigned int n=0; n<values.size(); ++n)\n    {\n      if( mat_entry_set.find(std::make_pair(cols[n], rows[n])) == mat_entry_set.end() )\n        pad_entry[cols[n]].push_back( std::make_pair(rows[n], 1.0) );\n    }\n  }\n\n  rows.clear();\n  cols.clear();\n  values.clear();\n\n\n  TIFF *fout= TIFFOpen(image_file.c_str(), \"w\");\n  int sampleperpixel = 3;    //RGB channel\n\n  TIFFSetField(fout, TIFFTAG_IMAGEWIDTH, M);  // set the width of the image\n  TIFFSetField(fout, TIFFTAG_IMAGELENGTH, N);    // set the height of the image\n  TIFFSetField(fout, TIFFTAG_SAMPLESPERPIXEL, sampleperpixel);   // set number of channels per pixel\n  TIFFSetField(fout, TIFFTAG_BITSPERSAMPLE, 8);    // set the size of the channels\n  TIFFSetField(fout, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);    // set the origin of the image.\n  TIFFSetField(fout, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n  TIFFSetField(fout, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n  TIFFSetField(fout, TIFFTAG_COMPRESSION, COMPRESSION_PACKBITS);\n\n  tsize_t linebytes = sampleperpixel*M;     // length in memory of one row of pixel in the image.\n  // We set the strip size of the file to be size of one row of pixels\n  TIFFSetField(fout, TIFFTAG_ROWSPERSTRIP, TIFFDefaultStripSize(fout, linebytes));\n\n  unsigned int rainbow[20][3] =\n    {\n      0, 0, 65535,\n      0, 29298, 65535,\n      0, 41377, 65535,\n      0, 50629, 65535,\n      0, 58596, 65535,\n      0, 65535, 65535,\n      0, 65535, 56797,\n      0, 65535, 46003,\n      0, 65535, 32639,\n      0, 65535, 0,\n      32125, 65535, 0,\n      46260, 65535, 0,\n      56540, 65535, 0,\n      65535, 65535, 0,\n      65535, 59881, 0,\n      65535, 53199, 0,\n      65535, 45746, 0,\n      65535, 38036, 0,\n      65535, 26471, 0,\n      65535, 0, 0\n    };\n\n  //Now writing image to the file one strip at a time\n  for (PetscInt row = 0; row < N; row++)\n  {\n    std::vector<unsigned char> image(linebytes, 255);\n    const std::vector< std::pair<PetscInt, PetscScalar> > & one_row = entry[row];\n    for(unsigned int n=0; n<one_row.size(); ++n)\n    {\n      int col = one_row[n].first;\n      PetscScalar value = one_row[n].second;\n      int level = 19*(value/max_value);//map to rainbow\n      image[3*col + 0] = rainbow[level][0]/255;\n      image[3*col + 1] = rainbow[level][1]/255;\n      image[3*col + 2] = rainbow[level][2]/255;\n    }\n    TIFFWriteScanline(fout, &image[0], row, 0);\n  }\n  TIFFClose(fout);\n}",
    "bool wxTIFFHandler::SaveFile( wxImage *image, wxOutputStream& stream, bool verbose )\n{\n    TIFF *tif = TIFFwxOpen( stream, \"image\", \"w\" );\n\n    if (!tif)\n    {\n        if (verbose)\n            wxLogError( _(\"TIFF: Error saving image.\") );\n\n        return false;\n    }\n\n    TIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n    TIFFSetField(tif, TIFFTAG_IMAGEWIDTH,  (uint32)image->GetWidth());\n    TIFFSetField(tif, TIFFTAG_IMAGELENGTH, (uint32)image->GetHeight());\n    TIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n    TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\n    if ( image->HasOption(wxIMAGE_OPTION_RESOLUTIONX) &&\n            image->HasOption(wxIMAGE_OPTION_RESOLUTIONY) )\n    {\n        TIFFSetField(tif, TIFFTAG_XRESOLUTION,\n                        (float)image->GetOptionInt(wxIMAGE_OPTION_RESOLUTIONX));\n        TIFFSetField(tif, TIFFTAG_YRESOLUTION,\n                        (float)image->GetOptionInt(wxIMAGE_OPTION_RESOLUTIONY));\n    }\n\n    int spp = image->GetOptionInt(wxIMAGE_OPTION_SAMPLESPERPIXEL);\n    if ( !spp )\n        spp = 3;\n\n    int bpp = image->GetOptionInt(wxIMAGE_OPTION_BITSPERSAMPLE);\n    if ( !bpp )\n        bpp=8;\n\n    int compression = image->GetOptionInt(wxIMAGE_OPTION_COMPRESSION);\n    if ( !compression )\n        compression=COMPRESSION_LZW;\n\n    TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, spp);\n    TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, bpp);\n    TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, spp*bpp == 1 ? PHOTOMETRIC_MINISBLACK\n                                                        : PHOTOMETRIC_RGB);\n    TIFFSetField(tif, TIFFTAG_COMPRESSION, compression);\n\n    // scanlinesize if determined by spp and bpp\n    tsize_t linebytes = (tsize_t)image->GetWidth() * spp * bpp / 8;\n\n    if ( (image->GetWidth() % 8 > 0) && (spp * bpp < 8) )\n        linebytes+=1;\n\n    unsigned char *buf;\n\n    if (TIFFScanlineSize(tif) > linebytes || (spp * bpp < 24))\n    {\n        buf = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(tif));\n        if (!buf)\n        {\n            if (verbose)\n                wxLogError( _(\"TIFF: Couldn't allocate memory.\") );\n\n            TIFFClose( tif );\n\n            return false;\n        }\n    }\n    else\n    {\n        buf = NULL;\n    }\n\n    TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP,TIFFDefaultStripSize(tif, (uint32) -1));\n\n    unsigned char *ptr = image->GetData();\n    for ( int row = 0; row < image->GetHeight(); row++ )\n    {\n        if ( buf )\n        {\n            if ( spp * bpp > 1 )\n            {\n                // color image\n                memcpy(buf, ptr, image->GetWidth());\n            }\n            else // black and white image\n            {\n                for ( int column = 0; column < linebytes; column++ )\n                {\n                    uint8 reverse = 0;\n                    for ( int bp = 0; bp < 8; bp++ )\n                    {\n                        if ( ptr[column*24 + bp*3] > 0 )\n                        {\n                            // check only red as this is sufficient\n                            reverse = reverse | 128 >> bp;\n                        }\n                    }\n\n                    buf[column] = reverse;\n                }\n            }\n        }\n\n        if ( TIFFWriteScanline(tif, buf ? buf : ptr, (uint32)row, 0) < 0 )\n        {\n            if (verbose)\n                wxLogError( _(\"TIFF: Error writing image.\") );\n\n            TIFFClose( tif );\n            if (buf)\n                _TIFFfree(buf);\n\n            return false;\n        }\n\n        ptr += image->GetWidth()*3;\n    }\n\n    (void) TIFFClose(tif);\n\n    if (buf)\n        _TIFFfree(buf);\n\n    return true;\n}",
    "int WriteTiff(GLubyte *image, const char *filename, const char *description, int x, int y, int width, int height, int compression, int super)\n{\n\tTIFF *file;\n\tGLubyte *p;\n\tint i;\n\n\tfile = TIFFOpen(filename, \"w\");\n\tif (file == NULL) \n\t{\n\t\treturn 1;\n\t}\n\t\t\n\tTIFFSetField(file, TIFFTAG_IMAGEWIDTH, (uint32) width);\n\tTIFFSetField(file, TIFFTAG_IMAGELENGTH, (uint32) height);\n\tTIFFSetField(file, TIFFTAG_BITSPERSAMPLE, 8);\n\tTIFFSetField(file, TIFFTAG_COMPRESSION, compression);\n\tTIFFSetField(file, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n\tTIFFSetField(file, TIFFTAG_SAMPLESPERPIXEL, 3);\n\tTIFFSetField(file, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\tTIFFSetField(file, TIFFTAG_ROWSPERSTRIP, 1);\n\tTIFFSetField(file, TIFFTAG_IMAGEDESCRIPTION, description);\n\tp = image;\n\tfor (i = height - 1; i >= 0; i--) \n\t{\n\t\tif (TIFFWriteScanline(file, p, i, 0) < 0) \n\t\t{\n\t\t\tfree(image);\n\t\t\tTIFFClose(file);\n\t\t\treturn 1;\n\t\t}\n\t\tp += width * sizeof(GLubyte) * 3;\n\t}\n\tTIFFClose(file);\n\tfree(image);\n\treturn 0;\n}",
    "void TIFFWritePimpl::write_raw_pixel_line(const bool* data)\n{\n\t//Do some type checking\n\tif(type != PNM::type_name<bool>::name())\n\t\tthrow WriteTypeMismatch(type, PNM::type_name<bool>::name());\n\t\n\t//Do some sanity checking\n\tif(row >= (unsigned long)my_size.y)\n\t\tthrow InternalLibraryError(\"CVD\", \"Write past end of image.\");\n\n\t\n\tfill(bool_rowbuf.begin(), bool_rowbuf.end(), 0);\n\n\t//Pack bools\n\tfor(int i=0; i < my_size.x  ;i++)\n\t\tbool_rowbuf[i/8] |=  (data[i] & 1) << (7-i%8);\n\n\tif(TIFFWriteScanline(tif, &bool_rowbuf[0], row) == -1)\n\t\tthrow WriteError(error_msg);\n\n\t\n\t\t\n\trow++;\n}",
    "void WriteTIFF(const char *name, float *rgba, int XRes, int YRes, bool hasAlpha) \n{\n    // Open 8-bit TIFF file for writing\n    TIFF *tiff = TIFFOpen(name, \"w\");\n    if (!tiff) {\n\tfprintf(stderr, \"Unable to open TIFF %s for writing\", name);\n\treturn;\n    }\n\n    int nChannels = hasAlpha ? 4 : 3;\n    TIFFSetField(tiff, TIFFTAG_SAMPLESPERPIXEL, nChannels);\n    if (hasAlpha) {\n\tshort int extra[] = { EXTRASAMPLE_ASSOCALPHA };\n\tTIFFSetField(tiff, TIFFTAG_EXTRASAMPLES, (short)1, extra);\n    }\n    // Write image resolution information\n    TIFFSetField(tiff, TIFFTAG_IMAGEWIDTH, XRes);\n    TIFFSetField(tiff, TIFFTAG_IMAGELENGTH, YRes);\n    TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 8);\n    TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n    // Set Generic TIFF Fields\n    TIFFSetField(tiff, TIFFTAG_ROWSPERSTRIP, 1);\n    TIFFSetField(tiff, TIFFTAG_XRESOLUTION, 1.f);\n    TIFFSetField(tiff, TIFFTAG_YRESOLUTION, 1.f);\n    TIFFSetField(tiff, TIFFTAG_RESOLUTIONUNIT, (short)1);\n    TIFFSetField(tiff, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n    TIFFSetField(tiff, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    TIFFSetField(tiff, TIFFTAG_ORIENTATION, (int)ORIENTATION_TOPLEFT);\n    // Write 8-bit scanlines\n    u_char *buf = new u_char[nChannels * XRes];\n    for (int y = 0; y < YRes; ++y) {\n\tu_char *bufp = buf;\n\tfor (int x = 0; x < XRes; ++x) {\n\t    // Pack 8-bit pixels samples into buf\n\t    for (int s = 0; s < nChannels; ++s)\n\t\t*bufp++ = (u_char)*rgba++;\n\t}\n\tTIFFWriteScanline(tiff, buf, y, 1);\n    }\n    // Close 8-bit TIFF file\n    delete[] buf;\n    TIFFClose(tiff);\n}",
    "GDALDataset *\nGTiffDataset::CreateCopy( const char * pszFilename, GDALDataset *poSrcDS, \n                          int bStrict, char ** papszOptions, \n                          GDALProgressFunc pfnProgress, void * pProgressData )\n\n{\n    TIFF\t*hTIFF;\n    int\t\tnXSize = poSrcDS->GetRasterXSize();\n    int\t\tnYSize = poSrcDS->GetRasterYSize();\n    int\t\tnBands = poSrcDS->GetRasterCount();\n    int         iBand;\n    CPLErr      eErr = CE_None;\n    uint16\tnPlanarConfig;\n    uint16\tnBitsPerSample;\n    GDALRasterBand *poPBand;\n\n    if( poSrcDS->GetRasterCount() == 0 )\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                  \"Unable to export GeoTIFF files with zero bands.\" );\n        return NULL;\n    }\n        \n    poPBand = poSrcDS->GetRasterBand(1);\n    GDALDataType eType = poPBand->GetRasterDataType();\n\n/* -------------------------------------------------------------------- */\n/*      Check, whether all bands in input dataset has the same type.    */\n/* -------------------------------------------------------------------- */\n    for ( iBand = 2; iBand <= nBands; iBand++ )\n    {\n        if ( eType != poSrcDS->GetRasterBand(iBand)->GetRasterDataType() )\n        {\n            if ( bStrict )\n            {\n                CPLError( CE_Failure, CPLE_AppDefined,\n                          \"Unable to export GeoTIFF file with different datatypes per\\n\"\n                          \"different bands. All bands should have the same types in TIFF.\" );\n                return NULL;\n            }\n            else\n            {\n                CPLError( CE_Warning, CPLE_AppDefined,\n                          \"Unable to export GeoTIFF file with different datatypes per\\n\"\n                          \"different bands. All bands should have the same types in TIFF.\" );\n            }\n        }\n    }\n\n    if( !pfnProgress( 0.0, NULL, pProgressData ) )\n        return NULL;\n\n/* -------------------------------------------------------------------- */\n/*      Capture the profile.                                            */\n/* -------------------------------------------------------------------- */\n    const char          *pszProfile;\n    int                 bGeoTIFF;\n\n    pszProfile = CSLFetchNameValue(papszOptions,\"PROFILE\");\n    if( pszProfile == NULL )\n        pszProfile = \"GDALGeoTIFF\";\n\n    if( !EQUAL(pszProfile,\"BASELINE\") \n        && !EQUAL(pszProfile,\"GeoTIFF\") \n        && !EQUAL(pszProfile,\"GDALGeoTIFF\") )\n    {\n        CPLError( CE_Failure, CPLE_AppDefined, \n                  \"PROFILE=%s not supported in GTIFF driver.\", \n                  pszProfile );\n        return NULL;\n    }\n    \n    if( EQUAL(pszProfile,\"BASELINE\") )\n        bGeoTIFF = FALSE;\n    else\n        bGeoTIFF = TRUE;\n\n/* -------------------------------------------------------------------- */\n/*      Special handling for NBITS.  Copy from band metadata if found.  */\n/* -------------------------------------------------------------------- */\n    char     **papszCreateOptions = CSLDuplicate( papszOptions );\n\n    if( poPBand->GetMetadataItem( \"NBITS\", \"IMAGE_STRUCTURE\" ) != NULL \n        && atoi(poPBand->GetMetadataItem( \"NBITS\", \"IMAGE_STRUCTURE\" )) > 0\n        && CSLFetchNameValue( papszCreateOptions, \"NBITS\") == NULL )\n    {\n        papszCreateOptions = \n            CSLSetNameValue( papszCreateOptions, \"NBITS\",\n                             poPBand->GetMetadataItem( \"NBITS\", \n                                                       \"IMAGE_STRUCTURE\" ) );\n    }\n\n    if( CSLFetchNameValue( papszOptions, \"PIXELTYPE\" ) == NULL\n        && eType == GDT_Byte\n        && poPBand->GetMetadataItem( \"PIXELTYPE\", \"IMAGE_STRUCTURE\" ) )\n    {\n        papszCreateOptions = \n            CSLSetNameValue( papszCreateOptions, \"PIXELTYPE\", \n                             poPBand->GetMetadataItem( \n                                 \"PIXELTYPE\", \"IMAGE_STRUCTURE\" ) );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Create the file.                                                */\n/* -------------------------------------------------------------------- */\n    hTIFF = CreateLL( pszFilename, nXSize, nYSize, nBands, \n                      eType, papszCreateOptions );\n\n    CSLDestroy( papszCreateOptions );\n\n    if( hTIFF == NULL )\n        return NULL;\n\n    TIFFGetField( hTIFF, TIFFTAG_PLANARCONFIG, &nPlanarConfig );\n    TIFFGetField(hTIFF, TIFFTAG_BITSPERSAMPLE, &nBitsPerSample );\n\n/* -------------------------------------------------------------------- */\n/*      Are we really producing an RGBA image?  If so, set the          */\n/*      associated alpha information.                                   */\n/* -------------------------------------------------------------------- */\n    int bForcePhotometric = \n        CSLFetchNameValue(papszOptions,\"PHOTOMETRIC\") != NULL;\n\n    if( nBands == 4 && !bForcePhotometric\n        && poSrcDS->GetRasterBand(4)->GetColorInterpretation()==GCI_AlphaBand)\n    {\n        uint16 v[1];\n\n        v[0] = EXTRASAMPLE_ASSOCALPHA;\n\tTIFFSetField(hTIFF, TIFFTAG_EXTRASAMPLES, 1, v);\n        TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If the output is jpeg compressed, and the input is RGB make     */\n/*      sure we note that.                                              */\n/* -------------------------------------------------------------------- */\n    uint16      nCompression;\n\n    if( !TIFFGetField( hTIFF, TIFFTAG_COMPRESSION, &(nCompression) ) )\n        nCompression = COMPRESSION_NONE;\n\n    if( nCompression == COMPRESSION_JPEG )\n    {\n        if( nBands >= 3 \n            && (poSrcDS->GetRasterBand(1)->GetColorInterpretation() \n                == GCI_YCbCr_YBand)\n            && (poSrcDS->GetRasterBand(2)->GetColorInterpretation() \n                == GCI_YCbCr_CbBand)\n            && (poSrcDS->GetRasterBand(3)->GetColorInterpretation() \n                == GCI_YCbCr_CrBand) )\n        {\n            /* do nothing ... */\n        }\n        else\n        {\n            /* we assume RGB if it isn't explicitly YCbCr */\n            CPLDebug( \"GTiff\", \"Setting JPEGCOLORMODE_RGB\" );\n            TIFFSetField( hTIFF, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB );\n        }\n    }\n        \n/* -------------------------------------------------------------------- */\n/*      Does the source image consist of one band, with a palette?      */\n/*      If so, copy over.                                               */\n/* -------------------------------------------------------------------- */\n    if( nBands == 1 && poSrcDS->GetRasterBand(1)->GetColorTable() != NULL \n        && eType == GDT_Byte )\n    {\n        unsigned short\tanTRed[256], anTGreen[256], anTBlue[256];\n        GDALColorTable *poCT;\n\n        poCT = poSrcDS->GetRasterBand(1)->GetColorTable();\n        \n        for( int iColor = 0; iColor < 256; iColor++ )\n        {\n            if( iColor < poCT->GetColorEntryCount() )\n            {\n                GDALColorEntry  sRGB;\n\n                poCT->GetColorEntryAsRGB( iColor, &sRGB );\n\n                anTRed[iColor] = (unsigned short) (257 * sRGB.c1);\n                anTGreen[iColor] = (unsigned short) (257 * sRGB.c2);\n                anTBlue[iColor] = (unsigned short) (257 * sRGB.c3);\n            }\n            else\n            {\n                anTRed[iColor] = anTGreen[iColor] = anTBlue[iColor] = 0;\n            }\n        }\n\n        if( !bForcePhotometric )\n            TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_PALETTE );\n        TIFFSetField( hTIFF, TIFFTAG_COLORMAP, anTRed, anTGreen, anTBlue );\n    }\n    else if( nBands == 1 \n             && poSrcDS->GetRasterBand(1)->GetColorTable() != NULL \n             && eType == GDT_UInt16 )\n    {\n        unsigned short\t*panTRed, *panTGreen, *panTBlue;\n        GDALColorTable *poCT;\n\n        panTRed   = (unsigned short *) CPLMalloc(65536*sizeof(unsigned short));\n        panTGreen = (unsigned short *) CPLMalloc(65536*sizeof(unsigned short));\n        panTBlue  = (unsigned short *) CPLMalloc(65536*sizeof(unsigned short));\n\n        poCT = poSrcDS->GetRasterBand(1)->GetColorTable();\n        \n        for( int iColor = 0; iColor < 65536; iColor++ )\n        {\n            if( iColor < poCT->GetColorEntryCount() )\n            {\n                GDALColorEntry  sRGB;\n\n                poCT->GetColorEntryAsRGB( iColor, &sRGB );\n\n                panTRed[iColor] = (unsigned short) (256 * sRGB.c1);\n                panTGreen[iColor] = (unsigned short) (256 * sRGB.c2);\n                panTBlue[iColor] = (unsigned short) (256 * sRGB.c3);\n            }\n            else\n            {\n                panTRed[iColor] = panTGreen[iColor] = panTBlue[iColor] = 0;\n            }\n        }\n\n        if( !bForcePhotometric )\n            TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_PALETTE );\n        TIFFSetField( hTIFF, TIFFTAG_COLORMAP, panTRed, panTGreen, panTBlue );\n\n        CPLFree( panTRed );\n        CPLFree( panTGreen );\n        CPLFree( panTBlue );\n    }\n    else if( poSrcDS->GetRasterBand(1)->GetColorTable() != NULL )\n        CPLError( CE_Warning, CPLE_AppDefined,\n                  \"Unable to export color table to GeoTIFF file.  Color tables\\n\"\n                  \"can only be written to 1 band Byte or UInt16 GeoTIFF files.\" );\n\n/* -------------------------------------------------------------------- */\n/*      Transfer some TIFF specific metadata, if available.             */\n/*      The return value will tell us if we need to try again later with*/\n/*      PAM because the profile doesn't allow to write some metadata    */\n/*      as TIFF tag                                                     */\n/* -------------------------------------------------------------------- */\n    int bHasWrittenMDInGeotiffTAG =\n            GTiffDataset::WriteMetadata( poSrcDS, hTIFF, FALSE, pszProfile,\n                                 pszFilename, papszOptions );\n\n/* -------------------------------------------------------------------- */\n/* \tWrite NoData value, if exist.                                   */\n/* -------------------------------------------------------------------- */\n    if( EQUAL(pszProfile,\"GDALGeoTIFF\") )\n    {\n        int\t\tbSuccess;\n        double\tdfNoData;\n    \n        dfNoData = poSrcDS->GetRasterBand(1)->GetNoDataValue( &bSuccess );\n        if ( bSuccess )\n            GTiffDataset::WriteNoDataValue( hTIFF, dfNoData );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Write affine transform if it is meaningful.                     */\n/* -------------------------------------------------------------------- */\n    const char *pszProjection = NULL;\n    double      adfGeoTransform[6];\n    \n    if( poSrcDS->GetGeoTransform( adfGeoTransform ) == CE_None\n        && (adfGeoTransform[0] != 0.0 || adfGeoTransform[1] != 1.0\n            || adfGeoTransform[2] != 0.0 || adfGeoTransform[3] != 0.0\n            || adfGeoTransform[4] != 0.0 || ABS(adfGeoTransform[5]) != 1.0 ))\n    {\n        if( bGeoTIFF )\n        {\n            if( adfGeoTransform[2] == 0.0 && adfGeoTransform[4] == 0.0 \n                && adfGeoTransform[5] < 0.0 )\n            {\n\n                double\tadfPixelScale[3], adfTiePoints[6];\n\n                adfPixelScale[0] = adfGeoTransform[1];\n                adfPixelScale[1] = fabs(adfGeoTransform[5]);\n                adfPixelScale[2] = 0.0;\n\n                TIFFSetField( hTIFF, TIFFTAG_GEOPIXELSCALE, 3, adfPixelScale );\n            \n                adfTiePoints[0] = 0.0;\n                adfTiePoints[1] = 0.0;\n                adfTiePoints[2] = 0.0;\n                adfTiePoints[3] = adfGeoTransform[0];\n                adfTiePoints[4] = adfGeoTransform[3];\n                adfTiePoints[5] = 0.0;\n        \n                TIFFSetField( hTIFF, TIFFTAG_GEOTIEPOINTS, 6, adfTiePoints );\n            }\n            else\n            {\n                double\tadfMatrix[16];\n\n                memset(adfMatrix,0,sizeof(double) * 16);\n\n                adfMatrix[0] = adfGeoTransform[1];\n                adfMatrix[1] = adfGeoTransform[2];\n                adfMatrix[3] = adfGeoTransform[0];\n                adfMatrix[4] = adfGeoTransform[4];\n                adfMatrix[5] = adfGeoTransform[5];\n                adfMatrix[7] = adfGeoTransform[3];\n                adfMatrix[15] = 1.0;\n\n                TIFFSetField( hTIFF, TIFFTAG_GEOTRANSMATRIX, 16, adfMatrix );\n            }\n            \n            pszProjection = poSrcDS->GetProjectionRef();\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Do we need a TFW file?                                          */\n/* -------------------------------------------------------------------- */\n        if( CSLFetchBoolean( papszOptions, \"TFW\", FALSE ) )\n            GDALWriteWorldFile( pszFilename, \"tfw\", adfGeoTransform );\n        else if( CSLFetchBoolean( papszOptions, \"WORLDFILE\", FALSE ) )\n            GDALWriteWorldFile( pszFilename, \"wld\", adfGeoTransform );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Otherwise write tiepoints if they are available.                */\n/* -------------------------------------------------------------------- */\n    else if( poSrcDS->GetGCPCount() > 0 && bGeoTIFF )\n    {\n        const GDAL_GCP *pasGCPs = poSrcDS->GetGCPs();\n        double\t*padfTiePoints;\n\n        padfTiePoints = (double *) \n            CPLMalloc(6*sizeof(double)*poSrcDS->GetGCPCount());\n\n        for( int iGCP = 0; iGCP < poSrcDS->GetGCPCount(); iGCP++ )\n        {\n\n            padfTiePoints[iGCP*6+0] = pasGCPs[iGCP].dfGCPPixel;\n            padfTiePoints[iGCP*6+1] = pasGCPs[iGCP].dfGCPLine;\n            padfTiePoints[iGCP*6+2] = 0;\n            padfTiePoints[iGCP*6+3] = pasGCPs[iGCP].dfGCPX;\n            padfTiePoints[iGCP*6+4] = pasGCPs[iGCP].dfGCPY;\n            padfTiePoints[iGCP*6+5] = pasGCPs[iGCP].dfGCPZ;\n        }\n\n        TIFFSetField( hTIFF, TIFFTAG_GEOTIEPOINTS, \n                      6*poSrcDS->GetGCPCount(), padfTiePoints );\n        CPLFree( padfTiePoints );\n        \n        pszProjection = poSrcDS->GetGCPProjection();\n        \n        if( CSLFetchBoolean( papszOptions, \"TFW\", FALSE ) \n            || CSLFetchBoolean( papszOptions, \"WORLDFILE\", FALSE ) )\n        {\n            CPLError(CE_Warning, CPLE_AppDefined,\n                     \"TFW=ON or WORLDFILE=ON creation options are ignored when GCPs are available\");\n        }\n    }\n\n    else\n        pszProjection = poSrcDS->GetProjectionRef();\n\n/* -------------------------------------------------------------------- */\n/*      Write the projection information, if possible.                  */\n/* -------------------------------------------------------------------- */\n    if( pszProjection != NULL && strlen(pszProjection) > 0 && bGeoTIFF )\n    {\n        GTIF\t*psGTIF;\n\n        psGTIF = GTIFNew( hTIFF );\n        GTIFSetFromOGISDefn( psGTIF, pszProjection );\n\n        if( poSrcDS->GetMetadataItem( GDALMD_AREA_OR_POINT ) \n            && EQUAL(poSrcDS->GetMetadataItem(GDALMD_AREA_OR_POINT),\n                     GDALMD_AOP_POINT) )\n        {\n            GTIFKeySet(psGTIF, GTRasterTypeGeoKey, TYPE_SHORT, 1,\n                       RasterPixelIsPoint);\n        }\n\n        GTIFWriteKeys( psGTIF );\n        GTIFFree( psGTIF );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Cleanup                                                         */\n/* -------------------------------------------------------------------- */\n    \n    TIFFWriteCheck( hTIFF, TIFFIsTiled(hTIFF), \"GTiffCreateCopy()\");\n    TIFFWriteDirectory( hTIFF );\n    TIFFFlush( hTIFF );\n    XTIFFClose( hTIFF );\n    hTIFF = NULL;\n\n    if( eErr != CE_None )\n    {\n        VSIUnlink( pszFilename );\n        return NULL;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Re-open as a dataset and copy over missing metadata using       */\n/*      PAM facilities.                                                 */\n/* -------------------------------------------------------------------- */\n    GTiffDataset *poDS;\n    CPLString osFileName(\"GTIFF_RAW:\");\n\n    osFileName += pszFilename;\n\n    poDS = (GTiffDataset *) GDALOpen( osFileName, GA_Update );\n    if( poDS == NULL )\n        poDS = (GTiffDataset *) GDALOpen( osFileName, GA_ReadOnly );\n\n    if ( poDS == NULL )\n    {\n        VSIUnlink( pszFilename );\n        return NULL;\n    }\n\n    poDS->osProfile = pszProfile;\n    poDS->CloneInfo( poSrcDS, GCIF_PAM_DEFAULT );\n    poDS->papszCreationOptions = CSLDuplicate( papszOptions );\n\n/* -------------------------------------------------------------------- */\n/*      CloneInfo() doesn't merge metadata, it just replaces it totally */\n/*      So we have to merge it                                          */\n/* -------------------------------------------------------------------- */\n\n    char **papszSRC_MD = poSrcDS->GetMetadata();\n    char **papszDST_MD = CSLDuplicate(poDS->GetMetadata());\n\n    papszDST_MD = CSLMerge( papszDST_MD, papszSRC_MD );\n\n    poDS->SetMetadata( papszDST_MD );\n    CSLDestroy( papszDST_MD );\n\n    /* Depending on the PHOTOMETRIC tag, the TIFF file may not have */\n    /* the same band count as the source. Will fail later in GDALDatasetCopyWholeRaster anyway... */\n    for( int nBand = 1;\n         nBand <= MIN(poDS->GetRasterCount(), poSrcDS->GetRasterCount()) ;\n         nBand++ )\n    {\n        char **papszSRC_MD = poSrcDS->GetRasterBand(nBand)->GetMetadata();\n        char **papszDST_MD = CSLDuplicate(poDS->GetRasterBand(nBand)->GetMetadata());\n\n        papszDST_MD = CSLMerge( papszDST_MD, papszSRC_MD );\n\n        poDS->GetRasterBand(nBand)->SetMetadata( papszDST_MD );\n        CSLDestroy( papszDST_MD );\n    }\n\n    hTIFF = (TIFF*) poDS->GetInternalHandle(NULL);\n\n/* -------------------------------------------------------------------- */\n/*      Second chance : now that we have a PAM dataset, it is possible  */\n/*      to write metadata that we couldn't be writen as TIFF tag        */\n/* -------------------------------------------------------------------- */\n    if (!bHasWrittenMDInGeotiffTAG)\n        GTiffDataset::WriteMetadata( poDS, hTIFF, TRUE, pszProfile,\n                                     pszFilename, papszOptions, TRUE /* don't write RPC and IMG file again */);\n\n    /* To avoid unnecessary directory rewriting */\n    poDS->bMetadataChanged = FALSE;\n    poDS->bGeoTIFFInfoChanged = FALSE;\n\n    /* We must re-set the compression level at this point, since it has */\n    /* been lost a few lines above when closing the newly create TIFF file */\n    /* The TIFFTAG_ZIPQUALITY & TIFFTAG_JPEGQUALITY are not store in the TIFF file. */\n    /* They are just TIFF session parameters */\n    if (nCompression == COMPRESSION_ADOBE_DEFLATE)\n    {\n        int nZLevel = GTiffGetZLevel(papszOptions);\n        if (nZLevel != -1)\n        {\n            TIFFSetField( hTIFF, TIFFTAG_ZIPQUALITY, nZLevel );\n        }\n    }\n    else if( nCompression == COMPRESSION_JPEG)\n    {\n        int nJpegQuality = GTiffGetJpegQuality(papszOptions);\n        if (nJpegQuality != -1)\n        {\n            TIFFSetField( hTIFF, TIFFTAG_JPEGQUALITY, nJpegQuality );\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Copy actual imagery.                                            */\n/* -------------------------------------------------------------------- */\n\n    if (poDS->bTreatAsSplit || poDS->bTreatAsSplitBitmap)\n    {\n        /* For split bands, we use TIFFWriteScanline() interface */\n        CPLAssert(poDS->nBitsPerSample == 8 || poDS->nBitsPerSample == 1);\n        \n        if (poDS->nPlanarConfig == PLANARCONFIG_CONTIG && poDS->nBands > 1)\n        {\n            int j;\n            GByte* pabyScanline = (GByte *) CPLMalloc(TIFFScanlineSize(hTIFF));\n            eErr = CE_None;\n            for(j=0;j<nYSize && eErr == CE_None;j++)\n            {\n                eErr = poSrcDS->RasterIO(GF_Read, 0, j, nXSize, 1,\n                                         pabyScanline, nXSize, 1,\n                                         GDT_Byte, nBands, NULL, poDS->nBands, 0, 1);\n                if (eErr == CE_None &&\n                    TIFFWriteScanline( hTIFF, pabyScanline, j, 0) == -1)\n                {\n                    CPLError( CE_Failure, CPLE_AppDefined,\n                              \"TIFFWriteScanline() failed.\" );\n                    eErr = CE_Failure;\n                }\n                if( !pfnProgress( (j+1) * 1.0 / nYSize, NULL, pProgressData ) )\n                    eErr = CE_Failure;\n            }\n            CPLFree(pabyScanline);\n        }\n        else\n        {\n            int iBand, j;\n            GByte* pabyScanline = (GByte *) CPLMalloc(TIFFScanlineSize(hTIFF));\n            eErr = CE_None;\n            for(iBand=1;iBand<=nBands && eErr == CE_None;iBand++)\n            {\n                for(j=0;j<nYSize && eErr == CE_None;j++)\n                {\n                    eErr = poSrcDS->GetRasterBand(iBand)->RasterIO(\n                                                    GF_Read, 0, j, nXSize, 1,\n                                                    pabyScanline, nXSize, 1,\n                                                    GDT_Byte, 0, 0);\n                    if (poDS->bTreatAsSplitBitmap)\n                    {\n                        for(int i=0;i<nXSize;i++)\n                        {\n                            GByte byVal = pabyScanline[i];\n                            if ((i & 0x7) == 0)\n                                pabyScanline[i >> 3] = 0;\n                            if (byVal)\n                                pabyScanline[i >> 3] |= (0x80 >> (i & 0x7));\n                        }\n                    }\n                    if (eErr == CE_None &&\n                        TIFFWriteScanline( hTIFF, pabyScanline, j, iBand - 1) == -1)\n                    {\n                        CPLError( CE_Failure, CPLE_AppDefined,\n                                  \"TIFFWriteScanline() failed.\" );\n                        eErr = CE_Failure;\n                    }\n                    if( !pfnProgress( (j+1 + (iBand - 1) * nYSize) * 1.0 /\n                                      (nBands * nYSize), NULL, pProgressData ) )\n                        eErr = CE_Failure;\n                }\n            }\n            CPLFree(pabyScanline);\n        }\n        \n        /* Necessary to be able to read the file without re-opening */\n        TIFFFlush( hTIFF );\n    }\n    else\n    {\n        char* papszCopyWholeRasterOptions[2] = { NULL, NULL };\n        if (nCompression != COMPRESSION_NONE)\n            papszCopyWholeRasterOptions[0] = (char*) \"COMPRESSED=YES\";\n        eErr = GDALDatasetCopyWholeRaster( (GDALDatasetH) poSrcDS, \n                                            (GDALDatasetH) poDS,\n                                            papszCopyWholeRasterOptions,\n                                            pfnProgress, pProgressData );\n    }\n\n    if( eErr == CE_Failure )\n    {\n        delete poDS;\n        poDS = NULL;\n\n        VSIUnlink( pszFilename ); // should really delete more carefully.\n    }\n\n    return poDS;\n}",
    "bool CImageTIF::SaveRAW(const QString& fileName, const void* pData, int width, int height, int bytesPerChannel, int numChannels, bool bFloat, const char* preset)\n{\n    if (bFloat && (bytesPerChannel != 2 && bytesPerChannel != 4))\n    {\n        bFloat = false;\n    }\n\n    bool bRet = false;\n\n    CFileUtil::OverwriteFile(fileName);\n    TIFF* tif = TIFFOpen(fileName.toUtf8().data(), \"wb\");\n    if (tif)\n    {\n        TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, width);\n        TIFFSetField(tif, TIFFTAG_IMAGELENGTH, height);\n        TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, numChannels);\n        TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, bytesPerChannel * 8);\n        TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n        TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, 1);\n        TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n        TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, (numChannels == 1) ? PHOTOMETRIC_MINISBLACK : PHOTOMETRIC_RGB);\n        TIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n        if (bFloat)\n        {\n            TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);\n        }\n\n        if (preset && preset[0])\n        {\n            AZStd::string tiffphotoshopdata, valueheader;\n            AZStd::string presetkeyvalue = AZStd::string(\"/preset=\") + AZStd::string(preset);\n\n            valueheader.push_back('\\x1C');\n            valueheader.push_back('\\x02');\n            valueheader.push_back('\\x28');\n            valueheader.push_back((presetkeyvalue.size() >> 8) & 0xFF);\n            valueheader.push_back((presetkeyvalue.size()) & 0xFF);\n            valueheader.append(presetkeyvalue);\n\n            tiffphotoshopdata.push_back('8');\n            tiffphotoshopdata.push_back('B');\n            tiffphotoshopdata.push_back('I');\n            tiffphotoshopdata.push_back('M');\n            tiffphotoshopdata.push_back('\\x04');\n            tiffphotoshopdata.push_back('\\x04');\n            tiffphotoshopdata.push_back('\\x00');\n            tiffphotoshopdata.push_back('\\x00');\n\n            tiffphotoshopdata.push_back((valueheader.size() >> 24) & 0xFF);\n            tiffphotoshopdata.push_back((valueheader.size() >> 16) & 0xFF);\n            tiffphotoshopdata.push_back((valueheader.size() >> 8) & 0xFF);\n            tiffphotoshopdata.push_back((valueheader.size()) & 0xFF);\n            tiffphotoshopdata.append(valueheader);\n\n            TIFFSetField(tif, TIFFTAG_PHOTOSHOP, tiffphotoshopdata.size(), tiffphotoshopdata.c_str());\n        }\n\n        size_t pitch = width * bytesPerChannel * numChannels;\n        char* raster = (char*) _TIFFmalloc((tsize_t)(pitch * height));\n        memcpy(raster, pData, pitch * height);\n\n        bRet = true;\n        for (int h = 0; h < height; ++h)\n        {\n            size_t offset = h * pitch;\n            int err = TIFFWriteScanline(tif, raster + offset, h, 0);\n            if (err < 0)\n            {\n                bRet = false;\n                break;\n            }\n        }\n        _TIFFfree(raster);\n        TIFFClose(tif);\n    }\n    return bRet;\n}",
    "bool\nTiffWriter::writeRGB32Image(\n    TiffHandle const& tif, QImage const& image)\n{\n    assert(image.format() == QImage::Format_RGB32);\n\n    TIFFSetField(tif.handle(), TIFFTAG_SAMPLESPERPIXEL, uint16_t(3));\n    TIFFSetField(tif.handle(), TIFFTAG_COMPRESSION, COMPRESSION_LZW);\n    TIFFSetField(tif.handle(), TIFFTAG_BITSPERSAMPLE, uint16_t(8));\n    TIFFSetField(tif.handle(), TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n\n    int const width = image.width();\n    int const height = image.height();\n\n    std::vector<uint8_t> tmp_line(width * 3);\n\n    // Libtiff expects \"RR GG BB\" sequences regardless of CPU byte order.\n\n    for (int y = 0; y < height; ++y)\n    {\n        uint32_t const* p_src = (uint32_t const*)image.scanLine(y);\n        uint8_t* p_dst = &tmp_line[0];\n        for (int x = 0; x < width; ++x)\n        {\n            uint32_t const ARGB = *p_src;\n            p_dst[0] = static_cast<uint8_t>(ARGB >> 16);\n            p_dst[1] = static_cast<uint8_t>(ARGB >> 8);\n            p_dst[2] = static_cast<uint8_t>(ARGB);\n            ++p_src;\n            p_dst += 3;\n        }\n        if (TIFFWriteScanline(tif.handle(), &tmp_line[0], y) == -1)\n        {\n            return false;\n        }\n    }\n\n    return true;\n}",
    "bool\nTiffWriter::writeARGB32Image(\n    TiffHandle const& tif, QImage const& image)\n{\n    assert(image.format() == QImage::Format_ARGB32);\n\n    TIFFSetField(tif.handle(), TIFFTAG_SAMPLESPERPIXEL, uint16_t(4));\n    TIFFSetField(tif.handle(), TIFFTAG_COMPRESSION, COMPRESSION_LZW);\n    TIFFSetField(tif.handle(), TIFFTAG_BITSPERSAMPLE, uint16_t(8));\n    TIFFSetField(tif.handle(), TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n\n    int const width = image.width();\n    int const height = image.height();\n\n    std::vector<uint8_t> tmp_line(width * 4);\n\n    // Libtiff expects \"RR GG BB AA\" sequences regardless of CPU byte order.\n\n    for (int y = 0; y < height; ++y)\n    {\n        uint32_t const* p_src = (uint32_t const*)image.scanLine(y);\n        uint8_t* p_dst = &tmp_line[0];\n        for (int x = 0; x < width; ++x)\n        {\n            uint32_t const ARGB = *p_src;\n            p_dst[0] = static_cast<uint8_t>(ARGB >> 16);\n            p_dst[1] = static_cast<uint8_t>(ARGB >> 8);\n            p_dst[2] = static_cast<uint8_t>(ARGB);\n            p_dst[3] = static_cast<uint8_t>(ARGB >> 24);\n            ++p_src;\n            p_dst += 4;\n        }\n        if (TIFFWriteScanline(tif.handle(), &tmp_line[0], y) == -1)\n        {\n            return false;\n        }\n    }\n\n    return true;\n}",
    "static int write_rgb_image(IMAGE *image, TIFF *tfp) {\n  int scanlinesize;\n  UCHAR *outbuf, *buf;\n  int row, lx, ly, x, wrapx, x0, y0;\n  LPIXEL *gl_buf, *tmp;\n\n  lx    = image->pixmap.xSBsize;\n  ly    = image->pixmap.ySBsize;\n  x0    = image->pixmap.xD;\n  y0    = image->pixmap.yD;\n  wrapx = image->pixmap.xsize;\n\n  tmp          = (LPIXEL *)image->pixmap.buffer + y0 * wrapx + x0;\n  scanlinesize = TIFFScanlineSize(tfp);\n  outbuf       = new UCHAR[scanlinesize];\n\n  if (!outbuf) return FALSE;\n\n  for (row = 0; row < ly; row++) {\n    buf    = outbuf;\n    gl_buf = tmp;\n    for (x = 0; x < lx; x++) {\n      *buf++ = gl_buf->r;\n      *buf++ = gl_buf->g;\n      *buf++ = gl_buf->b;\n      *buf++ = gl_buf->m;\n      gl_buf++;\n    }\n    if (TIFFWriteScanline(tfp, outbuf, row, 0) < 0) goto bad;\n    tmp += wrapx;\n  }\n\n  delete[] outbuf;\n\n  if (image->pixmap.extra_mask) write_extra(image, tfp);\n\n  return TRUE;\n\nbad:\n  // tmsg_error(\"write_scan_line failed at row %d\", row);\n  delete[] outbuf;\n  return FALSE;\n}",
    "static int write_cmapped_image(IMAGE *image, TIFF *tfp) {\n  int scanline, lx, ly, x0, y0, wrapx;\n  int row;\n  UCHAR *outbuf;\n  USHORT *tmp;\n  int tmp_icon;\n  struct s_pixmap ori_icon;\n  UINT tif_compression;\n\n  tif_compression = get_output_compression();\n\n  tmp_icon = FALSE;\n\n  lx    = image->pixmap.xSBsize;\n  ly    = image->pixmap.ySBsize;\n  x0    = image->pixmap.xD;\n  y0    = image->pixmap.yD;\n  wrapx = image->pixmap.xsize;\n\n  tmp    = image->pixmap.buffer + y0 * wrapx + x0;\n  outbuf = 0;\n  for (row = 0; row < ly; row++) {\n    outbuf = (UCHAR *)tmp;\n    if (TIFFWriteScanline(tfp, outbuf, row, 0) < 0) goto bad;\n    tmp += wrapx;\n  }\n  if (image->pixmap.extra_mask && !image->icon.buffer) {\n    ori_icon = image->icon;\n    // make_icon (image, ICON_WIDTH, ICON_HEIGHT);\n    tmp_icon = TRUE;\n  }\n  if (image->icon.buffer) {\n    if (!TIFFFlush(tfp)) {\n      // tmsg_error(\"Unable to flush data to .tz(up) file\");\n      goto bad;\n    }\n    lx = image->icon.xsize;\n    ly = image->icon.ysize;\n\n    TIFFSetField(tfp, TIFFTAG_SUBFILETYPE, 1);\n    TIFFSetField(tfp, TIFFTAG_BITSPERSAMPLE, 16);\n    TIFFSetField(tfp, TIFFTAG_SAMPLESPERPIXEL, 1);\n    TIFFSetField(tfp, TIFFTAG_IMAGEWIDTH, lx);\n    TIFFSetField(tfp, TIFFTAG_IMAGELENGTH, ly);\n    TIFFSetField(tfp, TIFFTAG_ORIENTATION, ORIENTATION_BOTLEFT);\n    TIFFSetField(tfp, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    TIFFSetField(tfp, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_PALETTE);\n    TIFFSetField(tfp, TIFFTAG_COMPRESSION, tif_compression);\n\n    scanline = TIFFScanlineSize(tfp);\n    outbuf   = (UCHAR *)image->icon.buffer;\n    for (row = 0; row < ly; row++) {\n      if (TIFFWriteScanline(tfp, outbuf, row, 0) < 0) {\n        // tmsg_error(\"error writing icon to .tz(up) file\");\n        goto bad;\n      }\n      outbuf += scanline;\n    }\n  }\n  if (image->pixmap.extra_mask) write_extra(image, tfp);\n\n  if (tmp_icon && image->icon.buffer) {\n    TFREE(image->icon.buffer)\n    image->icon = ori_icon;\n  }\n  return TRUE;\n\nbad:\n  if (tmp_icon && image->icon.buffer) {\n    TFREE(image->icon.buffer)\n    image->icon = ori_icon;\n  }\n  return FALSE;\n}",
    "static int write_cmapped24_image(IMAGE *image, TIFF *tfp) {\n  int scanline, lx, ly, x0, y0, wrapx;\n  int row;\n  UCHAR *outbuf;\n  ULONG *tmp;\n  UINT tif_compression;\n\n  tif_compression = get_output_compression();\n\n  lx    = image->pixmap.xSBsize;\n  ly    = image->pixmap.ySBsize;\n  x0    = image->pixmap.xD;\n  y0    = image->pixmap.yD;\n  wrapx = image->pixmap.xsize;\n\n  tmp    = (ULONG *)image->pixmap.buffer + y0 * wrapx + x0;\n  outbuf = 0;\n  for (row = 0; row < ly; row++) {\n    outbuf = (UCHAR *)tmp;\n    if (TIFFWriteScanline(tfp, outbuf, row, 0) < 0) goto bad;\n    tmp += wrapx;\n  }\n\n  if (image->icon.buffer) {\n    if (!TIFFFlush(tfp)) {\n      // tmsg_error(\"Unable to flush data to .tz(up) file\");\n      goto bad;\n    }\n    lx = image->icon.xsize;\n    ly = image->icon.ysize;\n\n    TIFFSetField(tfp, TIFFTAG_SUBFILETYPE, 1);\n    TIFFSetField(tfp, TIFFTAG_BITSPERSAMPLE, 32);\n    TIFFSetField(tfp, TIFFTAG_SAMPLESPERPIXEL, 1);\n    TIFFSetField(tfp, TIFFTAG_IMAGEWIDTH, lx);\n    TIFFSetField(tfp, TIFFTAG_IMAGELENGTH, ly);\n    TIFFSetField(tfp, TIFFTAG_ORIENTATION, ORIENTATION_BOTLEFT);\n    TIFFSetField(tfp, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    TIFFSetField(tfp, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_PALETTE);\n    TIFFSetField(tfp, TIFFTAG_COMPRESSION, tif_compression);\n\n    scanline = TIFFScanlineSize(tfp);\n    outbuf   = (UCHAR *)image->icon.buffer;\n    for (row = 0; row < ly; row++) {\n      if (TIFFWriteScanline(tfp, outbuf, row, 0) < 0) {\n        // tmsg_error(\"error writing icon to .tz(up) file\");\n        goto bad;\n      }\n      outbuf += scanline;\n    }\n  }\n  return TRUE;\n\nbad:\n  return FALSE;\n}",
    "static int write_extra(IMAGE *image, TIFF *tfp) {\n  int lx, ly, x0, y0, wrapx, row;\n  UCHAR *extra;\n  UINT tif_compression;\n  int rowsperstrip;\n\n  if (!image->pixmap.extra_mask) return TRUE;\n\n  tif_compression = get_output_compression();\n\n  if (!TIFFFlush(tfp)) {\n    // tmsg_error(\"Unable to flush data to .tz(up) file\");\n    goto bad;\n  }\n  lx    = image->pixmap.xSBsize;\n  ly    = image->pixmap.ySBsize;\n  x0    = image->pixmap.xD;\n  y0    = image->pixmap.yD;\n  wrapx = image->pixmap.xsize;\n\n  TIFFSetField(tfp, TIFFTAG_SUBFILETYPE, 1);\n  TIFFSetField(tfp, TIFFTAG_BITSPERSAMPLE, 8);\n  TIFFSetField(tfp, TIFFTAG_SAMPLESPERPIXEL, 1);\n  TIFFSetField(tfp, TIFFTAG_IMAGEWIDTH, lx);\n  TIFFSetField(tfp, TIFFTAG_IMAGELENGTH, ly);\n  TIFFSetField(tfp, TIFFTAG_ORIENTATION, ORIENTATION_BOTLEFT);\n  TIFFSetField(tfp, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n  TIFFSetField(tfp, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n  TIFFSetField(tfp, TIFFTAG_COMPRESSION, tif_compression);\n\n  rowsperstrip = (8 * 1024) / lx; /* contig, 1 byte per pixel */\n  NOT_LESS_THAN(1, rowsperstrip)\n  TIFFSetField(tfp, TIFFTAG_ROWSPERSTRIP, rowsperstrip);\n\n  extra = image->pixmap.extra + y0 * wrapx + x0;\n  for (row = 0; row < ly; row++) {\n    if (TIFFWriteScanline(tfp, extra, row, 0) < 0) goto bad;\n    extra += wrapx;\n  }\n  return TRUE;\n\nbad:\n  // tmsg_error (\"error writing extra information to .tz(up) file\");\n  return FALSE;\n}",
    "Expected<void> writeRawTiff( const uint8_t* bytes, const std::filesystem::path& path, const BaseTiffParameters& params )\n{\n    TIFF* tif = TIFFOpen( MR::utf8string( path ).c_str(), \"w\" );\n    if ( !tif )\n        return unexpected(\"Cannot write file: \"+ utf8string( path ) );\n\n    TIFFSetField( tif, TIFFTAG_IMAGEWIDTH, params.imageSize.x );\n    TIFFSetField( tif, TIFFTAG_IMAGELENGTH, params.imageSize.y );\n    TIFFSetField( tif, TIFFTAG_BITSPERSAMPLE, params.bytesPerSample * 8 );\n    int numSamples = 1;\n    switch ( params.valueType )\n    {\n    case BaseTiffParameters::ValueType::Scalar:\n        numSamples = 1;\n        break;\n    case BaseTiffParameters::ValueType::RGB:\n        numSamples = 3;\n        break;\n    case BaseTiffParameters::ValueType::RGBA:\n        numSamples = 4;\n        break;\n    default:\n        break;\n    }\n    TIFFSetField( tif, TIFFTAG_SAMPLESPERPIXEL, numSamples );\n\n    int sampleType = 0;\n    switch ( params.sampleType )\n    {\n    case BaseTiffParameters::SampleType::Float:\n        sampleType = SAMPLEFORMAT_IEEEFP;\n        break;\n    case BaseTiffParameters::SampleType::Uint:\n        sampleType = SAMPLEFORMAT_UINT;\n        break;\n    case BaseTiffParameters::SampleType::Int:\n        sampleType = SAMPLEFORMAT_INT;\n        break;\n    default:\n        return unexpected( \"Unknown sample format\" );\n        break;\n    }\n\n    TIFFSetField( tif, TIFFTAG_SAMPLEFORMAT, sampleType );\n\n    TIFFSetField( tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG );\n    TIFFSetField( tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISWHITE );\n\n    for ( int row = 0; row < params.imageSize.y; row++ )\n        TIFFWriteScanline( tif, ( void* )( bytes + row * params.imageSize.x * numSamples * params.bytesPerSample ), row );\n\n    TIFFClose( tif );\n    return {};\n}",
    "void IOtiff::writeImage(const FrameBuffer& img, const std::string& filename,\n                            const WriteRequest& request) const\n    {\n#ifdef _MSC_VER\n        TIFF* tif = TIFFOpenW(UNICODE_C_STR(filename.c_str()), \"w\");\n#else\n        TIFF* tif = TIFFOpen(filename.c_str(), \"w\");\n#endif\n        const FrameBuffer* outfb = &img;\n        bool yryby = img.isYRYBY() || img.isYRYBYPlanar();\n\n        if (!tif)\n        {\n            TWK_THROW_STREAM(IOException, \"TIFF: cannot open \"\n                                              << filename << \" for writing\");\n        }\n\n        switch (outfb->dataType())\n        {\n        case FrameBuffer::HALF:\n            outfb = copyConvert(outfb, FrameBuffer::FLOAT);\n            // fall through\n        case FrameBuffer::FLOAT:\n            TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);\n            break;\n        case FrameBuffer::USHORT:\n        case FrameBuffer::UCHAR:\n            TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT);\n            break;\n        case FrameBuffer::PACKED_R10_G10_B10_X2:\n        case FrameBuffer::PACKED_X2_B10_G10_R10:\n        case FrameBuffer::PACKED_Y8_Cb8_Y8_Cr8:\n        case FrameBuffer::PACKED_Cb8_Y8_Cr8_Y8:\n        {\n            const FrameBuffer* nfb = outfb;\n            outfb = convertToLinearRGB709(outfb);\n            delete nfb;\n            TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT);\n            break;\n        }\n        default:\n            TWK_THROW_STREAM(Exception, \"TIFF: Unsupported data format: \"\n                                            << outfb->dataType());\n        }\n\n        //\n        //  If its planar and the request is to convert to packed or for\n        //  the \"common\" format, then make the image packed RGB.\n        //\n\n        if (img.isPlanar()\n            && (!request.keepPlanar || request.preferCommonFormat || yryby))\n        {\n            const FrameBuffer* fb = outfb;\n            outfb = mergePlanes(outfb);\n            if (fb != &img)\n                delete fb;\n        }\n\n        //\n        //  Convert YUV, YRYBY, or non-RGB 709 images to RGB 709 In the\n        //  case of YRYBY, TIFF can't really store it so we need to\n        //  convert no matter what.\n        //\n\n        if ((request.preferCommonFormat\n             && (outfb->hasPrimaries() || outfb->isYUV()))\n            || yryby)\n        {\n            const FrameBuffer* fb = outfb;\n            outfb = convertToLinearRGB709(outfb);\n            if (fb != &img)\n                delete fb;\n        }\n\n        assert(!outfb->isPlanar()); // can't write the planar images yet\n\n        unsigned short tifforientation;\n\n        //\n        //  Don't ask\n        //\n\n        switch (outfb->orientation())\n        {\n        case FrameBuffer::NATURAL:\n            tifforientation = ORIENTATION_TOPLEFT;\n            break;\n        case FrameBuffer::TOPLEFT:\n            tifforientation = ORIENTATION_BOTLEFT;\n            break;\n        case FrameBuffer::TOPRIGHT:\n            tifforientation = ORIENTATION_BOTRIGHT;\n            break;\n        case FrameBuffer::BOTTOMRIGHT:\n            tifforientation = ORIENTATION_TOPRIGHT;\n            break;\n        default:\n            break;\n        };\n\n        TIFFSetField(tif, TIFFTAG_ORIENTATION, tifforientation);\n\n        //\n        //  Basic geometry\n        //\n\n        TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, outfb->width());\n        TIFFSetField(tif, TIFFTAG_IMAGELENGTH, outfb->height());\n        TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, outfb->numChannels());\n        TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8 * outfb->bytesPerChannel());\n        TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n        TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, outfb->height());\n\n        //\n        //  Compression\n        //\n\n        unsigned int compression = COMPRESSION_DEFLATE; // default zip compress\n\n        if (unsigned int ctag =\n                nameToTag(request.compression.c_str(), compTags))\n        {\n            compression = ctag;\n        }\n        else if (request.compression != \"\")\n        {\n            cerr << \"WARNING: IOtiff: unknown compression type \"\n                 << request.compression << \", using DEFLATE instead\" << endl;\n\n            compression = COMPRESSION_DEFLATE;\n        }\n\n        TIFFSetField(tif, TIFFTAG_COMPRESSION, compression);\n\n        //\n        //  Photometric interpretation\n        //\n\n        if (outfb->isYUV())\n        {\n            TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);\n        }\n        else\n        {\n            TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n        }\n\n        if (outfb->hasChannel(\"A\") && outfb->numChannels() > 1)\n        {\n            uint16 extrasamples = 1;\n            uint16 sampleinfo[1] = {EXTRASAMPLE_ASSOCALPHA};\n            TIFFSetField(tif, TIFFTAG_EXTRASAMPLES, extrasamples, sampleinfo);\n        }\n\n        for (int y = 0; y < outfb->height(); ++y)\n        {\n            int flipY = outfb->height() - y - 1;\n\n            if (TIFFWriteScanline(\n                    tif, (void*)outfb->scanline<unsigned char>(flipY), y, 0)\n                == -1)\n            {\n                TWK_THROW_STREAM(IOException,\n                                 \"TIFF: Error write scanline \" << filename);\n            }\n        }\n\n        TIFFClose(tif);\n        if (outfb != &img)\n            delete outfb;\n    }",
    "void save_tiff(cv::Mat data,std::string file,bool bgr2rgb)\n    {\n        if(bgr2rgb) {\n            cv::Mat tmp;\n            if(data.channels() == 3) {\n                cv::cvtColor(data,tmp,cv::COLOR_BGR2RGB);\n                data = tmp;\n            }\n            else if(data.channels() == 4) {\n                cv::cvtColor(data,tmp,cv::COLOR_BGRA2RGBA);\n                data = tmp;\n            }\n        }\n            \n        TIFF *out= TIFFOpen(file.c_str(), \"w\");\n        if(!out)\n            throw std::runtime_error(\"Failed to open file to write \"+ file);\n        try {\n            TIFFSetField(out,TIFFTAG_IMAGEWIDTH,data.cols);\n            TIFFSetField(out,TIFFTAG_IMAGELENGTH,data.rows);\n            TIFFSetField(out,TIFFTAG_SAMPLESPERPIXEL,data.channels());\n            TIFFSetField(out,TIFFTAG_BITSPERSAMPLE,data.elemSize1()*8);\n            TIFFSetField(out,TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n            TIFFSetField(out,TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG);\n            TIFFSetField(out,TIFFTAG_PHOTOMETRIC, data.channels()== 3 ? PHOTOMETRIC_RGB : PHOTOMETRIC_MINISBLACK);\n            switch(data.type() & CV_MAT_DEPTH_MASK) {\n            case CV_8U:\n            case CV_16U:\n                TIFFSetField(out,TIFFTAG_SAMPLEFORMAT,SAMPLEFORMAT_UINT);\n                break;\n            case CV_8S:\n            case CV_16S:\n            case CV_32S:\n                TIFFSetField(out,TIFFTAG_SAMPLEFORMAT,SAMPLEFORMAT_INT);\n                break;\n            case CV_32F:\n            case CV_64F:\n                TIFFSetField(out,TIFFTAG_SAMPLEFORMAT,SAMPLEFORMAT_IEEEFP);\n                break;\n            default:\n                throw std::runtime_error(\"Unsupported matrix format\");\n            }\n            size_t n = TIFFScanlineSize(out);\n            if(n != data.cols * data.channels() * data.elemSize1())\n                throw std::runtime_error(\"Internal error scanline size is inconsistent\");\n            for(int i=0;i<data.rows;i++) { \n                if(TIFFWriteScanline(out,(char*)(data.data) + data.step[0]*i,i,0) < 0)\n                    throw std::runtime_error(\"Failed to write tiff image\");\n            }\n        }\n        catch(...) {\n            TIFFClose(out);\n            throw;\n        }\n        TIFFClose(out);\n    }",
    "void tiff_write(const char *name, float scale,\n                const ctl::dpx::fb<float> &pixels,\n                format_t *format) {\n\tTIFF *t;\n\tuint16_t bits_per_sample;\n\ttdata_t scanline_buffer;\n\tuint32_t y;\n\tuint8_t channel;\n\tconst float *row;\n\n\tchannel = 0;\n\n\tTIFFSetErrorHandler(ErrorHandler);\n\tTIFFSetWarningHandler(WarningHandler);\n\n\tbits_per_sample=format->bps;\n\tif(format->bps<=8) {\n\t\tbits_per_sample=8;\n\t} else if(format->bps<=16) {\n\t\tbits_per_sample=16;\n\t} else if(format->bps!=32) {\n\t\tTHROW(Iex::ArgExc, \"TIFF files can only support files with <=16 bps \"\n\t\t      \"(integer) or 32 bps (float).\");\n\t}\n\n\tt=TIFFOpen(name, \"w\");\n\tif(t==NULL) {\n\t\t// What went wrong\n\t\t//fprintf(stderr, \"WARNING on line %d of file %s in function %s(): tiff_write() cannot open output file %s\\n\", __LINE__, __FILE__, __FUNCTION__, name);\n\t\tTHROW(Iex::ArgExc, \"tiff_write() cannot open output file \" << std::string(name) );\n\t\treturn;\n\t}\n\n\tTIFFSetField(t, TIFFTAG_SAMPLESPERPIXEL, pixels.depth());\n\tTIFFSetField(t, TIFFTAG_BITSPERSAMPLE, bits_per_sample);\n\tTIFFSetField(t, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\tTIFFSetField(t, TIFFTAG_IMAGEWIDTH, pixels.width());\n\tTIFFSetField(t, TIFFTAG_IMAGELENGTH, pixels.height());\n\tTIFFSetField(t, TIFFTAG_ROWSPERSTRIP, 1);\n\tTIFFSetField(t, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n\t// Worst case...\n\tscanline_buffer=alloca(sizeof(float)*pixels.depth()*pixels.width());\n\n\tif(bits_per_sample==8) {\n\t\tTIFFSetField(t, TIFFTAG_SAMPLEFORMAT, 1);\n\t\tfor(y=0; y<pixels.height(); y++) {\n\t\t\trow=pixels.ptr()+y*pixels.width()*pixels.depth();\n\t\t\ttiff_convert_uint8((uint8_t *)scanline_buffer, row,\n\t\t\t                   scale, pixels.depth()*pixels.width());\n\t\t\tTIFFWriteScanline(t, scanline_buffer, y, 0);\n\t\t}\n\t} else if(bits_per_sample==16) {\n\t\tTIFFSetField(t, TIFFTAG_SAMPLEFORMAT, 1);\n\t\tfor(y=0; y<pixels.height(); y++) {\n\t\t\trow=pixels.ptr()+y*pixels.width()*pixels.depth();\n\t\t\ttiff_convert_uint16((uint16_t *)scanline_buffer, row,\n\t\t\t                    scale, pixels.depth()*pixels.width());\n\t\t\tTIFFWriteScanline(t, scanline_buffer, y, channel);\n\t\t}\n\t} else if(bits_per_sample==32) {\n\t\tTIFFSetField(t, TIFFTAG_SAMPLEFORMAT, 3);\n\t\tfor(y=0; y<pixels.height(); y++) {\n\t\t\trow=pixels.ptr()+y*pixels.width()*pixels.depth();\n\t\t\ttiff_convert_float((float *)scanline_buffer, row,\n\t\t\t                   scale, pixels.depth()*pixels.width());\n\t\t\tTIFFWriteScanline(t, scanline_buffer, y, channel);\n\t\t}\n\t}\n\n\tTIFFClose(t);\n}",
    "Expected<void> toTiff( const Image& image, const std::filesystem::path& path )\n{\n    auto tiff = TIFFOpen( utf8string( path ).c_str(), \"w\" );\n    if ( !tiff )\n        return unexpected( \"Cannot write file: \" + utf8string( path ) );\n    MR_FINALLY {\n        TIFFClose( tiff );\n    };\n\n    TIFFSetField( tiff, TIFFTAG_IMAGEWIDTH, image.resolution.x );\n    TIFFSetField( tiff, TIFFTAG_IMAGELENGTH, image.resolution.y );\n\n    // 32-bit RGBA\n    TIFFSetField( tiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB );\n    TIFFSetField( tiff, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT );\n    TIFFSetField( tiff, TIFFTAG_BITSPERSAMPLE, 8 );\n    TIFFSetField( tiff, TIFFTAG_SAMPLESPERPIXEL, 4 );\n\n    // FIXME: orientation is ignored\n    TIFFSetField( tiff, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT );\n    TIFFSetField( tiff, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG );\n\n    for ( auto row = 0; row < image.resolution.y; ++row )\n    {\n        // FIXME: orientation is ignored\n        const auto* data = image.pixels.data() + (size_t)( image.resolution.y - 1 - row ) * image.resolution.x;\n        TIFFWriteScanline( tiff, (void*)data, row );\n    }\n    TIFFFlush( tiff );\n\n    return {};\n}",
    "MemoryBuffer tiffEncode(const ImageImpl *impl)\n\t{\n\t\tTIFF *t = nullptr;\n\t\ttry\n\t\t{\n\t\t\tMemoryBuffer res;\n\t\t\tres.resize(impl->width * impl->height * impl->channels * formatBytes(impl->format) + 100); // preallocate and fill, instead of reserve\n\t\t\tdetail::memset(res.data(), 0, res.size()); // avoid storing uninitialized memory from the tiff library\n\t\t\tres.resize(0);\n\t\t\tBufferOStream stream(res);\n\t\t\tt = TIFFStreamOpen(\"MemTIFF\", &stream);\n\t\t\tif (!t)\n\t\t\t\tCAGE_THROW_ERROR(Exception, \"failed to initialize tiff encoding\");\n\t\t\tTIFFSetField(t, TIFFTAG_IMAGEWIDTH, impl->width);\n\t\t\tTIFFSetField(t, TIFFTAG_IMAGELENGTH, impl->height);\n\t\t\tTIFFSetField(t, TIFFTAG_SAMPLESPERPIXEL, impl->channels);\n\t\t\tswitch (impl->format)\n\t\t\t{\n\t\t\t\tcase ImageFormatEnum::U8:\n\t\t\t\t\tTIFFSetField(t, TIFFTAG_BITSPERSAMPLE, 8);\n\t\t\t\t\tTIFFSetField(t, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ImageFormatEnum::U16:\n\t\t\t\t\tTIFFSetField(t, TIFFTAG_BITSPERSAMPLE, 16);\n\t\t\t\t\tTIFFSetField(t, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ImageFormatEnum::Float:\n\t\t\t\t\tTIFFSetField(t, TIFFTAG_BITSPERSAMPLE, 32);\n\t\t\t\t\tTIFFSetField(t, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tCAGE_THROW_ERROR(Exception, \"unsupported format in tiff encoding\");\n\t\t\t}\n\t\t\tTIFFSetField(t, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\t\t\tTIFFSetField(t, TIFFTAG_COMPRESSION, COMPRESSION_ADOBE_DEFLATE);\n\t\t\tsetExtraSamples(t, impl);\n\t\t\tTIFFSetField(t, TIFFTAG_SOFTWARE, \"CageEngine\");\n\t\t\tconst uint32 stride = numeric_cast<uint32>(TIFFScanlineSize(t));\n\t\t\tCAGE_ASSERT(stride == impl->width * impl->channels * formatBytes(impl->format));\n\t\t\tfor (uint32 row = 0; row < impl->height; row++)\n\t\t\t{\n\t\t\t\tconst char *src = impl->mem.data() + row * stride;\n\t\t\t\tif (TIFFWriteScanline(t, (void *)src, row) < 0)\n\t\t\t\t\tCAGE_THROW_ERROR(Exception, \"failed scanline writing in tiff encoding\");\n\t\t\t}\n\t\t\tTIFFClose(t);\n\t\t\treturn res;\n\t\t}\n\t\tcatch (...)\n\t\t{\n\t\t\tif (t)\n\t\t\t\tTIFFClose(t);\n\t\t\tthrow;\n\t\t}\n\t}",
    "bool\nTIFFOutput::write_scanline(int y, int z, TypeDesc format, const void* data,\n                           stride_t xstride)\n{\n    m_spec.auto_stride(xstride, format, spec().nchannels);\n    data = to_native_scanline(format, data, xstride, m_scratch, m_dither, y, z);\n\n    // Handle weird photometric/color spaces\n    std::vector<unsigned char> cmyk;\n    if (m_photometric == PHOTOMETRIC_SEPARATED && m_convert_rgb_to_cmyk)\n        data = convert_to_cmyk(spec().width, data, cmyk);\n    size_t scanline_vals = size_t(spec().width) * m_outputchans;\n\n    // Handle weird bit depths\n    if (spec().format.size() * 8 != m_bitspersample) {\n        data = move_to_scratch(data, scanline_vals * spec().format.size());\n        fix_bitdepth(m_scratch.data(), scanline_vals);\n    }\n\n    y -= m_spec.y;\n    if (m_planarconfig == PLANARCONFIG_SEPARATE && m_spec.nchannels > 1) {\n        // Convert from contiguous (RGBRGBRGB) to separate (RRRGGGBBB)\n        int plane_bytes = m_spec.width * m_spec.format.size();\n\n        char* separate;\n        OIIO_ALLOCATE_STACK_OR_HEAP(separate, char, plane_bytes* m_outputchans);\n\n        contig_to_separate(m_spec.width, m_outputchans, (const char*)data,\n                           separate);\n        for (int c = 0; c < m_outputchans; ++c) {\n            if (TIFFWriteScanline(m_tif, (tdata_t)&separate[plane_bytes * c], y,\n                                  c)\n                < 0) {\n                std::string err = oiio_tiff_last_error();\n                errorfmt(\"TIFFWriteScanline failed writing line y={},z={} ({})\",\n                         y, z, err.size() ? err.c_str() : \"unknown error\");\n                return false;\n            }\n        }\n    } else {\n        // No contig->separate is necessary.  But we still use scratch\n        // space since TIFFWriteScanline is destructive when\n        // TIFFTAG_PREDICTOR is used.\n        data = move_to_scratch(data, scanline_vals * m_spec.format.size());\n        if (TIFFWriteScanline(m_tif, (tdata_t)data, y) < 0) {\n            std::string err = oiio_tiff_last_error();\n            errorfmt(\"TIFFWriteScanline failed writing line y={},z={} ({})\", y,\n                     z, err.size() ? err.c_str() : \"unknown error\");\n            return false;\n        }\n    }\n\n    // Should we checkpoint? Only if we have enough scanlines and enough\n    // time has passed (or if using JPEG compression, for which it seems\n    // necessary).\n    ++m_checkpointItems;\n    if ((m_checkpointTimer() > DEFAULT_CHECKPOINT_INTERVAL_SECONDS\n         || m_compression == COMPRESSION_JPEG)\n        && m_checkpointItems >= MIN_SCANLINES_OR_TILES_PER_CHECKPOINT) {\n        TIFFCheckpointDirectory(m_tif);\n        m_checkpointTimer.lap();\n        m_checkpointItems = 0;\n    }\n\n    return true;\n}",
    "void tiffWriteToVector(std::vector<std::byte>& out, std::vector<T>& in, uint32_t width,\n    uint32_t height, uint32_t samples, uint32_t bits) {\n\n  std::ostringstream oStream;\n  TIFF*              tiff = TIFFStreamOpen(\"MemTIFF\", &oStream);\n\n  TIFFSetField(tiff, TIFFTAG_IMAGEWIDTH, width);\n  TIFFSetField(tiff, TIFFTAG_IMAGELENGTH, height);\n  TIFFSetField(tiff, TIFFTAG_SAMPLESPERPIXEL, samples);\n  TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, bits);\n  TIFFSetField(tiff, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n  TIFFSetField(tiff, TIFFTAG_ROWSPERSTRIP, 16);\n  TIFFSetField(tiff, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n  TIFFSetField(tiff, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n  TIFFSetField(tiff, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);\n\n  if (samples == 3) {\n    TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n  } else {\n    TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n  }\n\n  for (uint32_t i(0); i < height; ++i) {\n    TIFFWriteScanline(tiff, &in.at((height - i - 1) * width * samples), i);\n  }\n\n  TIFFClose(tiff);\n\n  // Convert the stringstream to a std::vector<std::byte>.\n  std::string s = oStream.str();\n  out.reserve(s.size());\n\n  std::transform(s.begin(), s.end(), std::back_inserter(out),\n      [](char& c) { return static_cast<std::byte>(c); });\n}",
    "void writetiff(char *filename, char *description,\n               int x, int y, int width, int height, int compression)\n{\n    TIFF *file;\n    GLubyte *image = NULL, *p;\n    int i;\n\n    file = TIFFOpen(filename, \"w\");\n    if (file == NULL)\n    {\n        exit(ANIM_ERROR);\n    }\n    /*pe image = (GLubyte *) malloc(width * height * sizeof(GLubyte) * 3); */\n    OWN_CALLOC(image, GLubyte, width * height * 3);\n\n    /* OpenGL's default 4 byte pack alignment would leave extra bytes at the\n     end of each image row so that each full row contained a number of bytes\n     divisible by 4.  Ie, an RGB row with 3 pixels and 8-bit componets would\n     be laid out like \"RGBRGBRGBxxx\" where the last three \"xxx\" bytes exist\n     just to pad the row out to 12 bytes (12 is divisible by 4). To make sure\n     the rows are packed as tight as possible (no row padding), set the pack\n     alignment to 1. */\n    glPixelStorei(GL_PACK_ALIGNMENT, 1);\n\n    glReadPixels(x, y, width, height, GL_RGB, GL_UNSIGNED_BYTE, image);\n    TIFFSetField(file, TIFFTAG_IMAGEWIDTH, (uint32)width);\n    TIFFSetField(file, TIFFTAG_IMAGELENGTH, (uint32)height);\n    TIFFSetField(file, TIFFTAG_BITSPERSAMPLE, 8);\n    TIFFSetField(file, TIFFTAG_COMPRESSION, compression);\n    TIFFSetField(file, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n    TIFFSetField(file, TIFFTAG_SAMPLESPERPIXEL, 3);\n    TIFFSetField(file, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    TIFFSetField(file, TIFFTAG_ROWSPERSTRIP, 1);\n    TIFFSetField(file, TIFFTAG_IMAGEDESCRIPTION, description);\n    p = image;\n    for (i = height - 1; i >= 0; i--)\n    {\n        if (TIFFWriteScanline(file, p, i, 0) < 0)\n        {\n            OWN_FREE(image);\n            TIFFClose(file);\n            exit(ANIM_ERROR);\n        }\n        p += width * sizeof(GLubyte) * 3;\n    }\n    TIFFClose(file);\n    OWN_FREE(image);\n}",
    "bool wxTIFFHandler::SaveFile( wxImage *image, wxOutputStream& stream, bool verbose )\n{\n    TIFF *tif = TIFFwxOpen( stream, \"image\", \"w\" );\n\n    if (!tif)\n    {\n        if (verbose)\n        {\n            wxLogError( _(\"TIFF: Error saving image.\") );\n        }\n\n        return false;\n    }\n\n    const int imageWidth = image->GetWidth();\n    TIFFSetField(tif, TIFFTAG_IMAGEWIDTH,  (wxUint32) imageWidth);\n    TIFFSetField(tif, TIFFTAG_IMAGELENGTH, (wxUint32)image->GetHeight());\n    TIFFSetField(tif, TIFFTAG_ORIENTATION, (wxUint16)ORIENTATION_TOPLEFT);\n    TIFFSetField(tif, TIFFTAG_PLANARCONFIG, (wxUint16)PLANARCONFIG_CONTIG);\n\n    // save the image resolution if we have it\n    int xres, yres;\n    const wxImageResolution res = GetResolutionFromOptions(*image, &xres, &yres);\n    wxUint16 tiffRes;\n    switch ( res )\n    {\n        default:\n            wxFAIL_MSG( wxT(\"unknown image resolution units\") );\n            wxFALLTHROUGH;\n\n        case wxIMAGE_RESOLUTION_NONE:\n            tiffRes = RESUNIT_NONE;\n            break;\n\n        case wxIMAGE_RESOLUTION_INCHES:\n            tiffRes = RESUNIT_INCH;\n            break;\n\n        case wxIMAGE_RESOLUTION_CM:\n            tiffRes = RESUNIT_CENTIMETER;\n            break;\n    }\n\n    if ( tiffRes != RESUNIT_NONE )\n    {\n        TIFFSetField(tif, TIFFTAG_RESOLUTIONUNIT, tiffRes);\n        TIFFSetField(tif, TIFFTAG_XRESOLUTION, static_cast<double>(xres));\n        TIFFSetField(tif, TIFFTAG_YRESOLUTION, static_cast<double>(yres));\n    }\n\n\n    int spp = image->GetOptionInt(wxIMAGE_OPTION_TIFF_SAMPLESPERPIXEL);\n    if ( !spp )\n        spp = 3;\n\n    int bps = image->GetOptionInt(wxIMAGE_OPTION_TIFF_BITSPERSAMPLE);\n    if ( !bps )\n    {\n        bps = 8;\n    }\n    else if (bps == 1)\n    {\n        // One bit per sample combined with 3 samples per pixel is\n        // not allowed and crashes libtiff.\n        spp = 1;\n    }\n\n    int photometric = PHOTOMETRIC_RGB;\n\n    if ( image->HasOption(wxIMAGE_OPTION_TIFF_PHOTOMETRIC) )\n    {\n        photometric = image->GetOptionInt(wxIMAGE_OPTION_TIFF_PHOTOMETRIC);\n        if (photometric == PHOTOMETRIC_MINISWHITE\n            || photometric == PHOTOMETRIC_MINISBLACK)\n        {\n            // either b/w or greyscale\n            spp = 1;\n        }\n    }\n    else if (spp <= 2)\n    {\n        photometric = PHOTOMETRIC_MINISWHITE;\n    }\n\n    const bool hasAlpha = image->HasAlpha();\n\n    int compression = image->GetOptionInt(wxIMAGE_OPTION_TIFF_COMPRESSION);\n    if ( !compression || (compression == COMPRESSION_JPEG && hasAlpha) )\n    {\n        // We can't use COMPRESSION_LZW because current version of libtiff\n        // doesn't implement it (\"no longer implemented due to Unisys patent\n        // enforcement\") and other compression methods are lossy so we\n        // shouldn't use them by default -- and the only remaining one is none.\n        // Also JPEG compression for alpha images is not a good idea (viewers\n        // not opening the image properly).\n        compression = COMPRESSION_NONE;\n    }\n\n    if\n    (\n        (photometric == PHOTOMETRIC_RGB && spp == 4)\n        || (photometric <= PHOTOMETRIC_MINISBLACK && spp == 2)\n    )\n    {\n        // Compensate for user passing a SamplesPerPixel that includes\n        // the alpha channel.\n        spp--;\n    }\n\n\n    int extraSamples = hasAlpha ? 1 : 0;\n\n    TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, (wxUint16)(spp + extraSamples));\n    TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, (wxUint16)bps);\n    TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, (wxUint16)photometric);\n    TIFFSetField(tif, TIFFTAG_COMPRESSION, (wxUint16)compression);\n\n    if (extraSamples)\n    {\n        wxUint16 extra[] = { EXTRASAMPLE_UNSPECIFIED };\n        TIFFSetField(tif, TIFFTAG_EXTRASAMPLES, (wxUint16) 1, &extra);\n    }\n\n    // scanlinesize is determined by spp+extraSamples and bps\n    const tsize_t linebytes =\n        (tsize_t)((imageWidth * (spp + extraSamples) * bps + 7) / 8);\n\n    unsigned char* buf = nullptr;\n\n    // Ensure that everything is cleaned up on scope exit.\n    class CleanUp\n    {\n    public:\n        CleanUp(TIFF* tif, unsigned char* buf)\n            : m_tif(tif), m_buf(buf)\n        {\n        }\n\n        ~CleanUp()\n        {\n            TIFFClose(m_tif);\n\n            if (m_buf)\n                _TIFFfree(m_buf);\n        }\n\n        CleanUp(const CleanUp&) = delete;\n        CleanUp& operator=(const CleanUp&) = delete;\n\n    private:\n        TIFF* const m_tif;\n        unsigned char* const m_buf;\n    } cleanUp(tif, buf);\n\n    const bool isColouredImage = (spp > 1)\n        && (photometric != PHOTOMETRIC_MINISWHITE)\n        && (photometric != PHOTOMETRIC_MINISBLACK);\n\n\n    if (TIFFScanlineSize(tif) > linebytes || !isColouredImage || hasAlpha)\n    {\n        buf = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(tif));\n        if (!buf)\n        {\n            if (verbose)\n            {\n                wxLogError( _(\"TIFF: Couldn't allocate memory.\") );\n            }\n\n            return false;\n        }\n    }\n\n    TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP,TIFFDefaultStripSize(tif, (wxUint32) -1));\n\n    const int bitsPerPixel = (spp + extraSamples) * bps;\n    const int bytesPerPixel = (bitsPerPixel + 7) / 8;\n    const int pixelsPerByte = 8 / bitsPerPixel;\n    int remainingPixelCount = 0;\n\n    if (pixelsPerByte)\n    {\n        // How many pixels to write in the last byte column?\n        remainingPixelCount = imageWidth % pixelsPerByte;\n        if (!remainingPixelCount) remainingPixelCount = pixelsPerByte;\n    }\n\n    const bool minIsWhite = (photometric == PHOTOMETRIC_MINISWHITE);\n    unsigned char *ptr = image->GetData();\n    for ( int row = 0; row < image->GetHeight(); row++ )\n    {\n        if ( buf )\n        {\n            if (isColouredImage)\n            {\n                // colour image\n                if (hasAlpha)\n                {\n                    for ( int column = 0; column < imageWidth; column++ )\n                    {\n                        buf[column*4    ] = ptr[column*3    ];\n                        buf[column*4 + 1] = ptr[column*3 + 1];\n                        buf[column*4 + 2] = ptr[column*3 + 2];\n                        buf[column*4 + 3] = image->GetAlpha(column, row);\n                    }\n                }\n                else\n                {\n                    memcpy(buf, ptr, imageWidth * 3);\n                }\n            }\n            else if (spp * bps == 8) // greyscale image\n            {\n                for ( int column = 0; column < imageWidth; column++ )\n                {\n                    wxUint8 value = ptr[column*3 + 1];\n                    if (minIsWhite)\n                    {\n                        value = 255 - value;\n                    }\n\n                    buf[column * bytesPerPixel] = value;\n\n                    if (hasAlpha)\n                    {\n                        value = image->GetAlpha(column, row);\n                        buf[column*bytesPerPixel+1] = minIsWhite ? 255 - value\n                                                                 : value;\n                    }\n                }\n            }\n            else // black and white image\n            {\n                for ( int column = 0; column < linebytes; column++ )\n                {\n                    wxUint8 reverse = 0;\n                    int pixelsPerByteCount = (column + 1 != linebytes)\n                        ? pixelsPerByte\n                        : remainingPixelCount;\n                    for ( int bp = 0; bp < pixelsPerByteCount; bp++ )\n                    {\n                        if ( (ptr[column * 3 * pixelsPerByte + bp*3 + 1] <=127)\n                            == minIsWhite )\n                        {\n                            // check only green as this is sufficient\n                            reverse |= (wxUint8) (128 >> (bp * bitsPerPixel));\n                        }\n\n                        if (hasAlpha\n                            && (image->GetAlpha(column * pixelsPerByte + bp,\n                                    row) <= 127) == minIsWhite)\n                        {\n                            reverse |= (wxUint8) (64 >> (bp * bitsPerPixel));\n                        }\n                    }\n\n                    buf[column] = reverse;\n                }\n            }\n        }\n\n        if ( TIFFWriteScanline(tif, buf ? buf : ptr, (wxUint32)row, 0) < 0 )\n        {\n            if (verbose)\n            {\n                wxLogError( _(\"TIFF: Error writing image.\") );\n            }\n\n            return false;\n        }\n\n        ptr += imageWidth * 3;\n    }\n\n    if (!TIFFFlush(tif))\n    {\n        if (verbose)\n        {\n            wxLogError( _(\"TIFF: Error flushing data.\") );\n        }\n\n        return false;\n    }\n\n    return true;\n}",
    "int WriteTIFF(unsigned short * buffer, int cols, int rows, char * filename)\n{\n\tTIFF *image;\n\tunsigned char *out;\n\tout = new unsigned char[cols*rows];\n\n\tAdjustImage(buffer, cols, rows, out);\n\n\t// Open the TIFF file\n\tif((image = TIFFOpen(filename, \"w\")) == NULL)\n\t{\n\t\tprintf(\"Could not open output.tif for writing\\n\");\n\t\texit(42);\n\t}\n\t\n\t// We need to set some values for basic tags before we can add any data\n\tTIFFSetField(image, TIFFTAG_IMAGEWIDTH, cols);\n\tTIFFSetField(image, TIFFTAG_IMAGELENGTH, rows);\n\tTIFFSetField(image, TIFFTAG_BITSPERSAMPLE, 8);\n\tTIFFSetField(image, TIFFTAG_SAMPLESPERPIXEL, 1);\n\tTIFFSetField(image, TIFFTAG_ROWSPERSTRIP, 1);\n\t\n\tTIFFSetField(image, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n\tTIFFSetField(image, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n\tTIFFSetField(image, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);\n\tTIFFSetField(image, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\t\n\tTIFFSetField(image, TIFFTAG_XRESOLUTION, 150.0);\n\tTIFFSetField(image, TIFFTAG_YRESOLUTION, 150.0);\n\tTIFFSetField(image, TIFFTAG_RESOLUTIONUNIT, RESUNIT_INCH);\n\t\n\t// Write the information to the file\n\tfor (int y = 0; y < rows; y++)\n\t{\n\t\tTIFFWriteScanline(image, &out[cols*y], y);\n\t}\n\t\n\t// Close the file\n\tTIFFClose(image);\n\tdelete[] (out);\n\treturn 0;\n}",
    "void image_info::writetif(const char *filename) const {\n#ifdef USE_LIBTIFF\n#ifdef _USE_DL_\n  if(!have_tiff){\n    if(init_tiff(LIBTIFF_SOLIBRARY)){ \n      have_tiff = 1;\n    }\n  }\n  if(!have_tiff){\n    printf(\"tiff library not found\\n\");\n    printf(\"Please try reading from a supported format\\n\");\n    return;\n  }\n#endif  \n  image_info tmp = *this;\n  tmp.convert_rgba();\n  TIFF* tif = TIFFOpen(filename, \"w\");\n  TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, tmp.width);\n  TIFFSetField(tif, TIFFTAG_IMAGELENGTH, tmp.height);\n  TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n  TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE,8);\n  TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL,4);\n  TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n  TIFFSetField(tif, TIFFTAG_COMPRESSION,COMPRESSION_NONE);\n  uint32 *raster = (uint32*) _TIFFmalloc(tmp.width*tmp.height*sizeof(uint32));\n\n  int ii=0;\n  for(int i=0;i<tmp.height;i++){\n    for(int j=0;j<tmp.width;j++){\n       unsigned char r,g, b,a;\n       r = tmp.pixels[ii++];\n       g = tmp.pixels[ii++];\n       b = tmp.pixels[ii++];\n       a = tmp.pixels[ii++];\n       uint32 pix = 0;\n       pix |= r;\n       pix |= (g<<8);\n       pix |= (b<<16);\n       pix |= (a<<24);\n       raster[i*tmp.width+j] = pix;\n    }\n  }\n  for (int row = 0; row < tmp.height; row++)\n    TIFFWriteScanline(tif, raster+row*tmp.width, row, 0);\n  _TIFFfree(raster);\n  TIFFClose(tif);\n#else\n    printf(\"No tiff support compiled into this program\\n\");\n    printf(\"Please install libtiff (if not already done) and\\n\");\n    printf(\"rebuild adding -DUSE_LIBTIFF to C_DEFINES\\n\");\n    printf(\"and CXX_DEFINES. Or try writing to a\\n\");\n    printf(\"supported format.\\n\");\n#endif  \n}",
    "void TIFEncoder::Data::WriteLineRaw(const byte *s)\r\n{\r\n\tmemcpy(rowbuf.Begin(), s, linebytes);\r\n\tTIFFWriteScanline(tiff, rowbuf.Begin(), line, 0);\r\n\tif(++line >= size.cy) {\r\n\t\tTIFFClose(tiff);\r\n\t\ttiff = NULL;\r\n\t}\r\n}",
    "int WriteTIFF(unsigned short * buffer, int cols, int rows, char * filename)\n{\n#ifdef HAVE_TIFFIO_H\n\tTIFF *image;\n\tunsigned char out[cols*rows];\n\n\tAdjustImage(buffer, cols, rows, out);\n\n\t// Open the TIFF file\n\tif((image = TIFFOpen(filename, \"w\")) == NULL)\n\t{\n\t\tprintf(\"Could not open %s for writing\\n\", filename);\n\t\texit(1);\n\t}\n\t\n\t// We need to set some values for basic tags before we can add any data\n\tTIFFSetField(image, TIFFTAG_IMAGEWIDTH, cols);\n\tTIFFSetField(image, TIFFTAG_IMAGELENGTH, rows);\n\tTIFFSetField(image, TIFFTAG_BITSPERSAMPLE, 8);\n\tTIFFSetField(image, TIFFTAG_SAMPLESPERPIXEL, 1);\n\tTIFFSetField(image, TIFFTAG_ROWSPERSTRIP, 1);\n\t\n\tTIFFSetField(image, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n\tTIFFSetField(image, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n\tTIFFSetField(image, TIFFTAG_FILLORDER, FILLORDER_LSB2MSB);\n\tTIFFSetField(image, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\t\n\tTIFFSetField(image, TIFFTAG_XRESOLUTION, 150.0);\n\tTIFFSetField(image, TIFFTAG_YRESOLUTION, 150.0);\n\tTIFFSetField(image, TIFFTAG_RESOLUTIONUNIT, RESUNIT_INCH);\n\t\n\t// Write the information to the file\n\tfor (int y = 0; y < rows; y++)\n\t{\n\t\tTIFFWriteScanline(image, &out[cols*y], y);\n\t}\n\t\n\t// Close the file\n\tTIFFClose(image);\n#else /* HAVE_TIFFIO_H */\n\tstd::cerr << \"TIFF not supported\" << std::endl;\n\treturn -1;\n#endif /* HAVE_TIFFIO_H */\n}",
    "bool SlaOutputDev::radialShadedFill(GfxState *state, GfxRadialShading *shading, double sMin, double sMax)\r\n{\r\n//\tqDebug() << \"SlaOutputDev::radialShadedFill\";\r\n\tdouble GrStartX;\r\n\tdouble GrStartY;\r\n\tdouble GrEndX;\r\n\tdouble GrEndY;\r\n\tint shade = 100;\r\n\tconst Function *func = shading->getFunc(0);\r\n\tVGradient fillGradient(VGradient::linear);\r\n\tfillGradient.clearStops();\r\n\tGfxColorSpace *color_space = shading->getColorSpace();\r\n#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(24, 3, 0)\r\n\tif (func->getType() == Function::Type::Stitching)\r\n#else\r\n\tif (func->getType() == 3)\r\n#endif\r\n\t{\r\n\t\tconst auto *stitchingFunc = (const StitchingFunction*) func;\r\n\t\tconst double *bounds = stitchingFunc->getBounds();\r\n\t\tint num_funcs = stitchingFunc->getNumFuncs();\r\n\t\tdouble domain_min = stitchingFunc->getDomainMin(0);\r\n\t\tdouble domain_max = stitchingFunc->getDomainMax(0);\r\n\t\tif (fabs(domain_max - domain_min) < 1e-6)\r\n\t\t{\r\n\t\t\tdomain_min = 0.0;\r\n\t\t\tdomain_max = 1.0;\r\n\t\t}\r\n\t\t// Add stops from all the stitched functions\r\n\t\tfor (int i = 0 ; i <= num_funcs ; i++)\r\n\t\t{\r\n\t\t\tGfxColor temp;\r\n\t\t\tshading->getColor(bounds[i], &temp);\r\n\t\t\tQString stopColor = getColor(color_space, &temp, &shade);\r\n\t\t\tdouble stopPoint = (bounds[i] - domain_min) / (domain_max - domain_min);\r\n\t\t\tfillGradient.addStop( ScColorEngine::getShadeColor(m_doc->PageColors[stopColor], m_doc, shade), stopPoint, 0.5, 1.0, stopColor, shade );\r\n\t\t}\r\n\t}\r\n#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(24, 3, 0)\r\n\telse if ((func->getType() == Function::Type::Exponential) || (func->getType() == Function::Type::Sampled))\r\n#else\r\n\telse if ((func->getType() == 2) || (func->getType() == 0))\r\n#endif\r\n\t{\r\n\t\tGfxColor stop1;\r\n\t\tshading->getColor(0.0, &stop1);\r\n\t\tQString stopColor1 = getColor(color_space, &stop1, &shade);\r\n\t\tfillGradient.addStop( ScColorEngine::getShadeColor(m_doc->PageColors[stopColor1], m_doc, shade), 0.0, 0.5, 1.0, stopColor1, shade );\r\n\t\tGfxColor stop2;\r\n\t\tshading->getColor(1.0, &stop2);\r\n\t\tQString stopColor2 = getColor(color_space, &stop2, &shade);\r\n\t\tfillGradient.addStop( ScColorEngine::getShadeColor(m_doc->PageColors[stopColor2], m_doc, shade), 1.0, 0.5, 1.0, stopColor2, shade );\r\n\t}\r\n\r\n\tdouble r0, x1, y1, r1;\r\n\tshading->getCoords(&GrStartX, &GrStartY, &r0, &x1, &y1, &r1);\r\n\tdouble xmin, ymin, xmax, ymax;\r\n\t// get the clip region bbox\r\n\tstate->getClipBBox(&xmin, &ymin, &xmax, &ymax);\r\n\tQRectF crect(QPointF(xmin, ymin), QPointF(xmax, ymax));\r\n\tcrect = crect.normalized();\r\n\tdouble GrFocalX = x1;\r\n\tdouble GrFocalY = y1;\r\n\tGrEndX = GrFocalX + r1;\r\n\tGrEndY = GrFocalY;\r\n\tconst double *ctm = state->getCTM();\r\n\tm_ctm = QTransform(ctm[0], ctm[1], ctm[2], ctm[3], ctm[4], ctm[5]);\r\n\tFPointArray gr;\r\n\tgr.addPoint(GrStartX, GrStartY);\r\n\tgr.addPoint(GrEndX, GrEndY);\r\n\tgr.addPoint(GrFocalX, GrFocalY);\r\n\tgr.map(m_ctm);\r\n\tGrStartX = gr.point(0).x() - crect.x();\r\n\tGrStartY = gr.point(0).y() - crect.y();\r\n\tGrEndX = gr.point(1).x() - crect.x();\r\n\tGrEndY = gr.point(1).y() - crect.y();\r\n\tGrFocalX = gr.point(2).x() - crect.x();\r\n\tGrFocalY = gr.point(2).y() - crect.y();\r\n\tdouble xCoor = m_doc->currentPage()->xOffset();\r\n\tdouble yCoor = m_doc->currentPage()->yOffset();\r\n\tQString output = QString(\"M %1 %2\").arg(0.0).arg(0.0);\r\n\toutput += QString(\"L %1 %2\").arg(crect.width()).arg(0.0);\r\n\toutput += QString(\"L %1 %2\").arg(crect.width()).arg(crect.height());\r\n\toutput += QString(\"L %1 %2\").arg(0.0).arg(crect.height());\r\n\toutput += QString(\"L %1 %2\").arg(0.0).arg(0.0);\r\n\toutput += QString(\"Z\");\r\n\tm_pathIsClosed = true;\r\n\tm_coords = output;\r\n\r\n\tconst auto& graphicState = m_graphicStack.top();\r\n\tint z = m_doc->itemAdd(PageItem::Polygon, PageItem::Rectangle, xCoor + crect.x(), yCoor + crect.y(), crect.width(), crect.height(), 0, graphicState.fillColor, CommonStrings::None);\r\n\tPageItem* ite = m_doc->Items->at(z);\r\n\tif (checkClip())\r\n\t{\r\n\t\tQPainterPath out = graphicState.clipPath;\r\n\t\tout.translate(m_doc->currentPage()->xOffset(), m_doc->currentPage()->yOffset());\r\n\t\tout.translate(-ite->xPos(), -ite->yPos());\r\n\t\tite->PoLine.fromQPainterPath(out, true);\r\n\t\tite->setFillEvenOdd(out.fillRule() == Qt::OddEvenFill);\r\n\t}\r\n\tite->ClipEdited = true;\r\n\tite->FrameType = 3;\r\n\tite->setFillShade(graphicState.fillShade);\r\n\tite->setLineShade(100);\r\n\tite->setFillTransparency(1.0 - state->getFillOpacity());\r\n\tite->setFillBlendmode(getBlendMode(state));\r\n\tite->setLineEnd(m_lineEnd);\r\n\tite->setLineJoin(m_lineJoin);\r\n\tite->setTextFlowMode(PageItem::TextFlowDisabled);\r\n\tite->GrType = 7;\r\n\tif (!shading->getExtend0() || !shading->getExtend1())\r\n\t{\r\n\t\tfillGradient.setRepeatMethod(VGradient::none);\r\n\t\tite->setGradientExtend(VGradient::none);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tfillGradient.setRepeatMethod(VGradient::pad);\r\n\t\tite->setGradientExtend(VGradient::pad);\r\n\t}\r\n\tite->fill_gradient = fillGradient;\r\n\tite->setGradientVector(GrStartX, GrStartY, GrEndX, GrEndY, GrFocalX, GrFocalY, 1, 0);\r\n\tm_doc->adjustItemSize(ite);\r\n\tm_Elements->append(ite);\r\n\tif (m_groupStack.count() != 0)\r\n\t{\r\n\t\tm_groupStack.top().Items.append(ite);\r\n\t\tapplyMask(ite);\r\n\t}\r\n\treturn true;\r\n}\r\n\r\nbool SlaOutputDev::gouraudTriangleShadedFill(GfxState *state, GfxGouraudTriangleShading *shading)\r\n{\r\n//\tqDebug() << \"SlaOutputDev::gouraudTriangleShadedFill\";\r\n\tdouble xCoor = m_doc->currentPage()->xOffset();\r\n\tdouble yCoor = m_doc->currentPage()->yOffset();\r\n\tdouble xmin, ymin, xmax, ymax;\r\n\t// get the clip region bbox\r\n\tstate->getClipBBox(&xmin, &ymin, &xmax, &ymax);\r\n\tQRectF crect(QPointF(xmin, ymin), QPointF(xmax, ymax));\r\n\tcrect = crect.normalized();\r\n\tQString output = QString(\"M %1 %2\").arg(0.0).arg(0.0);\r\n\toutput += QString(\"L %1 %2\").arg(crect.width()).arg(0.0);\r\n\toutput += QString(\"L %1 %2\").arg(crect.width()).arg(crect.height());\r\n\toutput += QString(\"L %1 %2\").arg(0.0).arg(crect.height());\r\n\toutput += QString(\"L %1 %2\").arg(0.0).arg(0.0);\r\n\toutput += QString(\"Z\");\r\n\tm_pathIsClosed = true;\r\n\tm_coords = output;\r\n\tconst double *ctm = state->getCTM();\r\n\tm_ctm = QTransform(ctm[0], ctm[1], ctm[2], ctm[3], ctm[4], ctm[5]);\r\n\tconst auto& graphicState = m_graphicStack.top();\r\n\tint z = m_doc->itemAdd(PageItem::Polygon, PageItem::Rectangle, xCoor + crect.x(), yCoor + crect.y(), crect.width(), crect.height(), 0, graphicState.fillColor, CommonStrings::None);\r\n\tPageItem* ite = m_doc->Items->at(z);\r\n\tite->ClipEdited = true;\r\n\tite->FrameType = 3;\r\n\tite->setFillShade(graphicState.fillShade);\r\n\tite->setLineShade(100);\r\n\tite->setFillEvenOdd(false);\r\n\tite->setFillTransparency(1.0 - state->getFillOpacity());\r\n\tite->setFillBlendmode(getBlendMode(state));\r\n\tite->setLineEnd(m_lineEnd);\r\n\tite->setLineJoin(m_lineJoin);\r\n\tite->setTextFlowMode(PageItem::TextFlowDisabled);\r\n\tm_doc->adjustItemSize(ite);\r\n\tm_Elements->append(ite);\r\n\tif (m_groupStack.count() != 0)\r\n\t{\r\n\t\tm_groupStack.top().Items.append(ite);\r\n\t\tapplyMask(ite);\r\n\t}\r\n\tGfxColor color[3];\r\n\tdouble x0, y0, x1, y1, x2, y2;\r\n\tfor (int i = 0; i < shading->getNTriangles(); i++)\r\n\t{\r\n\t\tint shade = 100;\r\n\t\tmeshGradientPatch patchM;\r\n\t\tshading->getTriangle(i, &x0, &y0, &color[0],  &x1, &y1, &color[1],  &x2, &y2, &color[2]);\r\n\t\tpatchM.BL.resetTo(FPoint(x0, y0));\r\n\t\tpatchM.BL.shade = 100;\r\n\t\tpatchM.BL.transparency = 1.0;\r\n\t\tpatchM.BL.colorName = getColor(shading->getColorSpace(), &color[0], &shade);\r\n\t\tpatchM.BL.color = ScColorEngine::getShadeColorProof(m_doc->PageColors[patchM.BL.colorName], m_doc, shade);\r\n\t\tpatchM.TL.resetTo(FPoint(x1, y1));\r\n\t\tpatchM.TL.shade = 100;\r\n\t\tpatchM.TL.transparency = 1.0;\r\n\t\tpatchM.TL.colorName = getColor(shading->getColorSpace(), &color[1], &shade);\r\n\t\tpatchM.TL.color = ScColorEngine::getShadeColorProof(m_doc->PageColors[patchM.TL.colorName], m_doc, shade);\r\n\t\tpatchM.TR.resetTo(FPoint(x2, y2));\r\n\t\tpatchM.TR.shade = 100;\r\n\t\tpatchM.TR.transparency = 1.0;\r\n\t\tpatchM.TR.colorName = getColor(shading->getColorSpace(), &color[2], &shade);\r\n\t\tpatchM.TR.color = ScColorEngine::getShadeColorProof(m_doc->PageColors[patchM.TR.colorName], m_doc, shade);\r\n\t\tpatchM.BR.resetTo(FPoint(x0, y0));\r\n\t\tpatchM.BR.shade = 100;\r\n\t\tpatchM.BR.transparency = 1.0;\r\n\t\tpatchM.BR.colorName = getColor(shading->getColorSpace(), &color[0], &shade);\r\n\t\tpatchM.BR.color = ScColorEngine::getShadeColorProof(m_doc->PageColors[patchM.BR.colorName], m_doc, shade);\r\n\t\tpatchM.TL.transform(m_ctm);\r\n\t\tpatchM.TL.moveRel(-crect.x(), -crect.y());\r\n\t\tpatchM.TR.transform(m_ctm);\r\n\t\tpatchM.TR.moveRel(-crect.x(), -crect.y());\r\n\t\tpatchM.BR.transform(m_ctm);\r\n\t\tpatchM.BR.moveRel(-crect.x(), -crect.y());\r\n\t\tpatchM.BL.transform(m_ctm);\r\n\t\tpatchM.BL.moveRel(-crect.x(), -crect.y());\r\n\t\tite->meshGradientPatches.append(patchM);\r\n\t}\r\n\tite->GrType = 12;\r\n\treturn true;\r\n}\r\n\r\nbool SlaOutputDev::patchMeshShadedFill(GfxState *state, GfxPatchMeshShading *shading)\r\n{\r\n//\tqDebug() << \"SlaOutputDev::patchMeshShadedFill\";\r\n\tdouble xCoor = m_doc->currentPage()->xOffset();\r\n\tdouble yCoor = m_doc->currentPage()->yOffset();\r\n\tdouble xmin, ymin, xmax, ymax;\r\n\t// get the clip region bbox\r\n\tstate->getClipBBox(&xmin, &ymin, &xmax, &ymax);\r\n\tQRectF crect(QPointF(xmin, ymin), QPointF(xmax, ymax));\r\n\tcrect = crect.normalized();\r\n\tQString output = QString(\"M %1 %2\").arg(0.0).arg(0.0);\r\n\toutput += QString(\"L %1 %2\").arg(crect.width()).arg(0.0);\r\n\toutput += QString(\"L %1 %2\").arg(crect.width()).arg(crect.height());\r\n\toutput += QString(\"L %1 %2\").arg(0.0).arg(crect.height());\r\n\toutput += QString(\"L %1 %2\").arg(0.0).arg(0.0);\r\n\toutput += QString(\"Z\");\r\n\tm_pathIsClosed = true;\r\n\tm_coords = output;\r\n\tconst double *ctm = state->getCTM();\r\n\tm_ctm = QTransform(ctm[0], ctm[1], ctm[2], ctm[3], ctm[4], ctm[5]);\r\n\tconst auto& graphicState = m_graphicStack.top();\r\n\tint z = m_doc->itemAdd(PageItem::Polygon, PageItem::Rectangle, xCoor + crect.x(), yCoor + crect.y(), crect.width(), crect.height(), 0, graphicState.fillColor, CommonStrings::None);\r\n\tPageItem* ite = m_doc->Items->at(z);\r\n\tite->ClipEdited = true;\r\n\tite->FrameType = 3;\r\n\tite->setFillShade(graphicState.fillShade);\r\n\tite->setLineShade(100);\r\n\tite->setFillEvenOdd(false);\r\n\tite->setFillTransparency(1.0 - state->getFillOpacity());\r\n\tite->setFillBlendmode(getBlendMode(state));\r\n\tite->setLineEnd(m_lineEnd);\r\n\tite->setLineJoin(m_lineJoin);\r\n\tite->setTextFlowMode(PageItem::TextFlowDisabled);\r\n\tm_doc->adjustItemSize(ite);\r\n\tm_Elements->append(ite);\r\n\tif (m_groupStack.count() != 0)\r\n\t{\r\n\t\tm_groupStack.top().Items.append(ite);\r\n\t\tapplyMask(ite);\r\n\t}\r\n\tite->meshGradientPatches.clear();\r\n\tfor (int i = 0; i < shading->getNPatches(); i++)\r\n\t{\r\n\t\tint shade = 100;\r\n\t\tconst GfxPatch *patch = shading->getPatch(i);\r\n\t\tGfxColor color;\r\n\t\tmeshGradientPatch patchM;\r\n\t\tint u, v;\r\n\t\tpatchM.BL.resetTo(FPoint(patch->x[0][0], patch->y[0][0]));\r\n\t\tpatchM.BL.controlTop = FPoint(patch->x[0][1], patch->y[0][1]);\r\n\t\tpatchM.BL.controlRight = FPoint(patch->x[1][0], patch->y[1][0]);\r\n\t\tpatchM.BL.controlColor = FPoint(patch->x[1][1], patch->y[1][1]);\r\n\t\tu = 0;\r\n\t\tv = 0;\r\n\t\tif (shading->isParameterized())\r\n\t\t{\r\n\t\t\tshading->getParameterizedColor (patch->color[u][v].c[0], &color);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tfor (int k = 0; k < shading->getColorSpace()->getNComps(); k++)\r\n\t\t\t{\r\n\t\t\t\tcolor.c[k] = GfxColorComp (patch->color[u][v].c[k]);\r\n\t\t\t}\r\n\t\t}\r\n\t\tpatchM.BL.colorName = getColor(shading->getColorSpace(), &color, &shade);\r\n\t\tpatchM.BL.shade = 100;\r\n\t\tpatchM.BL.transparency = 1.0;\r\n\t\tpatchM.BL.color = ScColorEngine::getShadeColorProof(m_doc->PageColors[patchM.BL.colorName], m_doc, shade);\r\n\r\n\t\tu = 0;\r\n\t\tv = 1;\r\n\t\tpatchM.TL.resetTo(FPoint(patch->x[0][3], patch->y[0][3]));\r\n\t\tpatchM.TL.controlRight = FPoint(patch->x[1][3], patch->y[1][3]);\r\n\t\tpatchM.TL.controlBottom = FPoint(patch->x[0][2], patch->y[0][2]);\r\n\t\tpatchM.TL.controlColor = FPoint(patch->x[1][2], patch->y[1][2]);\r\n\t\tif (shading->isParameterized())\r\n\t\t{\r\n\t\t\tshading->getParameterizedColor (patch->color[u][v].c[0], &color);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tfor (int k = 0; k < shading->getColorSpace()->getNComps(); k++)\r\n\t\t\t{\r\n\t\t\t\tcolor.c[k] = GfxColorComp (patch->color[u][v].c[k]);\r\n\t\t\t}\r\n\t\t}\r\n\t\tpatchM.TL.colorName = getColor(shading->getColorSpace(), &color, &shade);\r\n\t\tpatchM.TL.shade = 100;\r\n\t\tpatchM.TL.transparency = 1.0;\r\n\t\tpatchM.TL.color = ScColorEngine::getShadeColorProof(m_doc->PageColors[patchM.TL.colorName], m_doc, shade);\r\n\r\n\t\tu = 1;\r\n\t\tv = 1;\r\n\t\tpatchM.TR.resetTo(FPoint(patch->x[3][3], patch->y[3][3]));\r\n\t\tpatchM.TR.controlBottom = FPoint(patch->x[3][2], patch->y[3][2]);\r\n\t\tpatchM.TR.controlLeft = FPoint(patch->x[2][3], patch->y[2][3]);\r\n\t\tpatchM.TR.controlColor = FPoint(patch->x[2][2], patch->y[2][2]);\r\n\t\tif (shading->isParameterized())\r\n\t\t{\r\n\t\t\tshading->getParameterizedColor (patch->color[u][v].c[0], &color);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tfor (int k = 0; k < shading->getColorSpace()->getNComps(); k++)\r\n\t\t\t{\r\n\t\t\t\tcolor.c[k] = GfxColorComp (patch->color[u][v].c[k]);\r\n\t\t\t}\r\n\t\t}\r\n\t\tpatchM.TR.colorName = getColor(shading->getColorSpace(), &color, &shade);\r\n\t\tpatchM.TR.shade = 100;\r\n\t\tpatchM.TR.transparency = 1.0;\r\n\t\tpatchM.TR.color = ScColorEngine::getShadeColorProof(m_doc->PageColors[patchM.TR.colorName], m_doc, shade);\r\n\r\n\t\tu = 1;\r\n\t\tv = 0;\r\n\t\tpatchM.BR.resetTo(FPoint(patch->x[3][0], patch->y[3][0]));\r\n\t\tpatchM.BR.controlLeft = FPoint(patch->x[2][0], patch->y[2][0]);\r\n\t\tpatchM.BR.controlTop = FPoint(patch->x[3][1], patch->y[3][1]);\r\n\t\tpatchM.BR.controlColor = FPoint(patch->x[2][1], patch->y[2][1]);\r\n\t\tif (shading->isParameterized())\r\n\t\t{\r\n\t\t\tshading->getParameterizedColor (patch->color[u][v].c[0], &color);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tfor (int k = 0; k < shading->getColorSpace()->getNComps(); k++)\r\n\t\t\t{\r\n\t\t\t\tcolor.c[k] = GfxColorComp (patch->color[u][v].c[k]);\r\n\t\t\t}\r\n\t\t}\r\n\t\tpatchM.BR.colorName = getColor(shading->getColorSpace(), &color, &shade);\r\n\t\tpatchM.BR.shade = 100;\r\n\t\tpatchM.BR.transparency = 1.0;\r\n\t\tpatchM.BR.color = ScColorEngine::getShadeColorProof(m_doc->PageColors[patchM.BR.colorName], m_doc, shade);\r\n\r\n\t\tpatchM.TL.transform(m_ctm);\r\n\t\tpatchM.TL.moveRel(-crect.x(), -crect.y());\r\n\t\tpatchM.TR.transform(m_ctm);\r\n\t\tpatchM.TR.moveRel(-crect.x(), -crect.y());\r\n\t\tpatchM.BR.transform(m_ctm);\r\n\t\tpatchM.BR.moveRel(-crect.x(), -crect.y());\r\n\t\tpatchM.BL.transform(m_ctm);\r\n\t\tpatchM.BL.moveRel(-crect.x(), -crect.y());\r\n\t\tite->meshGradientPatches.append(patchM);\r\n\t}\r\n\tite->GrType = 12;\r\n\treturn true;\r\n}\r\n\r\nbool SlaOutputDev::tilingPatternFill(GfxState *state, Gfx * /*gfx*/, Catalog *cat, GfxTilingPattern *tPat, const double *mat, int x0, int y0, int x1, int y1, double xStep, double yStep)\r\n{\r\n//\tqDebug() << \"SlaOutputDev::tilingPatternFill\";\r\n\tconst double *bbox = tPat->getBBox();\r\n\tconst double *pmat = tPat->getMatrix();\r\n\tDict *resDict = tPat->getResDict();\r\n\r\n\tPDFRectangle box;\r\n\tGfx *gfx;\r\n\tQString id;\r\n\tPageItem *ite;\r\n\tgroupEntry gElements;\r\n\tm_groupStack.push(gElements);\r\n\tdouble width, height;\r\n\twidth = bbox[2] - bbox[0];\r\n\theight = bbox[3] - bbox[1];\r\n\tif (xStep != width || yStep != height)\r\n\t\treturn false;\r\n\tbox.x1 = bbox[0];\r\n\tbox.y1 = bbox[1];\r\n\tbox.x2 = bbox[2];\r\n\tbox.y2 = bbox[3];\r\n\r\n\tconst double *ctm = state->getCTM();\r\n\tm_ctm = QTransform(ctm[0], ctm[1], ctm[2], ctm[3], ctm[4], ctm[5]);\r\n\tQTransform mm(mat[0], mat[1], mat[2], mat[3], mat[4], mat[5]);\r\n\tQTransform mmx = mm * m_ctm;\r\n\r\n\tgfx = new Gfx(m_pdfDoc, this, resDict, &box, nullptr);\r\n\tm_inPattern++;\r\n\t// Unset the clip path as it is unrelated to the pattern's coordinate space.\r\n\tQPainterPath savedClip = m_graphicStack.top().clipPath;\r\n\tm_graphicStack.top().clipPath = QPainterPath();\r\n\tgfx->display(tPat->getContentStream());\r\n\tm_graphicStack.top().clipPath = savedClip;\r\n\tm_inPattern--;\r\n\tm_doc->m_Selection->clear();\r\n\r\n\tgElements = m_groupStack.pop();\r\n\tif (gElements.Items.count() > 0)\r\n\t{\r\n\t\tfor (int dre = 0; dre < gElements.Items.count(); ++dre)\r\n\t\t{\r\n\t\t\tm_doc->m_Selection->addItem(gElements.Items.at(dre), true);\r\n\t\t\tm_Elements->removeAll(gElements.Items.at(dre));\r\n\t\t}\r\n\t\tm_doc->itemSelection_FlipV();\r\n\t\tPageItem *ite;\r\n\t\tif (m_doc->m_Selection->count() > 1)\r\n\t\t\tite = m_doc->groupObjectsSelection();\r\n\t\telse\r\n\t\t\tite = m_doc->m_Selection->itemAt(0);\r\n\t\tite->setFillTransparency(1.0 - state->getFillOpacity());\r\n\t\tite->setFillBlendmode(getBlendMode(state));\r\n\t\tm_doc->m_Selection->clear();\r\n\t\tm_doc->DoDrawing = true;\r\n\t\tScPattern pat(m_doc);\r\n\t\tpat.pattern = ite->DrawObj_toImage(qMin(qMax(ite->width(), ite->height()), 500.0));\r\n\t\tpat.xoffset = 0;\r\n\t\tpat.yoffset = 0;\r\n\t\tm_doc->DoDrawing = false;\r\n\t\tpat.width = ite->width();\r\n\t\tpat.height = ite->height();\r\n\t\tite->gXpos = 0;\r\n\t\tite->gYpos = 0;\r\n\t\tite->setXYPos(ite->gXpos, ite->gYpos, true);\r\n\t\tpat.items.append(ite);\r\n\t\tm_doc->Items->removeAll(ite);\r\n\t\tid = QString(\"Pattern_from_PDF_%1\").arg(m_doc->docPatterns.count() + 1);\r\n\t\tm_doc->addPattern(id, pat);\r\n\t}\r\n\tdouble xCoor = m_doc->currentPage()->xOffset();\r\n\tdouble yCoor = m_doc->currentPage()->yOffset();\r\n\tdouble xmin, ymin, xmax, ymax;\r\n\t// get the clip region bbox\r\n\tstate->getClipBBox(&xmin, &ymin, &xmax, &ymax);\r\n\tQRectF crect(QPointF(xmin, ymin), QPointF(xmax, ymax));\r\n\tcrect = crect.normalized();\r\n\tQString output = QString(\"M %1 %2\").arg(0.0).arg(0.0);\r\n\toutput += QString(\"L %1 %2\").arg(crect.width()).arg(0.0);\r\n\toutput += QString(\"L %1 %2\").arg(crect.width()).arg(crect.height());\r\n\toutput += QString(\"L %1 %2\").arg(0.0).arg(crect.height());\r\n\toutput += QString(\"L %1 %2\").arg(0.0).arg(0.0);\r\n\toutput += QString(\"Z\");\r\n\tm_pathIsClosed = true;\r\n\tm_coords = output;\r\n\r\n\tconst auto& graphicState = m_graphicStack.top();\r\n\tint z = m_doc->itemAdd(PageItem::Polygon, PageItem::Rectangle, xCoor + crect.x(), yCoor + crect.y(), crect.width(), crect.height(), 0, graphicState.fillColor, CommonStrings::None);\r\n\tite = m_doc->Items->at(z);\r\n\r\n\tm_ctm = QTransform(ctm[0], ctm[1], ctm[2], ctm[3], ctm[4], ctm[5]);\r\n\tdouble angle = m_ctm.map(QLineF(0, 0, 1, 0)).angle();\r\n\tite->setRotation(-angle);\r\n\tif (checkClip())\r\n\t{\r\n\t\tQPainterPath outline = graphicState.clipPath;\r\n\t\toutline.translate(xCoor - ite->xPos(), yCoor - ite->yPos());\r\n\t\t// Undo the rotation of the clipping path as it is rotated together with the item.\r\n\t\tQTransform mm;\r\n\t\tmm.rotate(angle);\r\n\t\toutline = mm.map(outline);\r\n\t\tite->PoLine.fromQPainterPath(outline, true);\r\n\t\tite->setFillEvenOdd(outline.fillRule() == Qt::OddEvenFill);\r\n\t}\r\n\tite->ClipEdited = true;\r\n\tite->FrameType = 3;\r\n\tite->setFillShade(graphicState.fillShade);\r\n\tite->setLineShade(100);\r\n\tite->setFillTransparency(1.0 - state->getFillOpacity());\r\n\tite->setFillBlendmode(getBlendMode(state));\r\n\tite->setLineEnd(m_lineEnd);\r\n\tite->setLineJoin(m_lineJoin);\r\n\tite->setTextFlowMode(PageItem::TextFlowDisabled);\r\n\tite->GrType = 8;\r\n\tite->setPattern(id);\r\n\tite->setPatternTransform(fabs(pmat[0]), fabs(pmat[3]), mmx.dx() - ctm[4], mmx.dy() - ctm[5], 0, -1 * pmat[1], pmat[2]);\r\n\tm_doc->adjustItemSize(ite);\r\n\tm_Elements->append(ite);\r\n\tif (m_groupStack.count() != 0)\r\n\t{\r\n\t\tm_groupStack.top().Items.append(ite);\r\n\t\tapplyMask(ite);\r\n\t}\r\n\tdelete gfx;\r\n\treturn true;\r\n}\r\n\r\nvoid SlaOutputDev::drawImageMask(GfxState *state, Object *ref, Stream *str, int width, int height, bool invert, bool interpolate, bool inlineImg)\r\n{\r\n//\tqDebug() << \"Draw Image Mask\";\r\n\tauto imgStr = std::make_unique<ImageStream>(str, width, 1, 1);\r\n\timgStr->reset();\r\n#ifdef WORDS_BIGENDIAN\r\n\tQImage image(width, height, QImage::Format_Mono);\r\n#else\r\n\tQImage image(width, height, QImage::Format_MonoLSB);\r\n#endif\r\n\tif (image.isNull())\r\n\t\treturn;\r\n\r\n\tint invertBit = invert ? 1 : 0;\r\n\tunsigned char* buffer = image.bits();\r\n\tunsigned char* dest = nullptr;\r\n\tqsizetype rowStride = image.bytesPerLine();\r\n\tint i, bit;\r\n\tunsigned char* pix;\r\n\r\n\tfor (int y = 0; y < height; y++)\r\n\t{\r\n\t\tpix = imgStr->getLine();\r\n\t\tdest = buffer + y * rowStride;\r\n\t\ti = 0;\r\n\t\tbit = 0;\r\n\t\tfor (int x = 0; x < width; x++)\r\n\t\t{\r\n\t\t\tif (bit == 0)\r\n\t\t\t\tdest[i] = 0;\r\n\t\t\tif (!(pix[x] ^ invertBit))\r\n\t\t\t{\r\n#ifdef WORDS_BIGENDIAN\r\n\t\t\t\tdest[i] |= (1 << (7 - bit));\r\n#else\r\n\t\t\t\tdest[i] |= (1 << bit);\r\n#endif\r\n\t\t\t}\r\n\t\t\tbit++;\r\n\t\t\tif (bit > 7)\r\n\t\t\t{\r\n\t\t\t\tbit = 0;\r\n\t\t\t\ti++;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tconst auto& graphicState = m_graphicStack.top();\r\n\tQColor backColor = ScColorEngine::getShadeColorProof(m_doc->PageColors[graphicState.fillColor], m_doc, graphicState.fillShade);\r\n\tQImage res(width, height, QImage::Format_ARGB32);\r\n\tres.fill(backColor.rgb());\r\n\tunsigned char cc, cm, cy, ck;\r\n\tfor (int yi = 0; yi < res.height(); ++yi)\r\n\t{\r\n\t\tQRgb *t = (QRgb*)(res.scanLine( yi ));\r\n\t\tfor (int xi = 0; xi < res.width(); ++xi)\r\n\t\t{\r\n\t\t\tcc = static_cast<unsigned char>( qRed(*t) );\r\n\t\t\tcm = static_cast<unsigned char>( qGreen(*t) );\r\n\t\t\tcy = static_cast<unsigned char>( qBlue(*t) );\r\n\t\t\tck = static_cast<unsigned char>( image.pixel(xi, yi) );\r\n\t\t\tif (ck == 0)\r\n\t\t\t\t(*t) = qRgba(cc, cm, cy, 0);\r\n\t\t\telse\r\n\t\t\t\t(*t) = qRgba(cc, cm, cy, 255);\r\n\t\t\tt++;\r\n\t\t}\r\n\t}\r\n\r\n\tcreateImageFrame(res, state, 3);\r\n\r\n\timgStr->close();\r\n}\r\n\r\nvoid SlaOutputDev::drawSoftMaskedImage(GfxState *state, Object *ref, Stream *str, int width, int height, GfxImageColorMap *colorMap, bool interpolate, Stream *maskStr, int maskWidth, int maskHeight,\r\n\t\t\t\t   GfxImageColorMap *maskColorMap, bool maskInterpolate)\r\n{\r\n//\tqDebug() << \"SlaOutputDev::drawSoftMaskedImage Masked Image Components\" << colorMap->getNumPixelComps();\r\n\tauto imgStr = std::make_unique<ImageStream>(str, width, colorMap->getNumPixelComps(), colorMap->getBits());\r\n\timgStr->reset();\r\n\tunsigned int *dest = nullptr;\r\n\tunsigned char * buffer = new unsigned char[width * height * 4];\r\n\tfor (int y = 0; y < height; y++)\r\n\t{\r\n\t\tdest = (unsigned int *)(buffer + y * 4 * width);\r\n\t\tunsigned char * pix = imgStr->getLine();\r\n\t\tcolorMap->getRGBLine(pix, dest, width);\r\n\t}\r\n\r\n\tQImage image(buffer, width, height, QImage::Format_RGB32);\r\n\tif (image.isNull())\r\n\t{\r\n\t\tdelete[] buffer;\r\n\t\treturn;\r\n\t}\r\n\r\n\tauto mskStr = std::make_unique<ImageStream>(maskStr, maskWidth, maskColorMap->getNumPixelComps(), maskColorMap->getBits());\r\n\tmskStr->reset();\r\n\tunsigned char *mdest = nullptr;\r\n\tunsigned char * mbuffer = new unsigned char[maskWidth * maskHeight];\r\n\tmemset(mbuffer, 0, maskWidth * maskHeight);\r\n\tfor (int y = 0; y < maskHeight; y++)\r\n\t{\r\n\t\tmdest = mbuffer + y * maskWidth;\r\n\t\tunsigned char * pix = mskStr->getLine();\r\n\t\tmaskColorMap->getGrayLine(pix, mdest, maskWidth);\r\n\t}\r\n\tif ((maskWidth != width) || (maskHeight != height))\r\n\t\timage = image.scaled(maskWidth, maskHeight, Qt::IgnoreAspectRatio, Qt::SmoothTransformation);\r\n\tQImage res = image.convertToFormat(QImage::Format_ARGB32);\r\n\r\n\tint matteRc, matteGc, matteBc;\r\n\tconst GfxColor *matteColor = maskColorMap->getMatteColor();\r\n\tif (matteColor != nullptr)\r\n\t{\r\n\t\tGfxRGB matteRgb;\r\n\t\tcolorMap->getColorSpace()->getRGB(matteColor, &matteRgb);\r\n\t\tmatteRc = qRound(colToDbl(matteRgb.r) * 255);\r\n\t\tmatteGc = qRound(colToDbl(matteRgb.g) * 255);\r\n\t\tmatteBc = qRound(colToDbl(matteRgb.b) * 255);\r\n\t}\r\n\r\n\tunsigned char cr, cg, cb, ca;\r\n\tint s = 0;\r\n\tfor (int yi = 0; yi < res.height(); ++yi)\r\n\t{\r\n\t\tQRgb *t = (QRgb*)(res.scanLine( yi ));\r\n\t\tfor (int xi = 0; xi < res.width(); ++xi)\r\n\t\t{\r\n\t\t\tcr = static_cast<unsigned char>( qRed(*t) );\r\n\t\t\tcg = static_cast<unsigned char>( qGreen(*t) );\r\n\t\t\tcb = static_cast<unsigned char>( qBlue(*t) );\r\n\t\t\tca = mbuffer[s];\r\n\t\t\tif (matteColor != nullptr)\r\n\t\t\t{\r\n\t\t\t\tcr = static_cast<unsigned char>( unblendMatte(cr, ca, matteRc) );\r\n\t\t\t\tcg = static_cast<unsigned char>( unblendMatte(cg, ca, matteGc) );\r\n\t\t\t\tcb = static_cast<unsigned char>( unblendMatte(cb, ca, matteBc) );\r\n\t\t\t}\r\n\t\t\t(*t) = qRgba(cr, cg, cb, ca);\r\n\t\t\ts++;\r\n\t\t\tt++;\r\n\t\t}\r\n\t}\r\n\r\n\tcreateImageFrame(res, state, 3);\r\n\r\n\tdelete[] buffer;\r\n\tdelete[] mbuffer;\r\n}\r\n\r\nvoid SlaOutputDev::drawMaskedImage(GfxState *state, Object *ref, Stream *str,  int width, int height, GfxImageColorMap *colorMap, bool interpolate, Stream *maskStr, int maskWidth, int maskHeight, bool maskInvert, bool maskInterpolate)\r\n{\r\n//\tqDebug() << \"SlaOutputDev::drawMaskedImage\";\r\n\tauto imgStr = std::make_unique<ImageStream>(str, width, colorMap->getNumPixelComps(), colorMap->getBits());\r\n\timgStr->reset();\r\n\tunsigned int *dest = nullptr;\r\n\tunsigned char * buffer = new unsigned char[width * height * 4];\r\n\tfor (int y = 0; y < height; y++)\r\n\t{\r\n\t\tdest = (unsigned int *)(buffer + y * 4 * width);\r\n\t\tunsigned char * pix = imgStr->getLine();\r\n\t\tcolorMap->getRGBLine(pix, dest, width);\r\n\t}\r\n\r\n\tQImage image(buffer, width, height, QImage::Format_RGB32);\r\n\tif (image.isNull())\r\n\t{\r\n\t\tdelete[] buffer;\r\n\t\treturn;\r\n\t}\r\n\r\n\tauto mskStr = std::make_unique<ImageStream>(maskStr, maskWidth, 1, 1);\r\n\tmskStr->reset();\r\n\tunsigned char *mdest = nullptr;\r\n\tint invert_bit = maskInvert ? 1 : 0;\r\n\tunsigned char * mbuffer = new unsigned char[maskWidth * maskHeight];\r\n\tmemset(mbuffer, 0, maskWidth * maskHeight);\r\n\tfor (int y = 0; y < maskHeight; y++)\r\n\t{\r\n\t\tmdest = mbuffer + y * maskWidth;\r\n\t\tunsigned char * pix = mskStr->getLine();\r\n\t\tfor (int x = 0; x < maskWidth; x++)\r\n\t\t{\r\n\t\t\tif (pix[x] ^ invert_bit)\r\n\t\t\t\t*mdest++ = 0;\r\n\t\t\telse\r\n\t\t\t\t*mdest++ = 255;\r\n\t\t}\r\n\t}\r\n\tif ((maskWidth != width) || (maskHeight != height))\r\n\t\timage = image.scaled(maskWidth, maskHeight, Qt::IgnoreAspectRatio, Qt::SmoothTransformation);\r\n\tQImage res = image.convertToFormat(QImage::Format_ARGB32);\r\n\tunsigned char cc, cm, cy, ck;\r\n\tint s = 0;\r\n\tfor (int yi = 0; yi < res.height(); ++yi)\r\n\t{\r\n\t\tQRgb *t = (QRgb*)(res.scanLine( yi ));\r\n\t\tfor (int xi = 0; xi < res.width(); ++xi)\r\n\t\t{\r\n\t\t\tcc = static_cast<unsigned char>( qRed(*t) );\r\n\t\t\tcm = static_cast<unsigned char>( qGreen(*t) );\r\n\t\t\tcy = static_cast<unsigned char>( qBlue(*t) );\r\n\t\t\tck = mbuffer[s];\r\n\t\t\t(*t) = qRgba(cc, cm, cy, ck);\r\n\t\t\ts++;\r\n\t\t\tt++;\r\n\t\t}\r\n\t}\r\n\r\n\tcreateImageFrame(res, state, 3);\r\n\r\n\tdelete[] buffer;\r\n\tdelete[] mbuffer;\r\n}\r\n\r\nvoid SlaOutputDev::drawImage(GfxState *state, Object *ref, Stream *str, int width, int height, GfxImageColorMap *colorMap, bool interpolate, const int* maskColors, bool inlineImg)\r\n{\r\n\tauto imgStr = std::make_unique<ImageStream>(str, width, colorMap->getNumPixelComps(), colorMap->getBits());\r\n\timgStr->reset();\r\n\r\n\tQImage image(width, height, QImage::Format_ARGB32);\r\n\tif (image.isNull())\r\n\t\treturn;\r\n\r\n\tif (maskColors)\r\n\t{\r\n\t\tfor (int y = 0; y < height; y++)\r\n\t\t{\r\n\t\t\tQRgb *s = (QRgb*)(image.scanLine(y));\r\n\t\t\tunsigned char *pix = imgStr->getLine();\r\n\t\t\tfor (int x = 0; x < width; x++)\r\n\t\t\t{\r\n\t\t\t\tGfxRGB rgb;\r\n\t\t\t\tcolorMap->getRGB(pix, &rgb);\r\n\t\t\t\tint Rc = qRound(colToDbl(rgb.r) * 255);\r\n\t\t\t\tint Gc = qRound(colToDbl(rgb.g) * 255);\r\n\t\t\t\tint Bc = qRound(colToDbl(rgb.b) * 255);\r\n\t\t\t\t*s = qRgba(Rc, Gc, Bc, 255);\r\n\t\t\t\tfor (int i = 0; i < colorMap->getNumPixelComps(); ++i)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (pix[i] < maskColors[2*i] * 255 || pix[i] > maskColors[2*i+1] * 255)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t*s = *s | 0xff000000;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\ts++;\r\n\t\t\t\tpix += colorMap->getNumPixelComps();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tfor (int y = 0; y < height; y++)\r\n\t\t{\r\n\t\t\tQRgb *s = (QRgb*)(image.scanLine(y));\r\n\t\t\tunsigned char *pix = imgStr->getLine();\r\n\t\t\tfor (int x = 0; x < width; x++)\r\n\t\t\t{\r\n\t\t\t\tif (colorMap->getNumPixelComps() == 4)\r\n\t\t\t\t{\r\n\t\t\t\t\tGfxCMYK cmyk;\r\n\t\t\t\t\tcolorMap->getCMYK(pix, &cmyk);\r\n\t\t\t\t\tint Cc = qRound(colToDbl(cmyk.c) * 255);\r\n\t\t\t\t\tint Mc = qRound(colToDbl(cmyk.m) * 255);\r\n\t\t\t\t\tint Yc = qRound(colToDbl(cmyk.y) * 255);\r\n\t\t\t\t\tint Kc = qRound(colToDbl(cmyk.k) * 255);\r\n\t\t\t\t\t*s = qRgba(Yc, Mc, Cc, Kc);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tGfxRGB rgb;\r\n\t\t\t\t\tcolorMap->getRGB(pix, &rgb);\r\n\t\t\t\t\tint Rc = qRound(colToDbl(rgb.r) * 255);\r\n\t\t\t\t\tint Gc = qRound(colToDbl(rgb.g) * 255);\r\n\t\t\t\t\tint Bc = qRound(colToDbl(rgb.b) * 255);\r\n\t\t\t\t\t*s = qRgba(Rc, Gc, Bc, 255);\r\n\t\t\t\t}\r\n\t\t\t\ts++;\r\n\t\t\t\tpix += colorMap->getNumPixelComps();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tcreateImageFrame(image, state, colorMap->getNumPixelComps());\r\n}\r\n\r\nvoid SlaOutputDev::createImageFrame(QImage& image, GfxState *state, int numColorComponents)\r\n{\r\n//\tqDebug() << \"SlaOutputDev::createImageFrame\";\r\n\tconst double *ctm = state->getCTM();\r\n\tdouble xCoor = m_doc->currentPage()->xOffset();\r\n\tdouble yCoor = m_doc->currentPage()->yOffset();\r\n\r\n\tm_ctm = QTransform(ctm[0], ctm[1], ctm[2], ctm[3], ctm[4], ctm[5]);\r\n\tdouble angle = m_ctm.map(QLineF(0, 0, 1, 0)).angle();\r\n\tQPointF torigin;\r\n\t// In PDF all images considered squares with unit length that are transformed into the proper\r\n\t// dimensions by ctm.\r\n\t// A positive determinant retains orientation. Thus orientation is the same as in the PDF\r\n\t// coordinate system (y-axis increases upwards). As Scribus uses the inverse orientation the\r\n\t// image needs to be flipped (a horizontal flip is applied later).  For a flipped image the\r\n\t// corner that will be origin in Scribus is the upper right corner (1, 1) of the image.\r\n\t// A negative determinant changes the orientation such that the image is already in the Scribus\r\n\t// coordinate orientation and no flip is necessary. The origin will be the upper left corner (0, 1).\r\n\tif (m_ctm.determinant() > 0) {\r\n\t\ttorigin = m_ctm.map(QPointF(1, 1));\r\n\t} else {\r\n\t\ttorigin = m_ctm.map(QPointF(0, 1));\r\n\t}\r\n\r\n\t// Determine the visible area of the picture after clipping it. If it is empty, no item\r\n\t// needs to be created.\r\n\tQPainterPath outline;\r\n\toutline.addRect(0, 0, 1, 1);\r\n\toutline = m_ctm.map(outline);\r\n\toutline = intersection(outline, m_graphicStack.top().clipPath);\r\n\r\n\tif ((m_inPattern == 0) && (outline.isEmpty() || outline.boundingRect().isNull()))\r\n\t\treturn;\r\n\r\n    // Determine the width and height of the image by undoing the rotation part\r\n\t// of the CTM and applying the result to the unit square.\r\n\tQTransform without_rotation;\r\n\twithout_rotation = m_ctm * without_rotation.rotate(angle);\r\n\tQRectF trect_wr = without_rotation.mapRect(QRectF(0, 0, 1, 1));\r\n\r\n\tint z = m_doc->itemAdd(PageItem::ImageFrame, PageItem::Rectangle, xCoor + torigin.x(), yCoor + torigin.y(), trect_wr.width(), trect_wr.height(), 0, CommonStrings::None, CommonStrings::None);\r\n\tPageItem* ite = m_doc->Items->at(z);\r\n\tite->ClipEdited = true;\r\n\tite->FrameType = 3;\r\n\tm_doc->setRedrawBounding(ite);\r\n\tite->Clip = flattenPath(ite->PoLine, ite->Segments);\r\n\tite->setTextFlowMode(PageItem::TextFlowDisabled);\r\n\tite->setFillShade(100);\r\n\tite->setLineShade(100);\r\n\tite->setFillEvenOdd(false);\r\n\tite->setFillTransparency(1.0 - state->getFillOpacity());\r\n\tite->setFillBlendmode(getBlendMode(state));\r\n\tif (m_ctm.determinant() > 0)\r\n\t{\r\n\t\tite->setRotation(-(angle - 180));\r\n\t\tite->setImageFlippedH(true);\r\n\t}\r\n\telse\r\n\t\tite->setRotation(-angle);\r\n\tm_doc->adjustItemSize(ite);\r\n\r\n\tif (numColorComponents == 4)\r\n\t{\r\n\t\tauto *tempFile = new QTemporaryFile(QDir::tempPath() + \"/scribus_temp_pdf_XXXXXX.tif\");\r\n\t\ttempFile->setAutoRemove(false);\r\n\t\tif (tempFile->open())\r\n\t\t{\r\n\t\t\tQString fileName = getLongPathName(tempFile->fileName());\r\n\t\t\tif (!fileName.isEmpty())\r\n\t\t\t{\r\n\t\t\t\ttempFile->close();\r\n\t\t\t\tite->isInlineImage = true;\r\n\t\t\t\tite->isTempFile = true;\r\n\t\t\t\tite->AspectRatio = false;\r\n\t\t\t\tite->ScaleType   = false;\r\n\t\t\t\tTIFF* tif = TIFFOpen(fileName.toLocal8Bit().data(), \"w\");\r\n\t\t\t\tif (tif)\r\n\t\t\t\t{\r\n\t\t\t\t\tTIFFSetField(tif, TIFFTAG_IMAGEWIDTH, image.width());\r\n\t\t\t\t\tTIFFSetField(tif, TIFFTAG_IMAGELENGTH, image.height());\r\n\t\t\t\t\tTIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8);\r\n\t\t\t\t\tTIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 4);\r\n\t\t\t\t\tTIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\r\n\t\t\t\t\tTIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_SEPARATED);\r\n\t\t\t\t\tTIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_LZW);\r\n\t\t\t\t\tfor (int y = 0; y < image.height(); ++y)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tTIFFWriteScanline(tif, image.scanLine(y), y);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tTIFFClose(tif);\r\n\t\t\t\t\tm_doc->loadPict(fileName, ite);\r\n\t\t\t\t}\r\n\t\t\t\tm_Elements->append(ite);\r\n\t\t\t\tif (m_groupStack.count() != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tm_groupStack.top().Items.append(ite);\r\n\t\t\t\t\tapplyMask(ite);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\tm_doc->Items->removeAll(ite);\r\n\t\t}\r\n\t\tdelete tempFile;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tauto *tempFile = new QTemporaryFile(QDir::tempPath() + \"/scribus_temp_pdf_XXXXXX.png\");\r\n\t\ttempFile->setAutoRemove(false);\r\n\t\tif (tempFile->open())\r\n\t\t{\r\n\t\t\tQString fileName = getLongPathName(tempFile->fileName());\r\n\t\t\tif (!fileName.isEmpty())\r\n\t\t\t{\r\n\t\t\t\ttempFile->close();\r\n\t\t\t\tite->isInlineImage = true;\r\n\t\t\t\tite->isTempFile = true;\r\n\t\t\t\tite->AspectRatio = false;\r\n\t\t\t\tite->ScaleType   = false;\r\n\t\t\t\timage.save(fileName, \"PNG\");\r\n\t\t\t\tm_doc->loadPict(fileName, ite);\r\n\t\t\t\tm_Elements->append(ite);\r\n\t\t\t\tif (m_groupStack.count() != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tm_groupStack.top().Items.append(ite);\r\n\t\t\t\t\tapplyMask(ite);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\tm_doc->Items->removeAll(ite);\r\n\t\t}\r\n\t\tdelete tempFile;\r\n\t}\r\n\tif (m_inPattern == 0)\r\n\t{\r\n\t\toutline.translate(xCoor - ite->xPos(), yCoor - ite->yPos());\r\n\t\t// Undo the rotation of the clipping path as it is rotated together with the image.\r\n\t\tQTransform mm;\r\n\t\tmm.rotate(-ite->rotation());\r\n\t\toutline = mm.map(outline);\r\n\t\tite->PoLine.fromQPainterPath(outline, true);\r\n\t\tite->setFillEvenOdd(outline.fillRule() == Qt::OddEvenFill);\r\n\t\tite->ClipEdited = true;\r\n\t\tite->FrameType = 3;\r\n\t\tite->setTextFlowMode(PageItem::TextFlowDisabled);\r\n\t\tite->ScaleType   = true;\r\n\t\tm_doc->adjustItemSize(ite);\r\n\t\tite->OldB2 = ite->width();\r\n\t\tite->OldH2 = ite->height();\r\n\t\tite->updateClip();\r\n\t}\r\n}\r\n\r\nvoid SlaOutputDev::beginMarkedContent(const char *name, Object *dictRef)\r\n{\r\n\tmContent mSte;\r\n\tmSte.name = QString(name);\r\n\tmSte.ocgName = \"\";\r\n\tif (m_importerFlags & LoadSavePlugin::lfCreateDoc)\r\n\t{\r\n\t\tif (dictRef->isNull())\r\n\t\t\treturn;\r\n\t\tPOPPLER_CONST_25_02 OCGs *contentConfig = m_catalog->getOptContentConfig();\r\n\t\tOptionalContentGroup *oc;\r\n\t\tif (dictRef->isRef())\r\n\t\t{\r\n\t\t\toc = contentConfig->findOcgByRef(dictRef->getRef());\r\n\t\t\tif (oc)\r\n\t\t\t{\r\n//\t\t\t\tqDebug() << \"Begin OCG Content (Ref) with Name \" << QString(name) << \"Layer\" << UnicodeParsedString(oc->getName());\r\n\t\t\t\tm_doc->setActiveLayer(UnicodeParsedString(oc->getName()));\r\n\t\t\t\tmSte.ocgName = UnicodeParsedString(oc->getName());\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tObject dictObj = dictRef->fetch(m_xref);\r\n\t\t\tif (!dictObj.isDict())\r\n\t\t\t\treturn;\r\n\t\t\tconst Dict* dict = dictObj.getDict();\r\n\t\t\tObject dictType = dict->lookup(\"Type\");\r\n\t\t\tif (dictType.isName(\"OCG\"))\r\n\t\t\t{\r\n\t\t\t\toc = contentConfig->findOcgByRef(dictRef->getRef());\r\n\t\t\t\tif (oc)\r\n\t\t\t\t{\r\n//\t\t\t\t\tqDebug() << \"Begin OCG Content with Name \" << UnicodeParsedString(oc->getName());\r\n\t\t\t\t\tm_doc->setActiveLayer(UnicodeParsedString(oc->getName()));\r\n\t\t\t\t\tmSte.ocgName = UnicodeParsedString(oc->getName());\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tm_mcStack.push(mSte);\r\n}\r\n\r\nvoid SlaOutputDev::beginMarkedContent(const char *name, Dict *properties)\r\n{\r\n//\tqDebug() << \"Begin Marked Content with Name \" << QString(name);\r\n\tQString nam(name);\r\n\tmContent mSte;\r\n\tmSte.name = nam;\r\n\tmSte.ocgName = \"\";\r\n\tm_mcStack.push(mSte);\r\n\tif (m_importerFlags & LoadSavePlugin::lfCreateDoc)\r\n\t{\r\n\t\tif (nam == \"Layer\")\t\t// Handle Adobe Illustrator Layer command\r\n\t\t{\r\n\t\t\tif (layersSetByOCG)\r\n\t\t\t\treturn;\r\n\t\t\tQString lName = QString(\"Layer_%1\").arg(m_layerNum + 1);\r\n\t\t\tObject obj = properties->lookup(\"Title\");\r\n\t\t\tif (obj.isString())\r\n\t\t\t\tlName = QString(obj.getString()->c_str());\r\n\t\t\tfor (const auto& layer : m_doc->Layers)\r\n\t\t\t{\r\n\t\t\t\tif (layer.Name == lName)\r\n\t\t\t\t{\r\n\t\t\t\t\tm_doc->setActiveLayer(lName);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tm_layerNum++;\r\n\t\t\tif (!m_firstLayer)\r\n\t\t\t\tm_currentLayer = m_doc->addLayer(lName, true);\r\n\t\t\tm_firstLayer = false;\r\n\r\n\t\t\tobj = properties->lookup(\"Visible\");\r\n\t\t\tif (obj.isBool())\r\n\t\t\t\tm_doc->setLayerVisible(m_currentLayer, obj.getBool());\r\n\t\t\tobj = properties->lookup(\"Editable\");\r\n\t\t\tif (obj.isBool())\r\n\t\t\t\tm_doc->setLayerLocked(m_currentLayer, !obj.getBool());\r\n\t\t\tobj = properties->lookup(\"Printed\");\r\n\t\t\tif (obj.isBool())\r\n\t\t\t\tm_doc->setLayerPrintable(m_currentLayer, obj.getBool());\r\n\t\t\tobj = properties->lookup(\"Color\");\r\n\t\t\tif (obj.isArray())\r\n\t\t\t{\r\n\t\t\t\tObject obj1;\r\n\t\t\t\tobj1 = obj.arrayGet(0);\r\n\t\t\t\tint r = obj1.getNum() / 256;\r\n\t\t\t\tobj1 = obj.arrayGet(1);\r\n\t\t\t\tint g = obj1.getNum() / 256;\r\n\t\t\t\tobj1 = obj.arrayGet(2);\r\n\t\t\t\tint b = obj1.getNum() / 256;\r\n\t\t\t\tm_doc->setLayerMarker(m_currentLayer, QColor(r, g, b));\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid SlaOutputDev::endMarkedContent(GfxState *state)\r\n{\r\n\tif (m_mcStack.isEmpty())\r\n\t\treturn;\r\n\r\n\tmContent mSte = m_mcStack.pop();\r\n\tif ((m_importerFlags & LoadSavePlugin::lfCreateDoc) == 0)\r\n\t\treturn;\r\n\tif (mSte.name != \"OC\")\r\n\t\treturn;\r\n\r\n\tfor (const auto& layer : m_doc->Layers)\r\n\t{\r\n\t\tif (layer.Name == mSte.ocgName)\r\n\t\t{\r\n\t\t\tm_doc->setActiveLayer(mSte.ocgName);\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid SlaOutputDev::markPoint(const char *name)\r\n{\r\n//\tqDebug() << \"Begin Marked Point with Name \" << QString(name);\r\n}\r\n\r\nvoid SlaOutputDev::markPoint(const char *name, Dict *properties)\r\n{\r\n//\tqDebug() << \"Begin Marked Point with Name \" << QString(name) << \"and Properties\";\r\n\tbeginMarkedContent(name, properties);\r\n}\r\n\r\nvoid SlaOutputDev::updateFont(GfxState *state)\r\n{\r\n\tstd::optional<GfxFontLoc> fontLoc;\r\n\tstd::string fileName;\r\n\tstd::unique_ptr<FoFiTrueType> ff;\r\n\tstd::optional<std::vector<unsigned char>> tmpBuf;\r\n\tGfxFontType fontType;\r\n#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(24, 11, 0)\r\n\tstd::unique_ptr<SlaOutFontFileID> id;\r\n#else\r\n\tSlaOutFontFileID *id;\r\n#endif\r\n\tSplashFontFile *fontFile;\r\n\tSplashFontSrc *fontsrc = nullptr;\r\n\tObject refObj, strObj;\r\n#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(25, 2, 0)\r\n\tstd::vector<int> codeToGID;\r\n#else\r\n\tint *codeToGID = nullptr;\r\n#endif\r\n\tconst double *textMat = nullptr;\r\n\tdouble m11, m12, m21, m22, fontSize;\r\n\tSplashCoord mat[4] = { 1.0, 0.0, 0.0, 1.0 };\r\n\tint n = 0;\r\n\tint faceIndex = 0;\r\n\tSplashCoord matrix[6] = { 1.0, 0.0, 0.0, 1.0, 0.0, 0.0 };\r\n\r\n\tm_font = nullptr;\r\n\r\n\tGfxFont* gfxFont = state->getFont().get();\r\n\tif (!gfxFont)\r\n\t\tgoto err1;\r\n\r\n\tfontType = gfxFont->getType();\r\n\tif (fontType == fontType3)\r\n\t\tgoto err1;\r\n\r\n\t// check the font file cache\r\n#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(24, 11, 0)\r\n\tid = std::make_unique<SlaOutFontFileID>(gfxFont->getID());\r\n\tif ((fontFile = m_fontEngine->getFontFile(*id)))\r\n\t\tid.reset();\r\n#else\r\n\tid = new SlaOutFontFileID(gfxFont->getID());\r\n\tif ((fontFile = m_fontEngine->getFontFile(id)))\r\n\t\tdelete id;\r\n#endif\r\n\telse\r\n\t{\r\n\t\tfontLoc = gfxFont->locateFont(m_xref ? m_xref : m_pdfDoc->getXRef(), nullptr);\r\n\t\tif (!fontLoc)\r\n\t\t{\r\n\t\t\terror(errSyntaxError, -1, \"Couldn't find a font for '{0:s}'\", gfxFont->getName() ? gfxFont->getName()->c_str() : \"(unnamed)\");\r\n\t\t\tgoto err2;\r\n\t\t}\r\n\r\n\t\t// embedded font\r\n\t\tif (fontLoc->locType == gfxFontLocEmbedded)\r\n\t\t{\r\n\t\t\t// if there is an embedded font, read it to memory\r\n\t\t\ttmpBuf = gfxFont->readEmbFontFile(m_xref ? m_xref : m_pdfDoc->getXRef());\r\n\t\t\tif (! tmpBuf)\r\n\t\t\t\tgoto err2;\r\n\r\n\t\t\t// external font\r\n\t\t}\r\n\t\telse\r\n\t\t{ // gfxFontLocExternal\r\n\t\t\tfileName = fontLoc->path;\r\n\t\t\tfontType = fontLoc->fontType;\r\n\t\t}\r\n\r\n\t\tfontsrc = new SplashFontSrc;\r\n\t\tif (!fileName.empty())\r\n\t\t\tfontsrc->setFile(fileName);\r\n\t\telse\r\n\t\t\tfontsrc->setBuf(std::move(tmpBuf.value()));\r\n\r\n\t\t// load the font file\r\n\t\tswitch (fontType) {\r\n\t\tcase fontType1:\r\n#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(24, 11, 0)\r\n\t\t\tif (!(fontFile = m_fontEngine->loadType1Font(std::move(id), fontsrc, (const char**) ((Gfx8BitFont*) gfxFont)->getEncoding(), fontLoc->fontNum)))\r\n\t\t\t{\r\n\t\t\t\terror(errSyntaxError, -1, \"Couldn't create a font for '{0:s}'\", gfxFont->getName() ? gfxFont->getName()->c_str() : \"(unnamed)\");\r\n\t\t\t\tgoto err2;\r\n\t\t\t}\r\n#else\r\n\t\t\tif (!(fontFile = m_fontEngine->loadType1Font(id, fontsrc, (const char **)((Gfx8BitFont *) gfxFont)->getEncoding())))\r\n\t\t\t{\r\n\t\t\t\terror(errSyntaxError, -1, \"Couldn't create a font for '{0:s}'\", gfxFont->getName() ? gfxFont->getName()->c_str() : \"(unnamed)\");\r\n\t\t\t\tgoto err2;\r\n\t\t\t}\r\n#endif\r\n\t\t\tbreak;\r\n\t\tcase fontType1C:\r\n#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(24, 11, 0)\r\n\t\t\tif (!(fontFile = m_fontEngine->loadType1CFont(std::move(id), fontsrc, (const char**) ((Gfx8BitFont*) gfxFont)->getEncoding(), fontLoc->fontNum)))\r\n\t\t\t{\r\n\t\t\t\terror(errSyntaxError, -1, \"Couldn't create a font for '{0:s}'\", gfxFont->getName() ? gfxFont->getName()->c_str() : \"(unnamed)\");\r\n\t\t\t\tgoto err2;\r\n\t\t\t}\r\n#else\r\n\t\t\tif (!(fontFile = m_fontEngine->loadType1CFont(id, fontsrc, (const char **)((Gfx8BitFont *) gfxFont)->getEncoding())))\r\n\t\t\t{\r\n\t\t\t\terror(errSyntaxError, -1, \"Couldn't create a font for '{0:s}'\", gfxFont->getName() ? gfxFont->getName()->c_str() : \"(unnamed)\");\r\n\t\t\t\tgoto err2;\r\n\t\t\t}\r\n#endif\r\n\t\t\tbreak;\r\n\t\tcase fontType1COT:\r\n#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(24, 11, 0)\r\n\t\t\tif (!(fontFile = m_fontEngine->loadOpenTypeT1CFont(std::move(id), fontsrc, (const char **)((Gfx8BitFont *) gfxFont)->getEncoding(), fontLoc->fontNum)))\r\n\t\t\t{\r\n\t\t\t\terror(errSyntaxError, -1, \"Couldn't create a font for '{0:s}'\", gfxFont->getName() ? gfxFont->getName()->c_str() : \"(unnamed)\");\r\n\t\t\t\tgoto err2;\r\n\t\t\t}\r\n#else\r\n\t\t\tif (!(fontFile = m_fontEngine->loadOpenTypeT1CFont(id, fontsrc, (const char **)((Gfx8BitFont *) gfxFont)->getEncoding())))\r\n\t\t\t{\r\n\t\t\t\terror(errSyntaxError, -1, \"Couldn't create a font for '{0:s}'\", gfxFont->getName() ? gfxFont->getName()->c_str() : \"(unnamed)\");\r\n\t\t\t\tgoto err2;\r\n\t\t\t}\r\n#endif\r\n\t\t\tbreak;\r\n\t\tcase fontTrueType:\r\n\t\tcase fontTrueTypeOT:\r\n#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(24, 11, 0)\r\n\t\t\tif (!fileName.empty())\r\n\t\t\t\tff = FoFiTrueType::load(fileName.c_str(), fontLoc->fontNum);\r\n\t\t\telse\r\n\t\t\t\tff = FoFiTrueType::make(fontsrc->buf.data(), fontsrc->buf.size(), fontLoc->fontNum);\r\n#else\r\n\t\t\tif (!fileName.empty())\r\n\t\t\t\tff = FoFiTrueType::load(fileName.c_str());\r\n\t\t\telse\r\n\t\t\t\tff = FoFiTrueType::make(fontsrc->buf.data(), fontsrc->buf.size());\r\n#endif\r\n\t\t\tif (ff)\r\n\t\t\t{\r\n\t\t\t\tcodeToGID = ((Gfx8BitFont*) gfxFont)->getCodeToGIDMap(ff.get());\r\n\t\t\t\tff.reset();\r\n\t\t\t\tn = 256;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(25, 2, 0)\r\n\t\t\t\tcodeToGID.clear();\r\n#else\r\n\t\t\t\tcodeToGID = nullptr;\r\n#endif\r\n\t\t\t\tn = 0;\r\n\t\t\t}\r\n#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(25, 2, 0)\r\n\t\t\tif (!(fontFile = m_fontEngine->loadTrueTypeFont(std::move(id), fontsrc, std::move(codeToGID), fontLoc->fontNum)))\r\n\t\t\t{\r\n\t\t\t\terror(errSyntaxError, -1, \"Couldn't create a font for '{0:s}'\", gfxFont->getName() ? gfxFont->getName()->c_str() : \"(unnamed)\");\r\n\t\t\t\tgoto err2;\r\n\t\t\t}\r\n#elif POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(24, 11, 0)\r\n\t\t\tif (!(fontFile = m_fontEngine->loadTrueTypeFont(std::move(id), fontsrc, codeToGID, n, fontLoc->fontNum)))\r\n\t\t\t{\r\n\t\t\t\terror(errSyntaxError, -1, \"Couldn't create a font for '{0:s}'\", gfxFont->getName() ? gfxFont->getName()->c_str() : \"(unnamed)\");\r\n\t\t\t\tgoto err2;\r\n\t\t\t}\r\n#else\r\n\t\t\tif (!(fontFile = m_fontEngine->loadTrueTypeFont(id, fontsrc, codeToGID, n)))\r\n\t\t\t{\r\n\t\t\t\terror(errSyntaxError, -1, \"Couldn't create a font for '{0:s}'\", gfxFont->getName() ? gfxFont->getName()->c_str() : \"(unnamed)\");\r\n\t\t\t\tgoto err2;\r\n\t\t\t}\r\n#endif\r\n\t\t\tbreak;\r\n\t\tcase fontCIDType0:\r\n\t\tcase fontCIDType0C:\r\n#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(24, 11, 0)\r\n\t\t\tif (!(fontFile = m_fontEngine->loadCIDFont(std::move(id), fontsrc, fontLoc->fontNum)))\r\n\t\t\t{\r\n\t\t\t\terror(errSyntaxError, -1, \"Couldn't create a font for '{0:s}'\", gfxFont->getName() ? gfxFont->getName()->c_str() : \"(unnamed)\");\r\n\t\t\t\tgoto err2;\r\n\t\t\t}\r\n#else\r\n\t\t\tif (!(fontFile = m_fontEngine->loadCIDFont(id, fontsrc)))\r\n\t\t\t{\r\n\t\t\t\terror(errSyntaxError, -1, \"Couldn't create a font for '{0:s}'\", gfxFont->getName() ? gfxFont->getName()->c_str() : \"(unnamed)\");\r\n\t\t\t\tgoto err2;\r\n\t\t\t}\r\n#endif\r\n\t\t\tbreak;\r\n\t\tcase fontCIDType0COT:\r\n#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(25, 2, 0)\r\n\t\t\tif (((GfxCIDFont*) gfxFont)->getCIDToGIDLen() > 0)\r\n\t\t\t{\r\n\t\t\t\tcodeToGID = ((GfxCIDFont*) gfxFont)->getCIDToGID();\r\n\t\t\t\tn = codeToGID.size();\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tcodeToGID.clear();\r\n\t\t\t\tn = 0;\r\n\t\t\t}\r\n#else\r\n\t\t\tif (((GfxCIDFont *) gfxFont)->getCIDToGID())\r\n\t\t\t{\r\n\t\t\t\tn = ((GfxCIDFont *) gfxFont)->getCIDToGIDLen();\r\n\t\t\t\tcodeToGID = (int *) gmallocn(n, sizeof(*codeToGID));\r\n\t\t\t\tmemcpy(codeToGID, ((GfxCIDFont *) gfxFont)->getCIDToGID(), n * sizeof(*codeToGID));\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tcodeToGID = nullptr;\r\n\t\t\t\tn = 0;\r\n\t\t\t}\r\n#endif\r\n#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(25, 2, 0)\r\n\t\t\tif (!(fontFile = m_fontEngine->loadOpenTypeCFFFont(std::move(id), fontsrc, std::move(codeToGID), fontLoc->fontNum)))\r\n\t\t\t{\r\n\t\t\t\terror(errSyntaxError, -1, \"Couldn't create a font for '{0:s}'\",\r\n\t\t\t\t\tgfxFont->getName() ? gfxFont->getName()->c_str() : \"(unnamed)\");\r\n\t\t\t\tgoto err2;\r\n\t\t\t}\r\n#elif POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(24, 11, 0)\r\n\t\t\tif (!(fontFile = m_fontEngine->loadOpenTypeCFFFont(std::move(id), fontsrc, codeToGID, n, fontLoc->fontNum)))\r\n\t\t\t{\r\n\t\t\t\terror(errSyntaxError, -1, \"Couldn't create a font for '{0:s}'\",\r\n\t\t\t\t\tgfxFont->getName() ? gfxFont->getName()->c_str() : \"(unnamed)\");\r\n\t\t\t\tgoto err2;\r\n\t\t\t}\r\n#else\r\n\t\t\tif (!(fontFile = m_fontEngine->loadOpenTypeCFFFont(id, fontsrc, codeToGID, n)))\r\n\t\t\t{\r\n\t\t\t\terror(errSyntaxError, -1, \"Couldn't create a font for '{0:s}'\",\r\n\t\t\t\tgfxFont->getName() ? gfxFont->getName()->c_str() : \"(unnamed)\");\r\n\t\t\t\tgoto err2;\r\n\t\t\t}\r\n#endif\r\n\t\t\tbreak;\r\n\t\tcase fontCIDType2:\r\n\t\tcase fontCIDType2OT:\r\n#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(25, 2, 0)\r\n\t\t\tcodeToGID.clear();\r\n\t\t\tn = 0;\r\n\t\t\tif (((GfxCIDFont*) gfxFont)->getCIDToGIDLen() > 0)\r\n\t\t\t{\r\n\t\t\t\tcodeToGID = ((GfxCIDFont*) gfxFont)->getCIDToGID();\r\n\t\t\t\tn = codeToGID.size();\r\n\t\t\t}\r\n#else\r\n\t\t\tcodeToGID = nullptr;\r\n\t\t\tn = 0;\r\n\t\t\tif (((GfxCIDFont *) gfxFont)->getCIDToGID())\r\n\t\t\t{\r\n\t\t\t\tn = ((GfxCIDFont *) gfxFont)->getCIDToGIDLen();\r\n\t\t\t\tif (n)\r\n\t\t\t\t{\r\n\t\t\t\t\tcodeToGID = (int *)gmallocn(n, sizeof(*codeToGID));\r\n\t\t\t\t\tmemcpy(codeToGID, ((GfxCIDFont *)gfxFont)->getCIDToGID(), n * sizeof(*codeToGID));\r\n\t\t\t\t}\r\n\t\t\t}\r\n#endif\r\n\t\t\telse\r\n\t\t\t{\r\n#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(24, 11, 0)\r\n\t\t\t\tif (!fileName.empty())\r\n\t\t\t\t\tff = FoFiTrueType::load(fileName.c_str(), fontLoc->fontNum);\r\n\t\t\t\telse\r\n\t\t\t\t\tff = FoFiTrueType::make(fontsrc->buf.data(), fontsrc->buf.size(), fontLoc->fontNum);\r\n#else\r\n\t\t\t\tif (!fileName.empty())\r\n\t\t\t\t\tff = FoFiTrueType::load(fileName.c_str());\r\n\t\t\t\telse\r\n\t\t\t\t\tff = FoFiTrueType::make(fontsrc->buf.data(), fontsrc->buf.size());\r\n#endif\r\n\t\t\t\tif (! ff)\r\n\t\t\t\t\tgoto err2;\r\n#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(25, 2, 0)\r\n\t\t\t\tcodeToGID = ((GfxCIDFont*) gfxFont)->getCodeToGIDMap(ff.get());\r\n#else\r\n\t\t\t\tcodeToGID = ((GfxCIDFont*) gfxFont)->getCodeToGIDMap(ff.get(), &n);\r\n#endif\r\n\t\t\t\tff.reset();\r\n\t\t\t}\r\n#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(25, 2, 0)\r\n\t\t\tif (!(fontFile = m_fontEngine->loadTrueTypeFont(std::move(id), fontsrc, std::move(codeToGID), fontLoc->fontNum)))\r\n\t\t\t{\r\n\t\t\t\terror(errSyntaxError, -1, \"Couldn't create a font for '{0:s}'\", gfxFont->getName() ? gfxFont->getName()->c_str() : \"(unnamed)\");\r\n\t\t\t\tgoto err2;\r\n\t\t\t}\r\n#elif POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(24, 11, 0)\r\n\t\t\tif (!(fontFile = m_fontEngine->loadTrueTypeFont(std::move(id), fontsrc, codeToGID, n, fontLoc->fontNum)))\r\n\t\t\t{\r\n\t\t\t\terror(errSyntaxError, -1, \"Couldn't create a font for '{0:s}'\", gfxFont->getName() ? gfxFont->getName()->c_str() : \"(unnamed)\");\r\n\t\t\t\tgoto err2;\r\n\t\t\t}\r\n#else\r\n\t\t\tif (!(fontFile = m_fontEngine->loadTrueTypeFont(id, fontsrc, codeToGID, n, faceIndex)))\r\n\t\t\t{\r\n\t\t\t\terror(errSyntaxError, -1, \"Couldn't create a font for '{0:s}'\", gfxFont->getName() ? gfxFont->getName()->c_str() : \"(unnamed)\");\r\n\t\t\t\tgoto err2;\r\n\t\t\t}\r\n#endif\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\t// this shouldn't happen\r\n\t\t\tgoto err2;\r\n\t\t}\r\n\t}",
    "void SlaOutputDev::createImageFrame(QImage& image, GfxState *state, int numColorComponents)\r\n{\r\n//\tqDebug() << \"SlaOutputDev::createImageFrame\";\r\n\tconst double *ctm = state->getCTM();\r\n\tdouble xCoor = m_doc->currentPage()->xOffset();\r\n\tdouble yCoor = m_doc->currentPage()->yOffset();\r\n\r\n\tm_ctm = QTransform(ctm[0], ctm[1], ctm[2], ctm[3], ctm[4], ctm[5]);\r\n\tdouble angle = m_ctm.map(QLineF(0, 0, 1, 0)).angle();\r\n\tQPointF torigin;\r\n\t// In PDF all images considered squares with unit length that are transformed into the proper\r\n\t// dimensions by ctm.\r\n\t// A positive determinant retains orientation. Thus orientation is the same as in the PDF\r\n\t// coordinate system (y-axis increases upwards). As Scribus uses the inverse orientation the\r\n\t// image needs to be flipped (a horizontal flip is applied later).  For a flipped image the\r\n\t// corner that will be origin in Scribus is the upper right corner (1, 1) of the image.\r\n\t// A negative determinant changes the orientation such that the image is already in the Scribus\r\n\t// coordinate orientation and no flip is necessary. The origin will be the upper left corner (0, 1).\r\n\tif (m_ctm.determinant() > 0) {\r\n\t\ttorigin = m_ctm.map(QPointF(1, 1));\r\n\t} else {\r\n\t\ttorigin = m_ctm.map(QPointF(0, 1));\r\n\t}\r\n\r\n\t// Determine the visible area of the picture after clipping it. If it is empty, no item\r\n\t// needs to be created.\r\n\tQPainterPath outline;\r\n\toutline.addRect(0, 0, 1, 1);\r\n\toutline = m_ctm.map(outline);\r\n\toutline = intersection(outline, m_graphicStack.top().clipPath);\r\n\r\n\tif ((m_inPattern == 0) && (outline.isEmpty() || outline.boundingRect().isNull()))\r\n\t\treturn;\r\n\r\n    // Determine the width and height of the image by undoing the rotation part\r\n\t// of the CTM and applying the result to the unit square.\r\n\tQTransform without_rotation;\r\n\twithout_rotation = m_ctm * without_rotation.rotate(angle);\r\n\tQRectF trect_wr = without_rotation.mapRect(QRectF(0, 0, 1, 1));\r\n\r\n\tint z = m_doc->itemAdd(PageItem::ImageFrame, PageItem::Rectangle, xCoor + torigin.x(), yCoor + torigin.y(), trect_wr.width(), trect_wr.height(), 0, CommonStrings::None, CommonStrings::None);\r\n\tPageItem* ite = m_doc->Items->at(z);\r\n\tite->ClipEdited = true;\r\n\tite->FrameType = 3;\r\n\tm_doc->setRedrawBounding(ite);\r\n\tite->Clip = flattenPath(ite->PoLine, ite->Segments);\r\n\tite->setTextFlowMode(PageItem::TextFlowDisabled);\r\n\tite->setFillShade(100);\r\n\tite->setLineShade(100);\r\n\tite->setFillEvenOdd(false);\r\n\tite->setFillTransparency(1.0 - state->getFillOpacity());\r\n\tite->setFillBlendmode(getBlendMode(state));\r\n\tif (m_ctm.determinant() > 0)\r\n\t{\r\n\t\tite->setRotation(-(angle - 180));\r\n\t\tite->setImageFlippedH(true);\r\n\t}\r\n\telse\r\n\t\tite->setRotation(-angle);\r\n\tm_doc->adjustItemSize(ite);\r\n\r\n\tif (numColorComponents == 4)\r\n\t{\r\n\t\tauto *tempFile = new QTemporaryFile(QDir::tempPath() + \"/scribus_temp_pdf_XXXXXX.tif\");\r\n\t\ttempFile->setAutoRemove(false);\r\n\t\tif (tempFile->open())\r\n\t\t{\r\n\t\t\tQString fileName = getLongPathName(tempFile->fileName());\r\n\t\t\tif (!fileName.isEmpty())\r\n\t\t\t{\r\n\t\t\t\ttempFile->close();\r\n\t\t\t\tite->isInlineImage = true;\r\n\t\t\t\tite->isTempFile = true;\r\n\t\t\t\tite->AspectRatio = false;\r\n\t\t\t\tite->ScaleType   = false;\r\n\t\t\t\tTIFF* tif = TIFFOpen(fileName.toLocal8Bit().data(), \"w\");\r\n\t\t\t\tif (tif)\r\n\t\t\t\t{\r\n\t\t\t\t\tTIFFSetField(tif, TIFFTAG_IMAGEWIDTH, image.width());\r\n\t\t\t\t\tTIFFSetField(tif, TIFFTAG_IMAGELENGTH, image.height());\r\n\t\t\t\t\tTIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8);\r\n\t\t\t\t\tTIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 4);\r\n\t\t\t\t\tTIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\r\n\t\t\t\t\tTIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_SEPARATED);\r\n\t\t\t\t\tTIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_LZW);\r\n\t\t\t\t\tfor (int y = 0; y < image.height(); ++y)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tTIFFWriteScanline(tif, image.scanLine(y), y);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tTIFFClose(tif);\r\n\t\t\t\t\tm_doc->loadPict(fileName, ite);\r\n\t\t\t\t}\r\n\t\t\t\tm_Elements->append(ite);\r\n\t\t\t\tif (m_groupStack.count() != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tm_groupStack.top().Items.append(ite);\r\n\t\t\t\t\tapplyMask(ite);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\tm_doc->Items->removeAll(ite);\r\n\t\t}\r\n\t\tdelete tempFile;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tauto *tempFile = new QTemporaryFile(QDir::tempPath() + \"/scribus_temp_pdf_XXXXXX.png\");\r\n\t\ttempFile->setAutoRemove(false);\r\n\t\tif (tempFile->open())\r\n\t\t{\r\n\t\t\tQString fileName = getLongPathName(tempFile->fileName());\r\n\t\t\tif (!fileName.isEmpty())\r\n\t\t\t{\r\n\t\t\t\ttempFile->close();\r\n\t\t\t\tite->isInlineImage = true;\r\n\t\t\t\tite->isTempFile = true;\r\n\t\t\t\tite->AspectRatio = false;\r\n\t\t\t\tite->ScaleType   = false;\r\n\t\t\t\timage.save(fileName, \"PNG\");\r\n\t\t\t\tm_doc->loadPict(fileName, ite);\r\n\t\t\t\tm_Elements->append(ite);\r\n\t\t\t\tif (m_groupStack.count() != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tm_groupStack.top().Items.append(ite);\r\n\t\t\t\t\tapplyMask(ite);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\tm_doc->Items->removeAll(ite);\r\n\t\t}\r\n\t\tdelete tempFile;\r\n\t}\r\n\tif (m_inPattern == 0)\r\n\t{\r\n\t\toutline.translate(xCoor - ite->xPos(), yCoor - ite->yPos());\r\n\t\t// Undo the rotation of the clipping path as it is rotated together with the image.\r\n\t\tQTransform mm;\r\n\t\tmm.rotate(-ite->rotation());\r\n\t\toutline = mm.map(outline);\r\n\t\tite->PoLine.fromQPainterPath(outline, true);\r\n\t\tite->setFillEvenOdd(outline.fillRule() == Qt::OddEvenFill);\r\n\t\tite->ClipEdited = true;\r\n\t\tite->FrameType = 3;\r\n\t\tite->setTextFlowMode(PageItem::TextFlowDisabled);\r\n\t\tite->ScaleType   = true;\r\n\t\tm_doc->adjustItemSize(ite);\r\n\t\tite->OldB2 = ite->width();\r\n\t\tite->OldH2 = ite->height();\r\n\t\tite->updateClip();\r\n\t}\r\n}",
    "static bool TiffIff_write_f(const Img4f* img, const char* fileName,\n                                const TwkMath::Mat44f* Mcamera,\n                                const TwkMath::Mat44f* Mscreen, const int depth)\n    {\n        if (depth != 8 && depth != 16 && depth != 32)\n        {\n            string errmsg = \"Unable to write bit depth: \" + depth;\n            IffExc exc(errmsg.c_str());\n            throw(exc);\n        }\n\n        TIFF* tif = TIFFOpen(fileName, \"w\");\n        if (tif == NULL)\n        {\n            IffExc exc(\"Could not open specified image file for writing\");\n            throw(exc);\n        }\n\n        TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, img->width());\n        TIFFSetField(tif, TIFFTAG_IMAGELENGTH, img->height());\n        TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 4);\n        TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, depth);\n        TIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n        TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n        TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n        TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_PACKBITS);\n\n        if (Mcamera != NULL)\n        {\n            TIFFSetField(tif, TIFFTAG_CAMERA_MATRIX, (uint16)16,\n                         (const float*)Mcamera);\n        }\n        if (Mscreen != NULL)\n        {\n            TIFFSetField(tif, TIFFTAG_SCREEN_MATRIX, (uint16)16,\n                         (const float*)Mscreen);\n        }\n\n        char hostname[64];\n        gethostname(hostname, 64);\n        TIFFSetField(tif, TIFFTAG_HOSTCOMPUTER, hostname);\n\n        switch (depth)\n        {\n        case 32:\n            TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);\n            break;\n        case 16:\n            TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT);\n            break;\n        case 8:\n            TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT);\n            break;\n        default:\n            break;\n        }\n        uint16 extrasamples = 1;\n        uint16 sampleinfo[1] = {EXTRASAMPLE_ASSOCALPHA};\n        TIFFSetField(tif, TIFFTAG_EXTRASAMPLES, extrasamples, sampleinfo);\n\n        tdata_t buf = _TIFFmalloc(TIFFScanlineSize(tif));\n\n        switch (depth)\n        {\n        case 8:\n            for (int y = 0; y < img->height(); ++y)\n            {\n                Col4uc* dstPixel = (Col4uc*)buf;\n                const Col4f* srcPixel = (*img)[img->height() - y - 1];\n\n                for (int x = 0; x < img->width(); ++x, dstPixel++, ++srcPixel)\n                {\n                    (*dstPixel).x = (unsigned char)(TwkMath::clamp(\n                        (*srcPixel).x * 255.0f, 0.0f, 255.0f));\n                    (*dstPixel).y = (unsigned char)(TwkMath::clamp(\n                        (*srcPixel).y * 255.0f, 0.0f, 255.0f));\n                    (*dstPixel).z = (unsigned char)(TwkMath::clamp(\n                        (*srcPixel).z * 255.0f, 0.0f, 255.0f));\n                    (*dstPixel).w = (unsigned char)(TwkMath::clamp(\n                        (*srcPixel).w * 255.0f, 0.0f, 255.0f));\n                }\n                if (TIFFWriteScanline(tif, buf, y, 0) == -1)\n                {\n                    IffExc exc(\"Error while writing TIFF scanline\");\n                    throw(exc);\n                }\n            }\n            break;\n        case 16:\n            for (int y = 0; y < img->height(); ++y)\n            {\n                Col4us* dstPixel = (Col4us*)buf;\n                const Col4f* srcPixel = (*img)[img->height() - y - 1];\n\n                for (int x = 0; x < img->width(); ++x, dstPixel++, ++srcPixel)\n                {\n                    (*dstPixel).x = (unsigned short)(TwkMath::clamp(\n                        (*srcPixel).x * 65535.0f, 0.0f, 65535.0f));\n                    (*dstPixel).y = (unsigned short)(TwkMath::clamp(\n                        (*srcPixel).y * 65535.0f, 0.0f, 65535.0f));\n                    (*dstPixel).z = (unsigned short)(TwkMath::clamp(\n                        (*srcPixel).z * 65535.0f, 0.0f, 65535.0f));\n                    (*dstPixel).w = (unsigned short)(TwkMath::clamp(\n                        (*srcPixel).w * 65535.0f, 0.0f, 65535.0f));\n                }\n                if (TIFFWriteScanline(tif, buf, y, 0) == -1)\n                {\n                    IffExc exc(\"Error while writing TIFF scanline\");\n                    throw(exc);\n                }\n            }\n            break;\n        case 32:\n            for (int y = 0; y < img->height(); ++y)\n            {\n                Col4f* srcPixel = (Col4f*)(*img)[img->height() - y - 1];\n                if (TIFFWriteScanline(tif, srcPixel, y, 0) == -1)\n                {\n                    IffExc exc(\"Error while writing TIFF scanline\");\n                    throw(exc);\n                }\n            }\n            break;\n        }\n\n        _TIFFfree(buf);\n\n        TIFFClose(tif);\n\n        return true;\n    }",
    "static bool TiffIff_write_uc(const Img4uc* img, const char* fileName,\n                                 const Mat44f* Mcamera, const Mat44f* Mscreen)\n    {\n        TIFF* tif = TIFFOpen(fileName, \"w\");\n        if (tif == NULL)\n        {\n            IffExc exc(\"Could not open specified image file for writing\");\n            throw(exc);\n        }\n\n        TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, img->width());\n        TIFFSetField(tif, TIFFTAG_IMAGELENGTH, img->height());\n        TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 4);\n        TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8);\n        TIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n        TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n        TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n        TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_PACKBITS);\n        TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT);\n\n        if (Mcamera != NULL)\n        {\n            TIFFSetField(tif, TIFFTAG_CAMERA_MATRIX, (uint16)16,\n                         (const float*)Mcamera);\n        }\n        if (Mscreen != NULL)\n        {\n            TIFFSetField(tif, TIFFTAG_SCREEN_MATRIX, (uint16)16,\n                         (const float*)Mscreen);\n        }\n\n        char hostname[64];\n        gethostname(hostname, 64);\n        TIFFSetField(tif, TIFFTAG_HOSTCOMPUTER, hostname);\n\n        uint16 extrasamples = 1;\n        uint16 sampleinfo[1] = {EXTRASAMPLE_ASSOCALPHA};\n        TIFFSetField(tif, TIFFTAG_EXTRASAMPLES, extrasamples, sampleinfo);\n\n        tdata_t buf = _TIFFmalloc(TIFFScanlineSize(tif));\n\n        for (int y = 0; y < img->height(); ++y)\n        {\n            Col4uc* srcPixel = (Col4uc*)(*img)[img->height() - y - 1];\n            if (TIFFWriteScanline(tif, srcPixel, y, 0) == -1)\n            {\n                IffExc exc(\"Error while writing TIFF scanline\");\n                throw(exc);\n            }\n        }\n\n        _TIFFfree(buf);\n\n        TIFFClose(tif);\n\n        return true;\n    }",
    "static bool TiffIff_write_us(const Img4us* img, const char* fileName,\n                                 const Mat44f* Mcamera, const Mat44f* Mscreen)\n    {\n        TIFF* tif = TIFFOpen(fileName, \"w\");\n        if (tif == NULL)\n        {\n            IffExc exc(\"Could not open specified image file for writing\");\n            throw(exc);\n        }\n\n        TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, img->width());\n        TIFFSetField(tif, TIFFTAG_IMAGELENGTH, img->height());\n        TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 4);\n        TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 16);\n        TIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n        TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n        TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n        TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_PACKBITS);\n        TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT);\n\n        if (Mcamera != NULL)\n        {\n            TIFFSetField(tif, TIFFTAG_CAMERA_MATRIX, (uint16)16,\n                         (const float*)Mcamera);\n        }\n        if (Mscreen != NULL)\n        {\n            TIFFSetField(tif, TIFFTAG_SCREEN_MATRIX, (uint16)16,\n                         (const float*)Mscreen);\n        }\n\n        char hostname[64];\n        gethostname(hostname, 64);\n        TIFFSetField(tif, TIFFTAG_HOSTCOMPUTER, hostname);\n\n        uint16 extrasamples = 1;\n        uint16 sampleinfo[1] = {EXTRASAMPLE_ASSOCALPHA};\n        TIFFSetField(tif, TIFFTAG_EXTRASAMPLES, extrasamples, sampleinfo);\n\n        tdata_t buf = _TIFFmalloc(TIFFScanlineSize(tif));\n\n        for (int y = 0; y < img->height(); ++y)\n        {\n            Col4us* srcPixel = (Col4us*)(*img)[img->height() - y - 1];\n            if (TIFFWriteScanline(tif, srcPixel, y, 0) == -1)\n            {\n                IffExc exc(\"Error while writing TIFF scanline\");\n                throw(exc);\n            }\n        }\n\n        _TIFFfree(buf);\n\n        TIFFClose(tif);\n\n        return true;\n    }",
    "absl::Status TiffWriter::Context::WriteImage(\n    const ImageInfo& info, tensorstore::span<const unsigned char> source) {\n  image_number++;\n  if (image_number > 0) {\n    return absl::UnknownError(\n        \"Failed to write TIFF file; multi-page write support incomplete\");\n  }\n\n  TIFFSetField(tiff_, TIFFTAG_IMAGEWIDTH, info.width);\n  TIFFSetField(tiff_, TIFFTAG_IMAGELENGTH, info.height);\n  TIFFSetField(tiff_, TIFFTAG_BITSPERSAMPLE, info.dtype.size() * 8);\n  TIFFSetField(tiff_, TIFFTAG_SAMPLESPERPIXEL, info.num_components);\n\n  if (info.num_components == 3 || info.num_components == 4) {\n    TIFFSetField(tiff_, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n  } else {\n    // Grayscale, black is 0\n    TIFFSetField(tiff_, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n  }\n\n  // TODO: extra samples?\n  // TODO: Compression config.\n  // TODO: Orientation\n  TIFFSetField(tiff_, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n  TIFFSetField(tiff_, TIFFTAG_ROWSPERSTRIP, 1);\n  TIFFSetField(tiff_, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n  TIFFSetField(tiff_, TIFFTAG_SOFTWARE, \"tensorstore\");\n\n  // This assumes that no conversion is required.\n  ImageView view = MakeWriteImageView(info, source);\n  for (int row = 0; row < info.height; ++row) {\n    if (!TIFFWriteScanline(tiff_, view.data_row(row).data(), row, 0)) {\n      error_.Update(absl::InvalidArgumentError(\"Failed to write scanline\"));\n      return ExtractErrors();\n    }\n  }\n\n  if (TIFFWriteDirectory(tiff_) == 0) {\n    error_.Update(absl::InvalidArgumentError(\"Failed to write directory\"));\n  }\n  return ExtractErrors();\n}",
    "bool KisTIFFWriterVisitor::saveLayerProjection(KisLayer *layer)\n{\n    dbgFile << \"visiting on layer\" << layer->name() << \"\";\n    KisPaintDeviceSP pd = layer->projection();\n\n    uint16_t color_type = 0;\n    uint16_t sample_format = SAMPLEFORMAT_UINT;\n    const KoColorSpace *destColorSpace = nullptr;\n    // Check colorspace\n    if (!writeColorSpaceInformation(image(), pd->colorSpace(), color_type, sample_format, destColorSpace)) { // unsupported colorspace\n        if (!destColorSpace) {\n            return false;\n        }\n        pd.attach(new KisPaintDevice(*pd));\n        pd->convertTo(destColorSpace);\n    }\n\n    {\n        // WORKAROUND: block any attempts to use YCbCr with alpha channels.\n        // This should not happen because alpha is disabled by default\n        // and the checkbox is blocked for YCbCr and CMYK.\n        KIS_SAFE_ASSERT_RECOVER(color_type != PHOTOMETRIC_YCBCR\n                                || !m_options->alpha)\n        {\n            warnFile << \"TIFF does not support exporting alpha channels with \"\n                        \"YCbCr. Skipping...\";\n            m_options->alpha = false;\n        }\n    }\n\n    // Save depth\n    uint32_t depth = 8 * pd->pixelSize() / pd->channelCount();\n    TIFFSetField(image(), TIFFTAG_BITSPERSAMPLE, depth);\n\n    {\n        // WORKAROUND: block any attempts to use JPEG with >= 8 bits\n\n        if (m_options->compressionType == COMPRESSION_JPEG && depth != 8) {\n            warnFile << \"Attempt to export JPEG with multi-byte depth, \"\n                        \"disabling compression\";\n            m_options->compressionType = COMPRESSION_NONE;\n        }\n    }\n\n    // Save number of samples\n    if (m_options->alpha) {\n        TIFFSetField(image(), TIFFTAG_SAMPLESPERPIXEL, pd->channelCount());\n        const std::array<uint16_t, 1> sampleinfo = {EXTRASAMPLE_UNASSALPHA};\n        TIFFSetField(image(), TIFFTAG_EXTRASAMPLES, 1, sampleinfo.data());\n    } else {\n        TIFFSetField(image(), TIFFTAG_SAMPLESPERPIXEL, pd->channelCount() - 1);\n        TIFFSetField(image(), TIFFTAG_EXTRASAMPLES, 0);\n    }\n\n    // Save colorspace information\n    TIFFSetField(image(), TIFFTAG_PHOTOMETRIC, color_type);\n    TIFFSetField(image(), TIFFTAG_SAMPLEFORMAT, sample_format);\n    TIFFSetField(image(), TIFFTAG_IMAGEWIDTH, layer->image()->width());\n    TIFFSetField(image(), TIFFTAG_IMAGELENGTH, layer->image()->height());\n\n    // Set the compression options\n    TIFFSetField(image(), TIFFTAG_COMPRESSION, m_options->compressionType);\n    if (m_options->compressionType == COMPRESSION_JPEG) {\n        TIFFSetField(image(), TIFFTAG_JPEGQUALITY, m_options->jpegQuality);\n    } else if (m_options->compressionType == COMPRESSION_ADOBE_DEFLATE) {\n        TIFFSetField(image(), TIFFTAG_ZIPQUALITY, m_options->deflateCompress);\n    } else if (m_options->compressionType == COMPRESSION_PIXARLOG) {\n        TIFFSetField(image(),\n                     TIFFTAG_PIXARLOGQUALITY,\n                     m_options->pixarLogCompress);\n    }\n\n    // Set the predictor\n    if (m_options->compressionType == COMPRESSION_LZW\n        || m_options->compressionType == COMPRESSION_ADOBE_DEFLATE)\n        TIFFSetField(image(), TIFFTAG_PREDICTOR, m_options->predictor);\n\n    // Use contiguous configuration\n    TIFFSetField(image(), TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\n    // Do not set the rowsperstrip, as it's incompatible with JPEG\n\n    // But do set YCbCr 4:4:4 if applicable\n    if (color_type == PHOTOMETRIC_YCBCR) {\n        TIFFSetField(image(), TIFFTAG_YCBCRSUBSAMPLING, 1, 1);\n        TIFFSetField(image(), TIFFTAG_YCBCRPOSITIONING, YCBCRPOSITION_CENTERED);\n        if (m_options->compressionType == COMPRESSION_JPEG) {\n            TIFFSetField(image(), TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RAW);\n        }\n    }\n\n    // Save profile\n    if (m_options->saveProfile) {\n        const KoColorProfile* profile = pd->colorSpace()->profile();\n        if (profile && profile->type() == \"icc\" && !profile->rawData().isEmpty()) {\n            QByteArray ba = profile->rawData();\n            TIFFSetField(image(), TIFFTAG_ICCPROFILE, ba.size(), ba.constData());\n        }\n    }\n\n    {\n        // IPTC\n        KisMetaData::IOBackend *io =\n            KisMetadataBackendRegistry::instance()->value(\"iptc\");\n        QBuffer buf;\n        io->saveTo(layer->metaData(), &buf, KisMetaData::IOBackend::NoHeader);\n\n        if (buf.size()\n            && !TIFFSetField(image(),\n                             TIFFTAG_RICHTIFFIPTC,\n                             static_cast<uint32_t>(buf.size()),\n                             buf.data().data())) {\n            dbgFile << \"Failed to write the IPTC metadata to the TIFF field\";\n        }\n    }\n\n    {\n        // XMP\n        KisMetaData::IOBackend *io =\n            KisMetadataBackendRegistry::instance()->value(\"xmp\");\n        QBuffer buf;\n        io->saveTo(layer->metaData(), &buf, KisMetaData::IOBackend::NoHeader);\n\n        if (buf.size()\n            && !TIFFSetField(image(),\n                             TIFFTAG_XMLPACKET,\n                             static_cast<uint32_t>(buf.size()),\n                             buf.data().data())) {\n            dbgFile << \"Failed to write the XMP metadata to the TIFF field\";\n        }\n    }\n\n    tsize_t stripsize = TIFFStripSize(image());\n    std::unique_ptr<std::remove_pointer_t<tdata_t>, decltype(&_TIFFfree)> buff(\n        _TIFFmalloc(stripsize),\n        &_TIFFfree);\n    KIS_ASSERT_RECOVER_RETURN_VALUE(\n        buff && \"Unable to allocate buffer for TIFF!\",\n        false);\n    qint32 height = layer->image()->height();\n    qint32 width = layer->image()->width();\n    bool r = true;\n    for (int y = 0; y < height; y++) {\n        KisHLineConstIteratorSP it = pd->createHLineConstIteratorNG(0, y, width);\n        switch (color_type) {\n        case PHOTOMETRIC_MINISBLACK: {\n            const std::array<quint8, 5> poses = {0, 1};\n            r = copyDataToStrips(it,\n                                 buff.get(),\n                                 depth,\n                                 sample_format,\n                                 1,\n                                 poses);\n            }\n            break;\n        case PHOTOMETRIC_RGB: {\n            const auto poses = [&]() -> std::array<quint8, 5> {\n                if (sample_format == SAMPLEFORMAT_IEEEFP) {\n                    return {0, 1, 2, 3};\n                } else {\n                    return {2, 1, 0, 3};\n                }\n            }();\n            r = copyDataToStrips(it,\n                                 buff.get(),\n                                 depth,\n                                 sample_format,\n                                 3,\n                                 poses);\n            }\n            break;\n        case PHOTOMETRIC_SEPARATED: {\n            const std::array<quint8, 5> poses = {0, 1, 2, 3, 4};\n            r = copyDataToStrips(it,\n                                 buff.get(),\n                                 depth,\n                                 sample_format,\n                                 4,\n                                 poses);\n            }\n            break;\n            case PHOTOMETRIC_ICCLAB:\n            case PHOTOMETRIC_YCBCR: {\n                const std::array<quint8, 5> poses = {0, 1, 2, 3};\n                r = copyDataToStrips(it,\n                                     buff.get(),\n                                     depth,\n                                     sample_format,\n                                     3,\n                                     poses);\n            } break;\n        }\n        if (!r) return false;\n        TIFFWriteScanline(image(),\n                          buff.get(),\n                          static_cast<uint32_t>(y),\n                          (tsample_t)-1);\n    }\n    buff.reset();\n\n    return TIFFWriteDirectory(image());\n}",
    "int DiTIFFPlugin::write(\n  DiImage *image,\n  FILE *stream,\n  const unsigned long frame) const\n{\n  int result = 0;\n  if ((image != NULL) && (stream != NULL))\n  {\n    int stream_fd = fileno(stream);\n\n\n#ifdef _WIN32\n\n    /* On Windows, TIFFFdOpen() expects a Windows HANDLE (which is a pointer\n     * type) instead of a file descriptor, but passes the file descriptor as an\n     * int.  Despite HANDLE being a 64-bit type on Win64 and int being 32-bit,\n     * this is apparently safe, because Win64 guarantees to only use 32-bit\n     * handles, for interoperability reasons, as documented here:\n     *\n     *   https://docs.microsoft.com/en-us/windows/win32/winprog64/interprocess-communication\n     *\n     * Therefore, we use _get_osfhandle() to access the HANDLE underlying the\n     * file descriptor.\n     */\n\n#ifdef __CYGWIN__\n    stream_fd = OFstatic_cast(int, get_osfhandle(stream_fd));\n#else\n    stream_fd = OFstatic_cast(int, _get_osfhandle(stream_fd));\n#endif\n\n#endif /* _WIN32 */\n\n    /* create bitmap with 8 bits per sample */\n    void *data = OFconst_cast(void *, image->getOutputData(frame, 8 /*bits*/, 0 /*planar*/));\n    if (data != NULL)\n    {\n      OFBool isMono = (image->getInternalColorModel() == EPI_Monochrome1) || (image->getInternalColorModel() == EPI_Monochrome2);\n      Uint16 rows = image->getRows();\n      Uint16 cols = image->getColumns();\n\n      short photometric = isMono ? PHOTOMETRIC_MINISBLACK : PHOTOMETRIC_RGB;\n      short samplesperpixel = isMono ? 1 : 3;\n      unsigned long bytesperrow = cols * samplesperpixel;\n      if (bytesperrow > 0)\n      {\n        short opt_predictor = 0;\n        switch (predictor)\n        {\n          case E_tiffLZWPredictorDefault:\n            opt_predictor = 0;\n            break;\n          case E_tiffLZWPredictorNoPrediction:\n            opt_predictor = 1;\n            break;\n          case E_tiffLZWPredictorHDifferencing:\n            opt_predictor = 2;\n            break;\n        }\n\n        unsigned short opt_compression = COMPRESSION_NONE;\n        switch (compressionType)\n        {\n          case E_tiffLZWCompression:\n            opt_compression = COMPRESSION_LZW;\n            break;\n          case E_tiffPackBitsCompression:\n            opt_compression = COMPRESSION_PACKBITS;\n            break;\n          case E_tiffNoCompression:\n            opt_compression = COMPRESSION_NONE;\n            break;\n        }\n\n        long opt_rowsperstrip = OFstatic_cast(long, rowsPerStrip);\n        if (opt_rowsperstrip <= 0) opt_rowsperstrip = 8192 / bytesperrow;\n        if (opt_rowsperstrip == 0) opt_rowsperstrip++;\n\n        OFBool OK = OFTrue;\n        unsigned char *bytedata = OFstatic_cast(unsigned char *, data);\n        TIFF *tif = TIFFFdOpen(stream_fd, \"TIFF\", \"w\");\n        if (tif)\n        {\n          /* Set TIFF parameters. */\n          TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, cols);\n          TIFFSetField(tif, TIFFTAG_IMAGELENGTH, rows);\n          TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8);\n          TIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n          TIFFSetField(tif, TIFFTAG_COMPRESSION, opt_compression);\n          if (opt_compression == COMPRESSION_LZW && opt_predictor != 0)\n          TIFFSetField(tif, TIFFTAG_PREDICTOR, opt_predictor);\n          TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, photometric);\n          TIFFSetField(tif, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);\n          TIFFSetField(tif, TIFFTAG_DOCUMENTNAME, \"unnamed\");\n          TIFFSetField(tif, TIFFTAG_IMAGEDESCRIPTION, \"Converted DICOM Image\");\n          TIFFSetField(tif, TIFFTAG_SOFTWARE, \"OFFIS DCMTK \" OFFIS_DCMTK_VERSION);\n          TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, samplesperpixel);\n          TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, opt_rowsperstrip);\n          /* TIFFSetField(tif, TIFFTAG_STRIPBYTECOUNTS, rows / opt_rowsperstrip); */\n          TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\n          /* Now write the TIFF data. */\n          unsigned long offset = 0;\n          for (Uint16 i=0; (i < rows) && OK; i++)\n          {\n            if (TIFFWriteScanline(tif, bytedata + offset, i, 0) < 0) OK = OFFalse;\n            offset += bytesperrow;\n          }\n          TIFFFlushData(tif);\n\n          /* Clean up internal structures and free memory.\n           * However, the file will be closed by the caller, therefore\n           * TIFFClose() is not called.\n           */\n          TIFFCleanup(tif);\n        }\n        if (OK) result = 1;\n      }\n    }\n\n    /* delete pixel data */\n    image->deleteOutputData();\n  }\n  return result;\n}",
    "bool saveImageLibTiff(const std::string& path, const Image& img)\n{\n    TIFFSetWarningHandler(nullptr);\n    TIFFSetWarningHandlerExt(nullptr);\n\n    TIFF* tif = TIFFOpen(path.c_str(), \"w\");\n    if (!tif) return false;\n\n    uint32_t width  = img.width;\n    uint32_t height = img.height;\n\n    // Get the image width and height\n    if (!TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, width))\n    {\n        return false;\n    }\n    if (!TIFFSetField(tif, TIFFTAG_IMAGELENGTH, height))\n    {\n        return false;\n    }\n\n\n    uint16_t bitspersample = 0, sample_format = SAMPLEFORMAT_UINT;\n    uint16_t samples = 1;\n    switch (img.type)\n    {\n        case ImageType::UC1:\n            sample_format = SAMPLEFORMAT_UINT;\n            bitspersample = 8;\n            break;\n        case ImageType::US1:\n            sample_format = SAMPLEFORMAT_UINT;\n            bitspersample = 16;\n            break;\n        case ImageType::F1:\n            sample_format = SAMPLEFORMAT_IEEEFP;\n            bitspersample = 32;\n            break;\n        default:\n            return false;\n    }\n\n\n    if (!TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, bitspersample))\n    {\n        return false;\n    }\n\n    // These tags might actually be not present. In these cases the default values are used.\n    if (!TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, sample_format))\n    {\n        return false;\n    }\n    if (!TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, samples))\n    {\n        return false;\n    }\n\n\n    for (uint32_t row = 0; row < height; ++row)\n    {\n        TIFFWriteScanline(tif, const_cast<void*>(img.rowPtr(row)), row);\n    }\n\n    TIFFClose(tif);\n\n    return true;\n}",
    "FrameCaptureOutputResult TiffFrameCaptureOutput(\n            const AZStd::string& outputFilePath, const AZ::RPI::AttachmentReadback::ReadbackResult& readbackResult)\n        {\n            AZStd::shared_ptr<AZStd::vector<uint8_t>> buffer = readbackResult.m_dataBuffer;\n            const uint32_t width = readbackResult.m_imageDescriptor.m_size.m_width;\n            const uint32_t height = readbackResult.m_imageDescriptor.m_size.m_height;\n            const uint32_t numChannels = AZ::RHI::GetFormatComponentCount(readbackResult.m_imageDescriptor.m_format);\n            const uint32_t bytesPerChannel = AZ::RHI::GetFormatSize(readbackResult.m_imageDescriptor.m_format) / numChannels;\n            const uint32_t bitsPerChannel = bytesPerChannel * 8;\n\n            TIFF* out = TIFFOpen(outputFilePath.c_str(), \"w\");\n            TIFFSetField(out, TIFFTAG_IMAGEWIDTH, width);\n            TIFFSetField(out, TIFFTAG_IMAGELENGTH, height);\n            TIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, numChannels);\n            TIFFSetField(out, TIFFTAG_BITSPERSAMPLE, bitsPerChannel);\n            TIFFSetField(out, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n            TIFFSetField(out, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n            TIFFSetField(out, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n            TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n            TIFFSetField(out, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);   // interpret each pixel as a float\n\n            size_t pitch = width * numChannels * bytesPerChannel;\n            AZ_Assert((pitch * height) == buffer->size(), \"Image buffer does not match allocated bytes for tiff saving.\")\n            unsigned char* raster = (unsigned char*)_TIFFmalloc((tsize_t)(pitch * height));\n            memcpy(raster, buffer->data(), pitch * height);\n            bool success = true;\n            for (uint32_t h = 0; h < height; ++h)\n            {\n                size_t offset = h * pitch;\n                int err = TIFFWriteScanline(out, raster + offset, h, 0);\n                if (err < 0)\n                {\n                    success = false;\n                    break;\n                }\n            }\n            _TIFFfree(raster);\n            TIFFClose(out);\n            return success ? FrameCaptureOutputResult{ FrameCaptureResult::Success, AZStd::nullopt }\n                           : FrameCaptureOutputResult{ FrameCaptureResult::InternalError, \"Unable to save tif frame capture output to \" + outputFilePath };\n        }",
    "void write2D(std::string const& path, float* texture, int width, int height, int components) {\n  auto* tiff = TIFFOpen(path.c_str(), \"w\");\n  TIFFSetField(tiff, TIFFTAG_IMAGEWIDTH, width);\n  TIFFSetField(tiff, TIFFTAG_IMAGELENGTH, height);\n  TIFFSetField(tiff, TIFFTAG_SAMPLESPERPIXEL, components);\n  TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 32);\n  TIFFSetField(tiff, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);\n  TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n  TIFFSetField(tiff, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n  TIFFSetField(tiff, TIFFTAG_ROWSPERSTRIP, 1);\n  for (int y = 0; y < height; ++y) {\n    TIFFWriteScanline(tiff, texture + y * width * components, height - y - 1);\n  }\n  TIFFClose(tiff);\n}",
    "void write3D(\n    std::string const& path, float* texture, int width, int height, int depth, int components) {\n  auto* tiff = TIFFOpen(path.c_str(), \"w\");\n\n  for (int z = 0; z < depth; ++z) {\n    TIFFSetField(tiff, TIFFTAG_PAGENUMBER, z, z);\n    TIFFSetField(tiff, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE);\n    TIFFSetField(tiff, TIFFTAG_IMAGEWIDTH, width);\n    TIFFSetField(tiff, TIFFTAG_IMAGELENGTH, height);\n    TIFFSetField(tiff, TIFFTAG_SAMPLESPERPIXEL, components);\n    TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 32);\n    TIFFSetField(tiff, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);\n    TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n    TIFFSetField(tiff, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    TIFFSetField(tiff, TIFFTAG_ROWSPERSTRIP, 1);\n    for (int y = 0; y < height; ++y) {\n      TIFFWriteScanline(\n          tiff, texture + z * width * height * components + y * width * components, height - y - 1);\n    }\n    TIFFWriteDirectory(tiff);\n  }\n  TIFFClose(tiff);\n}",
    "KisImportExportErrorCode KisTiffPsdWriter::writeImage(KisGroupLayerSP layer)\n{\n    dbgFile << \"Starting write of Photoshop layer data\";\n\n    /**\n     * For Photoshop tiff files, first thing is to write the\n     * projection of the image file.\n     */\n\n    if (layer->image()->width() > MAX_PSD_SIZE || layer->image()->height() > MAX_PSD_SIZE) {\n        dbgFile << \"This TIFF file is too big to be represented as a PSD blob!\";\n        return ImportExportCodes::Failure;\n    }\n\n    dbgFile << \"Writing root layer projection\";\n    KisPaintDeviceSP pd = layer->projection();\n\n    uint16_t color_type = 0;\n    uint16_t sample_format = SAMPLEFORMAT_UINT;\n    const KoColorSpace *destColorSpace = nullptr;\n    // Check colorspace\n    if (!writeColorSpaceInformation(image(), pd->colorSpace(), color_type, sample_format, destColorSpace)) { // unsupported colorspace\n        if (!destColorSpace) {\n            dbgFile << \"Unsupported colorspace\" << pd->colorSpace()->name();\n            return ImportExportCodes::FormatColorSpaceUnsupported;\n        }\n        pd.attach(new KisPaintDevice(*pd));\n        pd->convertTo(destColorSpace);\n    }\n\n    {\n        // WORKAROUND: block any attempts to use YCbCr with alpha channels.\n        // This should not happen because alpha is disabled by default\n        // and the checkbox is blocked for YCbCr and CMYK.\n        KIS_SAFE_ASSERT_RECOVER(color_type != PHOTOMETRIC_YCBCR\n                                || !m_options->alpha)\n        {\n            warnFile << \"TIFF does not support exporting alpha channels with \"\n                        \"YCbCr. Skipping...\";\n            m_options->alpha = false;\n        }\n    }\n\n    // Save depth\n    uint32_t depth = 8 * pd->pixelSize() / pd->channelCount();\n    TIFFSetField(image(), TIFFTAG_BITSPERSAMPLE, depth);\n\n    {\n        // WORKAROUND: block any attempts to use JPEG with >= 8 bits\n\n        if (m_options->compressionType == COMPRESSION_JPEG && depth != 8) {\n            warnFile << \"Attempt to export JPEG with multi-byte depth, \"\n                        \"disabling compression\";\n            m_options->compressionType = COMPRESSION_NONE;\n        }\n    }\n\n    // Save number of samples\n    if (m_options->alpha) {\n        TIFFSetField(image(), TIFFTAG_SAMPLESPERPIXEL, pd->channelCount());\n        const std::array<uint16_t, 1> sampleinfo = {EXTRASAMPLE_UNASSALPHA};\n        TIFFSetField(image(), TIFFTAG_EXTRASAMPLES, 1, sampleinfo.data());\n    } else {\n        TIFFSetField(image(), TIFFTAG_SAMPLESPERPIXEL, pd->channelCount() - 1);\n        TIFFSetField(image(), TIFFTAG_EXTRASAMPLES, 0);\n    }\n\n    // Save colorspace information\n    TIFFSetField(image(), TIFFTAG_PHOTOMETRIC, color_type);\n    TIFFSetField(image(), TIFFTAG_SAMPLEFORMAT, sample_format);\n    TIFFSetField(image(), TIFFTAG_IMAGEWIDTH, layer->image()->width());\n    TIFFSetField(image(), TIFFTAG_IMAGELENGTH, layer->image()->height());\n\n    // Set the compression options\n    TIFFSetField(image(), TIFFTAG_COMPRESSION, m_options->compressionType);\n    if (m_options->compressionType == COMPRESSION_JPEG) {\n        TIFFSetField(image(), TIFFTAG_JPEGQUALITY, m_options->jpegQuality);\n    } else if (m_options->compressionType == COMPRESSION_ADOBE_DEFLATE) {\n        TIFFSetField(image(), TIFFTAG_ZIPQUALITY, m_options->deflateCompress);\n    } else if (m_options->compressionType == COMPRESSION_PIXARLOG) {\n        TIFFSetField(image(),\n                     TIFFTAG_PIXARLOGQUALITY,\n                     m_options->pixarLogCompress);\n    }\n\n    // Set the predictor\n    if (m_options->compressionType == COMPRESSION_LZW\n        || m_options->compressionType == COMPRESSION_ADOBE_DEFLATE)\n        TIFFSetField(image(), TIFFTAG_PREDICTOR, m_options->predictor);\n\n    // Use contiguous configuration\n    TIFFSetField(image(), TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\n    // Do not set the rowsperstrip, as it's incompatible with JPEG\n\n    // But do set YCbCr 4:4:4 if applicable\n    if (color_type == PHOTOMETRIC_YCBCR) {\n        TIFFSetField(image(), TIFFTAG_YCBCRSUBSAMPLING, 1, 1);\n        TIFFSetField(image(), TIFFTAG_YCBCRPOSITIONING, YCBCRPOSITION_CENTERED);\n        if (m_options->compressionType == COMPRESSION_JPEG) {\n            TIFFSetField(image(), TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RAW);\n        }\n    }\n\n    // Save profile\n    if (m_options->saveProfile) {\n        const KoColorProfile *profile = pd->colorSpace()->profile();\n        if (profile && profile->type() == \"icc\" && !profile->rawData().isEmpty()) {\n            QByteArray ba = profile->rawData();\n            TIFFSetField(image(), TIFFTAG_ICCPROFILE, ba.size(), ba.constData());\n        }\n    }\n    tsize_t stripsize = TIFFStripSize(image());\n    std::unique_ptr<std::remove_pointer_t<tdata_t>, decltype(&_TIFFfree)> buff(\n        _TIFFmalloc(stripsize),\n        &_TIFFfree);\n    KIS_ASSERT_RECOVER_RETURN_VALUE(\n        buff && \"Unable to allocate buffer for TIFF!\",\n        ImportExportCodes::InsufficientMemory);\n    qint32 height = layer->image()->height();\n    qint32 width = layer->image()->width();\n    bool r = true;\n    for (qint32 y = 0; y < height; y++) {\n        KisHLineConstIteratorSP it = pd->createHLineConstIteratorNG(0, y, width);\n        switch (color_type) {\n        case PHOTOMETRIC_MINISBLACK: {\n            const std::array<quint8, 5> poses = {0, 1};\n            r = copyDataToStrips(it,\n                                 buff.get(),\n                                 depth,\n                                 sample_format,\n                                 1,\n                                 poses);\n        } break;\n        case PHOTOMETRIC_RGB: {\n            const auto poses = [&]() -> std::array<quint8, 5> {\n                if (sample_format == SAMPLEFORMAT_IEEEFP) {\n                    return {0, 1, 2, 3};\n                } else {\n                    return {2, 1, 0, 3};\n                }\n            }();\n            r = copyDataToStrips(it,\n                                 buff.get(),\n                                 depth,\n                                 sample_format,\n                                 3,\n                                 poses);\n        } break;\n        case PHOTOMETRIC_SEPARATED: {\n            const std::array<quint8, 5> poses = {0, 1, 2, 3, 4};\n            r = copyDataToStrips(it,\n                                 buff.get(),\n                                 depth,\n                                 sample_format,\n                                 4,\n                                 poses);\n        } break;\n        case PHOTOMETRIC_ICCLAB:\n        case PHOTOMETRIC_YCBCR: {\n            const std::array<quint8, 5> poses = {0, 1, 2, 3};\n            r = copyDataToStrips(it,\n                                 buff.get(),\n                                 depth,\n                                 sample_format,\n                                 3,\n                                 poses);\n        } break;\n        }\n        if (!r)\n            return ImportExportCodes::InternalError;\n        TIFFWriteScanline(image(),\n                          buff.get(),\n                          static_cast<quint32>(y),\n                          (tsample_t)-1);\n    }\n    buff.reset();\n\n    ///* BEGIN PHOTOSHOP SPECIFIC HANDLING CODE *///\n\n    /**\n     * Synthesize the PSD file into the TIFFTAG_IMAGESOURCEDATA field.\n     */\n\n    {\n        const bool haveLayers = layer->childCount() > 1 || KisPainter::checkDeviceHasTransparency(layer->firstChild()->projection());\n\n        QBuffer buf;\n        buf.open(QIODevice::WriteOnly);\n\n        dbgFile << \"m_image->rootLayer->childCount\" << layer->childCount() << buf.pos();\n\n        if (haveLayers) {\n            KisTiffPsdLayerRecord layerSection(\n                TIFFIsBigEndian(image()),\n                static_cast<uint32_t>(width),\n                static_cast<uint32_t>(height),\n                static_cast<uint16_t>(depth),\n                static_cast<uint16_t>(pd->channelCount()),\n                color_type,\n                true);\n\n            if (!layerSection.write(buf, layer, static_cast<psd_compression_type>(m_options->psdCompressionType))) {\n                dbgFile << \"failed to write layer section. Error:\" << layerSection.record()->error << buf.pos();\n                return ImportExportCodes::ErrorWhileWriting;\n            }\n        } else {\n            // else write a zero length block\n            dbgFile << \"No layers, saving empty layers/mask block\" << buf.pos();\n            psdwrite(buf, (quint32)0);\n        }\n\n        buf.close();\n        buf.open(QIODevice::ReadOnly);\n\n        if (!TIFFSetField(image(), TIFFTAG_IMAGESOURCEDATA, static_cast<uint32_t>(buf.size()), buf.data().constData())) {\n            dbgFile << \"Failed to write the PSD image block to the TIFF field\";\n            return ImportExportCodes::ErrorWhileWriting;\n        }\n    }\n\n    /**\n     * Write all the annotations into the TIFFTAG_PHOTOSHOP field.\n     */\n\n    {\n        // IMAGE RESOURCES SECTION\n        KisTiffPsdResourceRecord resourceSection;\n\n        for (vKisAnnotationSP_it it = layer->image()->beginAnnotations(); it != layer->image()->endAnnotations(); ++it) {\n            KisAnnotationSP annotation = (*it);\n            if (!annotation || annotation->type().isEmpty()) {\n                dbgFile << \"Warning: empty annotation\";\n                continue;\n            }\n\n            dbgFile << \"Annotation:\" << annotation->type() << annotation->description();\n\n            if (annotation->type().startsWith(QString(\"PSD Resource Block:\"))) { //\n                PSDResourceBlock *resourceBlock =\n                    dynamic_cast<PSDResourceBlock *>(annotation.data());\n                if (resourceBlock) {\n                    dbgFile << \"Adding PSD Resource Block\" << resourceBlock->identifier;\n                    resourceSection.resources[(KisTiffPsdResourceRecord::PSDResourceID)resourceBlock->identifier] = resourceBlock;\n                }\n            }\n        }\n\n        // Add resolution block\n        {\n            auto *resInfo = new RESN_INFO_1005();\n            resInfo->hRes = static_cast<int>(INCH_TO_POINT(layer->image()->xRes()));\n            resInfo->vRes = static_cast<int>(INCH_TO_POINT(layer->image()->yRes()));\n            auto *block = new PSDResourceBlock();\n            block->identifier = KisTiffPsdResourceRecord::RESN_INFO;\n            block->resource = resInfo;\n            resourceSection.resources[KisTiffPsdResourceRecord::RESN_INFO] = block;\n        }\n\n        // Add icc block\n        {\n            auto *profileInfo = new ICC_PROFILE_1039();\n            profileInfo->icc = layer->image()->profile()->rawData();\n            auto *block = new PSDResourceBlock();\n            block->identifier = KisTiffPsdResourceRecord::ICC_PROFILE;\n            block->resource = profileInfo;\n            resourceSection.resources[KisTiffPsdResourceRecord::ICC_PROFILE] = block;\n        }\n\n        dbgFile << \"Resource section ready to write\";\n\n        QBuffer buf;\n        buf.open(QIODevice::WriteOnly);\n\n        if (!resourceSection.write(buf)) {\n            dbgFile << \"Failed to write resource section. Error:\" << resourceSection.error << buf.pos();\n            return ImportExportCodes::ErrorWhileWriting;\n        }\n\n        buf.close();\n        buf.open(QIODevice::WriteOnly);\n\n        if (!TIFFSetField(image(), TIFFTAG_PHOTOSHOP, static_cast<uint32_t>(buf.size()), buf.data().data())) {\n            dbgFile << \"Failed to write the PSD resource block to the TIFF field\";\n            return ImportExportCodes::ErrorWhileWriting;\n        }\n    }\n\n    /**\n     * Freshly baked Photoshoppy TIFF file!\n     */\n\n    ///* END PHOTOSHOP SPECIFIC HANDLING CODE *///\n\n    TIFFWriteDirectory(image());\n    return ImportExportCodes::OK;\n}",
    "void vw::DiskImageResourceTIFF::write( ImageBuffer const& src, BBox2i const& bbox )\n{\n  VW_ASSERT(bbox.width() == m_format.cols,\n            ArgumentErr() << \"DiskImageResourceTIFF: bounding box must be the same width as image.\\n\");\n\n  // Allocate some buffer memory for the output data\n  uint32 scanline_size = num_channels(m_format.pixel_format) * channel_size(m_format.channel_type) * m_format.cols;\n  tdata_t buf = _TIFFmalloc(scanline_size);\n  if( !buf ) vw_throw( vw::IOErr() << \"DiskImageResourceTIFF: Failed to malloc!\" );\n\n  // Set up the image buffer and convert the data into this buffer.\n  ImageBuffer dst(m_format, buf);\n\n  ImageBuffer src_plane = src;\n  src_plane.format.rows = 1;\n  src_plane.format.planes = 1;\n  dst.format.rows = 1;\n  dst.format.planes = 1;\n\n  // Write the image data to disk.\n  for (int32 p = 0; p < m_format.planes; p++) {\n    ImageBuffer src_row = src_plane;\n    for (int32 row = 0; row < bbox.height(); row++) {\n      convert( dst, src_row, m_rescale );\n      check_retval(TIFFWriteScanline(m_info->tif, (uint8*)buf, bbox.min()[1]+row, p), -1);\n      src_row.data = (uint8*)src_row.data + src_row.rstride;\n    }\n    src_plane.data = (uint8*)src_plane.data + src_plane.pstride;\n  }\n\n  // Clean up\n  _TIFFfree(buf);\n}",
    "DECLAREcpFunc(cpContig2ContigByRow)\n{\n    unsigned char *buf = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(in));\n    uint32_t         row;\n\n    (void)imagewidth;\n    (void)spp;\n    for (row = 0; row < imagelength; row++) {\n        if (TIFFReadScanline(in, buf, row, 0) < 0 && !ignore) goto done;\n        if (TIFFWriteScanline(out, buf, row, 0) < 0) goto bad;\n    }\ndone:\n    _TIFFfree(buf);\n    return (TRUE);\nbad:\n    _TIFFfree(buf);\n    return (FALSE);\n}",
    "DECLAREcpFunc(cpContig2ContigByRow_8_to_4)\n{\n    unsigned char *buf_in = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(in));\n    unsigned char *buf_out = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(out));\n    uint32_t         row;\n\n    printf(\"Downsample\\n\");\n\n    (void)imagewidth;\n    (void)spp;\n    for (row = 0; row < imagelength; row++) {\n        int i_in, i_out_byte;\n\n        if (TIFFReadScanline(in, buf_in, row, 0) < 0 && !ignore) goto done;\n\n        for (i_in = 0, i_out_byte = 0; i_in < (int)imagewidth; i_in += 2, i_out_byte++) { buf_out[i_out_byte] = (buf_in[i_in] & 0xf) * 16 + (buf_in[i_in + 1] & 0xf); }\n\n        if (TIFFWriteScanline(out, buf_out, row, 0) < 0) goto bad;\n    }\ndone:\n    _TIFFfree(buf_in);\n    _TIFFfree(buf_out);\n    return (TRUE);\nbad:\n    _TIFFfree(buf_in);\n    _TIFFfree(buf_out);\n    return (FALSE);\n}",
    "DECLAREcpFunc(cpSeparate2SeparateByRow)\n{\n    unsigned char *buf = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(in));\n    uint32_t         row;\n    tsample_t      s;\n\n    (void)imagewidth;\n    for (s = 0; s < spp; s++) {\n        for (row = 0; row < imagelength; row++) {\n            if (TIFFReadScanline(in, buf, row, s) < 0 && !ignore) goto done;\n            if (TIFFWriteScanline(out, buf, row, s) < 0) goto bad;\n        }\n    }\ndone:\n    _TIFFfree(buf);\n    return (TRUE);\nbad:\n    _TIFFfree(buf);\n    return (FALSE);\n}",
    "DECLAREcpFunc(cpContig2SeparateByRow)\n{\n    unsigned char *inbuf = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(in));\n    unsigned char *outbuf = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(out));\n    unsigned char *inp, *outp;\n    uint32_t         n;\n    uint32_t         row;\n    tsample_t      s;\n\n    /* unpack channels */\n    for (s = 0; s < spp; s++) {\n        for (row = 0; row < imagelength; row++) {\n            if (TIFFReadScanline(in, inbuf, row, 0) < 0 && !ignore) goto done;\n            inp = inbuf + s;\n            outp = outbuf;\n            for (n = imagewidth; n-- > 0;) {\n                *outp++ = *inp;\n                inp += spp;\n            }\n            if (TIFFWriteScanline(out, outbuf, row, s) < 0) goto bad;\n        }\n    }\ndone:\n    if (inbuf) _TIFFfree(inbuf);\n    if (outbuf) _TIFFfree(outbuf);\n    return (TRUE);\nbad:\n    if (inbuf) _TIFFfree(inbuf);\n    if (outbuf) _TIFFfree(outbuf);\n    return (FALSE);\n}",
    "DECLAREcpFunc(cpSeparate2ContigByRow)\n{\n    unsigned char *inbuf = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(in));\n    unsigned char *outbuf = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(out));\n    unsigned char *inp, *outp;\n    uint32_t         n;\n    uint32_t         row;\n    tsample_t      s;\n\n    for (row = 0; row < imagelength; row++) {\n        /* merge channels */\n        for (s = 0; s < spp; s++) {\n            if (TIFFReadScanline(in, inbuf, row, s) < 0 && !ignore) goto done;\n            inp = inbuf;\n            outp = outbuf + s;\n            for (n = imagewidth; n-- > 0;) {\n                *outp = *inp++;\n                outp += spp;\n            }\n        }\n        if (TIFFWriteScanline(out, outbuf, row, 0) < 0) goto bad;\n    }\ndone:\n    if (inbuf) _TIFFfree(inbuf);\n    if (outbuf) _TIFFfree(outbuf);\n    return (TRUE);\nbad:\n    if (inbuf) _TIFFfree(inbuf);\n    if (outbuf) _TIFFfree(outbuf);\n    return (FALSE);\n}",
    "DECLAREwriteFunc(writeBufferToContigStrips)\n{\n    tsize_t scanline = TIFFScanlineSize(out);\n    uint32_t  row;\n\n    (void)imagewidth;\n    (void)spp;\n    for (row = 0; row < imagelength; row++) {\n        if (TIFFWriteScanline(out, buf, row, 0) < 0) return (FALSE);\n        buf += scanline;\n    }\n    return (TRUE);\n}",
    "DECLAREwriteFunc(writeBufferToSeparateStrips)\n{\n    unsigned char *obuf = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(out));\n    tsample_t      s;\n\n    if (obuf == NULL) return (0);\n    for (s = 0; s < spp; s++) {\n        uint32_t row;\n        for (row = 0; row < imagelength; row++) {\n            unsigned char *inp = buf + s;\n            unsigned char *outp = obuf;\n            uint32_t         n = imagewidth;\n\n            while (n-- > 0) *outp++ = *inp, inp += spp;\n            if (TIFFWriteScanline(out, obuf, row, s) < 0) {\n                _TIFFfree(obuf);\n                return (FALSE);\n            }\n        }\n    }\n    _TIFFfree(obuf);\n    return (TRUE);\n}",
    "void Preprocessor::save(std::string const& directory) {\n  std::cout << \"Saving precomputed atmosphere to disk...\" << std::endl;\n\n  // For debugging purposes, we print the maximum ray deviation in degrees.\n  std::vector<float> pixels(\n      mParams.mTransmittanceTextureWidth.get() * mParams.mTransmittanceTextureHeight.get() * 3);\n  glBindTexture(GL_TEXTURE_2D, mThetaDeviationTexture);\n  glGetTexImage(GL_TEXTURE_2D, 0, GL_RGB, GL_FLOAT, pixels.data());\n  glBindTexture(GL_TEXTURE_2D, 0);\n\n  float maxThetaDeviation = 0.F;\n  for (int x = 0; x < mParams.mTransmittanceTextureWidth.get(); ++x) {\n    for (int y = 0; y < mParams.mTransmittanceTextureHeight.get(); ++y) {\n      int i = 3 * (y * mParams.mTransmittanceTextureWidth.get() + x);\n\n      float thetaDeviation = pixels[i];\n      float contactRadius  = pixels[i + 1];\n\n      if (contactRadius > 0.F) {\n        maxThetaDeviation = std::max(maxThetaDeviation, thetaDeviation);\n      }\n    }\n  }\n\n  std::cout << \"Maximum ray deviation: \" << maxThetaDeviation * 180.F / glm::pi<float>()\n            << \" degrees.\" << std::endl;\n\n  auto write2D = [](std::string const& path, GLuint texture, int width, int height) {\n    std::vector<float> data(width * height * 3);\n    glBindTexture(GL_TEXTURE_2D, texture);\n    glGetTexImage(GL_TEXTURE_2D, 0, GL_RGB, GL_FLOAT, data.data());\n    glBindTexture(GL_TEXTURE_2D, 0);\n\n    auto* tiff = TIFFOpen(path.c_str(), \"w\");\n    TIFFSetField(tiff, TIFFTAG_IMAGEWIDTH, width);\n    TIFFSetField(tiff, TIFFTAG_IMAGELENGTH, height);\n    TIFFSetField(tiff, TIFFTAG_SAMPLESPERPIXEL, 3);\n    TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 32);\n    TIFFSetField(tiff, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);\n    TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n    TIFFSetField(tiff, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    TIFFSetField(tiff, TIFFTAG_ROWSPERSTRIP, 1);\n    for (int y = 0; y < height; ++y) {\n      TIFFWriteScanline(tiff, data.data() + y * width * 3, y);\n    }\n    TIFFClose(tiff);\n  };\n\n  auto write3D = [](std::string const& path, GLuint texture, int width, int height, int depth) {\n    std::vector<float> data(width * height * depth * 3);\n    glBindTexture(GL_TEXTURE_3D, texture);\n    glGetTexImage(GL_TEXTURE_3D, 0, GL_RGB, GL_FLOAT, data.data());\n    glBindTexture(GL_TEXTURE_3D, 0);\n\n    auto* tiff = TIFFOpen(path.c_str(), \"w\");\n\n    for (int z = 0; z < depth; ++z) {\n      TIFFSetField(tiff, TIFFTAG_PAGENUMBER, z, z);\n      TIFFSetField(tiff, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE);\n      TIFFSetField(tiff, TIFFTAG_IMAGEWIDTH, width);\n      TIFFSetField(tiff, TIFFTAG_IMAGELENGTH, height);\n      TIFFSetField(tiff, TIFFTAG_SAMPLESPERPIXEL, 3);\n      TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 32);\n      TIFFSetField(tiff, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);\n      TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n      TIFFSetField(tiff, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n      TIFFSetField(tiff, TIFFTAG_ROWSPERSTRIP, 1);\n      for (int y = 0; y < height; ++y) {\n        TIFFWriteScanline(tiff, data.data() + z * width * height * 3 + y * width * 3, y);\n      }\n      TIFFWriteDirectory(tiff);\n    }\n    TIFFClose(tiff);\n  };\n\n  int numAngles = static_cast<int>(mParams.mMolecules.mPhase.size());\n  write2D(directory + \"/phase.tif\", mPhaseTexture, numAngles, 2);\n  write2D(directory + \"/transmittance.tif\", mTransmittanceTexture,\n      mParams.mTransmittanceTextureWidth.get(), mParams.mTransmittanceTextureHeight.get());\n  write2D(directory + \"/indirect_illuminance.tif\", mIrradianceTexture,\n      mParams.mIrradianceTextureWidth.get(), mParams.mIrradianceTextureHeight.get());\n  write3D(directory + \"/multiple_scattering.tif\", mMultipleScatteringTexture,\n      mScatteringTextureWidth, mScatteringTextureHeight, mScatteringTextureDepth);\n  write3D(directory + \"/single_aerosols_scattering.tif\", mSingleAerosolsScatteringTexture,\n      mScatteringTextureWidth, mScatteringTextureHeight, mScatteringTextureDepth);\n\n  if (mParams.mRefraction.get()) {\n    write2D(directory + \"/theta_deviation.tif\", mThetaDeviationTexture,\n        mParams.mTransmittanceTextureWidth.get(), mParams.mTransmittanceTextureHeight.get());\n  }\n\n  std::ofstream  out(directory + \"/metadata.json\");\n  nlohmann::json data = mMetadata;\n  out << std::setw(2) << data;\n\n  std::cout << \"Precomputed atmosphere saved to disk.\" << std::endl;\n}",
    "void LibRaw2DngConverter::SetBuffer(\n    const Halide::Runtime::Buffer<uint16_t> &buffer) const {\n  const auto width = buffer.width();\n  const auto height = buffer.height();\n  const auto tiff = Tiff.get();\n  TIFFSetField(tiff, TIFFTAG_IMAGEWIDTH, width);\n  TIFFSetField(tiff, TIFFTAG_IMAGELENGTH, height);\n\n  uint16_t *row_pointer = buffer.data();\n  for (int row = 0; row < height; row++) {\n    TIFFWriteScanline(tiff, row_pointer, row, 0);\n    row_pointer += width;\n  }\n}",
    "void tiffWriteImage(TIFF* pTiff, IplImage* image)\n{\n#ifdef EMGU_CV_WITH_TIFF\n\tcv::Mat mat = cv::cvarrToMat(image);\n\tCvSize imageSize = cvSize(image->width, image->height);\n\ttiffWriteImageSize(pTiff, &imageSize);\n\n\t//write scaneline image data\n\tfor (int row = 0; row < mat.rows; row++)\n\t{\n\t\tTIFFWriteScanline(pTiff, mat.ptr(row), row, 0);\n\t}\n\t//end writing image data\n#else\n\tthrow_no_tiff();\n#endif\n}",
    "bool QTiffHandler::write(const QImage &image)\n{\n   if (!device()->isWritable()) {\n      return false;\n   }\n\n   TIFF *const tiff = TIFFClientOpen(\"foo\",\n         \"w\",\n         this,\n         qtiffReadProc,\n         qtiffWriteProc,\n         qtiffSeekProc,\n         qtiffCloseProc,\n         qtiffSizeProc,\n         qtiffMapProc,\n         qtiffUnmapProc);\n   if (!tiff) {\n      return false;\n   }\n\n   const int width = image.width();\n   const int height = image.height();\n\n   if (!TIFFSetField(tiff, TIFFTAG_IMAGEWIDTH, width)\n      || !TIFFSetField(tiff, TIFFTAG_IMAGELENGTH, height)\n      || !TIFFSetField(tiff, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG)) {\n      TIFFClose(tiff);\n      return false;\n   }\n\n   // set the resolution\n   bool  resolutionSet = false;\n   const int dotPerMeterX = image.dotsPerMeterX();\n   const int dotPerMeterY = image.dotsPerMeterY();\n   if ((dotPerMeterX % 100) == 0\n      && (dotPerMeterY % 100) == 0) {\n      resolutionSet = TIFFSetField(tiff, TIFFTAG_RESOLUTIONUNIT, RESUNIT_CENTIMETER)\n         && TIFFSetField(tiff, TIFFTAG_XRESOLUTION, dotPerMeterX / 100.0)\n         && TIFFSetField(tiff, TIFFTAG_YRESOLUTION, dotPerMeterY / 100.0);\n   } else {\n      resolutionSet = TIFFSetField(tiff, TIFFTAG_RESOLUTIONUNIT, RESUNIT_INCH)\n         && TIFFSetField(tiff, TIFFTAG_XRESOLUTION, static_cast<float>(image.logicalDpiX()))\n         && TIFFSetField(tiff, TIFFTAG_YRESOLUTION, static_cast<float>(image.logicalDpiY()));\n   }\n   if (!resolutionSet) {\n      TIFFClose(tiff);\n      return false;\n   }\n\n   // configure image depth\n   const QImage::Format format = image.format();\n   if (format == QImage::Format_Mono || format == QImage::Format_MonoLSB) {\n      uint16_t photometric = PHOTOMETRIC_MINISBLACK;\n      if (image.colorTable().at(0) == 0xffffffff) {\n         photometric = PHOTOMETRIC_MINISWHITE;\n      }\n      if (!TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, photometric)\n         || !TIFFSetField(tiff, TIFFTAG_COMPRESSION, compression == NoCompression ? COMPRESSION_NONE : COMPRESSION_CCITTRLE)\n         || !TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 1)) {\n         TIFFClose(tiff);\n         return false;\n      }\n\n      // try to do the conversion in chunks no greater than 16 MB\n      int chunks = (width * height / (1024 * 1024 * 16)) + 1;\n      int chunkHeight = qMax(height / chunks, 1);\n\n      int y = 0;\n      while (y < height) {\n         QImage chunk = image.copy(0, y, width, qMin(chunkHeight, height - y)).convertToFormat(QImage::Format_Mono);\n\n         int chunkStart = y;\n         int chunkEnd = y + chunk.height();\n         while (y < chunkEnd) {\n            if (TIFFWriteScanline(tiff, reinterpret_cast<uint32_t *>(chunk.scanLine(y - chunkStart)), y) != 1) {\n               TIFFClose(tiff);\n               return false;\n            }\n            ++y;\n         }\n      }\n      TIFFClose(tiff);\n   } else if (format == QImage::Format_Indexed8) {\n      const QVector<QRgb> colorTable = image.colorTable();\n      bool isGrayscale = checkGrayscale(colorTable);\n      if (isGrayscale) {\n         uint16_t photometric = PHOTOMETRIC_MINISBLACK;\n         if (image.colorTable().at(0) == 0xffffffff) {\n            photometric = PHOTOMETRIC_MINISWHITE;\n         }\n         if (!TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, photometric)\n            || !TIFFSetField(tiff, TIFFTAG_COMPRESSION, compression == NoCompression ? COMPRESSION_NONE : COMPRESSION_PACKBITS)\n            || !TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 8)) {\n            TIFFClose(tiff);\n            return false;\n         }\n      } else {\n         if (!TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_PALETTE)\n            || !TIFFSetField(tiff, TIFFTAG_COMPRESSION, compression == NoCompression ? COMPRESSION_NONE : COMPRESSION_PACKBITS)\n            || !TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 8)) {\n            TIFFClose(tiff);\n            return false;\n         }\n         //// write the color table\n         // allocate the color tables\n         uint16_t *redTable   = static_cast<uint16_t *>(malloc(256 * sizeof(uint16_t)));\n         uint16_t *greenTable = static_cast<uint16_t *>(malloc(256 * sizeof(uint16_t)));\n         uint16_t *blueTable  = static_cast<uint16_t *>(malloc(256 * sizeof(uint16_t)));\n\n         if (!redTable || !greenTable || !blueTable) {\n            free(redTable);\n            free(greenTable);\n            free(blueTable);\n            TIFFClose(tiff);\n            return false;\n         }\n\n         // set the color table\n         const int tableSize = colorTable.size();\n         Q_ASSERT(tableSize <= 256);\n         for (int i = 0; i < tableSize; ++i) {\n            const QRgb color = colorTable.at(i);\n            redTable[i] = qRed(color) * 257;\n            greenTable[i] = qGreen(color) * 257;\n            blueTable[i] = qBlue(color) * 257;\n         }\n\n         const bool setColorTableSuccess = TIFFSetField(tiff, TIFFTAG_COLORMAP, redTable, greenTable, blueTable);\n\n         free(redTable);\n         free(greenTable);\n         free(blueTable);\n\n         if (!setColorTableSuccess) {\n            TIFFClose(tiff);\n            return false;\n         }\n      }\n\n      //// write the data\n      // try to do the conversion in chunks no greater than 16 MB\n      int chunks = (width * height / (1024 * 1024 * 16)) + 1;\n      int chunkHeight = qMax(height / chunks, 1);\n\n      int y = 0;\n      while (y < height) {\n         QImage chunk = image.copy(0, y, width, qMin(chunkHeight, height - y));\n\n         int chunkStart = y;\n         int chunkEnd = y + chunk.height();\n         while (y < chunkEnd) {\n            if (TIFFWriteScanline(tiff, reinterpret_cast<uint32_t *>(chunk.scanLine(y - chunkStart)), y) != 1) {\n               TIFFClose(tiff);\n               return false;\n            }\n            ++y;\n         }\n      }\n      TIFFClose(tiff);\n\n   } else {\n      if (!TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB)\n         || !TIFFSetField(tiff, TIFFTAG_COMPRESSION, compression == NoCompression ? COMPRESSION_NONE : COMPRESSION_LZW)\n         || !TIFFSetField(tiff, TIFFTAG_SAMPLESPERPIXEL, 4)\n         || !TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 8)) {\n         TIFFClose(tiff);\n         return false;\n      }\n      // try to do the ARGB32 conversion in chunks no greater than 16 MB\n      int chunks = (width * height * 4 / (1024 * 1024 * 16)) + 1;\n      int chunkHeight = qMax(height / chunks, 1);\n\n      int y = 0;\n      while (y < height) {\n         QImage chunk = image.copy(0, y, width, qMin(chunkHeight, height - y)).convertToFormat(QImage::Format_ARGB32);\n\n         int chunkStart = y;\n         int chunkEnd = y + chunk.height();\n\n         while (y < chunkEnd) {\n            if constexpr (QSysInfo::ByteOrder == QSysInfo::LittleEndian) {\n               convert32BitOrder(chunk.scanLine(y - chunkStart), width);\n            } else {\n               convert32BitOrderBigEndian(chunk.scanLine(y - chunkStart), width);\n            }\n\n            if (TIFFWriteScanline(tiff, reinterpret_cast<uint32_t *>(chunk.scanLine(y - chunkStart)), y) != 1) {\n               TIFFClose(tiff);\n               return false;\n            }\n            ++y;\n         }\n      }\n      TIFFClose(tiff);\n   }\n\n   return true;\n}",
    "void writetiff( char *myfile, unsigned char *img, int channels, int width, int height, int depth )\n//===================================================================================================\n{\n    TIFF* tif = TIFFOpen(myfile, \"w\");\n    if (tif)\n    {\n\t\tfor(int layerIndex = 0; layerIndex < depth ; layerIndex++)\n\t\t{\n\t\t\t//set tiff tags to generate an uncompressed TIFF image\n\t\t\t//SETTAGS( tif, width, height, channels );\n\t\t\t//dimensions of the image\n\t\t\tTIFFSetField(tif, TIFFTAG_IMAGEWIDTH,  width);\n\t\t\tTIFFSetField(tif, TIFFTAG_IMAGELENGTH, height);\n\t\t\t\n\t\t\t//starting from top-left corner\n\t\t\tTIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n\t\t\t\n\t\t\t//grayscale or color image\n\t\t\tTIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, channels);\n\t\t\tTIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8);\n\t\t\tTIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\t\t\tif (channels == 1)\n\t\t\t\tTIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n\t\t\telse\n\t\t\t\tif (channels == 3)\n\t\t\t\t\tTIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n\t\t\t\n\t\t\t//Miscalleneous Tags\n\t\t\tTIFFSetField( tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\t\t\tTIFFSetField( tif, TIFFTAG_COMPRESSION , COMPRESSION_NONE );\n\t\t\tTIFFSetField( tif, TIFFTAG_ROWSPERSTRIP,\n\t\t\t\t\t\t TIFFDefaultStripSize(tif , (uint32) -1) );\n\t\t\tTIFFSetField(tif, TIFFTAG_XRESOLUTION, 72);\n\t\t\tTIFFSetField(tif, TIFFTAG_YRESOLUTION, 72);\n\t\t\tTIFFSetField(tif, TIFFTAG_RESOLUTIONUNIT, RESUNIT_INCH);\n\t\t\t\n\t\t\t//create a dummy array\n\t\t\tint linebytes = channels*width;\n\t\t\tunsigned char *buf = new unsigned char[linebytes];\n\t\t\tTIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, TIFFDefaultStripSize(tif, linebytes));\n\t\t\t\n\t\t\t//start writing the data into the TIFF file in scanlines\n\t\t\tfor ( int row = 0; row < height; row++)\n\t\t\t{\n\t\t\t\t//check if a grayscale or color image is being written\n\t\t\t\tmemcpy(buf, &img[layerIndex*width*height*channels+row*linebytes], linebytes);\n\t\t\t\t\n\t\t\t\tif (TIFFWriteScanline(tif, buf, row, 0) < 0)\n\t\t\t\t{\n\t\t\t\t\tcerr<<\"Error in scanline while writing !\\n\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tdelete(buf);\n\t\t\tTIFFWriteDirectory(tif);\n\t\t}\n        TIFFClose(tif);\n    }\n    else\n    {\n        cerr<<\"Unable to open file for writing !\\n\";\n    }\n}",
    "void TIFFWritePimpl::write_raw_pixel_line(const bool* data)\n{\n\t//Do some type checking\n\tif(type != PNM::type_name<bool>::name())\n\t\tthrow WriteTypeMismatch(type, PNM::type_name<bool>::name());\n\n\t//Do some sanity checking\n\tif(row >= (unsigned long)my_size.y)\n\t\tthrow InternalLibraryError(\"CVD\", \"Write past end of image.\");\n\n\tfill(bool_rowbuf.begin(), bool_rowbuf.end(), 0);\n\n\t//Pack bools\n\tfor(int i = 0; i < my_size.x; i++)\n\t\tbool_rowbuf[i / 8] |= static_cast<unsigned char>((data[i] & 1) << (7 - i % 8));\n\n\tif(TIFFWriteScanline(tif, &bool_rowbuf[0], row) == -1)\n\t\tthrow WriteError(error_msg);\n\n\trow++;\n}",
    "BOOL BitmapIO_TIF::WriteTIF(FILE *stream) {\n\t\n\tlong packw;\n\n    WORD y, j, k, l;\n\tunsigned long grey;\n\tint nstrip = 0;\n\n\ty = 0;\n\n\tdo {\n\t\trawcc = 0;\n#ifdef ALLOW_LZW_COMPRESSION\n\t\tif (UserData.compressed)\n\t\t\tLZWPreEncode();\n#endif //ALLOW_LZW_COMPRESSION\n\t\tfor (j=0; j<rps; j++) {\n\n\t\t\t/* remove the desired sample */\n\t\t\tif (UserData.writeType == tif_write_color) {\t\t\t\t/* color tiff */\n\t\t\t\t/* get a row and prepare for encoding */\n\t\t\t\tGetOutputPixels(0,y,width,scanline); // Get gamma-corrected pixels\n\t\t\t\tint index = 0;\n\t\t\t\tscanptr = scanline;\n\t\t\t\tfor(k = 0; k < width; k++, ++scanptr) {\n\t\t\t\t\tWORD *pixel = (WORD *)scanptr;\n\t\t\t\t\tfor(l = 0; l < spp; ++l)\n\t\t\t\t\t\tshortstrip[index++] = (BYTE)(pixel[l] >> 8);\n\t\t\t\t\t}\n\t\t\t\tpackw = width*spp;\n\t\t\t\t}\n\t\t\telse if (UserData.writeType == tif_write_mono)\n\t\t\t\t{\t\t\t\t\t\t\t\t\t/* grey scale tiff */\n\t\t\t\t/* get a row and prepare for encoding */\n\t\t\t\tGetOutputPixels(0,y,width,scanline); // Get gamma-corrected pixels\n\t\t\t\tscanptr = scanline;\n\t\t\t\tfor (k=0; k<width; k++, ++scanptr) {\n\t\t\t\t\tgrey = (unsigned long)scanptr->r * 30L;\t\t/* 30% red */\n\t\t\t\t\tgrey+= (unsigned long)scanptr->g * 59L;\t\t/* 59% green */\n\t\t\t\t\tgrey+= (unsigned long)scanptr->b * 11L;\t\t/* 11% blue */\n\t\t\t\t\tgrey/= 100L;\n\t\t\t\t\tshortstrip[k] = (BYTE)(grey >> 8);\n\t\t\t\t\t}\n\t\t\t\tpackw = width;\n\t\t\t\t}\n\t\t\telse if (UserData.writeType == tif_write_logl)\t\t/*Log-Luminance type tiff*/\n\t\t\t\t{\n\t\t\t\t//as long as we have set the tag TIFFTAG_SGILOGDATAFMT to realize float format - \n\t\t\t\t//and the tiff writer knows we're using logL, so we feed it an array of floats\n\t\t\t\t//for each row, calculated from the BMM_Color_fl we have from GetLinearPixels().\n\t\t\t\tif (Storage()->IsHighDynamicRange())\n\t\t\t\t\t{\n\t\t\t\t\tint type = 0;\n\t\t\t\t\tif (Storage() && Storage()->GetStoragePtr(&type) && type == BMM_LOGLUV_32)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tLogLUV32Pixel* pixel = (LogLUV32Pixel*)Storage()->GetStoragePtr(&type);\n\t\t\t\t\t\tpixel += y*width;\n\t\t\t\t\t\t//we're writing in float format, so we have to convert each pixel's luminance to float.\n\t\t\t\t\t\tfloat* lum = (float*)shortstrip;\n\t\t\t\t\t\tfor (k=0; k<width; k++, pixel++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlum[k] = (float)pix16toY((int)pixel->value >> 16);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t/* get a row and prepare for encoding */\n\t\t\t\t\tGetOutputPixels(0,y,width,scanline); // Get gamma-corrected pixels\n\t\t\t\t\tscanptr = scanline;\n\t\t\t\t\tfloat* lum = (float*)shortstrip;//cast to float\n\t\t\t\t\tfor (k=0; k<width; k++, ++scanptr) \n\t\t\t\t\t\t{\n\t\t\t\t\t\tstatic LogLUV24Pixel converter;\n\t\t\t\t\t\tBMM_Color_64 rgb = *scanptr;\n\t\t\t\t\t\tColor rgbColor (rgb);//construct float color struct from BMM_Color_64\n\t\t\t\t\t\tColor xyz;\n\t\t\t\t\t\tconverter.RGBtoXYZ(rgbColor, xyz);//convert rgb values to adjust for human sensitivity.\n\t\t\t\t\t\tlum[k] = (xyz.r + xyz.g + xyz.b)/3;//uh... integrate? to get grey value from xyz coordinates\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\telse if (UserData.writeType == tif_write_logluv)\n\t\t\t\t{\n\t\t\t\t\n\t\t\t\tif (Storage()->IsHighDynamicRange())\n\t\t\t\t\t//the header should have already been set to SGILOGDATAFMT_RAW, so that we can just \n\t\t\t\t\t//grab the data storage of the bitmap, and feed it to the tiffwriter, row by row.\n\t\t\t\t\n\t\t\t\t\t{\n\t\t\t\t\tStorage()->GetPixels(0, y, width, (BMM_Color_fl*)scanline); //no gamma correction, HDR from LogLUV storage.\n\t\t\t\t\tBMM_Color_fl* scanPtrHDR = (BMM_Color_fl*)scanline;\n\t\t\t\t\tColor* lum = (Color*)shortstrip;\n\t\t\t\t\tfor (k=0; k<width; k++, scanPtrHDR++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tstatic LogLUV32Pixel converter;\n\t\t\t\t\t\tColor xyz;\n\t\t\t\t\t\tconverter.RGBtoXYZ(*scanPtrHDR, xyz);\n\t\t\t\t\t\tlum[k] = xyz;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\telse//conversion from native type.\n\t\t\t\t\t{\n\t\t\t\t\t/* get a row and prepare for encoding */\n\t\t\t\t\tGetOutputPixels(0,y,width,scanline); // Get gamma-corrected pixels\n\t\t\t\t\tscanptr = scanline;\n\t\t\t\t\tColor* lum = (Color*)shortstrip;\n\t\t\t\t\tfor (k=0; k<width; k++, ++scanptr)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tstatic LogLUV32Pixel converter;\n\t\t\t\t\t\tBMM_Color_64 rgb = *scanptr;\n\t\t\t\t\t\tColor rgbColor (rgb);\n\t\t\t\t\t\tColor xyz;\n\t\t\t\t\t\tconverter.RGBtoXYZ(rgbColor, xyz);//Adjust for human sensitivity.\n\t\t\t\t\t\tlum[k] = xyz;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tTIFFError(\"tif.cpp\", GetString(IDS_NO_WRITE_ALGORITHM));\n#ifdef ALLOW_LZW_COMPRESSION\n\t\t\tif (UserData.compressionType == tif_compress_lzw)\n\t\t\t\tLZWEncode(shortstrip, packw);\n\t\t\telse {\n#endif //ALLOW_LZW_COMPRESSION\n\t\t\t\tTIFFWriteScanline(tif, shortstrip, y);//copy the scanline to the tif output buffer.\n\t\t\t\trawcc+= packw;\n#ifdef ALLOW_LZW_COMPRESSION\n\t\t\t\t}\n#endif //ALLOW_LZW_COMPRESSION\n\t\t\ty++;\n\t\t\tif (y == height) break;\n\t\t\t}\n\n#ifdef ALLOW_LZW_COMPRESSION\n\t\tif (UserData.compressionType == tif_compress_lzw)\n\t\t\tLZWPostEncode();\n#endif //ALLOW_LZW_COMPRESSION\n\n\t\t}\twhile (y != height);\n\n\treturn TRUE;\n\t}",
    "bool wxTIFFHandler::SaveFile( wxImage *image, wxOutputStream& stream, bool verbose )\r\n{\r\n    TIFF *tif = TIFFwxOpen( stream, \"image\", \"w\" );\r\n\r\n    if (!tif)\r\n    {\r\n        if (verbose)\r\n        {\r\n            wxLogError( _(\"TIFF: Error saving image.\") );\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    TIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\r\n    TIFFSetField(tif, TIFFTAG_IMAGEWIDTH,  (uint32)image->GetWidth());\r\n    TIFFSetField(tif, TIFFTAG_IMAGELENGTH, (uint32)image->GetHeight());\r\n    TIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\r\n    TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\r\n\r\n    // save the image resolution if we have it\r\n    int xres, yres;\r\n    const wxImageResolution res = GetResolutionFromOptions(*image, &xres, &yres);\r\n    uint16 tiffRes;\r\n    switch ( res )\r\n    {\r\n        default:\r\n            wxFAIL_MSG( wxT(\"unknown image resolution units\") );\r\n            // fall through\r\n\r\n        case wxIMAGE_RESOLUTION_NONE:\r\n            tiffRes = RESUNIT_NONE;\r\n            break;\r\n\r\n        case wxIMAGE_RESOLUTION_INCHES:\r\n            tiffRes = RESUNIT_INCH;\r\n            break;\r\n\r\n        case wxIMAGE_RESOLUTION_CM:\r\n            tiffRes = RESUNIT_CENTIMETER;\r\n            break;\r\n    }\r\n\r\n    if ( tiffRes != RESUNIT_NONE )\r\n    {\r\n        TIFFSetField(tif, TIFFTAG_RESOLUTIONUNIT, tiffRes);\r\n        TIFFSetField(tif, TIFFTAG_XRESOLUTION, (float)xres);\r\n        TIFFSetField(tif, TIFFTAG_YRESOLUTION, (float)yres);\r\n    }\r\n\r\n\r\n    int spp = image->GetOptionInt(wxIMAGE_OPTION_SAMPLESPERPIXEL);\r\n    if ( !spp )\r\n        spp = 3;\r\n\r\n    int bpp = image->GetOptionInt(wxIMAGE_OPTION_BITSPERSAMPLE);\r\n    if ( !bpp )\r\n        bpp = 8;\r\n\r\n    int compression = image->GetOptionInt(wxIMAGE_OPTION_COMPRESSION);\r\n    if ( !compression )\r\n    {\r\n        // we can't use COMPRESSION_LZW because current version of libtiff\r\n        // doesn't implement it (\"no longer implemented due to Unisys patent\r\n        // enforcement\") and other compression methods are lossy so we\r\n        // shouldn't use them by default -- and the only remaining one is none\r\n        compression = COMPRESSION_NONE;\r\n    }\r\n\r\n    TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, spp);\r\n    TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, bpp);\r\n    TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, spp*bpp == 1 ? PHOTOMETRIC_MINISBLACK\r\n                                                        : PHOTOMETRIC_RGB);\r\n    TIFFSetField(tif, TIFFTAG_COMPRESSION, compression);\r\n\r\n    // scanlinesize if determined by spp and bpp\r\n    tsize_t linebytes = (tsize_t)image->GetWidth() * spp * bpp / 8;\r\n\r\n    if ( (image->GetWidth() % 8 > 0) && (spp * bpp < 8) )\r\n        linebytes+=1;\r\n\r\n    unsigned char *buf;\r\n\r\n    if (TIFFScanlineSize(tif) > linebytes || (spp * bpp < 24))\r\n    {\r\n        buf = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(tif));\r\n        if (!buf)\r\n        {\r\n            if (verbose)\r\n            {\r\n                wxLogError( _(\"TIFF: Couldn't allocate memory.\") );\r\n            }\r\n\r\n            TIFFClose( tif );\r\n\r\n            return false;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        buf = NULL;\r\n    }\r\n\r\n    TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP,TIFFDefaultStripSize(tif, (uint32) -1));\r\n\r\n    unsigned char *ptr = image->GetData();\r\n    for ( int row = 0; row < image->GetHeight(); row++ )\r\n    {\r\n        if ( buf )\r\n        {\r\n            if ( spp * bpp > 1 )\r\n            {\r\n                // color image\r\n                memcpy(buf, ptr, image->GetWidth());\r\n            }\r\n            else // black and white image\r\n            {\r\n                for ( int column = 0; column < linebytes; column++ )\r\n                {\r\n                    uint8 reverse = 0;\r\n                    for ( int bp = 0; bp < 8; bp++ )\r\n                    {\r\n                        if ( ptr[column*24 + bp*3] > 0 )\r\n                        {\r\n                            // check only red as this is sufficient\r\n                            reverse = (uint8)(reverse | 128 >> bp);\r\n                        }\r\n                    }\r\n\r\n                    buf[column] = reverse;\r\n                }\r\n            }\r\n        }\r\n\r\n        if ( TIFFWriteScanline(tif, buf ? buf : ptr, (uint32)row, 0) < 0 )\r\n        {\r\n            if (verbose)\r\n            {\r\n                wxLogError( _(\"TIFF: Error writing image.\") );\r\n            }\r\n\r\n            TIFFClose( tif );\r\n            if (buf)\r\n                _TIFFfree(buf);\r\n\r\n            return false;\r\n        }\r\n\r\n        ptr += image->GetWidth()*3;\r\n    }\r\n\r\n    (void) TIFFClose(tif);\r\n\r\n    if (buf)\r\n        _TIFFfree(buf);\r\n\r\n    return true;\r\n}",
    "bool _writeTIFF(const char *filename, char *imagedata, unsigned width, unsigned height, unsigned numcolors, unsigned numbits, std::map<std::string,std::string> info, char *iccprofile, unsigned iccprofilelength)\n{\n\tchar *img;\n\tunsigned char *buf;\n\tuint32_t w, h;\n\tuint16_t c, b;\n\t\n\tTIFFSetErrorHandler(0);\n\n\tTIFF* tif = TIFFOpen(filename, \"w\");\n\tif (tif) {\n\n\t\tTIFFSetField(tif, TIFFTAG_IMAGEWIDTH, width);  \n\t\tTIFFSetField(tif, TIFFTAG_IMAGELENGTH, height);    \n\t\tTIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, numcolors);   \n\t\tTIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, numbits);\n\t\tif (numbits == 8 | numbits == 16)\n\t\t\tTIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT);\n\t\telse if (numbits == 32)\n\t\t\tTIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);\n\t\telse\n\t\t\treturn false;\n\t\tTIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);   \n\n\t\tTIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\t\tTIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n\t\tTIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_NONE); //todo: COMPRESSION_ADOBE_DEFLATE);\n\t\t// We set the strip size of the file to be size of one row of pixels\n\t\tTIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, TIFFDefaultStripSize(tif, width*numcolors));\n\n\t\t//if (info.find(\"Artist\") != info.end())  TIFFSetField(tif, TIFFTAG_ARTIST, info[\"Artist\"].c_str());\n\t\t//if (info.find(\"Make\") != info.end())  TIFFSetField(tif, TIFFTAG_MAKE, info[\"Make\"].c_str());\n\t\t//if (info.find(\"Model\") != info.end())  TIFFSetField(tif, TIFFTAG_MODEL, info[\"Model\"].c_str());\n\t\t//if (info.find(\"Software\") != info.end())  TIFFSetField(tif, TIFFTAG_SOFTWARE, info[\"Software\"].c_str());\n\t\t//if (info.find(\"Copyright\") != info.end())  TIFFSetField(tif, TIFFTAG_COPYRIGHT, info[\"Copyright\"].c_str());\n\t\t//if (info.find(\"LensInfo\") != info.end())  TIFFSetField(tif, TIFFTAG_LENSINFO, info[\"LensInfo\"].c_str());\n\t\t//if (info.find(\"DateTime\") != info.end()) TIFFSetField(tif, TIFFTAG_DATETIME, info[\"DateTime\"].c_str());\n\t\t//if (info.find(\"ImageDescription\") != info.end())  TIFFSetField(tif, TIFFTAG_IMAGEDESCRIPTION, info[\"ImageDescription\"].c_str());\n\t\t//if (info.find(\"Orientation\") != info.end()) {\n\t\t//\tuint16_t orient = (uint16_t) atoi(info[\"Orientation\"].c_str());\n\t\t//\tTIFFSetField(tif, TIFFTAG_ORIENTATION, 1, &orient);\n\t\t//}\n\n\t\t//if (iccprofile) TIFFSetField(tif, TIFFTAG_ICCPROFILE, iccprofilelength, iccprofile);\n\t\t\t\t\n\t\tunsigned scanlinesize = TIFFScanlineSize(tif);\n\t\tbuf = (unsigned char *) _TIFFmalloc(scanlinesize);\n\t\timg = imagedata;\n\n\t\tfor (unsigned row = 0; row < height; row++)\n\t\t{\n\t\t\tmemcpy(buf, img, scanlinesize);\n\t\t\tif (TIFFWriteScanline(tif, buf, row, 0) < 0) {\n\t\t\t\tprintf(\"TIFFWriteScanline got an error...\\n\");\n\t\t\t\tTIFFError(NULL,NULL);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\timg+=scanlinesize;\n\t\t}\n\n\t\tTIFFWriteDirectory( tif );\n\n\t\t(void) TIFFClose(tif);\n\t\tif (buf) _TIFFfree(buf);\n\t\treturn true;\n\t}\n\telse return true;\n\n}",
    "int ImageIO::saveTIFF (const Glib::ustring &fname, int bps, bool isFloat, bool uncompressed) const\n{\n    if (getWidth() < 1 || getHeight() < 1) {\n        return IMIO_HEADERERROR;\n    }\n\n    bool writeOk = true;\n    int width = getWidth ();\n    int height = getHeight ();\n\n    if (bps < 0) {\n        bps = getBPS ();\n    }\n\n    int lineWidth = width * 3 * bps / 8;\n    unsigned char* linebuffer = new unsigned char[lineWidth];\n\n    // little hack to get libTiff to use proper byte order (see TIFFClienOpen()):\n    const char *mode = \"w\";\n#ifdef WIN32\n    FILE *file = g_fopen_withBinaryAndLock (fname);\n    int fileno = _fileno(file);\n    int osfileno = _get_osfhandle(fileno);\n    TIFF* out = TIFFFdOpen (osfileno, fname.c_str(), mode);\n#else\n    TIFF* out = TIFFOpen(fname.c_str(), mode);\n    // int fileno = TIFFFileno (out);\n#endif\n\n    if (!out) {\n        delete [] linebuffer;\n        return IMIO_CANNOTWRITEFILE;\n    }\n\n    if (pl) {\n        pl->setProgressStr (\"PROGRESSBAR_SAVETIFF\");\n        pl->setProgress (0.0);\n    }\n\n    bool needsReverse = false;\n\n    TIFFSetField (out, TIFFTAG_SOFTWARE, RTNAME \" \" RTVERSION);\n    TIFFSetField (out, TIFFTAG_IMAGEWIDTH, width);\n    TIFFSetField (out, TIFFTAG_IMAGELENGTH, height);\n    TIFFSetField (out, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n    TIFFSetField (out, TIFFTAG_SAMPLESPERPIXEL, 3);\n    TIFFSetField (out, TIFFTAG_ROWSPERSTRIP, height);\n    TIFFSetField (out, TIFFTAG_BITSPERSAMPLE, bps);\n    TIFFSetField (out, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    TIFFSetField (out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n    TIFFSetField (out, TIFFTAG_COMPRESSION, uncompressed ? COMPRESSION_NONE : COMPRESSION_ADOBE_DEFLATE);\n    TIFFSetField (out, TIFFTAG_SAMPLEFORMAT, (bps == 16 || bps == 32) && isFloat ? SAMPLEFORMAT_IEEEFP : SAMPLEFORMAT_UINT);\n\n    // somehow Exiv2 (tested with 0.27.3) doesn't seem to be able to update\n    // XResolution and YResolution, so we do it ourselves here....\n    constexpr float default_resolution = 300.f;\n    float x_res = default_resolution;\n    float y_res = default_resolution;\n    int res_unit = RESUNIT_INCH;\n    if (!metadataInfo.filename().empty()) {\n        auto exif = metadataInfo.getOutputExifData();\n        auto it = exif.findKey(Exiv2::ExifKey(\"Exif.Image.XResolution\"));\n        if (it != exif.end()) {\n            x_res = it->toFloat();\n        }\n        it = exif.findKey(Exiv2::ExifKey(\"Exif.Image.YResolution\"));\n        if (it != exif.end()) {\n            y_res = it->toFloat();\n        }\n        it = exif.findKey(Exiv2::ExifKey(\"Exif.Image.ResolutionUnit\"));\n        if (it != exif.end()) {\n            res_unit = exiv2_to_long(*it);\n        }\n    }\n    TIFFSetField(out, TIFFTAG_XRESOLUTION, x_res);\n    TIFFSetField(out, TIFFTAG_YRESOLUTION, y_res);\n    TIFFSetField(out, TIFFTAG_RESOLUTIONUNIT, res_unit);\n\n    if (!uncompressed) {\n        TIFFSetField (out, TIFFTAG_PREDICTOR, (bps == 16 || bps == 32) && isFloat ? PREDICTOR_FLOATINGPOINT : PREDICTOR_HORIZONTAL);\n    }\n    if (profileData) {\n        TIFFSetField (out, TIFFTAG_ICCPROFILE, profileLength, profileData);\n    }\n\n    for (int row = 0; row < height; row++) {\n        getScanline (row, linebuffer, bps, isFloat);\n\n        if (bps == 16) {\n            if(needsReverse && !uncompressed && isFloat) {\n                for(int i = 0; i < lineWidth; i += 2) {\n                    char temp = linebuffer[i];\n                    linebuffer[i] = linebuffer[i + 1];\n                    linebuffer[i + 1] = temp;\n                }\n            }\n        } else if (bps == 32) {\n            if(needsReverse && !uncompressed) {\n                for(int i = 0; i < lineWidth; i += 4) {\n                    char temp = linebuffer[i];\n                    linebuffer[i] = linebuffer[i + 3];\n                    linebuffer[i + 3] = temp;\n                    temp = linebuffer[i + 1];\n                    linebuffer[i + 1] = linebuffer[i + 2];\n                    linebuffer[i + 2] = temp;\n                }\n            }\n        }\n\n        if (TIFFWriteScanline (out, linebuffer, row, 0) < 0) {\n            TIFFClose (out);\n            delete [] linebuffer;\n            return IMIO_CANNOTWRITEFILE;\n        }\n\n        if (pl && !(row % 100)) {\n            pl->setProgress ((double)(row + 1) / height);\n        }\n    }\n\n    if (TIFFFlush(out) != 1) {\n        writeOk = false;\n    }\n\n    TIFFClose (out);\n#ifdef WIN32\n    fclose (file);\n#endif\n\n    delete [] linebuffer;\n\n    if (!saveMetadata(fname)) {\n        writeOk = false;\n    }\n\n    if (pl) {\n        pl->setProgressStr (\"PROGRESSBAR_READY\");\n        pl->setProgress (1.0);\n    }\n\n    if(writeOk) {\n        return IMIO_SUCCESS;\n    } else {\n        g_remove (fname.c_str());\n        return IMIO_CANNOTWRITEFILE;\n    }\n}",
    "WriteResult::WriteStatus writeTIFStream(std::ostream& fout, const osg::Image& img, const osgDB::ReaderWriter::Options* options) const\n        {\n            int compressionType = COMPRESSION_PACKBITS;\n            if (options) {\n                std::istringstream iss(options->getOptionString());\n                std::string opt;\n                while (iss >> opt) {\n                    opt = osgDB::convertToLowerCase(opt);\n\n                    std::size_t eqInd = opt.find(\"=\");\n                    if (opt.substr(0, eqInd) == \"tiff_compression\") {\n                        std::string compressTypeOpt;\n                        compressTypeOpt = opt.substr(eqInd + 1);\n                        compressTypeOpt = osgDB::convertToLowerCase(compressTypeOpt);\n                        if (compressTypeOpt == \"packbits\") {\n                            compressionType = COMPRESSION_PACKBITS;\n                        }\n                        else if (compressTypeOpt == \"lzw\") {\n                            compressionType = COMPRESSION_LZW;\n                        }\n                        else if (compressTypeOpt == \"jpeg\") {\n                            compressionType = COMPRESSION_JPEG;\n                        }\n                    }\n                }\n            }\n\n\n            //Code is based from the following article on CodeProject.com\n            //http://www.codeproject.com/bitmap/BitmapsToTiffs.asp\n\n            TIFF *image;\n            int samplesPerPixel;\n            int bitsPerSample;\n            uint16 photometric;\n\n            image = TIFFClientOpen(\"outputstream\", \"w\", (thandle_t)&fout,\n                                    libtiffOStreamReadProc, //Custom read function\n                                    libtiffOStreamWriteProc, //Custom write function\n                                    libtiffOStreamSeekProc, //Custom seek function\n                                    libtiffStreamCloseProc, //Custom close function\n                                    libtiffOStreamSizeProc, //Custom size function\n                                    libtiffStreamMapProc, //Custom map function\n                                    libtiffStreamUnmapProc); //Custom unmap function\n\n            if(image == NULL)\n            {\n                return WriteResult::ERROR_IN_WRITING_FILE;\n            }\n\n            switch(img.getPixelFormat()) {\n                case GL_DEPTH_COMPONENT:\n                case GL_LUMINANCE:\n                case GL_ALPHA:\n                    photometric = PHOTOMETRIC_MINISBLACK;\n                    samplesPerPixel = 1;\n                    break;\n                case GL_LUMINANCE_ALPHA:\n                    photometric = PHOTOMETRIC_MINISBLACK;\n                    samplesPerPixel = 2;\n                    break;\n                case GL_RGB:\n                    photometric = PHOTOMETRIC_RGB;\n                    samplesPerPixel = 3;\n                    break;\n                case GL_RGBA:\n                    photometric = PHOTOMETRIC_RGB;\n                    samplesPerPixel = 4;\n                    break;\n                default:\n                    return WriteResult::ERROR_IN_WRITING_FILE;\n                    break;\n            }\n\n            switch(img.getDataType()){\n                case GL_FLOAT:\n                    TIFFSetField(image, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);\n                    TIFFSetField(image, TIFFTAG_ROWSPERSTRIP, 1);\n                    bitsPerSample = 32;\n                    break;\n                case GL_SHORT:\n                    TIFFSetField(image, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_INT);\n                    bitsPerSample = 16;\n                    break;\n                default:\n                    bitsPerSample = 8;\n                    break;\n            }\n\n            TIFFSetField(image, TIFFTAG_IMAGEWIDTH,img.s());\n            TIFFSetField(image, TIFFTAG_IMAGELENGTH,img.t());\n            TIFFSetField(image, TIFFTAG_BITSPERSAMPLE,bitsPerSample);\n            TIFFSetField(image, TIFFTAG_SAMPLESPERPIXEL,samplesPerPixel);\n            TIFFSetField(image, TIFFTAG_PHOTOMETRIC, photometric);\n            TIFFSetField(image, TIFFTAG_COMPRESSION, compressionType);\n            TIFFSetField(image, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);\n            TIFFSetField(image, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\n            //uint32 rowsperstrip = TIFFDefaultStripSize(image, -1);\n            //TIFFSetField(image, TIFFTAG_ROWSPERSTRIP, rowsperstrip);\n\n            // Write the information to the file\n            for(int i = 0; i < img.t(); ++i) {\n                TIFFWriteScanline(image,(tdata_t)img.data(0,img.t()-i-1),i,0);\n            }\n\n            // Close the file\n            TIFFClose(image);\n\n            return WriteResult::FILE_SAVED;\n        }",
    "GDALDataset *\nGTiffDataset::CreateCopy( const char * pszFilename, GDALDataset *poSrcDS, \n                          int bStrict, char ** papszOptions, \n                          GDALProgressFunc pfnProgress, void * pProgressData )\n\n{\n    TIFF\t*hTIFF;\n    int\t\tnXSize = poSrcDS->GetRasterXSize();\n    int\t\tnYSize = poSrcDS->GetRasterYSize();\n    int\t\tnBands = poSrcDS->GetRasterCount();\n    int         iBand;\n    CPLErr      eErr = CE_None;\n    uint16\tnPlanarConfig;\n    uint16\tnBitsPerSample;\n    GDALRasterBand *poPBand;\n\n    if( poSrcDS->GetRasterCount() == 0 )\n    {\n        CPLError( CE_Failure, CPLE_AppDefined,\n                  \"Unable to export GeoTIFF files with zero bands.\" );\n        return NULL;\n    }\n        \n    poPBand = poSrcDS->GetRasterBand(1);\n    GDALDataType eType = poPBand->GetRasterDataType();\n\n/* -------------------------------------------------------------------- */\n/*      Check, whether all bands in input dataset has the same type.    */\n/* -------------------------------------------------------------------- */\n    for ( iBand = 2; iBand <= nBands; iBand++ )\n    {\n        if ( eType != poSrcDS->GetRasterBand(iBand)->GetRasterDataType() )\n        {\n            if ( bStrict )\n            {\n                CPLError( CE_Failure, CPLE_AppDefined,\n                          \"Unable to export GeoTIFF file with different datatypes per\\n\"\n                          \"different bands. All bands should have the same types in TIFF.\" );\n                return NULL;\n            }\n            else\n            {\n                CPLError( CE_Warning, CPLE_AppDefined,\n                          \"Unable to export GeoTIFF file with different datatypes per\\n\"\n                          \"different bands. All bands should have the same types in TIFF.\" );\n            }\n        }\n    }\n\n    if( !pfnProgress( 0.0, NULL, pProgressData ) )\n        return NULL;\n\n/* -------------------------------------------------------------------- */\n/*      Capture the profile.                                            */\n/* -------------------------------------------------------------------- */\n    const char          *pszProfile;\n    int                 bGeoTIFF;\n\n    pszProfile = CSLFetchNameValue(papszOptions,\"PROFILE\");\n    if( pszProfile == NULL )\n        pszProfile = \"GDALGeoTIFF\";\n\n    if( !EQUAL(pszProfile,\"BASELINE\") \n        && !EQUAL(pszProfile,\"GeoTIFF\") \n        && !EQUAL(pszProfile,\"GDALGeoTIFF\") )\n    {\n        CPLError( CE_Failure, CPLE_AppDefined, \n                  \"PROFILE=%s not supported in GTIFF driver.\", \n                  pszProfile );\n        return NULL;\n    }\n    \n    if( EQUAL(pszProfile,\"BASELINE\") )\n        bGeoTIFF = FALSE;\n    else\n        bGeoTIFF = TRUE;\n\n/* -------------------------------------------------------------------- */\n/*      Special handling for NBITS.  Copy from band metadata if found.  */\n/* -------------------------------------------------------------------- */\n    char     **papszCreateOptions = CSLDuplicate( papszOptions );\n\n    if( poPBand->GetMetadataItem( \"NBITS\", \"IMAGE_STRUCTURE\" ) != NULL \n        && atoi(poPBand->GetMetadataItem( \"NBITS\", \"IMAGE_STRUCTURE\" )) > 0\n        && CSLFetchNameValue( papszCreateOptions, \"NBITS\") == NULL )\n    {\n        papszCreateOptions = \n            CSLSetNameValue( papszCreateOptions, \"NBITS\",\n                             poPBand->GetMetadataItem( \"NBITS\", \n                                                       \"IMAGE_STRUCTURE\" ) );\n    }\n\n    if( CSLFetchNameValue( papszOptions, \"PIXELTYPE\" ) == NULL\n        && eType == GDT_Byte\n        && poPBand->GetMetadataItem( \"PIXELTYPE\", \"IMAGE_STRUCTURE\" ) )\n    {\n        papszCreateOptions = \n            CSLSetNameValue( papszCreateOptions, \"PIXELTYPE\", \n                             poPBand->GetMetadataItem( \n                                 \"PIXELTYPE\", \"IMAGE_STRUCTURE\" ) );\n    }\n    \n    int nSrcOverviews = poSrcDS->GetRasterBand(1)->GetOverviewCount();\n    double dfExtraSpaceForOverviews = 0;\n    if (nSrcOverviews != 0 &&\n        CSLFetchBoolean(papszOptions, \"COPY_SRC_OVERVIEWS\", FALSE))\n    {\n        int i;\n        for(i=0;i<nSrcOverviews;i++)\n        {\n            dfExtraSpaceForOverviews += ((double)poSrcDS->GetRasterBand(1)->GetOverview(i)->GetXSize()) *\n                                        poSrcDS->GetRasterBand(1)->GetOverview(i)->GetYSize();\n        }\n        dfExtraSpaceForOverviews *= nBands * (GDALGetDataTypeSize(eType) / 8);\n    }\n    \n/* -------------------------------------------------------------------- */\n/*      Create the file.                                                */\n/* -------------------------------------------------------------------- */\n    hTIFF = CreateLL( pszFilename, nXSize, nYSize, nBands, \n                      eType, dfExtraSpaceForOverviews, papszCreateOptions );\n\n    CSLDestroy( papszCreateOptions );\n\n    if( hTIFF == NULL )\n        return NULL;\n\n    TIFFGetField( hTIFF, TIFFTAG_PLANARCONFIG, &nPlanarConfig );\n    TIFFGetField(hTIFF, TIFFTAG_BITSPERSAMPLE, &nBitsPerSample );\n\n/* -------------------------------------------------------------------- */\n/*      Are we really producing an RGBA image?  If so, set the          */\n/*      associated alpha information.                                   */\n/* -------------------------------------------------------------------- */\n    int bForcePhotometric = \n        CSLFetchNameValue(papszOptions,\"PHOTOMETRIC\") != NULL;\n\n    if( nBands == 4 && !bForcePhotometric\n        && poSrcDS->GetRasterBand(4)->GetColorInterpretation()==GCI_AlphaBand)\n    {\n        uint16 v[1];\n\n        v[0] = EXTRASAMPLE_ASSOCALPHA;\n\tTIFFSetField(hTIFF, TIFFTAG_EXTRASAMPLES, 1, v);\n        TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If the output is jpeg compressed, and the input is RGB make     */\n/*      sure we note that.                                              */\n/* -------------------------------------------------------------------- */\n    uint16      nCompression;\n\n    if( !TIFFGetField( hTIFF, TIFFTAG_COMPRESSION, &(nCompression) ) )\n        nCompression = COMPRESSION_NONE;\n\n    if( nCompression == COMPRESSION_JPEG )\n    {\n        if( nBands >= 3 \n            && (poSrcDS->GetRasterBand(1)->GetColorInterpretation() \n                == GCI_YCbCr_YBand)\n            && (poSrcDS->GetRasterBand(2)->GetColorInterpretation() \n                == GCI_YCbCr_CbBand)\n            && (poSrcDS->GetRasterBand(3)->GetColorInterpretation() \n                == GCI_YCbCr_CrBand) )\n        {\n            /* do nothing ... */\n        }\n        else\n        {\n            /* we assume RGB if it isn't explicitly YCbCr */\n            CPLDebug( \"GTiff\", \"Setting JPEGCOLORMODE_RGB\" );\n            TIFFSetField( hTIFF, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB );\n        }\n    }\n        \n/* -------------------------------------------------------------------- */\n/*      Does the source image consist of one band, with a palette?      */\n/*      If so, copy over.                                               */\n/* -------------------------------------------------------------------- */\n    if( (nBands == 1 || nBands == 2) && poSrcDS->GetRasterBand(1)->GetColorTable() != NULL \n        && eType == GDT_Byte )\n    {\n        unsigned short\tanTRed[256], anTGreen[256], anTBlue[256];\n        GDALColorTable *poCT;\n\n        poCT = poSrcDS->GetRasterBand(1)->GetColorTable();\n        \n        for( int iColor = 0; iColor < 256; iColor++ )\n        {\n            if( iColor < poCT->GetColorEntryCount() )\n            {\n                GDALColorEntry  sRGB;\n\n                poCT->GetColorEntryAsRGB( iColor, &sRGB );\n\n                anTRed[iColor] = (unsigned short) (257 * sRGB.c1);\n                anTGreen[iColor] = (unsigned short) (257 * sRGB.c2);\n                anTBlue[iColor] = (unsigned short) (257 * sRGB.c3);\n            }\n            else\n            {\n                anTRed[iColor] = anTGreen[iColor] = anTBlue[iColor] = 0;\n            }\n        }\n\n        if( !bForcePhotometric )\n            TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_PALETTE );\n        TIFFSetField( hTIFF, TIFFTAG_COLORMAP, anTRed, anTGreen, anTBlue );\n    }\n    else if( (nBands == 1 || nBands == 2) \n             && poSrcDS->GetRasterBand(1)->GetColorTable() != NULL \n             && eType == GDT_UInt16 )\n    {\n        unsigned short\t*panTRed, *panTGreen, *panTBlue;\n        GDALColorTable *poCT;\n\n        panTRed   = (unsigned short *) CPLMalloc(65536*sizeof(unsigned short));\n        panTGreen = (unsigned short *) CPLMalloc(65536*sizeof(unsigned short));\n        panTBlue  = (unsigned short *) CPLMalloc(65536*sizeof(unsigned short));\n\n        poCT = poSrcDS->GetRasterBand(1)->GetColorTable();\n        \n        for( int iColor = 0; iColor < 65536; iColor++ )\n        {\n            if( iColor < poCT->GetColorEntryCount() )\n            {\n                GDALColorEntry  sRGB;\n\n                poCT->GetColorEntryAsRGB( iColor, &sRGB );\n\n                panTRed[iColor] = (unsigned short) (256 * sRGB.c1);\n                panTGreen[iColor] = (unsigned short) (256 * sRGB.c2);\n                panTBlue[iColor] = (unsigned short) (256 * sRGB.c3);\n            }\n            else\n            {\n                panTRed[iColor] = panTGreen[iColor] = panTBlue[iColor] = 0;\n            }\n        }\n\n        if( !bForcePhotometric )\n            TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_PALETTE );\n        TIFFSetField( hTIFF, TIFFTAG_COLORMAP, panTRed, panTGreen, panTBlue );\n\n        CPLFree( panTRed );\n        CPLFree( panTGreen );\n        CPLFree( panTBlue );\n    }\n    else if( poSrcDS->GetRasterBand(1)->GetColorTable() != NULL )\n        CPLError( CE_Warning, CPLE_AppDefined,\n                  \"Unable to export color table to GeoTIFF file.  Color tables\\n\"\n                  \"can only be written to 1 band or 2 bands Byte or UInt16 GeoTIFF files.\" );\n\n    if( nBands == 2\n        && poSrcDS->GetRasterBand(1)->GetColorTable() != NULL \n        && (eType == GDT_Byte || eType == GDT_UInt16) )\n    {\n        uint16 v[1] = { EXTRASAMPLE_UNASSALPHA };\n\n        TIFFSetField(hTIFF, TIFFTAG_EXTRASAMPLES, 1, v );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Transfer some TIFF specific metadata, if available.             */\n/*      The return value will tell us if we need to try again later with*/\n/*      PAM because the profile doesn't allow to write some metadata    */\n/*      as TIFF tag                                                     */\n/* -------------------------------------------------------------------- */\n    int bHasWrittenMDInGeotiffTAG =\n            GTiffDataset::WriteMetadata( poSrcDS, hTIFF, FALSE, pszProfile,\n                                 pszFilename, papszOptions );\n\n/* -------------------------------------------------------------------- */\n/* \tWrite NoData value, if exist.                                   */\n/* -------------------------------------------------------------------- */\n    if( EQUAL(pszProfile,\"GDALGeoTIFF\") )\n    {\n        int\t\tbSuccess;\n        double\tdfNoData;\n    \n        dfNoData = poSrcDS->GetRasterBand(1)->GetNoDataValue( &bSuccess );\n        if ( bSuccess )\n            GTiffDataset::WriteNoDataValue( hTIFF, dfNoData );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Are we addressing PixelIsPoint mode?                            */\n/* -------------------------------------------------------------------- */\n    bool bPixelIsPoint = false;\n    int  bPointGeoIgnore = FALSE;\n\n    if( poSrcDS->GetMetadataItem( GDALMD_AREA_OR_POINT ) \n        && EQUAL(poSrcDS->GetMetadataItem(GDALMD_AREA_OR_POINT),\n                 GDALMD_AOP_POINT) )\n    {\n        bPixelIsPoint = true;\n        bPointGeoIgnore = \n            CSLTestBoolean( CPLGetConfigOption(\"GTIFF_POINT_GEO_IGNORE\",\n                                               \"FALSE\") );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Write affine transform if it is meaningful.                     */\n/* -------------------------------------------------------------------- */\n    const char *pszProjection = NULL;\n    double      adfGeoTransform[6];\n    \n    if( poSrcDS->GetGeoTransform( adfGeoTransform ) == CE_None\n        && (adfGeoTransform[0] != 0.0 || adfGeoTransform[1] != 1.0\n            || adfGeoTransform[2] != 0.0 || adfGeoTransform[3] != 0.0\n            || adfGeoTransform[4] != 0.0 || adfGeoTransform[5] != 1.0 ))\n    {\n        if( bGeoTIFF )\n        {\n            if( adfGeoTransform[2] == 0.0 && adfGeoTransform[4] == 0.0 \n                && adfGeoTransform[5] < 0.0 )\n            {\n\n                double\tadfPixelScale[3], adfTiePoints[6];\n\n                adfPixelScale[0] = adfGeoTransform[1];\n                adfPixelScale[1] = fabs(adfGeoTransform[5]);\n                adfPixelScale[2] = 0.0;\n\n                TIFFSetField( hTIFF, TIFFTAG_GEOPIXELSCALE, 3, adfPixelScale );\n            \n                adfTiePoints[0] = 0.0;\n                adfTiePoints[1] = 0.0;\n                adfTiePoints[2] = 0.0;\n                adfTiePoints[3] = adfGeoTransform[0];\n                adfTiePoints[4] = adfGeoTransform[3];\n                adfTiePoints[5] = 0.0;\n                \n                if( bPixelIsPoint && !bPointGeoIgnore )\n                {\n                    adfTiePoints[3] += adfGeoTransform[1] * 0.5 + adfGeoTransform[2] * 0.5;\n                    adfTiePoints[4] += adfGeoTransform[4] * 0.5 + adfGeoTransform[5] * 0.5;\n                }\n\t    \n                TIFFSetField( hTIFF, TIFFTAG_GEOTIEPOINTS, 6, adfTiePoints );\n            }\n            else\n            {\n                double\tadfMatrix[16];\n\n                memset(adfMatrix,0,sizeof(double) * 16);\n\n                adfMatrix[0] = adfGeoTransform[1];\n                adfMatrix[1] = adfGeoTransform[2];\n                adfMatrix[3] = adfGeoTransform[0];\n                adfMatrix[4] = adfGeoTransform[4];\n                adfMatrix[5] = adfGeoTransform[5];\n                adfMatrix[7] = adfGeoTransform[3];\n                adfMatrix[15] = 1.0;\n                \n                if( bPixelIsPoint && !bPointGeoIgnore )\n                {\n                    adfMatrix[3] += adfGeoTransform[1] * 0.5 + adfGeoTransform[2] * 0.5;\n                    adfMatrix[7] += adfGeoTransform[4] * 0.5 + adfGeoTransform[5] * 0.5;\n                }\n\n                TIFFSetField( hTIFF, TIFFTAG_GEOTRANSMATRIX, 16, adfMatrix );\n            }\n            \n            pszProjection = poSrcDS->GetProjectionRef();\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Do we need a TFW file?                                          */\n/* -------------------------------------------------------------------- */\n        if( CSLFetchBoolean( papszOptions, \"TFW\", FALSE ) )\n            GDALWriteWorldFile( pszFilename, \"tfw\", adfGeoTransform );\n        else if( CSLFetchBoolean( papszOptions, \"WORLDFILE\", FALSE ) )\n            GDALWriteWorldFile( pszFilename, \"wld\", adfGeoTransform );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Otherwise write tiepoints if they are available.                */\n/* -------------------------------------------------------------------- */\n    else if( poSrcDS->GetGCPCount() > 0 && bGeoTIFF )\n    {\n        const GDAL_GCP *pasGCPs = poSrcDS->GetGCPs();\n        double\t*padfTiePoints;\n\n        padfTiePoints = (double *) \n            CPLMalloc(6*sizeof(double)*poSrcDS->GetGCPCount());\n\n        for( int iGCP = 0; iGCP < poSrcDS->GetGCPCount(); iGCP++ )\n        {\n\n            padfTiePoints[iGCP*6+0] = pasGCPs[iGCP].dfGCPPixel;\n            padfTiePoints[iGCP*6+1] = pasGCPs[iGCP].dfGCPLine;\n            padfTiePoints[iGCP*6+2] = 0;\n            padfTiePoints[iGCP*6+3] = pasGCPs[iGCP].dfGCPX;\n            padfTiePoints[iGCP*6+4] = pasGCPs[iGCP].dfGCPY;\n            padfTiePoints[iGCP*6+5] = pasGCPs[iGCP].dfGCPZ;\n\n            if( bPixelIsPoint && !bPointGeoIgnore )\n            {\n                padfTiePoints[iGCP*6+0] += 0.5;\n                padfTiePoints[iGCP*6+1] += 0.5;\n            }\n        }\n\n        TIFFSetField( hTIFF, TIFFTAG_GEOTIEPOINTS, \n                      6*poSrcDS->GetGCPCount(), padfTiePoints );\n        CPLFree( padfTiePoints );\n        \n        pszProjection = poSrcDS->GetGCPProjection();\n        \n        if( CSLFetchBoolean( papszOptions, \"TFW\", FALSE ) \n            || CSLFetchBoolean( papszOptions, \"WORLDFILE\", FALSE ) )\n        {\n            CPLError(CE_Warning, CPLE_AppDefined,\n                     \"TFW=ON or WORLDFILE=ON creation options are ignored when GCPs are available\");\n        }\n    }\n\n    else\n        pszProjection = poSrcDS->GetProjectionRef();\n\n/* -------------------------------------------------------------------- */\n/*      Write the projection information, if possible.                  */\n/* -------------------------------------------------------------------- */\n    if( pszProjection != NULL && strlen(pszProjection) > 0 && bGeoTIFF )\n    {\n        GTIF\t*psGTIF;\n\n        psGTIF = GTIFNew( hTIFF );\n        GTIFSetFromOGISDefn( psGTIF, pszProjection );\n\n        if( poSrcDS->GetMetadataItem( GDALMD_AREA_OR_POINT ) \n            && EQUAL(poSrcDS->GetMetadataItem(GDALMD_AREA_OR_POINT),\n                     GDALMD_AOP_POINT) )\n        {\n            GTIFKeySet(psGTIF, GTRasterTypeGeoKey, TYPE_SHORT, 1,\n                       RasterPixelIsPoint);\n        }\n\n        GTIFWriteKeys( psGTIF );\n        GTIFFree( psGTIF );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If we are writing jpeg compression we need to write some        */\n/*      imagery to force the jpegtables to get created.  This is,       */\n/*      likely only needed with libtiff >= 3.9.3 (#3633)                */\n/* -------------------------------------------------------------------- */\n    int bDontReloadFirstBlock = FALSE;\n    if( nCompression == COMPRESSION_JPEG\n        && strstr(TIFFLIB_VERSION_STR, \"Version 3.9\") != NULL )\n    {\n        CPLDebug( \"GDAL\", \n                  \"Writing zero block to force creation of JPEG tables.\" );\n        if( TIFFIsTiled( hTIFF ) )\n        {\n            int cc = TIFFTileSize( hTIFF );\n            unsigned char *pabyZeros = (unsigned char *) CPLCalloc(cc,1);\n            TIFFWriteEncodedTile(hTIFF, 0, pabyZeros, cc);\n            CPLFree( pabyZeros );\n        }\n        else\n        {\n            int cc = TIFFStripSize( hTIFF );\n            unsigned char *pabyZeros = (unsigned char *) CPLCalloc(cc,1);\n            TIFFWriteEncodedStrip(hTIFF, 0, pabyZeros, cc);\n            CPLFree( pabyZeros );\n        }\n        bDontReloadFirstBlock = TRUE;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Cleanup                                                         */\n/* -------------------------------------------------------------------- */\n    \n    TIFFWriteCheck( hTIFF, TIFFIsTiled(hTIFF), \"GTiffCreateCopy()\");\n    TIFFWriteDirectory( hTIFF );\n    TIFFFlush( hTIFF );\n    XTIFFClose( hTIFF );\n    hTIFF = NULL;\n\n    if( eErr != CE_None )\n    {\n        VSIUnlink( pszFilename );\n        return NULL;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Re-open as a dataset and copy over missing metadata using       */\n/*      PAM facilities.                                                 */\n/* -------------------------------------------------------------------- */\n    GTiffDataset *poDS;\n    CPLString osFileName(\"GTIFF_RAW:\");\n\n    osFileName += pszFilename;\n\n    poDS = (GTiffDataset *) GDALOpen( osFileName, GA_Update );\n    if( poDS == NULL )\n        poDS = (GTiffDataset *) GDALOpen( osFileName, GA_ReadOnly );\n\n    if ( poDS == NULL )\n    {\n        VSIUnlink( pszFilename );\n        return NULL;\n    }\n\n    poDS->osProfile = pszProfile;\n    poDS->CloneInfo( poSrcDS, GCIF_PAM_DEFAULT & ~GCIF_MASK );\n    poDS->papszCreationOptions = CSLDuplicate( papszOptions );\n    poDS->bDontReloadFirstBlock = bDontReloadFirstBlock;\n\n/* -------------------------------------------------------------------- */\n/*      CloneInfo() doesn't merge metadata, it just replaces it totally */\n/*      So we have to merge it                                          */\n/* -------------------------------------------------------------------- */\n\n    char **papszSRC_MD = poSrcDS->GetMetadata();\n    char **papszDST_MD = CSLDuplicate(poDS->GetMetadata());\n\n    papszDST_MD = CSLMerge( papszDST_MD, papszSRC_MD );\n\n    poDS->SetMetadata( papszDST_MD );\n    CSLDestroy( papszDST_MD );\n\n    /* Depending on the PHOTOMETRIC tag, the TIFF file may not have */\n    /* the same band count as the source. Will fail later in GDALDatasetCopyWholeRaster anyway... */\n    for( int nBand = 1;\n         nBand <= MIN(poDS->GetRasterCount(), poSrcDS->GetRasterCount()) ;\n         nBand++ )\n    {\n        char **papszSRC_MD = poSrcDS->GetRasterBand(nBand)->GetMetadata();\n        char **papszDST_MD = CSLDuplicate(poDS->GetRasterBand(nBand)->GetMetadata());\n\n        papszDST_MD = CSLMerge( papszDST_MD, papszSRC_MD );\n\n        poDS->GetRasterBand(nBand)->SetMetadata( papszDST_MD );\n        CSLDestroy( papszDST_MD );\n    }\n\n    hTIFF = (TIFF*) poDS->GetInternalHandle(NULL);\n\n/* -------------------------------------------------------------------- */\n/*      Handle forcing xml:ESRI data to be written to PAM.              */\n/* -------------------------------------------------------------------- */\n    if( CSLTestBoolean(CPLGetConfigOption( \"ESRI_XML_PAM\", \"NO\" )) )\n    {\n        char **papszESRIMD = poSrcDS->GetMetadata(\"xml:ESRI\");\n        if( papszESRIMD )\n        {\n            poDS->SetMetadata( papszESRIMD, \"xml:ESRI\");\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Second chance : now that we have a PAM dataset, it is possible  */\n/*      to write metadata that we couldn't be writen as TIFF tag        */\n/* -------------------------------------------------------------------- */\n    if (!bHasWrittenMDInGeotiffTAG)\n        GTiffDataset::WriteMetadata( poDS, hTIFF, TRUE, pszProfile,\n                                     pszFilename, papszOptions, TRUE /* don't write RPC and IMD file again */);\n\n    /* To avoid unnecessary directory rewriting */\n    poDS->bMetadataChanged = FALSE;\n    poDS->bGeoTIFFInfoChanged = FALSE;\n\n    /* We must re-set the compression level at this point, since it has */\n    /* been lost a few lines above when closing the newly create TIFF file */\n    /* The TIFFTAG_ZIPQUALITY & TIFFTAG_JPEGQUALITY are not store in the TIFF file. */\n    /* They are just TIFF session parameters */\n\n    poDS->nZLevel = GTiffGetZLevel(papszOptions);\n    poDS->nLZMAPreset = GTiffGetLZMAPreset(papszOptions);\n    poDS->nJpegQuality = GTiffGetJpegQuality(papszOptions);\n\n    if (nCompression == COMPRESSION_ADOBE_DEFLATE)\n    {\n        if (poDS->nZLevel != -1)\n        {\n            TIFFSetField( hTIFF, TIFFTAG_ZIPQUALITY, poDS->nZLevel );\n        }\n    }\n    else if( nCompression == COMPRESSION_JPEG)\n    {\n        if (poDS->nJpegQuality != -1)\n        {\n            TIFFSetField( hTIFF, TIFFTAG_JPEGQUALITY, poDS->nJpegQuality );\n        }\n    }\n    else if( nCompression == COMPRESSION_LZMA)\n    {\n        if (poDS->nLZMAPreset != -1)\n        {\n            TIFFSetField( hTIFF, TIFFTAG_LZMAPRESET, poDS->nLZMAPreset );\n        }\n    }\n\n    /* Precreate (internal) mask, so that the IBuildOverviews() below */\n    /* has a chance to create also the overviews of the mask */\n    int nMaskFlags = poSrcDS->GetRasterBand(1)->GetMaskFlags();\n    if( eErr == CE_None\n        && !(nMaskFlags & (GMF_ALL_VALID|GMF_ALPHA|GMF_NODATA) )\n        && (nMaskFlags & GMF_PER_DATASET) )\n    {\n        eErr = poDS->CreateMaskBand( nMaskFlags );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Create and then copy existing overviews if requested            */\n/*  We do it such that all the IFDs are at the beginning of the file,   */\n/*  and that the imagery data for the smallest overview is written      */\n/*  first, that way the file is more usable when embedded in a          */\n/*  compressed stream.                                                  */\n/* -------------------------------------------------------------------- */\n\n    /* For scaled progress due to overview copying */\n    double dfTotalPixels = ((double)nXSize) * nYSize;\n    double dfCurPixels = 0;\n\n    if (eErr == CE_None &&\n        nSrcOverviews != 0 &&\n        CSLFetchBoolean(papszOptions, \"COPY_SRC_OVERVIEWS\", FALSE))\n    {\n        eErr = poDS->CreateOverviewsFromSrcOverviews(poSrcDS);\n\n        if (poDS->nOverviewCount != nSrcOverviews)\n        {\n            CPLError(CE_Failure, CPLE_AppDefined,\n                     \"Did only manage to instanciate %d overview levels, whereas source contains %d\",\n                     poDS->nOverviewCount, nSrcOverviews);\n            eErr = CE_Failure;\n        }\n\n        int i;\n        for(i=0;i<nSrcOverviews;i++)\n        {\n            GDALRasterBand* poOvrBand = poSrcDS->GetRasterBand(1)->GetOverview(i);\n            dfTotalPixels += ((double)poOvrBand->GetXSize()) *\n                                      poOvrBand->GetYSize();\n        }\n\n        char* papszCopyWholeRasterOptions[2] = { NULL, NULL };\n        if (nCompression != COMPRESSION_NONE)\n            papszCopyWholeRasterOptions[0] = (char*) \"COMPRESSED=YES\";\n        /* Now copy the imagery */\n        for(i=0;eErr == CE_None && i<nSrcOverviews;i++)\n        {\n            /* Begin with the smallest overview */\n            int iOvrLevel = nSrcOverviews-1-i;\n            \n            /* Create a fake dataset with the source overview level so that */\n            /* GDALDatasetCopyWholeRaster can cope with it */\n            GDALDataset* poSrcOvrDS = new GDALOverviewDS(poSrcDS, iOvrLevel);\n            \n            GDALRasterBand* poOvrBand =\n                    poSrcDS->GetRasterBand(1)->GetOverview(iOvrLevel);\n            double dfNextCurPixels = dfCurPixels +\n                    ((double)poOvrBand->GetXSize()) * poOvrBand->GetYSize();\n\n            void* pScaledData = GDALCreateScaledProgress( dfCurPixels / dfTotalPixels,\n                                      dfNextCurPixels / dfTotalPixels,\n                                      pfnProgress, pProgressData);\n                                \n            eErr = GDALDatasetCopyWholeRaster( (GDALDatasetH) poSrcOvrDS,\n                                                (GDALDatasetH) poDS->papoOverviewDS[iOvrLevel],\n                                                papszCopyWholeRasterOptions,\n                                                GDALScaledProgress, pScaledData );\n                                                \n            dfCurPixels = dfNextCurPixels;\n            GDALDestroyScaledProgress(pScaledData);\n\n            delete poSrcOvrDS;\n            poDS->papoOverviewDS[iOvrLevel]->FlushCache();\n\n            /* Copy mask of the overview */\n            if (eErr == CE_None && poDS->poMaskDS != NULL)\n            {\n                eErr = GDALRasterBandCopyWholeRaster( poOvrBand->GetMaskBand(),\n                                                    poDS->papoOverviewDS[iOvrLevel]->poMaskDS->GetRasterBand(1),\n                                                    papszCopyWholeRasterOptions,\n                                                    GDALDummyProgress, NULL);\n                poDS->papoOverviewDS[iOvrLevel]->poMaskDS->FlushCache();\n            }\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Copy actual imagery.                                            */\n/* -------------------------------------------------------------------- */\n    void* pScaledData = GDALCreateScaledProgress( dfCurPixels / dfTotalPixels,\n                                                  1.0,\n                                                  pfnProgress, pProgressData);\n\n    if (poDS->bTreatAsSplit || poDS->bTreatAsSplitBitmap)\n    {\n        /* For split bands, we use TIFFWriteScanline() interface */\n        CPLAssert(poDS->nBitsPerSample == 8 || poDS->nBitsPerSample == 1);\n        \n        if (poDS->nPlanarConfig == PLANARCONFIG_CONTIG && poDS->nBands > 1)\n        {\n            int j;\n            GByte* pabyScanline = (GByte *) CPLMalloc(TIFFScanlineSize(hTIFF));\n            for(j=0;j<nYSize && eErr == CE_None;j++)\n            {\n                eErr = poSrcDS->RasterIO(GF_Read, 0, j, nXSize, 1,\n                                         pabyScanline, nXSize, 1,\n                                         GDT_Byte, nBands, NULL, poDS->nBands, 0, 1);\n                if (eErr == CE_None &&\n                    TIFFWriteScanline( hTIFF, pabyScanline, j, 0) == -1)\n                {\n                    CPLError( CE_Failure, CPLE_AppDefined,\n                              \"TIFFWriteScanline() failed.\" );\n                    eErr = CE_Failure;\n                }\n                if( !GDALScaledProgress( (j+1) * 1.0 / nYSize, NULL, pScaledData ) )\n                    eErr = CE_Failure;\n            }\n            CPLFree(pabyScanline);\n        }\n        else\n        {\n            int iBand, j;\n            GByte* pabyScanline = (GByte *) CPLMalloc(TIFFScanlineSize(hTIFF));\n            eErr = CE_None;\n            for(iBand=1;iBand<=nBands && eErr == CE_None;iBand++)\n            {\n                for(j=0;j<nYSize && eErr == CE_None;j++)\n                {\n                    eErr = poSrcDS->GetRasterBand(iBand)->RasterIO(\n                                                    GF_Read, 0, j, nXSize, 1,\n                                                    pabyScanline, nXSize, 1,\n                                                    GDT_Byte, 0, 0);\n                    if (poDS->bTreatAsSplitBitmap)\n                    {\n                        for(int i=0;i<nXSize;i++)\n                        {\n                            GByte byVal = pabyScanline[i];\n                            if ((i & 0x7) == 0)\n                                pabyScanline[i >> 3] = 0;\n                            if (byVal)\n                                pabyScanline[i >> 3] |= (0x80 >> (i & 0x7));\n                        }\n                    }\n                    if (eErr == CE_None &&\n                        TIFFWriteScanline( hTIFF, pabyScanline, j, (uint16) (iBand-1)) == -1)\n                    {\n                        CPLError( CE_Failure, CPLE_AppDefined,\n                                  \"TIFFWriteScanline() failed.\" );\n                        eErr = CE_Failure;\n                    }\n                    if( !GDALScaledProgress( (j+1 + (iBand - 1) * nYSize) * 1.0 /\n                                      (nBands * nYSize), NULL, pScaledData ) )\n                        eErr = CE_Failure;\n                }\n            }\n            CPLFree(pabyScanline);\n        }\n        \n        /* Necessary to be able to read the file without re-opening */\n#if defined(HAVE_TIFFGETSIZEPROC)\n        TIFFSizeProc pfnSizeProc = TIFFGetSizeProc( hTIFF );\n\n        TIFFFlushData( hTIFF );\n\n        toff_t nNewDirOffset = pfnSizeProc( TIFFClientdata( hTIFF ) );\n        if( (nNewDirOffset % 2) == 1 )\n            nNewDirOffset++;\n#endif\n\n        TIFFFlush( hTIFF );\n\n#if defined(HAVE_TIFFGETSIZEPROC)\n        if( poDS->nDirOffset != TIFFCurrentDirOffset( hTIFF ) )\n        {\n            poDS->nDirOffset = nNewDirOffset;\n            CPLDebug( \"GTiff\", \"directory moved during flush.\" );\n        }\n#endif\n    }\n    else if (eErr == CE_None)\n    {\n        char* papszCopyWholeRasterOptions[2] = { NULL, NULL };\n        if (nCompression != COMPRESSION_NONE)\n            papszCopyWholeRasterOptions[0] = (char*) \"COMPRESSED=YES\";\n        eErr = GDALDatasetCopyWholeRaster( (GDALDatasetH) poSrcDS, \n                                            (GDALDatasetH) poDS,\n                                            papszCopyWholeRasterOptions,\n                                            GDALScaledProgress, pScaledData );\n    }\n    \n    GDALDestroyScaledProgress(pScaledData);\n\n    if (eErr == CE_None)\n    {\n        if (poDS->poMaskDS)\n        {\n            const char* papszOptions[2] = { \"COMPRESSED=YES\", NULL };\n            eErr = GDALRasterBandCopyWholeRaster(\n                                    poSrcDS->GetRasterBand(1)->GetMaskBand(),\n                                    poDS->GetRasterBand(1)->GetMaskBand(),\n                                    (char**)papszOptions,\n                                    GDALDummyProgress, NULL);\n        }\n        else\n            eErr = GDALDriver::DefaultCopyMasks( poSrcDS, poDS, bStrict );\n    }\n\n    if( eErr == CE_Failure )\n    {\n        delete poDS;\n        poDS = NULL;\n\n        if (CSLTestBoolean(CPLGetConfigOption(\"GTIFF_DELETE_ON_ERROR\", \"YES\")))\n            VSIUnlink( pszFilename ); // should really delete more carefully.\n    }\n\n    return poDS;\n}",
    "bool QTiffHandler::write(const QImage &image)\n{\n    if (!device()->isWritable())\n        return false;\n\n    TIFF *const tiff = TIFFClientOpen(\"foo\",\n                                      \"wB\",\n                                      this,\n                                      qtiffReadProc,\n                                      qtiffWriteProc,\n                                      qtiffSeekProc,\n                                      qtiffCloseProc,\n                                      qtiffSizeProc,\n                                      qtiffMapProc,\n                                      qtiffUnmapProc);\n    if (!tiff)\n        return false;\n\n    const int width = image.width();\n    const int height = image.height();\n\n    if (!TIFFSetField(tiff, TIFFTAG_IMAGEWIDTH, width)\n        || !TIFFSetField(tiff, TIFFTAG_IMAGELENGTH, height)\n        || !TIFFSetField(tiff, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG)) {\n        TIFFClose(tiff);\n        return false;\n    }\n\n    // set the resolution\n    bool  resolutionSet = false;\n    const int dotPerMeterX = image.dotsPerMeterX();\n    const int dotPerMeterY = image.dotsPerMeterY();\n    if ((dotPerMeterX % 100) == 0\n        && (dotPerMeterY % 100) == 0) {\n        resolutionSet = TIFFSetField(tiff, TIFFTAG_RESOLUTIONUNIT, RESUNIT_CENTIMETER)\n                        && TIFFSetField(tiff, TIFFTAG_XRESOLUTION, dotPerMeterX/100.0)\n                        && TIFFSetField(tiff, TIFFTAG_YRESOLUTION, dotPerMeterY/100.0);\n    } else {\n        resolutionSet = TIFFSetField(tiff, TIFFTAG_RESOLUTIONUNIT, RESUNIT_INCH)\n                        && TIFFSetField(tiff, TIFFTAG_XRESOLUTION, static_cast<float>(image.logicalDpiX()))\n                        && TIFFSetField(tiff, TIFFTAG_YRESOLUTION, static_cast<float>(image.logicalDpiY()));\n    }\n    if (!resolutionSet) {\n        TIFFClose(tiff);\n        return false;\n    }\n\n    // configure image depth\n    const QImage::Format format = image.format();\n    if (format == QImage::Format_Mono || format == QImage::Format_MonoLSB) {\n        uint16 photometric = PHOTOMETRIC_MINISBLACK;\n        if (image.colorTable().at(0) == 0xffffffff)\n            photometric = PHOTOMETRIC_MINISWHITE;\n        if (!TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, photometric)\n            || !TIFFSetField(tiff, TIFFTAG_COMPRESSION, compression == NoCompression ? COMPRESSION_NONE : COMPRESSION_CCITTRLE)\n            || !TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 1)) {\n            TIFFClose(tiff);\n            return false;\n        }\n\n        // try to do the conversion in chunks no greater than 16 MB\n        int chunks = (width * height / (1024 * 1024 * 16)) + 1;\n        int chunkHeight = qMax(height / chunks, 1);\n\n        int y = 0;\n        while (y < height) {\n            QImage chunk = image.copy(0, y, width, qMin(chunkHeight, height - y)).convertToFormat(QImage::Format_Mono);\n\n            int chunkStart = y;\n            int chunkEnd = y + chunk.height();\n            while (y < chunkEnd) {\n                if (TIFFWriteScanline(tiff, reinterpret_cast<uint32 *>(chunk.scanLine(y - chunkStart)), y) != 1) {\n                    TIFFClose(tiff);\n                    return false;\n                }\n                ++y;\n            }\n        }\n        TIFFClose(tiff);\n    } else if (format == QImage::Format_Indexed8) {\n        const QVector<QRgb> colorTable = image.colorTable();\n        bool isGrayscale = checkGrayscale(colorTable);\n        if (isGrayscale) {\n            uint16 photometric = PHOTOMETRIC_MINISBLACK;\n            if (image.colorTable().at(0) == 0xffffffff)\n                photometric = PHOTOMETRIC_MINISWHITE;\n            if (!TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, photometric)\n                    || !TIFFSetField(tiff, TIFFTAG_COMPRESSION, compression == NoCompression ? COMPRESSION_NONE : COMPRESSION_PACKBITS)\n                    || !TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 8)) {\n                TIFFClose(tiff);\n                return false;\n            }\n        } else {\n            if (!TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_PALETTE)\n                    || !TIFFSetField(tiff, TIFFTAG_COMPRESSION, compression == NoCompression ? COMPRESSION_NONE : COMPRESSION_PACKBITS)\n                    || !TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 8)) {\n                TIFFClose(tiff);\n                return false;\n            }\n            //// write the color table\n            // allocate the color tables\n            const int tableSize = colorTable.size();\n            Q_ASSERT(tableSize <= 256);\n            QVarLengthArray<uint16> redTable(tableSize);\n            QVarLengthArray<uint16> greenTable(tableSize);\n            QVarLengthArray<uint16> blueTable(tableSize);\n\n            // set the color table\n            for (int i = 0; i<tableSize; ++i) {\n                const QRgb color = colorTable.at(i);\n                redTable[i] = qRed(color) * 257;\n                greenTable[i] = qGreen(color) * 257;\n                blueTable[i] = qBlue(color) * 257;\n            }\n\n            const bool setColorTableSuccess = TIFFSetField(tiff, TIFFTAG_COLORMAP, redTable.data(), greenTable.data(), blueTable.data());\n\n            if (!setColorTableSuccess) {\n                TIFFClose(tiff);\n                return false;\n            }\n        }\n\n        //// write the data\n        // try to do the conversion in chunks no greater than 16 MB\n        int chunks = (width * height/ (1024 * 1024 * 16)) + 1;\n        int chunkHeight = qMax(height / chunks, 1);\n\n        int y = 0;\n        while (y < height) {\n            QImage chunk = image.copy(0, y, width, qMin(chunkHeight, height - y));\n\n            int chunkStart = y;\n            int chunkEnd = y + chunk.height();\n            while (y < chunkEnd) {\n                if (TIFFWriteScanline(tiff, reinterpret_cast<uint32 *>(chunk.scanLine(y - chunkStart)), y) != 1) {\n                    TIFFClose(tiff);\n                    return false;\n                }\n                ++y;\n            }\n        }\n        TIFFClose(tiff);\n\n    } else if (!image.hasAlphaChannel()) {\n        if (!TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB)\n            || !TIFFSetField(tiff, TIFFTAG_COMPRESSION, compression == NoCompression ? COMPRESSION_NONE : COMPRESSION_LZW)\n            || !TIFFSetField(tiff, TIFFTAG_SAMPLESPERPIXEL, 3)\n            || !TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 8)) {\n            TIFFClose(tiff);\n            return false;\n        }\n        // try to do the RGB888 conversion in chunks no greater than 16 MB\n        const int chunks = (width * height * 3 / (1024 * 1024 * 16)) + 1;\n        const int chunkHeight = qMax(height / chunks, 1);\n\n        int y = 0;\n        while (y < height) {\n            const QImage chunk = image.copy(0, y, width, qMin(chunkHeight, height - y)).convertToFormat(QImage::Format_RGB888);\n\n            int chunkStart = y;\n            int chunkEnd = y + chunk.height();\n            while (y < chunkEnd) {\n                if (TIFFWriteScanline(tiff, (void*)chunk.scanLine(y - chunkStart), y) != 1) {\n                    TIFFClose(tiff);\n                    return false;\n                }\n                ++y;\n            }\n        }\n        TIFFClose(tiff);\n    } else {\n        if (!TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB)\n            || !TIFFSetField(tiff, TIFFTAG_COMPRESSION, compression == NoCompression ? COMPRESSION_NONE : COMPRESSION_LZW)\n            || !TIFFSetField(tiff, TIFFTAG_SAMPLESPERPIXEL, 4)\n            || !TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 8)) {\n            TIFFClose(tiff);\n            return false;\n        }\n#if (QT_VERSION >= QT_VERSION_CHECK(5, 2, 0))\n        // try to do the RGBA8888 conversion in chunks no greater than 16 MB\n#else\n        // try to do the ARGB32 conversion in chunks no greater than 16 MB\n#endif\n        const int chunks = (width * height * 4 / (1024 * 1024 * 16)) + 1;\n        const int chunkHeight = qMax(height / chunks, 1);\n\n        int y = 0;\n        while (y < height) {\n#if (QT_VERSION >= QT_VERSION_CHECK(5, 2, 0))\n            const QImage chunk = image.copy(0, y, width, qMin(chunkHeight, height - y)).convertToFormat(QImage::Format_RGBA8888);\n#else\n            QImage chunk = image.copy(0, y, width, qMin(chunkHeight, height - y)).convertToFormat(QImage::Format_ARGB32);\n#endif\n\n            int chunkStart = y;\n            int chunkEnd = y + chunk.height();\n            while (y < chunkEnd) {\n#if (QT_VERSION < QT_VERSION_CHECK(5, 2, 0))\n                if (QSysInfo::ByteOrder == QSysInfo::LittleEndian)\n                    convert32BitOrder(chunk.scanLine(y - chunkStart), width);\n                else\n                    convert32BitOrderBigEndian(chunk.scanLine(y - chunkStart), width);\n#endif\n                if (TIFFWriteScanline(tiff, (void*)chunk.scanLine(y - chunkStart), y) != 1) {\n                    TIFFClose(tiff);\n                    return false;\n                }\n                ++y;\n            }\n        }\n        TIFFClose(tiff);\n    }\n\n    return true;\n}",
    "bool QTiffHandler::write(const QImage &image)\n{\n    if (!device()->isWritable())\n        return false;\n\n    TIFF *const tiff = TIFFClientOpen(\"foo\",\n                                      \"wB\",\n                                      device(),\n                                      qtiffReadProc,\n                                      qtiffWriteProc,\n                                      qtiffSeekProc,\n                                      qtiffCloseProc,\n                                      qtiffSizeProc,\n                                      qtiffMapProc,\n                                      qtiffUnmapProc);\n    if (!tiff)\n        return false;\n\n    const int width = image.width();\n    const int height = image.height();\n    const int compression = d->compression;\n\n    if (!TIFFSetField(tiff, TIFFTAG_IMAGEWIDTH, width)\n        || !TIFFSetField(tiff, TIFFTAG_IMAGELENGTH, height)\n        || !TIFFSetField(tiff, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG)) {\n        TIFFClose(tiff);\n        return false;\n    }\n\n    // set the resolution\n    bool  resolutionSet = false;\n    const int dotPerMeterX = image.dotsPerMeterX();\n    const int dotPerMeterY = image.dotsPerMeterY();\n    if ((dotPerMeterX % 100) == 0\n        && (dotPerMeterY % 100) == 0) {\n        resolutionSet = TIFFSetField(tiff, TIFFTAG_RESOLUTIONUNIT, RESUNIT_CENTIMETER)\n                        && TIFFSetField(tiff, TIFFTAG_XRESOLUTION, dotPerMeterX/100.0)\n                        && TIFFSetField(tiff, TIFFTAG_YRESOLUTION, dotPerMeterY/100.0);\n    } else {\n        resolutionSet = TIFFSetField(tiff, TIFFTAG_RESOLUTIONUNIT, RESUNIT_INCH)\n                        && TIFFSetField(tiff, TIFFTAG_XRESOLUTION, static_cast<float>(image.logicalDpiX()))\n                        && TIFFSetField(tiff, TIFFTAG_YRESOLUTION, static_cast<float>(image.logicalDpiY()));\n    }\n    if (!resolutionSet) {\n        TIFFClose(tiff);\n        return false;\n    }\n    // set the orienataion\n    bool orientationSet = false;\n    orientationSet = TIFFSetField(tiff, TIFFTAG_ORIENTATION, qt2Exif(d->transformation));\n    if (!orientationSet) {\n        TIFFClose(tiff);\n        return false;\n    }\n\n    // configure image depth\n    const QImage::Format format = image.format();\n    if (format == QImage::Format_Mono || format == QImage::Format_MonoLSB) {\n        uint16 photometric = PHOTOMETRIC_MINISBLACK;\n        if (image.colorTable().at(0) == 0xffffffff)\n            photometric = PHOTOMETRIC_MINISWHITE;\n        if (!TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, photometric)\n            || !TIFFSetField(tiff, TIFFTAG_COMPRESSION, compression == NoCompression ? COMPRESSION_NONE : COMPRESSION_CCITTRLE)\n            || !TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 1)) {\n            TIFFClose(tiff);\n            return false;\n        }\n\n        // try to do the conversion in chunks no greater than 16 MB\n        int chunks = (width * height / (1024 * 1024 * 16)) + 1;\n        int chunkHeight = qMax(height / chunks, 1);\n\n        int y = 0;\n        while (y < height) {\n            QImage chunk = image.copy(0, y, width, qMin(chunkHeight, height - y)).convertToFormat(QImage::Format_Mono);\n\n            int chunkStart = y;\n            int chunkEnd = y + chunk.height();\n            while (y < chunkEnd) {\n                if (TIFFWriteScanline(tiff, reinterpret_cast<uint32 *>(chunk.scanLine(y - chunkStart)), y) != 1) {\n                    TIFFClose(tiff);\n                    return false;\n                }\n                ++y;\n            }\n        }\n        TIFFClose(tiff);\n    } else if (format == QImage::Format_Indexed8\n               || format == QImage::Format_Grayscale8\n               || format == QImage::Format_Alpha8) {\n        QVector<QRgb> colorTable = effectiveColorTable(image);\n        bool isGrayscale = checkGrayscale(colorTable);\n        if (isGrayscale) {\n            uint16 photometric = PHOTOMETRIC_MINISBLACK;\n            if (colorTable.at(0) == 0xffffffff)\n                photometric = PHOTOMETRIC_MINISWHITE;\n            if (!TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, photometric)\n                    || !TIFFSetField(tiff, TIFFTAG_COMPRESSION, compression == NoCompression ? COMPRESSION_NONE : COMPRESSION_PACKBITS)\n                    || !TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 8)) {\n                TIFFClose(tiff);\n                return false;\n            }\n        } else {\n            if (!TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_PALETTE)\n                    || !TIFFSetField(tiff, TIFFTAG_COMPRESSION, compression == NoCompression ? COMPRESSION_NONE : COMPRESSION_PACKBITS)\n                    || !TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 8)) {\n                TIFFClose(tiff);\n                return false;\n            }\n            //// write the color table\n            // allocate the color tables\n            const int tableSize = colorTable.size();\n            Q_ASSERT(tableSize <= 256);\n            QVarLengthArray<uint16> redTable(tableSize);\n            QVarLengthArray<uint16> greenTable(tableSize);\n            QVarLengthArray<uint16> blueTable(tableSize);\n\n            // set the color table\n            for (int i = 0; i<tableSize; ++i) {\n                const QRgb color = colorTable.at(i);\n                redTable[i] = qRed(color) * 257;\n                greenTable[i] = qGreen(color) * 257;\n                blueTable[i] = qBlue(color) * 257;\n            }\n\n            const bool setColorTableSuccess = TIFFSetField(tiff, TIFFTAG_COLORMAP, redTable.data(), greenTable.data(), blueTable.data());\n\n            if (!setColorTableSuccess) {\n                TIFFClose(tiff);\n                return false;\n            }\n        }\n\n        //// write the data\n        // try to do the conversion in chunks no greater than 16 MB\n        int chunks = (width * height/ (1024 * 1024 * 16)) + 1;\n        int chunkHeight = qMax(height / chunks, 1);\n\n        int y = 0;\n        while (y < height) {\n            QImage chunk = image.copy(0, y, width, qMin(chunkHeight, height - y));\n\n            int chunkStart = y;\n            int chunkEnd = y + chunk.height();\n            while (y < chunkEnd) {\n                if (TIFFWriteScanline(tiff, reinterpret_cast<uint32 *>(chunk.scanLine(y - chunkStart)), y) != 1) {\n                    TIFFClose(tiff);\n                    return false;\n                }\n                ++y;\n            }\n        }\n        TIFFClose(tiff);\n    } else if (!image.hasAlphaChannel()) {\n        if (!TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB)\n            || !TIFFSetField(tiff, TIFFTAG_COMPRESSION, compression == NoCompression ? COMPRESSION_NONE : COMPRESSION_LZW)\n            || !TIFFSetField(tiff, TIFFTAG_SAMPLESPERPIXEL, 3)\n            || !TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 8)) {\n            TIFFClose(tiff);\n            return false;\n        }\n        // try to do the RGB888 conversion in chunks no greater than 16 MB\n        const int chunks = (width * height * 3 / (1024 * 1024 * 16)) + 1;\n        const int chunkHeight = qMax(height / chunks, 1);\n\n        int y = 0;\n        while (y < height) {\n            const QImage chunk = image.copy(0, y, width, qMin(chunkHeight, height - y)).convertToFormat(QImage::Format_RGB888);\n\n            int chunkStart = y;\n            int chunkEnd = y + chunk.height();\n            while (y < chunkEnd) {\n                if (TIFFWriteScanline(tiff, (void*)chunk.scanLine(y - chunkStart), y) != 1) {\n                    TIFFClose(tiff);\n                    return false;\n                }\n                ++y;\n            }\n        }\n        TIFFClose(tiff);\n    } else {\n        const bool premultiplied = image.format() != QImage::Format_ARGB32\n                                && image.format() != QImage::Format_RGBA8888;\n        const uint16 extrasamples = premultiplied ? EXTRASAMPLE_ASSOCALPHA : EXTRASAMPLE_UNASSALPHA;\n        if (!TIFFSetField(tiff, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB)\n            || !TIFFSetField(tiff, TIFFTAG_COMPRESSION, compression == NoCompression ? COMPRESSION_NONE : COMPRESSION_LZW)\n            || !TIFFSetField(tiff, TIFFTAG_SAMPLESPERPIXEL, 4)\n            || !TIFFSetField(tiff, TIFFTAG_BITSPERSAMPLE, 8)\n            || !TIFFSetField(tiff, TIFFTAG_EXTRASAMPLES, 1, &extrasamples)) {\n            TIFFClose(tiff);\n            return false;\n        }\n        // try to do the RGBA8888 conversion in chunks no greater than 16 MB\n        const int chunks = (width * height * 4 / (1024 * 1024 * 16)) + 1;\n        const int chunkHeight = qMax(height / chunks, 1);\n\n        const QImage::Format format = premultiplied ? QImage::Format_RGBA8888_Premultiplied\n                                                    : QImage::Format_RGBA8888;\n        int y = 0;\n        while (y < height) {\n            const QImage chunk = image.copy(0, y, width, qMin(chunkHeight, height - y)).convertToFormat(format);\n\n            int chunkStart = y;\n            int chunkEnd = y + chunk.height();\n            while (y < chunkEnd) {\n                if (TIFFWriteScanline(tiff, (void*)chunk.scanLine(y - chunkStart), y) != 1) {\n                    TIFFClose(tiff);\n                    return false;\n                }\n                ++y;\n            }\n        }\n        TIFFClose(tiff);\n    }\n\n    return true;\n}",
    "bool CxImageTIF::Encode(FILE * infile)\n{\n\tTIFF *m_tif=NULL; // = (TIFF *)new(byte[512]);\n\tm_tif=TIFFOpenEx(infile, \"wb\");\n\t//\tm_tif=TIFFOpen(imageFileName,\"wb\");\n\tif (m_tif==NULL) return false;\n\n\tuint32 height=head.biHeight;\n\tuint32 width=head.biWidth;\n\tuint16 bitspersample=head.biBitCount;\n\tuint16 samplesperpixel;\n\tuint16 photometric;\n\tuint16 compression;\n\tuint16 pitch;\n\tint line;\n\tuint32 x, y;\n\n\tsamplesperpixel = ((bitspersample == 24) || (bitspersample == 32)) ? 3 : 1;\n\n\t//set the PHOTOMETRIC tag\n\tRGBQUAD *rgb = GetPalette();\n\tswitch (bitspersample) {\n\t\tcase 1:\n\t\t\tif (RGB2GRAY(rgb[0].rgbRed,rgb[0].rgbGreen,rgb[0].rgbBlue)<\n\t\t\t\tRGB2GRAY(rgb[1].rgbRed,rgb[1].rgbGreen,rgb[1].rgbBlue))\n\t\t\t\tphotometric = PHOTOMETRIC_MINISBLACK;\n\t\t\telse\n\t\t\t\tphotometric = PHOTOMETRIC_MINISWHITE;\n\t\t\tbreak;\n\t\tcase 4:\t// Check if the DIB has a color or a greyscale palette\n\t\tcase 8:\n\t\t\tphotometric = PHOTOMETRIC_MINISBLACK; //default to gray scale\n\t\t\tfor (x = 0; x < head.biClrUsed; x++) {\n\t\t\t\tif ((rgb->rgbRed != x)||(rgb->rgbRed != rgb->rgbGreen)||(rgb->rgbRed != rgb->rgbBlue)){\n\t\t\t\t\tphotometric = PHOTOMETRIC_PALETTE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\trgb++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 24:\n\t\t\tphotometric = PHOTOMETRIC_RGB;\t\t\t\n\t\t\tbreak;\n\t}\n\n\tline = CalculateLine(width, bitspersample * samplesperpixel);\n\tpitch = CalculatePitch(line);\n\n\t//prepare the palette struct\n\tRGBQUAD pal[256];\n\tif (GetPalette()){\n\t\tBYTE b;\n\t\tmemcpy(pal,GetPalette(),GetPaletteSize());\n\t\tfor(WORD a=0;a<head.biClrUsed;a++){\t//swap blue and red components\n\t\t\tb=pal[a].rgbBlue; pal[a].rgbBlue=pal[a].rgbRed; pal[a].rgbRed=b;\n\t\t}\n\t}\n\n\t// handle standard width/height/bpp stuff\n\tTIFFSetField(m_tif, TIFFTAG_IMAGEWIDTH, width);\n\tTIFFSetField(m_tif, TIFFTAG_IMAGELENGTH, height);\n\tTIFFSetField(m_tif, TIFFTAG_SAMPLESPERPIXEL, samplesperpixel);\n\tTIFFSetField(m_tif, TIFFTAG_BITSPERSAMPLE, ((bitspersample == 32) ? 24 : bitspersample) / samplesperpixel);\n\tTIFFSetField(m_tif, TIFFTAG_PHOTOMETRIC, photometric);\n\tTIFFSetField(m_tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\t// single image plane \n\tTIFFSetField(m_tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n\tTIFFSetField(m_tif, TIFFTAG_ROWSPERSTRIP, 1);\n//\tTIFFSetField(m_tif, TIFFTAG_ROWSPERSTRIP, TIFFDefaultStripSize(m_tif, rowsperstrip));\n\n\t// handle metrics\n\tTIFFSetField(m_tif, TIFFTAG_RESOLUTIONUNIT, RESUNIT_INCH);\n\tTIFFSetField(m_tif, TIFFTAG_XRESOLUTION, 72.0);\n\tTIFFSetField(m_tif, TIFFTAG_YRESOLUTION, 72.0);\n\n\t// multi-paging\n//\tif (page >= 0) {\n//\t\tchar page_number[20];\n//\t\tsprintf(page_number, \"Page %d\", page);\n//\n//\t\tTIFFSetField(m_tif, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE);\n//\t\tTIFFSetField(m_tif, TIFFTAG_PAGENUMBER, page);\n//\t\tTIFFSetField(m_tif, TIFFTAG_PAGENAME, page_number);\n//\t} else {\n\t\tTIFFSetField(m_tif, TIFFTAG_SUBFILETYPE, 0);\n//\t}\n\n\t// palettes (image colormaps are automatically scaled to 16-bits)\n\tif (photometric == PHOTOMETRIC_PALETTE) {\n\t\tuint16 *r, *g, *b;\n\t\tr = (uint16 *) _TIFFmalloc(sizeof(uint16) * 3 * 256);\n\t\tg = r + 256;\n\t\tb = g + 256;\n\n\t\tfor (int i = 255; i >= 0; i--) {\n\t\t\tb[i] = SCALE((uint16)pal[i].rgbRed);\n\t\t\tg[i] = SCALE((uint16)pal[i].rgbGreen);\n\t\t\tr[i] = SCALE((uint16)pal[i].rgbBlue);\n\t\t}\n\n\t\tTIFFSetField(m_tif, TIFFTAG_COLORMAP, r, g, b);\n\t\t_TIFFfree(r);\n\t}\n\n\t// compression\n\tswitch(bitspersample) {\n\t\tcase 1 :\n\t\t\tcompression = COMPRESSION_CCITTFAX3; //COMPRESSION_CCITTFAX4;\n\t\t\tbreak;\n\t\tcase 8 :\n\t\tcase 24 :\n\t\tcase 32 :\n\t\t\tcompression = COMPRESSION_PACKBITS;\n\t\t\tbreak;\n\t\tdefault :\n\t\t\tcompression = COMPRESSION_NONE;\n\t\t\tbreak;\n\t}\n\tTIFFSetField(m_tif, TIFFTAG_COMPRESSION, compression);\n\n\t// read the DIB lines from bottom to top\n\t// and save them in the TIF\n\t// -------------------------------------\t\n\tBYTE *bits;\n\tswitch(bitspersample) {\t\t\t\t\n\t\tcase 1 :\n\t\tcase 4 :\n\t\tcase 8 :\n\t\t{\n\t\t\tfor (y = 0; y < height; y++) {\n\t\t\t\tbits= info.pImage + (height - y - 1)*info.dwEffWidth;\n\t\t\t\tTIFFWriteScanline(m_tif,bits, y, 0);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\t\t\t\t\n\t\tcase 24:\n\t\tcase 32 :\n\t\t{\n\t\t\tBYTE *buffer = (BYTE *)malloc(info.dwEffWidth);\n\t\t\tfor (y = 0; y < height; y++) {\n\t\t\t\t// get a pointer to the scanline\n\t\t\t\tmemcpy(buffer, info.pImage + (height - y - 1)*info.dwEffWidth, info.dwEffWidth);\n\t\t\t\t// TIFFs store color data RGB instead of BGR\n\t\t\t\tBYTE *pBuf = buffer;\n\t\t\t\tfor (x = 0; x < width; x++) {\n\t\t\t\t\tBYTE tmp = pBuf[0];\n\t\t\t\t\tpBuf[0] = pBuf[2];\n\t\t\t\t\tpBuf[2] = tmp;\n\t\t\t\t\tpBuf += 3;\n\t\t\t\t}\n\t\t\t\t// write the scanline to disc\n\t\t\t\tTIFFWriteScanline(m_tif, buffer, y, 0);\n\t\t\t}\n\t\t\tfree(buffer);\n\t\t\tbreak;\n\t\t}\t\t\t\t\n\t}\n\tTIFFClose(m_tif);\n\treturn true;\n}"
]